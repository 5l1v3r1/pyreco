__FILENAME__ = abstract_colormap
""" Defines the base class for color maps
"""
from traits.api import Enum, HasTraits, Instance

from data_range_1d import DataRange1D

class AbstractColormap(HasTraits):
    """
    Abstract class for color maps, which map from scalar values to color values.
    """

    # The data-space bounds of the mapper.
    range = Instance(DataRange1D)

    # The color depth of the colors to use.
    color_depth = Enum('rgba', 'rgb')


    def map_screen(self, val):
        """
        map_screen(val) -> color

        Maps an array of values to an array of colors.  If the input array is
        NxM, the returned array is NxMx3 or NxMx4, depending on the
        **color_depth** setting.
        """
        raise NotImplementedError()

    def map_data(self, ary):
        """
        map_data(ary) -> color_array

        Returns an array of values containing the colors mapping to the values
        in *ary*. If the input array is NxM, the returned array is NxMx3 or
        NxMx4, depending on the **color_depth** setting.
        """
        # XXX this seems bogus: by analogy with AbstractMapper, this should map
        # colors to data values, and that will be generally hard to do well.
        # no subclass implements this - CJW
        raise NotImplementedError()

    def map_index(self, ary):
        """
        map_index(ary) -> index into color_bands

        This method is like map_screen(), but it returns an array of indices
        into the color map's color bands instead of an array of colors.  If the
        input array is NxM, then the output is NxM integer indices.

        This method might not apply to all color maps.  Ones that cannot
        define a static set of color bands (e.g., function-defined color maps)
        are not able to implement this function.
        """
        raise NotImplementedError()

    def map_uint8(self, val):
        """
        map_uint8(val) -> rgb24 or rgba32 color

        Maps a single value to a single color.  Color is represented as either
        length-3 or length-4 array of rgb(a) uint8 values, depending on the
        **color_depth** setting.
        """
        # default implementation (not efficient)
        return (self.map_screen(val)*255.0).astype('uint8')



# EOF

########NEW FILE########
__FILENAME__ = abstract_controller
""" Defines the base class for controllers.
"""
# Enthought library imports
from enable.api import Component, Interactor
from traits.api import Instance


class AbstractController(Interactor):
    """
    Abstract class for tools that manipulate PlotComponents. By default, a
    controller attaches to a single PlotComponent.
    """

    component = Instance(Component)

    def __init__(self, component, *args, **kw):
        self.component = component
        super(AbstractController, self).__init__(*args, **kw)
        return

    def deactivate(self, component):
        """ This method is called by the component when this controller is no
        longer the active tool.
        """
        pass


# EOF

########NEW FILE########
__FILENAME__ = abstract_data_range
"""
Defines the base class for data ranges.
"""

# Enthought library imports
from traits.api import Event, Float, HasTraits, Instance, List, Trait

# Local relative imports
from abstract_data_source import AbstractDataSource


class AbstractDataRange(HasTraits):
    """ Abstract class for ranges that represent sub-regions of data space.

    They support "autoscaling" by querying their associated data sources.
    """

    # The list of data sources to which this range responds.
    sources = List(Instance(AbstractDataSource))

    # The actual value of the lower bound of this range. To set it, use
    # low_setting. (Setting this attribute directly just calls the setter for
    # low_setting.) Although the default value is specified as 0.0, subclasses
    # can redefine the default. Also, subclasses can redefined the type to
    # correspond to their dimensionality.
    low = Float(0.0)

    # The actual value of the upper bound of this range. To set it, use
    # high_setting. (Setting this attribute directly just calls the setter for
    # high_setting.) Although the default value is specified as 1.0, subclasses
    # can redefine the default. Also, subclasses can redefined the type to
    # correspond to their dimensionality.
    high = Float(1.0)

    # Setting for the lower bound of this range.
    low_setting = Trait('auto', 'auto', Float)
    # Setting for the upper bound of this range.
    high_setting = Trait('auto', 'auto', Float)

    # Event that is fired when the actual bounds values change; the value
    # of the event is a tuple (low_bound, high_bound)
    updated = Event

    #------------------------------------------------------------------------
    # Concrete methods
    #------------------------------------------------------------------------

    def __init__(self, *sources, **kwargs):
        if len(sources) > 0:
            if 'sources' in kwargs:
                raise RuntimeError("Datasources for data range provided as "
                                   "both positional and keyword arguments.")
            else:
                kwargs['sources'] = list(sources)
        super(AbstractDataRange, self).__init__(**kwargs)


    #------------------------------------------------------------------------
    # Abstract methods that subclasses must implement
    #------------------------------------------------------------------------

    def clip_data(self, data):
        """ Returns a list of data values that are within the range.

        Given an array of data values of the same dimensionality as the range,
        returns a list of data values that are inside the range.
        """
        raise NotImplementedError

    def mask_data(self, data):
        """ Returns a mask array, indicating whether values in the given array
        are inside the range.

        Given an array of data values of the same dimensionality as the range,
        this method returns a mask array of the same length as data, filled
        with 1s and 0s corresponding to whether the data value at that index
        is inside or outside the range.
        """
        raise NotImplementedError

    def bound_data(self, data):
        """ Returns a tuple of indices for the start and end of the first run
        of data that falls within the range.

        Given an array of data values of the same dimensionality as the range,
        returns a tuple of indices (start, end) corresponding to the first and
        last elements of the first run of data that falls within the range.
        For monotonic data, this basically returns the first and last elements
        that fall within the range. Using this method is not advised for
        non-monotonic data; in that case, it returns the first and last
        elements of the first "chunk" of data that falls within the range.
        """
        raise NotImplementedError

    def set_bounds(self, *new_bounds):
        """ Sets all the bounds of the range simultaneously.

        Because each bounds change probably fires an event, this method allows
        tools to set all range elements in a single, atomic step.

        Parameters
        ----------
        new_bounds : a tuple of (low, high)
            The new bounds for the range; the dimensionality and cardinality
            depend on the specific subclass.

        This method not only reduces the number of spurious events (the
        ones that result from having to set both **high** and **low**), but also
        allows listeners to differentiate between translation and resize
        operations.
        """
        raise NotImplementedError

    def _refresh_bounds(self):
        """ Resets the values of the bounds depending on the data sources
        referenced by the range.

        This method is called only if one of the bounds settings is "auto".
        """
        raise NotImplementedError


########NEW FILE########
__FILENAME__ = abstract_data_source
"""
Defines the AbstractDataSource class.
"""

from traits.api import Bool, Dict, Event, HasTraits

# Local relative imports
from base import DimensionTrait

class AbstractDataSource(HasTraits):
    """ This abstract interface must be implemented by any class supplying data
    to Chaco.

    Chaco does not have a notion of a "data format". For the most part, a data
    source looks like an array of values with an optional mask and metadata.
    If you implement this interface, you are responsible for adapting your
    domain-specific or application-specific data to meet this interface.

    Chaco provides some basic data source implementations. In most cases, the
    easiest strategy is to create one of these basic data source with the
    numeric data from a domain model. In cases when this strategy is not
    possible, domain classes (or an adapter) must implement AbstractDataSource.
    """

    # The dimensionality of the value at each index point.
    # Subclasses re-declare this trait as a read-only trait with
    # the right default value.
    value_dimension = DimensionTrait

    # The dimensionality of the indices into this data source.
    # Subclasses re-declare this trait as a read-only trait with
    # the right default value.
    index_dimension = DimensionTrait

    # A dictionary keyed on strings.  In general, it maps to indices (or tuples
    # of indices, depending on **value_dimension**), as in the case of
    # selections and annotations.  Applications and renderers can add their own
    # custom metadata, but must avoid using keys that might result in name
    # collision.
    metadata = Dict

    # Event that fires when the data values change.
    data_changed = Event

    # Event that fires when just the bounds change.
    bounds_changed = Event

    # Event that fires when metadata structure is changed.
    metadata_changed = Event

    # Should the data that this datasource refers to be serialized when
    # the datasource is serialized?
    persist_data = Bool(True)

    #------------------------------------------------------------------------
    # Abstract methods
    #------------------------------------------------------------------------

    def get_data(self):
        """get_data() -> data_array

        Returns a data array of the dimensions of the data source. This data
        array must not be altered in-place, and the caller must assume it is
        read-only.  This data is contiguous and not masked.

        In the case of structured (gridded) 2-D data, this method may return
        two 1-D ArrayDataSources as an optimization.
        """
        raise NotImplementedError

    def get_data_mask(self):
        """get_data_mask() -> (data_array, mask_array)

        Returns the full, raw, source data array and a corresponding binary
        mask array.  Treat both arrays as read-only.

        The mask is a superposition of the masks of all upstream data sources.
        The length of the returned array may be much larger than what
        get_size() returns; the unmasked portion, however, matches what
        get_size() returns.
        """
        raise NotImplementedError

    def is_masked(self):
        """is_masked() -> bool

        Returns True if this data source's data uses a mask. In this case,
        to retrieve the data, call get_data_mask() instead of get_data().
        If you call get_data() for this data source, it returns data, but that
        data might not be the expected data.
        """
        raise NotImplementedError

    def get_size(self):
        """get_size() -> int

        Returns an integer estimate or the exact size of the dataset that
        get_data() returns for this object.  This method is useful for
        down-sampling.
        """
        raise NotImplementedError

    def get_bounds(self):
        """get_bounds() -> tuple(min, max)

        Returns a tuple (min, max) of the bounding values for the data source.
        In the case of 2-D data, min and max are 2-D points that represent the
        bounding corners of a rectangle enclosing the data set.  Note that
        these values are not view-dependent, but represent intrinsic properties
        of the data source.

        If data is the empty set, then the min and max vals are 0.0.
        """
        raise NotImplementedError


    ### Persistence ###########################################################

    def _metadata_default(self):
        return {"selections":[], "annotations":[]}

    def __getstate__(self):
        state = super(AbstractDataSource,self).__getstate__()

        # everything but 'metadata'
        for key in ['value_dimension', 'index_dimension', 'persist_data']:
            if state.has_key(key):
                del state[key]

        return state



# EOF

########NEW FILE########
__FILENAME__ = abstract_mapper
""" Defines the base class for mappings.
"""
# Major library imports
from numpy import array

# Enthought library imports
from traits.api import Event, HasTraits, Tuple


class AbstractMapper(HasTraits):
    """ Defines an abstract mapping from a region in input space to a
    region in output space.
    """

    # A generic "update" event that generally means that anything that relies
    # on this mapper for visual output should do a redraw or repaint.
    updated = Event

    # FIXME: domain_limits is never used

    # A tuple representing the minimum and maximum values of the domain (data
    # space).  The dimensionality of each value varies depending on the
    # dimensions of the mapper, so for 1D mappers these will be scalars, for
    # image and 2D mappers these will be tuples.
    domain_limits = Tuple(None, None)

    def map_screen(self, data_array):
        """ map_screen(data_array) -> screen_array

        Maps values from data space into screen space.
        """
        return

    def map_data(self, screen_val):
        """ map_data(screen_val) -> data_val

        Maps values from screen space into data space.
        """
        return

    def map_data_array(self, screen_vals):
        """ map_data_array(screen_vals) -> data_vals

        Maps an array of values from screen space into data space.
        By default, this method just loops over the points, calling map_data()
        on each one.  For vectorizable mapping functions, override this
        implmentation with a faster one.
        """
        return array([self.map_data(v) for v in screen_vals])


    #------------------------------------------------------------------------
    # Persistence-related methods
    #------------------------------------------------------------------------
    def __getstate__(self):
        state = super(AbstractMapper,self).__getstate__()
        for key in ['_cache_valid']:
            if state.has_key(key):
                del state[key]

        return state

    def _post_load(self):
        self._cache_valid = False
        self._range_changed(None, self.range)
        return

# EOF

########NEW FILE########
__FILENAME__ = abstract_overlay
""" Abstract base class for plot decorators and overlays.

This class is primarily used so that tools can easily distinguish between
data-related plot items and the decorators on them.
"""

from enable.api import Component
from traits.api import Instance

from plot_component import PlotComponent


class AbstractOverlay(PlotComponent):
    """ The base class for overlays and underlays of the plot area.

    The only default additional feature of an overlay is that it implements
    an overlay() drawing method that overlays this component on top of
    another, without the components necessarily having an object
    containment-ownership relationship.
    """

    # The component that this object overlays. This can be None. By default, if
    # this object is called to draw(), it tries to render onto this component.
    component = Instance(Component)

    # The default layer that this component draws into.
    draw_layer = "overlay"

    # The background color (overrides PlotComponent).
    # Typically, an overlay does not render a background.
    bgcolor = "transparent"

    def __init__(self, component=None, *args, **kw):
        if component is not None:
            self.component = component
        super(AbstractOverlay, self).__init__(*args, **kw)

    def overlay(self, other_component, gc, view_bounds=None, mode="normal"):
        """ Draws this component overlaid on another component.
        """
        pass

    def _draw(self, gc, view_bounds=None, mode="normal"):
        """ Draws the component, paying attention to **draw_order**.  If the
        overlay has a non-null .component, then renders as an overlay;
        otherwise, default to the standard PlotComponent behavior.

        Overrides PlotComponent.
        """
        if self.component is not None:
            self.overlay(self.component, gc, view_bounds, mode)
        else:
            super(AbstractOverlay, self)._draw(gc, view_bounds, mode)
        return

    def _request_redraw(self):
        """ Overrides Enable Component.
        """
        if self.component is not None:
            self.component.request_redraw()
        super(AbstractOverlay, self)._request_redraw()
        return

# EOF

########NEW FILE########
__FILENAME__ = abstract_plot_data
""" Defines the base class for plot data.
"""
from traits.api import Bool, Event, HasTraits


class AbstractPlotData(HasTraits):
    """
    Defines the interface for data providers to Plot.
    """

    #-------------------------------------------------------------------------
    # Events that consumers of this data should use
    #-------------------------------------------------------------------------

    # Indicates that some of the data has changed.  The event object must
    # be a dict with keys "added", "removed", "changed" and values that are
    # lists of strings. This event is used by consumers of this data.
    data_changed = Event


    #-------------------------------------------------------------------------
    # Flags - these determine how downstream consumers of the PlotData objet
    # interact with it.  (Typically "consumers" just refers to Plots.)
    #-------------------------------------------------------------------------

    # Can consumers (Plots) write data back through this interface using
    # set_data()?
    writable = Bool(True)

    # Can consumers (Plots) set selections?
    selectable = Bool(True)


    def list_data(self):
        """ Returns a list of valid names to use for get_data().

        These names are generally strings but can also be integers or any other
        hashable type.
        """
        raise NotImplementedError


    def get_data(self, name):
        """ Returns the data or data source associated with *name*.

        If there is no data or data source associated with the name, this method
        returns None.
        """
        raise NotImplementedError


    def del_data(self, name):
        """ Deletes the array specified by *name*, or raises a KeyError if
        the named array does not exist.
        
        If the instance is not writable, then this must do nothing.
        
        """
        raise NotImplementedError

    def set_data(self, name, new_data, generate_name=False):
        """ Sets the specified array as the value for either the specified
        name or a generated name.

        If the instance's `writable` attribute is True, then this method sets
        the data associated with the given name to the new value, otherwise it
        does nothing.

        Parameters
        ----------
        name : string
            The name of the array whose value is to be set.
        new_data : array
            The array to set as the value of *name*.
        generate_name : Boolean
            If True, a unique name of the form 'seriesN' is created for the
            array, and is used in place of *name*. The 'N' in 'seriesN' is
            one greater the largest N already used.

        Returns
        -------
        The name under which the array was set.

        """
        raise NotImplementedError


    def update_data(self, *args, **kwargs):
        """
        Update a set of data values, firing only one data_changed event.
        
        This function has the same signature as the dictionary update()
        method.
        
        """
        raise NotImplementedError

    def set_selection(self, name, selection):
        """ Sets the selection on the specified data.

        This method informs the class that Chaco has selected a portion of the
        data.

        Parameters
        ----------
        name : string
            Name of an array
        selection : array of Booleans
            Indicates whether the data in the cooresponding position of the
            array named by *name* is selected.
        """
        raise NotImplementedError

    #------------------------------------------------------------------------
    # Dictionary Interface
    #------------------------------------------------------------------------

    def __getitem__(self, name):
        return self.arrays.get(name, None)

    def __setitem__(self, name, value):
        return self.set_data(name, value)

    def __delitem__(self, name):
        return self.del_data(name)

    def update(self, *args, **kwargs):
        self.update_data(*args, **kwargs)
    

########NEW FILE########
__FILENAME__ = abstract_plot_renderer
""" Defines a base class for plot renderers.
"""
# Enthought library imports.
from traits.api import Enum

# Local relative imports
from plot_component import PlotComponent

class AbstractPlotRenderer(PlotComponent):
    """ This is the minimal interface that all plot renderers must support.

    Higher-dimensionality plot renderers can implement a richer subclass of
    this abstract class.

    This interface exists mostly to support the development of generic
    interactors and plot tools.
    """

    origin = Enum("bottom left", "top left", "bottom right", "top right")

    #------------------------------------------------------------------------
    # Override default values of inherited traits PlotComponent
    #------------------------------------------------------------------------

    # Overrides the default value inherited from PlotComponent.
    bgcolor = "transparent"

    # Overrides the default value inherited from PlotComponent.
    resizable = "hv"


    def map_screen(self, data_array):
        """ Maps an array of data points to screen space and returns an array
        of screen space points.
        """
        raise NotImplementedError

    def map_data(self, screen_pt):
        """ Maps a screen space point (sx, sy) to the "index" space of the plot.

        Returns a floating point number, *not* an integer index.
        """
        raise NotImplementedError

    def map_index(self, screen_pt, threshold=0.0, outside_returns_none=True, \
                  index_only = False):
        """ Maps a screen space point to an index into the plot's index array(s).

        Parameters
        ----------
        screen_pt : (x,y)
            The screen space point to map.
        threshold : float
            Optional screen-space distance allowed between *screen_pt* and the
            plot; if non-zero, then a *screen_pt* within this distance is
            mapped to the neared plot index. (This feature is useful for sparse
            2-D data.)
        outside_returns_none : Boolean
            If True, then if *screen_pt* is outside the range of the data, the
            method returns None. If False, it returns the nearest end index in
            such a case.
        index_only : Boolean
            If True, then this method maps based only on the index coordinate
            of *screen_pt*, and ignores the value coordinate.

        Returns
        -------
        An index into the plot's index array(s). Typically this index is just
        an integer, but if the plot has a 2-D index dimension, then this method
        returns a tuple of integers. If the input point cannot be mapped to an
        index, then None is returned.

        If *screen_pt* corresponds to multiple indices, then only the first
        index is returned.
        """
        raise NotImplementedError

    def _render_icon(self, gc, x, y, width, height):
        """ Renders an icon for this plot.

        This method is used by the legend to draw representation of this plot
        as an icon into the box defined by the given coordinates.
        """
        pass


# EOF

########NEW FILE########
__FILENAME__ = api
""" Defines the publicly accessible items of the Chaco API.
"""
# This just imports the key datamodel classes into the top-level package
# namespace for convenience.

from base import NumericalSequenceTrait, PointTrait, ImageTrait, DimensionTrait, \
                 SortOrderTrait, bin_search, reverse_map_1d, right_shift, \
                 left_shift, sort_points, find_runs, arg_find_runs, \
                 point_line_distance

# Data model
from abstract_data_source import AbstractDataSource
from array_data_source import ArrayDataSource
from grid_data_source import GridDataSource
from image_data import ImageData
from multi_array_data_source import MultiArrayDataSource
from point_data_source import PointDataSource
from abstract_data_range import AbstractDataRange
from base_data_range import BaseDataRange
from data_range_1d import DataRange1D
from data_range_2d import DataRange2D

# Mappers
from abstract_mapper import AbstractMapper
from base_1d_mapper import Base1DMapper
from grid_mapper import GridMapper
from log_mapper import LogMapper
from linear_mapper import LinearMapper
from color_mapper import ColorMapper, ColorMapTemplate
from transform_color_mapper import TransformColorMapper

# Colormaps and color palettes
from default_colormaps import *
from default_colors import *

# Visual components
from abstract_plot_renderer import AbstractPlotRenderer
from abstract_overlay import AbstractOverlay
from base_plot_container import BasePlotContainer
from base_plot_frame import BasePlotFrame
from cross_plot_frame import CrossPlotFrame
from data_view import DataView
from simple_plot_frame import SimplePlotFrame
from plot_component import PlotComponent
from plot_graphics_context import PlotGraphicsContext, PlotGraphicsContextMixin
from selectable_overlay_container import SelectableOverlayPlotContainer
from plot_containers import OverlayPlotContainer, HPlotContainer, VPlotContainer, \
                            GridPlotContainer
GridContainer = GridPlotContainer

from label import Label
from plot_label import PlotLabel
from legend import Legend
from tooltip import ToolTip
from data_label import DataLabel
from lasso_overlay import LassoOverlay
from color_bar import ColorBar
from text_box_overlay import TextBoxOverlay
from scatter_inspector_overlay import ScatterInspectorOverlay

# Renderers
from barplot import BarPlot
from base_2d_plot import Base2DPlot
from base_xy_plot import BaseXYPlot
from scatterplot import ScatterPlot, render_markers
from image_plot import ImagePlot
from cmap_image_plot import CMapImagePlot
from contour_line_plot import ContourLinePlot
from contour_poly_plot import ContourPolyPlot
from lineplot import LinePlot
from colormapped_scatterplot import ColormappedScatterPlot
from colormapped_selection_overlay import ColormappedSelectionOverlay
from polygon_plot import PolygonPlot
from errorbar_plot import ErrorBarPlot
from filled_line_plot import FilledLinePlot
from quiverplot import QuiverPlot
from candle_plot import CandlePlot
from multi_line_plot import MultiLinePlot
from jitterplot import JitterPlot
from variable_size_scatterplot import VariableSizeScatterPlot
from horizon_plot import BandedMapper, HorizonPlot

# Plot factories
from plot_factory import create_bar_plot, create_line_plot, create_scatter_plot, \
                         create_polar_plot, add_default_axes, add_default_grids

from abstract_plot_data import AbstractPlotData
from array_plot_data import ArrayPlotData
from plot import Plot
from toolbar_plot import ToolbarPlot

# Axis
from axis import PlotAxis
from label_axis import LabelAxis
from ticks import AbstractTickGenerator, DefaultTickGenerator, auto_ticks, auto_interval, \
                  tick_intervals, log_auto_ticks, auto_bounds, calc_bound

# Grid
from grid import PlotGrid

# Style stuff
#from stylable import Stylable
#from stylesheets import Style, StyleSheet

# Tools
from abstract_controller import AbstractController

# Importing various symbols into the Chaco namespace for backwards
# compatibility.  New code should directly import from Enable.
from enable.base_tool import BaseTool, KeySpec
from enable.markers import marker_trait

#EOF

########NEW FILE########
__FILENAME__ = array_data_source
""" Defines the ArrayDataSource class."""

# Major library imports
from numpy import array, isfinite, ones, nanargmin, nanargmax, ndarray

# Enthought library imports
from traits.api import Any, Constant, Int, Tuple

# Chaco imports
from base import NumericalSequenceTrait, reverse_map_1d, SortOrderTrait
from abstract_data_source import AbstractDataSource


def bounded_nanargmin(arr):
    """ Find the index of the minimum value, ignoring NaNs.

    If all NaNs, return 0.
    """
    # Different versions of numpy behave differently in the all-NaN case, so we
    # catch this condition in two different ways.
    try:
        min = nanargmin(arr)
    except ValueError:
        return 0
    if isfinite(min):
        return min
    else:
        return 0

def bounded_nanargmax(arr):
    """ Find the index of the maximum value, ignoring NaNs.

    If all NaNs, return -1.
    """
    try:
        max = nanargmax(arr)
    except ValueError:
        return -1
    if isfinite(max):
        return max
    else:
        return -1

class ArrayDataSource(AbstractDataSource):
    """ A data source representing a single, continuous array of numerical data.

    This class does not listen to the array for value changes; if you need that
    behavior, create a subclass that hooks up the appropriate listeners.
    """

    #------------------------------------------------------------------------
    # AbstractDataSource traits
    #------------------------------------------------------------------------

    # The dimensionality of the indices into this data source (overrides
    # AbstractDataSource).
    index_dimension = Constant('scalar')

    # The dimensionality of the value at each index point (overrides
    # AbstractDataSource).
    value_dimension = Constant('scalar')

    # The sort order of the data.
    # This is a specialized optimization for 1-D arrays, but it's an important
    # one that's used everywhere.
    sort_order = SortOrderTrait


    #------------------------------------------------------------------------
    # Private traits
    #------------------------------------------------------------------------

    # The data array itself.
    _data = NumericalSequenceTrait

    # Cached values of min and max as long as **_data** doesn't change.
    _cached_bounds = Tuple

    # Not necessary, since this is not a filter, but provided for convenience.
    _cached_mask = Any

    # The index of the (first) minimum value in self._data
    # FIXME: This is an Any instead of an Int trait because of how Traits
    # typechecks numpy.int64 on 64-bit Windows systems.
    _min_index = Any

    # The index of the (first) maximum value in self._data
    # FIXME: This is an Any instead of an Int trait because of how Traits
    # typechecks numpy.int64 on 64-bit Windows systems.
    _max_index = Any


    #------------------------------------------------------------------------
    # Public methods
    #------------------------------------------------------------------------

    def __init__(self, data=array([]), sort_order="none", **kw):
        AbstractDataSource.__init__(self, **kw)
        self.set_data(data, sort_order)
        return

    def set_data(self, newdata, sort_order=None):
        """ Sets the data, and optionally the sort order, for this data source.

        Parameters
        ----------
        newdata : array
            The data to use.
        sort_order : SortOrderTrait
            The sort order of the data
        """
        self._data = newdata
        if sort_order is not None:
            self.sort_order = sort_order
        self._compute_bounds()
        self.data_changed = True
        return

    def set_mask(self, mask):
        """ Sets the mask for this data source.
        """
        self._cached_mask = mask
        self.data_changed = True
        return

    def remove_mask(self):
        """ Removes the mask on this data source.
        """
        self._cached_mask = None
        self.data_changed = True
        return

    #------------------------------------------------------------------------
    # AbstractDataSource interface
    #------------------------------------------------------------------------

    def get_data(self):
        """ Returns the data for this data source, or 0.0 if it has no data.

        Implements AbstractDataSource.
        """
        if self._data is not None:
            return self._data
        else:
            return 0.0

    def get_data_mask(self):
        """get_data_mask() -> (data_array, mask_array)

        Implements AbstractDataSource.
        """
        if self._cached_mask is None:
            return self._data, ones(len(self._data), dtype=bool)
        else:
            return self._data, self._cached_mask

    def is_masked(self):
        """is_masked() -> bool

        Implements AbstractDataSource.
        """
        if self._cached_mask is not None:
            return True
        else:
            return False

    def get_size(self):
        """get_size() -> int

        Implements AbstractDataSource.
        """
        if self._data is not None:
            return len(self._data)
        else:
            return 0

    def get_bounds(self):
        """ Returns the minimum and maximum values of the data source's data.

        Implements AbstractDataSource.
        """
        if self._cached_bounds is None or self._cached_bounds == () or \
               self._cached_bounds == 0.0:
            self._compute_bounds()
        return self._cached_bounds

    def reverse_map(self, pt, index=0, outside_returns_none=True):
        """Returns the index of *pt* in the data source.

        Parameters
        ----------
        pt : scalar value
            value to find
        index
            ignored for data series with 1-D indices
        outside_returns_none : Boolean
            Whether the method returns None if *pt* is outside the range of
            the data source; if False, the method returns the value of the
            bound that *pt* is outside of.
        """
        if self.sort_order == "none":
            raise NotImplementedError

        # index is ignored for dataseries with 1-dimensional indices
        minval, maxval = self._cached_bounds
        if (pt < minval):
            if outside_returns_none:
                return None
            else:
                return self._min_index
        elif (pt > maxval):
            if outside_returns_none:
                return None
            else:
                return self._max_index
        else:
            return reverse_map_1d(self._data, pt, self.sort_order)


    #------------------------------------------------------------------------
    # Private methods
    #------------------------------------------------------------------------

    def _compute_bounds(self, data=None):
        """ Computes the minimum and maximum values of self._data.

        If a data array is passed in, then that is used instead of self._data.
        This behavior is useful for subclasses.
        """
        # TODO: as an optimization, perhaps create and cache a sorted
        #       version of the dataset?

        if data is None:
            # Several sources weren't setting the _data attribute, so we
            # go through the interface.  This seems like the correct thing
            # to do anyway... right?
            #data = self._data
            data = self.get_data()

        data_len = 0
        try:
            data_len = len(data)
        except:
            pass
        if data_len == 0:
            self._min_index = 0
            self._max_index = 0
            self._cached_bounds = (0.0, 0.0)
        elif data_len == 1:
            self._min_index = 0
            self._max_index = 0
            self._cached_bounds = (data[0], data[0])
        else:
            if self.sort_order == "ascending":
                self._min_index = 0
                self._max_index = -1
            elif self.sort_order == "descending":
                self._min_index = -1
                self._max_index = 0
            else:
                # ignore NaN values.  This is probably a little slower,
                # but also much safer.

                # data might be an array of strings or objects that
                # can't have argmin calculated on them.
                try:
                    # the data may be in a subclass of numpy.array, viewing
                    # the data as a ndarray will remove side effects of
                    # the subclasses, such as different operator behaviors
                    self._min_index = bounded_nanargmin(data.view(ndarray))
                    self._max_index = bounded_nanargmax(data.view(ndarray))
                except (TypeError, IndexError, NotImplementedError):
                    # For strings and objects, we punt...  These show up in
                    # label-ish data sources.
                    self._cached_bounds = (0.0, 0.0)

            self._cached_bounds = (data[self._min_index],
                               data[self._max_index])
        return

    #------------------------------------------------------------------------
    # Event handlers
    #------------------------------------------------------------------------

    def _metadata_changed(self, event):
        self.metadata_changed = True

    def _metadata_items_changed(self, event):
        self.metadata_changed = True

    #------------------------------------------------------------------------
    # Persistence-related methods
    #------------------------------------------------------------------------

    def __getstate__(self):
        state = self.__dict__.copy()
        if not self.persist_data:
            state.pop("_data", None)
            state.pop("_cached_mask", None)
            state.pop("_cached_bounds", None)
            state.pop("_min_index", None)
            state.pop("_max_index", None)
        return state

    def _post_load(self):
        super(ArrayDataSource, self)._post_load()
        self._cached_bounds = ()
        self._cached_mask = None
        return


# EOF

########NEW FILE########
__FILENAME__ = array_plot_data
""" Defines ArrayPlotData.
"""

from numpy import array, ndarray

# Enthought library imports
from traits.api import Dict

# Local, relative imports
from .abstract_plot_data import AbstractPlotData
from .abstract_data_source import AbstractDataSource


class ArrayPlotData(AbstractPlotData):
    """ A PlotData implementation class that handles a list of Numpy arrays
    (or a 2-D Numpy array).

    By default, it doesn't allow its input data to be modified by downstream
    Chaco components or interactors.
    """

    #-------------------------------------------------------------------------
    # Public traits
    #-------------------------------------------------------------------------

    # Map of names to arrays.  Although there is no restriction on the array
    # dimensions, each array must correspond to a single plot item; that
    # is, a single name must not map to a multi-dimensional array unless
    # the array is being used for an image plot or for something that can handle
    # multi-dimensional input data.
    arrays = Dict

    # Consumers can write data to this object (overrides AbstractPlotData).
    writable = True

    def __init__(self, *data, **kw):
        """ ArrayPlotData can be constructed by passing in arrays.

        Keyword arguments can be used to give certain arrays specific names;
        unnamed arrays are given a generic name of the format 'seriesN', where
        N is its position in the argument list.

        For example::

            ArrayPlotData(array1, array2, index=array3, foo=array4)

        This call results in the creation of four entries in self.arrays::

            'series1' -> array1
            'series2' -> array2
            'index'   -> array3
            'foo'     -> array4

        If any names in the keyword parameter list collide with the
        auto-generated positional names "series1", "series2", etc., then those
        arrays are replaced.

        Note that this factor means that keyword traits are *not* set using the
        keyword parameters in the constructor. This strategy defies some
        conventions, but was it chosen for convenience, since the raison d'etre
        of this class is convenience.
        """
        super(AbstractPlotData, self).__init__()
        self._update_data(kw)
        data = dict(zip(self._generate_names(len(data)), data))
        self._update_data(data)


    #------------------------------------------------------------------------
    # AbstractPlotData Interface
    #------------------------------------------------------------------------

    def list_data(self):
        """ Returns a list of the names of the arrays managed by this instance.
        """
        return self.arrays.keys()


    def get_data(self, name):
        """ Returns the array associated with *name*.

        Implements AbstractDataSource.
        """
        return self.arrays.get(name, None)


    def del_data(self, name):
        """ Deletes the array specified by *name*, or raises a KeyError if
        the named array does not exist.
        """
        if not self.writable:
            return None

        if name in self.arrays:
            del self.arrays[name]
            self.data_changed = {'removed': [name]}
        else:
            raise KeyError("Data series '%s' does not exist." % name)


    def set_data(self, name, new_data, generate_name=False):
        """ Sets the specified array as the value for either the specified
        name or a generated name.

        If the instance's `writable` attribute is True, then this method sets
        the data associated with the given name to the new value, otherwise it
        does nothing.

        Parameters
        ----------
        name : string
            The name of the array whose value is to be set.
        new_data : array
            The array to set as the value of *name*.
        generate_name : Boolean
            If True, a unique name of the form 'seriesN' is created for the
            array, and is used in place of *name*. The 'N' in 'seriesN' is
            one greater the largest N already used.

        Returns
        -------
        The name under which the array was set.

        """
        if not self.writable:
            return None

        if generate_name:
            names = self._generate_names(1)
            name = names[0]
            
        self.update_data({name: new_data})
        return name


    def update_data(self, *args, **kwargs):
        """ Sets the specified array as the value for either the specified
        name or a generated name.

        Implements AbstractPlotData's update_data() method.  This method has
        the same signature as the dictionary update() method.

        """
        if not self.writable:
            return None
        
        data = dict(*args, **kwargs)
        event = {}
        for name in data:
            if name in self.arrays:
                event.setdefault('changed', []).append(name)
            else:
                event.setdefault('added', []).append(name)

        self._update_data(data)
        self.data_changed = event


    def set_selection(self, name, selection):
        """ Overrides AbstractPlotData to do nothing and not raise an error.
        """
        pass

    #------------------------------------------------------------------------
    # Private methods
    #------------------------------------------------------------------------    

    def _generate_names(self, n):
        """ Generate n new names
        """
        max_index = max(self._generate_indices())
        names = ["series{0:d}".format(n) for n in range(max_index+1, max_index+n+1)]
        return names

    def _generate_indices(self):
        """ Generator that yields all integers that match "series%d" in keys
        """
        yield 0 # default minimum
        for name in self.list_data():
            if name.startswith('series'):
                try:
                    v = int(name[6:])
                except ValueError:
                    continue
                yield v

    def _update_data(self, data):
        """ Update the array, ensuring that data is an array
        """
        # note that this call modifies data, but that's OK since the callers
        # all create the dictionary that they pass in
        for name, value in data.items():
            if not isinstance(value, (ndarray, AbstractDataSource)):
                data[name] = array(value)
            else:
                data[name] = value

        self.arrays.update(data)


########NEW FILE########
__FILENAME__ = axis
""" Defines the PlotAxis class, and associated validator and UI.
"""

from __future__ import with_statement

# Major library import
from numpy import array, around, absolute, cos, dot, float64, inf, pi, \
                  sqrt, sin, transpose

# Enthought Library imports
from enable.api import ColorTrait, LineStyle
from kiva.trait_defs.kiva_font_trait import KivaFont
from traits.api import Any, Float, Int, Str, Trait, Unicode, \
     Bool, Event, List, Array, Instance, Enum, Callable

# Local relative imports
from ticks import AbstractTickGenerator, DefaultTickGenerator
from abstract_mapper import AbstractMapper
from abstract_overlay import AbstractOverlay
from label import Label
from log_mapper import LogMapper


def DEFAULT_TICK_FORMATTER(val):
    return ("%f"%val).rstrip("0").rstrip(".")

class PlotAxis(AbstractOverlay):
    """
    The PlotAxis is a visual component that can be rendered on its own as
    a standalone component or attached as an overlay to another component.
    (To attach it as an overlay, set its **component** attribute.)

    When it is attached as an overlay, it draws into the padding around
    the component.
    """

    # The mapper that drives this axis.
    mapper = Instance(AbstractMapper)

    # Keep an origin for plots that aren't attached to a component
    origin = Enum("bottom left", "top left", "bottom right", "top right")

    # The text of the axis title.
    title = Trait('', Str, Unicode) #May want to add PlotLabel option

    # The font of the title.
    title_font = KivaFont('modern 12')

    # The spacing between the axis line and the title
    title_spacing = Trait('auto', 'auto', Float)

    # The color of the title.
    title_color = ColorTrait("black")

    # The thickness (in pixels) of each tick.
    tick_weight = Float(1.0)

    # The color of the ticks.
    tick_color = ColorTrait("black")

    # The font of the tick labels.
    tick_label_font = KivaFont('modern 10')

    # The color of the tick labels.
    tick_label_color = ColorTrait("black")

    # The rotation of the tick labels.
    tick_label_rotate_angle = Float(0)

    # Whether to align to corners or edges (corner is better for 45 degree rotation)
    tick_label_alignment = Enum('edge', 'corner')

    # The margin around the tick labels.
    tick_label_margin = Int(2)

    # The distance of the tick label from the axis.
    tick_label_offset = Float(8.)

    # Whether the tick labels appear to the inside or the outside of the plot area
    tick_label_position = Enum("outside", "inside")

    # A callable that is passed the numerical value of each tick label and
    # that returns a string.
    tick_label_formatter = Callable(DEFAULT_TICK_FORMATTER)

    # The number of pixels by which the ticks extend into the plot area.
    tick_in = Int(5)

    # The number of pixels by which the ticks extend into the label area.
    tick_out = Int(5)

    # Are ticks visible at all?
    tick_visible = Bool(True)

    # The dataspace interval between ticks.
    tick_interval = Trait('auto', 'auto', Float)

    # A callable that implements the AbstractTickGenerator interface.
    tick_generator = Instance(AbstractTickGenerator)

    # The location of the axis relative to the plot.  This determines where
    # the axis title is located relative to the axis line.
    orientation = Enum("top", "bottom", "left", "right")

    # Is the axis line visible?
    axis_line_visible = Bool(True)

    # The color of the axis line.
    axis_line_color = ColorTrait("black")

    # The line thickness (in pixels) of the axis line.
    axis_line_weight = Float(1.0)

    # The dash style of the axis line.
    axis_line_style = LineStyle('solid')

    # A special version of the axis line that is more useful for geophysical
    # plots.
    small_haxis_style = Bool(False)

    # Does the axis ensure that its end labels fall within its bounding area?
    ensure_labels_bounded = Bool(False)

    # Does the axis prevent the ticks from being rendered outside its bounds?
    # This flag is off by default because the standard axis *does* render ticks
    # that encroach on the plot area.
    ensure_ticks_bounded = Bool(False)

    # Fired when the axis's range bounds change.
    updated = Event

    #------------------------------------------------------------------------
    # Override default values of inherited traits
    #------------------------------------------------------------------------

    # Background color (overrides AbstractOverlay). Axes usually let the color of
    # the container show through.
    bgcolor = ColorTrait("transparent")

    # Dimensions that the axis is resizable in (overrides PlotComponent).
    # Typically, axes are resizable in both dimensions.
    resizable = "hv"

    #------------------------------------------------------------------------
    # Private Traits
    #------------------------------------------------------------------------

    # Cached position calculations

    _tick_list = List  # These are caches of their respective positions
    _tick_positions = Any #List
    _tick_label_list = Any
    _tick_label_positions = Any
    _tick_label_bounding_boxes = List
    _major_axis_size = Float
    _minor_axis_size = Float
    _major_axis = Array
    _title_orientation = Array
    _title_angle = Float
    _origin_point = Array
    _inside_vector = Array
    _axis_vector = Array
    _axis_pixel_vector = Array
    _end_axis_point = Array


    ticklabel_cache = List
    _cache_valid = Bool(False)


    #------------------------------------------------------------------------
    # Public methods
    #------------------------------------------------------------------------

    def __init__(self, component=None, **kwargs):
        # TODO: change this back to a factory in the instance trait some day
        self.tick_generator = DefaultTickGenerator()
        # Override init so that our component gets set last.  We want the
        # _component_changed() event handler to get run last.
        super(PlotAxis, self).__init__(**kwargs)
        if component is not None:
            self.component = component

    def invalidate(self):
        """ Invalidates the pre-computed layout and scaling data.
        """
        self._reset_cache()
        self.invalidate_draw()
        return

    def traits_view(self):
        """ Returns a View instance for use with Traits UI.  This method is
        called automatically be the Traits framework when .edit_traits() is
        invoked.
        """
        from axis_view import AxisView
        return AxisView


    #------------------------------------------------------------------------
    # PlotComponent and AbstractOverlay interface
    #------------------------------------------------------------------------

    def _do_layout(self, *args, **kw):
        """ Tells this component to do layout at a given size.

        Overrides Component.
        """
        if self.use_draw_order and self.component is not None:
            self._layout_as_overlay(*args, **kw)
        else:
            super(PlotAxis, self)._do_layout(*args, **kw)
        return

    def overlay(self, component, gc, view_bounds=None, mode='normal'):
        """ Draws this component overlaid on another component.

        Overrides AbstractOverlay.
        """
        if not self.visible:
            return
        self._draw_component(gc, view_bounds, mode, component)
        return

    def _draw_overlay(self, gc, view_bounds=None, mode='normal'):
        """ Draws the overlay layer of a component.

        Overrides PlotComponent.
        """
        self._draw_component(gc, view_bounds, mode)
        return

    def _draw_component(self, gc, view_bounds=None, mode='normal', component=None):
        """ Draws the component.

        This method is preserved for backwards compatibility. Overrides
        PlotComponent.
        """
        if not self.visible:
            return

        if not self._cache_valid:
            if component is not None:
                self._calculate_geometry_overlay(component)
            else:
                self._calculate_geometry()
            self._compute_tick_positions(gc, component)
            self._compute_labels(gc)

        with gc:
            # slight optimization: if we set the font correctly on the
            # base gc before handing it in to our title and tick labels,
            # their set_font() won't have to do any work.
            gc.set_font(self.tick_label_font)

            if self.axis_line_visible:
                self._draw_axis_line(gc, self._origin_point, self._end_axis_point)
            if self.title:
                self._draw_title(gc)

            self._draw_ticks(gc)
            self._draw_labels(gc)

        self._cache_valid = True
        return


    #------------------------------------------------------------------------
    # Private draw routines
    #------------------------------------------------------------------------

    def _layout_as_overlay(self, size=None, force=False):
        """ Lays out the axis as an overlay on another component.
        """
        if self.component is not None:
            if self.orientation in ("left", "right"):
                self.y = self.component.y
                self.height = self.component.height
                if self.orientation == "left":
                    self.width = self.component.padding_left
                    self.x = self.component.outer_x
                elif self.orientation == "right":
                    self.width = self.component.padding_right
                    self.x = self.component.x2 + 1
            else:
                self.x = self.component.x
                self.width = self.component.width
                if self.orientation == "bottom":
                    self.height = self.component.padding_bottom
                    self.y = self.component.outer_y
                elif self.orientation == "top":
                    self.height = self.component.padding_top
                    self.y = self.component.y2 + 1
        return

    def _draw_axis_line(self, gc, startpoint, endpoint):
        """ Draws the line for the axis.
        """
        with gc:
            gc.set_antialias(0)
            gc.set_line_width(self.axis_line_weight)
            gc.set_stroke_color(self.axis_line_color_)
            gc.set_line_dash(self.axis_line_style_)
            gc.move_to(*around(startpoint))
            gc.line_to(*around(endpoint))
            gc.stroke_path()
        return


    def _draw_title(self, gc, label=None, axis_offset=None):
        """ Draws the title for the axis.
        """
        if label is None:
            title_label = Label(text=self.title,
                                font=self.title_font,
                                color=self.title_color,
                                rotate_angle=self.title_angle)
        else:
            title_label = label

        # get the _rotated_ bounding box of the label
        tl_bounds = array(title_label.get_bounding_box(gc), float64)
        text_center_to_corner = -tl_bounds/2.0
        # which axis are we moving away from the axis line along?
        axis_index = self._major_axis.argmin()

        if self.title_spacing != 'auto':
            axis_offset = self.title_spacing

        if (self.title_spacing) and (axis_offset is None ):
            if not self.ticklabel_cache:
                axis_offset = 25
            else:
                axis_offset = max([l._bounding_box[axis_index] for l in self.ticklabel_cache]) * 1.3

        offset = (self._origin_point+self._end_axis_point)/2
        axis_dist = self.tick_out + tl_bounds[axis_index]/2.0 + axis_offset
        offset -= self._inside_vector * axis_dist
        offset += text_center_to_corner

        gc.translate_ctm(*offset)
        title_label.draw(gc)
        gc.translate_ctm(*(-offset))
        return


    def _draw_ticks(self, gc):
        """ Draws the tick marks for the axis.
        """
        if not self.tick_visible:
            return
        gc.set_stroke_color(self.tick_color_)
        gc.set_line_width(self.tick_weight)
        gc.set_antialias(False)
        gc.begin_path()
        tick_in_vector = self._inside_vector*self.tick_in
        tick_out_vector = self._inside_vector*self.tick_out
        for tick_pos in self._tick_positions:
            gc.move_to(*(tick_pos + tick_in_vector))
            gc.line_to(*(tick_pos - tick_out_vector))
        gc.stroke_path()
        return

    def _draw_labels(self, gc):
        """ Draws the tick labels for the axis.
        """
        # which axis are we moving away from the axis line along?
        axis_index = self._major_axis.argmin()

        inside_vector = self._inside_vector
        if self.tick_label_position == "inside":
            inside_vector = -inside_vector

        for i in range(len(self._tick_label_positions)):
            #We want a more sophisticated scheme than just 2 decimals all the time
            ticklabel = self.ticklabel_cache[i]
            tl_bounds = self._tick_label_bounding_boxes[i]

            #base_position puts the tick label at a point where the vector
            #extending from the tick mark inside 8 units
            #just touches the rectangular bounding box of the tick label.
            #Note: This is not necessarily optimal for non
            #horizontal/vertical axes.  More work could be done on this.

            base_position = self._tick_label_positions[i].copy()
            axis_dist = self.tick_label_offset + tl_bounds[axis_index]/2.0
            base_position -= inside_vector * axis_dist
            base_position -= tl_bounds/2.0

            if self.tick_label_alignment == 'corner':
                if self.orientation in ("top", "bottom"):
                    base_position[0] += tl_bounds[0]/2.0
                elif self.orientation == "left":
                    base_position[1] -= tl_bounds[1]/2.0
                elif self.orientation == "right":
                    base_position[1] += tl_bounds[1]/2.0

            if self.ensure_labels_bounded:
                bound_idx = self._major_axis.argmax()
                if i == 0:
                    base_position[bound_idx] = max(base_position[bound_idx],
                                                   self._origin_point[bound_idx])
                elif i == len(self._tick_label_positions)-1:
                    base_position[bound_idx] = min(base_position[bound_idx],
                                                   self._end_axis_point[bound_idx] - \
                                                   tl_bounds[bound_idx])

            tlpos = around(base_position)
            gc.translate_ctm(*tlpos)
            ticklabel.draw(gc)
            gc.translate_ctm(*(-tlpos))
        return


    #------------------------------------------------------------------------
    # Private methods for computing positions and layout
    #------------------------------------------------------------------------

    def _reset_cache(self):
        """ Clears the cached tick positions, labels, and label positions.
        """
        self._tick_positions = []
        self._tick_label_list = []
        self._tick_label_positions = []
        return

    def _compute_tick_positions(self, gc, overlay_component=None):
        """ Calculates the positions for the tick marks.
        """
        if (self.mapper is None):
            self._reset_cache()
            self._cache_valid = True
            return

        datalow = self.mapper.range.low
        datahigh = self.mapper.range.high
        screenhigh = self.mapper.high_pos
        screenlow = self.mapper.low_pos
        if overlay_component is not None:
            origin = getattr(overlay_component, 'origin', 'bottom left')
        else:
            origin = self.origin
        if self.orientation in ("top", "bottom"):
            if "right" in origin:
                flip_from_gc = True
            else:
                flip_from_gc = False
        elif self.orientation in ("left", "right"):
            if "top" in origin:
                flip_from_gc = True
            else:
                flip_from_gc = False
        if flip_from_gc:
            screenlow, screenhigh = screenhigh, screenlow

        if (datalow == datahigh) or (screenlow == screenhigh) or \
           (datalow in [inf, -inf]) or (datahigh in [inf, -inf]):
            self._reset_cache()
            self._cache_valid = True
            return

        if datalow > datahigh:
            raise RuntimeError, "DataRange low is greater than high; unable to compute axis ticks."

        if not self.tick_generator:
            return

        if hasattr(self.tick_generator, "get_ticks_and_labels"):
            # generate ticks and labels simultaneously
            tmp = self.tick_generator.get_ticks_and_labels(datalow, datahigh,
                                                screenlow, screenhigh)
            if len(tmp) == 0:
                tick_list = []
                labels = []
            else:
                tick_list, labels = tmp
            # compute the labels here
            self.ticklabel_cache = [Label(text=lab,
                                          font=self.tick_label_font,
                                          color=self.tick_label_color) \
                                    for lab in labels]
            self._tick_label_bounding_boxes = [array(ticklabel.get_bounding_box(gc), float64) \
                                               for ticklabel in self.ticklabel_cache]
        else:
            scale = 'log' if isinstance(self.mapper, LogMapper) else 'linear'
            if self.small_haxis_style:
                tick_list = array([datalow, datahigh])
            else:
                tick_list = array(self.tick_generator.get_ticks(datalow, datahigh,
                                                                datalow, datahigh,
                                                                self.tick_interval,
                                                                use_endpoints=False,
                                                                scale=scale), float64)

        mapped_tick_positions = (array(self.mapper.map_screen(tick_list))-screenlow) / \
                                            (screenhigh-screenlow)
        self._tick_positions = around(array([self._axis_vector*tickpos + self._origin_point \
                                for tickpos in mapped_tick_positions]))
        self._tick_label_list = tick_list
        self._tick_label_positions = self._tick_positions
        return


    def _compute_labels(self, gc):
        """Generates the labels for tick marks.

        Waits for the cache to become invalid.
        """
        # tick labels are already computed
        if hasattr(self.tick_generator, "get_ticks_and_labels"):
            return

        formatter = self.tick_label_formatter
        def build_label(val):
            tickstring = formatter(val) if formatter is not None else str(val)
            return Label(text=tickstring,
                         font=self.tick_label_font,
                         color=self.tick_label_color,
                         rotate_angle=self.tick_label_rotate_angle,
                         margin=self.tick_label_margin)

        self.ticklabel_cache = [build_label(val) for val in self._tick_label_list]
        self._tick_label_bounding_boxes = [array(ticklabel.get_bounding_box(gc), float)
                                               for ticklabel in self.ticklabel_cache]
        return


    def _calculate_geometry(self):
        origin = self.origin
        screenhigh = self.mapper.high_pos
        screenlow = self.mapper.low_pos

        if self.orientation in ('top', 'bottom'):
            self._major_axis_size = self.bounds[0]
            self._minor_axis_size = self.bounds[1]
            self._major_axis = array([1., 0.])
            self._title_orientation = array([0.,1.])
            self.title_angle = 0.0
            if self.orientation == 'top':
                self._origin_point = array(self.position)
                self._inside_vector = array([0.,-1.])
            else: #self.oriention == 'bottom'
                self._origin_point = array(self.position) + array([0., self.bounds[1]])
                self._inside_vector = array([0., 1.])
            if "right" in origin:
                screenlow, screenhigh = screenhigh, screenlow

        elif self.orientation in ('left', 'right'):
            self._major_axis_size = self.bounds[1]
            self._minor_axis_size = self.bounds[0]
            self._major_axis = array([0., 1.])
            self._title_orientation = array([-1., 0])
            if self.orientation == 'left':
                self._origin_point = array(self.position) + array([self.bounds[0], 0.])
                self._inside_vector = array([1., 0.])
                self.title_angle = 90.0
            else: #self.orientation == 'right'
                self._origin_point = array(self.position)
                self._inside_vector = array([-1., 0.])
                self.title_angle = 270.0
            if "top" in origin:
                screenlow, screenhigh = screenhigh, screenlow

        if self.ensure_ticks_bounded:
            self._origin_point -= self._inside_vector*self.tick_in

        self._end_axis_point = abs(screenhigh-screenlow)*self._major_axis + self._origin_point
        self._axis_vector = self._end_axis_point - self._origin_point
        # This is the vector that represents one unit of data space in terms of screen space.
        self._axis_pixel_vector = self._axis_vector/sqrt(dot(self._axis_vector,self._axis_vector))
        return


    def _calculate_geometry_overlay(self, overlay_component=None):
        if overlay_component is None:
            overlay_component = self
        component_origin = getattr(overlay_component, "origin", 'bottom left')

        screenhigh = self.mapper.high_pos
        screenlow = self.mapper.low_pos

        if self.orientation in ('top', 'bottom'):
            self._major_axis_size = overlay_component.bounds[0]
            self._minor_axis_size = overlay_component.bounds[1]
            self._major_axis = array([1., 0.])
            self._title_orientation = array([0.,1.])
            self.title_angle = 0.0
            if self.orientation == 'top':
                self._origin_point = array([overlay_component.x, overlay_component.y2])
                self._inside_vector = array([0.0, -1.0])
            else:
                self._origin_point = array([overlay_component.x, overlay_component.y])
                self._inside_vector = array([0.0, 1.0])
            if "right" in component_origin:
                screenlow, screenhigh = screenhigh, screenlow

        elif self.orientation in ('left', 'right'):
            self._major_axis_size = overlay_component.bounds[1]
            self._minor_axis_size = overlay_component.bounds[0]
            self._major_axis = array([0., 1.])
            self._title_orientation = array([-1., 0])
            if self.orientation == 'left':
                self._origin_point = array([overlay_component.x, overlay_component.y])
                self._inside_vector = array([1.0, 0.0])
                self.title_angle = 90.0
            else:
                self._origin_point = array([overlay_component.x2, overlay_component.y])
                self._inside_vector = array([-1.0, 0.0])
                self.title_angle = 270.0
            if "top" in component_origin:
                screenlow, screenhigh = screenhigh, screenlow

        if self.ensure_ticks_bounded:
            self._origin_point -= self._inside_vector*self.tick_in

        self._end_axis_point = abs(screenhigh-screenlow)*self._major_axis + self._origin_point
        self._axis_vector = self._end_axis_point - self._origin_point
        # This is the vector that represents one unit of data space in terms of screen space.
        self._axis_pixel_vector = self._axis_vector/sqrt(dot(self._axis_vector,self._axis_vector))
        return


    #------------------------------------------------------------------------
    # Event handlers
    #------------------------------------------------------------------------

    def _bounds_changed(self, old, new):
        super(PlotAxis, self)._bounds_changed(old, new)
        self._layout_needed = True
        self._invalidate()

    def _bounds_items_changed(self, event):
        super(PlotAxis, self)._bounds_items_changed(event)
        self._layout_needed = True
        self._invalidate()

    def _mapper_changed(self, old, new):
        if old is not None:
            old.on_trait_change(self.mapper_updated, "updated", remove=True)
        if new is not None:
            new.on_trait_change(self.mapper_updated, "updated")
        self._invalidate()

    def mapper_updated(self):
        """
        Event handler that is bound to this axis's mapper's **updated** event
        """
        self._invalidate()

    def _position_changed(self, old, new):
        super(PlotAxis, self)._position_changed(old, new)
        self._cache_valid = False

    def _position_items_changed(self, event):
        super(PlotAxis, self)._position_items_changed(event)
        self._cache_valid = False

    def _position_changed_for_component(self):
        self._cache_valid = False

    def _position_items_changed_for_component(self):
        self._cache_valid = False

    def _bounds_changed_for_component(self):
        self._cache_valid = False
        self._layout_needed = True

    def _bounds_items_changed_for_component(self):
        self._cache_valid = False
        self._layout_needed = True

    def _origin_changed_for_component(self):
        self._invalidate()

    def _updated_fired(self):
        """If the axis bounds changed, redraw."""
        self._cache_valid = False
        return

    def _invalidate(self):
        self._cache_valid = False
        self.invalidate_draw()
        if self.component:
            self.component.invalidate_draw()
        return

    def _component_changed(self):
        if self.mapper is not None:
            # If there is a mapper set, just leave it be.
            return

        # Try to pick the most appropriate mapper for our orientation
        # and what information we can glean from our component.
        attrmap = { "left": ("ymapper", "y_mapper", "value_mapper"),
                    "bottom": ("xmapper", "x_mapper", "index_mapper"), }
        attrmap["right"] = attrmap["left"]
        attrmap["top"] = attrmap["bottom"]

        component = self.component
        attr1, attr2, attr3 = attrmap[self.orientation]
        for attr in attrmap[self.orientation]:
            if hasattr(component, attr):
                self.mapper = getattr(component, attr)
                break

        # Keep our origin in sync with the component
        self.origin = getattr(component, 'origin', 'bottom left')
        return


    #------------------------------------------------------------------------
    # The following event handlers just invalidate our previously computed
    # Label instances and backbuffer if any of our visual attributes change.
    # TODO: refactor this stuff and the caching of contained objects (e.g. Label)
    #------------------------------------------------------------------------

    def _title_changed(self):
        self.invalidate_draw()
        if self.component:
            self.component.invalidate_draw()
        return

    def _anytrait_changed(self, name, old, new):
        """ For every trait that defines a visual attribute
            we just call _invalidate() when a change is made.
        """
        invalidate_traits = [
            'title_font',
            'title_spacing',
            'title_color',
            'tick_weight',
            'tick_color',
            'tick_label_font',
            'tick_label_color',
            'tick_label_rotate_angle',
            'tick_label_alignment',
            'tick_label_margin',
            'tick_label_offset',
            'tick_label_position',
            'tick_label_formatter',
            'tick_in',
            'tick_out',
            'tick_visible',
            'tick_interval',
            'tick_generator',
            'orientation',
            'origin',
            'axis_line_visible',
            'axis_line_color',
            'axis_line_weight',
            'axis_line_style',
            'small_haxis_style',
            'ensure_labels_bounded',
            'ensure_ticks_bounded',
        ]
        if name in invalidate_traits:
            self._invalidate()

    #------------------------------------------------------------------------
    # Persistence-related methods
    #------------------------------------------------------------------------

    def __getstate__(self):
        dont_pickle = [
            '_tick_list',
            '_tick_positions',
            '_tick_label_list',
            '_tick_label_positions',
            '_tick_label_bounding_boxes',
            '_major_axis_size',
            '_minor_axis_size',
            '_major_axis',
            '_title_orientation',
            '_title_angle',
            '_origin_point',
            '_inside_vector',
            '_axis_vector',
            '_axis_pixel_vector',
            '_end_axis_point',
            '_ticklabel_cache',
            '_cache_valid'
           ]

        state = super(PlotAxis,self).__getstate__()
        for key in dont_pickle:
            if state.has_key(key):
                del state[key]

        return state

    def __setstate__(self, state):
        super(PlotAxis,self).__setstate__(state)
        self._mapper_changed(None, self.mapper)
        self._reset_cache()
        self._cache_valid = False
        return


# EOF ########################################################################

########NEW FILE########
__FILENAME__ = axis_view
""" Defines the Traits UI view for a PlotAxis """

from traits.api import TraitError
from traitsui.api import View, HGroup, Group, VGroup, Item, TextEditor

def float_or_auto(val):
    """
    Validator function that returns *val* if *val* is either a number or
    the word 'auto'.  This is used as a validator for the text editor
    in the Traits UI for the **tick_interval** trait.
    """
    try:
        return float(val)
    except:
        if isinstance(val, basestring) and val == "auto":
            return val
    raise TraitError, "Tick interval must be a number or 'auto'."

# Traits UI for a PlotAxis.
AxisView = View(VGroup(
                Group(
                    Item("object.mapper.range.low", label="Low Range"),
                    Item("object.mapper.range.high", label="High Range"),
                    ),
                Group(
                    Item("title", label="Title", editor=TextEditor()),
                    Item("title_font", label="Font", style="simple"),
                    Item("title_color", label="Color", style="custom"),
                    Item("tick_interval", label="Interval", editor=TextEditor(evaluate=float_or_auto)),
                    label="Main"),
                Group(
                    Item("tick_color", label="Color", style="custom"),
                         #editor=EnableRGBAColorEditor()),
                    Item("tick_weight", label="Thickness"),
                    #Item("tick_label_font", label="Font"),
                    Item("tick_label_color", label="Label color", style="custom"),
                         #editor=EnableRGBAColorEditor()),
                    HGroup(
                        Item("tick_in", label="Tick in"),
                        Item("tick_out", label="Tick out"),
                        ),
                    Item("tick_visible", label="Visible"),
                    label="Ticks"),
                Group(
                    Item("axis_line_color", label="Color", style="custom"),
                         #editor=EnableRGBAColorEditor()),
                    Item("axis_line_weight", label="Thickness"),
                    Item("axis_line_visible", label="Visible"),
                    label="Line"),
                ),
                buttons = ["OK", "Cancel"]
            )


########NEW FILE########
__FILENAME__ = barplot
""" Defines the BarPlot class.
"""

from __future__ import with_statement

import logging

from numpy import array, compress, column_stack, invert, isnan, transpose, zeros
from traits.api import Any, Bool, Enum, Float, Instance, Property, \
        Range, Tuple, cached_property, on_trait_change
from enable.api import black_color_trait
from kiva.constants import FILL_STROKE

# Local relative imports
from chaco.abstract_plot_renderer import AbstractPlotRenderer
from abstract_mapper import AbstractMapper
from array_data_source import ArrayDataSource
from base import reverse_map_1d


logger = logging.getLogger(__name__)


# TODO: make child of BaseXYPlot

class BarPlot(AbstractPlotRenderer):
    """
    A renderer for bar charts.
    """
    # The data source to use for the index coordinate.
    index = Instance(ArrayDataSource)

    # The data source to use as value points.
    value = Instance(ArrayDataSource)

    # The data source to use as "starting" values for the bars.
    # For instance, if the values are [10, 20] and starting_value
    # is [3, 7], BarPlot will plot two bars, one  between 3 and 10, and
    # one between 7 and 20
    starting_value = Instance(ArrayDataSource)

    # Labels for the indices.
    index_mapper = Instance(AbstractMapper)
    # Labels for the values.
    value_mapper = Instance(AbstractMapper)

    # The orientation of the index axis.
    orientation = Enum("h", "v")

    # The direction of the index axis with respect to the graphics context's
    # direction.
    index_direction = Enum("normal", "flipped")

    # The direction of the value axis with respect to the graphics context's
    # direction.
    value_direction = Enum("normal", "flipped")

    # Type of width used for bars:
    #
    # 'data'
    #     The width is in the units along the x-dimension of the data space.
    # 'screen'
    #     The width uses a fixed width of pixels.
    bar_width_type = Enum("data", "screen")

    # Width of the bars, in data or screen space (determined by
    # **bar_width_type**).
    bar_width = Float(10)

    # Round on rectangle dimensions? This is not strictly an "antialias", but
    # it has the same effect through exact pixel drawing.
    antialias = Bool(True)

    # Width of the border of the bars.
    line_width = Float(1.0)
    # Color of the border of the bars.
    line_color = black_color_trait
    # Color to fill the bars.
    fill_color = black_color_trait

    # The RGBA tuple for rendering lines.  It is always a tuple of length 4.
    # It has the same RGB values as line_color_, and its alpha value is the
    # alpha value of self.line_color multiplied by self.alpha. 
    effective_line_color = Property(Tuple, depends_on=['line_color', 'alpha'])
    
    # The RGBA tuple for rendering the fill.  It is always a tuple of length 4.
    # It has the same RGB values as fill_color_, and its alpha value is the
    # alpha value of self.fill_color multiplied by self.alpha.   
    effective_fill_color = Property(Tuple, depends_on=['fill_color', 'alpha'])

    # Overall alpha value of the image. Ranges from 0.0 for transparent to 1.0
    alpha = Range(0.0, 1.0, 1.0)


    #use_draw_order = False

    # Convenience properties that correspond to either index_mapper or
    # value_mapper, depending on the orientation of the plot.

    # Corresponds to either **index_mapper** or **value_mapper**, depending on
    # the orientation of the plot.
    x_mapper = Property
    # Corresponds to either **value_mapper** or **index_mapper**, depending on
    # the orientation of the plot.
    y_mapper = Property

    # Corresponds to either **index_direction** or **value_direction**,
    # depending on the orientation of the plot.
    x_direction = Property
    # Corresponds to either **value_direction** or **index_direction**,
    # depending on the orientation of the plot
    y_direction = Property

    # Convenience property for accessing the index data range.
    index_range = Property
    # Convenience property for accessing the value data range.
    value_range = Property


    #------------------------------------------------------------------------
    # Private traits
    #------------------------------------------------------------------------

    # Indicates whether or not the data cache is valid
    _cache_valid = Bool(False)

    # Cached data values from the datasources.  If **bar_width_type** is "data",
    # then this is an Nx4 array of (bar_left, bar_right, start, end) for a
    # bar plot in normal orientation.  If **bar_width_type** is "screen", then
    # this is an Nx3 array of (bar_center, start, end).
    _cached_data_pts = Any


    #------------------------------------------------------------------------
    # AbstractPlotRenderer interface
    #------------------------------------------------------------------------

    def __init__(self, *args, **kw):
        # These Traits depend on others, so we'll defer setting them until
        # after the HasTraits initialization has been completed.
        later_list = ['index_direction', 'value_direction']
        postponed = {}
        for name in later_list:
            if name in kw:
                postponed[name] = kw.pop(name)

        super(BarPlot, self).__init__(*args, **kw)

        # Set any keyword Traits that were postponed.
        self.set(**postponed)


    def map_screen(self, data_array):
        """ Maps an array of data points into screen space and returns it as
        an array.

        Implements the AbstractPlotRenderer interface.
        """
        # data_array is Nx2 array
        if len(data_array) == 0:
            return []
        x_ary, y_ary = transpose(data_array)
        sx = self.index_mapper.map_screen(x_ary)
        sy = self.value_mapper.map_screen(y_ary)

        if self.orientation == "h":
            return transpose(array((sx,sy)))
        else:
            return transpose(array((sy,sx)))

    def map_data(self, screen_pt):
        """ Maps a screen space point into the "index" space of the plot.

        Implements the AbstractPlotRenderer interface.
        """
        if self.orientation == "h":
            screen_coord = screen_pt[0]
        else:
            screen_coord = screen_pt[1]
        return self.index_mapper.map_data(screen_coord)

    def map_index(self, screen_pt, threshold=2.0, outside_returns_none=True,
                  index_only=False):
        """ Maps a screen space point to an index into the plot's index array(s).

        Implements the AbstractPlotRenderer interface.
        """
        data_pt = self.map_data(screen_pt)
        if ((data_pt < self.index_mapper.range.low) or \
            (data_pt > self.index_mapper.range.high)) and outside_returns_none:
            return None
        index_data = self.index.get_data()
        value_data = self.value.get_data()

        if len(value_data) == 0 or len(index_data) == 0:
            return None

        try:
            ndx = reverse_map_1d(index_data, data_pt, self.index.sort_order)
        except IndexError:
            return None

        x = index_data[ndx]
        y = value_data[ndx]

        result = self.map_screen(array([[x,y]]))
        if result is None:
            return None

        sx, sy = result[0]
        if index_only and ((screen_pt[0]-sx) < threshold):
            return ndx
        elif ((screen_pt[0]-sx)**2 + (screen_pt[1]-sy)**2 < threshold*threshold):
            return ndx
        else:
            return None

    #------------------------------------------------------------------------
    # PlotComponent interface
    #------------------------------------------------------------------------

    def _gather_points(self):
        """ Collects data points that are within the range of the plot, and
        caches them in **_cached_data_pts**.
        """
        index, index_mask = self.index.get_data_mask()
        value, value_mask = self.value.get_data_mask()

        if not self.index or not self.value:
            return

        if len(index) == 0 or len(value) == 0 or len(index) != len(value):
            logger.warn("Chaco: using empty dataset; index_len=%d, value_len=%d." \
                                % (len(index), len(value)))
            self._cached_data_pts = array([])
            self._cache_valid = True
            return

        # TODO: Until we code up a better handling of value-based culling that
        # takes into account starting_value and dataspace bar widths, just use
        # the index culling for now.
#        value_range_mask = self.value_mapper.range.mask_data(value)
#        nan_mask = invert(isnan(index_mask)) & invert(isnan(value_mask))
#        point_mask = index_mask & value_mask & nan_mask & \
#                     index_range_mask & value_range_mask

        index_range_mask = self.index_mapper.range.mask_data(index)
        nan_mask = invert(isnan(index_mask))
        point_mask = index_mask & nan_mask & index_range_mask

        if self.starting_value is None:
            starting_values = zeros(len(index))
        else:
            starting_values = self.starting_value.get_data()

        if self.bar_width_type == "data":
            half_width = self.bar_width / 2.0
            points = column_stack((index-half_width, index+half_width,
                                   starting_values, value))
        else:
            points = column_stack((index, starting_values, value))
        self._cached_data_pts = compress(point_mask, points, axis=0)

        self._cache_valid = True
        return

    def _draw_plot(self, gc, view_bounds=None, mode="normal"):
        """ Draws the 'plot' layer.
        """
        if not self._cache_valid:
            self._gather_points()

        data = self._cached_data_pts
        if data.size == 0:
            # Nothing to draw.
            return

        with gc:
            gc.clip_to_rect(self.x, self.y, self.width, self.height)
            gc.set_antialias(self.antialias)
            gc.set_stroke_color(self.effective_line_color)
            gc.set_fill_color(self.effective_fill_color)
            gc.set_line_width(self.line_width)

            if self.bar_width_type == "data":
                # map the bar start and stop locations into screen space
                lower_left_pts = self.map_screen(data[:,(0,2)])
                upper_right_pts = self.map_screen(data[:,(1,3)])
            else:
                half_width = self.bar_width / 2.0
                # map the bar centers into screen space and then compute the bar
                # start and end positions
                lower_left_pts = self.map_screen(data[:,(0,1)])
                upper_right_pts = self.map_screen(data[:,(0,2)])
                lower_left_pts[:,0] -= half_width
                upper_right_pts[:,0] += half_width

            bounds = upper_right_pts - lower_left_pts
            gc.rects(column_stack((lower_left_pts, bounds)))
            gc.draw_path()


    def _draw_default_axes(self, gc):
        if not self.origin_axis_visible:
            return

        with gc:
            gc.set_stroke_color(self.origin_axis_color_)
            gc.set_line_width(self.origin_axis_width)
            gc.set_line_dash(None)

            for range in (self.index_mapper.range, self.value_mapper.range):
                if (range.low < 0) and (range.high > 0):
                    if range == self.index_mapper.range:
                        dual = self.value_mapper.range
                        data_pts = array([[0.0,dual.low], [0.0, dual.high]])
                    else:
                        dual = self.index_mapper.range
                        data_pts = array([[dual.low,0.0], [dual.high,0.0]])
                    start,end = self.map_screen(data_pts)
                    gc.move_to(int(start[0])+0.5, int(start[1])+0.5)
                    gc.line_to(int(end[0])+0.5, int(end[1])+0.5)
                    gc.stroke_path()

        return

    def _render_icon(self, gc, x, y, width, height):
        with gc:
            gc.set_fill_color(self.effective_fill_color)
            gc.set_stroke_color(self.effective_line_color)
            gc.rect(x+width/4, y+height/4, width/2, height/2)
            gc.draw_path(FILL_STROKE)

    def _post_load(self):
        super(BarPlot, self)._post_load()
        return


    #------------------------------------------------------------------------
    # Properties
    #------------------------------------------------------------------------

    def _get_index_range(self):
        return self.index_mapper.range

    def _set_index_range(self, val):
        self.index_mapper.range = val

    def _get_value_range(self):
        return self.value_mapper.range

    def _set_value_range(self, val):
        self.value_mapper.range = val

    def _get_x_mapper(self):
        if self.orientation == "h":
            return self.index_mapper
        else:
            return self.value_mapper

    def _get_y_mapper(self):
        if self.orientation == "h":
            return self.value_mapper
        else:
            return self.index_mapper

    def _get_x_direction(self):
        if self.orientation == "h":
            return self.index_direction
        else:
            return self.value_direction

    def _get_y_direction(self):
        if self.orientation == "h":
            return self.value_direction
        else:
            return self.index_direction

    #------------------------------------------------------------------------
    # Event handlers - these are mostly copied from BaseXYPlot
    #------------------------------------------------------------------------

    def _update_mappers(self):
        """ Updates the index and value mappers. Called by trait change handlers
        for various traits.
        """
        x_mapper = self.index_mapper
        y_mapper = self.value_mapper
        x_dir = self.index_direction
        y_dir = self.value_direction

        if self.orientation == "v":
            x_mapper, y_mapper = y_mapper, x_mapper
            x_dir, y_dir = y_dir, x_dir

        x = self.x
        x2 = self.x2
        y = self.y
        y2 = self.y2

        if x_mapper is not None:
            if x_dir =="normal":
                x_mapper.low_pos = x
                x_mapper.high_pos = x2
            else:
                x_mapper.low_pos = x2
                x_mapper.high_pos = x

        if y_mapper is not None:
            if y_dir == "normal":
                y_mapper.low_pos = y
                y_mapper.high_pos = y2
            else:
                y_mapper.low_pos = y2
                y_mapper.high_pos = y

        self.invalidate_draw()
        self._cache_valid = False

    @on_trait_change('line_color, line_width, fill_color, alpha')
    def _attributes_changed(self):
        self.invalidate_draw()
        self.request_redraw()

    def _bounds_changed(self, old, new):
        super(BarPlot, self)._bounds_changed(old, new)
        self._update_mappers()

    def _bounds_items_changed(self, event):
        super(BarPlot, self)._bounds_items_changed(event)
        self._update_mappers()

    def _orientation_changed(self):
        self._update_mappers()

    def _index_changed(self, old, new):
        if old is not None:
            old.on_trait_change(self._either_data_changed, "data_changed", remove=True)
        if new is not None:
            new.on_trait_change(self._either_data_changed, "data_changed")
        self._either_data_changed()

    def _index_direction_changed(self):
        m = self.index_mapper
        m.low_pos, m.high_pos = m.high_pos, m.low_pos
        self.invalidate_draw()

    def _value_direction_changed(self):
        m = self.value_mapper
        m.low_pos, m.high_pos = m.high_pos, m.low_pos
        self.invalidate_draw()

    def _either_data_changed(self):
        self.invalidate_draw()
        self._cache_valid = False
        self.request_redraw()

    def _value_changed(self, old, new):
        if old is not None:
            old.on_trait_change(self._either_data_changed, "data_changed", remove=True)
        if new is not None:
            new.on_trait_change(self._either_data_changed, "data_changed")
        self._either_data_changed()

    def _index_mapper_changed(self, old, new):
        return self._either_mapper_changed(old, new)

    def _value_mapper_changed(self, old, new):
        return self._either_mapper_changed(old, new)

    def _either_mapper_changed(self, old, new):
        if old is not None:
            old.on_trait_change(self._mapper_updated_handler, "updated", remove=True)
        if new is not None:
            new.on_trait_change(self._mapper_updated_handler, "updated")
        self.invalidate_draw()

    def _mapper_updated_handler(self):
        self._cache_valid = False
        self.invalidate_draw()
        self.request_redraw()

    def _bar_width_changed(self):
        self._cache_valid = False
        self.invalidate_draw()
        self.request_redraw()

    def _bar_width_type_changed(self):
        self._cache_valid = False
        self.invalidate_draw()
        self.request_redraw()

    #------------------------------------------------------------------------
    # Property getters
    #------------------------------------------------------------------------

    @cached_property
    def _get_effective_line_color(self):
        if len(self.line_color_) == 4:
            line_alpha = self.line_color_[-1]
        else:
            line_alpha = 1.0
        c = self.line_color_[:3] + (line_alpha * self.alpha,)
        return c

    @cached_property
    def _get_effective_fill_color(self):
        if len(self.fill_color_) == 4:
            fill_alpha = self.fill_color_[-1]
        else:
            fill_alpha = 1.0
        c = self.fill_color_[:3] + (fill_alpha * self.alpha,)
        return c


### EOF ####################################################################

########NEW FILE########
__FILENAME__ = base
"""
Defines basic traits and functions for the data model.
"""

# Standard library imports
from math import radians, sqrt

# Major library imports
from numpy import (array, argsort, concatenate, cos, dot, empty, nonzero,
    pi, sin, take, ndarray)

# Enthought library imports
from traits.api import CArray, Enum, Trait



# Dimensions

# A single array of numbers.
NumericalSequenceTrait = Trait(None, None, CArray(value=empty(0)))

# A sequence of pairs of numbers, i.e., an Nx2 array.
PointTrait = Trait(None, None, CArray(value=empty(0)))

# An NxM array of numbers.
ImageTrait = Trait(None, None, CArray(value=empty(0)))

# An 3D array of numbers of shape (Nx, Ny, Nz)
CubeTrait = Trait(None, None, CArray(value=empty(0)))


# This enumeration lists the fundamental mathematical coordinate types that
# Chaco supports.
DimensionTrait = Enum("scalar", "point", "image", "cube")

# Linear sort order.
SortOrderTrait = Enum("ascending", "descending", "none")


#----------------------------------------------------------------------------
# Utility functions
#----------------------------------------------------------------------------

def poly_point(center, r, degrees):
    x = r * cos(degrees) + center[0]
    y = r * sin(degrees) + center[1]
    return x,y

def n_gon(center, r, nsides, rot_degrees=0):
    """ Generates the points of a regular polygon with specified center,
    radius, and number of sides.

    By default the rightmost point of the polygon is (*r*,0) but a
    rotation about the center may be specified with *rot_degrees*.
    """
    if nsides < 3:
        raise ValueError, 'Must have at least 3 sides in a polygon'
    rotation = radians(rot_degrees)
    theta = (pi * 2) / nsides
    return [poly_point(center, r, i*theta+rotation) for i in range(nsides)]


# Ripped from Chaco 1.0's plot_base.py
def bin_search(values, value, ascending):
    """
    Performs a binary search of a sorted array looking for a specified value.

    Returns the lowest position where the value can be found or where the
    array value is the last value less (greater) than the desired value.
    Returns -1 if *value* is beyond the minimum or maximum of *values*.
    """
    if ascending > 0:
        if (value < values[0]) or (value > values[-1]):
            return -1
    else:
        if (value < values[-1]) or (value > values[0]):
            return -1
    lo = 0
    hi = len( values )
    while True:
        mid  = (hi + lo) / 2
        test = cmp( values[ mid ], value ) * ascending
        if test == 0:
            return mid
        if test > 0:
            hi = mid
        else:
            lo = mid
        if lo >= (hi - 1):
            return lo

def reverse_map_1d(data, pt, sort_order, floor_only=False):
    """Returns the index of *pt* in the array *data*.

    Raises IndexError if *pt* is outside the range of values in *data*.

    Parameters
    ----------
    data : 1-D array
        data to search

    pt : scalar value
        value to find, which must be within the value range of *data*

    sort_order : string
        "ascending" or "descending"

    floor_only : bool
        if true, don't find "nearest" point, instead find last point
        less (greater) than pt
    """
    if sort_order == "ascending":
        ndx = bin_search(data, pt, 1)
    elif sort_order == "descending":
        ndx = bin_search(data, pt, -1)
    else:
        raise NotImplementedError, "reverse_map_1d() requires a sorted array"

    if ndx == -1:
        raise IndexError, "value outside array data range"


    # Now round the index to the closest matching index.  Do this
    # by determining the width (in value space) of each cell and
    # figuring out which side of the midpoint pt falls into.  Since
    # bin_search rounds down (i.e. each cell index contains the point
    # and all points up to the next cell index), we only need to look
    # at ndx+1 and not ndx-1 as well.
    last = len(data) - 1
    if ndx < last:
        if floor_only:
            return ndx
        delta = 0.5 * (data[ndx+1] - data[ndx])
        if ((sort_order == "ascending") and (pt > data[ndx] + delta)) or \
           ((sort_order == "descending") and (pt < data[ndx] + delta)):
            return ndx + 1
        else:
            return ndx
    else:
        # NB: OK floor_only is typically used with image plots, which
        # will have one extra "fencepost" so the assumption here is that
        # if we hit the last point exactly we still really want the index
        # of the previous point
        if floor_only:
            return last-1
        # If pt happened to match the value of data[last] exactly,
        # we just return it here.
        return last

# These are taken from Chaco 1.0's datamapper and subdivision_cells modules.
# TODO: Write unit tests for these!
def right_shift(ary, newval):
    "Returns a right-shifted version of *ary* with *newval* inserted on the left."
    return concatenate([[newval], ary[:-1]])

def left_shift(ary, newval):
    "Returns a left-shifted version of *ary* with *newval* inserted on the right."
    return concatenate([ary[1:], [newval]])

def sort_points(points, index=0):
    """
    sort_points(array_of_points, index=<0|1>) -> sorted_array

    Takes a list of points as an Nx2 array and sorts them according
    to their x- or y-coordinate.  If *index* is zero, the points are sorted
    on their x-coordinate.
    """
    if len(points.shape) != 2 or (2 not in points.shape):
        raise RuntimeError, "sort_points(): Array of wrong shape."
    return take( points, argsort(points[:,index]) )

def find_runs(int_array, order='ascending'):
    """
    find_runs(int_array, order=<'ascending'|'flat'|'descending'>) -> list_of_int_arrays

    Given an integer array sorted in ascending/descending order or flat order,
    returns a list of continuous runs of integers inside the list.  for example::

        find_runs([1,2,3,6,7,8,9,10,11,15])

    returns [ [1,2,3], [6,7,8,9,10,11], [15] ]
    and::

        find_runs([0,0,0,1,1,1,1,0,0,0,0], "flat")

    return [ [0,0,0], [1,1,1,1], [0,0,0,0] ]
    """
    ranges = arg_find_runs(int_array, order)
    if ranges:
        return [int_array[i:j] for (i,j) in ranges]
    else:
        return []

def arg_find_runs(int_array, order='ascending'):
    """
    Like find_runs(), but returns a list of tuples indicating the start and
    end indices of runs in the input *int_array*.
    """
    if len(int_array) == 0:
        return []
    assert len(int_array.shape)==1, "find_runs() requires a 1D integer array."
    if order == 'ascending':
        increment = 1
    elif order == 'descending':
        increment = -1
    else:
        increment = 0
    rshifted = right_shift(int_array, int_array[0]-increment).view(ndarray)
    start_indices = concatenate([[0], nonzero(int_array - (rshifted+increment))[0]])
    end_indices = left_shift(start_indices, len(int_array))
    return zip(start_indices, end_indices)


def point_line_distance(pt, p1, p2):
    """ Returns the perpendicular distance between *pt* and the line segment
    between the points *p1* and *p2*.
    """
    v1 = array((pt[0] - p1[0], pt[1] - p1[1]))
    v2 = array((p2[0] - p1[0], p2[1] - p1[1]))
    diff = v1 - dot(v1, v2) / dot(v2, v2) * v2

    return sqrt(dot(diff,diff))


#EOF

########NEW FILE########
__FILENAME__ = base_1d_mapper
""" Defines the Base1DMapper class.
"""
# Enthought library imports
from traits.api import Bool, Instance, Float, Property

# Local relative imports
from abstract_mapper import AbstractMapper
from data_range_1d import DataRange1D


class Base1DMapper(AbstractMapper):
    """ Defines an abstract mapping from a 1-D region in input space to a 1-D
    region in output space.
    """

    # The data-space bounds of the mapper.
    range = Instance(DataRange1D)

    # The screen space position of the lower bound of the data space.
    low_pos = Float(0.0)

    # The screen space position of the upper bound of the data space.
    high_pos  = Float(1.0)

    # Convenience property to get low and high positions in one structure.
    # Must be a tuple (low_pos, high_pos).
    screen_bounds = Property

    # Should the mapper stretch the dataspace when its screen space bounds are
    # modified (default), or should it preserve the screen-to-data ratio and
    # resize the data bounds?  If the latter, it will only try to preserve
    # the ratio if both screen and data space extents are non-zero.
    stretch_data = Bool(True)

    # The sign of the mapping: 1 if deltas match sign, -1 if opposite sign
    sign = Property

    # If the subclass uses a cache, _cache_valid is maintained to
    # monitor its status
    _cache_valid = Bool(False)

    # Indicates whether or not the bounds have been set at all, or if they
    # are at their initial default values.
    _bounds_initialized = Bool(False)

    #------------------------------------------------------------------------
    # Event handlers
    #------------------------------------------------------------------------

    def _low_pos_changed(self):
        self._cache_valid = False
        self.updated = True
        return

    def _high_pos_changed(self):
        self._cache_valid = False
        self.updated = True
        return

    def _range_changed(self, old, new):
        if old is not None:
            old.on_trait_change(self._range_change_handler, "updated",
                                remove = True)
        if new is not None:
            new.on_trait_change(self._range_change_handler, "updated")

        self._cache_valid = False
        self.updated = new
        return

    def _range_change_handler(self, obj, name, new):
        "Handles the range changing; dynamically attached to our ranges"
        self._cache_valid = False
        self.updated = obj
        return

    def _get_screen_bounds(self):
        return (self.low_pos, self.high_pos)

    def _get_sign(self):
        delta_screen = (self.high_pos - self.low_pos)
        delta_data = (self.range.high-self.range.low)
        if delta_screen == 0 or delta_data == 0:
            return 0
        elif delta_screen/float(delta_data) < 0:
            return -1
        else:
            return 1

    def _set_screen_bounds(self, new_bounds):
        if new_bounds[0] == self.low_pos and new_bounds[1] == self.high_pos:
            return
        if not self.stretch_data and self.range is not None and self._bounds_initialized:
            rangelow = self.range.low
            rangehigh = self.range.high
            d_data = rangehigh - rangelow
            d_screen = self.high_pos - self.low_pos
            if d_data != 0 and d_screen != 0:
                new_data_extent = d_data / d_screen * abs(new_bounds[1] - new_bounds[0])
                self.range.set_bounds(rangelow, rangelow + new_data_extent)
        self.set(low_pos = new_bounds[0], trait_change_notify=False)
        self.set(high_pos = new_bounds[1], trait_change_notify=False)
        self._cache_valid = False
        self._bounds_initialized = True
        self.updated = True
        return


########NEW FILE########
__FILENAME__ = base_2d_plot
""" Defines the base class for 2-D plots.
"""
# Standard library imports
from numpy import asarray, isnan

# Enthought library imports.
from traits.api import Enum, Event, Instance, Property, Range, Trait

# Local relative imports
from abstract_plot_renderer import AbstractPlotRenderer
from base import reverse_map_1d
from plot_label import PlotLabel
from grid_data_source import GridDataSource
from grid_mapper import GridMapper
from image_data import ImageData


class Base2DPlot(AbstractPlotRenderer):
    """ Base class for 2-D plots.
    """
    #------------------------------------------------------------------------
    # Data-related traits
    #------------------------------------------------------------------------

    # The data source to use for the index coordinate.
    index = Instance(GridDataSource)

    # The data source to use as value points.
    value = Instance(ImageData)

    # Screen mapper for 2-D structured (gridded) index data.
    index_mapper = Instance(GridMapper)

    # Convenience property for accessing the data range of the mapper.
    index_range = Property

    # Convenience property for accessing the plots labels.
    labels = Property

    # The direction that the first array returned by self.index.get_data()
    # maps to.
    #
    # * 'h': index maps to x-direction
    # * 'v': index maps to y-direction
    orientation = Enum("h", "v")

    # Overrides PlotComponent; 2-D plots draw on the 'image' layer,
    # underneath all decorations and annotations, and above only the background
    # fill color.
    draw_layer = "image"

    # Convenience property for accessing the x-direction mappers regardless
    # of orientation.  This provides compatibility with a number of tools.
    x_mapper = Property
    # Convenience property for accessing the y-direction mappers regardless
    # of orientation.  This provides compatibility with a number of tools.
    y_mapper = Property

    # Overall alpha value of the image. Ranges from 0.0 for transparent to 1.0
    # for full intensity.
    alpha = Trait(1.0, Range(0.0, 1.0))

    # Event fired when the index data changes. Subclasses can listen for this
    # event and take appropriate steps (except for requesting a redraw, which
    # is done in this class).
    index_data_changed = Event

    # Event fired when the index mapper changes. Subclasses can listen for this
    # event and take appropriate steps (except for requesting a redraw, which
    # is done in this class).
    index_mapper_changed = Event

    # Event fired when the value data changes. Subclasses can listen for this
    # event and take appropriate steps (except for requesting a redraw, which
    # is done in this class).
    value_data_changed = Event

    #------------------------------------------------------------------------
    # Public methods
    #------------------------------------------------------------------------

    def __init__(self, **kwargs):
        # Handling the setting/initialization of these traits manually because
        # they should be initialized in a certain order.
        kwargs_tmp = {"trait_change_notify": False}
        for trait_name in ("index", "value"):
            if trait_name in kwargs:
                kwargs_tmp[trait_name] = kwargs.pop(trait_name)
        self.set(**kwargs_tmp)
        super(Base2DPlot, self).__init__(**kwargs)
        if self.index is not None:
            self.index.on_trait_change(self._update_index_data,
                                       "data_changed")
        if self.index_mapper:
            self.index_mapper.on_trait_change(self._update_index_mapper,
                                              "updated")
        if self.value is not None:
            self.value.on_trait_change(self._update_value_data,
                                       "data_changed")
        # If we are not resizable, we will not get a bounds update upon layout,
        # so we have to manually update our mappers
        if self.resizable == "":
            self._update_mappers()
        return

    #------------------------------------------------------------------------
    # AbstractPlotRenderer interface
    #------------------------------------------------------------------------

    def map_screen(self, data_pts):
        """ Maps an array of data points into screen space and returns it as
        an array.

        Implements the AbstractPlotRenderer interface.
        """
        # data_pts is Nx2 array
        if len(data_pts) == 0:
            return []
        return asarray(self.index_mapper.map_screen(data_pts))

    def map_data(self, screen_pts):
        """ Maps a screen space point into the "index" space of the plot.

        Implements the AbstractPlotRenderer interface.
        """
        return self.index_mapper.map_data(screen_pts)

    def map_index(self, screen_pt, threshold=2.0,
                  outside_returns_none=True, index_only=False):
        """ Maps a screen space point to an index into the plot's index arrays.

        Implements the AbstractPlotRenderer interface.
        The *index_only* parameter is ignored because the index is
        intrinsically 2-D.
        """
        if self.orientation == 'h':
            x_pt,y_pt = self.map_data([screen_pt])[0]
        else:
            x_pt,y_pt = self.map_data([(screen_pt[1],screen_pt[0])])[0]

        if ((x_pt < self.index_mapper.range.low[0]) or
            (x_pt > self.index_mapper.range.high[0]) or
            (y_pt < self.index_mapper.range.low[1]) or
            (y_pt > self.index_mapper.range.high[1])) and outside_returns_none:
            return None, None

        x_index_data, y_index_data = self.index.get_data()

        if x_index_data.get_size() == 0 or y_index_data.get_size() == 0:
            return None, None

        # attempt to map to the x index
        x_data = x_index_data.get_data()
        y_data = y_index_data.get_data()
        try:
            x_ndx = reverse_map_1d(x_data, x_pt, self.index.sort_order[0],
                                   floor_only=True)
        except IndexError, e:
            if outside_returns_none:
                return None, None

            # x index
            if x_pt < x_data[0]:
                x_ndx =  0
            else:
                x_ndx = len(x_data) - 1

        try:
            y_ndx = reverse_map_1d(y_data, y_pt, self.index.sort_order[1],
                                   floor_only=True)
        except IndexError, e:
            if outside_returns_none:
                return None, None

            # y index
            if y_pt < y_data[0]:
                y_ndx =  0
            else:
                y_ndx = len(y_data) - 1

        if threshold == 0:
            return x_ndx, y_ndx

        x = x_data[x_ndx]
        y = y_data[y_ndx]
        if isnan(x) or isnan(y):
            return None, None

        sx, sy =  self.map_screen([(x,y)])[0]
        if ((screen_pt[0]-sx)**2 + (screen_pt[1]-sy)**2 < threshold**2):
            return x_ndx, y_ndx
        else:
            return None, None

    #------------------------------------------------------------------------
    # PlotComponent interface
    #------------------------------------------------------------------------

    def _draw_image(self, gc, view_bounds=None, mode="normal"):
        """ Handler for drawing the 'image' layer.

        Used by the PlotComponent interface.
        """
        self._render(gc)
        return

    #------------------------------------------------------------------------
    # Abstract methods that subclasses must implement
    #------------------------------------------------------------------------

    def _render(self, gc, points):
        """ Abstract method for drawing the plot.
        """
        raise NotImplementedError

    #------------------------------------------------------------------------
    # Properties
    #------------------------------------------------------------------------

    def _get_index_range(self):
        return self.index_mapper.range

    def _set_index_range(self, val):
        self.index_mapper.range = val

    def _get_labels(self):
        labels = []
        for obj in self.underlays+self.overlays:
            if isinstance(obj, PlotLabel):
                labels.append(obj)
        return labels

    def _get_x_mapper(self):
        if self.orientation == 'h':
            return self.index_mapper._xmapper
        else:
            return self.index_mapper._ymapper

    def _get_y_mapper(self):
        if self.orientation == 'h':
            return self.index_mapper._ymapper
        else:
            return self.index_mapper._xmapper


    #------------------------------------------------------------------------
    # Private methods
    #------------------------------------------------------------------------

    def _update_index_mapper(self):
        """ Updates the index mapper.

        Called by various trait change handlers.
        """

        x = self.x
        x2 = self.x2
        y = self.y
        y2 = self.y2

        if "left" in self.origin:
            x_low = x
            x_high = x2
        else:
            x_low = x2
            x_high = x

        if "bottom" in self.origin:
            y_low = y
            y_high = y2
        else:
            y_low = y2
            y_high = y

        if self.index_mapper is not None:
            if self.orientation == 'h':
                self.index_mapper.screen_bounds = (x_low, x_high, y_low, y_high)
            else:
                self.index_mapper.screen_bounds = (y_low, y_high, x_low, x_high)
            self.index_mapper_changed = True
            self.invalidate_draw()

    def _update_index_data(self):
        """ Updates the index data.

        Called by various trait change handlers.
        """
        self.index_data_changed = True
        self.invalidate_draw()

    def _update_value_data(self):
        """ Updates the value data.

        Called by various trait change handlers.
        """
        self.value_data_changed = True
        self.invalidate_draw()


    #------------------------------------------------------------------------
    # Event handlers
    #------------------------------------------------------------------------

    def _bounds_changed(self, old, new):
        super(Base2DPlot, self)._bounds_changed(old, new)
        self._update_index_mapper()

    def _bounds_items_changed(self, event):
        super(Base2DPlot, self)._bounds_items_changed(event)
        self._update_index_mapper()

    def _orientation_changed(self):
        self._update_index_mapper()

    def _origin_changed(self):
        self._update_index_mapper()

    def _index_changed(self, old, new):
        if old is not None:
            old.on_trait_change(self._update_index_data,
                                "data_changed", remove=True)
        if new is not None:
            new.on_trait_change(self._update_index_data, "data_changed")
        self._update_index_data()

    def _value_changed(self, old, new):
        if old is not None:
            old.on_trait_change(self._update_value_data,
                                "data_changed", remove=True)
        if new is not None:
            new.on_trait_change(self._update_value_data, "data_changed")
        self._update_value_data()

    def _index_mapper_changed(self, old, new):
        if old is not None:
            old.on_trait_change(self._update_index_mapper,
                                "updated", remove=True)
        if new is not None:
            new.on_trait_change(self._update_index_mapper, "updated")
        self._update_index_mapper()


########NEW FILE########
__FILENAME__ = base_candle_plot

from __future__ import with_statement

# Major library imports
from numpy import array, column_stack

# Enthought library imports
from enable.api import ColorTrait
from traits.api import Bool, Float, Int, List, Property, Trait

# Chaco imports
from base_xy_plot import BaseXYPlot

# TODO: allow to set the width of the bar

def Alias(name):
    return Property(lambda obj: getattr(obj, name),
                    lambda obj, val: setattr(obj, name, val))

class BaseCandlePlot(BaseXYPlot):
    """ Represents the base class for candle- and bar-type plots that are
    multi-valued at each index point, and optionally have an extent in the
    index dimension.

    Implements the rendering logic and centralizes a lot of the visual
    attributes for these sorts of plots.  The gather and culling and
    clipping of data is up to individual subclasses.
    """

    #------------------------------------------------------------------------
    # Appearance traits
    #------------------------------------------------------------------------

    # The fill color of the marker.
    color = ColorTrait("black")

    # The fill color of the bar
    bar_color = Alias("color")

    # The color of the rectangular box forming the bar.
    bar_line_color = Alias("outline_color")

    # The color of the stems reaching from the bar ends to the min and max
    # values.  Also the color of the endcap line segments at min and max.  If
    # None, this defaults to **bar_line_color**.
    stem_color = Trait(None, None, ColorTrait("black"))

    # The color of the line drawn across the bar at the center values.
    # If None, this defaults to **bar_line_color**.
    center_color = Trait(None, None, ColorTrait("black"))

    # The color of the outline to draw around the bar.
    outline_color = ColorTrait("black")

    # The thickness, in pixels, of the outline to draw around the bar.  If
    # this is 0, no outline is drawn.
    line_width = Float(1.0)

    # The thickness, in pixels, of the stem lines.  If None, this defaults
    # to **line_width**.
    stem_width = Trait(None, None, Int(1))

    # The thickeness, in pixels, of the line drawn across the bar at the
    # center values.  If None, this defaults to **line_width**.
    center_width = Trait(None, None, Int(1))

    # Whether or not to draw bars at the min and max extents of the error bar
    end_cap = Bool(True)

    #------------------------------------------------------------------------
    # Private traits
    #------------------------------------------------------------------------

    # Override the base class definition of this because we store a list of
    # arrays and not a single array.
    _cached_data_pts = List()

    #------------------------------------------------------------------------
    # BaseXYPlot interface
    #------------------------------------------------------------------------

    def get_screen_points(self):
        # Override the BaseXYPlot implementation so that this is just
        # a pass-through, in case anyone calls it.
        pass

    #------------------------------------------------------------------------
    # Protected methods (subclasses should be able to use these directly
    # or wrap them)
    #------------------------------------------------------------------------

    def _render(self, gc, right, left, min, bar_min, center, bar_max, max):
        stack = column_stack

        with gc:
            widths = right - left
            bar_vert_center = left + widths / 2.0

            # Draw the stem lines for min to max.  Draw these first so we can
            # draw the boxes on top.
            # A little tricky: we need to account for cases when either min or max
            # are None.  To do this, just draw to bar_min or from bar_max instead
            # of drawing a single line from min to max.
            if min is not None or max is not None:
                if self.stem_color is None:
                    stem_color = self.outline_color_
                else:
                    stem_color = self.stem_color_
                gc.set_stroke_color(stem_color)

                if self.stem_width is None:
                    stem_width = self.line_width
                else:
                    stem_width = self.stem_width
                gc.set_line_width(stem_width)

                if min is None:
                    gc.line_set(stack((bar_vert_center, bar_max)), stack((bar_vert_center, max)))
                    if self.end_cap:
                        gc.line_set(stack((left, max)), stack((right, max)))
                elif max is None:
                    gc.line_set(stack((bar_vert_center, min)), stack((bar_vert_center, bar_min)))
                    if self.end_cap:
                        gc.line_set(stack((left, min)), stack((right, min)))
                else:
                    gc.line_set(stack((bar_vert_center, min)), stack((bar_vert_center, max)))
                    if self.end_cap:
                        gc.line_set(stack((left, max)), stack((right, max)))
                        gc.line_set(stack((left, min)), stack((right, min)))
                gc.stroke_path()

            # Draw the candlestick boxes
            boxes = stack((left, bar_min, widths, bar_max - bar_min))
            gc.set_antialias(False)
            gc.set_stroke_color(self.outline_color_)
            gc.set_line_width(self.line_width)
            gc.rects(boxes)
            if self.color in ("none", "transparent", "clear"):
                gc.stroke_path()
            else:
                gc.set_fill_color(self.color_)
                gc.draw_path()

            # Draw the center line
            if center is not None:
                if self.center_color is None:
                    gc.set_stroke_color(self.outline_color_)
                else:
                    gc.set_stroke_color(self.center_color_)
                if self.center_width is None:
                    gc.set_line_width(self.line_width)
                else:
                    gc.set_line_width(self.center_width)
                gc.line_set(stack((left, center)), stack((right, center)))
                gc.stroke_path()

    def _render_icon(self, gc, x, y, width, height):
        min = array([y + 1])
        max = array([y + height - 1])
        bar_min = array([y + height / 3])
        bar_max = array([y + height - (height / 3)])
        center = array([y + (height / 2)])
        self._render(gc, array([x+width/4]), array([x+3*width/4]), min, bar_min, center, bar_max, max)





########NEW FILE########
__FILENAME__ = base_contour_plot

from numpy import array, isscalar, issubsctype, linspace, number

# Enthought library imports
from enable.api import ColorTrait
from traits.api import Bool, Instance, Int, List, Property, \
        Range, Str, Trait, Tuple

# Local relative imports
from base_2d_plot import Base2DPlot
from color_mapper import ColorMapper


class BaseContourPlot(Base2DPlot):
    """ The base class for contour plots.  Mostly manages configuration and
    change events with colormap and contour parameters.
    """

    #------------------------------------------------------------------------
    # Data-related traits
    #------------------------------------------------------------------------

    # Defines the levels to contour.
    # ``levels`` can be either: a list of floating point numbers that define
    # the value of the function at the contours; a positive integer, in which
    # case the range of the value is divided in the given number of equally
    # spaced levels; or "auto" (default), which divides the range in 10 levels
    levels = Trait("auto", Int, List)

    # The color(s) of the lines.
    # ``colors`` can be given as a color name, in which case all contours have
    # the same color, as a list of colors, or as a colormap. If the list of
    # colors is shorter than the number of levels, the values are repeated
    # from the beginning of the list. Default is black.
    # Colors are associated with levels of increasing value.
    colors = Trait(None, Str, Instance(ColorMapper), List, Tuple)

    # If present, the color mapper for the colorbar to look at.
    color_mapper = Property(Instance(ColorMapper))

    # A global alpha value to apply to all the contours
    alpha = Trait(1.0, Range(0.0, 1.0))

    #------------------------------------------------------------------------
    # Private traits
    #------------------------------------------------------------------------

    # Is the cached level data valid?
    _level_cache_valid = Bool(False)

    # Is the cached color data valid?
    _colors_cache_valid = Bool(False)

    # List of levels and their associated line properties.
    _levels = List

    # List of colors
    _colors = List

    # Mapped trait used to convert user-suppied color values to AGG-acceptable
    # ones. (Mapped traits in lists are not supported, must be converted one at
    # a time.)
    _color_map_trait = ColorTrait


    def __init__(self, *args, **kwargs):
        super(BaseContourPlot, self).__init__(*args, **kwargs)
        if self.color_mapper:
            self.color_mapper.on_trait_change(self._update_color_mapper, "updated")
        return

    def _update_levels(self):
        """ Updates the levels cache.  """
        low, high = self.value.get_bounds()
        if self.levels == "auto":
            self._levels = list(linspace(low, high, 10))
        elif isinstance(self.levels, int):
            self._levels = list(linspace(low, high, self.levels))
        else:
            self._levels = self.levels
            self._levels.sort()
        self._level_cache_valid = True
        self._colors_cache_valid = False

    def _update_colors(self, numcolors=None):
        """ Update the colors cache using our color mapper and based
        on our number of levels.  The **mode** parameter accounts for fenceposting:
          - If **mode** is "poly", then the number of colors to generate is 1
            less than the number of levels
          - If **mode** is "line", then the number of colors to generate is
            equal to the number of levels
        """
        if numcolors is None:
            numcolors = len(self._levels)

        colors = self.colors
        # If we are given no colors, set a default for all levels
        if colors is None:
            self._color_map_trait = "black"
            self._colors = [self._color_map_trait_] * numcolors

        # If we are given a single color, apply it to all levels
        elif isinstance(colors, basestring):
            self._color_map_trait = colors
            self._colors = [self._color_map_trait_] * numcolors

        # If we are given a colormap, use it to map all the levels to colors
        elif isinstance(colors, ColorMapper):
            self._colors =  []
            mapped_colors = self.color_mapper.map_screen(array(self._levels))
            for i in range(numcolors):
                self._color_map_trait = tuple(mapped_colors[i])
                self._colors.append(self._color_map_trait_)

        # A list or tuple
        # This could be a length 3 or 4 sequence of scalars, which indicates
        # a color; otherwise, this is interpreted as a list of items to
        # be converted via self._color_map_trait.
        else:
            if len(colors) in (3,4) and \
                    (isscalar(colors[0]) and issubsctype(type(colors[0]), number)):
                self._color_map_trait = colors
                self._colors = [self._color_map_trait_] * numcolors
            else:
                # if the list of colors is shorter than the list of levels, simply
                # repeat colors from the beginning of the list as needed
                self._colors = []
                for i in range(len(self._levels)):
                    self._color_map_trait = colors[i%len(colors)]
                    self._colors.append(self._color_map_trait_)

        self._colors_cache_valid = True
        return


    #------------------------------------------------------------------------
    # Event handlers
    #------------------------------------------------------------------------

    def _index_data_changed_fired(self):
        # If the index data has changed, the reset the levels cache (which
        # also triggers all the other caches to reset).
        self._level_cache_valid = False
        self.invalidate_draw()

    def _value_data_changed_fired(self):
        # If the index data has changed, the reset the levels cache (which
        # also triggers all the other caches to reset).
        self._level_cache_valid = False
        self.invalidate_draw()

    def _index_mapper_changed_fired(self):
        # If the index mapper has changed, then we need to redraw
        self.invalidate_draw()

    def _update_color_mapper(self):
        # If the color mapper has changed, then we need to recompute the
        # levels and cached data associated with that.
        self._level_cache_valid = False
        self.invalidate_draw()

    def _levels_changed(self):
        self._update_levels()
        self.invalidate_draw()
        self.request_redraw()

    def _colors_changed(self):
        if self._level_cache_valid:
            self._update_colors()
            self.invalidate_draw()

    #------------------------------------------------------------------------
    # Trait properties
    #------------------------------------------------------------------------

    def _get_color_mapper(self):
        if isinstance(self.colors, ColorMapper):
            return self.colors
        else:
            return None

    def _set_color_mapper(self, color_mapper):
        # Remove the dynamic event handler from the old color mapper
        if self.colors is not None and isinstance(self.colors, ColorMapper):
            self.colors.on_trait_change(self._update_color_mapper, "updated", remove=True)

            # Check to see if we should copy over the range as well
            if color_mapper is not None:
                if color_mapper.range is None and self.colors.range is not None:
                    color_mapper.range = self.colors.range

        # Attach the dynamic event handler to the new color mapper
        if color_mapper is not None:
            color_mapper.on_trait_change(self._update_color_mapper, "updated")

        self.colors = color_mapper
        self._update_color_mapper()

########NEW FILE########
__FILENAME__ = base_data_range
"""
Defines the BaseDataRange class.
"""

# Local relative imports
from abstract_data_range import AbstractDataRange


class BaseDataRange(AbstractDataRange):
    """ Ranges represent sub-regions of data space.

    They support "autoscaling" by querying their associated data sources.
    """

    #------------------------------------------------------------------------
    # Public methods
    #------------------------------------------------------------------------

    def __init__(self, *datasources, **kwtraits):
        super(AbstractDataRange, self).__init__(**kwtraits)
        if len(datasources) > 0:
            self.sources.extend(datasources)

    def add(self, *datasources):
        """ Convenience method to add a data source. """
        for datasource in datasources:
            if datasource not in self.sources:
                self.sources.append(datasource)

    def remove(self, *datasources):
        """ Convenience method to remove a data source. """
        for datasource in datasources:
            if datasource in self.sources:
                self.sources.remove(datasource)




########NEW FILE########
__FILENAME__ = base_plot_container
""" Defines the BasePlotContainer class.
"""
import warnings

# Enthought library imports
from enable.api import Container
from traits.api import Bool, Instance, Property, Str, Tuple

# Local, relative imports
from plot_component import DEFAULT_DRAWING_ORDER, PlotComponent


class BasePlotContainer(Container):
    """
    A container for PlotComponents that conforms to being laid out by
    PlotFrames.  Serves as the base class for other PlotContainers.

    PlotContainers define a layout, i.e., a spatial relationship between
    their contained components.  (BasePlotContainer doesn't define one,
    but its various subclasses do.)

    BasePlotContainer is a subclass of Enable Container, so it is possible to
    insert Enable-level components into it.  However, because Enable
    components don't have the correct interfaces to participate in layout,
    the visual results will probably be incorrect.
    """

    # Redefine the container layers to name the main layer as "plot" instead
    # of the Enable default of "mainlayer"
    container_under_layers = Tuple("background", "image", "underlay", "plot")

    #------------------------------------------------------------------------
    # Duplicate trait declarations from PlotComponent.  We don't subclass
    # PlotComponent to avoid MRO complications with trait handlers and property
    # getters/setters.
    #------------------------------------------------------------------------

    draw_order = Instance(list, args=(DEFAULT_DRAWING_ORDER,))
    draw_layer = Str("plot")

    #------------------------------------------------------------------------
    # Deprecated traits
    #------------------------------------------------------------------------

    # Deprecated flag to indicate that a component needed to do old-style
    # drawing.  Unused by any recent Chaco component.
    use_draw_order = Bool(True)

    # Deprecated property for accessing the components in the container.
    plot_components = Property

    def _get_plot_components(self):
        warnings.warn("Use of plot_components attribute deprecated." \
                      "Use components attribute instead.", DeprecationWarning)
        return self._components

    def _set_plot_components(self, new):
        warnings.warn("Use of plot_components attribute deprecated." \
                      "Use components attribute instead.", DeprecationWarning)
        self._components = new

    def _use_draw_order_changed(self, old, new):
        """ Handler to catch the case when someone is trying to use the
        old-style drawing mechanism, which is now unsupported.
        """
        if new == False:
            raise RuntimeError("The old-style drawing mechanism is no longer " \
                    "supported in Chaco.")

# EOF

########NEW FILE########
__FILENAME__ = base_plot_frame
""" Defines the BasePlotFrame class (deprecated).
"""

#################################################################################
#
# NOTE: PlotFrames are deprecated.  There is no need to use them any more.
# This class will be removed some time in the near future.
#
#################################################################################

from __future__ import with_statement

# Enthought library imports
from enable.api import Container
from traits.api import Enum

# Local, relative imports
from plot_component import PlotComponent, DEFAULT_DRAWING_ORDER


class BasePlotFrame(Container, PlotComponent):
    """
    Base class for plot frames.  Primarily defines the basic functionality
    of managing slots (sub-containers) within the plot frame.

    NOTE: PlotFrames are deprecated. There is no need to use them any more.
    This class will be removed some time in the near future.
    """

    # A named list of places/positions/"slots" on the frame where PlotComponents
    # can place themselves.  Subclasses must redefine this trait with the
    # appropriate values.  Note that by default, __getattr__ treats these
    # slot names as attributes on the class so they can be directly accessed.
    # This is a class attribute.
    slot_names = ()

    # Dimensions in which this frame can resize to fit its components.
    # This is similar to the **resizable** trait on PlotComponent. Chaco
    # plot frames use this attribute in preference to the Enable
    # **auto_size** attribute (which is overridden to be False by default).
    fit_components = Enum("", "h", "v", "hv")

    # Overrides the Enable auto_size trait (which will be deprecated in the future)
    auto_size = False

    draw_order = DEFAULT_DRAWING_ORDER

    def __init__(self, **kw):
        self._frame_slots = {}
        super(BasePlotFrame, self).__init__(**kw)
        return

    def add_to_slot(self, slot, component, stack="overlay"):
        """
        Adds a component to the named slot using the given stacking mode.
        The valid modes are: 'overlay', 'left', 'right', 'top', 'bottom'.
        """
        self.frame_slots[slot].add_plot_component(component, stack)
        return

    def set_slot(self, slotname, container):
        """
        Sets the named slot to use the given container. *container* can be None.
        """
        if self._frame_slots.has_key(slotname):
            old_container = self._frame_slots[slotname]
            Container.remove(self, old_container)
        if container is not None:
            self._frame_slots[slotname] = container
            Container.add(self, container)
        return

    def get_slot(self, slotname):
        """ Returns the container in the named slot. """
        return self._frame_slots.get(slotname, None)

    #------------------------------------------------------------------------
    # PlotComponent interface
    #------------------------------------------------------------------------

    def draw(self, gc, view_bounds=None, mode="normal"):
        """ Draws the plot frame.

        Frames are the topmost Chaco component that knows about layout, and they
        are the start of the layout pipeline.  When they are asked to draw,
        they can assume that their own size has been set properly and this in
        turn drives the layout of the contained components within the trame.
        """
        self.do_layout()

        #if gc.window and gc.window.is_sizing:
        if 0:
            with gc:
                gc.translate_ctm(*self.position)
                #TODO: We are ignoring Container...
                PlotComponent.draw(self, gc, view_bounds, "interactive")
        else:
            super(BasePlotFrame, self).draw(gc, view_bounds, mode)
        return

    def do_layout(self, size=None, force=False):
        """ Tells this frame to do layout at a given size.

        Overrides PlotComponent. If this frame needs to fit components in at
        least one dimension, then it checks whether any of them need to do
        layout; if so, the frame needs to do layout also.
        """
        if not self._layout_needed and not force and self.fit_components != "":
            for slot in self._frame_slots.values():
                if slot._layout_needed:
                    self._layout_needed = True
                    break
        return PlotComponent.do_layout(self, size, force)

    def _draw(self, *args, **kw):
        """ Draws the plot frame.

        Overrides PlotComponent and Container, explicitly calling the
        PlotComponent version of _draw().
        """
        PlotComponent._draw(self, *args, **kw)
        return

    def _dispatch_to_enable(self, event, suffix):
        """ Calls Enable-level event handlers.

        Overrides PlotComponent.
        """
        Container.dispatch(self, event, suffix)
        return

    #------------------------------------------------------------------------
    # Event handlers, properties
    #------------------------------------------------------------------------

    def _bounds_changed(self, old, new):
        if self.container is not None:
            self.container._component_bounds_changed(self)
        self._layout_needed = True
        return

    def _bounds_items_changed(self, event):
        return self._bounds_changed(None, self.bounds)

    #------------------------------------------------------------------------
    # Private methods
    #------------------------------------------------------------------------

    def __getattr__(self, name):
        if name in self.slot_names:
            return self._frame_slots[name]
        else:
            raise AttributeError, "'%s' object has no attribute '%s'" % \
                                    (self.__class__.__name__, name)

    def __setattr__(self, name, value):
        if name in self.slot_names:
            self.set_slot(name, value)
        else:
            super(BasePlotFrame, self).__setattr__(name, value)
        return

    ### Persistence ###########################################################
#    _pickles = ("_frame_slots", "_components", "fit_components", "fit_window")

    def post_load(self, path=None):
        super(BasePlotFrame, self).post_load(path)
        for slot in self._frame_slots.values():
            slot.post_load(path)
        return


# EOF

########NEW FILE########
__FILENAME__ = base_xy_plot
""" Defines the base class for XY plots.
"""

from __future__ import with_statement

from math import sqrt
from numpy import around, array, isnan, transpose

# Enthought library imports
from enable.api import black_color_trait
from traits.api import Any, Array, Bool, Enum, Float, Instance, \
                             Property, Range


# Local relative imports
from abstract_mapper import AbstractMapper
from abstract_plot_renderer import AbstractPlotRenderer
from abstract_data_source import AbstractDataSource
from array_data_source import ArrayDataSource
from axis import PlotAxis
from base import point_line_distance, reverse_map_1d
from grid import PlotGrid
from plot_label import PlotLabel


class BaseXYPlot(AbstractPlotRenderer):
    """ Base class for simple X-vs-Y plots that consist of a single index
    data array and a single value data array.

    Subclasses handle the actual rendering, but this base class takes care of
    most of making sure events are wired up between mappers and data or screen
    space changes, etc.
    """

    #------------------------------------------------------------------------
    # Data-related traits
    #------------------------------------------------------------------------

    # The data source to use for the index coordinate.
    index = Instance(ArrayDataSource)

    # The data source to use as value points.
    value = Instance(AbstractDataSource)

    # Screen mapper for index data.
    index_mapper = Instance(AbstractMapper)
    # Screen mapper for value data
    value_mapper = Instance(AbstractMapper)


    # Convenience properties that correspond to either index_mapper or
    # value_mapper, depending on the orientation of the plot.

    # Corresponds to either **index_mapper** or **value_mapper**, depending on
    # the orientation of the plot.
    x_mapper = Property
    # Corresponds to either **value_mapper** or **index_mapper**, depending on
    # the orientation of the plot.
    y_mapper = Property

    # Convenience property for accessing the index data range.
    index_range = Property
    # Convenience property for accessing the value data range.
    value_range = Property

    # The type of hit-testing that is appropriate for this renderer.
    #
    # * 'line': Computes Euclidean distance to the line between the
    #   nearest adjacent points.
    # * 'point': Checks for adjacency to a marker or point.
    hittest_type = Enum("point", "line")

    #------------------------------------------------------------------------
    # Appearance-related traits
    #------------------------------------------------------------------------

    # The orientation of the index axis.
    orientation = Enum("h", "v")

    # Overall alpha value of the image. Ranges from 0.0 for transparent to 1.0
    alpha = Range(0.0, 1.0, 1.0)

    #------------------------------------------------------------------------
    # Convenience readonly properties for common annotations
    #------------------------------------------------------------------------

    # Read-only property for horizontal grid.
    hgrid = Property
    # Read-only property for vertical grid.
    vgrid = Property
    # Read-only property for x-axis.
    x_axis = Property
    # Read-only property for y-axis.
    y_axis = Property
    # Read-only property for labels.
    labels = Property


    #------------------------------------------------------------------------
    # Other public traits
    #------------------------------------------------------------------------

    # Does the plot use downsampling?
    # This is not used right now.  It needs an implementation of robust, fast
    # downsampling, which does not exist yet.
    use_downsampling = Bool(False)

    # Does the plot use a spatial subdivision structure for fast hit-testing?
    # This makes data updates slower, but makes hit-tests extremely fast.
    use_subdivision = Bool(False)

    # Overrides the default background color trait in PlotComponent.
    bgcolor = "transparent"

    # This just turns on a simple drawing of the X and Y axes... not a long
    # term solution, but good for testing.

    # Defines the origin axis color, for testing.
    origin_axis_color = black_color_trait
    # Defines a the origin axis width, for testing.
    origin_axis_width = Float(1.0)
    # Defines the origin axis visibility, for testing.
    origin_axis_visible = Bool(False)

    #------------------------------------------------------------------------
    # Private traits
    #------------------------------------------------------------------------

    # Are the cache traits valid? If False, new ones need to be compute.
    _cache_valid = Bool(False)

    # Cached array of (x,y) data-space points; regardless of self.orientation,
    # these points are always stored as (index_pt, value_pt).
    _cached_data_pts = Array

    # Cached array of (x,y) screen-space points.
    _cached_screen_pts = Array

    # Does **_cached_screen_pts** contain the screen-space coordinates
    # of the points currently in **_cached_data_pts**?
    _screen_cache_valid = Bool(False)

    # Reference to a spatial subdivision acceleration structure.
    _subdivision = Any

    #------------------------------------------------------------------------
    # Abstract methods that subclasses must implement
    #------------------------------------------------------------------------

    def _render(self, gc, points):
        """ Abstract method for rendering points.

        Parameters
        ----------
        gc : graphics context
            Target for drawing the points
        points : List of Nx2 arrays
            Screen-space points to render
        """
        raise NotImplementedError

    def _gather_points(self):
        """ Abstract method to collect data points that are within the range of
        the plot, and cache them.
        """
        raise NotImplementedError

    def _downsample(self):
        """ Abstract method that gives the renderer a chance to downsample in
        screen space.
        """
        # By default, this just does a mapscreen and returns the result
        raise NotImplementedError

    #------------------------------------------------------------------------
    # Concrete methods below
    #------------------------------------------------------------------------

    def __init__(self, **kwtraits):
        # Handling the setting/initialization of these traits manually because
        # they should be initialized in a certain order.
        kwargs_tmp = {"trait_change_notify": False}
        for trait_name in ("index", "value", "index_mapper", "value_mapper"):
            if trait_name in kwtraits:
                kwargs_tmp[trait_name] = kwtraits.pop(trait_name)
        self.set(**kwargs_tmp)
        AbstractPlotRenderer.__init__(self, **kwtraits)
        if self.index is not None:
            self.index.on_trait_change(self._either_data_changed, "data_changed")
            self.index.on_trait_change(self._either_metadata_changed, "metadata_changed")
        if self.index_mapper:
            self.index_mapper.on_trait_change(self._mapper_updated_handler, "updated")
        if self.value is not None:
            self.value.on_trait_change(self._either_data_changed, "data_changed")
            self.value.on_trait_change(self._either_metadata_changed, "metadata_changed")
        if self.value_mapper:
            self.value_mapper.on_trait_change(self._mapper_updated_handler, "updated")

        # If we are not resizable, we will not get a bounds update upon layout,
        # so we have to manually update our mappers
        if self.resizable == "":
            self._update_mappers()
        return

    def hittest(self, screen_pt, threshold=7.0, return_distance=False):
        """ Performs proximity testing between a given screen point and the
        plot.

        Parameters
        ----------
        screen_pt : (x,y)
            A point to test.
        threshold : integer
            Optional maximum screen space distance (pixels) between
            *screen_pt* and the plot.
        return_distance : Boolean
            If True, also return the distance.

        Returns
        -------
        If self.hittest_type is 'point', then this method returns the screen
        coordinates of the closest point on the plot as a tuple (x,y)

        If self.hittest_type is 'line', then this method returns the screen
        endpoints of the line segment closest to *screen_pt*, as
        ((x1,y1), (x2,y2))

        If *screen_pt* does not fall within *threshold* of the plot, then this
        method returns None.

        If return_distance is True, return the (x, y, d), where d is the
        distance between the distance between the input point and
        the closest point (x, y), in screen coordinates.
        """
        if self.hittest_type == "point":
            tmp = self.get_closest_point(screen_pt, threshold)
        elif self.hittest_type == "line":
            tmp = self.get_closest_line(screen_pt, threshold)
        else:
            raise ValueError("Unknown hittest type '%s'" % self.hittest_type)

        if tmp is not None:
            if return_distance:
                return tmp
            else:
                return tmp[:-1]
        else:
            return None

    def get_closest_point(self, screen_pt, threshold=7.0):
        """ Tests for proximity in screen-space.

        This method checks only data points, not the line segments connecting
        them; to do the latter use get_closest_line() instead.

        Parameters
        ----------
        screen_pt : (x,y)
            A point to test.
        threshold : integer
            Optional maximum screen space distance (pixels) between
            *screen_pt* and the plot.  If 0.0, then no threshold tests
            are performed, and the nearest point is returned.

        Returns
        -------
        (x, y, distance) of a datapoint nearest to *screen_pt*.
        If no data points are within *threshold* of *screen_pt*, returns None.
        """
        ndx = self.map_index(screen_pt, threshold)
        if ndx is not None:
            x = self.x_mapper.map_screen(self.index.get_data()[ndx])
            y = self.y_mapper.map_screen(self.value.get_data()[ndx])
            return (x, y, sqrt((x-screen_pt[0])**2 + (y-screen_pt[1])**2))
        else:
            return None

    def get_closest_line(self, screen_pt, threshold=7.0):
        """ Tests for proximity in screen-space against lines connecting the
        points in this plot's dataset.

        Parameters
        ----------
        screen_pt : (x,y)
            A point to test.
        threshold : integer
            Optional maximum screen space distance (pixels) between
            the line and the plot.  If 0.0, then the method returns the closest
            line regardless of distance from the plot.

        Returns
        -------
        (x1, y1, x2, y2, dist) of the endpoints of the line segment
        closest to *screen_pt*.  The *dist* element is the perpendicular
        distance from *screen_pt* to the line.  If there is only a single point
        in the renderer's data, then the method returns the same point twice.

        If no data points are within *threshold* of *screen_pt*, returns None.
        """
        ndx = self.map_index(screen_pt, threshold=0.0)
        if ndx is None:
            return None

        index_data = self.index.get_data()
        value_data = self.value.get_data()
        x = self.x_mapper.map_screen(index_data[ndx])
        y = self.y_mapper.map_screen(value_data[ndx])

        # We need to find another index so we have two points; in the
        # even that we only have 1 point, just return that point.
        datalen = len(index_data)
        if datalen == 1:
            dist = (x, y, sqrt((x-screen_pt[0])**2 + (y-screen_pt[1])**2))
            if (threshold == 0.0) or (dist <= threshold):
                return (x, y, x, y, dist)
            else:
                return None
        else:
            if (ndx == 0) or (screen_pt[0] >= x):
                ndx2 = ndx + 1
            elif (ndx == datalen - 1) or (screen_pt[0] <= x):
                ndx2 = ndx - 1
            x2 = self.x_mapper.map_screen(index_data[ndx2])
            y2 = self.y_mapper.map_screen(value_data[ndx2])
            dist = point_line_distance(screen_pt, (x,y), (x2,y2))
            if (threshold == 0.0) or (dist <= threshold):
                return (x, y, x2, y2, dist)
            else:
                return None


    #------------------------------------------------------------------------
    # AbstractPlotRenderer interface
    #------------------------------------------------------------------------

    def map_screen(self, data_array):
        """ Maps an array of data points into screen space and returns it as
        an array.

        Implements the AbstractPlotRenderer interface.
        """
        # data_array is Nx2 array
        if len(data_array) == 0:
            return []

        x_ary, y_ary = transpose(data_array)

        sx = self.index_mapper.map_screen(x_ary)
        sy = self.value_mapper.map_screen(y_ary)
        if self.orientation == "h":
            return transpose(array((sx,sy)))
        else:
            return transpose(array((sy,sx)))

    def map_data(self, screen_pt, all_values=False):
        """ Maps a screen space point into the "index" space of the plot.

        Implements the AbstractPlotRenderer interface.

        If *all_values* is True, returns an array of (index, value) tuples;
        otherwise, it returns only the index values.
        """
        x, y = screen_pt
        if self.orientation == 'v':
                x, y = y, x
        if all_values:
            return array((self.index_mapper.map_data(x),
                          self.value_mapper.map_data(y)))
        else:
            return self.index_mapper.map_data(x)

    def map_index(self, screen_pt, threshold=2.0, outside_returns_none=True,
                  index_only=False):
        """ Maps a screen space point to an index into the plot's index array(s).

        Implements the AbstractPlotRenderer interface.

        Parameters
        ----------
        screen_pt :
            Screen space point

        threshold : float
            Maximum distance from screen space point to plot data point.
            A value of 0.0 means no threshold (any distance will do).

        outside_returns_none : bool
            If True, a screen space point outside the data range returns None.
            Otherwise, it returns either 0 (outside the lower range) or
            the last index (outside the upper range)

        index_only : bool
            If True, the threshold is measured on the distance between the
            index values, otherwise as Euclidean distance between the (x,y)
            coordinates.
        """

        data_pt = self.map_data(screen_pt)
        if ((data_pt < self.index_mapper.range.low) or
            (data_pt > self.index_mapper.range.high)) and outside_returns_none:
            return None
        index_data = self.index.get_data()
        value_data = self.value.get_data()

        if len(value_data) == 0 or len(index_data) == 0:
            return None

        try:
            # find the closest point to data_pt in index_data
            ndx = reverse_map_1d(index_data, data_pt, self.index.sort_order)
        except IndexError:
            # if reverse_map raises this exception, it means that data_pt is
            # outside the range of values in index_data.
            if outside_returns_none:
                return None
            else:
                if data_pt < index_data[0]:
                    return 0
                else:
                    return len(index_data) - 1

        if threshold == 0.0:
            # Don't do any threshold testing
            return ndx

        x = index_data[ndx]
        y = value_data[ndx]
        if isnan(x) or isnan(y):
            return None

        # transform x,y in a 1x2 array, which is the preferred format of
        # map_screen. this makes it robust against differences in
        # the map_screen methods of logmapper and linearmapper
        # when passed a scalar
        xy = array([[x,y]])
        sx, sy = self.map_screen(xy).T
        if index_only and (threshold == 0.0 or screen_pt[0]-sx < threshold):
            return ndx
        elif ((screen_pt[0]-sx)**2 + (screen_pt[1]-sy)**2
              < threshold*threshold):
            return ndx
        else:
            return None

    def get_screen_points(self):
        """Returns the currently visible screen-space points.

        Intended for use with overlays.
        """
        self._gather_points()
        if self.use_downsampling:
            # The BaseXYPlot implementation of _downsample doesn't actually
            # do any downsampling.
            return self._downsample()
        else:
            return self.map_screen(self._cached_data_pts)


    #------------------------------------------------------------------------
    # PlotComponent interface
    #------------------------------------------------------------------------

    def _draw_plot(self, gc, view_bounds=None, mode="normal"):
        """ Draws the 'plot' layer.
        """
        self._draw_component(gc, view_bounds, mode)
        return

    def _draw_component(self, gc, view_bounds=None, mode="normal"):
        # This method should be folded into self._draw_plot(), but is here for
        # backwards compatibilty with non-draw-order stuff.

        pts = self.get_screen_points()
        self._render(gc, pts)
        return

    def _draw_default_axes(self, gc):
        if not self.origin_axis_visible:
            return

        with gc:
            gc.set_stroke_color(self.origin_axis_color_)
            gc.set_line_width(self.origin_axis_width)
            gc.set_line_dash(None)

            for range in (self.index_mapper.range, self.value_mapper.range):
                if (range.low < 0) and (range.high > 0):
                    if range == self.index_mapper.range:
                        dual = self.value_mapper.range
                        data_pts = array([[0.0,dual.low], [0.0, dual.high]])
                    else:
                        dual = self.index_mapper.range
                        data_pts = array([[dual.low,0.0], [dual.high,0.0]])
                    start,end = self.map_screen(data_pts)
                    start = around(start)
                    end = around(end)
                    gc.move_to(int(start[0]), int(start[1]))
                    gc.line_to(int(end[0]), int(end[1]))
                    gc.stroke_path()
        return

    def _post_load(self):
        super(BaseXYPlot, self)._post_load()
        self._update_mappers()
        self.invalidate_draw()
        self._cache_valid = False
        self._screen_cache_valid = False
        return

    def _update_subdivision(self):

        return

    #------------------------------------------------------------------------
    # Properties
    #------------------------------------------------------------------------

    def _get_index_range(self):
        return self.index_mapper.range

    def _set_index_range(self, val):
        self.index_mapper.range = val

    def _get_value_range(self):
        return self.value_mapper.range

    def _set_value_range(self, val):
        self.value_mapper.range = val

    def _get_x_mapper(self):
        if self.orientation == "h":
            return self.index_mapper
        else:
            return self.value_mapper

    def _get_y_mapper(self):
        if self.orientation == "h":
            return self.value_mapper
        else:
            return self.index_mapper

    def _get_hgrid(self):
        for obj in self.underlays+self.overlays:
            if isinstance(obj, PlotGrid) and obj.orientation=="horizontal":
                return obj
        else:
            return None

    def _get_vgrid(self):
        for obj in self.underlays+self.overlays:
            if isinstance(obj, PlotGrid) and obj.orientation=="vertical":
                return obj
        else:
            return None

    def _get_x_axis(self):
        for obj in self.underlays+self.overlays:
            if isinstance(obj, PlotAxis) and obj.orientation in ("bottom", "top"):
                return obj
        else:
            return None

    def _get_y_axis(self):
        for obj in self.underlays+self.overlays:
            if isinstance(obj, PlotAxis) and obj.orientation in ("left", "right"):
                return obj
        else:
            return None

    def _get_labels(self):
        labels = []
        for obj in self.underlays+self.overlays:
            if isinstance(obj, PlotLabel):
                labels.append(obj)
        return labels

    #------------------------------------------------------------------------
    # Event handlers
    #------------------------------------------------------------------------

    def _update_mappers(self):
        x_mapper = self.index_mapper
        y_mapper = self.value_mapper

        if self.orientation == "v":
            x_mapper, y_mapper = y_mapper, x_mapper

        x = self.x
        x2 = self.x2
        y = self.y
        y2 = self.y2

        if "left" in self.origin:
            x_mapper.screen_bounds = (x, x2)
        else:
            x_mapper.screen_bounds = (x2, x)

        if "bottom" in self.origin:
            y_mapper.screen_bounds = (y, y2)
        else:
            y_mapper.screen_bounds = (y2, y)

        self.invalidate_draw()
        self._cache_valid = False
        self._screen_cache_valid = False

    def _bounds_changed(self, old, new):
        super(BaseXYPlot, self)._bounds_changed(old, new)
        self._update_mappers()

    def _bounds_items_changed(self, event):
        super(BaseXYPlot, self)._bounds_items_changed(event)
        self._update_mappers()

    def _position_changed(self):
        self._update_mappers()

    def _position_items_changed(self):
        self._update_mappers()

    def _orientation_changed(self):
        self._update_mappers()

    def _index_changed(self, old, new):
        if old is not None:
            old.on_trait_change(self._either_data_changed, "data_changed", remove=True)
            old.on_trait_change(self._either_metadata_changed, "metadata_changed",
                                remove=True)
        if new is not None:
            new.on_trait_change(self._either_data_changed, "data_changed")
            new.on_trait_change(self._either_metadata_changed, "metadata_changed")
        self._either_data_changed()
        return

    def _either_data_changed(self):
        self.invalidate_draw()
        self._cache_valid = False
        self._screen_cache_valid = False
        self.request_redraw()
        return

    def _either_metadata_changed(self):
        # By default, don't respond to metadata change events.
        pass

    def _value_changed(self, old, new):
        if old is not None:
            old.on_trait_change(self._either_data_changed, "data_changed", remove=True)
            old.on_trait_change(self._either_metadata_changed, "metadata_changed",
                                remove=True)
        if new is not None:
            new.on_trait_change(self._either_data_changed, "data_changed")
            new.on_trait_change(self._either_metadata_changed, "metadata_changed")
        self._either_data_changed()
        return

    def _origin_changed(self, old, new):
        # origin switch from left to right or vice versa?
        if old.split()[1] != new.split()[1]:
            xm = self.x_mapper
            xm.low_pos, xm.high_pos = xm.high_pos, xm.low_pos
        # origin switch from top to bottom or vice versa?
        if old.split()[0] != new.split()[0]:
            ym = self.y_mapper
            ym.low_pos, ym.high_pos = ym.high_pos, ym.low_pos

        self.invalidate_draw()
        self._screen_cache_valid = False
        return

    def _index_mapper_changed(self, old, new):
        self._either_mapper_changed(self, "index_mapper", old, new)
        if self.orientation == "h":
            self.trait_property_changed("x_mapper", old, new)
        else:
            self.trait_property_changed("y_mapper", old, new)
        return

    def _value_mapper_changed(self, old, new):
        self._either_mapper_changed(self, "value_mapper", old, new)
        if self.orientation == "h":
            self.trait_property_changed("y_mapper", old, new)
        else:
            self.trait_property_changed("x_mapper", old, new)
        return

    def _either_mapper_changed(self, obj, name, old, new):
        if old is not None:
            old.on_trait_change(self._mapper_updated_handler, "updated", remove=True)
        if new is not None:
            new.on_trait_change(self._mapper_updated_handler, "updated")
        self.invalidate_draw()
        self._screen_cache_valid = False
        return

    def _mapper_updated_handler(self):
        self._cache_valid = False
        self._screen_cache_valid = False
        self.invalidate_draw()
        self.request_redraw()
        return

    def _visible_changed(self, old, new):
        if new:
            self._layout_needed = True

    def _bgcolor_changed(self):
        self.invalidate_draw()

    def _use_subdivision_changed(self, old, new):
        if new:
            self._set_up_subdivision()
        return

    #------------------------------------------------------------------------
    # Persistence
    #------------------------------------------------------------------------

    def __getstate__(self):
        state = super(BaseXYPlot,self).__getstate__()
        for key in ['_cache_valid', '_cached_data_pts', '_screen_cache_valid',
                    '_cached_screen_pts']:
            if state.has_key(key):
                del state[key]

        return state

    def __setstate__(self, state):
        super(BaseXYPlot, self).__setstate__(state)
        if self.index is not None:
            self.index.on_trait_change(self._either_data_changed, "data_changed")
        if self.value is not None:
            self.value.on_trait_change(self._either_data_changed, "data_changed")

        self.invalidate_draw()
        self._cache_valid = False
        self._screen_cache_valid = False
        self._update_mappers()
        return



# EOF

########NEW FILE########
__FILENAME__ = candle_plot

from __future__ import with_statement

# Major library imports
from numpy import array, compress, concatenate, searchsorted

# Enthought library imports
from traits.api import Instance, Property

# Chaco imports
from abstract_data_source import AbstractDataSource
from base_candle_plot import BaseCandlePlot

def broaden(mask):
    """ Takes a 1D boolean mask array and returns a copy with all the non-zero
    runs widened by 1.
    """
    if len(mask) < 2:
        return mask
    # Note: the order in which these operations are performed is important.
    # Modifying newmask in-place with the |= operator only works for if
    # newmask[:-1] is the L-value.
    newmask = concatenate(([False], mask[1:] | mask[:-1]))
    newmask[:-1] |= mask[1:]
    return newmask


class CandlePlot(BaseCandlePlot):
    """ A plot consisting of a filled bar with an optional centerline and
    stems extending to extrema.  Usually used to represent some statistics
    on bins of data, with the centerline representing the mean, the bar
    extents representing +/- 1 standard dev or 10th/90th percentiles, and
    the stems extents representing the minimum and maximum samples.

    The values in the **index** datasource indicate the centers of the bins;
    the widths of the bins are *not* specified in data space, and are
    determined by the minimum space between adjacent index values.
    """

    #------------------------------------------------------------------------
    # Data-related traits
    #------------------------------------------------------------------------

    # The minimum values at each index point.  If None, then no stem and no
    # endcap line will be drawn below each bar.
    min_values = Instance(AbstractDataSource)

    # The "lower" extent of the "bar", i.e. the value closest to the
    # corresponding value in min_values at each index.
    bar_min = Instance(AbstractDataSource)

    # Values that appear inside the bar, between bar_min and bar_max.  These
    # Are usually mean or median values, and are rendered with a solid line
    # of a different color than the bar fill color.  This can be None.
    center_values = Instance(AbstractDataSource)

    # The "upper" extent of the "bar", i.e. the value closest to the
    # corresponding value in max_values at each index.
    bar_max = Instance(AbstractDataSource)

    # The maximum value at each index point.  If None, then no stem and no
    # endcap line will be drawn above each bar.
    max_values = Instance(AbstractDataSource)

    value = Property

    def map_data(self, screen_pt, all_values=True):
        """ Maps a screen space point into the "index" space of the plot.

        Overrides the BaseXYPlot implementation, and always returns an
        array of (index, value) tuples.
        """
        x, y = screen_pt
        if self.orientation == 'v':
            x, y = y, x
        return array((self.index_mapper.map_data(x),
                      self.value_mapper.map_data(y)))

    def map_index(self, screen_pt, threshold=0.0, outside_returns_none=True,
                  index_only = True):
        if not index_only:
            raise NotImplementedError("Candle Plots only support index_only map_index()")
        if len(screen_pt) == 0:
            return None

        # Find the closest index point using numpy
        index_data = self.index.get_data()
        if len(index_data) == 0:
            return None

        target_data = self.index_mapper.map_data(screen_pt[0])

        index = searchsorted(index_data, [target_data])[0]
        if index == len(index_data):
            index -= 1
        # Bracket index and map those points to screen space, then
        # compute the distance
        if index > 0:
            lower = index_data[index-1]
            upper = index_data[index]
            screen_low, screen_high = self.index_mapper.map_screen(array([lower, upper]))
            # Find the closest index
            low_dist = abs(screen_pt[0] - screen_low)
            high_dist = abs(screen_pt[0] - screen_high)
            if low_dist < high_dist:
                index = index - 1
                dist = low_dist
            else:
                dist = high_dist
            # Determine if we need to check the threshold
            if threshold > 0 and dist >= threshold:
                return None
            else:
                return index
        else:
            screen = self.index_mapper.map_screen(index_data[0])
            if threshold > 0 and abs(screen - screen_pt[0]) >= threshold:
                return None
            else:
                return index

    def _gather_points(self):
        index = self.index.get_data()
        mask = broaden(self.index_range.mask_data(index))

        if not mask.any():
            self._cached_data_pts = []
            self._cache_valid = True
            return

        data_pts = [compress(mask, index)]

        for v in (self.min_values, self.bar_min, self.center_values, self.bar_max, self.max_values):
            if v is None or len(v.get_data()) == 0:
                data_pts.append(None)
            else:
                data_pts.append(compress(mask, v.get_data()))

        self._cached_data_pts = data_pts
        self._cache_valid = True

    def _draw_plot(self, gc, view_bounds=None, mode="normal"):
        self._gather_points()
        if len(self._cached_data_pts) == 0:
            return

        index = self.index_mapper.map_screen(self._cached_data_pts[0])
        if len(index) == 0:
            return

        vals = []
        for v in self._cached_data_pts[1:]:
            if v is None:
                vals.append(None)
            else:
                vals.append(self.value_mapper.map_screen(v))

        # Compute lefts and rights from self.index, which represents bin
        # centers.
        if len(index) == 1:
            width = 5.0
        else:
            width = (index[1:] - index[:-1]).min() / 2.5
        left = index - width
        right = index + width

        with gc:
            gc.clip_to_rect(self.x, self.y, self.width, self.height)
            self._render(gc, left, right, *vals)

    def _get_value(self):
        if self.center_values is not None:
            return self.center_values
        elif self.bar_min is not None:
            return self.bar_min
        elif self.bar_max is not None:
            return self.bar_max



########NEW FILE########
__FILENAME__ = chaco_plot_container_editor
""" Deprecated alias for ComponentEditor.
"""

import warnings

from enable.component_editor import ComponentEditor


class PlotContainerEditor(ComponentEditor):
    """ Deprecated alias for ComponentEditor.
    """

    def __init__(self, *args, **kwds):
        super(PlotContainerEditor, self).__init__(*args, **kwds)
        warnings.warn("DEPRECATED: Use enable.component_editor"
            ".ComponentEditor instead.", DeprecationWarning)


########NEW FILE########
__FILENAME__ = chaco_plot_editor
"""
Traits UI editor for WX, based on the Chaco1 PlotEditor in
traits.ui.wx.plot_editor.
"""

# Enthought library imports
from traits.etsconfig.api import ETSConfig
from enable.api import black_color_trait, LineStyle, ColorTrait,\
    white_color_trait, MarkerTrait, Window
from enable.trait_defs.ui.api import RGBAColorEditor
from kiva.trait_defs.kiva_font_trait import KivaFont
from traits.api import Enum, Str, Range, Tuple, \
                                 Bool, Trait, Int, Any, Property
from traitsui.api import Item
from traitsui.editor_factory import EditorFactory

# Toolkit dependent imports
from traitsui.toolkit import toolkit_object
Editor = toolkit_object('editor:Editor')

# Local relative imports
from axis import PlotAxis
from plot_containers import OverlayPlotContainer
from plot_factory import create_line_plot, create_scatter_plot, \
                         add_default_grids, add_default_axes
from plot_label import PlotLabel

# Somewhat unorthodox...
from chaco.tools.api import PanTool, ZoomTool

#-------------------------------------------------------------------------------
#  Trait definitions:
#-------------------------------------------------------------------------------

# Range of values for an axis.
AxisRange =  Tuple( ( 0.0, 1.0, 0.01 ),
                    labels = [ 'Low', 'High', 'Step' ],
                    cols   = 3 )

# Range of axis bounds.
AxisBounds = Tuple( ( 0.0, 1.0 ),
                    labels = [ 'Min', 'Max' ],
                    cols   = 2 )

# Range for the height and width for the plot widget.
PlotSize = Range( 50, 1000, 180 )

# Range of plot line weights.
LineWeight = Range( 1, 9, 3 )

# The color editor to use for various color traits.
color_editor = RGBAColorEditor()


USE_DATA_UPDATE = 1


class ChacoPlotItem(Item):
    """ A Traits UI Item for a Chaco plot, for use in Traits UI Views.

    NOTE: ComponentEditor is preferred over this class, as it is more flexible.
    """
    # Name of the trait that references the index data source.
    index = Str
    # Name of the trait that references the value data source.
    value = Str
    # Title of the plot (overlaid on the plot container).
    title = Str("Plot Editor")

    # Bounds of the x-axis, used if **x_auto** is False.
    x_bounds = AxisBounds
    # Set the x-axis bounds automatically?
    x_auto = Bool(True)
    # Bounds of the y-axis, used if **y_auto** is False.
    y_bounds = AxisBounds
    # Set the y-axis bounds automatically?
    y_auto = Bool(True)

    # The orientation of the index axis.
    orientation = Enum("h", "v")

    # If these are None, then the index/value trait names are used

    # Label of the x-axis; if None, the **index** name is used.
    x_label = Trait(None, None, Str)
    # Name of the trait on the object containing the label of the x-axis.
    # This takes precedence over **x_label**.
    x_label_trait = Trait(None, None, Str)
    # Font for the label of the x-axis.
    x_label_font = KivaFont("modern 10")
    # Color of the label of the x-axis.
    x_label_color = black_color_trait
    # Label of the y-axis; if None, the **value** name is used.
    y_label = Trait(None, None, Str)
    # Name of the trait on the object containing the label of the y-axis.
    # This takes precedence over **y_label**.
    y_label_trait = Trait(None, None, Str)
    # Font for the label of the y-axis.
    y_label_font = KivaFont("modern 10")
    # Color of the label of the y-axis.
    y_label_color = black_color_trait

    # General plot properties

    # Foreground olor of the plot.
    color = ColorTrait("blue")
    # Background color of the plot.
    bgcolor = white_color_trait
    # Background color of the plot (deprecated).
    bg_color = Property   # backwards compatibility; deprecated
    # Color of the background padding.
    padding_bg_color = ColorTrait("sys_window")

    # Border properties

    # Width of the plot border
    border_width = Int(1)
    # Is the border visible?
    border_visible = Bool(False)
    # Line style of the border.
    border_dash = LineStyle
    # Color of the border.
    border_color = black_color_trait

    # The type of the plot.
    type = Enum("line", "scatter")
    # The type of the plot as a string.
    type_trait = Str

    # plot-specific properties.  These might not apply to all plot types.

    # Type of marker (for plots that use markers).
    marker = MarkerTrait
    # Size of marker (for plots that use markers).
    marker_size = Int(4)
    # Marker outline color (for plots that user markers).
    outline_color = black_color_trait

    def __init__(self, index, value, type="line", **traits):
        self.index = index
        self.value = value
        self.type = type
        self.name = index
        super(ChacoPlotItem, self).__init__(**traits)

        self.editor = ChacoEditorFactory()

        self.editor.plotitem = self

        return

    def _set_bg_color(self, val):
        self.bgcolor = val

    def _get_bg_color(self):
        return self.bgcolor


class ChacoEditorFactory ( EditorFactory ):
    """ Editor factory for plot editors.
    """
    #---------------------------------------------------------------------------
    #  Trait definitions:
    #---------------------------------------------------------------------------

    # Width of the plot editor.
    width    = PlotSize
    # Height of the plot editor.
    height   = PlotSize
    # The ChacoPlotItem associated with this factory.
    plotitem = Any


    #---------------------------------------------------------------------------
    #  'Editor' factory methods:
    #---------------------------------------------------------------------------

    def simple_editor ( self, ui, object, name, description, parent ):
        return ChacoPlotEditor( parent,
                                 factory     = self,
                                 ui          = ui,
                                 object      = object,
                                 name        = name,
                                 description = description )

    def text_editor ( self, ui, object, name, description, parent ):
        return ChacoPlotEditor( parent,
                                 factory     = self,
                                 ui          = ui,
                                 object      = object,
                                 name        = name,
                                 description = description )

    def readonly_editor ( self, ui, object, name, description, parent ):
        return ChacoPlotEditor( parent,
                                 factory     = self,
                                 ui          = ui,
                                 object      = object,
                                 name        = name,
                                 description = description )


class ChacoPlotEditor ( Editor ):
    """ Traits UI editor for displaying trait values in a Chaco plot.
    """

    #---------------------------------------------------------------------------
    #  Finishes initializing the editor by creating the underlying toolkit
    #  widget:
    #---------------------------------------------------------------------------

    def init ( self, parent ):
        """ Finishes initializing the editor by creating the underlying toolkit
            widget.
        """
        factory = self.factory
        plotitem = factory.plotitem

        container = OverlayPlotContainer(padding = 50, fill_padding = True,
                                         bgcolor = plotitem.padding_bg_color,
                                         use_backbuffer=True)

        if plotitem.title != '':
            container.overlays.append(PlotLabel(plotitem.title,
                                                component=container,
                                                overlay_position="top"))

        self._container = container
        window = Window(parent, component = container)

        # FIXME: Toolkit specifc code here. The AbstractWindow should have a
        # 'set size' method as part of its API.
        self.control = control = window.control
        if ETSConfig.toolkit == 'wx':
            control.SetSize((factory.width, factory.height))
        elif ETSConfig.toolkit == 'qt4':
            control.resize(factory.width, factory.height)
        else:
            raise NotImplementedError

        # Attach listeners to the object's traits appropriately so we can
        # update the plot when they change.  For the _update_axis_grids()
        # callback, we have to wrap it in a lambda to keep traits from
        # inferring the calling convention based on introspecting the argument
        # list.
        object = self.object
        if USE_DATA_UPDATE == 1:
            for name in (plotitem.index, plotitem.value):
                object.on_trait_change( self._update_data, name)
        for name in (plotitem.x_label_trait, plotitem.y_label_trait):
            object.on_trait_change(lambda s: self._update_axis_grids(), name)
        if plotitem.type_trait not in ("", None):
            object.on_trait_change(self.update_editor, plotitem.type_trait)
        return

    #---------------------------------------------------------------------------
    #  Disposes of the contents of an editor:
    #---------------------------------------------------------------------------

    def dispose(self):
        """ Disposes of the contents of the editor.
        """
        object = self.object
        plotitem = self.factory.plotitem

        if USE_DATA_UPDATE == 1:
            for name in (plotitem.index, plotitem.value):
                object.on_trait_change( self._update_data, name, remove = True )
        for name in (plotitem.type_trait,):
            object.on_trait_change( self.update_editor, name, remove = True )
        self._destroy_plot()
        super(ChacoPlotEditor, self).dispose()

    def _destroy_plot(self):
        if self._container and self._plot:
            plot = self._plot
            del plot.index._data
            del plot.index._cached_mask
            del plot.value._data
            del plot.value._cached_mask
            self._container.remove(plot)
            self._plot = None
            plot.index = None
            plot.value = None
        return

    #---------------------------------------------------------------------------
    #  Updates the editor when the object trait changes externally to the editor:
    #---------------------------------------------------------------------------

    def update_editor(self):
        """ Updates the editor when the object trait changes externally to the
            editor.
        """

        factory  = self.factory
        if factory is None:
            return
        plotitem = factory.plotitem

        # Remove the old plot
        if self._plot is not None:
            self._destroy_plot()

        try:
            x_values = getattr(self.object, plotitem.index)
            y_values = getattr(self.object, plotitem.value)
        except:
            self._container.request_redraw()
            return

        if plotitem.type_trait != "":
            plot_type = getattr(self.object, plotitem.type_trait)
        else:
            plot_type = plotitem.type

        if plotitem.x_auto == True:
            index_bounds = None
        else:
            index_bounds = plotitem.x_bounds

        if plotitem.y_auto == True:
            value_bounds = None
        else:
            value_bounds = plotitem.y_bounds

        # Class-level attribute mapping different plot_type strings to methods for
        # creating different types of plots
        plot_creator_map = { "line": self._create_line_plot,
                             "scatter": self._create_scatter_plot }

        if plot_type in plot_creator_map.keys():
            plot = plot_creator_map[plot_type](plotitem, (x_values, y_values),
                                                index_bounds = index_bounds,
                                                value_bounds = value_bounds,
                                                orientation = plotitem.orientation)
        else:
            raise RuntimeError, "Unknown plot type '%s' in ChacoPlotEditor." % plot_type

        self._set_basic_properties(plot, plotitem)

        self._add_axis_grids(plot, plotitem)

        self._plot = plot
        self._container.add(plot)
        self._container.request_redraw()
        return

    def _update_data(self):
        """ Updates the editor when the object trait changes externally to the
            editor.
        """
        if self._plot is None:
            self.update_editor()
        else:
            x_values = getattr(self.object, self.factory.plotitem.index)
            y_values = getattr(self.object, self.factory.plotitem.value)
            self._plot.index.set_data(x_values)
            self._plot.value.set_data(y_values)


    def _set_basic_properties(self, plot, plotitem):
        for attr in ("color", "bgcolor", "border_visible", "border_width",
                     "border_dash", "border_color"):
            setattr(plot, attr, getattr(plotitem, attr))
        return

    def _create_line_plot(self, plotitem, values, **kwargs):
        plot = create_line_plot(values, **kwargs)
        return plot

    def _create_scatter_plot(self, plotitem, values, **kwargs):
        plot = create_scatter_plot(values, **kwargs)
        for attr in ("marker", "marker_size", "outline_color"):
            setattr(plot, attr, getattr(plotitem, attr))
        return plot

    def _add_axis_grids(self, new_plot, plotitem):
        value_axis, index_axis = add_default_axes(new_plot,
                                    orientation=plotitem.orientation)
        add_default_grids(new_plot)
        new_plot.tools.append(PanTool(new_plot))
        zoom = ZoomTool(component=new_plot, tool_mode="box", always_on=False)
        new_plot.overlays.append(zoom)

        # Update the titles and labels
        self._update_axis_grids(new_plot, plotitem)

    def _update_axis_grids(self, plot=None, plotitem=None):
        if self.factory is None:
            return

        if plot is None:
            if self._plot is None:
                return
            else:
                plot = self._plot
        if plotitem is None:
            plotitem = self.factory.plotitem

        if plotitem.x_label_trait is not None:
            htitle = getattr(self.object, plotitem.x_label_trait)
        elif plotitem.x_label is not None:
            htitle = plotitem.x_label
        else:
            htitle = plotitem.index

        if plotitem.y_label_trait is not None:
            vtitle = getattr(self.object, plotitem.y_label_trait)
        elif plotitem.y_label is not None:
            vtitle = plotitem.y_label
        else:
            vtitle = plotitem.value

        if plotitem.orientation == "v":
            htitle, vtitle = vtitle, htitle
        plot.x_axis.title = htitle
        plot.y_axis.title = vtitle

        # This is sort of crappy.. since we are using BaseXYPlots and not
        # Plot/DataViews, we actually can't easily get references to the plot's
        # index and value axes.  So we have to search through the underlays for
        # PlotAxis instances whose ranges match the index and value ranges.
        for axis in plot.underlays + plot.overlays:
            if isinstance(axis, PlotAxis) and axis.mapper.range is plot.index_range:
                axis.title_font = plotitem.x_label_font
                axis.title_color = plotitem.x_label_color

        for axis in plot.underlays + plot.overlays:
            if isinstance(axis, PlotAxis) and axis.mapper.range is plot.value_range:
                axis.title_font = plotitem.y_label_font
                axis.title_color = plotitem.y_label_color

        plot.request_redraw()
        return


# EOF

########NEW FILE########
__FILENAME__ = chaco_traits
""" Defines various traits that are used in many places in Chaco.
"""

# Enthought library imports
from traits.api import Enum

#----------------------------------------------------------------------------
# Box positioning traits: used to specify positions of boxes relative to
# one another.  Generally used for layout.
#----------------------------------------------------------------------------

box_edge_enum = Enum("left", "right", "top", "bottom")

# Values correspond to: top, bottom, left, right, top left, top right, bottom
# left, bottom right
box_position_enum = Enum("T", "B", "L", "R", "TL", "TR", "BL", "BR")

# For backwards compatibility, import LineStyle & LineStyleEditor from enable.
# (They used to be defined here.)
from enable.api import LineStyle, LineStyleEditor

# EOF

########NEW FILE########
__FILENAME__ = chaco_version
#------------------------------------------------------------------------------
# Copyright (c) 2005, Enthought, Inc.
# All rights reserved.
#
# This software is provided without warranty under the terms of the BSD
# license included in LICENSE.txt and may be redistributed only
# under the conditions described in the aforementioned license.  The license
# is also available online at http://www.enthought.com/licenses/BSD.txt
# Thanks for using Enthought open source!
#
# Author: Enthought, Inc.
# Description: <Enthought library component>
#------------------------------------------------------------------------------
""" Defines version numbering for the Chaco package.
"""
major = 2
minor = 0
micro = 9

version = "%s.%s.%s" % (major, minor, micro)


release_level = "beta"
branch = ""
revision = version

########NEW FILE########
__FILENAME__ = cmap_image_plot
#
# (C) Copyright 2013 Enthought, Inc., Austin, TX
# All right reserved.
#
# This file is open source software distributed according to the terms in
# LICENSE.txt
#

from numpy import zeros

# Enthought library imports.
from traits.api import Any, Bool, Float, Instance, Property, Tuple

# Local relative imports
from image_plot import ImagePlot
from abstract_colormap import AbstractColormap
from speedups import apply_selection_fade


class CMapImagePlot(ImagePlot):
    """ Colormapped image plot.  Takes a value data object whose elements are
    scalars, and renders them as a colormapped image.
    """

    # TODO: Modify ImageData to explicitly support scalar value arrays

    #------------------------------------------------------------------------
    # Data-related traits
    #------------------------------------------------------------------------

    # Maps from scalar data values in self.data.value to color tuples
    value_mapper = Instance(AbstractColormap)

    # Convenience property for value_mapper as color_mapper
    color_mapper = Property

    # Convenience property for accessing the data range of the mapper.
    value_range = Property

    # alpha value to use to fade out unselected data points when there is an
    # active selection
    fade_alpha = Float(0.3)

    #fade_background = Tuple((255,255,255))
    # RGB color to use to fade out unselected points.
    fade_background = Tuple((0,0,0))
    
    # whether to pre-compute the full colormapped RGB(A) image
    cache_full_map = Bool(True)

    #------------------------------------------------------------------------
    # Private Traits
    #------------------------------------------------------------------------

    # Is the mapped image valid?
    _mapped_image_cache_valid = Bool(False)

    # Cache of the fully mapped RGB(A) image.
    _cached_mapped_image = Any

    #------------------------------------------------------------------------
    # Public methods
    #------------------------------------------------------------------------

    def __init__(self, **kwargs):
        super(CMapImagePlot, self).__init__(**kwargs)
        if self.value_mapper:
            self.value_mapper.on_trait_change(self._update_value_mapper,
                                              "updated")
        if self.value:
            self.value.on_trait_change(self._update_selections,
                                       "metadata_changed")

    def set_value_selection(self, val):
        """ Sets a range of values in the value data source as selected.
        """
        if val is not None:
            low, high = val
            data = self.value.get_data()
            new_mask = (data>=low) & (data<=high)
            self.value.metadata["selection_masks"] = [new_mask]
        else:
            del self.value.metadata["selection_masks"]

        self._update_selections()

    #------------------------------------------------------------------------
    # Base2DPlot interface
    #------------------------------------------------------------------------

    def _render(self, gc):
        """ Ensures that the cached image is valid.

        Called before _render() is called. Implements the Base2DPlot interface.
        """
        if not self._mapped_image_cache_valid:
            if 'selection_masks' in self.value.metadata:
                self._compute_cached_image(self.value.metadata['selection_masks'])
            else:
                self._compute_cached_image()
        ImagePlot._render(self, gc)


    #------------------------------------------------------------------------
    # Private methods
    #------------------------------------------------------------------------
    
    def _cmap_values(self, data, selection_masks=None):
        """ Maps the data to RGB(A) with optional selection masks overlayed
        
        """
        # get the RGBA values from the color map as uint8
        mapped_image = self.value_mapper.map_uint8(data)
        if selection_masks is not None:
            # construct a composite mask
            if len(selection_masks) > 0:
                mask = zeros(mapped_image.shape[:2], dtype=bool)
                for m in selection_masks:
                    mask = mask | m
            else:
                mask = zeros(self._cached_mapped_image.shape[:2], dtype=bool)
            # Apply the selection fade, from speedups.py
            apply_selection_fade(mapped_image, mask,
                    self.fade_alpha, self.fade_background)
        return mapped_image
        
    def _compute_cached_image(self, selection_masks=None):
        """ Updates the cached image.
        """
        if self.cache_full_map:
            if not self._mapped_image_cache_valid:
                self._cached_mapped_image = self._cmap_values(self.value.data,
                    selection_masks)
                self._mapped_image_cache_valid = True

            mapped_value = self._cached_mapped_image
            ImagePlot._compute_cached_image(self, mapped_value)
        else:
            self._mapped_image_cache_valid = True
            ImagePlot._compute_cached_image(self, self.value.data, mapper=lambda data:
                self._cmap_values(data))
            
    def _update_value_mapper(self):
        self._mapped_image_cache_valid = False
        self._image_cache_valid = False
        self.invalidate_draw()

    def _update_selections(self):
        self._mapped_image_cache_valid = False
        self._image_cache_valid = False
        self.invalidate_draw()

    #------------------------------------------------------------------------
    # Properties
    #------------------------------------------------------------------------

    def _get_value_range(self):
        return self.value_mapper.range

    def _set_value_range(self, val):
        self.value_mapper.range = val

    def _get_color_mapper(self):
        return self.value_mapper

    def _set_color_mapper(self, val):
        self.value_mapper = val

    #------------------------------------------------------------------------
    # Event handlers
    #------------------------------------------------------------------------

    def _value_mapper_changed(self, old, new):
        if old is not None:
            old.on_trait_change(self._update_value_mapper,
                                "updated", remove=True)
        if new is not None:
            new.on_trait_change(self._update_value_mapper, "updated")

        if old and new:
            if new.range is None and old.range is not None:
                new.range = old.range
        self._update_value_mapper()
    
    def _value_data_changed_fired(self):
        super(CMapImagePlot, self)._value_data_changed_fired()
        self._mapped_image_cache_valid = False
        return

    def _index_data_changed_fired(self):
        super(CMapImagePlot, self)._index_data_changed_fired()
        self._mapped_image_cache_valid = False
        return
    
    def _cache_full_map_changed(self):
        self._mapped_image_cache_valid = False
        


########NEW FILE########
__FILENAME__ = colormapped_scatterplot
""" Defines the ColormappedScatterPlot and ColormappedScatterPlotView classes.
"""

from __future__ import with_statement

# Major library imports
from numpy import argsort, array, concatenate, nonzero, invert, take, \
                  isnan, transpose, newaxis, zeros, ndarray

# Enthought library imports
from kiva.constants import STROKE
from traits.api import Dict, Enum, Float, Instance
from traitsui.api import Item, RangeEditor

# Local, relative imports
from array_data_source import ArrayDataSource
from base import left_shift, right_shift
from color_mapper import ColorMapper
from scatterplot import ScatterPlot, ScatterPlotView


class ColormappedScatterPlotView(ScatterPlotView):
    """ Traits UI View for customizing a color-mapped scatter plot.
    """
    def __init__(self):
        super(ColormappedScatterPlotView, self).__init__()
        vgroup = self.content
        vgroup.content[0].content.append(Item("fill_alpha", label="Fill alpha",
                                   editor=RangeEditor(low=0.0, high=1.0)))
        return


class ColormappedScatterPlot(ScatterPlot):
    """
    A scatter plot that allows each point to take on a different color,
    corresponding to a color map.

    If the **color_data** or **color_mapper** attributes are None, then it
    behaves like a normal ScatterPlot.
    """

    # Source for color data.
    color_data = Instance(ArrayDataSource)

    # Mapping for colors.
    color_mapper = Instance(ColorMapper)

    # The alpha value to apply to the result of the color-mapping process.
    # (This makes it easier to create color maps without having to worry
    # about alpha.)
    fill_alpha = Float(1.0)

    # Determines what drawing approach to use:
    #
    # banded:
    #     Draw the points color-band by color-band, thus reducing the number of
    #     set_stroke_color() calls. Disadvantage is that some colors will
    #     appear more prominently than others if there are a lot of
    #     overlapping points.
    # bruteforce:
    #     Set the stroke color before drawing each marker.  Slower, but doesn't
    #     produce the banding effect that puts some colors on top of others;
    #     useful if there is a lot of overlap of the data.
    # auto:
    #     Determines which render method to use based on the number of points
    #
    # TODO: Based on preliminary results, "banded" isn't significantly
    # more expensive than "bruteforce" for small datasets (<1000),
    # so perhaps banded should be removed.
    render_method = Enum("auto", "banded", "bruteforce")

    # A dict mapping color-map indices to arrays of indices into self.data.
    # This is used for the "banded" render method.
    # This mapping is only valid if **_cache_valid** is True.
    _index_bands = Dict()

    # Traits UI View for customizing the plot. Overrides the ScatterPlot value.
    traits_view = ColormappedScatterPlotView()

    #------------------------------------------------------------------------
    # BaseXYPlot interface
    #------------------------------------------------------------------------

    def map_screen(self, data_array):
        """
        Maps an array of data points into screen space, and returns them as
        an array.

        The *data_array* parameter must be an Nx2 (index, value) or Nx3
        (index, value, color_value) array. The returned array is an Nx2
        array of (x, y) tuples.
        """
        if len(data_array)>0:
            if data_array.shape[1] == 3:
                data_array = data_array[:, :2]
        return super(ColormappedScatterPlot, self).map_screen(data_array)

    def _draw_plot(self, gc, view_bounds=None, mode="normal"):
        """ Draws the 'plot' layer.

        Overrides BaseXYPlot, which isn't really fully generic (it assumes that
        the output of map_screen() is sufficient to render the data).
        """
        self._gather_points()
        if len(self._cached_data_pts) == 0:
            pass
        elif self._cached_data_pts.shape[1] == 2:
            # Take into account fill_alpha even if we are rendering with only two values
            old_color = self.color
            self.color = tuple(self.fill_alpha * array(self.color_))
            super(ColormappedScatterPlot, self)._draw_component(gc, view_bounds, mode)
            self.color = old_color
        else:
            colors = self._cached_data_pts[:,2]
            screen_pts = self.map_screen(self._cached_data_pts)
            pts = concatenate((screen_pts, colors[:, newaxis]), axis=1)
            self._render(gc, pts)
        return

    def _gather_points(self):
        """
        Collects the data points that are within the plot bounds and caches them
        """
        if self._cache_valid:
            return

        if not self.index or not self.value:
            self._cached_data_pts = []
            self._cache_valid = True
            return

        index, index_mask = self.index.get_data_mask()
        value, value_mask = self.value.get_data_mask()

        if len(index) == 0 or len(value) == 0 or len(index) != len(value):
            self._cached_data_pts = []
            self._cache_valid = True
            return

        index_range_mask = self.index_mapper.range.mask_data(index)
        value_range_mask = self.value_mapper.range.mask_data(value)
        nan_mask = invert(isnan(index_mask)) & invert(isnan(value_mask))
        point_mask = index_mask & value_mask & nan_mask & \
                     index_range_mask & value_range_mask

        if self.color_data is not None:
            if self.color_data.is_masked():
                color_data, color_mask = self.color_data.get_data_mask()
                point_mask = point_mask & color_mask
            else:
                color_data = self.color_data.get_data()

            #color_nan_mask = isreal(color_data)
            color_nan_mask = invert(isnan(color_data))

            point_mask = point_mask & color_nan_mask
            points = transpose(array((index, value, color_data)))
        else:
            points = transpose(array((index, value)))


        self._cached_data_pts = points[point_mask]
        self._cached_point_mask = point_mask

        self._cache_valid = True
        return

    def _render(self, gc, points):
        """ Actually draws the plot.

        Overrides the ScatterPlot implementation.
        """
        # If we don't have a color data set, then use the base class to render
        if (self.color_mapper is None) or (self.color_data is None):
            return super(ColormappedScatterPlot, self)._render(gc, points)

        # If the GC doesn't have draw_*_at_points, then use bruteforce
        if hasattr(gc, 'draw_marker_at_points') or hasattr(gc, 'draw_path_at_points'):
            batch_capable = True
        else:
            batch_capable = False

        if self.render_method == 'auto':
            method = self._calc_render_method(len(points))
        else:
            method = self.render_method

        with gc:
            if method == 'bruteforce' or (not batch_capable):
                self._render_bruteforce(gc, points)
            elif method == 'banded':
                self._render_banded(gc, points)
        return


    #------------------------------------------------------------------------
    # Private methods
    #------------------------------------------------------------------------

    def _compute_bands(self, points, smartmode=False):
        """
        Sorts self.data into a list of arrays of data points by color,
        filling in self._index_bands.  If *smartmode* is True, then it first
        calls _calc_render_method() to see which rendering method is
        optimal for the number of points and the distribution of
        color indices; if the rendering method is 'bruteforce', then
        this method short-circuits and returns without doing
        anything.
        """
        if len(points) == 0:
            return
        if self.color_mapper is None:
            return

        # map the V values in the (x,y,v) self.data array

        color_data = points[:,2]
        color_indices = self.color_mapper.map_index(color_data)

        if smartmode and self.render_method == 'bruteforce':
             pass
        else:
            # shuffle_indices indicates how to sort the points in self.data
            # so that their color_indices are in order.  We don't really care
            # about the sorting so much as the fact that once they are sorted,
            # points of the same color are grouped together into "bands".
            shuffle_indices = argsort(color_indices)

            # This pulls values from the color_indices array into
            # sorted_color_indices, using the results of the sort we just did.
            sorted_color_indices = take(color_indices, shuffle_indices)

            # Now we want to determine where the continuous bands are.  We do
            # this by right-shifting the sorted_color_indices array, subtracting
            # it from the original, and looking for all the nonzero points.
            shifted = right_shift(sorted_color_indices, sorted_color_indices[0])
            start_indices = concatenate([[0], nonzero(sorted_color_indices - shifted)[0]])
            end_indices = left_shift(start_indices, len(sorted_color_indices))

            # Store the shuffled indices in self._index_bands.  We don't store the
            # actual data points because we need to allow the renderer to index into
            # the mapped XY screen positions.
            self._index_bands = {}
            for (start, end) in zip(start_indices, end_indices):
                color_index = sorted_color_indices[start]
                self._index_bands[color_index] = shuffle_indices[start:end]

        self._color_indices = color_indices
        self._cache_valid = True
        return

    def _calc_render_method(self, numpoints):
        """ Returns a string indicating the render method.
        """
        if numpoints > 1000 and isinstance(self.marker_size, float):
            return 'banded'
        else:
            return "bruteforce"

    def _set_draw_info(self, gc, mode, color, outline_color=None, outline_weight=None):
        """ Sets the stroke color, fill color, and line width on the graphics
        context.
        """
        color = tuple(color[:3]) + (self.fill_alpha,)
        if mode == STROKE:
            if outline_color is not None:
                gc.set_stroke_color( color )
        else:
            if outline_color is not None:
                gc.set_stroke_color( outline_color )
            gc.set_fill_color( color )
        if outline_weight is not None:
            gc.set_line_width(outline_weight)
        return

    def _render_banded(self, gc, points):
        """ Draws the points color-band by color-band.
        """
        self._compute_bands(points)

        # Grab the XY values corresponding to each color band of points

        xy_points = points[:,0:2]

        marker = self.marker_
        size = self.marker_size
        assert isinstance(size, float), "Variable size markers not implemented for banded rendering"

        # Set up the GC for drawing
        gc.set_line_dash( None )
        if marker.draw_mode == STROKE:
            gc.set_line_width(self.line_width)

        gc.begin_path()

        cmap = self.color_mapper

        if (hasattr(gc, 'draw_marker_at_points') and self.marker not in ('custom', 'circle', 'diamond')):
            # This is the fastest method: we use one of the built-in markers.
            color_bands = cmap.color_bands
            # Initial setup of drawing parameters
            self._set_draw_info(gc, marker.draw_mode, color_bands[0],
                                self.outline_color_, self.line_width)
            index_bands = self._index_bands
            mode = marker.draw_mode
            for color_index in index_bands.keys():
                self._set_draw_info(gc, mode, color_bands[color_index])
                gc.draw_marker_at_points(xy_points[index_bands[color_index]], size, marker.kiva_marker)


        elif hasattr( gc, 'draw_path_at_points' ):
            point_bands = {}
            for color_index, indices in self._index_bands.items():
                point_bands[color_index] = xy_points[indices]
            # We have to construct the path for the marker.
            if self.marker != 'custom':
                path = gc.get_empty_path()
                # turn the class into an instance... we should make add_to_path a
                # class method at some point.
                marker().add_to_path(path, size)
                mode = marker.draw_mode
            else:
                path = self.custom_symbol
                mode = STROKE

            color_bands = cmap.color_bands
            for color_index, xy in point_bands.items():
                self._set_draw_info(gc, mode, color_bands[color_index],
                                    self.outline_color_, self.line_width)
                gc.draw_path_at_points(xy, path, mode)
        else:
            raise RuntimeError, "Batch drawing requested on non-batch-capable GC."
        return

    def _render_bruteforce(self, gc, points):
        """ Draws the points, setting the stroke color for each one.
        """
        x, y, colors = transpose(points)

        # Map the colors
        colors = self.color_mapper.map_screen(colors)
        alphas = (zeros(len(colors))+self.fill_alpha)[:, newaxis]
        colors = concatenate((colors[:, :3], alphas), axis=1)

        with gc:
            gc.clip_to_rect(self.x, self.y, self.width, self.height)
            gc.set_stroke_color(self.outline_color_)
            gc.set_line_width(self.line_width)

            marker_cls = self.marker_
            marker_size = self.marker_size
            if isinstance(marker_size, ndarray) and self._cached_point_mask is not None:
                marker_size = marker_size[self._cached_point_mask]
            mode = marker_cls.draw_mode

            if marker_cls != "custom":
                if (hasattr(gc, "draw_marker_at_points") and self.marker not in ('custom', 'circle', 'diamond')):
                    draw_func = lambda x, y, size: gc.draw_marker_at_points([[x,y]], size, marker_cls.kiva_marker)

                elif hasattr(gc, "draw_path_at_points"):
                    # turn the class into an instance... we should make add_to_path a
                    # class method at some point.
                    m = marker_cls()
                    def draw_func(x, y, size):
                        path = gc.get_empty_path()
                        m.add_to_path(path, size)
                        gc.draw_path_at_points([[x, y]], path, mode)
                else:
                    m = marker_cls()
                    def draw_func(x, y, size):
                        gc.translate_ctm(x, y)
                        gc.begin_path()
                        m.add_to_path(gc, size)
                        gc.draw_path(mode)
                        gc.translate_ctm(-x, -y)

                for i in range(len(x)):
                    if isinstance(marker_size, float):
                        size = marker_size
                    else:
                        size = marker_size[i]
                    gc.set_fill_color(colors[i])
                    draw_func(x[i], y[i], size)

            else:
                path = marker_cls.custom_symbol
                for i in range(len(x)):
                    gc.set_fill_color(colors[i])
                    gc.draw_path_at_points([[x[i], y[i]]], path, STROKE)


    #------------------------------------------------------------------------
    # Event handlers
    #------------------------------------------------------------------------

    def _color_data_changed(self, old, new):
        if old is not None:
            old.on_trait_change(self._either_data_changed, "data_changed", remove=True)
        if new is not None:
            new.on_trait_change(self._either_data_changed, "data_changed")
        self._either_data_changed()
        return

    def _color_mapper_changed(self, old, new):
        self._cache_valid = False

        if hasattr(new, 'range') and new.range is None and old is not None:
            # Someone passed in a ColorMapper that has no range associated with
            # it. Use the range on the old ColorMapper.
            new.range = old.range

        self.invalidate_draw()
        self.request_redraw()

        return

    def _fill_alpha_changed(self):
        self.invalidate_draw()
        self.request_redraw()
        return


# EOF

########NEW FILE########
__FILENAME__ = colormapped_selection_overlay
""" Defines the ColormappedSelectionOverlay class.
"""
from numpy import logical_and

# Enthought library imports
from traits.api import Any, Bool, Float, Instance, Property, Enum

# Local imports
from abstract_overlay import AbstractOverlay
from colormapped_scatterplot import ColormappedScatterPlot

class ColormappedSelectionOverlay(AbstractOverlay):
    """
    Overlays and changes a ColormappedScatterPlot to fade its non-selected
    points to a very low alpha.
    """

    # The ColormappedScatterPlot that this overlay is listening to.
    # By default, it looks at self.component
    plot = Property

    # The amount to fade the unselected points.
    fade_alpha = Float(0.15)

    # The minimum difference, in float percent, between the starting and ending
    # selection values, if range selection mode is enabled
    minimum_delta = Float(0.01)

    # Outline width for selected points.
    selected_outline_width = Float(1.0)
    # Outline width for unselected points.
    unselected_outline_width = Float(0.0)

    # The type of selection used by the data source.
    selection_type = Enum('range', 'mask')

    _plot = Instance(ColormappedScatterPlot)

    _visible = Bool(False)

    _old_alpha = Float
    _old_outline_color = Any
    _old_line_width = Float(0.0)

    def __init__(self, component=None, **kw):
        super(ColormappedSelectionOverlay, self).__init__(**kw)
        self.component = component
        return

    def overlay(self, component, gc, view_bounds=None, mode="normal"):
        """ Draws this component overlaid on another component.

        Implements AbstractOverlay.
        """
        if not self._visible:
            return

        plot = self.plot
        datasource = plot.color_data

        if self.selection_type == 'range':
            selections = datasource.metadata["selections"]

            if selections is not None and len(selections) == 0:
                return

            low, high = selections
            if abs(high - low) / abs(high + low) < self.minimum_delta:
                return

            # Mask the data with just the points falling within the data
            # range selected on the colorbar
            data_pts = datasource.get_data()
            mask = (data_pts >= low) & (data_pts <= high)

        elif self.selection_type == 'mask':
            mask = reduce(logical_and, datasource.metadata["selection_masks"])
            if sum(mask)<2:
                return

        datasource.set_mask(mask)

        # Store the current plot color settings before overwriting them
        fade_outline_color = plot.outline_color_

        # Overwrite marker outline color and fill alpha settings of
        # the plot, then manually invoke the plot to draw onto the GC.
        plot.outline_color = list(self._old_outline_color[:3]) + [1.0]
        plot.fill_alpha = 1.0
        plot.line_width = self.selected_outline_width
        plot._draw_plot(gc, view_bounds, mode)


        # Restore the plot's previous color settings and data mask.
        plot.fill_alpha = self.fade_alpha
        plot.outline_color = fade_outline_color
        plot.line_width = self.unselected_outline_width
        datasource.remove_mask()
        return

    def _component_changed(self, old, new):
        if old:
            old.on_trait_change(self.datasource_change_handler, "color_data", remove=True)
        if new:
            new.on_trait_change(self.datasource_change_handler, "color_data")
            self._old_alpha = new.fill_alpha
            self._old_outline_color = new.outline_color
            self._old_line_width = new.line_width
            self.datasource_change_handler(new, "color_data", None, new.color_data)
        return

    def datasource_change_handler(self, obj, name, old, new):
        if old:
            old.on_trait_change(self.selection_change_handler, "metadata_changed", remove=True)
        if new:
            new.on_trait_change(self.selection_change_handler, "metadata_changed")
            self.selection_change_handler(new, "metadata_changed", None, new.metadata)
        return

    def selection_change_handler(self, obj, name, old, new):
        if self.selection_type == 'range':
            selection_key = 'selections'
        elif self.selection_type == 'mask':
            selection_key = 'selection_masks'

        if type(new) == dict and new.get(selection_key, None) is not None \
                             and len(new[selection_key]) > 0:
            if not self._visible:
                # We have a new selection, so replace the colors on the plot with the
                # faded alpha and colors
                plot = self.plot

                # Save the line width and set it to zero for the unselected points
                self._old_line_width = plot.line_width
                plot.line_width = self.unselected_outline_width
                # Save the outline color and set it to the faded version
                self._old_outline_color = plot.outline_color_
                outline_color = list(plot.outline_color_)
                if len(outline_color) == 3:
                    outline_color += [self.fade_alpha]
                else:
                    outline_color[3] = self.fade_alpha
                plot.outline_color = outline_color

                # Save the alpha value and set it to a faded version
                self._old_alpha = plot.fill_alpha
                plot.fill_alpha = self.fade_alpha

            self.plot.invalidate_draw()
            self._visible = True
        else:
            self.plot.fill_alpha = self._old_alpha
            self.plot.outline_color = self._old_outline_color
            self.plot.line_width = self._old_line_width
            self.plot.invalidate_draw()
            self._visible = False

        self.plot.request_redraw()
        return

    def _get_plot(self):
        if self._plot is not None:
            return self._plot
        else:
            return self.component

    def _set_plot(self, val):
        self._plot = val


# EOF

########NEW FILE########
__FILENAME__ = color_bar
""" Defines the ColorBar class.
"""

from __future__ import with_statement

# Major library imports
from numpy import array, arange, ascontiguousarray, ones, transpose, uint8

# Enthought library imports
from traits.api import Any, Bool, Enum, Instance, Property, \
                                 cached_property, on_trait_change
from kiva.image import GraphicsContext

# Local imports
from base_xy_plot import BaseXYPlot
from abstract_plot_renderer import AbstractPlotRenderer
from abstract_mapper import AbstractMapper
from array_data_source import ArrayDataSource
from grid import PlotGrid
from axis import PlotAxis


class ColorBar(AbstractPlotRenderer):
    """ A color bar for a color-mapped plot.
    """
    # Screen mapper for index data.
    index_mapper = Instance(AbstractMapper)

    # Screen mapper for color data
    color_mapper = Property #Instance(ColorMapper)

    # Screen mapper for value data (synonym for color_mapper)
    value_mapper = Property(depends_on='color_mapper')

    # Optional index data source for generic tools to attach metadata to.
    index = Property

    # Optional color-mapped plot that this color bar references.  If specified,
    # the plot must have a **color_mapper** attribute.
    plot = Any

    # Is there a visible grid on the colorbar?
    grid_visible = Bool(True)

    # Is there a visible axis on the colorbar?
    axis_visible = Bool(True)

    # Corresponds to either **index_mapper** or None, depending on
    # the orientation of the plot.
    x_mapper = Property
    # Corresponds to either **index_mapper** or None, depending on
    # the orientation of the plot.
    y_mapper = Property

    #------------------------------------------------------------------------
    # Override default values of inherited traits
    #------------------------------------------------------------------------

    # The border is visible (overrides enable.Component).
    border_visible = True
    # The orientation of the index axis.
    orientation = Enum('v', 'h')
    # Should the bar go left-to-right or bottom-to-top (normal) or the reverse?
    direction = Enum('normal', 'flipped')
    # Overrides the default background color trait in PlotComponent.
    bgcolor = 'transparent'
    # Draw layers in "draw order"
    use_draw_order = True
    # Default width is 40 pixels (overrides enable.CoordinateBox)
    width = 40

    # Faux origin for the axis to look at
    origin = Enum('bottom left', 'top left', 'bottom right', 'top right')

    #------------------------------------------------------------------------
    # Private attributes
    #------------------------------------------------------------------------

    # The grid
    _grid = Instance(PlotGrid)

    # The axis
    _axis = Instance(PlotAxis)

    # Shadow attribute for color_mapper
    _color_mapper = Any

    # Shadow attribute for index
    _index = Instance(ArrayDataSource, args=())

    def __init__(self, *args, **kw):
        """ In creating an instance, this method ensures that the grid and the
        axis are created before setting their visibility.
        """
        grid_visible = kw.pop("grid_visible", True)
        axis_visible = kw.pop("axis_visible", True)

        super(ColorBar, self).__init__(*args, **kw)

        if self.orientation == 'h':
            if self.direction == 'normal':
                self.origin = 'bottom left'
            else:
                self.origin = 'bottom right'
            grid_orientation = 'vertical'
            axis_orientation = 'bottom'
        else:
            if self.direction == 'normal':
                self.origin = 'bottom left'
            else:
                self.origin = 'top left'
            grid_orientation = 'horizontal'
            axis_orientation = 'left'

        self._grid = PlotGrid(orientation=grid_orientation,
                              mapper=self.index_mapper,
                              component=self)
        self._axis = PlotAxis(orientation=axis_orientation,
                              mapper=self.index_mapper,
                              component=self)
        self.overlays.append(self._grid)
        self.overlays.append(self._axis)

        # Now that we have a grid and an axis, we can safely set the visibility
        self.grid_visible = grid_visible
        self.axis_visible = axis_visible
        return

    def _draw_plot(self, gc, view_bounds=None, mode='normal'):
        """ Draws the 'plot' layer.
        """
        self._update_mappers()
        with gc:
            if self.orientation == 'h':
                perpendicular_dim = 1
                axis_dim = 0
            else:
                perpendicular_dim = 0
                axis_dim = 1

            mapper = self.index_mapper

            scrn_points = arange(mapper.low_pos, mapper.high_pos+1)

            # Get the data values associated with the list of screen points.
            if mapper.range.low == mapper.range.high:
                # LogMapper.map_data() returns something unexpected if low==high,
                # so we'll handle that case here.
                data_points = array([mapper.range.high])
            else:
                data_points = mapper.map_data(scrn_points)

            if self.direction == 'flipped':
                data_points = data_points[::-1]

            # Get the colors associated with the data points.
            colors = self.color_mapper.map_screen(data_points)

            img = self._make_color_image(colors, self.bounds[perpendicular_dim],
                                                    self.orientation, self.direction)
            gc.draw_image(img, (self.x, self.y, self.width, self.height))

    def _make_color_image(self, color_values, width, orientation, direction):
        """
        Returns an image graphics context representing the array of color
        values (Nx3 or Nx4). The *width* parameter is the width of the
        colorbar, and *orientation* is the orientation of the plot.
        """
        bmparray = ones((width, color_values.shape[0],
                                    color_values.shape[1]))* color_values * 255

        if orientation == "v":
            bmparray = ascontiguousarray(transpose(bmparray, axes=(1,0,2))[::-1])
        bmparray = bmparray.astype(uint8)
        img = GraphicsContext(bmparray, "rgba32")
        return img


    #------------------------------------------------------------------------
    # Trait events
    #------------------------------------------------------------------------

    def _update_mappers(self):
        if not self.index_mapper or not self.color_mapper:
            return
        if self.orientation == 'h' and 'left' in self.origin:
            self.index_mapper.low_pos = self.x
            self.index_mapper.high_pos = self.x2
        elif self.orientation == 'h' and 'right' in self.origin:
            self.index_mapper.low_pos = self.x2
            self.index_mapper.high_pos = self.x
        elif self.orientation == 'v' and 'bottom' in self.origin:
            self.index_mapper.low_pos = self.y
            self.index_mapper.high_pos = self.y2
        elif self.orientation == 'v' and 'top' in self.origin:
            self.index_mapper.low_pos = self.y2
            self.index_mapper.high_pos = self.y
        self.index_mapper.range = self.color_mapper.range

    def _bounds_changed(self, old, new):
        super(ColorBar, self)._bounds_changed(old, new)
        self._update_mappers()

    def _bounds_items_changed(self, event):
        super(ColorBar, self)._bounds_items_changed(event)
        self._update_mappers()

    def _position_changed(self, old, new):
        super(ColorBar, self)._position_changed(old, new)
        self._update_mappers()

    def _position_items_changed(self, event):
        super(ColorBar, self)._position_items_changed(event)
        self._update_mappers()

    def _updated_changed_for_index_mapper(self):
        self._update_mappers()

    def _updated_changed_for_color_mapper(self):
        self._update_mappers()

    @on_trait_change('[index_mapper,color_mapper].+')
    def _either_mapper_changed(self):
        self.invalidate_draw()
        self.request_redraw()

    def _index_mapper_changed(self):
        # Keep the grid and axis index_mappers the same as our index_mapper.
        if self._grid is not None:
            self._grid.mapper = self.index_mapper
        if self._axis is not None:
            self._axis.mapper = self.index_mapper
        self._either_mapper_changed()

    def _color_mapper_changed(self):
        self._either_mapper_changed()

    def _value_mapper_changed(self):
        self._color_mapper_changed()

    def _plot_changed(self):
        self.request_redraw()

    def _grid_visible_changed(self, old, new):
        self._grid.visible = new
        self.request_redraw()

    def _axis_visible_changed(self, old, new):
        self._axis.visible = new
        self.request_redraw()

    #------------------------------------------------------------------------
    # Property setters and getters
    #------------------------------------------------------------------------

    def _get_x_mapper(self):
        if self.orientation == "h":
            return self.index_mapper
        else:
            return None

    def _get_y_mapper(self):
        if self.orientation == "h":
            return None
        else:
            return self.index_mapper

    def _get_color_mapper(self):
        if self.plot:
            return self.plot.color_mapper
        elif self._color_mapper:
            return self._color_mapper
        else:
            return None

    def _set_color_mapper(self, val):
        self._color_mapper = val

    @cached_property
    def _get_value_mapper(self):
        return self._get_color_mapper()

    def _set_value_mapper(self, val):
        self._set_color_mapper(val)

    def _get_index(self):
        if self.plot and hasattr(self.plot, "color_data"):
            return self.plot.color_data
        elif self.plot and isinstance(self.plot, BaseXYPlot):
            return self.plot.index
        elif self._index:
            return self._index
        else:
            return None

    def _set_index(self, val):
        self._index = val


# EOF

########NEW FILE########
__FILENAME__ = color_mapper
""" Defines the ColorMapper and ColorMapTemplate classes.
"""

# Major library imports
from types import IntType, FloatType
from numpy import arange, array, asarray, clip, divide, float32, int8, isinf, \
        isnan, ones, searchsorted, sometrue, sort, take, uint8, where, zeros, \
        linspace, ones_like

# Enthought library imports
from traits.api import Any, Array, Bool, Dict, Event, Float, HasTraits, \
                                 Int, Property, Str, Trait

# Relative imports
from abstract_colormap import AbstractColormap
from data_range_1d import DataRange1D

from speedups import map_colors, map_colors_uint8


class ColorMapTemplate(HasTraits):
    """
    A class representing the state of a ColorMapper, for use when persisting
    plots.
    """
    # The segment data of the color map.
    segment_map = Any
    # The number of steps in the color map.
    steps = Int(256)
    # Low end of the color map range.
    range_low_setting = Trait('auto', 'auto', Float)
    # High end of the color map range.
    range_high_setting = Trait('auto', 'auto', Float)

    def __init__(self, colormap=None, **kwtraits):
        """
        Creates this template from a color map instance or creates an empty
        template.
        """
        if colormap:
            self.from_colormap(colormap)
        return

    def from_colormap(self, colormap):
        """ Populates this template from a color map.
        """
        self.segment_map = colormap._segmentdata.copy()
        self.steps = colormap.steps
        self.range_low_setting = colormap.range.low_setting
        self.range_high_setting = colormap.range.high_setting
        return

    def to_colormap(self, range=None):
        """ Returns a ColorMapper instance from this template.
        """
        colormap = ColorMapper(self.segment_map, steps = self.steps)
        if range:
            colormap.range = range
        else:
            colormap.range = DataRange1D(low = self.range_low_setting,
                                       high = self.range_high_setting)
        return colormap



class ColorMapper(AbstractColormap):
    """ Represents a simple band-of-colors style of color map.

    The look-up transfer function is a simple linear function between defined
    intensities.  There is no limit to the number of steps that can be
    defined. If the segment intervals contain very few array
    locations, quantization errors will occur.

    Construction of a ColorMapper can be done through the factory methods
    from_palette_array() and from_segment_map(). Do not make direct calls to the
    ColorMapper constructor.
    """

    # The color table.
    color_bands = Property(Array)

    # The total number of color steps in the map.
    steps = Int(256)

    # The name of this color map.
    name = Str

    # Not used.
    low_pos = None
    # Not used.
    high_pos = None

    # A generic "update" event that generally means that anything that relies
    # on this mapper for visual output should do a redraw or repaint.
    updated = Event

    # Are the mapping arrays out of date?
    _dirty = Bool(True)

    # The raw segment data for creating the mapping array.
    _segmentdata = Dict  # (Str, Tuple | List)


    #------------------------------------------------------------------------
    # Static methods.
    #------------------------------------------------------------------------

    @classmethod
    def from_palette_array(cls, palette, **traits):
        """ Creates a ColorMapper from a palette array.

        The palette colors are linearly interpolated across the range of
        mapped values.

        The *palette* parameter is a Nx3 or Nx4 array of intensity values, where
        N > 1::

            [[R0, G0, B0], ... [R(N-1), G(N-1), B(N-1)]]

            [[R0, G0, B0, A0], ... [R(N-1), G(N-1), B(N-1), A(N-1]]
        """

        palette = asarray(palette)
        n_colors, n_components = palette.shape
        if n_colors < 2:
            raise ValueError("Palette must contain at least two colors.")
        if n_components not in (3,4):
            raise ValueError("Palette must be of RGB or RGBA colors. "
                "Got %s color components." % n_components)

        # Compute the % offset for each of the color locations.
        offsets = linspace(0.0, 1.0, n_colors)

        # From the offsets and the color data, generate a segment map.
        segment_map = {}
        red_values = palette[:,0]
        segment_map['red'] = zip(offsets, red_values, red_values)
        green_values = palette[:,1]
        segment_map['green'] = zip(offsets, green_values, green_values)
        blue_values = palette[:,2]
        segment_map['blue'] = zip(offsets, blue_values, blue_values)
        if n_components == 3:
            alpha_values = ones(n_colors)
        else:
            alpha_values = palette[:,3]
        segment_map['alpha'] = zip(offsets, alpha_values, alpha_values)

        return cls(segment_map, **traits)

    @classmethod
    def from_segment_map(cls, segment_map, **traits):
        """ Creates a Colormapper from a segment map.

        The *segment_map* parameter is a dictionary with 'red', 'green', and
        'blue' (and optionally 'alpha') entries.  Each entry is a list of
        (x, y0, y1) tuples:

        * x: an offset in [0..1] (offsets within the list must be in ascending order)
        * y0: value for the color channel for values less than or equal to x
        * y1: value for the color channel for values greater than x

        When a data value gets mapped to a color, it will be normalized to be
        within [0..1]. For each RGB(A) component, the two adjacent values will
        be found in the segment_map. The mapped component value will be found by
        linearly interpolating the two values.

        Generally, y0==y1. Colormaps with sharp transitions will have y0!=y1 at
        the transitions.
        """

        if 'alpha' not in segment_map:
            segment_map = segment_map.copy()
            segment_map['alpha'] = [(0.0, 1.0, 1.0), (1.0, 1.0, 1.0)]
        return cls(segment_map, **traits)

    @classmethod
    def from_file(cls, filename, **traits):
        """ Creates a ColorMapper from a file.

        The *filename* parameter is the name of a file whose lines each contain
        4 or 5 float values between 0.0 and 1.0. The first value is an offset in
        the range [0..1], and the remaining 3 or 4 values are red, green, blue,
        and optionally alpha values for the color corresponding to that offset.

        The first line is assumed to contain the name of the colormap.
        """
        colormap_file = open(filename, 'r')
        lines = colormap_file.readlines()
        colormap_file.close()
        rgba_arr = [[],[],[],[]]
        for line in lines[1:]:
            strvalues = line.strip().split()
            values = [float32(value) for value in strvalues]
            if len(values) > 4:
                channels = (0,1,2,3)
            else:
                channels = (0,1,2)
            for i in channels:
                channeltuple = (values[0], values[i+1], values[i+1])
                rgba_arr[i].append(channeltuple)
        # Alpha is frequently unspecified.
        if len(rgba_arr[-1]) == 0:
            rgba_arr[-1] = [(0.0, 1.0, 1.0), (1.0, 1.0, 1.0)]
        if 'name' not in traits:
            # Don't override the code.
            traits['name'] = lines[0].strip()
        rgba_dict = {
            'red': rgba_arr[0],
            'green': rgba_arr[1],
            'blue': rgba_arr[2],
            'alpha': rgba_arr[3],
        }

        return cls(rgba_dict, **traits)


    #------------------------------------------------------------------------
    # Public methods
    #------------------------------------------------------------------------

    def __init__(self, segmentdata, **kwtraits):
        """ Creates a Colormapper from a segment map.

        The *segment_map* parameter is a dictionary with 'red', 'green', and
        'blue' (and optionally 'alpha') entries.  Each entry is a list of
        (x, y0, y1) tuples:

        * x: an offset in [0..1] (offsets within the list must be in ascending order)
        * y0: value for the color channel for values less than or equal to x
        * y1: value for the color channel for values greater than x

        When a data value gets mapped to a color, it will be normalized to be
        within [0..1]. For each RGB(A) component, the two adjacent values will
        be found in the segment_map. The mapped component value will be found by
        linearly interpolating the two values.

        Generally, y0==y1. Colormaps with sharp transitions will have y0!=y1 at
        the transitions.
        """
        self._segmentdata = segmentdata
        super(ColorMapper, self).__init__(**kwtraits)
        return


    def map_screen(self, data_array):
        """ Maps an array of data values to an array of colors.
        """
        if self._dirty:
            self._recalculate()

        rgba = map_colors(data_array, self.steps, self.range.low,
                self.range.high, self._red_lut, self._green_lut,
                self._blue_lut, self._alpha_lut)

        return rgba


    def map_index(self, ary):
        """ Maps an array of values to their corresponding color band index.
        """

        if self._dirty:
            self._recalculate()

        indices = (ary - self.range.low) / (self.range.high - self.range.low) * self.steps

        return clip(indices.astype(IntType), 0, self.steps - 1)

    def reverse_colormap(self):
        """ Reverses the color bands of this colormap.
        """
        for name in ("red", "green", "blue", "alpha"):
            data = asarray(self._segmentdata[name])
            data[:, (1,2)] = data[:, (2,1)]
            data[:,0] = (1.0 - data[:,0])
            self._segmentdata[name] = data[::-1]
        self._recalculate()

    def map_uint8(self, data_array):
        """ Maps an array of data values to an array of colors.
        """
        if self._dirty:
            self._recalculate()

        rgba = map_colors_uint8(data_array, self.steps, self.range.low,
                self.range.high, self._red_lut_uint8, self._green_lut_uint8,
                self._blue_lut_uint8, self._alpha_lut_uint8)

        return rgba


    #------------------------------------------------------------------------
    # Private methods
    #------------------------------------------------------------------------


    def _get_color_bands(self):
        """ Gets the color bands array.
        """
        if self._dirty:
            self._recalculate()

        luts = [self._red_lut, self._green_lut, self._blue_lut]
        if self.color_depth is 'rgba':
            luts.append(self._alpha_lut)

        result = zip(*luts)

        return result

    def _recalculate(self):
        """ Recalculates the mapping arrays.
        """

        self._red_lut = self._make_mapping_array(
            self.steps, self._segmentdata['red']
        )
        self._green_lut = self._make_mapping_array(
            self.steps, self._segmentdata['green']
        )
        self._blue_lut = self._make_mapping_array(
            self.steps, self._segmentdata['blue']
        )
        self._alpha_lut = self._make_mapping_array(
            self.steps, self._segmentdata['alpha']
        )
        self._red_lut_uint8 = (self._red_lut * 255.0).astype('uint8')
        self._green_lut_uint8 = (self._green_lut * 255.0).astype('uint8')
        self._blue_lut_uint8 = (self._blue_lut * 255.0).astype('uint8')
        self._alpha_lut_uint8 = (self._alpha_lut * 255.0).astype('uint8')
        self.updated = True
        self._dirty = False

        return

    #### matplotlib ####
    def _make_mapping_array(self, n, data):
        """Creates an N-element 1-D lookup table

        The *data* parameter is a list of x,y0,y1 mapping correspondences (which
        can be lists or tuples), where all the items are values between 0 and 1,
        inclusive. The items in the mapping are:

        * x: a value being mapped
        * y0: the value of y for values of x less than or equal to the given x value.
        * y1: the value of y for values of x greater than the given x value.

        The two values of y allow for discontinuous mapping functions (for
        example, as might be found in a sawtooth function)

        The list must start with x=0, end with x=1, and
        all values of x must be in increasing order. Values between
        the given mapping points are determined by simple linear interpolation.

        The function returns an array "result" where result[x*(N-1)]
        gives the closest value for values of x between 0 and 1.
        """

        try:
            adata = array(data)
        except:
            raise TypeError("data must be convertable to an array")
        shape = adata.shape
        if len(shape) != 2 and shape[1] != 3:
            raise ValueError("data must be nx3 format")

        x  = adata[:,0]
        y0 = adata[:,1]
        y1 = adata[:,2]

        if x[0] != 0. or x[-1] != 1.0:
            raise ValueError(
                "data mapping points must start with x=0. and end with x=1")
        if sometrue(sort(x)-x):
            raise ValueError(
                "data mapping points must have x in increasing order")
        # begin generation of lookup table
        x = x * (n-1)
        lut = zeros((n,), float32)
        xind = arange(float32(n), dtype=float32)
        ind = searchsorted(x, xind)[1:-1]

        lut[1:-1] = ( divide(xind[1:-1] - take(x,ind-1),
                             take(x,ind)-take(x,ind-1) )
                      *(take(y0,ind)-take(y1,ind-1)) + take(y1,ind-1))
        lut[0] = y1[0]
        lut[-1] = y0[-1]

        # ensure that the lut is confined to values between 0 and 1 by clipping it
        lut = lut.clip(0, 1)
        return lut

    #### matplotlib ####
    def _map(self, X):
        """ Maps from a scalar or an array to an RGBA value or array.

        The *X* parameter is either a scalar or an array (of any dimension).
        If it is scalar, the function returns a tuple of RGBA values; otherwise
        it returns an array with the new shape = oldshape+(4,).  Any values
        that are outside the 0,1 interval are clipped to that interval before
        generating RGB values.

        This is no longer used in this class. It has been deprecated and
        retained for API compatibility.

        """

        if type(X) in [IntType, FloatType]:
            vtype = 'scalar'
            xa = array([X])
        else:
            vtype = 'array'
            xa = asarray(X)

        # assume the data is properly normalized
        #xa = where(xa>1.,1.,xa)
        #xa = where(xa<0.,0.,xa)


        nanmask = isnan(xa)
        xa = where(nanmask, 0, (xa * (self.steps-1)).astype(int))
        rgba = zeros(xa.shape+(4,), float)
        rgba[...,0] = where(nanmask, 0, take(self._red_lut, xa))
        rgba[...,1] = where(nanmask, 0, take(self._green_lut, xa))
        rgba[...,2] = where(nanmask, 0, take(self._blue_lut, xa))
        rgba[...,3] = where(nanmask, 0, take(self._alpha_lut, xa))
        if vtype == 'scalar':
            rgba = tuple(rgba[0,:])

        return rgba

    def _range_changed(self, old, new):
        if old is not None:
            old.on_trait_change(self._range_change_handler, "updated",
                                remove = True)
        if new is not None:
            new.on_trait_change(self._range_change_handler, "updated")

        self.updated = new

    def _range_change_handler(self, obj, name, new):
        "Handles the range changing; dynamically attached to our ranges"
        self.updated = obj



# EOF

########NEW FILE########
__FILENAME__ = contour_line_plot
""" Defines the ContourLinePlot class.
"""

from __future__ import with_statement

# Major library imports
from numpy import array, linspace, meshgrid, transpose

# Enthought library imports
from enable.api import LineStyle
from kiva import constants
from traits.api import Bool, Dict, Float, List, Str, Trait

# Local relative imports
from base_contour_plot import BaseContourPlot
from contour.contour import Cntr


class ContourLinePlot(BaseContourPlot):
    """ Takes a value data object whose elements are scalars, and renders them
    as a contour plot.
    """

    # TODO: Modify ImageData to explicitly support scalar value arrays

    #------------------------------------------------------------------------
    # Data-related traits
    #------------------------------------------------------------------------

    # The thickness(es) of the contour lines.
    # It can be either a scalar value, valid for all contour lines, or a list
    # of widths. If the list is too short with respect to then number of
    # contour lines, the values are repeated from the beginning of the list.
    # Widths are associated with levels of increasing value.
    widths = Trait(1.0, Float, List)

    # The line dash style(s).
    styles = Trait("signed", Str, List)

    # Line style for positive levels.
    positive_style = LineStyle("solid")

    # Line style for negative levels.
    negative_style = LineStyle("dash")

    #------------------------------------------------------------------------
    # Private traits
    #------------------------------------------------------------------------

    # Are the cached contours valid? If False, new ones need to be computed.
    _contour_cache_valid = Bool(False)

    # Cached collection of traces.
    _cached_contours = Dict

    # Is the cached width data valid?
    _widths_cache_valid = Bool(False)

    # Is the cached style data valid?
    _styles_cache_valid = Bool(False)

    # Cached list of line widths
    _widths = List

    # Cached list of line styles
    _styles = List

    # Mapped trait used to convert user-supplied line style values to
    # AGG-acceptable ones. (Mapped traits in lists are not supported, must be
    # converted one at a time.)
    _style_map_trait = LineStyle

    #------------------------------------------------------------------------
    # Private methods
    #------------------------------------------------------------------------

    def _render(self, gc):
        """ Actually draws the plot.

        Implements the Base2DPlot interface.
        """
        if not self._level_cache_valid:
            self._update_levels()
        if not self._contour_cache_valid:
            self._update_contours()
        if not self._widths_cache_valid:
            self._update_widths()
        if not self._styles_cache_valid:
            self._update_styles()
        if not self._colors_cache_valid:
            self._update_colors()

        with gc:
            gc.set_antialias(True)
            gc.clip_to_rect(self.x, self.y, self.width, self.height)
            gc.set_alpha(self.alpha)
            gc.set_line_join(constants.JOIN_BEVEL)
            gc.set_line_cap(constants.CAP_ROUND)

            for i in range(len(self._levels)):
                gc.set_stroke_color(self._colors[i])
                gc.set_line_width(self._widths[i])
                gc.set_line_dash(self._styles[i])
                for trace in self._cached_contours[self._levels[i]]:
                    if self.orientation == "h":
                        strace = self.index_mapper.map_screen(trace)
                    else:
                        strace = array(self.index_mapper.map_screen(trace))[:,::-1]
                    gc.begin_path()
                    gc.lines(strace)
                    gc.stroke_path()

    def _update_contours(self):
        """ Updates the cache of contour lines """
        # x and y data are "fenceposts" so ignore the last value
        # XXX: this truncation is causing errors in Cntr() as of r13735
        xdata = self.index._xdata.get_data()
        ydata = self.index._ydata.get_data()
        xs = linspace(xdata[0], xdata[-1], len(xdata)-1)
        ys = linspace(ydata[0], ydata[-1], len(ydata)-1)
        xg, yg = meshgrid(xs, ys)
        if self.orientation == "h":
            c = Cntr(xg, yg, self.value.raw_value)
        else:
            c = Cntr(xg, yg, self.value.raw_value.T)
        self._cached_contours = {}
        for level in self._levels:
            self._cached_contours[level] = []
            traces = c.trace(level)
            for trace in traces:
                self._cached_contours[level].append(transpose(trace))
        self._contour_cache_valid = True

    def _update_levels(self):
        """ Extends the parent method to also invalidate some other things """
        super(ContourLinePlot, self)._update_levels()
        self._contour_cache_valid = False
        self._widths_cache_valid = False
        self._styles_cache_valid = False

    def _update_widths(self):
        """ Updates the widths cache.
        """
        # If we are given a single width, apply it to all levels
        if isinstance(self.widths, float):
            self._widths = [self.widths] * len(self._levels)

        # If the list of widths is shorter than the list of levels,
        # simply repeat widths from the beginning of the list as needed
        else:
            self._widths = []
            for i in range(len(self._levels)):
                self._widths.append(self.widths[i%len(self.widths)])

        self._widths_cache_valid = True

    def _update_styles(self):
        """ Updates the styles cache.
        """
        # If the style type is "signed" then assign styles to levels based
        # on their sign
        if self.styles == "signed":
            self._styles = []
            for level in self._levels:
                if level < 0:
                    self._styles.append(self.negative_style_)
                else:
                    self._styles.append(self.positive_style_)

        # If we not given a list, apply the one style to all levels
        elif not isinstance(self.styles, list):
            self._style_map_trait = self.styles
            self._styles = [self._style_map_trait_] * len(self._levels)

        # If the list of styles is shorter than the list of levels,
        # simply repeat styles from the beginning of the list as needed
        else:
            self._styles = []
            for i in range(len(self._levels)):
                self._style_map_trait = self.styles[i%len(self.styles)]
                self._styles.append(self._style_map_trait_)

        self._styles_cache_valid = True


    #------------------------------------------------------------------------
    # Event handlers
    #------------------------------------------------------------------------

    def _widths_changed(self):
        if self._level_cache_valid:
            self._update_widths()
            self.invalidate_draw()

    def _styles_changed(self):
        if self._level_cache_valid:
            self._update_styles()
            self.invalidate_draw()

    def _negative_style_changed(self):
        if self._level_cache_valid:
            self._update_styles()
            self.invalidate_draw()

    def _positive_style_changed(self):
        if self._level_cache_valid:
            self._update_styles()
            self.invalidate_draw()


########NEW FILE########
__FILENAME__ = contour_poly_plot
""" Defines the ContourPolyPlot class.
"""

from __future__ import with_statement

# Major library imports
from numpy import array, linspace, meshgrid, transpose

# Enthought library imports
from traits.api import Bool, Dict

# Local relative imports
from base_contour_plot import BaseContourPlot
from contour.contour import Cntr


class ContourPolyPlot(BaseContourPlot):
    """ Contour image plot.  Takes a value data object whose elements are
    scalars, and renders them as a contour plot.
    """

    # TODO: Modify ImageData to explicitly support scalar value arrays
    #------------------------------------------------------------------------
    # Private traits
    #------------------------------------------------------------------------

    # Are the cached contours valid? If False, new ones need to be computed.
    _poly_cache_valid = Bool(False)

    # Cached collection of traces.
    _cached_polys = Dict

    #------------------------------------------------------------------------
    # Private methods
    #------------------------------------------------------------------------

    def _render(self, gc):
        """ Actually draws the plot.

        Implements the Base2DPlot interface.
        """

        if not self._level_cache_valid:
            self._update_levels()
        if not self._poly_cache_valid:
            self._update_polys()
        if not self._colors_cache_valid:
            self._update_colors()

        with gc:
            gc.set_antialias(True)
            gc.clip_to_rect(self.x, self.y, self.width, self.height)
            gc.set_line_width(0)
            gc.set_alpha(self.alpha)

            for i in range(len(self._levels)-1):
                gc.set_fill_color(self._colors[i])
                gc.set_stroke_color(self._colors[i])
                key = (self._levels[i], self._levels[i+1])
                for poly in self._cached_polys[key]:
                    if self.orientation == "h":
                        spoly = self.index_mapper.map_screen(poly)
                    else:
                        spoly = array(self.index_mapper.map_screen(poly))[:,::-1]
                    gc.lines(spoly)
                    gc.close_path()
                    gc.draw_path()

    def _update_polys(self):
        """ Updates the cache of contour polygons """
        # x and ydata are "fenceposts" so ignore the last value
        # XXX: this truncation is causing errors in Cntr() as of r13735
        xdata = self.index._xdata.get_data()
        ydata = self.index._ydata.get_data()
        xs = linspace(xdata[0], xdata[-1], len(xdata)-1)
        ys = linspace(ydata[0], ydata[-1], len(ydata)-1)
        xg, yg = meshgrid(xs, ys)
        if self.orientation == "h":
            c = Cntr(xg, yg, self.value.raw_value)
        else:
            c = Cntr(xg, yg, self.value.raw_value.T)
        self._cached_contours = {}
        for i in range(len(self._levels)-1):
            key = (self._levels[i], self._levels[i+1])
            self._cached_polys[key] = []
            polys = c.trace(*key)
            for poly in polys:
                self._cached_polys[key].append(transpose(poly))
        self._poly_cache_valid = True

    def _update_levels(self):
        """ Extends the parent method to also invalidate some other things """
        super(ContourPolyPlot, self)._update_levels()
        self._poly_cache_valid = False

    def _update_colors(self):
        BaseContourPlot._update_colors(self, numcolors = len(self._levels) - 1)



########NEW FILE########
__FILENAME__ = cross_plot_frame
""" Defines the (deprecated) CrossPlotFrame class.
"""
#################################################################################
#
# NOTE: PlotFrames are deprecated.  There is no need to use them any more.
# This class will be removed sometime in the near future.
#
#################################################################################

from __future__ import with_statement

# Enthought library imports
from traits.api import Bool, Float

# Local, relative imports
from base_plot_frame import BasePlotFrame
from plot_containers import HPlotContainer, OverlayPlotContainer, VPlotContainer


class CrossPlotFrame(BasePlotFrame):
    """ A simple, box-layout based plotframe.

    This class supports a central plot area with optional axes on the top, bottom,
    and sides.  The legend can be placed to the bottom, left, right, or
    inside the plot area.  The title can be placed along any of the four
    edges.

    NOTE: PlotFrames are deprecated.  There is no need to use them any more.
    This class will be removed sometime in the future.
    """

    # Slots or positions on the frame where plot components can place themselves.
    # Overrides PlotFrame.
    slot_names = ("center", "left", "right", "top", "bottom")

    # Default width and height. Class attribute.
    default_bounds = (500,500)

    # The sizes of the various areas

    # Width of the left slot.
    left_width = Float(50.0)
    # Width of the right slot.
    right_width = Float(50.0)
    # Height of the top slot.
    top_height = Float(50.0)
    # Height of the bottom slot.
    bottom_height = Float(50.0)

    # Does the component need to do a layout call?
    _layout_needed = Bool(True)


    def __init__(self, **kwtraits):
        if kwtraits.has_key("bounds"):
            bounds = kwtraits.pop("bounds")
        else:
            bounds = list(self.default_bounds)
        BasePlotFrame.__init__(self, **kwtraits)

        # Create our plot containers
        self.set_slot("center", OverlayPlotContainer(resizable="hv"))
        self.set_slot("left", HPlotContainer(resizable="v"))
        self.set_slot("right", HPlotContainer(resizable="v"))
        self.set_slot("top", VPlotContainer(resizable="h"))
        self.set_slot("bottom", VPlotContainer(resizable="h"))

        self.bounds = bounds
        return

    def set_visible_slots(self, *names):
        """
        Convenience method to set the named slots to visible, while setting
        all others to not visible.
        """
        for slot in self.slot_names:
            if slot in names:
                self.get_slot(slot).visible = True
            else:
                self.get_slot(slot).visible = False
        return


    #------------------------------------------------------------------------
    # Protected methods
    #------------------------------------------------------------------------

    def _draw_component(self, gc, view_bounds=None, mode="normal"):
        """ Draws the component.

        This method is preserved for backwards compatibility with _old_draw().
        Overrides PlotComponent.
        """
        with gc:
            gc.translate_ctm(*self.position)
            for slotname in self.slot_names:
                if getattr(self, slotname).visible:
                    with gc:
                        self.get_slot(slotname).draw(gc, view_bounds, mode)
        return

    def _do_layout(self):
        """
        Performs a layout and sets the size and positions on this frame's
        containers, given its width and height.
        """
        left = self.left
        right = self.right
        top = self.top
        bottom = self.bottom
        center = self.center

        # Calculate the bounds of the resizable center container, then set
        # the bounds on all the containers.  center_x,_y represent the (x,y)
        # coordinate of the lower-left corner of the center region;
        # center_x2 and center_y2 represent the upper-right corner of the
        # center region.

        if self.left.visible:
            center_x = self.left_width
        else:
            center_x = self.x
        if self.bottom.visible:
            center_y = self.bottom_height
        else:
            center_y = self.y
        if self.right.visible:
            center_x2 = self.width - self.right_width - 1
        else:
            center_x2 = self.width
        if self.top.visible:
            center_y2 = self.height - self.top_height - 1
        else:
            center_y2 = self.height

        left.outer_position = [0.0, center_y]
        left.outer_bounds = [self.left_width, center_y2 - center_y + 1]

        right.outer_position = [center_x2 + 1, center_y]
        right.outer_bounds = [self.right_width, left.height]

        bottom.outer_position = [center_x, 0.0]
        bottom.outer_bounds = [center_x2 - center_x + 1, self.bottom_height]

        top.outer_position = [center_x, center_y2 + 1]
        top.outer_bounds = [bottom.width, self.top_height]

        center.outer_position = [center_x, center_y]
        center.outer_bounds = [bottom.width, left.height]

        for slot in self._frame_slots.values():
            if slot.visible:
                preferred_size = slot.get_preferred_size()
                if "h" not in slot.resizable:
                    slot.outer_width = preferred_size[0]
                if "v" not in slot.resizable:
                    slot.outer_height = preferred_size[1]
                slot.do_layout()

        return


    ### Persistence ###########################################################

    #_pickles = ("left_width", "right_width", "top_height", "bottom_height")

    def __getstate__(self):
        state = super(CrossPlotFrame,self).__getstate__()
        for key in ['_layout_needed']:
            if state.has_key(key):
                del state[key]

        return state


# EOF

########NEW FILE########
__FILENAME__ = datamapper
"""
CAUTION: This is an old file from Chaco 1.x to support the spatial subdivision
structures.  It will be refactored soon.

If you are looking for Chaco's mappers (subclasses of AbstractMapper),
look in abstract_mapper.py, linear_mapper.py, and log_mapper.py.

Defines AbstractDataMapper and BruteForceDataMapper classes, and related trait
and functions.
"""


from numpy import array, concatenate, take, argsort, argmin, \
                  argmax, transpose, newaxis, sort

from traits.api import HasStrictTraits, Bool, Enum, Tuple, \
                             Property, Any, Float


#-------------------------------------------------------------------
# Module-specific traits
#-------------------------------------------------------------------

# Expresses sorting order of
ArraySortTrait = Enum('ascending', 'descending')


#-------------------------------------------------------------------
# Module-specific utility functions
#-------------------------------------------------------------------

def right_shift(ary, newval):
    "Returns a right-shifted version of *ary* with *newval* inserted on the left."
    return concatenate([[newval], ary[:-1]])

def left_shift(ary, newval):
    "Returns a left-shifted version of *ary* with *newval* inserted on the right."
    return concatenate([ary[1:], [newval]])

def sort_points(points, index=0):
    """
    sort_points(array_of_points, index=<0|1>) -> sorted_array

    Takes a list of points as an Nx2 array and sorts them according
    to their x-coordinate (index=0) or y-coordinate (index=1).
    """
    if len(points.shape) != 2 or (2 not in points.shape):
        raise RuntimeError, "sort_points(): Array of wrong shape."
    return take( points, argsort(points[:,index]) )

def array_zip(*arys):
    """
    Returns a Numeric array that is the concatenation of the input 1-D
    *arys* along a new axis.  This function is basically equivalent to
    ``array(zip(*arys))``, but is more resource-efficient.
    """
    return transpose(array(arys))


class AbstractDataMapper(HasStrictTraits):
    """
    A data mapper maps from coordinate space to data elements.  In its most
    basic form, it loops over all the available data points to find the ones
    near a given coordinate or within an area.  More advanced functionality
    includes returning rect-aligned "affected regions" enclosing all the
    returned points, etc.
    """

    # How to sort the output list of intersected points that the
    # get_points_near_*() function returns.  The points are always sorted
    # by their domain (first/X-value) coordinate.
    sort_order = ArraySortTrait

    # A read-only property that describes the origin and size of the data
    # set in data space as a 4-tuple (min_x, min_y, width, height)
    extents = Property()


    #-------------------------------------------------------------------
    # Private traits
    #-------------------------------------------------------------------

    _data = Any

    # Internally we expect Nx2 arrays; if the user hands in something
    # different, we stored a transposed version but always remember to
    # transpose once again whenever we return data.
    _is_transposed = Bool(False)

    # the max and min points in data space expressed as a 4-tuple (x,y,w,h)
    _extents = Tuple

    # a "fudge factor" to make the extents slightly larger than the actual
    # values in the data set
    _extents_delta = Float(0.1)

    def __init__(self, data=None, data_sorting='none', **kw):
        "See set_data() for description."
        self._data = array([])
        HasStrictTraits.__init__(self, **kw)
        if data is not None:
            self.set_data(data, data_sorting)
        return

    def get_points_near(self, pointlist, radius=0.0):
        """
        get_points_near([points], radius=0.0) -> Nx2 array of candidate points

        Returns a list of points near the input points (Nx2 array).

        For each point in the input set, *radius* is used to create a
        conceptual circle; if any points in the DataMapper's values lie inside
        this circle, they are returned.

        The returned list is not guaranteed to be a minimum or exact set,
        but it is guaranteed to contain all points that intersect the
        *pointlist*.  The caller still must do fine-grained testing to see
        if the points in the returned point list are a match.
        """
        raise NotImplementedError

    def get_points_near_polyline(self, line):
        """
        get_points_near_polyline([v1, ... vN]) -> [ [points], [points], ... ]

        This method is like get_points_near(), except that it takes a polyline
        as input.  A polyline is a list of vertices, each connected to the next
        by a straight line. The polyline has infinitely thin width.

        The input array can have shape 2xN or Nx2.
        """
        raise NotImplementedError

    def get_points_in_rect(self, rect):
        """
        get_points_in_rect( (x,y,w,h) ) -> [ [points], [points], ... ]

        This method is like get_points_near(), except that it takes a rectangle
        as input.  The rectangle has infinitely thin width.
        """
        raise NotImplementedError

    def get_points_in_poly(self, poly):
        """
        get_points_in_poly([v1, ... vN]) -> [ [points], [points], ... ]

        This method is like get_points_near(), except that it takes a polygon
        as input.  The polygon has infinitely thin width and can be
        self-intersecting and concave.

        The input array can have shape 2xN or Nx2.
        """
        raise NotImplementedError

    def get_last_region(self):
        """
        Returns a region of screen space that contains all of the
        points/lines/rect/polys in the last get_points_in_*() call.  The
        region returned by this method is guaranteed to only contain the points
        that were returned by the previous call.

        The region is returned as a list of (possibly disjoint) rectangles,
        where each rectangle is a 4-tuple (x,y,w,h).
        """
        raise NotImplementedError

    def set_data(self, new_data, new_data_sorting='none'):
        """
        set_data(new_data, new_data_sorting='none')

        Sets the data used by this DataMapper.  The *new_data_sorting* parameter
        indicates how the new data is sorted: 'none', 'ascending', or 'descending'.
        The default is 'none', which causes the data mapper to perform
        a full sort of the input data.

        The input data can be shaped 2xN or Nx2.
        """
        if len(new_data) == 0:
            self.clear()
            return

        if new_data.shape[0] == 2:
            self._is_transposed = True
            self._data = transpose(new_data)
        else:
            self._is_transposed = False
            self._data = new_data

        if new_data_sorting == 'none':
            if self.sort_order == 'ascending':
                self._data = sort_points(self._data)
            else:
                self._data = sort_points(self._data)[::-1]
        elif new_data_sorting != self.sort_order:
            self._data = self._data[::-1]

        self._calc_data_extents()
        self._update_datamap()
        # a re-sorting is unnecessary because any internal data structures
        # will have been updated by the _data update process.
        return

    def clear(self):
        """
        clear()

        Resets internal state and any cached data to reflect an empty
        data set/data space.
        """
        self._data = None
        self._extents = (0,0,0,0)
        self._clear()
        return

    def get_data(self):
        "Returns the actual data used by the DataMapper."
        if self._is_transposed:
            return transpose(self._data)
        else:
            return self._data

    #-------------------------------------------------------------------
    # Concrete private methods and event handlers
    # Child classes shouldn't have to override these.
    #-------------------------------------------------------------------

    def _get_extents(self):
        return self._extents

    def _calc_data_extents(self):
        """
        Computes ((minX, minY), (width, height)) of self._data; sets self._extent and
        returns nothing.
        """
        if len(self._data) == 0:
            self._extents = ((0,0), (0,0))
        else:
            value = self._data
            min_indices = argmin(value, axis=0)
            max_indices = argmax(value, axis=0)
            x = value[min_indices[0], 0] - self._extents_delta
            y = value[min_indices[1], 1] - self._extents_delta
            maxX = value[max_indices[0], 0] + self._extents_delta
            maxY = value[max_indices[1], 1] + self._extents_delta
            self._extents = ((x, y), (maxX-x, maxY-y))
        return


    #-------------------------------------------------------------------
    # Abstract private methods and event handlers
    #-------------------------------------------------------------------

    def _update_datamap(self):
        """
        This function gets called after self._data has changed.  Child classes
        should implement this function if they need to recompute any cached
        data structures, etc.
        """
        return

    def _clear(self):
        "Performs subclass-specific clearing/cleanup."
        return

    def _sort_order_changed(self, old, new):
        return


class BruteForceDataMapper(AbstractDataMapper):
    """
    The BruteForceDataMapper returns all the points, all the time.
    This is basically the same behavior as not having a data mapper in
    the pipeline at all.
    """

    def get_points_near(self, pointlist, radius=0):
        return self.get_data()

    def get_points_near_polyline(self, line):
        return self.get_data()

    def get_points_in_rect(self, rect):
        return self.get_data()

    def get_points_in_poly(self, poly):
        return self.get_data()

    def get_last_region(self):
        return self._extents

    def _sort_order_changed(self, old, new):
        if len(self._data) == 0:
            return
        else:
            if self.sort_order == 'ascending':
                self._data = sort_points(self._data)
            else:
                self._data = sort_points(self._data)[::-1]
        return

#EOF

########NEW FILE########
__FILENAME__ = data_label
""" Defines the DataLabel class and related trait and function.
"""
# Major library imports
from math import sqrt
from numpy import array, asarray, inf
from numpy.linalg import norm

# Enthought library imports
from traits.api import Any, Array, Bool, Enum, Float, Int, List, \
     Str, Tuple, Trait, on_trait_change, Property
from enable.api import ColorTrait, MarkerTrait

# Local, relative imports
from scatterplot import render_markers
from tooltip import ToolTip


# Specifies the position of a label relative to its target.  This can
# be one of the text strings indicated, or a tuple or list of floats
# representing the (x_offset, y_offset) in screen space of the label's
# lower left corner.
LabelPositionTrait = Trait("top right",
                           Enum("bottom", "left", "right", "top",
                                "top right", "top left",
                                "bottom left", "bottom right"),
                           Tuple, List)


def draw_arrow(gc, pt1, pt2, color, arrowhead_size=10.0, offset1=0,
               offset2=0, arrow=None, minlen=0, maxlen=inf):
    """ Renders an arrow from *pt1* to *pt2*.  If gc is None, then just returns
    the arrow object.

    Parameters
    ==========
    gc : graphics context
        where to render the arrow
    pt1 : point
        the origin of the arrow
    pt2 : point
        where the arrow is pointing
    color : a 3- or 4-tuple of color value
        the color to use for the arrow stem and head
    arrowhead_size : number
        screen units corresponding to the length of the arrowhead
    offset1 : number
        the amount of space from the start of the arrow to pt1
    offset2 : number
        the amount of space from the tip of the arrow to pt2
    arrow : object
        an opaque object returned by previous calls to draw_arrow.  If this
        argument is provided, all other arguments (except gc) are ignored
    minlen: number or None
        the minimum length of the arrow; if the arrow is shorter than this,
        it will not be drawn
    maxlen: number or None
        the maximum length of the arrow; if the arrow is longer than this, it
        will not be drawn

    Returns
    =======
    An 'arrow' (opaque object) which can be passed in to subsequent
    calls to this method to short-circuit some of the computation.
    Even if an arrow is not drawn (due to minlen/maxlen restrictions),
    an arrow will be returned.
    """

    if arrow is None:
        pt1 = asarray(pt1)
        pt2 = asarray(pt2)

        unit_vec = pt2 - pt1
        unit_vec /= norm(unit_vec)

        if unit_vec[0] == 0:
            perp_vec = array((0.3 * arrowhead_size, 0))
        elif unit_vec[1] == 0:
            perp_vec = array((0, 0.3 * arrowhead_size))
        else:
            slope = unit_vec[1] / unit_vec[0]
            perp_slope = -1 / slope
            perp_vec = array((1.0, perp_slope))
            perp_vec *= 0.3 * arrowhead_size / norm(perp_vec)

        pt1 = pt1 + offset1 * unit_vec
        pt2 = pt2 - offset2 * unit_vec

        arrowhead_l = pt2 - (arrowhead_size * unit_vec + perp_vec)
        arrowhead_r = pt2 - (arrowhead_size * unit_vec - perp_vec)
        arrow = (pt1, pt2, arrowhead_l, arrowhead_r)
    else:
        pt1, pt2, arrowhead_l, arrowhead_r = arrow

    arrowlen = norm(pt2 - pt1)
    if arrowlen < minlen or arrowlen > maxlen:
        # This is the easiest way to circumvent the actual drawing
        gc = None

    if gc is not None:
        gc.set_stroke_color(color)
        gc.set_fill_color(color)
        gc.begin_path()
        gc.move_to(*pt1)
        gc.line_to(*pt2)
        gc.stroke_path()
        gc.move_to(*pt2)
        gc.line_to(*arrowhead_l)
        gc.line_to(*arrowhead_r)
        gc.fill_path()
    return arrow


def find_region(px, py, x, y, x2, y2):
    """Classify the location of the point (px, py) relative to a rectangle.

    (x, y) and (x2, y2) are the lower-left and upper-right corners of the
    rectangle, respectively.  (px, py) is classified as "left", "right",
    "top", "bottom" or "inside", according to the following diagram:

            \     top      /
             \            /
              +----------+
         left |  inside  | right
              +----------+
             /            \ 
            /    bottom    \ 

    """
    if px < x:
        dx = x - px
        if py > y2 + dx:
            region = 'top'
        elif py < y - dx:
            region = 'bottom'
        else:
            region = 'left'
    elif px > x2:
        dx = px - x2
        if py > y2 + dx:
            region = 'top'
        elif py < y - dx:
            region = 'bottom'
        else:
            region = 'right'
    else:  # x <= px <= x2
        if py > y2:
            region = 'top'
        elif py < y:
            region = 'bottom'
        else:
            region = 'inside'
    return region


class DataLabel(ToolTip):
    """ A label on a point in data space.

    Optionally, an arrow is drawn to the point.
    """

    # The symbol to use if **marker** is set to "custom". This attribute must
    # be a compiled path for the given Kiva context.
    custom_symbol = Any

    # The point in data space where this label should anchor itself.
    data_point = Trait(None, None, Tuple, List, Array)

    # The location of the data label relative to the data point.
    label_position = LabelPositionTrait

    # The format string that determines the label's text.  This string is
    # formatted using a dict containing the keys 'x' and 'y', corresponding to
    # data space values.
    label_format = Str("(%(x)f, %(y)f)")

    # The text to show on the label, or above the coordinates for the label, if
    # show_label_coords is True
    label_text = Str

    # Flag whether to show coordinates with the label or not.
    show_label_coords = Bool(True)

    # Does the label clip itself against the main plot area?  If not, then
    # the label draws into the padding area (where axes typically reside).
    clip_to_plot = Bool(True)

    # The center x position (average of x and x2)
    xmid = Property(Float, depends_on=['x', 'x2'])

    # The center y position (average of y and y2)
    ymid = Property(Float, depends_on=['y', 'y2'])

    # 'box' is a simple rectangular box, with an arrow that is a single line
    # with an arrowhead at the data point.
    # 'bubble' can be given rounded corners (by setting `corner_radius`), and
    # the 'arrow' is a thin triangular wedge with its point at the data point.
    # When label_style is 'bubble', the following traits are ignored:
    #    arrow_size, arrow_color, arrow_root, and arrow_max_length.
    label_style = Enum('box', 'bubble')

    #----------------------------------------------------------------------
    # Marker traits
    #----------------------------------------------------------------------

    # Mark the point on the data that this label refers to?
    marker_visible = Bool(True)

    # The type of marker to use.  This is a mapped trait using strings as the
    # keys.
    marker = MarkerTrait

    # The pixel size of the marker (doesn't include the thickness of the
    # outline).
    marker_size = Int(4)

    # The thickness, in pixels, of the outline to draw around the marker.
    # If this is 0, no outline will be drawn.
    marker_line_width = Float(1.0)

    # The color of the inside of the marker.
    marker_color = ColorTrait("red")

    # The color out of the border drawn around the marker.
    marker_line_color = ColorTrait("black")

    #----------------------------------------------------------------------
    # Arrow traits
    #----------------------------------------------------------------------

    # Draw an arrow from the label to the data point?  Only
    # used if **data_point** is not None.
    arrow_visible = Bool(True)   # FIXME: replace with some sort of ArrowStyle

    # The length of the arrowhead, in screen points (e.g., pixels).
    arrow_size = Float(10)

    # The color of the arrow.
    arrow_color = ColorTrait("black")

    # The position of the base of the arrow on the label.  If this
    # is 'auto', then the label uses **label_position**.  Otherwise, it
    # treats the label as if it were at the label position indicated by
    # this attribute.
    arrow_root = Trait("auto", "auto", "top left", "top right", "bottom left",
                       "bottom right", "top center", "bottom center",
                       "left center", "right center")

    # The minimum length of the arrow before it will be drawn.  By default,
    # the arrow will be drawn regardless of how short it is.
    arrow_min_length = Float(0)

    # The maximum length of the arrow before it will be drawn.  By default,
    # the arrow will be drawn regardless of how long it is.
    arrow_max_length = Float(inf)

    #----------------------------------------------------------------------
    # Bubble traits
    #----------------------------------------------------------------------

    # The radius (in screen coordinates) of the curved corners of the "bubble".
    corner_radius = Float(10)

    #-------------------------------------------------------------------------
    # Private traits
    #-------------------------------------------------------------------------

    # Tuple (sx, sy) of the mapped screen coordinates of **data_point**.
    _screen_coords = Any

    _cached_arrow = Any

    # When **arrow_root** is 'auto', this determines the location on the data
    # label from which the arrow is drawn, based on the position of the label
    # relative to its data point.
    _position_root_map = {
        "top left": "bottom right",
        "top right": "bottom left",
        "bottom left": "top right",
        "bottom right": "top left",
        "top center": "bottom center",
        "bottom center": "top center",
        "left center": "right center",
        "right center": "left center"
        }

    _root_positions = {
        "bottom right": ("x2", "y"),
        "bottom left": ("x", "y"),
        "top right": ("x2", "y2"),
        "top left": ("x", "y2"),
        "top center": ("xmid", "y2"),
        "bottom center": ("xmid", "y"),
        "left center": ("x", "ymid"),
        "right center": ("x2", "ymid"),
        }

    def overlay(self, component, gc, view_bounds=None, mode="normal"):
        """ Draws the tooltip overlaid on another component.

        Overrides and extends ToolTip.overlay()
        """
        if self.clip_to_plot:
            gc.save_state()
            c = component
            gc.clip_to_rect(c.x, c.y, c.width, c.height)

        self.do_layout()

        if self.label_style == 'box':
            self._render_box(component, gc, view_bounds=view_bounds,
                             mode=mode)
        else:
            self._render_bubble(component, gc, view_bounds=view_bounds,
                                mode=mode)

        # draw the marker
        if self.marker_visible:
            render_markers(gc, [self._screen_coords],
                           self.marker, self.marker_size,
                           self.marker_color_, self.marker_line_width,
                           self.marker_line_color_, self.custom_symbol)

        if self.clip_to_plot:
            gc.restore_state()

    def _render_box(self, component, gc, view_bounds=None, mode='normal'):
        # draw the arrow if necessary
        if self.arrow_visible:
            if self._cached_arrow is None:
                if self.arrow_root in self._root_positions:
                    ox, oy = self._root_positions[self.arrow_root]
                else:
                    if self.arrow_root == "auto":
                        arrow_root = self.label_position
                    else:
                        arrow_root = self.arrow_root
                    pos = self._position_root_map.get(arrow_root, "DUMMY")
                    ox, oy = self._root_positions.get(pos,
                                        (self.x + self.width / 2,
                                         self.y + self.height / 2))

                if type(ox) == str:
                    ox = getattr(self, ox)
                    oy = getattr(self, oy)
                self._cached_arrow = draw_arrow(gc, (ox, oy),
                                            self._screen_coords,
                                            self.arrow_color_,
                                            arrowhead_size=self.arrow_size,
                                            offset1=3,
                                            offset2=self.marker_size + 3,
                                            minlen=self.arrow_min_length,
                                            maxlen=self.arrow_max_length)
            else:
                draw_arrow(gc, None, None, self.arrow_color_,
                           arrow=self._cached_arrow,
                           minlen=self.arrow_min_length,
                           maxlen=self.arrow_max_length)

        # layout and render the label itself
        ToolTip.overlay(self, component, gc, view_bounds, mode)

    def _render_bubble(self, component, gc, view_bounds=None, mode='normal'):
        """ Render the bubble label in the graphics context. """
        # (px, py) is the data point in screen space.
        px, py = self._screen_coords

        # (x, y) is the lower left corner of the label.
        x = self.x
        y = self.y
        # (x2, y2) is the upper right corner of the label.
        x2 = self.x2
        y2 = self.y2
        # r is the corner radius.
        r = self.corner_radius

        if self.arrow_visible:
            # FIXME: Make 'gap_width' a configurable trait (and give it a
            #        better name).
            max_gap_width = 10
            gap_width = min(max_gap_width,
                            abs(x2 - x - 2 * r),
                            abs(y2 - y - 2 * r))
            region = find_region(px, py, x, y, x2, y2)

            # Figure out where the "arrow" connects to the "bubble".
            if region == 'left' or region == 'right':
                gap_start = py - gap_width / 2
                if gap_start < y + r:
                    gap_start = y + r
                elif gap_start > y2 - r - gap_width:
                    gap_start = y2 - r - gap_width
                by = gap_start + 0.5 * gap_width
                if region == 'left':
                    bx = x
                else:
                    bx = x2
            else:
                gap_start = px - gap_width / 2
                if gap_start < x + r:
                    gap_start = x + r
                elif gap_start > x2 - r - gap_width:
                    gap_start = x2 - r - gap_width
                bx = gap_start + 0.5 * gap_width
                if region == 'top':
                    by = y2
                else:
                    by = y

        arrow_len = sqrt((px - bx) ** 2 + (py - by) ** 2)
        arrow_visible = (self.arrow_visible and
                         (arrow_len >= self.arrow_min_length))

        with gc:
            if self.border_visible:
                gc.set_line_width(self.border_width)
                gc.set_stroke_color(self.border_color_)
            else:
                gc.set_line_width(0)
                gc.set_stroke_color((0, 0, 0, 0))
            gc.set_fill_color(self.bgcolor_)

            # Start at the lower left, on the left edge where the curved
            # part of the box ends.
            gc.move_to(x, y + r)

            # Draw the left side and the upper left curved corner.
            if arrow_visible and region == 'left':
                gc.line_to(x, gap_start)
                gc.line_to(px, py)
                gc.line_to(x, gap_start + gap_width)
            gc.arc_to(x, y2, x + r, y2, r)

            # Draw the top and the upper right curved corner.
            if arrow_visible and region == 'top':
                gc.line_to(gap_start, y2)
                gc.line_to(px, py)
                gc.line_to(gap_start + gap_width, y2)
            gc.arc_to(x2, y2, x2, y2 - r, r)

            # Draw the right side and the lower right curved corner.
            if arrow_visible and region == 'right':
                gc.line_to(x2, gap_start + gap_width)
                gc.line_to(px, py)
                gc.line_to(x2, gap_start)
            gc.arc_to(x2, y, x2 - r, y, r)

            # Draw the bottom and the lower left curved corner.
            if arrow_visible and region == 'bottom':
                gc.line_to(gap_start + gap_width, y)
                gc.line_to(px, py)
                gc.line_to(gap_start, y)
            gc.arc_to(x, y, x, y + r, r)

            # Finish the "bubble".
            gc.draw_path()

            self._draw_overlay(gc)

    def _do_layout(self, size=None):
        """Computes the size and position of the label and arrow.

        Overrides and extends ToolTip._do_layout()
        """
        if not self.component or not hasattr(self.component, "map_screen"):
            return

        # Call the parent class layout.  This computes all the label
        ToolTip._do_layout(self)

        self._screen_coords = self.component.map_screen([self.data_point])[0]
        sx, sy = self._screen_coords

        if isinstance(self.label_position, str):
            orientation = self.label_position
            if ("left" in orientation) or ("right" in orientation):
                if " " not in orientation:
                    self.y = sy - self.height / 2
                if "left" in orientation:
                    self.outer_x = sx - self.outer_width - 1
                elif "right" in orientation:
                    self.outer_x = sx
            if ("top" in orientation) or ("bottom" in orientation):
                if " " not in orientation:
                    self.x = sx - self.width / 2
                if "bottom" in orientation:
                    self.outer_y = sy - self.outer_height - 1
                elif "top" in orientation:
                    self.outer_y = sy
            if "center" in orientation:
                if " " not in orientation:
                    self.x = sx - (self.width / 2)
                    self.y = sy - (self.height / 2)
                else:
                    self.x = sx - (self.outer_width / 2) - 1
                    self.y = sy - (self.outer_height / 2) - 1
        else:
            self.x = sx + self.label_position[0]
            self.y = sy + self.label_position[1]

        self._cached_arrow = None
        return

    def _data_point_changed(self, old, new):
        if new is not None:
            self._create_new_labels()

    def _label_format_changed(self, old, new):
        self._create_new_labels()

    def _label_text_changed(self, old, new):
        self._create_new_labels()

    def _show_label_coords_changed(self, old, new):
        self._create_new_labels()

    def _create_new_labels(self):
        pt = self.data_point
        if pt is not None:
            if self.show_label_coords:
                self.lines = [self.label_text,
                              self.label_format % {"x": pt[0], "y": pt[1]}]
            else:
                self.lines = [self.label_text]

    def _component_changed(self, old, new):
        for comp, attach in ((old, False), (new, True)):
            if comp is not None:
                if hasattr(comp, 'index_mapper'):
                    self._modify_mapper_listeners(comp.index_mapper,
                                                  attach=attach)
                if hasattr(comp, 'value_mapper'):
                    self._modify_mapper_listeners(comp.value_mapper,
                                                  attach=attach)
        return

    def _modify_mapper_listeners(self, mapper, attach=True):
        if mapper is not None:
            mapper.on_trait_change(self._handle_mapper, 'updated',
                                   remove=not attach)
        return

    def _handle_mapper(self):
        # This gets fired whenever a mapper on our plot fires its
        # 'updated' event.
        self._layout_needed = True

    @on_trait_change("arrow_size,arrow_root,arrow_min_length," +
                     "arrow_max_length")
    def _invalidate_arrow(self):
        self._cached_arrow = None
        self._layout_needed = True

    @on_trait_change("label_position,position,position_items,bounds," +
                     "bounds_items")
    def _invalidate_layout(self):
        self._layout_needed = True

    def _get_xmid(self):
        return 0.5 * (self.x + self.x2)

    def _get_ymid(self):
        return 0.5 * (self.y + self.y2)

########NEW FILE########
__FILENAME__ = data_range_1d
"""
Defines the DataRange1D class.
"""


# Major library imports
from math import ceil, floor, log
from numpy import compress, inf, isinf, isnan, ndarray

# Enthought library imports
from traits.api import Bool, CFloat, Enum, Float, Property, Trait, \
                                 Callable

# Local relative imports
from base import arg_find_runs
from base_data_range import BaseDataRange
from ticks import heckbert_interval


class DataRange1D(BaseDataRange):
    """ Represents a 1-D data range.
    """

    # The actual value of the lower bound of this range (overrides
    # AbstractDataRange). To set it, use **low_setting**.
    low = Property
    # The actual value of the upper bound of this range (overrides
    # AbstractDataRange). To set it, use **high_setting**.
    high = Property

    # Property for the lower bound of this range (overrides AbstractDataRange).
    #
    # * 'auto': The lower bound is automatically set at or below the minimum
    #   of the data.
    # * 'track': The lower bound tracks the upper bound by **tracking_amount**.
    # * CFloat: An explicit value for the lower bound
    low_setting = Property(Trait('auto', 'auto', 'track', CFloat))
    # Property for the upper bound of this range (overrides AbstractDataRange).
    #
    # * 'auto': The upper bound is automatically set at or above the maximum
    #   of the data.
    # * 'track': The upper bound tracks the lower bound by **tracking_amount**.
    # * CFloat: An explicit value for the upper bound
    high_setting = Property(Trait('auto', 'auto', 'track', CFloat))

    # Do "auto" bounds imply an exact fit to the data? If False,
    # they pad a little bit of margin on either side.
    tight_bounds = Bool(True)

    # A user supplied function returning the proper bounding interval.
    # bounds_func takes (data_low, data_high, margin, tight_bounds)
    # and returns (low, high)
    bounds_func = Callable

    # The amount of margin to place on either side of the data, expressed as
    # a percentage of the full data width
    margin = Float(0.05)

    # The minimum percentage difference between low and high.  That is,
    # (high-low) >= epsilon * low.
    # Used to be 1.0e-20 but chaco cannot plot at such a precision!
    epsilon = CFloat(1.0e-10)

    # When either **high** or **low** tracks the other, track by this amount.
    default_tracking_amount = CFloat(20.0)

    # The current tracking amount. This value changes with zooming.
    tracking_amount = default_tracking_amount

    # Default tracking state. This value is used when self.reset() is called.
    #
    # * 'auto': Both bounds reset to 'auto'.
    # * 'high_track': The high bound resets to 'track', and the low bound
    #   resets to 'auto'.
    # * 'low_track': The low bound resets to 'track', and the high bound
    #   resets to 'auto'.
    default_state = Enum('auto', 'high_track', 'low_track')

    # FIXME: this attribute is not used anywhere, is it safe to remove it?
    # Is this range dependent upon another range?
    fit_to_subset = Bool(False)

    #------------------------------------------------------------------------
    # Private traits
    #------------------------------------------------------------------------

    # The "_setting" attributes correspond to what the user has "set"; the
    # "_value" attributes are the actual numerical values for the given
    # setting.

    # The user-specified low setting.
    _low_setting = Trait('auto', 'auto', 'track', CFloat)
    # The actual numerical value for the low setting.
    _low_value = CFloat(-inf)
    # The user-specified high setting.
    _high_setting = Trait('auto', 'auto', 'track', CFloat)
    # The actual numerical value for the high setting.
    _high_value = CFloat(inf)

    # A list of attributes to persist
    # _pickle_attribs = ("_low_setting", "_high_setting")

    #------------------------------------------------------------------------
    # AbstractRange interface
    #------------------------------------------------------------------------

    def clip_data(self, data):
        """ Returns a list of data values that are within the range.

        Implements AbstractDataRange.
        """
        return compress(self.mask_data(data), data)

    def mask_data(self, data):
        """ Returns a mask array, indicating whether values in the given array
        are inside the range.

        Implements AbstractDataRange.
        """
        return ((data.view(ndarray) >= self._low_value) &
                (data.view(ndarray) <= self._high_value))

    def bound_data(self, data):
        """ Returns a tuple of indices for the start and end of the first run
        of *data* that falls within the range.

        Implements AbstractDataRange.
        """
        mask = self.mask_data(data)
        runs = arg_find_runs(mask, "flat")
        # Since runs of "0" are also considered runs, we have to cycle through
        # until we find the first run of "1"s.
        for run in runs:
            if mask[run[0]] == 1:
                # arg_find_runs returns 1 past the end
                return run[0], run[1] - 1
        return (0, 0)

    def set_bounds(self, low, high):
        """ Sets all the bounds of the range simultaneously.

        Implements AbstractDataRange.
        """
        if low == 'track':
            # Set the high setting first
            result_high = self._do_set_high_setting(high, fire_event=False)
            result_low = self._do_set_low_setting(low, fire_event=False)
            result = result_low or result_high
        else:
            # Either set low first or order doesn't matter
            result_low = self._do_set_low_setting(low, fire_event=False)
            result_high = self._do_set_high_setting(high, fire_event=False)
            result = result_high or result_low
        if result:
            self.updated = result

    def scale_tracking_amount(self, multiplier):
        """ Sets the **tracking_amount** to a new value, scaled by *multiplier*.
        """
        self.tracking_amount = self.tracking_amount * multiplier
        self._do_track()

    def set_tracking_amount(self, amount):
        """ Sets the **tracking_amount** to a new value, *amount*.
        """
        self.tracking_amount = amount
        self._do_track()

    def set_default_tracking_amount(self, amount):
        """ Sets the **default_tracking_amount** to a new value, *amount*.
        """
        self.default_tracking_amount = amount

    #------------------------------------------------------------------------
    # Public methods
    #------------------------------------------------------------------------

    def reset(self):
        """ Resets the bounds of this range, based on **default_state**.
        """
        # need to maintain 'track' setting
        if self.default_state == 'auto':
            self._high_setting = 'auto'
            self._low_setting = 'auto'
        elif self.default_state == 'low_track':
            self._high_setting = 'auto'
            self._low_setting = 'track'
        elif self.default_state == 'high_track':
            self._high_setting = 'track'
            self._low_setting = 'auto'
        self._refresh_bounds()
        self.tracking_amount = self.default_tracking_amount

    def refresh(self):
        """ If any of the bounds is 'auto', this method refreshes the actual
        low and high values from the set of the view filters' data sources.
        """
        if ('auto' in (self._low_setting, self._high_setting)) or \
            ('track' in (self._low_setting, self._high_setting)):
            # If the user has hard-coded bounds, then refresh() doesn't do
            # anything.
            self._refresh_bounds()
        else:
            return

    #------------------------------------------------------------------------
    # Private methods (getters and setters)
    #------------------------------------------------------------------------

    def _get_low(self):
        return float(self._low_value)

    def _set_low(self, val):
        return self._set_low_setting(val)

    def _get_low_setting(self):
        return self._low_setting

    def _do_set_low_setting(self, val, fire_event=True):
        """
        Returns
        -------
        If fire_event is False and the change would have fired an event, returns
        the tuple of the new low and high values.  Otherwise returns None.  In
        particular, if fire_event is True, it always returns None.
        """
        new_values = None
        if self._low_setting != val:

            # Save the new setting.
            self._low_setting = val

            # If val is 'auto' or 'track', get the corresponding numerical
            # value.
            if val == 'auto':
                if len(self.sources) > 0:
                    val = min([source.get_bounds()[0]
                               for source in self.sources])
                else:
                    val = -inf
            elif val == 'track':
                if len(self.sources) > 0 or self._high_setting != 'auto':
                    val = self._high_value - self.tracking_amount
                else:
                    val = -inf

            # val is now a numerical value.  If it is the same as the current
            # value, there is nothing to do.
            if self._low_value != val:
                self._low_value = val
                if self._high_setting == 'track':
                    self._high_value = val + self.tracking_amount
                if fire_event:
                    self.updated = (self._low_value, self._high_value)
                else:
                    new_values = (self._low_value, self._high_value)

        return new_values

    def _set_low_setting(self, val):
        self._do_set_low_setting(val, True)

    def _get_high(self):
        return float(self._high_value)

    def _set_high(self, val):
        return self._set_high_setting(val)

    def _get_high_setting(self):
        return self._high_setting

    def _do_set_high_setting(self, val, fire_event=True):
        """
        Returns
        -------
        If fire_event is False and the change would have fired an event, returns
        the tuple of the new low and high values.  Otherwise returns None.  In
        particular, if fire_event is True, it always returns None.
        """
        new_values = None
        if self._high_setting != val:

            # Save the new setting.
            self._high_setting = val

            # If val is 'auto' or 'track', get the corresponding numerical
            # value.
            if val == 'auto':
                if len(self.sources) > 0:
                    val = max([source.get_bounds()[1]
                               for source in self.sources])
                else:
                    val = inf
            elif val == 'track':
                if len(self.sources) > 0 or self._low_setting != 'auto':
                    val = self._low_value + self.tracking_amount
                else:
                    val = inf

            # val is now a numerical value.  If it is the same as the current
            # value, there is nothing to do.
            if self._high_value != val:
                self._high_value = val
                if self._low_setting == 'track':
                    self._low_value = val - self.tracking_amount
                if fire_event:
                    self.updated = (self._low_value, self._high_value)
                else:
                    new_values = (self._low_value, self._high_value)

        return new_values

    def _set_high_setting(self, val):
        self._do_set_high_setting(val, True)

    def _refresh_bounds(self):
        null_bounds = False
        if len(self.sources) == 0:
            null_bounds = True
        else:
            bounds_list = [source.get_bounds() for source in self.sources \
                              if source.get_size() > 0]

            if len(bounds_list) == 0:
                null_bounds = True

        if null_bounds:
            # If we have no sources and our settings are "auto", then reset our
            # bounds to infinity; otherwise, set the _value to the corresponding
            # setting.
            if (self._low_setting in ("auto", "track")):
                self._low_value = -inf
            else:
                self._low_value = self._low_setting
            if (self._high_setting in ("auto", "track")):
                self._high_value = inf
            else:
                self._high_value = self._high_setting
            return
        else:
            mins, maxes = zip(*bounds_list)

            low_start, high_start = \
                     calc_bounds(self._low_setting, self._high_setting,
                                 mins, maxes, self.epsilon,
                                 self.tight_bounds, margin=self.margin,
                                 track_amount=self.tracking_amount,
                                 bounds_func=self.bounds_func)

        if (self._low_value != low_start) or (self._high_value != high_start):
            self._low_value = low_start
            self._high_value = high_start
            self.updated = (self._low_value, self._high_value)
        return

    def _do_track(self):
        changed = False
        if self._low_setting == 'track':
            new_value = self._high_value - self.tracking_amount
            if self._low_value != new_value:
                self._low_value = new_value
                changed = True
        elif self._high_setting == 'track':
            new_value = self._low_value + self.tracking_amount
            if self._high_value != new_value:
                self._high_value = new_value
                changed = True
        if changed:
            self.updated = (self._low_value, self._high_value)

    #------------------------------------------------------------------------
    # Event handlers
    #------------------------------------------------------------------------

    def _sources_items_changed(self, event):
        self.refresh()
        for source in event.removed:
            source.on_trait_change(self.refresh, "data_changed", remove=True)
        for source in event.added:
            source.on_trait_change(self.refresh, "data_changed")

    def _sources_changed(self, old, new):
        self.refresh()
        for source in old:
            source.on_trait_change(self.refresh, "data_changed", remove=True)
        for source in new:
            source.on_trait_change(self.refresh, "data_changed")

    #------------------------------------------------------------------------
    # Serialization interface
    #------------------------------------------------------------------------

    def _post_load(self):
        self._sources_changed(None, self.sources)


###### method to calculate bounds for a given 1-dimensional set of data
def calc_bounds(low_set, high_set, mins, maxes, epsilon, tight_bounds,
                margin=0.08, track_amount=0, bounds_func=None):
    """ Calculates bounds for a given 1-D set of data.

    Parameters
    ----------
    low_set : 'auto', 'track', or number
        Current low setting
    high_set : 'auto', 'track', or number
        Current high setting
    mins : list of numbers
        Potential minima.
    maxes : list
        Potential maxima.
    epsilon : number
        Minimum percentage difference between bounds
    tight_bounds : Boolean
        Do 'auto' bounds imply an exact fit to the data? If False, they pad a
        little bit of margin on either side.
    margin : float (default=0.08)
        The margin, expressed as a percentage of total data width, to place
        on either side of the data if tight_bounds is False.
    track_amount : number
        The amount by which a 'track' bound tracks another bound.
    bounds_func : Callable
        A callable which can override the bounds calculation.

    Returns
    -------
    (min, max) for the new bounds. If either of the calculated bounds is NaN,
    returns (0,0).

    Description
    -----------
    Setting both *low_set* and *high_set* to 'track' is an invalid state;
    the method copes by setting *high_set* to 'auto', and proceeding.
    """

    if (low_set == 'track') and (high_set == 'track'):
        high_set = 'auto'

    if low_set == 'auto':
        real_min = min(mins)
    elif low_set == 'track':
        # real_max hasn't been set yet
        pass
    else:
        real_min = low_set

    if high_set == 'auto':
        real_max = max(maxes)
    elif high_set == 'track':
        # real_min has been set now
        real_max = real_min + track_amount
    else:
        real_max = high_set

    # Go back and set real_min if we need to
    if low_set == 'track':
        real_min = real_max - track_amount

    # If we're all NaNs, just return a 0,1 range
    if isnan(real_max) or isnan(real_min):
        return 0, 0

    if not isinf(real_min) and not isinf(real_max) and \
            (abs(real_max - real_min) <= abs(epsilon * real_min)):
        # If we get here, then real_min and real_max are (for all
        # intents and purposes) identical, and so we just base
        # everything off of real_min.
        # Note: we have to use <= and not strict < because otherwise
        # we won't catch the cases when real_min == 0.0.
        if abs(real_min) > 1.0:
            # Round up to the next power of ten that encloses these
            log_val = log(abs(real_min), 10)
            if real_min >= 0:
                real_min = pow(10, floor(log_val))
                real_max = pow(10, ceil(log_val))
            else:
                real_min = -pow(10, ceil(log_val))
                real_max = -pow(10, floor(log_val))
        else:
            # If the user has a constant value less than 1, then these
            # are the bounds we use.
            if real_min > 0.0:
                real_max = 2 * real_min
                real_min = 0.0
            elif real_min == 0.0:
                real_min = -1.0
                real_max = 1.0
            else:
                real_min = 2 * real_min
                real_max = 0.0

    # Now test if the bounds leave some room around the data, unless
    # tight_bounds==True or unless another function to compute the bound
    # is provided.
    if bounds_func is not None:
        return bounds_func(real_min, real_max, margin, tight_bounds)
    elif not tight_bounds:
        low, high, d = heckbert_interval(real_min, real_max)
        # 2nd run of heckbert_interval necessary? Will be if bounds are
        # too tights (ie within the margin).
        rerun = False
        if abs(low - real_min) / (high - low) < margin:
            modified_min = real_min - (high - low) * margin
            rerun = True
        else:
            modified_min = real_min
        if abs(high - real_max) / (high - low) < margin:
            modified_max = real_max + (high - low) * margin
            rerun = True
        else:
            modified_max = real_max
        if rerun:
            low, high, d = heckbert_interval(modified_min, modified_max)
        return low, high
    else:
        return real_min, real_max

########NEW FILE########
__FILENAME__ = data_range_2d
"""
Defines the DataRange2D class.
"""

from numpy import compress, inf, transpose

# Enthought library imports
from traits.api import Any, Bool, CFloat, Instance, Property, Trait, \
    Tuple, on_trait_change

# Local relative imports
from base_data_range import BaseDataRange
from data_range_1d import DataRange1D


class DataRange2D(BaseDataRange):
    """ A range on (2-D) image data.

    In a mathematically general sense, a 2-D range is an arbitrary region in
    the plane.  Arbitrary regions are difficult to implement well, so this
    class supports only rectangular regions for now.
    """

    # The actual value of the lower bound of this range. To set it, use
    # **low_setting**.
    low = Property  # (2,) array of lower-left x,y
    # The actual value of the upper bound of this range. To set it, use
    # **high_setting**.
    high = Property  # (2,) array of upper-right x,y

    # Property for the lower bound of this range (overrides AbstractDataRange).
    low_setting = Property
    # Property for the upper bound of this range (overrides AbstractDataRange).
    high_setting = Property

    # The 2-D grid range is actually implemented as two 1-D ranges, which can
    # be accessed individually.  They can also be set to new DataRange1D
    # instances; in that case, the DataRange2D's sources are removed from
    # its old 1-D dataranges and added to the new one.

    # Property for the range in the x-dimension.
    x_range = Property
    # Property for the range in the y-dimension.
    y_range = Property

    # Do "auto" bounds imply an exact fit to the data? (One Boolean per
    # dimension) If False, the bounds pad a little bit of margin on either
    # side.
    tight_bounds = Tuple(Bool(True), Bool(True))
    # The minimum percentage difference between low and high for each
    # dimension. That is, (high-low) >= epsilon * low.
    epsilon = Tuple(CFloat(1.0e-4), CFloat(1.0e-4))

    #------------------------------------------------------------------------
    # Private traits
    #------------------------------------------------------------------------

    # The "_setting" attributes correspond to what the user has "set"; the
    # "_value" attributes are the actual numerical values for the given
    # setting.

    # The user-specified low settings.
    _low_setting = Trait(('auto', 'auto'), Any)
    # The actual numerical values for the low setting.
    _low_value = Trait((-inf, -inf), Tuple(CFloat, CFloat))
    # The user-specified high settings.
    _high_setting = Trait(('auto', 'auto'), Any)
    # The actual numerical value for the high setting.
    _high_value = Trait((inf, inf), Tuple(CFloat, CFloat))

    # DataRange1D for the x-dimension.
    _xrange = Instance(DataRange1D, args=())
    # DataRange1D for the y-dimension.
    _yrange = Instance(DataRange1D, args=())

    #------------------------------------------------------------------------
    # AbstractRange interface
    #------------------------------------------------------------------------

    def clip_data(self, data):
        """ Returns a list of data values that are within the range.

        Implements AbstractDataRange.
        """
        return compress(self.mask_data(data), data, axis=0)

    def mask_data(self, data):
        """ Returns a mask array, indicating whether values in the given array
        are inside the range.

        Implements AbstractDataRange.
        """
        x_points, y_points = transpose(data)
        x_mask = (x_points >= self.low[0]) & (x_points <= self.high[0])
        y_mask = (y_points >= self.low[1]) & (y_points <= self.high[1])
        return x_mask & y_mask

    def bound_data(self, data):
        """ Not implemented for this class.
        """
        raise NotImplementedError("bound_data() has not been implemented "
                                  "for 2d pointsets.")

    def set_bounds(self, low, high):
        """ Sets all the bounds of the range simultaneously.

        Implements AbstractDataRange.

        Parameters
        ----------
        low : (x,y)
            Lower-left corner of the range.
        high : (x,y)
            Upper right corner of the range.
        """
        self._do_set_low_setting(low, fire_event=False)
        self._do_set_high_setting(high)

    #------------------------------------------------------------------------
    # Public methods
    #------------------------------------------------------------------------

    def __init__(self, *args, **kwargs):
        super(DataRange2D, self).__init__(*args, **kwargs)

    def reset(self):
        """ Resets the bounds of this range.
        """
        self._high_setting = ('auto', 'auto')
        self._low_setting = ('auto', 'auto')
        self._refresh_bounds()

    def refresh(self):
        """ If any of the bounds is 'auto', this method refreshes the actual
        low and high values from the set of the view filters' data sources.
        """
        if 'auto' not in self._low_setting and \
           'auto' not in self._high_setting:
            # If the user has hard-coded bounds, then refresh() doesn't do
            # anything.
            return
        else:
            self._refresh_bounds()

    #------------------------------------------------------------------------
    # Public methods
    #------------------------------------------------------------------------

    def _do_set_high_setting(self, val, fire_event=True):
        self._xrange.high_setting = val[0]
        self._yrange.high_setting = val[1]

    def _refresh_bounds(self):
        self._xrange.refresh()
        self._yrange.refresh()

    #------------------------------------------------------------------------
    # Property getters and setters
    #------------------------------------------------------------------------

    def _get_low(self):
        return (self._xrange.low, self._yrange.low)

    def _set_low(self, val):
        return self._set_low_setting(val)

    def _get_low_setting(self):
        return (self._xrange.low_setting, self._yrange.low_setting)

    def _set_low_setting(self, val):
        self._do_set_low_setting(val)

    def _do_set_low_setting(self, val, fire_event=True):
        self._xrange.low_setting = val[0]
        self._yrange.low_setting = val[1]

    def _get_high(self):
        return (self._xrange.high, self._yrange.high)

    def _set_high(self, val):
        return self._set_high_setting(val)

    def _get_high_setting(self):
        return (self._xrange.high_setting, self._yrange.high_setting)

    def _set_high_setting(self, val):
        self._do_set_high_setting(val)

    def _get_x_range(self):
        return self._xrange

    def _set_x_range(self, newrange):
        self._set_1d_range("_xdata", self._xrange, newrange)
        self._xrange = newrange

    def _get_y_range(self):
        return self._yrange

    def _set_y_range(self, newrange):
        self._set_1d_range("_ydata", self._yrange, newrange)
        self._yrange = newrange

    def _set_1d_range(self, dataname, oldrange, newrange):
        # dataname is the name of the underlying 1d data source of the
        # ImageData instances in self.sources, e.g. "_xdata" or "_ydata"
        for source in self.sources:
            source1d = getattr(source, dataname, None)
            if source1d:
                if oldrange:
                    oldrange.remove(source1d)
                if newrange:
                    newrange.add(source1d)
        return

    #------------------------------------------------------------------------
    # Event handlers
    #------------------------------------------------------------------------

    def _sources_items_changed(self, event):
        for source in event.removed:
            source.on_trait_change(self.refresh, "data_changed", remove=True)
        for source in event.added:
            source.on_trait_change(self.refresh, "data_changed")
        # the _xdata and _ydata of the sources may be created anew on every
        # access, so we can't just add/delete from _xrange and _yrange sources
        # based on object identity. So recreate lists each time:
        self._xrange.sources = [s._xdata for s in self.sources]
        self._yrange.sources = [s._ydata for s in self.sources]
        self.refresh()

    def _sources_changed(self, old, new):
        for source in old:
            source.on_trait_change(self.refresh, "data_changed", remove=True)
        for source in new:
            source.on_trait_change(self.refresh, "data_changed")
        # the _xdata and _ydata of the sources may be created anew on every
        # access, so we can't just add/delete from _xrange and _yrange sources
        # based on object identity. So recreate lists each time:
        self._xrange.sources = [s._xdata for s in self.sources]
        self._yrange.sources = [s._ydata for s in self.sources]
        self.refresh()

    @on_trait_change("_xrange.updated,_yrange.updated")
    def _subranges_updated(self):
        self.updated = True

########NEW FILE########
__FILENAME__ = data_view
""" Defines the DataView class, and associated property traits and property
functions.
"""
from numpy import array, transpose

from traits.api import Bool, Enum, Instance, Property
from enable.colors import color_table

from abstract_overlay import AbstractOverlay
from axis import PlotAxis
from base_1d_mapper import Base1DMapper
from base_2d_plot import Base2DPlot
from data_range_2d import DataRange2D
from grid import PlotGrid
from linear_mapper import LinearMapper
from log_mapper import LogMapper
from plot_containers import OverlayPlotContainer


#-----------------------------------------------------------------------------
# Define new traits to condense the definition of some convenience
# properties in the Plot class
#-----------------------------------------------------------------------------

def get_mapper(self, attr_name):
    """ Getter function used by OrientedMapperProperty.
    """
    if (attr_name,self.orientation) in [("x_mapper","h"), ("y_mapper","v")]:
        return self.index_mapper
    else:
        return self.value_mapper

def set_mapper(self, attr_name, new):
    """ Setter function used by OrientedMapperProperty.
    """
    if (attr_name,self.orientation) in [("x_mapper","h"), ("y_mapper","v")]:
        self.index_mapper = new
    else:
        self.value_mapper = new

# Property that represents a mapper for an orientation.
OrientedMapperProperty = Property(get_mapper, set_mapper)


def get_axis(self, attr_name):
    """ Getter function used by AxisProperty.
    """
    if (attr_name,self.orientation) in [("index_axis","h"), ("value_axis","v")]:
        return self.x_axis
    else:
        return self.y_axis

def set_axis(self, attr_name, new):
    """ Setter function used by AxisProperty.
    """
    if (attr_name,self.orientation) in [("index_axis","h"), ("value_axis","v")]:
        self.x_axis = new
    else:
        self.y_axis = new

# Property that represents an axis.
AxisProperty = Property(get_axis, set_axis)


def get_grid(self, attr_name):
    """ Getter function used by GridProperty.
    """
    if (attr_name,self.orientation) in [("index_grid","v"), ("value_grid","h")]:
        return self.y_grid
    else:
        return self.x_grid

def set_grid(self, attr_name, new):
    """ Setter function used by GridProperty.
    """
    if (attr_name,self.orientation) in [("index_grid","v"), ("value_grid","h")]:
        self.y_grid = new
    else:
        self.y_grid = new

# Property that represents a grid for a particular orientation.
GridProperty = Property(get_grid, set_grid)


class DataView(OverlayPlotContainer):
    """ Represents a mapping from 2-D data space into 2-D screen space.

    It can house renderers and other plot components, and otherwise behaves
    just like a normal PlotContainer.
    """

    # The orientation of the index axis.
    orientation = Enum("h", "v")

    # The default location of the origin  for new plots
    default_origin = Enum("bottom left", "top left",
                          "bottom right", "top right")

    # The origin reported to axes, etc
    origin = Property(depends_on='default_origin')

    # Whether our map_screen and map_data should treat screen-space
    # coords as being in our coordinate space or in our contained
    # coordinate space.

    # The mapper to use for the index data.
    index_mapper = Instance(Base1DMapper)

    # The mapper to use for value data.
    value_mapper = Instance(Base1DMapper)

    # For x-y plots, the scale of the index axis.
    index_scale = Enum("linear", "log")

    # For x-y plots, the scale of the index axis.
    value_scale = Enum("linear", "log")

    # The range used for the index data.
    index_range = Property

    # The range used for the value data.
    value_range = Property

    # The 2-D data range whose x- and y-ranges are exposed as the
    # **index_range** and **value_range** property traits. This allows
    # supporting both XY plots and 2-D (image) plots.
    range2d = Instance(DataRange2D)

    # Convenience property that offers access to whatever mapper corresponds
    # to the X-axis.
    x_mapper = OrientedMapperProperty

    # Convenience property that offers access to whatever mapper corresponds
    # to the Y-axis
    y_mapper = OrientedMapperProperty

    #------------------------------------------------------------------------
    # Axis and Grids
    #------------------------------------------------------------------------

    # The horizontal axis.  Its position relative to the plot
    # area can be "top", "bottom", or "float".  The default position for a new
    # x-axis is "bottom".
    #
    # TODO: For now, this is an instance of AbstractOverlay instead of PlotAxis
    # because scales_axis.PlotAxis doesn't inherit from PlotAxis, but instead is a
    # semi-reimplementation.  Thus, rather than making scales_axis.PlotAxis
    # inherit a concrete class, I chose to loosen this trait by specifying
    # a more general base class of PlotAxis.  This incurs lower risk of subtle
    # and difficult-to-catch bugs being introduced by changes to the
    # axis.PlotAxis class.  This same comment applies to the y_axis trait
    # below.  --pwang
    #x_axis = Instance(PlotAxis)
    x_axis = Instance(AbstractOverlay)

    # The vertical axis.  Its position relative to the plot
    # area can be "left", "right", or "float".  The default position for a new
    # y-axis is "left".
    #y_axis = Instance(PlotAxis)
    y_axis = Instance(AbstractOverlay)

    # The grid that intersects the x-axis, i.e., a set of vertical lines.
    x_grid = Instance(PlotGrid)

    # The grid that intersects the y-axis, i.e., a set of horizontal lines.
    y_grid = Instance(PlotGrid)

    # Whether to automatically create the x_axis and y_axis if they were not
    # already set by the caller.
    auto_axis = Bool(True)

    # Whether to automatically create the x_grid and y_grid if they were not
    # already set by the caller.
    auto_grid = Bool(True)

    # Convenience property for accessing the index axis, which can be X or Y,
    # depending on **orientation**.
    index_axis = AxisProperty
    # Convenience property for accessing the value axis, which can be Y or X,
    # depending on **orientation**.
    value_axis = AxisProperty
    # Convenience property for accessing the index grid, which can be horizontal
    # or vertical, depending on **orientation**.
    index_grid = GridProperty
    # Convenience property for accessing the value grid, which can be vertical
    # or horizontal, depending on **orientation**.
    value_grid = GridProperty

    #------------------------------------------------------------------------
    # Appearance
    #------------------------------------------------------------------------

    # Background color (overrides Enable Component)
    bgcolor = "white"

    # Padding defaults.
    padding_top = 50
    padding_bottom = 50
    padding_left = 50
    padding_right = 50

    border_visible = True

    #------------------------------------------------------------------------
    # Public methods
    #------------------------------------------------------------------------

    def __init__(self, **kwtraits):
        super(DataView, self).__init__(**kwtraits)
        self._init_components()

        # If we are not resizable, we will not get a bounds update upon layout,
        # so we have to manually update our mappers
        if self.resizable == "":
            self._update_mappers()
        return

    def map_screen(self, data_array):
        """ Maps an array of data points to screen space and returns an array
        of screen space points.
        """
        # data_array is Nx2 array
        if len(data_array) == 0:
            return []
        x_ary, y_ary = transpose(data_array)
        sx = self.index_mapper.map_screen(x_ary)
        sy = self.value_mapper.map_screen(y_ary)
        if self.orientation == "h":
            return transpose(array((sx,sy)))
        else:
            return transpose(array((sy,sx)))

    def map_data(self, screen_pt):
        """ Maps a screen space point into the 2D data space of this plot.
        (Note that this differs from the BaseXYPlot implementation, which by
        default only maps into the 1D index space.)
        """
        # At some point it would be good to change the DataView to use
        # the GridMapper, and then use its map_data() method.
        x, y = screen_pt
        return array((self.index_mapper.map_data(x),
                      self.value_mapper.map_data(y)))

    #------------------------------------------------------------------------
    # Private methods
    #------------------------------------------------------------------------

    def _init_components(self):
        # Since this is called after the HasTraits constructor, we have to make
        # sure that we don't blow away any components that the caller may have
        # already set.

        if not self.range2d:
            self.range2d = DataRange2D()

        if not self.index_mapper:
            if self.index_scale == "linear":
                imap = LinearMapper(range=self.range2d.x_range)
            else:
                imap = LogMapper(range=self.range2d.x_range)
            self.index_mapper = imap

        if not self.value_mapper:
            if self.value_scale == "linear":
                vmap = LinearMapper(range=self.range2d.y_range)
            else:
                vmap = LogMapper(range=self.range2d.y_range)
            self.value_mapper = vmap

        # make sure the grid and bgcolor are not the same color

        grid_color = 'lightgray'
        if color_table[self.bgcolor] == color_table[grid_color]:
            grid_color = 'white'

        if not self.x_grid and self.auto_grid:
            self.x_grid = PlotGrid(mapper=self.x_mapper, orientation="vertical",
                                  line_color=grid_color, line_style="dot",
                                  component=self)
        if not self.y_grid and self.auto_grid:
            self.y_grid = PlotGrid(mapper=self.y_mapper, orientation="horizontal",
                                  line_color=grid_color, line_style="dot",
                                  component=self)

        if not self.x_axis and self.auto_axis:
            self.x_axis = PlotAxis(mapper=self.x_mapper, orientation="bottom",
                                  component=self)

        if not self.y_axis and self.auto_axis:
            self.y_axis = PlotAxis(mapper=self.y_mapper, orientation="left",
                                  component=self)

    #-------------------------------------------------------------------------
    # Event handlers
    #-------------------------------------------------------------------------

    def _update_mappers(self):

        x = self.x
        x2 = self.x2
        y = self.y
        y2 = self.y2

        if self.x_mapper is not None:
            if "left" in self.origin:
                self.x_mapper.low_pos = x
                self.x_mapper.high_pos = x2
            else:
                self.x_mapper.low_pos = x2
                self.x_mapper.high_pos = x

        if self.y_mapper is not None:
            if "bottom" in self.origin:
                self.y_mapper.low_pos = y
                self.y_mapper.high_pos = y2
            else:
                self.y_mapper.low_pos = y2
                self.y_mapper.high_pos = y

        self.invalidate_draw()
        return

    def _bounds_changed(self, old, new):
        super(DataView, self)._bounds_changed(old, new)
        self._update_mappers()

    def _bounds_items_changed(self, event):
        super(DataView, self)._bounds_items_changed(event)
        self._update_mappers()

    def _position_changed(self, old, new):
        super(DataView, self)._position_changed(old, new)
        self._update_mappers()

    def _position_items_changed(self, event):
        super(DataView, self)._position_items_changed(event)
        self._update_mappers()

    def _origin_changed(self):
        self._update_mappers()

    def _orientation_changed(self):
        # Change our grid and axis mappers so that they correspond to the
        # new mapper configuration.  Using the self.x_mapper and self.y_mapper
        # properties will grab the correct mappers corresponding to our new
        # orientation.
        if self.x_grid is not None:
            self.x_grid.mapper = self.x_mapper
        if self.y_grid is not None:
            self.y_grid.mapper = self.y_mapper
        if self.x_axis is not None:
            self.x_axis.mapper = self.x_mapper
        if self.y_axis is not None:
            self.y_axis.mapper = self.y_mapper
        self._update_mappers()
        for renderer in self.components:
            if hasattr(renderer, "orientation"):
                renderer.orientation = self.orientation
        return

    def _index_mapper_changed(self, old, new):
        if new is not None:
            if new.range is not None:
                # Add the range's datasources to our range
                for source in new.range.sources:
                    self.index_range.add(source)
            new.range = self.index_range
        if self.index_axis:
            self.index_axis.mapper = new
        if self.index_grid:
            self.index_grid.mapper = new

    def _value_mapper_changed(self, old, new):
        if new is not None:
            if new.range is not None:
                # Add the range's datasources to our range
                for source in new.range.sources:
                    self.value_range.add(source)
            new.range = self.value_range
        if self.value_axis:
            self.value_axis.mapper = new
        if self.value_grid:
            self.value_grid.mapper = new

    def _bgcolor_changed(self):
        self.invalidate_draw()

    def _x_grid_changed(self, old, new):
        self._underlay_change_helper(old, new)

    def _y_grid_changed(self, old, new):
        self._underlay_change_helper(old, new)

    def _x_axis_changed(self, old, new):
        self._underlay_change_helper(old, new)

    def _y_axis_changed(self, old, new):
        self._underlay_change_helper(old, new)

    def _underlay_change_helper(self, old, new):
        if old in self.underlays:
            self.underlays.remove(old)
        if new is not None:
            self.underlays.append(new)

    def _overlay_change_helper(self, old, new):
        if old in self.overlays:
            self.overlays.remove(old)
        if new is not None:
            self.overlays.append(new)

    def _range2d_changed(self, old, new):
        if new is not None:
            if self.index_mapper is not None:
                self.index_mapper.range = new.x_range
            if self.value_mapper is not None:
                self.value_mapper.range = new.y_range
        else:
            self.index_mapper.range = None
            self.value_mapper.range = None
        if old is not None:
            for datasource in old.sources[:]:
                old.remove(datasource)
                if new is not None:
                    new.add(datasource)
        for renderer in self.components:
            if hasattr(renderer, 'range2d'):
                renderer.range2d = new
            elif isinstance(renderer, Base2DPlot):
                renderer.index_range = new
            else:
                if hasattr(renderer, 'index_range'):
                    setattr(renderer, 'index_range', self.index_range)
                if hasattr(renderer, 'value_range'):
                    setattr(renderer, 'value_range', self.value_range)
        return

    def _range2d_default(self):
        """ Default trait initializer for the range2d trait """
        return DataRange2D()


    #------------------------------------------------------------------------
    # Property getters and setters
    #------------------------------------------------------------------------

    def _get_index_range(self):
        return self.range2d.x_range

    def _set_index_range(self, newrange):
        self._handle_range_changed("index", self.range2d.x_range, newrange)
        self.range2d.x_range = newrange

    def _get_value_range(self):
        return self.range2d.y_range

    def _set_value_range(self, newrange):
        self._handle_range_changed("value", self.range2d.y_range, newrange)
        self.range2d.y_range = newrange

    def _handle_range_changed(self, name, old, new):
        mapper = getattr(self, name+"_mapper")
        if mapper.range == old:
            mapper.range = new
        if old is not None:
            for datasource in old.sources[:]:
                old.remove(datasource)
                if new is not None:
                    new.add(datasource)
        range_name = name + "_range"
        for renderer in self.components:
            if hasattr(renderer, range_name):
                setattr(renderer, range_name, new)

    def _get_origin(self):
        # FIXME:
        return self.default_origin



########NEW FILE########
__FILENAME__ = default_colormaps
#------------------------------------------------------------------------------
# Copyright (c) 2005, Enthought, Inc.
# All rights reserved.
#
# This software is provided without warranty under the terms of the BSD
# license included in LICENSE.txt and may be redistributed only
# under the conditions described in the aforementioned license.  The license
# is also available online at http://www.enthought.com/licenses/BSD.txt
# Thanks for using Enthought open source!
#
# Portions of this software are:
# Copyright (c) 2002-2004 John D. Hunter
# All Rights Reserved.
#------------------------------------------------------------------------------

"""
A collection of pre-defined colormap generator functions.

Each of the functions can be called with *min_value* and *max_value* parameters.
In that case, they produce a Colormap which linearly maps over the specified
range and has the color palette indicated by the function name.
"""

from numpy import array

# Local imports.
from color_mapper import ColorMapper

# The colormaps will be added to this at the end of the file.
__all__ = ['reverse', 'center', 'color_map_functions', 'color_map_dict',
    'color_map_name_dict']


# Utility functions.

def reverse(func):
    """ Modify a colormap factory to reverse the color sequence

    Parameters
    ----------
    func : callable
        A colormap factory function like those provided in this module.

    Returns
    -------
    cmap : callable
        A wrapper factory function that can be used in place of the original
        factory function.
    """
    def cmap(range, **traits):
        cm = func(range, **traits)
        cm.reverse_colormap()
        return cm

    # Look a little like the wrapped function.
    cmap.__name__ = 'reversed_' + func.__name__
    cmap.__doc__ = 'Reversed: ' + func.__doc__
    return cmap

def center(func, center=0.0):
    """ Modify the range of a colormap to be centered around the given value.

    For example, when passed a DataRange1D(low=-0.5, high=1.0), a colormap would
    usually have its lowest color at -0.5 and its highest at 1.0. Some colormaps
    are designed such that the middle color is special. Using this modifier, the
    example range would be modified to -1.0 and 1.0 to make 0.0 correspond with
    the middle color.

    Parameters
    ----------
    func : callable
        A colormap factory function like those provided in this module.
    center : float, optional
        The center value in dataspace.

    Returns
    -------
    cmap : callable
        A wrapper factory function that can be used in place of the original
        factory function.
    """
    def cmap(range, **traits):
        maxdev = max(abs(range.low - center), abs(range.high - center))
        range = range.clone_traits()
        range.low = center - maxdev
        range.high = center + maxdev
        return func(range, **traits)

    # Look a little like the wrapped function.
    cmap.__name__ = 'centered_' + func.__name__
    cmap.__doc__ = 'Centered: ' + func.__doc__
    return cmap

def fix(func, range):
    """ Apply the given range to a colormap rather than accept the one coming
    from the data.

    This is useful for colormaps intrinsically tied to a given scale, like
    bathymetry/elevation colormaps for GIS or for working around Chaco to
    implement custom behavior.

    Paramaters
    ----------
    func : callable
        A colormap factory function like those provided in this module.
    range : DataRange1D or (low, high) tuple.
        The range to apply.

    Returns
    -------
    cmap : callable
        A wrapper factory function that can be used in place of the original
        factory function.
    """
    if isinstance(range, tuple):
        # Adapt tuples to DataRange1D for convenience.
        from chaco.data_range_1d import DataRange1D
        range = DataRange1D(low=range[0], high=range[1])

    def cmap(dummy_range, **traits):
        # Use the range given to the fix() function, not the cmap() function.
        return func(range, **traits)

    # Look a little like the wrapped function.
    cmap.__name__ = 'fixed_' + func.__name__
    cmap.__doc__ = 'Fixed: ' + func.__doc__
    return cmap


# Colormaps.


def autumn(range, **traits):
    """ Generator function for the 'autumn' colormap. """

    _data = {'red':   ((0., 1.0, 1.0),(1.0, 1.0, 1.0)),
             'green': ((0., 0., 0.),(1.0, 1.0, 1.0)),
             'blue':  ((0., 0., 0.),(1.0, 0., 0.))}

    return ColorMapper.from_segment_map(_data, range=range, **traits)


def bone(range, **traits):
    """ Generator function for the 'bone' colormap. """

    _data = {'red':   ((0., 0., 0.), (0.746032, 0.652778, 0.652778), (1.0, 1.0, 1.0)),
             'green': ((0., 0., 0.), (0.365079, 0.319444, 0.319444), (0.746032, 0.777778, 0.777778), (1.0, 1.0, 1.0)),
             'blue':  ((0., 0., 0.), (0.365079, 0.444444, 0.444444), (1.0, 1.0, 1.0))}

    return ColorMapper.from_segment_map(_data, range=range, **traits)

def cool(range, **traits):
    """ Generator function for the 'cool' colormap. """

    _data = {'red':   ((0., 0., 0.), (1.0, 1.0, 1.0)),
              'green': ((0., 1., 1.), (1.0, 0.,  0.)),
              'blue':  ((0., 1., 1.), (1.0, 1.,  1.))}

    return ColorMapper.from_segment_map(_data, range=range, **traits)

def copper(range, **traits):
    """ Generator function for the 'copper' colormap. """

    _data = {'red':   ((0., 0., 0.),(0.809524, 1.000000, 1.000000),(1.0, 1.0, 1.0)),
             'green': ((0., 0., 0.),(1.0, 0.7812, 0.7812)),
             'blue':  ((0., 0., 0.),(1.0, 0.4975, 0.4975))}

    return ColorMapper.from_segment_map(_data, range=range, **traits)

def flag(range, **traits):
    """ Generator function for the 'flag' colormap. """

    _data = {'red':   ((0., 1., 1.),(0.015873, 1.000000, 1.000000),
                       (0.031746, 0.000000, 0.000000),(0.047619, 0.000000, 0.000000),
                       (0.063492, 1.000000, 1.000000),(0.079365, 1.000000, 1.000000),
                       (0.095238, 0.000000, 0.000000),(0.111111, 0.000000, 0.000000),
                       (0.126984, 1.000000, 1.000000),(0.142857, 1.000000, 1.000000),
                       (0.158730, 0.000000, 0.000000),(0.174603, 0.000000, 0.000000),
                       (0.190476, 1.000000, 1.000000),(0.206349, 1.000000, 1.000000),
                       (0.222222, 0.000000, 0.000000),(0.238095, 0.000000, 0.000000),
                       (0.253968, 1.000000, 1.000000),(0.269841, 1.000000, 1.000000),
                       (0.285714, 0.000000, 0.000000),(0.301587, 0.000000, 0.000000),
                       (0.317460, 1.000000, 1.000000),(0.333333, 1.000000, 1.000000),
                       (0.349206, 0.000000, 0.000000),(0.365079, 0.000000, 0.000000),
                       (0.380952, 1.000000, 1.000000),(0.396825, 1.000000, 1.000000),
                       (0.412698, 0.000000, 0.000000),(0.428571, 0.000000, 0.000000),
                       (0.444444, 1.000000, 1.000000),(0.460317, 1.000000, 1.000000),
                       (0.476190, 0.000000, 0.000000),(0.492063, 0.000000, 0.000000),
                       (0.507937, 1.000000, 1.000000),(0.523810, 1.000000, 1.000000),
                       (0.539683, 0.000000, 0.000000),(0.555556, 0.000000, 0.000000),
                       (0.571429, 1.000000, 1.000000),(0.587302, 1.000000, 1.000000),
                       (0.603175, 0.000000, 0.000000),(0.619048, 0.000000, 0.000000),
                       (0.634921, 1.000000, 1.000000),(0.650794, 1.000000, 1.000000),
                       (0.666667, 0.000000, 0.000000),(0.682540, 0.000000, 0.000000),
                       (0.698413, 1.000000, 1.000000),(0.714286, 1.000000, 1.000000),
                       (0.730159, 0.000000, 0.000000),(0.746032, 0.000000, 0.000000),
                       (0.761905, 1.000000, 1.000000),(0.777778, 1.000000, 1.000000),
                       (0.793651, 0.000000, 0.000000),(0.809524, 0.000000, 0.000000),
                       (0.825397, 1.000000, 1.000000),(0.841270, 1.000000, 1.000000),
                       (0.857143, 0.000000, 0.000000),(0.873016, 0.000000, 0.000000),
                       (0.888889, 1.000000, 1.000000),(0.904762, 1.000000, 1.000000),
                       (0.920635, 0.000000, 0.000000),(0.936508, 0.000000, 0.000000),
                       (0.952381, 1.000000, 1.000000),(0.968254, 1.000000, 1.000000),
                       (0.984127, 0.000000, 0.000000),(1.0, 0., 0.)),
             'green': ((0., 0., 0.),(0.015873, 1.000000, 1.000000),
                       (0.031746, 0.000000, 0.000000),(0.063492, 0.000000, 0.000000),
                       (0.079365, 1.000000, 1.000000),(0.095238, 0.000000, 0.000000),
                       (0.126984, 0.000000, 0.000000),(0.142857, 1.000000, 1.000000),
                       (0.158730, 0.000000, 0.000000),(0.190476, 0.000000, 0.000000),
                       (0.206349, 1.000000, 1.000000),(0.222222, 0.000000, 0.000000),
                       (0.253968, 0.000000, 0.000000),(0.269841, 1.000000, 1.000000),
                       (0.285714, 0.000000, 0.000000),(0.317460, 0.000000, 0.000000),
                       (0.333333, 1.000000, 1.000000),(0.349206, 0.000000, 0.000000),
                       (0.380952, 0.000000, 0.000000),(0.396825, 1.000000, 1.000000),
                       (0.412698, 0.000000, 0.000000),(0.444444, 0.000000, 0.000000),
                       (0.460317, 1.000000, 1.000000),(0.476190, 0.000000, 0.000000),
                       (0.507937, 0.000000, 0.000000),(0.523810, 1.000000, 1.000000),
                       (0.539683, 0.000000, 0.000000),(0.571429, 0.000000, 0.000000),
                       (0.587302, 1.000000, 1.000000),(0.603175, 0.000000, 0.000000),
                       (0.634921, 0.000000, 0.000000),(0.650794, 1.000000, 1.000000),
                       (0.666667, 0.000000, 0.000000),(0.698413, 0.000000, 0.000000),
                       (0.714286, 1.000000, 1.000000),(0.730159, 0.000000, 0.000000),
                       (0.761905, 0.000000, 0.000000),(0.777778, 1.000000, 1.000000),
                       (0.793651, 0.000000, 0.000000),(0.825397, 0.000000, 0.000000),
                        (0.841270, 1.000000, 1.000000),(0.857143, 0.000000, 0.000000),
                       (0.888889, 0.000000, 0.000000),(0.904762, 1.000000, 1.000000),
                       (0.920635, 0.000000, 0.000000),(0.952381, 0.000000, 0.000000),
                       (0.968254, 1.000000, 1.000000),(0.984127, 0.000000, 0.000000),
                       (1.0, 0., 0.)),
             'blue':  ((0., 0., 0.),(0.015873, 1.000000, 1.000000),
                       (0.031746, 1.000000, 1.000000),(0.047619, 0.000000, 0.000000),
                       (0.063492, 0.000000, 0.000000),(0.079365, 1.000000, 1.000000),
                       (0.095238, 1.000000, 1.000000),(0.111111, 0.000000, 0.000000),
                       (0.126984, 0.000000, 0.000000),(0.142857, 1.000000, 1.000000),
                       (0.158730, 1.000000, 1.000000),(0.174603, 0.000000, 0.000000),
                       (0.190476, 0.000000, 0.000000),(0.206349, 1.000000, 1.000000),
                       (0.222222, 1.000000, 1.000000),(0.238095, 0.000000, 0.000000),
                       (0.253968, 0.000000, 0.000000),(0.269841, 1.000000, 1.000000),
                       (0.285714, 1.000000, 1.000000),(0.301587, 0.000000, 0.000000),
                       (0.317460, 0.000000, 0.000000),(0.333333, 1.000000, 1.000000),
                       (0.349206, 1.000000, 1.000000),(0.365079, 0.000000, 0.000000),
                       (0.380952, 0.000000, 0.000000),(0.396825, 1.000000, 1.000000),
                       (0.412698, 1.000000, 1.000000),(0.428571, 0.000000, 0.000000),
                       (0.444444, 0.000000, 0.000000),(0.460317, 1.000000, 1.000000),
                       (0.476190, 1.000000, 1.000000),(0.492063, 0.000000, 0.000000),
                       (0.507937, 0.000000, 0.000000),(0.523810, 1.000000, 1.000000),
                       (0.539683, 1.000000, 1.000000),(0.555556, 0.000000, 0.000000),
                       (0.571429, 0.000000, 0.000000),(0.587302, 1.000000, 1.000000),
                       (0.603175, 1.000000, 1.000000),(0.619048, 0.000000, 0.000000),
                       (0.634921, 0.000000, 0.000000),(0.650794, 1.000000, 1.000000),
                       (0.666667, 1.000000, 1.000000),(0.682540, 0.000000, 0.000000),
                       (0.698413, 0.000000, 0.000000),(0.714286, 1.000000, 1.000000),
                       (0.730159, 1.000000, 1.000000),(0.746032, 0.000000, 0.000000),
                       (0.761905, 0.000000, 0.000000),(0.777778, 1.000000, 1.000000),
                       (0.793651, 1.000000, 1.000000),(0.809524, 0.000000, 0.000000),
                       (0.825397, 0.000000, 0.000000),(0.841270, 1.000000, 1.000000),
                       (0.857143, 1.000000, 1.000000),(0.873016, 0.000000, 0.000000),
                       (0.888889, 0.000000, 0.000000),(0.904762, 1.000000, 1.000000),
                       (0.920635, 1.000000, 1.000000),(0.936508, 0.000000, 0.000000),
                       (0.952381, 0.000000, 0.000000),(0.968254, 1.000000, 1.000000),
                       (0.984127, 1.000000, 1.000000),(1.0, 0., 0.))}

    return ColorMapper.from_segment_map(_data, range=range, **traits)

def gray(range, **traits):
    """ Generator function for the 'gray' colormap. """

    _data =  {'red':   ((0., 0, 0), (1., 1, 1)),
              'green': ((0., 0, 0), (1., 1, 1)),
              'blue':  ((0., 0, 0), (1., 1, 1))}

    return ColorMapper.from_segment_map(_data, range=range, **traits)

def yarg(range, **traits):
    """ Generator function for the 'yarg' colormap. """

    _data =  {'red':   ((0., 1, 1), (1., 0, 0)),
              'green': ((0., 1, 1), (1., 0, 0)),
              'blue':  ((0., 1, 1), (1., 0, 0))}

    return ColorMapper.from_segment_map(_data, range=range, **traits)

def hot(range, **traits):
    """ Generator function for the 'hot' colormap. """

    _data = {'red':   ((0., 0.0416, 0.0416),(0.365079, 1.000000, 1.000000),(1.0, 1.0, 1.0)),
             'green': ((0., 0., 0.),(0.365079, 0.000000, 0.000000),
                       (0.746032, 1.000000, 1.000000),(1.0, 1.0, 1.0)),
             'blue':  ((0., 0., 0.),(0.746032, 0.000000, 0.000000),(1.0, 1.0, 1.0))}

    return ColorMapper.from_segment_map(_data, range=range, **traits)

def hsv(range, **traits):
    """ Generator function for the 'hsv' colormap. """

    _data = {'red':   ((0., 1., 1.),(0.158730, 1.000000, 1.000000),
                       (0.174603, 0.968750, 0.968750),(0.333333, 0.031250, 0.031250),
                       (0.349206, 0.000000, 0.000000),(0.666667, 0.000000, 0.000000),
                       (0.682540, 0.031250, 0.031250),(0.841270, 0.968750, 0.968750),
                       (0.857143, 1.000000, 1.000000),(1.0, 1.0, 1.0)),
             'green': ((0., 0., 0.),(0.158730, 0.937500, 0.937500),
                       (0.174603, 1.000000, 1.000000),(0.507937, 1.000000, 1.000000),
                       (0.666667, 0.062500, 0.062500),(0.682540, 0.000000, 0.000000),
                       (1.0, 0., 0.)),
             'blue':  ((0., 0., 0.),(0.333333, 0.000000, 0.000000),
                       (0.349206, 0.062500, 0.062500),(0.507937, 1.000000, 1.000000),
                       (0.841270, 1.000000, 1.000000),(0.857143, 0.937500, 0.937500),
                       (1.0, 0.09375, 0.09375))}

    return ColorMapper.from_segment_map(_data, range=range, **traits)

def jet(range, **traits):
    """ Generator function for the 'jet' colormap. """

    _data =   {'red':   ((0., 0, 0), (0.35, 0, 0), (0.66, 1, 1), (0.89,1, 1),
                         (1, 0.5, 0.5)),
               'green': ((0., 0, 0), (0.125,0, 0), (0.375,1, 1), (0.64,1, 1),
                         (0.91,0,0), (1, 0, 0)),
               'blue':  ((0., 0.5, 0.5), (0.11, 1, 1), (0.34, 1, 1), (0.65,0, 0),
                         (1, 0, 0))}

    return ColorMapper.from_segment_map(_data, range=range, **traits)

def pink(range, **traits):
    """ Generator function for the 'pink' colormap. """

    _data = {'red':   ((0., 0.1178, 0.1178),(0.015873, 0.195857, 0.195857),
                       (0.031746, 0.250661, 0.250661),(0.047619, 0.295468, 0.295468),
                       (0.063492, 0.334324, 0.334324),(0.079365, 0.369112, 0.369112),
                       (0.095238, 0.400892, 0.400892),(0.111111, 0.430331, 0.430331),
                       (0.126984, 0.457882, 0.457882),(0.142857, 0.483867, 0.483867),
                       (0.158730, 0.508525, 0.508525),(0.174603, 0.532042, 0.532042),
                       (0.190476, 0.554563, 0.554563),(0.206349, 0.576204, 0.576204),
                       (0.222222, 0.597061, 0.597061),(0.238095, 0.617213, 0.617213),
                       (0.253968, 0.636729, 0.636729),(0.269841, 0.655663, 0.655663),
                       (0.285714, 0.674066, 0.674066),(0.301587, 0.691980, 0.691980),
                       (0.317460, 0.709441, 0.709441),(0.333333, 0.726483, 0.726483),
                       (0.349206, 0.743134, 0.743134),(0.365079, 0.759421, 0.759421),
                       (0.380952, 0.766356, 0.766356),(0.396825, 0.773229, 0.773229),
                       (0.412698, 0.780042, 0.780042),(0.428571, 0.786796, 0.786796),
                       (0.444444, 0.793492, 0.793492),(0.460317, 0.800132, 0.800132),
                       (0.476190, 0.806718, 0.806718),(0.492063, 0.813250, 0.813250),
                       (0.507937, 0.819730, 0.819730),(0.523810, 0.826160, 0.826160),
                       (0.539683, 0.832539, 0.832539),(0.555556, 0.838870, 0.838870),
                       (0.571429, 0.845154, 0.845154),(0.587302, 0.851392, 0.851392),
                       (0.603175, 0.857584, 0.857584),(0.619048, 0.863731, 0.863731),
                       (0.634921, 0.869835, 0.869835),(0.650794, 0.875897, 0.875897),
                       (0.666667, 0.881917, 0.881917),(0.682540, 0.887896, 0.887896),
                       (0.698413, 0.893835, 0.893835),(0.714286, 0.899735, 0.899735),
                       (0.730159, 0.905597, 0.905597),(0.746032, 0.911421, 0.911421),
                       (0.761905, 0.917208, 0.917208),(0.777778, 0.922958, 0.922958),
                       (0.793651, 0.928673, 0.928673),(0.809524, 0.934353, 0.934353),
                       (0.825397, 0.939999, 0.939999),(0.841270, 0.945611, 0.945611),
                       (0.857143, 0.951190, 0.951190),(0.873016, 0.956736, 0.956736),
                       (0.888889, 0.962250, 0.962250),(0.904762, 0.967733, 0.967733),
                       (0.920635, 0.973185, 0.973185),(0.936508, 0.978607, 0.978607),
                       (0.952381, 0.983999, 0.983999),(0.968254, 0.989361, 0.989361),
                       (0.984127, 0.994695, 0.994695),(1.0, 1.0, 1.0)),
             'green': ((0., 0., 0.),(0.015873, 0.102869, 0.102869),
                       (0.031746, 0.145479, 0.145479),(0.047619, 0.178174, 0.178174),
                       (0.063492, 0.205738, 0.205738),(0.079365, 0.230022, 0.230022),
                       (0.095238, 0.251976, 0.251976),(0.111111, 0.272166, 0.272166),
                       (0.126984, 0.290957, 0.290957),(0.142857, 0.308607, 0.308607),
                       (0.158730, 0.325300, 0.325300),(0.174603, 0.341178, 0.341178),
                       (0.190476, 0.356348, 0.356348),(0.206349, 0.370899, 0.370899),
                       (0.222222, 0.384900, 0.384900),(0.238095, 0.398410, 0.398410),
                       (0.253968, 0.411476, 0.411476),(0.269841, 0.424139, 0.424139),
                       (0.285714, 0.436436, 0.436436),(0.301587, 0.448395, 0.448395),
                       (0.317460, 0.460044, 0.460044),(0.333333, 0.471405, 0.471405),
                       (0.349206, 0.482498, 0.482498),(0.365079, 0.493342, 0.493342),
                       (0.380952, 0.517549, 0.517549),(0.396825, 0.540674, 0.540674),
                       (0.412698, 0.562849, 0.562849),(0.428571, 0.584183, 0.584183),
                       (0.444444, 0.604765, 0.604765),(0.460317, 0.624669, 0.624669),
                       (0.476190, 0.643958, 0.643958),(0.492063, 0.662687, 0.662687),
                       (0.507937, 0.680900, 0.680900),(0.523810, 0.698638, 0.698638),
                       (0.539683, 0.715937, 0.715937),(0.555556, 0.732828, 0.732828),
                       (0.571429, 0.749338, 0.749338),(0.587302, 0.765493, 0.765493),
                       (0.603175, 0.781313, 0.781313),(0.619048, 0.796819, 0.796819),
                       (0.634921, 0.812029, 0.812029),(0.650794, 0.826960, 0.826960),
                       (0.666667, 0.841625, 0.841625),(0.682540, 0.856040, 0.856040),
                       (0.698413, 0.870216, 0.870216),(0.714286, 0.884164, 0.884164),
                       (0.730159, 0.897896, 0.897896),(0.746032, 0.911421, 0.911421),
                       (0.761905, 0.917208, 0.917208),(0.777778, 0.922958, 0.922958),
                       (0.793651, 0.928673, 0.928673),(0.809524, 0.934353, 0.934353),
                       (0.825397, 0.939999, 0.939999),(0.841270, 0.945611, 0.945611),
                       (0.857143, 0.951190, 0.951190),(0.873016, 0.956736, 0.956736),
                       (0.888889, 0.962250, 0.962250),(0.904762, 0.967733, 0.967733),
                       (0.920635, 0.973185, 0.973185),(0.936508, 0.978607, 0.978607),
                       (0.952381, 0.983999, 0.983999),(0.968254, 0.989361, 0.989361),
                       (0.984127, 0.994695, 0.994695),(1.0, 1.0, 1.0)),
             'blue':  ((0., 0., 0.),(0.015873, 0.102869, 0.102869),
                       (0.031746, 0.145479, 0.145479),(0.047619, 0.178174, 0.178174),
                       (0.063492, 0.205738, 0.205738),(0.079365, 0.230022, 0.230022),
                       (0.095238, 0.251976, 0.251976),(0.111111, 0.272166, 0.272166),
                       (0.126984, 0.290957, 0.290957),(0.142857, 0.308607, 0.308607),
                       (0.158730, 0.325300, 0.325300),(0.174603, 0.341178, 0.341178),
                       (0.190476, 0.356348, 0.356348),(0.206349, 0.370899, 0.370899),
                       (0.222222, 0.384900, 0.384900),(0.238095, 0.398410, 0.398410),
                       (0.253968, 0.411476, 0.411476),(0.269841, 0.424139, 0.424139),
                       (0.285714, 0.436436, 0.436436),(0.301587, 0.448395, 0.448395),
                       (0.317460, 0.460044, 0.460044),(0.333333, 0.471405, 0.471405),
                       (0.349206, 0.482498, 0.482498),(0.365079, 0.493342, 0.493342),
                       (0.380952, 0.503953, 0.503953),(0.396825, 0.514344, 0.514344),
                       (0.412698, 0.524531, 0.524531),(0.428571, 0.534522, 0.534522),
                       (0.444444, 0.544331, 0.544331),(0.460317, 0.553966, 0.553966),
                       (0.476190, 0.563436, 0.563436),(0.492063, 0.572750, 0.572750),
                       (0.507937, 0.581914, 0.581914),(0.523810, 0.590937, 0.590937),
                       (0.539683, 0.599824, 0.599824),(0.555556, 0.608581, 0.608581),
                       (0.571429, 0.617213, 0.617213),(0.587302, 0.625727, 0.625727),
                       (0.603175, 0.634126, 0.634126),(0.619048, 0.642416, 0.642416),
                       (0.634921, 0.650600, 0.650600),(0.650794, 0.658682, 0.658682),
                       (0.666667, 0.666667, 0.666667),(0.682540, 0.674556, 0.674556),
                       (0.698413, 0.682355, 0.682355),(0.714286, 0.690066, 0.690066),
                       (0.730159, 0.697691, 0.697691),(0.746032, 0.705234, 0.705234),
                       (0.761905, 0.727166, 0.727166),(0.777778, 0.748455, 0.748455),
                       (0.793651, 0.769156, 0.769156),(0.809524, 0.789314, 0.789314),
                       (0.825397, 0.808969, 0.808969),(0.841270, 0.828159, 0.828159),
                       (0.857143, 0.846913, 0.846913),(0.873016, 0.865261, 0.865261),
                       (0.888889, 0.883229, 0.883229),(0.904762, 0.900837, 0.900837),
                       (0.920635, 0.918109, 0.918109),(0.936508, 0.935061, 0.935061),
                       (0.952381, 0.951711, 0.951711),(0.968254, 0.968075, 0.968075),
                       (0.984127, 0.984167, 0.984167),(1.0, 1.0, 1.0))}

    return ColorMapper.from_segment_map(_data, range=range, **traits)

def prism(range, **traits):
    """ Generator function for the 'prism' colormap. """

    _data = {'red':   ((0., 1., 1.),(0.031746, 1.000000, 1.000000),
                       (0.047619, 0.000000, 0.000000),(0.063492, 0.000000, 0.000000),
                       (0.079365, 0.666667, 0.666667),(0.095238, 1.000000, 1.000000),
                       (0.126984, 1.000000, 1.000000),(0.142857, 0.000000, 0.000000),
                       (0.158730, 0.000000, 0.000000),(0.174603, 0.666667, 0.666667),
                       (0.190476, 1.000000, 1.000000),(0.222222, 1.000000, 1.000000),
                       (0.238095, 0.000000, 0.000000),(0.253968, 0.000000, 0.000000),
                       (0.269841, 0.666667, 0.666667),(0.285714, 1.000000, 1.000000),
                       (0.317460, 1.000000, 1.000000),(0.333333, 0.000000, 0.000000),
                       (0.349206, 0.000000, 0.000000),(0.365079, 0.666667, 0.666667),
                       (0.380952, 1.000000, 1.000000),(0.412698, 1.000000, 1.000000),
                       (0.428571, 0.000000, 0.000000),(0.444444, 0.000000, 0.000000),
                       (0.460317, 0.666667, 0.666667),(0.476190, 1.000000, 1.000000),
                       (0.507937, 1.000000, 1.000000),(0.523810, 0.000000, 0.000000),
                       (0.539683, 0.000000, 0.000000),(0.555556, 0.666667, 0.666667),
                       (0.571429, 1.000000, 1.000000),(0.603175, 1.000000, 1.000000),
                       (0.619048, 0.000000, 0.000000),(0.634921, 0.000000, 0.000000),
                       (0.650794, 0.666667, 0.666667),(0.666667, 1.000000, 1.000000),
                       (0.698413, 1.000000, 1.000000),(0.714286, 0.000000, 0.000000),
                       (0.730159, 0.000000, 0.000000),(0.746032, 0.666667, 0.666667),
                       (0.761905, 1.000000, 1.000000),(0.793651, 1.000000, 1.000000),
                       (0.809524, 0.000000, 0.000000),(0.825397, 0.000000, 0.000000),
                       (0.841270, 0.666667, 0.666667),(0.857143, 1.000000, 1.000000),
                       (0.888889, 1.000000, 1.000000),(0.904762, 0.000000, 0.000000),
                       (0.920635, 0.000000, 0.000000),(0.936508, 0.666667, 0.666667),
                       (0.952381, 1.000000, 1.000000),(0.984127, 1.000000, 1.000000),
                       (1.0, 0.0, 0.0)),
             'green': ((0., 0., 0.),(0.031746, 1.000000, 1.000000),
                       (0.047619, 1.000000, 1.000000),(0.063492, 0.000000, 0.000000),
                       (0.095238, 0.000000, 0.000000),(0.126984, 1.000000, 1.000000),
                       (0.142857, 1.000000, 1.000000),(0.158730, 0.000000, 0.000000),
                       (0.190476, 0.000000, 0.000000),(0.222222, 1.000000, 1.000000),
                       (0.238095, 1.000000, 1.000000),(0.253968, 0.000000, 0.000000),
                       (0.285714, 0.000000, 0.000000),(0.317460, 1.000000, 1.000000),
                       (0.333333, 1.000000, 1.000000),(0.349206, 0.000000, 0.000000),
                       (0.380952, 0.000000, 0.000000),(0.412698, 1.000000, 1.000000),
                       (0.428571, 1.000000, 1.000000),(0.444444, 0.000000, 0.000000),
                       (0.476190, 0.000000, 0.000000),(0.507937, 1.000000, 1.000000),
                       (0.523810, 1.000000, 1.000000),(0.539683, 0.000000, 0.000000),
                       (0.571429, 0.000000, 0.000000),(0.603175, 1.000000, 1.000000),
                       (0.619048, 1.000000, 1.000000),(0.634921, 0.000000, 0.000000),
                       (0.666667, 0.000000, 0.000000),(0.698413, 1.000000, 1.000000),
                       (0.714286, 1.000000, 1.000000),(0.730159, 0.000000, 0.000000),
                       (0.761905, 0.000000, 0.000000),(0.793651, 1.000000, 1.000000),
                       (0.809524, 1.000000, 1.000000),(0.825397, 0.000000, 0.000000),
                       (0.857143, 0.000000, 0.000000),(0.888889, 1.000000, 1.000000),
                       (0.904762, 1.000000, 1.000000),(0.920635, 0.000000, 0.000000),
                       (0.952381, 0.000000, 0.000000),(0.984127, 1.000000, 1.000000),
                       (1.0, 1.0, 1.0)),
             'blue':  ((0., 0., 0.),(0.047619, 0.000000, 0.000000),
                       (0.063492, 1.000000, 1.000000),(0.079365, 1.000000, 1.000000),
                       (0.095238, 0.000000, 0.000000),(0.142857, 0.000000, 0.000000),
                       (0.158730, 1.000000, 1.000000),(0.174603, 1.000000, 1.000000),
                       (0.190476, 0.000000, 0.000000),(0.238095, 0.000000, 0.000000),
                       (0.253968, 1.000000, 1.000000),(0.269841, 1.000000, 1.000000),
                       (0.285714, 0.000000, 0.000000),(0.333333, 0.000000, 0.000000),
                       (0.349206, 1.000000, 1.000000),(0.365079, 1.000000, 1.000000),
                       (0.380952, 0.000000, 0.000000),(0.428571, 0.000000, 0.000000),
                       (0.444444, 1.000000, 1.000000),(0.460317, 1.000000, 1.000000),
                       (0.476190, 0.000000, 0.000000),(0.523810, 0.000000, 0.000000),
                       (0.539683, 1.000000, 1.000000),(0.555556, 1.000000, 1.000000),
                       (0.571429, 0.000000, 0.000000),(0.619048, 0.000000, 0.000000),
                       (0.634921, 1.000000, 1.000000),(0.650794, 1.000000, 1.000000),
                       (0.666667, 0.000000, 0.000000),(0.714286, 0.000000, 0.000000),
                       (0.730159, 1.000000, 1.000000),(0.746032, 1.000000, 1.000000),
                       (0.761905, 0.000000, 0.000000),(0.809524, 0.000000, 0.000000),
                       (0.825397, 1.000000, 1.000000),(0.841270, 1.000000, 1.000000),
                       (0.857143, 0.000000, 0.000000),(0.904762, 0.000000, 0.000000),
                       (0.920635, 1.000000, 1.000000),(0.936508, 1.000000, 1.000000),
                       (0.952381, 0.000000, 0.000000),(1.0, 0.0, 0.0))}

    return ColorMapper.from_segment_map(_data, range=range, **traits)

def spring(range, **traits):
    """ Generator function for the 'spring' colormap. """

    _data = {'red':   ((0., 1., 1.),(1.0, 1.0, 1.0)),
             'green': ((0., 0., 0.),(1.0, 1.0, 1.0)),
             'blue':  ((0., 1., 1.),(1.0, 0.0, 0.0))}

    return ColorMapper.from_segment_map(_data, range=range, **traits)

def summer(range, **traits):
    """ Generator function for the 'summer' colormap. """

    _data = {'red':   ((0., 0., 0.),(1.0, 1.0, 1.0)),
             'green': ((0., 0.5, 0.5),(1.0, 1.0, 1.0)),
             'blue':  ((0., 0.4, 0.4),(1.0, 0.4, 0.4))}

    return ColorMapper.from_segment_map(_data, range=range, **traits)

def winter(range, **traits):
    """ Generator function for the 'winter' colormap. """

    _data = {'red':   ((0., 0., 0.),(1.0, 0.0, 0.0)),
             'green': ((0., 0., 0.),(1.0, 1.0, 1.0)),
             'blue':  ((0., 1., 1.),(1.0, 0.5, 0.5))}

    return ColorMapper.from_segment_map(_data, range=range, **traits)

def cw1_004(range, **traits):
    """ Generator function for the Crumblingwalls cw1-004 gradient """

    colors = array([(0.7176,0.6980,0.6118),
                  (0.8000,0.5373,0.7059),
                  (0.2510,0.4588,0.4902),
                  (0.0588,0.3176,0.5137)])

    return ColorMapper.from_palette_array(colors, range=range, **traits)

def cw1_005(range, **traits):
    """ Generator function for the Crumblingwalls cw1-005 gradient """
    colors = array([(0.7059,0.1686,0.0980),
                    (0.7961,0.5176,0.2039),
                    (0.2863,0.3255,0.1294)])

    return ColorMapper.from_palette_array(colors, range=range, **traits)

def cw1_006(range, **traits):
    """ Generator function for the Crumblingwalls cw1-006 gradient """

    colors = array([(0.4275,0.2824,0.4667),
                    (0.2039,0.1843,0.4667),
                    (0.0863,0.4078,0.2078)])

    return ColorMapper.from_palette_array(colors, range=range, **traits)

def cw1_028(range, **traits):
    """ Generator function for the Crumblingwalls cw1-058 gradient """

    colors = array([(0.2275, 0.2275, 0.4784),
                    (0.3294, 0.5137, 0.8588),
                    (0.4078, 0.8471, 0.8510)])

    return ColorMapper.from_palette_array(colors, range=range, **traits)

def gmt_drywet(range, **traits):

    _data = {'red': ((0.00000,0.5255,0.5255),
                    (0.16670,0.9333,0.9333),
                    (0.33330,0.7059,0.7059),
                    (0.50000,0.1961,0.1961),
                    (0.66670,0.0471,0.0471),
                    (0.83330,0.1490,0.1490),
                    (1.00000,0.0314,0.0314)),

             'green': ((0.00000,0.3804,0.3804),
                    (0.16670,0.7804,0.7804),
                    (0.33330,0.9333,0.9333),
                    (0.50000,0.9333,0.9333),
                    (0.66670,0.4706,0.4706),
                    (0.83330,0.0039,0.0039),
                    (1.00000,0.2000,0.2000)),

             'blue': ((0.00000,0.1647,0.1647),
                    (0.16670,0.3922,0.3922),
                    (0.33330,0.5294,0.5294),
                    (0.50000,0.9216,0.9216),
                    (0.66670,0.9333,0.9333),
                    (0.83330,0.7176,0.7176),
                    (1.00000,0.4431,0.4431)) }

    return ColorMapper.from_segment_map(_data, range=range, **traits)


# The following colormaps come from ColorBrewer.
# Only the 'Sequential' and 'Diverging' colormaps and not the 'Qualitative'
# colormaps since Chaco currently does not implement qualtitative colormaps.

def Blues(range, **traits):
    """ Generator for the 'Blues' colormap from ColorBrewer.

    Although the ColorBrewer colormaps are defined as discrete colormaps, we
    create continuous colormaps from them by linear interpolation in RGB
    colorspace.
    """
    _data = dict(
        red = [(0.0, 0.96862745098, 0.96862745098),
            (0.125, 0.870588235294, 0.870588235294),
            (0.25, 0.776470588235, 0.776470588235),
            (0.375, 0.619607843137, 0.619607843137),
            (0.5, 0.419607843137, 0.419607843137),
            (0.625, 0.258823529412, 0.258823529412),
            (0.75, 0.129411764706, 0.129411764706),
            (0.875, 0.0313725490196, 0.0313725490196),
            (1.0, 0.0313725490196, 0.0313725490196)],
        green = [(0.0, 0.98431372549, 0.98431372549),
            (0.125, 0.921568627451, 0.921568627451),
            (0.25, 0.858823529412, 0.858823529412),
            (0.375, 0.792156862745, 0.792156862745),
            (0.5, 0.682352941176, 0.682352941176),
            (0.625, 0.572549019608, 0.572549019608),
            (0.75, 0.443137254902, 0.443137254902),
            (0.875, 0.317647058824, 0.317647058824),
            (1.0, 0.188235294118, 0.188235294118)],
        blue = [(0.0, 1.0, 1.0),
            (0.125, 0.96862745098, 0.96862745098),
            (0.25, 0.937254901961, 0.937254901961),
            (0.375, 0.882352941176, 0.882352941176),
            (0.5, 0.839215686275, 0.839215686275),
            (0.625, 0.776470588235, 0.776470588235),
            (0.75, 0.709803921569, 0.709803921569),
            (0.875, 0.611764705882, 0.611764705882),
            (1.0, 0.419607843137, 0.419607843137)],
    )
    return ColorMapper.from_segment_map(_data, range=range, **traits)

def BrBG(range, **traits):
    """ Generator for the 'BrBG' colormap from ColorBrewer.

    This is a diverging colormap. It is good for data which is centered around
    a "special" value, like 0.

    Although the ColorBrewer colormaps are defined as discrete colormaps, we
    create continuous colormaps from them by linear interpolation in RGB
    colorspace.
    """
    _data = dict(
        red = [(0.0, 0.329411764706, 0.329411764706),
            (0.1, 0.549019607843, 0.549019607843),
            (0.2, 0.749019607843, 0.749019607843),
            (0.3, 0.874509803922, 0.874509803922),
            (0.4, 0.964705882353, 0.964705882353),
            (0.5, 0.960784313725, 0.960784313725),
            (0.6, 0.780392156863, 0.780392156863),
            (0.7, 0.501960784314, 0.501960784314),
            (0.8, 0.207843137255, 0.207843137255),
            (0.9, 0.00392156862745, 0.00392156862745),
            (1.0, 0.0, 0.0)],
        green = [(0.0, 0.188235294118, 0.188235294118),
            (0.1, 0.317647058824, 0.317647058824),
            (0.2, 0.505882352941, 0.505882352941),
            (0.3, 0.760784313725, 0.760784313725),
            (0.4, 0.909803921569, 0.909803921569),
            (0.5, 0.960784313725, 0.960784313725),
            (0.6, 0.917647058824, 0.917647058824),
            (0.7, 0.803921568627, 0.803921568627),
            (0.8, 0.592156862745, 0.592156862745),
            (0.9, 0.4, 0.4),
            (1.0, 0.235294117647, 0.235294117647)],
        blue = [(0.0, 0.0196078431373, 0.0196078431373),
            (0.1, 0.0392156862745, 0.0392156862745),
            (0.2, 0.176470588235, 0.176470588235),
            (0.3, 0.490196078431, 0.490196078431),
            (0.4, 0.764705882353, 0.764705882353),
            (0.5, 0.960784313725, 0.960784313725),
            (0.6, 0.898039215686, 0.898039215686),
            (0.7, 0.756862745098, 0.756862745098),
            (0.8, 0.560784313725, 0.560784313725),
            (0.9, 0.36862745098, 0.36862745098),
            (1.0, 0.188235294118, 0.188235294118)],
    )
    return ColorMapper.from_segment_map(_data, range=range, **traits)

def BuGn(range, **traits):
    """ Generator for the 'BuGn' colormap from ColorBrewer.

    Although the ColorBrewer colormaps are defined as discrete colormaps, we
    create continuous colormaps from them by linear interpolation in RGB
    colorspace.
    """
    _data = dict(
        red = [(0.0, 0.96862745098, 0.96862745098),
            (0.125, 0.898039215686, 0.898039215686),
            (0.25, 0.8, 0.8),
            (0.375, 0.6, 0.6),
            (0.5, 0.4, 0.4),
            (0.625, 0.254901960784, 0.254901960784),
            (0.75, 0.137254901961, 0.137254901961),
            (0.875, 0.0, 0.0),
            (1.0, 0.0, 0.0)],
        green = [(0.0, 0.988235294118, 0.988235294118),
            (0.125, 0.960784313725, 0.960784313725),
            (0.25, 0.925490196078, 0.925490196078),
            (0.375, 0.847058823529, 0.847058823529),
            (0.5, 0.760784313725, 0.760784313725),
            (0.625, 0.682352941176, 0.682352941176),
            (0.75, 0.545098039216, 0.545098039216),
            (0.875, 0.427450980392, 0.427450980392),
            (1.0, 0.266666666667, 0.266666666667)],
        blue = [(0.0, 0.992156862745, 0.992156862745),
            (0.125, 0.976470588235, 0.976470588235),
            (0.25, 0.901960784314, 0.901960784314),
            (0.375, 0.788235294118, 0.788235294118),
            (0.5, 0.643137254902, 0.643137254902),
            (0.625, 0.462745098039, 0.462745098039),
            (0.75, 0.270588235294, 0.270588235294),
            (0.875, 0.172549019608, 0.172549019608),
            (1.0, 0.105882352941, 0.105882352941)],
    )
    return ColorMapper.from_segment_map(_data, range=range, **traits)

def BuPu(range, **traits):
    """ Generator for the 'BuPu' colormap from ColorBrewer.

    Although the ColorBrewer colormaps are defined as discrete colormaps, we
    create continuous colormaps from them by linear interpolation in RGB
    colorspace.
    """
    _data = dict(
        red = [(0.0, 0.96862745098, 0.96862745098),
            (0.125, 0.878431372549, 0.878431372549),
            (0.25, 0.749019607843, 0.749019607843),
            (0.375, 0.619607843137, 0.619607843137),
            (0.5, 0.549019607843, 0.549019607843),
            (0.625, 0.549019607843, 0.549019607843),
            (0.75, 0.533333333333, 0.533333333333),
            (0.875, 0.505882352941, 0.505882352941),
            (1.0, 0.301960784314, 0.301960784314)],
        green = [(0.0, 0.988235294118, 0.988235294118),
            (0.125, 0.925490196078, 0.925490196078),
            (0.25, 0.827450980392, 0.827450980392),
            (0.375, 0.737254901961, 0.737254901961),
            (0.5, 0.588235294118, 0.588235294118),
            (0.625, 0.419607843137, 0.419607843137),
            (0.75, 0.254901960784, 0.254901960784),
            (0.875, 0.0588235294118, 0.0588235294118),
            (1.0, 0.0, 0.0)],
        blue = [(0.0, 0.992156862745, 0.992156862745),
            (0.125, 0.956862745098, 0.956862745098),
            (0.25, 0.901960784314, 0.901960784314),
            (0.375, 0.854901960784, 0.854901960784),
            (0.5, 0.776470588235, 0.776470588235),
            (0.625, 0.694117647059, 0.694117647059),
            (0.75, 0.61568627451, 0.61568627451),
            (0.875, 0.486274509804, 0.486274509804),
            (1.0, 0.294117647059, 0.294117647059)],
    )
    return ColorMapper.from_segment_map(_data, range=range, **traits)

def GnBu(range, **traits):
    """ Generator for the 'GnBu' colormap from ColorBrewer.

    Although the ColorBrewer colormaps are defined as discrete colormaps, we
    create continuous colormaps from them by linear interpolation in RGB
    colorspace.
    """
    _data = dict(
        red = [(0.0, 0.96862745098, 0.96862745098),
            (0.125, 0.878431372549, 0.878431372549),
            (0.25, 0.8, 0.8),
            (0.375, 0.658823529412, 0.658823529412),
            (0.5, 0.482352941176, 0.482352941176),
            (0.625, 0.305882352941, 0.305882352941),
            (0.75, 0.16862745098, 0.16862745098),
            (0.875, 0.0313725490196, 0.0313725490196),
            (1.0, 0.0313725490196, 0.0313725490196)],
        green = [(0.0, 0.988235294118, 0.988235294118),
            (0.125, 0.952941176471, 0.952941176471),
            (0.25, 0.921568627451, 0.921568627451),
            (0.375, 0.866666666667, 0.866666666667),
            (0.5, 0.8, 0.8),
            (0.625, 0.701960784314, 0.701960784314),
            (0.75, 0.549019607843, 0.549019607843),
            (0.875, 0.407843137255, 0.407843137255),
            (1.0, 0.250980392157, 0.250980392157)],
        blue = [(0.0, 0.941176470588, 0.941176470588),
            (0.125, 0.858823529412, 0.858823529412),
            (0.25, 0.772549019608, 0.772549019608),
            (0.375, 0.709803921569, 0.709803921569),
            (0.5, 0.76862745098, 0.76862745098),
            (0.625, 0.827450980392, 0.827450980392),
            (0.75, 0.745098039216, 0.745098039216),
            (0.875, 0.674509803922, 0.674509803922),
            (1.0, 0.505882352941, 0.505882352941)],
    )
    return ColorMapper.from_segment_map(_data, range=range, **traits)

def Greens(range, **traits):
    """ Generator for the 'Greens' colormap from ColorBrewer.

    Although the ColorBrewer colormaps are defined as discrete colormaps, we
    create continuous colormaps from them by linear interpolation in RGB
    colorspace.
    """
    _data = dict(
        red = [(0.0, 0.96862745098, 0.96862745098),
            (0.125, 0.898039215686, 0.898039215686),
            (0.25, 0.780392156863, 0.780392156863),
            (0.375, 0.63137254902, 0.63137254902),
            (0.5, 0.454901960784, 0.454901960784),
            (0.625, 0.254901960784, 0.254901960784),
            (0.75, 0.137254901961, 0.137254901961),
            (0.875, 0.0, 0.0),
            (1.0, 0.0, 0.0)],
        green = [(0.0, 0.988235294118, 0.988235294118),
            (0.125, 0.960784313725, 0.960784313725),
            (0.25, 0.913725490196, 0.913725490196),
            (0.375, 0.850980392157, 0.850980392157),
            (0.5, 0.76862745098, 0.76862745098),
            (0.625, 0.670588235294, 0.670588235294),
            (0.75, 0.545098039216, 0.545098039216),
            (0.875, 0.427450980392, 0.427450980392),
            (1.0, 0.266666666667, 0.266666666667)],
        blue = [(0.0, 0.960784313725, 0.960784313725),
            (0.125, 0.878431372549, 0.878431372549),
            (0.25, 0.752941176471, 0.752941176471),
            (0.375, 0.607843137255, 0.607843137255),
            (0.5, 0.462745098039, 0.462745098039),
            (0.625, 0.364705882353, 0.364705882353),
            (0.75, 0.270588235294, 0.270588235294),
            (0.875, 0.172549019608, 0.172549019608),
            (1.0, 0.105882352941, 0.105882352941)],
    )
    return ColorMapper.from_segment_map(_data, range=range, **traits)

def Greys(range, **traits):
    """ Generator for the 'Greys' colormap from ColorBrewer.

    Although the ColorBrewer colormaps are defined as discrete colormaps, we
    create continuous colormaps from them by linear interpolation in RGB
    colorspace.
    """
    _data = dict(
        red = [(0.0, 1.0, 1.0),
            (0.125, 0.941176470588, 0.941176470588),
            (0.25, 0.850980392157, 0.850980392157),
            (0.375, 0.741176470588, 0.741176470588),
            (0.5, 0.588235294118, 0.588235294118),
            (0.625, 0.450980392157, 0.450980392157),
            (0.75, 0.321568627451, 0.321568627451),
            (0.875, 0.145098039216, 0.145098039216),
            (1.0, 0.0, 0.0)],
        green = [(0.0, 1.0, 1.0),
            (0.125, 0.941176470588, 0.941176470588),
            (0.25, 0.850980392157, 0.850980392157),
            (0.375, 0.741176470588, 0.741176470588),
            (0.5, 0.588235294118, 0.588235294118),
            (0.625, 0.450980392157, 0.450980392157),
            (0.75, 0.321568627451, 0.321568627451),
            (0.875, 0.145098039216, 0.145098039216),
            (1.0, 0.0, 0.0)],
        blue = [(0.0, 1.0, 1.0),
            (0.125, 0.941176470588, 0.941176470588),
            (0.25, 0.850980392157, 0.850980392157),
            (0.375, 0.741176470588, 0.741176470588),
            (0.5, 0.588235294118, 0.588235294118),
            (0.625, 0.450980392157, 0.450980392157),
            (0.75, 0.321568627451, 0.321568627451),
            (0.875, 0.145098039216, 0.145098039216),
            (1.0, 0.0, 0.0)],
    )
    return ColorMapper.from_segment_map(_data, range=range, **traits)

def OrRd(range, **traits):
    """ Generator for the 'OrRd' colormap from ColorBrewer.

    Although the ColorBrewer colormaps are defined as discrete colormaps, we
    create continuous colormaps from them by linear interpolation in RGB
    colorspace.
    """
    _data = dict(
        red = [(0.0, 1.0, 1.0),
            (0.125, 0.996078431373, 0.996078431373),
            (0.25, 0.992156862745, 0.992156862745),
            (0.375, 0.992156862745, 0.992156862745),
            (0.5, 0.988235294118, 0.988235294118),
            (0.625, 0.937254901961, 0.937254901961),
            (0.75, 0.843137254902, 0.843137254902),
            (0.875, 0.701960784314, 0.701960784314),
            (1.0, 0.498039215686, 0.498039215686)],
        green = [(0.0, 0.96862745098, 0.96862745098),
            (0.125, 0.909803921569, 0.909803921569),
            (0.25, 0.83137254902, 0.83137254902),
            (0.375, 0.733333333333, 0.733333333333),
            (0.5, 0.552941176471, 0.552941176471),
            (0.625, 0.396078431373, 0.396078431373),
            (0.75, 0.188235294118, 0.188235294118),
            (0.875, 0.0, 0.0),
            (1.0, 0.0, 0.0)],
        blue = [(0.0, 0.925490196078, 0.925490196078),
            (0.125, 0.78431372549, 0.78431372549),
            (0.25, 0.619607843137, 0.619607843137),
            (0.375, 0.517647058824, 0.517647058824),
            (0.5, 0.349019607843, 0.349019607843),
            (0.625, 0.282352941176, 0.282352941176),
            (0.75, 0.121568627451, 0.121568627451),
            (0.875, 0.0, 0.0),
            (1.0, 0.0, 0.0)],
    )
    return ColorMapper.from_segment_map(_data, range=range, **traits)

def Oranges(range, **traits):
    """ Generator for the 'Oranges' colormap from ColorBrewer.

    Although the ColorBrewer colormaps are defined as discrete colormaps, we
    create continuous colormaps from them by linear interpolation in RGB
    colorspace.
    """
    _data = dict(
        red = [(0.0, 1.0, 1.0),
            (0.125, 0.996078431373, 0.996078431373),
            (0.25, 0.992156862745, 0.992156862745),
            (0.375, 0.992156862745, 0.992156862745),
            (0.5, 0.992156862745, 0.992156862745),
            (0.625, 0.945098039216, 0.945098039216),
            (0.75, 0.850980392157, 0.850980392157),
            (0.875, 0.650980392157, 0.650980392157),
            (1.0, 0.498039215686, 0.498039215686)],
        green = [(0.0, 0.960784313725, 0.960784313725),
            (0.125, 0.901960784314, 0.901960784314),
            (0.25, 0.81568627451, 0.81568627451),
            (0.375, 0.682352941176, 0.682352941176),
            (0.5, 0.552941176471, 0.552941176471),
            (0.625, 0.411764705882, 0.411764705882),
            (0.75, 0.282352941176, 0.282352941176),
            (0.875, 0.211764705882, 0.211764705882),
            (1.0, 0.152941176471, 0.152941176471)],
        blue = [(0.0, 0.921568627451, 0.921568627451),
            (0.125, 0.807843137255, 0.807843137255),
            (0.25, 0.635294117647, 0.635294117647),
            (0.375, 0.419607843137, 0.419607843137),
            (0.5, 0.235294117647, 0.235294117647),
            (0.625, 0.0745098039216, 0.0745098039216),
            (0.75, 0.00392156862745, 0.00392156862745),
            (0.875, 0.0117647058824, 0.0117647058824),
            (1.0, 0.0156862745098, 0.0156862745098)],
    )
    return ColorMapper.from_segment_map(_data, range=range, **traits)

def PRGn(range, **traits):
    """ Generator for the 'PRGn' colormap from ColorBrewer.

    This is a diverging colormap. It is good for data which is centered around
    a "special" value, like 0.

    Although the ColorBrewer colormaps are defined as discrete colormaps, we
    create continuous colormaps from them by linear interpolation in RGB
    colorspace.
    """
    _data = dict(
        red = [(0.0, 0.250980392157, 0.250980392157),
            (0.1, 0.462745098039, 0.462745098039),
            (0.2, 0.6, 0.6),
            (0.3, 0.760784313725, 0.760784313725),
            (0.4, 0.905882352941, 0.905882352941),
            (0.5, 0.96862745098, 0.96862745098),
            (0.6, 0.850980392157, 0.850980392157),
            (0.7, 0.650980392157, 0.650980392157),
            (0.8, 0.352941176471, 0.352941176471),
            (0.9, 0.105882352941, 0.105882352941),
            (1.0, 0.0, 0.0)],
        green = [(0.0, 0.0, 0.0),
            (0.1, 0.164705882353, 0.164705882353),
            (0.2, 0.439215686275, 0.439215686275),
            (0.3, 0.647058823529, 0.647058823529),
            (0.4, 0.83137254902, 0.83137254902),
            (0.5, 0.96862745098, 0.96862745098),
            (0.6, 0.941176470588, 0.941176470588),
            (0.7, 0.858823529412, 0.858823529412),
            (0.8, 0.682352941176, 0.682352941176),
            (0.9, 0.470588235294, 0.470588235294),
            (1.0, 0.266666666667, 0.266666666667)],
        blue = [(0.0, 0.294117647059, 0.294117647059),
            (0.1, 0.513725490196, 0.513725490196),
            (0.2, 0.670588235294, 0.670588235294),
            (0.3, 0.811764705882, 0.811764705882),
            (0.4, 0.909803921569, 0.909803921569),
            (0.5, 0.96862745098, 0.96862745098),
            (0.6, 0.827450980392, 0.827450980392),
            (0.7, 0.627450980392, 0.627450980392),
            (0.8, 0.380392156863, 0.380392156863),
            (0.9, 0.21568627451, 0.21568627451),
            (1.0, 0.105882352941, 0.105882352941)],
    )
    return ColorMapper.from_segment_map(_data, range=range, **traits)

def PiYG(range, **traits):
    """ Generator for the 'PiYG' colormap from ColorBrewer.

    This is a diverging colormap. It is good for data which is centered around
    a "special" value, like 0.

    Although the ColorBrewer colormaps are defined as discrete colormaps, we
    create continuous colormaps from them by linear interpolation in RGB
    colorspace.
    """
    _data = dict(
        red = [(0.0, 0.556862745098, 0.556862745098),
            (0.1, 0.772549019608, 0.772549019608),
            (0.2, 0.870588235294, 0.870588235294),
            (0.3, 0.945098039216, 0.945098039216),
            (0.4, 0.992156862745, 0.992156862745),
            (0.5, 0.96862745098, 0.96862745098),
            (0.6, 0.901960784314, 0.901960784314),
            (0.7, 0.721568627451, 0.721568627451),
            (0.8, 0.498039215686, 0.498039215686),
            (0.9, 0.301960784314, 0.301960784314),
            (1.0, 0.152941176471, 0.152941176471)],
        green = [(0.0, 0.00392156862745, 0.00392156862745),
            (0.1, 0.105882352941, 0.105882352941),
            (0.2, 0.466666666667, 0.466666666667),
            (0.3, 0.713725490196, 0.713725490196),
            (0.4, 0.878431372549, 0.878431372549),
            (0.5, 0.96862745098, 0.96862745098),
            (0.6, 0.960784313725, 0.960784313725),
            (0.7, 0.882352941176, 0.882352941176),
            (0.8, 0.737254901961, 0.737254901961),
            (0.9, 0.572549019608, 0.572549019608),
            (1.0, 0.392156862745, 0.392156862745)],
        blue = [(0.0, 0.321568627451, 0.321568627451),
            (0.1, 0.490196078431, 0.490196078431),
            (0.2, 0.682352941176, 0.682352941176),
            (0.3, 0.854901960784, 0.854901960784),
            (0.4, 0.937254901961, 0.937254901961),
            (0.5, 0.96862745098, 0.96862745098),
            (0.6, 0.81568627451, 0.81568627451),
            (0.7, 0.525490196078, 0.525490196078),
            (0.8, 0.254901960784, 0.254901960784),
            (0.9, 0.129411764706, 0.129411764706),
            (1.0, 0.0980392156863, 0.0980392156863)],
    )
    return ColorMapper.from_segment_map(_data, range=range, **traits)

def PuBu(range, **traits):
    """ Generator for the 'PuBu' colormap from ColorBrewer.

    Although the ColorBrewer colormaps are defined as discrete colormaps, we
    create continuous colormaps from them by linear interpolation in RGB
    colorspace.
    """
    _data = dict(
        red = [(0.0, 1.0, 1.0),
            (0.125, 0.925490196078, 0.925490196078),
            (0.25, 0.81568627451, 0.81568627451),
            (0.375, 0.650980392157, 0.650980392157),
            (0.5, 0.454901960784, 0.454901960784),
            (0.625, 0.211764705882, 0.211764705882),
            (0.75, 0.0196078431373, 0.0196078431373),
            (0.875, 0.0156862745098, 0.0156862745098),
            (1.0, 0.0078431372549, 0.0078431372549)],
        green = [(0.0, 0.96862745098, 0.96862745098),
            (0.125, 0.905882352941, 0.905882352941),
            (0.25, 0.819607843137, 0.819607843137),
            (0.375, 0.741176470588, 0.741176470588),
            (0.5, 0.662745098039, 0.662745098039),
            (0.625, 0.564705882353, 0.564705882353),
            (0.75, 0.439215686275, 0.439215686275),
            (0.875, 0.352941176471, 0.352941176471),
            (1.0, 0.219607843137, 0.219607843137)],
        blue = [(0.0, 0.98431372549, 0.98431372549),
            (0.125, 0.949019607843, 0.949019607843),
            (0.25, 0.901960784314, 0.901960784314),
            (0.375, 0.858823529412, 0.858823529412),
            (0.5, 0.811764705882, 0.811764705882),
            (0.625, 0.752941176471, 0.752941176471),
            (0.75, 0.690196078431, 0.690196078431),
            (0.875, 0.552941176471, 0.552941176471),
            (1.0, 0.345098039216, 0.345098039216)],
    )
    return ColorMapper.from_segment_map(_data, range=range, **traits)

def PuBuGn(range, **traits):
    """ Generator for the 'PuBuGn' colormap from ColorBrewer.

    Although the ColorBrewer colormaps are defined as discrete colormaps, we
    create continuous colormaps from them by linear interpolation in RGB
    colorspace.
    """
    _data = dict(
        red = [(0.0, 1.0, 1.0),
            (0.125, 0.925490196078, 0.925490196078),
            (0.25, 0.81568627451, 0.81568627451),
            (0.375, 0.650980392157, 0.650980392157),
            (0.5, 0.403921568627, 0.403921568627),
            (0.625, 0.211764705882, 0.211764705882),
            (0.75, 0.0078431372549, 0.0078431372549),
            (0.875, 0.00392156862745, 0.00392156862745),
            (1.0, 0.00392156862745, 0.00392156862745)],
        green = [(0.0, 0.96862745098, 0.96862745098),
            (0.125, 0.886274509804, 0.886274509804),
            (0.25, 0.819607843137, 0.819607843137),
            (0.375, 0.741176470588, 0.741176470588),
            (0.5, 0.662745098039, 0.662745098039),
            (0.625, 0.564705882353, 0.564705882353),
            (0.75, 0.505882352941, 0.505882352941),
            (0.875, 0.423529411765, 0.423529411765),
            (1.0, 0.274509803922, 0.274509803922)],
        blue = [(0.0, 0.98431372549, 0.98431372549),
            (0.125, 0.941176470588, 0.941176470588),
            (0.25, 0.901960784314, 0.901960784314),
            (0.375, 0.858823529412, 0.858823529412),
            (0.5, 0.811764705882, 0.811764705882),
            (0.625, 0.752941176471, 0.752941176471),
            (0.75, 0.541176470588, 0.541176470588),
            (0.875, 0.349019607843, 0.349019607843),
            (1.0, 0.211764705882, 0.211764705882)],
    )
    return ColorMapper.from_segment_map(_data, range=range, **traits)

def PuOr(range, **traits):
    """ Generator for the 'PuOr' colormap from ColorBrewer.

    This is a diverging colormap. It is good for data which is centered around
    a "special" value, like 0.

    Although the ColorBrewer colormaps are defined as discrete colormaps, we
    create continuous colormaps from them by linear interpolation in RGB
    colorspace.
    """
    _data = dict(
        red = [(0.0, 0.498039215686, 0.498039215686),
            (0.1, 0.701960784314, 0.701960784314),
            (0.2, 0.878431372549, 0.878431372549),
            (0.3, 0.992156862745, 0.992156862745),
            (0.4, 0.996078431373, 0.996078431373),
            (0.5, 0.96862745098, 0.96862745098),
            (0.6, 0.847058823529, 0.847058823529),
            (0.7, 0.698039215686, 0.698039215686),
            (0.8, 0.501960784314, 0.501960784314),
            (0.9, 0.329411764706, 0.329411764706),
            (1.0, 0.176470588235, 0.176470588235)],
        green = [(0.0, 0.23137254902, 0.23137254902),
            (0.1, 0.345098039216, 0.345098039216),
            (0.2, 0.509803921569, 0.509803921569),
            (0.3, 0.721568627451, 0.721568627451),
            (0.4, 0.878431372549, 0.878431372549),
            (0.5, 0.96862745098, 0.96862745098),
            (0.6, 0.854901960784, 0.854901960784),
            (0.7, 0.670588235294, 0.670588235294),
            (0.8, 0.450980392157, 0.450980392157),
            (0.9, 0.152941176471, 0.152941176471),
            (1.0, 0.0, 0.0)],
        blue = [(0.0, 0.0313725490196, 0.0313725490196),
            (0.1, 0.0235294117647, 0.0235294117647),
            (0.2, 0.078431372549, 0.078431372549),
            (0.3, 0.388235294118, 0.388235294118),
            (0.4, 0.713725490196, 0.713725490196),
            (0.5, 0.96862745098, 0.96862745098),
            (0.6, 0.921568627451, 0.921568627451),
            (0.7, 0.823529411765, 0.823529411765),
            (0.8, 0.674509803922, 0.674509803922),
            (0.9, 0.533333333333, 0.533333333333),
            (1.0, 0.294117647059, 0.294117647059)],
    )
    return ColorMapper.from_segment_map(_data, range=range, **traits)

def PuRd(range, **traits):
    """ Generator for the 'PuRd' colormap from ColorBrewer.

    Although the ColorBrewer colormaps are defined as discrete colormaps, we
    create continuous colormaps from them by linear interpolation in RGB
    colorspace.
    """
    _data = dict(
        red = [(0.0, 0.96862745098, 0.96862745098),
            (0.125, 0.905882352941, 0.905882352941),
            (0.25, 0.83137254902, 0.83137254902),
            (0.375, 0.788235294118, 0.788235294118),
            (0.5, 0.874509803922, 0.874509803922),
            (0.625, 0.905882352941, 0.905882352941),
            (0.75, 0.807843137255, 0.807843137255),
            (0.875, 0.596078431373, 0.596078431373),
            (1.0, 0.403921568627, 0.403921568627)],
        green = [(0.0, 0.956862745098, 0.956862745098),
            (0.125, 0.882352941176, 0.882352941176),
            (0.25, 0.725490196078, 0.725490196078),
            (0.375, 0.580392156863, 0.580392156863),
            (0.5, 0.396078431373, 0.396078431373),
            (0.625, 0.160784313725, 0.160784313725),
            (0.75, 0.0705882352941, 0.0705882352941),
            (0.875, 0.0, 0.0),
            (1.0, 0.0, 0.0)],
        blue = [(0.0, 0.976470588235, 0.976470588235),
            (0.125, 0.937254901961, 0.937254901961),
            (0.25, 0.854901960784, 0.854901960784),
            (0.375, 0.780392156863, 0.780392156863),
            (0.5, 0.690196078431, 0.690196078431),
            (0.625, 0.541176470588, 0.541176470588),
            (0.75, 0.337254901961, 0.337254901961),
            (0.875, 0.262745098039, 0.262745098039),
            (1.0, 0.121568627451, 0.121568627451)],
    )
    return ColorMapper.from_segment_map(_data, range=range, **traits)

def Purples(range, **traits):
    """ Generator for the 'Purples' colormap from ColorBrewer.

    Although the ColorBrewer colormaps are defined as discrete colormaps, we
    create continuous colormaps from them by linear interpolation in RGB
    colorspace.
    """
    _data = dict(
        red = [(0.0, 0.988235294118, 0.988235294118),
            (0.125, 0.937254901961, 0.937254901961),
            (0.25, 0.854901960784, 0.854901960784),
            (0.375, 0.737254901961, 0.737254901961),
            (0.5, 0.619607843137, 0.619607843137),
            (0.625, 0.501960784314, 0.501960784314),
            (0.75, 0.41568627451, 0.41568627451),
            (0.875, 0.329411764706, 0.329411764706),
            (1.0, 0.247058823529, 0.247058823529)],
        green = [(0.0, 0.98431372549, 0.98431372549),
            (0.125, 0.929411764706, 0.929411764706),
            (0.25, 0.854901960784, 0.854901960784),
            (0.375, 0.741176470588, 0.741176470588),
            (0.5, 0.603921568627, 0.603921568627),
            (0.625, 0.490196078431, 0.490196078431),
            (0.75, 0.317647058824, 0.317647058824),
            (0.875, 0.152941176471, 0.152941176471),
            (1.0, 0.0, 0.0)],
        blue = [(0.0, 0.992156862745, 0.992156862745),
            (0.125, 0.960784313725, 0.960784313725),
            (0.25, 0.921568627451, 0.921568627451),
            (0.375, 0.862745098039, 0.862745098039),
            (0.5, 0.78431372549, 0.78431372549),
            (0.625, 0.729411764706, 0.729411764706),
            (0.75, 0.639215686275, 0.639215686275),
            (0.875, 0.560784313725, 0.560784313725),
            (1.0, 0.490196078431, 0.490196078431)],
    )
    return ColorMapper.from_segment_map(_data, range=range, **traits)

def RdBu(range, **traits):
    """ Generator for the 'RdBu' colormap from ColorBrewer.

    This is a diverging colormap. It is good for data which is centered around
    a "special" value, like 0.

    Although the ColorBrewer colormaps are defined as discrete colormaps, we
    create continuous colormaps from them by linear interpolation in RGB
    colorspace.
    """
    _data = dict(
        red = [(0.0, 0.403921568627, 0.403921568627),
            (0.1, 0.698039215686, 0.698039215686),
            (0.2, 0.839215686275, 0.839215686275),
            (0.3, 0.956862745098, 0.956862745098),
            (0.4, 0.992156862745, 0.992156862745),
            (0.5, 0.96862745098, 0.96862745098),
            (0.6, 0.819607843137, 0.819607843137),
            (0.7, 0.572549019608, 0.572549019608),
            (0.8, 0.262745098039, 0.262745098039),
            (0.9, 0.129411764706, 0.129411764706),
            (1.0, 0.0196078431373, 0.0196078431373)],
        green = [(0.0, 0.0, 0.0),
            (0.1, 0.0941176470588, 0.0941176470588),
            (0.2, 0.376470588235, 0.376470588235),
            (0.3, 0.647058823529, 0.647058823529),
            (0.4, 0.858823529412, 0.858823529412),
            (0.5, 0.96862745098, 0.96862745098),
            (0.6, 0.898039215686, 0.898039215686),
            (0.7, 0.772549019608, 0.772549019608),
            (0.8, 0.576470588235, 0.576470588235),
            (0.9, 0.4, 0.4),
            (1.0, 0.188235294118, 0.188235294118)],
        blue = [(0.0, 0.121568627451, 0.121568627451),
            (0.1, 0.16862745098, 0.16862745098),
            (0.2, 0.301960784314, 0.301960784314),
            (0.3, 0.509803921569, 0.509803921569),
            (0.4, 0.780392156863, 0.780392156863),
            (0.5, 0.96862745098, 0.96862745098),
            (0.6, 0.941176470588, 0.941176470588),
            (0.7, 0.870588235294, 0.870588235294),
            (0.8, 0.764705882353, 0.764705882353),
            (0.9, 0.674509803922, 0.674509803922),
            (1.0, 0.380392156863, 0.380392156863)],
    )
    return ColorMapper.from_segment_map(_data, range=range, **traits)

def RdGy(range, **traits):
    """ Generator for the 'RdGy' colormap from ColorBrewer.

    This is a diverging colormap. It is good for data which is centered around
    a "special" value, like 0.

    Although the ColorBrewer colormaps are defined as discrete colormaps, we
    create continuous colormaps from them by linear interpolation in RGB
    colorspace.
    """
    _data = dict(
        red = [(0.0, 0.403921568627, 0.403921568627),
            (0.1, 0.698039215686, 0.698039215686),
            (0.2, 0.839215686275, 0.839215686275),
            (0.3, 0.956862745098, 0.956862745098),
            (0.4, 0.992156862745, 0.992156862745),
            (0.5, 1.0, 1.0),
            (0.6, 0.878431372549, 0.878431372549),
            (0.7, 0.729411764706, 0.729411764706),
            (0.8, 0.529411764706, 0.529411764706),
            (0.9, 0.301960784314, 0.301960784314),
            (1.0, 0.101960784314, 0.101960784314)],
        green = [(0.0, 0.0, 0.0),
            (0.1, 0.0941176470588, 0.0941176470588),
            (0.2, 0.376470588235, 0.376470588235),
            (0.3, 0.647058823529, 0.647058823529),
            (0.4, 0.858823529412, 0.858823529412),
            (0.5, 1.0, 1.0),
            (0.6, 0.878431372549, 0.878431372549),
            (0.7, 0.729411764706, 0.729411764706),
            (0.8, 0.529411764706, 0.529411764706),
            (0.9, 0.301960784314, 0.301960784314),
            (1.0, 0.101960784314, 0.101960784314)],
        blue = [(0.0, 0.121568627451, 0.121568627451),
            (0.1, 0.16862745098, 0.16862745098),
            (0.2, 0.301960784314, 0.301960784314),
            (0.3, 0.509803921569, 0.509803921569),
            (0.4, 0.780392156863, 0.780392156863),
            (0.5, 1.0, 1.0),
            (0.6, 0.878431372549, 0.878431372549),
            (0.7, 0.729411764706, 0.729411764706),
            (0.8, 0.529411764706, 0.529411764706),
            (0.9, 0.301960784314, 0.301960784314),
            (1.0, 0.101960784314, 0.101960784314)],
    )
    return ColorMapper.from_segment_map(_data, range=range, **traits)

def RdPu(range, **traits):
    """ Generator for the 'RdPu' colormap from ColorBrewer.

    Although the ColorBrewer colormaps are defined as discrete colormaps, we
    create continuous colormaps from them by linear interpolation in RGB
    colorspace.
    """
    _data = dict(
        red = [(0.0, 1.0, 1.0),
            (0.125, 0.992156862745, 0.992156862745),
            (0.25, 0.988235294118, 0.988235294118),
            (0.375, 0.980392156863, 0.980392156863),
            (0.5, 0.96862745098, 0.96862745098),
            (0.625, 0.866666666667, 0.866666666667),
            (0.75, 0.682352941176, 0.682352941176),
            (0.875, 0.478431372549, 0.478431372549),
            (1.0, 0.286274509804, 0.286274509804)],
        green = [(0.0, 0.96862745098, 0.96862745098),
            (0.125, 0.878431372549, 0.878431372549),
            (0.25, 0.772549019608, 0.772549019608),
            (0.375, 0.623529411765, 0.623529411765),
            (0.5, 0.407843137255, 0.407843137255),
            (0.625, 0.203921568627, 0.203921568627),
            (0.75, 0.00392156862745, 0.00392156862745),
            (0.875, 0.00392156862745, 0.00392156862745),
            (1.0, 0.0, 0.0)],
        blue = [(0.0, 0.952941176471, 0.952941176471),
            (0.125, 0.866666666667, 0.866666666667),
            (0.25, 0.752941176471, 0.752941176471),
            (0.375, 0.709803921569, 0.709803921569),
            (0.5, 0.63137254902, 0.63137254902),
            (0.625, 0.592156862745, 0.592156862745),
            (0.75, 0.494117647059, 0.494117647059),
            (0.875, 0.466666666667, 0.466666666667),
            (1.0, 0.41568627451, 0.41568627451)],
    )
    return ColorMapper.from_segment_map(_data, range=range, **traits)

def RdYlBu(range, **traits):
    """ Generator for the 'RdYlBu' colormap from ColorBrewer.

    This is a diverging colormap. It is good for data which is centered around
    a "special" value, like 0.

    Although the ColorBrewer colormaps are defined as discrete colormaps, we
    create continuous colormaps from them by linear interpolation in RGB
    colorspace.
    """
    _data = dict(
        red = [(0.0, 0.647058823529, 0.647058823529),
            (0.1, 0.843137254902, 0.843137254902),
            (0.2, 0.956862745098, 0.956862745098),
            (0.3, 0.992156862745, 0.992156862745),
            (0.4, 0.996078431373, 0.996078431373),
            (0.5, 1.0, 1.0),
            (0.6, 0.878431372549, 0.878431372549),
            (0.7, 0.670588235294, 0.670588235294),
            (0.8, 0.454901960784, 0.454901960784),
            (0.9, 0.270588235294, 0.270588235294),
            (1.0, 0.192156862745, 0.192156862745)],
        green = [(0.0, 0.0, 0.0),
            (0.1, 0.188235294118, 0.188235294118),
            (0.2, 0.427450980392, 0.427450980392),
            (0.3, 0.682352941176, 0.682352941176),
            (0.4, 0.878431372549, 0.878431372549),
            (0.5, 1.0, 1.0),
            (0.6, 0.952941176471, 0.952941176471),
            (0.7, 0.850980392157, 0.850980392157),
            (0.8, 0.678431372549, 0.678431372549),
            (0.9, 0.458823529412, 0.458823529412),
            (1.0, 0.211764705882, 0.211764705882)],
        blue = [(0.0, 0.149019607843, 0.149019607843),
            (0.1, 0.152941176471, 0.152941176471),
            (0.2, 0.262745098039, 0.262745098039),
            (0.3, 0.380392156863, 0.380392156863),
            (0.4, 0.564705882353, 0.564705882353),
            (0.5, 0.749019607843, 0.749019607843),
            (0.6, 0.972549019608, 0.972549019608),
            (0.7, 0.913725490196, 0.913725490196),
            (0.8, 0.819607843137, 0.819607843137),
            (0.9, 0.705882352941, 0.705882352941),
            (1.0, 0.58431372549, 0.58431372549)],
    )
    return ColorMapper.from_segment_map(_data, range=range, **traits)

def RdYlGn(range, **traits):
    """ Generator for the 'RdYlGn' colormap from ColorBrewer.

    This is a diverging colormap. It is good for data which is centered around
    a "special" value, like 0.

    Although the ColorBrewer colormaps are defined as discrete colormaps, we
    create continuous colormaps from them by linear interpolation in RGB
    colorspace.
    """
    _data = dict(
        red = [(0.0, 0.647058823529, 0.647058823529),
            (0.1, 0.843137254902, 0.843137254902),
            (0.2, 0.956862745098, 0.956862745098),
            (0.3, 0.992156862745, 0.992156862745),
            (0.4, 0.996078431373, 0.996078431373),
            (0.5, 1.0, 1.0),
            (0.6, 0.850980392157, 0.850980392157),
            (0.7, 0.650980392157, 0.650980392157),
            (0.8, 0.4, 0.4),
            (0.9, 0.101960784314, 0.101960784314),
            (1.0, 0.0, 0.0)],
        green = [(0.0, 0.0, 0.0),
            (0.1, 0.188235294118, 0.188235294118),
            (0.2, 0.427450980392, 0.427450980392),
            (0.3, 0.682352941176, 0.682352941176),
            (0.4, 0.878431372549, 0.878431372549),
            (0.5, 1.0, 1.0),
            (0.6, 0.937254901961, 0.937254901961),
            (0.7, 0.850980392157, 0.850980392157),
            (0.8, 0.741176470588, 0.741176470588),
            (0.9, 0.596078431373, 0.596078431373),
            (1.0, 0.407843137255, 0.407843137255)],
        blue = [(0.0, 0.149019607843, 0.149019607843),
            (0.1, 0.152941176471, 0.152941176471),
            (0.2, 0.262745098039, 0.262745098039),
            (0.3, 0.380392156863, 0.380392156863),
            (0.4, 0.545098039216, 0.545098039216),
            (0.5, 0.749019607843, 0.749019607843),
            (0.6, 0.545098039216, 0.545098039216),
            (0.7, 0.41568627451, 0.41568627451),
            (0.8, 0.388235294118, 0.388235294118),
            (0.9, 0.313725490196, 0.313725490196),
            (1.0, 0.21568627451, 0.21568627451)],
    )
    return ColorMapper.from_segment_map(_data, range=range, **traits)

def Reds(range, **traits):
    """ Generator for the 'Reds' colormap from ColorBrewer.

    Although the ColorBrewer colormaps are defined as discrete colormaps, we
    create continuous colormaps from them by linear interpolation in RGB
    colorspace.
    """
    _data = dict(
        red = [(0.0, 1.0, 1.0),
            (0.125, 0.996078431373, 0.996078431373),
            (0.25, 0.988235294118, 0.988235294118),
            (0.375, 0.988235294118, 0.988235294118),
            (0.5, 0.98431372549, 0.98431372549),
            (0.625, 0.937254901961, 0.937254901961),
            (0.75, 0.796078431373, 0.796078431373),
            (0.875, 0.647058823529, 0.647058823529),
            (1.0, 0.403921568627, 0.403921568627)],
        green = [(0.0, 0.960784313725, 0.960784313725),
            (0.125, 0.878431372549, 0.878431372549),
            (0.25, 0.733333333333, 0.733333333333),
            (0.375, 0.572549019608, 0.572549019608),
            (0.5, 0.41568627451, 0.41568627451),
            (0.625, 0.23137254902, 0.23137254902),
            (0.75, 0.0941176470588, 0.0941176470588),
            (0.875, 0.0588235294118, 0.0588235294118),
            (1.0, 0.0, 0.0)],
        blue = [(0.0, 0.941176470588, 0.941176470588),
            (0.125, 0.823529411765, 0.823529411765),
            (0.25, 0.63137254902, 0.63137254902),
            (0.375, 0.447058823529, 0.447058823529),
            (0.5, 0.290196078431, 0.290196078431),
            (0.625, 0.172549019608, 0.172549019608),
            (0.75, 0.113725490196, 0.113725490196),
            (0.875, 0.0823529411765, 0.0823529411765),
            (1.0, 0.0509803921569, 0.0509803921569)],
    )
    return ColorMapper.from_segment_map(_data, range=range, **traits)

def Spectral(range, **traits):
    """ Generator for the 'Spectral' colormap from ColorBrewer.

    This is a diverging colormap. It is good for data which is centered around
    a "special" value, like 0.

    Although the ColorBrewer colormaps are defined as discrete colormaps, we
    create continuous colormaps from them by linear interpolation in RGB
    colorspace.
    """
    _data = dict(
        red = [(0.0, 0.619607843137, 0.619607843137),
            (0.1, 0.835294117647, 0.835294117647),
            (0.2, 0.956862745098, 0.956862745098),
            (0.3, 0.992156862745, 0.992156862745),
            (0.4, 0.996078431373, 0.996078431373),
            (0.5, 1.0, 1.0),
            (0.6, 0.901960784314, 0.901960784314),
            (0.7, 0.670588235294, 0.670588235294),
            (0.8, 0.4, 0.4),
            (0.9, 0.196078431373, 0.196078431373),
            (1.0, 0.36862745098, 0.36862745098)],
        green = [(0.0, 0.00392156862745, 0.00392156862745),
            (0.1, 0.243137254902, 0.243137254902),
            (0.2, 0.427450980392, 0.427450980392),
            (0.3, 0.682352941176, 0.682352941176),
            (0.4, 0.878431372549, 0.878431372549),
            (0.5, 1.0, 1.0),
            (0.6, 0.960784313725, 0.960784313725),
            (0.7, 0.866666666667, 0.866666666667),
            (0.8, 0.760784313725, 0.760784313725),
            (0.9, 0.533333333333, 0.533333333333),
            (1.0, 0.309803921569, 0.309803921569)],
        blue = [(0.0, 0.258823529412, 0.258823529412),
            (0.1, 0.309803921569, 0.309803921569),
            (0.2, 0.262745098039, 0.262745098039),
            (0.3, 0.380392156863, 0.380392156863),
            (0.4, 0.545098039216, 0.545098039216),
            (0.5, 0.749019607843, 0.749019607843),
            (0.6, 0.596078431373, 0.596078431373),
            (0.7, 0.643137254902, 0.643137254902),
            (0.8, 0.647058823529, 0.647058823529),
            (0.9, 0.741176470588, 0.741176470588),
            (1.0, 0.635294117647, 0.635294117647)],
    )
    return ColorMapper.from_segment_map(_data, range=range, **traits)

def YlGn(range, **traits):
    """ Generator for the 'YlGn' colormap from ColorBrewer.

    Although the ColorBrewer colormaps are defined as discrete colormaps, we
    create continuous colormaps from them by linear interpolation in RGB
    colorspace.
    """
    _data = dict(
        red = [(0.0, 1.0, 1.0),
            (0.125, 0.96862745098, 0.96862745098),
            (0.25, 0.850980392157, 0.850980392157),
            (0.375, 0.678431372549, 0.678431372549),
            (0.5, 0.470588235294, 0.470588235294),
            (0.625, 0.254901960784, 0.254901960784),
            (0.75, 0.137254901961, 0.137254901961),
            (0.875, 0.0, 0.0),
            (1.0, 0.0, 0.0)],
        green = [(0.0, 1.0, 1.0),
            (0.125, 0.988235294118, 0.988235294118),
            (0.25, 0.941176470588, 0.941176470588),
            (0.375, 0.866666666667, 0.866666666667),
            (0.5, 0.776470588235, 0.776470588235),
            (0.625, 0.670588235294, 0.670588235294),
            (0.75, 0.517647058824, 0.517647058824),
            (0.875, 0.407843137255, 0.407843137255),
            (1.0, 0.270588235294, 0.270588235294)],
        blue = [(0.0, 0.898039215686, 0.898039215686),
            (0.125, 0.725490196078, 0.725490196078),
            (0.25, 0.639215686275, 0.639215686275),
            (0.375, 0.556862745098, 0.556862745098),
            (0.5, 0.474509803922, 0.474509803922),
            (0.625, 0.364705882353, 0.364705882353),
            (0.75, 0.262745098039, 0.262745098039),
            (0.875, 0.21568627451, 0.21568627451),
            (1.0, 0.160784313725, 0.160784313725)],
    )
    return ColorMapper.from_segment_map(_data, range=range, **traits)

def YlGnBu(range, **traits):
    """ Generator for the 'YlGnBu' colormap from ColorBrewer.

    Although the ColorBrewer colormaps are defined as discrete colormaps, we
    create continuous colormaps from them by linear interpolation in RGB
    colorspace.
    """
    _data = dict(
        red = [(0.0, 1.0, 1.0),
            (0.125, 0.929411764706, 0.929411764706),
            (0.25, 0.780392156863, 0.780392156863),
            (0.375, 0.498039215686, 0.498039215686),
            (0.5, 0.254901960784, 0.254901960784),
            (0.625, 0.113725490196, 0.113725490196),
            (0.75, 0.133333333333, 0.133333333333),
            (0.875, 0.145098039216, 0.145098039216),
            (1.0, 0.0313725490196, 0.0313725490196)],
        green = [(0.0, 1.0, 1.0),
            (0.125, 0.972549019608, 0.972549019608),
            (0.25, 0.913725490196, 0.913725490196),
            (0.375, 0.803921568627, 0.803921568627),
            (0.5, 0.713725490196, 0.713725490196),
            (0.625, 0.56862745098, 0.56862745098),
            (0.75, 0.36862745098, 0.36862745098),
            (0.875, 0.203921568627, 0.203921568627),
            (1.0, 0.113725490196, 0.113725490196)],
        blue = [(0.0, 0.850980392157, 0.850980392157),
            (0.125, 0.694117647059, 0.694117647059),
            (0.25, 0.705882352941, 0.705882352941),
            (0.375, 0.733333333333, 0.733333333333),
            (0.5, 0.76862745098, 0.76862745098),
            (0.625, 0.752941176471, 0.752941176471),
            (0.75, 0.658823529412, 0.658823529412),
            (0.875, 0.580392156863, 0.580392156863),
            (1.0, 0.345098039216, 0.345098039216)],
    )
    return ColorMapper.from_segment_map(_data, range=range, **traits)

def YlOrBr(range, **traits):
    """ Generator for the 'YlOrBr' colormap from ColorBrewer.

    Although the ColorBrewer colormaps are defined as discrete colormaps, we
    create continuous colormaps from them by linear interpolation in RGB
    colorspace.
    """
    _data = dict(
        red = [(0.0, 1.0, 1.0),
            (0.125, 1.0, 1.0),
            (0.25, 0.996078431373, 0.996078431373),
            (0.375, 0.996078431373, 0.996078431373),
            (0.5, 0.996078431373, 0.996078431373),
            (0.625, 0.925490196078, 0.925490196078),
            (0.75, 0.8, 0.8),
            (0.875, 0.6, 0.6),
            (1.0, 0.4, 0.4)],
        green = [(0.0, 1.0, 1.0),
            (0.125, 0.96862745098, 0.96862745098),
            (0.25, 0.890196078431, 0.890196078431),
            (0.375, 0.76862745098, 0.76862745098),
            (0.5, 0.6, 0.6),
            (0.625, 0.439215686275, 0.439215686275),
            (0.75, 0.298039215686, 0.298039215686),
            (0.875, 0.203921568627, 0.203921568627),
            (1.0, 0.145098039216, 0.145098039216)],
        blue = [(0.0, 0.898039215686, 0.898039215686),
            (0.125, 0.737254901961, 0.737254901961),
            (0.25, 0.56862745098, 0.56862745098),
            (0.375, 0.309803921569, 0.309803921569),
            (0.5, 0.160784313725, 0.160784313725),
            (0.625, 0.078431372549, 0.078431372549),
            (0.75, 0.0078431372549, 0.0078431372549),
            (0.875, 0.0156862745098, 0.0156862745098),
            (1.0, 0.0235294117647, 0.0235294117647)],
    )
    return ColorMapper.from_segment_map(_data, range=range, **traits)

def YlOrRd(range, **traits):
    """ Generator for the 'YlOrRd' colormap from ColorBrewer.

    Although the ColorBrewer colormaps are defined as discrete colormaps, we
    create continuous colormaps from them by linear interpolation in RGB
    colorspace.
    """
    _data = dict(
        red = [(0.0, 1.0, 1.0),
            (0.125, 1.0, 1.0),
            (0.25, 0.996078431373, 0.996078431373),
            (0.375, 0.996078431373, 0.996078431373),
            (0.5, 0.992156862745, 0.992156862745),
            (0.625, 0.988235294118, 0.988235294118),
            (0.75, 0.890196078431, 0.890196078431),
            (0.875, 0.741176470588, 0.741176470588),
            (1.0, 0.501960784314, 0.501960784314)],
        green = [(0.0, 1.0, 1.0),
            (0.125, 0.929411764706, 0.929411764706),
            (0.25, 0.850980392157, 0.850980392157),
            (0.375, 0.698039215686, 0.698039215686),
            (0.5, 0.552941176471, 0.552941176471),
            (0.625, 0.305882352941, 0.305882352941),
            (0.75, 0.101960784314, 0.101960784314),
            (0.875, 0.0, 0.0),
            (1.0, 0.0, 0.0)],
        blue = [(0.0, 0.8, 0.8),
            (0.125, 0.627450980392, 0.627450980392),
            (0.25, 0.462745098039, 0.462745098039),
            (0.375, 0.298039215686, 0.298039215686),
            (0.5, 0.235294117647, 0.235294117647),
            (0.625, 0.164705882353, 0.164705882353),
            (0.75, 0.109803921569, 0.109803921569),
            (0.875, 0.149019607843, 0.149019607843),
            (1.0, 0.149019607843, 0.149019607843)],
    )
    return ColorMapper.from_segment_map(_data, range=range, **traits)


# The following colormaps are from Yorick, a derivative of the GIST package.

def gist_earth(range, **traits):
    """ Generator for the 'gist_earth' colormap from GIST.
    """
    _data = dict(
        red = [(0.0, 0.0, 0.0),
            (0.0042016808874905109, 0.0, 0.0),
            (0.0084033617749810219, 0.0, 0.0),
            (0.012605042196810246, 0.0, 0.0),
            (0.016806723549962044, 0.0, 0.0),
            (0.021008403971791267, 0.0, 0.0),
            (0.025210084393620491, 0.0, 0.0),
            (0.029411764815449715, 0.0, 0.0),
            (0.033613447099924088, 0.0, 0.0),
            (0.037815127521753311, 0.0039215688593685627, 0.0039215688593685627),
            (0.042016807943582535, 0.0078431377187371254, 0.0078431377187371254),
            (0.046218488365411758, 0.0078431377187371254, 0.0078431377187371254),
            (0.050420168787240982, 0.011764706112444401, 0.011764706112444401),
            (0.054621849209070206, 0.015686275437474251, 0.015686275437474251),
            (0.058823529630899429, 0.019607843831181526, 0.019607843831181526),
            (0.063025213778018951, 0.019607843831181526, 0.019607843831181526),
            (0.067226894199848175, 0.023529412224888802, 0.023529412224888802),
            (0.071428574621677399, 0.027450980618596077, 0.027450980618596077),
            (0.075630255043506622, 0.031372550874948502, 0.031372550874948502),
            (0.079831935465335846, 0.031372550874948502, 0.031372550874948502),
            (0.08403361588716507, 0.035294119268655777, 0.035294119268655777),
            (0.088235296308994293, 0.039215687662363052, 0.039215687662363052),
            (0.092436976730823517, 0.043137256056070328, 0.043137256056070328),
            (0.09663865715265274, 0.043137256056070328, 0.043137256056070328),
            (0.10084033757448196, 0.047058824449777603, 0.047058824449777603),
            (0.10504201799631119, 0.050980392843484879, 0.050980392843484879),
            (0.10924369841814041, 0.054901961237192154, 0.054901961237192154),
            (0.11344537883996964, 0.058823529630899429, 0.058823529630899429),
            (0.11764705926179886, 0.058823529630899429, 0.058823529630899429),
            (0.12184873968362808, 0.062745101749897003, 0.062745101749897003),
            (0.1260504275560379, 0.066666670143604279, 0.066666670143604279),
            (0.13025210797786713, 0.070588238537311554, 0.070588238537311554),
            (0.13445378839969635, 0.070588238537311554, 0.070588238537311554),
            (0.13865546882152557, 0.074509806931018829, 0.074509806931018829),
            (0.1428571492433548, 0.078431375324726105, 0.078431375324726105),
            (0.14705882966518402, 0.08235294371843338, 0.08235294371843338),
            (0.15126051008701324, 0.086274512112140656, 0.086274512112140656),
            (0.15546219050884247, 0.086274512112140656, 0.086274512112140656),
            (0.15966387093067169, 0.090196080505847931, 0.090196080505847931),
            (0.16386555135250092, 0.094117648899555206, 0.094117648899555206),
            (0.16806723177433014, 0.098039217293262482, 0.098039217293262482),
            (0.17226891219615936, 0.10196078568696976, 0.10196078568696976),
            (0.17647059261798859, 0.10196078568696976, 0.10196078568696976),
            (0.18067227303981781, 0.10588235408067703, 0.10588235408067703),
            (0.18487395346164703, 0.10980392247438431, 0.10980392247438431),
            (0.18907563388347626, 0.11372549086809158, 0.11372549086809158),
            (0.19327731430530548, 0.11764705926179886, 0.11764705926179886),
            (0.1974789947271347, 0.12156862765550613, 0.12156862765550613),
            (0.20168067514896393, 0.12156862765550613, 0.12156862765550613),
            (0.20588235557079315, 0.12549020349979401, 0.12549020349979401),
            (0.21008403599262238, 0.12941177189350128, 0.12941177189350128),
            (0.2142857164144516, 0.13333334028720856, 0.13333334028720856),
            (0.21848739683628082, 0.13725490868091583, 0.13725490868091583),
            (0.22268907725811005, 0.14117647707462311, 0.14117647707462311),
            (0.22689075767993927, 0.14117647707462311, 0.14117647707462311),
            (0.23109243810176849, 0.14509804546833038, 0.14509804546833038),
            (0.23529411852359772, 0.14901961386203766, 0.14901961386203766),
            (0.23949579894542694, 0.15294118225574493, 0.15294118225574493),
            (0.24369747936725616, 0.15686275064945221, 0.15686275064945221),
            (0.24789915978908539, 0.16078431904315948, 0.16078431904315948),
            (0.25210085511207581, 0.16078431904315948, 0.16078431904315948),
            (0.25630253553390503, 0.16470588743686676, 0.16470588743686676),
            (0.26050421595573425, 0.16862745583057404, 0.16862745583057404),
            (0.26470589637756348, 0.17254902422428131, 0.17254902422428131),
            (0.2689075767993927, 0.17647059261798859, 0.17647059261798859),
            (0.27310925722122192, 0.18039216101169586, 0.18039216101169586),
            (0.27731093764305115, 0.18431372940540314, 0.18431372940540314),
            (0.28151261806488037, 0.18823529779911041, 0.18823529779911041),
            (0.28571429848670959, 0.18823529779911041, 0.18823529779911041),
            (0.28991597890853882, 0.18823529779911041, 0.18823529779911041),
            (0.29411765933036804, 0.19215686619281769, 0.19215686619281769),
            (0.29831933975219727, 0.19215686619281769, 0.19215686619281769),
            (0.30252102017402649, 0.19607843458652496, 0.19607843458652496),
            (0.30672270059585571, 0.19607843458652496, 0.19607843458652496),
            (0.31092438101768494, 0.20000000298023224, 0.20000000298023224),
            (0.31512606143951416, 0.20000000298023224, 0.20000000298023224),
            (0.31932774186134338, 0.20392157137393951, 0.20392157137393951),
            (0.32352942228317261, 0.20392157137393951, 0.20392157137393951),
            (0.32773110270500183, 0.20784313976764679, 0.20784313976764679),
            (0.33193278312683105, 0.20784313976764679, 0.20784313976764679),
            (0.33613446354866028, 0.21176470816135406, 0.21176470816135406),
            (0.3403361439704895, 0.21176470816135406, 0.21176470816135406),
            (0.34453782439231873, 0.21568627655506134, 0.21568627655506134),
            (0.34873950481414795, 0.21568627655506134, 0.21568627655506134),
            (0.35294118523597717, 0.21960784494876862, 0.21960784494876862),
            (0.3571428656578064, 0.21960784494876862, 0.21960784494876862),
            (0.36134454607963562, 0.22352941334247589, 0.22352941334247589),
            (0.36554622650146484, 0.22352941334247589, 0.22352941334247589),
            (0.36974790692329407, 0.22745098173618317, 0.22745098173618317),
            (0.37394958734512329, 0.22745098173618317, 0.22745098173618317),
            (0.37815126776695251, 0.23137255012989044, 0.23137255012989044),
            (0.38235294818878174, 0.23137255012989044, 0.23137255012989044),
            (0.38655462861061096, 0.23529411852359772, 0.23529411852359772),
            (0.39075630903244019, 0.23921568691730499, 0.23921568691730499),
            (0.39495798945426941, 0.23921568691730499, 0.23921568691730499),
            (0.39915966987609863, 0.24313725531101227, 0.24313725531101227),
            (0.40336135029792786, 0.24313725531101227, 0.24313725531101227),
            (0.40756303071975708, 0.24705882370471954, 0.24705882370471954),
            (0.4117647111415863, 0.24705882370471954, 0.24705882370471954),
            (0.41596639156341553, 0.25098040699958801, 0.25098040699958801),
            (0.42016807198524475, 0.25098040699958801, 0.25098040699958801),
            (0.42436975240707397, 0.25490197539329529, 0.25490197539329529),
            (0.4285714328289032, 0.25490197539329529, 0.25490197539329529),
            (0.43277311325073242, 0.25882354378700256, 0.25882354378700256),
            (0.43697479367256165, 0.26274511218070984, 0.26274511218070984),
            (0.44117647409439087, 0.26274511218070984, 0.26274511218070984),
            (0.44537815451622009, 0.26666668057441711, 0.26666668057441711),
            (0.44957983493804932, 0.26666668057441711, 0.26666668057441711),
            (0.45378151535987854, 0.27058824896812439, 0.27058824896812439),
            (0.45798319578170776, 0.27058824896812439, 0.27058824896812439),
            (0.46218487620353699, 0.27450981736183167, 0.27450981736183167),
            (0.46638655662536621, 0.27843138575553894, 0.27843138575553894),
            (0.47058823704719543, 0.28627452254295349, 0.28627452254295349),
            (0.47478991746902466, 0.29803922772407532, 0.29803922772407532),
            (0.47899159789085388, 0.30588236451148987, 0.30588236451148987),
            (0.48319327831268311, 0.31764706969261169, 0.31764706969261169),
            (0.48739495873451233, 0.32549020648002625, 0.32549020648002625),
            (0.49159663915634155, 0.33725491166114807, 0.33725491166114807),
            (0.49579831957817078, 0.34509804844856262, 0.34509804844856262),
            (0.5, 0.35686275362968445, 0.35686275362968445),
            (0.50420171022415161, 0.36862745881080627, 0.36862745881080627),
            (0.50840336084365845, 0.37647059559822083, 0.37647059559822083),
            (0.51260507106781006, 0.38823530077934265, 0.38823530077934265),
            (0.51680672168731689, 0.3960784375667572, 0.3960784375667572),
            (0.52100843191146851, 0.40784314274787903, 0.40784314274787903),
            (0.52521008253097534, 0.41568627953529358, 0.41568627953529358),
            (0.52941179275512695, 0.42745098471641541, 0.42745098471641541),
            (0.53361344337463379, 0.43529412150382996, 0.43529412150382996),
            (0.5378151535987854, 0.44705882668495178, 0.44705882668495178),
            (0.54201680421829224, 0.45882353186607361, 0.45882353186607361),
            (0.54621851444244385, 0.46666666865348816, 0.46666666865348816),
            (0.55042016506195068, 0.47450980544090271, 0.47450980544090271),
            (0.55462187528610229, 0.47843137383460999, 0.47843137383460999),
            (0.55882352590560913, 0.48627451062202454, 0.48627451062202454),
            (0.56302523612976074, 0.49411764740943909, 0.49411764740943909),
            (0.56722688674926758, 0.50196081399917603, 0.50196081399917603),
            (0.57142859697341919, 0.5058823823928833, 0.5058823823928833),
            (0.57563024759292603, 0.51372551918029785, 0.51372551918029785),
            (0.57983195781707764, 0.5215686559677124, 0.5215686559677124),
            (0.58403360843658447, 0.52941179275512695, 0.52941179275512695),
            (0.58823531866073608, 0.53333336114883423, 0.53333336114883423),
            (0.59243696928024292, 0.54117649793624878, 0.54117649793624878),
            (0.59663867950439453, 0.54901963472366333, 0.54901963472366333),
            (0.60084033012390137, 0.55294120311737061, 0.55294120311737061),
            (0.60504204034805298, 0.56078433990478516, 0.56078433990478516),
            (0.60924369096755981, 0.56862747669219971, 0.56862747669219971),
            (0.61344540119171143, 0.57647061347961426, 0.57647061347961426),
            (0.61764705181121826, 0.58431375026702881, 0.58431375026702881),
            (0.62184876203536987, 0.58823531866073608, 0.58823531866073608),
            (0.62605041265487671, 0.59607845544815063, 0.59607845544815063),
            (0.63025212287902832, 0.60392159223556519, 0.60392159223556519),
            (0.63445377349853516, 0.61176472902297974, 0.61176472902297974),
            (0.63865548372268677, 0.61568629741668701, 0.61568629741668701),
            (0.6428571343421936, 0.62352943420410156, 0.62352943420410156),
            (0.64705884456634521, 0.63137257099151611, 0.63137257099151611),
            (0.65126049518585205, 0.63921570777893066, 0.63921570777893066),
            (0.65546220541000366, 0.64705884456634521, 0.64705884456634521),
            (0.6596638560295105, 0.65098041296005249, 0.65098041296005249),
            (0.66386556625366211, 0.65882354974746704, 0.65882354974746704),
            (0.66806721687316895, 0.66666668653488159, 0.66666668653488159),
            (0.67226892709732056, 0.67450982332229614, 0.67450982332229614),
            (0.67647057771682739, 0.68235296010971069, 0.68235296010971069),
            (0.680672287940979, 0.68627452850341797, 0.68627452850341797),
            (0.68487393856048584, 0.69411766529083252, 0.69411766529083252),
            (0.68907564878463745, 0.70196080207824707, 0.70196080207824707),
            (0.69327729940414429, 0.70980393886566162, 0.70980393886566162),
            (0.6974790096282959, 0.71764707565307617, 0.71764707565307617),
            (0.70168066024780273, 0.71764707565307617, 0.71764707565307617),
            (0.70588237047195435, 0.72156864404678345, 0.72156864404678345),
            (0.71008402109146118, 0.72156864404678345, 0.72156864404678345),
            (0.71428573131561279, 0.72549021244049072, 0.72549021244049072),
            (0.71848738193511963, 0.72549021244049072, 0.72549021244049072),
            (0.72268909215927124, 0.729411780834198, 0.729411780834198),
            (0.72689074277877808, 0.729411780834198, 0.729411780834198),
            (0.73109245300292969, 0.73333334922790527, 0.73333334922790527),
            (0.73529410362243652, 0.73333334922790527, 0.73333334922790527),
            (0.73949581384658813, 0.73333334922790527, 0.73333334922790527),
            (0.74369746446609497, 0.73725491762161255, 0.73725491762161255),
            (0.74789917469024658, 0.73725491762161255, 0.73725491762161255),
            (0.75210082530975342, 0.74117648601531982, 0.74117648601531982),
            (0.75630253553390503, 0.74117648601531982, 0.74117648601531982),
            (0.76050418615341187, 0.7450980544090271, 0.7450980544090271),
            (0.76470589637756348, 0.7450980544090271, 0.7450980544090271),
            (0.76890754699707031, 0.7450980544090271, 0.7450980544090271),
            (0.77310925722122192, 0.74901962280273438, 0.74901962280273438),
            (0.77731090784072876, 0.74901962280273438, 0.74901962280273438),
            (0.78151261806488037, 0.75294119119644165, 0.75294119119644165),
            (0.78571426868438721, 0.75294119119644165, 0.75294119119644165),
            (0.78991597890853882, 0.75686275959014893, 0.75686275959014893),
            (0.79411762952804565, 0.76470589637756348, 0.76470589637756348),
            (0.79831933975219727, 0.76862746477127075, 0.76862746477127075),
            (0.8025209903717041, 0.77254903316497803, 0.77254903316497803),
            (0.80672270059585571, 0.7764706015586853, 0.7764706015586853),
            (0.81092435121536255, 0.78039216995239258, 0.78039216995239258),
            (0.81512606143951416, 0.78823530673980713, 0.78823530673980713),
            (0.819327712059021, 0.7921568751335144, 0.7921568751335144),
            (0.82352942228317261, 0.79607844352722168, 0.79607844352722168),
            (0.82773107290267944, 0.80000001192092896, 0.80000001192092896),
            (0.83193278312683105, 0.80392158031463623, 0.80392158031463623),
            (0.83613443374633789, 0.81176471710205078, 0.81176471710205078),
            (0.8403361439704895, 0.81568628549575806, 0.81568628549575806),
            (0.84453779458999634, 0.81960785388946533, 0.81960785388946533),
            (0.84873950481414795, 0.82352942228317261, 0.82352942228317261),
            (0.85294115543365479, 0.82745099067687988, 0.82745099067687988),
            (0.8571428656578064, 0.83529412746429443, 0.83529412746429443),
            (0.86134451627731323, 0.83921569585800171, 0.83921569585800171),
            (0.86554622650146484, 0.84313726425170898, 0.84313726425170898),
            (0.86974787712097168, 0.84705883264541626, 0.84705883264541626),
            (0.87394958734512329, 0.85098040103912354, 0.85098040103912354),
            (0.87815123796463013, 0.85882353782653809, 0.85882353782653809),
            (0.88235294818878174, 0.86274510622024536, 0.86274510622024536),
            (0.88655459880828857, 0.86666667461395264, 0.86666667461395264),
            (0.89075630903244019, 0.87058824300765991, 0.87058824300765991),
            (0.89495795965194702, 0.87450981140136719, 0.87450981140136719),
            (0.89915966987609863, 0.88235294818878174, 0.88235294818878174),
            (0.90336132049560547, 0.88627451658248901, 0.88627451658248901),
            (0.90756303071975708, 0.89019608497619629, 0.89019608497619629),
            (0.91176468133926392, 0.89411765336990356, 0.89411765336990356),
            (0.91596639156341553, 0.89803922176361084, 0.89803922176361084),
            (0.92016804218292236, 0.90588235855102539, 0.90588235855102539),
            (0.92436975240707397, 0.90980392694473267, 0.90980392694473267),
            (0.92857140302658081, 0.91372549533843994, 0.91372549533843994),
            (0.93277311325073242, 0.91764706373214722, 0.91764706373214722),
            (0.93697476387023926, 0.92156863212585449, 0.92156863212585449),
            (0.94117647409439087, 0.92941176891326904, 0.92941176891326904),
            (0.94537812471389771, 0.93333333730697632, 0.93333333730697632),
            (0.94957983493804932, 0.93725490570068359, 0.93725490570068359),
            (0.95378148555755615, 0.94117647409439087, 0.94117647409439087),
            (0.95798319578170776, 0.94509804248809814, 0.94509804248809814),
            (0.9621848464012146, 0.9529411792755127, 0.9529411792755127),
            (0.96638655662536621, 0.95686274766921997, 0.95686274766921997),
            (0.97058820724487305, 0.96078431606292725, 0.96078431606292725),
            (0.97478991746902466, 0.96470588445663452, 0.96470588445663452),
            (0.97899156808853149, 0.9686274528503418, 0.9686274528503418),
            (0.98319327831268311, 0.97647058963775635, 0.97647058963775635),
            (0.98739492893218994, 0.98039215803146362, 0.98039215803146362),
            (0.99159663915634155, 0.9843137264251709, 0.9843137264251709),
            (0.99579828977584839, 0.98823529481887817, 0.98823529481887817),
            (1.0, 0.99215686321258545, 0.99215686321258545)],
        green = [(0.0, 0.0, 0.0),
            (0.0042016808874905109, 0.0, 0.0),
            (0.0084033617749810219, 0.0, 0.0),
            (0.012605042196810246, 0.0, 0.0),
            (0.016806723549962044, 0.0, 0.0),
            (0.021008403971791267, 0.0, 0.0),
            (0.025210084393620491, 0.0, 0.0),
            (0.029411764815449715, 0.0, 0.0),
            (0.033613447099924088, 0.011764706112444401, 0.011764706112444401),
            (0.037815127521753311, 0.023529412224888802, 0.023529412224888802),
            (0.042016807943582535, 0.031372550874948502, 0.031372550874948502),
            (0.046218488365411758, 0.043137256056070328, 0.043137256056070328),
            (0.050420168787240982, 0.050980392843484879, 0.050980392843484879),
            (0.054621849209070206, 0.062745101749897003, 0.062745101749897003),
            (0.058823529630899429, 0.070588238537311554, 0.070588238537311554),
            (0.063025213778018951, 0.08235294371843338, 0.08235294371843338),
            (0.067226894199848175, 0.090196080505847931, 0.090196080505847931),
            (0.071428574621677399, 0.10196078568696976, 0.10196078568696976),
            (0.075630255043506622, 0.10980392247438431, 0.10980392247438431),
            (0.079831935465335846, 0.12156862765550613, 0.12156862765550613),
            (0.08403361588716507, 0.12941177189350128, 0.12941177189350128),
            (0.088235296308994293, 0.14117647707462311, 0.14117647707462311),
            (0.092436976730823517, 0.14901961386203766, 0.14901961386203766),
            (0.09663865715265274, 0.16078431904315948, 0.16078431904315948),
            (0.10084033757448196, 0.16862745583057404, 0.16862745583057404),
            (0.10504201799631119, 0.17647059261798859, 0.17647059261798859),
            (0.10924369841814041, 0.18823529779911041, 0.18823529779911041),
            (0.11344537883996964, 0.19607843458652496, 0.19607843458652496),
            (0.11764705926179886, 0.20392157137393951, 0.20392157137393951),
            (0.12184873968362808, 0.21568627655506134, 0.21568627655506134),
            (0.1260504275560379, 0.22352941334247589, 0.22352941334247589),
            (0.13025210797786713, 0.23137255012989044, 0.23137255012989044),
            (0.13445378839969635, 0.23921568691730499, 0.23921568691730499),
            (0.13865546882152557, 0.25098040699958801, 0.25098040699958801),
            (0.1428571492433548, 0.25882354378700256, 0.25882354378700256),
            (0.14705882966518402, 0.26666668057441711, 0.26666668057441711),
            (0.15126051008701324, 0.27450981736183167, 0.27450981736183167),
            (0.15546219050884247, 0.28235295414924622, 0.28235295414924622),
            (0.15966387093067169, 0.29019609093666077, 0.29019609093666077),
            (0.16386555135250092, 0.30196079611778259, 0.30196079611778259),
            (0.16806723177433014, 0.30980393290519714, 0.30980393290519714),
            (0.17226891219615936, 0.31764706969261169, 0.31764706969261169),
            (0.17647059261798859, 0.32549020648002625, 0.32549020648002625),
            (0.18067227303981781, 0.3333333432674408, 0.3333333432674408),
            (0.18487395346164703, 0.34117648005485535, 0.34117648005485535),
            (0.18907563388347626, 0.3490196168422699, 0.3490196168422699),
            (0.19327731430530548, 0.35686275362968445, 0.35686275362968445),
            (0.1974789947271347, 0.364705890417099, 0.364705890417099),
            (0.20168067514896393, 0.37254902720451355, 0.37254902720451355),
            (0.20588235557079315, 0.3803921639919281, 0.3803921639919281),
            (0.21008403599262238, 0.38823530077934265, 0.38823530077934265),
            (0.2142857164144516, 0.39215686917304993, 0.39215686917304993),
            (0.21848739683628082, 0.40000000596046448, 0.40000000596046448),
            (0.22268907725811005, 0.40784314274787903, 0.40784314274787903),
            (0.22689075767993927, 0.41568627953529358, 0.41568627953529358),
            (0.23109243810176849, 0.42352941632270813, 0.42352941632270813),
            (0.23529411852359772, 0.42745098471641541, 0.42745098471641541),
            (0.23949579894542694, 0.43529412150382996, 0.43529412150382996),
            (0.24369747936725616, 0.44313725829124451, 0.44313725829124451),
            (0.24789915978908539, 0.45098039507865906, 0.45098039507865906),
            (0.25210085511207581, 0.45490196347236633, 0.45490196347236633),
            (0.25630253553390503, 0.46274510025978088, 0.46274510025978088),
            (0.26050421595573425, 0.47058823704719543, 0.47058823704719543),
            (0.26470589637756348, 0.47450980544090271, 0.47450980544090271),
            (0.2689075767993927, 0.48235294222831726, 0.48235294222831726),
            (0.27310925722122192, 0.49019607901573181, 0.49019607901573181),
            (0.27731093764305115, 0.49411764740943909, 0.49411764740943909),
            (0.28151261806488037, 0.50196081399917603, 0.50196081399917603),
            (0.28571429848670959, 0.50196081399917603, 0.50196081399917603),
            (0.28991597890853882, 0.5058823823928833, 0.5058823823928833),
            (0.29411765933036804, 0.5058823823928833, 0.5058823823928833),
            (0.29831933975219727, 0.50980395078659058, 0.50980395078659058),
            (0.30252102017402649, 0.51372551918029785, 0.51372551918029785),
            (0.30672270059585571, 0.51372551918029785, 0.51372551918029785),
            (0.31092438101768494, 0.51764708757400513, 0.51764708757400513),
            (0.31512606143951416, 0.5215686559677124, 0.5215686559677124),
            (0.31932774186134338, 0.5215686559677124, 0.5215686559677124),
            (0.32352942228317261, 0.52549022436141968, 0.52549022436141968),
            (0.32773110270500183, 0.52549022436141968, 0.52549022436141968),
            (0.33193278312683105, 0.52941179275512695, 0.52941179275512695),
            (0.33613446354866028, 0.53333336114883423, 0.53333336114883423),
            (0.3403361439704895, 0.53333336114883423, 0.53333336114883423),
            (0.34453782439231873, 0.5372549295425415, 0.5372549295425415),
            (0.34873950481414795, 0.54117649793624878, 0.54117649793624878),
            (0.35294118523597717, 0.54117649793624878, 0.54117649793624878),
            (0.3571428656578064, 0.54509806632995605, 0.54509806632995605),
            (0.36134454607963562, 0.54901963472366333, 0.54901963472366333),
            (0.36554622650146484, 0.54901963472366333, 0.54901963472366333),
            (0.36974790692329407, 0.55294120311737061, 0.55294120311737061),
            (0.37394958734512329, 0.55294120311737061, 0.55294120311737061),
            (0.37815126776695251, 0.55686277151107788, 0.55686277151107788),
            (0.38235294818878174, 0.56078433990478516, 0.56078433990478516),
            (0.38655462861061096, 0.56078433990478516, 0.56078433990478516),
            (0.39075630903244019, 0.56470590829849243, 0.56470590829849243),
            (0.39495798945426941, 0.56862747669219971, 0.56862747669219971),
            (0.39915966987609863, 0.56862747669219971, 0.56862747669219971),
            (0.40336135029792786, 0.57254904508590698, 0.57254904508590698),
            (0.40756303071975708, 0.57254904508590698, 0.57254904508590698),
            (0.4117647111415863, 0.57647061347961426, 0.57647061347961426),
            (0.41596639156341553, 0.58039218187332153, 0.58039218187332153),
            (0.42016807198524475, 0.58039218187332153, 0.58039218187332153),
            (0.42436975240707397, 0.58431375026702881, 0.58431375026702881),
            (0.4285714328289032, 0.58823531866073608, 0.58823531866073608),
            (0.43277311325073242, 0.58823531866073608, 0.58823531866073608),
            (0.43697479367256165, 0.59215688705444336, 0.59215688705444336),
            (0.44117647409439087, 0.59215688705444336, 0.59215688705444336),
            (0.44537815451622009, 0.59607845544815063, 0.59607845544815063),
            (0.44957983493804932, 0.60000002384185791, 0.60000002384185791),
            (0.45378151535987854, 0.60000002384185791, 0.60000002384185791),
            (0.45798319578170776, 0.60392159223556519, 0.60392159223556519),
            (0.46218487620353699, 0.60784316062927246, 0.60784316062927246),
            (0.46638655662536621, 0.60784316062927246, 0.60784316062927246),
            (0.47058823704719543, 0.61176472902297974, 0.61176472902297974),
            (0.47478991746902466, 0.61176472902297974, 0.61176472902297974),
            (0.47899159789085388, 0.61568629741668701, 0.61568629741668701),
            (0.48319327831268311, 0.61960786581039429, 0.61960786581039429),
            (0.48739495873451233, 0.61960786581039429, 0.61960786581039429),
            (0.49159663915634155, 0.62352943420410156, 0.62352943420410156),
            (0.49579831957817078, 0.62745100259780884, 0.62745100259780884),
            (0.5, 0.62745100259780884, 0.62745100259780884),
            (0.50420171022415161, 0.63137257099151611, 0.63137257099151611),
            (0.50840336084365845, 0.63137257099151611, 0.63137257099151611),
            (0.51260507106781006, 0.63529413938522339, 0.63529413938522339),
            (0.51680672168731689, 0.63921570777893066, 0.63921570777893066),
            (0.52100843191146851, 0.63921570777893066, 0.63921570777893066),
            (0.52521008253097534, 0.64313727617263794, 0.64313727617263794),
            (0.52941179275512695, 0.64705884456634521, 0.64705884456634521),
            (0.53361344337463379, 0.64705884456634521, 0.64705884456634521),
            (0.5378151535987854, 0.65098041296005249, 0.65098041296005249),
            (0.54201680421829224, 0.65098041296005249, 0.65098041296005249),
            (0.54621851444244385, 0.65490198135375977, 0.65490198135375977),
            (0.55042016506195068, 0.65882354974746704, 0.65882354974746704),
            (0.55462187528610229, 0.65882354974746704, 0.65882354974746704),
            (0.55882352590560913, 0.65882354974746704, 0.65882354974746704),
            (0.56302523612976074, 0.66274511814117432, 0.66274511814117432),
            (0.56722688674926758, 0.66274511814117432, 0.66274511814117432),
            (0.57142859697341919, 0.66666668653488159, 0.66666668653488159),
            (0.57563024759292603, 0.66666668653488159, 0.66666668653488159),
            (0.57983195781707764, 0.67058825492858887, 0.67058825492858887),
            (0.58403360843658447, 0.67058825492858887, 0.67058825492858887),
            (0.58823531866073608, 0.67450982332229614, 0.67450982332229614),
            (0.59243696928024292, 0.67450982332229614, 0.67450982332229614),
            (0.59663867950439453, 0.67450982332229614, 0.67450982332229614),
            (0.60084033012390137, 0.67843139171600342, 0.67843139171600342),
            (0.60504204034805298, 0.67843139171600342, 0.67843139171600342),
            (0.60924369096755981, 0.68235296010971069, 0.68235296010971069),
            (0.61344540119171143, 0.68235296010971069, 0.68235296010971069),
            (0.61764705181121826, 0.68627452850341797, 0.68627452850341797),
            (0.62184876203536987, 0.68627452850341797, 0.68627452850341797),
            (0.62605041265487671, 0.68627452850341797, 0.68627452850341797),
            (0.63025212287902832, 0.69019609689712524, 0.69019609689712524),
            (0.63445377349853516, 0.69019609689712524, 0.69019609689712524),
            (0.63865548372268677, 0.69411766529083252, 0.69411766529083252),
            (0.6428571343421936, 0.69411766529083252, 0.69411766529083252),
            (0.64705884456634521, 0.69803923368453979, 0.69803923368453979),
            (0.65126049518585205, 0.69803923368453979, 0.69803923368453979),
            (0.65546220541000366, 0.70196080207824707, 0.70196080207824707),
            (0.6596638560295105, 0.70196080207824707, 0.70196080207824707),
            (0.66386556625366211, 0.70196080207824707, 0.70196080207824707),
            (0.66806721687316895, 0.70588237047195435, 0.70588237047195435),
            (0.67226892709732056, 0.70588237047195435, 0.70588237047195435),
            (0.67647057771682739, 0.70980393886566162, 0.70980393886566162),
            (0.680672287940979, 0.70980393886566162, 0.70980393886566162),
            (0.68487393856048584, 0.7137255072593689, 0.7137255072593689),
            (0.68907564878463745, 0.7137255072593689, 0.7137255072593689),
            (0.69327729940414429, 0.71764707565307617, 0.71764707565307617),
            (0.6974790096282959, 0.71764707565307617, 0.71764707565307617),
            (0.70168066024780273, 0.7137255072593689, 0.7137255072593689),
            (0.70588237047195435, 0.70980393886566162, 0.70980393886566162),
            (0.71008402109146118, 0.70980393886566162, 0.70980393886566162),
            (0.71428573131561279, 0.70588237047195435, 0.70588237047195435),
            (0.71848738193511963, 0.70196080207824707, 0.70196080207824707),
            (0.72268909215927124, 0.69803923368453979, 0.69803923368453979),
            (0.72689074277877808, 0.69411766529083252, 0.69411766529083252),
            (0.73109245300292969, 0.69019609689712524, 0.69019609689712524),
            (0.73529410362243652, 0.68627452850341797, 0.68627452850341797),
            (0.73949581384658813, 0.68235296010971069, 0.68235296010971069),
            (0.74369746446609497, 0.67843139171600342, 0.67843139171600342),
            (0.74789917469024658, 0.67450982332229614, 0.67450982332229614),
            (0.75210082530975342, 0.67058825492858887, 0.67058825492858887),
            (0.75630253553390503, 0.66666668653488159, 0.66666668653488159),
            (0.76050418615341187, 0.66274511814117432, 0.66274511814117432),
            (0.76470589637756348, 0.65882354974746704, 0.65882354974746704),
            (0.76890754699707031, 0.65490198135375977, 0.65490198135375977),
            (0.77310925722122192, 0.65098041296005249, 0.65098041296005249),
            (0.77731090784072876, 0.64705884456634521, 0.64705884456634521),
            (0.78151261806488037, 0.64313727617263794, 0.64313727617263794),
            (0.78571426868438721, 0.63921570777893066, 0.63921570777893066),
            (0.78991597890853882, 0.63921570777893066, 0.63921570777893066),
            (0.79411762952804565, 0.64313727617263794, 0.64313727617263794),
            (0.79831933975219727, 0.64313727617263794, 0.64313727617263794),
            (0.8025209903717041, 0.64705884456634521, 0.64705884456634521),
            (0.80672270059585571, 0.64705884456634521, 0.64705884456634521),
            (0.81092435121536255, 0.65098041296005249, 0.65098041296005249),
            (0.81512606143951416, 0.65490198135375977, 0.65490198135375977),
            (0.819327712059021, 0.65490198135375977, 0.65490198135375977),
            (0.82352942228317261, 0.65882354974746704, 0.65882354974746704),
            (0.82773107290267944, 0.66274511814117432, 0.66274511814117432),
            (0.83193278312683105, 0.66666668653488159, 0.66666668653488159),
            (0.83613443374633789, 0.67058825492858887, 0.67058825492858887),
            (0.8403361439704895, 0.67450982332229614, 0.67450982332229614),
            (0.84453779458999634, 0.67843139171600342, 0.67843139171600342),
            (0.84873950481414795, 0.68235296010971069, 0.68235296010971069),
            (0.85294115543365479, 0.68627452850341797, 0.68627452850341797),
            (0.8571428656578064, 0.69019609689712524, 0.69019609689712524),
            (0.86134451627731323, 0.69411766529083252, 0.69411766529083252),
            (0.86554622650146484, 0.69803923368453979, 0.69803923368453979),
            (0.86974787712097168, 0.70196080207824707, 0.70196080207824707),
            (0.87394958734512329, 0.70980393886566162, 0.70980393886566162),
            (0.87815123796463013, 0.7137255072593689, 0.7137255072593689),
            (0.88235294818878174, 0.72156864404678345, 0.72156864404678345),
            (0.88655459880828857, 0.72549021244049072, 0.72549021244049072),
            (0.89075630903244019, 0.73333334922790527, 0.73333334922790527),
            (0.89495795965194702, 0.73725491762161255, 0.73725491762161255),
            (0.89915966987609863, 0.7450980544090271, 0.7450980544090271),
            (0.90336132049560547, 0.75294119119644165, 0.75294119119644165),
            (0.90756303071975708, 0.7607843279838562, 0.7607843279838562),
            (0.91176468133926392, 0.76862746477127075, 0.76862746477127075),
            (0.91596639156341553, 0.7764706015586853, 0.7764706015586853),
            (0.92016804218292236, 0.78431373834609985, 0.78431373834609985),
            (0.92436975240707397, 0.7921568751335144, 0.7921568751335144),
            (0.92857140302658081, 0.80000001192092896, 0.80000001192092896),
            (0.93277311325073242, 0.80784314870834351, 0.80784314870834351),
            (0.93697476387023926, 0.81568628549575806, 0.81568628549575806),
            (0.94117647409439087, 0.82745099067687988, 0.82745099067687988),
            (0.94537812471389771, 0.83529412746429443, 0.83529412746429443),
            (0.94957983493804932, 0.84313726425170898, 0.84313726425170898),
            (0.95378148555755615, 0.85490196943283081, 0.85490196943283081),
            (0.95798319578170776, 0.86666667461395264, 0.86666667461395264),
            (0.9621848464012146, 0.87450981140136719, 0.87450981140136719),
            (0.96638655662536621, 0.88627451658248901, 0.88627451658248901),
            (0.97058820724487305, 0.89803922176361084, 0.89803922176361084),
            (0.97478991746902466, 0.90980392694473267, 0.90980392694473267),
            (0.97899156808853149, 0.92156863212585449, 0.92156863212585449),
            (0.98319327831268311, 0.93333333730697632, 0.93333333730697632),
            (0.98739492893218994, 0.94509804248809814, 0.94509804248809814),
            (0.99159663915634155, 0.95686274766921997, 0.95686274766921997),
            (0.99579828977584839, 0.97254902124404907, 0.97254902124404907),
            (1.0, 0.9843137264251709, 0.9843137264251709)],
        blue = [(0.0, 0.0, 0.0),
            (0.0042016808874905109, 0.18039216101169586, 0.18039216101169586),
            (0.0084033617749810219, 0.22745098173618317, 0.22745098173618317),
            (0.012605042196810246, 0.27058824896812439, 0.27058824896812439),
            (0.016806723549962044, 0.31764706969261169, 0.31764706969261169),
            (0.021008403971791267, 0.36078432202339172, 0.36078432202339172),
            (0.025210084393620491, 0.40784314274787903, 0.40784314274787903),
            (0.029411764815449715, 0.45490196347236633, 0.45490196347236633),
            (0.033613447099924088, 0.45490196347236633, 0.45490196347236633),
            (0.037815127521753311, 0.45490196347236633, 0.45490196347236633),
            (0.042016807943582535, 0.45490196347236633, 0.45490196347236633),
            (0.046218488365411758, 0.45490196347236633, 0.45490196347236633),
            (0.050420168787240982, 0.45882353186607361, 0.45882353186607361),
            (0.054621849209070206, 0.45882353186607361, 0.45882353186607361),
            (0.058823529630899429, 0.45882353186607361, 0.45882353186607361),
            (0.063025213778018951, 0.45882353186607361, 0.45882353186607361),
            (0.067226894199848175, 0.45882353186607361, 0.45882353186607361),
            (0.071428574621677399, 0.46274510025978088, 0.46274510025978088),
            (0.075630255043506622, 0.46274510025978088, 0.46274510025978088),
            (0.079831935465335846, 0.46274510025978088, 0.46274510025978088),
            (0.08403361588716507, 0.46274510025978088, 0.46274510025978088),
            (0.088235296308994293, 0.46274510025978088, 0.46274510025978088),
            (0.092436976730823517, 0.46666666865348816, 0.46666666865348816),
            (0.09663865715265274, 0.46666666865348816, 0.46666666865348816),
            (0.10084033757448196, 0.46666666865348816, 0.46666666865348816),
            (0.10504201799631119, 0.46666666865348816, 0.46666666865348816),
            (0.10924369841814041, 0.46666666865348816, 0.46666666865348816),
            (0.11344537883996964, 0.47058823704719543, 0.47058823704719543),
            (0.11764705926179886, 0.47058823704719543, 0.47058823704719543),
            (0.12184873968362808, 0.47058823704719543, 0.47058823704719543),
            (0.1260504275560379, 0.47058823704719543, 0.47058823704719543),
            (0.13025210797786713, 0.47058823704719543, 0.47058823704719543),
            (0.13445378839969635, 0.47450980544090271, 0.47450980544090271),
            (0.13865546882152557, 0.47450980544090271, 0.47450980544090271),
            (0.1428571492433548, 0.47450980544090271, 0.47450980544090271),
            (0.14705882966518402, 0.47450980544090271, 0.47450980544090271),
            (0.15126051008701324, 0.47450980544090271, 0.47450980544090271),
            (0.15546219050884247, 0.47843137383460999, 0.47843137383460999),
            (0.15966387093067169, 0.47843137383460999, 0.47843137383460999),
            (0.16386555135250092, 0.47843137383460999, 0.47843137383460999),
            (0.16806723177433014, 0.47843137383460999, 0.47843137383460999),
            (0.17226891219615936, 0.47843137383460999, 0.47843137383460999),
            (0.17647059261798859, 0.48235294222831726, 0.48235294222831726),
            (0.18067227303981781, 0.48235294222831726, 0.48235294222831726),
            (0.18487395346164703, 0.48235294222831726, 0.48235294222831726),
            (0.18907563388347626, 0.48235294222831726, 0.48235294222831726),
            (0.19327731430530548, 0.48235294222831726, 0.48235294222831726),
            (0.1974789947271347, 0.48627451062202454, 0.48627451062202454),
            (0.20168067514896393, 0.48627451062202454, 0.48627451062202454),
            (0.20588235557079315, 0.48627451062202454, 0.48627451062202454),
            (0.21008403599262238, 0.48627451062202454, 0.48627451062202454),
            (0.2142857164144516, 0.48627451062202454, 0.48627451062202454),
            (0.21848739683628082, 0.49019607901573181, 0.49019607901573181),
            (0.22268907725811005, 0.49019607901573181, 0.49019607901573181),
            (0.22689075767993927, 0.49019607901573181, 0.49019607901573181),
            (0.23109243810176849, 0.49019607901573181, 0.49019607901573181),
            (0.23529411852359772, 0.49019607901573181, 0.49019607901573181),
            (0.23949579894542694, 0.49411764740943909, 0.49411764740943909),
            (0.24369747936725616, 0.49411764740943909, 0.49411764740943909),
            (0.24789915978908539, 0.49411764740943909, 0.49411764740943909),
            (0.25210085511207581, 0.49411764740943909, 0.49411764740943909),
            (0.25630253553390503, 0.49411764740943909, 0.49411764740943909),
            (0.26050421595573425, 0.49803921580314636, 0.49803921580314636),
            (0.26470589637756348, 0.49803921580314636, 0.49803921580314636),
            (0.2689075767993927, 0.49803921580314636, 0.49803921580314636),
            (0.27310925722122192, 0.49803921580314636, 0.49803921580314636),
            (0.27731093764305115, 0.49803921580314636, 0.49803921580314636),
            (0.28151261806488037, 0.50196081399917603, 0.50196081399917603),
            (0.28571429848670959, 0.49411764740943909, 0.49411764740943909),
            (0.28991597890853882, 0.49019607901573181, 0.49019607901573181),
            (0.29411765933036804, 0.48627451062202454, 0.48627451062202454),
            (0.29831933975219727, 0.48235294222831726, 0.48235294222831726),
            (0.30252102017402649, 0.47843137383460999, 0.47843137383460999),
            (0.30672270059585571, 0.47058823704719543, 0.47058823704719543),
            (0.31092438101768494, 0.46666666865348816, 0.46666666865348816),
            (0.31512606143951416, 0.46274510025978088, 0.46274510025978088),
            (0.31932774186134338, 0.45882353186607361, 0.45882353186607361),
            (0.32352942228317261, 0.45098039507865906, 0.45098039507865906),
            (0.32773110270500183, 0.44705882668495178, 0.44705882668495178),
            (0.33193278312683105, 0.44313725829124451, 0.44313725829124451),
            (0.33613446354866028, 0.43529412150382996, 0.43529412150382996),
            (0.3403361439704895, 0.43137255311012268, 0.43137255311012268),
            (0.34453782439231873, 0.42745098471641541, 0.42745098471641541),
            (0.34873950481414795, 0.42352941632270813, 0.42352941632270813),
            (0.35294118523597717, 0.41568627953529358, 0.41568627953529358),
            (0.3571428656578064, 0.4117647111415863, 0.4117647111415863),
            (0.36134454607963562, 0.40784314274787903, 0.40784314274787903),
            (0.36554622650146484, 0.40000000596046448, 0.40000000596046448),
            (0.36974790692329407, 0.3960784375667572, 0.3960784375667572),
            (0.37394958734512329, 0.39215686917304993, 0.39215686917304993),
            (0.37815126776695251, 0.38431373238563538, 0.38431373238563538),
            (0.38235294818878174, 0.3803921639919281, 0.3803921639919281),
            (0.38655462861061096, 0.37647059559822083, 0.37647059559822083),
            (0.39075630903244019, 0.36862745881080627, 0.36862745881080627),
            (0.39495798945426941, 0.364705890417099, 0.364705890417099),
            (0.39915966987609863, 0.36078432202339172, 0.36078432202339172),
            (0.40336135029792786, 0.35294118523597717, 0.35294118523597717),
            (0.40756303071975708, 0.3490196168422699, 0.3490196168422699),
            (0.4117647111415863, 0.34509804844856262, 0.34509804844856262),
            (0.41596639156341553, 0.33725491166114807, 0.33725491166114807),
            (0.42016807198524475, 0.3333333432674408, 0.3333333432674408),
            (0.42436975240707397, 0.32941177487373352, 0.32941177487373352),
            (0.4285714328289032, 0.32156863808631897, 0.32156863808631897),
            (0.43277311325073242, 0.31764706969261169, 0.31764706969261169),
            (0.43697479367256165, 0.31372550129890442, 0.31372550129890442),
            (0.44117647409439087, 0.30588236451148987, 0.30588236451148987),
            (0.44537815451622009, 0.30196079611778259, 0.30196079611778259),
            (0.44957983493804932, 0.29803922772407532, 0.29803922772407532),
            (0.45378151535987854, 0.29019609093666077, 0.29019609093666077),
            (0.45798319578170776, 0.28627452254295349, 0.28627452254295349),
            (0.46218487620353699, 0.27843138575553894, 0.27843138575553894),
            (0.46638655662536621, 0.27450981736183167, 0.27450981736183167),
            (0.47058823704719543, 0.27843138575553894, 0.27843138575553894),
            (0.47478991746902466, 0.28235295414924622, 0.28235295414924622),
            (0.47899159789085388, 0.28235295414924622, 0.28235295414924622),
            (0.48319327831268311, 0.28627452254295349, 0.28627452254295349),
            (0.48739495873451233, 0.28627452254295349, 0.28627452254295349),
            (0.49159663915634155, 0.29019609093666077, 0.29019609093666077),
            (0.49579831957817078, 0.29411765933036804, 0.29411765933036804),
            (0.5, 0.29411765933036804, 0.29411765933036804),
            (0.50420171022415161, 0.29803922772407532, 0.29803922772407532),
            (0.50840336084365845, 0.29803922772407532, 0.29803922772407532),
            (0.51260507106781006, 0.30196079611778259, 0.30196079611778259),
            (0.51680672168731689, 0.30196079611778259, 0.30196079611778259),
            (0.52100843191146851, 0.30588236451148987, 0.30588236451148987),
            (0.52521008253097534, 0.30980393290519714, 0.30980393290519714),
            (0.52941179275512695, 0.30980393290519714, 0.30980393290519714),
            (0.53361344337463379, 0.31372550129890442, 0.31372550129890442),
            (0.5378151535987854, 0.31372550129890442, 0.31372550129890442),
            (0.54201680421829224, 0.31764706969261169, 0.31764706969261169),
            (0.54621851444244385, 0.32156863808631897, 0.32156863808631897),
            (0.55042016506195068, 0.32156863808631897, 0.32156863808631897),
            (0.55462187528610229, 0.32156863808631897, 0.32156863808631897),
            (0.55882352590560913, 0.32549020648002625, 0.32549020648002625),
            (0.56302523612976074, 0.32549020648002625, 0.32549020648002625),
            (0.56722688674926758, 0.32549020648002625, 0.32549020648002625),
            (0.57142859697341919, 0.32941177487373352, 0.32941177487373352),
            (0.57563024759292603, 0.32941177487373352, 0.32941177487373352),
            (0.57983195781707764, 0.32941177487373352, 0.32941177487373352),
            (0.58403360843658447, 0.3333333432674408, 0.3333333432674408),
            (0.58823531866073608, 0.3333333432674408, 0.3333333432674408),
            (0.59243696928024292, 0.3333333432674408, 0.3333333432674408),
            (0.59663867950439453, 0.33725491166114807, 0.33725491166114807),
            (0.60084033012390137, 0.33725491166114807, 0.33725491166114807),
            (0.60504204034805298, 0.33725491166114807, 0.33725491166114807),
            (0.60924369096755981, 0.34117648005485535, 0.34117648005485535),
            (0.61344540119171143, 0.34117648005485535, 0.34117648005485535),
            (0.61764705181121826, 0.34117648005485535, 0.34117648005485535),
            (0.62184876203536987, 0.34509804844856262, 0.34509804844856262),
            (0.62605041265487671, 0.34509804844856262, 0.34509804844856262),
            (0.63025212287902832, 0.34509804844856262, 0.34509804844856262),
            (0.63445377349853516, 0.3490196168422699, 0.3490196168422699),
            (0.63865548372268677, 0.3490196168422699, 0.3490196168422699),
            (0.6428571343421936, 0.3490196168422699, 0.3490196168422699),
            (0.64705884456634521, 0.35294118523597717, 0.35294118523597717),
            (0.65126049518585205, 0.35294118523597717, 0.35294118523597717),
            (0.65546220541000366, 0.35294118523597717, 0.35294118523597717),
            (0.6596638560295105, 0.35686275362968445, 0.35686275362968445),
            (0.66386556625366211, 0.35686275362968445, 0.35686275362968445),
            (0.66806721687316895, 0.35686275362968445, 0.35686275362968445),
            (0.67226892709732056, 0.36078432202339172, 0.36078432202339172),
            (0.67647057771682739, 0.36078432202339172, 0.36078432202339172),
            (0.680672287940979, 0.36078432202339172, 0.36078432202339172),
            (0.68487393856048584, 0.364705890417099, 0.364705890417099),
            (0.68907564878463745, 0.364705890417099, 0.364705890417099),
            (0.69327729940414429, 0.364705890417099, 0.364705890417099),
            (0.6974790096282959, 0.36862745881080627, 0.36862745881080627),
            (0.70168066024780273, 0.36862745881080627, 0.36862745881080627),
            (0.70588237047195435, 0.36862745881080627, 0.36862745881080627),
            (0.71008402109146118, 0.37254902720451355, 0.37254902720451355),
            (0.71428573131561279, 0.37254902720451355, 0.37254902720451355),
            (0.71848738193511963, 0.37254902720451355, 0.37254902720451355),
            (0.72268909215927124, 0.37647059559822083, 0.37647059559822083),
            (0.72689074277877808, 0.37647059559822083, 0.37647059559822083),
            (0.73109245300292969, 0.3803921639919281, 0.3803921639919281),
            (0.73529410362243652, 0.3803921639919281, 0.3803921639919281),
            (0.73949581384658813, 0.3803921639919281, 0.3803921639919281),
            (0.74369746446609497, 0.38431373238563538, 0.38431373238563538),
            (0.74789917469024658, 0.38431373238563538, 0.38431373238563538),
            (0.75210082530975342, 0.38431373238563538, 0.38431373238563538),
            (0.75630253553390503, 0.38823530077934265, 0.38823530077934265),
            (0.76050418615341187, 0.38823530077934265, 0.38823530077934265),
            (0.76470589637756348, 0.38823530077934265, 0.38823530077934265),
            (0.76890754699707031, 0.39215686917304993, 0.39215686917304993),
            (0.77310925722122192, 0.39215686917304993, 0.39215686917304993),
            (0.77731090784072876, 0.39215686917304993, 0.39215686917304993),
            (0.78151261806488037, 0.3960784375667572, 0.3960784375667572),
            (0.78571426868438721, 0.3960784375667572, 0.3960784375667572),
            (0.78991597890853882, 0.40784314274787903, 0.40784314274787903),
            (0.79411762952804565, 0.41568627953529358, 0.41568627953529358),
            (0.79831933975219727, 0.42352941632270813, 0.42352941632270813),
            (0.8025209903717041, 0.43529412150382996, 0.43529412150382996),
            (0.80672270059585571, 0.44313725829124451, 0.44313725829124451),
            (0.81092435121536255, 0.45490196347236633, 0.45490196347236633),
            (0.81512606143951416, 0.46274510025978088, 0.46274510025978088),
            (0.819327712059021, 0.47450980544090271, 0.47450980544090271),
            (0.82352942228317261, 0.48235294222831726, 0.48235294222831726),
            (0.82773107290267944, 0.49411764740943909, 0.49411764740943909),
            (0.83193278312683105, 0.5058823823928833, 0.5058823823928833),
            (0.83613443374633789, 0.51372551918029785, 0.51372551918029785),
            (0.8403361439704895, 0.52549022436141968, 0.52549022436141968),
            (0.84453779458999634, 0.5372549295425415, 0.5372549295425415),
            (0.84873950481414795, 0.54509806632995605, 0.54509806632995605),
            (0.85294115543365479, 0.55686277151107788, 0.55686277151107788),
            (0.8571428656578064, 0.56862747669219971, 0.56862747669219971),
            (0.86134451627731323, 0.58039218187332153, 0.58039218187332153),
            (0.86554622650146484, 0.58823531866073608, 0.58823531866073608),
            (0.86974787712097168, 0.60000002384185791, 0.60000002384185791),
            (0.87394958734512329, 0.61176472902297974, 0.61176472902297974),
            (0.87815123796463013, 0.62352943420410156, 0.62352943420410156),
            (0.88235294818878174, 0.63529413938522339, 0.63529413938522339),
            (0.88655459880828857, 0.64705884456634521, 0.64705884456634521),
            (0.89075630903244019, 0.65882354974746704, 0.65882354974746704),
            (0.89495795965194702, 0.66666668653488159, 0.66666668653488159),
            (0.89915966987609863, 0.67843139171600342, 0.67843139171600342),
            (0.90336132049560547, 0.69019609689712524, 0.69019609689712524),
            (0.90756303071975708, 0.70196080207824707, 0.70196080207824707),
            (0.91176468133926392, 0.7137255072593689, 0.7137255072593689),
            (0.91596639156341553, 0.72549021244049072, 0.72549021244049072),
            (0.92016804218292236, 0.74117648601531982, 0.74117648601531982),
            (0.92436975240707397, 0.75294119119644165, 0.75294119119644165),
            (0.92857140302658081, 0.76470589637756348, 0.76470589637756348),
            (0.93277311325073242, 0.7764706015586853, 0.7764706015586853),
            (0.93697476387023926, 0.78823530673980713, 0.78823530673980713),
            (0.94117647409439087, 0.80000001192092896, 0.80000001192092896),
            (0.94537812471389771, 0.81176471710205078, 0.81176471710205078),
            (0.94957983493804932, 0.82745099067687988, 0.82745099067687988),
            (0.95378148555755615, 0.83921569585800171, 0.83921569585800171),
            (0.95798319578170776, 0.85098040103912354, 0.85098040103912354),
            (0.9621848464012146, 0.86274510622024536, 0.86274510622024536),
            (0.96638655662536621, 0.87843137979507446, 0.87843137979507446),
            (0.97058820724487305, 0.89019608497619629, 0.89019608497619629),
            (0.97478991746902466, 0.90196079015731812, 0.90196079015731812),
            (0.97899156808853149, 0.91764706373214722, 0.91764706373214722),
            (0.98319327831268311, 0.92941176891326904, 0.92941176891326904),
            (0.98739492893218994, 0.94509804248809814, 0.94509804248809814),
            (0.99159663915634155, 0.95686274766921997, 0.95686274766921997),
            (0.99579828977584839, 0.97254902124404907, 0.97254902124404907),
            (1.0, 0.9843137264251709, 0.9843137264251709)],
    )
    return ColorMapper.from_segment_map(_data, range=range, **traits)

def gist_gray(range, **traits):
    """ Generator for the 'gist_gray' colormap from GIST.
    """
    _data = dict(
        red = [(0.0, 0.0, 0.0),
            (0.0042016808874905109, 0.0039215688593685627, 0.0039215688593685627),
            (0.0084033617749810219, 0.0078431377187371254, 0.0078431377187371254),
            (0.012605042196810246, 0.011764706112444401, 0.011764706112444401),
            (0.016806723549962044, 0.015686275437474251, 0.015686275437474251),
            (0.021008403971791267, 0.019607843831181526, 0.019607843831181526),
            (0.025210084393620491, 0.023529412224888802, 0.023529412224888802),
            (0.029411764815449715, 0.027450980618596077, 0.027450980618596077),
            (0.033613447099924088, 0.035294119268655777, 0.035294119268655777),
            (0.037815127521753311, 0.039215687662363052, 0.039215687662363052),
            (0.042016807943582535, 0.043137256056070328, 0.043137256056070328),
            (0.046218488365411758, 0.047058824449777603, 0.047058824449777603),
            (0.050420168787240982, 0.050980392843484879, 0.050980392843484879),
            (0.054621849209070206, 0.054901961237192154, 0.054901961237192154),
            (0.058823529630899429, 0.058823529630899429, 0.058823529630899429),
            (0.063025213778018951, 0.062745101749897003, 0.062745101749897003),
            (0.067226894199848175, 0.066666670143604279, 0.066666670143604279),
            (0.071428574621677399, 0.070588238537311554, 0.070588238537311554),
            (0.075630255043506622, 0.074509806931018829, 0.074509806931018829),
            (0.079831935465335846, 0.078431375324726105, 0.078431375324726105),
            (0.08403361588716507, 0.08235294371843338, 0.08235294371843338),
            (0.088235296308994293, 0.086274512112140656, 0.086274512112140656),
            (0.092436976730823517, 0.090196080505847931, 0.090196080505847931),
            (0.09663865715265274, 0.098039217293262482, 0.098039217293262482),
            (0.10084033757448196, 0.10196078568696976, 0.10196078568696976),
            (0.10504201799631119, 0.10588235408067703, 0.10588235408067703),
            (0.10924369841814041, 0.10980392247438431, 0.10980392247438431),
            (0.11344537883996964, 0.11372549086809158, 0.11372549086809158),
            (0.11764705926179886, 0.11764705926179886, 0.11764705926179886),
            (0.12184873968362808, 0.12156862765550613, 0.12156862765550613),
            (0.1260504275560379, 0.12549020349979401, 0.12549020349979401),
            (0.13025210797786713, 0.12941177189350128, 0.12941177189350128),
            (0.13445378839969635, 0.13333334028720856, 0.13333334028720856),
            (0.13865546882152557, 0.13725490868091583, 0.13725490868091583),
            (0.1428571492433548, 0.14117647707462311, 0.14117647707462311),
            (0.14705882966518402, 0.14509804546833038, 0.14509804546833038),
            (0.15126051008701324, 0.14901961386203766, 0.14901961386203766),
            (0.15546219050884247, 0.15294118225574493, 0.15294118225574493),
            (0.15966387093067169, 0.16078431904315948, 0.16078431904315948),
            (0.16386555135250092, 0.16470588743686676, 0.16470588743686676),
            (0.16806723177433014, 0.16862745583057404, 0.16862745583057404),
            (0.17226891219615936, 0.17254902422428131, 0.17254902422428131),
            (0.17647059261798859, 0.17647059261798859, 0.17647059261798859),
            (0.18067227303981781, 0.18039216101169586, 0.18039216101169586),
            (0.18487395346164703, 0.18431372940540314, 0.18431372940540314),
            (0.18907563388347626, 0.18823529779911041, 0.18823529779911041),
            (0.19327731430530548, 0.19215686619281769, 0.19215686619281769),
            (0.1974789947271347, 0.19607843458652496, 0.19607843458652496),
            (0.20168067514896393, 0.20000000298023224, 0.20000000298023224),
            (0.20588235557079315, 0.20392157137393951, 0.20392157137393951),
            (0.21008403599262238, 0.20784313976764679, 0.20784313976764679),
            (0.2142857164144516, 0.21176470816135406, 0.21176470816135406),
            (0.21848739683628082, 0.21568627655506134, 0.21568627655506134),
            (0.22268907725811005, 0.22352941334247589, 0.22352941334247589),
            (0.22689075767993927, 0.22745098173618317, 0.22745098173618317),
            (0.23109243810176849, 0.23137255012989044, 0.23137255012989044),
            (0.23529411852359772, 0.23529411852359772, 0.23529411852359772),
            (0.23949579894542694, 0.23921568691730499, 0.23921568691730499),
            (0.24369747936725616, 0.24313725531101227, 0.24313725531101227),
            (0.24789915978908539, 0.24705882370471954, 0.24705882370471954),
            (0.25210085511207581, 0.25098040699958801, 0.25098040699958801),
            (0.25630253553390503, 0.25490197539329529, 0.25490197539329529),
            (0.26050421595573425, 0.25882354378700256, 0.25882354378700256),
            (0.26470589637756348, 0.26274511218070984, 0.26274511218070984),
            (0.2689075767993927, 0.26666668057441711, 0.26666668057441711),
            (0.27310925722122192, 0.27058824896812439, 0.27058824896812439),
            (0.27731093764305115, 0.27450981736183167, 0.27450981736183167),
            (0.28151261806488037, 0.27843138575553894, 0.27843138575553894),
            (0.28571429848670959, 0.28627452254295349, 0.28627452254295349),
            (0.28991597890853882, 0.29019609093666077, 0.29019609093666077),
            (0.29411765933036804, 0.29411765933036804, 0.29411765933036804),
            (0.29831933975219727, 0.29803922772407532, 0.29803922772407532),
            (0.30252102017402649, 0.30196079611778259, 0.30196079611778259),
            (0.30672270059585571, 0.30588236451148987, 0.30588236451148987),
            (0.31092438101768494, 0.30980393290519714, 0.30980393290519714),
            (0.31512606143951416, 0.31372550129890442, 0.31372550129890442),
            (0.31932774186134338, 0.31764706969261169, 0.31764706969261169),
            (0.32352942228317261, 0.32156863808631897, 0.32156863808631897),
            (0.32773110270500183, 0.32549020648002625, 0.32549020648002625),
            (0.33193278312683105, 0.32941177487373352, 0.32941177487373352),
            (0.33613446354866028, 0.3333333432674408, 0.3333333432674408),
            (0.3403361439704895, 0.33725491166114807, 0.33725491166114807),
            (0.34453782439231873, 0.34117648005485535, 0.34117648005485535),
            (0.34873950481414795, 0.3490196168422699, 0.3490196168422699),
            (0.35294118523597717, 0.35294118523597717, 0.35294118523597717),
            (0.3571428656578064, 0.35686275362968445, 0.35686275362968445),
            (0.36134454607963562, 0.36078432202339172, 0.36078432202339172),
            (0.36554622650146484, 0.364705890417099, 0.364705890417099),
            (0.36974790692329407, 0.36862745881080627, 0.36862745881080627),
            (0.37394958734512329, 0.37254902720451355, 0.37254902720451355),
            (0.37815126776695251, 0.37647059559822083, 0.37647059559822083),
            (0.38235294818878174, 0.3803921639919281, 0.3803921639919281),
            (0.38655462861061096, 0.38431373238563538, 0.38431373238563538),
            (0.39075630903244019, 0.38823530077934265, 0.38823530077934265),
            (0.39495798945426941, 0.39215686917304993, 0.39215686917304993),
            (0.39915966987609863, 0.3960784375667572, 0.3960784375667572),
            (0.40336135029792786, 0.40000000596046448, 0.40000000596046448),
            (0.40756303071975708, 0.40392157435417175, 0.40392157435417175),
            (0.4117647111415863, 0.4117647111415863, 0.4117647111415863),
            (0.41596639156341553, 0.41568627953529358, 0.41568627953529358),
            (0.42016807198524475, 0.41960784792900085, 0.41960784792900085),
            (0.42436975240707397, 0.42352941632270813, 0.42352941632270813),
            (0.4285714328289032, 0.42745098471641541, 0.42745098471641541),
            (0.43277311325073242, 0.43137255311012268, 0.43137255311012268),
            (0.43697479367256165, 0.43529412150382996, 0.43529412150382996),
            (0.44117647409439087, 0.43921568989753723, 0.43921568989753723),
            (0.44537815451622009, 0.44313725829124451, 0.44313725829124451),
            (0.44957983493804932, 0.44705882668495178, 0.44705882668495178),
            (0.45378151535987854, 0.45098039507865906, 0.45098039507865906),
            (0.45798319578170776, 0.45490196347236633, 0.45490196347236633),
            (0.46218487620353699, 0.45882353186607361, 0.45882353186607361),
            (0.46638655662536621, 0.46274510025978088, 0.46274510025978088),
            (0.47058823704719543, 0.46666666865348816, 0.46666666865348816),
            (0.47478991746902466, 0.47450980544090271, 0.47450980544090271),
            (0.47899159789085388, 0.47843137383460999, 0.47843137383460999),
            (0.48319327831268311, 0.48235294222831726, 0.48235294222831726),
            (0.48739495873451233, 0.48627451062202454, 0.48627451062202454),
            (0.49159663915634155, 0.49019607901573181, 0.49019607901573181),
            (0.49579831957817078, 0.49411764740943909, 0.49411764740943909),
            (0.5, 0.49803921580314636, 0.49803921580314636),
            (0.50420171022415161, 0.50196081399917603, 0.50196081399917603),
            (0.50840336084365845, 0.5058823823928833, 0.5058823823928833),
            (0.51260507106781006, 0.50980395078659058, 0.50980395078659058),
            (0.51680672168731689, 0.51372551918029785, 0.51372551918029785),
            (0.52100843191146851, 0.51764708757400513, 0.51764708757400513),
            (0.52521008253097534, 0.5215686559677124, 0.5215686559677124),
            (0.52941179275512695, 0.52549022436141968, 0.52549022436141968),
            (0.53361344337463379, 0.52941179275512695, 0.52941179275512695),
            (0.5378151535987854, 0.5372549295425415, 0.5372549295425415),
            (0.54201680421829224, 0.54117649793624878, 0.54117649793624878),
            (0.54621851444244385, 0.54509806632995605, 0.54509806632995605),
            (0.55042016506195068, 0.54901963472366333, 0.54901963472366333),
            (0.55462187528610229, 0.55294120311737061, 0.55294120311737061),
            (0.55882352590560913, 0.55686277151107788, 0.55686277151107788),
            (0.56302523612976074, 0.56078433990478516, 0.56078433990478516),
            (0.56722688674926758, 0.56470590829849243, 0.56470590829849243),
            (0.57142859697341919, 0.56862747669219971, 0.56862747669219971),
            (0.57563024759292603, 0.57254904508590698, 0.57254904508590698),
            (0.57983195781707764, 0.57647061347961426, 0.57647061347961426),
            (0.58403360843658447, 0.58039218187332153, 0.58039218187332153),
            (0.58823531866073608, 0.58431375026702881, 0.58431375026702881),
            (0.59243696928024292, 0.58823531866073608, 0.58823531866073608),
            (0.59663867950439453, 0.59215688705444336, 0.59215688705444336),
            (0.60084033012390137, 0.60000002384185791, 0.60000002384185791),
            (0.60504204034805298, 0.60392159223556519, 0.60392159223556519),
            (0.60924369096755981, 0.60784316062927246, 0.60784316062927246),
            (0.61344540119171143, 0.61176472902297974, 0.61176472902297974),
            (0.61764705181121826, 0.61568629741668701, 0.61568629741668701),
            (0.62184876203536987, 0.61960786581039429, 0.61960786581039429),
            (0.62605041265487671, 0.62352943420410156, 0.62352943420410156),
            (0.63025212287902832, 0.62745100259780884, 0.62745100259780884),
            (0.63445377349853516, 0.63137257099151611, 0.63137257099151611),
            (0.63865548372268677, 0.63529413938522339, 0.63529413938522339),
            (0.6428571343421936, 0.63921570777893066, 0.63921570777893066),
            (0.64705884456634521, 0.64313727617263794, 0.64313727617263794),
            (0.65126049518585205, 0.64705884456634521, 0.64705884456634521),
            (0.65546220541000366, 0.65098041296005249, 0.65098041296005249),
            (0.6596638560295105, 0.65490198135375977, 0.65490198135375977),
            (0.66386556625366211, 0.66274511814117432, 0.66274511814117432),
            (0.66806721687316895, 0.66666668653488159, 0.66666668653488159),
            (0.67226892709732056, 0.67058825492858887, 0.67058825492858887),
            (0.67647057771682739, 0.67450982332229614, 0.67450982332229614),
            (0.680672287940979, 0.67843139171600342, 0.67843139171600342),
            (0.68487393856048584, 0.68235296010971069, 0.68235296010971069),
            (0.68907564878463745, 0.68627452850341797, 0.68627452850341797),
            (0.69327729940414429, 0.69019609689712524, 0.69019609689712524),
            (0.6974790096282959, 0.69411766529083252, 0.69411766529083252),
            (0.70168066024780273, 0.69803923368453979, 0.69803923368453979),
            (0.70588237047195435, 0.70196080207824707, 0.70196080207824707),
            (0.71008402109146118, 0.70588237047195435, 0.70588237047195435),
            (0.71428573131561279, 0.70980393886566162, 0.70980393886566162),
            (0.71848738193511963, 0.7137255072593689, 0.7137255072593689),
            (0.72268909215927124, 0.71764707565307617, 0.71764707565307617),
            (0.72689074277877808, 0.72549021244049072, 0.72549021244049072),
            (0.73109245300292969, 0.729411780834198, 0.729411780834198),
            (0.73529410362243652, 0.73333334922790527, 0.73333334922790527),
            (0.73949581384658813, 0.73725491762161255, 0.73725491762161255),
            (0.74369746446609497, 0.74117648601531982, 0.74117648601531982),
            (0.74789917469024658, 0.7450980544090271, 0.7450980544090271),
            (0.75210082530975342, 0.74901962280273438, 0.74901962280273438),
            (0.75630253553390503, 0.75294119119644165, 0.75294119119644165),
            (0.76050418615341187, 0.75686275959014893, 0.75686275959014893),
            (0.76470589637756348, 0.7607843279838562, 0.7607843279838562),
            (0.76890754699707031, 0.76470589637756348, 0.76470589637756348),
            (0.77310925722122192, 0.76862746477127075, 0.76862746477127075),
            (0.77731090784072876, 0.77254903316497803, 0.77254903316497803),
            (0.78151261806488037, 0.7764706015586853, 0.7764706015586853),
            (0.78571426868438721, 0.78039216995239258, 0.78039216995239258),
            (0.78991597890853882, 0.78823530673980713, 0.78823530673980713),
            (0.79411762952804565, 0.7921568751335144, 0.7921568751335144),
            (0.79831933975219727, 0.79607844352722168, 0.79607844352722168),
            (0.8025209903717041, 0.80000001192092896, 0.80000001192092896),
            (0.80672270059585571, 0.80392158031463623, 0.80392158031463623),
            (0.81092435121536255, 0.80784314870834351, 0.80784314870834351),
            (0.81512606143951416, 0.81176471710205078, 0.81176471710205078),
            (0.819327712059021, 0.81568628549575806, 0.81568628549575806),
            (0.82352942228317261, 0.81960785388946533, 0.81960785388946533),
            (0.82773107290267944, 0.82352942228317261, 0.82352942228317261),
            (0.83193278312683105, 0.82745099067687988, 0.82745099067687988),
            (0.83613443374633789, 0.83137255907058716, 0.83137255907058716),
            (0.8403361439704895, 0.83529412746429443, 0.83529412746429443),
            (0.84453779458999634, 0.83921569585800171, 0.83921569585800171),
            (0.84873950481414795, 0.84313726425170898, 0.84313726425170898),
            (0.85294115543365479, 0.85098040103912354, 0.85098040103912354),
            (0.8571428656578064, 0.85490196943283081, 0.85490196943283081),
            (0.86134451627731323, 0.85882353782653809, 0.85882353782653809),
            (0.86554622650146484, 0.86274510622024536, 0.86274510622024536),
            (0.86974787712097168, 0.86666667461395264, 0.86666667461395264),
            (0.87394958734512329, 0.87058824300765991, 0.87058824300765991),
            (0.87815123796463013, 0.87450981140136719, 0.87450981140136719),
            (0.88235294818878174, 0.87843137979507446, 0.87843137979507446),
            (0.88655459880828857, 0.88235294818878174, 0.88235294818878174),
            (0.89075630903244019, 0.88627451658248901, 0.88627451658248901),
            (0.89495795965194702, 0.89019608497619629, 0.89019608497619629),
            (0.89915966987609863, 0.89411765336990356, 0.89411765336990356),
            (0.90336132049560547, 0.89803922176361084, 0.89803922176361084),
            (0.90756303071975708, 0.90196079015731812, 0.90196079015731812),
            (0.91176468133926392, 0.90588235855102539, 0.90588235855102539),
            (0.91596639156341553, 0.91372549533843994, 0.91372549533843994),
            (0.92016804218292236, 0.91764706373214722, 0.91764706373214722),
            (0.92436975240707397, 0.92156863212585449, 0.92156863212585449),
            (0.92857140302658081, 0.92549020051956177, 0.92549020051956177),
            (0.93277311325073242, 0.92941176891326904, 0.92941176891326904),
            (0.93697476387023926, 0.93333333730697632, 0.93333333730697632),
            (0.94117647409439087, 0.93725490570068359, 0.93725490570068359),
            (0.94537812471389771, 0.94117647409439087, 0.94117647409439087),
            (0.94957983493804932, 0.94509804248809814, 0.94509804248809814),
            (0.95378148555755615, 0.94901961088180542, 0.94901961088180542),
            (0.95798319578170776, 0.9529411792755127, 0.9529411792755127),
            (0.9621848464012146, 0.95686274766921997, 0.95686274766921997),
            (0.96638655662536621, 0.96078431606292725, 0.96078431606292725),
            (0.97058820724487305, 0.96470588445663452, 0.96470588445663452),
            (0.97478991746902466, 0.9686274528503418, 0.9686274528503418),
            (0.97899156808853149, 0.97647058963775635, 0.97647058963775635),
            (0.98319327831268311, 0.98039215803146362, 0.98039215803146362),
            (0.98739492893218994, 0.9843137264251709, 0.9843137264251709),
            (0.99159663915634155, 0.98823529481887817, 0.98823529481887817),
            (0.99579828977584839, 0.99215686321258545, 0.99215686321258545),
            (1.0, 0.99607843160629272, 0.99607843160629272)],
        green = [(0.0, 0.0, 0.0),
            (0.0042016808874905109, 0.0039215688593685627, 0.0039215688593685627),
            (0.0084033617749810219, 0.0078431377187371254, 0.0078431377187371254),
            (0.012605042196810246, 0.011764706112444401, 0.011764706112444401),
            (0.016806723549962044, 0.015686275437474251, 0.015686275437474251),
            (0.021008403971791267, 0.019607843831181526, 0.019607843831181526),
            (0.025210084393620491, 0.023529412224888802, 0.023529412224888802),
            (0.029411764815449715, 0.027450980618596077, 0.027450980618596077),
            (0.033613447099924088, 0.035294119268655777, 0.035294119268655777),
            (0.037815127521753311, 0.039215687662363052, 0.039215687662363052),
            (0.042016807943582535, 0.043137256056070328, 0.043137256056070328),
            (0.046218488365411758, 0.047058824449777603, 0.047058824449777603),
            (0.050420168787240982, 0.050980392843484879, 0.050980392843484879),
            (0.054621849209070206, 0.054901961237192154, 0.054901961237192154),
            (0.058823529630899429, 0.058823529630899429, 0.058823529630899429),
            (0.063025213778018951, 0.062745101749897003, 0.062745101749897003),
            (0.067226894199848175, 0.066666670143604279, 0.066666670143604279),
            (0.071428574621677399, 0.070588238537311554, 0.070588238537311554),
            (0.075630255043506622, 0.074509806931018829, 0.074509806931018829),
            (0.079831935465335846, 0.078431375324726105, 0.078431375324726105),
            (0.08403361588716507, 0.08235294371843338, 0.08235294371843338),
            (0.088235296308994293, 0.086274512112140656, 0.086274512112140656),
            (0.092436976730823517, 0.090196080505847931, 0.090196080505847931),
            (0.09663865715265274, 0.098039217293262482, 0.098039217293262482),
            (0.10084033757448196, 0.10196078568696976, 0.10196078568696976),
            (0.10504201799631119, 0.10588235408067703, 0.10588235408067703),
            (0.10924369841814041, 0.10980392247438431, 0.10980392247438431),
            (0.11344537883996964, 0.11372549086809158, 0.11372549086809158),
            (0.11764705926179886, 0.11764705926179886, 0.11764705926179886),
            (0.12184873968362808, 0.12156862765550613, 0.12156862765550613),
            (0.1260504275560379, 0.12549020349979401, 0.12549020349979401),
            (0.13025210797786713, 0.12941177189350128, 0.12941177189350128),
            (0.13445378839969635, 0.13333334028720856, 0.13333334028720856),
            (0.13865546882152557, 0.13725490868091583, 0.13725490868091583),
            (0.1428571492433548, 0.14117647707462311, 0.14117647707462311),
            (0.14705882966518402, 0.14509804546833038, 0.14509804546833038),
            (0.15126051008701324, 0.14901961386203766, 0.14901961386203766),
            (0.15546219050884247, 0.15294118225574493, 0.15294118225574493),
            (0.15966387093067169, 0.16078431904315948, 0.16078431904315948),
            (0.16386555135250092, 0.16470588743686676, 0.16470588743686676),
            (0.16806723177433014, 0.16862745583057404, 0.16862745583057404),
            (0.17226891219615936, 0.17254902422428131, 0.17254902422428131),
            (0.17647059261798859, 0.17647059261798859, 0.17647059261798859),
            (0.18067227303981781, 0.18039216101169586, 0.18039216101169586),
            (0.18487395346164703, 0.18431372940540314, 0.18431372940540314),
            (0.18907563388347626, 0.18823529779911041, 0.18823529779911041),
            (0.19327731430530548, 0.19215686619281769, 0.19215686619281769),
            (0.1974789947271347, 0.19607843458652496, 0.19607843458652496),
            (0.20168067514896393, 0.20000000298023224, 0.20000000298023224),
            (0.20588235557079315, 0.20392157137393951, 0.20392157137393951),
            (0.21008403599262238, 0.20784313976764679, 0.20784313976764679),
            (0.2142857164144516, 0.21176470816135406, 0.21176470816135406),
            (0.21848739683628082, 0.21568627655506134, 0.21568627655506134),
            (0.22268907725811005, 0.22352941334247589, 0.22352941334247589),
            (0.22689075767993927, 0.22745098173618317, 0.22745098173618317),
            (0.23109243810176849, 0.23137255012989044, 0.23137255012989044),
            (0.23529411852359772, 0.23529411852359772, 0.23529411852359772),
            (0.23949579894542694, 0.23921568691730499, 0.23921568691730499),
            (0.24369747936725616, 0.24313725531101227, 0.24313725531101227),
            (0.24789915978908539, 0.24705882370471954, 0.24705882370471954),
            (0.25210085511207581, 0.25098040699958801, 0.25098040699958801),
            (0.25630253553390503, 0.25490197539329529, 0.25490197539329529),
            (0.26050421595573425, 0.25882354378700256, 0.25882354378700256),
            (0.26470589637756348, 0.26274511218070984, 0.26274511218070984),
            (0.2689075767993927, 0.26666668057441711, 0.26666668057441711),
            (0.27310925722122192, 0.27058824896812439, 0.27058824896812439),
            (0.27731093764305115, 0.27450981736183167, 0.27450981736183167),
            (0.28151261806488037, 0.27843138575553894, 0.27843138575553894),
            (0.28571429848670959, 0.28627452254295349, 0.28627452254295349),
            (0.28991597890853882, 0.29019609093666077, 0.29019609093666077),
            (0.29411765933036804, 0.29411765933036804, 0.29411765933036804),
            (0.29831933975219727, 0.29803922772407532, 0.29803922772407532),
            (0.30252102017402649, 0.30196079611778259, 0.30196079611778259),
            (0.30672270059585571, 0.30588236451148987, 0.30588236451148987),
            (0.31092438101768494, 0.30980393290519714, 0.30980393290519714),
            (0.31512606143951416, 0.31372550129890442, 0.31372550129890442),
            (0.31932774186134338, 0.31764706969261169, 0.31764706969261169),
            (0.32352942228317261, 0.32156863808631897, 0.32156863808631897),
            (0.32773110270500183, 0.32549020648002625, 0.32549020648002625),
            (0.33193278312683105, 0.32941177487373352, 0.32941177487373352),
            (0.33613446354866028, 0.3333333432674408, 0.3333333432674408),
            (0.3403361439704895, 0.33725491166114807, 0.33725491166114807),
            (0.34453782439231873, 0.34117648005485535, 0.34117648005485535),
            (0.34873950481414795, 0.3490196168422699, 0.3490196168422699),
            (0.35294118523597717, 0.35294118523597717, 0.35294118523597717),
            (0.3571428656578064, 0.35686275362968445, 0.35686275362968445),
            (0.36134454607963562, 0.36078432202339172, 0.36078432202339172),
            (0.36554622650146484, 0.364705890417099, 0.364705890417099),
            (0.36974790692329407, 0.36862745881080627, 0.36862745881080627),
            (0.37394958734512329, 0.37254902720451355, 0.37254902720451355),
            (0.37815126776695251, 0.37647059559822083, 0.37647059559822083),
            (0.38235294818878174, 0.3803921639919281, 0.3803921639919281),
            (0.38655462861061096, 0.38431373238563538, 0.38431373238563538),
            (0.39075630903244019, 0.38823530077934265, 0.38823530077934265),
            (0.39495798945426941, 0.39215686917304993, 0.39215686917304993),
            (0.39915966987609863, 0.3960784375667572, 0.3960784375667572),
            (0.40336135029792786, 0.40000000596046448, 0.40000000596046448),
            (0.40756303071975708, 0.40392157435417175, 0.40392157435417175),
            (0.4117647111415863, 0.4117647111415863, 0.4117647111415863),
            (0.41596639156341553, 0.41568627953529358, 0.41568627953529358),
            (0.42016807198524475, 0.41960784792900085, 0.41960784792900085),
            (0.42436975240707397, 0.42352941632270813, 0.42352941632270813),
            (0.4285714328289032, 0.42745098471641541, 0.42745098471641541),
            (0.43277311325073242, 0.43137255311012268, 0.43137255311012268),
            (0.43697479367256165, 0.43529412150382996, 0.43529412150382996),
            (0.44117647409439087, 0.43921568989753723, 0.43921568989753723),
            (0.44537815451622009, 0.44313725829124451, 0.44313725829124451),
            (0.44957983493804932, 0.44705882668495178, 0.44705882668495178),
            (0.45378151535987854, 0.45098039507865906, 0.45098039507865906),
            (0.45798319578170776, 0.45490196347236633, 0.45490196347236633),
            (0.46218487620353699, 0.45882353186607361, 0.45882353186607361),
            (0.46638655662536621, 0.46274510025978088, 0.46274510025978088),
            (0.47058823704719543, 0.46666666865348816, 0.46666666865348816),
            (0.47478991746902466, 0.47450980544090271, 0.47450980544090271),
            (0.47899159789085388, 0.47843137383460999, 0.47843137383460999),
            (0.48319327831268311, 0.48235294222831726, 0.48235294222831726),
            (0.48739495873451233, 0.48627451062202454, 0.48627451062202454),
            (0.49159663915634155, 0.49019607901573181, 0.49019607901573181),
            (0.49579831957817078, 0.49411764740943909, 0.49411764740943909),
            (0.5, 0.49803921580314636, 0.49803921580314636),
            (0.50420171022415161, 0.50196081399917603, 0.50196081399917603),
            (0.50840336084365845, 0.5058823823928833, 0.5058823823928833),
            (0.51260507106781006, 0.50980395078659058, 0.50980395078659058),
            (0.51680672168731689, 0.51372551918029785, 0.51372551918029785),
            (0.52100843191146851, 0.51764708757400513, 0.51764708757400513),
            (0.52521008253097534, 0.5215686559677124, 0.5215686559677124),
            (0.52941179275512695, 0.52549022436141968, 0.52549022436141968),
            (0.53361344337463379, 0.52941179275512695, 0.52941179275512695),
            (0.5378151535987854, 0.5372549295425415, 0.5372549295425415),
            (0.54201680421829224, 0.54117649793624878, 0.54117649793624878),
            (0.54621851444244385, 0.54509806632995605, 0.54509806632995605),
            (0.55042016506195068, 0.54901963472366333, 0.54901963472366333),
            (0.55462187528610229, 0.55294120311737061, 0.55294120311737061),
            (0.55882352590560913, 0.55686277151107788, 0.55686277151107788),
            (0.56302523612976074, 0.56078433990478516, 0.56078433990478516),
            (0.56722688674926758, 0.56470590829849243, 0.56470590829849243),
            (0.57142859697341919, 0.56862747669219971, 0.56862747669219971),
            (0.57563024759292603, 0.57254904508590698, 0.57254904508590698),
            (0.57983195781707764, 0.57647061347961426, 0.57647061347961426),
            (0.58403360843658447, 0.58039218187332153, 0.58039218187332153),
            (0.58823531866073608, 0.58431375026702881, 0.58431375026702881),
            (0.59243696928024292, 0.58823531866073608, 0.58823531866073608),
            (0.59663867950439453, 0.59215688705444336, 0.59215688705444336),
            (0.60084033012390137, 0.60000002384185791, 0.60000002384185791),
            (0.60504204034805298, 0.60392159223556519, 0.60392159223556519),
            (0.60924369096755981, 0.60784316062927246, 0.60784316062927246),
            (0.61344540119171143, 0.61176472902297974, 0.61176472902297974),
            (0.61764705181121826, 0.61568629741668701, 0.61568629741668701),
            (0.62184876203536987, 0.61960786581039429, 0.61960786581039429),
            (0.62605041265487671, 0.62352943420410156, 0.62352943420410156),
            (0.63025212287902832, 0.62745100259780884, 0.62745100259780884),
            (0.63445377349853516, 0.63137257099151611, 0.63137257099151611),
            (0.63865548372268677, 0.63529413938522339, 0.63529413938522339),
            (0.6428571343421936, 0.63921570777893066, 0.63921570777893066),
            (0.64705884456634521, 0.64313727617263794, 0.64313727617263794),
            (0.65126049518585205, 0.64705884456634521, 0.64705884456634521),
            (0.65546220541000366, 0.65098041296005249, 0.65098041296005249),
            (0.6596638560295105, 0.65490198135375977, 0.65490198135375977),
            (0.66386556625366211, 0.66274511814117432, 0.66274511814117432),
            (0.66806721687316895, 0.66666668653488159, 0.66666668653488159),
            (0.67226892709732056, 0.67058825492858887, 0.67058825492858887),
            (0.67647057771682739, 0.67450982332229614, 0.67450982332229614),
            (0.680672287940979, 0.67843139171600342, 0.67843139171600342),
            (0.68487393856048584, 0.68235296010971069, 0.68235296010971069),
            (0.68907564878463745, 0.68627452850341797, 0.68627452850341797),
            (0.69327729940414429, 0.69019609689712524, 0.69019609689712524),
            (0.6974790096282959, 0.69411766529083252, 0.69411766529083252),
            (0.70168066024780273, 0.69803923368453979, 0.69803923368453979),
            (0.70588237047195435, 0.70196080207824707, 0.70196080207824707),
            (0.71008402109146118, 0.70588237047195435, 0.70588237047195435),
            (0.71428573131561279, 0.70980393886566162, 0.70980393886566162),
            (0.71848738193511963, 0.7137255072593689, 0.7137255072593689),
            (0.72268909215927124, 0.71764707565307617, 0.71764707565307617),
            (0.72689074277877808, 0.72549021244049072, 0.72549021244049072),
            (0.73109245300292969, 0.729411780834198, 0.729411780834198),
            (0.73529410362243652, 0.73333334922790527, 0.73333334922790527),
            (0.73949581384658813, 0.73725491762161255, 0.73725491762161255),
            (0.74369746446609497, 0.74117648601531982, 0.74117648601531982),
            (0.74789917469024658, 0.7450980544090271, 0.7450980544090271),
            (0.75210082530975342, 0.74901962280273438, 0.74901962280273438),
            (0.75630253553390503, 0.75294119119644165, 0.75294119119644165),
            (0.76050418615341187, 0.75686275959014893, 0.75686275959014893),
            (0.76470589637756348, 0.7607843279838562, 0.7607843279838562),
            (0.76890754699707031, 0.76470589637756348, 0.76470589637756348),
            (0.77310925722122192, 0.76862746477127075, 0.76862746477127075),
            (0.77731090784072876, 0.77254903316497803, 0.77254903316497803),
            (0.78151261806488037, 0.7764706015586853, 0.7764706015586853),
            (0.78571426868438721, 0.78039216995239258, 0.78039216995239258),
            (0.78991597890853882, 0.78823530673980713, 0.78823530673980713),
            (0.79411762952804565, 0.7921568751335144, 0.7921568751335144),
            (0.79831933975219727, 0.79607844352722168, 0.79607844352722168),
            (0.8025209903717041, 0.80000001192092896, 0.80000001192092896),
            (0.80672270059585571, 0.80392158031463623, 0.80392158031463623),
            (0.81092435121536255, 0.80784314870834351, 0.80784314870834351),
            (0.81512606143951416, 0.81176471710205078, 0.81176471710205078),
            (0.819327712059021, 0.81568628549575806, 0.81568628549575806),
            (0.82352942228317261, 0.81960785388946533, 0.81960785388946533),
            (0.82773107290267944, 0.82352942228317261, 0.82352942228317261),
            (0.83193278312683105, 0.82745099067687988, 0.82745099067687988),
            (0.83613443374633789, 0.83137255907058716, 0.83137255907058716),
            (0.8403361439704895, 0.83529412746429443, 0.83529412746429443),
            (0.84453779458999634, 0.83921569585800171, 0.83921569585800171),
            (0.84873950481414795, 0.84313726425170898, 0.84313726425170898),
            (0.85294115543365479, 0.85098040103912354, 0.85098040103912354),
            (0.8571428656578064, 0.85490196943283081, 0.85490196943283081),
            (0.86134451627731323, 0.85882353782653809, 0.85882353782653809),
            (0.86554622650146484, 0.86274510622024536, 0.86274510622024536),
            (0.86974787712097168, 0.86666667461395264, 0.86666667461395264),
            (0.87394958734512329, 0.87058824300765991, 0.87058824300765991),
            (0.87815123796463013, 0.87450981140136719, 0.87450981140136719),
            (0.88235294818878174, 0.87843137979507446, 0.87843137979507446),
            (0.88655459880828857, 0.88235294818878174, 0.88235294818878174),
            (0.89075630903244019, 0.88627451658248901, 0.88627451658248901),
            (0.89495795965194702, 0.89019608497619629, 0.89019608497619629),
            (0.89915966987609863, 0.89411765336990356, 0.89411765336990356),
            (0.90336132049560547, 0.89803922176361084, 0.89803922176361084),
            (0.90756303071975708, 0.90196079015731812, 0.90196079015731812),
            (0.91176468133926392, 0.90588235855102539, 0.90588235855102539),
            (0.91596639156341553, 0.91372549533843994, 0.91372549533843994),
            (0.92016804218292236, 0.91764706373214722, 0.91764706373214722),
            (0.92436975240707397, 0.92156863212585449, 0.92156863212585449),
            (0.92857140302658081, 0.92549020051956177, 0.92549020051956177),
            (0.93277311325073242, 0.92941176891326904, 0.92941176891326904),
            (0.93697476387023926, 0.93333333730697632, 0.93333333730697632),
            (0.94117647409439087, 0.93725490570068359, 0.93725490570068359),
            (0.94537812471389771, 0.94117647409439087, 0.94117647409439087),
            (0.94957983493804932, 0.94509804248809814, 0.94509804248809814),
            (0.95378148555755615, 0.94901961088180542, 0.94901961088180542),
            (0.95798319578170776, 0.9529411792755127, 0.9529411792755127),
            (0.9621848464012146, 0.95686274766921997, 0.95686274766921997),
            (0.96638655662536621, 0.96078431606292725, 0.96078431606292725),
            (0.97058820724487305, 0.96470588445663452, 0.96470588445663452),
            (0.97478991746902466, 0.9686274528503418, 0.9686274528503418),
            (0.97899156808853149, 0.97647058963775635, 0.97647058963775635),
            (0.98319327831268311, 0.98039215803146362, 0.98039215803146362),
            (0.98739492893218994, 0.9843137264251709, 0.9843137264251709),
            (0.99159663915634155, 0.98823529481887817, 0.98823529481887817),
            (0.99579828977584839, 0.99215686321258545, 0.99215686321258545),
            (1.0, 0.99607843160629272, 0.99607843160629272)],
        blue = [(0.0, 0.0, 0.0),
            (0.0042016808874905109, 0.0039215688593685627, 0.0039215688593685627),
            (0.0084033617749810219, 0.0078431377187371254, 0.0078431377187371254),
            (0.012605042196810246, 0.011764706112444401, 0.011764706112444401),
            (0.016806723549962044, 0.015686275437474251, 0.015686275437474251),
            (0.021008403971791267, 0.019607843831181526, 0.019607843831181526),
            (0.025210084393620491, 0.023529412224888802, 0.023529412224888802),
            (0.029411764815449715, 0.027450980618596077, 0.027450980618596077),
            (0.033613447099924088, 0.035294119268655777, 0.035294119268655777),
            (0.037815127521753311, 0.039215687662363052, 0.039215687662363052),
            (0.042016807943582535, 0.043137256056070328, 0.043137256056070328),
            (0.046218488365411758, 0.047058824449777603, 0.047058824449777603),
            (0.050420168787240982, 0.050980392843484879, 0.050980392843484879),
            (0.054621849209070206, 0.054901961237192154, 0.054901961237192154),
            (0.058823529630899429, 0.058823529630899429, 0.058823529630899429),
            (0.063025213778018951, 0.062745101749897003, 0.062745101749897003),
            (0.067226894199848175, 0.066666670143604279, 0.066666670143604279),
            (0.071428574621677399, 0.070588238537311554, 0.070588238537311554),
            (0.075630255043506622, 0.074509806931018829, 0.074509806931018829),
            (0.079831935465335846, 0.078431375324726105, 0.078431375324726105),
            (0.08403361588716507, 0.08235294371843338, 0.08235294371843338),
            (0.088235296308994293, 0.086274512112140656, 0.086274512112140656),
            (0.092436976730823517, 0.090196080505847931, 0.090196080505847931),
            (0.09663865715265274, 0.098039217293262482, 0.098039217293262482),
            (0.10084033757448196, 0.10196078568696976, 0.10196078568696976),
            (0.10504201799631119, 0.10588235408067703, 0.10588235408067703),
            (0.10924369841814041, 0.10980392247438431, 0.10980392247438431),
            (0.11344537883996964, 0.11372549086809158, 0.11372549086809158),
            (0.11764705926179886, 0.11764705926179886, 0.11764705926179886),
            (0.12184873968362808, 0.12156862765550613, 0.12156862765550613),
            (0.1260504275560379, 0.12549020349979401, 0.12549020349979401),
            (0.13025210797786713, 0.12941177189350128, 0.12941177189350128),
            (0.13445378839969635, 0.13333334028720856, 0.13333334028720856),
            (0.13865546882152557, 0.13725490868091583, 0.13725490868091583),
            (0.1428571492433548, 0.14117647707462311, 0.14117647707462311),
            (0.14705882966518402, 0.14509804546833038, 0.14509804546833038),
            (0.15126051008701324, 0.14901961386203766, 0.14901961386203766),
            (0.15546219050884247, 0.15294118225574493, 0.15294118225574493),
            (0.15966387093067169, 0.16078431904315948, 0.16078431904315948),
            (0.16386555135250092, 0.16470588743686676, 0.16470588743686676),
            (0.16806723177433014, 0.16862745583057404, 0.16862745583057404),
            (0.17226891219615936, 0.17254902422428131, 0.17254902422428131),
            (0.17647059261798859, 0.17647059261798859, 0.17647059261798859),
            (0.18067227303981781, 0.18039216101169586, 0.18039216101169586),
            (0.18487395346164703, 0.18431372940540314, 0.18431372940540314),
            (0.18907563388347626, 0.18823529779911041, 0.18823529779911041),
            (0.19327731430530548, 0.19215686619281769, 0.19215686619281769),
            (0.1974789947271347, 0.19607843458652496, 0.19607843458652496),
            (0.20168067514896393, 0.20000000298023224, 0.20000000298023224),
            (0.20588235557079315, 0.20392157137393951, 0.20392157137393951),
            (0.21008403599262238, 0.20784313976764679, 0.20784313976764679),
            (0.2142857164144516, 0.21176470816135406, 0.21176470816135406),
            (0.21848739683628082, 0.21568627655506134, 0.21568627655506134),
            (0.22268907725811005, 0.22352941334247589, 0.22352941334247589),
            (0.22689075767993927, 0.22745098173618317, 0.22745098173618317),
            (0.23109243810176849, 0.23137255012989044, 0.23137255012989044),
            (0.23529411852359772, 0.23529411852359772, 0.23529411852359772),
            (0.23949579894542694, 0.23921568691730499, 0.23921568691730499),
            (0.24369747936725616, 0.24313725531101227, 0.24313725531101227),
            (0.24789915978908539, 0.24705882370471954, 0.24705882370471954),
            (0.25210085511207581, 0.25098040699958801, 0.25098040699958801),
            (0.25630253553390503, 0.25490197539329529, 0.25490197539329529),
            (0.26050421595573425, 0.25882354378700256, 0.25882354378700256),
            (0.26470589637756348, 0.26274511218070984, 0.26274511218070984),
            (0.2689075767993927, 0.26666668057441711, 0.26666668057441711),
            (0.27310925722122192, 0.27058824896812439, 0.27058824896812439),
            (0.27731093764305115, 0.27450981736183167, 0.27450981736183167),
            (0.28151261806488037, 0.27843138575553894, 0.27843138575553894),
            (0.28571429848670959, 0.28627452254295349, 0.28627452254295349),
            (0.28991597890853882, 0.29019609093666077, 0.29019609093666077),
            (0.29411765933036804, 0.29411765933036804, 0.29411765933036804),
            (0.29831933975219727, 0.29803922772407532, 0.29803922772407532),
            (0.30252102017402649, 0.30196079611778259, 0.30196079611778259),
            (0.30672270059585571, 0.30588236451148987, 0.30588236451148987),
            (0.31092438101768494, 0.30980393290519714, 0.30980393290519714),
            (0.31512606143951416, 0.31372550129890442, 0.31372550129890442),
            (0.31932774186134338, 0.31764706969261169, 0.31764706969261169),
            (0.32352942228317261, 0.32156863808631897, 0.32156863808631897),
            (0.32773110270500183, 0.32549020648002625, 0.32549020648002625),
            (0.33193278312683105, 0.32941177487373352, 0.32941177487373352),
            (0.33613446354866028, 0.3333333432674408, 0.3333333432674408),
            (0.3403361439704895, 0.33725491166114807, 0.33725491166114807),
            (0.34453782439231873, 0.34117648005485535, 0.34117648005485535),
            (0.34873950481414795, 0.3490196168422699, 0.3490196168422699),
            (0.35294118523597717, 0.35294118523597717, 0.35294118523597717),
            (0.3571428656578064, 0.35686275362968445, 0.35686275362968445),
            (0.36134454607963562, 0.36078432202339172, 0.36078432202339172),
            (0.36554622650146484, 0.364705890417099, 0.364705890417099),
            (0.36974790692329407, 0.36862745881080627, 0.36862745881080627),
            (0.37394958734512329, 0.37254902720451355, 0.37254902720451355),
            (0.37815126776695251, 0.37647059559822083, 0.37647059559822083),
            (0.38235294818878174, 0.3803921639919281, 0.3803921639919281),
            (0.38655462861061096, 0.38431373238563538, 0.38431373238563538),
            (0.39075630903244019, 0.38823530077934265, 0.38823530077934265),
            (0.39495798945426941, 0.39215686917304993, 0.39215686917304993),
            (0.39915966987609863, 0.3960784375667572, 0.3960784375667572),
            (0.40336135029792786, 0.40000000596046448, 0.40000000596046448),
            (0.40756303071975708, 0.40392157435417175, 0.40392157435417175),
            (0.4117647111415863, 0.4117647111415863, 0.4117647111415863),
            (0.41596639156341553, 0.41568627953529358, 0.41568627953529358),
            (0.42016807198524475, 0.41960784792900085, 0.41960784792900085),
            (0.42436975240707397, 0.42352941632270813, 0.42352941632270813),
            (0.4285714328289032, 0.42745098471641541, 0.42745098471641541),
            (0.43277311325073242, 0.43137255311012268, 0.43137255311012268),
            (0.43697479367256165, 0.43529412150382996, 0.43529412150382996),
            (0.44117647409439087, 0.43921568989753723, 0.43921568989753723),
            (0.44537815451622009, 0.44313725829124451, 0.44313725829124451),
            (0.44957983493804932, 0.44705882668495178, 0.44705882668495178),
            (0.45378151535987854, 0.45098039507865906, 0.45098039507865906),
            (0.45798319578170776, 0.45490196347236633, 0.45490196347236633),
            (0.46218487620353699, 0.45882353186607361, 0.45882353186607361),
            (0.46638655662536621, 0.46274510025978088, 0.46274510025978088),
            (0.47058823704719543, 0.46666666865348816, 0.46666666865348816),
            (0.47478991746902466, 0.47450980544090271, 0.47450980544090271),
            (0.47899159789085388, 0.47843137383460999, 0.47843137383460999),
            (0.48319327831268311, 0.48235294222831726, 0.48235294222831726),
            (0.48739495873451233, 0.48627451062202454, 0.48627451062202454),
            (0.49159663915634155, 0.49019607901573181, 0.49019607901573181),
            (0.49579831957817078, 0.49411764740943909, 0.49411764740943909),
            (0.5, 0.49803921580314636, 0.49803921580314636),
            (0.50420171022415161, 0.50196081399917603, 0.50196081399917603),
            (0.50840336084365845, 0.5058823823928833, 0.5058823823928833),
            (0.51260507106781006, 0.50980395078659058, 0.50980395078659058),
            (0.51680672168731689, 0.51372551918029785, 0.51372551918029785),
            (0.52100843191146851, 0.51764708757400513, 0.51764708757400513),
            (0.52521008253097534, 0.5215686559677124, 0.5215686559677124),
            (0.52941179275512695, 0.52549022436141968, 0.52549022436141968),
            (0.53361344337463379, 0.52941179275512695, 0.52941179275512695),
            (0.5378151535987854, 0.5372549295425415, 0.5372549295425415),
            (0.54201680421829224, 0.54117649793624878, 0.54117649793624878),
            (0.54621851444244385, 0.54509806632995605, 0.54509806632995605),
            (0.55042016506195068, 0.54901963472366333, 0.54901963472366333),
            (0.55462187528610229, 0.55294120311737061, 0.55294120311737061),
            (0.55882352590560913, 0.55686277151107788, 0.55686277151107788),
            (0.56302523612976074, 0.56078433990478516, 0.56078433990478516),
            (0.56722688674926758, 0.56470590829849243, 0.56470590829849243),
            (0.57142859697341919, 0.56862747669219971, 0.56862747669219971),
            (0.57563024759292603, 0.57254904508590698, 0.57254904508590698),
            (0.57983195781707764, 0.57647061347961426, 0.57647061347961426),
            (0.58403360843658447, 0.58039218187332153, 0.58039218187332153),
            (0.58823531866073608, 0.58431375026702881, 0.58431375026702881),
            (0.59243696928024292, 0.58823531866073608, 0.58823531866073608),
            (0.59663867950439453, 0.59215688705444336, 0.59215688705444336),
            (0.60084033012390137, 0.60000002384185791, 0.60000002384185791),
            (0.60504204034805298, 0.60392159223556519, 0.60392159223556519),
            (0.60924369096755981, 0.60784316062927246, 0.60784316062927246),
            (0.61344540119171143, 0.61176472902297974, 0.61176472902297974),
            (0.61764705181121826, 0.61568629741668701, 0.61568629741668701),
            (0.62184876203536987, 0.61960786581039429, 0.61960786581039429),
            (0.62605041265487671, 0.62352943420410156, 0.62352943420410156),
            (0.63025212287902832, 0.62745100259780884, 0.62745100259780884),
            (0.63445377349853516, 0.63137257099151611, 0.63137257099151611),
            (0.63865548372268677, 0.63529413938522339, 0.63529413938522339),
            (0.6428571343421936, 0.63921570777893066, 0.63921570777893066),
            (0.64705884456634521, 0.64313727617263794, 0.64313727617263794),
            (0.65126049518585205, 0.64705884456634521, 0.64705884456634521),
            (0.65546220541000366, 0.65098041296005249, 0.65098041296005249),
            (0.6596638560295105, 0.65490198135375977, 0.65490198135375977),
            (0.66386556625366211, 0.66274511814117432, 0.66274511814117432),
            (0.66806721687316895, 0.66666668653488159, 0.66666668653488159),
            (0.67226892709732056, 0.67058825492858887, 0.67058825492858887),
            (0.67647057771682739, 0.67450982332229614, 0.67450982332229614),
            (0.680672287940979, 0.67843139171600342, 0.67843139171600342),
            (0.68487393856048584, 0.68235296010971069, 0.68235296010971069),
            (0.68907564878463745, 0.68627452850341797, 0.68627452850341797),
            (0.69327729940414429, 0.69019609689712524, 0.69019609689712524),
            (0.6974790096282959, 0.69411766529083252, 0.69411766529083252),
            (0.70168066024780273, 0.69803923368453979, 0.69803923368453979),
            (0.70588237047195435, 0.70196080207824707, 0.70196080207824707),
            (0.71008402109146118, 0.70588237047195435, 0.70588237047195435),
            (0.71428573131561279, 0.70980393886566162, 0.70980393886566162),
            (0.71848738193511963, 0.7137255072593689, 0.7137255072593689),
            (0.72268909215927124, 0.71764707565307617, 0.71764707565307617),
            (0.72689074277877808, 0.72549021244049072, 0.72549021244049072),
            (0.73109245300292969, 0.729411780834198, 0.729411780834198),
            (0.73529410362243652, 0.73333334922790527, 0.73333334922790527),
            (0.73949581384658813, 0.73725491762161255, 0.73725491762161255),
            (0.74369746446609497, 0.74117648601531982, 0.74117648601531982),
            (0.74789917469024658, 0.7450980544090271, 0.7450980544090271),
            (0.75210082530975342, 0.74901962280273438, 0.74901962280273438),
            (0.75630253553390503, 0.75294119119644165, 0.75294119119644165),
            (0.76050418615341187, 0.75686275959014893, 0.75686275959014893),
            (0.76470589637756348, 0.7607843279838562, 0.7607843279838562),
            (0.76890754699707031, 0.76470589637756348, 0.76470589637756348),
            (0.77310925722122192, 0.76862746477127075, 0.76862746477127075),
            (0.77731090784072876, 0.77254903316497803, 0.77254903316497803),
            (0.78151261806488037, 0.7764706015586853, 0.7764706015586853),
            (0.78571426868438721, 0.78039216995239258, 0.78039216995239258),
            (0.78991597890853882, 0.78823530673980713, 0.78823530673980713),
            (0.79411762952804565, 0.7921568751335144, 0.7921568751335144),
            (0.79831933975219727, 0.79607844352722168, 0.79607844352722168),
            (0.8025209903717041, 0.80000001192092896, 0.80000001192092896),
            (0.80672270059585571, 0.80392158031463623, 0.80392158031463623),
            (0.81092435121536255, 0.80784314870834351, 0.80784314870834351),
            (0.81512606143951416, 0.81176471710205078, 0.81176471710205078),
            (0.819327712059021, 0.81568628549575806, 0.81568628549575806),
            (0.82352942228317261, 0.81960785388946533, 0.81960785388946533),
            (0.82773107290267944, 0.82352942228317261, 0.82352942228317261),
            (0.83193278312683105, 0.82745099067687988, 0.82745099067687988),
            (0.83613443374633789, 0.83137255907058716, 0.83137255907058716),
            (0.8403361439704895, 0.83529412746429443, 0.83529412746429443),
            (0.84453779458999634, 0.83921569585800171, 0.83921569585800171),
            (0.84873950481414795, 0.84313726425170898, 0.84313726425170898),
            (0.85294115543365479, 0.85098040103912354, 0.85098040103912354),
            (0.8571428656578064, 0.85490196943283081, 0.85490196943283081),
            (0.86134451627731323, 0.85882353782653809, 0.85882353782653809),
            (0.86554622650146484, 0.86274510622024536, 0.86274510622024536),
            (0.86974787712097168, 0.86666667461395264, 0.86666667461395264),
            (0.87394958734512329, 0.87058824300765991, 0.87058824300765991),
            (0.87815123796463013, 0.87450981140136719, 0.87450981140136719),
            (0.88235294818878174, 0.87843137979507446, 0.87843137979507446),
            (0.88655459880828857, 0.88235294818878174, 0.88235294818878174),
            (0.89075630903244019, 0.88627451658248901, 0.88627451658248901),
            (0.89495795965194702, 0.89019608497619629, 0.89019608497619629),
            (0.89915966987609863, 0.89411765336990356, 0.89411765336990356),
            (0.90336132049560547, 0.89803922176361084, 0.89803922176361084),
            (0.90756303071975708, 0.90196079015731812, 0.90196079015731812),
            (0.91176468133926392, 0.90588235855102539, 0.90588235855102539),
            (0.91596639156341553, 0.91372549533843994, 0.91372549533843994),
            (0.92016804218292236, 0.91764706373214722, 0.91764706373214722),
            (0.92436975240707397, 0.92156863212585449, 0.92156863212585449),
            (0.92857140302658081, 0.92549020051956177, 0.92549020051956177),
            (0.93277311325073242, 0.92941176891326904, 0.92941176891326904),
            (0.93697476387023926, 0.93333333730697632, 0.93333333730697632),
            (0.94117647409439087, 0.93725490570068359, 0.93725490570068359),
            (0.94537812471389771, 0.94117647409439087, 0.94117647409439087),
            (0.94957983493804932, 0.94509804248809814, 0.94509804248809814),
            (0.95378148555755615, 0.94901961088180542, 0.94901961088180542),
            (0.95798319578170776, 0.9529411792755127, 0.9529411792755127),
            (0.9621848464012146, 0.95686274766921997, 0.95686274766921997),
            (0.96638655662536621, 0.96078431606292725, 0.96078431606292725),
            (0.97058820724487305, 0.96470588445663452, 0.96470588445663452),
            (0.97478991746902466, 0.9686274528503418, 0.9686274528503418),
            (0.97899156808853149, 0.97647058963775635, 0.97647058963775635),
            (0.98319327831268311, 0.98039215803146362, 0.98039215803146362),
            (0.98739492893218994, 0.9843137264251709, 0.9843137264251709),
            (0.99159663915634155, 0.98823529481887817, 0.98823529481887817),
            (0.99579828977584839, 0.99215686321258545, 0.99215686321258545),
            (1.0, 0.99607843160629272, 0.99607843160629272)],
    )
    return ColorMapper.from_segment_map(_data, range=range, **traits)

def gist_heat(range, **traits):
    """ Generator for the 'gist_heat' colormap from GIST.
    """
    _data = dict(
        red = [(0.0, 0.0, 0.0),
            (0.0042016808874905109, 0.0039215688593685627, 0.0039215688593685627),
            (0.0084033617749810219, 0.0078431377187371254, 0.0078431377187371254),
            (0.012605042196810246, 0.015686275437474251, 0.015686275437474251),
            (0.016806723549962044, 0.019607843831181526, 0.019607843831181526),
            (0.021008403971791267, 0.027450980618596077, 0.027450980618596077),
            (0.025210084393620491, 0.031372550874948502, 0.031372550874948502),
            (0.029411764815449715, 0.039215687662363052, 0.039215687662363052),
            (0.033613447099924088, 0.043137256056070328, 0.043137256056070328),
            (0.037815127521753311, 0.050980392843484879, 0.050980392843484879),
            (0.042016807943582535, 0.058823529630899429, 0.058823529630899429),
            (0.046218488365411758, 0.066666670143604279, 0.066666670143604279),
            (0.050420168787240982, 0.070588238537311554, 0.070588238537311554),
            (0.054621849209070206, 0.078431375324726105, 0.078431375324726105),
            (0.058823529630899429, 0.08235294371843338, 0.08235294371843338),
            (0.063025213778018951, 0.090196080505847931, 0.090196080505847931),
            (0.067226894199848175, 0.094117648899555206, 0.094117648899555206),
            (0.071428574621677399, 0.10196078568696976, 0.10196078568696976),
            (0.075630255043506622, 0.10588235408067703, 0.10588235408067703),
            (0.079831935465335846, 0.10980392247438431, 0.10980392247438431),
            (0.08403361588716507, 0.11764705926179886, 0.11764705926179886),
            (0.088235296308994293, 0.12156862765550613, 0.12156862765550613),
            (0.092436976730823517, 0.12941177189350128, 0.12941177189350128),
            (0.09663865715265274, 0.13333334028720856, 0.13333334028720856),
            (0.10084033757448196, 0.14117647707462311, 0.14117647707462311),
            (0.10504201799631119, 0.14509804546833038, 0.14509804546833038),
            (0.10924369841814041, 0.15294118225574493, 0.15294118225574493),
            (0.11344537883996964, 0.15686275064945221, 0.15686275064945221),
            (0.11764705926179886, 0.16470588743686676, 0.16470588743686676),
            (0.12184873968362808, 0.16862745583057404, 0.16862745583057404),
            (0.1260504275560379, 0.18039216101169586, 0.18039216101169586),
            (0.13025210797786713, 0.18431372940540314, 0.18431372940540314),
            (0.13445378839969635, 0.19215686619281769, 0.19215686619281769),
            (0.13865546882152557, 0.19607843458652496, 0.19607843458652496),
            (0.1428571492433548, 0.20392157137393951, 0.20392157137393951),
            (0.14705882966518402, 0.20784313976764679, 0.20784313976764679),
            (0.15126051008701324, 0.21568627655506134, 0.21568627655506134),
            (0.15546219050884247, 0.21960784494876862, 0.21960784494876862),
            (0.15966387093067169, 0.22352941334247589, 0.22352941334247589),
            (0.16386555135250092, 0.23137255012989044, 0.23137255012989044),
            (0.16806723177433014, 0.23529411852359772, 0.23529411852359772),
            (0.17226891219615936, 0.24313725531101227, 0.24313725531101227),
            (0.17647059261798859, 0.24705882370471954, 0.24705882370471954),
            (0.18067227303981781, 0.25490197539329529, 0.25490197539329529),
            (0.18487395346164703, 0.25882354378700256, 0.25882354378700256),
            (0.18907563388347626, 0.26666668057441711, 0.26666668057441711),
            (0.19327731430530548, 0.27058824896812439, 0.27058824896812439),
            (0.1974789947271347, 0.27450981736183167, 0.27450981736183167),
            (0.20168067514896393, 0.28235295414924622, 0.28235295414924622),
            (0.20588235557079315, 0.28627452254295349, 0.28627452254295349),
            (0.21008403599262238, 0.29803922772407532, 0.29803922772407532),
            (0.2142857164144516, 0.30588236451148987, 0.30588236451148987),
            (0.21848739683628082, 0.30980393290519714, 0.30980393290519714),
            (0.22268907725811005, 0.31764706969261169, 0.31764706969261169),
            (0.22689075767993927, 0.32156863808631897, 0.32156863808631897),
            (0.23109243810176849, 0.32941177487373352, 0.32941177487373352),
            (0.23529411852359772, 0.3333333432674408, 0.3333333432674408),
            (0.23949579894542694, 0.33725491166114807, 0.33725491166114807),
            (0.24369747936725616, 0.34509804844856262, 0.34509804844856262),
            (0.24789915978908539, 0.3490196168422699, 0.3490196168422699),
            (0.25210085511207581, 0.36078432202339172, 0.36078432202339172),
            (0.25630253553390503, 0.36862745881080627, 0.36862745881080627),
            (0.26050421595573425, 0.37254902720451355, 0.37254902720451355),
            (0.26470589637756348, 0.3803921639919281, 0.3803921639919281),
            (0.2689075767993927, 0.38431373238563538, 0.38431373238563538),
            (0.27310925722122192, 0.38823530077934265, 0.38823530077934265),
            (0.27731093764305115, 0.3960784375667572, 0.3960784375667572),
            (0.28151261806488037, 0.40000000596046448, 0.40000000596046448),
            (0.28571429848670959, 0.40784314274787903, 0.40784314274787903),
            (0.28991597890853882, 0.4117647111415863, 0.4117647111415863),
            (0.29411765933036804, 0.42352941632270813, 0.42352941632270813),
            (0.29831933975219727, 0.43137255311012268, 0.43137255311012268),
            (0.30252102017402649, 0.43529412150382996, 0.43529412150382996),
            (0.30672270059585571, 0.44313725829124451, 0.44313725829124451),
            (0.31092438101768494, 0.44705882668495178, 0.44705882668495178),
            (0.31512606143951416, 0.45098039507865906, 0.45098039507865906),
            (0.31932774186134338, 0.45882353186607361, 0.45882353186607361),
            (0.32352942228317261, 0.46274510025978088, 0.46274510025978088),
            (0.32773110270500183, 0.47058823704719543, 0.47058823704719543),
            (0.33193278312683105, 0.47450980544090271, 0.47450980544090271),
            (0.33613446354866028, 0.48235294222831726, 0.48235294222831726),
            (0.3403361439704895, 0.48627451062202454, 0.48627451062202454),
            (0.34453782439231873, 0.49411764740943909, 0.49411764740943909),
            (0.34873950481414795, 0.49803921580314636, 0.49803921580314636),
            (0.35294118523597717, 0.50196081399917603, 0.50196081399917603),
            (0.3571428656578064, 0.50980395078659058, 0.50980395078659058),
            (0.36134454607963562, 0.51372551918029785, 0.51372551918029785),
            (0.36554622650146484, 0.5215686559677124, 0.5215686559677124),
            (0.36974790692329407, 0.52549022436141968, 0.52549022436141968),
            (0.37394958734512329, 0.53333336114883423, 0.53333336114883423),
            (0.37815126776695251, 0.54509806632995605, 0.54509806632995605),
            (0.38235294818878174, 0.54901963472366333, 0.54901963472366333),
            (0.38655462861061096, 0.55294120311737061, 0.55294120311737061),
            (0.39075630903244019, 0.56078433990478516, 0.56078433990478516),
            (0.39495798945426941, 0.56470590829849243, 0.56470590829849243),
            (0.39915966987609863, 0.57254904508590698, 0.57254904508590698),
            (0.40336135029792786, 0.57647061347961426, 0.57647061347961426),
            (0.40756303071975708, 0.58431375026702881, 0.58431375026702881),
            (0.4117647111415863, 0.58823531866073608, 0.58823531866073608),
            (0.41596639156341553, 0.59607845544815063, 0.59607845544815063),
            (0.42016807198524475, 0.60000002384185791, 0.60000002384185791),
            (0.42436975240707397, 0.60784316062927246, 0.60784316062927246),
            (0.4285714328289032, 0.61176472902297974, 0.61176472902297974),
            (0.43277311325073242, 0.61568629741668701, 0.61568629741668701),
            (0.43697479367256165, 0.62352943420410156, 0.62352943420410156),
            (0.44117647409439087, 0.62745100259780884, 0.62745100259780884),
            (0.44537815451622009, 0.63529413938522339, 0.63529413938522339),
            (0.44957983493804932, 0.63921570777893066, 0.63921570777893066),
            (0.45378151535987854, 0.64705884456634521, 0.64705884456634521),
            (0.45798319578170776, 0.65098041296005249, 0.65098041296005249),
            (0.46218487620353699, 0.66274511814117432, 0.66274511814117432),
            (0.46638655662536621, 0.66666668653488159, 0.66666668653488159),
            (0.47058823704719543, 0.67450982332229614, 0.67450982332229614),
            (0.47478991746902466, 0.67843139171600342, 0.67843139171600342),
            (0.47899159789085388, 0.68627452850341797, 0.68627452850341797),
            (0.48319327831268311, 0.69019609689712524, 0.69019609689712524),
            (0.48739495873451233, 0.69803923368453979, 0.69803923368453979),
            (0.49159663915634155, 0.70196080207824707, 0.70196080207824707),
            (0.49579831957817078, 0.70980393886566162, 0.70980393886566162),
            (0.5, 0.7137255072593689, 0.7137255072593689),
            (0.50420171022415161, 0.72549021244049072, 0.72549021244049072),
            (0.50840336084365845, 0.729411780834198, 0.729411780834198),
            (0.51260507106781006, 0.73725491762161255, 0.73725491762161255),
            (0.51680672168731689, 0.74117648601531982, 0.74117648601531982),
            (0.52100843191146851, 0.74901962280273438, 0.74901962280273438),
            (0.52521008253097534, 0.75294119119644165, 0.75294119119644165),
            (0.52941179275512695, 0.7607843279838562, 0.7607843279838562),
            (0.53361344337463379, 0.76470589637756348, 0.76470589637756348),
            (0.5378151535987854, 0.77254903316497803, 0.77254903316497803),
            (0.54201680421829224, 0.7764706015586853, 0.7764706015586853),
            (0.54621851444244385, 0.78823530673980713, 0.78823530673980713),
            (0.55042016506195068, 0.7921568751335144, 0.7921568751335144),
            (0.55462187528610229, 0.80000001192092896, 0.80000001192092896),
            (0.55882352590560913, 0.80392158031463623, 0.80392158031463623),
            (0.56302523612976074, 0.81176471710205078, 0.81176471710205078),
            (0.56722688674926758, 0.81568628549575806, 0.81568628549575806),
            (0.57142859697341919, 0.82352942228317261, 0.82352942228317261),
            (0.57563024759292603, 0.82745099067687988, 0.82745099067687988),
            (0.57983195781707764, 0.83137255907058716, 0.83137255907058716),
            (0.58403360843658447, 0.83921569585800171, 0.83921569585800171),
            (0.58823531866073608, 0.84313726425170898, 0.84313726425170898),
            (0.59243696928024292, 0.85098040103912354, 0.85098040103912354),
            (0.59663867950439453, 0.85490196943283081, 0.85490196943283081),
            (0.60084033012390137, 0.86274510622024536, 0.86274510622024536),
            (0.60504204034805298, 0.86666667461395264, 0.86666667461395264),
            (0.60924369096755981, 0.87450981140136719, 0.87450981140136719),
            (0.61344540119171143, 0.87843137979507446, 0.87843137979507446),
            (0.61764705181121826, 0.88627451658248901, 0.88627451658248901),
            (0.62184876203536987, 0.89019608497619629, 0.89019608497619629),
            (0.62605041265487671, 0.89411765336990356, 0.89411765336990356),
            (0.63025212287902832, 0.90588235855102539, 0.90588235855102539),
            (0.63445377349853516, 0.91372549533843994, 0.91372549533843994),
            (0.63865548372268677, 0.91764706373214722, 0.91764706373214722),
            (0.6428571343421936, 0.92549020051956177, 0.92549020051956177),
            (0.64705884456634521, 0.92941176891326904, 0.92941176891326904),
            (0.65126049518585205, 0.93725490570068359, 0.93725490570068359),
            (0.65546220541000366, 0.94117647409439087, 0.94117647409439087),
            (0.6596638560295105, 0.94509804248809814, 0.94509804248809814),
            (0.66386556625366211, 0.9529411792755127, 0.9529411792755127),
            (0.66806721687316895, 0.95686274766921997, 0.95686274766921997),
            (0.67226892709732056, 0.96470588445663452, 0.96470588445663452),
            (0.67647057771682739, 0.9686274528503418, 0.9686274528503418),
            (0.680672287940979, 0.97647058963775635, 0.97647058963775635),
            (0.68487393856048584, 0.98039215803146362, 0.98039215803146362),
            (0.68907564878463745, 0.98823529481887817, 0.98823529481887817),
            (0.69327729940414429, 0.99215686321258545, 0.99215686321258545),
            (0.6974790096282959, 1.0, 1.0),
            (0.70168066024780273, 1.0, 1.0),
            (0.70588237047195435, 1.0, 1.0),
            (0.71008402109146118, 1.0, 1.0),
            (0.71428573131561279, 1.0, 1.0),
            (0.71848738193511963, 1.0, 1.0),
            (0.72268909215927124, 1.0, 1.0),
            (0.72689074277877808, 1.0, 1.0),
            (0.73109245300292969, 1.0, 1.0),
            (0.73529410362243652, 1.0, 1.0),
            (0.73949581384658813, 1.0, 1.0),
            (0.74369746446609497, 1.0, 1.0),
            (0.74789917469024658, 1.0, 1.0),
            (0.75210082530975342, 1.0, 1.0),
            (0.75630253553390503, 1.0, 1.0),
            (0.76050418615341187, 1.0, 1.0),
            (0.76470589637756348, 1.0, 1.0),
            (0.76890754699707031, 1.0, 1.0),
            (0.77310925722122192, 1.0, 1.0),
            (0.77731090784072876, 1.0, 1.0),
            (0.78151261806488037, 1.0, 1.0),
            (0.78571426868438721, 1.0, 1.0),
            (0.78991597890853882, 1.0, 1.0),
            (0.79411762952804565, 1.0, 1.0),
            (0.79831933975219727, 1.0, 1.0),
            (0.8025209903717041, 1.0, 1.0),
            (0.80672270059585571, 1.0, 1.0),
            (0.81092435121536255, 1.0, 1.0),
            (0.81512606143951416, 1.0, 1.0),
            (0.819327712059021, 1.0, 1.0),
            (0.82352942228317261, 1.0, 1.0),
            (0.82773107290267944, 1.0, 1.0),
            (0.83193278312683105, 1.0, 1.0),
            (0.83613443374633789, 1.0, 1.0),
            (0.8403361439704895, 1.0, 1.0),
            (0.84453779458999634, 1.0, 1.0),
            (0.84873950481414795, 1.0, 1.0),
            (0.85294115543365479, 1.0, 1.0),
            (0.8571428656578064, 1.0, 1.0),
            (0.86134451627731323, 1.0, 1.0),
            (0.86554622650146484, 1.0, 1.0),
            (0.86974787712097168, 1.0, 1.0),
            (0.87394958734512329, 1.0, 1.0),
            (0.87815123796463013, 1.0, 1.0),
            (0.88235294818878174, 1.0, 1.0),
            (0.88655459880828857, 1.0, 1.0),
            (0.89075630903244019, 1.0, 1.0),
            (0.89495795965194702, 1.0, 1.0),
            (0.89915966987609863, 1.0, 1.0),
            (0.90336132049560547, 1.0, 1.0),
            (0.90756303071975708, 1.0, 1.0),
            (0.91176468133926392, 1.0, 1.0),
            (0.91596639156341553, 1.0, 1.0),
            (0.92016804218292236, 1.0, 1.0),
            (0.92436975240707397, 1.0, 1.0),
            (0.92857140302658081, 1.0, 1.0),
            (0.93277311325073242, 1.0, 1.0),
            (0.93697476387023926, 1.0, 1.0),
            (0.94117647409439087, 1.0, 1.0),
            (0.94537812471389771, 1.0, 1.0),
            (0.94957983493804932, 1.0, 1.0),
            (0.95378148555755615, 1.0, 1.0),
            (0.95798319578170776, 1.0, 1.0),
            (0.9621848464012146, 1.0, 1.0),
            (0.96638655662536621, 1.0, 1.0),
            (0.97058820724487305, 1.0, 1.0),
            (0.97478991746902466, 1.0, 1.0),
            (0.97899156808853149, 1.0, 1.0),
            (0.98319327831268311, 1.0, 1.0),
            (0.98739492893218994, 1.0, 1.0),
            (0.99159663915634155, 1.0, 1.0),
            (0.99579828977584839, 1.0, 1.0),
            (1.0, 1.0, 1.0)],
        green = [(0.0, 0.0, 0.0),
            (0.0042016808874905109, 0.0, 0.0),
            (0.0084033617749810219, 0.0, 0.0),
            (0.012605042196810246, 0.0, 0.0),
            (0.016806723549962044, 0.0, 0.0),
            (0.021008403971791267, 0.0, 0.0),
            (0.025210084393620491, 0.0, 0.0),
            (0.029411764815449715, 0.0, 0.0),
            (0.033613447099924088, 0.0, 0.0),
            (0.037815127521753311, 0.0, 0.0),
            (0.042016807943582535, 0.0, 0.0),
            (0.046218488365411758, 0.0, 0.0),
            (0.050420168787240982, 0.0, 0.0),
            (0.054621849209070206, 0.0, 0.0),
            (0.058823529630899429, 0.0, 0.0),
            (0.063025213778018951, 0.0, 0.0),
            (0.067226894199848175, 0.0, 0.0),
            (0.071428574621677399, 0.0, 0.0),
            (0.075630255043506622, 0.0, 0.0),
            (0.079831935465335846, 0.0, 0.0),
            (0.08403361588716507, 0.0, 0.0),
            (0.088235296308994293, 0.0, 0.0),
            (0.092436976730823517, 0.0, 0.0),
            (0.09663865715265274, 0.0, 0.0),
            (0.10084033757448196, 0.0, 0.0),
            (0.10504201799631119, 0.0, 0.0),
            (0.10924369841814041, 0.0, 0.0),
            (0.11344537883996964, 0.0, 0.0),
            (0.11764705926179886, 0.0, 0.0),
            (0.12184873968362808, 0.0, 0.0),
            (0.1260504275560379, 0.0, 0.0),
            (0.13025210797786713, 0.0, 0.0),
            (0.13445378839969635, 0.0, 0.0),
            (0.13865546882152557, 0.0, 0.0),
            (0.1428571492433548, 0.0, 0.0),
            (0.14705882966518402, 0.0, 0.0),
            (0.15126051008701324, 0.0, 0.0),
            (0.15546219050884247, 0.0, 0.0),
            (0.15966387093067169, 0.0, 0.0),
            (0.16386555135250092, 0.0, 0.0),
            (0.16806723177433014, 0.0, 0.0),
            (0.17226891219615936, 0.0, 0.0),
            (0.17647059261798859, 0.0, 0.0),
            (0.18067227303981781, 0.0, 0.0),
            (0.18487395346164703, 0.0, 0.0),
            (0.18907563388347626, 0.0, 0.0),
            (0.19327731430530548, 0.0, 0.0),
            (0.1974789947271347, 0.0, 0.0),
            (0.20168067514896393, 0.0, 0.0),
            (0.20588235557079315, 0.0, 0.0),
            (0.21008403599262238, 0.0, 0.0),
            (0.2142857164144516, 0.0, 0.0),
            (0.21848739683628082, 0.0, 0.0),
            (0.22268907725811005, 0.0, 0.0),
            (0.22689075767993927, 0.0, 0.0),
            (0.23109243810176849, 0.0, 0.0),
            (0.23529411852359772, 0.0, 0.0),
            (0.23949579894542694, 0.0, 0.0),
            (0.24369747936725616, 0.0, 0.0),
            (0.24789915978908539, 0.0, 0.0),
            (0.25210085511207581, 0.0, 0.0),
            (0.25630253553390503, 0.0, 0.0),
            (0.26050421595573425, 0.0, 0.0),
            (0.26470589637756348, 0.0, 0.0),
            (0.2689075767993927, 0.0, 0.0),
            (0.27310925722122192, 0.0, 0.0),
            (0.27731093764305115, 0.0, 0.0),
            (0.28151261806488037, 0.0, 0.0),
            (0.28571429848670959, 0.0, 0.0),
            (0.28991597890853882, 0.0, 0.0),
            (0.29411765933036804, 0.0, 0.0),
            (0.29831933975219727, 0.0, 0.0),
            (0.30252102017402649, 0.0, 0.0),
            (0.30672270059585571, 0.0, 0.0),
            (0.31092438101768494, 0.0, 0.0),
            (0.31512606143951416, 0.0, 0.0),
            (0.31932774186134338, 0.0, 0.0),
            (0.32352942228317261, 0.0, 0.0),
            (0.32773110270500183, 0.0, 0.0),
            (0.33193278312683105, 0.0, 0.0),
            (0.33613446354866028, 0.0, 0.0),
            (0.3403361439704895, 0.0, 0.0),
            (0.34453782439231873, 0.0, 0.0),
            (0.34873950481414795, 0.0, 0.0),
            (0.35294118523597717, 0.0, 0.0),
            (0.3571428656578064, 0.0, 0.0),
            (0.36134454607963562, 0.0, 0.0),
            (0.36554622650146484, 0.0, 0.0),
            (0.36974790692329407, 0.0, 0.0),
            (0.37394958734512329, 0.0, 0.0),
            (0.37815126776695251, 0.0, 0.0),
            (0.38235294818878174, 0.0, 0.0),
            (0.38655462861061096, 0.0, 0.0),
            (0.39075630903244019, 0.0, 0.0),
            (0.39495798945426941, 0.0, 0.0),
            (0.39915966987609863, 0.0, 0.0),
            (0.40336135029792786, 0.0, 0.0),
            (0.40756303071975708, 0.0, 0.0),
            (0.4117647111415863, 0.0, 0.0),
            (0.41596639156341553, 0.0, 0.0),
            (0.42016807198524475, 0.0, 0.0),
            (0.42436975240707397, 0.0, 0.0),
            (0.4285714328289032, 0.0, 0.0),
            (0.43277311325073242, 0.0, 0.0),
            (0.43697479367256165, 0.0, 0.0),
            (0.44117647409439087, 0.0, 0.0),
            (0.44537815451622009, 0.0, 0.0),
            (0.44957983493804932, 0.0, 0.0),
            (0.45378151535987854, 0.0, 0.0),
            (0.45798319578170776, 0.0, 0.0),
            (0.46218487620353699, 0.0, 0.0),
            (0.46638655662536621, 0.0, 0.0),
            (0.47058823704719543, 0.0, 0.0),
            (0.47478991746902466, 0.0, 0.0),
            (0.47899159789085388, 0.0039215688593685627, 0.0039215688593685627),
            (0.48319327831268311, 0.011764706112444401, 0.011764706112444401),
            (0.48739495873451233, 0.019607843831181526, 0.019607843831181526),
            (0.49159663915634155, 0.027450980618596077, 0.027450980618596077),
            (0.49579831957817078, 0.035294119268655777, 0.035294119268655777),
            (0.5, 0.043137256056070328, 0.043137256056070328),
            (0.50420171022415161, 0.058823529630899429, 0.058823529630899429),
            (0.50840336084365845, 0.066666670143604279, 0.066666670143604279),
            (0.51260507106781006, 0.070588238537311554, 0.070588238537311554),
            (0.51680672168731689, 0.078431375324726105, 0.078431375324726105),
            (0.52100843191146851, 0.086274512112140656, 0.086274512112140656),
            (0.52521008253097534, 0.094117648899555206, 0.094117648899555206),
            (0.52941179275512695, 0.10196078568696976, 0.10196078568696976),
            (0.53361344337463379, 0.10980392247438431, 0.10980392247438431),
            (0.5378151535987854, 0.11764705926179886, 0.11764705926179886),
            (0.54201680421829224, 0.12549020349979401, 0.12549020349979401),
            (0.54621851444244385, 0.13725490868091583, 0.13725490868091583),
            (0.55042016506195068, 0.14509804546833038, 0.14509804546833038),
            (0.55462187528610229, 0.15294118225574493, 0.15294118225574493),
            (0.55882352590560913, 0.16078431904315948, 0.16078431904315948),
            (0.56302523612976074, 0.16862745583057404, 0.16862745583057404),
            (0.56722688674926758, 0.17647059261798859, 0.17647059261798859),
            (0.57142859697341919, 0.18431372940540314, 0.18431372940540314),
            (0.57563024759292603, 0.19215686619281769, 0.19215686619281769),
            (0.57983195781707764, 0.20000000298023224, 0.20000000298023224),
            (0.58403360843658447, 0.20392157137393951, 0.20392157137393951),
            (0.58823531866073608, 0.21176470816135406, 0.21176470816135406),
            (0.59243696928024292, 0.21960784494876862, 0.21960784494876862),
            (0.59663867950439453, 0.22745098173618317, 0.22745098173618317),
            (0.60084033012390137, 0.23529411852359772, 0.23529411852359772),
            (0.60504204034805298, 0.24313725531101227, 0.24313725531101227),
            (0.60924369096755981, 0.25098040699958801, 0.25098040699958801),
            (0.61344540119171143, 0.25882354378700256, 0.25882354378700256),
            (0.61764705181121826, 0.26666668057441711, 0.26666668057441711),
            (0.62184876203536987, 0.27058824896812439, 0.27058824896812439),
            (0.62605041265487671, 0.27843138575553894, 0.27843138575553894),
            (0.63025212287902832, 0.29411765933036804, 0.29411765933036804),
            (0.63445377349853516, 0.30196079611778259, 0.30196079611778259),
            (0.63865548372268677, 0.30980393290519714, 0.30980393290519714),
            (0.6428571343421936, 0.31764706969261169, 0.31764706969261169),
            (0.64705884456634521, 0.32549020648002625, 0.32549020648002625),
            (0.65126049518585205, 0.3333333432674408, 0.3333333432674408),
            (0.65546220541000366, 0.33725491166114807, 0.33725491166114807),
            (0.6596638560295105, 0.34509804844856262, 0.34509804844856262),
            (0.66386556625366211, 0.35294118523597717, 0.35294118523597717),
            (0.66806721687316895, 0.36078432202339172, 0.36078432202339172),
            (0.67226892709732056, 0.36862745881080627, 0.36862745881080627),
            (0.67647057771682739, 0.37647059559822083, 0.37647059559822083),
            (0.680672287940979, 0.38431373238563538, 0.38431373238563538),
            (0.68487393856048584, 0.39215686917304993, 0.39215686917304993),
            (0.68907564878463745, 0.40000000596046448, 0.40000000596046448),
            (0.69327729940414429, 0.40392157435417175, 0.40392157435417175),
            (0.6974790096282959, 0.4117647111415863, 0.4117647111415863),
            (0.70168066024780273, 0.41960784792900085, 0.41960784792900085),
            (0.70588237047195435, 0.42745098471641541, 0.42745098471641541),
            (0.71008402109146118, 0.43529412150382996, 0.43529412150382996),
            (0.71428573131561279, 0.45098039507865906, 0.45098039507865906),
            (0.71848738193511963, 0.45882353186607361, 0.45882353186607361),
            (0.72268909215927124, 0.46666666865348816, 0.46666666865348816),
            (0.72689074277877808, 0.47058823704719543, 0.47058823704719543),
            (0.73109245300292969, 0.47843137383460999, 0.47843137383460999),
            (0.73529410362243652, 0.48627451062202454, 0.48627451062202454),
            (0.73949581384658813, 0.49411764740943909, 0.49411764740943909),
            (0.74369746446609497, 0.50196081399917603, 0.50196081399917603),
            (0.74789917469024658, 0.50980395078659058, 0.50980395078659058),
            (0.75210082530975342, 0.51764708757400513, 0.51764708757400513),
            (0.75630253553390503, 0.53333336114883423, 0.53333336114883423),
            (0.76050418615341187, 0.5372549295425415, 0.5372549295425415),
            (0.76470589637756348, 0.54509806632995605, 0.54509806632995605),
            (0.76890754699707031, 0.55294120311737061, 0.55294120311737061),
            (0.77310925722122192, 0.56078433990478516, 0.56078433990478516),
            (0.77731090784072876, 0.56862747669219971, 0.56862747669219971),
            (0.78151261806488037, 0.57647061347961426, 0.57647061347961426),
            (0.78571426868438721, 0.58431375026702881, 0.58431375026702881),
            (0.78991597890853882, 0.59215688705444336, 0.59215688705444336),
            (0.79411762952804565, 0.60000002384185791, 0.60000002384185791),
            (0.79831933975219727, 0.61176472902297974, 0.61176472902297974),
            (0.8025209903717041, 0.61960786581039429, 0.61960786581039429),
            (0.80672270059585571, 0.62745100259780884, 0.62745100259780884),
            (0.81092435121536255, 0.63529413938522339, 0.63529413938522339),
            (0.81512606143951416, 0.64313727617263794, 0.64313727617263794),
            (0.819327712059021, 0.65098041296005249, 0.65098041296005249),
            (0.82352942228317261, 0.65882354974746704, 0.65882354974746704),
            (0.82773107290267944, 0.66666668653488159, 0.66666668653488159),
            (0.83193278312683105, 0.67058825492858887, 0.67058825492858887),
            (0.83613443374633789, 0.67843139171600342, 0.67843139171600342),
            (0.8403361439704895, 0.68627452850341797, 0.68627452850341797),
            (0.84453779458999634, 0.69411766529083252, 0.69411766529083252),
            (0.84873950481414795, 0.70196080207824707, 0.70196080207824707),
            (0.85294115543365479, 0.70980393886566162, 0.70980393886566162),
            (0.8571428656578064, 0.71764707565307617, 0.71764707565307617),
            (0.86134451627731323, 0.72549021244049072, 0.72549021244049072),
            (0.86554622650146484, 0.73333334922790527, 0.73333334922790527),
            (0.86974787712097168, 0.73725491762161255, 0.73725491762161255),
            (0.87394958734512329, 0.7450980544090271, 0.7450980544090271),
            (0.87815123796463013, 0.75294119119644165, 0.75294119119644165),
            (0.88235294818878174, 0.76862746477127075, 0.76862746477127075),
            (0.88655459880828857, 0.7764706015586853, 0.7764706015586853),
            (0.89075630903244019, 0.78431373834609985, 0.78431373834609985),
            (0.89495795965194702, 0.7921568751335144, 0.7921568751335144),
            (0.89915966987609863, 0.80000001192092896, 0.80000001192092896),
            (0.90336132049560547, 0.80392158031463623, 0.80392158031463623),
            (0.90756303071975708, 0.81176471710205078, 0.81176471710205078),
            (0.91176468133926392, 0.81960785388946533, 0.81960785388946533),
            (0.91596639156341553, 0.82745099067687988, 0.82745099067687988),
            (0.92016804218292236, 0.83529412746429443, 0.83529412746429443),
            (0.92436975240707397, 0.84313726425170898, 0.84313726425170898),
            (0.92857140302658081, 0.85098040103912354, 0.85098040103912354),
            (0.93277311325073242, 0.85882353782653809, 0.85882353782653809),
            (0.93697476387023926, 0.86666667461395264, 0.86666667461395264),
            (0.94117647409439087, 0.87058824300765991, 0.87058824300765991),
            (0.94537812471389771, 0.87843137979507446, 0.87843137979507446),
            (0.94957983493804932, 0.88627451658248901, 0.88627451658248901),
            (0.95378148555755615, 0.89411765336990356, 0.89411765336990356),
            (0.95798319578170776, 0.90196079015731812, 0.90196079015731812),
            (0.9621848464012146, 0.90980392694473267, 0.90980392694473267),
            (0.96638655662536621, 0.92549020051956177, 0.92549020051956177),
            (0.97058820724487305, 0.93333333730697632, 0.93333333730697632),
            (0.97478991746902466, 0.93725490570068359, 0.93725490570068359),
            (0.97899156808853149, 0.94509804248809814, 0.94509804248809814),
            (0.98319327831268311, 0.9529411792755127, 0.9529411792755127),
            (0.98739492893218994, 0.96078431606292725, 0.96078431606292725),
            (0.99159663915634155, 0.9686274528503418, 0.9686274528503418),
            (0.99579828977584839, 0.97647058963775635, 0.97647058963775635),
            (1.0, 0.9843137264251709, 0.9843137264251709)],
        blue = [(0.0, 0.0, 0.0),
            (0.0042016808874905109, 0.0, 0.0),
            (0.0084033617749810219, 0.0, 0.0),
            (0.012605042196810246, 0.0, 0.0),
            (0.016806723549962044, 0.0, 0.0),
            (0.021008403971791267, 0.0, 0.0),
            (0.025210084393620491, 0.0, 0.0),
            (0.029411764815449715, 0.0, 0.0),
            (0.033613447099924088, 0.0, 0.0),
            (0.037815127521753311, 0.0, 0.0),
            (0.042016807943582535, 0.0, 0.0),
            (0.046218488365411758, 0.0, 0.0),
            (0.050420168787240982, 0.0, 0.0),
            (0.054621849209070206, 0.0, 0.0),
            (0.058823529630899429, 0.0, 0.0),
            (0.063025213778018951, 0.0, 0.0),
            (0.067226894199848175, 0.0, 0.0),
            (0.071428574621677399, 0.0, 0.0),
            (0.075630255043506622, 0.0, 0.0),
            (0.079831935465335846, 0.0, 0.0),
            (0.08403361588716507, 0.0, 0.0),
            (0.088235296308994293, 0.0, 0.0),
            (0.092436976730823517, 0.0, 0.0),
            (0.09663865715265274, 0.0, 0.0),
            (0.10084033757448196, 0.0, 0.0),
            (0.10504201799631119, 0.0, 0.0),
            (0.10924369841814041, 0.0, 0.0),
            (0.11344537883996964, 0.0, 0.0),
            (0.11764705926179886, 0.0, 0.0),
            (0.12184873968362808, 0.0, 0.0),
            (0.1260504275560379, 0.0, 0.0),
            (0.13025210797786713, 0.0, 0.0),
            (0.13445378839969635, 0.0, 0.0),
            (0.13865546882152557, 0.0, 0.0),
            (0.1428571492433548, 0.0, 0.0),
            (0.14705882966518402, 0.0, 0.0),
            (0.15126051008701324, 0.0, 0.0),
            (0.15546219050884247, 0.0, 0.0),
            (0.15966387093067169, 0.0, 0.0),
            (0.16386555135250092, 0.0, 0.0),
            (0.16806723177433014, 0.0, 0.0),
            (0.17226891219615936, 0.0, 0.0),
            (0.17647059261798859, 0.0, 0.0),
            (0.18067227303981781, 0.0, 0.0),
            (0.18487395346164703, 0.0, 0.0),
            (0.18907563388347626, 0.0, 0.0),
            (0.19327731430530548, 0.0, 0.0),
            (0.1974789947271347, 0.0, 0.0),
            (0.20168067514896393, 0.0, 0.0),
            (0.20588235557079315, 0.0, 0.0),
            (0.21008403599262238, 0.0, 0.0),
            (0.2142857164144516, 0.0, 0.0),
            (0.21848739683628082, 0.0, 0.0),
            (0.22268907725811005, 0.0, 0.0),
            (0.22689075767993927, 0.0, 0.0),
            (0.23109243810176849, 0.0, 0.0),
            (0.23529411852359772, 0.0, 0.0),
            (0.23949579894542694, 0.0, 0.0),
            (0.24369747936725616, 0.0, 0.0),
            (0.24789915978908539, 0.0, 0.0),
            (0.25210085511207581, 0.0, 0.0),
            (0.25630253553390503, 0.0, 0.0),
            (0.26050421595573425, 0.0, 0.0),
            (0.26470589637756348, 0.0, 0.0),
            (0.2689075767993927, 0.0, 0.0),
            (0.27310925722122192, 0.0, 0.0),
            (0.27731093764305115, 0.0, 0.0),
            (0.28151261806488037, 0.0, 0.0),
            (0.28571429848670959, 0.0, 0.0),
            (0.28991597890853882, 0.0, 0.0),
            (0.29411765933036804, 0.0, 0.0),
            (0.29831933975219727, 0.0, 0.0),
            (0.30252102017402649, 0.0, 0.0),
            (0.30672270059585571, 0.0, 0.0),
            (0.31092438101768494, 0.0, 0.0),
            (0.31512606143951416, 0.0, 0.0),
            (0.31932774186134338, 0.0, 0.0),
            (0.32352942228317261, 0.0, 0.0),
            (0.32773110270500183, 0.0, 0.0),
            (0.33193278312683105, 0.0, 0.0),
            (0.33613446354866028, 0.0, 0.0),
            (0.3403361439704895, 0.0, 0.0),
            (0.34453782439231873, 0.0, 0.0),
            (0.34873950481414795, 0.0, 0.0),
            (0.35294118523597717, 0.0, 0.0),
            (0.3571428656578064, 0.0, 0.0),
            (0.36134454607963562, 0.0, 0.0),
            (0.36554622650146484, 0.0, 0.0),
            (0.36974790692329407, 0.0, 0.0),
            (0.37394958734512329, 0.0, 0.0),
            (0.37815126776695251, 0.0, 0.0),
            (0.38235294818878174, 0.0, 0.0),
            (0.38655462861061096, 0.0, 0.0),
            (0.39075630903244019, 0.0, 0.0),
            (0.39495798945426941, 0.0, 0.0),
            (0.39915966987609863, 0.0, 0.0),
            (0.40336135029792786, 0.0, 0.0),
            (0.40756303071975708, 0.0, 0.0),
            (0.4117647111415863, 0.0, 0.0),
            (0.41596639156341553, 0.0, 0.0),
            (0.42016807198524475, 0.0, 0.0),
            (0.42436975240707397, 0.0, 0.0),
            (0.4285714328289032, 0.0, 0.0),
            (0.43277311325073242, 0.0, 0.0),
            (0.43697479367256165, 0.0, 0.0),
            (0.44117647409439087, 0.0, 0.0),
            (0.44537815451622009, 0.0, 0.0),
            (0.44957983493804932, 0.0, 0.0),
            (0.45378151535987854, 0.0, 0.0),
            (0.45798319578170776, 0.0, 0.0),
            (0.46218487620353699, 0.0, 0.0),
            (0.46638655662536621, 0.0, 0.0),
            (0.47058823704719543, 0.0, 0.0),
            (0.47478991746902466, 0.0, 0.0),
            (0.47899159789085388, 0.0, 0.0),
            (0.48319327831268311, 0.0, 0.0),
            (0.48739495873451233, 0.0, 0.0),
            (0.49159663915634155, 0.0, 0.0),
            (0.49579831957817078, 0.0, 0.0),
            (0.5, 0.0, 0.0),
            (0.50420171022415161, 0.0, 0.0),
            (0.50840336084365845, 0.0, 0.0),
            (0.51260507106781006, 0.0, 0.0),
            (0.51680672168731689, 0.0, 0.0),
            (0.52100843191146851, 0.0, 0.0),
            (0.52521008253097534, 0.0, 0.0),
            (0.52941179275512695, 0.0, 0.0),
            (0.53361344337463379, 0.0, 0.0),
            (0.5378151535987854, 0.0, 0.0),
            (0.54201680421829224, 0.0, 0.0),
            (0.54621851444244385, 0.0, 0.0),
            (0.55042016506195068, 0.0, 0.0),
            (0.55462187528610229, 0.0, 0.0),
            (0.55882352590560913, 0.0, 0.0),
            (0.56302523612976074, 0.0, 0.0),
            (0.56722688674926758, 0.0, 0.0),
            (0.57142859697341919, 0.0, 0.0),
            (0.57563024759292603, 0.0, 0.0),
            (0.57983195781707764, 0.0, 0.0),
            (0.58403360843658447, 0.0, 0.0),
            (0.58823531866073608, 0.0, 0.0),
            (0.59243696928024292, 0.0, 0.0),
            (0.59663867950439453, 0.0, 0.0),
            (0.60084033012390137, 0.0, 0.0),
            (0.60504204034805298, 0.0, 0.0),
            (0.60924369096755981, 0.0, 0.0),
            (0.61344540119171143, 0.0, 0.0),
            (0.61764705181121826, 0.0, 0.0),
            (0.62184876203536987, 0.0, 0.0),
            (0.62605041265487671, 0.0, 0.0),
            (0.63025212287902832, 0.0, 0.0),
            (0.63445377349853516, 0.0, 0.0),
            (0.63865548372268677, 0.0, 0.0),
            (0.6428571343421936, 0.0, 0.0),
            (0.64705884456634521, 0.0, 0.0),
            (0.65126049518585205, 0.0, 0.0),
            (0.65546220541000366, 0.0, 0.0),
            (0.6596638560295105, 0.0, 0.0),
            (0.66386556625366211, 0.0, 0.0),
            (0.66806721687316895, 0.0, 0.0),
            (0.67226892709732056, 0.0, 0.0),
            (0.67647057771682739, 0.0, 0.0),
            (0.680672287940979, 0.0, 0.0),
            (0.68487393856048584, 0.0, 0.0),
            (0.68907564878463745, 0.0, 0.0),
            (0.69327729940414429, 0.0, 0.0),
            (0.6974790096282959, 0.0, 0.0),
            (0.70168066024780273, 0.0, 0.0),
            (0.70588237047195435, 0.0, 0.0),
            (0.71008402109146118, 0.0, 0.0),
            (0.71428573131561279, 0.0, 0.0),
            (0.71848738193511963, 0.0, 0.0),
            (0.72268909215927124, 0.0, 0.0),
            (0.72689074277877808, 0.0, 0.0),
            (0.73109245300292969, 0.0, 0.0),
            (0.73529410362243652, 0.0, 0.0),
            (0.73949581384658813, 0.0, 0.0),
            (0.74369746446609497, 0.0, 0.0),
            (0.74789917469024658, 0.0, 0.0),
            (0.75210082530975342, 0.0, 0.0),
            (0.75630253553390503, 0.027450980618596077, 0.027450980618596077),
            (0.76050418615341187, 0.043137256056070328, 0.043137256056070328),
            (0.76470589637756348, 0.058823529630899429, 0.058823529630899429),
            (0.76890754699707031, 0.074509806931018829, 0.074509806931018829),
            (0.77310925722122192, 0.090196080505847931, 0.090196080505847931),
            (0.77731090784072876, 0.10588235408067703, 0.10588235408067703),
            (0.78151261806488037, 0.12156862765550613, 0.12156862765550613),
            (0.78571426868438721, 0.13725490868091583, 0.13725490868091583),
            (0.78991597890853882, 0.15294118225574493, 0.15294118225574493),
            (0.79411762952804565, 0.16862745583057404, 0.16862745583057404),
            (0.79831933975219727, 0.20000000298023224, 0.20000000298023224),
            (0.8025209903717041, 0.21176470816135406, 0.21176470816135406),
            (0.80672270059585571, 0.22745098173618317, 0.22745098173618317),
            (0.81092435121536255, 0.24313725531101227, 0.24313725531101227),
            (0.81512606143951416, 0.25882354378700256, 0.25882354378700256),
            (0.819327712059021, 0.27450981736183167, 0.27450981736183167),
            (0.82352942228317261, 0.29019609093666077, 0.29019609093666077),
            (0.82773107290267944, 0.30588236451148987, 0.30588236451148987),
            (0.83193278312683105, 0.32156863808631897, 0.32156863808631897),
            (0.83613443374633789, 0.33725491166114807, 0.33725491166114807),
            (0.8403361439704895, 0.35294118523597717, 0.35294118523597717),
            (0.84453779458999634, 0.36862745881080627, 0.36862745881080627),
            (0.84873950481414795, 0.38431373238563538, 0.38431373238563538),
            (0.85294115543365479, 0.40000000596046448, 0.40000000596046448),
            (0.8571428656578064, 0.4117647111415863, 0.4117647111415863),
            (0.86134451627731323, 0.42745098471641541, 0.42745098471641541),
            (0.86554622650146484, 0.44313725829124451, 0.44313725829124451),
            (0.86974787712097168, 0.45882353186607361, 0.45882353186607361),
            (0.87394958734512329, 0.47450980544090271, 0.47450980544090271),
            (0.87815123796463013, 0.49019607901573181, 0.49019607901573181),
            (0.88235294818878174, 0.5215686559677124, 0.5215686559677124),
            (0.88655459880828857, 0.5372549295425415, 0.5372549295425415),
            (0.89075630903244019, 0.55294120311737061, 0.55294120311737061),
            (0.89495795965194702, 0.56862747669219971, 0.56862747669219971),
            (0.89915966987609863, 0.58431375026702881, 0.58431375026702881),
            (0.90336132049560547, 0.60000002384185791, 0.60000002384185791),
            (0.90756303071975708, 0.61176472902297974, 0.61176472902297974),
            (0.91176468133926392, 0.62745100259780884, 0.62745100259780884),
            (0.91596639156341553, 0.64313727617263794, 0.64313727617263794),
            (0.92016804218292236, 0.65882354974746704, 0.65882354974746704),
            (0.92436975240707397, 0.67450982332229614, 0.67450982332229614),
            (0.92857140302658081, 0.69019609689712524, 0.69019609689712524),
            (0.93277311325073242, 0.70588237047195435, 0.70588237047195435),
            (0.93697476387023926, 0.72156864404678345, 0.72156864404678345),
            (0.94117647409439087, 0.73725491762161255, 0.73725491762161255),
            (0.94537812471389771, 0.75294119119644165, 0.75294119119644165),
            (0.94957983493804932, 0.76862746477127075, 0.76862746477127075),
            (0.95378148555755615, 0.78431373834609985, 0.78431373834609985),
            (0.95798319578170776, 0.80000001192092896, 0.80000001192092896),
            (0.9621848464012146, 0.81176471710205078, 0.81176471710205078),
            (0.96638655662536621, 0.84313726425170898, 0.84313726425170898),
            (0.97058820724487305, 0.85882353782653809, 0.85882353782653809),
            (0.97478991746902466, 0.87450981140136719, 0.87450981140136719),
            (0.97899156808853149, 0.89019608497619629, 0.89019608497619629),
            (0.98319327831268311, 0.90588235855102539, 0.90588235855102539),
            (0.98739492893218994, 0.92156863212585449, 0.92156863212585449),
            (0.99159663915634155, 0.93725490570068359, 0.93725490570068359),
            (0.99579828977584839, 0.9529411792755127, 0.9529411792755127),
            (1.0, 0.9686274528503418, 0.9686274528503418)],
    )
    return ColorMapper.from_segment_map(_data, range=range, **traits)

def gist_ncar(range, **traits):
    """ Generator for the 'gist_ncar' colormap from GIST.
    """
    _data = dict(
        red = [(0.0, 0.0, 0.0),
            (0.0050505050458014011, 0.0, 0.0),
            (0.010101010091602802, 0.0, 0.0),
            (0.015151515603065491, 0.0, 0.0),
            (0.020202020183205605, 0.0, 0.0),
            (0.025252524763345718, 0.0, 0.0),
            (0.030303031206130981, 0.0, 0.0),
            (0.035353533923625946, 0.0, 0.0),
            (0.040404040366411209, 0.0, 0.0),
            (0.045454546809196472, 0.0, 0.0),
            (0.050505049526691437, 0.0, 0.0),
            (0.0555555559694767, 0.0, 0.0),
            (0.060606062412261963, 0.0, 0.0),
            (0.065656565129756927, 0.0, 0.0),
            (0.070707067847251892, 0.0, 0.0),
            (0.075757578015327454, 0.0, 0.0),
            (0.080808080732822418, 0.0, 0.0),
            (0.085858583450317383, 0.0, 0.0),
            (0.090909093618392944, 0.0, 0.0),
            (0.095959596335887909, 0.0, 0.0),
            (0.10101009905338287, 0.0, 0.0),
            (0.10606060922145844, 0.0, 0.0),
            (0.1111111119389534, 0.0, 0.0),
            (0.11616161465644836, 0.0, 0.0),
            (0.12121212482452393, 0.0, 0.0),
            (0.12626262009143829, 0.0, 0.0),
            (0.13131313025951385, 0.0, 0.0),
            (0.13636364042758942, 0.0, 0.0),
            (0.14141413569450378, 0.0, 0.0),
            (0.14646464586257935, 0.0, 0.0),
            (0.15151515603065491, 0.0, 0.0),
            (0.15656565129756927, 0.0, 0.0),
            (0.16161616146564484, 0.0, 0.0),
            (0.1666666716337204, 0.0, 0.0),
            (0.17171716690063477, 0.0, 0.0),
            (0.17676767706871033, 0.0, 0.0),
            (0.18181818723678589, 0.0, 0.0),
            (0.18686868250370026, 0.0, 0.0),
            (0.19191919267177582, 0.0, 0.0),
            (0.19696970283985138, 0.0, 0.0),
            (0.20202019810676575, 0.0, 0.0),
            (0.20707070827484131, 0.0, 0.0),
            (0.21212121844291687, 0.0, 0.0),
            (0.21717171370983124, 0.0, 0.0),
            (0.2222222238779068, 0.0, 0.0),
            (0.22727273404598236, 0.0, 0.0),
            (0.23232322931289673, 0.0, 0.0),
            (0.23737373948097229, 0.0, 0.0),
            (0.24242424964904785, 0.0, 0.0),
            (0.24747474491596222, 0.0, 0.0),
            (0.25252524018287659, 0.0, 0.0),
            (0.25757575035095215, 0.0, 0.0),
            (0.26262626051902771, 0.0, 0.0),
            (0.26767677068710327, 0.0, 0.0),
            (0.27272728085517883, 0.0, 0.0),
            (0.27777779102325439, 0.0, 0.0),
            (0.28282827138900757, 0.0, 0.0),
            (0.28787878155708313, 0.0, 0.0),
            (0.29292929172515869, 0.0, 0.0),
            (0.29797980189323425, 0.0, 0.0),
            (0.30303031206130981, 0.0, 0.0),
            (0.30808082222938538, 0.0, 0.0),
            (0.31313130259513855, 0.0, 0.0),
            (0.31818181276321411, 0.0039215688593685627, 0.0039215688593685627),
            (0.32323232293128967, 0.043137256056070328, 0.043137256056070328),
            (0.32828283309936523, 0.08235294371843338, 0.08235294371843338),
            (0.3333333432674408, 0.11764705926179886, 0.11764705926179886),
            (0.33838382363319397, 0.15686275064945221, 0.15686275064945221),
            (0.34343433380126953, 0.19607843458652496, 0.19607843458652496),
            (0.34848484396934509, 0.23137255012989044, 0.23137255012989044),
            (0.35353535413742065, 0.27058824896812439, 0.27058824896812439),
            (0.35858586430549622, 0.30980393290519714, 0.30980393290519714),
            (0.36363637447357178, 0.3490196168422699, 0.3490196168422699),
            (0.36868685483932495, 0.38431373238563538, 0.38431373238563538),
            (0.37373736500740051, 0.40392157435417175, 0.40392157435417175),
            (0.37878787517547607, 0.41568627953529358, 0.41568627953529358),
            (0.38383838534355164, 0.42352941632270813, 0.42352941632270813),
            (0.3888888955116272, 0.43137255311012268, 0.43137255311012268),
            (0.39393940567970276, 0.44313725829124451, 0.44313725829124451),
            (0.39898988604545593, 0.45098039507865906, 0.45098039507865906),
            (0.40404039621353149, 0.45882353186607361, 0.45882353186607361),
            (0.40909090638160706, 0.47058823704719543, 0.47058823704719543),
            (0.41414141654968262, 0.47843137383460999, 0.47843137383460999),
            (0.41919192671775818, 0.49019607901573181, 0.49019607901573181),
            (0.42424243688583374, 0.50196081399917603, 0.50196081399917603),
            (0.42929291725158691, 0.52549022436141968, 0.52549022436141968),
            (0.43434342741966248, 0.54901963472366333, 0.54901963472366333),
            (0.43939393758773804, 0.57254904508590698, 0.57254904508590698),
            (0.4444444477558136, 0.60000002384185791, 0.60000002384185791),
            (0.44949495792388916, 0.62352943420410156, 0.62352943420410156),
            (0.45454546809196472, 0.64705884456634521, 0.64705884456634521),
            (0.4595959484577179, 0.67058825492858887, 0.67058825492858887),
            (0.46464645862579346, 0.69411766529083252, 0.69411766529083252),
            (0.46969696879386902, 0.72156864404678345, 0.72156864404678345),
            (0.47474747896194458, 0.7450980544090271, 0.7450980544090271),
            (0.47979798913002014, 0.76862746477127075, 0.76862746477127075),
            (0.4848484992980957, 0.7921568751335144, 0.7921568751335144),
            (0.48989897966384888, 0.81568628549575806, 0.81568628549575806),
            (0.49494948983192444, 0.83921569585800171, 0.83921569585800171),
            (0.5, 0.86274510622024536, 0.86274510622024536),
            (0.50505048036575317, 0.88627451658248901, 0.88627451658248901),
            (0.51010102033615112, 0.90980392694473267, 0.90980392694473267),
            (0.5151515007019043, 0.93333333730697632, 0.93333333730697632),
            (0.52020204067230225, 0.95686274766921997, 0.95686274766921997),
            (0.52525252103805542, 0.98039215803146362, 0.98039215803146362),
            (0.53030300140380859, 1.0, 1.0),
            (0.53535354137420654, 1.0, 1.0),
            (0.54040402173995972, 1.0, 1.0),
            (0.54545456171035767, 1.0, 1.0),
            (0.55050504207611084, 1.0, 1.0),
            (0.55555558204650879, 1.0, 1.0),
            (0.56060606241226196, 1.0, 1.0),
            (0.56565654277801514, 1.0, 1.0),
            (0.57070708274841309, 1.0, 1.0),
            (0.57575756311416626, 1.0, 1.0),
            (0.58080810308456421, 1.0, 1.0),
            (0.58585858345031738, 1.0, 1.0),
            (0.59090906381607056, 1.0, 1.0),
            (0.59595960378646851, 1.0, 1.0),
            (0.60101008415222168, 1.0, 1.0),
            (0.60606062412261963, 1.0, 1.0),
            (0.6111111044883728, 1.0, 1.0),
            (0.61616164445877075, 1.0, 1.0),
            (0.62121212482452393, 1.0, 1.0),
            (0.6262626051902771, 1.0, 1.0),
            (0.63131314516067505, 1.0, 1.0),
            (0.63636362552642822, 1.0, 1.0),
            (0.64141416549682617, 1.0, 1.0),
            (0.64646464586257935, 1.0, 1.0),
            (0.65151512622833252, 1.0, 1.0),
            (0.65656566619873047, 1.0, 1.0),
            (0.66161614656448364, 1.0, 1.0),
            (0.66666668653488159, 1.0, 1.0),
            (0.67171716690063477, 1.0, 1.0),
            (0.67676764726638794, 1.0, 1.0),
            (0.68181818723678589, 1.0, 1.0),
            (0.68686866760253906, 1.0, 1.0),
            (0.69191920757293701, 1.0, 1.0),
            (0.69696968793869019, 1.0, 1.0),
            (0.70202022790908813, 1.0, 1.0),
            (0.70707070827484131, 1.0, 1.0),
            (0.71212118864059448, 1.0, 1.0),
            (0.71717172861099243, 1.0, 1.0),
            (0.72222220897674561, 1.0, 1.0),
            (0.72727274894714355, 1.0, 1.0),
            (0.73232322931289673, 1.0, 1.0),
            (0.7373737096786499, 1.0, 1.0),
            (0.74242424964904785, 1.0, 1.0),
            (0.74747473001480103, 1.0, 1.0),
            (0.75252526998519897, 1.0, 1.0),
            (0.75757575035095215, 1.0, 1.0),
            (0.7626262903213501, 1.0, 1.0),
            (0.76767677068710327, 1.0, 1.0),
            (0.77272725105285645, 1.0, 1.0),
            (0.77777779102325439, 1.0, 1.0),
            (0.78282827138900757, 1.0, 1.0),
            (0.78787881135940552, 1.0, 1.0),
            (0.79292929172515869, 1.0, 1.0),
            (0.79797977209091187, 0.96470588445663452, 0.96470588445663452),
            (0.80303031206130981, 0.92549020051956177, 0.92549020051956177),
            (0.80808079242706299, 0.89019608497619629, 0.89019608497619629),
            (0.81313133239746094, 0.85098040103912354, 0.85098040103912354),
            (0.81818181276321411, 0.81568628549575806, 0.81568628549575806),
            (0.82323235273361206, 0.7764706015586853, 0.7764706015586853),
            (0.82828283309936523, 0.74117648601531982, 0.74117648601531982),
            (0.83333331346511841, 0.70196080207824707, 0.70196080207824707),
            (0.83838385343551636, 0.66666668653488159, 0.66666668653488159),
            (0.84343433380126953, 0.62745100259780884, 0.62745100259780884),
            (0.84848487377166748, 0.61960786581039429, 0.61960786581039429),
            (0.85353535413742065, 0.65098041296005249, 0.65098041296005249),
            (0.85858583450317383, 0.68235296010971069, 0.68235296010971069),
            (0.86363637447357178, 0.7137255072593689, 0.7137255072593689),
            (0.86868685483932495, 0.7450980544090271, 0.7450980544090271),
            (0.8737373948097229, 0.77254903316497803, 0.77254903316497803),
            (0.87878787517547607, 0.80392158031463623, 0.80392158031463623),
            (0.88383835554122925, 0.83529412746429443, 0.83529412746429443),
            (0.8888888955116272, 0.86666667461395264, 0.86666667461395264),
            (0.89393937587738037, 0.89803922176361084, 0.89803922176361084),
            (0.89898991584777832, 0.92941176891326904, 0.92941176891326904),
            (0.90404039621353149, 0.93333333730697632, 0.93333333730697632),
            (0.90909093618392944, 0.93725490570068359, 0.93725490570068359),
            (0.91414141654968262, 0.93725490570068359, 0.93725490570068359),
            (0.91919189691543579, 0.94117647409439087, 0.94117647409439087),
            (0.92424243688583374, 0.94509804248809814, 0.94509804248809814),
            (0.92929291725158691, 0.94509804248809814, 0.94509804248809814),
            (0.93434345722198486, 0.94901961088180542, 0.94901961088180542),
            (0.93939393758773804, 0.9529411792755127, 0.9529411792755127),
            (0.94444441795349121, 0.9529411792755127, 0.9529411792755127),
            (0.94949495792388916, 0.95686274766921997, 0.95686274766921997),
            (0.95454543828964233, 0.96078431606292725, 0.96078431606292725),
            (0.95959597826004028, 0.96470588445663452, 0.96470588445663452),
            (0.96464645862579346, 0.9686274528503418, 0.9686274528503418),
            (0.96969699859619141, 0.97254902124404907, 0.97254902124404907),
            (0.97474747896194458, 0.97647058963775635, 0.97647058963775635),
            (0.97979795932769775, 0.98039215803146362, 0.98039215803146362),
            (0.9848484992980957, 0.9843137264251709, 0.9843137264251709),
            (0.98989897966384888, 0.98823529481887817, 0.98823529481887817),
            (0.99494951963424683, 0.99215686321258545, 0.99215686321258545),
            (1.0, 0.99607843160629272, 0.99607843160629272)],
        green = [(0.0, 0.0, 0.0),
            (0.0050505050458014011, 0.035294119268655777, 0.035294119268655777),
            (0.010101010091602802, 0.074509806931018829, 0.074509806931018829),
            (0.015151515603065491, 0.10980392247438431, 0.10980392247438431),
            (0.020202020183205605, 0.14901961386203766, 0.14901961386203766),
            (0.025252524763345718, 0.18431372940540314, 0.18431372940540314),
            (0.030303031206130981, 0.22352941334247589, 0.22352941334247589),
            (0.035353533923625946, 0.25882354378700256, 0.25882354378700256),
            (0.040404040366411209, 0.29803922772407532, 0.29803922772407532),
            (0.045454546809196472, 0.3333333432674408, 0.3333333432674408),
            (0.050505049526691437, 0.37254902720451355, 0.37254902720451355),
            (0.0555555559694767, 0.36862745881080627, 0.36862745881080627),
            (0.060606062412261963, 0.3333333432674408, 0.3333333432674408),
            (0.065656565129756927, 0.29411765933036804, 0.29411765933036804),
            (0.070707067847251892, 0.25882354378700256, 0.25882354378700256),
            (0.075757578015327454, 0.21960784494876862, 0.21960784494876862),
            (0.080808080732822418, 0.18431372940540314, 0.18431372940540314),
            (0.085858583450317383, 0.14509804546833038, 0.14509804546833038),
            (0.090909093618392944, 0.10980392247438431, 0.10980392247438431),
            (0.095959596335887909, 0.070588238537311554, 0.070588238537311554),
            (0.10101009905338287, 0.035294119268655777, 0.035294119268655777),
            (0.10606060922145844, 0.0, 0.0),
            (0.1111111119389534, 0.074509806931018829, 0.074509806931018829),
            (0.11616161465644836, 0.14509804546833038, 0.14509804546833038),
            (0.12121212482452393, 0.21568627655506134, 0.21568627655506134),
            (0.12626262009143829, 0.28627452254295349, 0.28627452254295349),
            (0.13131313025951385, 0.36078432202339172, 0.36078432202339172),
            (0.13636364042758942, 0.43137255311012268, 0.43137255311012268),
            (0.14141413569450378, 0.50196081399917603, 0.50196081399917603),
            (0.14646464586257935, 0.57254904508590698, 0.57254904508590698),
            (0.15151515603065491, 0.64705884456634521, 0.64705884456634521),
            (0.15656565129756927, 0.71764707565307617, 0.71764707565307617),
            (0.16161616146564484, 0.7607843279838562, 0.7607843279838562),
            (0.1666666716337204, 0.78431373834609985, 0.78431373834609985),
            (0.17171716690063477, 0.80784314870834351, 0.80784314870834351),
            (0.17676767706871033, 0.83137255907058716, 0.83137255907058716),
            (0.18181818723678589, 0.85490196943283081, 0.85490196943283081),
            (0.18686868250370026, 0.88235294818878174, 0.88235294818878174),
            (0.19191919267177582, 0.90588235855102539, 0.90588235855102539),
            (0.19696970283985138, 0.92941176891326904, 0.92941176891326904),
            (0.20202019810676575, 0.9529411792755127, 0.9529411792755127),
            (0.20707070827484131, 0.97647058963775635, 0.97647058963775635),
            (0.21212121844291687, 0.99607843160629272, 0.99607843160629272),
            (0.21717171370983124, 0.99607843160629272, 0.99607843160629272),
            (0.2222222238779068, 0.99215686321258545, 0.99215686321258545),
            (0.22727273404598236, 0.99215686321258545, 0.99215686321258545),
            (0.23232322931289673, 0.99215686321258545, 0.99215686321258545),
            (0.23737373948097229, 0.98823529481887817, 0.98823529481887817),
            (0.24242424964904785, 0.98823529481887817, 0.98823529481887817),
            (0.24747474491596222, 0.9843137264251709, 0.9843137264251709),
            (0.25252524018287659, 0.9843137264251709, 0.9843137264251709),
            (0.25757575035095215, 0.98039215803146362, 0.98039215803146362),
            (0.26262626051902771, 0.98039215803146362, 0.98039215803146362),
            (0.26767677068710327, 0.98039215803146362, 0.98039215803146362),
            (0.27272728085517883, 0.98039215803146362, 0.98039215803146362),
            (0.27777779102325439, 0.9843137264251709, 0.9843137264251709),
            (0.28282827138900757, 0.9843137264251709, 0.9843137264251709),
            (0.28787878155708313, 0.98823529481887817, 0.98823529481887817),
            (0.29292929172515869, 0.98823529481887817, 0.98823529481887817),
            (0.29797980189323425, 0.99215686321258545, 0.99215686321258545),
            (0.30303031206130981, 0.99215686321258545, 0.99215686321258545),
            (0.30808082222938538, 0.99607843160629272, 0.99607843160629272),
            (0.31313130259513855, 0.99607843160629272, 0.99607843160629272),
            (0.31818181276321411, 0.99607843160629272, 0.99607843160629272),
            (0.32323232293128967, 0.97647058963775635, 0.97647058963775635),
            (0.32828283309936523, 0.95686274766921997, 0.95686274766921997),
            (0.3333333432674408, 0.93725490570068359, 0.93725490570068359),
            (0.33838382363319397, 0.92156863212585449, 0.92156863212585449),
            (0.34343433380126953, 0.90196079015731812, 0.90196079015731812),
            (0.34848484396934509, 0.88235294818878174, 0.88235294818878174),
            (0.35353535413742065, 0.86274510622024536, 0.86274510622024536),
            (0.35858586430549622, 0.84705883264541626, 0.84705883264541626),
            (0.36363637447357178, 0.82745099067687988, 0.82745099067687988),
            (0.36868685483932495, 0.80784314870834351, 0.80784314870834351),
            (0.37373736500740051, 0.81568628549575806, 0.81568628549575806),
            (0.37878787517547607, 0.83529412746429443, 0.83529412746429443),
            (0.38383838534355164, 0.85098040103912354, 0.85098040103912354),
            (0.3888888955116272, 0.87058824300765991, 0.87058824300765991),
            (0.39393940567970276, 0.89019608497619629, 0.89019608497619629),
            (0.39898988604545593, 0.90980392694473267, 0.90980392694473267),
            (0.40404039621353149, 0.92549020051956177, 0.92549020051956177),
            (0.40909090638160706, 0.94509804248809814, 0.94509804248809814),
            (0.41414141654968262, 0.96470588445663452, 0.96470588445663452),
            (0.41919192671775818, 0.9843137264251709, 0.9843137264251709),
            (0.42424243688583374, 1.0, 1.0),
            (0.42929291725158691, 1.0, 1.0),
            (0.43434342741966248, 1.0, 1.0),
            (0.43939393758773804, 1.0, 1.0),
            (0.4444444477558136, 1.0, 1.0),
            (0.44949495792388916, 1.0, 1.0),
            (0.45454546809196472, 1.0, 1.0),
            (0.4595959484577179, 1.0, 1.0),
            (0.46464645862579346, 1.0, 1.0),
            (0.46969696879386902, 1.0, 1.0),
            (0.47474747896194458, 1.0, 1.0),
            (0.47979798913002014, 1.0, 1.0),
            (0.4848484992980957, 1.0, 1.0),
            (0.48989897966384888, 1.0, 1.0),
            (0.49494948983192444, 1.0, 1.0),
            (0.5, 1.0, 1.0),
            (0.50505048036575317, 1.0, 1.0),
            (0.51010102033615112, 1.0, 1.0),
            (0.5151515007019043, 1.0, 1.0),
            (0.52020204067230225, 1.0, 1.0),
            (0.52525252103805542, 1.0, 1.0),
            (0.53030300140380859, 0.99215686321258545, 0.99215686321258545),
            (0.53535354137420654, 0.98039215803146362, 0.98039215803146362),
            (0.54040402173995972, 0.96470588445663452, 0.96470588445663452),
            (0.54545456171035767, 0.94901961088180542, 0.94901961088180542),
            (0.55050504207611084, 0.93333333730697632, 0.93333333730697632),
            (0.55555558204650879, 0.91764706373214722, 0.91764706373214722),
            (0.56060606241226196, 0.90588235855102539, 0.90588235855102539),
            (0.56565654277801514, 0.89019608497619629, 0.89019608497619629),
            (0.57070708274841309, 0.87450981140136719, 0.87450981140136719),
            (0.57575756311416626, 0.85882353782653809, 0.85882353782653809),
            (0.58080810308456421, 0.84313726425170898, 0.84313726425170898),
            (0.58585858345031738, 0.83137255907058716, 0.83137255907058716),
            (0.59090906381607056, 0.81960785388946533, 0.81960785388946533),
            (0.59595960378646851, 0.81176471710205078, 0.81176471710205078),
            (0.60101008415222168, 0.80000001192092896, 0.80000001192092896),
            (0.60606062412261963, 0.78823530673980713, 0.78823530673980713),
            (0.6111111044883728, 0.7764706015586853, 0.7764706015586853),
            (0.61616164445877075, 0.76470589637756348, 0.76470589637756348),
            (0.62121212482452393, 0.75294119119644165, 0.75294119119644165),
            (0.6262626051902771, 0.74117648601531982, 0.74117648601531982),
            (0.63131314516067505, 0.729411780834198, 0.729411780834198),
            (0.63636362552642822, 0.70980393886566162, 0.70980393886566162),
            (0.64141416549682617, 0.66666668653488159, 0.66666668653488159),
            (0.64646464586257935, 0.62352943420410156, 0.62352943420410156),
            (0.65151512622833252, 0.58039218187332153, 0.58039218187332153),
            (0.65656566619873047, 0.5372549295425415, 0.5372549295425415),
            (0.66161614656448364, 0.49411764740943909, 0.49411764740943909),
            (0.66666668653488159, 0.45098039507865906, 0.45098039507865906),
            (0.67171716690063477, 0.40392157435417175, 0.40392157435417175),
            (0.67676764726638794, 0.36078432202339172, 0.36078432202339172),
            (0.68181818723678589, 0.31764706969261169, 0.31764706969261169),
            (0.68686866760253906, 0.27450981736183167, 0.27450981736183167),
            (0.69191920757293701, 0.24705882370471954, 0.24705882370471954),
            (0.69696968793869019, 0.21960784494876862, 0.21960784494876862),
            (0.70202022790908813, 0.19607843458652496, 0.19607843458652496),
            (0.70707070827484131, 0.16862745583057404, 0.16862745583057404),
            (0.71212118864059448, 0.14509804546833038, 0.14509804546833038),
            (0.71717172861099243, 0.11764705926179886, 0.11764705926179886),
            (0.72222220897674561, 0.090196080505847931, 0.090196080505847931),
            (0.72727274894714355, 0.066666670143604279, 0.066666670143604279),
            (0.73232322931289673, 0.039215687662363052, 0.039215687662363052),
            (0.7373737096786499, 0.015686275437474251, 0.015686275437474251),
            (0.74242424964904785, 0.0, 0.0),
            (0.74747473001480103, 0.0, 0.0),
            (0.75252526998519897, 0.0, 0.0),
            (0.75757575035095215, 0.0, 0.0),
            (0.7626262903213501, 0.0, 0.0),
            (0.76767677068710327, 0.0, 0.0),
            (0.77272725105285645, 0.0, 0.0),
            (0.77777779102325439, 0.0, 0.0),
            (0.78282827138900757, 0.0, 0.0),
            (0.78787881135940552, 0.0, 0.0),
            (0.79292929172515869, 0.0, 0.0),
            (0.79797977209091187, 0.015686275437474251, 0.015686275437474251),
            (0.80303031206130981, 0.031372550874948502, 0.031372550874948502),
            (0.80808079242706299, 0.050980392843484879, 0.050980392843484879),
            (0.81313133239746094, 0.066666670143604279, 0.066666670143604279),
            (0.81818181276321411, 0.086274512112140656, 0.086274512112140656),
            (0.82323235273361206, 0.10588235408067703, 0.10588235408067703),
            (0.82828283309936523, 0.12156862765550613, 0.12156862765550613),
            (0.83333331346511841, 0.14117647707462311, 0.14117647707462311),
            (0.83838385343551636, 0.15686275064945221, 0.15686275064945221),
            (0.84343433380126953, 0.17647059261798859, 0.17647059261798859),
            (0.84848487377166748, 0.20000000298023224, 0.20000000298023224),
            (0.85353535413742065, 0.23137255012989044, 0.23137255012989044),
            (0.85858583450317383, 0.25882354378700256, 0.25882354378700256),
            (0.86363637447357178, 0.29019609093666077, 0.29019609093666077),
            (0.86868685483932495, 0.32156863808631897, 0.32156863808631897),
            (0.8737373948097229, 0.35294118523597717, 0.35294118523597717),
            (0.87878787517547607, 0.38431373238563538, 0.38431373238563538),
            (0.88383835554122925, 0.41568627953529358, 0.41568627953529358),
            (0.8888888955116272, 0.44313725829124451, 0.44313725829124451),
            (0.89393937587738037, 0.47450980544090271, 0.47450980544090271),
            (0.89898991584777832, 0.5058823823928833, 0.5058823823928833),
            (0.90404039621353149, 0.52941179275512695, 0.52941179275512695),
            (0.90909093618392944, 0.55294120311737061, 0.55294120311737061),
            (0.91414141654968262, 0.57254904508590698, 0.57254904508590698),
            (0.91919189691543579, 0.59607845544815063, 0.59607845544815063),
            (0.92424243688583374, 0.61960786581039429, 0.61960786581039429),
            (0.92929291725158691, 0.64313727617263794, 0.64313727617263794),
            (0.93434345722198486, 0.66274511814117432, 0.66274511814117432),
            (0.93939393758773804, 0.68627452850341797, 0.68627452850341797),
            (0.94444441795349121, 0.70980393886566162, 0.70980393886566162),
            (0.94949495792388916, 0.729411780834198, 0.729411780834198),
            (0.95454543828964233, 0.75294119119644165, 0.75294119119644165),
            (0.95959597826004028, 0.78039216995239258, 0.78039216995239258),
            (0.96464645862579346, 0.80392158031463623, 0.80392158031463623),
            (0.96969699859619141, 0.82745099067687988, 0.82745099067687988),
            (0.97474747896194458, 0.85098040103912354, 0.85098040103912354),
            (0.97979795932769775, 0.87450981140136719, 0.87450981140136719),
            (0.9848484992980957, 0.90196079015731812, 0.90196079015731812),
            (0.98989897966384888, 0.92549020051956177, 0.92549020051956177),
            (0.99494951963424683, 0.94901961088180542, 0.94901961088180542),
            (1.0, 0.97254902124404907, 0.97254902124404907)],
        blue = [(0.0, 0.50196081399917603, 0.50196081399917603),
            (0.0050505050458014011, 0.45098039507865906, 0.45098039507865906),
            (0.010101010091602802, 0.40392157435417175, 0.40392157435417175),
            (0.015151515603065491, 0.35686275362968445, 0.35686275362968445),
            (0.020202020183205605, 0.30980393290519714, 0.30980393290519714),
            (0.025252524763345718, 0.25882354378700256, 0.25882354378700256),
            (0.030303031206130981, 0.21176470816135406, 0.21176470816135406),
            (0.035353533923625946, 0.16470588743686676, 0.16470588743686676),
            (0.040404040366411209, 0.11764705926179886, 0.11764705926179886),
            (0.045454546809196472, 0.070588238537311554, 0.070588238537311554),
            (0.050505049526691437, 0.019607843831181526, 0.019607843831181526),
            (0.0555555559694767, 0.047058824449777603, 0.047058824449777603),
            (0.060606062412261963, 0.14509804546833038, 0.14509804546833038),
            (0.065656565129756927, 0.23921568691730499, 0.23921568691730499),
            (0.070707067847251892, 0.3333333432674408, 0.3333333432674408),
            (0.075757578015327454, 0.43137255311012268, 0.43137255311012268),
            (0.080808080732822418, 0.52549022436141968, 0.52549022436141968),
            (0.085858583450317383, 0.61960786581039429, 0.61960786581039429),
            (0.090909093618392944, 0.71764707565307617, 0.71764707565307617),
            (0.095959596335887909, 0.81176471710205078, 0.81176471710205078),
            (0.10101009905338287, 0.90588235855102539, 0.90588235855102539),
            (0.10606060922145844, 1.0, 1.0),
            (0.1111111119389534, 1.0, 1.0),
            (0.11616161465644836, 1.0, 1.0),
            (0.12121212482452393, 1.0, 1.0),
            (0.12626262009143829, 1.0, 1.0),
            (0.13131313025951385, 1.0, 1.0),
            (0.13636364042758942, 1.0, 1.0),
            (0.14141413569450378, 1.0, 1.0),
            (0.14646464586257935, 1.0, 1.0),
            (0.15151515603065491, 1.0, 1.0),
            (0.15656565129756927, 1.0, 1.0),
            (0.16161616146564484, 1.0, 1.0),
            (0.1666666716337204, 1.0, 1.0),
            (0.17171716690063477, 1.0, 1.0),
            (0.17676767706871033, 1.0, 1.0),
            (0.18181818723678589, 1.0, 1.0),
            (0.18686868250370026, 1.0, 1.0),
            (0.19191919267177582, 1.0, 1.0),
            (0.19696970283985138, 1.0, 1.0),
            (0.20202019810676575, 1.0, 1.0),
            (0.20707070827484131, 1.0, 1.0),
            (0.21212121844291687, 0.99215686321258545, 0.99215686321258545),
            (0.21717171370983124, 0.95686274766921997, 0.95686274766921997),
            (0.2222222238779068, 0.91764706373214722, 0.91764706373214722),
            (0.22727273404598236, 0.88235294818878174, 0.88235294818878174),
            (0.23232322931289673, 0.84313726425170898, 0.84313726425170898),
            (0.23737373948097229, 0.80392158031463623, 0.80392158031463623),
            (0.24242424964904785, 0.76862746477127075, 0.76862746477127075),
            (0.24747474491596222, 0.729411780834198, 0.729411780834198),
            (0.25252524018287659, 0.69019609689712524, 0.69019609689712524),
            (0.25757575035095215, 0.65490198135375977, 0.65490198135375977),
            (0.26262626051902771, 0.61568629741668701, 0.61568629741668701),
            (0.26767677068710327, 0.56470590829849243, 0.56470590829849243),
            (0.27272728085517883, 0.50980395078659058, 0.50980395078659058),
            (0.27777779102325439, 0.45098039507865906, 0.45098039507865906),
            (0.28282827138900757, 0.39215686917304993, 0.39215686917304993),
            (0.28787878155708313, 0.3333333432674408, 0.3333333432674408),
            (0.29292929172515869, 0.27843138575553894, 0.27843138575553894),
            (0.29797980189323425, 0.21960784494876862, 0.21960784494876862),
            (0.30303031206130981, 0.16078431904315948, 0.16078431904315948),
            (0.30808082222938538, 0.10588235408067703, 0.10588235408067703),
            (0.31313130259513855, 0.047058824449777603, 0.047058824449777603),
            (0.31818181276321411, 0.0, 0.0),
            (0.32323232293128967, 0.0, 0.0),
            (0.32828283309936523, 0.0, 0.0),
            (0.3333333432674408, 0.0, 0.0),
            (0.33838382363319397, 0.0, 0.0),
            (0.34343433380126953, 0.0, 0.0),
            (0.34848484396934509, 0.0, 0.0),
            (0.35353535413742065, 0.0, 0.0),
            (0.35858586430549622, 0.0, 0.0),
            (0.36363637447357178, 0.0, 0.0),
            (0.36868685483932495, 0.0, 0.0),
            (0.37373736500740051, 0.0, 0.0),
            (0.37878787517547607, 0.0, 0.0),
            (0.38383838534355164, 0.0, 0.0),
            (0.3888888955116272, 0.0, 0.0),
            (0.39393940567970276, 0.0, 0.0),
            (0.39898988604545593, 0.0, 0.0),
            (0.40404039621353149, 0.0, 0.0),
            (0.40909090638160706, 0.0, 0.0),
            (0.41414141654968262, 0.0, 0.0),
            (0.41919192671775818, 0.0, 0.0),
            (0.42424243688583374, 0.0039215688593685627, 0.0039215688593685627),
            (0.42929291725158691, 0.027450980618596077, 0.027450980618596077),
            (0.43434342741966248, 0.050980392843484879, 0.050980392843484879),
            (0.43939393758773804, 0.074509806931018829, 0.074509806931018829),
            (0.4444444477558136, 0.094117648899555206, 0.094117648899555206),
            (0.44949495792388916, 0.11764705926179886, 0.11764705926179886),
            (0.45454546809196472, 0.14117647707462311, 0.14117647707462311),
            (0.4595959484577179, 0.16470588743686676, 0.16470588743686676),
            (0.46464645862579346, 0.18823529779911041, 0.18823529779911041),
            (0.46969696879386902, 0.21176470816135406, 0.21176470816135406),
            (0.47474747896194458, 0.23529411852359772, 0.23529411852359772),
            (0.47979798913002014, 0.22352941334247589, 0.22352941334247589),
            (0.4848484992980957, 0.20000000298023224, 0.20000000298023224),
            (0.48989897966384888, 0.17647059261798859, 0.17647059261798859),
            (0.49494948983192444, 0.15294118225574493, 0.15294118225574493),
            (0.5, 0.12941177189350128, 0.12941177189350128),
            (0.50505048036575317, 0.10980392247438431, 0.10980392247438431),
            (0.51010102033615112, 0.086274512112140656, 0.086274512112140656),
            (0.5151515007019043, 0.062745101749897003, 0.062745101749897003),
            (0.52020204067230225, 0.039215687662363052, 0.039215687662363052),
            (0.52525252103805542, 0.015686275437474251, 0.015686275437474251),
            (0.53030300140380859, 0.0, 0.0),
            (0.53535354137420654, 0.0, 0.0),
            (0.54040402173995972, 0.0, 0.0),
            (0.54545456171035767, 0.0, 0.0),
            (0.55050504207611084, 0.0, 0.0),
            (0.55555558204650879, 0.0, 0.0),
            (0.56060606241226196, 0.0, 0.0),
            (0.56565654277801514, 0.0, 0.0),
            (0.57070708274841309, 0.0, 0.0),
            (0.57575756311416626, 0.0, 0.0),
            (0.58080810308456421, 0.0, 0.0),
            (0.58585858345031738, 0.0039215688593685627, 0.0039215688593685627),
            (0.59090906381607056, 0.0078431377187371254, 0.0078431377187371254),
            (0.59595960378646851, 0.011764706112444401, 0.011764706112444401),
            (0.60101008415222168, 0.019607843831181526, 0.019607843831181526),
            (0.60606062412261963, 0.023529412224888802, 0.023529412224888802),
            (0.6111111044883728, 0.031372550874948502, 0.031372550874948502),
            (0.61616164445877075, 0.035294119268655777, 0.035294119268655777),
            (0.62121212482452393, 0.043137256056070328, 0.043137256056070328),
            (0.6262626051902771, 0.047058824449777603, 0.047058824449777603),
            (0.63131314516067505, 0.054901961237192154, 0.054901961237192154),
            (0.63636362552642822, 0.054901961237192154, 0.054901961237192154),
            (0.64141416549682617, 0.050980392843484879, 0.050980392843484879),
            (0.64646464586257935, 0.043137256056070328, 0.043137256056070328),
            (0.65151512622833252, 0.039215687662363052, 0.039215687662363052),
            (0.65656566619873047, 0.031372550874948502, 0.031372550874948502),
            (0.66161614656448364, 0.027450980618596077, 0.027450980618596077),
            (0.66666668653488159, 0.019607843831181526, 0.019607843831181526),
            (0.67171716690063477, 0.015686275437474251, 0.015686275437474251),
            (0.67676764726638794, 0.011764706112444401, 0.011764706112444401),
            (0.68181818723678589, 0.0039215688593685627, 0.0039215688593685627),
            (0.68686866760253906, 0.0, 0.0),
            (0.69191920757293701, 0.0, 0.0),
            (0.69696968793869019, 0.0, 0.0),
            (0.70202022790908813, 0.0, 0.0),
            (0.70707070827484131, 0.0, 0.0),
            (0.71212118864059448, 0.0, 0.0),
            (0.71717172861099243, 0.0, 0.0),
            (0.72222220897674561, 0.0, 0.0),
            (0.72727274894714355, 0.0, 0.0),
            (0.73232322931289673, 0.0, 0.0),
            (0.7373737096786499, 0.0, 0.0),
            (0.74242424964904785, 0.031372550874948502, 0.031372550874948502),
            (0.74747473001480103, 0.12941177189350128, 0.12941177189350128),
            (0.75252526998519897, 0.22352941334247589, 0.22352941334247589),
            (0.75757575035095215, 0.32156863808631897, 0.32156863808631897),
            (0.7626262903213501, 0.41568627953529358, 0.41568627953529358),
            (0.76767677068710327, 0.50980395078659058, 0.50980395078659058),
            (0.77272725105285645, 0.60784316062927246, 0.60784316062927246),
            (0.77777779102325439, 0.70196080207824707, 0.70196080207824707),
            (0.78282827138900757, 0.79607844352722168, 0.79607844352722168),
            (0.78787881135940552, 0.89411765336990356, 0.89411765336990356),
            (0.79292929172515869, 0.98823529481887817, 0.98823529481887817),
            (0.79797977209091187, 1.0, 1.0),
            (0.80303031206130981, 1.0, 1.0),
            (0.80808079242706299, 1.0, 1.0),
            (0.81313133239746094, 1.0, 1.0),
            (0.81818181276321411, 1.0, 1.0),
            (0.82323235273361206, 1.0, 1.0),
            (0.82828283309936523, 1.0, 1.0),
            (0.83333331346511841, 1.0, 1.0),
            (0.83838385343551636, 1.0, 1.0),
            (0.84343433380126953, 1.0, 1.0),
            (0.84848487377166748, 0.99607843160629272, 0.99607843160629272),
            (0.85353535413742065, 0.98823529481887817, 0.98823529481887817),
            (0.85858583450317383, 0.9843137264251709, 0.9843137264251709),
            (0.86363637447357178, 0.97647058963775635, 0.97647058963775635),
            (0.86868685483932495, 0.9686274528503418, 0.9686274528503418),
            (0.8737373948097229, 0.96470588445663452, 0.96470588445663452),
            (0.87878787517547607, 0.95686274766921997, 0.95686274766921997),
            (0.88383835554122925, 0.94901961088180542, 0.94901961088180542),
            (0.8888888955116272, 0.94509804248809814, 0.94509804248809814),
            (0.89393937587738037, 0.93725490570068359, 0.93725490570068359),
            (0.89898991584777832, 0.93333333730697632, 0.93333333730697632),
            (0.90404039621353149, 0.93333333730697632, 0.93333333730697632),
            (0.90909093618392944, 0.93725490570068359, 0.93725490570068359),
            (0.91414141654968262, 0.93725490570068359, 0.93725490570068359),
            (0.91919189691543579, 0.94117647409439087, 0.94117647409439087),
            (0.92424243688583374, 0.94509804248809814, 0.94509804248809814),
            (0.92929291725158691, 0.94509804248809814, 0.94509804248809814),
            (0.93434345722198486, 0.94901961088180542, 0.94901961088180542),
            (0.93939393758773804, 0.9529411792755127, 0.9529411792755127),
            (0.94444441795349121, 0.9529411792755127, 0.9529411792755127),
            (0.94949495792388916, 0.95686274766921997, 0.95686274766921997),
            (0.95454543828964233, 0.96078431606292725, 0.96078431606292725),
            (0.95959597826004028, 0.96470588445663452, 0.96470588445663452),
            (0.96464645862579346, 0.9686274528503418, 0.9686274528503418),
            (0.96969699859619141, 0.97254902124404907, 0.97254902124404907),
            (0.97474747896194458, 0.97647058963775635, 0.97647058963775635),
            (0.97979795932769775, 0.98039215803146362, 0.98039215803146362),
            (0.9848484992980957, 0.9843137264251709, 0.9843137264251709),
            (0.98989897966384888, 0.98823529481887817, 0.98823529481887817),
            (0.99494951963424683, 0.99215686321258545, 0.99215686321258545),
            (1.0, 0.99607843160629272, 0.99607843160629272)],
    )
    return ColorMapper.from_segment_map(_data, range=range, **traits)

def gist_rainbow(range, **traits):
    """ Generator for the 'gist_rainbow' colormap from GIST.
    """
    _data = dict(
        red = [(0.0, 1.0, 1.0),
            (0.0042016808874905109, 1.0, 1.0),
            (0.0084033617749810219, 1.0, 1.0),
            (0.012605042196810246, 1.0, 1.0),
            (0.016806723549962044, 1.0, 1.0),
            (0.021008403971791267, 1.0, 1.0),
            (0.025210084393620491, 1.0, 1.0),
            (0.029411764815449715, 1.0, 1.0),
            (0.033613447099924088, 1.0, 1.0),
            (0.037815127521753311, 1.0, 1.0),
            (0.042016807943582535, 1.0, 1.0),
            (0.046218488365411758, 1.0, 1.0),
            (0.050420168787240982, 1.0, 1.0),
            (0.054621849209070206, 1.0, 1.0),
            (0.058823529630899429, 1.0, 1.0),
            (0.063025213778018951, 1.0, 1.0),
            (0.067226894199848175, 1.0, 1.0),
            (0.071428574621677399, 1.0, 1.0),
            (0.075630255043506622, 1.0, 1.0),
            (0.079831935465335846, 1.0, 1.0),
            (0.08403361588716507, 1.0, 1.0),
            (0.088235296308994293, 1.0, 1.0),
            (0.092436976730823517, 1.0, 1.0),
            (0.09663865715265274, 1.0, 1.0),
            (0.10084033757448196, 1.0, 1.0),
            (0.10504201799631119, 1.0, 1.0),
            (0.10924369841814041, 1.0, 1.0),
            (0.11344537883996964, 1.0, 1.0),
            (0.11764705926179886, 1.0, 1.0),
            (0.12184873968362808, 1.0, 1.0),
            (0.1260504275560379, 1.0, 1.0),
            (0.13025210797786713, 1.0, 1.0),
            (0.13445378839969635, 1.0, 1.0),
            (0.13865546882152557, 1.0, 1.0),
            (0.1428571492433548, 1.0, 1.0),
            (0.14705882966518402, 1.0, 1.0),
            (0.15126051008701324, 1.0, 1.0),
            (0.15546219050884247, 1.0, 1.0),
            (0.15966387093067169, 1.0, 1.0),
            (0.16386555135250092, 1.0, 1.0),
            (0.16806723177433014, 1.0, 1.0),
            (0.17226891219615936, 1.0, 1.0),
            (0.17647059261798859, 1.0, 1.0),
            (0.18067227303981781, 1.0, 1.0),
            (0.18487395346164703, 1.0, 1.0),
            (0.18907563388347626, 1.0, 1.0),
            (0.19327731430530548, 1.0, 1.0),
            (0.1974789947271347, 1.0, 1.0),
            (0.20168067514896393, 1.0, 1.0),
            (0.20588235557079315, 1.0, 1.0),
            (0.21008403599262238, 1.0, 1.0),
            (0.2142857164144516, 1.0, 1.0),
            (0.21848739683628082, 1.0, 1.0),
            (0.22268907725811005, 0.96078431606292725, 0.96078431606292725),
            (0.22689075767993927, 0.94117647409439087, 0.94117647409439087),
            (0.23109243810176849, 0.92156863212585449, 0.92156863212585449),
            (0.23529411852359772, 0.89803922176361084, 0.89803922176361084),
            (0.23949579894542694, 0.87843137979507446, 0.87843137979507446),
            (0.24369747936725616, 0.85882353782653809, 0.85882353782653809),
            (0.24789915978908539, 0.83529412746429443, 0.83529412746429443),
            (0.25210085511207581, 0.81568628549575806, 0.81568628549575806),
            (0.25630253553390503, 0.7921568751335144, 0.7921568751335144),
            (0.26050421595573425, 0.77254903316497803, 0.77254903316497803),
            (0.26470589637756348, 0.75294119119644165, 0.75294119119644165),
            (0.2689075767993927, 0.729411780834198, 0.729411780834198),
            (0.27310925722122192, 0.70980393886566162, 0.70980393886566162),
            (0.27731093764305115, 0.68627452850341797, 0.68627452850341797),
            (0.28151261806488037, 0.66666668653488159, 0.66666668653488159),
            (0.28571429848670959, 0.62352943420410156, 0.62352943420410156),
            (0.28991597890853882, 0.60392159223556519, 0.60392159223556519),
            (0.29411765933036804, 0.58431375026702881, 0.58431375026702881),
            (0.29831933975219727, 0.56078433990478516, 0.56078433990478516),
            (0.30252102017402649, 0.54117649793624878, 0.54117649793624878),
            (0.30672270059585571, 0.51764708757400513, 0.51764708757400513),
            (0.31092438101768494, 0.49803921580314636, 0.49803921580314636),
            (0.31512606143951416, 0.47843137383460999, 0.47843137383460999),
            (0.31932774186134338, 0.45490196347236633, 0.45490196347236633),
            (0.32352942228317261, 0.43529412150382996, 0.43529412150382996),
            (0.32773110270500183, 0.41568627953529358, 0.41568627953529358),
            (0.33193278312683105, 0.39215686917304993, 0.39215686917304993),
            (0.33613446354866028, 0.37254902720451355, 0.37254902720451355),
            (0.3403361439704895, 0.3490196168422699, 0.3490196168422699),
            (0.34453782439231873, 0.32941177487373352, 0.32941177487373352),
            (0.34873950481414795, 0.28627452254295349, 0.28627452254295349),
            (0.35294118523597717, 0.26666668057441711, 0.26666668057441711),
            (0.3571428656578064, 0.24705882370471954, 0.24705882370471954),
            (0.36134454607963562, 0.22352941334247589, 0.22352941334247589),
            (0.36554622650146484, 0.20392157137393951, 0.20392157137393951),
            (0.36974790692329407, 0.18039216101169586, 0.18039216101169586),
            (0.37394958734512329, 0.16078431904315948, 0.16078431904315948),
            (0.37815126776695251, 0.14117647707462311, 0.14117647707462311),
            (0.38235294818878174, 0.11764705926179886, 0.11764705926179886),
            (0.38655462861061096, 0.098039217293262482, 0.098039217293262482),
            (0.39075630903244019, 0.074509806931018829, 0.074509806931018829),
            (0.39495798945426941, 0.054901961237192154, 0.054901961237192154),
            (0.39915966987609863, 0.035294119268655777, 0.035294119268655777),
            (0.40336135029792786, 0.011764706112444401, 0.011764706112444401),
            (0.40756303071975708, 0.0, 0.0),
            (0.4117647111415863, 0.0, 0.0),
            (0.41596639156341553, 0.0, 0.0),
            (0.42016807198524475, 0.0, 0.0),
            (0.42436975240707397, 0.0, 0.0),
            (0.4285714328289032, 0.0, 0.0),
            (0.43277311325073242, 0.0, 0.0),
            (0.43697479367256165, 0.0, 0.0),
            (0.44117647409439087, 0.0, 0.0),
            (0.44537815451622009, 0.0, 0.0),
            (0.44957983493804932, 0.0, 0.0),
            (0.45378151535987854, 0.0, 0.0),
            (0.45798319578170776, 0.0, 0.0),
            (0.46218487620353699, 0.0, 0.0),
            (0.46638655662536621, 0.0, 0.0),
            (0.47058823704719543, 0.0, 0.0),
            (0.47478991746902466, 0.0, 0.0),
            (0.47899159789085388, 0.0, 0.0),
            (0.48319327831268311, 0.0, 0.0),
            (0.48739495873451233, 0.0, 0.0),
            (0.49159663915634155, 0.0, 0.0),
            (0.49579831957817078, 0.0, 0.0),
            (0.5, 0.0, 0.0),
            (0.50420171022415161, 0.0, 0.0),
            (0.50840336084365845, 0.0, 0.0),
            (0.51260507106781006, 0.0, 0.0),
            (0.51680672168731689, 0.0, 0.0),
            (0.52100843191146851, 0.0, 0.0),
            (0.52521008253097534, 0.0, 0.0),
            (0.52941179275512695, 0.0, 0.0),
            (0.53361344337463379, 0.0, 0.0),
            (0.5378151535987854, 0.0, 0.0),
            (0.54201680421829224, 0.0, 0.0),
            (0.54621851444244385, 0.0, 0.0),
            (0.55042016506195068, 0.0, 0.0),
            (0.55462187528610229, 0.0, 0.0),
            (0.55882352590560913, 0.0, 0.0),
            (0.56302523612976074, 0.0, 0.0),
            (0.56722688674926758, 0.0, 0.0),
            (0.57142859697341919, 0.0, 0.0),
            (0.57563024759292603, 0.0, 0.0),
            (0.57983195781707764, 0.0, 0.0),
            (0.58403360843658447, 0.0, 0.0),
            (0.58823531866073608, 0.0, 0.0),
            (0.59243696928024292, 0.0, 0.0),
            (0.59663867950439453, 0.0, 0.0),
            (0.60084033012390137, 0.0, 0.0),
            (0.60504204034805298, 0.0, 0.0),
            (0.60924369096755981, 0.0, 0.0),
            (0.61344540119171143, 0.0, 0.0),
            (0.61764705181121826, 0.0, 0.0),
            (0.62184876203536987, 0.0, 0.0),
            (0.62605041265487671, 0.0, 0.0),
            (0.63025212287902832, 0.0, 0.0),
            (0.63445377349853516, 0.0, 0.0),
            (0.63865548372268677, 0.0, 0.0),
            (0.6428571343421936, 0.0, 0.0),
            (0.64705884456634521, 0.0, 0.0),
            (0.65126049518585205, 0.0, 0.0),
            (0.65546220541000366, 0.0, 0.0),
            (0.6596638560295105, 0.0, 0.0),
            (0.66386556625366211, 0.0, 0.0),
            (0.66806721687316895, 0.0, 0.0),
            (0.67226892709732056, 0.0, 0.0),
            (0.67647057771682739, 0.0, 0.0),
            (0.680672287940979, 0.0, 0.0),
            (0.68487393856048584, 0.0, 0.0),
            (0.68907564878463745, 0.0, 0.0),
            (0.69327729940414429, 0.0, 0.0),
            (0.6974790096282959, 0.0, 0.0),
            (0.70168066024780273, 0.0, 0.0),
            (0.70588237047195435, 0.0, 0.0),
            (0.71008402109146118, 0.0, 0.0),
            (0.71428573131561279, 0.0, 0.0),
            (0.71848738193511963, 0.0, 0.0),
            (0.72268909215927124, 0.0, 0.0),
            (0.72689074277877808, 0.0, 0.0),
            (0.73109245300292969, 0.0, 0.0),
            (0.73529410362243652, 0.0, 0.0),
            (0.73949581384658813, 0.0, 0.0),
            (0.74369746446609497, 0.0, 0.0),
            (0.74789917469024658, 0.0, 0.0),
            (0.75210082530975342, 0.0, 0.0),
            (0.75630253553390503, 0.0, 0.0),
            (0.76050418615341187, 0.0, 0.0),
            (0.76470589637756348, 0.0, 0.0),
            (0.76890754699707031, 0.0, 0.0),
            (0.77310925722122192, 0.0, 0.0),
            (0.77731090784072876, 0.0, 0.0),
            (0.78151261806488037, 0.0078431377187371254, 0.0078431377187371254),
            (0.78571426868438721, 0.027450980618596077, 0.027450980618596077),
            (0.78991597890853882, 0.070588238537311554, 0.070588238537311554),
            (0.79411762952804565, 0.094117648899555206, 0.094117648899555206),
            (0.79831933975219727, 0.11372549086809158, 0.11372549086809158),
            (0.8025209903717041, 0.13333334028720856, 0.13333334028720856),
            (0.80672270059585571, 0.15686275064945221, 0.15686275064945221),
            (0.81092435121536255, 0.17647059261798859, 0.17647059261798859),
            (0.81512606143951416, 0.19607843458652496, 0.19607843458652496),
            (0.819327712059021, 0.21960784494876862, 0.21960784494876862),
            (0.82352942228317261, 0.23921568691730499, 0.23921568691730499),
            (0.82773107290267944, 0.26274511218070984, 0.26274511218070984),
            (0.83193278312683105, 0.28235295414924622, 0.28235295414924622),
            (0.83613443374633789, 0.30196079611778259, 0.30196079611778259),
            (0.8403361439704895, 0.32549020648002625, 0.32549020648002625),
            (0.84453779458999634, 0.34509804844856262, 0.34509804844856262),
            (0.84873950481414795, 0.364705890417099, 0.364705890417099),
            (0.85294115543365479, 0.40784314274787903, 0.40784314274787903),
            (0.8571428656578064, 0.43137255311012268, 0.43137255311012268),
            (0.86134451627731323, 0.45098039507865906, 0.45098039507865906),
            (0.86554622650146484, 0.47058823704719543, 0.47058823704719543),
            (0.86974787712097168, 0.49411764740943909, 0.49411764740943909),
            (0.87394958734512329, 0.51372551918029785, 0.51372551918029785),
            (0.87815123796463013, 0.53333336114883423, 0.53333336114883423),
            (0.88235294818878174, 0.55686277151107788, 0.55686277151107788),
            (0.88655459880828857, 0.57647061347961426, 0.57647061347961426),
            (0.89075630903244019, 0.60000002384185791, 0.60000002384185791),
            (0.89495795965194702, 0.61960786581039429, 0.61960786581039429),
            (0.89915966987609863, 0.63921570777893066, 0.63921570777893066),
            (0.90336132049560547, 0.66274511814117432, 0.66274511814117432),
            (0.90756303071975708, 0.68235296010971069, 0.68235296010971069),
            (0.91176468133926392, 0.70588237047195435, 0.70588237047195435),
            (0.91596639156341553, 0.7450980544090271, 0.7450980544090271),
            (0.92016804218292236, 0.76862746477127075, 0.76862746477127075),
            (0.92436975240707397, 0.78823530673980713, 0.78823530673980713),
            (0.92857140302658081, 0.80784314870834351, 0.80784314870834351),
            (0.93277311325073242, 0.83137255907058716, 0.83137255907058716),
            (0.93697476387023926, 0.85098040103912354, 0.85098040103912354),
            (0.94117647409439087, 0.87450981140136719, 0.87450981140136719),
            (0.94537812471389771, 0.89411765336990356, 0.89411765336990356),
            (0.94957983493804932, 0.91372549533843994, 0.91372549533843994),
            (0.95378148555755615, 0.93725490570068359, 0.93725490570068359),
            (0.95798319578170776, 0.95686274766921997, 0.95686274766921997),
            (0.9621848464012146, 0.97647058963775635, 0.97647058963775635),
            (0.96638655662536621, 1.0, 1.0),
            (0.97058820724487305, 1.0, 1.0),
            (0.97478991746902466, 1.0, 1.0),
            (0.97899156808853149, 1.0, 1.0),
            (0.98319327831268311, 1.0, 1.0),
            (0.98739492893218994, 1.0, 1.0),
            (0.99159663915634155, 1.0, 1.0),
            (0.99579828977584839, 1.0, 1.0),
            (1.0, 1.0, 1.0)],
        green = [(0.0, 0.0, 0.0),
            (0.0042016808874905109, 0.0, 0.0),
            (0.0084033617749810219, 0.0, 0.0),
            (0.012605042196810246, 0.0, 0.0),
            (0.016806723549962044, 0.0, 0.0),
            (0.021008403971791267, 0.0, 0.0),
            (0.025210084393620491, 0.0, 0.0),
            (0.029411764815449715, 0.0, 0.0),
            (0.033613447099924088, 0.019607843831181526, 0.019607843831181526),
            (0.037815127521753311, 0.043137256056070328, 0.043137256056070328),
            (0.042016807943582535, 0.062745101749897003, 0.062745101749897003),
            (0.046218488365411758, 0.086274512112140656, 0.086274512112140656),
            (0.050420168787240982, 0.10588235408067703, 0.10588235408067703),
            (0.054621849209070206, 0.12549020349979401, 0.12549020349979401),
            (0.058823529630899429, 0.14901961386203766, 0.14901961386203766),
            (0.063025213778018951, 0.16862745583057404, 0.16862745583057404),
            (0.067226894199848175, 0.18823529779911041, 0.18823529779911041),
            (0.071428574621677399, 0.21176470816135406, 0.21176470816135406),
            (0.075630255043506622, 0.23137255012989044, 0.23137255012989044),
            (0.079831935465335846, 0.25490197539329529, 0.25490197539329529),
            (0.08403361588716507, 0.27450981736183167, 0.27450981736183167),
            (0.088235296308994293, 0.29411765933036804, 0.29411765933036804),
            (0.092436976730823517, 0.31764706969261169, 0.31764706969261169),
            (0.09663865715265274, 0.35686275362968445, 0.35686275362968445),
            (0.10084033757448196, 0.3803921639919281, 0.3803921639919281),
            (0.10504201799631119, 0.40000000596046448, 0.40000000596046448),
            (0.10924369841814041, 0.42352941632270813, 0.42352941632270813),
            (0.11344537883996964, 0.44313725829124451, 0.44313725829124451),
            (0.11764705926179886, 0.46274510025978088, 0.46274510025978088),
            (0.12184873968362808, 0.48627451062202454, 0.48627451062202454),
            (0.1260504275560379, 0.5058823823928833, 0.5058823823928833),
            (0.13025210797786713, 0.52941179275512695, 0.52941179275512695),
            (0.13445378839969635, 0.54901963472366333, 0.54901963472366333),
            (0.13865546882152557, 0.56862747669219971, 0.56862747669219971),
            (0.1428571492433548, 0.59215688705444336, 0.59215688705444336),
            (0.14705882966518402, 0.61176472902297974, 0.61176472902297974),
            (0.15126051008701324, 0.63137257099151611, 0.63137257099151611),
            (0.15546219050884247, 0.65490198135375977, 0.65490198135375977),
            (0.15966387093067169, 0.69803923368453979, 0.69803923368453979),
            (0.16386555135250092, 0.71764707565307617, 0.71764707565307617),
            (0.16806723177433014, 0.73725491762161255, 0.73725491762161255),
            (0.17226891219615936, 0.7607843279838562, 0.7607843279838562),
            (0.17647059261798859, 0.78039216995239258, 0.78039216995239258),
            (0.18067227303981781, 0.80000001192092896, 0.80000001192092896),
            (0.18487395346164703, 0.82352942228317261, 0.82352942228317261),
            (0.18907563388347626, 0.84313726425170898, 0.84313726425170898),
            (0.19327731430530548, 0.86666667461395264, 0.86666667461395264),
            (0.1974789947271347, 0.88627451658248901, 0.88627451658248901),
            (0.20168067514896393, 0.90588235855102539, 0.90588235855102539),
            (0.20588235557079315, 0.92941176891326904, 0.92941176891326904),
            (0.21008403599262238, 0.94901961088180542, 0.94901961088180542),
            (0.2142857164144516, 0.9686274528503418, 0.9686274528503418),
            (0.21848739683628082, 0.99215686321258545, 0.99215686321258545),
            (0.22268907725811005, 1.0, 1.0),
            (0.22689075767993927, 1.0, 1.0),
            (0.23109243810176849, 1.0, 1.0),
            (0.23529411852359772, 1.0, 1.0),
            (0.23949579894542694, 1.0, 1.0),
            (0.24369747936725616, 1.0, 1.0),
            (0.24789915978908539, 1.0, 1.0),
            (0.25210085511207581, 1.0, 1.0),
            (0.25630253553390503, 1.0, 1.0),
            (0.26050421595573425, 1.0, 1.0),
            (0.26470589637756348, 1.0, 1.0),
            (0.2689075767993927, 1.0, 1.0),
            (0.27310925722122192, 1.0, 1.0),
            (0.27731093764305115, 1.0, 1.0),
            (0.28151261806488037, 1.0, 1.0),
            (0.28571429848670959, 1.0, 1.0),
            (0.28991597890853882, 1.0, 1.0),
            (0.29411765933036804, 1.0, 1.0),
            (0.29831933975219727, 1.0, 1.0),
            (0.30252102017402649, 1.0, 1.0),
            (0.30672270059585571, 1.0, 1.0),
            (0.31092438101768494, 1.0, 1.0),
            (0.31512606143951416, 1.0, 1.0),
            (0.31932774186134338, 1.0, 1.0),
            (0.32352942228317261, 1.0, 1.0),
            (0.32773110270500183, 1.0, 1.0),
            (0.33193278312683105, 1.0, 1.0),
            (0.33613446354866028, 1.0, 1.0),
            (0.3403361439704895, 1.0, 1.0),
            (0.34453782439231873, 1.0, 1.0),
            (0.34873950481414795, 1.0, 1.0),
            (0.35294118523597717, 1.0, 1.0),
            (0.3571428656578064, 1.0, 1.0),
            (0.36134454607963562, 1.0, 1.0),
            (0.36554622650146484, 1.0, 1.0),
            (0.36974790692329407, 1.0, 1.0),
            (0.37394958734512329, 1.0, 1.0),
            (0.37815126776695251, 1.0, 1.0),
            (0.38235294818878174, 1.0, 1.0),
            (0.38655462861061096, 1.0, 1.0),
            (0.39075630903244019, 1.0, 1.0),
            (0.39495798945426941, 1.0, 1.0),
            (0.39915966987609863, 1.0, 1.0),
            (0.40336135029792786, 1.0, 1.0),
            (0.40756303071975708, 1.0, 1.0),
            (0.4117647111415863, 1.0, 1.0),
            (0.41596639156341553, 1.0, 1.0),
            (0.42016807198524475, 1.0, 1.0),
            (0.42436975240707397, 1.0, 1.0),
            (0.4285714328289032, 1.0, 1.0),
            (0.43277311325073242, 1.0, 1.0),
            (0.43697479367256165, 1.0, 1.0),
            (0.44117647409439087, 1.0, 1.0),
            (0.44537815451622009, 1.0, 1.0),
            (0.44957983493804932, 1.0, 1.0),
            (0.45378151535987854, 1.0, 1.0),
            (0.45798319578170776, 1.0, 1.0),
            (0.46218487620353699, 1.0, 1.0),
            (0.46638655662536621, 1.0, 1.0),
            (0.47058823704719543, 1.0, 1.0),
            (0.47478991746902466, 1.0, 1.0),
            (0.47899159789085388, 1.0, 1.0),
            (0.48319327831268311, 1.0, 1.0),
            (0.48739495873451233, 1.0, 1.0),
            (0.49159663915634155, 1.0, 1.0),
            (0.49579831957817078, 1.0, 1.0),
            (0.5, 1.0, 1.0),
            (0.50420171022415161, 1.0, 1.0),
            (0.50840336084365845, 1.0, 1.0),
            (0.51260507106781006, 1.0, 1.0),
            (0.51680672168731689, 1.0, 1.0),
            (0.52100843191146851, 1.0, 1.0),
            (0.52521008253097534, 1.0, 1.0),
            (0.52941179275512695, 1.0, 1.0),
            (0.53361344337463379, 1.0, 1.0),
            (0.5378151535987854, 1.0, 1.0),
            (0.54201680421829224, 1.0, 1.0),
            (0.54621851444244385, 1.0, 1.0),
            (0.55042016506195068, 1.0, 1.0),
            (0.55462187528610229, 1.0, 1.0),
            (0.55882352590560913, 1.0, 1.0),
            (0.56302523612976074, 1.0, 1.0),
            (0.56722688674926758, 1.0, 1.0),
            (0.57142859697341919, 1.0, 1.0),
            (0.57563024759292603, 1.0, 1.0),
            (0.57983195781707764, 1.0, 1.0),
            (0.58403360843658447, 1.0, 1.0),
            (0.58823531866073608, 1.0, 1.0),
            (0.59243696928024292, 1.0, 1.0),
            (0.59663867950439453, 0.98039215803146362, 0.98039215803146362),
            (0.60084033012390137, 0.93725490570068359, 0.93725490570068359),
            (0.60504204034805298, 0.91764706373214722, 0.91764706373214722),
            (0.60924369096755981, 0.89411765336990356, 0.89411765336990356),
            (0.61344540119171143, 0.87450981140136719, 0.87450981140136719),
            (0.61764705181121826, 0.85490196943283081, 0.85490196943283081),
            (0.62184876203536987, 0.83137255907058716, 0.83137255907058716),
            (0.62605041265487671, 0.81176471710205078, 0.81176471710205078),
            (0.63025212287902832, 0.78823530673980713, 0.78823530673980713),
            (0.63445377349853516, 0.76862746477127075, 0.76862746477127075),
            (0.63865548372268677, 0.74901962280273438, 0.74901962280273438),
            (0.6428571343421936, 0.72549021244049072, 0.72549021244049072),
            (0.64705884456634521, 0.70588237047195435, 0.70588237047195435),
            (0.65126049518585205, 0.68235296010971069, 0.68235296010971069),
            (0.65546220541000366, 0.66274511814117432, 0.66274511814117432),
            (0.6596638560295105, 0.64313727617263794, 0.64313727617263794),
            (0.66386556625366211, 0.60000002384185791, 0.60000002384185791),
            (0.66806721687316895, 0.58039218187332153, 0.58039218187332153),
            (0.67226892709732056, 0.55686277151107788, 0.55686277151107788),
            (0.67647057771682739, 0.5372549295425415, 0.5372549295425415),
            (0.680672287940979, 0.51372551918029785, 0.51372551918029785),
            (0.68487393856048584, 0.49411764740943909, 0.49411764740943909),
            (0.68907564878463745, 0.47450980544090271, 0.47450980544090271),
            (0.69327729940414429, 0.45098039507865906, 0.45098039507865906),
            (0.6974790096282959, 0.43137255311012268, 0.43137255311012268),
            (0.70168066024780273, 0.4117647111415863, 0.4117647111415863),
            (0.70588237047195435, 0.38823530077934265, 0.38823530077934265),
            (0.71008402109146118, 0.36862745881080627, 0.36862745881080627),
            (0.71428573131561279, 0.34509804844856262, 0.34509804844856262),
            (0.71848738193511963, 0.32549020648002625, 0.32549020648002625),
            (0.72268909215927124, 0.30588236451148987, 0.30588236451148987),
            (0.72689074277877808, 0.26274511218070984, 0.26274511218070984),
            (0.73109245300292969, 0.24313725531101227, 0.24313725531101227),
            (0.73529410362243652, 0.21960784494876862, 0.21960784494876862),
            (0.73949581384658813, 0.20000000298023224, 0.20000000298023224),
            (0.74369746446609497, 0.17647059261798859, 0.17647059261798859),
            (0.74789917469024658, 0.15686275064945221, 0.15686275064945221),
            (0.75210082530975342, 0.13725490868091583, 0.13725490868091583),
            (0.75630253553390503, 0.11372549086809158, 0.11372549086809158),
            (0.76050418615341187, 0.094117648899555206, 0.094117648899555206),
            (0.76470589637756348, 0.070588238537311554, 0.070588238537311554),
            (0.76890754699707031, 0.050980392843484879, 0.050980392843484879),
            (0.77310925722122192, 0.031372550874948502, 0.031372550874948502),
            (0.77731090784072876, 0.0078431377187371254, 0.0078431377187371254),
            (0.78151261806488037, 0.0, 0.0),
            (0.78571426868438721, 0.0, 0.0),
            (0.78991597890853882, 0.0, 0.0),
            (0.79411762952804565, 0.0, 0.0),
            (0.79831933975219727, 0.0, 0.0),
            (0.8025209903717041, 0.0, 0.0),
            (0.80672270059585571, 0.0, 0.0),
            (0.81092435121536255, 0.0, 0.0),
            (0.81512606143951416, 0.0, 0.0),
            (0.819327712059021, 0.0, 0.0),
            (0.82352942228317261, 0.0, 0.0),
            (0.82773107290267944, 0.0, 0.0),
            (0.83193278312683105, 0.0, 0.0),
            (0.83613443374633789, 0.0, 0.0),
            (0.8403361439704895, 0.0, 0.0),
            (0.84453779458999634, 0.0, 0.0),
            (0.84873950481414795, 0.0, 0.0),
            (0.85294115543365479, 0.0, 0.0),
            (0.8571428656578064, 0.0, 0.0),
            (0.86134451627731323, 0.0, 0.0),
            (0.86554622650146484, 0.0, 0.0),
            (0.86974787712097168, 0.0, 0.0),
            (0.87394958734512329, 0.0, 0.0),
            (0.87815123796463013, 0.0, 0.0),
            (0.88235294818878174, 0.0, 0.0),
            (0.88655459880828857, 0.0, 0.0),
            (0.89075630903244019, 0.0, 0.0),
            (0.89495795965194702, 0.0, 0.0),
            (0.89915966987609863, 0.0, 0.0),
            (0.90336132049560547, 0.0, 0.0),
            (0.90756303071975708, 0.0, 0.0),
            (0.91176468133926392, 0.0, 0.0),
            (0.91596639156341553, 0.0, 0.0),
            (0.92016804218292236, 0.0, 0.0),
            (0.92436975240707397, 0.0, 0.0),
            (0.92857140302658081, 0.0, 0.0),
            (0.93277311325073242, 0.0, 0.0),
            (0.93697476387023926, 0.0, 0.0),
            (0.94117647409439087, 0.0, 0.0),
            (0.94537812471389771, 0.0, 0.0),
            (0.94957983493804932, 0.0, 0.0),
            (0.95378148555755615, 0.0, 0.0),
            (0.95798319578170776, 0.0, 0.0),
            (0.9621848464012146, 0.0, 0.0),
            (0.96638655662536621, 0.0, 0.0),
            (0.97058820724487305, 0.0, 0.0),
            (0.97478991746902466, 0.0, 0.0),
            (0.97899156808853149, 0.0, 0.0),
            (0.98319327831268311, 0.0, 0.0),
            (0.98739492893218994, 0.0, 0.0),
            (0.99159663915634155, 0.0, 0.0),
            (0.99579828977584839, 0.0, 0.0),
            (1.0, 0.0, 0.0)],
        blue = [(0.0, 0.16470588743686676, 0.16470588743686676),
            (0.0042016808874905109, 0.14117647707462311, 0.14117647707462311),
            (0.0084033617749810219, 0.12156862765550613, 0.12156862765550613),
            (0.012605042196810246, 0.10196078568696976, 0.10196078568696976),
            (0.016806723549962044, 0.078431375324726105, 0.078431375324726105),
            (0.021008403971791267, 0.058823529630899429, 0.058823529630899429),
            (0.025210084393620491, 0.039215687662363052, 0.039215687662363052),
            (0.029411764815449715, 0.015686275437474251, 0.015686275437474251),
            (0.033613447099924088, 0.0, 0.0),
            (0.037815127521753311, 0.0, 0.0),
            (0.042016807943582535, 0.0, 0.0),
            (0.046218488365411758, 0.0, 0.0),
            (0.050420168787240982, 0.0, 0.0),
            (0.054621849209070206, 0.0, 0.0),
            (0.058823529630899429, 0.0, 0.0),
            (0.063025213778018951, 0.0, 0.0),
            (0.067226894199848175, 0.0, 0.0),
            (0.071428574621677399, 0.0, 0.0),
            (0.075630255043506622, 0.0, 0.0),
            (0.079831935465335846, 0.0, 0.0),
            (0.08403361588716507, 0.0, 0.0),
            (0.088235296308994293, 0.0, 0.0),
            (0.092436976730823517, 0.0, 0.0),
            (0.09663865715265274, 0.0, 0.0),
            (0.10084033757448196, 0.0, 0.0),
            (0.10504201799631119, 0.0, 0.0),
            (0.10924369841814041, 0.0, 0.0),
            (0.11344537883996964, 0.0, 0.0),
            (0.11764705926179886, 0.0, 0.0),
            (0.12184873968362808, 0.0, 0.0),
            (0.1260504275560379, 0.0, 0.0),
            (0.13025210797786713, 0.0, 0.0),
            (0.13445378839969635, 0.0, 0.0),
            (0.13865546882152557, 0.0, 0.0),
            (0.1428571492433548, 0.0, 0.0),
            (0.14705882966518402, 0.0, 0.0),
            (0.15126051008701324, 0.0, 0.0),
            (0.15546219050884247, 0.0, 0.0),
            (0.15966387093067169, 0.0, 0.0),
            (0.16386555135250092, 0.0, 0.0),
            (0.16806723177433014, 0.0, 0.0),
            (0.17226891219615936, 0.0, 0.0),
            (0.17647059261798859, 0.0, 0.0),
            (0.18067227303981781, 0.0, 0.0),
            (0.18487395346164703, 0.0, 0.0),
            (0.18907563388347626, 0.0, 0.0),
            (0.19327731430530548, 0.0, 0.0),
            (0.1974789947271347, 0.0, 0.0),
            (0.20168067514896393, 0.0, 0.0),
            (0.20588235557079315, 0.0, 0.0),
            (0.21008403599262238, 0.0, 0.0),
            (0.2142857164144516, 0.0, 0.0),
            (0.21848739683628082, 0.0, 0.0),
            (0.22268907725811005, 0.0, 0.0),
            (0.22689075767993927, 0.0, 0.0),
            (0.23109243810176849, 0.0, 0.0),
            (0.23529411852359772, 0.0, 0.0),
            (0.23949579894542694, 0.0, 0.0),
            (0.24369747936725616, 0.0, 0.0),
            (0.24789915978908539, 0.0, 0.0),
            (0.25210085511207581, 0.0, 0.0),
            (0.25630253553390503, 0.0, 0.0),
            (0.26050421595573425, 0.0, 0.0),
            (0.26470589637756348, 0.0, 0.0),
            (0.2689075767993927, 0.0, 0.0),
            (0.27310925722122192, 0.0, 0.0),
            (0.27731093764305115, 0.0, 0.0),
            (0.28151261806488037, 0.0, 0.0),
            (0.28571429848670959, 0.0, 0.0),
            (0.28991597890853882, 0.0, 0.0),
            (0.29411765933036804, 0.0, 0.0),
            (0.29831933975219727, 0.0, 0.0),
            (0.30252102017402649, 0.0, 0.0),
            (0.30672270059585571, 0.0, 0.0),
            (0.31092438101768494, 0.0, 0.0),
            (0.31512606143951416, 0.0, 0.0),
            (0.31932774186134338, 0.0, 0.0),
            (0.32352942228317261, 0.0, 0.0),
            (0.32773110270500183, 0.0, 0.0),
            (0.33193278312683105, 0.0, 0.0),
            (0.33613446354866028, 0.0, 0.0),
            (0.3403361439704895, 0.0, 0.0),
            (0.34453782439231873, 0.0, 0.0),
            (0.34873950481414795, 0.0, 0.0),
            (0.35294118523597717, 0.0, 0.0),
            (0.3571428656578064, 0.0, 0.0),
            (0.36134454607963562, 0.0, 0.0),
            (0.36554622650146484, 0.0, 0.0),
            (0.36974790692329407, 0.0, 0.0),
            (0.37394958734512329, 0.0, 0.0),
            (0.37815126776695251, 0.0, 0.0),
            (0.38235294818878174, 0.0, 0.0),
            (0.38655462861061096, 0.0, 0.0),
            (0.39075630903244019, 0.0, 0.0),
            (0.39495798945426941, 0.0, 0.0),
            (0.39915966987609863, 0.0, 0.0),
            (0.40336135029792786, 0.0, 0.0),
            (0.40756303071975708, 0.0039215688593685627, 0.0039215688593685627),
            (0.4117647111415863, 0.047058824449777603, 0.047058824449777603),
            (0.41596639156341553, 0.066666670143604279, 0.066666670143604279),
            (0.42016807198524475, 0.090196080505847931, 0.090196080505847931),
            (0.42436975240707397, 0.10980392247438431, 0.10980392247438431),
            (0.4285714328289032, 0.12941177189350128, 0.12941177189350128),
            (0.43277311325073242, 0.15294118225574493, 0.15294118225574493),
            (0.43697479367256165, 0.17254902422428131, 0.17254902422428131),
            (0.44117647409439087, 0.19215686619281769, 0.19215686619281769),
            (0.44537815451622009, 0.21568627655506134, 0.21568627655506134),
            (0.44957983493804932, 0.23529411852359772, 0.23529411852359772),
            (0.45378151535987854, 0.25882354378700256, 0.25882354378700256),
            (0.45798319578170776, 0.27843138575553894, 0.27843138575553894),
            (0.46218487620353699, 0.29803922772407532, 0.29803922772407532),
            (0.46638655662536621, 0.32156863808631897, 0.32156863808631897),
            (0.47058823704719543, 0.34117648005485535, 0.34117648005485535),
            (0.47478991746902466, 0.38431373238563538, 0.38431373238563538),
            (0.47899159789085388, 0.40392157435417175, 0.40392157435417175),
            (0.48319327831268311, 0.42745098471641541, 0.42745098471641541),
            (0.48739495873451233, 0.44705882668495178, 0.44705882668495178),
            (0.49159663915634155, 0.46666666865348816, 0.46666666865348816),
            (0.49579831957817078, 0.49019607901573181, 0.49019607901573181),
            (0.5, 0.50980395078659058, 0.50980395078659058),
            (0.50420171022415161, 0.52941179275512695, 0.52941179275512695),
            (0.50840336084365845, 0.55294120311737061, 0.55294120311737061),
            (0.51260507106781006, 0.57254904508590698, 0.57254904508590698),
            (0.51680672168731689, 0.59607845544815063, 0.59607845544815063),
            (0.52100843191146851, 0.61568629741668701, 0.61568629741668701),
            (0.52521008253097534, 0.63529413938522339, 0.63529413938522339),
            (0.52941179275512695, 0.65882354974746704, 0.65882354974746704),
            (0.53361344337463379, 0.67843139171600342, 0.67843139171600342),
            (0.5378151535987854, 0.72156864404678345, 0.72156864404678345),
            (0.54201680421829224, 0.74117648601531982, 0.74117648601531982),
            (0.54621851444244385, 0.76470589637756348, 0.76470589637756348),
            (0.55042016506195068, 0.78431373834609985, 0.78431373834609985),
            (0.55462187528610229, 0.80392158031463623, 0.80392158031463623),
            (0.55882352590560913, 0.82745099067687988, 0.82745099067687988),
            (0.56302523612976074, 0.84705883264541626, 0.84705883264541626),
            (0.56722688674926758, 0.87058824300765991, 0.87058824300765991),
            (0.57142859697341919, 0.89019608497619629, 0.89019608497619629),
            (0.57563024759292603, 0.90980392694473267, 0.90980392694473267),
            (0.57983195781707764, 0.93333333730697632, 0.93333333730697632),
            (0.58403360843658447, 0.9529411792755127, 0.9529411792755127),
            (0.58823531866073608, 0.97254902124404907, 0.97254902124404907),
            (0.59243696928024292, 0.99607843160629272, 0.99607843160629272),
            (0.59663867950439453, 1.0, 1.0),
            (0.60084033012390137, 1.0, 1.0),
            (0.60504204034805298, 1.0, 1.0),
            (0.60924369096755981, 1.0, 1.0),
            (0.61344540119171143, 1.0, 1.0),
            (0.61764705181121826, 1.0, 1.0),
            (0.62184876203536987, 1.0, 1.0),
            (0.62605041265487671, 1.0, 1.0),
            (0.63025212287902832, 1.0, 1.0),
            (0.63445377349853516, 1.0, 1.0),
            (0.63865548372268677, 1.0, 1.0),
            (0.6428571343421936, 1.0, 1.0),
            (0.64705884456634521, 1.0, 1.0),
            (0.65126049518585205, 1.0, 1.0),
            (0.65546220541000366, 1.0, 1.0),
            (0.6596638560295105, 1.0, 1.0),
            (0.66386556625366211, 1.0, 1.0),
            (0.66806721687316895, 1.0, 1.0),
            (0.67226892709732056, 1.0, 1.0),
            (0.67647057771682739, 1.0, 1.0),
            (0.680672287940979, 1.0, 1.0),
            (0.68487393856048584, 1.0, 1.0),
            (0.68907564878463745, 1.0, 1.0),
            (0.69327729940414429, 1.0, 1.0),
            (0.6974790096282959, 1.0, 1.0),
            (0.70168066024780273, 1.0, 1.0),
            (0.70588237047195435, 1.0, 1.0),
            (0.71008402109146118, 1.0, 1.0),
            (0.71428573131561279, 1.0, 1.0),
            (0.71848738193511963, 1.0, 1.0),
            (0.72268909215927124, 1.0, 1.0),
            (0.72689074277877808, 1.0, 1.0),
            (0.73109245300292969, 1.0, 1.0),
            (0.73529410362243652, 1.0, 1.0),
            (0.73949581384658813, 1.0, 1.0),
            (0.74369746446609497, 1.0, 1.0),
            (0.74789917469024658, 1.0, 1.0),
            (0.75210082530975342, 1.0, 1.0),
            (0.75630253553390503, 1.0, 1.0),
            (0.76050418615341187, 1.0, 1.0),
            (0.76470589637756348, 1.0, 1.0),
            (0.76890754699707031, 1.0, 1.0),
            (0.77310925722122192, 1.0, 1.0),
            (0.77731090784072876, 1.0, 1.0),
            (0.78151261806488037, 1.0, 1.0),
            (0.78571426868438721, 1.0, 1.0),
            (0.78991597890853882, 1.0, 1.0),
            (0.79411762952804565, 1.0, 1.0),
            (0.79831933975219727, 1.0, 1.0),
            (0.8025209903717041, 1.0, 1.0),
            (0.80672270059585571, 1.0, 1.0),
            (0.81092435121536255, 1.0, 1.0),
            (0.81512606143951416, 1.0, 1.0),
            (0.819327712059021, 1.0, 1.0),
            (0.82352942228317261, 1.0, 1.0),
            (0.82773107290267944, 1.0, 1.0),
            (0.83193278312683105, 1.0, 1.0),
            (0.83613443374633789, 1.0, 1.0),
            (0.8403361439704895, 1.0, 1.0),
            (0.84453779458999634, 1.0, 1.0),
            (0.84873950481414795, 1.0, 1.0),
            (0.85294115543365479, 1.0, 1.0),
            (0.8571428656578064, 1.0, 1.0),
            (0.86134451627731323, 1.0, 1.0),
            (0.86554622650146484, 1.0, 1.0),
            (0.86974787712097168, 1.0, 1.0),
            (0.87394958734512329, 1.0, 1.0),
            (0.87815123796463013, 1.0, 1.0),
            (0.88235294818878174, 1.0, 1.0),
            (0.88655459880828857, 1.0, 1.0),
            (0.89075630903244019, 1.0, 1.0),
            (0.89495795965194702, 1.0, 1.0),
            (0.89915966987609863, 1.0, 1.0),
            (0.90336132049560547, 1.0, 1.0),
            (0.90756303071975708, 1.0, 1.0),
            (0.91176468133926392, 1.0, 1.0),
            (0.91596639156341553, 1.0, 1.0),
            (0.92016804218292236, 1.0, 1.0),
            (0.92436975240707397, 1.0, 1.0),
            (0.92857140302658081, 1.0, 1.0),
            (0.93277311325073242, 1.0, 1.0),
            (0.93697476387023926, 1.0, 1.0),
            (0.94117647409439087, 1.0, 1.0),
            (0.94537812471389771, 1.0, 1.0),
            (0.94957983493804932, 1.0, 1.0),
            (0.95378148555755615, 1.0, 1.0),
            (0.95798319578170776, 1.0, 1.0),
            (0.9621848464012146, 1.0, 1.0),
            (0.96638655662536621, 0.99607843160629272, 0.99607843160629272),
            (0.97058820724487305, 0.97647058963775635, 0.97647058963775635),
            (0.97478991746902466, 0.9529411792755127, 0.9529411792755127),
            (0.97899156808853149, 0.91372549533843994, 0.91372549533843994),
            (0.98319327831268311, 0.89019608497619629, 0.89019608497619629),
            (0.98739492893218994, 0.87058824300765991, 0.87058824300765991),
            (0.99159663915634155, 0.85098040103912354, 0.85098040103912354),
            (0.99579828977584839, 0.82745099067687988, 0.82745099067687988),
            (1.0, 0.80784314870834351, 0.80784314870834351)],
    )
    return ColorMapper.from_segment_map(_data, range=range, **traits)

def gist_stern(range, **traits):
    """ Generator for the 'gist_stern' colormap from GIST.
    """
    _data = dict(
        red = [(0.0, 0.0, 0.0),
            (0.0042016808874905109, 0.070588238537311554, 0.070588238537311554),
            (0.0084033617749810219, 0.14117647707462311, 0.14117647707462311),
            (0.012605042196810246, 0.21176470816135406, 0.21176470816135406),
            (0.016806723549962044, 0.28235295414924622, 0.28235295414924622),
            (0.021008403971791267, 0.35294118523597717, 0.35294118523597717),
            (0.025210084393620491, 0.42352941632270813, 0.42352941632270813),
            (0.029411764815449715, 0.49803921580314636, 0.49803921580314636),
            (0.033613447099924088, 0.56862747669219971, 0.56862747669219971),
            (0.037815127521753311, 0.63921570777893066, 0.63921570777893066),
            (0.042016807943582535, 0.78039216995239258, 0.78039216995239258),
            (0.046218488365411758, 0.85098040103912354, 0.85098040103912354),
            (0.050420168787240982, 0.92156863212585449, 0.92156863212585449),
            (0.054621849209070206, 0.99607843160629272, 0.99607843160629272),
            (0.058823529630899429, 0.97647058963775635, 0.97647058963775635),
            (0.063025213778018951, 0.95686274766921997, 0.95686274766921997),
            (0.067226894199848175, 0.93725490570068359, 0.93725490570068359),
            (0.071428574621677399, 0.91764706373214722, 0.91764706373214722),
            (0.075630255043506622, 0.89803922176361084, 0.89803922176361084),
            (0.079831935465335846, 0.87450981140136719, 0.87450981140136719),
            (0.08403361588716507, 0.85490196943283081, 0.85490196943283081),
            (0.088235296308994293, 0.83529412746429443, 0.83529412746429443),
            (0.092436976730823517, 0.81568628549575806, 0.81568628549575806),
            (0.09663865715265274, 0.79607844352722168, 0.79607844352722168),
            (0.10084033757448196, 0.77254903316497803, 0.77254903316497803),
            (0.10504201799631119, 0.75294119119644165, 0.75294119119644165),
            (0.10924369841814041, 0.73333334922790527, 0.73333334922790527),
            (0.11344537883996964, 0.7137255072593689, 0.7137255072593689),
            (0.11764705926179886, 0.69411766529083252, 0.69411766529083252),
            (0.12184873968362808, 0.67450982332229614, 0.67450982332229614),
            (0.1260504275560379, 0.63137257099151611, 0.63137257099151611),
            (0.13025210797786713, 0.61176472902297974, 0.61176472902297974),
            (0.13445378839969635, 0.59215688705444336, 0.59215688705444336),
            (0.13865546882152557, 0.57254904508590698, 0.57254904508590698),
            (0.1428571492433548, 0.54901963472366333, 0.54901963472366333),
            (0.14705882966518402, 0.52941179275512695, 0.52941179275512695),
            (0.15126051008701324, 0.50980395078659058, 0.50980395078659058),
            (0.15546219050884247, 0.49019607901573181, 0.49019607901573181),
            (0.15966387093067169, 0.47058823704719543, 0.47058823704719543),
            (0.16386555135250092, 0.45098039507865906, 0.45098039507865906),
            (0.16806723177433014, 0.42745098471641541, 0.42745098471641541),
            (0.17226891219615936, 0.40784314274787903, 0.40784314274787903),
            (0.17647059261798859, 0.38823530077934265, 0.38823530077934265),
            (0.18067227303981781, 0.36862745881080627, 0.36862745881080627),
            (0.18487395346164703, 0.3490196168422699, 0.3490196168422699),
            (0.18907563388347626, 0.32549020648002625, 0.32549020648002625),
            (0.19327731430530548, 0.30588236451148987, 0.30588236451148987),
            (0.1974789947271347, 0.28627452254295349, 0.28627452254295349),
            (0.20168067514896393, 0.26666668057441711, 0.26666668057441711),
            (0.20588235557079315, 0.24705882370471954, 0.24705882370471954),
            (0.21008403599262238, 0.20392157137393951, 0.20392157137393951),
            (0.2142857164144516, 0.18431372940540314, 0.18431372940540314),
            (0.21848739683628082, 0.16470588743686676, 0.16470588743686676),
            (0.22268907725811005, 0.14509804546833038, 0.14509804546833038),
            (0.22689075767993927, 0.12549020349979401, 0.12549020349979401),
            (0.23109243810176849, 0.10196078568696976, 0.10196078568696976),
            (0.23529411852359772, 0.08235294371843338, 0.08235294371843338),
            (0.23949579894542694, 0.062745101749897003, 0.062745101749897003),
            (0.24369747936725616, 0.043137256056070328, 0.043137256056070328),
            (0.24789915978908539, 0.023529412224888802, 0.023529412224888802),
            (0.25210085511207581, 0.25098040699958801, 0.25098040699958801),
            (0.25630253553390503, 0.25490197539329529, 0.25490197539329529),
            (0.26050421595573425, 0.25882354378700256, 0.25882354378700256),
            (0.26470589637756348, 0.26274511218070984, 0.26274511218070984),
            (0.2689075767993927, 0.26666668057441711, 0.26666668057441711),
            (0.27310925722122192, 0.27058824896812439, 0.27058824896812439),
            (0.27731093764305115, 0.27450981736183167, 0.27450981736183167),
            (0.28151261806488037, 0.27843138575553894, 0.27843138575553894),
            (0.28571429848670959, 0.28235295414924622, 0.28235295414924622),
            (0.28991597890853882, 0.28627452254295349, 0.28627452254295349),
            (0.29411765933036804, 0.29411765933036804, 0.29411765933036804),
            (0.29831933975219727, 0.29803922772407532, 0.29803922772407532),
            (0.30252102017402649, 0.30196079611778259, 0.30196079611778259),
            (0.30672270059585571, 0.30588236451148987, 0.30588236451148987),
            (0.31092438101768494, 0.30980393290519714, 0.30980393290519714),
            (0.31512606143951416, 0.31372550129890442, 0.31372550129890442),
            (0.31932774186134338, 0.31764706969261169, 0.31764706969261169),
            (0.32352942228317261, 0.32156863808631897, 0.32156863808631897),
            (0.32773110270500183, 0.32549020648002625, 0.32549020648002625),
            (0.33193278312683105, 0.32941177487373352, 0.32941177487373352),
            (0.33613446354866028, 0.3333333432674408, 0.3333333432674408),
            (0.3403361439704895, 0.33725491166114807, 0.33725491166114807),
            (0.34453782439231873, 0.34117648005485535, 0.34117648005485535),
            (0.34873950481414795, 0.34509804844856262, 0.34509804844856262),
            (0.35294118523597717, 0.3490196168422699, 0.3490196168422699),
            (0.3571428656578064, 0.35294118523597717, 0.35294118523597717),
            (0.36134454607963562, 0.35686275362968445, 0.35686275362968445),
            (0.36554622650146484, 0.36078432202339172, 0.36078432202339172),
            (0.36974790692329407, 0.364705890417099, 0.364705890417099),
            (0.37394958734512329, 0.36862745881080627, 0.36862745881080627),
            (0.37815126776695251, 0.37647059559822083, 0.37647059559822083),
            (0.38235294818878174, 0.3803921639919281, 0.3803921639919281),
            (0.38655462861061096, 0.38431373238563538, 0.38431373238563538),
            (0.39075630903244019, 0.38823530077934265, 0.38823530077934265),
            (0.39495798945426941, 0.39215686917304993, 0.39215686917304993),
            (0.39915966987609863, 0.3960784375667572, 0.3960784375667572),
            (0.40336135029792786, 0.40000000596046448, 0.40000000596046448),
            (0.40756303071975708, 0.40392157435417175, 0.40392157435417175),
            (0.4117647111415863, 0.40784314274787903, 0.40784314274787903),
            (0.41596639156341553, 0.4117647111415863, 0.4117647111415863),
            (0.42016807198524475, 0.41568627953529358, 0.41568627953529358),
            (0.42436975240707397, 0.41960784792900085, 0.41960784792900085),
            (0.4285714328289032, 0.42352941632270813, 0.42352941632270813),
            (0.43277311325073242, 0.42745098471641541, 0.42745098471641541),
            (0.43697479367256165, 0.43137255311012268, 0.43137255311012268),
            (0.44117647409439087, 0.43529412150382996, 0.43529412150382996),
            (0.44537815451622009, 0.43921568989753723, 0.43921568989753723),
            (0.44957983493804932, 0.44313725829124451, 0.44313725829124451),
            (0.45378151535987854, 0.44705882668495178, 0.44705882668495178),
            (0.45798319578170776, 0.45098039507865906, 0.45098039507865906),
            (0.46218487620353699, 0.45882353186607361, 0.45882353186607361),
            (0.46638655662536621, 0.46274510025978088, 0.46274510025978088),
            (0.47058823704719543, 0.46666666865348816, 0.46666666865348816),
            (0.47478991746902466, 0.47058823704719543, 0.47058823704719543),
            (0.47899159789085388, 0.47450980544090271, 0.47450980544090271),
            (0.48319327831268311, 0.47843137383460999, 0.47843137383460999),
            (0.48739495873451233, 0.48235294222831726, 0.48235294222831726),
            (0.49159663915634155, 0.48627451062202454, 0.48627451062202454),
            (0.49579831957817078, 0.49019607901573181, 0.49019607901573181),
            (0.5, 0.49411764740943909, 0.49411764740943909),
            (0.50420171022415161, 0.50196081399917603, 0.50196081399917603),
            (0.50840336084365845, 0.5058823823928833, 0.5058823823928833),
            (0.51260507106781006, 0.50980395078659058, 0.50980395078659058),
            (0.51680672168731689, 0.51372551918029785, 0.51372551918029785),
            (0.52100843191146851, 0.51764708757400513, 0.51764708757400513),
            (0.52521008253097534, 0.5215686559677124, 0.5215686559677124),
            (0.52941179275512695, 0.52549022436141968, 0.52549022436141968),
            (0.53361344337463379, 0.52941179275512695, 0.52941179275512695),
            (0.5378151535987854, 0.53333336114883423, 0.53333336114883423),
            (0.54201680421829224, 0.5372549295425415, 0.5372549295425415),
            (0.54621851444244385, 0.54509806632995605, 0.54509806632995605),
            (0.55042016506195068, 0.54901963472366333, 0.54901963472366333),
            (0.55462187528610229, 0.55294120311737061, 0.55294120311737061),
            (0.55882352590560913, 0.55686277151107788, 0.55686277151107788),
            (0.56302523612976074, 0.56078433990478516, 0.56078433990478516),
            (0.56722688674926758, 0.56470590829849243, 0.56470590829849243),
            (0.57142859697341919, 0.56862747669219971, 0.56862747669219971),
            (0.57563024759292603, 0.57254904508590698, 0.57254904508590698),
            (0.57983195781707764, 0.57647061347961426, 0.57647061347961426),
            (0.58403360843658447, 0.58039218187332153, 0.58039218187332153),
            (0.58823531866073608, 0.58431375026702881, 0.58431375026702881),
            (0.59243696928024292, 0.58823531866073608, 0.58823531866073608),
            (0.59663867950439453, 0.59215688705444336, 0.59215688705444336),
            (0.60084033012390137, 0.59607845544815063, 0.59607845544815063),
            (0.60504204034805298, 0.60000002384185791, 0.60000002384185791),
            (0.60924369096755981, 0.60392159223556519, 0.60392159223556519),
            (0.61344540119171143, 0.60784316062927246, 0.60784316062927246),
            (0.61764705181121826, 0.61176472902297974, 0.61176472902297974),
            (0.62184876203536987, 0.61568629741668701, 0.61568629741668701),
            (0.62605041265487671, 0.61960786581039429, 0.61960786581039429),
            (0.63025212287902832, 0.62745100259780884, 0.62745100259780884),
            (0.63445377349853516, 0.63137257099151611, 0.63137257099151611),
            (0.63865548372268677, 0.63529413938522339, 0.63529413938522339),
            (0.6428571343421936, 0.63921570777893066, 0.63921570777893066),
            (0.64705884456634521, 0.64313727617263794, 0.64313727617263794),
            (0.65126049518585205, 0.64705884456634521, 0.64705884456634521),
            (0.65546220541000366, 0.65098041296005249, 0.65098041296005249),
            (0.6596638560295105, 0.65490198135375977, 0.65490198135375977),
            (0.66386556625366211, 0.65882354974746704, 0.65882354974746704),
            (0.66806721687316895, 0.66274511814117432, 0.66274511814117432),
            (0.67226892709732056, 0.66666668653488159, 0.66666668653488159),
            (0.67647057771682739, 0.67058825492858887, 0.67058825492858887),
            (0.680672287940979, 0.67450982332229614, 0.67450982332229614),
            (0.68487393856048584, 0.67843139171600342, 0.67843139171600342),
            (0.68907564878463745, 0.68235296010971069, 0.68235296010971069),
            (0.69327729940414429, 0.68627452850341797, 0.68627452850341797),
            (0.6974790096282959, 0.69019609689712524, 0.69019609689712524),
            (0.70168066024780273, 0.69411766529083252, 0.69411766529083252),
            (0.70588237047195435, 0.69803923368453979, 0.69803923368453979),
            (0.71008402109146118, 0.70196080207824707, 0.70196080207824707),
            (0.71428573131561279, 0.70980393886566162, 0.70980393886566162),
            (0.71848738193511963, 0.7137255072593689, 0.7137255072593689),
            (0.72268909215927124, 0.71764707565307617, 0.71764707565307617),
            (0.72689074277877808, 0.72156864404678345, 0.72156864404678345),
            (0.73109245300292969, 0.72549021244049072, 0.72549021244049072),
            (0.73529410362243652, 0.729411780834198, 0.729411780834198),
            (0.73949581384658813, 0.73333334922790527, 0.73333334922790527),
            (0.74369746446609497, 0.73725491762161255, 0.73725491762161255),
            (0.74789917469024658, 0.74117648601531982, 0.74117648601531982),
            (0.75210082530975342, 0.7450980544090271, 0.7450980544090271),
            (0.75630253553390503, 0.75294119119644165, 0.75294119119644165),
            (0.76050418615341187, 0.75686275959014893, 0.75686275959014893),
            (0.76470589637756348, 0.7607843279838562, 0.7607843279838562),
            (0.76890754699707031, 0.76470589637756348, 0.76470589637756348),
            (0.77310925722122192, 0.76862746477127075, 0.76862746477127075),
            (0.77731090784072876, 0.77254903316497803, 0.77254903316497803),
            (0.78151261806488037, 0.7764706015586853, 0.7764706015586853),
            (0.78571426868438721, 0.78039216995239258, 0.78039216995239258),
            (0.78991597890853882, 0.78431373834609985, 0.78431373834609985),
            (0.79411762952804565, 0.78823530673980713, 0.78823530673980713),
            (0.79831933975219727, 0.79607844352722168, 0.79607844352722168),
            (0.8025209903717041, 0.80000001192092896, 0.80000001192092896),
            (0.80672270059585571, 0.80392158031463623, 0.80392158031463623),
            (0.81092435121536255, 0.80784314870834351, 0.80784314870834351),
            (0.81512606143951416, 0.81176471710205078, 0.81176471710205078),
            (0.819327712059021, 0.81568628549575806, 0.81568628549575806),
            (0.82352942228317261, 0.81960785388946533, 0.81960785388946533),
            (0.82773107290267944, 0.82352942228317261, 0.82352942228317261),
            (0.83193278312683105, 0.82745099067687988, 0.82745099067687988),
            (0.83613443374633789, 0.83137255907058716, 0.83137255907058716),
            (0.8403361439704895, 0.83529412746429443, 0.83529412746429443),
            (0.84453779458999634, 0.83921569585800171, 0.83921569585800171),
            (0.84873950481414795, 0.84313726425170898, 0.84313726425170898),
            (0.85294115543365479, 0.84705883264541626, 0.84705883264541626),
            (0.8571428656578064, 0.85098040103912354, 0.85098040103912354),
            (0.86134451627731323, 0.85490196943283081, 0.85490196943283081),
            (0.86554622650146484, 0.85882353782653809, 0.85882353782653809),
            (0.86974787712097168, 0.86274510622024536, 0.86274510622024536),
            (0.87394958734512329, 0.86666667461395264, 0.86666667461395264),
            (0.87815123796463013, 0.87058824300765991, 0.87058824300765991),
            (0.88235294818878174, 0.87843137979507446, 0.87843137979507446),
            (0.88655459880828857, 0.88235294818878174, 0.88235294818878174),
            (0.89075630903244019, 0.88627451658248901, 0.88627451658248901),
            (0.89495795965194702, 0.89019608497619629, 0.89019608497619629),
            (0.89915966987609863, 0.89411765336990356, 0.89411765336990356),
            (0.90336132049560547, 0.89803922176361084, 0.89803922176361084),
            (0.90756303071975708, 0.90196079015731812, 0.90196079015731812),
            (0.91176468133926392, 0.90588235855102539, 0.90588235855102539),
            (0.91596639156341553, 0.90980392694473267, 0.90980392694473267),
            (0.92016804218292236, 0.91372549533843994, 0.91372549533843994),
            (0.92436975240707397, 0.91764706373214722, 0.91764706373214722),
            (0.92857140302658081, 0.92156863212585449, 0.92156863212585449),
            (0.93277311325073242, 0.92549020051956177, 0.92549020051956177),
            (0.93697476387023926, 0.92941176891326904, 0.92941176891326904),
            (0.94117647409439087, 0.93333333730697632, 0.93333333730697632),
            (0.94537812471389771, 0.93725490570068359, 0.93725490570068359),
            (0.94957983493804932, 0.94117647409439087, 0.94117647409439087),
            (0.95378148555755615, 0.94509804248809814, 0.94509804248809814),
            (0.95798319578170776, 0.94901961088180542, 0.94901961088180542),
            (0.9621848464012146, 0.9529411792755127, 0.9529411792755127),
            (0.96638655662536621, 0.96078431606292725, 0.96078431606292725),
            (0.97058820724487305, 0.96470588445663452, 0.96470588445663452),
            (0.97478991746902466, 0.9686274528503418, 0.9686274528503418),
            (0.97899156808853149, 0.97254902124404907, 0.97254902124404907),
            (0.98319327831268311, 0.97647058963775635, 0.97647058963775635),
            (0.98739492893218994, 0.98039215803146362, 0.98039215803146362),
            (0.99159663915634155, 0.9843137264251709, 0.9843137264251709),
            (0.99579828977584839, 0.98823529481887817, 0.98823529481887817),
            (1.0, 0.99215686321258545, 0.99215686321258545)],
        green = [(0.0, 0.0, 0.0),
            (0.0042016808874905109, 0.0039215688593685627, 0.0039215688593685627),
            (0.0084033617749810219, 0.0078431377187371254, 0.0078431377187371254),
            (0.012605042196810246, 0.011764706112444401, 0.011764706112444401),
            (0.016806723549962044, 0.015686275437474251, 0.015686275437474251),
            (0.021008403971791267, 0.019607843831181526, 0.019607843831181526),
            (0.025210084393620491, 0.023529412224888802, 0.023529412224888802),
            (0.029411764815449715, 0.027450980618596077, 0.027450980618596077),
            (0.033613447099924088, 0.031372550874948502, 0.031372550874948502),
            (0.037815127521753311, 0.035294119268655777, 0.035294119268655777),
            (0.042016807943582535, 0.043137256056070328, 0.043137256056070328),
            (0.046218488365411758, 0.047058824449777603, 0.047058824449777603),
            (0.050420168787240982, 0.050980392843484879, 0.050980392843484879),
            (0.054621849209070206, 0.054901961237192154, 0.054901961237192154),
            (0.058823529630899429, 0.058823529630899429, 0.058823529630899429),
            (0.063025213778018951, 0.062745101749897003, 0.062745101749897003),
            (0.067226894199848175, 0.066666670143604279, 0.066666670143604279),
            (0.071428574621677399, 0.070588238537311554, 0.070588238537311554),
            (0.075630255043506622, 0.074509806931018829, 0.074509806931018829),
            (0.079831935465335846, 0.078431375324726105, 0.078431375324726105),
            (0.08403361588716507, 0.08235294371843338, 0.08235294371843338),
            (0.088235296308994293, 0.086274512112140656, 0.086274512112140656),
            (0.092436976730823517, 0.090196080505847931, 0.090196080505847931),
            (0.09663865715265274, 0.094117648899555206, 0.094117648899555206),
            (0.10084033757448196, 0.098039217293262482, 0.098039217293262482),
            (0.10504201799631119, 0.10196078568696976, 0.10196078568696976),
            (0.10924369841814041, 0.10588235408067703, 0.10588235408067703),
            (0.11344537883996964, 0.10980392247438431, 0.10980392247438431),
            (0.11764705926179886, 0.11372549086809158, 0.11372549086809158),
            (0.12184873968362808, 0.11764705926179886, 0.11764705926179886),
            (0.1260504275560379, 0.12549020349979401, 0.12549020349979401),
            (0.13025210797786713, 0.12941177189350128, 0.12941177189350128),
            (0.13445378839969635, 0.13333334028720856, 0.13333334028720856),
            (0.13865546882152557, 0.13725490868091583, 0.13725490868091583),
            (0.1428571492433548, 0.14117647707462311, 0.14117647707462311),
            (0.14705882966518402, 0.14509804546833038, 0.14509804546833038),
            (0.15126051008701324, 0.14901961386203766, 0.14901961386203766),
            (0.15546219050884247, 0.15294118225574493, 0.15294118225574493),
            (0.15966387093067169, 0.15686275064945221, 0.15686275064945221),
            (0.16386555135250092, 0.16078431904315948, 0.16078431904315948),
            (0.16806723177433014, 0.16470588743686676, 0.16470588743686676),
            (0.17226891219615936, 0.16862745583057404, 0.16862745583057404),
            (0.17647059261798859, 0.17254902422428131, 0.17254902422428131),
            (0.18067227303981781, 0.17647059261798859, 0.17647059261798859),
            (0.18487395346164703, 0.18039216101169586, 0.18039216101169586),
            (0.18907563388347626, 0.18431372940540314, 0.18431372940540314),
            (0.19327731430530548, 0.18823529779911041, 0.18823529779911041),
            (0.1974789947271347, 0.19215686619281769, 0.19215686619281769),
            (0.20168067514896393, 0.19607843458652496, 0.19607843458652496),
            (0.20588235557079315, 0.20000000298023224, 0.20000000298023224),
            (0.21008403599262238, 0.20784313976764679, 0.20784313976764679),
            (0.2142857164144516, 0.21176470816135406, 0.21176470816135406),
            (0.21848739683628082, 0.21568627655506134, 0.21568627655506134),
            (0.22268907725811005, 0.21960784494876862, 0.21960784494876862),
            (0.22689075767993927, 0.22352941334247589, 0.22352941334247589),
            (0.23109243810176849, 0.22745098173618317, 0.22745098173618317),
            (0.23529411852359772, 0.23137255012989044, 0.23137255012989044),
            (0.23949579894542694, 0.23529411852359772, 0.23529411852359772),
            (0.24369747936725616, 0.23921568691730499, 0.23921568691730499),
            (0.24789915978908539, 0.24313725531101227, 0.24313725531101227),
            (0.25210085511207581, 0.25098040699958801, 0.25098040699958801),
            (0.25630253553390503, 0.25490197539329529, 0.25490197539329529),
            (0.26050421595573425, 0.25882354378700256, 0.25882354378700256),
            (0.26470589637756348, 0.26274511218070984, 0.26274511218070984),
            (0.2689075767993927, 0.26666668057441711, 0.26666668057441711),
            (0.27310925722122192, 0.27058824896812439, 0.27058824896812439),
            (0.27731093764305115, 0.27450981736183167, 0.27450981736183167),
            (0.28151261806488037, 0.27843138575553894, 0.27843138575553894),
            (0.28571429848670959, 0.28235295414924622, 0.28235295414924622),
            (0.28991597890853882, 0.28627452254295349, 0.28627452254295349),
            (0.29411765933036804, 0.29411765933036804, 0.29411765933036804),
            (0.29831933975219727, 0.29803922772407532, 0.29803922772407532),
            (0.30252102017402649, 0.30196079611778259, 0.30196079611778259),
            (0.30672270059585571, 0.30588236451148987, 0.30588236451148987),
            (0.31092438101768494, 0.30980393290519714, 0.30980393290519714),
            (0.31512606143951416, 0.31372550129890442, 0.31372550129890442),
            (0.31932774186134338, 0.31764706969261169, 0.31764706969261169),
            (0.32352942228317261, 0.32156863808631897, 0.32156863808631897),
            (0.32773110270500183, 0.32549020648002625, 0.32549020648002625),
            (0.33193278312683105, 0.32941177487373352, 0.32941177487373352),
            (0.33613446354866028, 0.3333333432674408, 0.3333333432674408),
            (0.3403361439704895, 0.33725491166114807, 0.33725491166114807),
            (0.34453782439231873, 0.34117648005485535, 0.34117648005485535),
            (0.34873950481414795, 0.34509804844856262, 0.34509804844856262),
            (0.35294118523597717, 0.3490196168422699, 0.3490196168422699),
            (0.3571428656578064, 0.35294118523597717, 0.35294118523597717),
            (0.36134454607963562, 0.35686275362968445, 0.35686275362968445),
            (0.36554622650146484, 0.36078432202339172, 0.36078432202339172),
            (0.36974790692329407, 0.364705890417099, 0.364705890417099),
            (0.37394958734512329, 0.36862745881080627, 0.36862745881080627),
            (0.37815126776695251, 0.37647059559822083, 0.37647059559822083),
            (0.38235294818878174, 0.3803921639919281, 0.3803921639919281),
            (0.38655462861061096, 0.38431373238563538, 0.38431373238563538),
            (0.39075630903244019, 0.38823530077934265, 0.38823530077934265),
            (0.39495798945426941, 0.39215686917304993, 0.39215686917304993),
            (0.39915966987609863, 0.3960784375667572, 0.3960784375667572),
            (0.40336135029792786, 0.40000000596046448, 0.40000000596046448),
            (0.40756303071975708, 0.40392157435417175, 0.40392157435417175),
            (0.4117647111415863, 0.40784314274787903, 0.40784314274787903),
            (0.41596639156341553, 0.4117647111415863, 0.4117647111415863),
            (0.42016807198524475, 0.41568627953529358, 0.41568627953529358),
            (0.42436975240707397, 0.41960784792900085, 0.41960784792900085),
            (0.4285714328289032, 0.42352941632270813, 0.42352941632270813),
            (0.43277311325073242, 0.42745098471641541, 0.42745098471641541),
            (0.43697479367256165, 0.43137255311012268, 0.43137255311012268),
            (0.44117647409439087, 0.43529412150382996, 0.43529412150382996),
            (0.44537815451622009, 0.43921568989753723, 0.43921568989753723),
            (0.44957983493804932, 0.44313725829124451, 0.44313725829124451),
            (0.45378151535987854, 0.44705882668495178, 0.44705882668495178),
            (0.45798319578170776, 0.45098039507865906, 0.45098039507865906),
            (0.46218487620353699, 0.45882353186607361, 0.45882353186607361),
            (0.46638655662536621, 0.46274510025978088, 0.46274510025978088),
            (0.47058823704719543, 0.46666666865348816, 0.46666666865348816),
            (0.47478991746902466, 0.47058823704719543, 0.47058823704719543),
            (0.47899159789085388, 0.47450980544090271, 0.47450980544090271),
            (0.48319327831268311, 0.47843137383460999, 0.47843137383460999),
            (0.48739495873451233, 0.48235294222831726, 0.48235294222831726),
            (0.49159663915634155, 0.48627451062202454, 0.48627451062202454),
            (0.49579831957817078, 0.49019607901573181, 0.49019607901573181),
            (0.5, 0.49411764740943909, 0.49411764740943909),
            (0.50420171022415161, 0.50196081399917603, 0.50196081399917603),
            (0.50840336084365845, 0.5058823823928833, 0.5058823823928833),
            (0.51260507106781006, 0.50980395078659058, 0.50980395078659058),
            (0.51680672168731689, 0.51372551918029785, 0.51372551918029785),
            (0.52100843191146851, 0.51764708757400513, 0.51764708757400513),
            (0.52521008253097534, 0.5215686559677124, 0.5215686559677124),
            (0.52941179275512695, 0.52549022436141968, 0.52549022436141968),
            (0.53361344337463379, 0.52941179275512695, 0.52941179275512695),
            (0.5378151535987854, 0.53333336114883423, 0.53333336114883423),
            (0.54201680421829224, 0.5372549295425415, 0.5372549295425415),
            (0.54621851444244385, 0.54509806632995605, 0.54509806632995605),
            (0.55042016506195068, 0.54901963472366333, 0.54901963472366333),
            (0.55462187528610229, 0.55294120311737061, 0.55294120311737061),
            (0.55882352590560913, 0.55686277151107788, 0.55686277151107788),
            (0.56302523612976074, 0.56078433990478516, 0.56078433990478516),
            (0.56722688674926758, 0.56470590829849243, 0.56470590829849243),
            (0.57142859697341919, 0.56862747669219971, 0.56862747669219971),
            (0.57563024759292603, 0.57254904508590698, 0.57254904508590698),
            (0.57983195781707764, 0.57647061347961426, 0.57647061347961426),
            (0.58403360843658447, 0.58039218187332153, 0.58039218187332153),
            (0.58823531866073608, 0.58431375026702881, 0.58431375026702881),
            (0.59243696928024292, 0.58823531866073608, 0.58823531866073608),
            (0.59663867950439453, 0.59215688705444336, 0.59215688705444336),
            (0.60084033012390137, 0.59607845544815063, 0.59607845544815063),
            (0.60504204034805298, 0.60000002384185791, 0.60000002384185791),
            (0.60924369096755981, 0.60392159223556519, 0.60392159223556519),
            (0.61344540119171143, 0.60784316062927246, 0.60784316062927246),
            (0.61764705181121826, 0.61176472902297974, 0.61176472902297974),
            (0.62184876203536987, 0.61568629741668701, 0.61568629741668701),
            (0.62605041265487671, 0.61960786581039429, 0.61960786581039429),
            (0.63025212287902832, 0.62745100259780884, 0.62745100259780884),
            (0.63445377349853516, 0.63137257099151611, 0.63137257099151611),
            (0.63865548372268677, 0.63529413938522339, 0.63529413938522339),
            (0.6428571343421936, 0.63921570777893066, 0.63921570777893066),
            (0.64705884456634521, 0.64313727617263794, 0.64313727617263794),
            (0.65126049518585205, 0.64705884456634521, 0.64705884456634521),
            (0.65546220541000366, 0.65098041296005249, 0.65098041296005249),
            (0.6596638560295105, 0.65490198135375977, 0.65490198135375977),
            (0.66386556625366211, 0.65882354974746704, 0.65882354974746704),
            (0.66806721687316895, 0.66274511814117432, 0.66274511814117432),
            (0.67226892709732056, 0.66666668653488159, 0.66666668653488159),
            (0.67647057771682739, 0.67058825492858887, 0.67058825492858887),
            (0.680672287940979, 0.67450982332229614, 0.67450982332229614),
            (0.68487393856048584, 0.67843139171600342, 0.67843139171600342),
            (0.68907564878463745, 0.68235296010971069, 0.68235296010971069),
            (0.69327729940414429, 0.68627452850341797, 0.68627452850341797),
            (0.6974790096282959, 0.69019609689712524, 0.69019609689712524),
            (0.70168066024780273, 0.69411766529083252, 0.69411766529083252),
            (0.70588237047195435, 0.69803923368453979, 0.69803923368453979),
            (0.71008402109146118, 0.70196080207824707, 0.70196080207824707),
            (0.71428573131561279, 0.70980393886566162, 0.70980393886566162),
            (0.71848738193511963, 0.7137255072593689, 0.7137255072593689),
            (0.72268909215927124, 0.71764707565307617, 0.71764707565307617),
            (0.72689074277877808, 0.72156864404678345, 0.72156864404678345),
            (0.73109245300292969, 0.72549021244049072, 0.72549021244049072),
            (0.73529410362243652, 0.729411780834198, 0.729411780834198),
            (0.73949581384658813, 0.73333334922790527, 0.73333334922790527),
            (0.74369746446609497, 0.73725491762161255, 0.73725491762161255),
            (0.74789917469024658, 0.74117648601531982, 0.74117648601531982),
            (0.75210082530975342, 0.7450980544090271, 0.7450980544090271),
            (0.75630253553390503, 0.75294119119644165, 0.75294119119644165),
            (0.76050418615341187, 0.75686275959014893, 0.75686275959014893),
            (0.76470589637756348, 0.7607843279838562, 0.7607843279838562),
            (0.76890754699707031, 0.76470589637756348, 0.76470589637756348),
            (0.77310925722122192, 0.76862746477127075, 0.76862746477127075),
            (0.77731090784072876, 0.77254903316497803, 0.77254903316497803),
            (0.78151261806488037, 0.7764706015586853, 0.7764706015586853),
            (0.78571426868438721, 0.78039216995239258, 0.78039216995239258),
            (0.78991597890853882, 0.78431373834609985, 0.78431373834609985),
            (0.79411762952804565, 0.78823530673980713, 0.78823530673980713),
            (0.79831933975219727, 0.79607844352722168, 0.79607844352722168),
            (0.8025209903717041, 0.80000001192092896, 0.80000001192092896),
            (0.80672270059585571, 0.80392158031463623, 0.80392158031463623),
            (0.81092435121536255, 0.80784314870834351, 0.80784314870834351),
            (0.81512606143951416, 0.81176471710205078, 0.81176471710205078),
            (0.819327712059021, 0.81568628549575806, 0.81568628549575806),
            (0.82352942228317261, 0.81960785388946533, 0.81960785388946533),
            (0.82773107290267944, 0.82352942228317261, 0.82352942228317261),
            (0.83193278312683105, 0.82745099067687988, 0.82745099067687988),
            (0.83613443374633789, 0.83137255907058716, 0.83137255907058716),
            (0.8403361439704895, 0.83529412746429443, 0.83529412746429443),
            (0.84453779458999634, 0.83921569585800171, 0.83921569585800171),
            (0.84873950481414795, 0.84313726425170898, 0.84313726425170898),
            (0.85294115543365479, 0.84705883264541626, 0.84705883264541626),
            (0.8571428656578064, 0.85098040103912354, 0.85098040103912354),
            (0.86134451627731323, 0.85490196943283081, 0.85490196943283081),
            (0.86554622650146484, 0.85882353782653809, 0.85882353782653809),
            (0.86974787712097168, 0.86274510622024536, 0.86274510622024536),
            (0.87394958734512329, 0.86666667461395264, 0.86666667461395264),
            (0.87815123796463013, 0.87058824300765991, 0.87058824300765991),
            (0.88235294818878174, 0.87843137979507446, 0.87843137979507446),
            (0.88655459880828857, 0.88235294818878174, 0.88235294818878174),
            (0.89075630903244019, 0.88627451658248901, 0.88627451658248901),
            (0.89495795965194702, 0.89019608497619629, 0.89019608497619629),
            (0.89915966987609863, 0.89411765336990356, 0.89411765336990356),
            (0.90336132049560547, 0.89803922176361084, 0.89803922176361084),
            (0.90756303071975708, 0.90196079015731812, 0.90196079015731812),
            (0.91176468133926392, 0.90588235855102539, 0.90588235855102539),
            (0.91596639156341553, 0.90980392694473267, 0.90980392694473267),
            (0.92016804218292236, 0.91372549533843994, 0.91372549533843994),
            (0.92436975240707397, 0.91764706373214722, 0.91764706373214722),
            (0.92857140302658081, 0.92156863212585449, 0.92156863212585449),
            (0.93277311325073242, 0.92549020051956177, 0.92549020051956177),
            (0.93697476387023926, 0.92941176891326904, 0.92941176891326904),
            (0.94117647409439087, 0.93333333730697632, 0.93333333730697632),
            (0.94537812471389771, 0.93725490570068359, 0.93725490570068359),
            (0.94957983493804932, 0.94117647409439087, 0.94117647409439087),
            (0.95378148555755615, 0.94509804248809814, 0.94509804248809814),
            (0.95798319578170776, 0.94901961088180542, 0.94901961088180542),
            (0.9621848464012146, 0.9529411792755127, 0.9529411792755127),
            (0.96638655662536621, 0.96078431606292725, 0.96078431606292725),
            (0.97058820724487305, 0.96470588445663452, 0.96470588445663452),
            (0.97478991746902466, 0.9686274528503418, 0.9686274528503418),
            (0.97899156808853149, 0.97254902124404907, 0.97254902124404907),
            (0.98319327831268311, 0.97647058963775635, 0.97647058963775635),
            (0.98739492893218994, 0.98039215803146362, 0.98039215803146362),
            (0.99159663915634155, 0.9843137264251709, 0.9843137264251709),
            (0.99579828977584839, 0.98823529481887817, 0.98823529481887817),
            (1.0, 0.99215686321258545, 0.99215686321258545)],
        blue = [(0.0, 0.0, 0.0),
            (0.0042016808874905109, 0.0039215688593685627, 0.0039215688593685627),
            (0.0084033617749810219, 0.011764706112444401, 0.011764706112444401),
            (0.012605042196810246, 0.019607843831181526, 0.019607843831181526),
            (0.016806723549962044, 0.027450980618596077, 0.027450980618596077),
            (0.021008403971791267, 0.035294119268655777, 0.035294119268655777),
            (0.025210084393620491, 0.043137256056070328, 0.043137256056070328),
            (0.029411764815449715, 0.050980392843484879, 0.050980392843484879),
            (0.033613447099924088, 0.058823529630899429, 0.058823529630899429),
            (0.037815127521753311, 0.066666670143604279, 0.066666670143604279),
            (0.042016807943582535, 0.08235294371843338, 0.08235294371843338),
            (0.046218488365411758, 0.090196080505847931, 0.090196080505847931),
            (0.050420168787240982, 0.098039217293262482, 0.098039217293262482),
            (0.054621849209070206, 0.10588235408067703, 0.10588235408067703),
            (0.058823529630899429, 0.11372549086809158, 0.11372549086809158),
            (0.063025213778018951, 0.12156862765550613, 0.12156862765550613),
            (0.067226894199848175, 0.12941177189350128, 0.12941177189350128),
            (0.071428574621677399, 0.13725490868091583, 0.13725490868091583),
            (0.075630255043506622, 0.14509804546833038, 0.14509804546833038),
            (0.079831935465335846, 0.15294118225574493, 0.15294118225574493),
            (0.08403361588716507, 0.16078431904315948, 0.16078431904315948),
            (0.088235296308994293, 0.16862745583057404, 0.16862745583057404),
            (0.092436976730823517, 0.17647059261798859, 0.17647059261798859),
            (0.09663865715265274, 0.18431372940540314, 0.18431372940540314),
            (0.10084033757448196, 0.19215686619281769, 0.19215686619281769),
            (0.10504201799631119, 0.20000000298023224, 0.20000000298023224),
            (0.10924369841814041, 0.20784313976764679, 0.20784313976764679),
            (0.11344537883996964, 0.21568627655506134, 0.21568627655506134),
            (0.11764705926179886, 0.22352941334247589, 0.22352941334247589),
            (0.12184873968362808, 0.23137255012989044, 0.23137255012989044),
            (0.1260504275560379, 0.24705882370471954, 0.24705882370471954),
            (0.13025210797786713, 0.25490197539329529, 0.25490197539329529),
            (0.13445378839969635, 0.26274511218070984, 0.26274511218070984),
            (0.13865546882152557, 0.27058824896812439, 0.27058824896812439),
            (0.1428571492433548, 0.27843138575553894, 0.27843138575553894),
            (0.14705882966518402, 0.28627452254295349, 0.28627452254295349),
            (0.15126051008701324, 0.29411765933036804, 0.29411765933036804),
            (0.15546219050884247, 0.30196079611778259, 0.30196079611778259),
            (0.15966387093067169, 0.30980393290519714, 0.30980393290519714),
            (0.16386555135250092, 0.31764706969261169, 0.31764706969261169),
            (0.16806723177433014, 0.32549020648002625, 0.32549020648002625),
            (0.17226891219615936, 0.3333333432674408, 0.3333333432674408),
            (0.17647059261798859, 0.34117648005485535, 0.34117648005485535),
            (0.18067227303981781, 0.3490196168422699, 0.3490196168422699),
            (0.18487395346164703, 0.35686275362968445, 0.35686275362968445),
            (0.18907563388347626, 0.364705890417099, 0.364705890417099),
            (0.19327731430530548, 0.37254902720451355, 0.37254902720451355),
            (0.1974789947271347, 0.3803921639919281, 0.3803921639919281),
            (0.20168067514896393, 0.38823530077934265, 0.38823530077934265),
            (0.20588235557079315, 0.3960784375667572, 0.3960784375667572),
            (0.21008403599262238, 0.4117647111415863, 0.4117647111415863),
            (0.2142857164144516, 0.41960784792900085, 0.41960784792900085),
            (0.21848739683628082, 0.42745098471641541, 0.42745098471641541),
            (0.22268907725811005, 0.43529412150382996, 0.43529412150382996),
            (0.22689075767993927, 0.44313725829124451, 0.44313725829124451),
            (0.23109243810176849, 0.45098039507865906, 0.45098039507865906),
            (0.23529411852359772, 0.45882353186607361, 0.45882353186607361),
            (0.23949579894542694, 0.46666666865348816, 0.46666666865348816),
            (0.24369747936725616, 0.47450980544090271, 0.47450980544090271),
            (0.24789915978908539, 0.48235294222831726, 0.48235294222831726),
            (0.25210085511207581, 0.49803921580314636, 0.49803921580314636),
            (0.25630253553390503, 0.5058823823928833, 0.5058823823928833),
            (0.26050421595573425, 0.51372551918029785, 0.51372551918029785),
            (0.26470589637756348, 0.5215686559677124, 0.5215686559677124),
            (0.2689075767993927, 0.52941179275512695, 0.52941179275512695),
            (0.27310925722122192, 0.5372549295425415, 0.5372549295425415),
            (0.27731093764305115, 0.54509806632995605, 0.54509806632995605),
            (0.28151261806488037, 0.55294120311737061, 0.55294120311737061),
            (0.28571429848670959, 0.56078433990478516, 0.56078433990478516),
            (0.28991597890853882, 0.56862747669219971, 0.56862747669219971),
            (0.29411765933036804, 0.58431375026702881, 0.58431375026702881),
            (0.29831933975219727, 0.59215688705444336, 0.59215688705444336),
            (0.30252102017402649, 0.60000002384185791, 0.60000002384185791),
            (0.30672270059585571, 0.60784316062927246, 0.60784316062927246),
            (0.31092438101768494, 0.61568629741668701, 0.61568629741668701),
            (0.31512606143951416, 0.62352943420410156, 0.62352943420410156),
            (0.31932774186134338, 0.63137257099151611, 0.63137257099151611),
            (0.32352942228317261, 0.63921570777893066, 0.63921570777893066),
            (0.32773110270500183, 0.64705884456634521, 0.64705884456634521),
            (0.33193278312683105, 0.65490198135375977, 0.65490198135375977),
            (0.33613446354866028, 0.66274511814117432, 0.66274511814117432),
            (0.3403361439704895, 0.67058825492858887, 0.67058825492858887),
            (0.34453782439231873, 0.67843139171600342, 0.67843139171600342),
            (0.34873950481414795, 0.68627452850341797, 0.68627452850341797),
            (0.35294118523597717, 0.69411766529083252, 0.69411766529083252),
            (0.3571428656578064, 0.70196080207824707, 0.70196080207824707),
            (0.36134454607963562, 0.70980393886566162, 0.70980393886566162),
            (0.36554622650146484, 0.71764707565307617, 0.71764707565307617),
            (0.36974790692329407, 0.72549021244049072, 0.72549021244049072),
            (0.37394958734512329, 0.73333334922790527, 0.73333334922790527),
            (0.37815126776695251, 0.74901962280273438, 0.74901962280273438),
            (0.38235294818878174, 0.75686275959014893, 0.75686275959014893),
            (0.38655462861061096, 0.76470589637756348, 0.76470589637756348),
            (0.39075630903244019, 0.77254903316497803, 0.77254903316497803),
            (0.39495798945426941, 0.78039216995239258, 0.78039216995239258),
            (0.39915966987609863, 0.78823530673980713, 0.78823530673980713),
            (0.40336135029792786, 0.79607844352722168, 0.79607844352722168),
            (0.40756303071975708, 0.80392158031463623, 0.80392158031463623),
            (0.4117647111415863, 0.81176471710205078, 0.81176471710205078),
            (0.41596639156341553, 0.81960785388946533, 0.81960785388946533),
            (0.42016807198524475, 0.82745099067687988, 0.82745099067687988),
            (0.42436975240707397, 0.83529412746429443, 0.83529412746429443),
            (0.4285714328289032, 0.84313726425170898, 0.84313726425170898),
            (0.43277311325073242, 0.85098040103912354, 0.85098040103912354),
            (0.43697479367256165, 0.85882353782653809, 0.85882353782653809),
            (0.44117647409439087, 0.86666667461395264, 0.86666667461395264),
            (0.44537815451622009, 0.87450981140136719, 0.87450981140136719),
            (0.44957983493804932, 0.88235294818878174, 0.88235294818878174),
            (0.45378151535987854, 0.89019608497619629, 0.89019608497619629),
            (0.45798319578170776, 0.89803922176361084, 0.89803922176361084),
            (0.46218487620353699, 0.91372549533843994, 0.91372549533843994),
            (0.46638655662536621, 0.92156863212585449, 0.92156863212585449),
            (0.47058823704719543, 0.92941176891326904, 0.92941176891326904),
            (0.47478991746902466, 0.93725490570068359, 0.93725490570068359),
            (0.47899159789085388, 0.94509804248809814, 0.94509804248809814),
            (0.48319327831268311, 0.9529411792755127, 0.9529411792755127),
            (0.48739495873451233, 0.96078431606292725, 0.96078431606292725),
            (0.49159663915634155, 0.9686274528503418, 0.9686274528503418),
            (0.49579831957817078, 0.97647058963775635, 0.97647058963775635),
            (0.5, 0.9843137264251709, 0.9843137264251709),
            (0.50420171022415161, 1.0, 1.0),
            (0.50840336084365845, 0.9843137264251709, 0.9843137264251709),
            (0.51260507106781006, 0.9686274528503418, 0.9686274528503418),
            (0.51680672168731689, 0.9529411792755127, 0.9529411792755127),
            (0.52100843191146851, 0.93333333730697632, 0.93333333730697632),
            (0.52521008253097534, 0.91764706373214722, 0.91764706373214722),
            (0.52941179275512695, 0.90196079015731812, 0.90196079015731812),
            (0.53361344337463379, 0.88627451658248901, 0.88627451658248901),
            (0.5378151535987854, 0.86666667461395264, 0.86666667461395264),
            (0.54201680421829224, 0.85098040103912354, 0.85098040103912354),
            (0.54621851444244385, 0.81960785388946533, 0.81960785388946533),
            (0.55042016506195068, 0.80000001192092896, 0.80000001192092896),
            (0.55462187528610229, 0.78431373834609985, 0.78431373834609985),
            (0.55882352590560913, 0.76862746477127075, 0.76862746477127075),
            (0.56302523612976074, 0.75294119119644165, 0.75294119119644165),
            (0.56722688674926758, 0.73333334922790527, 0.73333334922790527),
            (0.57142859697341919, 0.71764707565307617, 0.71764707565307617),
            (0.57563024759292603, 0.70196080207824707, 0.70196080207824707),
            (0.57983195781707764, 0.68627452850341797, 0.68627452850341797),
            (0.58403360843658447, 0.66666668653488159, 0.66666668653488159),
            (0.58823531866073608, 0.65098041296005249, 0.65098041296005249),
            (0.59243696928024292, 0.63529413938522339, 0.63529413938522339),
            (0.59663867950439453, 0.61960786581039429, 0.61960786581039429),
            (0.60084033012390137, 0.60000002384185791, 0.60000002384185791),
            (0.60504204034805298, 0.58431375026702881, 0.58431375026702881),
            (0.60924369096755981, 0.56862747669219971, 0.56862747669219971),
            (0.61344540119171143, 0.55294120311737061, 0.55294120311737061),
            (0.61764705181121826, 0.53333336114883423, 0.53333336114883423),
            (0.62184876203536987, 0.51764708757400513, 0.51764708757400513),
            (0.62605041265487671, 0.50196081399917603, 0.50196081399917603),
            (0.63025212287902832, 0.46666666865348816, 0.46666666865348816),
            (0.63445377349853516, 0.45098039507865906, 0.45098039507865906),
            (0.63865548372268677, 0.43529412150382996, 0.43529412150382996),
            (0.6428571343421936, 0.41960784792900085, 0.41960784792900085),
            (0.64705884456634521, 0.40000000596046448, 0.40000000596046448),
            (0.65126049518585205, 0.38431373238563538, 0.38431373238563538),
            (0.65546220541000366, 0.36862745881080627, 0.36862745881080627),
            (0.6596638560295105, 0.35294118523597717, 0.35294118523597717),
            (0.66386556625366211, 0.3333333432674408, 0.3333333432674408),
            (0.66806721687316895, 0.31764706969261169, 0.31764706969261169),
            (0.67226892709732056, 0.30196079611778259, 0.30196079611778259),
            (0.67647057771682739, 0.28627452254295349, 0.28627452254295349),
            (0.680672287940979, 0.26666668057441711, 0.26666668057441711),
            (0.68487393856048584, 0.25098040699958801, 0.25098040699958801),
            (0.68907564878463745, 0.23529411852359772, 0.23529411852359772),
            (0.69327729940414429, 0.21960784494876862, 0.21960784494876862),
            (0.6974790096282959, 0.20000000298023224, 0.20000000298023224),
            (0.70168066024780273, 0.18431372940540314, 0.18431372940540314),
            (0.70588237047195435, 0.16862745583057404, 0.16862745583057404),
            (0.71008402109146118, 0.15294118225574493, 0.15294118225574493),
            (0.71428573131561279, 0.11764705926179886, 0.11764705926179886),
            (0.71848738193511963, 0.10196078568696976, 0.10196078568696976),
            (0.72268909215927124, 0.086274512112140656, 0.086274512112140656),
            (0.72689074277877808, 0.066666670143604279, 0.066666670143604279),
            (0.73109245300292969, 0.050980392843484879, 0.050980392843484879),
            (0.73529410362243652, 0.035294119268655777, 0.035294119268655777),
            (0.73949581384658813, 0.019607843831181526, 0.019607843831181526),
            (0.74369746446609497, 0.0, 0.0),
            (0.74789917469024658, 0.011764706112444401, 0.011764706112444401),
            (0.75210082530975342, 0.027450980618596077, 0.027450980618596077),
            (0.75630253553390503, 0.058823529630899429, 0.058823529630899429),
            (0.76050418615341187, 0.074509806931018829, 0.074509806931018829),
            (0.76470589637756348, 0.086274512112140656, 0.086274512112140656),
            (0.76890754699707031, 0.10196078568696976, 0.10196078568696976),
            (0.77310925722122192, 0.11764705926179886, 0.11764705926179886),
            (0.77731090784072876, 0.13333334028720856, 0.13333334028720856),
            (0.78151261806488037, 0.14901961386203766, 0.14901961386203766),
            (0.78571426868438721, 0.16078431904315948, 0.16078431904315948),
            (0.78991597890853882, 0.17647059261798859, 0.17647059261798859),
            (0.79411762952804565, 0.19215686619281769, 0.19215686619281769),
            (0.79831933975219727, 0.22352941334247589, 0.22352941334247589),
            (0.8025209903717041, 0.23529411852359772, 0.23529411852359772),
            (0.80672270059585571, 0.25098040699958801, 0.25098040699958801),
            (0.81092435121536255, 0.26666668057441711, 0.26666668057441711),
            (0.81512606143951416, 0.28235295414924622, 0.28235295414924622),
            (0.819327712059021, 0.29803922772407532, 0.29803922772407532),
            (0.82352942228317261, 0.30980393290519714, 0.30980393290519714),
            (0.82773107290267944, 0.32549020648002625, 0.32549020648002625),
            (0.83193278312683105, 0.34117648005485535, 0.34117648005485535),
            (0.83613443374633789, 0.35686275362968445, 0.35686275362968445),
            (0.8403361439704895, 0.37254902720451355, 0.37254902720451355),
            (0.84453779458999634, 0.38431373238563538, 0.38431373238563538),
            (0.84873950481414795, 0.40000000596046448, 0.40000000596046448),
            (0.85294115543365479, 0.41568627953529358, 0.41568627953529358),
            (0.8571428656578064, 0.43137255311012268, 0.43137255311012268),
            (0.86134451627731323, 0.44705882668495178, 0.44705882668495178),
            (0.86554622650146484, 0.45882353186607361, 0.45882353186607361),
            (0.86974787712097168, 0.47450980544090271, 0.47450980544090271),
            (0.87394958734512329, 0.49019607901573181, 0.49019607901573181),
            (0.87815123796463013, 0.5058823823928833, 0.5058823823928833),
            (0.88235294818878174, 0.5372549295425415, 0.5372549295425415),
            (0.88655459880828857, 0.54901963472366333, 0.54901963472366333),
            (0.89075630903244019, 0.56470590829849243, 0.56470590829849243),
            (0.89495795965194702, 0.58039218187332153, 0.58039218187332153),
            (0.89915966987609863, 0.59607845544815063, 0.59607845544815063),
            (0.90336132049560547, 0.61176472902297974, 0.61176472902297974),
            (0.90756303071975708, 0.62352943420410156, 0.62352943420410156),
            (0.91176468133926392, 0.63921570777893066, 0.63921570777893066),
            (0.91596639156341553, 0.65490198135375977, 0.65490198135375977),
            (0.92016804218292236, 0.67058825492858887, 0.67058825492858887),
            (0.92436975240707397, 0.68627452850341797, 0.68627452850341797),
            (0.92857140302658081, 0.69803923368453979, 0.69803923368453979),
            (0.93277311325073242, 0.7137255072593689, 0.7137255072593689),
            (0.93697476387023926, 0.729411780834198, 0.729411780834198),
            (0.94117647409439087, 0.7450980544090271, 0.7450980544090271),
            (0.94537812471389771, 0.7607843279838562, 0.7607843279838562),
            (0.94957983493804932, 0.77254903316497803, 0.77254903316497803),
            (0.95378148555755615, 0.78823530673980713, 0.78823530673980713),
            (0.95798319578170776, 0.80392158031463623, 0.80392158031463623),
            (0.9621848464012146, 0.81960785388946533, 0.81960785388946533),
            (0.96638655662536621, 0.84705883264541626, 0.84705883264541626),
            (0.97058820724487305, 0.86274510622024536, 0.86274510622024536),
            (0.97478991746902466, 0.87843137979507446, 0.87843137979507446),
            (0.97899156808853149, 0.89411765336990356, 0.89411765336990356),
            (0.98319327831268311, 0.90980392694473267, 0.90980392694473267),
            (0.98739492893218994, 0.92156863212585449, 0.92156863212585449),
            (0.99159663915634155, 0.93725490570068359, 0.93725490570068359),
            (0.99579828977584839, 0.9529411792755127, 0.9529411792755127),
            (1.0, 0.9686274528503418, 0.9686274528503418)],
    )
    return ColorMapper.from_segment_map(_data, range=range, **traits)

def gist_yarg(range, **traits):
    """ Generator for the 'gist_yarg' colormap from GIST.
    """
    _data = dict(
        red = [(0.0, 1.0, 1.0),
            (0.0042016808874905109, 0.99607843160629272, 0.99607843160629272),
            (0.0084033617749810219, 0.99215686321258545, 0.99215686321258545),
            (0.012605042196810246, 0.98823529481887817, 0.98823529481887817),
            (0.016806723549962044, 0.9843137264251709, 0.9843137264251709),
            (0.021008403971791267, 0.98039215803146362, 0.98039215803146362),
            (0.025210084393620491, 0.97647058963775635, 0.97647058963775635),
            (0.029411764815449715, 0.97254902124404907, 0.97254902124404907),
            (0.033613447099924088, 0.96470588445663452, 0.96470588445663452),
            (0.037815127521753311, 0.96078431606292725, 0.96078431606292725),
            (0.042016807943582535, 0.95686274766921997, 0.95686274766921997),
            (0.046218488365411758, 0.9529411792755127, 0.9529411792755127),
            (0.050420168787240982, 0.94901961088180542, 0.94901961088180542),
            (0.054621849209070206, 0.94509804248809814, 0.94509804248809814),
            (0.058823529630899429, 0.94117647409439087, 0.94117647409439087),
            (0.063025213778018951, 0.93725490570068359, 0.93725490570068359),
            (0.067226894199848175, 0.93333333730697632, 0.93333333730697632),
            (0.071428574621677399, 0.92941176891326904, 0.92941176891326904),
            (0.075630255043506622, 0.92549020051956177, 0.92549020051956177),
            (0.079831935465335846, 0.92156863212585449, 0.92156863212585449),
            (0.08403361588716507, 0.91764706373214722, 0.91764706373214722),
            (0.088235296308994293, 0.91372549533843994, 0.91372549533843994),
            (0.092436976730823517, 0.90980392694473267, 0.90980392694473267),
            (0.09663865715265274, 0.90196079015731812, 0.90196079015731812),
            (0.10084033757448196, 0.89803922176361084, 0.89803922176361084),
            (0.10504201799631119, 0.89411765336990356, 0.89411765336990356),
            (0.10924369841814041, 0.89019608497619629, 0.89019608497619629),
            (0.11344537883996964, 0.88627451658248901, 0.88627451658248901),
            (0.11764705926179886, 0.88235294818878174, 0.88235294818878174),
            (0.12184873968362808, 0.87843137979507446, 0.87843137979507446),
            (0.1260504275560379, 0.87450981140136719, 0.87450981140136719),
            (0.13025210797786713, 0.87058824300765991, 0.87058824300765991),
            (0.13445378839969635, 0.86666667461395264, 0.86666667461395264),
            (0.13865546882152557, 0.86274510622024536, 0.86274510622024536),
            (0.1428571492433548, 0.85882353782653809, 0.85882353782653809),
            (0.14705882966518402, 0.85490196943283081, 0.85490196943283081),
            (0.15126051008701324, 0.85098040103912354, 0.85098040103912354),
            (0.15546219050884247, 0.84705883264541626, 0.84705883264541626),
            (0.15966387093067169, 0.83921569585800171, 0.83921569585800171),
            (0.16386555135250092, 0.83529412746429443, 0.83529412746429443),
            (0.16806723177433014, 0.83137255907058716, 0.83137255907058716),
            (0.17226891219615936, 0.82745099067687988, 0.82745099067687988),
            (0.17647059261798859, 0.82352942228317261, 0.82352942228317261),
            (0.18067227303981781, 0.81960785388946533, 0.81960785388946533),
            (0.18487395346164703, 0.81568628549575806, 0.81568628549575806),
            (0.18907563388347626, 0.81176471710205078, 0.81176471710205078),
            (0.19327731430530548, 0.80784314870834351, 0.80784314870834351),
            (0.1974789947271347, 0.80392158031463623, 0.80392158031463623),
            (0.20168067514896393, 0.80000001192092896, 0.80000001192092896),
            (0.20588235557079315, 0.79607844352722168, 0.79607844352722168),
            (0.21008403599262238, 0.7921568751335144, 0.7921568751335144),
            (0.2142857164144516, 0.78823530673980713, 0.78823530673980713),
            (0.21848739683628082, 0.78431373834609985, 0.78431373834609985),
            (0.22268907725811005, 0.7764706015586853, 0.7764706015586853),
            (0.22689075767993927, 0.77254903316497803, 0.77254903316497803),
            (0.23109243810176849, 0.76862746477127075, 0.76862746477127075),
            (0.23529411852359772, 0.76470589637756348, 0.76470589637756348),
            (0.23949579894542694, 0.7607843279838562, 0.7607843279838562),
            (0.24369747936725616, 0.75686275959014893, 0.75686275959014893),
            (0.24789915978908539, 0.75294119119644165, 0.75294119119644165),
            (0.25210085511207581, 0.74901962280273438, 0.74901962280273438),
            (0.25630253553390503, 0.7450980544090271, 0.7450980544090271),
            (0.26050421595573425, 0.74117648601531982, 0.74117648601531982),
            (0.26470589637756348, 0.73725491762161255, 0.73725491762161255),
            (0.2689075767993927, 0.73333334922790527, 0.73333334922790527),
            (0.27310925722122192, 0.729411780834198, 0.729411780834198),
            (0.27731093764305115, 0.72549021244049072, 0.72549021244049072),
            (0.28151261806488037, 0.72156864404678345, 0.72156864404678345),
            (0.28571429848670959, 0.7137255072593689, 0.7137255072593689),
            (0.28991597890853882, 0.70980393886566162, 0.70980393886566162),
            (0.29411765933036804, 0.70588237047195435, 0.70588237047195435),
            (0.29831933975219727, 0.70196080207824707, 0.70196080207824707),
            (0.30252102017402649, 0.69803923368453979, 0.69803923368453979),
            (0.30672270059585571, 0.69411766529083252, 0.69411766529083252),
            (0.31092438101768494, 0.69019609689712524, 0.69019609689712524),
            (0.31512606143951416, 0.68627452850341797, 0.68627452850341797),
            (0.31932774186134338, 0.68235296010971069, 0.68235296010971069),
            (0.32352942228317261, 0.67843139171600342, 0.67843139171600342),
            (0.32773110270500183, 0.67450982332229614, 0.67450982332229614),
            (0.33193278312683105, 0.67058825492858887, 0.67058825492858887),
            (0.33613446354866028, 0.66666668653488159, 0.66666668653488159),
            (0.3403361439704895, 0.66274511814117432, 0.66274511814117432),
            (0.34453782439231873, 0.65882354974746704, 0.65882354974746704),
            (0.34873950481414795, 0.65098041296005249, 0.65098041296005249),
            (0.35294118523597717, 0.64705884456634521, 0.64705884456634521),
            (0.3571428656578064, 0.64313727617263794, 0.64313727617263794),
            (0.36134454607963562, 0.63921570777893066, 0.63921570777893066),
            (0.36554622650146484, 0.63529413938522339, 0.63529413938522339),
            (0.36974790692329407, 0.63137257099151611, 0.63137257099151611),
            (0.37394958734512329, 0.62745100259780884, 0.62745100259780884),
            (0.37815126776695251, 0.62352943420410156, 0.62352943420410156),
            (0.38235294818878174, 0.61960786581039429, 0.61960786581039429),
            (0.38655462861061096, 0.61568629741668701, 0.61568629741668701),
            (0.39075630903244019, 0.61176472902297974, 0.61176472902297974),
            (0.39495798945426941, 0.60784316062927246, 0.60784316062927246),
            (0.39915966987609863, 0.60392159223556519, 0.60392159223556519),
            (0.40336135029792786, 0.60000002384185791, 0.60000002384185791),
            (0.40756303071975708, 0.59607845544815063, 0.59607845544815063),
            (0.4117647111415863, 0.58823531866073608, 0.58823531866073608),
            (0.41596639156341553, 0.58431375026702881, 0.58431375026702881),
            (0.42016807198524475, 0.58039218187332153, 0.58039218187332153),
            (0.42436975240707397, 0.57647061347961426, 0.57647061347961426),
            (0.4285714328289032, 0.57254904508590698, 0.57254904508590698),
            (0.43277311325073242, 0.56862747669219971, 0.56862747669219971),
            (0.43697479367256165, 0.56470590829849243, 0.56470590829849243),
            (0.44117647409439087, 0.56078433990478516, 0.56078433990478516),
            (0.44537815451622009, 0.55686277151107788, 0.55686277151107788),
            (0.44957983493804932, 0.55294120311737061, 0.55294120311737061),
            (0.45378151535987854, 0.54901963472366333, 0.54901963472366333),
            (0.45798319578170776, 0.54509806632995605, 0.54509806632995605),
            (0.46218487620353699, 0.54117649793624878, 0.54117649793624878),
            (0.46638655662536621, 0.5372549295425415, 0.5372549295425415),
            (0.47058823704719543, 0.53333336114883423, 0.53333336114883423),
            (0.47478991746902466, 0.52549022436141968, 0.52549022436141968),
            (0.47899159789085388, 0.5215686559677124, 0.5215686559677124),
            (0.48319327831268311, 0.51764708757400513, 0.51764708757400513),
            (0.48739495873451233, 0.51372551918029785, 0.51372551918029785),
            (0.49159663915634155, 0.50980395078659058, 0.50980395078659058),
            (0.49579831957817078, 0.5058823823928833, 0.5058823823928833),
            (0.5, 0.50196081399917603, 0.50196081399917603),
            (0.50420171022415161, 0.49803921580314636, 0.49803921580314636),
            (0.50840336084365845, 0.49411764740943909, 0.49411764740943909),
            (0.51260507106781006, 0.49019607901573181, 0.49019607901573181),
            (0.51680672168731689, 0.48627451062202454, 0.48627451062202454),
            (0.52100843191146851, 0.48235294222831726, 0.48235294222831726),
            (0.52521008253097534, 0.47843137383460999, 0.47843137383460999),
            (0.52941179275512695, 0.47450980544090271, 0.47450980544090271),
            (0.53361344337463379, 0.47058823704719543, 0.47058823704719543),
            (0.5378151535987854, 0.46274510025978088, 0.46274510025978088),
            (0.54201680421829224, 0.45882353186607361, 0.45882353186607361),
            (0.54621851444244385, 0.45490196347236633, 0.45490196347236633),
            (0.55042016506195068, 0.45098039507865906, 0.45098039507865906),
            (0.55462187528610229, 0.44705882668495178, 0.44705882668495178),
            (0.55882352590560913, 0.44313725829124451, 0.44313725829124451),
            (0.56302523612976074, 0.43921568989753723, 0.43921568989753723),
            (0.56722688674926758, 0.43529412150382996, 0.43529412150382996),
            (0.57142859697341919, 0.43137255311012268, 0.43137255311012268),
            (0.57563024759292603, 0.42745098471641541, 0.42745098471641541),
            (0.57983195781707764, 0.42352941632270813, 0.42352941632270813),
            (0.58403360843658447, 0.41960784792900085, 0.41960784792900085),
            (0.58823531866073608, 0.41568627953529358, 0.41568627953529358),
            (0.59243696928024292, 0.4117647111415863, 0.4117647111415863),
            (0.59663867950439453, 0.40784314274787903, 0.40784314274787903),
            (0.60084033012390137, 0.40000000596046448, 0.40000000596046448),
            (0.60504204034805298, 0.3960784375667572, 0.3960784375667572),
            (0.60924369096755981, 0.39215686917304993, 0.39215686917304993),
            (0.61344540119171143, 0.38823530077934265, 0.38823530077934265),
            (0.61764705181121826, 0.38431373238563538, 0.38431373238563538),
            (0.62184876203536987, 0.3803921639919281, 0.3803921639919281),
            (0.62605041265487671, 0.37647059559822083, 0.37647059559822083),
            (0.63025212287902832, 0.37254902720451355, 0.37254902720451355),
            (0.63445377349853516, 0.36862745881080627, 0.36862745881080627),
            (0.63865548372268677, 0.364705890417099, 0.364705890417099),
            (0.6428571343421936, 0.36078432202339172, 0.36078432202339172),
            (0.64705884456634521, 0.35686275362968445, 0.35686275362968445),
            (0.65126049518585205, 0.35294118523597717, 0.35294118523597717),
            (0.65546220541000366, 0.3490196168422699, 0.3490196168422699),
            (0.6596638560295105, 0.34509804844856262, 0.34509804844856262),
            (0.66386556625366211, 0.33725491166114807, 0.33725491166114807),
            (0.66806721687316895, 0.3333333432674408, 0.3333333432674408),
            (0.67226892709732056, 0.32941177487373352, 0.32941177487373352),
            (0.67647057771682739, 0.32549020648002625, 0.32549020648002625),
            (0.680672287940979, 0.32156863808631897, 0.32156863808631897),
            (0.68487393856048584, 0.31764706969261169, 0.31764706969261169),
            (0.68907564878463745, 0.31372550129890442, 0.31372550129890442),
            (0.69327729940414429, 0.30980393290519714, 0.30980393290519714),
            (0.6974790096282959, 0.30588236451148987, 0.30588236451148987),
            (0.70168066024780273, 0.30196079611778259, 0.30196079611778259),
            (0.70588237047195435, 0.29803922772407532, 0.29803922772407532),
            (0.71008402109146118, 0.29411765933036804, 0.29411765933036804),
            (0.71428573131561279, 0.29019609093666077, 0.29019609093666077),
            (0.71848738193511963, 0.28627452254295349, 0.28627452254295349),
            (0.72268909215927124, 0.28235295414924622, 0.28235295414924622),
            (0.72689074277877808, 0.27450981736183167, 0.27450981736183167),
            (0.73109245300292969, 0.27058824896812439, 0.27058824896812439),
            (0.73529410362243652, 0.26666668057441711, 0.26666668057441711),
            (0.73949581384658813, 0.26274511218070984, 0.26274511218070984),
            (0.74369746446609497, 0.25882354378700256, 0.25882354378700256),
            (0.74789917469024658, 0.25490197539329529, 0.25490197539329529),
            (0.75210082530975342, 0.25098040699958801, 0.25098040699958801),
            (0.75630253553390503, 0.24705882370471954, 0.24705882370471954),
            (0.76050418615341187, 0.24313725531101227, 0.24313725531101227),
            (0.76470589637756348, 0.23921568691730499, 0.23921568691730499),
            (0.76890754699707031, 0.23529411852359772, 0.23529411852359772),
            (0.77310925722122192, 0.23137255012989044, 0.23137255012989044),
            (0.77731090784072876, 0.22745098173618317, 0.22745098173618317),
            (0.78151261806488037, 0.22352941334247589, 0.22352941334247589),
            (0.78571426868438721, 0.21960784494876862, 0.21960784494876862),
            (0.78991597890853882, 0.21176470816135406, 0.21176470816135406),
            (0.79411762952804565, 0.20784313976764679, 0.20784313976764679),
            (0.79831933975219727, 0.20392157137393951, 0.20392157137393951),
            (0.8025209903717041, 0.20000000298023224, 0.20000000298023224),
            (0.80672270059585571, 0.19607843458652496, 0.19607843458652496),
            (0.81092435121536255, 0.19215686619281769, 0.19215686619281769),
            (0.81512606143951416, 0.18823529779911041, 0.18823529779911041),
            (0.819327712059021, 0.18431372940540314, 0.18431372940540314),
            (0.82352942228317261, 0.18039216101169586, 0.18039216101169586),
            (0.82773107290267944, 0.17647059261798859, 0.17647059261798859),
            (0.83193278312683105, 0.17254902422428131, 0.17254902422428131),
            (0.83613443374633789, 0.16862745583057404, 0.16862745583057404),
            (0.8403361439704895, 0.16470588743686676, 0.16470588743686676),
            (0.84453779458999634, 0.16078431904315948, 0.16078431904315948),
            (0.84873950481414795, 0.15686275064945221, 0.15686275064945221),
            (0.85294115543365479, 0.14901961386203766, 0.14901961386203766),
            (0.8571428656578064, 0.14509804546833038, 0.14509804546833038),
            (0.86134451627731323, 0.14117647707462311, 0.14117647707462311),
            (0.86554622650146484, 0.13725490868091583, 0.13725490868091583),
            (0.86974787712097168, 0.13333334028720856, 0.13333334028720856),
            (0.87394958734512329, 0.12941177189350128, 0.12941177189350128),
            (0.87815123796463013, 0.12549020349979401, 0.12549020349979401),
            (0.88235294818878174, 0.12156862765550613, 0.12156862765550613),
            (0.88655459880828857, 0.11764705926179886, 0.11764705926179886),
            (0.89075630903244019, 0.11372549086809158, 0.11372549086809158),
            (0.89495795965194702, 0.10980392247438431, 0.10980392247438431),
            (0.89915966987609863, 0.10588235408067703, 0.10588235408067703),
            (0.90336132049560547, 0.10196078568696976, 0.10196078568696976),
            (0.90756303071975708, 0.098039217293262482, 0.098039217293262482),
            (0.91176468133926392, 0.094117648899555206, 0.094117648899555206),
            (0.91596639156341553, 0.086274512112140656, 0.086274512112140656),
            (0.92016804218292236, 0.08235294371843338, 0.08235294371843338),
            (0.92436975240707397, 0.078431375324726105, 0.078431375324726105),
            (0.92857140302658081, 0.074509806931018829, 0.074509806931018829),
            (0.93277311325073242, 0.070588238537311554, 0.070588238537311554),
            (0.93697476387023926, 0.066666670143604279, 0.066666670143604279),
            (0.94117647409439087, 0.062745101749897003, 0.062745101749897003),
            (0.94537812471389771, 0.058823529630899429, 0.058823529630899429),
            (0.94957983493804932, 0.054901961237192154, 0.054901961237192154),
            (0.95378148555755615, 0.050980392843484879, 0.050980392843484879),
            (0.95798319578170776, 0.047058824449777603, 0.047058824449777603),
            (0.9621848464012146, 0.043137256056070328, 0.043137256056070328),
            (0.96638655662536621, 0.039215687662363052, 0.039215687662363052),
            (0.97058820724487305, 0.035294119268655777, 0.035294119268655777),
            (0.97478991746902466, 0.031372550874948502, 0.031372550874948502),
            (0.97899156808853149, 0.023529412224888802, 0.023529412224888802),
            (0.98319327831268311, 0.019607843831181526, 0.019607843831181526),
            (0.98739492893218994, 0.015686275437474251, 0.015686275437474251),
            (0.99159663915634155, 0.011764706112444401, 0.011764706112444401),
            (0.99579828977584839, 0.0078431377187371254, 0.0078431377187371254),
            (1.0, 0.0039215688593685627, 0.0039215688593685627)],
        green = [(0.0, 1.0, 1.0),
            (0.0042016808874905109, 0.99607843160629272, 0.99607843160629272),
            (0.0084033617749810219, 0.99215686321258545, 0.99215686321258545),
            (0.012605042196810246, 0.98823529481887817, 0.98823529481887817),
            (0.016806723549962044, 0.9843137264251709, 0.9843137264251709),
            (0.021008403971791267, 0.98039215803146362, 0.98039215803146362),
            (0.025210084393620491, 0.97647058963775635, 0.97647058963775635),
            (0.029411764815449715, 0.97254902124404907, 0.97254902124404907),
            (0.033613447099924088, 0.96470588445663452, 0.96470588445663452),
            (0.037815127521753311, 0.96078431606292725, 0.96078431606292725),
            (0.042016807943582535, 0.95686274766921997, 0.95686274766921997),
            (0.046218488365411758, 0.9529411792755127, 0.9529411792755127),
            (0.050420168787240982, 0.94901961088180542, 0.94901961088180542),
            (0.054621849209070206, 0.94509804248809814, 0.94509804248809814),
            (0.058823529630899429, 0.94117647409439087, 0.94117647409439087),
            (0.063025213778018951, 0.93725490570068359, 0.93725490570068359),
            (0.067226894199848175, 0.93333333730697632, 0.93333333730697632),
            (0.071428574621677399, 0.92941176891326904, 0.92941176891326904),
            (0.075630255043506622, 0.92549020051956177, 0.92549020051956177),
            (0.079831935465335846, 0.92156863212585449, 0.92156863212585449),
            (0.08403361588716507, 0.91764706373214722, 0.91764706373214722),
            (0.088235296308994293, 0.91372549533843994, 0.91372549533843994),
            (0.092436976730823517, 0.90980392694473267, 0.90980392694473267),
            (0.09663865715265274, 0.90196079015731812, 0.90196079015731812),
            (0.10084033757448196, 0.89803922176361084, 0.89803922176361084),
            (0.10504201799631119, 0.89411765336990356, 0.89411765336990356),
            (0.10924369841814041, 0.89019608497619629, 0.89019608497619629),
            (0.11344537883996964, 0.88627451658248901, 0.88627451658248901),
            (0.11764705926179886, 0.88235294818878174, 0.88235294818878174),
            (0.12184873968362808, 0.87843137979507446, 0.87843137979507446),
            (0.1260504275560379, 0.87450981140136719, 0.87450981140136719),
            (0.13025210797786713, 0.87058824300765991, 0.87058824300765991),
            (0.13445378839969635, 0.86666667461395264, 0.86666667461395264),
            (0.13865546882152557, 0.86274510622024536, 0.86274510622024536),
            (0.1428571492433548, 0.85882353782653809, 0.85882353782653809),
            (0.14705882966518402, 0.85490196943283081, 0.85490196943283081),
            (0.15126051008701324, 0.85098040103912354, 0.85098040103912354),
            (0.15546219050884247, 0.84705883264541626, 0.84705883264541626),
            (0.15966387093067169, 0.83921569585800171, 0.83921569585800171),
            (0.16386555135250092, 0.83529412746429443, 0.83529412746429443),
            (0.16806723177433014, 0.83137255907058716, 0.83137255907058716),
            (0.17226891219615936, 0.82745099067687988, 0.82745099067687988),
            (0.17647059261798859, 0.82352942228317261, 0.82352942228317261),
            (0.18067227303981781, 0.81960785388946533, 0.81960785388946533),
            (0.18487395346164703, 0.81568628549575806, 0.81568628549575806),
            (0.18907563388347626, 0.81176471710205078, 0.81176471710205078),
            (0.19327731430530548, 0.80784314870834351, 0.80784314870834351),
            (0.1974789947271347, 0.80392158031463623, 0.80392158031463623),
            (0.20168067514896393, 0.80000001192092896, 0.80000001192092896),
            (0.20588235557079315, 0.79607844352722168, 0.79607844352722168),
            (0.21008403599262238, 0.7921568751335144, 0.7921568751335144),
            (0.2142857164144516, 0.78823530673980713, 0.78823530673980713),
            (0.21848739683628082, 0.78431373834609985, 0.78431373834609985),
            (0.22268907725811005, 0.7764706015586853, 0.7764706015586853),
            (0.22689075767993927, 0.77254903316497803, 0.77254903316497803),
            (0.23109243810176849, 0.76862746477127075, 0.76862746477127075),
            (0.23529411852359772, 0.76470589637756348, 0.76470589637756348),
            (0.23949579894542694, 0.7607843279838562, 0.7607843279838562),
            (0.24369747936725616, 0.75686275959014893, 0.75686275959014893),
            (0.24789915978908539, 0.75294119119644165, 0.75294119119644165),
            (0.25210085511207581, 0.74901962280273438, 0.74901962280273438),
            (0.25630253553390503, 0.7450980544090271, 0.7450980544090271),
            (0.26050421595573425, 0.74117648601531982, 0.74117648601531982),
            (0.26470589637756348, 0.73725491762161255, 0.73725491762161255),
            (0.2689075767993927, 0.73333334922790527, 0.73333334922790527),
            (0.27310925722122192, 0.729411780834198, 0.729411780834198),
            (0.27731093764305115, 0.72549021244049072, 0.72549021244049072),
            (0.28151261806488037, 0.72156864404678345, 0.72156864404678345),
            (0.28571429848670959, 0.7137255072593689, 0.7137255072593689),
            (0.28991597890853882, 0.70980393886566162, 0.70980393886566162),
            (0.29411765933036804, 0.70588237047195435, 0.70588237047195435),
            (0.29831933975219727, 0.70196080207824707, 0.70196080207824707),
            (0.30252102017402649, 0.69803923368453979, 0.69803923368453979),
            (0.30672270059585571, 0.69411766529083252, 0.69411766529083252),
            (0.31092438101768494, 0.69019609689712524, 0.69019609689712524),
            (0.31512606143951416, 0.68627452850341797, 0.68627452850341797),
            (0.31932774186134338, 0.68235296010971069, 0.68235296010971069),
            (0.32352942228317261, 0.67843139171600342, 0.67843139171600342),
            (0.32773110270500183, 0.67450982332229614, 0.67450982332229614),
            (0.33193278312683105, 0.67058825492858887, 0.67058825492858887),
            (0.33613446354866028, 0.66666668653488159, 0.66666668653488159),
            (0.3403361439704895, 0.66274511814117432, 0.66274511814117432),
            (0.34453782439231873, 0.65882354974746704, 0.65882354974746704),
            (0.34873950481414795, 0.65098041296005249, 0.65098041296005249),
            (0.35294118523597717, 0.64705884456634521, 0.64705884456634521),
            (0.3571428656578064, 0.64313727617263794, 0.64313727617263794),
            (0.36134454607963562, 0.63921570777893066, 0.63921570777893066),
            (0.36554622650146484, 0.63529413938522339, 0.63529413938522339),
            (0.36974790692329407, 0.63137257099151611, 0.63137257099151611),
            (0.37394958734512329, 0.62745100259780884, 0.62745100259780884),
            (0.37815126776695251, 0.62352943420410156, 0.62352943420410156),
            (0.38235294818878174, 0.61960786581039429, 0.61960786581039429),
            (0.38655462861061096, 0.61568629741668701, 0.61568629741668701),
            (0.39075630903244019, 0.61176472902297974, 0.61176472902297974),
            (0.39495798945426941, 0.60784316062927246, 0.60784316062927246),
            (0.39915966987609863, 0.60392159223556519, 0.60392159223556519),
            (0.40336135029792786, 0.60000002384185791, 0.60000002384185791),
            (0.40756303071975708, 0.59607845544815063, 0.59607845544815063),
            (0.4117647111415863, 0.58823531866073608, 0.58823531866073608),
            (0.41596639156341553, 0.58431375026702881, 0.58431375026702881),
            (0.42016807198524475, 0.58039218187332153, 0.58039218187332153),
            (0.42436975240707397, 0.57647061347961426, 0.57647061347961426),
            (0.4285714328289032, 0.57254904508590698, 0.57254904508590698),
            (0.43277311325073242, 0.56862747669219971, 0.56862747669219971),
            (0.43697479367256165, 0.56470590829849243, 0.56470590829849243),
            (0.44117647409439087, 0.56078433990478516, 0.56078433990478516),
            (0.44537815451622009, 0.55686277151107788, 0.55686277151107788),
            (0.44957983493804932, 0.55294120311737061, 0.55294120311737061),
            (0.45378151535987854, 0.54901963472366333, 0.54901963472366333),
            (0.45798319578170776, 0.54509806632995605, 0.54509806632995605),
            (0.46218487620353699, 0.54117649793624878, 0.54117649793624878),
            (0.46638655662536621, 0.5372549295425415, 0.5372549295425415),
            (0.47058823704719543, 0.53333336114883423, 0.53333336114883423),
            (0.47478991746902466, 0.52549022436141968, 0.52549022436141968),
            (0.47899159789085388, 0.5215686559677124, 0.5215686559677124),
            (0.48319327831268311, 0.51764708757400513, 0.51764708757400513),
            (0.48739495873451233, 0.51372551918029785, 0.51372551918029785),
            (0.49159663915634155, 0.50980395078659058, 0.50980395078659058),
            (0.49579831957817078, 0.5058823823928833, 0.5058823823928833),
            (0.5, 0.50196081399917603, 0.50196081399917603),
            (0.50420171022415161, 0.49803921580314636, 0.49803921580314636),
            (0.50840336084365845, 0.49411764740943909, 0.49411764740943909),
            (0.51260507106781006, 0.49019607901573181, 0.49019607901573181),
            (0.51680672168731689, 0.48627451062202454, 0.48627451062202454),
            (0.52100843191146851, 0.48235294222831726, 0.48235294222831726),
            (0.52521008253097534, 0.47843137383460999, 0.47843137383460999),
            (0.52941179275512695, 0.47450980544090271, 0.47450980544090271),
            (0.53361344337463379, 0.47058823704719543, 0.47058823704719543),
            (0.5378151535987854, 0.46274510025978088, 0.46274510025978088),
            (0.54201680421829224, 0.45882353186607361, 0.45882353186607361),
            (0.54621851444244385, 0.45490196347236633, 0.45490196347236633),
            (0.55042016506195068, 0.45098039507865906, 0.45098039507865906),
            (0.55462187528610229, 0.44705882668495178, 0.44705882668495178),
            (0.55882352590560913, 0.44313725829124451, 0.44313725829124451),
            (0.56302523612976074, 0.43921568989753723, 0.43921568989753723),
            (0.56722688674926758, 0.43529412150382996, 0.43529412150382996),
            (0.57142859697341919, 0.43137255311012268, 0.43137255311012268),
            (0.57563024759292603, 0.42745098471641541, 0.42745098471641541),
            (0.57983195781707764, 0.42352941632270813, 0.42352941632270813),
            (0.58403360843658447, 0.41960784792900085, 0.41960784792900085),
            (0.58823531866073608, 0.41568627953529358, 0.41568627953529358),
            (0.59243696928024292, 0.4117647111415863, 0.4117647111415863),
            (0.59663867950439453, 0.40784314274787903, 0.40784314274787903),
            (0.60084033012390137, 0.40000000596046448, 0.40000000596046448),
            (0.60504204034805298, 0.3960784375667572, 0.3960784375667572),
            (0.60924369096755981, 0.39215686917304993, 0.39215686917304993),
            (0.61344540119171143, 0.38823530077934265, 0.38823530077934265),
            (0.61764705181121826, 0.38431373238563538, 0.38431373238563538),
            (0.62184876203536987, 0.3803921639919281, 0.3803921639919281),
            (0.62605041265487671, 0.37647059559822083, 0.37647059559822083),
            (0.63025212287902832, 0.37254902720451355, 0.37254902720451355),
            (0.63445377349853516, 0.36862745881080627, 0.36862745881080627),
            (0.63865548372268677, 0.364705890417099, 0.364705890417099),
            (0.6428571343421936, 0.36078432202339172, 0.36078432202339172),
            (0.64705884456634521, 0.35686275362968445, 0.35686275362968445),
            (0.65126049518585205, 0.35294118523597717, 0.35294118523597717),
            (0.65546220541000366, 0.3490196168422699, 0.3490196168422699),
            (0.6596638560295105, 0.34509804844856262, 0.34509804844856262),
            (0.66386556625366211, 0.33725491166114807, 0.33725491166114807),
            (0.66806721687316895, 0.3333333432674408, 0.3333333432674408),
            (0.67226892709732056, 0.32941177487373352, 0.32941177487373352),
            (0.67647057771682739, 0.32549020648002625, 0.32549020648002625),
            (0.680672287940979, 0.32156863808631897, 0.32156863808631897),
            (0.68487393856048584, 0.31764706969261169, 0.31764706969261169),
            (0.68907564878463745, 0.31372550129890442, 0.31372550129890442),
            (0.69327729940414429, 0.30980393290519714, 0.30980393290519714),
            (0.6974790096282959, 0.30588236451148987, 0.30588236451148987),
            (0.70168066024780273, 0.30196079611778259, 0.30196079611778259),
            (0.70588237047195435, 0.29803922772407532, 0.29803922772407532),
            (0.71008402109146118, 0.29411765933036804, 0.29411765933036804),
            (0.71428573131561279, 0.29019609093666077, 0.29019609093666077),
            (0.71848738193511963, 0.28627452254295349, 0.28627452254295349),
            (0.72268909215927124, 0.28235295414924622, 0.28235295414924622),
            (0.72689074277877808, 0.27450981736183167, 0.27450981736183167),
            (0.73109245300292969, 0.27058824896812439, 0.27058824896812439),
            (0.73529410362243652, 0.26666668057441711, 0.26666668057441711),
            (0.73949581384658813, 0.26274511218070984, 0.26274511218070984),
            (0.74369746446609497, 0.25882354378700256, 0.25882354378700256),
            (0.74789917469024658, 0.25490197539329529, 0.25490197539329529),
            (0.75210082530975342, 0.25098040699958801, 0.25098040699958801),
            (0.75630253553390503, 0.24705882370471954, 0.24705882370471954),
            (0.76050418615341187, 0.24313725531101227, 0.24313725531101227),
            (0.76470589637756348, 0.23921568691730499, 0.23921568691730499),
            (0.76890754699707031, 0.23529411852359772, 0.23529411852359772),
            (0.77310925722122192, 0.23137255012989044, 0.23137255012989044),
            (0.77731090784072876, 0.22745098173618317, 0.22745098173618317),
            (0.78151261806488037, 0.22352941334247589, 0.22352941334247589),
            (0.78571426868438721, 0.21960784494876862, 0.21960784494876862),
            (0.78991597890853882, 0.21176470816135406, 0.21176470816135406),
            (0.79411762952804565, 0.20784313976764679, 0.20784313976764679),
            (0.79831933975219727, 0.20392157137393951, 0.20392157137393951),
            (0.8025209903717041, 0.20000000298023224, 0.20000000298023224),
            (0.80672270059585571, 0.19607843458652496, 0.19607843458652496),
            (0.81092435121536255, 0.19215686619281769, 0.19215686619281769),
            (0.81512606143951416, 0.18823529779911041, 0.18823529779911041),
            (0.819327712059021, 0.18431372940540314, 0.18431372940540314),
            (0.82352942228317261, 0.18039216101169586, 0.18039216101169586),
            (0.82773107290267944, 0.17647059261798859, 0.17647059261798859),
            (0.83193278312683105, 0.17254902422428131, 0.17254902422428131),
            (0.83613443374633789, 0.16862745583057404, 0.16862745583057404),
            (0.8403361439704895, 0.16470588743686676, 0.16470588743686676),
            (0.84453779458999634, 0.16078431904315948, 0.16078431904315948),
            (0.84873950481414795, 0.15686275064945221, 0.15686275064945221),
            (0.85294115543365479, 0.14901961386203766, 0.14901961386203766),
            (0.8571428656578064, 0.14509804546833038, 0.14509804546833038),
            (0.86134451627731323, 0.14117647707462311, 0.14117647707462311),
            (0.86554622650146484, 0.13725490868091583, 0.13725490868091583),
            (0.86974787712097168, 0.13333334028720856, 0.13333334028720856),
            (0.87394958734512329, 0.12941177189350128, 0.12941177189350128),
            (0.87815123796463013, 0.12549020349979401, 0.12549020349979401),
            (0.88235294818878174, 0.12156862765550613, 0.12156862765550613),
            (0.88655459880828857, 0.11764705926179886, 0.11764705926179886),
            (0.89075630903244019, 0.11372549086809158, 0.11372549086809158),
            (0.89495795965194702, 0.10980392247438431, 0.10980392247438431),
            (0.89915966987609863, 0.10588235408067703, 0.10588235408067703),
            (0.90336132049560547, 0.10196078568696976, 0.10196078568696976),
            (0.90756303071975708, 0.098039217293262482, 0.098039217293262482),
            (0.91176468133926392, 0.094117648899555206, 0.094117648899555206),
            (0.91596639156341553, 0.086274512112140656, 0.086274512112140656),
            (0.92016804218292236, 0.08235294371843338, 0.08235294371843338),
            (0.92436975240707397, 0.078431375324726105, 0.078431375324726105),
            (0.92857140302658081, 0.074509806931018829, 0.074509806931018829),
            (0.93277311325073242, 0.070588238537311554, 0.070588238537311554),
            (0.93697476387023926, 0.066666670143604279, 0.066666670143604279),
            (0.94117647409439087, 0.062745101749897003, 0.062745101749897003),
            (0.94537812471389771, 0.058823529630899429, 0.058823529630899429),
            (0.94957983493804932, 0.054901961237192154, 0.054901961237192154),
            (0.95378148555755615, 0.050980392843484879, 0.050980392843484879),
            (0.95798319578170776, 0.047058824449777603, 0.047058824449777603),
            (0.9621848464012146, 0.043137256056070328, 0.043137256056070328),
            (0.96638655662536621, 0.039215687662363052, 0.039215687662363052),
            (0.97058820724487305, 0.035294119268655777, 0.035294119268655777),
            (0.97478991746902466, 0.031372550874948502, 0.031372550874948502),
            (0.97899156808853149, 0.023529412224888802, 0.023529412224888802),
            (0.98319327831268311, 0.019607843831181526, 0.019607843831181526),
            (0.98739492893218994, 0.015686275437474251, 0.015686275437474251),
            (0.99159663915634155, 0.011764706112444401, 0.011764706112444401),
            (0.99579828977584839, 0.0078431377187371254, 0.0078431377187371254),
            (1.0, 0.0039215688593685627, 0.0039215688593685627)],
        blue = [(0.0, 1.0, 1.0),
            (0.0042016808874905109, 0.99607843160629272, 0.99607843160629272),
            (0.0084033617749810219, 0.99215686321258545, 0.99215686321258545),
            (0.012605042196810246, 0.98823529481887817, 0.98823529481887817),
            (0.016806723549962044, 0.9843137264251709, 0.9843137264251709),
            (0.021008403971791267, 0.98039215803146362, 0.98039215803146362),
            (0.025210084393620491, 0.97647058963775635, 0.97647058963775635),
            (0.029411764815449715, 0.97254902124404907, 0.97254902124404907),
            (0.033613447099924088, 0.96470588445663452, 0.96470588445663452),
            (0.037815127521753311, 0.96078431606292725, 0.96078431606292725),
            (0.042016807943582535, 0.95686274766921997, 0.95686274766921997),
            (0.046218488365411758, 0.9529411792755127, 0.9529411792755127),
            (0.050420168787240982, 0.94901961088180542, 0.94901961088180542),
            (0.054621849209070206, 0.94509804248809814, 0.94509804248809814),
            (0.058823529630899429, 0.94117647409439087, 0.94117647409439087),
            (0.063025213778018951, 0.93725490570068359, 0.93725490570068359),
            (0.067226894199848175, 0.93333333730697632, 0.93333333730697632),
            (0.071428574621677399, 0.92941176891326904, 0.92941176891326904),
            (0.075630255043506622, 0.92549020051956177, 0.92549020051956177),
            (0.079831935465335846, 0.92156863212585449, 0.92156863212585449),
            (0.08403361588716507, 0.91764706373214722, 0.91764706373214722),
            (0.088235296308994293, 0.91372549533843994, 0.91372549533843994),
            (0.092436976730823517, 0.90980392694473267, 0.90980392694473267),
            (0.09663865715265274, 0.90196079015731812, 0.90196079015731812),
            (0.10084033757448196, 0.89803922176361084, 0.89803922176361084),
            (0.10504201799631119, 0.89411765336990356, 0.89411765336990356),
            (0.10924369841814041, 0.89019608497619629, 0.89019608497619629),
            (0.11344537883996964, 0.88627451658248901, 0.88627451658248901),
            (0.11764705926179886, 0.88235294818878174, 0.88235294818878174),
            (0.12184873968362808, 0.87843137979507446, 0.87843137979507446),
            (0.1260504275560379, 0.87450981140136719, 0.87450981140136719),
            (0.13025210797786713, 0.87058824300765991, 0.87058824300765991),
            (0.13445378839969635, 0.86666667461395264, 0.86666667461395264),
            (0.13865546882152557, 0.86274510622024536, 0.86274510622024536),
            (0.1428571492433548, 0.85882353782653809, 0.85882353782653809),
            (0.14705882966518402, 0.85490196943283081, 0.85490196943283081),
            (0.15126051008701324, 0.85098040103912354, 0.85098040103912354),
            (0.15546219050884247, 0.84705883264541626, 0.84705883264541626),
            (0.15966387093067169, 0.83921569585800171, 0.83921569585800171),
            (0.16386555135250092, 0.83529412746429443, 0.83529412746429443),
            (0.16806723177433014, 0.83137255907058716, 0.83137255907058716),
            (0.17226891219615936, 0.82745099067687988, 0.82745099067687988),
            (0.17647059261798859, 0.82352942228317261, 0.82352942228317261),
            (0.18067227303981781, 0.81960785388946533, 0.81960785388946533),
            (0.18487395346164703, 0.81568628549575806, 0.81568628549575806),
            (0.18907563388347626, 0.81176471710205078, 0.81176471710205078),
            (0.19327731430530548, 0.80784314870834351, 0.80784314870834351),
            (0.1974789947271347, 0.80392158031463623, 0.80392158031463623),
            (0.20168067514896393, 0.80000001192092896, 0.80000001192092896),
            (0.20588235557079315, 0.79607844352722168, 0.79607844352722168),
            (0.21008403599262238, 0.7921568751335144, 0.7921568751335144),
            (0.2142857164144516, 0.78823530673980713, 0.78823530673980713),
            (0.21848739683628082, 0.78431373834609985, 0.78431373834609985),
            (0.22268907725811005, 0.7764706015586853, 0.7764706015586853),
            (0.22689075767993927, 0.77254903316497803, 0.77254903316497803),
            (0.23109243810176849, 0.76862746477127075, 0.76862746477127075),
            (0.23529411852359772, 0.76470589637756348, 0.76470589637756348),
            (0.23949579894542694, 0.7607843279838562, 0.7607843279838562),
            (0.24369747936725616, 0.75686275959014893, 0.75686275959014893),
            (0.24789915978908539, 0.75294119119644165, 0.75294119119644165),
            (0.25210085511207581, 0.74901962280273438, 0.74901962280273438),
            (0.25630253553390503, 0.7450980544090271, 0.7450980544090271),
            (0.26050421595573425, 0.74117648601531982, 0.74117648601531982),
            (0.26470589637756348, 0.73725491762161255, 0.73725491762161255),
            (0.2689075767993927, 0.73333334922790527, 0.73333334922790527),
            (0.27310925722122192, 0.729411780834198, 0.729411780834198),
            (0.27731093764305115, 0.72549021244049072, 0.72549021244049072),
            (0.28151261806488037, 0.72156864404678345, 0.72156864404678345),
            (0.28571429848670959, 0.7137255072593689, 0.7137255072593689),
            (0.28991597890853882, 0.70980393886566162, 0.70980393886566162),
            (0.29411765933036804, 0.70588237047195435, 0.70588237047195435),
            (0.29831933975219727, 0.70196080207824707, 0.70196080207824707),
            (0.30252102017402649, 0.69803923368453979, 0.69803923368453979),
            (0.30672270059585571, 0.69411766529083252, 0.69411766529083252),
            (0.31092438101768494, 0.69019609689712524, 0.69019609689712524),
            (0.31512606143951416, 0.68627452850341797, 0.68627452850341797),
            (0.31932774186134338, 0.68235296010971069, 0.68235296010971069),
            (0.32352942228317261, 0.67843139171600342, 0.67843139171600342),
            (0.32773110270500183, 0.67450982332229614, 0.67450982332229614),
            (0.33193278312683105, 0.67058825492858887, 0.67058825492858887),
            (0.33613446354866028, 0.66666668653488159, 0.66666668653488159),
            (0.3403361439704895, 0.66274511814117432, 0.66274511814117432),
            (0.34453782439231873, 0.65882354974746704, 0.65882354974746704),
            (0.34873950481414795, 0.65098041296005249, 0.65098041296005249),
            (0.35294118523597717, 0.64705884456634521, 0.64705884456634521),
            (0.3571428656578064, 0.64313727617263794, 0.64313727617263794),
            (0.36134454607963562, 0.63921570777893066, 0.63921570777893066),
            (0.36554622650146484, 0.63529413938522339, 0.63529413938522339),
            (0.36974790692329407, 0.63137257099151611, 0.63137257099151611),
            (0.37394958734512329, 0.62745100259780884, 0.62745100259780884),
            (0.37815126776695251, 0.62352943420410156, 0.62352943420410156),
            (0.38235294818878174, 0.61960786581039429, 0.61960786581039429),
            (0.38655462861061096, 0.61568629741668701, 0.61568629741668701),
            (0.39075630903244019, 0.61176472902297974, 0.61176472902297974),
            (0.39495798945426941, 0.60784316062927246, 0.60784316062927246),
            (0.39915966987609863, 0.60392159223556519, 0.60392159223556519),
            (0.40336135029792786, 0.60000002384185791, 0.60000002384185791),
            (0.40756303071975708, 0.59607845544815063, 0.59607845544815063),
            (0.4117647111415863, 0.58823531866073608, 0.58823531866073608),
            (0.41596639156341553, 0.58431375026702881, 0.58431375026702881),
            (0.42016807198524475, 0.58039218187332153, 0.58039218187332153),
            (0.42436975240707397, 0.57647061347961426, 0.57647061347961426),
            (0.4285714328289032, 0.57254904508590698, 0.57254904508590698),
            (0.43277311325073242, 0.56862747669219971, 0.56862747669219971),
            (0.43697479367256165, 0.56470590829849243, 0.56470590829849243),
            (0.44117647409439087, 0.56078433990478516, 0.56078433990478516),
            (0.44537815451622009, 0.55686277151107788, 0.55686277151107788),
            (0.44957983493804932, 0.55294120311737061, 0.55294120311737061),
            (0.45378151535987854, 0.54901963472366333, 0.54901963472366333),
            (0.45798319578170776, 0.54509806632995605, 0.54509806632995605),
            (0.46218487620353699, 0.54117649793624878, 0.54117649793624878),
            (0.46638655662536621, 0.5372549295425415, 0.5372549295425415),
            (0.47058823704719543, 0.53333336114883423, 0.53333336114883423),
            (0.47478991746902466, 0.52549022436141968, 0.52549022436141968),
            (0.47899159789085388, 0.5215686559677124, 0.5215686559677124),
            (0.48319327831268311, 0.51764708757400513, 0.51764708757400513),
            (0.48739495873451233, 0.51372551918029785, 0.51372551918029785),
            (0.49159663915634155, 0.50980395078659058, 0.50980395078659058),
            (0.49579831957817078, 0.5058823823928833, 0.5058823823928833),
            (0.5, 0.50196081399917603, 0.50196081399917603),
            (0.50420171022415161, 0.49803921580314636, 0.49803921580314636),
            (0.50840336084365845, 0.49411764740943909, 0.49411764740943909),
            (0.51260507106781006, 0.49019607901573181, 0.49019607901573181),
            (0.51680672168731689, 0.48627451062202454, 0.48627451062202454),
            (0.52100843191146851, 0.48235294222831726, 0.48235294222831726),
            (0.52521008253097534, 0.47843137383460999, 0.47843137383460999),
            (0.52941179275512695, 0.47450980544090271, 0.47450980544090271),
            (0.53361344337463379, 0.47058823704719543, 0.47058823704719543),
            (0.5378151535987854, 0.46274510025978088, 0.46274510025978088),
            (0.54201680421829224, 0.45882353186607361, 0.45882353186607361),
            (0.54621851444244385, 0.45490196347236633, 0.45490196347236633),
            (0.55042016506195068, 0.45098039507865906, 0.45098039507865906),
            (0.55462187528610229, 0.44705882668495178, 0.44705882668495178),
            (0.55882352590560913, 0.44313725829124451, 0.44313725829124451),
            (0.56302523612976074, 0.43921568989753723, 0.43921568989753723),
            (0.56722688674926758, 0.43529412150382996, 0.43529412150382996),
            (0.57142859697341919, 0.43137255311012268, 0.43137255311012268),
            (0.57563024759292603, 0.42745098471641541, 0.42745098471641541),
            (0.57983195781707764, 0.42352941632270813, 0.42352941632270813),
            (0.58403360843658447, 0.41960784792900085, 0.41960784792900085),
            (0.58823531866073608, 0.41568627953529358, 0.41568627953529358),
            (0.59243696928024292, 0.4117647111415863, 0.4117647111415863),
            (0.59663867950439453, 0.40784314274787903, 0.40784314274787903),
            (0.60084033012390137, 0.40000000596046448, 0.40000000596046448),
            (0.60504204034805298, 0.3960784375667572, 0.3960784375667572),
            (0.60924369096755981, 0.39215686917304993, 0.39215686917304993),
            (0.61344540119171143, 0.38823530077934265, 0.38823530077934265),
            (0.61764705181121826, 0.38431373238563538, 0.38431373238563538),
            (0.62184876203536987, 0.3803921639919281, 0.3803921639919281),
            (0.62605041265487671, 0.37647059559822083, 0.37647059559822083),
            (0.63025212287902832, 0.37254902720451355, 0.37254902720451355),
            (0.63445377349853516, 0.36862745881080627, 0.36862745881080627),
            (0.63865548372268677, 0.364705890417099, 0.364705890417099),
            (0.6428571343421936, 0.36078432202339172, 0.36078432202339172),
            (0.64705884456634521, 0.35686275362968445, 0.35686275362968445),
            (0.65126049518585205, 0.35294118523597717, 0.35294118523597717),
            (0.65546220541000366, 0.3490196168422699, 0.3490196168422699),
            (0.6596638560295105, 0.34509804844856262, 0.34509804844856262),
            (0.66386556625366211, 0.33725491166114807, 0.33725491166114807),
            (0.66806721687316895, 0.3333333432674408, 0.3333333432674408),
            (0.67226892709732056, 0.32941177487373352, 0.32941177487373352),
            (0.67647057771682739, 0.32549020648002625, 0.32549020648002625),
            (0.680672287940979, 0.32156863808631897, 0.32156863808631897),
            (0.68487393856048584, 0.31764706969261169, 0.31764706969261169),
            (0.68907564878463745, 0.31372550129890442, 0.31372550129890442),
            (0.69327729940414429, 0.30980393290519714, 0.30980393290519714),
            (0.6974790096282959, 0.30588236451148987, 0.30588236451148987),
            (0.70168066024780273, 0.30196079611778259, 0.30196079611778259),
            (0.70588237047195435, 0.29803922772407532, 0.29803922772407532),
            (0.71008402109146118, 0.29411765933036804, 0.29411765933036804),
            (0.71428573131561279, 0.29019609093666077, 0.29019609093666077),
            (0.71848738193511963, 0.28627452254295349, 0.28627452254295349),
            (0.72268909215927124, 0.28235295414924622, 0.28235295414924622),
            (0.72689074277877808, 0.27450981736183167, 0.27450981736183167),
            (0.73109245300292969, 0.27058824896812439, 0.27058824896812439),
            (0.73529410362243652, 0.26666668057441711, 0.26666668057441711),
            (0.73949581384658813, 0.26274511218070984, 0.26274511218070984),
            (0.74369746446609497, 0.25882354378700256, 0.25882354378700256),
            (0.74789917469024658, 0.25490197539329529, 0.25490197539329529),
            (0.75210082530975342, 0.25098040699958801, 0.25098040699958801),
            (0.75630253553390503, 0.24705882370471954, 0.24705882370471954),
            (0.76050418615341187, 0.24313725531101227, 0.24313725531101227),
            (0.76470589637756348, 0.23921568691730499, 0.23921568691730499),
            (0.76890754699707031, 0.23529411852359772, 0.23529411852359772),
            (0.77310925722122192, 0.23137255012989044, 0.23137255012989044),
            (0.77731090784072876, 0.22745098173618317, 0.22745098173618317),
            (0.78151261806488037, 0.22352941334247589, 0.22352941334247589),
            (0.78571426868438721, 0.21960784494876862, 0.21960784494876862),
            (0.78991597890853882, 0.21176470816135406, 0.21176470816135406),
            (0.79411762952804565, 0.20784313976764679, 0.20784313976764679),
            (0.79831933975219727, 0.20392157137393951, 0.20392157137393951),
            (0.8025209903717041, 0.20000000298023224, 0.20000000298023224),
            (0.80672270059585571, 0.19607843458652496, 0.19607843458652496),
            (0.81092435121536255, 0.19215686619281769, 0.19215686619281769),
            (0.81512606143951416, 0.18823529779911041, 0.18823529779911041),
            (0.819327712059021, 0.18431372940540314, 0.18431372940540314),
            (0.82352942228317261, 0.18039216101169586, 0.18039216101169586),
            (0.82773107290267944, 0.17647059261798859, 0.17647059261798859),
            (0.83193278312683105, 0.17254902422428131, 0.17254902422428131),
            (0.83613443374633789, 0.16862745583057404, 0.16862745583057404),
            (0.8403361439704895, 0.16470588743686676, 0.16470588743686676),
            (0.84453779458999634, 0.16078431904315948, 0.16078431904315948),
            (0.84873950481414795, 0.15686275064945221, 0.15686275064945221),
            (0.85294115543365479, 0.14901961386203766, 0.14901961386203766),
            (0.8571428656578064, 0.14509804546833038, 0.14509804546833038),
            (0.86134451627731323, 0.14117647707462311, 0.14117647707462311),
            (0.86554622650146484, 0.13725490868091583, 0.13725490868091583),
            (0.86974787712097168, 0.13333334028720856, 0.13333334028720856),
            (0.87394958734512329, 0.12941177189350128, 0.12941177189350128),
            (0.87815123796463013, 0.12549020349979401, 0.12549020349979401),
            (0.88235294818878174, 0.12156862765550613, 0.12156862765550613),
            (0.88655459880828857, 0.11764705926179886, 0.11764705926179886),
            (0.89075630903244019, 0.11372549086809158, 0.11372549086809158),
            (0.89495795965194702, 0.10980392247438431, 0.10980392247438431),
            (0.89915966987609863, 0.10588235408067703, 0.10588235408067703),
            (0.90336132049560547, 0.10196078568696976, 0.10196078568696976),
            (0.90756303071975708, 0.098039217293262482, 0.098039217293262482),
            (0.91176468133926392, 0.094117648899555206, 0.094117648899555206),
            (0.91596639156341553, 0.086274512112140656, 0.086274512112140656),
            (0.92016804218292236, 0.08235294371843338, 0.08235294371843338),
            (0.92436975240707397, 0.078431375324726105, 0.078431375324726105),
            (0.92857140302658081, 0.074509806931018829, 0.074509806931018829),
            (0.93277311325073242, 0.070588238537311554, 0.070588238537311554),
            (0.93697476387023926, 0.066666670143604279, 0.066666670143604279),
            (0.94117647409439087, 0.062745101749897003, 0.062745101749897003),
            (0.94537812471389771, 0.058823529630899429, 0.058823529630899429),
            (0.94957983493804932, 0.054901961237192154, 0.054901961237192154),
            (0.95378148555755615, 0.050980392843484879, 0.050980392843484879),
            (0.95798319578170776, 0.047058824449777603, 0.047058824449777603),
            (0.9621848464012146, 0.043137256056070328, 0.043137256056070328),
            (0.96638655662536621, 0.039215687662363052, 0.039215687662363052),
            (0.97058820724487305, 0.035294119268655777, 0.035294119268655777),
            (0.97478991746902466, 0.031372550874948502, 0.031372550874948502),
            (0.97899156808853149, 0.023529412224888802, 0.023529412224888802),
            (0.98319327831268311, 0.019607843831181526, 0.019607843831181526),
            (0.98739492893218994, 0.015686275437474251, 0.015686275437474251),
            (0.99159663915634155, 0.011764706112444401, 0.011764706112444401),
            (0.99579828977584839, 0.0078431377187371254, 0.0078431377187371254),
            (1.0, 0.0039215688593685627, 0.0039215688593685627)],
    )
    return ColorMapper.from_segment_map(_data, range=range, **traits)


# Make the convenient list of all the function names as well as a dictionary
# of name->function mappings.  These are useful for UI editors.

color_map_functions = [
    jet,
    autumn,
    bone,
    cool,
    copper,
    flag,
    gray,
    yarg,
    hot,
    hsv,
    pink,
    prism,
    spring,
    summer,
    winter,
    cw1_004,
    cw1_005,
    cw1_006,
    cw1_028,
    gmt_drywet,
    Spectral,
    RdBu,
    RdPu,
    YlGnBu,
    RdYlBu,
    GnBu,
    RdYlGn,
    PuBu,
    BuGn,
    Greens,
    PRGn,
    BuPu,
    OrRd,
    Oranges,
    PiYG,
    YlGn,
    BrBG,
    Reds,
    RdGy,
    PuRd,
    Blues,
    Greys,
    YlOrRd,
    YlOrBr,
    Purples,
    PuOr,
    PuBuGn,
    gist_earth,
    gist_gray,
    gist_heat,
    gist_ncar,
    gist_rainbow,
    gist_stern,
    gist_yarg,
]

color_map_dict = {}
for func in color_map_functions:
    color_map_dict[func] = func.__name__

color_map_name_dict = {}
for func in color_map_functions:
    color_map_name_dict[func.__name__] = func
    __all__.append(func.__name__)


#### EOF ######################################################################

########NEW FILE########
__FILENAME__ = default_colors
"""List of nice color palettes for Chaco"""


# This is a palette of 10 nice colors to use for mapping/discrete
# color differentiation.  From ColorBrewer.
cbrewer = [
    (0.65098039,  0.80784314,  0.89019608, 1.0),
    (0.12156863,  0.47058824,  0.70588235, 1.0),
    (0.69803922,  0.8745098 ,  0.54117647, 1.0),
    (0.2       ,  0.62745098,  0.17254902, 1.0),
    (0.98431373,  0.60392157,  0.6       , 1.0),
    (0.89019608,  0.10196078,  0.10980392, 1.0),
    (0.99215686,  0.74901961,  0.43529412, 1.0),
    (1.        ,  0.49803922,  0.        , 1.0),
    (0.79215686,  0.69803922,  0.83921569, 1.0),
    (0.41568627,  0.23921569,  0.60392157, 1.0),
    ]

palette11 = [
    (0.725490, 0.329412, 0.615686, 1.0),
    (0.121569, 0.313725, 0.552941, 1.0),
    (0.376471, 0.525490, 0.082353, 1.0),
    (0.435294, 0.380392, 0.572549, 1.0),
    (0.988235, 0.400000, 0.600000, 1.0),
    (0.133333, 0.588235, 0.976471, 1.0),
    (0.992157, 0.600000, 0.400000, 1.0),
    (0.611765, 0.200000, 0.380392, 1.0),
    (0.388235, 0.647059, 0.537255, 1.0),
    (0.545098, 0.686275, 0.874510, 1.0),
    (0.623529, 0.501961, 0.862745, 1.0),
    ]

palette14 = [
    (0.286275, 0.235294, 0.545098, 1.0),
    (0.976471, 0.709804, 0.313725, 1.0),
    (0.850980, 0.094118, 0.521569, 1.0),
    (0.431373, 0.662745, 0.431373, 1.0),
    (0.803922, 0.345098, 0.345098, 1.0),
    (0.015686, 0.749020, 0.403922, 1.0),
    (0.694118, 0.686275, 0.580392, 1.0),
    (0.376471, 0.298039, 0.788235, 1.0),
    (0.992157, 0.396078, 0.011765, 1.0),
    (0.298039, 0.776471, 0.615686, 1.0),
    (0.988235, 0.407843, 0.686275, 1.0),
    (0.000000, 0.600000, 0.984314, 1.0),
    (0.470588, 0.917647, 0.478431, 1.0),
    (0.627451, 0.250980, 0.815686, 1.0),
    ]

PALETTES = [cbrewer, palette11, palette14]



########NEW FILE########
__FILENAME__ = errorbar_plot

from __future__ import with_statement

# Major library imports
from numpy import column_stack, compress, invert, isnan, transpose
import logging

# Enthought library imports
from traits.api import Any, Enum, Float, Instance

# Chaco imports
from lineplot import LinePlot
from abstract_data_source import AbstractDataSource

# Set up a logger for this module
logger = logging.getLogger(__name__)



class ErrorBarPlot(LinePlot):
    """ Renders errorbars at various points.
    """

    # The datasource containing the low values
    value_low = Instance(AbstractDataSource)

    # The datasource containing the high values
    value_high = Instance(AbstractDataSource)

    # The screen-space width of the endcap bars
    endcap_size = Float(5.0)

    # The kind of encap to render on error bars
    endcap_style = Enum("bar", "none", None)

    # Override the inherited trait definition
    _cached_data_pts = Any

    def map_screen(self, data_array):
        """ data_array can be Nx2 or Nx3.  In the former case, each row is
        treated as (index, value), and this method returns screen X and Y
        coordinates.  In the latter case, each row is treated as (index,
        value_low, value_high), and the method returns either (x, ylow, yhigh)
        or (y, xlow, xhigh) depending on self.orientation.
        """
        if len(data_array) == 0:
            return []
        elif data_array.shape[1] == 2:
            return LinePlot.map_screen(self, data_array)
        else:
            x, ylow, yhigh = transpose(data_array)
            sx = self.index_mapper.map_screen(x)
            sylow = self.value_mapper.map_screen(ylow)
            syhigh = self.value_mapper.map_screen(yhigh)
            return column_stack((sx, sylow, syhigh))

    def get_screen_points(self):
        self._gather_points()
        return self.map_screen(self._cached_data_pts)

    def _gather_points(self):

        if self._cache_valid:
            return

        if not self.index or not self.value_low or not self.value_high:
            return

        index, index_mask = self.index.get_data_mask()
        value_low, value_low_mask = self.value_low.get_data_mask()
        value_high, value_high_mask = self.value_high.get_data_mask()
        value_mask = value_low_mask & value_high_mask

        l1, l2, l3 = map(len, (index, value_low, value_high))
        if 0 in (l1, l2, l3) or not (l1 == l2 == l3):
            logger.warn("Chaco: using empty dataset; index_len=%d, value_low_len=%d, value_high_len=%d." % (l1,l2,l3))
            self._cached_data_pts = []
            self._cache_valid = True
            return

        index_range_mask = self.index_mapper.range.mask_data(index)
        value_low_mask = self.value_mapper.range.mask_data(value_low)
        value_high_mask = self.value_mapper.range.mask_data(value_high)
        value_range_mask = value_low_mask | value_high_mask

        nan_mask = invert(isnan(index_mask) | isnan(value_mask))
        point_mask = index_mask & value_mask & nan_mask & index_range_mask & value_range_mask

        points = column_stack((index, value_low, value_high))

        self._cached_data_pts = compress(point_mask, points, axis=0)
        self._cache_valid = True
        return

    def _render(self, gc, points, icon_mode=False):
        if len(points) == 0:
            return

        if not icon_mode:
            gc.clip_to_rect(self.x, self.y, self.width, self.height)

        with gc:
            gc.set_antialias(False)
            gc.set_stroke_color(self.color_)
            gc.set_line_width(self.line_width)
            gc.set_line_dash(self.line_style_)

            if self.orientation == "h":
                x, ylow, yhigh = transpose(points)
                start, end = column_stack((x, ylow)), column_stack((x, yhigh))
                gc.line_set(start, end)
                axis = 0
                low = ylow
                high = yhigh

            else:
                y, xlow, xhigh = transpose(points)
                start, end = column_stack((xlow, y)), column_stack((xhigh, y))
                gc.line_set(start, end)
                axis = 1
                low = xlow
                high = xhigh

            if self.endcap_style == "bar":
                self._render_bar_endcap(gc, start, end, low, high, axis)
            else:
                gc.stroke_path()

        if not icon_mode:
            self._draw_default_axes(gc)
        return


    def _render_bar_endcap(self, gc, start, end, low, high, axis):
        """ Renders the endcaps for endcap_style == "bar".  start and end are
        the two endpoints of the bare errorbar.  axis is the column index
        corresponding to the index direction, so for orientation of 'h', axis
        is 0.

        This method modifies start and end.
        """
        delta = self.endcap_size / 2.0
        start[:,axis] -= delta
        end[:,axis] += delta

        start[:,1-axis] = low
        end[:,1-axis] = low
        gc.line_set(start, end)

        start[:,1-axis] = high
        end[:,1-axis] = high
        gc.line_set(start, end)
        gc.stroke_path()
        return


    def _render_icon(self, gc, x, y, width, height):
        pass


########NEW FILE########
__FILENAME__ = example_support
doc = \
"""
This file contains a support class that wraps up the boilerplate toolkit calls
that virtually all the demo programs have to use, and doesn't actually do
anything when run on its own.

Try running simple_line.py, colormapped_scatter.py, or check out any of
the programs in in tutorials/.
"""

from numpy import array

from traits.etsconfig.api import ETSConfig


# Set up the debug logger for all chaco examples.
# We don't want users to go digging around for the default Enthought logfile
# in ~/envisage.log, so we add a handler to the global logger for a file
# "chaco.log" in the current directory.

#import logging, logging.handlers
#try:
#    chaco_handler = logging.handlers.RotatingFileHandler("chaco.log",
#                        maxBytes=1000000, backupCount=0)
#    logging.getLogger().addHandler(chaco_handler)
#except:
#    # If we can't override the default handler, it's OK.
#    pass


# Import a default palette for backwards compatibility
from default_colors import cbrewer as COLOR_PALETTE


# FIXME - it should be enough to do the following import, but because of the
# PyQt/traits problem (see below) we can't because it would drag in traits too
# early.  Until it is fixed we just assume wx if we can import it.
# Force the selection of a valid toolkit.
#import enable.toolkit
if not ETSConfig.toolkit:
    for toolkit, toolkit_module in (('wx', 'wx'), ('qt4', 'pyface.qt')):
        try:
            __import__(toolkit_module)
            ETSConfig.toolkit = toolkit
            break
        except ImportError:
            pass
    else:
        raise RuntimeError("Can't load wx or qt4 backend for Chaco.")


if ETSConfig.toolkit == 'wx':
    import wx

    class DemoFrame(wx.Frame):
        """ Wraps boilerplate WX calls that almost all the demo programs have
        to use.
        """
        def __init__ ( self, *args, **kw ):
            wx.Frame.__init__( *(self,) + args, **kw )
            self.SetAutoLayout( True )

            # Create the subclass's window
            self.plot_window = self._create_window()

            sizer = wx.BoxSizer(wx.HORIZONTAL)
            sizer.Add(self.plot_window.control, 1, wx.EXPAND)
            self.SetSizer(sizer)
            self.Show( True )
            return

        def _create_window(self):
            "Subclasses should override this method and return an enable.wx.Window"
            raise NotImplementedError


    def demo_main(demo_class, size=(400,400), title="Chaco plot"):
        "Takes the class of the demo to run as an argument."
        app = wx.PySimpleApp()
        frame = demo_class(None, size=size, title=title)
        app.SetTopWindow(frame)
        app.MainLoop()

elif ETSConfig.toolkit == 'qt4':
    from pyface.qt import QtGui

    _app = QtGui.QApplication.instance()

    if _app is None:
        import sys
        _app = QtGui.QApplication(sys.argv)

    class DemoFrame(QtGui.QWidget):
        def __init__ (self, parent, **kw):
            QtGui.QWidget.__init__(self)

            # Create the subclass's window
            self.plot_window = self._create_window()

            layout = QtGui.QVBoxLayout()
            layout.setMargin(0)
            layout.addWidget(self.plot_window.control)

            self.setLayout(layout)

            if 'size' in kw:
                self.resize(*kw['size'])

            if 'title' in kw:
                self.setWindowTitle(kw['title'])

            self.show()

        def _create_window(self):
            "Subclasses should override this method and return an enable.Window"
            raise NotImplementedError


    def demo_main(demo_class, size=(400,400), title="Chaco plot"):
        "Takes the class of the demo to run as an argument."
        frame = demo_class(None, size=size, title=title)
        _app.exec_()

elif ETSConfig.toolkit == 'pyglet':
    from enable.pyglet_backend.pyglet_app import get_app, PygletApp

    class DemoFrame(object):
        def __init__(self):
            app = get_app()
            if app:
                window = self._create_window()
                self.enable_win = window
                app.add_window(window.control)
            return

        def _create_window(self):
            raise NotImplementedError

    def demo_main(demo_class, size=(640,480), title="Chaco Example"):
        """ Runs a simple application in Pyglet using an instance of
        **demo_class** as the main window or frame.

        **demo_class** should be a subclass of DemoFrame or the pyglet
        backend's Window class.
        """
        app = PygletApp()
        if issubclass(demo_class, DemoFrame):
            frame = demo_class()
            window = frame.enable_win.control
        else:
            window = demo_class().control
        if not window._fullscreen:
            window.set_size(*size)
        window.set_caption(title)
        app.set_main_window(window)
        app.run()


if __name__ == "__main__":
    print "\n" + doc + "\n"

# EOF

########NEW FILE########
__FILENAME__ = filled_line_plot

from __future__ import with_statement

from numpy import empty
from traits.api import Property, Enum

# Local imports
from lineplot import LinePlot
from polygon_plot import PolygonPlot


def Alias(name):
    return Property(lambda obj: getattr(obj, name),
                    lambda obj, val: setattr(obj, name, val))


class FilledLinePlot(PolygonPlot):
    """ Draws a line plot filled to the axis """

    fill_color = Alias("face_color")

    # Direction to fill. Down is towards the origin, up is towards the max
    fill_direction = Enum("down", "up")

    # The rendering style of the line plot.
    #
    # connectedpoints
    #     "normal" style (default); each point is connected to subsequent and
    #     prior points by line segments
    # hold
    #     each point is represented by a line segment parallel to the abscissa
    #     (index axis) and spanning the length between the point and its
    #     subsequent point.
    # connectedhold
    #     like "hold" style, but line segments are drawn at each point of the
    #     plot to connect the hold lines of the prior point and the current
    #     point.  Also called a "right angle plot".
    render_style = Enum("connectedpoints", "hold", "connectedhold")

    def _render(self, gc, points):
        if len(points) == 0:
            return

        render_method_dict = {
                "hold": LinePlot._render_hold,
                "connectedhold": LinePlot._render_connected_hold,
                "connectedpoints": LinePlot._render_normal
                }
        render_lines = render_method_dict.get(self.render_style, LinePlot._render_normal)

        if self.fill_direction == 'down':
            ox, oy = self.map_screen([[0,0]])[0]
        else:
            ox, oy = self.map_screen([[self.x_mapper.range.high,
                                      self.y_mapper.range.high]])[0]

        with gc:
            gc.clip_to_rect(self.x, self.y, self.width, self.height)

            # If the fill color is not transparent, then draw the fill polygon first
            face_col = self.effective_face_color
            if not (len(face_col) == 4 and face_col[-1] == 0):
                if self.render_style in ("hold","connectedhold"):
                    # Modify the points array before passing it in to render_polys:
                    # Between every two points, create an intermediate point with
                    # the first point's Y and the second point's X.  (For vertical
                    # plots, use the first point's X and the second point's Y.)
                    new_points = empty((points.shape[0]*2-1, 2))
                    new_points[::2] = points
                    if self.orientation == "h":
                        new_points[1::2,0] = points[1:,0]
                        new_points[1::2,1] = points[:-1,1]
                    else:
                        new_points[1::2,0] = points[:-1,0]
                        new_points[1::2,1] = points[1:,1]
                    points = new_points

                self._render_polys(gc, points, ox, oy)

            # If the line color is not transparent, or tha same color
            # as the filled area:
            edge_col = self.effective_edge_color
            if (not (len(edge_col) == 4 and edge_col[-1] == 0)) and edge_col != face_col:
                gc.set_stroke_color(edge_col)
                gc.set_line_width(self.edge_width)
                gc.set_line_dash(self.edge_style_)
                # Create a list around points because the LinePlot supports
                # Nans, and its rendering methods expect lists of disjoint arrays.
                render_lines(gc, [points], self.orientation)


    def _render_polys(self, gc, points, ox, oy):
        face_col = self.effective_face_color
        gc.set_fill_color(face_col)
        gc.begin_path()
        startx, starty = points[0]
        if self.orientation == "h":
            gc.move_to(startx, oy)
            gc.line_to(startx, starty)
        else:
            gc.move_to(ox, starty)
            gc.line_to(startx, starty)

        gc.lines(points)

        endx, endy = points[-1]
        if self.orientation == "h":
            gc.line_to(endx, oy)
            gc.line_to(startx, oy)
        else:
            gc.line_to(ox, endy)
            gc.line_to(ox, starty)

        gc.close_path()
        gc.fill_path()

########NEW FILE########
__FILENAME__ = function_data_source

from numpy import array

# Enthought library imports
from traits.api import Callable, Instance, on_trait_change

# Local, relative imports
from abstract_data_source import AbstractDataSource
from array_data_source import ArrayDataSource
from data_range_1d import DataRange1D


class FunctionDataSource(ArrayDataSource):

    # The function to call with the low and high values of the range.
    # It should return an array of values.
    func = Callable

    # A reference to a datarange
    data_range = Instance(DataRange1D)

    def __init__(self, **kw):
        # Explicitly call the AbstractDataSource constructor because
        # the ArrayDataSource ctor wants a data array
        AbstractDataSource.__init__(self, **kw)
        self.recalculate()

    @on_trait_change('data_range.updated')
    def recalculate(self):
        if self.func is not None and self.data_range is not None:
            newarray = self.func(self.data_range.low, self.data_range.high)
            ArrayDataSource.set_data(self, newarray)
        else:
            self._data = array([], dtype=float)

    def set_data(self, *args, **kw):
        raise RuntimeError("Cannot set numerical data on a FunctionDataSource")

    def set_mask(self, mask):
        # This would be REALLY FREAKING SLICK, but it's current unimplemented
        raise NotImplementedError

    def remove_mask(self):
        raise NotImplementedError



########NEW FILE########
__FILENAME__ = function_image_data
from numpy import array
from traits.api import Instance, Callable, on_trait_change
from chaco.api import DataRange2D, ImageData

# Adapted (ie. copied and modified) from function_data_source.

# Given the time frequently required for image manipulation,
# it would be awesome if there was a mechanism for returning
# partial results as they become available.

class FunctionImageData(ImageData):
    """ A class that provides data for a 2-D image based upon the range
    supplied.  This class can be used as the data source for an image plot
    or contour plot.

    Computation should be fairly swift for acceptable interactive performance.
    """

    # The function to call with the low and high values of the range
    # in the x and y dimensions.  It should return either a 2-D array
    # of numerical values, or an array of RGB or RGBA values (shape should
    # be (n, m), (n, m, 3) or (n, m, 4)).
    func = Callable

    # the 2D data_range required for the data shown
    data_range = Instance(DataRange2D)

    def __init__(self, **kw):
        super(FunctionImageData, self).__init__(**kw)
        # Explicitly construct the initial data set for ImageData
        self.recalculate()

    @on_trait_change('data_range.updated')
    def recalculate(self):
        if self.func is not None and self.data_range is not None:
            newarray = self.func(
                self.data_range.x_range.low,
                self.data_range.x_range.high,
                self.data_range.y_range.low,
                self.data_range.y_range.high
            )
            ImageData.set_data(self, newarray)
        else:
            self._data = array([], dtype=float)

    def set_data(self, *args, **kw):
        raise RuntimeError("Cannot set numerical data on a FunctionImageData")

    def set_mask(self, mask):
        # This would be REALLY FREAKING SLICK, but it's currently unimplemented
        raise NotImplementedError

    def remove_mask(self):
        raise NotImplementedError

########NEW FILE########
__FILENAME__ = grid
""" Defines the PlotGrid class, and associated Traits UI View and validator
function.
"""

from __future__ import with_statement

from numpy import around, array, asarray, column_stack, float64, inf, zeros, zeros_like

# Enthought library imports
from enable.api import black_color_trait, LineStyle
from traits.api import Any, Bool, Callable, Enum, Float, Instance, \
        CInt, Trait, Property, TraitError, Tuple, on_trait_change
from traitsui.api import HGroup, Item, VGroup, View, TextEditor

# Local, relative imports
from abstract_overlay import AbstractOverlay
from abstract_mapper import AbstractMapper
from log_mapper import LogMapper
from ticks import AbstractTickGenerator, DefaultTickGenerator


def float_or_auto(val):
    """
    Validator function that returns *val* if *val* is either a number or
    the word 'auto'.  This is used as a validator for the text editor
    in the traits UI for the tick_interval trait.
    """
    try:
        return float(val)
    except:
        if isinstance(val, basestring) and val == "auto":
            return val
    raise TraitError, "Tick interval must be a number or 'auto'."

# View for setting grid properties.
GridView = View(VGroup(
                HGroup(Item("grid_interval", label="Interval", editor=TextEditor(evaluate=float_or_auto)),
                       Item("visible", label="Visible")),
                Item("line_color", label="Color", style="custom"),
                Item("line_style", label="Dash style"),
                Item("line_width", label="Thickness")
                ),
                buttons = ["OK", "Cancel"]
            )


def Alias(name):
    return Property(lambda obj: getattr(obj, name),
                    lambda obj, val: setattr(obj, name, val))


class PlotGrid(AbstractOverlay):
    """ An overlay that represents a grid.

    A grid is a set of parallel lines, horizontal or vertical. You can use
    multiple grids with different settings for the horizontal and vertical
    lines in a plot.
    """

    #------------------------------------------------------------------------
    # Data-related traits
    #------------------------------------------------------------------------

    # The mapper (and associated range) that drive this PlotGrid.
    mapper = Instance(AbstractMapper)

    # The dataspace interval between grid lines.
    grid_interval = Trait('auto', 'auto', Float)

    # The dataspace value at which to start this grid.  If None, then
    # uses the mapper.range.low.
    data_min = Trait(None, None, Float)

    # The dataspace value at which to end this grid.  If None, then uses
    # the mapper.range.high.
    data_max = Trait(None, None, Float)

    # A callable that implements the AbstractTickGenerator Interface.
    tick_generator = Instance(AbstractTickGenerator)

    #------------------------------------------------------------------------
    # Layout traits
    #------------------------------------------------------------------------

    # The orientation of the grid lines.  "horizontal" means that the grid
    # lines are parallel to the X axis and the ticker and grid interval
    # refer to the Y axis.
    orientation = Enum('horizontal', 'vertical')

    # Draw the ticks starting at the end of the mapper range? If False, the
    # ticks are drawn starting at 0. This setting can be useful to keep the
    # grid from from "flashing" as the user resizes the plot area.
    flip_axis = Bool(False)

    # Optional specification of the grid bounds in the dimension transverse
    # to the ticking/gridding dimension, i.e. along the direction specified
    # by self.orientation.  If this is specified but transverse_mapper is
    # not specified, then there is no effect.
    #
    #   None : use self.bounds or self.component.bounds (if overlay)
    #   Tuple : (low, high) extents, used for every grid line
    #   Callable : Function that takes an array of dataspace grid ticks
    #              and returns either an array of shape (N,2) of (starts,ends)
    #              for each grid point or a single tuple (low, high)
    transverse_bounds = Trait(None, Tuple, Callable)

    # Mapper in the direction corresponding to self.orientation, i.e. transverse
    # to the direction of self.mapper.  This is used to compute the screen
    # position of transverse_bounds.  If this is not specified, then
    # transverse_bounds has no effect, and vice versa.
    transverse_mapper = Instance(AbstractMapper)

    # Dimensions that the grid is resizable in (overrides PlotComponent).
    resizable = "hv"

    #------------------------------------------------------------------------
    # Appearance traits
    #------------------------------------------------------------------------

    # The color of the grid lines.
    line_color = black_color_trait

    # The style (i.e., dash pattern) of the grid lines.
    line_style = LineStyle('solid')

    # The thickness, in pixels, of the grid lines.
    line_width = CInt(1)
    line_weight = Alias("line_width")

    # Default Traits UI View for modifying grid attributes.
    traits_view = GridView

    #------------------------------------------------------------------------
    # Private traits; mostly cached information
    #------------------------------------------------------------------------

    _cache_valid = Bool(False)
    _tick_list = Any
    _tick_positions = Any

    # An array (N,2) of start,end positions in the transverse direction
    # i.e. the direction corresponding to self.orientation
    _tick_extents = Any

    #_length = Float(0.0)


    #------------------------------------------------------------------------
    # Public methods
    #------------------------------------------------------------------------

    def __init__(self, **traits):
        # TODO: change this back to a factory in the instance trait some day
        self.tick_generator = DefaultTickGenerator()
        super(PlotGrid, self).__init__(**traits)
        self.bgcolor = "none" #make sure we're transparent
        return

    @on_trait_change("bounds,bounds_items,position,position_items")
    def invalidate(self):
        """ Invalidate cached information about the grid.
        """
        self._reset_cache()
        return


    #------------------------------------------------------------------------
    # PlotComponent and AbstractOverlay interface
    #------------------------------------------------------------------------

    def do_layout(self, *args, **kw):
        """ Tells this component to do layout at a given size.

        Overrides PlotComponent.
        """
        if self.use_draw_order and self.component is not None:
            self._layout_as_overlay(*args, **kw)
        else:
            super(PlotGrid, self).do_layout(*args, **kw)
        return

    #------------------------------------------------------------------------
    # Private methods
    #------------------------------------------------------------------------

    def _do_layout(self):
        """ Performs a layout.

        Overrides PlotComponent.
        """
        return

    def _layout_as_overlay(self, size=None, force=False):
        """ Lays out the axis as an overlay on another component.
        """
        if self.component is not None:
            self.position = self.component.position
            self.bounds = self.component.bounds
        return

    def _reset_cache(self):
        """ Clears the cached tick positions.
        """
        self._tick_positions = array([], dtype=float)
        self._tick_extents = array([], dtype=float)
        self._cache_valid = False
        return

    def _compute_ticks(self, component=None):
        """ Calculates the positions for the grid lines.
        """
        if (self.mapper is None):
            self._reset_cache()
            self._cache_valid = True
            return

        if self.data_min is None:
            datalow = self.mapper.range.low
        else:
            datalow = self.data_min
        if self.data_max is None:
            datahigh = self.mapper.range.high
        else:
            datahigh = self.data_max

        # Map the low and high data points
        screenhigh = self.mapper.map_screen(datalow)
        screenlow = self.mapper.map_screen(datahigh)

        if (datalow == datahigh) or (screenlow == screenhigh) or \
           (datalow in [inf, -inf]) or (datahigh in [inf, -inf]):
            self._reset_cache()
            self._cache_valid = True
            return

        if component is None:
            component = self.component

        if component is not None:
            bounds = component.bounds
            position = component.position
        else:
            bounds = self.bounds
            position = self.position

        if isinstance(self.mapper, LogMapper):
            scale = 'log'
        else:
            scale = 'linear'

        ticks = self.tick_generator.get_ticks(datalow, datahigh, datalow, datahigh,
                                              self.grid_interval, use_endpoints = False,
                                              scale=scale)
        tick_positions = self.mapper.map_screen(array(ticks, float64))

        if self.orientation == 'horizontal':
            self._tick_positions = around(column_stack((zeros_like(tick_positions) + position[0],
                                           tick_positions)))
        elif self.orientation == 'vertical':
            self._tick_positions = around(column_stack((tick_positions,
                                           zeros_like(tick_positions) + position[1])))
        else:
            raise self.NotImplementedError

        # Compute the transverse direction extents
        self._tick_extents = zeros((len(ticks), 2), dtype=float)
        if self.transverse_bounds is None or self.transverse_mapper is None:
            # No mapping needed, just use the extents
            if self.orientation == 'horizontal':
                extents = (position[0], position[0] + bounds[0])
            elif self.orientation == 'vertical':
                extents = (position[1], position[1] + bounds[1])
            self._tick_extents[:] = extents
        elif callable(self.transverse_bounds):
            data_extents = self.transverse_bounds(ticks)
            tmapper = self.transverse_mapper
            if isinstance(data_extents, tuple):
                self._tick_extents[:] = tmapper.map_screen(asarray(data_extents))
            else:
                extents = array([tmapper.map_screen(data_extents[:,0]),
                                 tmapper.map_screen(data_extents[:,1])]).T
                self._tick_extents = extents
        else:
            # Already a tuple
            self._tick_extents[:] = self.transverse_mapper.map_screen(asarray(self.transverse_bounds))

        self._cache_valid = True


    def _draw_overlay(self, gc, view_bounds=None, mode='normal'):
        """ Draws the overlay layer of a component.

        Overrides PlotComponent.
        """
        self._draw_component(gc, view_bounds, mode)
        return

    def overlay(self, other_component, gc, view_bounds=None, mode="normal"):
        """ Draws this component overlaid on another component.

        Overrides AbstractOverlay.
        """
        if not self.visible:
            return
        self._compute_ticks(other_component)
        self._draw_component(gc, view_bounds, mode)
        self._cache_valid = False
        return

    def _draw_component(self, gc, view_bounds=None, mode="normal"):
        """ Draws the component.

        This method is preserved for backwards compatibility. Overrides
        PlotComponent.
        """
        # What we're really trying to do with a grid is plot contour lines in
        # the space of the plot.  In a rectangular plot, these will always be
        # straight lines.
        if not self.visible:
            return

        if not self._cache_valid:
            self._compute_ticks()

        if len(self._tick_positions) == 0:
            return

        with gc:
            gc.set_line_width(self.line_weight)
            gc.set_line_dash(self.line_style_)
            gc.set_stroke_color(self.line_color_)
            gc.set_antialias(False)

            if self.component is not None:
                gc.clip_to_rect(*(self.component.position + self.component.bounds))
            else:
                gc.clip_to_rect(*(self.position + self.bounds))

            gc.begin_path()
            if self.orientation == "horizontal":
                starts = self._tick_positions.copy()
                starts[:,0] = self._tick_extents[:,0]
                ends = self._tick_positions.copy()
                ends[:,0] = self._tick_extents[:,1]
            else:
                starts = self._tick_positions.copy()
                starts[:,1] = self._tick_extents[:,0]
                ends = self._tick_positions.copy()
                ends[:,1] = self._tick_extents[:,1]
            if self.flip_axis:
                starts, ends = ends, starts
            gc.line_set(starts, ends)
            gc.stroke_path()
        return

    def _mapper_changed(self, old, new):
        if old is not None:
            old.on_trait_change(self.mapper_updated, "updated", remove=True)
        if new is not None:
            new.on_trait_change(self.mapper_updated, "updated")
        self.invalidate()
        return

    def mapper_updated(self):
        """
        Event handler that is bound to this mapper's **updated** event.
        """
        self.invalidate()
        return

    def _position_changed_for_component(self):
        self.invalidate()

    def _position_items_changed_for_component(self):
        self.invalidate()

    def _bounds_changed_for_component(self):
        self.invalidate()

    def _bounds_items_changed_for_component(self):
        self.invalidate()

    #------------------------------------------------------------------------
    # Event handlers for visual attributes.  These mostly just call request_redraw()
    #------------------------------------------------------------------------

    @on_trait_change("visible,line_color,line_style,line_weight")
    def visual_attr_changed(self):
        """ Called when an attribute that affects the appearance of the grid
        is changed.
        """
        if self.component:
            self.component.invalidate_draw()
            self.component.request_redraw()
        else:
            self.invalidate_draw()
            self.request_redraw()

    def _grid_interval_changed(self):
        self.invalidate()
        self.visual_attr_changed()

    def _orientation_changed(self):
        self.invalidate()
        self.visual_attr_changed()
        return


    ### Persistence ###########################################################
    #_pickles = ("orientation", "line_color", "line_style", "line_weight",
    #            "grid_interval", "mapper")

    def __getstate__(self):
        state = super(PlotGrid,self).__getstate__()
        for key in ['_cache_valid', '_tick_list', '_tick_positions', '_tick_extents']:
            if state.has_key(key):
                del state[key]

        return state

    def _post_load(self):
        super(PlotGrid, self)._post_load()
        self._mapper_changed(None, self.mapper)
        self._reset_cache()
        self._cache_valid = False
        return


# EOF

########NEW FILE########
__FILENAME__ = grid_data_source
""" Defines the GridDataSource class.
"""

# Major library imports
from numpy import array

# Enthougth library imports
from traits.api import Constant, Instance, Tuple

# Chaco imports
from abstract_data_source import AbstractDataSource
from array_data_source import ArrayDataSource
from base import SortOrderTrait


class GridDataSource(AbstractDataSource):
    """ Implements a structured gridded 2-D data source (suitable as an index
    for an image, for example).
    """

    #------------------------------------------------------------------------
    # AbstractDataSource traits
    #------------------------------------------------------------------------

    # The dimensionality of the indices into this data source (overrides
    # AbstractDataSource).
    index_dimension = Constant('image')

    # The dimensionality of the value at each index point (overrides
    # AbstractDataSource).
    value_dimension = Constant('scalar')

    # The sort order of the data (overrides AbstractDataSource). There is no
    # overall sort order on 2-D data, but for gridded 2-D data, each axis can
    # have a sort order.
    sort_order =Tuple(SortOrderTrait, SortOrderTrait)

    #------------------------------------------------------------------------
    # Private traits
    #------------------------------------------------------------------------

    # Data grid ticks along the x (horizontal) axis.
    _xdata = Instance(ArrayDataSource, args=())

    # Data grid ticks along the y (vertical) axis
    _ydata = Instance(ArrayDataSource, args=())

    # Cached values of min and max as long as **_data** doesn't change
    # (overrides ArrayDataSource). ((min_x, max_x), (min_y, max_y))
    _cached_bounds = Tuple


    #------------------------------------------------------------------------
    # Public methods
    #------------------------------------------------------------------------

    def __init__(self, xdata=array([]), ydata=array([]),
                       sort_order=("none","none"), **kwargs):
        super(GridDataSource, self).__init__(**kwargs)
        self.set_data(xdata, ydata, sort_order)

    def set_data(self, xdata, ydata, sort_order=None):
        """ Sets the data, and optionally the sort order, for this data source.

        Parameters
        ----------
        xdata, ydata : array
            The data to use.
        sort_order : SortOrderTrait
            The sort order of the data
        """
        if sort_order is not None:
            self.sort_order = sort_order
            self._xdata.set_data(xdata, sort_order[0])
            self._ydata.set_data(ydata, sort_order[1])
        else:
            self._xdata.set_data(xdata)
            self._ydata.set_data(ydata)
        self._compute_bounds()
        self.data_changed = True


    #------------------------------------------------------------------------
    # AbstractDataSource interface
    #------------------------------------------------------------------------

    def get_data(self):
        """get_data() -> (xdata, ydata)

        Implements AbstractDataSource. Because this class uses structured
        (gridded) data, this method returns the pair of data axes, instead of,
        for example, a full mesh-grid. This behavious differs from
        other data sources.
        """
        if self._xdata is not None:
            xdata = self._xdata
        else:
            xdata = ArrayDataSource(array([]))

        if self._ydata is not None:
            ydata = self._ydata
        else:
            ydata = ArrayDataSource(array([]))

        return xdata, ydata

    def get_bounds(self):
        """get_bounds() -> ((LLx, LLy), (URx, URy))

        Implements AbstractDataSource. Returns two 2-D points, min and max, that
        represent the bounding corners of a rectangle enclosing the data set.
        Note that these values are not view-dependent, but represent intrinsic
        properties of the DataSource.

        If data axis is the empty set, then the min and max valuess are 0.0.
        """
        if self._cached_bounds == ():
            self._compute_bounds()
        return self._cached_bounds


    #------------------------------------------------------------------------
    # Private methods
    #------------------------------------------------------------------------

    def _compute_bounds(self, data=None):
        """ Computes the minimum and maximum points (LLx, LLy) and (URx, URy) of
        the data.
        """

        if data is None:
            xdata, ydata = self.get_data()
        else:
            xdata, ydata = data

        xbds = xdata.get_bounds()
        ybds = ydata.get_bounds()

        self._cached_bounds = ((xbds[0], ybds[0]), (xbds[1], ybds[1]))

    #------------------------------------------------------------------------
    # Event handlers
    #------------------------------------------------------------------------

    def _metadata_changed(self, event):
        self.metadata_changed = True

    def _metadata_items_changed(self, event):
        self.metadata_changed = True






########NEW FILE########
__FILENAME__ = grid_mapper
"""
Defines the GridMapper class, which maps from a 2-D region in data space
into a structured (gridded) 1-D output space.
"""

# Python standard library imports
from contextlib import contextmanager

# Major library imports
from numpy import transpose

# Enthought library imports
from traits.api import Bool, DelegatesTo, Instance, Float, Property

# Local relative imports
from abstract_mapper import AbstractMapper
from base_1d_mapper import Base1DMapper
from data_range_2d import DataRange2D
from linear_mapper import LinearMapper
from log_mapper import LogMapper


class GridMapper(AbstractMapper):
    """
    Maps a 2-D data space to and from screen space by specifying a 2-tuple in
    data space or by specifying a pair of screen coordinates.

    The mapper concerns itself only with metric and not with orientation. So,
    to "flip" a screen space orientation, swap the appropriate screen space
    values for **x_low_pos**, **x_high_pos**, **y_low_pos**, and
    **y_high_pos**.
    """

    # The data-space bounds of the mapper.
    range = Instance(DataRange2D)

    # The screen space position of the lower bound of the horizontal axis.
    x_low_pos = Float(0.0)

    # The screen space position of the upper bound of the horizontal axis.
    x_high_pos = Float(1.0)

    # The screen space position of the lower bound of the vertical axis.
    y_low_pos = Float(0.0)

    # The screen space position of the upper bound of the vertical axis.
    y_high_pos = Float(1.0)

    # Convenience property for low and high positions in one structure.
    # Must be a tuple (x_low_pos, x_high_pos, y_low_pos, y_high_pos).
    screen_bounds = Property

    # Should the mapper stretch the dataspace when its screen space bounds are
    # modified (default), or should it preserve the screen-to-data ratio and
    # resize the data bounds?  If the latter, it will only try to preserve
    # the ratio if both screen and data space extents are non-zero.
    stretch_data_x = DelegatesTo("_xmapper", prefix="stretch_data")
    stretch_data_y = DelegatesTo("_ymapper", prefix="stretch_data")

    # Should the mapper try to maintain a fixed aspect ratio between x and y
    maintain_aspect_ratio = Bool

    # The aspect ratio that we wish to maintain
    aspect_ratio = Float(1.0)

    #------------------------------------------------------------------------
    # Private Traits
    #------------------------------------------------------------------------

    _updating_submappers = Bool(False)
    _updating_aspect = Bool(False)

    _xmapper = Instance(Base1DMapper)
    _ymapper = Instance(Base1DMapper)

    #------------------------------------------------------------------------
    # Public methods
    #------------------------------------------------------------------------

    def __init__(self, x_type="linear", y_type="linear", range=None, **kwargs):
        # TODO: This is currently an implicit assumption, i.e. that the range
        # will be passed in to the constructor.  It would be impossible to
        # create the xmapper and ymapper otherwise.  However, this should be
        # changed so that the mappers get created or modified in response to
        # the .range attribute changing, instead of requiring the range to
        # be passed in at construction time.
        self.range = range

        if "_xmapper" not in kwargs:
            if x_type == "linear":
                self._xmapper = LinearMapper(range=self.range.x_range)
            elif x_type == "log":
                self._xmapper = LogMapper(range=self.range.x_range)
            else:
                raise ValueError("Invalid x axis type: %s" % x_type)
        else:
            self._xmapper = kwargs.pop("_xmapper")

        if "_ymapper" not in kwargs:
            if y_type == "linear":
                self._ymapper = LinearMapper(range=self.range.y_range)
            elif y_type == "log":
                self._ymapper = LogMapper(range=self.range.y_range)
            else:
                raise ValueError("Invalid y axis type: %s" % y_type)
        else:
            self._ymapper = kwargs.pop("_ymapper")

        # Now that the mappers are created, we can go to the normal HasTraits
        # constructor, which might set values that depend on us having a valid
        # range and mappers.
        super(GridMapper, self).__init__(**kwargs)

    def map_screen(self, data_pts):
        """ map_screen(data_pts) -> screen_array

        Maps values from data space into screen space.
        """
        xs, ys = transpose(data_pts)
        screen_xs = self._xmapper.map_screen(xs)
        screen_ys = self._ymapper.map_screen(ys)
        return zip(screen_xs, screen_ys)

    def map_data(self, screen_pts):
        """ map_data(screen_pts) -> data_vals

        Maps values from screen space into data space.
        """
        screen_xs, screen_ys = transpose(screen_pts)
        xs = self._xmapper.map_data(screen_xs)
        ys = self._ymapper.map_data(screen_ys)
        return zip(xs, ys)

    def map_data_array(self, screen_pts):
        return self.map_data(screen_pts)

    #------------------------------------------------------------------------
    # Private Methods
    #------------------------------------------------------------------------

    def _update_bounds(self):
        with self._update_submappers():
            self._xmapper.screen_bounds = (self.x_low_pos, self.x_high_pos)
            self._ymapper.screen_bounds = (self.y_low_pos, self.y_high_pos)
        self.updated = True

    def _update_range(self):
        self.updated = True

    def _update_aspect_x(self):
        y_width = self._ymapper.high_pos - self._ymapper.low_pos
        if y_width == 0:
            return
        y_scale = (self._ymapper.range.high - self._ymapper.range.low)/y_width
        x_range_low = self._xmapper.range.low
        x_width = self._xmapper.high_pos - self._xmapper.low_pos
        sign = self._xmapper.sign * self._ymapper.sign
        if x_width == 0 or sign == 0:
            return
        x_scale = sign*y_scale/self.aspect_ratio
        with self._update_aspect():
            self._xmapper.range.set_bounds(x_range_low, x_range_low +
                x_scale*x_width)

    def _update_aspect_y(self):
        x_width = self._xmapper.high_pos - self._xmapper.low_pos
        if x_width == 0:
            return
        x_scale = (self._xmapper.range.high - self._xmapper.range.low)/x_width
        y_range_low = self._ymapper.range.low
        y_width = self._ymapper.high_pos-self._ymapper.low_pos
        sign = self._xmapper.sign * self._ymapper.sign
        if y_width == 0 or sign == 0:
            return
        y_scale = sign*x_scale*self.aspect_ratio
        with self._update_aspect():
            self._ymapper.range.set_bounds(y_range_low, y_range_low +
                y_scale*y_width)

    #------------------------------------------------------------------------
    # Property handlers
    #------------------------------------------------------------------------

    def _range_changed(self, old, new):
        if old is not None:
            old.on_trait_change(self._update_range, "updated", remove=True)
        if new is not None:
            new.on_trait_change(self._update_range, "updated")
            if self._xmapper is not None:
                self._xmapper.range = new.x_range
            if self._ymapper is not None:
                self._ymapper.range = new.y_range
            self._update_range()

    def _x_low_pos_changed(self):
        self._xmapper.low_pos = self.x_low_pos

    def _x_high_pos_changed(self):
        self._xmapper.high_pos = self.x_high_pos

    def _y_low_pos_changed(self):
        self._ymapper.low_pos = self.y_low_pos

    def _y_high_pos_changed(self):
        self._ymapper.high_pos = self.y_high_pos

    def _set_screen_bounds(self, new_bounds):
        # TODO: figure out a way to not need to do this check:
        if self.screen_bounds == new_bounds:
            return
        self.set(x_low_pos=new_bounds[0], trait_change_notify=False)
        self.set(x_high_pos=new_bounds[1], trait_change_notify=False)
        self.set(y_low_pos=new_bounds[2], trait_change_notify=False)
        self.set(y_high_pos=new_bounds[3], trait_change_notify=False)
        self._update_bounds()

    def _get_screen_bounds(self):
        return (self.x_low_pos, self.x_high_pos,
                self.y_low_pos, self.y_high_pos)

    def _updated_fired_for__xmapper(self):
        if not self._updating_aspect:
            if self.maintain_aspect_ratio and self.stretch_data_x:
                self._update_aspect_y()
        if not self._updating_submappers:
            self.updated = True

    def _updated_fired_for__ymapper(self):
        if not self._updating_aspect:
            if self.maintain_aspect_ratio and self.stretch_data_y:
                self._update_aspect_x()
        if not self._updating_submappers:
            self.updated = True

    @contextmanager
    def _update_submappers(self):
        self._updating_submappers = True
        try:
            yield
        finally:
            self._updating_submappers = False

    @contextmanager
    def _update_aspect(self):
        self._updating_aspect = True
        try:
            yield
        finally:
            self._updating_aspect = False

########NEW FILE########
__FILENAME__ = horizon_plot
from __future__ import with_statement

from numpy import array, transpose, ndarray, empty
from traits.api import Instance, DelegatesTo, Bool, Int

from enable.api import transparent_color_trait
from chaco.color_mapper import ColorMapper
from chaco.base_xy_plot import BaseXYPlot
from chaco.linear_mapper import LinearMapper

class BandedMapper(LinearMapper):
    bands = Int(4)

    def map_screen(self, data_array):
        self._compute_scale()

        if self._null_data_range:
            if isinstance(data_array, (tuple, list, ndarray)):
                x = empty(data_array.shape)
                x.fill(self.low_pos)
                return x
            else:
                return array([self.low_pos])
        else:
            # Scale the data by the number of bands
            return (data_array*self.bands - self.range.low) * self._scale + self.low_pos

class HorizonPlot(BaseXYPlot):

    bands = DelegatesTo('value_mapper')
    color_mapper = Instance(ColorMapper)

    mirror = Bool(False)

    # FIXME There should be a way to automatically detect whether the data has
    # negative bands
    negative_bands = Bool(True)

    # Override parent traits

    orientation = 'h'

    def _color_mapper_changed(self, new):
        # change the number of steps to match the number of bands
        if not self.negative_bands:
            new.steps = self.bands+1
        else:
            new.steps = self.bands*2+1

    def _gather_points(self):
        """ Collects the data points that are within the bounds of the plot and
        caches them.
        """
        if self._cache_valid:
            return

        index = self.index.get_data()
        value = self.value.get_data()

        if not self.index or not self.value:
            return

        if len(index) == 0 or len(value) == 0 or len(index) != len(value):
            self._cached_data_pts = []
            self._cache_valid = True
            return

        points = transpose(array((index,value)))
        self._cached_data_pts = points

        self._cache_valid = True

    def _render(self, gc, points):
        if len(points) == 0:
            return

        ox, oy = self.map_screen([[0,0]])[0]
        ylow, yhigh = self.value_mapper.screen_bounds

        y_plus_height = yhigh - oy

        # Get color bands
        bands = array(self.color_mapper._get_color_bands())

        with gc: 
            gc.clip_to_rect(self.x, self.y, self.width, self.height)
            # draw positive bands
            inc = -1 * array([0, y_plus_height])
            if self.negative_bands: render_bands = bands[self.bands+1:]
            else: render_bands = bands[1:]
            for i, col in enumerate(render_bands):
                self._render_fill(gc, col, points+i*inc, ox, oy)

            # draw negative bands
            if self.negative_bands:
                if self.mirror: 
                    points[:,1] = oy - points[:,1]
                    zeroy = oy
                else: 
                    points[:,1] += y_plus_height
                    inc *= -1
                    zeroy = int(yhigh) + 2
                for i, col in enumerate(bands[self.bands-1::-1]):
                    self._render_fill(gc, col, points+i*inc, ox, zeroy)

            gc.set_stroke_color((.75, .75, .75))
            gc.set_line_width(2)
            gc.begin_path()
            gc.move_to(self.x, self.y)
            gc.line_to(self.x+self.width, self.y)
            gc.stroke_path()

    def _render_fill(self, gc, face_col, points, ox, oy):
        gc.set_fill_color(tuple(face_col))
        gc.begin_path()
        startx, starty = points[0]
        gc.move_to(startx, oy) 
        gc.line_to(startx, starty)

        gc.lines(points)

        endx, endy = points[-1]
        gc.line_to(endx, oy) 
        gc.line_to(startx, oy) 

        gc.close_path()
        gc.fill_path()

########NEW FILE########
__FILENAME__ = image_data
""" Defines the ImageData class.
"""
# Standard library imports
from numpy import nanmax, nanmin, swapaxes

# Enthought library imports
from traits.api import Bool, Int, Property, ReadOnly, Tuple

# Local relative imports
from base import DimensionTrait, ImageTrait
from abstract_data_source import AbstractDataSource

class ImageData(AbstractDataSource):
    """
    Represents a grid of data to be plotted using a Numpy 2-D grid.

    The data array has dimensions NxM, but it may have more than just 2
    dimensions.  The appropriate dimensionality of the value array depends
    on the context in which the ImageData instance will be used.
    """
    # The dimensionality of the data.
    dimension = ReadOnly(DimensionTrait('image'))

    # Depth of the values at each i,j. Values that are used include:
    #
    # * 3: color images, without alpha channel
    # * 4: color images, with alpha channel
    value_depth = Int(1) # TODO: Modify ImageData to explicitly support scalar
                         # value arrays, as needed by CMapImagePlot

    # Holds the grid data that forms the image.  The shape of the array is
    # (N, M, D) where:
    #
    # * D is 1, 3, or 4.
    # * N is the length of the y-axis.
    # * M is the length of the x-axis.
    #
    # Thus, data[0,:,:] must be the first row of data.  If D is 1, then
    # the array must be of type float; if D is 3 or 4, then the array
    # must be of type uint8.
    #
    # NOTE: If this ImageData was constructed with a transposed data array,
    # then internally it is still transposed (i.e., the x-axis is the first axis
    # and the y-axis is the second), and the **data** array property might not be
    # contiguous.  If contiguousness is required and calling copy() is too
    # expensive, use the **raw_value** attribute. Also note that setting this
    # trait does not change the value of **transposed**,
    # so be sure to set it to its proper value when using the same ImageData
    # instance interchangeably to store transposed and non-transposed data.
    data = Property(ImageTrait)

    # Is **raw_value**, the actual underlying image data
    # array, transposed from **data**? (I.e., does the first axis correspond to
    # the x-direction and the second axis correspond to the y-direction?)
    #
    # Rather than transposing or swapping axes on the data and destroying
    # continuity, this class exposes the data as both **data** and **raw_value**.
    transposed = Bool(False)

    # A read-only attribute that exposes the underlying array.
    raw_value = Property(ImageTrait)


    #------------------------------------------------------------------------
    # Private traits
    #------------------------------------------------------------------------

    # The actual image data array.  Can be MxN or NxM, depending on the value
    # of **transposed**.
    _data = ImageTrait

    # Is the bounds cache valid? If False, it needs to be computed.
    _bounds_cache_valid = Bool(False)

    # Cached value of min and max as long as **data** doesn't change.
    _bounds_cache = Tuple

    #------------------------------------------------------------------------
    # Public methods
    #------------------------------------------------------------------------

    @classmethod
    def fromfile(cls, filename):
        """ Alternate constructor to create an ImageData from an image file
        on disk. 'filename' may be a file path or a file object.
        """

        from kiva.image import Image
        img = Image(filename)
        imgdata = cls(data=img.bmp_array, transposed=False)
        fmt = img.format()

        if fmt == "rgb24":
            imgdata.value_depth = 3
        elif fmt == "rgba32":
            imgdata.value_depth = 4
        else:
            raise ValueError("Unknown image format in file %s: %s" %
                             (filename, fmt))
        return imgdata

    def get_width(self):
        """ Returns the shape of the x-axis.
        """
        if self.transposed:
            return self._data.shape[0]
        else:
            return self._data.shape[1]

    def get_height(self):
        """ Returns the shape of the y-axis.
        """
        if self.transposed:
            return self._data.shape[1]
        else:
            return self._data.shape[0]

    def get_array_bounds(self):
        """ Always returns ((0, width), (0, height)) for x-bounds and y-bounds.
        """
        if self.transposed:
            b = ((0,self._data.shape[0]), (0,self._data.shape[1]))
        else:
            b = ((0,self._data.shape[1]), (0,self._data.shape[0]))
        return b

    #------------------------------------------------------------------------
    # Datasource interface
    #------------------------------------------------------------------------

    def get_data(self):
        """ Returns the data for this data source.

        Implements AbstractDataSource.
        """
        return self.data

    def is_masked(self):
        """is_masked() -> False

        Implements AbstractDataSource.
        """
        return False

    def get_bounds(self):
        """ Returns the minimum and maximum values of the data source's data.

        Implements AbstractDataSource.
        """
        if not self._bounds_cache_valid:
            if self.raw_value.size == 0:
                self._cached_bounds = (0,0)
            else:
                self._cached_bounds = (nanmin(self.raw_value),
                                       nanmax(self.raw_value))
            self._bounds_cache_valid = True
        return self._cached_bounds

    def get_size(self):
        """get_size() -> int

        Implements AbstractDataSource.
        """
        if self._data is not None and self._data.shape[0] != 0:
            return self._data.shape[0] * self._data.shape[1]
        else:
            return 0

    def set_data(self, data):
        """ Sets the data for this data source.

        Parameters
        ----------
        data : array
            The data to use.
        """
        self._set_data(data)

    #------------------------------------------------------------------------
    # Private methods
    #------------------------------------------------------------------------

    def _get_data(self):
        if self.transposed:
            return swapaxes(self._data, 0, 1)
        else:
            return self._data

    def _set_data(self, newdata):
        self._data = newdata
        self._bounds_cache_valid = False
        self.data_changed = True

    def _get_raw_value(self):
        return self._data


    #------------------------------------------------------------------------
    # Event handlers
    #------------------------------------------------------------------------

    def _metadata_changed(self, event):
        self.metadata_changed = True

    def _metadata_items_changed(self, event):
        self.metadata_changed = True




# EOF

########NEW FILE########
__FILENAME__ = image_plot
#
# (C) Copyright 2013 Enthought, Inc., Austin, TX
# All right reserved.
#
# This file is open source software distributed according to the terms in
# LICENSE.txt
#

""" Defines the ImagePlot class.
"""

from __future__ import with_statement

# Standard library imports
from math import ceil, floor, pi

# Enthought library imports.
from traits.api import Bool, Either, Enum, Instance, \
                                 List, Range, Trait, Tuple
from kiva.agg import GraphicsContextArray

# Local relative imports
from base_2d_plot import Base2DPlot


class ImagePlot(Base2DPlot):
    """ A plot based on an image.
    """
    #------------------------------------------------------------------------
    # Data-related traits
    #------------------------------------------------------------------------

    # Overall alpha value of the image. Ranges from 0.0 for transparent to 1.0
    # for full intensity.
    alpha = Trait(1.0, Range(0.0, 1.0))

    # The interpolation method to use when rendering an image onto the GC.
    interpolation = Enum("nearest", "bilinear", "bicubic")
    
    #------------------------------------------------------------------------
    # Private traits
    #------------------------------------------------------------------------

    # Are the cache traits valid? If False, new ones need to be computed.
    _image_cache_valid = Bool(False)

    # Cached image of the bmp data (not the bmp data in self.data.value).
    _cached_image = Instance(GraphicsContextArray)

    # Tuple-defined rectangle (x, y, dx, dy) in screen space in which the
    # **_cached_image** is to be drawn.
    _cached_dest_rect = Either(Tuple, List)

    #------------------------------------------------------------------------
    # Base2DPlot interface
    #------------------------------------------------------------------------

    def _render(self, gc):
        """ Actually draws the plot.

        Implements the Base2DPlot interface.
        """
        if not self._image_cache_valid:
            self._compute_cached_image()

        if "bottom" in self.origin:
            sy = -1
        else:
            sy = 1
        if "left" in self.origin:
            sx = 1
        else:
            sx = -1

        # If the orientation is flipped, the BR and TL cases are swapped
        if self.orientation == "v" and sx == sy:
            sx, sy = -sx, -sy

        with gc:
            gc.clip_to_rect(self.x, self.y, self.width, self.height)
            gc.set_alpha(self.alpha)

            # Kiva image interpolation note:
            # Kiva's Agg backend uses the interpolation setting of the *source*
            # image to determine the type of interpolation to use when drawing the
            # image.  The mac backend uses the interpolation setting on the
            # destination GC.
            old_interp = self._cached_image.get_image_interpolation()
            if hasattr(gc, "set_interpolation_quality"):
                from kiva.quartz.ABCGI import InterpolationQuality
                interp_quality_dict = {"nearest": InterpolationQuality.none,
                        "bilinear": InterpolationQuality.low,
                        "bicubic": InterpolationQuality.high}
                gc.set_interpolation_quality(interp_quality_dict[self.interpolation])
            elif hasattr(gc, "set_image_interpolation"):
                self._cached_image.set_image_interpolation(self.interpolation)
            x, y, w, h = self._cached_dest_rect
            if self.orientation == "h":        # for horizontal orientation:
                gc.translate_ctm(x+w/2, y+h/2)   # translate back normally
            else:                              # for vertical orientation:
                gc.translate_ctm(y+h/2, x+w/2)   # translate back with dx,dy swap
            gc.scale_ctm(sx, sy)               # flip axes as appropriate
            if self.orientation == "v":        # for vertical orientation:
                gc.scale_ctm(1,-1)               # restore origin to lower left
                gc.rotate_ctm(pi/2)              # rotate 1/4 turn clockwise
            gc.translate_ctm(-x-w/2, -y-h/2)   # translate image center to origin
            gc.draw_image(self._cached_image, self._cached_dest_rect)
            self._cached_image.set_image_interpolation(old_interp)

    def map_index(self, screen_pt, threshold=0.0, outside_returns_none=True,
                  index_only=False):
        """ Maps a screen space point to an index into the plot's index array(s).

        Implements the AbstractPlotRenderer interface. Uses 0.0 for *threshold*,
        regardless of the passed value.
        """
        # For image plots, treat hittesting threshold as 0.0, because it's
        # the only thing that really makes sense.
        return Base2DPlot.map_index(self, screen_pt, 0.0, outside_returns_none,
                                    index_only)

    #------------------------------------------------------------------------
    # Private methods
    #------------------------------------------------------------------------

    def _compute_cached_image(self, data=None, mapper=None):
        """ Computes the correct sub-image coordinates and renders an image
        into self._cached_image.

        The parameter *data* is for subclasses that might not store an RGB(A)
        image as the value, but need to compute one to display (colormaps, etc.).
        
        The parameter *mapper* is also for subclasses that might not store an
        RGB(A) image as their value, and gives an opportunity to produce the
        values only for the visible region, rather than for the whole plot,
        at the expense of more frequent computation.
        """

        if data is None:
            data = self.value.data

        (lpt, upt) = self.index.get_bounds()
        ll_x, ll_y = self.map_screen([lpt])[0]
        ur_x, ur_y = self.map_screen([upt])[0]
        if "right" in self.origin:
            ll_x, ur_x = ur_x, ll_x
        if "top" in self.origin:
            ll_y, ur_y = ur_y, ll_y
        virtual_width = ur_x - ll_x
        virtual_height = ur_y - ll_y

        args = self.position \
             + self.bounds \
             + [ll_x, ll_y, virtual_width, virtual_height]
        img_pixels, gc_rect = self._calc_zoom_coords(*args)

        # Grab the appropriate sub-image, if necessary
        if img_pixels is not None:
            i1, j1, i2, j2 = img_pixels
            if "top" in self.origin:
                y_length = self.value.get_array_bounds()[1][1]
                j1 = y_length - j1
                j2 = y_length - j2
                # swap so that j1 < j2
                j1, j2 = j2, j1
            if "right" in self.origin:
                x_length = self.value.get_array_bounds()[0][1]
                i1 = x_length - i1
                i2 = x_length - i2
                # swap so that i1 < i2
                i1, i2 = i2, i1

            # Since data is row-major, j1 and j2 go first
            data = data[j1:j2, i1:i2]
        
        if mapper is not None:
            data = mapper(data)

        # Furthermore, the data presented to the GraphicsContextArray needs to
        # be contiguous.  If it is not, we need to make a copy.
        if not data.flags['C_CONTIGUOUS']:
            data = data.copy()

        if data.shape[2] == 3:
            kiva_depth = "rgb24"
        elif data.shape[2] == 4:
            kiva_depth = "rgba32"
        else:
            raise RuntimeError, "Unknown colormap depth value: %i" \
                                % data.value_depth


        self._cached_image = GraphicsContextArray(data, pix_format=kiva_depth)
        if gc_rect is not None:
            self._cached_dest_rect = gc_rect
        else:
            self._cached_dest_rect = (ll_x, ll_y, virtual_width, virtual_height)
        self._image_cache_valid = True

    def _calc_zoom_coords(self, px, py, plot_width, plot_height,
                                ix, iy, image_width, image_height):
        """ Calculates the coordinates of a zoomed sub-image.

        Because of floating point limitations, it is not advisable to request a
        extreme level of zoom, e.g., idx or idy > 10^10.

        Parameters
        ----------
        px : number
            X-coordinate of plot pixel bounds
        py : number
            Y-coordinate of plot pixel bounds
        plot_width : number
            Width of plot pixel bounds
        plot_height : number
            Height of plot pixel bounds
        ix : number
            X-coordinate of image pixel bounds
        iy : number
            Y-coordinate of image pixel bounds
        image_width : number
            Width of image pixel bounds
        image_height : number
            Height of image pixel bounds

        Returns
        -------
        ((i1, j1, i2, j2), (x, y, dx, dy))
            Lower left and upper right indices of the sub-image to be extracted,
            and graphics context origin and extents to draw the sub-image into.
        (None, None)
            No image extraction is necessary.
        """
        if (image_width < 1.5*plot_width) and (image_height < 1.5*plot_height):
            return (None, None)

        if 0 in (plot_width, plot_height, image_width, image_height):
            return (None, None)

        # We figure out the subimage coordinates using a two-step process:
        # 1. convert the plot boundaries from screen space into pixel offsets
        #    in the virtual image
        # 2. convert the coordinates in the virtual image into indices
        #    into the image data array
        # 3. from the data array indices, compute the screen coordinates of
        #    the corners of the data array sub-indices
        # in all the cases below, x1,y1 refers to the lower-left corner, and
        # x2,y2 refers to the upper-right corner.

        # 1. screen space -> pixel offsets
        if self.orientation == "h":
            x1 = px - ix
            x2 = (px + plot_width) - ix
            y1 = py - iy
            y2 = (py + plot_height) - iy
        else:
            x1 = px - ix
            x2 = (px + plot_height) - ix
            y1 = py - iy
            y2 = (py + plot_width) - iy


        # 2. pixel offsets -> data array indices
        # X and Y are transposed because for image plot data
        pixel_bounds = self.value.get_array_bounds()
        xpixels = pixel_bounds[0][1] - pixel_bounds[0][0]
        ypixels = pixel_bounds[1][1] - pixel_bounds[1][0]
        i1 = max(floor(float(x1) / image_width * xpixels), 0)
        i2 = min(ceil(float(x2) / image_width * xpixels), xpixels)
        j1 = max(floor(float(y1) / image_height * ypixels), 0)
        j2 = min(ceil(float(y2) / image_height * ypixels), ypixels)

        # 3. array indices -> new screen space coordinates
        x1 = float(i1)/xpixels * image_width + ix
        x2 = float(i2)/xpixels * image_width + ix
        y1 = float(j1)/ypixels * image_height + iy
        y2 = float(j2)/ypixels * image_height + iy

        # Handle really, really, subpixel cases
        subimage_index = [i1, j1, i2, j2]
        subimage_coords = [x1, y1, x2-x1, y2-y1]
        plot_dimensions = (px, py, plot_width, plot_height)
        xparams = (0, 2)
        yparams = (1, 3)
        for pos_index, size_index in (xparams, yparams):
            if subimage_index[pos_index] == subimage_index[pos_index+2]-1:
                # xcoords lie inside the same pixel, so set the subimage
                # coords to be the width of the image
                subimage_coords[pos_index] = plot_dimensions[pos_index]
                subimage_coords[size_index] = plot_dimensions[size_index]
            elif subimage_index[pos_index] == subimage_index[pos_index+2]-2:
                # coords span across a pixel boundary.  Find the scaling
                # factor of the virtual (and potentially large) subimage
                # size to the image size, and scale it down.  We can do
                # this without distortion b/c we are straddling only one
                # pixel boundary.
                #
                # If we scale down the extent to twice the screen size, we can
                # be sure that no matter what the offset, we will cover the
                # entire screen, since we are only straddling one pixel boundary.
                # The formula for calculating the new origin can be worked out
                # on paper.
                extent = subimage_coords[size_index]
                pixel_extent = extent/2   # we are indexed into two pixels
                origin = subimage_coords[pos_index]
                scale = float(2 * plot_dimensions[size_index] / extent)
                subimage_coords[size_index] *= scale
                subimage_coords[pos_index] = origin + (1-scale)*pixel_extent

        subimage_index = map(int, subimage_index)

        return [subimage_index, subimage_coords]


    #------------------------------------------------------------------------
    # Event handlers
    #------------------------------------------------------------------------

    def _index_data_changed_fired(self):
        self._image_cache_valid = False
        self.request_redraw()

    def _index_mapper_changed_fired(self):
        self._image_cache_valid = False
        self.request_redraw()

    def _value_data_changed_fired(self):
        self._image_cache_valid = False
        self.request_redraw()
        

########NEW FILE########
__FILENAME__ = jitterplot

from __future__ import with_statement

from itertools import izip
from math import sqrt
import numpy as np

from enable.api import black_color_trait, MarkerTrait
from traits.api import (Any, Bool, Callable, Enum, Float,
        Instance, Int, Property, Str, Trait, on_trait_change)

from abstract_plot_renderer import AbstractPlotRenderer
from abstract_mapper import AbstractMapper
from array_data_source import ArrayDataSource
from base import reverse_map_1d
from scatterplot import render_markers


class JitterPlot(AbstractPlotRenderer):
    """A renderer for a jitter plot, a 1D plot with some width in the
    dimension perpendicular to the primary axis.  Useful for understanding
    dense collections of points.
    """

    # The data source of values
    index = Instance(ArrayDataSource)

    # The single mapper that this plot uses
    mapper = Instance(AbstractMapper)

    # Just an alias for "mapper"
    index_mapper = Property(lambda obj,attr: getattr(obj, "mapper"),
                            lambda obj,attr,val: setattr(obj, "mapper", val))

    x_mapper = Property()
    y_mapper = Property()

    orientation = Enum("h", "v")

    # The size, in pixels, of the area over which to spread the data points
    # along the dimension orthogonal to the index direction.
    jitter_width = Int(50)

    # How the plot should center itself along the orthogonal dimension if the
    # component's width is greater than the jitter_width
    #align = Enum("center", "left", "right", "top", "bottom")

    # The type of marker to use.  This is a mapped trait using strings as the
    # keys.
    marker = MarkerTrait

    # The pixel size of the marker, not including the thickness of the outline.
    marker_size = Float(4.0)

    # The CompiledPath to use if **marker** is set to "custom". This attribute
    # must be a compiled path for the Kiva context onto which this plot will
    # be rendered.  Usually, importing kiva.GraphicsContext will do
    # the right thing.
    custom_symbol = Any

    # The function which actually renders the markers
    render_markers_func = Callable(render_markers)

    # The thickness, in pixels, of the outline to draw around the marker.  If
    # this is 0, no outline is drawn.
    line_width = Float(1.0)

    # The fill color of the marker.
    color = black_color_trait

    # The color of the outline to draw around the marker.
    outline_color = black_color_trait

    #------------------------------------------------------------------------
    # Built-in selection handling
    #------------------------------------------------------------------------

    # The name of the metadata attribute to look for on the datasource for
    # determine which points are selected and which are not.  The metadata
    # value returned should be a *list* of numpy arrays suitable for masking
    # the values returned by index.get_data().
    selection_metadata_name = Str("selections")

    # The color to use to render selected points
    selected_color = black_color_trait

    # Alpha value to apply to points that are not in the set of "selected"
    # points
    unselected_alpha = Float(0.3)
    unselected_line_width = Float(0.0)

    #------------------------------------------------------------------------
    # Private traits
    #------------------------------------------------------------------------

    _cache_valid = Bool(False)

    _cached_data_pts = Any()
    _cached_data_pts_sorted = Any()
    _cached_data_argsort = Any()

    _screen_cache_valid = Bool(False)
    _cached_screen_pts = Any()
    _cached_screen_map = Any()  # dict mapping index to value points

    # The random number seed used to generate the jitter.  We store this
    # so that the jittering is stable as the data is replotted.
    _jitter_seed = Trait(None, None, Int)

    #------------------------------------------------------------------------
    # Component/AbstractPlotRenderer interface
    #------------------------------------------------------------------------

    def map_screen(self, data_array):
        """ Maps an array of data points into screen space and returns it as
        an array.  Although the orthogonal (non-scaled) axis does not have
        a mapper, this method returns the scattered values in that dimension.

        Implements the AbstractPlotRenderer interface.
        """
        if len(data_array) == 0:
            return np.zeros(0)

        if self._screen_cache_valid:
            sm = self._cached_screen_map
            new_x = [x for x in data_array if x not in sm]
            if new_x:
                new_y = self._make_jitter_vals(len(new_x))
                sm.update(dict((new_x[i], new_y[i]) for i in range(len(new_x))))
            xs = self.mapper.map_screen(data_array)
            ys = [sm[x] for x in xs]

        else:
            if self._jitter_seed is None:
                self._set_seed(data_array)
            xs = self.mapper.map_screen(data_array)
            ys = self._make_jitter_vals(len(data_array))

        if self.orientation == "h":
            return np.vstack((xs, ys)).T
        else:
            return np.vstack((ys, xs)).T

    def _make_jitter_vals(self, numpts):
        vals = np.random.uniform(0, self.jitter_width, numpts)
        if self.orientation == "h":
            ymin = self.y
            height = self.height
            vals += ymin + height/2 - self.jitter_width/2
        else:
            xmin = self.x
            width = self.width
            vals += xmin + width/2 - self.jitter_width/2
        return vals

    def map_data(self, screen_pt):
        """ Maps a screen space point into the index space of the plot.
        """
        x, y = screen_pt
        if self.orientation == "v":
            x, y = y, x
        return self.mapper.map_data(x)

    def map_index(self, screen_pt, threshold=2.0, outside_returns_none=True, \
                  index_only = True):
        """ Maps a screen space point to an index into the plot's index array(s).
        """
        screen_points = self._cached_screen_pts

        if len(screen_points) == 0:
            return None

        data_pt = self.map_data(screen_pt)
        if ((data_pt < self.mapper.range.low) or \
            (data_pt > self.mapper.range.high)) and outside_returns_none:
            return None

        if self._cached_data_pts_sorted is None:
            self._cached_data_argsort = np.argsort(self._cached_data_pts)
            self._cached_data_pts_sorted = self._cached_data_pts[self._cached_data_argsort]

        data = self._cached_data_pts_sorted
        try:
            ndx = reverse_map_1d(data, data_pt, "ascending")
        except IndexError, e:
            if outside_returns_none:
                return None
            else:
                if data_pt < data[0]:
                    return 0
                else:
                    return len(data) - 1

        orig_ndx = self._cached_data_argsort[ndx]

        if threshold == 0.0:
            return orig_ndx

        sx, sy = screen_points[orig_ndx]
        if sqrt((screen_pt[0] - sx)**2 + (screen_pt[1] - sy)**2) <= threshold:
            return orig_ndx
        else:
            return None


    def _draw_plot(self, gc, view_bounds=None, mode="normal"):
        pts = self.get_screen_points()
        self._render(gc, pts)


    #------------------------------------------------------------------------
    # Private methods
    #------------------------------------------------------------------------

    def get_screen_points(self):
        if not self._screen_cache_valid:
            self._gather_points()
            pts = self.map_screen(self._cached_data_pts)
            if self.orientation == "h":
                self._cached_screen_map = dict((x,y) for x,y in izip(pts[:,0], pts[:,1]))
            else:
                self._cached_screen_map = dict((y,x) for x,y in izip(pts[:,0], pts[:,1]))
            self._cached_screen_pts = pts
            self._screen_cache_valid = True
            self._cached_data_pts_sorted = None
            self._cached_data_argsort = None
        return self._cached_screen_pts

    def _gather_points(self):
        if self._cache_valid:
            return

        if not self.index:
            return

        index, index_mask = self.index.get_data_mask()
        if len(index) == 0:
            self._cached_data_pts = []
            self._cache_valid = True
            return

        # For the jitter plot, we do not mask or compress the data in any
        # way, because if we do, we have no way of transforming from screen
        # points back into dataspace.  (Tools will be able to find an index
        # into the screen points array, but won't be able to go from that
        # back into the original data points array.)

        #index_range_mask = self.mapper.range.mask_data(index)
        #self._cached_data_pts = np.compress(index_mask & index_range_mask, index)
        self._cached_data_pts = index
        self._cache_valid = True
        self._cached_screen_pts = None
        self._screen_cache_valid = False

    def _render(self, gc, pts):
        with gc:
            gc.clip_to_rect(self.x, self.y, self.width, self.height)
            if not self.index:
                return
            name = self.selection_metadata_name
            md = self.index.metadata
            if name in md and md[name] is not None and len(md[name]) > 0:
                # FIXME: when will we ever encounter multiple masks in the list?
                sel_mask = md[name][0]
                sel_pts = np.compress(sel_mask, pts, axis=0)
                unsel_pts = np.compress(~sel_mask, pts, axis=0)
                color = list(self.color_)
                color[3] *= self.unselected_alpha
                outline_color = list(self.outline_color_)
                outline_color[3] *= self.unselected_alpha
                if unsel_pts.size > 0:
                    self.render_markers_func(gc, unsel_pts, self.marker, self.marker_size,
                            tuple(color), self.unselected_line_width, tuple(outline_color),
                            self.custom_symbol)
                if sel_pts.size > 0:
                    self.render_markers_func(gc, sel_pts, self.marker, self.marker_size,
                            self.selected_color_, self.line_width, self.outline_color_,
                            self.custom_symbol)
            else:
                self.render_markers_func(gc, pts, self.marker, self.marker_size,
                        self.color_, self.line_width, self.outline_color_,
                        self.custom_symbol)

    def _set_seed(self, data_array):
        """ Sets the internal random seed based on some input data """
        if isinstance(data_array, np.ndarray):
            seed = np.random.seed(data_array.size)
        else:
            seed = np.random.seed(map(int, data_array[:100]))

        self._jitter_seed = seed

    @on_trait_change("index.data_changed")
    def _invalidate(self):
        self._cache_valid = False
        self._screen_cache_valid = False

    @on_trait_change("mapper.updated")
    def _invalidate_screen(self):
        self._screen_cache_valid = False

    #------------------------------------------------------------------------
    # Event handlers
    #------------------------------------------------------------------------

    def _get_x_mapper(self):
        if self.orientation == "h":
            return self.mapper
        else:
            return None

    def _set_x_mapper(self, val):
        if self.orientation == "h":
            self.mapper = val
        else:
            raise ValueError("x_mapper is not defined for a vertical jitter plot")

    def _get_y_mapper(self):
        if self.orientation == "v":
            return self.mapper
        else:
            return None

    def _set_y_mapper(self, val):
        if self.orientation == "v":
            self.mapper = val
        else:
            raise ValueError("y_mapper is not defined for a horizontal jitter plot")

    def _update_mappers(self):
        mapper = self.mapper
        if mapper is None:
            return

        x = self.x
        x2 = self.x2
        y = self.y
        y2 = self.y2

        if "left" in self.origin and self.orientation == 'h':
            mapper.screen_bounds = (x, x2)
        elif "right" in self.origin and self.orientation == 'h':
            mapper.screen_bounds = (x2, x)
        elif "bottom" in self.origin  and self.orientation == 'v':
            mapper.screen_bounds = (y, y2)
        elif "top" in self.origin  and self.orientation == 'v':
            mapper.screen_bounds = (y2, y)

        self.invalidate_draw()
        self._cache_valid = False
        self._screen_cache_valid = False

    def _bounds_changed(self, old, new):
        super(JitterPlot, self)._bounds_changed(old, new)
        self._update_mappers()

    def _bounds_items_changed(self, event):
        super(JitterPlot, self)._bounds_items_changed(event)
        self._update_mappers()

    def _orientation_changed(self):
        self._update_mappers()


########NEW FILE########
__FILENAME__ = label
""" Defines the Label class.
"""

from __future__ import with_statement

# Major library imports
from math import cos, sin, pi
from numpy import array, dot

# Enthought library imports
from enable.api import black_color_trait, transparent_color_trait
from kiva.constants import FILL
from kiva.trait_defs.kiva_font_trait import KivaFont
from traits.api import (Any, Bool, Float, HasTraits, Int, List, Str,
                        on_trait_change)


class Label(HasTraits):
    """ A label used by overlays.

    Label is not a Component; it's just an object encapsulating text settings
    and appearance attributes.  It can be used by components that need text
    labels to store state, perform layout, and render the text.
    """

    # The anchor point is the position on the label that is placed at the
    # label's position.  The label is also rotated relative to this point.
    # "Left" refers to the left edge of the text's bounding box (including
    # margin), while "center" refers to the horizontal and vertical center
    # of the bounding box.
    # TODO: Implement this and test thoroughly
    #anchor = Enum("left", "right", "top", "bottom", "center",
    #              "top left", "top right", "bottom left", "bottom right")

    # The label text.  Carriage returns (\n) are always connverted into
    # line breaks.
    text = Str

    # The angle of rotation of the label.
    rotate_angle = Float(0)

    # The color of the label text.
    color = black_color_trait

    # The background color of the label.
    bgcolor = transparent_color_trait

    # The width of the label border. If it is 0, then it is not shown.
    border_width = Int(0)

    # The color of the border.
    border_color = black_color_trait

    # Whether or not the border is visible
    border_visible = Bool(True)

    # The font of the label text.
    font = KivaFont("modern 10")

    # Number of pixels of margin around the label, for both X and Y dimensions.
    margin = Int(2)

    # Number of pixels of spacing between lines of text.
    line_spacing = Int(5)

    # Number of pixels to limit the width of the label to. Lines which are
    # too long will be broken to fit on word boundaries. Line width is
    # calculated without considering the value of `margin`.
    # A `max_width` of 0.0 means that lines will not be broken.
    max_width = Float(0.0)

    #------------------------------------------------------------------------
    # Private traits
    #------------------------------------------------------------------------

    _bounding_box = List()
    _position_cache_valid = Bool(False)
    _text_needs_fitting = Bool(False)
    _line_xpos = Any()
    _line_ypos = Any()
    _rot_matrix = Any()

    def __init__(self, **traits):
        super(Label, self).__init__(**traits)
        self._bounding_box = [0, 0]
        return

    def get_width_height(self, gc):
        """ Returns the width and height of the label, in the rotated frame of
        reference.
        """
        self._fit_text_to_max_width(gc)
        self._calc_line_positions(gc)
        width, height = self._bounding_box
        return width, height

    def get_bounding_box(self, gc):
        """ Returns a rectangular bounding box for the Label as (width,height).
        """
        width, height = self.get_width_height(gc)
        if self.rotate_angle in (90.0, 270.0):
            return (height, width)
        elif self.rotate_angle in (0.0, 180.0):
            return (width, height)
        else:
            angle = self.rotate_angle
            return (abs(width*cos(angle))+abs(height*sin(angle)),
                    abs(height*sin(angle))+abs(width*cos(angle)))

    def get_bounding_poly(self, gc):
        """ Returns a list [(x0,y0), (x1,y1),...] of tuples representing a
        polygon that bounds the label.
        """
        width, height = self.get_width_height(gc)
        offset = array(self.get_bounding_box(gc))/2.
        # unrotated points relative to centre
        base_points = [
            array([[-width/2.], [-height/2.]]),
            array([[-width/2.], [height/2.]]),
            array([[width/2.], [height/2.]]),
            array([[width/2.], [-height/2.]]),
            array([[-width/2.], [-height/2.]]),
        ]
        # rotate about centre, and offset to bounding box coords
        points = [dot(self.get_rotation_matrix(), point).transpose()[0]+offset
                  for point in base_points]
        return points

    def get_rotation_matrix(self):
        return array([[cos(self.rotate_angle), -sin(self.rotate_angle)],
                     [sin(self.rotate_angle), cos(self.rotate_angle)]])

    def draw(self, gc):
        """ Draws the label.

        This method assumes the graphics context has been translated to the
        correct position such that the origin is at the lower left-hand corner
        of this text label's box.
        """
        # Make sure `max_width` is respected
        self._fit_text_to_max_width(gc)

        # For this version we're not supporting rotated text.
        self._calc_line_positions(gc)

        with gc:
            bb_width, bb_height = self.get_bounding_box(gc)

            # Rotate label about center of bounding box
            width, height = self._bounding_box
            gc.translate_ctm(bb_width/2.0, bb_height/2.0)
            gc.rotate_ctm(pi/180.0*self.rotate_angle)
            gc.translate_ctm(-width/2.0, -height/2.0)

            # Draw border and fill background
            if self.bgcolor != "transparent":
                gc.set_fill_color(self.bgcolor_)
                gc.draw_rect((0, 0, width, height), FILL)
            if self.border_visible and self.border_width > 0:
                gc.set_stroke_color(self.border_color_)
                gc.set_line_width(self.border_width)
                border_offset = (self.border_width-1)/2.0
                gc.rect(border_offset, border_offset,
                        width-2*border_offset, height-2*border_offset)
                gc.stroke_path()

            gc.set_fill_color(self.color_)
            gc.set_stroke_color(self.color_)
            gc.set_font(self.font)
            if self.font.size <= 8.0:
                gc.set_antialias(0)
            else:
                gc.set_antialias(1)

            lines = self.text.split("\n")
            if self.border_visible:
                gc.translate_ctm(self.border_width, self.border_width)
            width, height = self.get_width_height(gc)

            for i, line in enumerate(lines):
                if line == "":
                    continue
                x_offset = round(self._line_xpos[i])
                y_offset = round(self._line_ypos[i])
                gc.set_text_position(x_offset, y_offset)
                gc.show_text(line)

    #------------------------------------------------------------------------
    # Trait handlers
    #------------------------------------------------------------------------

    def _text_changed(self):
        self._text_needs_fitting = (self.max_width > 0.0)

    @on_trait_change("font,margin,text,rotate_angle")
    def _invalidate_position_cache(self):
        self._position_cache_valid = False

    #------------------------------------------------------------------------
    # Private methods
    #------------------------------------------------------------------------

    def _fit_text_to_max_width(self, gc):
        """ Break the text into lines whose width is no greater than
        `max_width`.
        """
        if self._text_needs_fitting:
            lines = []

            with gc:
                gc.set_font(self.font)
                for line in self.text.split('\n'):
                    if line == "":
                        lines.append(line)
                        continue

                    width = gc.get_full_text_extent(line)[0]
                    if width > self.max_width:
                        line_words = []
                        for word in line.split():
                            line_words.append(word)
                            test_line = ' '.join(line_words)
                            width = gc.get_full_text_extent(test_line)[0]
                            if width > self.max_width:
                                if len(line_words) > 1:
                                    lines.append(' '.join(line_words[:-1]))
                                    line_words = [word]
                                else:
                                    lines.append(word)
                                    line_words = []
                        if len(line_words) > 0:
                            lines.append(' '.join(line_words))
                    else:
                        lines.append(line)
            self.trait_setq(text='\n'.join(lines))
            self._text_needs_fitting = False

    def _calc_line_positions(self, gc):
        if not self._position_cache_valid:
            with gc:
                gc.set_font(self.font)
                # The bottommost line starts at postion (0, 0).
                x_pos = []
                y_pos = []
                self._bounding_box = [0, 0]
                margin = self.margin
                prev_y_pos = margin
                prev_y_height = -self.line_spacing
                max_width = 0
                for line in self.text.split("\n")[::-1]:
                    if line != "":
                        (width, height, descent, leading) = \
                            gc.get_full_text_extent(line)
                        ascent = height - abs(descent)
                        if width > max_width:
                            max_width = width
                        new_y_pos = prev_y_pos + prev_y_height \
                            + self.line_spacing
                    else:
                        # For blank lines, we use the height of the previous
                        # line, if there is one.  The width is 0.
                        leading = 0
                        if prev_y_height != -self.line_spacing:
                            new_y_pos = prev_y_pos + prev_y_height \
                                + self.line_spacing
                            ascent = prev_y_height
                        else:
                            new_y_pos = prev_y_pos
                            ascent = 0
                    x_pos.append(-leading + margin)
                    y_pos.append(new_y_pos)
                    prev_y_pos = new_y_pos
                    prev_y_height = ascent

            self._line_xpos = x_pos[::-1]
            self._line_ypos = y_pos[::-1]
            border_width = self.border_width if self.border_visible else 0
            self._bounding_box[0] = max_width + 2*margin + 2*border_width
            self._bounding_box[1] = prev_y_pos + prev_y_height + margin \
                + 2*border_width
            self._position_cache_valid = True
        return

########NEW FILE########
__FILENAME__ = label_axis
""" Defines the LabelAxis class.
"""
# Major library imports
from traceback import print_exc
from numpy import array, float64, inf, searchsorted, take, unique

# Enthought library imports
from traits.api import Any, Str, List, Float

# Local, relative imports
from axis import PlotAxis
from label import Label


class LabelAxis(PlotAxis):
    """ An axis whose ticks are labeled with text instead of numbers.
    """

    # List of labels to use on tick marks.
    labels = List(Str)

    # The angle of rotation of the label. Only multiples of 90 are supported.
    label_rotation = Float(0)

    # List of indices of ticks
    positions = Any  # List(Float), Array

    def _compute_tick_positions(self, gc, component=None):
        """ Calculates the positions for the tick marks.

        Overrides PlotAxis.
        """
        if (self.mapper is None):
            self._reset_cache()
            self._cache_valid = True
            return

        datalow = self.mapper.range.low
        datahigh = self.mapper.range.high
        screenhigh = self.mapper.high_pos
        screenlow = self.mapper.low_pos

        if (datalow == datahigh) or (screenlow == screenhigh) or \
           (datalow in [inf, -inf]) or (datahigh in [inf, -inf]):
            self._reset_cache()
            self._cache_valid = True
            return

        if not self.tick_generator:
            return

        # Get a set of ticks from the tick generator.
        tick_list = array(self.tick_generator.get_ticks(datalow, datahigh,
                                                        datalow, datahigh,
                                                        self.tick_interval), float64)

        # Find all the positions in the current range.
        pos_index = []
        pos = []
        pos_min = None
        pos_max = None
        for i, position in enumerate(self.positions):
            if datalow <= position <= datahigh:
                pos_max = max(position, pos_max) if pos_max is not None else position
                pos_min = min(position, pos_min) if pos_min is not None else position
                pos_index.append(i)
                pos.append(position)
        if len(pos_index) == 0:
            # No positions currently visible.
            self._tick_positions = []
            self._tick_label_positions = []
            self._tick_label_list = []
            return

        # Use the ticks generated by the tick generator as a guide for selecting
        # the positions to be displayed.
        tick_indices = unique(searchsorted(pos, tick_list))
        tick_indices = tick_indices[tick_indices < len(pos)]
        tick_positions =  take(pos, tick_indices)
        self._tick_label_list = take(self.labels, take(pos_index, tick_indices))

        if datalow > datahigh:
            raise RuntimeError, "DataRange low is greater than high; unable to compute axis ticks."

        mapped_label_positions = [((self.mapper.map_screen(pos)-screenlow) / \
                                    (screenhigh-screenlow)) for pos in tick_positions]
        self._tick_positions = [self._axis_vector*tickpos + self._origin_point \
                                 for tickpos in mapped_label_positions]
        self._tick_label_positions = self._tick_positions
        return


    def _compute_labels(self, gc):
        """Generates the labels for tick marks.

        Overrides PlotAxis.
        """
        try:
            self.ticklabel_cache = []
            for text in self._tick_label_list:
                ticklabel = Label(text=text, font=self.tick_label_font,
                                  color=self.tick_label_color,
                                  rotate_angle=self.label_rotation)
                self.ticklabel_cache.append(ticklabel)

            self._tick_label_bounding_boxes = [array(ticklabel.get_bounding_box(gc), float64) for ticklabel in self.ticklabel_cache]
        except:
            print_exc()
        return


########NEW FILE########
__FILENAME__ = lasso_overlay
""" Defines the LassoOverlay class.
"""

from __future__ import with_statement

from numpy import concatenate, newaxis

# Enthought library imports
from enable.api import ColorTrait, LineStyle
from traits.api import Float, Instance, Bool

# Local imports
from abstract_overlay import AbstractOverlay

class LassoOverlay(AbstractOverlay):
    """ Draws a lasso selection region on top of a plot.

    LassoOverlay gets its data from a LassoSelection.
    """

    # The LassoSelection that provides the data for this overlay.
    lasso_selection = Instance('chaco.tools.lasso_selection.LassoSelection')
    # The fill color for the selection region.
    selection_fill_color = ColorTrait('lightskyblue')
    # The border color for the selection region.
    selection_border_color = ColorTrait('dodgerblue')
    # The transparency level for the selection fill color.
    selection_alpha = Float(0.8)
    # The width of the selection border.
    selection_border_width = Float(2.0)
    # The line style of the selection border.
    selection_border_dash = LineStyle

    # The background color (overrides AbstractOverlay).
    bgcolor = 'clear'

    # Whether to draw the lasso
    # depends on the state of the lasso tool
    _draw_selection = Bool(False)

    def overlay(self, other_component, gc, view_bounds=None, mode="normal"):
        """ Draws this component overlaid on another component.

        Implements AbstractOverlay.
        """
        if not self._draw_selection:
            return
        with gc:
            c = other_component
            gc.clip_to_rect(c.x, c.y, c.width, c.height)
            self._draw_component(gc, view_bounds, mode)
        return

    def _updated_changed_for_lasso_selection(self):
        self.component.invalidate_draw()
        self.component.request_redraw()

    def _event_state_fired_for_lasso_selection(self, val):
        self._draw_selection = val == 'selecting'
        self.component.invalidate_draw()
        self.component.request_redraw()

    def _draw_component(self, gc, view_bounds=None, mode='normal'):
        """ Draws the component.

        This method is preserved for backwards compatibility with _old_draw().
        Overrides PlotComponent.
        """
        with gc:
            # We may need to make map_screen more flexible in the number of dimensions
            # it accepts for ths to work well.
            for selection in self.lasso_selection.disjoint_selections:
                points = self.component.map_screen(selection)
                if len(points) == 0:
                    return
                points = concatenate((points, points[0, newaxis]), axis=0)
                gc.set_line_width(self.selection_border_width)
                gc.set_line_dash(self.selection_border_dash_)
                gc.set_fill_color(self.selection_fill_color_)
                gc.set_stroke_color(self.selection_border_color_)
                gc.set_alpha(self.selection_alpha)
                gc.lines(points)
                gc.draw_path()

########NEW FILE########
__FILENAME__ = api
from status_layer import StatusLayer, ErrorLayer, WarningLayer

########NEW FILE########
__FILENAME__ = status_layer

from __future__ import with_statement

import os.path
import xml.etree.cElementTree as etree

from chaco.api import AbstractOverlay
from pyface.timer.timer import Timer
from traits.api import Instance, Str, Enum, Float, Int
from enable.savage.svg.document import SVGDocument
from enable.savage.svg.backends.kiva.renderer import Renderer as KivaRenderer

class StatusLayer(AbstractOverlay):

    filename = Str()
    document = Instance(SVGDocument)

    # Default size attributes if the svg does not specify them
    doc_width = 48.0
    doc_height = 48.0

    # The type determines if the layer is displayed as part of the component's
    # overlay or underlays
    type = Enum('overlay', 'underlay')

    # The position of the legend with respect to its overlaid component.
    #
    # * c  = Center
    # * ur = Upper Right
    # * ul = Upper Left
    # * ll = Lower Left
    # * lr = Lower Right
    align = Enum("c", "ur", "ul", "ll", "lr")

    # How big should the graphic be in comparison to the rest of the plot
    # area
    scale_factor = Float(0.5)

    # Initial transparency
    alpha = Float(1.0)

    # The minimum time it takes for the the layer to fade out, in
    # milliseconds. Actual time may be longer, depending on the pyface toolkit
    fade_out_time = Float(50)

    # The number of steps to take to fade from the initial transparency to
    # invisible
    fade_out_steps = Int(10)

    def __init__(self, component, *args, **kw):
        super(StatusLayer, self).__init__(component, *args, **kw)

        if self.document is None:
            if self.filename == '':
                self.filename = os.path.join(os.path.dirname(__file__), 'data',
                                            'Dialog-error.svg')
            tree = etree.parse(self.filename)
            root = tree.getroot()
            self.document = SVGDocument(root, renderer=KivaRenderer)

        if hasattr(self.document, 'getSize'):
            self.doc_width = self.document.getSize()[0]
            self.doc_height = self.document.getSize()[1]


    def overlay(self, other_component, gc, view_bounds=None, mode="normal"):
        """ Draws this component overlaid on another component.

        Implements AbstractOverlay.
        """
        with gc:
            gc.set_alpha(self.alpha)

            plot_width = self.component.width
            plot_height = self.component.height

            origin_x = self.component.padding_left
            origin_y = self.component.padding_top

            # zoom percentage, use the scale_factor as a % of the plot size.
            # base the size on the smaller aspect - if the plot is tall and narrow
            # the overlay should be 50% of the width, if the plot is short and wide
            # the overlay should be 50% of the height.
            if gc.height() < gc.width():
                scale = (plot_height/self.doc_height)*self.scale_factor
            else:
                scale = (plot_width/self.doc_width)*self.scale_factor

            scale_width = scale*self.doc_width
            scale_height = scale*self.doc_height

            # Set up the transforms to align the graphic to the desired position
            if self.align == 'ur':
                gc.translate_ctm(origin_x + (plot_width-scale_width),
                                origin_y + plot_height)
            elif self.align == 'lr':
                gc.translate_ctm(origin_x + (plot_width-scale_width),
                                origin_y + scale_height)
            elif self.align == 'ul':
                gc.translate_ctm(origin_x,
                                origin_y + plot_height)
            elif self.align == 'll':
                gc.translate_ctm(origin_x,
                                origin_y + scale_height)
            else:
                gc.translate_ctm(origin_x + (plot_width-scale_width)/2,
                                 origin_y + (plot_height+scale_height)/2)


            # SVG origin is the upper right with y positive down, so
            # we need to flip everything
            gc.scale_ctm(scale, -scale)

            self.document.render(gc)

            self._draw_component(gc, view_bounds, mode)

        return

    def fade_out(self):
        interval = self.fade_out_time/self.fade_out_steps
        self.timer = Timer(interval, self._fade_out_step)

    def _fade_out_step(self):
        """ Fades out the overlay over a half second. then removes it from
            the other_component's overlays
        """
        if self.alpha <= 0:
            if self.type == 'overlay':
                self.component.overlays.remove(self)
            else:
                self.component.underlays.remove(self)
            self.alpha = 1.0
            raise StopIteration
        else:
            self.alpha -= 0.1
            self.component.request_redraw()

class ErrorLayer(StatusLayer):
    filename = os.path.join(os.path.dirname(__file__), 'data',
                                            'Dialog-error.svg')

class WarningLayer(StatusLayer):
    filename = os.path.join(os.path.dirname(__file__), 'data',
                                            'Dialog-warning.svg')

########NEW FILE########
__FILENAME__ = svg_range_selection_overlay

from __future__ import with_statement

import os
import numpy

from chaco.api import GridMapper
from traits.api import Property, Enum, Str, cached_property

from status_layer import StatusLayer

class SvgRangeSelectionOverlay(StatusLayer):
    """ This is a primitive range selection overlay which uses
        a SVG to define the overlay.

        TODO: not inherit from StatusLayer, this was a convenience for a
            quick prototype

        TODO: use 2 svgs, one which defines the border and does not scale, and
            the other which defines the fill.
    """



    filename = os.path.join(os.path.dirname(__file__), 'data',
                                            'range_selection.svg')

    alpha = 0.5

    # The axis to which this tool is perpendicular.
    axis = Enum("index", "value")

    axis_index = Property(depends_on='axis')

    # Mapping from screen space to data space. By default, it is just
    # self.component.
    plot = Property(depends_on='component')

    # The mapper (and associated range) that drive this RangeSelectionOverlay.
    # By default, this is the mapper on self.plot that corresponds to self.axis.
    mapper = Property(depends_on='plot')

    # The name of the metadata to look at for dataspace bounds. The metadata
    # can be either a tuple (dataspace_start, dataspace_end) in "selections" or
    # a boolean array mask of seleted dataspace points with any other name
    metadata_name = Str("selections")

    def overlay(self, component, gc, view_bounds=None, mode="normal"):
        """ Draws this component overlaid on another component.

        Overrides AbstractOverlay.
        """
        # Draw the selection
        coords = self._get_selection_screencoords()

        if len(coords) == 0:
            return

        with gc:
            gc.set_alpha(self.alpha)

            plot_width = self.component.width
            plot_height = self.component.height

            origin_x = self.component.padding_left
            origin_y = self.component.padding_top

            if self.axis == 'index':
                if isinstance(self.mapper, GridMapper):
                    scale_width = (coords[-1][0] - coords[0][0])/self.doc_width
                else:
                    scale_width = (coords[0][-1] - coords[0][0])/self.doc_width
                scale_height = float(plot_height)/self.doc_height
                gc.translate_ctm(coords[0][0], origin_y + plot_height)
            else:
                scale_height = (coords[0][-1] - coords[0][0])/self.doc_height
                scale_width = float(plot_width)/self.doc_width
                gc.translate_ctm(origin_x, coords[0][0])

            # SVG origin is the upper right with y positive down, so
            # we need to flip everything
            gc.scale_ctm(scale_width, -scale_height)

            self.document.render(gc)

            self._draw_component(gc, view_bounds, mode)

        return

    def _get_selection_screencoords(self):
        """ Returns a tuple of (x1, x2) screen space coordinates of the start
        and end selection points.

        If there is no current selection, then returns None.
        """
        ds = getattr(self.plot, self.axis)
        selection = ds.metadata[self.metadata_name]

        # "selections" metadata must be a tuple
        if self.metadata_name == "selections":
            if selection is not None and len(selection) == 2:
                return [self.mapper.map_screen(numpy.array(selection))]
            else:
                return []
        # All other metadata is interpreted as a mask on dataspace
        else:
            ar = numpy.arange(0,len(selection), 1)
            runs = arg_find_runs(ar[selection])
            coords = []
            for inds in runs:
                start = ds._data[ar[selection][inds[0]]]
                end = ds._data[ar[selection][inds[1]-1]]
                coords.append(self.map_screen(numpy.array((start, end))))
            return coords

    @cached_property
    def _get_plot(self):
        return self.component

    @cached_property
    def _get_axis_index(self):
        if self.axis == 'index':
            return 0
        else:
            return 1

    @cached_property
    def _get_mapper(self):
        # If the plot's mapper is a GridMapper, return either its
        # x mapper or y mapper

        mapper = getattr(self.plot, self.axis + "_mapper")

        if isinstance(mapper, GridMapper):
            if self.axis == 'index':
                return mapper._xmapper
            else:
                return mapper._ymapper
        else:
            return mapper

########NEW FILE########
__FILENAME__ = legend
""" Defines the Legend, AbstractCompositeIconRenderer, and
CompositeIconRenderer classes.
"""

from __future__ import with_statement

from numpy import array, zeros_like

from enable.api import black_color_trait, white_color_trait
from enable.font_metrics_provider import font_metrics_provider
from kiva.trait_defs.kiva_font_trait import KivaFont
from traits.api import Any, Dict, Enum, Bool, HasTraits, Int, \
                                 Instance, List, CList, Float, Str

# Local relative imports
from abstract_overlay import AbstractOverlay
from label import Label
from lineplot import LinePlot
from plot_component import PlotComponent
from scatterplot import ScatterPlot


class AbstractCompositeIconRenderer(HasTraits):
    """ Abstract class for an icon renderer.
    """
    def render_icon(self, plots, gc, x, y, width, height):
        """ Renders an icon representing the given list of plots onto the
        graphics context, using the given dimensions and at the specified
        position.
        """
        raise NotImplementedError


class CompositeIconRenderer(AbstractCompositeIconRenderer):
    """ Renderer for composite icons.
    """
    def render_icon(self, plots, *render_args):
        """ Renders an icon for a list of plots. """
        types = set(map(type, plots))
        if types == set([ScatterPlot]):
            self._render_scatterplots(plots, *render_args)
        elif types == set([LinePlot]):
            self._render_lineplots(plots, *render_args)
        elif types == set([ScatterPlot, LinePlot]):
            self._render_line_scatter(plots, *render_args)
        else:
            raise ValueError("Don't know how to render combination plot with " +\
                             "renderers " + str(types))
        return

    def _render_scatterplots(self, plots, gc, x, y, width, height):
        # Don't support this for now
        pass

    def _render_lineplots(self, plots, gc, x, y, width, height):
        # Assume they are all the same color/appearance and use the first one
        plots[0]._render_icon(gc, x, y, width, height)

    def _render_line_scatter(self, plots, gc, x, y, width, height):
        # Separate plots into line and scatter renderers; render one of each
        scatter = [p for p in plots if type(p) == ScatterPlot]
        line = [p for p in plots if type(p) == LinePlot]
        line[0]._render_icon(gc, x, y, width, height)
        scatter[0]._render_icon(gc, x, y, width, height)



class Legend(AbstractOverlay):
    """ A legend for a plot.
    """
    # The font to use for the legend text.
    font = KivaFont("modern 12")

    # The amount of space between the content of the legend and the border.
    border_padding = Int(10)

    # The border is visible (overrides Enable Component).
    border_visible = True

    # The color of the text labels
    color = black_color_trait

    # The background color of the legend (overrides AbstractOverlay).
    bgcolor = white_color_trait

    # The position of the legend with respect to its overlaid component.  (This
    # attribute applies only if the legend is used as an overlay.)
    #
    # * ur = Upper Right
    # * ul = Upper Left
    # * ll = Lower Left
    # * lr = Lower Right
    align = Enum("ur", "ul", "ll", "lr")

    # The amount of space between legend items.
    line_spacing = Int(3)

    # The size of the icon or marker area drawn next to the label.
    icon_bounds = List([24, 24])

    # Amount of spacing between each label and its icon.
    icon_spacing = Int(5)

    # Map of labels (strings) to plot instances or lists of plot instances.  The
    # Legend determines the appropriate rendering of each plot's marker/line.
    plots = Dict

    # The list of labels to show and the order to show them in.  If this
    # list is blank, then the keys of self.plots is used and displayed in
    # alphabetical order.  Otherwise, only the items in the **labels**
    # list are drawn in the legend.  Labels are ordered from top to bottom.
    labels = List

    # Whether or not to hide plots that are not visible.  (This is checked during
    # layout.)  This option *will* filter out the items in **labels** above, so
    # if you absolutely, positively want to set the items that will always
    # display in the legend, regardless of anything else, then you should turn
    # this option off.  Otherwise, it usually makes sense that a plot renderer
    # that is not visible will also not be in the legend.
    hide_invisible_plots = Bool(True)

    # If hide_invisible_plots is False, we can still choose to render the names
    # of invisible plots with an alpha.
    invisible_plot_alpha = Float(0.33)

    # The renderer that draws the icons for the legend.
    composite_icon_renderer = Instance(AbstractCompositeIconRenderer)

    # Action that the legend takes when it encounters a plot whose icon it
    # cannot render:
    #
    # * 'skip': skip it altogether and don't render its name
    # * 'blank': render the name but leave the icon blank (color=self.bgcolor)
    # * 'questionmark': render a "question mark" icon
    error_icon = Enum("skip", "blank", "questionmark")

    # Should the legend clip to the bounds it needs, or to its parent?
    clip_to_component = Bool(False)

    # The legend is not resizable (overrides PlotComponent).
    resizable = "hv"

    # An optional title string to show on the legend.
    title = Str('')

    # If True, title is at top, if False then at bottom.
    title_at_top = Bool(True)

    # The legend draws itself as in one pass when its parent is drawing
    # the **draw_layer** (overrides PlotComponent).
    unified_draw = True
    # The legend is drawn on the overlay layer of its parent (overrides
    # PlotComponent).
    draw_layer = "overlay"

    #------------------------------------------------------------------------
    # Private Traits
    #------------------------------------------------------------------------

    # A cached list of Label instances
    _cached_labels = List

    # A cached array of label sizes.
    _cached_label_sizes = Any

    # A cached list of label names.
    _cached_label_names = CList

    # A list of the visible plots.  Each plot corresponds to the label at
    # the same index in _cached_label_names.  This list does not necessarily
    # correspond to self.plots.value() because it is sorted according to
    # the plot name and it potentially excludes invisible plots.
    _cached_visible_plots = CList

    # A cached array of label positions relative to the legend's origin
    _cached_label_positions = Any

    def is_in(self, x, y):
        """ overloads from parent class because legend alignment
            and padding does not cooperatate with the basic implementation

            This may just be caused byt a questionable implementation of the
            legend tool, but it works by adjusting the padding. The Component
            class implementation of is_in uses the outer positions which
            includes the padding
        """
        in_x = (x >= self.x) and (x <= self.x + self.width)
        in_y = (y >= self.y) and (y <= self.y + self.height)

        return in_x and in_y



    def overlay(self, component, gc, view_bounds=None, mode="normal"):
        """ Draws this component overlaid on another component.

        Implements AbstractOverlay.
        """
        self.do_layout()
        valign, halign = self.align
        if valign == "u":
            y = component.y2 - self.outer_height
        else:
            y = component.y
        if halign == "r":
            x = component.x2 - self.outer_width
        else:
            x = component.x
        self.outer_position = [x, y]

        if self.clip_to_component:
            c = self.component
            with gc:
                gc.clip_to_rect(c.x, c.y, c.width, c.height)
                PlotComponent._draw(self, gc, view_bounds, mode)
        else:
            PlotComponent._draw(self, gc, view_bounds, mode)


        return

    # The following two methods implement the functionality of the Legend
    # to act as a first-class component instead of merely as an overlay.
    # The make the Legend use the normal PlotComponent render methods when
    # it does not have a .component attribute, so that it can have its own
    # overlays (e.g. a PlotLabel).
    #
    # The core legend rendering method is named _draw_as_overlay() so that
    # it can be called from _draw_plot() when the Legend is not an overlay,
    # and from _draw_overlay() when the Legend is an overlay.

    def _draw_plot(self, gc, view_bounds=None, mode="normal"):
        if self.component is None:
            self._draw_as_overlay(gc, view_bounds, mode)
        return

    def _draw_overlay(self, gc, view_bounds=None, mode="normal"):
        if self.component is not None:
            self._draw_as_overlay(gc, view_bounds, mode)
        else:
            PlotComponent._draw_overlay(self, gc, view_bounds, mode)
        return

    def _draw_as_overlay(self, gc, view_bounds=None, mode="normal"):
        """ Draws the overlay layer of a component.

        Overrides PlotComponent.
        """
        # Determine the position we are going to draw at from our alignment
        # corner and the corresponding outer_padding parameters.  (Position
        # refers to the lower-left corner of our border.)

        # First draw the border, if necesssary.  This sort of duplicates
        # the code in PlotComponent._draw_overlay, which is unfortunate;
        # on the other hand, overlays of overlays seem like a rather obscure
        # feature.

        with gc:
            gc.clip_to_rect(int(self.x), int(self.y),
                            int(self.width), int(self.height))
            edge_space = self.border_width + self.border_padding
            icon_width, icon_height = self.icon_bounds

            icon_x = self.x + edge_space
            text_x = icon_x + icon_width + self.icon_spacing
            y = self.y2 - edge_space

            if self._cached_label_positions is not None:
                if len(self._cached_label_positions) > 0:
                    self._cached_label_positions[:,0] = icon_x

            for i, label_name in enumerate(self._cached_label_names):
                # Compute the current label's position
                label_height = self._cached_label_sizes[i][1]
                y -= label_height
                self._cached_label_positions[i][1] = y

                # Try to render the icon
                icon_y = y + (label_height - icon_height) / 2
                #plots = self.plots[label_name]
                plots = self._cached_visible_plots[i]
                render_args = (gc, icon_x, icon_y, icon_width, icon_height)

                try:
                    if isinstance(plots, list) or isinstance(plots, tuple):
                        # TODO: How do we determine if a *group* of plots is
                        # visible or not?  For now, just look at the first one
                        # and assume that applies to all of them
                        if not plots[0].visible:
                            # TODO: the get_alpha() method isn't supported on the Mac kiva backend
                            #old_alpha = gc.get_alpha()
                            old_alpha = 1.0
                            gc.set_alpha(self.invisible_plot_alpha)
                        else:
                            old_alpha = None
                        if len(plots) == 1:
                            plots[0]._render_icon(*render_args)
                        else:
                            self.composite_icon_renderer.render_icon(plots, *render_args)
                    elif plots is not None:
                        # Single plot
                        if not plots.visible:
                            #old_alpha = gc.get_alpha()
                            old_alpha = 1.0
                            gc.set_alpha(self.invisible_plot_alpha)
                        else:
                            old_alpha = None
                        plots._render_icon(*render_args)
                    else:
                        old_alpha = None  # Or maybe 1.0?

                    icon_drawn = True
                except:
                    icon_drawn = self._render_error(*render_args)

                if icon_drawn:
                    # Render the text
                    gc.translate_ctm(text_x, y)
                    gc.set_antialias(0)
                    self._cached_labels[i].draw(gc)
                    gc.set_antialias(1)
                    gc.translate_ctm(-text_x, -y)

                    # Advance y to the next label's baseline
                    y -= self.line_spacing
                if old_alpha is not None:
                    gc.set_alpha(old_alpha)

        return

    def _render_error(self, gc, icon_x, icon_y, icon_width, icon_height):
        """ Renders an error icon or performs some other action when a
        plot is unable to render its icon.

        Returns True if something was actually drawn (and hence the legend
        needs to advance the line) or False if nothing was drawn.
        """
        if self.error_icon == "skip":
            return False
        elif self.error_icon == "blank" or self.error_icon == "questionmark":
            with gc:
                gc.set_fill_color(self.bgcolor_)
                gc.rect(icon_x, icon_y, icon_width, icon_height)
                gc.fill_path()
            return True
        else:
            return False

    def get_preferred_size(self):
        """
        Computes the size and position of the legend based on the maximum size of
        the labels, the alignment, and position of the component to overlay.
        """
        # Gather the names of all the labels we will create
        if len(self.plots) == 0:
            return [0, 0]

        plot_names, visible_plots = map(list, zip(*sorted(self.plots.items())))
        label_names = self.labels
        if len(label_names) == 0:
            if len(self.plots) > 0:
                label_names = plot_names
            else:
                self._cached_labels = []
                self._cached_label_sizes = []
                self._cached_label_names = []
                self._cached_visible_plots = []
                self.outer_bounds = [0, 0]
                return [0, 0]

        if self.hide_invisible_plots:
            visible_labels = []
            visible_plots = []
            for name in label_names:
                # If the user set self.labels, there might be a bad value,
                # so ensure that each name is actually in the plots dict.
                if name in self.plots:
                    val = self.plots[name]
                    # Rather than checking for a list/TraitListObject/etc., we just check
                    # for the attribute first
                    if hasattr(val, 'visible'):
                        if val.visible:
                            visible_labels.append(name)
                            visible_plots.append(val)
                    else:
                        # If we have a list of renderers, add the name if any of them are
                        # visible
                        for renderer in val:
                            if renderer.visible:
                                visible_labels.append(name)
                                visible_plots.append(val)
                                break
            label_names = visible_labels

        # Create the labels
        labels = [self._create_label(text) for text in label_names]

        # For the legend title
        if self.title_at_top:
            labels.insert(0, self._create_label(self.title))
            label_names.insert(0, 'Legend Label')
            visible_plots.insert(0, None)
        else:
            labels.append(self._create_label(self.title))
            label_names.append(self.title)
            visible_plots.append(None)

        # We need a dummy GC in order to get font metrics
        dummy_gc = font_metrics_provider()
        label_sizes = array([label.get_width_height(dummy_gc) for label in labels])

        if len(label_sizes) > 0:
            max_label_width = max(label_sizes[:, 0])
            total_label_height = sum(label_sizes[:, 1]) + (len(label_sizes)-1)*self.line_spacing
        else:
            max_label_width = 0
            total_label_height = 0

        legend_width = max_label_width + self.icon_spacing + self.icon_bounds[0] \
                        + self.hpadding + 2*self.border_padding
        legend_height = total_label_height + self.vpadding + 2*self.border_padding

        self._cached_labels = labels
        self._cached_label_sizes = label_sizes
        self._cached_label_positions = zeros_like(label_sizes)
        self._cached_label_names = label_names
        self._cached_visible_plots = visible_plots

        if "h" not in self.resizable:
            legend_width = self.outer_width
        if "v" not in self.resizable:
            legend_height = self.outer_height
        return [legend_width, legend_height]

    def get_label_at(self, x, y):
        """ Returns the label object at (x,y) """
        for i, pos in enumerate(self._cached_label_positions):
            size = self._cached_label_sizes[i]
            corner = pos + size
            if (pos[0] <= x <= corner[0]) and (pos[1] <= y <= corner[1]):
                return self._cached_labels[i]
        else:
            return None

    def _do_layout(self):
        if self.component is not None or len(self._cached_labels) == 0 or \
                self._cached_label_sizes is None or len(self._cached_label_names) == 0:
            width, height = self.get_preferred_size()
            self.outer_bounds = [width, height]
        return

    def _create_label(self, text):
        """ Returns a new Label instance for the given text.  Subclasses can
        override this method to customize the creation of labels.
        """
        return Label(text=text, font=self.font, margin=0, color=self.color_,
                     bgcolor="transparent", border_width=0)

    def _composite_icon_renderer_default(self):
        return CompositeIconRenderer()

    #-- trait handlers --------------------------------------------------------
    def _anytrait_changed(self, name, old, new):
        if name in ("font", "border_padding", "padding", "line_spacing",
                    "icon_bounds", "icon_spacing", "labels", "plots",
                    "plots_items", "labels_items", "border_width", "align",
                    "position", "position_items", "bounds", "bounds_items",
                    "label_at_top"):
            self._layout_needed = True
        if name == "color":
            self.get_preferred_size()
        return

    def _plots_changed(self):
        """ Invalidate the caches.
        """
        self._cached_labels = []
        self._cached_label_sizes = None
        self._cached_label_names = []
        self._cached_visible_plots = []
        self._cached_label_positions = None

    def _title_at_top_changed(self, old, new):
        """ Trait handler for when self.title_at_top changes. """
        if old == True:
            indx = 0
        else:
            indx = -1
        if old != None:
            self._cached_labels.pop(indx)
            self._cached_label_names.pop(indx)
            self._cached_visible_plots.pop(indx)

        # For the legend title
        if self.title_at_top:
            self._cached_labels.insert(0, self._create_label(self.title))
            self._cached_label_names.insert(0, '__legend_label__')
            self._cached_visible_plots.insert(0, None)
        else:
            self._cached_labels.append(self._create_label(self.title))
            self._cached_label_names.append(self.title)
            self._cached_visible_plots.append(None)
#-- end Legend ----------------------------------------------------------------



########NEW FILE########
__FILENAME__ = linear_mapper
"""
Defines the LinearMapper class, which maps from a 1-D region in data space
into a 1-D output space.
"""

# Major library imports
from numpy import array, empty, ndarray

# Enthought library imports
from traits.api import Bool, Float

# Local relative imports
from base_1d_mapper import Base1DMapper


class LinearMapper(Base1DMapper):
    """ Maps a 1-D data space to and from screen space by specifying a range in
    data space and a corresponding fixed line in screen space.

    This class concerns itself only with metric and not with orientation. So, to
    "flip" the screen space orientation, simply swap the values for **low_pos**
    and **high_pos**.
    """

    #------------------------------------------------------------------------
    # Private traits
    #------------------------------------------------------------------------

    # Number of screen space units per data space unit.
    _scale = Float(1.0)
    # Is the range of the screen space empty?
    _null_screen_range = Bool(False)
    # Is the range of the data space empty?
    _null_data_range = Bool(False)

    #------------------------------------------------------------------------
    # Public methods
    #------------------------------------------------------------------------

    def map_screen(self, data_array):
        """ map_screen(data_array) -> screen_array

        Overrides AbstractMapper. Maps values from data space into screen space.
        """
        self._compute_scale()
        if self._null_data_range:
            if isinstance(data_array, (tuple, list, ndarray)):
                x = empty(data_array.shape)
                x.fill(self.low_pos)
                return x
            else:
                return array([self.low_pos])
        else:
            return (data_array - self.range.low) * self._scale + self.low_pos

    def map_data(self, screen_val):
        """ map_data(screen_val) -> data_val

        Overrides AbstractMapper. Maps values from screen space into data space.
        """
        self._compute_scale()
        if self._null_screen_range:
            return array([self.range.low])
        elif self._null_data_range:
            return array([self.range.low])
        else:
            return (screen_val - self.low_pos) / self._scale + self.range.low

    def map_data_array(self, screen_vals):
        """ map_data_array(screen_vals) -> data_vals

        Overrides AbstractMapper. Maps an array of values from screen space
        into data space.
        """
        return self.map_data(screen_vals)

    #------------------------------------------------------------------------
    # Private methods
    #------------------------------------------------------------------------

    def _compute_scale(self):
        if self._cache_valid:
            return

        if self.range is None:
            self._cache_valid = False
            return

        r = self.range
        screen_range = self.high_pos - self.low_pos
        data_range = r.high - r.low
        if screen_range == 0.0:
            self._null_screen_range = True
        else:
            self._null_screen_range = False
        if data_range == 0.0:
            self._null_data_range = True
        else:
            self._scale = screen_range / data_range
            # The screen_range might be small enough that dividing by the
            # data_range causes it to go to 0. Explicitly call bool because
            # _scale might also be a numpy scalar and yield another numpy scalar
            # that the Bool trait rejects.
            self._null_data_range = bool(self._scale == 0.0)

        self._cache_valid = True
        return

# EOF

########NEW FILE########
__FILENAME__ = lineplot
""" Defines the LinePlot class.
"""

from __future__ import with_statement

# Standard library imports
import warnings

# Major library imports
from numpy import argsort, array, concatenate, inf, invert, isnan, \
                  take, transpose, zeros, sqrt, argmin, clip, column_stack

# Enthought library imports
from enable.api import black_color_trait, ColorTrait, LineStyle
from traits.api import Enum, Float, List, Str, Property, Tuple, cached_property
from traitsui.api import Item, View

# Local relative imports
from base import arg_find_runs, bin_search, reverse_map_1d
from base_xy_plot import BaseXYPlot



class LinePlot(BaseXYPlot):
    """ A plot consisting of a line.

    This is the most fundamental object to use to create line plots. However,
    it is somewhat low-level and therefore creating one properly to do what
    you want can require some verbose code. The create_line_plot() function
    in plot_factory.py can hide some of this verbosity for common cases.
    """
    # The color of the line.
    color = black_color_trait

    # The RGBA tuple for rendering lines.  It is always a tuple of length 4.
    # It has the same RGB values as color_, and its alpha value is the alpha
    # value of self.color multiplied by self.alpha. 
    effective_color = Property(Tuple, depends_on=['color', 'alpha'])

    # The color to use to highlight the line when selected.
    selected_color = ColorTrait("lightyellow")

    # The style of the selected line.
    selected_line_style = LineStyle("solid")

    # The name of the key in self.metadata that holds the selection mask
    metadata_name = Str("selections")

    # The thickness of the line.
    line_width = Float(1.0)

    # The line dash style.
    line_style = LineStyle

    # The rendering style of the line plot.
    #
    # connectedpoints
    #     "normal" style (default); each point is connected to subsequent and
    #     prior points by line segments
    # hold
    #     each point is represented by a line segment parallel to the abscissa
    #     (index axis) and spanning the length between the point and its
    #     subsequent point.
    # connectedhold
    #     like "hold" style, but line segments are drawn at each point of the
    #     plot to connect the hold lines of the prior point and the current
    #     point.  Also called a "right angle plot".
    render_style = Enum("connectedpoints", "hold", "connectedhold")

    # Traits UI View for customizing the plot.
    traits_view = View(Item("color", style="custom"), "line_width", "line_style",
                       buttons=["OK", "Cancel"])

    #------------------------------------------------------------------------
    # Private traits
    #------------------------------------------------------------------------

    # Cached list of non-NaN arrays of (x,y) data-space points; regardless of
    # self.orientation, this is always stored as (index_pt, value_pt).  This is
    # different from the default BaseXYPlot definition.
    _cached_data_pts = List

    # Cached list of non-NaN arrays of (x,y) screen-space points.
    _cached_screen_pts = List


    def hittest(self, screen_pt, threshold=7.0, return_distance = False):
        """
        Tests whether the given screen point is within *threshold* pixels of
        any data points on the line.  If so, then it returns the (x,y) value of
        a data point near the screen point.  If not, then it returns None.
        """

        # First, check screen_pt is directly on a point in the lineplot
        ndx = self.map_index(screen_pt, threshold)
        if ndx is not None:
            # screen_pt is one of the points in the lineplot
            data_pt = (self.index.get_data()[ndx], self.value.get_data()[ndx])
            if return_distance:
                scrn_pt = self.map_screen(data_pt)
                dist = sqrt((screen_pt[0] - scrn_pt[0])**2
                            + (screen_pt[1] - scrn_pt[1])**2)
                return (data_pt[0], data_pt[1], dist)
            else:
                return data_pt
        else:
            # We now must check the lines themselves

            # Must check all lines within threshold along the major axis,
            # so determine the bounds of the region of interest in dataspace
            if self.orientation == "h":
                dmax = self.map_data((screen_pt[0]+threshold, screen_pt[1]))
                dmin = self.map_data((screen_pt[0]-threshold, screen_pt[1]))
            else:
                dmax = self.map_data((screen_pt[0], screen_pt[1]+threshold))
                dmin = self.map_data((screen_pt[0], screen_pt[1]-threshold))

            xmin, xmax = self.index.get_bounds()

            # Now compute the bounds of the region of interest as indexes
            if dmin < xmin:
                ndx1 = 0
            elif dmin > xmax:
                ndx1 = len(self.value.get_data())-1
            else:
                ndx1 = reverse_map_1d(self.index.get_data(), dmin,
                                      self.index.sort_order)
            if dmax < xmin:
                ndx2 = 0
            elif dmax > xmax:
                ndx2 = len(self.value.get_data())-1
            else:
                ndx2 = reverse_map_1d(self.index.get_data(), dmax,
                                      self.index.sort_order)

            start_ndx = max(0, min(ndx1-1, ndx2-1,))
            end_ndx = min(len(self.value.get_data())-1, max(ndx1+1, ndx2+1))

            # Compute the distances to all points in the range of interest
            start = array([ self.index.get_data()[start_ndx:end_ndx],
                            self.value.get_data()[start_ndx:end_ndx] ])
            end = array([ self.index.get_data()[start_ndx+1:end_ndx+1],
                            self.value.get_data()[start_ndx+1:end_ndx+1] ])

            # Convert to screen points
            s_start = transpose(self.map_screen(transpose(start)))
            s_end = transpose(self.map_screen(transpose(end)))

            # t gives the parameter of the closest point to screen_pt
            # on the line going from s_start to s_end
            t = _closest_point(screen_pt, s_start, s_end)

            # Restrict to points on the line segment s_start->s_end
            t = clip(t, 0, 1)

            # Gives the corresponding point on the line
            px, py = _t_to_point(t, s_start, s_end)

            # Calculate distances
            dist =  sqrt((px - screen_pt[0])**2 +
                         (py - screen_pt[1])**2)

            # Find the minimum
            n = argmin(dist)
            # And return if it is good
            if dist[n] <= threshold:
                best_pt = self.map_data((px[n], py[n]), all_values=True)

                if return_distance:
                    return [best_pt[0], best_pt[1], dist[n]]
                else:
                    return best_pt

            return None

    def interpolate(self, index_value):
        """
        Returns the value of the plot at the given index value in screen space.
        Raises an IndexError when *index_value* exceeds the bounds of indexes on
        the value.
        """

        if self.index is None or self.value is None:
            raise IndexError, "cannot index when data source index or value is None"

        index_data = self.index.get_data()
        value_data = self.value.get_data()

        ndx = reverse_map_1d(index_data, index_value, self.index.sort_order)

        # quick test to see if this value is already in the index array
        if index_value == index_data[ndx]:
            return value_data[ndx]

        # get x and y values to interpolate between
        if index_value < index_data[ndx]:
            x0 = index_data[ndx - 1]
            y0 = value_data[ndx - 1]
            x1 = index_data[ndx]
            y1 = value_data[ndx]
        else:
            x0 = index_data[ndx]
            y0 = value_data[ndx]
            x1 = index_data[ndx + 1]
            y1 = value_data[ndx + 1]

        if x1 != x0:
            slope = float(y1 - y0)/float(x1 - x0)
            dx = index_value - x0
            yp = y0 + slope * dx
        else:
            yp = inf

        return yp

    def get_screen_points(self):
        self._gather_points()
        return [self.map_screen(ary) for ary in self._cached_data_pts]

    #------------------------------------------------------------------------
    # Private methods; implements the BaseXYPlot stub methods
    #------------------------------------------------------------------------

    def _gather_points(self):
        """
        Collects the data points that are within the bounds of the plot and
        caches them.
        """
        if not self._cache_valid:

            if not self.index or not self.value:
                return

            index = self.index.get_data()
            value = self.value.get_data()

            # Check to see if the data is completely outside the view region
            for ds, rng in ((self.index, self.index_range), (self.value, self.value_range)):
                low, high = ds.get_bounds()
                if low > rng.high or high < rng.low:
                    self._cached_data_pts = []
                    self._cached_valid = True
                    return

            if len(index) == 0 or len(value) == 0 or len(index) != len(value):
                self._cached_data_pts = []
                self._cache_valid = True

            size_diff = len(value) - len(index)
            if size_diff > 0:
                warnings.warn('Chaco.LinePlot: len(value) %d - len(index) %d = %d\n' \
                              % (len(value), len(index), size_diff))
                index_max = len(index)
                value = value[:index_max]
            else:
                index_max = len(value)
                index = index[:index_max]

            # TODO: restore the functionality of rendering highlighted portions
            # of the line
            #selection = self.index.metadata.get(self.metadata_name, None)
            #if selection is not None and type(selection) in (ndarray, list) and \
            #        len(selection) > 0:

            # Split the index and value raw data into non-NaN chunks
            nan_mask = invert(isnan(value)) & invert(isnan(index))
            blocks = [b for b in arg_find_runs(nan_mask, "flat") if nan_mask[b[0]] != 0]

            points = []
            for block in blocks:
                start, end = block
                block_index = index[start:end]
                block_value = value[start:end]
                index_mask = self.index_mapper.range.mask_data(block_index)

                runs = [r for r in arg_find_runs(index_mask, "flat") \
                        if index_mask[r[0]] != 0]

                # Check to see if our data view region is between two points in the
                # index data.  If so, then we have to reverse map our current view
                # into the appropriate index and draw the bracketing points.
                if runs == []:
                    data_pt = self.map_data((self.x_mapper.low_pos, self.y_mapper.low_pos))
                    if self.index.sort_order == "none":
                        indices = argsort(index)
                        sorted_index = take(index, indices)
                        sorted_value = take(value, indices)
                        sort = 1
                    else:
                        sorted_index = index
                        sorted_value = value
                        if self.index.sort_order == "ascending":
                            sort = 1
                        else:
                            sort = -1
                    ndx = bin_search(sorted_index, data_pt, sort)
                    if ndx == -1:
                        # bin_search can return -1 if data_pt is outside the bounds
                        # of the source data
                        continue

                    points.append(transpose(array((sorted_index[ndx:ndx+2],
                                                   sorted_value[ndx:ndx+2]))))

                else:
                    # Expand the width of every group of points so we draw the lines
                    # up to their next point, outside the plot area
                    data_end = len(index_mask)
                    for run in runs:
                        start, end = run
                        if start != 0:
                            start -= 1
                        if end != data_end:
                            end += 1

                        run_data = ( block_index[start:end],
                                     block_value[start:end] )
                        run_data = column_stack(run_data)

                        points.append(run_data)

            self._cached_data_pts = points
            self._cache_valid = True
        return

    def _downsample(self):
        if not self._screen_cache_valid:
            self._cached_screen_pts = [self.map_screen(p) for p in self._cached_data_pts]
            self._screen_cache_valid = True

            pt_arrays = self._cached_screen_pts

            # some boneheaded short-circuits
            m = self.index_mapper
            total_numpoints = sum([p.shape for p in pt_arrays])
            if (total_numpoints < 400) or (total_numpoints < m.high_pos - m.low_pos):
                return self._cached_screen_pts

            # the new point array and a counter of how many actual points we've added
            # to it
            new_arrays = []
            for pts in pt_arrays:
                new_pts = zeros(pts.shape, "d")
                numpoints = 1
                new_pts[0] = pts[0]

                last_x, last_y = pts[0]
                for x, y in pts[1:]:
                    if (x-last_x)**2 + (y-last_y)**2 > 2:
                        new_pts[numpoints] = (x,y)
                        last_x = x
                        last_y = y
                        numpoints += 1

                new_arrays.append(new_pts[:numpoints])
        return self._cached_screen_pts

    def _render(self, gc, points, selected_points=None):
        if len(points) == 0:
            return

        with gc:
            gc.set_antialias(True)
            gc.clip_to_rect(self.x, self.y, self.width, self.height)

            render_method_dict = {
                    "hold": self._render_hold,
                    "connectedhold": self._render_connected_hold,
                    "connectedpoints": self._render_normal
                    }
            render = render_method_dict.get(self.render_style, self._render_normal)

            if selected_points is not None:
                gc.set_stroke_color(self.selected_color_)
                gc.set_line_width(self.line_width+10.0)
                gc.set_line_dash(self.selected_line_style_)
                render(gc, selected_points, self.orientation)

            # Render using the normal style
            gc.set_stroke_color(self.effective_color)
            gc.set_line_width(self.line_width)
            gc.set_line_dash(self.line_style_)
            render(gc, points, self.orientation)

            # Draw the default axes, if necessary
            self._draw_default_axes(gc)

    @classmethod
    def _render_normal(cls, gc, points, orientation):
        for ary in points:
            if len(ary) > 0:
                gc.begin_path()
                gc.lines(ary)
                gc.stroke_path()
        return

    @classmethod
    def _render_hold(cls, gc, points, orientation):
        for starts in points:
            x,y = starts.T
            if orientation == "h":
                ends = transpose(array( (x[1:], y[:-1]) ))
            else:
                ends = transpose(array( (x[:-1], y[1:]) ))
            gc.begin_path()
            gc.line_set(starts[:-1], ends)
            gc.stroke_path()
        return

    @classmethod
    def _render_connected_hold(cls, gc, points, orientation):
        for starts in points:
            x,y = starts.T
            if orientation == "h":
                ends = transpose(array( (x[1:], y[:-1]) ))
            else:
                ends = transpose(array( (x[:-1], y[1:]) ))
            gc.begin_path()
            gc.line_set(starts[:-1], ends)
            gc.line_set(ends, starts[1:])
            gc.stroke_path()
        return

    def _render_icon(self, gc, x, y, width, height):
        with gc:
            gc.set_stroke_color(self.effective_color)
            gc.set_line_width(self.line_width)
            gc.set_line_dash(self.line_style_)
            gc.set_antialias(0)
            gc.move_to(x, y+height/2)
            gc.line_to(x+width, y+height/2)
            gc.stroke_path()
        return

    def _downsample_vectorized(self):
        """
        Analyzes the screen-space points stored in self._cached_data_pts
        and replaces them with a downsampled set.
        """
        pts = self._cached_screen_pts  #.astype(int)

        # some boneheaded short-circuits
        m = self.index_mapper
        if (pts.shape[0] < 400) or (pts.shape[0] < m.high_pos - m.low_pos):
            return

        pts2 = concatenate((array([[0.0,0.0]]), pts[:-1]))
        z = abs(pts - pts2)
        d = z[:,0] + z[:,1]
        #... TODO ...
        return

    def _alpha_changed(self):
        self.invalidate_draw()
        self.request_redraw()
        return

    def _color_changed(self):
        self.invalidate_draw()
        self.request_redraw()
        return

    def _line_style_changed(self):
        self.invalidate_draw()
        self.request_redraw()
        return

    def _line_width_changed(self):
        self.invalidate_draw()
        self.request_redraw()
        return

    def __getstate__(self):
        state = super(LinePlot,self).__getstate__()
        for key in ['traits_view']:
            if state.has_key(key):
                del state[key]

        return state

    @cached_property
    def _get_effective_color(self):
        alpha = self.color_[-1] if len(self.color_) == 4 else 1
        c = self.color_[:3] + (alpha * self.alpha,)
        return c

def _closest_point(target, p1, p2):
    '''Utility function for hittest:
    finds the point on the line between p1 and p2 to
    the target. Returns the 't' value of that point
    where the line is parametrized as
        t -> p1*(1-t) + p2*t
    Notably, if t=0 is p1, t=2 is p2 and anything outside
    that range is a point outisde p1, p2 on the line
    Note: can divide by zero, so user should check for that'''
    t = ((p1[0] - target[0])*(p1[0]-p2[0]) \
            + (p1[1] - target[1])*(p1[1]-p2[1]))\
        / ((p1[0] - p2[0])*(p1[0] - p2[0]) + (p1[1] - p2[1])*(p1[1] - p2[1]))
    return t

def _t_to_point(t, p1, p2):
    '''utility function for hittest for use with _closest_point
    returns the point corresponding to the parameter t
    on the line going between p1 and p2'''
    return ( p1[0]*(1-t) + p2[0]*t,
             p1[1]*(1-t) + p2[1]*t )


# EOF

########NEW FILE########
__FILENAME__ = log_mapper
""" Defines the LogMapper and InvalidDataRangeException classes.
"""
# Major library imports
from numpy import array, isnan, log, log10, exp, zeros, sometrue,\
    floor, ceil, ndarray

# Enthought library imports
from traits.api import Bool, Float

#Local relative imports
from base_1d_mapper import Base1DMapper


LOG_MINIMUM = 0.0

class InvalidDataRangeException(Exception):
    pass

class LogMapper(Base1DMapper):
    """ Defines a 1-D logarithmic scale mapping from a 1-D region in input
    space to a 1-D region in output space.
    """

    # The value to map when asked to map values <= LOG_MINIMUM to screen space.
    fill_value = Float(1.0)

    #------------------------------------------------------------------------
    # Private traits
    #------------------------------------------------------------------------

    _inter_scale = Float(0.0)
    _inter_offset = Float(0.0)
    _screen_scale = Float(0.0)
    _screen_offset = Float(0.0)
    _null_screen_range = Bool(False)
    _null_data_range = Bool(False)

    #------------------------------------------------------------------------
    # Public methods
    #------------------------------------------------------------------------

    def map_screen(self, data_array):
        """ map_screen(data_array) -> screen_array

        Overrides AbstractMapper. Maps values from data space to screen space.
        """
        # Ensure that data_array is actually an array.
        if not isinstance(data_array, ndarray):
            data_array = array(data_array, ndmin=1)
        # First convert to a [0,1] space, then to the screen space.
        if not self._cache_valid:
            self._compute_scale()
        if self._inter_scale == 0.0:
            intermediate = data_array*0.0
        else:
            try:
                mask = (data_array <= LOG_MINIMUM) | isnan(data_array)
                if sometrue(mask):
                    data_array = array(data_array, copy=True, ndmin=1)
                    data_array[mask] = self.fill_value
                intermediate = (log(data_array) - self._inter_offset)/self._inter_scale
            except ValueError:
                intermediate = zeros(len(data_array))

        result = intermediate * self._screen_scale + self._screen_offset
        return result

    def map_data(self, screen_val):
        """ map_data(screen_val) -> data_val

        Overrides Abstract Mapper. Maps values from screen space into data space.
        """
        if not self._cache_valid:
            self._compute_scale()
        if self._null_screen_range or self._null_data_range:
            return array([self.range.low])
        #First convert to a [0,1] space, then to the data space
        intermediate = (screen_val-self._screen_offset)/self._screen_scale
        return exp(self._inter_scale*intermediate + self._inter_offset)

    def map_data_array(self, screen_vals):
        return self.map_data(screen_vals)

    #------------------------------------------------------------------------
    # Private methods
    #------------------------------------------------------------------------

    def _get_safe_scale(self, range):
        orig_low = range.low
        orig_high = range.high
        if orig_low < LOG_MINIMUM:
            low = LOG_MINIMUM
        else:
            low = orig_low

        if orig_high < LOG_MINIMUM:
            high = LOG_MINIMUM
        else:
            high = orig_high

        if low == high:
            if low == LOG_MINIMUM:
                low = 1.0
                high = 10.0
            else:
                log_val = log10(low)
                low = pow(10, floor(log_val))
                if ceil(log_val) != floor(log_val):
                    high = pow(10, ceil(log_val))
                else:
                    high = pow(10, ceil(log_val) + 1)

        return (low, high)

    def _compute_scale(self):
        if self._cache_valid:
            return

        if self.range is None:
            self._cache_valid = False
            return

        screen_range = self.high_pos - self.low_pos
        if screen_range == 0.0:
            self._null_screen_range = True

        # Get dataspace low and high from the range that are "safe" for a
        # logarithmic mapper, i.e. constrained to be between LOG_MINIMUM and inf.
        low, high = self._get_safe_scale(self.range)
        if high - low == 0:
            self._null_data_range = True
        else:
            if low == LOG_MINIMUM:
                self._inter_scale = log(high)
                self._inter_offset = 0.0
            else:
                self._inter_scale = log(high)-log(low)
                self._inter_offset = log(low)
            self._screen_scale = screen_range
            self._screen_offset = self.low_pos

        self._cache_valid = True
        return

# EOF

########NEW FILE########
__FILENAME__ = multi_array_data_source
""" Defines the MultiArrayDataSource class.
"""
# Major package imports
from numpy import nanmax, nanmin, array, shape, ones, bool, newaxis, nan_to_num
import types

# Enthought library imports
from traits.api import Any, Int, Tuple

# Chaco imports
from base import NumericalSequenceTrait, SortOrderTrait
from abstract_data_source import AbstractDataSource


class MultiArrayDataSource(AbstractDataSource):
    """ A data source representing a single, continuous array of
    multidimensional numerical data.

    It is useful, for example, to define 2D vector data at each point of
    a scatter plot (as in QuiverPlot), or to represent multiple values
    for each index (as in MultiLinePlot).

    This class does not listen to the array for value changes;  To implement
    such behavior, define a subclass that hooks up the appropriate listeners.
    """

    #------------------------------------------------------------------------
    # AbstractDataSource traits
    #------------------------------------------------------------------------

    # The dimensionality of the indices into this data source (overrides
    # AbstractDataSource).
    index_dimension = Int(0)

    # The dimensionality of the value at each index point (overrides
    # AbstractDataSource).
    value_dimension = Int(1)

    # The sort order of the data.
    # This is a specialized optimization for 1-D arrays, but it's an important
    # one that's used everywhere.
    sort_order = SortOrderTrait


    #------------------------------------------------------------------------
    # Private traits
    #------------------------------------------------------------------------

    # The data array itself.
    _data = NumericalSequenceTrait

    # Cached values of min and max as long as **_data** doesn't change.
    _cached_bounds = Tuple

    # Not necessary, since this is not a filter, but provided for convenience.
    _cached_mask = Any

    # The index of the (first) minimum value in self._data.
    _min_index = Int

    # The index of the (first) maximum value in self._data.
    _max_index = Int

    def __init__(self, data=array([]), sort_order="ascending", **traits):
        super(MultiArrayDataSource, self).__init__(**traits)
        self._set_data(data)
        self.sort_order = sort_order
        #self._compute_bounds()
        self.data_changed = True
        return

    def get_data(self, axes = None, remove_nans=False):
        """get_data() -> data_array

        If called with no arguments, this method returns a data array.
        Treat this data array as read-only, and do not alter it in-place.
        This data is contiguous and not masked.

        If *axes* is an integer or tuple, this method returns the data array,
        sliced along the **index_dimension**.
        """

        if type(axes) == types.IntType:
            if self.index_dimension == 0:
                data = self._data[::, axes]
            else:
                data = self._data[axes, ::]
        elif axes is None:
            data = self._data

        # fixme: we need to handle the multi-dimensional case.

        if remove_nans:
            return nan_to_num(data)
        else:
            return data

    def get_data_mask(self):
        """get_data_mask() -> (data_array, mask_array)

        Implements AbstractDataSource.
        """
        if self._cached_mask is None:
            self._cached_mask = ones(shape(self._data), bool)
        return self._data, self._cached_mask

    def is_masked(self):
        """is_masked() -> bool

        Returns True if this data source's data uses a mask. In this case,
        retrieve the data using get_data_mask() instead of get_data().
        If you call get_data() for this data source, it returns data, but that
        data may not be the expected data.)
        """
        return False

    def get_size(self):
        """get_size() -> int

        Implements AbstractDataSource. Returns an integer estimate, or the
        exact size, of the dataset that get_data() returns. This method is
        useful for downsampling.
        """
        # return the size along the index dimension
        size = 0
        if self._data is not None:
            size = shape(self._data)[self.index_dimension]

        return size

    def get_value_size(self):
        """ get_value_size() -> size

        Returns the size along the value dimension.
        """
        size = 0
        if self._data is not None:
            size = shape(self._data)[self.value_dimension]

        return size


    def get_bounds(self, value = None, index = None):
        """get_bounds() -> tuple(min, max)

        Returns a tuple (min, max) of the bounding values for the data source.
        In the case of 2-D data, min and max are 2-D points that represent the
        bounding corners of a rectangle enclosing the data set.  Note that
        these values are not view-dependent, but represent intrinsic properties
        of the data source.

        If data is the empty set, then the min and max vals are 0.0.

        If *value* and *index* are both None, then the method returns the
        global minimum and maximum for the entire data set.
        If *value* is an integer, then the method returns the minimum and
        maximum along the *value* slice in the **value_dimension**.
        If *index* is an integer, then the method returns the minimum and
        maximum along the *index* slice in the **index_direction**.
        """

        if self._data is None or 0 in self._data.shape:
            return (0.0, 0.0)

        if type(value) == types.IntType:
            if self.value_dimension == 0:
                maxi = nanmax(self._data[value, ::])
                mini = nanmin(self._data[value, ::])
            else:
                # value_dimension == 1
                maxi = nanmax(self._data[::, value])
                mini = nanmin(self._data[::, value])
        elif type(index) == types.IntType:
            if self.index_dimension == 0:
                maxi = nanmax(self._data[index, ::])
                mini = nanmin(self._data[index, ::])
            else:
                # index_dimension == 1
                maxi = nanmax(self._data[::, index])
                mini = nanmin(self._data[::, index])
        else:
            # value is None and index is None:
            maxi = nanmax(self._data)
            mini = nanmin(self._data)

        return (mini, maxi)

    def get_shape(self):
        """ Returns the shape of the multi-dimensional data source.
        """
        return shape(self._data)

    def set_data(self, value):
        """ Sets the data for this data source.

        Parameters
        ----------
        value : array
            The data to use.
        """
        self._set_data(value)
        self.data_changed = True
        return

    def _set_data(self, value):
        """ Forces 1-D data to 2-D.
        """
        if len(value.shape) == 1:
            if self.index_dimension == 0:
                value = value[:,newaxis]
            else:
                value = value[newaxis,:]

        if len(value.shape) != 2:
            msg = 'Input is %d dimensional, but it must be 1 or 2' \
                  'dimensional.' % len(value.shape)
            raise ValueError, msg

        self._data = value

# EOF

########NEW FILE########
__FILENAME__ = multi_line_plot
""" Defines the MultiLinePlot class.
"""

from __future__ import with_statement

# Standard library imports
import warnings
from math import ceil, floor

# Major library imports
import numpy as np
from numpy import argsort, array, invert, isnan, take, transpose

# Enthought library imports
from enable.api import black_color_trait, ColorTrait, LineStyle
from traits.api import Float, List, Str, Trait, \
            Bool, Callable, Property, cached_property, Instance, Array
from traitsui.api import Item, View, ScrubberEditor, HGroup

from array_data_source import ArrayDataSource
from base import arg_find_runs, bin_search
from base_xy_plot import BaseXYPlot


class MultiLinePlot(BaseXYPlot):
    """ A plot consisting of multiple lines.

    The data to be plotted must come from a two-dimensional array with shape M by N
    stored in a TraceArrayDataSource object.  M is the number of lines to be plotted,
    and N is the number of points in each line.

    Constructor Parameters
    ----------------------
    index : instance of an ArrayDataSource
        These are the 'x' or abscissa coordinates.

    yindex : instance of ArrayDataSource
        These are the 'y' coordinates.

    value : instance of a MultiArrayDataSource
        Note that the `scale`, `offset` and `normalized_amplitude` attributes of the
        MultiLinePlot control the projection of the traces into the (x,y)
        plot.  In simplest case, `scale=1` and `offset=0`, and `normalized_amplitude`
        controls the scaling of the traces relative to their base y value.

    global_min, global_max : float
        The minimum and maximum values of the data in `value`.  For large
        arrays, computing these could take excessive time, so they must be
        provided when an instance is created.

    normalized_amplitude : Float

    color : ColorTrait

    color_func : Callable or None
        If not None, this Callable overrides `color`.  The argument to `color_func`
        will be the integer index of the trace to be rendered.  `color_func` must
        return an RGBA 4-tuple.
        Default: None

    orientation : str
        Must be 'v' or 'h' (for 'vertical' or 'horizontal', respectively).  This is
        the orientation of the index axis (i.e. the 'x' axis).
        Default: 'h'

    fast_clip : bool
        If True, traces whose *base* 'y' coordinate is outside the value axis range
        are not plotted, even if some of the data in the curve extends into the plot
        region.
        Default: False

    line_width : float
        Width of the plotted lines.

    line_style :
        The style of the trace lines in the plot.

    The following are from the original LinePlot code, and are untested:

    selected_color
    selected_line_style

    """

    # M and N appearing in the comments are as defined in the docstring.

    yindex = Instance(ArrayDataSource)

    # amplitude = Float(0.0)

    # `scale` and `offset` provide a more general transformation, but are currently
    # untested.
    scale = Float(1.0)
    offset = Float(0.0)

    fast_clip = Bool(False)

    # The color of the lines.
    color = black_color_trait

    # A function that returns the color of lines.  Overrides `color` if not None.
    color_func = Trait(None, None, Callable)

    # The color to use to highlight the line when selected.
    selected_color = ColorTrait("lightyellow")

    # The style of the selected line.
    selected_line_style = LineStyle("solid")

    # The name of the key in self.metadata that holds the selection mask
    metadata_name = Str("selections")

    # The thickness of the line.
    line_width = Float(1.0)

    # The line dash style.
    line_style = LineStyle

    use_global_bounds = Bool(True)

    # Minimum value in the `value` data source.  This must be provided
    # in the call to the constructor.
    global_min = Float

    # Maximum value in the `value` data source.  This must be provided
    # in the call to the constructor.
    global_max = Float

    # Normalized amplitude is the value exposed to the user.
    normalized_amplitude = Float(-0.5)

    amplitude_scale = Property(Float, depends_on=['global_min', 'global_max', 'data',
                                                  'use_global_bounds', 'yindex'])

    amplitude = Property(Float, depends_on=['normalized_amplitude',
                                                'amplitude_scale'])

    #------------------------------------------------------------------------
    # Private traits
    #------------------------------------------------------------------------

    # The projected 2D numpy array.
    _trace_data = Property(Array, depends_on=['index', 'index.data_changed',
        'value', 'value.data_changed', 'yindex', 'yindex.data_changed',
        'amplitude', 'scale', 'offset'])

    # Cached list of non-NaN arrays of (x,y) data-space points; regardless of
    # self.orientation, this is always stored as (index_pt, value_pt).  This is
    # different from the default BaseXYPlot definition.
    _cached_data_pts = List

    # Cached list of non-NaN arrays of (x,y) screen-space points.
    _cached_screen_pts = List

    #------------------------------------------------------------------------
    #
    #------------------------------------------------------------------------

    def trait_view(self, obj):
        """Create a minimalist View, with just the amplitude and color attributes."""
        # Minimalist Traits UI View for customizing the plot: only the trace amplitude
        # and line color are exposed.
        view = View(
                HGroup(
                    Item('use_global_bounds'),
                    # Item('normalized_amplitude'),
                    # Item('normalized_amplitude', editor=RangeEditor()),
                    Item('normalized_amplitude',
                        editor=ScrubberEditor(increment=0.2, hover_color=0xFFFFFF, active_color=0xA0CD9E,
                                              border_color=0x0000FF)),
                    ),
                Item("color", label="Trace color", style="simple"),
                width=480,
                title="Trace Plot Line Attributes",
                buttons=["OK", "Cancel"])
        return view

    #------------------------------------------------------------------------
    #
    #------------------------------------------------------------------------

    # See base_xy_plot.py for these:
    ## def hittest(self, screen_pt, threshold=7.0):
    ## def interpolate(self, index_value):


    def get_screen_points(self):
        self._gather_points()
        scrn_pts_list = [[self.map_screen(ary) for ary in line]
                                for line in self._cached_data_pts]
        return scrn_pts_list

    #------------------------------------------------------------------------
    # Private methods
    #------------------------------------------------------------------------

    @cached_property
    def _get_amplitude_scale(self):
        """
        If the amplitude is set to this value, the largest trace deviation from
        its base y coordinate will be equal to the y coordinate spacing.
        """
        # Note: Like the rest of the current code, this ignores the `scale` attribute.

        if self.yindex is not None:
            coordinates = self.yindex.get_data()
        else:
            coordinates = []

        if len(coordinates) > 1:
            dy = coordinates[1] - coordinates[0]
            if dy == 0:
                dy = 1.0
        else:
            # default coordinate spacing if there is only 1 coordinate
            dy = 1.0

        if self.use_global_bounds:
            max_abs = max(abs(self.global_min), abs(self.global_max))
        else:
            data = self.value._data
            max_abs = np.max(np.abs(data))

        if max_abs == 0:
            amp_scale = 0.5 * dy
        else:
            amp_scale = 0.5 * dy / max_abs
        return amp_scale

    @cached_property
    def _get_amplitude(self):
        amplitude = self.normalized_amplitude * self.amplitude_scale
        return amplitude

    @cached_property
    def _get__trace_data(self):
        """Compute the transformed data."""

        # Get the array from `value`
        data = self.value._data
        coordinates = self.yindex.get_data()
        channel_data = self.scale*(self.amplitude*data + coordinates[:,np.newaxis]) \
                                + self.offset
        return channel_data


    def _gather_points(self):
        """
        Collects the data points that are within the bounds of the plot and
        caches them.
        """

        if self._cache_valid:
            return

        if not self.index or not self.value:
            return

        index = self.index.get_data()
        varray = self._trace_data

        if varray.size == 0:
            self._cached_data_pts = []
            self._cached_valid = True
            return

        coordinates = self.yindex.get_data()

        if self.fast_clip:
            coord_min = float(coordinates[0])
            coord_max = coordinates[-1]
            slice_min = max(0,ceil((varray.shape[0]-1)*(self.value_range.low - coord_min)/(coord_max - coord_min)))
            slice_max = min(varray.shape[0], 1+floor((varray.shape[0]-1)*(self.value_range.high - coord_min)/(coord_max - coord_min)))
            varray = varray[slice_min:slice_max]
            # FIXME: The y coordinates must also be sliced to match varray.

        # Check to see if the data is completely outside the view region.
        outside = False
        # Check x coordinates.
        low, high = self.index.get_bounds()
        if low > self.index_range.high or high < self.index_range.low:
            outside = True

        # Check y coordinates. Use varray because it is nased on the yindex,
        # but has been shifted up or down depending on the values.
        ylow, yhigh = varray.min(), varray.max()
        if ylow > self.value_range.high or yhigh < self.value_range.low:
            outside = True

        if outside:
            self._cached_data_pts = []
            self._cached_valid = True
            return

        if len(index) == 0 or varray.shape[0] == 0 or varray.shape[1] == 0 \
                or len(index) != varray.shape[1]:
            self._cached_data_pts = []
            self._cache_valid = True
            return

        size_diff = varray.shape[1] - len(index)
        if size_diff > 0:
            warnings.warn('Chaco.LinePlot: value.shape[1] %d - len(index) %d = %d\n' \
                          % (varray.shape[1], len(index), size_diff))
            index_max = len(index)
            varray = varray[:,:index_max]
        else:
            index_max = varray.shape[1]
            index = index[:index_max]

        # Split the index and value raw data into non-NaN chunks.
        # nan_mask is a boolean M by N array.
        nan_mask = invert(isnan(varray)) & invert(isnan(index))
        blocks_list = []
        for nm in nan_mask:
            blocks = [b for b in arg_find_runs(nm, "flat") if nm[b[0]] != 0]
            blocks_list.append(blocks)

        line_points = []
        for k, blocks in enumerate(blocks_list):
            points = []
            for block in blocks:
                start, end = block
                block_index = index[start:end]
                block_value = varray[k, start:end]
                index_mask = self.index_mapper.range.mask_data(block_index)

                runs = [r for r in arg_find_runs(index_mask, "flat") \
                        if index_mask[r[0]] != 0]

                # Check to see if our data view region is between two points in the
                # index data.  If so, then we have to reverse map our current view
                # into the appropriate index and draw the bracketing points.
                if runs == []:
                    data_pt = self.map_data((self.x_mapper.low_pos, self.y_mapper.low_pos))
                    if self.index.sort_order == "none":
                        indices = argsort(index)
                        sorted_index = take(index, indices)
                        sorted_value = take(varray[k], indices)
                        sort = 1
                    else:
                        sorted_index = index
                        sorted_value = varray[k]
                        if self.index.sort_order == "ascending":
                            sort = 1
                        else:
                            sort = -1
                    ndx = bin_search(sorted_index, data_pt, sort)
                    if ndx == -1:
                        # bin_search can return -1 if data_pt is outside the bounds
                        # of the source data
                        continue


                    z = transpose(array((sorted_index[ndx:ndx+2],
                                                   sorted_value[ndx:ndx+2])))
                    points.append(z)

                else:
                    # Expand the width of every group of points so we draw the lines
                    # up to their next point, outside the plot area
                    data_end = len(index_mask)
                    for run in runs:
                        start, end = run
                        if start != 0:
                            start -= 1
                        if end != data_end:
                            end += 1

                        run_data = transpose(array((block_index[start:end],
                                                    block_value[start:end])))
                        points.append(run_data)
            line_points.append(points)

        self._cached_data_pts = line_points
        self._cache_valid = True
        return


    # See base_xy_plot.py for:
    ## def _downsample(self):
    ## def _downsample_vectorized(self):


    def _render(self, gc, line_points, selected_points=None):

        if len(line_points) == 0:
            return

        with gc:
            gc.set_antialias(True)
            gc.clip_to_rect(self.x, self.y, self.width, self.height)

            render = self._render_normal

            if selected_points is not None:
                gc.set_stroke_color(self.selected_color_)
                gc.set_line_width(self.line_width+10.0)
                gc.set_line_dash(self.selected_line_style_)
                render(gc, selected_points)

            if self.color_func is not None:
                # Existence of self.color_func overrides self.color.
                color_func = self.color_func
            else:
                color_func = lambda k: self.color_

            tmp = list(enumerate(line_points))
            # Note: the list is reversed for testing with _render_filled.
            for k, points in reversed(tmp):
                color = color_func(k)
                # Apply the alpha
                alpha = color[-1] if len(color) == 4 else 1
                color = color[:3] + (alpha * self.alpha,)
                gc.set_stroke_color(color)
                gc.set_line_width(self.line_width)
                gc.set_line_dash(self.line_style_)
                render(gc, points)

            # Draw the default axes, if necessary
            self._draw_default_axes(gc)

    def _render_normal(self, gc, points):
        for ary in points:
            if len(ary) > 0:
                gc.begin_path()
                gc.lines(ary)
                gc.stroke_path()
        return


    def _render_icon(self, gc, x, y, width, height):
        with gc:
            gc.set_stroke_color(self.color_)
            gc.set_line_width(self.line_width)
            gc.set_line_dash(self.line_style_)
            gc.set_antialias(0)
            gc.move_to(x, y+height/2)
            gc.line_to(x+width, y+height/2)
            gc.stroke_path()


    def _alpha_changed(self):
        self.invalidate_draw()
        self.request_redraw()
        return

    def _color_changed(self):
        self.invalidate_draw()
        self.request_redraw()
        return

    def _line_style_changed(self):
        self.invalidate_draw()
        self.request_redraw()
        return

    def _line_width_changed(self):
        self.invalidate_draw()
        self.request_redraw()
        return

    def _amplitude_changed(self):
        self.value.data_changed = True
        self.invalidate_draw()
        self.request_redraw()
        return

    def __getstate__(self):
        state = super(MultiLinePlot,self).__getstate__()
        for key in ['traits_view']:
            if state.has_key(key):
                del state[key]

        return state

########NEW FILE########
__FILENAME__ = aligned_container_overlay
"""An overlay that aligns itself to the plot
"""

from traits.api import Enum, Any

from container_overlay import ContainerOverlay

class AlignedContainerOverlay(ContainerOverlay):
    """ Container overlay that aligns itself to the plot

    This overlay takes an alignment which specifies which corner of its
    container it should align itself with ("ur", "ul", "ll", or "lr").
    For tooltip or customizable behaviour, an alternative_position trait
    can be specified which gives the point to draw the component at, and
    the align is use to lay the container out relative to that position.
    """
    # XXX allow 'c' for center as an alignment option?
    # XXX make this alignment stuff a Container subclass?  A generic mixin?

    # Alignment of the text in the box:
    #
    # * "ur": upper right
    # * "ul": upper left
    # * "ll": lower left
    # * "lr": lower right
    align = Enum("ur", "ul", "ll", "lr")

    # This allows subclasses to specify an alternate position for the root
    # of the text box.  Must be a sequence of length 2.
    alternate_position = Any

    def overlay(self, other, gc, view_bounds, mode):
        self._compute_position(other)
        self.draw(gc, view_bounds, mode)

    # XXX should this method really be _do_layout?

    def _compute_position(self, component):
        """ Given the alignment and size of the overlay, position it.
        """
        if self.layout_needed:
            self.do_layout()
        valign, halign = self.align

        if self.alternate_position:
            x, y = self.alternate_position
            if valign == "u":
                self.outer_y = component.y + y
            else:
                self.outer_y2 = component.y + y

            if halign == "r":
                self.outer_x = component.x + x
            else:
                self.outer_x2 = component.x + x
        else:
            if valign == "u":
                self.outer_y2 = component.y2
            else:
                self.outer_y = component.y

            if halign == "r":
                self.outer_x2 = component.x2
            else:
                self.outer_x = component.x

            # attempt to get the box entirely within the component
            # (prefer expanding to top-right if we cover entire component)
            if self.x2 > component.x2:
                self.x2 = component.x2
            if self.y2 > component.y2:
                self.y2 = component.y2
            if self.x < component.x:
                self.x = component.x
            if self.y < component.y:
                self.y = component.y

########NEW FILE########
__FILENAME__ = api
from databox import DataBox
from container_overlay import ContainerOverlay
from aligned_container_overlay import AlignedContainerOverlay
from text_grid_overlay import TextGridOverlay
from simple_inspector_overlay import SimpleInspectorOverlay, basic_formatter, \
    datetime_formatter, date_formatter, time_formatter

########NEW FILE########
__FILENAME__ = container_overlay
"""Plot overlay which is an Enable Container

This module provides an Enable Container subclass which renders itself
into the overlay of a plot.  This allows the easy use of standard Enable
components in plot overlays.
"""

from traits.api import Instance
from enable.api import Container, Component
from chaco.api import PlotComponent


class ContainerOverlay(Container, PlotComponent):
    """ Container which is also a Chaco plot overlay

    Since this is an Enable container, any Components that it contains will
    be rendered into the overlay layer of the plot.
    """
    # XXX this works, but I'm not sure that it's quite right.

    # The component that this object overlays. This can be None. By default, if
    # this object is called to draw(), it tries to render onto this component.
    component = Instance(Component)

    draw_layer = "overlay"

    # The background color (overrides PlotComponent).
    # Typically, an overlay does not render a background.
    bgcolor = "transparent"

    unified_draw = True

    auto_size = True

    def overlay(self, other, gc, view_bounds, mode):
        self.draw(gc, view_bounds, mode)

    def _request_redraw(self):
        if self.component is not None:
            self.component.request_redraw()
        super(ContainerOverlay, self)._request_redraw()

########NEW FILE########
__FILENAME__ = coordinate_line_overlay
""" An overlay for drawing "infinite" vertical and horizontal lines.

This module defines the CoordinateLineOverlay class, a Chaco overlay
for Plot (and similar) objects.
"""

from __future__ import with_statement

from traits.api import Instance, Float, Array
from enable.api import black_color_trait, LineStyle, Component
from chaco.api import AbstractOverlay


class CoordinateLineOverlay(AbstractOverlay):

    # The data coordinates of the lines to be drawn perpendicular to the
    # index axis.
    index_data = Array

    # The data coordinates of the lines to be drawn perpendicular to the
    # value axis.
    value_data = Array

    # Width of the lines.
    line_width = Float(1.0)

    # Color of the lines.
    color = black_color_trait

    # Style of the lines ('solid', 'dash' or 'dot').
    line_style = LineStyle

    # The component that this tool overlays.  This must be a Component with
    # the following attributes:
    #     x, y, x2, y2
    #         The screen coordinates of the corners of the component.
    #     orientation ('h' or 'v')
    #         The orientation of the component, either horizontal or vertical.
    #         This is the orientation of the index axis.
    #     index_mapper
    #         index_mapper.map_screen maps `index_data` to screen coordinates.
    #     value_mapper
    #         value_mapper.map_screen maps `value_data` to screen coordinates.
    # Typically this will be a Plot instance.
    component = Instance(Component)

    #----------------------------------------------------------------------
    # Override AbstractOverlay methods
    #----------------------------------------------------------------------

    def overlay(self, component, gc, view_bounds, mode="normal"):

        comp = self.component
        x_pts = comp.index_mapper.map_screen(self.index_data)
        y_pts = comp.value_mapper.map_screen(self.value_data)
        if comp.orientation == "v":
            x_pts, y_pts = y_pts, x_pts

        with gc:
            # Set the line color and style parameters.
            gc.set_stroke_color(self.color_)
            gc.set_line_width(self.line_width)
            gc.set_line_dash(self.line_style_)

            # Draw the vertical lines.
            for screen_x in x_pts:
                self._draw_vertical_line(gc, screen_x)

            # Draw the horizontal lines.
            for screen_y in y_pts:
                self._draw_horizontal_line(gc, screen_y)

    #----------------------------------------------------------------------
    # Private methods
    #----------------------------------------------------------------------

    def _draw_vertical_line(self, gc, screen_x):
        if screen_x < self.component.x or screen_x > self.component.x2:
            return
        gc.move_to(screen_x, self.component.y)
        gc.line_to(screen_x, self.component.y2)
        gc.stroke_path()

    def _draw_horizontal_line(self, gc, screen_y):
        if screen_y < self.component.y or screen_y > self.component.y2:
            return
        gc.move_to(self.component.x, screen_y,)
        gc.line_to(self.component.x2, screen_y)
        gc.stroke_path()

########NEW FILE########
__FILENAME__ = databox

from __future__ import with_statement

from traits.api import (Bool, Enum, Float, Int, CList, Property, Trait,
        on_trait_change)
from enable.api import ColorTrait
from chaco.api import AbstractOverlay


class DataBox(AbstractOverlay):
    """
    An overlay that is a box defined by data space coordinates.  This can be
    used as a base class for various kinds of zoom boxes.  Unlike the
    "momentary" zoom box drawn for the ZoomTool, a ZoomBox is a more permanent
    visual component.
    """

    data_position = Property
    data_bounds = Property

    # Should the zoom box stay attached to the image or to the screen if the
    # component moves underneath it?
    # TODO: This basically works, but the problem is that it responds to both
    # changes in X and Y independently.  The DataRange2D needs to be updated
    # to reflect changes from its two DataRange1Ds.  The PanTool and ZoomTool
    # need to be improved that they change both dimensions at once.
    affinity = Enum("image", "screen")

    #-------------------------------------------------------------------------
    # Appearance properties (for Box mode)
    #-------------------------------------------------------------------------

    # The color of the selection box.
    color = ColorTrait("lightskyblue")

    # The alpha value to apply to **color** when filling in the selection
    # region.  Because it is almost certainly useless to have an opaque zoom
    # rectangle, but it's also extremely useful to be able to use the normal
    # named colors from Enable, this attribute allows the specification of a
    # separate alpha value that replaces the alpha value of **color** at draw
    # time.
    alpha = Trait(0.3, None, Float)

    # The color of the outside selection rectangle.
    border_color = ColorTrait("dodgerblue")

    # The thickness of selection rectangle border.
    border_size = Int(1)

    #-------------------------------------------------------------------------
    # Private Traits
    #-------------------------------------------------------------------------

    _data_position = CList([0,0])
    _data_bounds = CList([0,0])
    _position_valid = False
    _bounds_valid = False

    # Are we in the middle of an event handler or a property setter
    _updating = Bool(False)

    def __init__(self, *args, **kw):
        super(DataBox, self).__init__(*args, **kw)
        if hasattr(self.component, "range2d"):
            self.component.range2d._xrange.on_trait_change(self.my_component_moved, "updated")
            self.component.range2d._yrange.on_trait_change(self.my_component_moved, "updated")
        elif hasattr(self.component, "x_mapper") and hasattr(self.component, "y_mapper"):
            self.component.x_mapper.range.on_trait_change(self.my_component_moved, "updated")
            self.component.y_mapper.range.on_trait_change(self.my_component_moved, "updated")
        else:
            raise RuntimeError("DataBox cannot find a suitable mapper on its component.")
        self.component.on_trait_change(self.my_component_resized, "bounds")
        self.component.on_trait_change(self.my_component_resized, "bounds_items")


    def overlay(self, component, gc, view_bounds=None, mode="normal"):
        if not self._position_valid:
            tmp = self.component.map_screen([self._data_position])
            if len(tmp.shape) == 2:
                tmp = tmp[0]
            self._updating = True
            self.position = tmp
            self._updating = False
            self._position_valid = True

        if not self._bounds_valid:
            data_x2 = self._data_position[0] + self._data_bounds[0]
            data_y2 = self._data_position[1] + self._data_bounds[1]
            tmp = self.component.map_screen((data_x2, data_y2))
            if len(tmp.shape) == 2:
                tmp = tmp[0]
            x2, y2 = tmp
            x, y = self.position
            self._updating = True
            self.bounds = [x2 - x, y2 - y]
            self._updating = False
            self._bounds_valid = True

        with gc:
            gc.set_antialias(0)
            gc.set_line_width(self.border_size)
            gc.set_stroke_color(self.border_color_)
            gc.clip_to_rect(component.x, component.y, component.width, component.height)
            rect = self.position + self.bounds

            if self.color != "transparent":
                if self.alpha:
                    color = list(self.color_)
                    if len(color) == 4:
                        color[3] = self.alpha
                    else:
                        color += [self.alpha]
                else:
                    color = self.color_
                gc.set_fill_color(color)
                gc.rect(*rect)
                gc.draw_path()
            else:
                gc.rect(*rect)
                gc.stroke_path()

        return

    #-------------------------------------------------------------------------
    # Property setters/getters, event handlers
    #-------------------------------------------------------------------------

    def _get_data_position(self):
        return self._data_position

    def _set_data_position(self, val):
        self._data_position = val
        self._position_valid = False
        self.trait_property_changed("data_position", self._data_position)

    def _get_data_bounds(self):
        return self._data_bounds

    def _set_data_bounds(self, val):
        self._data_bounds = val
        self._bounds_valid = False
        self.trait_property_changed("data_bounds", self._data_bounds)

    @on_trait_change('position,position_items')
    def _update_position(self):
        if self._updating:
            return
        tmp = self.component.map_data(self.position)
        if len(tmp.shape) == 2:
            tmp = tmp.T[0]
        self._data_position = tmp
        self.trait_property_changed("data_position", self._data_position)

    @on_trait_change('bounds,bounds_items')
    def _update_bounds(self):
        if self._updating:
            return
        data_x2, data_y2 = self.component.map_data((self.x2, self.y2))
        data_pos = self._data_position
        self._data_bounds = [data_x2 - data_pos[0], data_y2 - data_pos[1]]
        self.trait_property_changed("data_bounds", self._data_bounds)

    def my_component_moved(self):
        if self.affinity == "screen":
            # If we have screen affinity, then we need to take our current position
            # and map that back down into data coords
            self._update_position()
            self._update_bounds()
        self._bounds_valid = False
        self._position_valid = False

    def my_component_resized(self):
        self._bounds_valid = False
        self._position_valid = False




########NEW FILE########
__FILENAME__ = simple_inspector_overlay
"""A simple inspector overlay for plots

This module provides the SimpleInspectorOverlay for displaying
information gathered from an inspector tool in a TextGrid.  By default
it is configured to work with a SimpleInspectorTool.

The module also provides some helper factory functions for creating text
formatters for dictionary values.
"""

from numpy import array

from traits.api import Any, List, Callable, Enum, Bool

from text_grid_overlay import TextGridOverlay

def basic_formatter(key, decimals):
    """Create a basic '<key>: <value>' formatting function

    This factory creates a function that formats a specified key and with a
    numerical value from a dictionary into a string.

    Parameters
    ----------

    key
        The dictionary key to format.
    decimals
        The number of decimal places to show.

    Returns
    -------

    format
        A factory function that takes a dictionary and returns a string.
    """
    format_string = '%s: %%(%s).%df' % (key, key, decimals)
    def format(**kwargs):
        return format_string % kwargs
    return format

def datetime_formatter(key, time_format='%Y/%m/%d %H:%M:%S'):
    """Create a datetime formatting function

    This factory creates a function that formats a specified key and with a
    timestamp value from a dictionary into a string.

    Parameters
    ----------

    key
        The dictionary key to format.  The corresponding value should be a
        timestamp.
    time_format
        A format string suitable for strftime().

    Returns
    -------

    format
        A factory function that takes a dictionary and returns a string.
    """
    import datetime
    def format(**kwargs):
        dt = datetime.datetime.fromtimestamp(kwargs[key])
        return key+': '+dt.strftime(time_format)
    return format

def time_formatter(key):
    """Create a time formatting function

    This factory creates a function that formats a specified key and with a
    timestamp value from a dictionary into a 'HH:MM:SS' format string.

    Parameters
    ----------

    key
        The dictionary key to format.  The corresponding value should be a
        timestamp.

    Returns
    -------

    format
        A factory function that takes a dictionary and returns a string.
    """
    return datetime_formatter(key, time_format='%H:%M:%S')

def date_formatter(key):
    """Create a date formatting function

    This factory creates a function that formats a specified key and with a
    timestamp value from a dictionary into a 'yyyy/mm/dd' format string.

    Parameters
    ----------

    key
        The dictionary key to format.  The corresponding value should be a
        timestamp.

    Returns
    -------

    format
        A factory function that takes a dictionary and returns a string.
    """
    return datetime_formatter(key, time_format='%Y/%m/%d')


class SimpleInspectorOverlay(TextGridOverlay):
    """ Simple inspector overlay for plots

    This is a simple overlay that listens for new_value events on a
    SimpleInspectorTool and displays formatted values in a grid.

    By default this displays the 'x' and 'y' values provided by the
    SimpleInspectorTool, but instances can provide a field_formatters
    trait which is a list of lists of callables which extract values
    from a dictionary and formats them.  Each callable corresponds to a
    cell in the underlying TextGrid component.

    Although by default this works with the SimpleInspectorTool, with
    appropriate field_formatters this class can be used with any inspector
    tool that follows the same API.
    """
    # XXX We should probably refactor this into a BaseInspectorOverlay
    # which handles the visibility and basic event handling, and smaller
    # version of this class which handles inserting values into a text grid

    # the inspector that I am listening to.  This should have a new_value
    # event and a visible trait for me to listen to.
    inspector = Any

    # fields to display
    field_formatters = List(List(Callable))

    # Anchor the text to the mouse?  (If False, then the text is in one of the
    # corners.)  Use the **align** trait to determine which corner.
    tooltip_mode = Bool(False)

    # The default state of the overlay is visible.
    visible = True

    # Whether the overlay should auto-hide and auto-show based on the
    # tool's location, or whether it should be forced to be hidden or visible.
    visibility = Enum("auto", True, False)

    #########################################################################
    # Traits Handlers
    #########################################################################

    def _field_formatters_default(self):
        return [[basic_formatter('x', 2)], [basic_formatter('y', 2)]]

    def _new_value_updated(self, event):
        if event is None:
            self.text_grid = array()
            if self.visibility == "auto":
                self.visibility = False
        elif self.visibility == "auto":
            self.visible = True

        if self.tooltip_mode:
            self.alternate_position = self.inspector.last_mouse_position

        d = event
        text = []
        self.text_grid.string_array = array([[formatter(**d) for formatter in row]
            for row in self.field_formatters])

        self.text_grid.request_redraw()

    def _visible_changed(self):
        if self.component:
            self.request_redraw()

    def _inspector_changed(self, old, new):
        if old:
            old.on_trait_event(self._new_value_updated, 'new_value', remove=True)
            old.on_trait_change(self._tool_visible_changed, "visible", remove=True)
        if new:
            new.on_trait_event(self._new_value_updated, 'new_value')
            new.on_trait_change(self._tool_visible_changed, "visible")
            self._tool_visible_changed()

    def _tool_visible_changed(self):
        self.visibility = self.inspector.visible
        if self.visibility != "auto":
            self.visible = self.visibility


########NEW FILE########
__FILENAME__ = text_grid_overlay
""" An overlay containing a TextGrid
"""

from traits.api import Instance
from enable.text_grid import TextGrid

from aligned_container_overlay import AlignedContainerOverlay

class TextGridOverlay(AlignedContainerOverlay):
    """ Overlay for plots containing a TextGrid

    This subclass of AlignedContainerOverlay has a TextGrid which it
    displays.  Subclasses or users are responsible for the content and
    formatting of the TextGrid.
    """
    # The text grid component we contain.
    text_grid = Instance(TextGrid)

    # XXX put some delegated traits for the text_grid here?

    def _text_grid_changed(self, old, new):
        if old is not None:
            self.remove(old)
        if new is not None:
            self.add(new)

    def _text_grid_default(self):
        text_grid = TextGrid(font='modern 12', cell_border_width=0)
        self.add(text_grid)
        return text_grid

########NEW FILE########
__FILENAME__ = pdf_graphics_context

# Major library imports
import warnings

try:
# PDF imports from reportlab
    from reportlab.pdfgen.canvas import Canvas
    from reportlab.lib.pagesizes import letter, A4, landscape
    from reportlab.lib.units import inch, cm, mm, pica

except ImportError:
    Canvas = None
    PdfPlotGraphicsContext = None

from kiva.pdf import GraphicsContext


PAGE_DPI = 72.0

PAGE_SIZE_MAP = {
    "letter": letter,
    "A4": A4,
    "landscape_letter": landscape(letter),
    "landscape_A4": landscape(A4)
}

UNITS_MAP = {
    "inch": inch,
    "cm": cm,
    "mm": mm,
    "pica": pica,
}

if Canvas is not None:
    class PdfPlotGraphicsContext(GraphicsContext):
        """ A convenience class for rendering PlotComponents onto PDF
        """

        # The name of the file that this graphics context will use when
        # gc.save() is called without a filename being supplied.
        filename = "saved_plot.pdf"

        # The page size of the generated PDF
        pagesize = "letter"  # Enum("letter", "A4")

        # A tuple (x, y, width, height) specifying the box into which the plot
        # should be rendered.  **x** and **y** correspond to the lower-left
        # hand coordinates of the box in the coordinates of the page
        # (i.e. 0,0 is at the lower left).  **width** and **height** can be
        # positive or negative;
        # if they are positive, they are interpreted as distances from (x,y);
        # if they are negative, they are interpreted as distances from the
        # right and top of the page, respectively.
        dest_box = (0.5, 0.5, -0.5, -0.5)

        # The units of the values in dest_box
        dest_box_units = "inch"   # Enum("inch", "cm", "mm", "pica")

        def __init__(self, pdf_canvas=None, filename=None, pagesize=None,
                     dest_box=None, dest_box_units=None):
            if filename:
                self.filename = filename
            if pagesize:
                self.pagesize = pagesize
            if dest_box:
                self.dest_box = dest_box
            if dest_box_units:
                self.dest_box_units = dest_box_units

            if pdf_canvas is None:
                pdf_canvas = self._create_new_canvas()

            GraphicsContext.__init__(self, pdf_canvas)

        def add_page(self):
            """ Adds a new page to the PDF canvas and makes that the current
            drawing target.
            """
            if self.gc is None:
                warnings.warn("PDF Canvas has not been created yet.")
                return

            # Add the new page
            self.gc.showPage()

            # We'll need to call _initialize_page() before drawing
            self._page_initialized = False

        def render_component(self, component, container_coords=False,
                             halign="center", valign="top"):
            """ Erases the current contents of the graphics context and renders
            the given component at the maximum possible scaling while
            preserving aspect ratio.

            Parameters
            ----------
            component : Component
                The component to be rendered.
            container_coords : Boolean
                Whether to use coordinates of the component's container
            halign : "center", "left", "right"
                Determines the position of the component if it is narrower than
                the graphics context area (after scaling)
            valign : "center", "top", "bottom"
                Determiens the position of the component if it is shorter than
                the graphics context area (after scaling)

            Description
            -----------
            If *container_coords* is False, then the (0,0) coordinate of this
            graphics context corresponds to the lower-left corner of the
            component's **outer_bounds**. If *container_coords* is True, then
            the method draws the component as it appears inside its container,
            i.e., it treats (0, 0) of the graphics context as the lower-left
            corner of the container's outer bounds.
            """

            if not self._page_initialized:
                # Make sure the origin is set up as before.
                self._initialize_page(self.gc)

            x, y = component.outer_position
            if container_coords:
                width, height = component.container.bounds
            else:
                x = -x
                y = -y
                width, height = component.outer_bounds

            # Compute the correct scaling to fit the component into the
            # available canvas space while preserving aspect ratio.
            units = UNITS_MAP[self.dest_box_units]
            pagesize = PAGE_SIZE_MAP[self.pagesize]

            full_page_width = pagesize[0]
            full_page_height = pagesize[1]
            page_offset_x = self.dest_box[0] * units
            page_offset_y = self.dest_box[1] * units
            page_width = self.dest_box[2] * units
            page_height = self.dest_box[3] * units

            if page_width < 0:
                page_width += full_page_width - page_offset_x
            if page_height < 0:
                page_height += full_page_height - page_offset_y

            aspect = float(width) / float(height)

            if aspect >= page_width / page_height:
                # We are limited in width, so use widths to compute the scale
                # factor between pixels to page units.  (We want square pixels,
                # so we re-use this scale for the vertical dimension.)
                scale = float(page_width) / float(width)
                trans_width = page_width

                trans_height = height * scale
                trans_x = x * scale
                trans_y = y * scale
                if valign == "top":
                    trans_y += page_height - trans_height
                elif valign == "center":
                    trans_y += (page_height - trans_height) / 2.0

            else:
                # We are limited in height
                scale = page_height / height
                trans_height = page_height

                trans_width = width * scale
                trans_x = x * scale
                trans_y = y * scale
                if halign == "right":
                    trans_x += page_width - trans_width
                elif halign == "center":
                    trans_x += (page_width - trans_width) / 2.0

            self.translate_ctm(trans_x, trans_y)
            self.scale_ctm(scale, scale)
            self.clip_to_rect(-x, -y, width, height)
            old_bb_setting = component.use_backbuffer
            component.use_backbuffer = False
            component.draw(self, view_bounds=(0, 0, width, height))
            component.use_backbuffer = old_bb_setting
            return

        def save(self, filename=None):
            self.gc.save()

        def _create_new_canvas(self):
            """ Create the PDF canvas context.
            """
            x, y, w, h, = self._get_bounding_box()
            if w < 0 or h < 0:
                self.gc = None
                return

            pagesize = PAGE_SIZE_MAP[self.pagesize]
            gc = Canvas(filename=self.filename, pagesize=pagesize)
            self._initialize_page(gc)

            return gc

        def _get_bounding_box(self):
            """ Compute the bounding rect of a page.
            """
            pagesize = PAGE_SIZE_MAP[self.pagesize]
            units = UNITS_MAP[self.dest_box_units]

            x = self.dest_box[0] * units
            y = self.dest_box[1] * units
            w = self.dest_box[2] * units
            h = self.dest_box[3] * units

            if w < 0:
                w += pagesize[0] * units * inch / PAGE_DPI
            if h < 0:
                h += pagesize[1] * units * inch / PAGE_DPI

            if w < 0 or h < 0:
                warnings.warn("Margins exceed page dimensions.")

            return x, y, w, h

        def _initialize_page(self, gc):
            """ Make sure the origin is set to something consistent.
            """
            x, y, w, h, = self._get_bounding_box()

            gc.translate(x, y)

            path = gc.beginPath()
            path.rect(0, 0, w, h)
            gc.clipPath(path, stroke=0, fill=0)

            self._page_initialized = True

########NEW FILE########
__FILENAME__ = plot
""" Defines the Plot class.
"""
# Major library imports
import itertools
import warnings
from numpy import arange, array, ndarray, linspace
from types import FunctionType

# Enthought library imports
from traits.api import Delegate, Dict, Instance, Int, List, Property, Str

# Local, relative imports
from abstract_colormap import AbstractColormap
from abstract_data_source import AbstractDataSource
from abstract_plot_data import AbstractPlotData
from array_data_source import ArrayDataSource
from array_plot_data import ArrayPlotData
from base_xy_plot import BaseXYPlot
from barplot import BarPlot
from candle_plot import CandlePlot
from colormapped_scatterplot import ColormappedScatterPlot
from contour_line_plot import ContourLinePlot
from contour_poly_plot import ContourPolyPlot
from cmap_image_plot import CMapImagePlot
from data_range_1d import DataRange1D
from data_view import DataView
from default_colormaps import Spectral
from grid_data_source import GridDataSource
from grid_mapper import GridMapper
from image_data import ImageData
from image_plot import ImagePlot
from legend import Legend
from lineplot import LinePlot
from linear_mapper import LinearMapper
from log_mapper import LogMapper
from plot_label import PlotLabel
from polygon_plot import PolygonPlot
from scatterplot import ScatterPlot
from filled_line_plot import FilledLinePlot
from quiverplot import QuiverPlot




#-----------------------------------------------------------------------------
# The Plot class
#-----------------------------------------------------------------------------

class Plot(DataView):
    """ Represents a correlated set of data, renderers, and axes in a single
    screen region.

    A Plot can reference an arbitrary amount of data and can have an
    unlimited number of renderers on it, but it has a single X-axis and a
    single Y-axis for all of its associated data. Therefore, there is a single
    range in X and Y, although there can be many different data series. A Plot
    also has a single set of grids and a single background layer for all of its
    renderers.  It cannot be split horizontally or vertically; to do so,
    create a VPlotContainer or HPlotContainer and put the Plots inside those.
    Plots can be overlaid as well; be sure to set the **bgcolor** of the
    overlaying plots to "none" or "transparent".

    A Plot consists of composable sub-plots.  Each of these is created
    or destroyed using the plot() or delplot() methods.  Every time that
    new data is used to drive these sub-plots, it is added to the Plot's
    list of data and data sources.  Data sources are reused whenever
    possible; in order to have the same actual array drive two de-coupled
    data sources, create those data sources before handing them to the Plot.
    """

    #------------------------------------------------------------------------
    # Data-related traits
    #------------------------------------------------------------------------

    # The PlotData instance that drives this plot.
    data = Instance(AbstractPlotData)

    # Mapping of data names from self.data to their respective datasources.
    datasources = Dict(Str, Instance(AbstractDataSource))

    #------------------------------------------------------------------------
    # General plotting traits
    #------------------------------------------------------------------------

    # Mapping of plot names to *lists* of plot renderers.
    plots = Dict(Str, List)

    # The default index to use when adding new subplots.
    default_index = Instance(AbstractDataSource)

    # Optional mapper for the color axis.  Not instantiated until first use;
    # destroyed if no color plots are on the plot.
    color_mapper = Instance(AbstractColormap)

    # List of colors to cycle through when auto-coloring is requested. Picked
    # and ordered to be red-green color-blind friendly, though should not
    # be an issue for blue-yellow.
    auto_colors = List(["green", "lightgreen", "blue", "lightblue", "red",
                        "pink", "darkgray", "silver"])

    # index into auto_colors list
    _auto_color_idx = Int(-1)
    _auto_edge_color_idx = Int(-1)
    _auto_face_color_idx = Int(-1)

    # Mapping of renderer type string to renderer class
    # This can be overriden to customize what renderer type the Plot
    # will instantiate for its various plotting methods.
    renderer_map = Dict(dict(line = LinePlot,
                             bar = BarPlot,
                             scatter = ScatterPlot,
                             polygon = PolygonPlot,
                             filled_line = FilledLinePlot,
                             cmap_scatter = ColormappedScatterPlot,
                             img_plot = ImagePlot,
                             cmap_img_plot = CMapImagePlot,
                             contour_line_plot = ContourLinePlot,
                             contour_poly_plot = ContourPolyPlot,
                             candle = CandlePlot,
                             quiver = QuiverPlot,))

    #------------------------------------------------------------------------
    # Annotations and decorations
    #------------------------------------------------------------------------

    # The title of the plot.
    title = Property()

    # The font to use for the title.
    title_font = Property()

    # Convenience attribute for title.overlay_position; can be "top",
    # "bottom", "left", or "right".
    title_position = Property()

    # Use delegates to expose the other PlotLabel attributes of the plot title
    title_text = Delegate("_title", prefix="text", modify=True)
    title_color = Delegate("_title", prefix="color", modify=True)
    title_angle = Delegate("_title", prefix="angle", modify=True)

    # The PlotLabel object that contains the title.
    _title = Instance(PlotLabel)

    # The legend on the plot.
    legend = Instance(Legend)

    # Convenience attribute for legend.align; can be "ur", "ul", "ll", "lr".
    legend_alignment = Property

    #------------------------------------------------------------------------
    # Public methods
    #------------------------------------------------------------------------

    def __init__(self, data=None, **kwtraits):
        if 'origin' in kwtraits:
            self.default_origin = kwtraits.pop('origin')
        if "title" in kwtraits:
            title = kwtraits.pop("title")
        else:
            title = None
        super(Plot, self).__init__(**kwtraits)
        if data is not None:
            if isinstance(data, AbstractPlotData):
                self.data = data
            elif type(data) in (ndarray, tuple, list):
                self.data = ArrayPlotData(data)
            else:
                raise ValueError, "Don't know how to create PlotData for data" \
                                  "of type " + str(type(data))

        if not self._title:
            self._title = PlotLabel(font="swiss 16", visible=False,
                                   overlay_position="top", component=self)
        if title is not None:
            self.title = title

        if not self.legend:
            self.legend = Legend(visible=False, align="ur", error_icon="blank",
                                 padding=10, component=self)

        # ensure that we only get displayed once by new_window()
        self._plot_ui_info = None

        return

    def add_xy_plot(self, index_name, value_name, renderer_factory, name=None,
        origin=None, **kwds):
        """ Add a BaseXYPlot renderer subclass to this Plot.

        Parameters
        ----------
        index_name : str
            The name of the index datasource.
        value_name : str
            The name of the value datasource.
        renderer_factory : callable
            The callable that creates the renderer.
        name : string (optional)
            The name of the plot.  If None, then a default one is created
            (usually "plotNNN").
        origin : string (optional)
            Which corner the origin of this plot should occupy:
                "bottom left", "top left", "bottom right", "top right"
        **kwds :
            Additional keywords to pass to the factory.
        """
        if name is None:
            name = self._make_new_plot_name()
        if origin is None:
            origin = self.default_origin
        index = self._get_or_create_datasource(index_name)
        self.index_range.add(index)
        value = self._get_or_create_datasource(value_name)
        self.value_range.add(value)

        if self.index_scale == "linear":
            imap = LinearMapper(range=self.index_range)
        else:
            imap = LogMapper(range=self.index_range)
        if self.value_scale == "linear":
            vmap = LinearMapper(range=self.value_range)
        else:
            vmap = LogMapper(range=self.value_range)

        renderer = renderer_factory(
            index = index,
            value = value,
            index_mapper = imap,
            value_mapper = vmap,
            orientation = self.orientation,
            origin = origin,
            **kwds
        )
        self.add(renderer)
        self.plots[name] = [renderer]
        self.invalidate_and_redraw()
        return self.plots[name]

    def plot(self, data, type="line", name=None, index_scale="linear",
             value_scale="linear", origin=None, **styles):
        """ Adds a new sub-plot using the given data and plot style.

        Parameters
        ----------
        data : string, tuple(string), list(string)
            The data to be plotted. The type of plot and the number of
            arguments determines how the arguments are interpreted:

            one item: (line/scatter)
                The data is treated as the value and self.default_index is
                used as the index.  If **default_index** does not exist, one is
                created from arange(len(*data*))
            two or more items: (line/scatter)
                Interpreted as (index, value1, value2, ...).  Each index,value
                pair forms a new plot of the type specified.
            two items: (cmap_scatter)
                Interpreted as (value, color_values).  Uses **default_index**.
            three or more items: (cmap_scatter)
                Interpreted as (index, val1, color_val1, val2, color_val2, ...)

        type : comma-delimited string of "line", "scatter", "cmap_scatter"
            The types of plots to add.
        name : string
            The name of the plot.  If None, then a default one is created
            (usually "plotNNN").
        index_scale : string
            The type of scale to use for the index axis. If not "linear", then
            a log scale is used.
        value_scale : string
            The type of scale to use for the value axis. If not "linear", then
            a log scale is used.
        origin : string
            Which corner the origin of this plot should occupy:
                "bottom left", "top left", "bottom right", "top right"
        styles : series of keyword arguments
            attributes and values that apply to one or more of the
            plot types requested, e.g.,'line_color' or 'line_width'.

        Examples
        --------
        ::

            plot("my_data", type="line", name="myplot", color=lightblue)

            plot(("x-data", "y-data"), type="scatter")

            plot(("x", "y1", "y2", "y3"))

        Returns
        -------
        [renderers] -> list of renderers created in response to this call to plot()
        """
        if len(data) == 0:
            return

        if isinstance(data, basestring):
            data = (data,)

        self.index_scale = index_scale
        self.value_scale = value_scale

        # TODO: support lists of plot types
        plot_type = type
        if name is None:
            name = self._make_new_plot_name()
        if origin is None:
            origin = self.default_origin
            
        if plot_type in ("line", "scatter", "polygon", "bar", "filled_line"):
            # Tie data to the index range
            if len(data) == 1:
                if self.default_index is None:
                    # Create the default index based on the length of the first
                    # data series
                    value = self._get_or_create_datasource(data[0])
                    self.default_index = ArrayDataSource(arange(len(value.get_data())),
                                                         sort_order="none")
                    self.index_range.add(self.default_index)
                index = self.default_index
            else:
                index = self._get_or_create_datasource(data[0])
                if self.default_index is None:
                    self.default_index = index
                self.index_range.add(index)
                data = data[1:]

            # Tie data to the value_range and create the renderer for each data
            new_plots = []
            simple_plot_types = ("line", "scatter")
            for value_name in data:
                value = self._get_or_create_datasource(value_name)
                self.value_range.add(value)
                if plot_type in simple_plot_types:
                    cls = self.renderer_map[plot_type]
                    # handle auto-coloring request
                    if styles.get("color") == "auto":
                        self._auto_color_idx = \
                            (self._auto_color_idx + 1) % len(self.auto_colors)
                        styles["color"] = self.auto_colors[self._auto_color_idx]
                elif plot_type in ("polygon", "filled_line"):
                    cls = self.renderer_map[plot_type]
                    # handle auto-coloring request
                    if styles.get("edge_color") == "auto":
                        self._auto_edge_color_idx = \
                            (self._auto_edge_color_idx + 1) % len(self.auto_colors)
                        styles["edge_color"] = self.auto_colors[self._auto_edge_color_idx]
                    if styles.get("face_color") == "auto":
                        self._auto_face_color_idx = \
                            (self._auto_face_color_idx + 1) % len(self.auto_colors)
                        styles["face_color"] = self.auto_colors[self._auto_face_color_idx]
                elif plot_type == 'bar':
                    cls = self.renderer_map[plot_type]
                    # handle auto-coloring request
                    if styles.get("color") == "auto":
                        self._auto_color_idx = \
                            (self._auto_color_idx + 1) % len(self.auto_colors)
                        styles["fill_color"] = self.auto_colors[self._auto_color_idx]
                else:
                    raise ValueError("Unhandled plot type: " + plot_type)

                if self.index_scale == "linear":
                    imap = LinearMapper(range=self.index_range,
                                stretch_data=self.index_mapper.stretch_data)
                else:
                    imap = LogMapper(range=self.index_range,
                                stretch_data=self.index_mapper.stretch_data)
                if self.value_scale == "linear":
                    vmap = LinearMapper(range=self.value_range,
                                stretch_data=self.value_mapper.stretch_data)
                else:
                    vmap = LogMapper(range=self.value_range,
                                stretch_data=self.value_mapper.stretch_data)

                plot = cls(index=index,
                           value=value,
                           index_mapper=imap,
                           value_mapper=vmap,
                           orientation=self.orientation,
                           origin = origin,
                           **styles)
                
                self.add(plot)
                new_plots.append(plot)
            
            if plot_type == 'bar':
                # For bar plots, compute the ranges from the data to make the 
                # plot look clean. 
                
                def custom_index_func(data_low, data_high, margin, tight_bounds):
                    """ Compute custom bounds of the plot along index (in 
                    data space).
                    """
                    bar_width = styles.get('bar_width', cls().bar_width)
                    plot_low = data_low - bar_width
                    plot_high = data_high + bar_width
                    return plot_low, plot_high
                
                if self.index_range.bounds_func is None:
                    self.index_range.bounds_func = custom_index_func
                        
                def custom_value_func(data_low, data_high, margin, tight_bounds):
                    """ Compute custom bounds of the plot along value (in 
                    data space).
                    """
                    plot_low = data_low - (data_high-data_low)*0.1
                    plot_high = data_high + (data_high-data_low)*0.1
                    return plot_low, plot_high
                
                if self.value_range.bounds_func is None:    
                    self.value_range.bounds_func = custom_value_func
                
                self.index_range.tight_bounds = False
                self.value_range.tight_bounds = False
                self.index_range.refresh()
                self.value_range.refresh()

            self.plots[name] = new_plots
            
        elif plot_type == "cmap_scatter":
            if len(data) != 3:
                raise ValueError("Colormapped scatter plots require (index, value, color) data")
            else:
                index = self._get_or_create_datasource(data[0])
                if self.default_index is None:
                    self.default_index = index
                self.index_range.add(index)
                value = self._get_or_create_datasource(data[1])
                self.value_range.add(value)
                color = self._get_or_create_datasource(data[2])
                if not styles.has_key("color_mapper"):
                    raise ValueError("Scalar 2D data requires a color_mapper.")

                colormap = styles.pop("color_mapper", None)

                if self.color_mapper is not None and self.color_mapper.range is not None:
                    color_range = self.color_mapper.range
                else:
                    color_range = DataRange1D()

                if isinstance(colormap, AbstractColormap):
                    self.color_mapper = colormap
                    if colormap.range is None:
                        color_range.add(color)
                        colormap.range = color_range

                elif callable(colormap):
                    color_range.add(color)
                    self.color_mapper = colormap(color_range)
                else:
                    raise ValueError("Unexpected colormap %r in plot()." % colormap)

                if self.index_scale == "linear":
                    imap = LinearMapper(range=self.index_range,
                                stretch_data=self.index_mapper.stretch_data)
                else:
                    imap = LogMapper(range=self.index_range,
                                stretch_data=self.index_mapper.stretch_data)
                if self.value_scale == "linear":
                    vmap = LinearMapper(range=self.value_range,
                                stretch_data=self.value_mapper.stretch_data)
                else:
                    vmap = LogMapper(range=self.value_range,
                                stretch_data=self.value_mapper.stretch_data)

                cls = self.renderer_map["cmap_scatter"]
                plot = cls(index=index,
                           index_mapper=imap,
                           value=value,
                           value_mapper=vmap,
                           color_data=color,
                           color_mapper=self.color_mapper,
                           orientation=self.orientation,
                           origin=origin,
                           **styles)
                self.add(plot)

            self.plots[name] = [plot]
        else:
            raise ValueError("Unknown plot type: " + plot_type)

        return self.plots[name]


    def img_plot(self, data, name=None, colormap=None,
                 xbounds=None, ybounds=None, origin=None, hide_grids=True, **styles):
        """ Adds image plots to this Plot object.

        If *data* has shape (N, M, 3) or (N, M, 4), then it is treated as RGB or
        RGBA (respectively) and *colormap* is ignored.

        If *data* is an array of floating-point data, then a colormap can
        be provided via the *colormap* argument, or the default of 'Spectral'
        will be used.

        *Data* should be in row-major order, so that xbounds corresponds to
        *data*'s second axis, and ybounds corresponds to the first axis.

        Parameters
        ----------
        data : string
            The name of the data array in self.plot_data
        name : string
            The name of the plot; if omitted, then a name is generated.
        xbounds, ybounds : string, tuple, or ndarray
            Bounds where this image resides. Bound may be: a) names of
            data in the plot data; b) tuples of (low, high) in data space,
            c) 1D arrays of values representing the pixel boundaries (must
            be 1 element larger than underlying data), or
            d) 2D arrays as obtained from a meshgrid operation
        origin : string
            Which corner the origin of this plot should occupy:
                "bottom left", "top left", "bottom right", "top right"
        hide_grids : bool, default True
            Whether or not to automatically hide the grid lines on the plot
        styles : series of keyword arguments
            Attributes and values that apply to one or more of the
            plot types requested, e.g.,'line_color' or 'line_width'.
        """
        if name is None:
            name = self._make_new_plot_name()
        if origin is None:
            origin = self.default_origin

        value = self._get_or_create_datasource(data)
        array_data = value.get_data()
        if len(array_data.shape) == 3:
            if array_data.shape[2] not in (3,4):
                raise ValueError("Image plots require color depth of 3 or 4.")
            cls = self.renderer_map["img_plot"]
            kwargs = dict(**styles)
        else:
            if colormap is None:
                if self.color_mapper is None:
                    colormap = Spectral(DataRange1D(value))
                else:
                    colormap = self.color_mapper
            elif isinstance(colormap, AbstractColormap):
                if colormap.range is None:
                    colormap.range = DataRange1D(value)
            else:
                colormap = colormap(DataRange1D(value))
            self.color_mapper = colormap
            cls = self.renderer_map["cmap_img_plot"]
            kwargs = dict(value_mapper=colormap, **styles)
        return self._create_2d_plot(cls, name, origin, xbounds, ybounds, value,
                                    hide_grids, **kwargs)


    def contour_plot(self, data, type="line", name=None, poly_cmap=None,
                     xbounds=None, ybounds=None, origin=None, hide_grids=True, **styles):
        """ Adds contour plots to this Plot object.

        Parameters
        ----------
        data : string
            The name of the data array in self.plot_data, which must be
            floating point data.
        type : comma-delimited string of "line", "poly"
            The type of contour plot to add. If the value is "poly"
            and no colormap is provided via the *poly_cmap* argument, then
            a default colormap of 'Spectral' is used.
        name : string
            The name of the plot; if omitted, then a name is generated.
        poly_cmap : string
            The name of the color-map function to call (in
            chaco.default_colormaps) or an AbstractColormap instance
            to use for contour poly plots (ignored for contour line plots)
        xbounds, ybounds : string, tuple, or ndarray
            Bounds where this image resides. Bound may be: a) names of
            data in the plot data; b) tuples of (low, high) in data space,
            c) 1D arrays of values representing the pixel boundaries (must
            be 1 element larger than underlying data), or
            d) 2D arrays as obtained from a meshgrid operation
        origin : string
            Which corner the origin of this plot should occupy:
                "bottom left", "top left", "bottom right", "top right"
        hide_grids : bool, default True
            Whether or not to automatically hide the grid lines on the plot
        styles : series of keyword arguments
            Attributes and values that apply to one or more of the
            plot types requested, e.g.,'line_color' or 'line_width'.
        """
        if name is None:
            name = self._make_new_plot_name()
        if origin is None:
            origin = self.default_origin

        value = self._get_or_create_datasource(data)
        if value.value_depth != 1:
            raise ValueError("Contour plots require 2D scalar field")
        if type == "line":
            cls = self.renderer_map["contour_line_plot"]
            kwargs = dict(**styles)
            # if colors is given as a factory func, use it to make a
            # concrete colormapper. Better way to do this?
            if "colors" in kwargs:
                cmap = kwargs["colors"]
                if isinstance(cmap, FunctionType):
                    kwargs["colors"] = cmap(DataRange1D(value))
                elif getattr(cmap, 'range', 'dummy') is None:
                    cmap.range = DataRange1D(value)
        elif type == "poly":
            if poly_cmap is None:
                poly_cmap = Spectral(DataRange1D(value))
            elif isinstance(poly_cmap, FunctionType):
                poly_cmap = poly_cmap(DataRange1D(value))
            elif getattr(poly_cmap, 'range', 'dummy') is None:
                poly_cmap.range = DataRange1D(value)
            cls = self.renderer_map["contour_poly_plot"]
            kwargs = dict(color_mapper=poly_cmap, **styles)
        else:
            raise ValueError("Unhandled contour plot type: " + type)

        return self._create_2d_plot(cls, name, origin, xbounds, ybounds, value,
                                    hide_grids, **kwargs)


    def _process_2d_bounds(self, bounds, array_data, axis):
        """Transform an arbitrary bounds definition into a linspace.

        Process all the ways the user could have defined the x- or y-bounds
        of a 2d plot and return a linspace between the lower and upper
        range of the bounds.

        Parameters
        ----------
        bounds : any
            User bounds definition

        array_data : 2D array
            The 2D plot data

        axis : int
            The axis along which the bounds are to be set
        """

        num_ticks = array_data.shape[axis] + 1

        if bounds is None:
            return arange(num_ticks)

        if type(bounds) is tuple:
            # create a linspace with the bounds limits
            return linspace(bounds[0], bounds[1], num_ticks)

        if type(bounds) is ndarray and len(bounds.shape) == 1:
            # bounds is 1D, but of the wrong size

            if len(bounds) != num_ticks:
                msg = ("1D bounds of an image plot needs to have 1 more "
                       "element than its corresponding data shape, because "
                       "they represent the locations of pixel boundaries.")
                raise ValueError(msg)
            else:
                return linspace(bounds[0], bounds[-1], num_ticks)

        if type(bounds) is ndarray and len(bounds.shape) == 2:
            # bounds is 2D, assumed to be a meshgrid
            # This is triggered when doing something like
            # >>> xbounds, ybounds = meshgrid(...)
            # >>> z = f(xbounds, ybounds)

            if bounds.shape != array_data.shape:
                msg = ("2D bounds of an image plot needs to have the same "
                       "shape as the underlying data, because "
                       "they are assumed to be generated from meshgrids.")
                raise ValueError(msg)
            else:
                if axis == 0: bounds = bounds[:,0]
                else: bounds = bounds[0,:]
                interval = bounds[1] - bounds[0]
                return linspace(bounds[0], bounds[-1]+interval, num_ticks)

        raise ValueError("bounds must be None, a tuple, an array, "
                         "or a PlotData name")


    def _create_2d_plot(self, cls, name, origin, xbounds, ybounds, value_ds,
                        hide_grids, **kwargs):
        if name is None:
            name = self._make_new_plot_name()
        if origin is None:
            origin = self.default_origin

        array_data = value_ds.get_data()

        # process bounds to get linspaces
        if isinstance(xbounds, basestring):
            xbounds = self._get_or_create_datasource(xbounds).get_data()

        xs = self._process_2d_bounds(xbounds, array_data, 1)

        if isinstance(ybounds, basestring):
            ybounds = self._get_or_create_datasource(ybounds).get_data()

        ys = self._process_2d_bounds(ybounds, array_data, 0)

        # Create the index and add its datasources to the appropriate ranges
        index = GridDataSource(xs, ys, sort_order=('ascending', 'ascending'))
        self.range2d.add(index)
        mapper = GridMapper(range=self.range2d,
                            stretch_data_x=self.x_mapper.stretch_data,
                            stretch_data_y=self.y_mapper.stretch_data)

        plot = cls(index=index,
                   value=value_ds,
                   index_mapper=mapper,
                   orientation=self.orientation,
                   origin=origin,
                   **kwargs)

        if hide_grids:
            self.x_grid.visible = False
            self.y_grid.visible = False

        self.add(plot)
        self.plots[name] = [plot]
        return self.plots[name]


    def candle_plot(self, data, name=None, value_scale="linear", origin=None,
                    **styles):
        """ Adds a new sub-plot using the given data and plot style.

        Parameters
        ----------
        data : list(string), tuple(string)
            The names of the data to be plotted in the ArrayDataSource.  The
            number of arguments determines how they are interpreted:

            (index, bar_min, bar_max)
                filled or outline-only bar extending from **bar_min** to
                **bar_max**

            (index, bar_min, center, bar_max)
                above, plus a center line of a different color at **center**

            (index, min, bar_min, bar_max, max)
                bar extending from **bar_min** to **bar_max**, with thin
                bars at **min** and **max** connected to the bar by a long
                stem

            (index, min, bar_min, center, bar_max, max)
                like above, plus a center line of a different color and
                configurable thickness at **center**

        name : string
            The name of the plot.  If None, then a default one is created.

        value_scale : string
            The type of scale to use for the value axis.  If not "linear",
            then a log scale is used.

        Styles
        ------
        These are all optional keyword arguments.

        bar_color : string, 3- or 4-tuple
            The fill color of the bar; defaults to "auto".
        bar_line_color : string, 3- or 4-tuple
            The color of the rectangular box forming the bar.
        stem_color : string, 3- or 4-tuple (default = bar_line_color)
            The color of the stems reaching from the bar to the min and
            max values.
        center_color : string, 3- or 4-tuple (default = bar_line_color)
            The color of the line drawn across the bar at the center values.
        line_width : int (default = 1)
            The thickness, in pixels, of the outline around the bar.
        stem_width : int (default = line_width)
            The thickness, in pixels, of the stem lines
        center_width : int (default = line_width)
            The width, in pixels, of the line drawn across the bar at the
            center values.
        end_cap : bool (default = True)
            Whether or not to draw bars at the min and max extents of the
            error bar.

        Returns
        -------
        [renderers] -> list of renderers created in response to this call.
        """
        if len(data) == 0:
            return
        self.value_scale = value_scale

        if name is None:
            name = self._make_new_plot_name()
        if origin is None:
            origin = self.default_origin

        # Create the datasources
        if len(data) == 3:
            index, bar_min, bar_max = map(self._get_or_create_datasource, data)
            self.value_range.add(bar_min, bar_max)
            center = None
            min = None
            max = None
        elif len(data) == 4:
            index, bar_min, center, bar_max = map(self._get_or_create_datasource, data)
            self.value_range.add(bar_min, center, bar_max)
            min = None
            max = None
        elif len(data) == 5:
            index, min, bar_min, bar_max, max = \
                            map(self._get_or_create_datasource, data)
            self.value_range.add(min, bar_min, bar_max, max)
            center = None
        elif len(data) == 6:
            index, min, bar_min, center, bar_max, max = \
                            map(self._get_or_create_datasource, data)
            self.value_range.add(min, bar_min, center, bar_max, max)
        self.index_range.add(index)

        if styles.get("bar_color") == "auto" or styles.get("color") == "auto":
            self._auto_color_idx = \
                (self._auto_color_idx + 1) % len(self.auto_colors)
            styles["color"] = self.auto_colors[self._auto_color_idx]

        if self.index_scale == "linear":
            imap = LinearMapper(range=self.index_range,
                        stretch_data=self.index_mapper.stretch_data)
        else:
            imap = LogMapper(range=self.index_range,
                        stretch_data=self.index_mapper.stretch_data)
        if self.value_scale == "linear":
            vmap = LinearMapper(range=self.value_range,
                        stretch_data=self.value_mapper.stretch_data)
        else:
            vmap = LogMapper(range=self.value_range,
                        stretch_data=self.value_mapper.stretch_data)

        cls = self.renderer_map["candle"]
        plot = cls(index = index,
                          min_values = min,
                          bar_min = bar_min,
                          center_values = center,
                          bar_max = bar_max,
                          max_values = max,
                          index_mapper = imap,
                          value_mapper = vmap,
                          orientation = self.orientation,
                          origin = self.origin,
                          **styles)
        self.add(plot)
        self.plots[name] = [plot]
        return [plot]

    def quiverplot(self, data, name=None, origin=None,
                    **styles):
        """ Adds a new sub-plot using the given data and plot style.

        Parameters
        ----------
        data : list(string), tuple(string)
            The names of the data to be plotted in the ArrayDataSource.  There
            is only one combination accepted by this function:

            (index, value, vectors)
                index and value together determine the start coordinates of
                each vector.  The vectors are an Nx2

        name : string
            The name of the plot.  If None, then a default one is created.

        origin : string
            Which corner the origin of this plot should occupy:
                "bottom left", "top left", "bottom right", "top right"

        Styles
        ------
        These are all optional keyword arguments.

        line_color : string (default = "black")
            The color of the arrows
        line_width : float (default = 1.0)
            The thickness, in pixels, of the arrows.
        arrow_size : int (default = 5)
            The length, in pixels, of the arrowhead

        Returns
        -------
        [renderers] -> list of renderers created in response to this call.
        """
        if name is None:
            name = self._make_new_plot_name()
        if origin is None:
            origin = self.default_origin

        index, value, vectors = map(self._get_or_create_datasource, data)

        self.index_range.add(index)
        self.value_range.add(value)

        imap = LinearMapper(range=self.index_range,
                            stretch_data=self.index_mapper.stretch_data)
        vmap = LinearMapper(range=self.value_range,
                            stretch_data=self.value_mapper.stretch_data)

        cls = self.renderer_map["quiver"]
        plot = cls(index = index,
                   value = value,
                   vectors = vectors,
                   index_mapper = imap,
                   value_mapper = vmap,
                   name = name,
                   origin = origin,
                   **styles
                   )
        self.add(plot)
        self.plots[name] = [plot]
        return [plot]        

    def delplot(self, *names):
        """ Removes the named sub-plots. """

        # This process involves removing the plots, then checking the index range
        # and value range for leftover datasources, and removing those if necessary.

        # Remove all the renderers from us (container) and create a set of the
        # datasources that we might have to remove from the ranges
        deleted_sources = set()
        for renderer in itertools.chain(*[self.plots.pop(name) for name in names]):
            self.remove(renderer)
            deleted_sources.add(renderer.index)
            deleted_sources.add(renderer.value)

        # Cull the candidate list of sources to remove by checking the other plots
        sources_in_use = set()
        for p in itertools.chain(*self.plots.values()):
                sources_in_use.add(p.index)
                sources_in_use.add(p.value)

        unused_sources = deleted_sources - sources_in_use - set([None])

        # Remove the unused sources from all ranges
        for source in unused_sources:
            if source.index_dimension == "scalar":
                # Try both index and range, it doesn't hurt
                self.index_range.remove(source)
                self.value_range.remove(source)
            elif source.index_dimension == "image":
                self.range2d.remove(source)
            else:
                warnings.warn("Couldn't remove datasource from datarange.")

        return

    def hideplot(self, *names):
        """ Convenience function to sets the named plots to be invisible.  Their
        renderers are not removed, and they are still in the list of plots.
        """
        for renderer in itertools.chain(*[self.plots[name] for name in names]):
            renderer.visible = False
        return

    def showplot(self, *names):
        """ Convenience function to sets the named plots to be visible.
        """
        for renderer in itertools.chain(*[self.plots[name] for name in names]):
            renderer.visible = True
        return

    def new_window(self, configure=False):
        """Convenience function that creates a window containing the Plot

        Don't call this if the plot is already displayed in a window.
        """
        from chaco.ui.plot_window import PlotWindow
        if self._plot_ui_info is None:
            if configure:
                self._plot_ui_info = PlotWindow(plot=self).configure_traits()
            else:
                self._plot_ui_info = PlotWindow(plot=self).edit_traits()
        return self._plot_ui_info

    #------------------------------------------------------------------------
    # Private methods
    #------------------------------------------------------------------------



    def _make_new_plot_name(self):
        """ Returns a string that is not already used as a plot title.
        """
        n = len(self.plots)
        plot_template = "plot%d"
        while 1:
            name = plot_template % n
            if name not in self.plots:
                break
            else:
                n += 1
        return name

    def _get_or_create_datasource(self, name):
        """ Returns the data source associated with the given name, or creates
        it if it doesn't exist.
        """

        if name not in self.datasources:
            data = self.data.get_data(name)

            if type(data) in (list, tuple):
                data = array(data)

            if isinstance(data, ndarray):
                if len(data.shape) == 1:
                    ds = ArrayDataSource(data, sort_order="none")
                elif len(data.shape) == 2:
                    ds = ImageData(data=data, value_depth=1)
                elif len(data.shape) == 3:
                    if data.shape[2] in (3,4):
                        ds = ImageData(data=data, value_depth=int(data.shape[2]))
                    else:
                        raise ValueError("Unhandled array shape in creating new plot: " \
                                         + str(data.shape))

            elif isinstance(data, AbstractDataSource):
                ds = data

            else:
                raise ValueError("Couldn't create datasource for data of type " + \
                                 str(type(data)))

            self.datasources[name] = ds

        return self.datasources[name]

    #------------------------------------------------------------------------
    # Event handlers
    #------------------------------------------------------------------------

    def _color_mapper_changed(self):
        for plist in self.plots.values():
            for plot in plist:
                plot.color_mapper = self.color_mapper
        self.invalidate_draw()

    def _data_changed(self, old, new):
        if old:
            old.on_trait_change(self._data_update_handler, "data_changed",
                                remove=True)
        if new:
            new.on_trait_change(self._data_update_handler, "data_changed")

    def _data_update_handler(self, name, event):
        # event should be a dict with keys "added", "removed", and "changed",
        # per the comments in AbstractPlotData.
        if "removed" in event:
            for name in event["removed"]:
                del self.datasources[name]

        if "added" in event:
            for name in event["added"]:
                self._get_or_create_datasource(name)

        if "changed" in event:
            for name in event["changed"]:
                if name in self.datasources:
                    source = self.datasources[name]
                    source.set_data(self.data.get_data(name))
                    
    def _plots_items_changed(self, event):
        if self.legend:
            self.legend.plots = self.plots

    def _index_scale_changed(self, old, new):
        if old is None: return
        if new == old: return
        if not self.range2d: return
        if self.index_scale == "linear":
            imap = LinearMapper(range=self.index_range,
                                screen_bounds=self.index_mapper.screen_bounds,
                                stretch_data=self.index_mapper.stretch_data)
        else:
            imap = LogMapper(range=self.index_range,
                             screen_bounds=self.index_mapper.screen_bounds,
                             stretch_data=self.index_mapper.stretch_data)
        self.index_mapper = imap
        for key in self.plots:
            for plot in self.plots[key]:
                if not isinstance(plot, BaseXYPlot):
                    raise ValueError("log scale only supported on XY plots")
                if self.index_scale == "linear":
                    imap = LinearMapper(range=plot.index_range,
                                screen_bounds=plot.index_mapper.screen_bounds,
                                stretch_data=self.index_mapper.stretch_data)
                else:
                    imap = LogMapper(range=plot.index_range,
                                screen_bounds=plot.index_mapper.screen_bounds,
                                stretch_data=self.index_mapper.stretch_data)
                plot.index_mapper = imap

    def _value_scale_changed(self, old, new):
        if old is None: return
        if new == old: return
        if not self.range2d: return
        if self.value_scale == "linear":
            vmap = LinearMapper(range=self.value_range,
                                screen_bounds=self.value_mapper.screen_bounds,
                                stretch_data=self.value_mapper.stretch_data)
        else:
            vmap = LogMapper(range=self.value_range,
                             screen_bounds=self.value_mapper.screen_bounds,
                                stretch_data=self.value_mapper.stretch_data)
        self.value_mapper = vmap
        for key in self.plots:
            for plot in self.plots[key]:
                if not isinstance(plot, BaseXYPlot):
                    raise ValueError("log scale only supported on XY plots")
                if self.value_scale == "linear":
                    vmap = LinearMapper(range=plot.value_range,
                                screen_bounds=plot.value_mapper.screen_bounds,
                                stretch_data=self.value_mapper.stretch_data)
                else:
                    vmap = LogMapper(range=plot.value_range,
                                screen_bounds=plot.value_mapper.screen_bounds,
                                stretch_data=self.value_mapper.stretch_data)
                plot.value_mapper = vmap

    def __title_changed(self, old, new):
        self._overlay_change_helper(old, new)

    def _legend_changed(self, old, new):
        self._overlay_change_helper(old, new)
        if new:
            new.plots = self.plots

    def _handle_range_changed(self, name, old, new):
        """ Overrides the DataView default behavior.

        Primarily changes how the list of renderers is looked up.
        """
        mapper = getattr(self, name+"_mapper")
        if mapper.range == old:
            mapper.range = new
        if old is not None:
            for datasource in old.sources[:]:
                old.remove(datasource)
                if new is not None:
                    new.add(datasource)
        range_name = name + "_range"
        for renderer in itertools.chain(*self.plots.values()):
            if hasattr(renderer, range_name):
                setattr(renderer, range_name, new)

    #------------------------------------------------------------------------
    # Property getters and setters
    #------------------------------------------------------------------------

    def _set_legend_alignment(self, align):
        if self.legend:
            self.legend.align = align

    def _get_legend_alignment(self):
        if self.legend:
            return self.legend.align
        else:
            return None

    def _set_title(self, text):
        self._title.text = text
        if text.strip() != "":
            self._title.visible = True
        else:
            self._title.visible = False

    def _get_title(self):
        return self._title.text

    def _set_title_position(self, pos):
        if self._title is not None:
            self._title.overlay_position = pos

    def _get_title_position(self):
        if self._title is not None:
            return self._title.overlay_position
        else:
            return None

    def _set_title_font(self, font):
        old_font = self._title.font
        self._title.font = font
        self.trait_property_changed("title_font", old_font, font)

    def _get_title_font(self):
        return self._title.font



########NEW FILE########
__FILENAME__ = plotscrollbar

from traits.api import Any, Enum, Int, Property, Trait

from enable.api import NativeScrollBar

class PlotScrollBar(NativeScrollBar):
    """
    A ScrollBar that can be wired up to anything with an xrange or yrange
    and which can be attached to a plot container.
    """

    # The axis corresponding to this scrollbar.
    axis = Enum("index", "value")

    # The renderer or Plot to attach this scrollbar to.  By default, this
    # is just self.component.
    plot = Property

    # The mapper for associated with the scrollbar. By default, this is the
    # mapper on **plot** that corresponds to **axis**.
    mapper = Property

    #------------------------------------------------------------------------
    # Private traits
    #------------------------------------------------------------------------

    # The value of the override plot to use, if any.  If None, then uses
    # self.component.
    _plot = Trait(None, Any)

    # The value of the override mapper to use, if any.  If None, then uses the
    # mapper on self.component.
    _mapper = Trait(None, Any)

    # Stores the index (0 or 1) corresponding to self.axis
    _axis_index = Trait(None, None, Int)


    #----------------------------------------------------------------------
    # Public methods
    #----------------------------------------------------------------------

    def force_data_update(self):
        """ This forces the scrollbar to recompute its range bounds.  This
        should be used if datasources are changed out on the range, or if
        the data ranges on existing datasources of the range are changed.
        """
        self._handle_dataspace_update()

    def overlay(self, component, gc, view_bounds=None, mode="default"):
        self.do_layout()
        self._draw_mainlayer(gc, view_bounds, "default")

    def _draw_plot(self, gc, view_bounds=None, mode="default"):
        self._draw_mainlayer(gc, view_bounds, "default")

    def _do_layout(self):
        if getattr(self.plot, "_layout_needed", False):
            self.plot.do_layout()
        axis = self._determine_axis()
        low, high = self.mapper.screen_bounds
        self.bounds[axis] = high - low
        self.position[axis] = low
        self._widget_moved = True

    def _get_abs_coords(self, x, y):
        if self.container is not None:
            return self.container.get_absolute_coords(x, y)
        else:
            return self.component.get_absolute_coords(x, y)

    #----------------------------------------------------------------------
    # Scrollbar
    #----------------------------------------------------------------------

    def _handle_dataspace_update(self):
        # This method reponds to changes from the dataspace side, e.g.
        # a change in the range bounds or the data bounds of the datasource.

        # Get the current datasource bounds
        range = self.mapper.range
        bounds_list = [source.get_bounds() for source in range.sources \
                       if source.get_size() > 0]
        mins, maxes = zip(*bounds_list)
        dmin = min(mins)
        dmax = max(maxes)

        #import pdb; pdb.set_trace()
        view = float(range.high - range.low)

        # Take into account the range's current low/high and the data bounds
        # to compute the total range
        totalmin = min(range.low, dmin)
        totalmax = max(range.high, dmax)

        # Compute the size available for the scrollbar to scroll in
        scrollrange = (totalmax - totalmin) - view
        if round(scrollrange/20.0) > 0.0:
            ticksize = scrollrange / round(scrollrange/20.0)
        else:
            ticksize = 1
        foo = (totalmin, totalmax, view, ticksize)
        print "scrollrange:", foo
        self.set(range = foo,
                 scroll_position = max(min(self.scroll_position, totalmax-view), totalmin),
                 trait_change_notify=False)
        self._scroll_updated = True
        self.request_redraw()
        return

    def _scroll_position_changed(self):
        super(PlotScrollBar, self)._scroll_position_changed()

        # Notify our range that we've changed
        range = self.mapper.range
        view_width = range.high - range.low
        new_scroll_pos = self.scroll_position
        range.set_bounds(new_scroll_pos, new_scroll_pos + view_width)
        return

    #----------------------------------------------------------------------
    # Event listeners
    #----------------------------------------------------------------------

    def _component_changed(self, old, new):
        # Check to see if we're currently overriding the value of self.component
        # in self.plot.  If so, then don't change the event listeners.
        if self._plot is not None:
            return
        if old is not None:
            self._modify_plot_listeners(old, "detach")
        if new is not None:
            self._modify_plot_listeners(new, "attach")
            self._update_mapper_listeners()
        return

    def __plot_changed(self, old, new):
        if old is not None:
            self._modify_plot_listeners(old, "detach")
        elif self.component is not None:
            # Remove listeners from self.component, if it exists
            self._modify_plot_listeners(self.component, "detach")
        if new is not None:
            self._modify_plot_listeners(new, "attach")
            self._update_mapper_listeners()
        elif self.component is not None:
            self._modify_plot_listeners(self.component, "attach")
            self._update_mapper_listeners()
        return

    def _modify_plot_listeners(self, plot, action="attach"):
        if action == "attach":
            remove=False
        else:
            remove=True
        plot.on_trait_change(self._component_bounds_handler,
                             "bounds", remove=remove)
        plot.on_trait_change(self._component_bounds_handler,
                             "bounds_items", remove=remove)
        plot.on_trait_change(self._component_pos_handler,
                             "position", remove=remove)
        plot.on_trait_change(self._component_pos_handler,
                             "position_items", remove=remove)
        return

    def _component_bounds_handler(self):
        self._handle_dataspace_update()
        self._widget_moved = True

    def _component_pos_handler(self):
        self._handle_dataspace_update()
        self._widget_moved = True

    def _update_mapper_listeners(self):
        #if self._mapper
        pass

    def _handle_mapper_updated(self):
        self._handle_dataspace_update()

    #------------------------------------------------------------------------
    # Property getter/setters
    #------------------------------------------------------------------------

    def _get_plot(self):
        if self._plot is not None:
            return self._plot
        else:
            return self.component

    def _set_plot(self, val):
        self._plot = val
        return

    def _get_mapper(self):
        if self._mapper is not None:
            return self._mapper
        else:
            return getattr(self.plot, self.axis + "_mapper")

    def _set_mapper(self, new_mapper):
        self._mapper = new_mapper
        return

    def _get_axis_index(self):
        if self._axis_index is None:
            return self._determine_axis()
        else:
            return self._axis_index

    def _set_axis_index(self, val):
        self._axis_index = val
        return

    #------------------------------------------------------------------------
    # Private methods
    #------------------------------------------------------------------------

    def _get_axis_coord(self, event, axis="index"):
        """ Returns the coordinate of the event along the axis of interest
        to this tool (or along the orthogonal axis, if axis="value").
        """
        event_pos = (event.x, event.y)
        if axis == "index":
            return event_pos[ self.axis_index ]
        else:
            return event_pos[ 1 - self.axis_index ]

    def _determine_axis(self):
        """ Determines whether the index of the coordinate along this tool's
        axis of interest is the first or second element of an (x,y) coordinate
        tuple.

        This method is only called if self._axis_index hasn't been set (or is
        None).
        """
        if self.axis == "index":
            if self.plot.orientation == "h":
                return 0
            else:
                return 1
        else:   # self.axis == "value"
            if self.plot.orientation == "h":
                return 1
            else:
                return 0

########NEW FILE########
__FILENAME__ = plot_canvas

# Enthought library imports
from enable.api import Canvas
from traits.api import Instance, Tuple

# Local, relative chaco imports
from plot_containers import DEFAULT_DRAWING_ORDER

class PlotCanvas(Canvas):
    """ The PlotCanvas is basically like Canvas, but we inherit some behaviors
    from PlotComponent as well.  Some methods are redefined in here to
    explicitly make sure we get the right dispatch order.
    """

    #-------------------------------------------------------------------------
    # Public traits
    #-------------------------------------------------------------------------

    # Default size to use for resizable components placed onto us.
    default_component_size = Tuple(200, 200)

    #-------------------------------------------------------------------------
    # Inherited traits
    #-------------------------------------------------------------------------

    # Explicitly use the Chaco drawing order instead of the Enable one
    draw_order = Instance(list, args=(DEFAULT_DRAWING_ORDER,))

    # Redefine the enable-level set of layers to use "plot" instead
    # of "mainlayer".  This is the same thing that BasePlotContainer does.
    container_under_layers = Tuple("background", "image", "underlay", "plot")

    # Override the definition from Component
    use_backbuffer = False


    #-------------------------------------------------------------------------
    # Inherited methods
    #-------------------------------------------------------------------------

    def draw(self, gc, view_bounds=None, mode="default"):
        if self.view_bounds is None:
            self.view_bounds = view_bounds
        if self.layout_needed:
            self.do_layout()
        self._draw(gc, view_bounds, mode)

    def _dispatch_draw(self, layer, gc, view_bounds, mode):
        Canvas._dispatch_draw(self, layer, gc, view_bounds, mode)

    def get_preferred_size(self, components=None):
        """ Returns the size (width,height) that is preferred for this
        components.
        """
        if self.view_bounds is not None:
            x, y, x2, y2 = self.view_bounds
        else:
            x, y, x2, y2 = self._bounding_box
        return (x2 - x + 1, y2 - y + 1)

    def _do_layout(self):
        for component in self.components + self.underlays + self.overlays:
            if not self._should_layout(component):
                continue
            bounds = list(component.outer_bounds)
            pref_size = list(component.get_preferred_size())
            if "h" in component.resizable:
                if pref_size[0] > 0:
                    bounds[0] = pref_size[0]
                else:
                    bounds[0] = self.default_component_size[0]
            if "v" in component.resizable:
                if pref_size[1] > 0:
                    bounds[1] = pref_size[1]
                else:
                    bounds[1] = self.default_component_size[1]
            component.outer_bounds = bounds

        for component in self.components + self.underlays + self.overlays:
            component.do_layout()
        return


########NEW FILE########
__FILENAME__ = plot_canvas_toolbar

from traits.api import Any, Enum, Int
from enable.drawing.api import ToolbarButton

# Local, relative imports
from plot_containers import VPlotContainer
from plot_component import PlotComponent


class PlotCanvasToolbar(VPlotContainer):

    # The placement of the toolbar over the canvas
    align = Enum("ur", "ul", "ll", "lr", "left", "right", "top", "bottom")

    # The spacing between buttons
    button_spacing = Int(5)

    # The (optional) component that we overlay
    component = Any

    # Override some inherited traits
    spacing = 5
    fit_components = "hv"
    resizable = "hv"
    halign = "center"
    valign = "center"
    fill_padding = False
    unified_draw = True

    def overlay(self, component, gc, view_bounds=None, mode="normal"):
        """ Allows the toolbar to behave like an overlay """
        self._do_layout()
        pref_size = self.get_preferred_size()


        # Special check for when we are overlaying an instance of enable.Canvas
        if hasattr(component, 'view_bounds'):
            cx, cy, cx2, cy2 = component.view_bounds
            cwidth = cx2 - cx + 1
            cheight = cy2 - cy + 1
        else:
            cx, cy = component.position
            cheight, cwidth = component.bounds

        if self.align in ("ur", "ul", "top"):
            y = cy + cheight - self.outer_height
        elif self.align in ("lr", "ll", "bottom"):
            y = cy
        else:
            y = cy + (cheight - pref_size[1])/2

        if self.align in ("ur", "lr", "right"):
            x = cx + cwidth - self.outer_width
        elif self.align in ("ul", "ll", "left"):
            x = cx
        else:
            x = cx + (cwidth - pref_size[0])/2

        self.outer_position = [x, y]
        VPlotContainer._draw(self, gc, view_bounds, mode)

    def _request_redraw(self):
        # Reproduce the behavior in AbstractOverlay to dispatch a
        # redraw event up to our overlaid component
        if self.component is not None:
            self.component.request_redraw()
        super(PlotCanvasToolbar, self)._request_redraw()
        return

class PlotToolbarButton(PlotComponent, ToolbarButton):

    label_font = "Arial 12"

    unified_draw = True

    def _draw_plot(self, *args, **kw):
        return self._draw_mainlayer(*args, **kw)

########NEW FILE########
__FILENAME__ = plot_component
""" Defines the PlotComponent class.
"""
# Enthought library imports
from enable.api import Component
from enable.kiva_graphics_context import GraphicsContext
from traits.api import Bool, Instance, Str


DEFAULT_DRAWING_ORDER = ["background", "image", "underlay",      "plot",
                         "selection", "border", "annotation", "overlay"]


class PlotComponent(Component):
    """
    PlotComponent is the base class for all plot-related visual components.
    It defines the various methods related to layout and tool handling,
    which virtually every subclass uses or needs to be aware of.

    Several of these top-level layout and draw methods have implementations
    that must not be overridden; instead, subclasses implement various
    protected stub methods.
    """

    #------------------------------------------------------------------------
    # Rendering control traits
    #------------------------------------------------------------------------

    # The order in which various rendering classes on this component are drawn.
    # Note that if this component is placed in a container, in most cases
    # the container's draw order is used, since the container calls
    # each of its contained components for each rendering pass.
    # Typically, the definitions of the layers are:
    #
    # 1. 'background': Background image, shading
    # 2. 'image': A special layer for plots that render as images.  This is in
    #     a separate layer since these plots must all render before non-image
    #     plots.
    # 3. 'underlay': Axes and grids
    # 4. 'plot': The main plot area itself
    # 5. 'selection': Selected content are rendered above normal plot elements
    #                 to make them stand out
    # 6. 'border': Plot borders
    # 7. 'annotation': Lines and text that are conceptually part of the "plot"
    #    but need to be rendered on top of everything else in the plot
    # 8. 'overlay': Legends, selection regions, and other tool-drawn visual
    #    elements
    draw_order = Instance(list, args=(DEFAULT_DRAWING_ORDER,))

    # The default draw layer for Chaco plot components is the "plot" layer
    draw_layer = Str("plot")

    # Draw layers in **draw_order**? If False, use _do_draw() (for backwards
    # compatibility).
    use_draw_order = Bool(True)

    def _use_draw_order_changed(self, old, new):
        """ Handler to catch the case when someone is trying to use the
        old-style drawing mechanism, which is now unsupported.
        """
        if new == False:
            raise RuntimeError("The old-style drawing mechanism is no longer " \
                    "supported in Chaco.")



########NEW FILE########
__FILENAME__ = plot_containers
""" Defines various plot container classes, including stacked, grid, and overlay.
"""
# Major library imports
from numpy import amax, any, arange, array, cumsum, hstack, sum, zeros, zeros_like

# Enthought library imports
from traits.api import Any, Array, Either, Enum, Float, Instance, \
    List, Property, Trait, Tuple, Int
from enable.simple_layout import simple_container_get_preferred_size, \
                                            simple_container_do_layout

# Local relative imports
from base_plot_container import BasePlotContainer


__all__ = ["OverlayPlotContainer", "HPlotContainer", "VPlotContainer", \
           "GridPlotContainer"]

DEFAULT_DRAWING_ORDER = ["background", "image", "underlay",      "plot",
                         "selection", "border", "annotation", "overlay"]

class OverlayPlotContainer(BasePlotContainer):
    """
    A plot container that stretches all its components to fit within its
    space.  All of its components must therefore be resizable.
    """

    draw_order = Instance(list, args=(DEFAULT_DRAWING_ORDER,))

    # Do not use an off-screen backbuffer.
    use_backbuffer = False

    # Cache (width, height) of the container's preferred size.
    _cached_preferred_size = Tuple

    def get_preferred_size(self, components=None):
        """ Returns the size (width,height) that is preferred for this component.

        Overrides PlotComponent
        """
        return simple_container_get_preferred_size(self, components=components)

    def _do_layout(self):
        """ Actually performs a layout (called by do_layout()).
        """
        simple_container_do_layout(self)
        return

class StackedPlotContainer(BasePlotContainer):
    """
    Base class for 1-D stacked plot containers, both horizontal and vertical.
    """

    draw_order = Instance(list, args=(DEFAULT_DRAWING_ORDER,))

    # The dimension along which to stack components that are added to
    # this container.
    stack_dimension = Enum("h", "v")

    # The "other" dimension, i.e., the dual of the stack dimension.
    other_dimension = Enum("v", "h")

    # The index into obj.position and obj.bounds that corresponds to
    # **stack_dimension**.  This is a class-level and not an instance-level
    # attribute. It must be 0 or 1.
    stack_index = 0

    def get_preferred_size(self, components=None):
        """ Returns the size (width,height) that is preferred for this component.

        Overrides PlotComponent.
        """
        if self.fixed_preferred_size is not None:
            self._cached_preferred_size = self.fixed_preferred_size
            return self.fixed_preferred_size

        if self.resizable == "":
            self._cached_preferred_size = self.outer_bounds[:]
            return self.outer_bounds

        if components is None:
            components = self.components

        ndx = self.stack_index
        other_ndx = 1 - ndx

        no_visible_components = True
        total_size = 0
        max_other_size = 0
        for component in components:
            if not self._should_layout(component):
                continue

            no_visible_components = False

            pref_size = component.get_preferred_size()
            total_size += pref_size[ndx] + self.spacing
            if pref_size[other_ndx] > max_other_size:
                max_other_size = pref_size[other_ndx]

        if total_size >= self.spacing:
            total_size -= self.spacing

        if (self.stack_dimension not in self.resizable) and \
           (self.stack_dimension not in self.fit_components):
            total_size = self.bounds[ndx]
        elif no_visible_components or (total_size == 0):
            total_size = self.default_size[ndx]

        if (self.other_dimension not in self.resizable) and \
           (self.other_dimension not in self.fit_components):
            max_other_size = self.bounds[other_ndx]
        elif no_visible_components or (max_other_size == 0):
            max_other_size = self.default_size[other_ndx]

        if ndx == 0:
            self._cached_preferred_size = (total_size + self.hpadding,
                                           max_other_size + self.vpadding)
        else:
            self._cached_preferred_size = (max_other_size + self.hpadding,
                                           total_size + self.vpadding)

        return self._cached_preferred_size


    def _do_stack_layout(self, components, align):
        """ Helper method that does the actual work of layout.
        """

        size = list(self.bounds)
        if self.fit_components != "":
            self.get_preferred_size()
            if "h" in self.fit_components:
                size[0] = self._cached_preferred_size[0] - self.hpadding
            if "v" in self.fit_components:
                size[1] = self._cached_preferred_size[1] - self.vpadding

        ndx = self.stack_index
        other_ndx = 1 - ndx
        other_dim = self.other_dimension

        # Assign sizes of non-resizable components, and compute the total size
        # used by them (along the stack dimension).
        total_fixed_size = 0
        resizable_components = []
        size_prefs = {}
        total_resizable_size = 0

        for component in components:
            if not self._should_layout(component):
                continue
            if self.stack_dimension not in component.resizable:
                total_fixed_size += component.outer_bounds[ndx]
            else:
                preferred_size = component.get_preferred_size()
                size_prefs[component] = preferred_size
                total_resizable_size += preferred_size[ndx]
                resizable_components.append(component)

        new_bounds_dict = {}

        # Assign sizes of all the resizable components along the stack dimension
        if resizable_components:
            space = self.spacing * (len(self.components) - 1)
            avail_size = size[ndx] - total_fixed_size - space
            if total_resizable_size > 0:
                scale = avail_size / float(total_resizable_size)
                for component in resizable_components:
                    tmp = list(component.outer_bounds)
                    tmp[ndx] = int(size_prefs[component][ndx] * scale)
                    new_bounds_dict[component] = tmp
            else:
                each_size = int(avail_size / len(resizable_components))
                for component in resizable_components:
                    tmp = list(component.outer_bounds)
                    tmp[ndx] = each_size
                    new_bounds_dict[component] = tmp

        # Loop over all the components, assigning position and computing the
        # size in the other dimension and its position.
        cur_pos = 0
        for component in components:
            if not self._should_layout(component):
                continue

            position = list(component.outer_position)
            position[ndx] = cur_pos

            bounds = new_bounds_dict.get(component, list(component.outer_bounds))
            cur_pos += bounds[ndx] + self.spacing

            if (bounds[other_ndx] > size[other_ndx]) or \
                    (other_dim in component.resizable):
                # If the component is resizable in the other dimension or it exceeds the
                # container bounds, set it to the maximum size of the container

                #component.set_outer_position(other_ndx, 0)
                #component.set_outer_bounds(other_ndx, size[other_ndx])
                position[other_ndx] = 0
                bounds[other_ndx] = size[other_ndx]
            else:
                #component.set_outer_position(other_ndx, 0)
                #old_coord = component.outer_position[other_ndx]
                position[other_ndx] = 0
                if align == "min":
                    pass
                elif align == "max":
                    position[other_ndx] = size[other_ndx] - bounds[other_ndx]
                elif align == "center":
                    position[other_ndx] = (size[other_ndx] - bounds[other_ndx]) / 2.0

            component.outer_position = position
            component.outer_bounds = bounds
            component.do_layout()
        return

    ### Persistence ###########################################################

    # PICKLE FIXME: blocked with _pickles, but not sure that was correct.
    def __getstate__(self):
        state = super(StackedPlotContainer,self).__getstate__()
        for key in ['stack_dimension', 'other_dimension', 'stack_index']:
            if state.has_key(key):
                del state[key]
        return state


class HPlotContainer(StackedPlotContainer):
    """
    A plot container that stacks all of its components horizontally. Resizable
    components share the free space evenly. All components are stacked from
    according to **stack_order* in the same order that they appear in the
    **components** list.
    """

    draw_order = Instance(list, args=(DEFAULT_DRAWING_ORDER,))

    # The order in which components in the plot container are laid out.
    stack_order = Enum("left_to_right", "right_to_left")

    # The amount of space to put between components.
    spacing = Float(0.0)

    # The vertical alignment of objects that don't span the full height.
    valign = Enum("bottom", "top", "center")

    _cached_preferred_size = Tuple

    def _do_layout(self):
        """ Actually performs a layout (called by do_layout()).
        """
        if self.stack_order == "left_to_right":
            components = self.components
        else:
            components = self.components[::-1]

        if self.valign == "bottom":
            align = "min"
        elif self.valign == "center":
            align = "center"
        else:
            align = "max"

        return self._do_stack_layout(components, align)

    ### Persistence ###########################################################
    #_pickles = ("stack_order", "spacing")

    def __getstate__(self):
        state = super(HPlotContainer,self).__getstate__()
        for key in ['_cached_preferred_size']:
            if state.has_key(key):
                del state[key]
        return state



class VPlotContainer(StackedPlotContainer):
    """
    A plot container that stacks plot components vertically.
    """

    draw_order = Instance(list, args=(DEFAULT_DRAWING_ORDER,))

    # Overrides StackedPlotContainer.
    stack_dimension = "v"
    # Overrides StackedPlotContainer.
    other_dimension = "h"
    # Overrides StackedPlotContainer.
    stack_index = 1

    # VPlotContainer attributes

    # The horizontal alignment of objects that don't span the full width.
    halign = Enum("left", "right", "center")

    # The order in which components in the plot container are laid out.
    stack_order = Enum("bottom_to_top", "top_to_bottom")

    # The amount of space to put between components.
    spacing = Float(0.0)

    def _do_layout(self):
        """ Actually performs a layout (called by do_layout()).
        """
        if self.stack_order == "bottom_to_top":
            components = self.components
        else:
            components = self.components[::-1]
        if self.halign == "left":
            align = "min"
        elif self.halign == "center":
            align = "center"
        else:
            align = "max"

        return self._do_stack_layout(components, align)


class GridPlotContainer(BasePlotContainer):
    """ A GridPlotContainer consists of rows and columns in a tabular format.

    Each cell's width is the same as all other cells in its column, and each
    cell's height is the same as all other cells in its row.

    Although grid layout requires more layout information than a simple
    ordered list, this class keeps components as a simple list and exposes a
    **shape** trait.
    """

    draw_order = Instance(list, args=(DEFAULT_DRAWING_ORDER,))

    # The amount of space to put on either side of each component, expressed
    # as a tuple (h_spacing, v_spacing).
    spacing = Either(Tuple, List, Array)

    # The vertical alignment of objects that don't span the full height.
    valign = Enum("bottom", "top", "center")

    # The horizontal alignment of objects that don't span the full width.
    halign = Enum("left", "right", "center")

    # The shape of this container, i.e, (rows, columns).  The items in
    # **components** are shuffled appropriately to match this
    # specification.  If there are fewer components than cells, the remaining
    # cells are filled in with spaces.  If there are more components than cells,
    # the remainder wrap onto new rows as appropriate.
    shape = Trait((0,0), Either(Tuple, List, Array))

    # This property exposes the underlying grid structure of the container,
    # and is the preferred way of setting and reading its contents.
    # When read, this property returns a Numpy array with dtype=object; values
    # for setting it can be nested tuples, lists, or 2-D arrays.
    # The array is in row-major order, so that component_grid[0] is the first
    # row, and component_grid[:,0] is the first column.  The rows are ordered
    # from top to bottom.
    component_grid = Property

    # The internal component grid, in row-major order.  This gets updated
    # when any of the following traits change: shape, components, grid_components
    _grid = Array

    _cached_total_size = Any
    _h_size_prefs = Any
    _v_size_prefs = Any

    class SizePrefs(object):
        """ Object to hold size preferences across spans in a particular
        dimension.  For instance, if SizePrefs is being used for the row
        axis, then each element in the arrays below express sizing information
        about the corresponding column.
        """

        # The maximum size of non-resizable elements in the span.  If an
        # element of this array is 0, then its corresponding span had no
        # non-resizable components.
        fixed_lengths = Array

        # The maximum preferred size of resizable elements in the span.
        # If an element of this array is 0, then its corresponding span
        # had no resizable components with a non-zero preferred size.
        resizable_lengths = Array

        # The direction of resizability associated with this SizePrefs
        # object.  If this SizePrefs is sizing along the X-axis, then
        # direction should be "h", and correspondingly for the Y-axis.
        direction = Enum("h", "v")

        # The index into a size tuple corresponding to our orientation
        # (0 for horizontal, 1 for vertical).  This is derived from
        # **direction** in the constructor.
        index = Int(0)

        def __init__(self, length, direction):
            """ Initializes this prefs object with empty arrays of the given
            length and with the given direction. """
            self.fixed_lengths = zeros(length)
            self.resizable_lengths = zeros(length)
            self.direction = direction
            if direction == "h":
                self.index = 0
            else:
                self.index = 1
            return

        def update_from_component(self, component, index):
            """ Given a component at a particular index along this SizePref's
            axis, integrates the component's resizability and sizing information
            into self.fixed_lengths and self.resizable_lengths. """
            resizable = self.direction in component.resizable
            pref_size = component.get_preferred_size()
            self.update_from_pref_size(pref_size[self.index], index, resizable)

        def update_from_pref_size(self, pref_length, index, resizable):
            if resizable:
                if pref_length > self.resizable_lengths[index]:
                    self.resizable_lengths[index] = pref_length
            else:
                if pref_length > self.fixed_lengths[index]:
                    self.fixed_lengths[index] = pref_length
            return

        def get_preferred_size(self):
            return amax((self.fixed_lengths, self.resizable_lengths), axis=0)

        def compute_size_array(self, size):
            """ Given a length along the axis corresponding to this SizePref,
            returns an array of lengths to assign each cell, taking into account
            resizability and preferred sizes.
            """
            # There are three basic cases for each column:
            #   1. size < total fixed size
            #   2. total fixed size < size < fixed size + resizable preferred size
            #   3. fixed size + resizable preferred size < size
            #
            # In all cases, non-resizable components get their full width.
            #
            # For resizable components with non-zero preferred size, the following
            # actions are taken depending on case:
            #   case 1: They get sized to 0.
            #   case 2: They get a fraction of their preferred size, scaled based on
            #           the amount of remaining space after non-resizable components
            #           get their full size.
            #   case 3: They get their full preferred size.
            #
            # For resizable components with no preferred size (indicated in our scheme
            # by having a preferred size of 0), the following actions are taken
            # depending on case:
            #   case 1: They get sized to 0.
            #   case 2: They get sized to 0.
            #   case 3: All resizable components with no preferred size split the
            #           remaining space evenly, after fixed width and resizable
            #           components with preferred size get their full size.
            fixed_lengths = self.fixed_lengths
            resizable_lengths = self.resizable_lengths
            return_lengths = zeros_like(fixed_lengths)

            fixed_size = sum(fixed_lengths)
            fixed_length_indices = fixed_lengths > resizable_lengths
            resizable_indices = resizable_lengths > fixed_lengths
            fully_resizable_indices = (resizable_lengths + fixed_lengths == 0)
            preferred_size = sum(fixed_lengths[fixed_length_indices]) + \
                                    sum(resizable_lengths[~fixed_length_indices])

            # Regardless of the relationship between available space and
            # resizable preferred sizes, columns/rows where the non-resizable
            # component is largest will always get that amount of space.
            return_lengths[fixed_length_indices] = fixed_lengths[fixed_length_indices]

            if size <= fixed_size:
                # We don't use fixed_length_indices here because that mask is
                # just where non-resizable components were larger than resizable
                # ones.  If our allotted size is less than the total fixed size,
                # then we should give all non-resizable components their desired
                # size.
                indices = fixed_lengths > 0
                return_lengths[indices] = fixed_lengths[indices]
                return_lengths[~indices] = 0

            elif size > fixed_size and (fixed_lengths > resizable_lengths).all():
                # If we only have to consider non-resizable lengths, and we have
                # extra space available, then we need to give each column an
                # amount of extra space corresponding to its size.
                desired_space = sum(fixed_lengths)
                if desired_space > 0:
                    scale = size / desired_space
                    return_lengths = (fixed_lengths * scale).astype(int)

            elif size <= preferred_size or not fully_resizable_indices.any():
                # If we don't have enough room to give all the non-fully resizable
                # components their preferred size, or we have more than enough
                # room for them and no fully resizable components to take up
                # the extra space, then we just scale the resizable components
                # up or down based on the amount of extra space available.
                delta_lengths = resizable_lengths[resizable_indices] - \
                                        fixed_lengths[resizable_indices]
                desired_space = sum(delta_lengths)
                if desired_space > 0:
                    avail_space = size - sum(fixed_lengths) #[fixed_length_indices])
                    scale = avail_space / desired_space
                    return_lengths[resizable_indices] = (fixed_lengths[resizable_indices] + \
                            scale * delta_lengths).astype(int)

            elif fully_resizable_indices.any():
                # We have enough room to fit all the non-resizable components
                # as well as components with preferred sizes, and room left
                # over for the fully resizable components.  Give the resizable
                # components their desired amount of space, and then give the
                # remaining space to the fully resizable components.
                return_lengths[resizable_indices] = resizable_lengths[resizable_indices]
                avail_space = size - preferred_size
                count = sum(fully_resizable_indices)
                space = avail_space / count
                return_lengths[fully_resizable_indices] = space

            else:
                raise RuntimeError("Unhandled sizing case in GridContainer")

            return return_lengths


    def get_preferred_size(self, components=None):
        """ Returns the size (width,height) that is preferred for this component.

        Overrides PlotComponent.
        """
        if self.fixed_preferred_size is not None:
            return self.fixed_preferred_size

        if components is None:
            components = self.component_grid
        else:
            # Convert to array; hopefully it is a list or tuple of list/tuples
            components = array(components)

        # These arrays track the maximum widths in each column and maximum
        # height in each row.
        numrows, numcols = self.shape

        no_visible_components = True
        self._h_size_prefs = GridPlotContainer.SizePrefs(numcols, "h")
        self._v_size_prefs = GridPlotContainer.SizePrefs(numrows, "v")
        self._pref_size_cache = {}
        for i, row in enumerate(components):
            for j, component in enumerate(row):
                if not self._should_layout(component):
                    continue
                else:
                    no_visible_components = False
                    self._h_size_prefs.update_from_component(component, j)
                    self._v_size_prefs.update_from_component(component, i)

        total_width = sum(self._h_size_prefs.get_preferred_size()) + self.hpadding
        total_height = sum(self._v_size_prefs.get_preferred_size()) + self.vpadding
        total_size = array([total_width, total_height])

        # Account for spacing.  There are N+1 of spaces, where N is the size in
        # each dimension.
        if self.spacing is None:
            spacing = zeros(2)
        else:
            spacing = array(self.spacing)
        total_spacing = array(components.shape[::-1]) * spacing * 2 * (total_size>0)
        total_size += total_spacing

        for orientation, ndx in (("h", 0), ("v", 1)):
            if (orientation not in self.resizable) and \
               (orientation not in self.fit_components):
                total_size[ndx] = self.outer_bounds[ndx]
            elif no_visible_components or (total_size[ndx] == 0):
                total_size[ndx] = self.default_size[ndx]

        self._cached_total_size = total_size
        if self.resizable == "":
            return self.outer_bounds
        else:
            return self._cached_total_size

    def _do_layout(self):
        # If we don't have cached size_prefs, then we need to call
        # get_preferred_size to build them.
        if self._cached_total_size is None:
            self.get_preferred_size()

        # If we need to fit our components, then rather than using our
        # currently assigned size to do layout, we use the preferred
        # size we computed from our components.
        size = array(self.bounds)
        if self.fit_components != "":
            self.get_preferred_size()
            if "h" in self.fit_components:
                size[0] = self._cached_total_size[0] - self.hpadding
            if "v" in self.fit_components:
                size[1] = self._cached_total_size[1] - self.vpadding

        # Compute total_spacing and spacing, which are used in computing
        # the bounds and positions of all the components.
        shape = array(self._grid.shape).transpose()
        if self.spacing is None:
            spacing = array([0,0])
        else:
            spacing = array(self.spacing)
        total_spacing = spacing * 2 * shape

        # Compute the total space used by non-resizable and resizable components
        # with non-zero preferred sizes.
        widths = self._h_size_prefs.compute_size_array(size[0] - total_spacing[0])
        heights = self._v_size_prefs.compute_size_array(size[1] - total_spacing[1])

        # Set the baseline h and v positions for each cell.  Resizable components
        # will get these as their position, but non-resizable components will have
        # to be aligned in H and V.
        summed_widths = cumsum(hstack(([0], widths[:-1])))
        summed_heights = cumsum(hstack(([0], heights[-1:0:-1])))
        h_positions = (2*(arange(self._grid.shape[1])+1) - 1) * spacing[0] + summed_widths
        v_positions = (2*(arange(self._grid.shape[0])+1) - 1) * spacing[1] + summed_heights
        v_positions = v_positions[::-1]

        # Loop over all rows and columns, assigning position, setting bounds for
        # resizable components, and aligning non-resizable ones
        valign = self.valign
        halign = self.halign
        for j, row in enumerate(self._grid):
            for i, component in enumerate(row):
                if not self._should_layout(component):
                    continue

                r = component.resizable
                x = h_positions[i]
                y = v_positions[j]
                w = widths[i]
                h = heights[j]

                if "v" not in r:
                    # Component is not vertically resizable
                    if valign == "top":
                        y += h - component.outer_height
                    elif valign == "center":
                        y += (h - component.outer_height) / 2
                if "h" not in r:
                    # Component is not horizontally resizable
                    if halign == "right":
                        x += w - component.outer_width
                    elif halign == "center":
                        x += (w - component.outer_width) / 2

                component.outer_position = [x,y]
                bounds = list(component.outer_bounds)
                if "h" in r:
                    bounds[0] = w
                if "v" in r:
                    bounds[1] = h

                component.outer_bounds = bounds
                component.do_layout()

        return


    def _reflow_layout(self):
        """ Re-computes self._grid based on self.components and self.shape.
        Adjusts self.shape accordingly.
        """
        numcells = self.shape[0] * self.shape[1]
        if numcells < len(self.components):
            numrows, numcols = divmod(len(self.components), self.shape[0])
            self.shape = (numrows, numcols)
        grid = array(self.components, dtype=object)
        grid.resize(self.shape)
        grid[grid==0] = None
        self._grid = grid
        self._layout_needed = True
        return

    def _shape_changed(self, old, new):
        self._reflow_layout()

    def __components_changed(self, old, new):
        self._reflow_layout()

    def __components_items_changed(self, event):
        self._reflow_layout()

    def _get_component_grid(self):
        return self._grid

    def _set_component_grid(self, val):
        grid = array(val)
        grid_set = set(grid.flatten())

        # Figure out which of the components in the component_grid are new,
        # and which have been removed.
        existing = set(array(self._grid).flatten())
        new = grid_set - existing
        removed = existing - grid_set

        for component in removed:
            if component is not None:
                component.container = None
        for component in new:
            if component is not None:
                if component.container is not None:
                    component.container.remove(component)
                component.container = self

        self.set(shape=grid.shape, trait_change_notify=False)
        self._components = list(grid.flatten())

        if self._should_compact():
            self.compact()

        self.invalidate_draw()
        return


### EOF


########NEW FILE########
__FILENAME__ = plot_factory
"""
Contains convenience functions to create ready-made PlotRenderer
and PlotFrame instances of various types.
"""

from numpy import array, ndarray, transpose, cos, sin

# Local relative imports
from abstract_data_source import AbstractDataSource
from array_data_source import ArrayDataSource
from axis import PlotAxis
from barplot import BarPlot
from data_range_1d import DataRange1D
from grid import PlotGrid
from linear_mapper import LinearMapper
from scatterplot import ScatterPlot
from polar_mapper import PolarMapper
from lineplot import LinePlot
from polar_line_renderer import PolarLineRenderer

def _create_data_sources(data, index_sort="none"):
    """
    Returns datasources for index and value based on the inputs.  Assumes that
    the index data is unsorted unless otherwise specified.
    """
    if (type(data) == ndarray) or (len(data) == 2):
        index, value = data
        if type(index) in (list, tuple, ndarray):
            index = ArrayDataSource(array(index), sort_order=index_sort)
        elif not isinstance(index, AbstractDataSource):
            raise RuntimeError, "Need an array or list of values or a DataSource, got %s instead." % type(index)

        if type(value) in (list, tuple, ndarray):
            value = ArrayDataSource(array(value))
        elif not isinstance(value, AbstractDataSource):
            raise RuntimeError, "Need an array or list of values or a DataSource, got %s instead." % type(index)

        return index, value
    else:
        raise RuntimeError, "Unable to create datasources."


def create_scatter_plot(data=[], index_bounds=None, value_bounds=None,
                        orientation="h", color="green", marker="square",
                        marker_size=4,
                        bgcolor="transparent", outline_color="black",
                        border_visible=True,
                        add_grid=False, add_axis=False,
                        index_sort="none"):
    """
    Creates a ScatterPlot from a single Nx2 data array or a tuple of
    two length-N 1-D arrays.  The data must be sorted on the index if any
    reverse-mapping tools are to be used.

    Pre-existing "index" and "value" datasources can be passed in.
    """

    index, value = _create_data_sources(data)

    if index_bounds is not None:
        index_range = DataRange1D(low=index_bounds[0], high=index_bounds[1])
    else:
        index_range = DataRange1D()
    index_range.add(index)
    index_mapper = LinearMapper(range=index_range)

    if value_bounds is not None:
        value_range = DataRange1D(low=value_bounds[0], high=value_bounds[1])
    else:
        value_range = DataRange1D()
    value_range.add(value)
    value_mapper = LinearMapper(range=value_range)

    plot = ScatterPlot(index=index, value=value,
                         index_mapper=index_mapper,
                         value_mapper=value_mapper,
                         orientation=orientation,
                         marker=marker,
                         marker_size=marker_size,
                         color=color,
                         bgcolor=bgcolor,
                         outline_color=outline_color,
                         border_visible=border_visible,)

    if add_grid:
        add_default_grids(plot, orientation)
    if add_axis:
        add_default_axes(plot, orientation)
    return plot


def create_line_plot(data=[], index_bounds=None, value_bounds=None,
                     orientation="h", color="red", width=1.0,
                     dash="solid", value_mapper_class=LinearMapper,
                     bgcolor="transparent", border_visible=False,
                     add_grid=False, add_axis=False,
                     index_sort="none"):

    index, value = _create_data_sources(data, index_sort)

    if index_bounds is not None:
        index_range = DataRange1D(low=index_bounds[0], high=index_bounds[1])
    else:
        index_range = DataRange1D()
    index_range.add(index)
    index_mapper = LinearMapper(range=index_range)

    if value_bounds is not None:
        value_range = DataRange1D(low=value_bounds[0], high=value_bounds[1])
    else:
        value_range = DataRange1D()
    value_range.add(value)
    value_mapper = value_mapper_class(range=value_range)

    plot = LinePlot(index=index, value=value,
                    index_mapper = index_mapper,
                    value_mapper = value_mapper,
                    orientation = orientation,
                    color = color,
                    bgcolor = bgcolor,
                    line_width = width,
                    line_style = dash,
                    border_visible=border_visible)

    if add_grid:
        add_default_grids(plot, orientation)
    if add_axis:
        add_default_axes(plot, orientation)
    return plot


def create_bar_plot(data=[], index_bounds=None, value_bounds=None,
                     orientation="h", color="red", bar_width=10.0,
                     value_mapper_class=LinearMapper,
                     line_color="black",
                     fill_color="red", line_width=1,
                     bgcolor="transparent", border_visible=False,
                     antialias=True,
                     add_grid=False, add_axis=False):

    index, value = _create_data_sources(data)

    if index_bounds is not None:
        index_range = DataRange1D(low=index_bounds[0], high=index_bounds[1])
    else:
        index_range = DataRange1D()
    index_range.add(index)
    index_mapper = LinearMapper(range=index_range)

    if value_bounds is not None:
        value_range = DataRange1D(low=value_bounds[0], high=value_bounds[1])
    else:
        value_range = DataRange1D()
    value_range.add(value)
    value_mapper = value_mapper_class(range=value_range)

    # Create the plot
    plot = BarPlot(index=index,
                    value=value,
                    value_mapper=value_mapper,
                    index_mapper=index_mapper,
                    orientation=orientation,
                    line_color=line_color,
                    fill_color=fill_color,
                    line_width=line_width,
                    bar_width=bar_width,
                    antialias=antialias,)

    if add_grid:
        add_default_grids(plot, orientation)
    if add_axis:
        add_default_axes(plot, orientation)
    return plot


def create_polar_plot(data, orientation='h', color='black', width=1.0,
                      dash="solid", grid="dot", value_mapper_class=PolarMapper):
    if (type(data) != ndarray) and (len(data) == 2):
        data = transpose(array(data))

    r_data, t_data = transpose(data)
    index_data= r_data*cos(t_data)
    value_data= r_data*sin(t_data)

    index = ArrayDataSource(index_data, sort_order='ascending')
    # Typically the value data is unsorted
    value = ArrayDataSource(value_data)

    index_range = DataRange1D()
    index_range.add(index)
    index_mapper = PolarMapper(range=index_range)

    value_range = DataRange1D()
    value_range.add(value)
    value_mapper = value_mapper_class(range=value_range)

    plot = PolarLineRenderer(index=index, value=value,
                    index_mapper = index_mapper,
                    value_mapper = value_mapper,
                    orientation = orientation,
                    color = color,
                    line_width = width,
                    line_style = dash,
                    grid_style = grid)

    return plot


def add_default_axes(plot, orientation="normal", vtitle="", htitle="",
                     axis_class=PlotAxis):
    """
    Creates left and bottom axes for a plot.  Assumes that the index is
    horizontal and value is vertical by default; set *orientation* to
    something other than "normal" if they are flipped.
    """
    if orientation in ("normal", "h"):
        v_mapper = plot.value_mapper
        h_mapper = plot.index_mapper
    else:
        v_mapper = plot.index_mapper
        h_mapper = plot.value_mapper

    left = axis_class(orientation='left',
                    title= vtitle,
                    mapper=v_mapper,
                    component=plot)

    bottom = axis_class(orientation='bottom',
                      title= htitle,
                      mapper=h_mapper,
                      component=plot)

    plot.underlays.append(left)
    plot.underlays.append(bottom)
    return left, bottom


def add_default_grids(plot, orientation="normal"):
    """
    Creates horizontal and vertical gridlines for a plot.  Assumes that the
    index is horizontal and value is vertical by default; set orientation to
    something other than "normal" if they are flipped.
    """
    if orientation in ("normal", "h"):
        v_mapper = plot.index_mapper
        h_mapper = plot.value_mapper
    else:
        v_mapper = plot.value_mapper
        h_mapper = plot.index_mapper

    vgrid = PlotGrid(mapper=v_mapper, orientation='vertical',
                     component=plot,
                     line_color="lightgray", line_style="dot")

    hgrid = PlotGrid(mapper=h_mapper, orientation='horizontal',
                     component=plot,
                     line_color="lightgray", line_style="dot")

    plot.underlays.append(vgrid)
    plot.underlays.append(hgrid)
    return hgrid, vgrid



# EOF

########NEW FILE########
__FILENAME__ = plot_graphics_context
""" Defines the PlotGraphicsContext class.
"""

from __future__ import with_statement

from enable.kiva_graphics_context import GraphicsContext

class PlotGraphicsContextMixin(object):

    """ A Kiva graphics context, which facilitates rendering plots and plot
    components into an offscreen or memory buffer.

    Its only real difference from a Kiva graphics context is that this
    class correctly offsets the coordinate frame by (0.5, 0.5) and increases
    the actual size of the image by 1 pixel in each dimension. When rendering
    into on-screen windows through Enable, this transformation step is handled
    by Enable.
    """
    # FIXME: Right now this does not resize correctly.  (But you shouldn't
    # resize your GC, anyway!)

    def __init__(self, size_or_ary, *args, **kw):
        scale = kw.pop('dpi', 72.0) / 72.0
        if type(size_or_ary) in (list, tuple) and len(size_or_ary) == 2:
            size_or_ary = (size_or_ary[0]*scale + 1, size_or_ary[1]*scale + 1)

        super(PlotGraphicsContextMixin, self).__init__(size_or_ary, *args, **kw)
        self.translate_ctm(0.5, 0.5)
        self.scale_ctm(scale, scale)
        return

    def render_component(self, component, container_coords=False):
        """ Renders the given component.

        Parameters
        ----------
        component : Component
            The component to be rendered.
        container_coords : Boolean
            Whether to use coordinates of the component's container

        Description
        -----------
        If *container_coords* is False, then the (0,0) coordinate of this
        graphics context corresponds to the lower-left corner of the
        component's **outer_bounds**. If *container_coords* is True, then the
        method draws the component as it appears inside its container, i.e., it
        treats (0,0) of the graphics context as the lower-left corner of the
        container's outer bounds.
        """

        x, y = component.outer_position
        if not container_coords:
            x = -x
            y = -y
        with self:
            self.translate_ctm(x, y)
            component.draw(self, view_bounds=(0, 0, self.width(), self.height()))
        return

    def clip_to_rect(self, x, y, width, height):
        """ Offsets the coordinate frame by (0.5, 0.5) and increases the actual
        size of the image by 1 pixel in each dimension.

        Overrides Kiva GraphicsContext.
        """
        super(PlotGraphicsContextMixin, self).clip_to_rect(x-0.5, y-0.5, width+1, height+1)

class PlotGraphicsContext(PlotGraphicsContextMixin, GraphicsContext):
    pass


########NEW FILE########
__FILENAME__ = plot_label
""" Defines the PlotLabel class.
"""

from __future__ import with_statement

from enable.font_metrics_provider import font_metrics_provider
from traits.api import DelegatesTo, Enum, Instance, Str, Trait

from abstract_overlay import AbstractOverlay
from label import Label


LabelDelegate = DelegatesTo("_label")

class PlotLabel(AbstractOverlay):
    """ A label used by plots.

    This class wraps a simple Label instance, and delegates some traits to it.
    """

    # The text of the label.
    text = LabelDelegate
    # The color of the label text.
    color = DelegatesTo("_label")
    # The font for the label text.
    font = LabelDelegate
    # The angle of rotation of the label.
    angle = DelegatesTo("_label", "rotate_angle")

    bgcolor = LabelDelegate
    border_width = LabelDelegate
    border_color = LabelDelegate
    border_visible = LabelDelegate
    margin = LabelDelegate
    line_spacing = LabelDelegate

    #------------------------------------------------------------------------
    # Layout-related traits
    #------------------------------------------------------------------------

    # Horizontal justification used if the label has more horizontal space
    # than it needs.
    hjustify = Enum("center", "left", "right")

    # Vertical justification used if the label has more vertical space than it
    # needs.
    vjustify = Enum("center", "bottom", "top")

    # The position of this label relative to the object it is overlaying.
    # Can be "top", "left", "right", "bottom", and optionally can be preceeded
    # by the words "inside" or "outside", separated by a space.  If "inside"
    # and "outside" are not provided, then defaults to "outside".
    # Examples:
    #     inside top
    #     outside right
    overlay_position = Trait("outside top", Str, None)

    # Should this PlotLabel modify the padding on its underlying component
    # if there is not enough room to lay out the text?
    # FIXME: This could cause cycles in layout, so not implemented for now
    #modify_component = Bool(True)

    # By default, this acts like a component and will render on the main
    # "plot" layer unless its **component** attribute gets set.
    draw_layer = "plot"

    #------------------------------------------------------------------------
    # Private traits
    #------------------------------------------------------------------------

    # The label has a fixed height and can be resized horizontally. (Overrides
    # PlotComponent.)
    resizable = "h"

    # The Label instance this plot label is wrapping.
    _label = Instance(Label, args=())


    def __init__(self, text="", *args, **kw):
        super(PlotLabel, self).__init__(*args, **kw)
        self.text = text
        return

    def overlay(self, component, gc, view_bounds=None, mode="normal"):
        """ Draws this label overlaid on another component.

        Overrides AbstractOverlay.
        """
        self._draw_overlay(gc, view_bounds, mode)
        return

    def get_preferred_size(self):
        """ Returns the label's preferred size.

        Overrides PlotComponent.
        """
        dummy_gc = font_metrics_provider()
        size = self._label.get_bounding_box(dummy_gc)
        return size

    def do_layout(self):
        """ Tells this component to do layout.

        Overrides PlotComponent.
        """
        if self.component is not None:
            self._layout_as_overlay()
        else:
            self._layout_as_component()
        return

    def _draw_overlay(self, gc, view_bounds=None, mode="normal"):
        """ Draws the overlay layer of a component.

        Overrides PlotComponent.
        """
        # Perform justification and compute the correct offsets for
        # the label position
        width, height = self._label.get_bounding_box(gc)
        if self.hjustify == "left":
            x_offset = 0
        elif self.hjustify == "right":
            x_offset = self.width - width
        elif self.hjustify == "center":
            x_offset = int((self.width - width) / 2)

        if self.vjustify == "bottom":
            y_offset = 0
        elif self.vjustify == "top":
            y_offset = self.height - height
        elif self.vjustify == "center":
            y_offset = int((self.height - height) / 2)

        with gc:
            # XXX: Uncomment this after we fix kiva GL backend's clip stack
            #gc.clip_to_rect(self.x, self.y, self.width, self.height)

            # We have to translate to our position because the label
            # tries to draw at (0,0).
            gc.translate_ctm(self.x + x_offset, self.y + y_offset)
            self._label.draw(gc)

        return

    def _draw_plot(self, gc, view_bounds=None, mode="normal"):
        if self.component is None:
            # We are not overlaying anything else, so we should render
            # on this layer
            self._draw_overlay(gc, view_bounds, mode)

    def _layout_as_component(self, size=None, force=False):
        pass

    def _layout_as_overlay(self, size=None, force=False):
        """ Lays out the label as an overlay on another component.
        """
        if self.component is not None:
            orientation = self.overlay_position
            outside = True
            if "inside" in orientation:
                tmp = orientation.split()
                tmp.remove("inside")
                orientation = tmp[0]
                outside = False
            elif "outside" in orientation:
                tmp = orientation.split()
                tmp.remove("outside")
                orientation = tmp[0]

            if orientation in ("left", "right"):
                self.y = self.component.y
                self.height = self.component.height
                if not outside:
                    gc = font_metrics_provider()
                    self.width = self._label.get_bounding_box(gc)[0]
                if orientation == "left":
                    if outside:
                        self.x = self.component.outer_x
                        self.width = self.component.padding_left
                    else:
                        self.outer_x = self.component.x
                elif orientation == "right":
                    if outside:
                        self.x = self.component.x2 + 1
                        self.width = self.component.padding_right
                    else:
                        self.x = self.component.x2 - self.outer_width
            elif orientation in ("bottom", "top"):
                self.x = self.component.x
                self.width = self.component.width
                if not outside:
                    gc = font_metrics_provider()
                    self.height = self._label.get_bounding_box(gc)[1]
                if orientation == "bottom":
                    if outside:
                        self.y = self.component.outer_y
                        self.height = self.component.padding_bottom
                    else:
                        self.outer_y = self.component.y
                elif orientation == "top":
                    if outside:
                        self.y = self.component.y2 + 1
                        self.height = self.component.padding_top
                    else:
                        self.y = self.component.y2 - self.outer_height
            else:
                # Leave the position alone
                pass
        return

    def _text_changed(self, old, new):
        self._label.text = new
        self.do_layout()
        return

    def _font_changed(self, old, new):
        self._label.font = new
        self.do_layout()
        return

    def _angle_changed(self, old, new):
        self._label.rotate_angle = new
        self.do_layout()
        return

    def _overlay_position_changed(self):
        self.do_layout()

    def _component_changed(self, old, new):
        if new:
            self.draw_layer = "overlay"
        else:
            self.draw_layer = "plot"
        return



# EOF

########NEW FILE########
__FILENAME__ = plot_template
"""
Defines classes needed to support templates in Chaco.

* AbstractTemplatizer
* CodeMetadata
* CodeTemplate
* PlotTemplate
* PlotTemplateException
* TemplateDescriptor
* Templatizable

Also defines the convenience function::

    bind_template(template, vars, type_check=False)

"""


from traits.api import Bool, Dict, HasTraits, Instance, Str



def bind_template(template, vars, type_check=False):
    """
    A convenience method for binding a plot template to set of variables.

    Parameters
    ----------
    template : a list of strings
        The code for the template, or a PlotTemplate object.
    vars : a dict
        Maps a template variable name to an object.
    type_check : Boolean
        If True, raises a PlotTemplateException with the name
        of the variable in *vars* whose type does not match what is
        specified in the template.
    """
    return


class PlotTemplateException(Exception):
    """ Raised for errors in plot templates.
    """
    pass


class TemplateDescriptor(HasTraits):
    """ Describes the names and types of template variables for a template.
    """

    # A dict with the template variable names as keys.  If the template is
    # unbound, the values are string representations of the types of objects
    # expected for each key.  These are simple types, e.g., 'tuple' or
    # 'PlotAxis'. If the template is bound, then the values are object
    # references.
    vars = Dict




class Templatizable(HasTraits):
    """ Mix-in class that makes objects capable of being incorporated
    into a Chaco template.

    Primarily defines the protocol used to query the class for its contents.
    """

    def templatize(self, my_name, ):
        """ Returns a dict mapping the name of the child in the local name space
        to a Templatizable object reference.
        """
        raise NotImplementedError

    def __gettemplate__(self):
        """ Returns a templatized version of the object.
        """

#    def bind(self,

    def rebind(self, obj):
        """ Replaces this object with the state in peer object *obj*.

        This method allows PlotTemplates to be used as live, application-level
        templates and not merely as a means to generating a plot script.

        (If you are having trouble implementing this method for something that
        should be Templatizable, it's probably a sign that you haven't fully
        considered the implications of your design, or that you are doing
        something a little weird.)
        """
        raise NotImplementedError


class PlotTemplate(HasTraits):
    """ Abstract base class for plot templates.
    """
    pass




class AbstractTemplatizer(HasTraits):
    """ A Templatizer accepts any subclass of Templatizable and returns a
    PlotTemplate.
    """



class CodeMetadata(HasTraits):
    """ Represents all the metadata about a plot template, to be stored into
    the generated code.

    The generated code for a plot template must create one of these objects,
    which is then used to drive the loading of the rest of the template.
    """
    # Not used for now, but could be handled later.
    version = "1.0"

    # The name of the Chaco package.
    pkg_name = "chaco"

    # A dict with the template variable names as keys.  If the template is
    # unbound, the values are string representations of the types of objects
    # expected for each key. These are simple types, e.g., 'tuple' or 'PlotAxis'.
    # If the template is bound, then the values are object references.
    template_vars = Dict

    # The name to evaluate to get the root object when the template
    # is instantiated.  Defaults to "ROOT_OBJ", but you can customize
    # this for aesthetic or readability reasons.
    root_name = Str

class CodeTemplate(PlotTemplate):
    """ A Chaco plot template.

    Because Chaco plot templates are just executable code that produces Chaco
    plots, the PlotTemplate class is used to manage, interact with, and inspect
    the code for the template.
    """

    #-------------------------------------------------------------------------
    # Configuration and general state of the template
    #-------------------------------------------------------------------------

    # Is the template completely bound?
    is_bound = Bool(False)


    #-------------------------------------------------------------------------
    # Object graph traits
    #-------------------------------------------------------------------------

    # The top-level Templatizable component in the plot.
    root = Instance(Templatizable)

    #-------------------------------------------------------------------------
    # Code-related traits
    # These are used during the actual code generation process.
    #-------------------------------------------------------------------------

    # Global variables used during the code generation process.
    code_globals = Dict
    # Imports used during the code generation process.
    code_imports = Dict

    def create_strings(self):
        """ Returns a list of strings which can be passed to bind_template().
        """
        # TODO:  do we need this?? can we do live generation?!!!
        pass

    def load_from_strings(self, stringlist):
        """ Fills this plot template with the template in *stringlist*.

        NOTE: Don't use this to bind a template to data!  There is a much easier
        way to do that: use the bind_template() function.
        """
        pass

    #-------------------------------------------------------------------------
    # Private methods
    #-------------------------------------------------------------------------

    def _write_metadata(self):
        """
        Produces a list of strings representing the code to create the
        metadata portion of this PlotTemplate.
        """
        pass

    #-------------------------------------------------------------------------
    # Methods used by Templatizable objects to query the generator about the
    # state of code generation.
    #-------------------------------------------------------------------------

    def create_global(self, name_hint):
        """ Requests that a new global symbol be allocated with the given name.

        Returns the actual name that was created.
        """
        pass

    def create_import(self, import_line, ):
        """ Adds another import line, verbatim, to the top of the output code.

        No order of imports is guaranteed.
        """
        pass

    def create_template_var(self, name_hint):
        """ Creates a new variable for parameterizing the template.

        Returns a string that represents the special token to be used in the
        output code to signal where the template value can be bound.
        """
        pass

    def create_function(self, name_hint):
        """ Requests that a new function be allocated with the given name.

        Returns the actual name that was created.
        """
        pass


# EOF

########NEW FILE########
__FILENAME__ = chaco_plugin
""" Envisage 3 plugin for Chaco functionality.
"""

from envisage.api import Plugin
from traits.api import List


ID = 'chaco'
ICHACO_SESSION = ID + '.plugin.session_service.SessionService'


class ChacoPlugin(Plugin):
    """ Envisage 3 plugin for Chaco functionality.
    """

    id = ID
    name = 'Chaco plugin'

    #### Contributions to extension points made by this plugin #################

    # Extension point Ids.
    COMMANDS = 'envisage.plugins.python_shell.commands'


    contributed_commands = List(contributes_to=COMMANDS)

    def _contributed_commands_default(self):
        commands = [
            "from chaco.shell.commands import *",
        ]
        return commands

    #### Plugin interface ######################################################

    def start(self):
        """ Monkeypatch the Chaco shell subsystem.
        """
        from chaco import shell
        from chaco.shell import commands
        from chaco.plugin.workbench_session import WorkbenchSession

        commands.session = shell.session = WorkbenchSession(
            application=self.application)

        def show():
            """ Shows all the figure windows that have been created thus far, and
            creates a GUI main loop.  This function is useful in scripts to show plots and
            keep their windows open, and has no effect when used from the interpreter
            prompt.

            Inside Envisage, just raise the current window.
            """
            win = commands.session.active_window
            win.raise_window()

        commands.show = show


########NEW FILE########
__FILENAME__ = plot_editor
from chaco.shell.scaly_plot import ScalyPlot
from enable.component_editor import ComponentEditor
from pyface.workbench.api import TraitsUIEditor
from traits.api import Any, Enum, HasTraits, Property, Str
from traitsui import api as tui


class PlotUI(HasTraits):
    """ Simple Traits UI proxy for a Chaco plot.
    """

    # The plot.
    component = Any()

    traits_view = tui.View(
        tui.Item('component', editor=ComponentEditor(), show_label=False),

        resizable=True,
    )


class PlotEditor(TraitsUIEditor):
    """ A Workbench Editor showing a Chaco plot for the shell interface.
    """

    bgcolor = Str('white')
    image_default_origin = Enum("bottom left", "top left",
                                "bottom right", "top right")

    # The plot.
    component = Property(Any)
    container = Property(Any)

    # The PlotData.
    data = Any()

    # The PlotSession of which we are a part.  We need to know this in order
    # to notify it of our being closed, etc.
    session = Any()

    def __init__(self, is_image=False, bgcolor="white",
                 image_default_origin="top left", *args, **kw):

        super(TraitsUIEditor, self).__init__(**kw)

        # Some defaults which should be overridden by preferences.
        self.bgcolor = bgcolor
        self.image_default_origin = image_default_origin

        # Create an empty top-level container
        if is_image:
            top_container = self._create_top_img_container()
        else:
            top_container = self._create_top_container()

        self.obj = PlotUI(component=top_container)


    #### PlotWindow interface ##################################################

    def get_container(self):
        return self.obj.component

    def set_container(self, container):
        self.obj.component = container

    def iconize(self, iconize):
        """Iconizes the window if *iconize* is True.

        Do nothing in this implementation.
        """

    def maximize(self, maximize):
        """ If *maximize* is True, maximizes the window size; restores if False.

        Do nothing in this implementation.
        """

    def set_size(self, width, height):
        pass

    def set_title(self, title):
        self.name = title

    def raise_window(self):
        self.window.activate_editor(self)


    #### Editor interface ######################################################

    def destroy_control(self):
        """ Destroy the toolkit-specific control that represents the part.
        """
        self._on_window_close()
        super(TraitsUIEditor, self).destroy_control()


    #### Private interface #####################################################

    def _get_container(self):
        return self.obj.component

    def _set_container(self, value):
        self.obj.component = value

    def _get_component(self):
        return self.obj.component

    def _set_component(self, value):
        self.obj.component = value

    def _create_top_container(self):
        plot = ScalyPlot(
            padding=50,
            fill_padding=True,
            bgcolor=self.bgcolor,
            use_backbuffer=True,
        )
        return plot

    def _create_top_img_container(self):
        plot = ScalyPlot(
            padding=50,
            fill_padding=True,
            bgcolor=self.bgcolor,
            use_backbuffer=True,
            default_origin=self.image_default_origin,
        )
        return plot

    def _on_window_close(self):
        if self.session:
            try:
                ndx = self.session.windows.index(self)
                self.session.del_window(ndx)
            except ValueError:
                pass


########NEW FILE########
__FILENAME__ = workbench_session
""" A Chaco Shell PlotSession which raises Workbench Editors instead of
free-standing windows.
"""

from traits.api import Any, Dict, List, Str
from chaco.shell.session import PlotSession

from plot_editor import PlotEditor


class WorkbenchSession(PlotSession):
    """ A Chaco Shell PlotSession which raises Workbench Editors instead of
    free-standing windows.
    """

    # The Envisage Application we are in.
    application = Any()

    # The list of currently active windows.
    windows = List()

    # A dict mapping names to windows.
    window_map = Dict(Str, Any)

    def new_window(self, name=None, title=None, is_image=False):
        """Creates a new window and returns the index into the **windows** list
        for the new window.
        """
        workbench = self.application.get_service(
            'envisage.ui.workbench.workbench.Workbench')
        new_win = PlotEditor(
            is_image=is_image,
            size=(self.prefs.window_width, self.prefs.window_height),
            bgcolor=self.prefs.bgcolor,
            image_default_origin=self.prefs.image_default_origin,
            window=workbench.active_window,
        )
        new_win.data = self.data
        new_win.get_container().data = self.data
        new_win.session = self

        if title is not None:
            new_win.set_title(title)
        elif name != None:
            new_win.set_title(name)
        else:
            new_win.set_title(self.prefs.default_window_name)

        self.windows.append(new_win)
        if name != None:
            self.window_map[name] = new_win

        workbench.edit(new_win.obj, kind=lambda *args, **kwds: new_win)

        return len(self.windows)-1



########NEW FILE########
__FILENAME__ = point_data_source
"""
Defines the PointDataSource class.
"""

# Major library imports
from numpy import array, transpose

# Enthought library imports
from traits.api import Enum, Property, ReadOnly, Tuple

# Local, relative imports
from base import PointTrait, reverse_map_1d, SortOrderTrait
from array_data_source import ArrayDataSource


class PointDataSource(ArrayDataSource):
    """ A data source representing a (possibly unordered) set of (X,Y) points.

    This is internally always represented by an Nx2 array, so that data[i]
    refers to a single point (represented as a length-2 array).

    Most of the traits and methods of ArrayDataSeries work for the
    PointDataSeries as well, since its data is linear.  This class
    overrides only the methods and traits that are different.

    """


    # The dimensionality of the indices into this data source (overrides
    # ArrayDataSource).
    index_dimension = ReadOnly('scalar')

    # The dimensionality of the value at each index point (overrides
    # ArrayDataSource).
    value_dimension = ReadOnly('point')

    # The sort order of the data. Although sort order is less common with point
    # data, it can be useful in case where the value data is sorted along some
    # axis.  Note that **sort_index** is used only if **sort_order** is not
    # 'none'.
    sort_order = SortOrderTrait

    # Which of the value axes the **sort_order** refers to.
    # If **sort_order** is 'none', this attribute is ignored.
    # In the unlikely event that the value data is sorted along both
    # X and Y (i.e., monotonic in both axes), then set **sort_index** to
    # whichever one has the best binary-search performance for hit-testing.
    sort_index = Enum(0, 1)


    #------------------------------------------------------------------------
    # Private traits
    #------------------------------------------------------------------------

    # The actual data (overrides ArrayDataSource).
    _data = PointTrait

    # Cached values of min and max as long as **_data** doesn't change
    # (overrides ArrayDataSource). ((min_x, max_x), (min_y, max_y))
    _cached_bounds = Tuple

    # These return lists of all the x and y positions, respectively

    # List of X positions.
    _xdata = Property
    # List of Y positions.
    _ydata = Property

    #------------------------------------------------------------------------
    # AbstractDataSource interface
    #------------------------------------------------------------------------

    def __init__(self, data = transpose(array([[],[]])), **kw):
        shape = data.shape
        if (len(shape) != 2) or (shape[1] != 2):
            raise RuntimeError, "PointDataSource constructor requires Nx2 array, but got array of shape " + str(shape) + " instead."
        super(PointDataSource, self).__init__(data, **kw)
        return

    def get_data(self):
        """ Returns the data for this data source, or (0.0, 0.0) if it has no
        data.

        Overrides ArryDataSource.
        """
        if self._data is not None:
            return self._data
        else:
            return (0.0, 0.0)

    def reverse_map(self, pt, index=0, outside_returns_none=True):
        """Returns the index of *pt* in the data source.

        Overrides ArrayDataSource.

        Parameters
        ----------
        pt : (x, y)
            value to find
        index : 0 or 1
            Which of the axes of *pt* the *sort_order* refers to.
        outside_returns_none : Boolean
            Whether the method returns None if *pt* is outside the range of
            the data source; if False, the method returns the value of the
            bound that *pt* is outside of, in the *index* dimension.

        """
        # reverse_map is of limited utility for a PointDataSeries and thus
        # we only perform reverse-mapping if the data is sorted along an axis.

        if self.sort_order == "none":
            # By default, only provide reverse_map if the value data is sorted
            # along one of its axes.
            raise NotImplementedError

        if index != 0 and index != 1:
            raise ValueError, "Index must be 0 or 1."

        # This basically reduces to a scalar data search along self.data[index].
        lowerleft, upperright= self._cached_bounds
        min_val = lowerleft[index]
        max_val = upperright[index]
        val = pt[index]
        if (val < min_val):
            if outside_returns_none:
                return None
            else:
                return self._min_index
        elif (val > max_val):
            if outside_returns_none:
                return None
            else:
                return self._max_index
        else:
            return reverse_map_1d(self._data[:,index], val, self.sort_order)

    #------------------------------------------------------------------------
    # Private methods
    #------------------------------------------------------------------------

    def _compute_bounds(self):
        """ Computes the minimum and maximum values of self._data.

        Overrides ArrayDataSource.
        """
        if len(self._data) == 0:
            self._cached_bounds = ((0.0,0.0), (0.0,0.0))
        elif len(self._data) == 1:
            x,y = self._data[0]
            self._cached_bounds = ((x,y), (x,y))
        else:
            # calculate the X and Y values independently
            x = self._data[:,0]
            min_x = min(x)
            max_x = max(x)
            y = self._data[:,1]
            min_y = min(y)
            max_y = max(y)
            self._cached_bounds = ((min_x,min_y), (max_x,max_y))
        return

    def _get__xdata(self):
        return ArrayDataSource(self._data[:,0])

    def _get__ydata(self):
        return ArrayDataSource(self._data[:,1])

# EOF

########NEW FILE########
__FILENAME__ = polar_line_renderer
""" Defines the PolarLineRenderer class.
"""

from __future__ import with_statement

# Major library imports
from numpy import array, cos, pi, sin, transpose

# Enthought library imports
from enable.api import black_color_trait, LineStyle
from traits.api import Float

# Local, relative imports
from abstract_plot_renderer import AbstractPlotRenderer


class PolarLineRenderer(AbstractPlotRenderer):
    """ A renderer for polar line plots.
    """
    #------------------------------------------------------------------------
    # Appearance-related traits
    #------------------------------------------------------------------------

    # The color of the origin axis.
    origin_axis_color_ = (0,0,0,1)
    # The width of the origin axis.
    origin_axis_width = 2.0
    # The origin axis is visible.
    origin_axis_visible=True
    # The grid is visible.
    grid_visible= True
    # The orientation of the plot is horizontal; for any other value, it is
    # transposed
    orientation = 'h'
    # The color of the line.
    color = black_color_trait
    # The width of the line.
    line_width = Float(1.0)
    # The style of the line.
    line_style = LineStyle("solid")
    # The style of the grid lines.
    grid_style= LineStyle("dot")

    def _gather_points(self):
        """
        Collects the data points that are within the plot bounds and caches them
        """
        # This is just a stub for now.  We should really find the lines only
        # inside the screen range here.

        x = self.index.get_data()
        y = self.value.get_data()
        rad= min(self.width/2.0,self.height/2.0)
        sx = x*rad+ self.x + self.width/2.0
        sy = y*rad+ self.y + self.height/2.0

        points = transpose(array((sx,sy)))
        self._cached_data_pts = points
        self._cache_valid = True
        return

    def _data_changed(self):
        self._cache_valid = False
        return

    def _update_mappers(self):
        #Dunno if there is anything else to do here
        self._cache_valid = False

    def _render(self, gc, points):
        """ Actually draw the plot.
        """
        with gc:
            gc.set_antialias(True)
            self._draw_default_axes(gc)
            self._draw_default_grid(gc)
            if len(points)>0:
                gc.clip_to_rect(self.x, self.y, self.width, self.height)
                gc.set_stroke_color(self.color_)
                gc.set_line_width(self.line_width)
                gc.set_line_dash(self.line_style_)

                gc.begin_path()
                gc.lines(points)
                gc.stroke_path()

        return

    def map_screen(self, data_array):
        """ Maps an array of data points into screen space and returns it as
        an array.

        Implements the AbstractPlotRenderer interface.
        """

        if len(data_array) == 0:
            return []
        elif len(data_array) == 1:
            xtmp, ytmp = transpose(data_array)
            x_ary = xtmp
            y_ary = ytmp
        else:
            x_ary, y_ary = transpose(data_array)

        sx = self.index_mapper.map_screen(x_ary)
        sy = self.value_mapper.map_screen(y_ary)

        if self.orientation == 'h':
            return transpose(array((sx, sy)))
        else:
            return transpose(array((sy, sx)))

    def map_data(self, screen_pt):
        """ Maps a screen space point into the "index" space of the plot.

        Implements the AbstractPlotRenderer interface.
        """
        if self.orientation == 'h':
            x, y = screen_pt
        else:
            y,x = screen_pt
        return array((self.index_mapper.map_data(x),
                      self.value_mapper.map_data(y)))


    def _downsample(self):
        return self.map_screen(self._cached_data_pts)

    def _draw_plot(self, *args, **kw):
        """ Draws the 'plot' layer.
        """
        # Simple compatibility with new-style rendering loop
        return self._draw_component(*args, **kw)


    def _draw_component(self, gc, view_bounds=None, mode='normal'):
        """ Renders the component.
        """
        self._gather_points()
        self._render(gc, self._cached_data_pts)

    def _bounds_changed(self, old, new):
        super(PolarLineRenderer, self)._bounds_changed(old, new)
        self._update_mappers()

    def _bounds_items_changed(self, event):
        super(PolarLineRenderer, self)._bounds_items_changed(event)
        self._update_mappers()

    def _draw_default_axes(self, gc):
        if not self.origin_axis_visible:
            return

        with gc:
            gc.set_stroke_color(self.origin_axis_color_)
            gc.set_line_width(self.origin_axis_width)
            gc.set_line_dash(self.grid_style_)
            x_data,y_data= transpose(self._cached_data_pts)
            x_center=self.x + self.width/2.0
            y_center=self.y + self.height/2.0

            for theta in range(12):
                    r= min(self.width/2.0,self.height/2.0)
                    x= r*cos(theta*pi/6) + x_center
                    y= r*sin(theta*pi/6) + y_center
                    data_pts= array([[x_center,y_center],[x,y]])
                    start,end = data_pts
                    gc.move_to(int(start[0]), int(start[1]))
                    gc.line_to(int(end[0]), int(end[1]))
                    gc.stroke_path()
        return

    def _draw_default_grid(self,gc):
        if not self.grid_visible:
            return

        with gc:
            gc.set_stroke_color(self.origin_axis_color_)
            gc.set_line_width(self.origin_axis_width)
            gc.set_line_dash(self.grid_style_)
            x_data,y_data = transpose(self._cached_data_pts)
            x_center = self.x + self.width/2.0
            y_center = self.y + self.height/2.0
            rad = min(self.width/2.0, self.height/2.0)
            for r_part in range(1,5):
                r = rad*r_part/4
                gc.arc(x_center, y_center, r, 0, 2*pi)
                gc.stroke_path()

        return

########NEW FILE########
__FILENAME__ = polar_mapper
"""
Defines the PolarMapper class, which maps from a 1-D region in data space
into a 1-D output space.
"""

# Major library imports
from numpy import array

# Enthought library imports
from traits.api import Bool, Float

# Local relative imports
from abstract_mapper import AbstractMapper

###############################################################
# same as linear mapper at the moment... to be modified later #
###############################################################
class PolarMapper(AbstractMapper):
    """
    Maps a 1-D data space to and from screen space by specifying a range in
    data space and a corresponding fixed line in screen space.

    This class concerns itself only with metric and not with orientation. So, to
    "flip" the screen space orientation, swap the values for **low_pos**
    and **high_pos**.
    """
    #------------------------------------------------------------------------
    # Private traits
    #------------------------------------------------------------------------


    _scale = Float(1.0)   # number of screen space units per data space unit
    _null_screen_range = Bool(False)
    _null_data_range = Bool(False)

    #------------------------------------------------------------------------
    # Public methods
    #------------------------------------------------------------------------

    def map_screen(self, data_array):
        """ map_screen(data_array) -> screen_array

        Converts radius and theta values from *data_array*
        to x and y values and then maps
        values from data space into screen space.
        """
        self._compute_scale()
        if self._null_data_range:
            return array([self.low_pos] * len(data_array))
        else:
            return (data_array - self.range.low) * self._scale + self.low_pos

    def map_data(self, screen_val):
        """ map_data(screen_val) -> data_val

        Maps values from screen space into data space.
        """
        self._compute_scale()
        if self._null_screen_range:
            return array([self.range.low])
        else:
            return (screen_val - self.low_pos) / self._scale + self.range.low

    #------------------------------------------------------------------------
    # Private methods
    #------------------------------------------------------------------------

    def _compute_scale(self):
        if self._cache_valid:
            return

        if self.range is None:
            self._cache_valid = False
            return

        d = self.range
        screen_range = self.high_pos - self.low_pos
        data_range = self._pol_to_rect(d.high) - self._pol_to_rect(d.low)
        if screen_range == 0.0:
            self._null_screen_range = True
        else:
            self._null_screen_range = False
        if data_range == 0.0:
            self._null_data_range = True
        else:
            self._scale = screen_range / data_range
            self._null_data_range = False

        self._cache_valid = True
        return


# EOF

########NEW FILE########
__FILENAME__ = polygon_plot
""" Defines the PolygonPlot class.
"""

from __future__ import with_statement

# Major library imports
import numpy as np

# Enthought library imports.
from enable.api import LineStyle, black_color_trait, \
                                  transparent_color_trait
from kiva.agg import points_in_polygon
from traits.api import Enum, Float, Tuple, Property, cached_property, \
                        on_trait_change

# Local imports.
from base_xy_plot import BaseXYPlot

class PolygonPlot(BaseXYPlot):
    """ Plots a polygon in dataspace.

    Assuming that the index and value mappers are linear mappers, and that
    "index" corresponds to X-coordinates and "value" corresponds to
    Y-coordinates, the points are arranged in a counter-clockwise fashion.
    The polygon is closed automatically, so there is no need to reproduce
    the first point as the last point.

    Nonlinear mappers are possible, but the results may be unexpected. Only the
    data-space points are mapped in a nonlinear fashion. Straight lines
    connecting them in a linear screen-space become curved in a nonlinear
    screen-space; however, the drawing still contains straight lines in
    screen-space.

    If you don't want the edge of the polygon to be drawn, set **edge_color**
    to transparent; don't try to do this by setting **edge_width** to 0. In
    some drawing systems, such as PostScript, a line width of 0 means to make
    the line as small as possible while still putting ink on the page.
    """

    # The color of the line on the edge of the polygon.
    edge_color = black_color_trait

    # The thickness of the edge of the polygon.
    edge_width = Float(1.0)

    # The line dash style for the edge of the polygon.
    edge_style = LineStyle

    # The color of the face of the polygon.
    face_color = transparent_color_trait

    # Override the hittest_type trait inherited from BaseXYPlot
    hittest_type = Enum("poly", "point", "line")
    
    # The RGBA tuple for rendering edges.  It is always a tuple of length 4.
    # It has the same RGB values as edge_color_, and its alpha value is the
    # alpha value of self.edge_color multiplied by self.alpha. 
    effective_edge_color = Property(Tuple, depends_on=['edge_color', 'alpha'])
    
    # The RGBA tuple for rendering the face.  It is always a tuple of length 4.
    # It has the same RGB values as face_color_, and its alpha value is the
    # alpha value of self.face_color multiplied by self.alpha.   
    effective_face_color = Property(Tuple, depends_on=['face_color', 'alpha'])

    #----------------------------------------------------------------------
    # Private 'BaseXYPlot' interface
    #----------------------------------------------------------------------

    def _gather_points(self):
        """ Collects the data points that are within the bounds of the plot and
        caches them.
        """
        if self._cache_valid:
            return

        index = self.index.get_data()
        value = self.value.get_data()

        if not self.index or not self.value:
            return

        if len(index) == 0 or len(value) == 0 or len(index) != len(value):
            self._cached_data_pts = []
            self._cache_valid = True
            return

        points = np.transpose(np.array((index,value)))
        self._cached_data_pts = points

        self._cache_valid = True


    def _render(self, gc, points):
        """ Renders an Nx2 array of screen-space points as a polygon.
        """
        with gc:
            gc.clip_to_rect(self.x, self.y, self.width, self.height)
            gc.set_stroke_color(self.effective_edge_color)
            gc.set_line_width(self.edge_width)
            gc.set_line_dash(self.edge_style_)
            gc.set_fill_color(self.effective_face_color)

            gc.lines(points)
            gc.close_path()
            gc.draw_path()


    def _render_icon(self, gc, x, y, width, height):
        """ Renders a representation of this plot as an icon into the box
        defined by the parameters.

        Used by the legend.
        """
        with gc:
            gc.set_stroke_color(self.effective_edge_color)
            gc.set_line_width(self.edge_width)
            gc.set_fill_color(self.effective_face_color)
            if hasattr(self, 'line_style_'):
                gc.set_line_dash(self.line_style_)
            gc.draw_rect((x,y,width,height))
        return

    def hittest(self, screen_pt, threshold=7.0, return_distance=False):
        """ Performs point-in-polygon testing or point/line proximity testing.
        If self.hittest_type is "line" or "point", then behaves like the
        parent class BaseXYPlot.hittest().

        If self.hittest_type is "poly", then returns True if the given
        point is inside the polygon, and False otherwise.
        """
        if self.hittest_type in ("line", "point"):
            return BaseXYPlot.hittest(self, screen_pt, threshold, return_distance)

        data_pt = self.map_data(screen_pt, all_values=True)
        index = self.index.get_data()
        value = self.value.get_data()
        poly = np.vstack((index,value)).T
        if points_in_polygon([data_pt], poly)[0] == 1:
            return True
        else:
            return False

    #------------------------------------------------------------------------
    # Event handlers
    #------------------------------------------------------------------------

    @on_trait_change('edge_color, edge_width, edge_style, face_color, alpha')
    def _attributes_changed(self):
        self.invalidate_draw()
        self.request_redraw()

    #------------------------------------------------------------------------
    # Property getters
    #------------------------------------------------------------------------

    @cached_property
    def _get_effective_edge_color(self):
        if len(self.edge_color_) == 4:
            edge_alpha = self.edge_color_[-1]
        else:
            edge_alpha = 1.0
        c = self.edge_color_[:3] + (edge_alpha * self.alpha,)
        return c

    @cached_property
    def _get_effective_face_color(self):
        if len(self.face_color_) == 4:
            face_alpha = self.face_color_[-1]
        else:
            face_alpha = 1.0
        c = self.face_color_[:3] + (face_alpha * self.alpha,)
        return c

########NEW FILE########
__FILENAME__ = quiverplot

from __future__ import with_statement

from numpy import array, compress, matrix, newaxis, sqrt, zeros

# Enthought library imports
from enable.api import ColorTrait
from traits.api import Array, Enum, Float, Instance, Int

# Chaco relative imports
from abstract_data_source import AbstractDataSource
from scatterplot import ScatterPlot

class QuiverPlot(ScatterPlot):

    # Determines how to interpret the data in the **vectors** data source.
    #   "vector": each tuple is a (dx, dy)
    #   "radial": each tuple is an (r, theta)
    data_type = Enum("vector", "radial") # TODO: implement "radial"

    # A datasource that returns an Nx2 array array indicating directions
    # of the vectors.  The interpretation of this array is dependent on
    # the setting of the **data_type** attribute.
    #
    # Usually this will be a MultiArrayDataSource.
    vectors = Instance(AbstractDataSource)

    #------------------------------------------------------------------------
    # Visual attributes of the vector
    #------------------------------------------------------------------------

    # The color of the lines
    line_color = ColorTrait("black")

    # The width of the lines
    line_width = Float(1.0)

    # The length, in pixels, of the arrowhead
    arrow_size = Int(5)

    #------------------------------------------------------------------------
    # Private traits
    #------------------------------------------------------------------------

    _cached_vector_data = Array
    _selected_vector_data = Array

    def _gather_points_old(self):
        # In addition to the standard scatterplot _gather_points, we need
        # to also grab the vectors that fall inside the view range
        super(QuiverPlot, self)._gather_points_old()

        if not self.index or not self.value:
            return

        if len(self._cached_point_mask) == 0:
            self._cached_vector_data = []
            return

        vectors = self.vectors.get_data()
        self._cached_vector_data = compress(self._cached_point_mask, vectors, axis=0)

        if self._cached_selected_pts is not None:
            indices = self._cached_selection_point_mask
            self._selected_vector_data = compress(indices, vectors, axis=0)
        else:
            self._selected_vector_data = None
        return


    def _render(self, gc, points, icon_mode=False):
        with gc:
            gc.clip_to_rect(self.x, self.y, self.width, self.height)

            gc.set_stroke_color(self.line_color_)
            gc.set_line_width(self.line_width)

            # Draw the body of the arrow
            starts = points
            ends = points + self._cached_vector_data
            gc.begin_path()
            gc.line_set(starts, ends)
            gc.stroke_path()

            if self.arrow_size > 0:
                vec = self._cached_vector_data
                unit_vec = vec / sqrt(vec[:,0] ** 2 + vec[:,1] ** 2)[:, newaxis]
                a = 0.707106781   # sqrt(2)/2

                # Draw the left arrowhead (for an arrow pointing straight up)
                arrow_ends = ends - array(unit_vec * matrix([[a, a], [-a, a]])) * self.arrow_size
                gc.begin_path()
                gc.line_set(ends, arrow_ends)
                gc.stroke_path()

                # Draw the left arrowhead (for an arrow pointing straight up)
                arrow_ends = ends - array(unit_vec * matrix([[a, -a], [a, a]])) * self.arrow_size
                gc.begin_path()
                gc.line_set(ends, arrow_ends)
                gc.stroke_path()

########NEW FILE########
__FILENAME__ = api
from formatters import *
from scales import *
from time_scale import *

########NEW FILE########
__FILENAME__ = formatters
"""
Classes for formatting labels for values or times.
"""

from math import ceil, floor, fmod, log10
from numpy import abs, all, array, asarray, amax, amin
from safetime import strftime, time, safe_fromtimestamp, localtime
import warnings


__all__ = ['NullFormatter', 'BasicFormatter', 'IntegerFormatter',
           'OffsetFormatter', 'TimeFormatter', 'strftimeEx']

class NullFormatter(object):
    """ Formatter for empty labels.
    """
    def format(ticks, numlabels=None, char_width=None):
        """ Returns a list containing an empty label for each item in *ticks*.
        """
        return [""] * len(ticks)

    def estimate_width(start, end, numlabels=None, char_width=None):
        """ Returns 0 for width and 0 for number of labels.
        """
        return 0, 0


class BasicFormatter(object):
    """ Formatter for numeric labels.
    """
    # This is a class-level default that is related to the algorithm in format()
    avg_label_width = 7.0

    # Toggles whether or not to use scientific notation when the values exceed
    # scientific_limits
    use_scientific = True

    # Any number smaller than 10 ** limits[0] or larger than 10 ** limits[1]
    # will be represented using scientific notiation.
    scientific_limits = (-3, 5)

    def __init__(self, **kwds):
        # Allow the user to override the class-level defaults.
        self.__dict__.update(kwds)

    def oldformat(self, ticks, numlabels=None, char_width=None):
        """ This function is adapted from matplotlib's "OldScalarFormatter".

        Parameters
        ----------
        ticks : array of numbers
            The tick values to be formatted.
        numlabels
            Not used.
        char_width
            Not used.

        Returns
        -------
        List of formatted labels.
        """
        labels = []
        if len(ticks) == 0:
            return []

        d = abs(ticks[-1] - ticks[0])
        for x in ticks:
            if abs(x)<1e4 and x==int(x):
                labels.append('%d' % x)
                continue

            if d < 1e-2: fmt = '%1.3e'
            elif d < 1e-1: fmt = '%1.3f'
            elif d > 1e5: fmt = '%1.1e'
            elif d > 10 : fmt = '%1.1f'
            elif d > 1 : fmt = '%1.2f'
            else: fmt = '%1.3f'
            s =  fmt % x
            tup = s.split('e')
            if len(tup)==2:
                mantissa = tup[0].rstrip('0').rstrip('.')
                sign = tup[1][0].replace('+', '')
                exponent = tup[1][1:].lstrip('0')
                if sign or exponent:
                    s = '%se%s%s' %(mantissa, sign, exponent)
                else:
                    s = mantissa
            else:
                s = s.rstrip('0').rstrip('.')
            labels.append(s)
        return labels

    def format(self, ticks, numlabels=None, char_width=None, fill_ratio=0.3):
        """ Does "nice" formatting of floating-point numbers.  *numlabels* is
        ignored in this method.
        """
        if len(ticks) == 0:
            return []

        ticks = asarray(ticks)
        if self.use_scientific:
            scientific = (((ticks % 10 ** self.scientific_limits[1]) == 0) |
                          (abs(ticks) <= 10 ** self.scientific_limits[0])).all()
        else:
            scientific = False

        if scientific:
            if char_width is not None:
                # We need to determine how many digits we can use in the
                # mantissa based on the order of magnitude of the exponent.
                chars_per_label = int(char_width * fill_ratio / len(ticks))
                maxtick = amax(abs(ticks))
                if maxtick > 0:
                    exp_oom = str(int(floor(log10(maxtick))))
                else:
                    exp_oom = "0"
                emax = len(exp_oom)

                if chars_per_label < emax:
                    # We're sort of hosed.  Use a minimum 3 chars for the mantissa.
                    mmax = 3
                else:
                    mmax = chars_per_label - emax - 1
            else:
                mmax = -1
            labels = [self._nice_sci(x, mmax) for x in ticks]

        else:
            # For decimal mode,
            if not (ticks % 1).any():
                labels = map(str, ticks.astype(int))
            else:
                labels = map(str, ticks)

        return labels

    def _nice_sci(self, val, mdigits, force_sign=False):
        """ Formats *val* nicely using scientific notation.  *mdigits* is the
        max number of digits to use for the mantissa.  If *force_sign* is True,
        then always show the sign of the mantissa, otherwise only show the sign
        if *val* is negative.
        """
        if val != 0:
            e = int(floor(log10(abs(val))))
        else:
            e = 0
        m = val / float(10**e)
        m_str = str(m)

        # Safely truncating the mantissa is somewhat tricky.  The minimum
        # length of the mantissa is everything up to (but not including) the
        # period.  If the m_str doesn't have a decimal point, then we have to
        # ignore mdigits.
        if mdigits > 0 and "." in m_str:
            max_len = max(m_str.index("."), mdigits)
            m_str = m_str[:max_len]

            # Strip off a trailing decimal
            if m_str[-1] == ".":
                m_str = m_str[:-1]

            # It's not sufficient just to truncate the string; we need to
            # handle proper rounding

        else:
            # Always strip off a trailing decimal
            if m_str[-1] == ".":
                m_str = m_str[:-1]

        if force_sign and not m_str.startswith("-"):
            m_str = "+" + m_str

        if e != 0:
            # Clean up the exponent
            e_str = str(e)

            if e_str.startswith("+") and not force_sign:
                e_str = e_str[1:]
            m_str += "e" + e_str

        return m_str


    def estimate_width(self, start, end, numlabels=None, char_width=None,
                       fill_ratio=0.3, ticker=None):
        """ Returns an estimate of the total number of characters used by the
        the labels for the given set of inputs, as well as the number of labels.

        Parameters
        ----------
        start : number
            The beginning of the interval.
        end : number
            The end of the interval.
        numlabels : number
            The ideal number of labels to generate on the interval.
        char_width : number
            The total character width available for labelling the interval.
        fill_ratio : 0.0 < float <= 1.0
            Ratio of the available width that will be occupied by label text.
        ticker : AbstractScale object
            Object that can calculate the number of labels needed.

        Returns
        -------
        (numlabels, total label width)
        """
        if numlabels == 0 or char_width == 0:
            return 0, 0

        # use the start and end points as ticks and average their label sizes
        labelsizes = map(len, self.format([start, end]))
        avg_size = sum(labelsizes) / 2.0

        if ticker:
            if numlabels:
                initial_estimate = numlabels
            elif char_width:
                initial_estimate = round(fill_ratio * char_width / avg_size)

            est_ticks = ticker.num_ticks(start, end, initial_estimate)

        elif numlabels:
            est_ticks = numlabels

        elif char_width:
            est_ticks = round(fill_ratio * char_width / avg_size)

        return est_ticks, est_ticks * avg_size


class IntegerFormatter(BasicFormatter):
    """ Format integer tick labels as integers.
    """

    def format(self, ticks, numlabels=None, char_width=None, fill_ratio=0.3):
        """ Formats integer tick labels.
        """
        return map(str, map(int, ticks))


class OffsetFormatter(BasicFormatter):
    """ This formatter is like BasicFormatter, but it supports formatting
    ticks using an offset.  This is useful for viewing small ranges within
    big numbers.
    """

    # Whether or not to use offsets when labelling the ticks.  Note that
    # even if this is true, offset are only used when the ratio of the data
    # range to the average data value is smaller than a threshold.
    use_offset = False

    # The threshold ratio of the data range to the average data value, below
    # which "offset" display mode will be used if use_offset is True.
    offset_threshold = 1e-3

    # Determines which ticks to display the offset value at.  Can be "all",
    # "firstlast", or "none".
    offset_display = "firstlast"

    # Determines which format to use to display the end labels.  Can be
    # "offset" or "sci".
    end_label_format = "offset"

    # Specifies the threshold values
    offset_limits = (-3, 4)

    # There are two possible formats for the offset.
    #
    # "sci"
    #     uses scientific notation for the offset
    # "decimal"
    #     pads with zeroes left or right until the decimal
    #
    # The following table shows some example ranges and how an intermediate
    # tick will be displayed.  These all assume an offset_display value of
    # "none" or "firstlast".
    #
    #  ============     ==========       =========      =========
    #     start            end             sci          decimal
    #  ============     ==========       =========      =========
    #    90.0004         90.0008         5.0e-4          .0005
    #    90.0004         90.0015         1.2e-3          .0012
    #   -1200015        -1200003           12              12
    #    2300015000     2300015030       1.502e4         15020
    #  ============     ==========       =========      =========
    #
    offset_format = "sci"

    # The offset generated by the last call to format()
    offset = None


    def _compute_offset(self, ticks):
        first, last = ticks[0], ticks[-1]
        data_range = ticks[-1] - ticks[0]
        range_oom = int(ceil(log10(data_range)))
        pow_of_ten = 10 ** range_oom
        if all(asarray(ticks) < 0):
            return ceil(amax(ticks) / pow_of_ten) * pow_of_ten
        else:
            return floor(amin(ticks) / pow_of_ten) * pow_of_ten


    def format(self, ticks, numlabels=None, char_width=None):
        if len(ticks) == 0:
            return []

        data_range = ticks[-1] - ticks[0]
        avg_data = sum(abs(ticks)) / len(ticks)
        if self.use_offset and data_range/avg_data < self.offset_threshold:
            offset = self._compute_offset(ticks)
            intermed_ticks = asarray(ticks) - offset

            if self.offset_format == "sci":
                labels = BasicFormatter.format(self, intermed_ticks)
            else:
                # have to decide between %d and %f here.  also have to
                # strip trailing "0"s.. test with %g.
                labels = ["%g" % i for i in intermed_ticks]

            if offset > 0:
                sign = "+"
            else:
                sign = ""
            offset_str = BasicFormatter.format(self, [offset])[0] + sign
            if self.offset_display == "firstlast":
                if self.end_label_format == "offset":
                    labels[0] = offset_str + labels[0]
                    labels[-1] = offset_str + labels[-1]
                else:
                    labels[0] = BasicFormatter.format(self, [ticks[0]])[0]
                    labels[-1] = BasicFormatter.format(self, [ticks[-1]])[0]

            elif self.offset_display == "all":
                labels = [offset_str + label for label in labels]

            return labels
        else:
            return BasicFormatter.format(self, ticks, numlabels, char_width)

    def estimate_width(self, start, end, numlabels=None, char_width=None,
                       fill_ratio=0.3, ticker=None):
        if numlabels == 0 or char_width == 0:
            return (0, 0)

        if ticker:
            if numlabels:
                initial_estimate = numlabels
            elif char_width:
                avg_size = len("%g%g" % (start, end)) / 2.0
                initial_estimate = round(fill_ratio * char_width / avg_size)
            est_ticks = int(ticker.num_ticks(start, end, initial_estimate))

        elif numlabels:
            est_ticks = numlabels

        elif char_width:
            est_ticks = round(fill_ratio * char_width / avg_size)

        start, mid, end = map(len, self.format([start, (start+end)/2.0, end]))
        if est_ticks > 2:
            size = start + end + (est_ticks-2) * mid
        else:
            size = start + end

        return est_ticks, size


def strftimeEx(fmt, t, timetuple=None):
    """
    Extends time.strftime() to format milliseconds and microseconds.

    Expects input to be a floating-point number of seconds since epoch.
    The additional formats are:

    - ``%(ms)``:  milliseconds (uses round())
    - ``%(ms_)``: milliseconds (uses floor())
    - ``%(us)``:  microseconds (uses round())

    The format may also be a callable which will bypass time.strftime() entirely.
    """
    if callable(fmt):
        return fmt(t)

    if "%(ms)" in fmt:
        # Assume that fmt does not also contain %(ms_) and %(us).
        # (It really doesn't make sense to mix %(ms) with those.)
        secs, frac = divmod(round(t,3), 1)
        ms = int(round(1e3*frac))
        fmt = fmt.replace("%(ms)", "%03d" % ms)
    else:
        # Assume fmt contains %(ms_) and %(us).
        secs, frac = divmod(round(t,6), 1)
        ms = int(round(1e3*frac))
        ms_, us = divmod(int(round(1e6*frac)),1000)
        fmt = fmt.replace("%(ms_)", "%03d" % ms_)
        fmt = fmt.replace("%(us)", "%03d" % us)

    if not timetuple:
        timetuple = localtime(secs)

    return strftime(fmt, timetuple)


def _two_digit_year(t):
    """ Round to the nearest Jan 1, roughly.
    """
    dt = safe_fromtimestamp(t)
    year = dt.year
    if dt.month >= 7:
        year += 1
    return "'%02d" % (year % 100)

def _four_digit_year(t):
    """ Round to the nearest Jan 1, roughly.
    """
    dt = safe_fromtimestamp(t)
    year = dt.year
    if dt.month >= 7:
        year += 1
    return str(year)


class TimeFormatter(object):
    """ Formatter for time values.
    """
    # This table of format is convert into the 'formats' dict.  Each tuple of
    # formats must be ordered from shortest to longest.
    _formats = {
        'microseconds': ('%(us)us', '%(ms_).%(us)ms'),
        'milliseconds': ('%(ms)ms', '%S.%(ms)s'),
        'seconds': (':%S', '%Ss'),
        'minsec': ('%M:%S',), # '%Mm%S', '%Mm%Ss'),
        'minutes': ('%Mm',),
        'hourmin': ('%H:%M',), #'%Hh%M', '%Hh%Mm', '%H:%M:%S','%Hh %Mm %Ss'),
        'hours': ('%Hh', '%H:%M'),
        'days': ('%m/%d', '%a%d',),
        'months': ('%m/%Y', '%b%y'),
        'years': (_two_digit_year, _four_digit_year),
        }

    # Labels of time units, from finest to coarsest.
    format_order = ['microseconds', 'milliseconds', 'seconds', 'minsec', 'minutes',
                    'hourmin', 'hours', 'days', 'months', 'years']

    # A dict whose are keys are the strings in **format_order**; each value is
    # two arrays, (widths, format strings/functions).
    formats = {}

    # Whether or not to strip the leading zeros on tick labels.
    strip_leading_zeros = True

    def __init__(self, **kwds):
        self.__dict__.update(kwds)
        self._compute_format_weights()

    def _compute_format_weights(self):
        if self.formats:
            return

        for fmt_name, fmt_strings in self._formats.items():
            sizes = []
            tmptime = time()
            for s in fmt_strings:
                size = len(strftimeEx(s, tmptime))
                sizes.append(size)
            self.formats[fmt_name] = (array(sizes), fmt_strings)
        return

    def _get_resolution(self, resolution, interval):
        r = resolution
        span = interval
        if r < 5e-4:
            resol = "microseconds"
        elif r < 0.5:
            resol = "milliseconds"
        elif r < 60:
            if span > 60:
                resol = "minsec"
            else:
                resol = "seconds"
        elif r < 3600:
            if span > 3600:
                resol = "hourmin"
            else:
                resol = "minutes"
        elif r < 24*3600:
            resol = "hours"
        elif r < 30*24*3600:
            resol = "days"
        elif r < 365*24*3600:
            resol = "months"
        else:
            resol = "years"
        return resol

    def format(self, ticks, numlabels=None, char_width=None, fill_ratio = 0.3,
               ticker=None):
        """ Formats a set of time values.

        Parameters
        ----------
        ticks : array of numbers
            The tick values to be formatted
        numlabels
            Not used.
        char_width : number
            The total character width available for labelling the interval.
        fill_ratio : 0.0 < float <= 1.0
            Ratio of the available width that will be occupied by label text.
        ticker : AbstractScale object
            Object that can calculate the number of labels needed.

        Returns
        -------
        List of formatted labels.

        """
        # In order to pick the right set of labels, we need to determine
        # the resolution of the ticks.  We can do this using a ticker if
        # it's provided, or by computing the resolution from the actual
        # ticks we've been given.
        if len(ticks) == 0:
            return []

        span = abs(ticks[-1] - ticks[0])
        if ticker:
            r = ticker.resolution
        else:
            r = span / (len(ticks) - 1)
        resol = self._get_resolution(r, span)

        widths, formats = self.formats[resol]
        format = formats[0]
        if char_width:
            # If a width is provided, then we pick the most appropriate scale,
            # otherwise just use the widest format
            good_formats = array(formats)[widths * len(ticks) < fill_ratio * char_width]
            if len(good_formats) > 0:
                format = good_formats[-1]

        # Apply the format to the tick values
        labels = []
        resol_ndx = self.format_order.index(resol)

        # This dictionary maps the name of a time resolution (in self.format_order)
        # to its index in a time.localtime() timetuple.  The default is to map
        # everything to index 0, which is year.  This is not ideal; it might cause
        # a problem with the tick at midnight, january 1st, 0 a.d. being incorrectly
        # promoted at certain tick resolutions.
        time_tuple_ndx_for_resol = dict.fromkeys(self.format_order, 0)
        time_tuple_ndx_for_resol.update( {
                "seconds" : 5,
                "minsec" : 4,
                "minutes" : 4,
                "hourmin" : 3,
                "hours" : 3,
                })

        # As we format each tick, check to see if we are at a boundary of the
        # next higher unit of time.  If so, replace the current format with one
        # from that resolution.  This is not the best heuristic in the world,
        # but it works!  There is some trickiness here due to having to deal
        # with hybrid formats in a reasonable manner.
        for t in ticks:
            try:
                tm = localtime(t)
                s = strftimeEx(format, t, tm)
            except ValueError, e:
                warnings.warn("Unable to convert tick for timestamp " + str(t))
                labels.append("ERR")
                continue

            hybrid_handled = False
            next_ndx = resol_ndx

            # The way to check that we are at the boundary of the next unit of
            # time is by checking that we have 0 units of the resolution, i.e.
            # we are at zero minutes, so display hours, or we are at zero seconds,
            # so display minutes (and if that is zero as well, then display hours).
            while tm[ time_tuple_ndx_for_resol[self.format_order[next_ndx]] ] == 0:
                next_ndx += 1
                if next_ndx == len(self.format_order):
                    break
                if resol in ("minsec", "hourmin") and not hybrid_handled:
                    if (resol == "minsec" and tm.tm_min == 0 and tm.tm_sec != 0) or \
                        (resol == "hourmin" and tm.tm_hour == 0 and tm.tm_min != 0):
                        next_format = self.formats[self.format_order[resol_ndx-1]][1][0]
                        s = strftimeEx(next_format, t, tm)
                        break
                    else:
                        hybrid_handled = True

                next_format = self.formats[self.format_order[next_ndx]][1][0]
                s = strftimeEx(next_format, t, tm)

            if self.strip_leading_zeros:
                ss = s.lstrip('0')
                if ss != s and (ss == '' or not ss[0].isdigit()):
                    # A label such as '000ms' should leave one zero.
                    ss = '0' + ss
                labels.append(ss)
            else:
                labels.append(s)

        return labels

    def estimate_width(self, start, end, numlabels=None, char_width=None,
                       fill_ratio = 0.2, ticker=None):
        """ Returns an estimate of the total number of characters used by the
        the labels for the given set of inputs, as well as the number of labels.

        Parameters
        ----------
        start : number
            The beginning of the interval.
        end : number
            The end of the interval.
        numlabels : number
            The ideal number of labels to generate on the interval.
        char_width : number
            The total character width available for labelling the interval.
        fill_ratio : 0.0 < float <= 1.0
            Ratio of the available width that will be occupied by label text.
        ticker : AbstractScale object
            Object that can calculate the number of labels needed.

        Returns
        -------
        (numlabels, total label width)
        """
        if numlabels == 0 or char_width == 0:
            return 0, 0

        if ticker is None or not hasattr(ticker, "unit"):
            raise ValueError("TimeFormatter requires a scale.")

        if not numlabels:
            numlabels = ticker.num_ticks(start, end)

        span = abs(end - start)
        if ticker:
            r = ticker.resolution
        else:
            r = span / numlabels
        unit = self._get_resolution(r, span)

        if unit == "milliseconds":
            return numlabels, numlabels * 6

        widths, strings = self.formats[unit]

        if char_width:
            # Find an appropriate resolution in self.formats and pick between
            # the various format strings
            good_widths = widths[widths * numlabels < fill_ratio * char_width]
            if len(good_widths) == 0:
                # All too big, pick the first label
                width = widths[0]
            else:
                # Pick the largest label that fits
                width = good_widths[-1]
            width *= numlabels
        else:
            # Just pick the middle of the pack of format widths
            width = widths[ int(len(widths) / 2) ] * numlabels

        return numlabels, width



########NEW FILE########
__FILENAME__ = safetime
""" This module wraps the standard library time module to gracefully
handle bad input values for time.
"""

import warnings
import time as stdlib_time
# Yup, we're exposing everything from time.
from time import *
from datetime import datetime, timedelta, MINYEAR, MAXYEAR

__all__ = ([x for x in dir(stdlib_time) if not x.startswith('_')]
    + ['safe_fromtimestamp', 'datetime', 'timedelta', 'MINYEAR', 'MAXYEAR',
        'EPOCH'])

EPOCH = datetime.fromtimestamp(0.0)

# Can't monkeypatch methods of anything in datetime, so we have to wrap them
def safe_fromtimestamp(timestamp, *args, **kwds):
    """ safe_fromtimestamp(timestamp) -> UTC time from POSIX timestamp.

    Timestamps outside of the valid range will be assigned datetime objects of
    Jan 1 of either MINYEAR or MAXYEAR, whichever appears closest.

    WARNING: This function does not behave properly with Daylight Savings Time,
    due to a documented issue with datetime arithmetic.
    """
    try:
        return EPOCH + timedelta(seconds=timestamp)
    except (ValueError, OverflowError), e:
        warnings.warn("Timestamp out of range.  Returning safe default value.")
        if timestamp <= 0:
            return datetime(MINYEAR, 1, 1, 0, 0, 0)
        else:
            return datetime(MAXYEAR, 1, 1, 0, 0, 0)

def mktime(t):
    """ mktime(tuple) -> floating point number

    Convert a time tuple in local time to seconds since the Epoch. Invalid time
    tuples will be assigned the value 0.0 and a warning will be issued.
    """
    try:
        return stdlib_time.mktime(t)
    except (ValueError, OverflowError):
        warnings.warn("Bad time for mktime().  Returning 0.")
        # mktime() returns a float
        return 0.0

def doy(dt):
    """ Find the day of year of the datetime.

    The returned DoY is in the range [1-366].
    """
    date = dt.date()
    jan01 = date.replace(month=1, day=1)
    doy = (date - jan01).days + 1
    return doy

struct_time = type(stdlib_time.localtime())

def localtime(t=None):
    """
    localtime([seconds]) -> (tm_year,tm_mon,tm_day,tm_hour,tm_min,tm_sec,tm_wday,tm_yday,tm_isdst)

    Convert seconds since the Epoch to a time tuple expressing local time.
    When 'seconds' is not passed in, convert the current time instead.

    Modified to accept timestamps before the Epoch.
    """
    if t is None:
        dt = datetime.now()
    else:
        dt = safe_fromtimestamp(t)
    timetuple = (dt.year, dt.month, dt.day, dt.hour, dt.minute, dt.second,
        dt.weekday(), doy(dt), -1)
    return struct_time(timetuple)


########NEW FILE########
__FILENAME__ = scales
"""
Functions and classes that compute ticks and labels for graph axes, with
special handling of time and calendar axes.
"""

from bisect import bisect
from math import ceil, floor, log10
from numpy import abs, argmin, array, isnan, linspace

# Local imports
from formatters import BasicFormatter


__all__ = ["AbstractScale", "DefaultScale", "FixedScale", "Pow10Scale",
           "LogScale", "ScaleSystem", "heckbert_interval", "frange"]

def frange(min, max, delta):
    """ Floating point range. """
    count = int(round((max - min) / delta)) + 1
    return [min + i*delta for i in range(count)]

class AbstractScale(object):
    """ Defines the general interface for scales. """

    DEFAULT_NUM_TICKS = 8

    def ticks(self, start, end, desired_ticks=None):
        """ Returns the set of "nice" positions on this scale that enclose and
        fall inside the interval (*start*,*end*).

        Parameters
        ----------
        start : number
            The beginning of the scale interval.
        end : number
            The end of the scale interval.
        desired_ticks : integer
            Number of ticks that the caller would like to get

        """
        raise NotImplementedError

    def num_ticks(self, start, end, desired_ticks=None):
        """ Returns an approximate number of ticks that this scale
        produces for the given interval.

        This method is used by the scale system to determine whether this is
        the appropriate scale to use for an interval; the returned number of
        ticks does not have to be exactly the same as what ticks() returns.

        Parameters
        ----------
        start : number
            The beginning of the scale interval.
        end : number
            The end of the scale interval.
        desired_ticks : integer
            Number of ticks that the caller would like to get

        Returns
        -------
        A float or an integer.
        """
        raise NotImplementedError

    def labels(self, start, end, numlabels=None, char_width=None):
        """ Returns a series of ticks and corresponding strings for labels
        that fall inside the interval (*start*,*end*).

        Parameters
        ----------
        start : number
            The beginning of the scale interval.
        end : number
            The end of the scale interval.
        numlabels : number
            The ideal number of labels to generate on the interval.
        char_width : number
            The total character width available for labelling the interval.

        One of *numlabels* or *char_width* must be provided. If both are
        provided, then both are considered when picking label density and format.
        """
        ticks = self.ticks(start, end, numlabels)
        labels = self.formatter.format(ticks, numlabels, char_width)
        return zip(ticks, labels)

    def label_width(self, start, end, numlabels=None, char_width=None):
        """ Returns an estimate of the total number of characters used by the
        the labels that this scale produces for the given set of
        inputs, as well as the number of labels.

        Parameters
        ----------
        start : number
            The beginning of the scale interval.
        end : number
            The end of the scale interval.
        numlabels : number
            The ideal number of labels to generate on the interval.
        char_width : number
            The total character width available for labelling the interval.

        Returns
        -------
        (numlabels, total label width)
        """
        return self.formatter.estimate_width(start, end, numlabels, char_width,
                                             ticker=self)


class FixedScale(AbstractScale):
    """ A scale with fixed resolution, and "nice" points that line up at
    multiples of the resolution.  An optional zero value can be defined
    that offsets the "nice" points to (N*resolution+zero).
    """
    def __init__(self, resolution, zero=0.0, formatter=None):
        self.resolution = resolution
        self.zero = zero
        if formatter is None:
            formatter = BasicFormatter()
        self.formatter = formatter

    def ticks(self, start, end, desired_ticks=None):
        """ For FixedScale, *desired_ticks* is ignored.

        Overrides AbstractScale.
        """
        if start == end or isnan(start) or isnan(end):
            return []
        res = self.resolution
        start -= self.zero
        end -= self.zero
        start_tick = int(ceil(start / res))
        end_tick = int(floor(end / res))
        ticks = [i*res for i in range(start_tick, end_tick+1)]
        return ticks

    def num_ticks(self, start, end, desired_ticks=None):
        """ For FixedScale, *desired_ticks* is ignored.

        Overrides AbstractScale.
        """
        if self.resolution is None or self.resolution == 0.0:
            return 0
        else:
            return (end - start) / self.resolution

def _nice(x, round=False):
    """ Returns a bracketing interval around interval *x*, whose endpoints fall
    on "nice" values.  If *round* is False, then it uses ceil(range)

    This function is adapted from the original in Graphics Gems; the boundaries
    have been changed to use (1, 2.5, 5, 10) as the nice values instead of
    (1, 2, 5, 10).
    """
    if x <= 0:
        import warnings
        warnings.warn("Invalid (negative) range passed to tick interval calculation")
        x = abs(x)
    expv = floor(log10(x))
    f = x / pow(10, expv)
    if round:
        if f < 1.75:
            nf = 1.0
        elif f < 3.75:
            nf = 2.5
        elif f < 7.0:
            nf = 5.0
        else:
            nf = 10.0
    else:
        if f <= 1.0:
            nf = 1.0
        elif f <= 2.5:
            nf = 2.5
        elif f <= 5.0:
            nf = 5.0
        else:
            nf = 10.0
    return nf * pow(10, expv)

def heckbert_interval(data_low, data_high, numticks=8, nicefunc=_nice, enclose=False):
    """ Returns a "nice" range and resolution for an interval and a preferred
    number of ticks, using Paul Heckbert's algorithm in Graphics Gems.

    If *enclose* is True, then the function returns a min and a max that fall
    inside *data_low* and *data_high*; if *enclose* is False, the nice interval
    can be larger than the input interval.
    """
    if data_high == data_low:
        return data_high, data_low, 0
    if numticks == 0:
        numticks = 1

    range = nicefunc(data_high - data_low)
    if numticks > 1:
        numticks -= 1
    d = nicefunc(range / numticks, round=True)
    if enclose:
        graphmin = ceil(data_low / d) * d
        graphmax = floor(data_high / d) * d
    else:
        graphmin = floor(data_low / d) * d
        graphmax = ceil(data_high / d) * d
    return graphmin, graphmax, d


class DefaultScale(AbstractScale):
    """ A dynamic scale that tries to place ticks at nice numbers (1, 2, 5, 10)
    so that ticks don't "pop" as the resolution changes.
    """
    def __init__(self, formatter=None):
        if formatter is None:
            formatter = BasicFormatter()
        self.formatter = formatter

    def ticks(self, start, end, desired_ticks=8):
        """ Returns the set of "nice" positions on this scale that enclose and
        fall inside the interval (*start*,*end*).

        Implements AbstractScale.
        """
        if start == end or isnan(start) or isnan(end):
            return [start]
        min, max, delta = heckbert_interval(start, end, desired_ticks, enclose=True)
        return frange(min, max, delta)

    def num_ticks(self, start, end, desired_ticks=8):
        """ Returns an approximate number of ticks that this scale
        produces for the given interval.

        Implements AbstractScale.
        """
        return len(self.ticks(start, end, desired_ticks))


class Pow10Scale(AbstractScale):
    """ A dynamic scale that shows only whole multiples of powers of 10
    (including powers < 1).
    """

    def __init__(self, formatter=None):
        if formatter is None:
            formatter = BasicFormatter()
        self.formatter = formatter

    def ticks(self, start, end, desired_ticks=8):
        """ Returns the set of "nice" positions on this scale that enclose and
        fall inside the interval (*start*,*end*).

        Implements AbstractScale.
        """
        if start == end or isnan(start) or isnan(end):
            return [start]
        min, max, delta = heckbert_interval(start, end, desired_ticks,
                                            nicefunc=self._nice_pow10,
                                            enclose = True)
        return frange(min, max, delta)

    def num_ticks(self, start, end, desired_ticks=8):
        """ Returns an approximate number of ticks that this scale
        produces for the given interval.

        Implements AbstractScale.
        """
        return len(self.ticks(start, end, desired_ticks))

    def _nice_pow10(self, x, round=False):
        return pow(10, floor(log10(x)))


class LogScale(AbstractScale):
    """ A dynamic scale that only produces ticks and labels that work well when
    plotting data on a logarithmic scale.
    """
    def __init__(self, formatter=None):
        if formatter is None:
            formatter = BasicFormatter()
        self.formatter = formatter

    # In the following utility functions, "irep" stands for "integer representation".
    # For a given base interval size i (i.e. "magic number"), there is a one-to-one
    # mapping between the nice tick values and the integers.

    def _irep_to_value(self,n,i):
        """ For a given "magic number" i (i.e. spacing of the evenly spaced ticks
        in the decade [1,10]), compute the tick value of the given integer
        representation."""
        if i == 1:
            j,k = divmod(n,9)
            v = (k+1)*10**j
            return v
        else:
            j,k = divmod(n,int(10.0/i))
            if k == 0:
                v = 10**j
            else:
                v = i*k*10**j
            return v

    def _power_and_interval(self,x,i):
        # j is the power of 10 of the decade in which x lies
        j = int(ceil(log10(x))) - 1
        # b is the interval size of the evenly spaced ticks in the decade
        b = i*10**j
        return (j,b)

    def _power_and_index_to_irep(self,j,k,i):
        if i == 1:
            n = j*9+(k-1)
        else:
            n = j*int(10.0/i)+k
        return n

    def _logtickceil_as_irep(self,x,i):
        """ For a given "magic number" i (i.e. spacing of the evenly spaced ticks
        in the decade [1,10]), compute the integer representation of the smallest
        tick not less than x."""
        j,b = self._power_and_interval(x,i)
        k = int(ceil(float(x)/b))
        n = self._power_and_index_to_irep(j,k,i)
        return n

    def _logtickfloor_as_irep(self,x,i):
        """ For a given "magic number" i (i.e. spacing of the evenly spaced ticks
        in the decade [1,10]), compute the integer representation of the largest
        tick not greater than x."""
        j,b = self._power_and_interval(x,i)
        k = int(floor(float(x)/b))
        n = self._power_and_index_to_irep(j,k,i)
        return n

    def ticks(self, start, end, desired_ticks=8):
        """ Compute a "nice" set of ticks for a log scale."""
        if start > end:
            start, end = end, start

        if start == 0.0:
            # Whoever calls us with a value of 0.0 puts themselves at our mercy
            log_start = 1e-9
        else:
            log_start = log10(start)

        if end == 0.0:
            log_end = 1e-9
        else:
            log_end = log10(end)
        log_interval = log_end - log_start

        if log_interval < 1.0:
            # If the data is spaced by less than a factor of 10, then use
            # regular/linear ticking
            min, max, delta = heckbert_interval(start, end, desired_ticks,
                                                                enclose=True)
            return frange(min, max, delta)

        elif log_interval < desired_ticks:
            magic_numbers = [1, 2, 5]
            for interval in magic_numbers:
                n1 = self._logtickceil_as_irep(start,interval)
                n2 = self._logtickfloor_as_irep(end,interval)
                ticks = [self._irep_to_value(n,interval) for n in range(n1,n2+1)]
                if len(ticks) < desired_ticks * 1.5:
                    return ticks
            return ticks

        else:
            # Put lines at every power of ten
            startlog = ceil(log_start)
            endlog = floor(log_end)
            expticks = linspace(startlog, endlog, endlog - startlog + 1)
            return 10**expticks

    def num_ticks(self, start, end, desired_ticks=8):
        """ Returns an approximate number of ticks that this scale
        produces for the given interval.

        Implements AbstractScale.
        """
        return len(self.ticks(start, end, desired_ticks))

##############################################################################
#
# ScaleSystem
#
##############################################################################

class ScaleSystem(object):
    """ Represents a collection of scales over some range of resolutions.

    This class has settings for a default scale that is used when ticking an
    interval that is smaller than the finest resolution scale or larger than
    the coarsest resolution scale.
    """

    def __init__(self, *scales, **kw):
        """ Creates a ScaleSystem

        Usage::

            ScaleSystem(scale1, .., scaleN, default_scale = DefaultScale())

        If *default_scale* is not specified, then an instance of DefaultScale()
        is created.  If no *default_scale* is needed, then set it to None.
        """
        self.scales = scales
        self.default_scale = kw.get("default_scale", DefaultScale())

        # Heuristics for picking labels
        # The ratio of total label character count to the available character width
        self.fill_ratio = 0.3
        self.default_numticks = 8


    def ticks(self, start, end, numticks=None):
        """ Computes nice locations for tick marks.

        Parameters
        ==========
        start, end : number
            The start and end values of the data.
        numticks : number
            The desired number of ticks to produce.
        scales : a list of tuples of (min_interval, Scale)
            Scales to use, in order from fine resolution to coarse.
            If the end-start interval is less than a particular scale's
            *min_interval*, then the previous scale is used.

        Returns
        =======
        A list of positions where the ticks are to be placed.
        """

        if numticks == 0:
            return []
        elif start == end or isnan(start) or isnan(end):
            return []
        elif numticks is None:
            numticks = self.default_numticks

        scale = self._get_scale(start, end, numticks)
        ticks = scale.ticks(start, end, numticks)
        return ticks

    def labels(self, start, end, numlabels=None, char_width=None):
        """ Computes position and labels for an interval

        Parameters
        ----------
        start : number
            The beginning of the scale interval.
        end : number
            The end of the scale interval.
        numlabels : number
            The ideal number of labels to generate on the interval.
        char_width : number
            The total character width available for labelling the interval.

        One of *numlabels* or *char_width* must be provided.  If both are
        provided, then both are considered when picking label density and format.

        Returns
        -------
        A list of (tick position, string) tuples.
        """

        # Check for insufficient arguments.
        if numlabels is None and char_width is None:
            raise ValueError, "Either numlabels or char_width (or both) must be given."

        if numlabels == 0 or char_width == 0 or isnan(start) or isnan(end):
            return []

        # There are three cases:
        #   1. we are given numlabels but not char_width
        #   2. we are given char_width and not numlabels
        #   3. we are given both
        #
        # Case 1: Use numlabels to find the closest scale purely on tick count.
        # Case 2: Query all scales for their approximate label_width, pick the
        #         closest one to char_width * self.fill_ratio
        # Case 3: Use numlabels to find the closest scale based on tick count.

        if numlabels and not char_width:
            # numlabels was given, but not char_width.
            scale = self._get_scale(start, end, numlabels)
            labels = scale.labels(start, end, numlabels)

        else:
            # char_width was given.
            if numlabels:
                # Both numlabels and char_width were given.
                scale = self._get_scale(start, end, numlabels)
                try:
                    ndx = list(self.scales).index(scale)
                    low = max(0, ndx - 1)
                    high = min(len(self.scales), ndx + 1)
                    scales = self.scales[low:high]
                except ValueError:
                    scales = [scale]
            else:
                # Only char_width was given.
                if len(self.scales) == 0:
                    scales = [self.default_scale]
                else:
                    scales = self.scales

            counts, widths = zip(*[s.label_width(start, end, char_width=char_width) \
                                      for s in scales])
            widths = array(widths)
            closest = argmin(abs(widths - char_width*self.fill_ratio))
            if numlabels is None:
                numlabels = scales[closest].num_ticks(start, end, counts[closest])
            labels = scales[closest].labels(start, end, numlabels,
                                            char_width=char_width)

        return labels


    def _get_scale(self, start, end, numticks):
        if len(self.scales) == 0:
            closest_scale = self.default_scale
        else:
            closest_scale = self._get_scale_np(start, end, numticks)

            if self.default_scale is not None:
                # Handle the edge cases and see if there is a major discrepancy between
                # what the scales offer and the desired number of ticks; if so, revert
                # to using the default scale
                approx_ticks = closest_scale.num_ticks(start, end, numticks)
                if (approx_ticks == 0) or (numticks == 0) or \
                       (abs(approx_ticks - numticks) / numticks > 1.2) or \
                       (abs(numticks - approx_ticks) / approx_ticks > 1.2):
                    closest_scale = self.default_scale
        return closest_scale

    def _get_scale_bisect(self, start, end, numticks):
        scale_intervals = [s.num_ticks(start, end, numticks) for s in self.scales]
        sorted_scales = sorted(zip(scale_intervals, self.scales))
        ndx = bisect(sorted_scales, numticks, lo=0, hi=len(self.scales))
        if ndx == len(self.scales):
            ndx -= 1
        return sorted_scales[ndx][1]

    def _get_scale_np(self, start, end, numticks):
        # Extract the intervals from the scales we were given
        scale_intervals = array([s.num_ticks(start, end, numticks) for s in self.scales])
        closest = argmin(abs(scale_intervals - numticks))
        return self.scales[closest]


########NEW FILE########
__FILENAME__ = scales_test_case

from traits.testing.unittest_tools import unittest

from numpy import array

from formatters import BasicFormatter, OffsetFormatter
from scales import Pow10Scale, FixedScale, LogScale, DefaultScale, ScaleSystem, frange


class TicksTestCase(unittest.TestCase):
    """ Base class for scale and scale system unit tests """
    def assert_empty(self, arg):
        self.assert_(len(arg) == 0)

    def check_ticks(self, ticks1, ticks2):
        self.assertEqual(len(ticks1),len(ticks2))
        for t1, t2 in zip(ticks1, ticks2):
            self.assertAlmostEqual(t1, t2, 6)

    def check_labels(self, labels1, labels2):
        self.assertEqual(len(labels1),len(labels2))
        for t1, t2, in zip(labels1, labels2):
            self.assert_(t1 == t2)


class ScalesTestCase(TicksTestCase):

    def test_pow10(self):
        scale = Pow10Scale()
        ticks = scale.ticks(5,15,8)
        self.check_ticks(ticks, frange(5, 15, 1.0))
        ticks = scale.ticks(5,105,8)
        self.check_ticks(ticks, frange(10, 100, 10.0))

    def test_log_scale_subdecade(self):
        # Test cases where log_interval is less than 1.
        scale = LogScale()
        ticks = scale.ticks(1.0, 2.0)
        self.check_ticks(ticks, array((1.0, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9, 2.0)))
        ticks = scale.ticks(0.9,2.1)
        self.check_ticks(ticks, array((1.0, 1.25, 1.5, 1.75, 2.0)))
        ticks = scale.ticks(1.1,9.9)
        self.check_ticks(ticks, array((2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0)))


    def test_log_scale_interval1(self):
        # Test the case where 1 < log_interval < desired_ticks, and interval=1
        # is the case that generates the ticks.
        scale = LogScale()
        ticks = scale.ticks(1.0,10.1)
        self.check_ticks(ticks, array((1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0)))
        ticks = scale.ticks(9.3,99.9)
        self.check_ticks(ticks, array((10.0, 20.0, 30.0, 40.0, 50.0, 60.0, 70.0, 80.0, 90.0)))
        ticks = scale.ticks(9.9,100.0)
        self.check_ticks(ticks, array((10.0, 20.0, 30.0, 40.0, 50.0, 60.0, 70.0, 80.0, 90.0, 100.0)))


    def test_log_scale(self):
        scale = LogScale()

        ticks = scale.ticks(0.1, 10.0)
        self.check_ticks(ticks, array((0.1, 0.2, 0.4, 0.6, 0.8, 1.0, 2.0, 4.0, 6.0, 8.0, 10.0)))
        ticks = scale.ticks(10.0, 1000.0)
        self.check_ticks(ticks, array((10.0, 20.0, 40.0, 60.0, 80.0, 100.0,
                                       200.0, 400.0, 600.0, 800.0, 1000.0)))
        ticks = scale.ticks(9.9, 1000.0)
        self.check_ticks(ticks, array((10.0, 20.0, 40.0, 60.0, 80.0, 100.0,
                                       200.0, 400.0, 600.0, 800.0, 1000.0)))
        ticks = scale.ticks(5.0, 4300)
        self.check_ticks(ticks, array((5, 10, 50, 100, 500, 1000)))
        # Test case when the log_interval is greater than 8 (the
        # default desired_ticks)
        ticks = scale.ticks(1e-3,1e6)
        self.check_ticks(ticks, array((1e-3, 1e-2, 1e-1, 1, 1e1, 1e2, 1e3, 1e4, 1e5, 1e6)))


class ScaleSystemTestCase(TicksTestCase):

    def test_defaults(self):
        ticker = ScaleSystem()
        ticks = ticker.ticks(5, 30, 10)
        self.check_ticks(ticks, frange(5.0, 30.0, 2.5))

    def test_fixed_scales(self):
        scales = [FixedScale(resolution = 1.0),
                  FixedScale(resolution = 10.0),
                  FixedScale(resolution = 100.0)]
        ticker = ScaleSystem(default_scale=None, *scales)
        self.check_ticks(ticker.ticks(5, 35, 3), (10.0, 20.0, 30.0))
        self.check_ticks(ticker.ticks(5, 35, 20), frange(5.0, 35.0, 1.0))
        self.check_ticks(ticker.ticks(5, 614, 10), (100, 200, 300, 400, 500, 600))

    def test_revert_to_default(self):
        scales = [FixedScale(resolution = 1.0),
                  FixedScale(resolution = 10.0),
                  FixedScale(resolution = 100.0)]
        ticker = ScaleSystem(*scales)
        ticks = ticker.ticks(2.0, 3.0, 10)
        self.check_ticks(ticks, frange(2.0, 3.0, 0.1))

    def test_translation(self):
        pass



class BasicFormatterTestCase(TicksTestCase):

    def test_format(self):
        fmt = BasicFormatter()

        # test with a fixed scale
        scale = FixedScale(resolution = 1.0)
        start, end = 12.0, 18.0
        numlabels = 8

        ticks = scale.ticks(start, end, numlabels)
        labels = fmt.format(ticks, numlabels, None)
        # desired = [str(float(x)) for x in range(12, 19)]
        ## This test fails when desired is created with str(float(x)).
        ## The format function returns "12",...,"18", not "12.0",...,"18.0".
        desired = ["12","13","14","15","16","17","18"]
        self.check_labels(labels, desired)

    def test_format_small_numbers(self):
        fmt = BasicFormatter()
        numlabels = 8
        # test with small numbers
        scale = FixedScale(resolution = 1e-4)
        start, end = 5e-5, 8.5e-4
        ticks = scale.ticks(start, end, numlabels)
        labels = fmt.format(ticks, numlabels, None)
        desired = [str(float(i))+"e-4" for i in range(1, 9)]
        self.check_labels(labels, desired)

    def test2_nice_sci(self):

        # The table of numerical values and their proper representation
        # given a certain number of mantissa digits
        vals = [ (3.14159e10, (2, "3e10"), (3, '3.1e10'), (5, '3.141e10')),
                 (123456789, (3, '1.2e8'), (5, '1.234e8')),
                 (-123456, (2, "-1e5"), (3, "-1e5"), (4, "-1.2e5")),
                 (123, (2, "1e2"), (3, "1.2e2"), (4, "1.23e2")),
                 (1.234, (2, "1"), (3, "1.2"), (4, "1.23")),
                 ]
        fmt = BasicFormatter()
        for lst in vals:
            val = lst[0]
            for mdigits, desired in lst[1:]:
                s = fmt._nice_sci(val, mdigits)
                if s != desired:
                    print "Mismatch for", val, "; desired:", desired, "actual:", s


    def test_estimate_default_scale(self):
        fmt = BasicFormatter()
        scale = DefaultScale()

        # Test using numlabels
        test_intervals = ((12., 18., 8),
                          (-4., 16., 10),
                          (5e-5, 8.5e-4, 8),
                          (3e8, 6e8, 8),
                          )
        for start, end, numlabels in test_intervals:
            estimate = fmt.estimate_width(start, end, numlabels, ticker=scale)[1]
            ticks = scale.ticks(start, end, numlabels)
            labels = fmt.format(ticks, numlabels, None)
            actual = sum(map(len, labels))
            err = abs(estimate - actual) / actual
            self.assertLess(err, 0.5)
        return

    def test_width_based_default_scale(self):
        scale = ScaleSystem()

        test_intervals = ((1, 100, 80),
                          (1, 100, 40),
                          (1, 100, 20),)
        print
        for start, end, width in test_intervals:
            labels = scale.labels(start, end, char_width=width)
            print "(%d,%d)" % (start,end), " avail:", width,
            print " used:", sum([len(x[1]) for x in labels])
        return

    def test_scale_system(self):
        scale = ScaleSystem(FixedScale(resolution = 1.0),
                            FixedScale(resolution = 2.5),
                            FixedScale(resolution = 5.0),
                            FixedScale(resolution = 10.0),
                            FixedScale(resolution = 20.0),
                            FixedScale(resolution = 100.0))

        test_intervals = ((1,100,200),
                          (1, 100, 80),
                          (1, 100, 40),
                          (1, 100, 20),
                          (1, 100, 5),
                          (1, 10, 100),
                          (1, 10, 50),
                          (1, 10, 20),)
        print
        for start, end, width in test_intervals:
            labels = scale.labels(start, end, char_width=width)
            print "(%d,%d)" % (start,end), " avail:", width,
            print " used:", sum([len(x[1]) for x in labels]),
            print zip(*labels)[1]
        return

class OffsetFormatterTestCase(TicksTestCase):


    def test_format(self):

        test_ranges = [(12003, 12015, 1.0),
                       (1.2003, 1.2015, 1e-4),
                       (-1.2015, -1.2003, 1e-4)]

        for start, end, resol in test_ranges:
            fmt = OffsetFormatter()
            fmt.use_offset=True
            fmt.offset_format = "decimal"
            fmt.end_label_format = "sci"

            scale = FixedScale(resolution = resol)
            numlabels = 12
            ticks = scale.ticks(start, end, numlabels)
            print "range:", start, end
            labels = fmt.format(ticks, numlabels, None)
            print "Labels:", labels, "\n"
            print "estimated width:", fmt.estimate_width(start, end, numlabels)
            print "actual width:", sum(map(len, labels))



if __name__ == "__main__":
    import nose
    nose.run()

########NEW FILE########
__FILENAME__ = test_formatters

from chaco.scales.formatters import strftimeEx, TimeFormatter


#----------------------------------------------------------------
# strftimeEx tests
#----------------------------------------------------------------

def test_strftimeEx_01():
    t = 0.123
    fmt = "%(ms)"
    result = strftimeEx(fmt, t)
    assert result == "123"

def test_strftimeEx_02():
    t = 0.123456
    fmt = "%(us)"
    result = strftimeEx(fmt, t)
    assert result == "456"

def test_strftimeEx_03():
    t = 0.678910
    fmt = "%(ms)"
    # According to the code, the number that replaces (ms) is *rounded*,
    # so this formt should give "679".
    result = strftimeEx(fmt, t)
    assert result == "679"

def test_strftimeEx_04():
    t = 0.678910
    fmt = "%(ms).%(us)ms"
    # According to the code, the number that replaces (ms) is *rounded*,
    # so this formt should give "679.910ms".  (See the next test case for the
    # correct way to do this.)
    result = strftimeEx(fmt, t)
    expected = "679.910ms"
    assert result == expected

def test_strftimeEx_04():
    t = 0.678910
    fmt = "%(ms_).%(us)ms"
    # The format "%(ms_)" uses floor().
    result = strftimeEx(fmt, t)
    expected = "678.910ms"
    print 'result = "%s"  expected = "%s"' % (result, expected)
    assert result == expected

def test_strftimeEx_05():
    """Test rounding that affects the seconds."""
    t = 7.9999999
    fmt = "%S %(ms_) %(us)"
    result = strftimeEx(fmt, t)
    expected = "08 000 000"
    print 'result = "%s"  expected = "%s"' % (result, expected)
    assert result == expected

def test_strftimeEx_06():
    """Test rounding that affects the seconds."""
    t = 7.9996
    fmt = "%S %(ms)"
    result = strftimeEx(fmt, t)
    expected = "08 000"
    print 'result = "%s"  expected = "%s"' % (result, expected)
    assert result == expected

def test_strftimeEx_07():
    """Test rounding that affects the seconds."""
    t = 7.9996
    fmt = "%S %(ms_)"
    result = strftimeEx(fmt, t)
    expected = "07 999"
    print 'result = "%s"  expected = "%s"' % (result, expected)
    assert result == expected

#----------------------------------------------------------------
# TimeFormatter tests
#----------------------------------------------------------------

def test_time_formatter_01():
    tf = TimeFormatter()
    ticks = [10.005, 10.0053, 10.0056]
    labels = tf.format(ticks, char_width=130)
    expected = ["5.000ms", "5.300ms", "5.600ms"]
    print "labels =", labels, " expected =", expected
    assert labels == expected

########NEW FILE########
__FILENAME__ = test_time_scale


import time

import numpy as np

from chaco.scales.time_scale import tfrac, trange, \
        TimeScale, CalendarScaleSystem
from chaco.scales.api import TimeFormatter


#----------------------------------------------------------------
# tfrac tests
#----------------------------------------------------------------

def test_tfrac_days_01():
    # Not sure this test is useful. --WW
    t = time.mktime(time.gmtime(0))
    (base, frac) = tfrac(t, days=1)
    assert base == t
    assert frac == 0.0

def test_tfrac_days_02():
    # Not sure this test is useful. --WW
    t = time.mktime(time.gmtime(0)) + 3*24.0*3600 + 1000.0
    (base, frac) = tfrac(t, days=1)
    assert base == t - 1000.0
    assert frac == 1000.0

def test_tfrac_hours_01():
    t = 3601
    (base, frac) = tfrac(t, hours=1)
    assert base == 3600
    assert frac == 1

def test_tfrac_hours_02():
    t = 3601
    (base, frac) = tfrac(t, hours=2)
    assert base == 0
    assert frac == 3601

def test_tfrac_hours_03():
    t = 3600 * 5.5
    (base, frac) = tfrac(t, hours=2)
    assert base == 3600 * 4
    assert frac == 3600 * 1.5

def test_tfrac_hours_04():
    t = 3600 * 5.5
    (base, frac) = tfrac(t, hours=3)
    assert base == 3600 * 3.0
    assert frac == 3600 * 2.5

def test_tfrac_hours_05():
    t = 3600 * 15.5
    (base, frac) = tfrac(t, hours=6)
    assert base == 3600 * 12.0
    assert frac == 3600 *  3.5

def test_tfrac_minutes_01():
    t = 3601
    (base, frac) = tfrac(t, minutes=1)
    assert base == 3600
    assert frac == 1

def test_tfrac_minutes_02():
    t = 123.5
    (base, frac) = tfrac(t, minutes=1)
    assert base == 120
    assert frac == 3.5

def test_tfrac_seconds_01():
    t = 3601
    (base, frac) = tfrac(t, seconds=1)
    assert base == 3601
    assert frac == 0

def test_tfrac_seconds_02():
    t = 1.75
    (base, frac) = tfrac(t, seconds=1)
    assert base == 1
    assert frac == 0.75

def test_tfrac_milliseconds_01():
    t = 123.5
    (base, frac) = tfrac(t, milliseconds=1)
    assert base == 123.5
    assert frac == 0.0

def test_tfrac_milliseconds_02():
    t = 10.0625
    (base, frac) = tfrac(t, milliseconds=1)
    assert base == 10.062
    assert frac ==  0.0005

def test_tfrac_milliseconds_03():
    t = 10.0625
    (base, frac) = tfrac(t, milliseconds=10)
    assert base == 10.06
    assert frac ==  0.0025

def test_tfrac_milliseconds_04():
    t = 1.0078121
    # Note that the last digit is lost due to rounding to microsecond scale.
    (base, frac) = tfrac(t, milliseconds=1)
    print base, frac
    assert base == 1.007
    assert frac == 0.000812

def test_tfrac_milliseconds_05():
    t = 1.0078056
    # Note that the last digit is lost due to rounding to microsecond scale.
    (base, frac) = tfrac(t, milliseconds=1)
    print base, frac
    assert base == 1.007
    assert frac == 0.000806


#----------------------------------------------------------------
# trange tests
#----------------------------------------------------------------

def test_trange_hours_01():
    r = trange(0, 1, hours=1)
    assert r == []

def test_trange_hours_02():
    r = trange(-1, 1, hours=1)
    assert r == [0.0]

def test_trange_hours_03():
    r = trange(0, 3600, hours=1)
    assert r == [0.0, 3600.0]

def test_trange_hours_04():
    r = trange(-3600, 3600, hours=1)
    assert r == [-3600.0, 0.0, 3600.0]

def test_trange_hours_05():
    r = trange(-10, 3610, hours=1)
    assert r == [0.0, 3600.0]

def test_trange_hours_06():
    r = trange(-10, 7210, hours=1)
    assert r == [0.0, 3600.0, 7200.0]

def test_trange_hours_07():
    r = trange(-10, 7210, hours=2)
    assert r == [0.0, 7200.0]

def test_trange_seconds_01():
    r = trange(0, 1, seconds=1)
    assert r == [0.0, 1.0]

def test_trange_seconds_02():
    r = trange(0, 10, seconds=1)
    assert r == range(11)

def test_trange_seconds_03():
    r = trange(0, 1.5, seconds=1)
    assert r == [0.0, 1.0]

def test_trange_milliseconds_01():
    r = trange(0, 0.1, milliseconds=1)
    assert np.allclose(np.array(r), np.linspace(0.0, 0.1, 101)).all()

def test_trange_milliseconds_02():
    r = trange(-0.002, 0.001, milliseconds=1)
    assert np.allclose(np.array(r), np.linspace(-0.002, 0.001, 4))


#----------------------------------------------------------------
# TimeScale tests
#----------------------------------------------------------------

# Could use more tests here... --WW

def test_time_scale_seconds_01():
    ts = TimeScale(seconds=1)
    ticks = ts.ticks(0, 10)
    assert (np.array(ticks) == np.linspace(0.0, 10.0, 11)).all()

def test_time_scale_seconds_02():
    ts = TimeScale(seconds=2)
    ticks = ts.ticks(0, 10)
    assert (np.array(ticks) == np.linspace(0.0, 10.0, 6)).all()

def test_time_scale_milliseconds_01():
    ts = TimeScale(milliseconds=1)
    ticks = ts.ticks(0, 0.1)
    assert len(ticks) == 11
    assert (np.array(ticks) == np.linspace(0.0, 0.1, 11)).all()

def test_time_scale_with_formatter():
    """ Regression test for TimeScale() with formatter keyword.

    Using the formatter keyword in the constructor of TimeScale
    could raise a KeyError.  This test passes if no exception is
    raised.
    """
    ts = TimeScale(seconds=1, formatter=TimeFormatter())
    ts = TimeScale(minutes=1, formatter=TimeFormatter())


#----------------------------------------------------------------
# CalendarScaleSystem tests
#----------------------------------------------------------------

def test_calendar_scale_system_01():
    css = CalendarScaleSystem()
    ticks = css.ticks(0,10)
    assert len(ticks) == 11
    assert (np.array(ticks) == np.linspace(0,10,11)).all()


# TODO: Add more tests of the ticks() and labels() methods of
# the CalendarScaleSystem.
#
# Determine why the format switches from '##s' to ':##'
# as in the following, and create appropriate tests:
#
# In [145]: css.labels(71010,71021, numlabels=8, char_width=130)
# Out[145]:
# [(71010.0, '30s'),
#  (71011.0, '31s'),
#  (71012.0, '32s'),
#  (71013.0, '33s'),
#  (71014.0, '34s'),
#  (71015.0, '35s'),
#  (71016.0, '36s'),
#  (71017.0, '37s'),
#  (71018.0, '38s'),
#  (71019.0, '39s'),
#  (71020.0, '40s'),
#  (71021.0, '41s')]
#
# In [146]: css.labels(71010,71022, numlabels=8, char_width=130)
# Out[146]:
# [(71010.0, ':30'),
#  (71011.0, ':31'),
#  (71012.0, ':32'),
#  (71013.0, ':33'),
#  (71014.0, ':34'),
#  (71015.0, ':35'),
#  (71016.0, ':36'),
#  (71017.0, ':37'),
#  (71018.0, ':38'),
#  (71019.0, ':39'),
#  (71020.0, ':40'),
#  (71021.0, ':41'),
#  (71022.0, ':42')]
#
# In [147]:

########NEW FILE########
__FILENAME__ = time_scale
"""
A scale for time and calendar intervals.
"""

from math import floor

from scales import AbstractScale, ScaleSystem, frange, heckbert_interval
from formatters import TimeFormatter
from safetime import (safe_fromtimestamp, datetime, timedelta, EPOCH,
                      MINYEAR, MAXYEAR)

# Labels for date and time units.
datetime_scale = ["microsecond", "second", "minute", "hour",
                  "day", "month", "year"]
datetime_zeros = zip(datetime_scale, [0, 0, 0, 0, 1, 1, 1])


__all__ = ["TimeScale", "CalendarScaleSystem", "HMSScales", "MDYScales",
           "trange", "tfrac", "td_to_sec", "dt_to_sec"]


def td_to_sec(td):
    """ Returns the floating point number of seconds in a timedelta object.
    """
    return td.days * 24 * 3600 + td.seconds + td.microseconds * 1e-6


def dt_to_sec(t):
    """ Returns the floating point number of seconds since the UNIX epoch
    corresponding to the given datetime instance.

    This value is more accurate than mktime(t.timetuple()) because it
    preserves milliseconds.
    """
    return td_to_sec(t - EPOCH)


def tfrac(t, **time_unit):
    """ Performs a calendar-aware split of a time into (aligned_time, frac)
    over an interval that is a multiple of one of the following time units:

        "microseconds" "milliseconds", "seconds", "minutes", "hours", "days", "years"

    Settings of milliseconds..hours are truncated towards 0, days are counted
    from January 1st of their respective year, and years are counted from 1 AD.
    This may lead to unexpected rounding if multi-day or multi-year intervals
    are used.

    For example:

    If it is currently 4:15pm on January 3rd, 2007, calling:
    ``tfrac(time.time(), hours=3)``
    returns the UNIX number of seconds corresponding to
    "January 3rd, 2007 15:00:00"
    as the aligned time, and the number of seconds in 1 hour and 15 minutes as
    the fractional part.

    Parameters
    ==========
    t : float
        time in seconds
    ``**time_unit`` : dict
        a single (interval=value) item

    Returns
    =======
    A tuple: (aligned time as UNIX time, remainder in seconds)
    """
    unit, period = time_unit.items()[0]
    if unit == "milliseconds":
        unit = "microsecond"
        period *= 1000
    else:
        unit = unit[:-1]  # strip off the 's'

    # Find the nearest round date
    dt = safe_fromtimestamp(t)
    amt = getattr(dt, unit)
    ndx = datetime_scale.index(unit)
    closest_multiple = int(floor(amt / period) * period)
    if closest_multiple == 0 and unit in ("day", "year"):
        # TODO: this isn't really quite right for intervals of days > 1...
        closest_multiple = 1
    whole = dt.replace(**{unit: closest_multiple})
    whole = whole.replace(**dict(datetime_zeros[:ndx]))
    frac = td_to_sec(dt - whole)

    return dt_to_sec(whole), frac

def _advance_month(dt, months):
    """ Advance a datetime object by a given number of months.
    """
    new_month = dt.month + months
    years, extra_months = divmod(new_month-1, 12)
    new_month = extra_months + 1
    return dt.replace(year=dt.year+years, month=new_month)

def trange_months(start, end, months):
    """ Create a range of timestamps separated by a given number of months.

    The start of the iteration is always aligned to Jan 1 2000.
    """
    dt_start = safe_fromtimestamp(start)
    dt_end = safe_fromtimestamp(end)
    dmonths = (12 * (dt_start.year - 2000) + dt_start.month - 1) % months
    dt = _advance_month(dt_start.replace(day=1, hour=0, minute=0, second=0,
        microsecond=0), -dmonths)
    while dt < dt_start:
        dt = _advance_month(dt, months)
    timestamps = []
    while dt <= dt_end:
        timestamps.append(dt_to_sec(dt))
        dt = _advance_month(dt, months)
    return timestamps

def _advance_years(dt, years):
    """ Advance a datetime object by a given number of years.
    """
    return dt.replace(year=dt.year+years)

def trange_years(start, end, years):
    """ Create a range of timestamps separated by a given number of years.

    The start of the iteration is aligned to Jan 1 2000.
    """
    dt_start = safe_fromtimestamp(start)
    dt_end = safe_fromtimestamp(end)
    dyears = (dt_start.year - 2000) % years
    if dyears < 0:
        dyears += years
    dt = datetime(dt_start.year-dyears, 1, 1, 0, 0, 0, 0)
    while dt < dt_start:
        dt = _advance_years(dt, years)
    timestamps = []
    while dt <= dt_end:
        timestamps.append(dt_to_sec(dt))
        dt = _advance_years(dt, years)
    return timestamps

def trange(start, end, **time_unit):
    """ Like range(), but for times, and with "natural" alignment depending on
    the interval.

    For example::

        t_range(time.time(), time.time()+76*3600, days=2)
        t_range(start, end, months=3)

    Parameters
    ==========
    start, end : float
        Time in seconds.  *end* must be later than *start*.
    time_unit : a single (key, int_value) pair
        The units to use. *key* must be in the list: "milliseconds", "seconds",
        "minutes", "hours", "days", "months", "years".  Months are treated as
        30 days, and years are treated as 365 days.

    Returns
    =======
    A list of times that nicely span the interval, or an empty list if *start*
    and *end* fall within the same interval.
    """
    if len(time_unit) > 1:
        raise ValueError("trange() only takes one keyword argument, got %d" % len(time_unit))

    # Months and years are non-uniform, so we special-case them.
    unit, value = time_unit.items()[0]
    if unit == 'months':
        return trange_months(start, end, value)
    elif unit == 'years':
        return trange_years(start, end, value)

    # Express start and end ticks as (date, frac) where date is calendar-aligned
    # with the interval in time_unit.
    start_whole, start_frac = tfrac(start, **time_unit)
    end_whole, end_frac = tfrac(end, **time_unit)

    # Handle some corner-cases
    if start_whole == end_whole:
        return []

    if start_frac < 1e-6:
        first_tick_ndx = 0
    else:
        first_tick_ndx = 1

    # Convert months and years into days
    time_unit["days"] = time_unit.setdefault("days", 0) + \
                            365 * time_unit.pop("years", 0) + \
                            30 * time_unit.pop("months", 0)
    delta = td_to_sec(timedelta(**time_unit))
    count = (end_whole - start_whole) / delta

    ticks = [start_whole + i*delta for i in range(int(round(count))+1)]
    return ticks[first_tick_ndx:]


class TimeScale(AbstractScale):
    """ A scale based on time intervals and calendar dates. The valid
    intervals are:

    Natural time:
        microseconds, milliseconds, seconds, minutes, hours, days, years
    Calendar time:
        day_of_month, month_of_year

    For calendar times, a list of hours/days/months is set.
    By default, intervals are aligned to January 1st.
    """

    # This is used to compute an approximate resolution for each type of scale.
    SECS_PER_UNIT = {"microseconds": 1e-6,
                     "milliseconds": 1e-3,
                     "seconds": 1,
                     "minutes": 60,
                     "hours": 3600,
                     "days": 24*3600,
                     "day_of_month": 30*24*3600,
                     "month_of_year": 365*24*3600,
                     "years": 365*24*3600,
                     }

    CALENDAR_UNITS = ("day_of_month", "month_of_year")

    def __init__(self, **kw_interval):
        """ Defines the time period that this scale uses.
        """
        self.formatter = kw_interval.pop("formatter", TimeFormatter())
        unit, val = kw_interval.items()[0]
        self.unit = unit
        if "_of_" in unit:
            # Calendar time interval - divide by the number of ticks per larger
            # unit of time to get an average resolution
            if type(val) in (int, float):
                val = [val]
            self.vals = val
            self.resolution = self.SECS_PER_UNIT[unit] / float(len(val))
        else:
            self.val = val
            self.resolution = val * self.SECS_PER_UNIT[unit]
        return

    def num_ticks(self, start, end, desired_ticks=None):
        """ Returns an approximate number of ticks that this scale
        produces for the given interval.

        Implements AbstractScale.
        """
        # This is only approximate, but puts us in the ballpark
        if self.unit in ("milliseconds", "microseconds"):
            ticks = self.ticks(start, end, desired_ticks=8)
            coarsest_scale_count = (end - start) / (500 * self.SECS_PER_UNIT[self.unit])
            return max(len(ticks), coarsest_scale_count)
        else:
            return (end - start) / self.resolution

    def ticks(self, start, end, desired_ticks=None):
        """ Returns the set of "nice" positions on this scale that enclose and
        fall inside the interval (*start*,*end*).

        Implements AbstractScale. The *start* and *end* parameters are
        floating-point seconds since the epoch.
        """

        if self.unit in self.CALENDAR_UNITS:
            return self.cal_ticks(start, end)
        elif self.unit in ("milliseconds", "microseconds"):
            if start == end or (end - start) < self.SECS_PER_UNIT[self.unit]:
                return [start]
            secs_per_unit = self.SECS_PER_UNIT[self.unit]
            start /= secs_per_unit
            end /= secs_per_unit
            if desired_ticks is None:
                min, max, delta = heckbert_interval(start, end, enclose=True)
            else:
                min, max, delta = heckbert_interval(start, end, desired_ticks,
                                                    enclose=True)
            min *= secs_per_unit
            max *= secs_per_unit
            delta *= secs_per_unit
            return frange(min, max, delta)
        else:
            return trange(start, end, **{self.unit: self.val})

    def cal_ticks(self, start, end):
        """ ticks() method for calendar-based intervals """

        try:
            start = datetime.fromtimestamp(start)
        except ValueError:
            start = datetime(MINYEAR, 1, 1, 0, 0, 0)
        try:
            end = datetime.fromtimestamp(end)
        except ValueError:
            end = datetime(MAXYEAR, 1, 1, 0, 0, 0)

        if self.unit == "day_of_month":
            s = start.year + 1/12.0 * start.month
            e = end.year + 1/12.0 * end.month
            num_months = int(round((e - s) * 12)) + 1   # add 1 for fencepost
            start_year = start.year
            start_month = start.month
            ym = [divmod(i, 12)
                  for i in range(start_month-1, start_month-1+num_months)]
            months = [start.replace(year=start_year+y, month=m+1, day=1)
                      for (y,m) in ym]
            ticks = [dt.replace(day=i) for dt in months for i in self.vals]

        elif self.unit == "month_of_year":
            years = [start.replace(year=newyear, day=1)
                     for newyear in range(start.year, end.year+1)]
            ticks = [dt.replace(month=i, day=1)
                     for dt in years for i in self.vals]

        else:
            raise ValueError("Unknown calendar unit '%s'" % self.unit)

        if len(ticks) > 0:
            # Find the first and last index in all_ticks that falls
            # within (start,end)
            for start_ndx in range(len(ticks)):
                if ticks[start_ndx] >= start:
                    break
            for end_ndx in range(len(ticks)-1, 0, -1):
                if ticks[end_ndx] <= end:
                    break
            ticks = ticks[start_ndx : end_ndx+1]

        return map(dt_to_sec, ticks)

    def labels(self, start, end, numlabels=None, char_width=None):
        """ Returns a series of ticks and corresponding strings for labels
        that fall inside the interval (*start*,*end*).

        Overrides AbstractScale.
        """
        ticks = self.ticks(start, end, numlabels)
        labels = self.formatter.format(ticks, numlabels, char_width, ticker=self)
        return zip(ticks, labels)

    def label_width(self, start, end, numlabels=None, char_width=None):
        """ Returns an estimate of total number of characters used by the
        the labels that this scale will produce for the given set of
        inputs, as well as the number of labels.

        Overrides AbstractScale.
        """
        return self.formatter.estimate_width(start, end, numlabels, char_width,
                                             ticker=self)


# Declare some default scale systems

# Default time scale for hours, minutes, seconds, and milliseconds.
HMSScales = [TimeScale(microseconds=1), TimeScale(milliseconds=1)] + \
            [TimeScale(seconds=dt) for dt in (1, 5, 15, 30)] + \
            [TimeScale(minutes=dt) for dt in (1, 5, 15, 30)] + \
            [TimeScale(hours=dt) for dt in (1, 2, 3, 4, 6, 12, 24)]

# Default time scale for months, days, and years.
MDYScales = [TimeScale(day_of_month=range(1,31,3)),
             TimeScale(day_of_month=(1,8,15,22)),
             TimeScale(day_of_month=(1,15)),
             TimeScale(month_of_year=range(1,13)),
             TimeScale(month_of_year=range(1,13,3)),
             TimeScale(month_of_year=(1,7)),
             TimeScale(month_of_year=(1,)),] + \
            [TimeScale(years=dt) for dt in (1,2,5,10)]

class CalendarScaleSystem(ScaleSystem):
    """ Scale system for calendars.

    This class has a pre-defined set of nice "time points" to use for ticking
    and labelling.
    """

    def __init__(self, *scales, **kw):
        """ Creates a new CalendarScaleSystem.

        If scales are not provided, then it defaults to HMSScales and MDYScales.
        """
        if len(scales) == 0:
            scales = HMSScales + MDYScales
        super(CalendarScaleSystem, self).__init__(*scales, **kw)

    def _get_scale(self, start, end, numticks):
        if len(self.scales) == 0:
            if self.default_scale is not None:
                closest_scale = self.default_scale
            else:
                raise ValueError("CalendarScaleSystem has not be configured "
                                 "with any scales.")
        elif end - start < 1e-6 or end - start > 1e5 * 365 * 24 * 3600:
            closest_scale = self.default_scale
        else:
            closest_scale = self._get_scale_np(start, end, numticks)

        return closest_scale

########NEW FILE########
__FILENAME__ = time_scale_test_case

from itertools import starmap
from datetime import datetime as DT

from scales import ScaleSystem
from time_scale import dt_to_sec, trange, TimeScale, HMSScales
from formatters import TimeFormatter

from scales_test_case import TicksTestCase


def DTS(*args, **kw):
    """ Returns a unix-timestamp-like time """
    return dt_to_sec(DT(*args, **kw))

def sec_from_hms(start, *times):
    """ Returns a list of times based on adding each offset tuple in times
    to the start time (which should be in seconds).  Offset tuples can be
    in any of the forms: (hours), (hours,minutes), or (hours,minutes,seconds).
    """
    ret = []
    for t in times:
        cur = 0
        if len(t) > 0:
            cur += t[0] * 3600
        if len(t) > 1:
            cur += t[1] * 60
        if len(t) > 2:
            cur += t[2]
        ret.append(start+cur)
    return ret


class TRangeTestCase(TicksTestCase):

    def test_null_ranges(self):
        ranges = (
            ((2005,3,15,10,23,15), (2005,3,15,10,23,45), {"minutes":1}),
            ((2005,3,15,10,23), (2005,3,15,10,47), {"hours":1}),
            ((2005,3,15,5,23), (2005,3,15,18,43), {"days":1}),
            ((2005,3,15,10,30), (2005,12,25,18,30), {"years":1})
            )
        for start, end, kw in ranges:
            self.assert_empty(trange(DTS(*start), DTS(*end), **kw))
        return

    def test_microseconds(self):
        # Testing the microsecond scale is dicey--`base` is a 10 digit integer,
        # so an increment of, say, 3 microseconds is only about a factor of 10
        # more than machine precision.
        base = DTS(2005, 3, 15, 10, 45, 10)
        print "base: ", base
        start = base + 0.0000027
        end   = base + 0.0000177
        ticks = trange(start, end, microseconds=5)
        desired = [base+i for i in (5e-6, 10e-6, 15e-6)]
        print "ticks:   ", ticks
        print "desired: ", desired
        self.check_ticks(ticks, desired)

    def test_milliseconds(self):
        base = DTS(2005, 3, 15, 10, 45, 10)
        start = base + 0.0028
        end = base + 0.0075
        ticks = trange(start, end, milliseconds=1)
        desired = [base + i for i in (0.003, 0.004, 0.005, 0.006, 0.007)]
        self.check_ticks(ticks, desired)
        ticks = trange(start, end, milliseconds=2)
        self.check_ticks(ticks, (base+0.004, base+0.006))

    def test_daily(self):
        base = DTS(2005, 1, 1)
        secs_per_day = 24*3600
        ticks = trange(base, base + secs_per_day*5, days=1)
        desired = [base+i*secs_per_day for i in range(6)]
        print "ticks:   ", ticks
        print "desired: ", desired
        self.check_ticks(ticks, desired)

    def test_daily_leap(self):
        start = DTS(2004, 2, 27)
        end = DTS(2004, 3, 2)
        ticks = trange(start, end, days=1)
        desired = [start + i*24*3600 for i in range(5)]
        self.check_ticks(ticks, desired)

    def test_hourly(self):
        # test between Feb 29,2004 10:15pm and Mar 1st 3:15am
        ticks = trange(DTS(2004,2,29,22,15), DTS(2004,3,1,3,15), hours=1)
        start = DTS(2004,2,29,23)
        desired = [start + i*3600 for i in range(5)]
        self.check_ticks(ticks, desired)

    def test_multiday_increment(self):
        start = DTS(2005, 1, 1)
        ticks = trange(start, start + 9*24*3600, days=3)
        desired = [start+i*3*24*3600 for i in range(4)]
        print "ticks: ", ticks, " desired: ", desired
        self.check_ticks(ticks, desired)



class TimeScaleTestCase(TicksTestCase):
    """ This exercises a single TimeScale set at various resolutions """

    def test_hourly(self):
        ts = TimeScale(hours=1)
        start = DTS(2005, 3, 15, 10, 30)
        end = DTS(2005, 3, 15, 16, 59)
        desired_start = DTS(2005, 3, 15)
        desired = [desired_start + i*3600 for i in (11, 12, 13, 14, 15, 16)]
        self.check_ticks(ts.ticks(start, end), desired)

    def test_minutes(self):
        ts = TimeScale(minutes=15)
        start = DTS(2005, 3, 15, 10, 20)
        end = DTS(2005, 3, 15, 11, 55)
        dstart = DTS(2005, 3, 15)
        desired = ((10,30), (10,45), (11,00), (11,15), (11,30), (11,45))
        self.check_ticks(ts.ticks(start, end),
                                sec_from_hms(dstart, *desired))

    def test_day_of_month(self):
        ts = TimeScale(day_of_month=(1,8,15,22))
        start = DTS(2005,3,12)
        end = DTS(2005,5,3)
        desired = list(starmap(DTS, ((2005,3,15), (2005,3,22), (2005,4,1), (2005,4,8),
                                (2005,4,15), (2005,4,22), (2005,5,1))))
        self.check_ticks(ts.ticks(start,end), desired)

        # test adjacent months
        start = DTS(2005, 3, 12)
        end = DTS(2005, 4, 10)
        desired = list(starmap(DTS, ((2005,3,15), (2005,3,22), (2005,4,1), (2005,4,8))))
        self.check_ticks(ts.ticks(start,end), desired)


    def test_month_of_year(self):
        ts = TimeScale(month_of_year=(1,4,8))
        start = DTS(2005,1,1)
        end = DTS(2006,5,1)
        desired = list(starmap(DTS, ((2005,1,1), (2005,4,1), (2005,8,1), (2006,1,1), (2006,4,1))))
        self.check_ticks(ts.ticks(start,end), desired)

    def test_microsecond(self):
        # This test is dicey, because the values being tested are close to
        # machine precision. See the comment in TRangeTestCase.test_microseconds().
        ts = TimeScale(microseconds=1)
        base = DTS(1975, 3, 15, 10, 45, 10)
        start = base + 2.8e-6
        end = base + 9.2e-6
        ticks = ts.ticks(start, end)
        desired = [base+i for i in (3e-6, 4e-6, 5e-6, 6e-6, 7e-6, 8e-6, 9e-6)]
        print "ticks:   ", ticks
        print "desired: ", desired
        self.check_ticks(ticks, desired)


class CalendarScaleSystemTestCase(TicksTestCase):
    """ This exercises the ability of multiple TimeScale objects to play well
    within a single ScaleSystem.
    """

    def test_hourly_scales(self):
        scales = [TimeScale(seconds=dt) for dt in (1, 5, 15, 30)] + \
                 [TimeScale(minutes=dt) for dt in (1, 5, 15, 30)] + \
                 [TimeScale(hours=dt) for dt in (1, 2, 3, 4, 6, 12)]

    def test_yearly_scales(self):
        ticker = ScaleSystem(TimeScale(month_of_year=1), default_scale=None)
        ticks = ticker.ticks(DTS(2000,1,1), DTS(2007,1,1), 10)
        desired = list(starmap(DTS, ((2000,1,1), (2001,1,1), (2002,1,1), (2003,1,1),
                                (2004,1,1), (2005,1,1), (2006,1,1), (2007,1,1))))
        self.check_ticks(ticks, desired)


class TimeFormatterTestCase(TicksTestCase):

    def test_widths(self):
        fmt = TimeFormatter()
        scale = TimeScale(minutes = 5)
        test_intervals = ([(2005,3,15,10,30), (2005,3,15,10,50), 50],
                          )
        print
        for start, end, width in test_intervals:
            est_width = scale.label_width(DTS(*start), DTS(*end), char_width=width)
            print start, end,
            print " avail:", width, "est:", est_width[1], "numlabels:", est_width[0]
        return

    def test_labels(self):
        fmt = TimeFormatter()
        scale = ScaleSystem(*HMSScales)

        test_intervals = ([(2005,3,15,10,30), (2005,3,15,10,50), 150],
                          )
        print
        for start, end, width in test_intervals:
            labels = scale.labels(DTS(*start), DTS(*end), char_width=width)
            print start, end, " avail:", width,
            print " used:", sum([len(x[1]) for x in labels]),
            print labels
        return


if __name__ == "__main__":
    import nose
    nose.run()

########NEW FILE########
__FILENAME__ = scales_tick_generator
""" Defines the ScalesTickGenerator class.
"""
from numpy import array

from traits.api import Any
from enable.font_metrics_provider import font_metrics_provider
from ticks import AbstractTickGenerator

# Use the new scales/ticks library
from scales.api import ScaleSystem


class ScalesTickGenerator(AbstractTickGenerator):

    scale = Any #Instance(ScaleSystem, args=())

    font = Any

    def _scale_default(self):
        return ScaleSystem()

    def get_ticks(self, data_low, data_high, bounds_low, bounds_high, interval,
                  use_endpoints=False, scale=None):
        if interval != "auto":
            ticks = self.scale.ticks(data_low, data_high, (data_high - data_low) / interval)
        else:
            ticks = self.scale.ticks(data_low, data_high)
        return ticks

    def get_ticks_and_labels(self, data_low, data_high, bounds_low, bounds_high,
                             orientation = "h"):
        # TODO: add support for Interval
        # TODO: add support for vertical labels
        metrics = font_metrics_provider()
        if self.font is not None and hasattr(metrics, "set_font"):
            metrics.set_font(self.font)
        test_str = "0123456789-+"
        charsize = metrics.get_full_text_extent(test_str)[0] / len(test_str)
        numchars = (bounds_high - bounds_low) / charsize
        tmp = zip(*self.scale.labels(data_low, data_high, numlabels=8, char_width=numchars))
        # Check to make sure we actually have labels/ticks to show before
        # unpacking the return tuple into (tick_array, labels).
        if len(tmp) == 0:
            return array([]), []
        else:
            return array(tmp[0]), tmp[1]

########NEW FILE########
__FILENAME__ = scatterplot
""" Defines the ScatterPlot class, and associated Traits UI view and helper
function.
"""

# Standard library imports
import itertools

# Major library imports
from numpy import abs, argmin, around, array, asarray, compress, invert, \
        isnan, sqrt, sum, transpose, where, ndarray

# Enthought library imports
from enable.api import black_color_trait, ColorTrait, AbstractMarker, \
        CustomMarker, MarkerNameDict, MarkerTrait
from kiva.constants import STROKE
from traits.api import Any, Array, Bool, Float, Trait, Callable, Property, \
        Tuple, Either, cached_property
from traitsui.api import View, VGroup, Item

# Local relative imports
from base_xy_plot import BaseXYPlot
from speedups import scatterplot_gather_points
from base import reverse_map_1d

#------------------------------------------------------------------------------
# Traits UI View for customizing a scatter plot.
#------------------------------------------------------------------------------

class ScatterPlotView(View):
    """ Traits UI View for customizing a scatter plot.
    """
    def __init__(self):
        vgroup = VGroup(
                Item("marker", label="Marker type"),
                Item("marker_size", label="Size"),
                Item("color", label="Color", style="custom"),
                )
        super(ScatterPlotView, self).__init__(vgroup)
        self.buttons = ["OK", "Cancel"]

#------------------------------------------------------------------------------
# Helper functions for scatterplot rendering
#------------------------------------------------------------------------------


def render_markers(gc, points, marker, marker_size,
                   color, line_width, outline_color,
                   custom_symbol=None, debug=False, point_mask=None):
    """ Helper function for a PlotComponent instance to render a
    set of (x,y) points onto a graphics context.  Currently, it makes some
    assumptions about the attributes on the plot object; these may be factored
    out eventually.

    Parameters
    ----------
    gc : GraphicsContext
        The target for rendering the points
    points : array of (x,y) points
        The points to render
    marker : string, class, or instance
        The type of marker to use for the points
    marker_size : number
        The size of the markers
    color : RGB(A) color
        The color of the markers
    line_width : number
        The width, in pixels, of the marker outline
    outline_color : RGB(A) color
        The color of the marker outline
    custom_symbol : CompiledPath
        If the marker style is 'custom', this is the symbol
    point_mask : array of bools
        The mask specifying which points need to be rendered. The `points`
        array is already masked
    """

    if len(points) == 0:
        return

    # marker can be string, class, or instance
    if isinstance(marker, basestring):
        marker = MarkerNameDict[marker]()
    elif issubclass(marker, AbstractMarker):
        marker = marker()

    with gc:
        gc.set_line_dash(None)
        if marker.draw_mode == STROKE:
            # markers with the STROKE draw mode will not be visible
            # if the line width is zero, so set it to 1
            if line_width == 0:
                line_width = 1.0
            gc.set_stroke_color(color)
            gc.set_line_width(line_width)
        else:
            gc.set_stroke_color(outline_color)
            gc.set_line_width(line_width)
            gc.set_fill_color(color)

        gc.begin_path()

        # try to invoke optimized routines if only one size and gc supports
        if not isinstance(marker_size, ndarray):
            # try fastest routine
            if not isinstance(marker, CustomMarker):
                # get fast renderer, or dummy if not implemented
                renderer = getattr(gc, 'draw_marker_at_points', lambda *a: 0)
                result = renderer(points, marker_size, marker.kiva_marker)
                # it worked, we're done
                if result != 0:
                    return

            # try next fastest routine
            if hasattr(gc, 'draw_path_at_points'):
                if not isinstance(marker, CustomMarker):
                    path = gc.get_empty_path()
                    marker.add_to_path(path, marker_size)
                    mode = marker.draw_mode
                else:
                    path = custom_symbol
                    mode = STROKE
                if not marker.antialias:
                    gc.set_antialias(False)
                gc.draw_path_at_points(points, path, mode)
                return

        if isinstance(marker_size, ndarray):
            if point_mask is not None:
                marker_size = marker_size[point_mask]
        else:
            marker_size = itertools.repeat(marker_size)

        if not marker.antialias:
            gc.set_antialias(False)
        if not isinstance(marker, CustomMarker):
            for pt,size in itertools.izip(points, marker_size):
                sx, sy = pt
                with gc:
                    gc.translate_ctm(sx, sy)
                    # Kiva GCs have a path-drawing interface
                    marker.add_to_path(gc, size)
                    gc.draw_path(marker.draw_mode)
        else:
            path = custom_symbol
            for pt,size in itertools.izip(points, marker_size):
                sx, sy = pt
                with gc:
                    gc.translate_ctm(sx, sy)
                    gc.scale_ctm(size, size)
                    gc.add_path(path)
                    gc.draw_path(STROKE)

    return

#------------------------------------------------------------------------------
# The scatter plot
#------------------------------------------------------------------------------


class ScatterPlot(BaseXYPlot):
    """
    Renders a scatter plot, given an index and value arrays.
    """

    # The CompiledPath to use if **marker** is set to "custom". This attribute
    # must be a compiled path for the Kiva context onto which this plot will
    # be rendered.  Usually, importing kiva.GraphicsContext will do
    # the right thing.
    custom_symbol = Any

    #------------------------------------------------------------------------
    # Styles on a ScatterPlot
    #------------------------------------------------------------------------

    # The type of marker to use.  This is a mapped trait using strings as the
    # keys.
    marker = MarkerTrait

    # The pixel size of the markers, not including the thickness of the outline.
    # Default value is 4.0.
    # TODO: for consistency, there should be a size data source and a mapper
    marker_size = Either(Float, Array)

    # The function which actually renders the markers
    render_markers_func = Callable(render_markers)

    # The thickness, in pixels, of the outline to draw around the marker.  If
    # this is 0, no outline is drawn.
    line_width = Float(1.0)

    # The fill color of the marker.
    color = black_color_trait

    # The color of the outline to draw around the marker.
    outline_color = black_color_trait

    # The RGBA tuple for rendering lines.  It is always a tuple of length 4.
    # It has the same RGB values as color_, and its alpha value is the alpha
    # value of self.color multiplied by self.alpha.
    effective_color = Property(Tuple, depends_on=['color', 'alpha'])

    # The RGBA tuple for rendering the fill.  It is always a tuple of length 4.
    # It has the same RGB values as outline_color_, and its alpha value is the
    # alpha value of self.outline_color multiplied by self.alpha.
    effective_outline_color = Property(Tuple, depends_on=['outline_color', 'alpha'])


    # Traits UI View for customizing the plot.
    traits_view = ScatterPlotView()

    #------------------------------------------------------------------------
    # Selection and selection rendering
    # A selection on the lot is indicated by setting the index or value
    # datasource's 'selections' metadata item to a list of indices, or the
    # 'selection_mask' metadata to a boolean array of the same length as the
    # datasource.
    #------------------------------------------------------------------------

    show_selection = Bool(True)

    selection_marker = MarkerTrait

    selection_marker_size = Float(4.0)

    selection_line_width = Float(1.0)

    selection_color = ColorTrait("yellow")

    selection_outline_color = black_color_trait

    #------------------------------------------------------------------------
    # Private traits
    #------------------------------------------------------------------------

    _cached_selected_pts = Trait(None, None, Array)
    _cached_selected_screen_pts = Array
    _cached_point_mask = Array
    _cached_selection_point_mask = Array
    _selection_cache_valid = Bool(False)

    #------------------------------------------------------------------------
    # Overridden PlotRenderer methods
    #------------------------------------------------------------------------

    def map_screen(self, data_array):
        """ Maps an array of data points into screen space and returns it as
        an array.

        Implements the AbstractPlotRenderer interface.
        """
        # data_array is Nx2 array
        if len(data_array) == 0:
            return []

        # XXX: For some reason, doing the tuple unpacking doesn't work:
        #        x_ary, y_ary = transpose(data_array)
        # There is a mysterious error "object of too small depth for
        # desired array".  However, if you catch this exception and
        # try to execute the very same line of code again, it works
        # without any complaints.
        #
        # For now, we just use slicing to assign the X and Y arrays.
        data_array = asarray(data_array)
        if len(data_array.shape) == 1:
            x_ary = data_array[0]
            y_ary = data_array[1]
        else:
            x_ary = data_array[:, 0]
            y_ary = data_array[:, 1]

        sx = self.index_mapper.map_screen(x_ary)
        sy = self.value_mapper.map_screen(y_ary)
        if self.orientation == "h":
            return transpose(array((sx,sy)))
        else:
            return transpose(array((sy,sx)))

    def map_data(self, screen_pt, all_values=True):
        """ Maps a screen space point into the "index" space of the plot.

        Overrides the BaseXYPlot implementation, and always returns an
        array of (index, value) tuples.
        """
        x, y = screen_pt
        if self.orientation == 'v':
            x, y = y, x
        return array((self.index_mapper.map_data(x),
                      self.value_mapper.map_data(y)))

    def map_index(self, screen_pt, threshold=0.0, outside_returns_none=True, \
                  index_only = False):
        """ Maps a screen space point to an index into the plot's index array(s).

        Overrides the BaseXYPlot implementation..
        """
        if index_only and self.index.sort_order != "none":
            data_pt = self.map_data(screen_pt)[0]
            # The rest of this was copied out of BaseXYPlot.
            # We can't just used BaseXYPlot.map_index because
            # it expect map_data to return a value, not a pair.
            if ((data_pt < self.index_mapper.range.low) or \
                (data_pt > self.index_mapper.range.high)) and outside_returns_none:
                return None
            index_data = self.index.get_data()
            value_data = self.value.get_data()

            if len(value_data) == 0 or len(index_data) == 0:
                return None

            try:
                ndx = reverse_map_1d(index_data, data_pt, self.index.sort_order)
            except IndexError, e:
                # if reverse_map raises this exception, it means that data_pt is
                # outside the range of values in index_data.
                if outside_returns_none:
                    return None
                else:
                    if data_pt < index_data[0]:
                        return 0
                    else:
                        return len(index_data) - 1

            if threshold == 0.0:
                # Don't do any threshold testing
                return ndx

            x = index_data[ndx]
            y = value_data[ndx]
            if isnan(x) or isnan(y):
                return None
            sx, sy = self.map_screen([x,y])
            if ((threshold == 0.0) or (screen_pt[0]-sx) < threshold):
                return ndx
            else:
                return None
        else:
            # Brute force implementation
            all_data = transpose(array([self.index.get_data(), self.value.get_data()]))
            screen_points = around(self.map_screen(all_data))
            if len(screen_points) == 0:
                return None
            if index_only:
                distances = abs(screen_points[:,0] - screen_pt[0])
            else:
                delta = screen_points - array([screen_pt])
                distances = sqrt(sum(delta*delta, axis=1))
            closest_ndx = argmin(distances)
            if distances[closest_ndx] <= threshold:
                return closest_ndx
            else:
                return None


    #------------------------------------------------------------------------
    # Private methods; implements the BaseXYPlot stub methods
    #------------------------------------------------------------------------

    def _gather_points_old(self):
        """
        Collects the data points that are within the bounds of the plot and
        caches them
        """
        if self._cache_valid and self._selection_cache_valid:
            return

        if not self.index or not self.value:
            return

        index, index_mask = self.index.get_data_mask()
        value, value_mask = self.value.get_data_mask()

        if len(index) == 0 or len(value) == 0 or len(index) != len(value):
            self._cached_data_pts = []
            self._cached_point_mask = []
            self._cache_valid = True
            return

        index_range_mask = self.index_mapper.range.mask_data(index)
        value_range_mask = self.value_mapper.range.mask_data(value)

        nan_mask = invert(isnan(index)) & index_mask & \
                   invert(isnan(value)) & value_mask
        point_mask = nan_mask & index_range_mask & value_range_mask

        if not self._cache_valid:
            points = transpose(array((index,value)))
            self._cached_data_pts = compress(point_mask, points, axis=0)
            self._cached_point_mask = point_mask[:]
            self._cache_valid = True

        if not self._selection_cache_valid:
            indices = None
            # Check both datasources for metadata
            # XXX: Only one is used, and if both are defined, then self.index
            # happens to take precendence.  Perhaps this should be more
            # structured?  Hopefully, when we create the Selection objects,
            # we'll have to define a small algebra about how they are combined,
            # and this will fall out...
            for ds in (self.index, self.value):
                if ds.metadata.get('selection_masks', None) is not None:
                    try:
                        for mask in ds.metadata['selection_masks']:
                            point_mask &= mask
                        indices = where(point_mask == True)
                        points = transpose(array((index[indices], value[indices])))
                    except:
                        continue
                elif ds.metadata.get('selections', None) is not None:
                    try:
                        indices = ds.metadata['selections']
                        point_mask = point_mask[indices]
                        points = transpose(array((index[indices], value[indices])))
                    except:
                        continue
                else:
                    continue

                self._cached_selection_point_mask = point_mask
                self._cached_selected_pts = points
                self._selection_cache_valid = True
                break
            else:
                self._cached_selected_pts = None
                self._selection_cache_valid = True

        return

    def _gather_points_fast(self):
        if self._cache_valid and self._selection_cache_valid:
            return

        if not self.index or not self.value:
            return

        index, index_mask = self.index.get_data_mask()
        value, value_mask = self.value.get_data_mask()

        index_range = self.index_mapper.range
        value_range = self.value_mapper.range

        kw = {}
        for axis in ("index", "value"):
            ds = getattr(self, axis)
            if ds.metadata.get('selections', None) is not None:
                kw[axis + "_sel"] = ds.metadata['selections']
            if ds.metadata.get('selection_mask', None) is not None:
                kw[axis + "_sel_mask"] = ds.metadata['selection_mask']

        points, selections = scatterplot_gather_points(index, index_range.low, index_range.high,
                                    value, value_range.low, value_range.high,
                                    index_mask = index_mask,
                                    value_mask = value_mask,
                                    **kw)

        if not self._cache_valid:
            self._cached_data_pts = points
            self._cache_valid = True

        if not self._selection_cache_valid:
            if selections is not None and len(selections) > 0:
                self._cached_selected_pts = points[selections]
                self._selection_cache_valid = True
            else:
                self._cached_selected_pts = None
                self._selection_cache_valid = True


    def _gather_points(self):
        #self._gather_points_fast()
        self._gather_points_old()

    def _render(self, gc, points, icon_mode=False):
        """
        This same method is used both to render the scatterplot and to
        draw just the iconified version of this plot, with the latter
        simply requiring that a few steps be skipped.
        """

        if not icon_mode:
            gc.save_state()
            gc.clip_to_rect(self.x, self.y, self.width, self.height)

        self.render_markers_func(gc, points, self.marker, self.marker_size,
                       self.effective_color, self.line_width, self.effective_outline_color,
                       self.custom_symbol, point_mask=self._cached_point_mask)

        if self._cached_selected_pts is not None and len(self._cached_selected_pts) > 0:
            sel_pts = self.map_screen(self._cached_selected_pts)
            self.render_markers_func(gc, sel_pts, self.selection_marker,
                    self.selection_marker_size, self.selection_color_,
                    self.selection_line_width, self.selection_outline_color_,
                    self.custom_symbol, point_mask=self._cached_point_mask)

        if not icon_mode:
            # Draw the default axes, if necessary
            self._draw_default_axes(gc)
            gc.restore_state()

    def _render_icon(self, gc, x, y, width, height):
        point = array([x+width/2, y+height/2])
        self._render(gc, [point], icon_mode=True)
        return

    #------------------------------------------------------------------------
    # Event handlers
    #------------------------------------------------------------------------

    def _alpha_changed(self):
        self.invalidate_draw()
        self.request_redraw()

    def _marker_changed(self):
        self.invalidate_draw()
        self.request_redraw()

    def _marker_size_changed(self):
        self.invalidate_draw()
        self.request_redraw()

    def _line_width_changed(self):
        self.invalidate_draw()
        self.request_redraw()

    def _color_changed(self):
        self.invalidate_draw()
        self.request_redraw()

    def _outline_color_changed(self):
        self.invalidate_draw()
        self.request_redraw()

    def _either_metadata_changed(self):
        self._selection_cache_valid = False
        self.invalidate_draw()
        self.request_redraw()

    #------------------------------------------------------------------------
    # Defaults
    #------------------------------------------------------------------------

    def _marker_size_default(self):
        return 4.0

    #------------------------------------------------------------------------
    # Properties
    #------------------------------------------------------------------------

    @cached_property
    def _get_effective_color(self):
        if len(self.color_) == 4:
            edge_alpha = self.color_[-1]
        else:
            edge_alpha = 1.0
        c = self.color_[:3] + (edge_alpha * self.alpha,)
        return c

    @cached_property
    def _get_effective_outline_color(self):
        if len(self.outline_color_) == 4:
            edge_alpha = self.outline_color_[-1]
        else:
            edge_alpha = 1.0
        c = self.outline_color_[:3] + (edge_alpha * self.alpha,)
        return c

# EOF

########NEW FILE########
__FILENAME__ = scatter_inspector_overlay

from __future__ import with_statement

# Major library imports
from numpy import array, asarray

# Enthought library imports
from enable.api import ColorTrait, MarkerTrait
from traits.api import Float, Int, Str, Trait

# Local, relative imports
from abstract_overlay import AbstractOverlay
from scatterplot import render_markers

class ScatterInspectorOverlay(AbstractOverlay):
    """
    Highlights points on a scatterplot as the mouse moves over them.
    Can render the points in a different style, as well as display a
    DataLabel.

    Used in conjuction with ScatterInspector.
    """

    # The style to use when a point is hovered over
    hover_metadata_name = Str('hover')
    hover_marker = Trait(None, None, MarkerTrait)
    hover_marker_size = Trait(None, None, Int)
    hover_line_width = Trait(None, None, Float)
    hover_color = Trait(None, None, ColorTrait)
    hover_outline_color = Trait(None, None, ColorTrait)

    # The style to use when a point has been selected by a click
    selection_metadata_name = Str('selections')
    selection_marker = Trait(None, None, MarkerTrait)
    selection_marker_size = Trait(None, None, Int)
    selection_line_width = Trait(None, None, Float)
    selection_color = Trait(None, None, ColorTrait)
    selection_outline_color = Trait(None, None, ColorTrait)

    # For now, implement the equivalent of this Traits 3 feature manually
    # using a series of trait change handlers (defined at the end of the
    # class)
    #@on_trait_change('component.index.metadata_changed,component.value.metadata_changed')
    def metadata_changed(self, object, name, old, new):
        if self.component is not None:
            self.component.request_redraw()
        return

    def overlay(self, component, gc, view_bounds=None, mode="normal"):
        plot = self.component
        if not plot or not plot.index or not getattr(plot, "value", True):
            return

        for inspect_type in (self.hover_metadata_name, self.selection_metadata_name):
            if inspect_type in plot.index.metadata:
                #if hasattr(plot,"value") and not inspect_type in plot.value.metadata:
                #    continue
                index = plot.index.metadata.get(inspect_type, None)

                if index is not None and len(index) > 0:
                    index = asarray(index)
                    index_data = plot.index.get_data()

                    # Only grab the indices which fall within the data range.
                    index = index[index < len(index_data)]

                    # FIXME: In order to work around some problems with the
                    # selection model, we will only use the selection on the
                    # index.  The assumption that they are the same is
                    # implicit, though unchecked, already.
                    #value = plot.value.metadata.get(inspect_type, None)
                    value = index

                    if hasattr(plot, "value"):
                        value_data = plot.value.get_data()
                        screen_pts = plot.map_screen(array([index_data[index],
                                                            value_data[value]]).T)
                    else:
                        screen_pts = plot.map_screen(index_data[index])

                    if inspect_type == self.selection_metadata_name:
                        prefix = "selection"
                    else:
                        prefix = "hover"
                    self._render_at_indices(gc, screen_pts, prefix)
        return

    def _render_at_indices(self, gc, screen_pts, inspect_type):
        """ screen_pt should always be a list """
        self._render_marker_at_indices(gc, screen_pts, inspect_type)

    def _render_marker_at_indices(self, gc, screen_pts, prefix, sep="_"):
        """ screen_pt should always be a list """
        if len(screen_pts) == 0:
            return

        plot = self.component

        mapped_attribs = ("color", "outline_color", "marker")
        other_attribs = ("marker_size", "line_width")
        kwargs = {}
        for attr in mapped_attribs + other_attribs:
            if attr in mapped_attribs:
                # Resolve the mapped trait
                valname = attr + "_"
            else:
                valname = attr

            tmp = getattr(self, prefix+sep+valname)
            if tmp is not None:
                kwargs[attr] = tmp
            else:
                kwargs[attr] = getattr(plot, valname)

        # If the marker type is 'custom', we have to pass in the custom_symbol
        # kwarg to render_markers.
        if kwargs.get("marker", None) == "custom":
            kwargs["custom_symbol"] = plot.custom_symbol

        with gc:
            gc.clip_to_rect(plot.x, plot.y, plot.width, plot.height)
            render_markers(gc, screen_pts, **kwargs)


    def _draw_overlay(self, gc, view_bounds=None, mode="normal"):
        self.overlay(self.component, gc, view_bounds, mode)

    def _component_changed(self, old, new):
        if old:
            old.on_trait_change(self._ds_changed, 'index', remove=True)
            if hasattr(old, "value"):
                old.on_trait_change(self._ds_changed, 'value', remove=True)
        if new:
            for dsname in ("index", "value"):
                if not hasattr(new, dsname):
                    continue
                new.on_trait_change(self._ds_changed, dsname)
                if getattr(new, dsname):
                    self._ds_changed(new, dsname, None, getattr(new,dsname))
        return

    def _ds_changed(self, object, name, old, new):
        if old:
            old.on_trait_change(self.metadata_changed, 'metadata_changed', remove=True)
        if new:
            new.on_trait_change(self.metadata_changed, 'metadata_changed')
        return



########NEW FILE########
__FILENAME__ = scatter_markers
# This module used to be the home of the various Marker classes, but they
# have since been moved to the enable.markers module.

from enable.compiled_path import CompiledPath
from enable.markers import AbstractMarker, SquareMarker, \
    CircleMarker, TriangleMarker, Inverted_TriangleMarker, PlusMarker, \
    CrossMarker, DiamondMarker, DotMarker, PixelMarker, CustomMarker, \
    marker_trait, MarkerNameDict, marker_names

from kiva.constants import STROKE, FILL_STROKE, \
            SQUARE_MARKER, DIAMOND_MARKER, CIRCLE_MARKER, \
            CROSS_MARKER, TRIANGLE_MARKER, \
            INVERTED_TRIANGLE_MARKER, PLUS_MARKER, DOT_MARKER, \
            PIXEL_MARKER, NO_MARKER




########NEW FILE########
__FILENAME__ = selectable_legend

from chaco.tools.api import SelectTool
from traits.api import List

from legend import Legend

class SelectableLegend(Legend, SelectTool):

    # A list of indices into self._cached_labels that indicates which labels
    # should be rendered in the "selected" style
    selections = List

    # A cached list of tuples (x,y,w,h) of each label's geometry
    _cached_label_dims = List

    #------------------------------------------------------------------------
    # Legend methods
    #------------------------------------------------------------------------

    def _do_layout(self):
        Legend._do_layout(self)
        self._compute_label_dims()

    def _compute_label_dims(self):
        dims = []
        edge_space = self.border_width + self.border_padding
        icon_width, icon_height = self.icon_bounds

        icon_x = self.x + edge_space
        text_x = icon_x + icon_width + self.icon_spacing
        y = self.y2 - edge_space
        for i, label_name in enumerate(self._cached_label_names):
            label_width, label_height = self._cached_label_sizes[i]
            y -= label_height
            icon_y = y + (label_height - icon_height) / 2
            dims.append((icon_x, icon_y, icon_width + self.icon_spacing + label_width,
                         label_height))
            y -= self.line_spacing
        self._cached_label_dims = dims

    #------------------------------------------------------------------------
    # SelectTool interface
    #------------------------------------------------------------------------

    def _get_selection_state(self, event):
        for ndx, dims in enumerate(self._cached_label_dims):
            x, y, w, h = dims
            if (x <= event.x <= x+w) and (y <= event.y <= y+h):
                return (ndx in self.selections), True
        else:
            if len(self._cached_label_dims) > 0:
                return (ndx in self.selections), False
            else:
                return False, False

    def _get_selection_token(self, event):
        for ndx, dims in enumerate(self._cached_label_dims):
            x, y, w, h = dims
            if (x <= event.x <= x+w) and (y <= event.y <= y+h):
                return ndx
        else:
            return None

    def _select(self, index, append=True):
        if append:
            self.selections.append(index)
        else:
            self.selections = [index]
        return

    def _deselect(self, index=None):
        if index in self.selections:
            self.selections.remove(index)
        return


########NEW FILE########
__FILENAME__ = selectable_overlay_container
""" Defines the SelectableOverlayPlotContainer class.
"""

from __future__ import with_statement

from numpy import array, float64

# Enthought library imports
from traits.api import Bool, Float, Enum
from enable.api import ColorTrait

# Local imports
from plot_containers import OverlayPlotContainer

class SelectableOverlayPlotContainer(OverlayPlotContainer):
    """
    An OverlayPlotContainer that can show a selection region on top of it.
    """

    # Screen position of the start of the selection, which can be in the x- or
    # y-dimension, depending on **selection_direction**.
    selection_screen_start = Float(0.0)
    # Screen position of the end of the selection, which can be in the x- or
    # y-dimension, depending on **selection_direction**.
    selection_screen_end = Float(0.0)
    # Is there an active selection?
    selection_active = Bool(False)
    # The direction of the selection.
    selection_direction = Enum('v', 'h')
    # The color to use to fill the selected region.
    selection_fill_color = ColorTrait('lightskyblue')
    # The color to use to draw the border of the selected region.
    selection_border_color = ColorTrait('dodgerblue')
    # The transparency of the **selection_fill_color**.
    selection_alpha = Float(0.3)

    def _draw_overlays(self, gc, view_bounds=None, mode='normal'):
        """ Method for backward compatability with old drawing scheme.

        Overrides BasePlotContainer.
        """
        self._draw_selection(gc, view_bounds=view_bounds, mode=mode)
        return

    def _draw_selection(self, gc, view_bounds=None, mode='normal'):
        """ Renders a selected subset of a component's data.

        Overrides PlotComponent.
        """
        if self.selection_active:
            if self.selection_direction == 'h':
                x1 = self.selection_screen_start
                x2 = self.selection_screen_end
                y1 = self.y
                y2 = self.position[1] + self.bounds[1] - 1
            else:
                x1 = self.x
                x2 = self.position[0] + self.bounds[0] - 1
                y1 = self.selection_screen_start
                y2 = self.selection_screen_end
            lowerleft = array((min(x1, x2), min(y1, y2)), float64)
            upperright = array((max(x1, x2), max(y1, y2)), float64)
            with gc:
                gc.translate_ctm(*self.position)
                gc.set_fill_color(self.selection_fill_color_)
                gc.set_stroke_color(self.selection_border_color_)
                gc.set_alpha(self.selection_alpha)
                gc.rect(lowerleft[0], lowerleft[1], upperright[0], upperright[1])
                gc.draw_path()
        return



########NEW FILE########
__FILENAME__ = serializable
""" Defines the Serializable mix-in class.
"""

class Serializable(object):
    """
    Mix-in class to help serialization.  Serializes just the attributes in
    **_pickles**.

    This mix-in works best when all the classes in a hierarchy subclass
    from it.  It solves the problem of allowing each class to specify
    its own set of attributes to pickle and attributes to ignore, without
    having to also implement __getstate__ and __setstate__.
    """

    # The basic list of attributes to save.  These get set without firing
    # any trait events.
    _pickles = None

    # A list of the parents of this class that will be searched for their
    # list of _pickles.  Only the parents in this list that inherit from
    # Serialized will be pickled.  The process stops at the first item in
    # __pickle_parents that is not a subclass of Serialized.
    #
    # This is a double-underscore variable so that Python's attribute name
    # will shield base class
#    __pickle_parents = None

    def _get_pickle_parents(self):
        """
        Subclasses can override this method to return the list of base
        classes they want to have the serializer look at.
        """
        bases = []
        for cls in self.__class__.__mro__:
            if cls is Serializable:
                # don't add Serializable to the list of parents
                continue
            elif issubclass(cls, Serializable):
                bases.append(cls)
            else:
                break
        return bases

    def _pre_save(self):
        """
        Called before __getstate__ to give the object a chance to tidy up
        and get ready to be saved.  This usually also calls the superclass.
        """
        return

    def _post_load(self):
        """
        Called after __setstate__ finishes restoring the state on the object.
        This method usually needs to include a call to super(cls, self)._post_load().
        Avoid explicitly calling a parent class by name, because in general
        you want post_load() to happen in the same order as MRO, which super()
        does automatically.
        """
        print 'Serializable._post_load'
        pass

    def _do_setstate(self, state):
        """
        Called by __setstate__ to allow the subclass to set its state in a
        special way.

        Subclasses should override this instead of Serializable.__setstate__
        because we need Serializable's implementation to call _post_load() after
        all the _do_setstate() have returned.)
        """
        # Quietly all the attributes
        self.set(trait_change_notify=False, **state)
        return

    #------------------------------------------------------------------------
    # Private methods
    #------------------------------------------------------------------------

#    def __getstate__(self):
#        #idstring = self.__class__.__name__ + " id=" + str(id(self))
#        # Give the object a chance to tidy up before saving
#        self._pre_save()
#
#        # Get the attributes that this class needs to serialize.  We do this by
#        # marching up the list of parent classes in _pickle_parents and getting
#        # their lists of _pickles.
#        all_pickles = Set()
#        pickle_parents = self._get_pickle_parents()
#        for parent_class in pickle_parents:
#            all_pickles.update(parent_class._pickles)
#
#        if self._pickles is not None:
#            all_pickles.update(self._pickles)
#
#        state = {}
#        for attrib in all_pickles:
#            state[attrib] = getattr(self, attrib)
#
#        print '<<<<<<<<<<<<<', self
#        for key,value in state.items():
#            print key, type(value)
#        print '>>>>>>>>>>>>>'
#
#        return state

    #~ def __setstate__(self, state):
        #~ idstring = self.__class__.__name__ + " id=" + str(id(self))
        #~ self._do_setstate(state)
        #~ self._post_load()
        #~ return


# EOF

########NEW FILE########
__FILENAME__ = chaco_shell_error
""" Defines the ChacoShellError class.
"""

class ChacoShellError(RuntimeError):
    """ Error raised by the Chaco shell.
    """
    pass

# EOF

########NEW FILE########
__FILENAME__ = commands
""" Defines commands for the Chaco shell.
"""

try:
    from wx import GetApp
except ImportError:
    GetApp = lambda: None

from chaco.api import Plot, color_map_name_dict
from chaco.scales.api import ScaleSystem
from chaco.tools.api import PanTool, ZoomTool

# Note: these are imported to be exposed in the namespace.
from chaco.scales.api import (FixedScale, Pow10Scale, LogScale,
    CalendarScaleSystem)
from chaco.default_colormaps import *

import plot_maker
from session import PlotSession

session = PlotSession()


#------------------------------------------------------------------------
# General help commands
#------------------------------------------------------------------------

def chaco_commands():
    """
    Prints the current list of all shell commands.  Information
    on each command is available in that command's docstring (__doc__).

    Window/Plot Management
    ----------------------
    figure
        creates a new figure window
    activate
        activates an existing window or plot
    close
        closes a window
    curplot
        returns a reference to the active window's Plot object
    show
        starts the GUI and displays windows (should only be used in scripts)

    Plotting
    --------
    plot
        plots some data
    imread
        creates an array from an image file on disk
    imshow
        creates an image plot from a file on disk
    pcolor
        plots some scalar data as a pseudocolor image
    contour
        creates a contour line plot of some scalar data
    contourf
        creates a contour poly plot of some scalar data
    loglog
        plots an x-y line or scatter plot on log-log scale
    semilogx
        plots an x-y line or scatter plot with a log x-scale
    semilogy
        plots an x-y line or scatter plot with a log y-scale
    hold
        turns "hold" on or off
    show
        shows plot on screen; used when running from script


    Axes, Annotations, Legends
    --------------------------
    xaxis
        toggles the horizontal axis, sets the interval
    yaxis
        toggles the vertical axis, sets the interval
    xgrid
        toggles the grid running along the X axis
    ygrid
        toggles the grid running along the Y axis
    xtitle
        sets the title of a horizontal axis
    ytitle
        sets the title of a vertical axis
    xscale
        sets the tick scale system of the X axis
    yscale
        sets the tick scale system of the Y axis
    title
        sets the title of the plot


    Tools
    -----
    colormap
        sets the current colormap

    IO
    --
    save
        saves the current plot to a file (png, bmp, jpg, pdf)
    """
    print chaco_commands.__doc__

    # The following are not implemented yet
    """
    tool -- toggles certain tools on or off
    load -- loads a saved plot from file into the active plot area
    scatter -- plots some data as a scatterplot (unordered X/Y data)
    line -- plots some data as an ordered set of of X,Y points
    label -- adds a label at a data point
    legend -- creates a legend and adds it to the plot

    Layout
    ------
    names -- temporarily overlays plot areas with their names
    hidenames -- force remove the name overlays from show_names
    happend -- create a new plot area horizontally after the active plot
    vappend -- create a new plot area vertically after the active plot
    hsplit -- splits the current plot into two horizontal subplots
    vsplit -- splits the current plot into two vertical subplots
    save_layout -- saves the current layout of plots and plots areas
    load_layout -- loads a saved layout of plot areas and applies it to the
                   current set of plots

    Sessions
    --------
    save_session -- saves the current "workspace", defined as the set of
                    active windows and plots
    load_session -- restores a previously-saved session
    save_prefs -- saves the current session's preferences, either in a
                  separate file or as the chaco.shell defaults
    load_prefs -- loads a previously-saved set of preferences
    """

#------------------------------------------------------------------------
# Window management commands
#------------------------------------------------------------------------

def figure(name=None, title=None):
    """ Creates a new figure window and returns its index.

    Parameters
    ----------
    name : string
        The name to use for this window. If this parameter is provided, then
        this name can be used instead of the window's integer index in other
        window-related functions.
    title : string
        The title of the plot window. If this is blank but *name* is provided,
        then that is used. If neither *name* nor *title* is provided, then the
        method uses the value of default_window_name in the Preferences.
    """
    win = session.new_window(name, title)
    activate(win)
    return win


def activate(ident=None):
    """ Activates and raises a figure window.

    Parameters
    ----------
    ident : integer or string
        Index or name of the window.  If neither is specified,
        then the function raises the currently active window.
    """
    if ident is not None:
        win = session.get_window(ident)
    else:
        win = session.active_window

    if win is not None:
        session.active_window = win
        win.raise_window()
    return

def show():
    """ Shows all the figure windows that have been created thus far, and
    creates a GUI main loop. This function is useful in scripts to show plots
    and keep their windows open, and has no effect when used from the
    interpreter prompt.
    """

    from traits.etsconfig.api import ETSConfig
    from pyface.util import guisupport
    is_event_loop_running = getattr(guisupport, 'is_event_loop_running_' + ETSConfig.toolkit)
    start_event_loop = getattr(guisupport, 'start_event_loop_' + ETSConfig.toolkit)

    if not is_event_loop_running():
        frame = session.active_window
        frame.raise_window()
        start_event_loop()
    return


def close(ident=None):
    """ Closes a figure window

    Parameters
    ----------
    ident : integer or string
        Index or name of the window to close, or "all".  If nothing
        is specified, then the function closes the active window.
    """
    win_list = []
    if ident is None:
        win_list.append(session.active_window)
    elif ident == 'all':
        win_list = session.windows
    else:
        win_list.append(session.get_window(ident))

    for win in win_list:
        win.close()
    return

def colormap(map):
    """Sets the active colormap.

    Parameters
    ----------
    map : a string, or a callable
         The color map to use; if it is a string, it is the name of a default
         colormap; if it is a callable, it must return an AbstractColorMap.
    """
    if isinstance(map, basestring):
        session.colormap = color_map_name_dict[map]
    else:
        session.colormap = map


def hold(state=None):
    """ Turns "hold" on or off, or toggles the current state if none
    is given.

    Parameters
    ----------
    state : Boolean
        The desired hold state.
    """
    if state is None:
        session.hold = not session.hold
    else:
        session.hold = state
    return

def curplot():
    if session.active_window:
        return session.active_window.get_container()
    else:
        return None

#------------------------------------------------------------------------
# Plotting functions
#------------------------------------------------------------------------

def _do_plot_boilerplate(kwargs, image=False):
    """ Used by various plotting functions.  Checks/handles hold state,
    returns a Plot object for the plotting function to use.
    """

    if kwargs.has_key("hold"):
        hold(kwargs["hold"])
        del kwargs["hold"]

    # Check for an active window; if none, open one.
    if len(session.windows) == 0:
        if image:
            win = session.new_window(is_image=True)
            activate(win)
        else:
            figure()

    cont = session.active_window.get_container()

    if not cont:
        cont = Plot(session.data)
        session.active_window.set_container(cont)

    existing_tools = [type(t) for t in (cont.tools + cont.overlays)]
    if not PanTool in existing_tools:
        cont.tools.append(PanTool(cont))
    if not ZoomTool in existing_tools:
        cont.overlays.append(ZoomTool(cont, tool_mode="box", always_on=True, drag_button="right"))

    if not session.hold:
        cont.delplot(*cont.plots.keys())

    return cont


def plot(*data, **kwargs):
    """ Plots data in a Matlab-compatible way.  Data is assumed to be
    X vs Y.  Any additional *kwargs* passed in are broadcast to all plots.

    Example::

        x = arange(-pi, pi, pi/100.)
        plot(x, sin(x), "b-")

    To use previous data, specify names instead of actual data arrays.
    """

    cont = _do_plot_boilerplate(kwargs)

    plots = plot_maker.do_plot(session.data, cont,
                               *data, **kwargs)

    cont.request_redraw()
    return


def semilogx(*data, **kwargs):
    """ Plots data on a semilog scale in a Matlab-compatible way.  Data is
    assumed to be X vs Y.  Any additional *kwargs* passed in are broadcast
    to all plots.

    Example::

        x = linspace(0.01, 10.0 100)
        semilogx(x, sqrt(x), "b-")

    To use previous data, specify names instead of actual data arrays.

    Adding a semilog plot to an active plot with a currently different scale
    rescales the plot.
    """
    kwargs["index_scale"] = "log"
    plot(*data, **kwargs)


def semilogy(*data, **kwargs):
    """ Plots data on a semilog scale in a Matlab-compatible way.  Data is
    assumed to be X vs Y.  Any additional *kwargs* passed in are broadcast
    to all plots.

    Example::

        x = linspace(0, 10.0, 100)
        semilogy(x, exp(x), "b-")

    To use previous data, specify names instead of actual data arrays.

    Adding a semilog plot to an active plot with a currently different scale
    rescales the plot.
    """
    kwargs["value_scale"] = "log"
    plot(*data, **kwargs)


def loglog(*data, **kwargs):
    """ Plots data on a log-log scale in a Matlab-compatible way.  Data is
    assumed to be X vs Y.  Any additional *kwargs* passed in are broadcast
    to all plots.

    Example::

        x = linspace(0.001, 10.0, 100)
        loglog(x, x**2, "b-")

    To use previous data, specify names instead of actual data arrays.

    Adding a log-log plot to an active plot with a currently different scale
    rescales the plot.
    """
    kwargs["index_scale"] = "log"
    kwargs["value_scale"] = "log"
    plot(*data, **kwargs)


def imread(*data, **kwargs):
    """ Returns image file as an array. """

    return plot_maker.do_imread(*data, **kwargs)


def imshow(*data, **kwargs):
    """ Creates an image plot from a file on disk.  Takes either
    filename or image data.  Any additional *kwargs* passed in are broadcast
    to all plots.

    Example 1::

        imshow("example.jpg")

    Example 2::

        image = ImageData.fromfile("example.jpg")
        imshow(image)

    To use previous data, specify names instead of filename or data arrays.

    """

    cont = _do_plot_boilerplate(kwargs, image=True)

    if "colormap" not in kwargs:
        kwargs["colormap"] = session.colormap
    plots = plot_maker.do_imshow(session.data, cont,
                                 *data, **kwargs)
    cont.request_redraw()
    return


def pcolor(*data, **kwargs):
    """ Colormaps scalar data in a roughly Matlab-compatible way. Data are
    assumed to be a scalar image.  Any additional *kwargs* passed in are
    broadcast to all plots.

    Example::

        xs = linspace(0,10,100)
        ys = linspace(0,20,200)
        x,y=meshgrid(xs,ys)
        z = sin(x)*y
        pcolor(x, y, z)

    To use previous data, specify names instead of actual data arrays.
    """

    cont = _do_plot_boilerplate(kwargs)

    plots = plot_maker.do_pcolor(session.data, session.colormap, cont,
                                 *data, **kwargs)
    cont.request_redraw()
    return



def contour(*data, **kwargs):
    """ Contour line plots of scalar data in a roughly Matlab-compatible way.
    Data are assumed to be a scalar image.  Any additional *kwargs* passed in
    are broadcast to all plots.

    Example::

        xs = linspace(0,10,100)
        ys = linspace(0,20,200)
        x,y=meshgrid(xs,ys)
        z = sin(x)*y
        contour(z)

    To use previous data, specify names instead of actual data arrays.
    """

    cont = _do_plot_boilerplate(kwargs)

    plots = plot_maker.do_contour(session.data, session.colormap, cont,
                                  "line", *data, **kwargs)
    cont.request_redraw()
    return



def contourf(*data, **kwargs):
    """ Contour polygon plots of scalar data in a roughly Matlab-compatible way.
    Data are assumed to be a scalar image.  Any additional *kwargs* passed in
    are broadcast to all plots.

    Example::

        xs = linspace(0,10,100)
        ys = linspace(0,20,200)
        x,y=meshgrid(xs,ys)
        z = sin(x)*y
        contourf(z)

    To use previous data, specify names instead of actual data arrays.
    """

    cont = _do_plot_boilerplate(kwargs)

    plots = plot_maker.do_contour(session.data, session.colormap, cont,
                                  "poly", *data, **kwargs)
    cont.request_redraw()
    return



def plotv(*args, **kwargs):
    """ Creates a plot of a particular type, or using a "best guess"
    approach based on the data, using chaco semantics.

    The number and shape of data arrays determine how the data is
    interpreted, and how many plots are created.

    Single-dimensional arrays (shape = (N,))
    ----------------------------------------
    1. Single array: the data is treated as the value array, and an index
       array is generated automatically using arange(len(value))
    2. Multiple arrays: the first array is treated as the index array, and
       each subsequent array is used as the value for a new plot.  All of
       the plots share a common index (first array).

    Multi-dimensional arrays (shape = (N,2) or (2,N))
    -------------------------------------------------
    1. Single array (NxM or MxN, N > M): interpreted as M-1 plots of
       N data points each, just like in the multiple 1D array case above.
    2. Multiple arrays: each array is treated as a separate set of inter-
       related plots, with its own index and value data sources

    Keyword Arguments
    -----------------
    type
        comma-separated combination of "line", "scatter", "polar"
    sort
        "ascending", "descending", or "none", indicating the sorting order
        of the array that will be used as the index
    color
        the color of the plot line and/or marker
    bgcolor
        the background color of the plot
    grid
        boolean specifying whether or not to draw a grid on the plot
    axis
        boolean specifying whether or not to draw an axis on the plot
    orientation
        "h" for index on the X axis, "v" for index on the Y axis

    Scatter plot keywords
    ---------------------
    marker
        the type of marker to use (square, diamond, circle, cross,
        crossed circle, triangle, inverted triangle, plus, dot, pixel
    marker_size
        the size (in pixels) of the marker
    outline_color
        the color of the marker outline

    Line plot keywords
    ------------------
    width
        the thickness of the line
    dash
        the dash style to use (solid, dot dash, dash, dot, long dash)
    """

    cont = _do_plot_boilerplate(kwargs)
    plots = plot_maker.do_plotv(session, *args, **kwargs)
    cont.add(*plots)
    cont.request_redraw()
    return


#-----------------------------------------------------------------------------
# Annotations
#-----------------------------------------------------------------------------

def xtitle(text):
    """ Sets the horizontal axis label to *text*. """
    p = curplot()
    if p:
        p.x_axis.title = text
        p.request_redraw()


def ytitle(text):
    """ Sets the vertical axis label to *text*. """
    p = curplot()
    if p:
        p.y_axis.title = text
        p.request_redraw()

def title(text):
    """ Sets the plot title to *text*. """
    p = curplot()
    if p:
        p.title = text
        p.request_redraw()

_axis_params = """Parameters
    ----------
    title : str
        The text of the title
    title_font : KivaFont('modern 12')
        The font in which to render the title
    title_color : color ('color_name' or (red, green, blue, [alpha]) tuple)
        The color in which to render the title
    tick_weight : float
        The thickness (in pixels) of each tick
    tick_color : color ('color_name' or (red, green, blue, [alpha]) tuple)
        The color of the ticks
    tick_label_font : KivaFont('modern 10')
        The font in which to render the tick labels
    tick_label_color : color ('color_name' or (red, green, blue, [alpha]) tuple)
        The color of the tick labels
    tick_label_formatter : callable
        A callable that is passed the numerical value of each tick label and
        which should return a string.
    tick_in : int
        The number of pixels by which the ticks go "into" the plot area
    tick_out : int
        The number of pixels by which the ticks extend into the label area
    tick_visible : bool
        Are ticks visible at all?
    tick_interval : 'auto' or float
        What is the dataspace interval between ticks?
    orientation : Enum("top", "bottom", "left", "right")
        The location of the axis relative to the plot.  This determines where
        the axis title is located relative to the axis line.
    axis_line_visible : bool
        Is the axis line visible?
    axis_line_color : color ('color_name' or (red, green, blue, [alpha]) tuple)
        The color of the axis line
    axis_line_weight : float
        The line thickness (in pixels) of the axis line
    axis_line_style : LineStyle('solid')
        The dash style of the axis line"""

def xaxis(**kwds):
    """ Configures the x-axis.

    Usage
    -----
    * ``xaxis()``: toggles the horizontal axis on or off.
    * ``xaxis(**kwds)``: set parameters of the horizontal axis.

    %s
    """ % _axis_params
    p = curplot()
    if p:
        if kwds:
            p.x_axis.set(**kwds)
        else:
            p.x_axis.visible ^= True
        p.request_redraw()

xaxis.__doc__ = """ Configures the x-axis.

    Usage
    -----
    * ``xaxis()``: toggles the horizontal axis on or off.
    * ``xaxis(**kwds)``: set parameters of the horizontal axis.

    %s
    """ % _axis_params

def yaxis(**kwds):
    """ Configures the y-axis.

    Usage
    -----
    * ``yaxis()``: toggles the vertical axis on or off.
    * ``yaxis(**kwds)``: set parameters of the vertical axis.

    %s
    """ % _axis_params
    p = curplot()
    if p:
        if kwds:
            p.y_axis.set(**kwds)
        else:
            p.y_axis.visible ^= True
        p.request_redraw()

yaxis.__doc__ =     """ Configures the y-axis.

    Usage
    -----
    * ``yaxis()``: toggles the vertical axis on or off.
    * ``yaxis(**kwds)``: set parameters of the vertical axis.

    %s
    """ % _axis_params


def xgrid():
    """ Toggles the grid perpendicular to the X axis. """
    p = curplot()
    if p:
        p.x_grid.visible ^= True
        p.request_redraw()

def ygrid():
    """ Toggles the grid perpendicular to the Y axis. """
    p = curplot()
    if p:
        p.y_grid.visible ^= True
        p.request_redraw()

def _set_scale(axis, system):
    p = curplot()
    if p:
        if axis == 'x':
            log_linear_trait = 'index_scale'
            ticks = p.x_ticks
        else:
            log_linear_trait = 'value_scale'
            ticks = p.y_ticks
        if system == 'time':
            system = CalendarScaleSystem()
        if isinstance(system, basestring):
            setattr(p, log_linear_trait, system)
        else:
            if system is None:
                system = dict(linear=p.linear_scale, log=p.log_scale).get(
                    p.get(log_linear_trait), p.linear_scale)
            ticks.scale = system
        p.request_redraw()

def xscale(system=None):
    """ Change the scale system for the X-axis ticks.

    Usage
    -----
    * ``xscale()``: revert the scale system to the default.
    * ``xscale('time')``: use the calendar scale system for time series.
    * ``xscale('log')``: use a generic log-scale.
    * ``xscale('linear')``: use a generic linear-scale.
    * ``xscale(some_scale_system)``: use an arbitrary ScaleSystem object.
    """
    _set_scale('x', system)

def yscale(system=None):
    """ Change the scale system for the Y-axis ticks.

    Usage
    -----
    * ``yscale()``: revert the scale system to the default.
    * ``yscale('time')``: use the calendar scale system for time series.
    * ``yscale('log')``: use a generic log-scale.
    * ``yscale('linear')``: use a generic linear-scale.
    * ``yscale(some_scale_system)``: use an arbitrary ScaleSystem object.
    """
    _set_scale('y', system)

def legend(setting=None):
    """ Sets or toggles the presence of the legend

    Usage
    -----
    * ``legend()``: toggles the legend; if it is currently visible, it is hideen, and if it is currently hidden, then it is displayed
    * ``legend(True)``: shows the legend
    * ``legend(False)``: hides the legend
    """
    p = curplot()
    if p:
        if setting is None:
            setting = not p.legend.visible
        p.legend.visible = setting
        p.request_redraw()


#-----------------------------------------------------------------------------
# Tools
#-----------------------------------------------------------------------------

def tool():
    """ Toggles tools on and off. """
    p = curplot()
    if p:
        pass



#-----------------------------------------------------------------------------
# Saving and IO
#-----------------------------------------------------------------------------

def save(filename="chacoplot.png", dpi=72, pagesize="letter", dest_box=None, units="inch"):
    """ Saves the active plot to an file.  Currently supported file types
    are: bmp, png, jpg.
    """
    p = curplot()
    if not p:
        print "Doing nothing because there is no active plot."
        return

    import os.path
    ext = os.path.splitext(filename)[-1]
    if ext == ".pdf":
        print "Warning: the PDF backend is still a little buggy."
        from chaco.pdf_graphics_context import PdfPlotGraphicsContext
        # Set some default PDF options if none are provided
        if dest_box is None:
            dest_box = (0.5, 0.5, -0.5, -0.5)
        gc = PdfPlotGraphicsContext(filename = filename,
                                    pagesize = pagesize,
                                    dest_box = dest_box,
                                    dest_box_units = units)

        # temporarily turn off the backbuffer for offscreen rendering
        use_backbuffer = p.use_backbuffer
        p.use_backbuffer = False
        gc.render_component(p)
        p.use_backbuffer = use_backbuffer

        gc.save()
        del gc
        print "Saved to", filename

    elif ext in [".bmp", ".png", ".jpg"]:
        from chaco.api import PlotGraphicsContext
        gc = PlotGraphicsContext(tuple(p.outer_bounds), dpi=dpi)

        # temporarily turn off the backbuffer for offscreen rendering
        use_backbuffer = p.use_backbuffer
        p.use_backbuffer = False
        gc.render_component(p)
        p.use_backbuffer = use_backbuffer

        gc.save(filename)
        del gc
        print "Saved to", filename
    else:
        print "Format not yet supported:", ext
        print "Currently supported formats are: bmp, png, jpg."
    return



# EOF

########NEW FILE########
__FILENAME__ = plot_maker
"""
Contains the logic behind creating and configuring new plots
from a set of user-supplied arguments.
"""

# Standard library imports
import re

# Major library imports
from numpy import all, array, arange, asarray, reshape, shape, transpose

# Chaco imports
from chaco.api import (create_line_plot, create_scatter_plot,
    ArrayDataSource, ImageData)

from chaco.tools.api import HighlightTool



# Local relative imports
from chaco_shell_error import ChacoShellError


# Normally I don't define an __all__, but this lets us distinguish
# the top level plot-producing functions from the various helper
# functions.
__all__ = ["do_plot", "do_imshow", "do_pcolor", "do_contour", "do_plotv",
           "SizeMismatch", ]


#-----------------------------------------------------------------------------
# Exceptions
#-----------------------------------------------------------------------------

class SizeMismatch(ChacoShellError):
    pass


#-----------------------------------------------------------------------------
# Utility functions
#-----------------------------------------------------------------------------

def is1D (a):
    s = shape(a)
    return ((len(s) == 1) or (s[0] == 1) or (s[1] == 1))

def is2D (a):
    return (len(shape(a)) == 2)

def row ( a ):
        return reshape( asarray( a ), [1,-1] )

def col ( a ):
        return reshape( asarray( a ), [-1,1] )


#-----------------------------------------------------------------------------
# Plot commands for chaco-style plotv()
#-----------------------------------------------------------------------------

def do_plotv(session, *args, **kw):
    """ Creates a list of plots from the data in ``*args`` and options in
    ``**kw``, according to the docstring on commands.plot().
    """

    sort = kw.get("sort", "none")
    sources_list = make_data_sources(session, sort, *args)

    plot_type = kw.get("type", "line")
    if plot_type == "scatter":
        plots = [create_scatter_plot(sources) for sources in sources_list]
    elif plot_type == "line":
        plots = [create_line_plot(sources) for sources in sources_list]
    else:
        raise ChacoShellError, "Unknown plot type '%s'." % plot_type

    for plot in plots:
        plot.orientation = kw.get("orientation", "h")


    return plots

def make_data_sources(session, index_sort="none", *args):
    """ Given a list of arguments, returns a list of (index, value) datasources
    to create plots from.
    """
    # Make sure everything is a numpy array
    data = []
    for arg in args:
        if isinstance(arg, list) or isinstance(arg, tuple):
            data.append(array(arg))
        else:
            data.append(arg)

    if len(data) == 0:
        raise ChacoShellError, "Insufficient data for plot."

    # 1D array(s)
    if len(data[0].shape) == 1:
        if len(data) == 1:
            # Only a single array was provided
            index_ds = ArrayDataSource(arange(len(data[0])), sort_order="ascending")
            value_ds = ArrayDataSource(data[0], sort_order="none")
            return [(index_ds, value_ds)]

        else:
            # multiple arrays were provided
            index_ds = ArrayDataSource(data[0], sort_order=index_sort)
            return [(index_ds, ArrayDataSource(v, sort_order="none")) for v in data[1:]]

    # 2D arrays
    elif len(data[0].shape) == 2:
        sources = []
        # Loop over all the 2D arrays
        for ary in data:
            if ary.shape[0] > ary.shape[1]:
                index_ary = ary[:, 0]
                value_arrays = ary[:, 1:]
            else:
                index_ary = ary[0]
                value_arrays = transpose(ary[1:])
            index_ds = ArrayDataSource(index_ary, sort_order=index_sort)
            sources.extend([(index_ds, ArrayDataSource(v, sort_order="none")) for v in value_arrays])
        return sources

    # Not a two-dimensional array, error.
    else:
        raise ChacoShellError, "Unable to create plot data sources from array of" \
                               "shape " + str(data[1].shape) + "."


#-----------------------------------------------------------------------------
# Plot commands for matlab-compatible plot() function
#-----------------------------------------------------------------------------

# Regular expressions for parsing the format string

color_re = re.compile('[ymcrgbwk]')
color_trans = {
    'y': 'yellow',
    'm': 'magenta',
    'c': 'cyan',
    'r': 'red',
    'g': 'green',
    'b': 'blue',
    'w': 'white',
    'k': 'black'
}

# This one isn't quite right:

marker_re = re.compile('[ox+s^v]|(?:[^-])[.]')
marker_trans = {
    '.': 'dot',
    'o': 'circle',
    'x': 'cross',
    '+': 'plus',
    's': 'square',
    '^': 'triangle',
    'v': 'inverted_triangle'
}

line_re = re.compile('--|-\.|[-:]')
line_trans = {
    '-':  'solid',
    ':':  'dot',
    '-.': 'dot dash',
    '--': 'dash'
}

def _process_format(format):
    """
    Converts a format string into a (color, line, marker, marker_color) tuple.
    """
    if format == '':
        return ('black', 'solid', None, None)
    color, line, marker, marker_color = 'black', None, None, None
    m = color_re.findall(format)
    if len(m) > 0:
        color = marker_color = color_trans[m[0]]
        if len(m) > 1:
            marker_color = color_trans[m[1]]
    m = marker_re.findall(format)
    # The -1 takes care of 'r.', etc:
    if len(m) > 0:
        marker = marker_trans[m[0][-1]]
    m = line_re.findall(format)
    if len(m):
        line = line_trans[m[0]]
    return (color, line, marker, marker_color)

def _process_group(group, plot_data=None):
    """ Returns a (x_1D, y_1D, format_str) tuple from an input tuple
    of 1 to 3 elements: (x,y,format_str).

    A PlotData object can be optionally provided to disambiguate the cases
    when exactly two strings are passed in.  The two strings could be the
    names of the x and y datasources, or they could be the name of the y
    datasource and a format string.  By checking the second string against
    the plot_data's list of datasources, the method can determine what it is meant
    to be.
    """
    # Interpret and split the 'group' tuple into x, y, and plotinfo
    plotinfo = ''
    if len(group) == 1:
        y = group[0]
        y_data = plot_data.get_data(y)
        x = plot_data.set_data("", arange(len(y_data)), generate_name=True)
    elif len(group) == 2:
        # There are two possibilities here; a single y was provided along
        # with a format string, or an x and y were provided.  If PlotData
        # was provided, use that to disambiguate; otherwise, assume that the
        # second string is a format string.
        if isinstance(group[1], basestring):
            if plot_data and group[1] in plot_data.list_data():
                x = group[0]
                y = group[1]
            else:
                plotinfo = group[1]
                y = group[0]
                y_data = plot_data.get_data(y)
                x = plot_data.set_data("", arange(len(y_data)), generate_name=True)
        else:
            x, y = group
    elif len(group) == 3:
        x, y, plotinfo = group
    else:
        raise ChacoShellError("Found too many elements in group while" \
                              " constructing plot.")
    return x, y, plotinfo


def _check_sort_order(data):
    diffs = data[1:] - data[:-1]
    if all(diffs >= 0):
        return "ascending"
    elif all(diffs <= 0):
        return "descending"
    else:
        return "none"


def do_plot(plotdata, active_plot, *data_and_formats, **kwtraits):
    """ Takes a list of data (arrays or names) and format string arguments
    and creates new plots on the active_plot.  Returns a list of plot names
    on the active plot.
    """
    # The list of data and formats is broken up by format strings,
    # so we break it up by arguments that are strings.
    cur_group = []
    groups = []
    valid_names = plotdata.list_data()
    for arg in data_and_formats:
        if not isinstance(arg, basestring):
            # an array was passed in
            cur_group.append(plotdata.set_data("", arg, generate_name=True))
        elif arg in valid_names:
            # the name of an existing plotdata item was passed in
            cur_group.append(arg)
        else:
            # String that is not in plotdata is interpreted as a format
            # string, thereby terminating this group
            cur_group.append(arg)
            groups.append(cur_group)
            cur_group = []

    if len(cur_group) > 0:
        groups.append(cur_group)

    # Process the list of groups and create a list of plots;
    # broadcast the keyword traits to all of them.
    plots = []

    for group in groups:
        x, y, format_str = _process_group(group, plot_data = plotdata)
        linecolor, line, marker, markercolor = _process_format(format_str)
        plot_type = []
        format = kwtraits.copy()
        if line is not None:
            plot_type.append("line")
            format["line_style"] = line
            format["color"] = linecolor
        if marker is not None:
            plot_type.append("scatter")
            format["marker"] = marker
            format["color"] = markercolor

        x_sort_order = _check_sort_order(plotdata.get_data(x))
        plots.extend(active_plot.plot((x,y), type=",".join(plot_type), **format))

        # Set the sort order
        x_ds = active_plot.datasources[x]
        if isinstance(x_ds, ArrayDataSource):
            x_ds.sort_order = x_sort_order

        # Check to see if the active_plot has a highlighter tool already; if not,
        # then add it.
        for tool in active_plot.tools:
            if isinstance(tool, HighlightTool):
                break
        else:
            active_plot.tools.append(HighlightTool(active_plot))

    return plots

def do_imread(*data, **kwargs):
    """ Returns image file as array. """

    # Check to see if the data given is either a file path or a file object
    if isinstance(data[0], basestring) or isinstance(data[0], file):
        return ImageData.fromfile(data[0])
    else:
        raise ValueError("do_imread takes a string filename")



def do_imshow(plotdata, active_plot, *data, **kwargs):
    """ Creates an image plot on the active plot, given either
    a filename or data.
    """

    if len(data) != 1:
        raise ValueError("do_imshow takes one data source")

    x = None
    y = None
    try:
        z = _get_or_create_plot_data(data[0], plotdata)
    except ValueError:
        # z is the name of the file
        # create plot data
        image = do_imread(data[0], *data, **kwargs)
        z = plotdata.set_data("", image, generate_name=True)

    plot_list = [active_plot.img_plot(z, xbounds=x, ybounds=y, **kwargs)]

    return plot_list


def do_pcolor(plotdata, colormap, active_plot, *data, **kwargs ):
    """ Creates a pseudocolor image plot on the active plot, given a 2-D
    scalar data and a colormap.
    """

    # if we get just one data source, it is assumed to be the scalar field
    if len(data) == 1:
        x = None
        y = None
        z = _get_or_create_plot_data(data[0], plotdata)

    # three data sources means we got x-y grid data of some sort, too
    elif len(data) == 3:
        x = _get_or_create_plot_data(data[0], plotdata)
        y = _get_or_create_plot_data(data[1], plotdata)
        z = _get_or_create_plot_data(data[2], plotdata)
    else:
        raise ValueError("do_pcolor takes one or three data sources")

    plot_list = [active_plot.img_plot(z, xbounds=x, ybounds=y,
                                colormap=colormap, **kwargs)]
    return plot_list


def do_contour(plotdata, colormap, active_plot, type, *data, **kwargs ):
    """ Creates a contour plot on the active plot, given a 2-D
    scalar data and a colormap.
    """

    # if we get just one data source, it is assumed to be the scalar field
    if len(data) == 1:
        x = None
        y = None
        z = _get_or_create_plot_data(data[0], plotdata)

    # three data sources means we got x-y grid data of some sort, too
    elif len(data) == 3:
        x = _get_or_create_plot_data(data[0], plotdata)
        y = _get_or_create_plot_data(data[1], plotdata)
        z = _get_or_create_plot_data(data[2], plotdata)

    else:
        raise ValueError("do_contour takes one or three data sources")

    # we have to do slightly different calls here because of the different
    # handling of colormaps
    if type is 'poly':
        plot_list = [active_plot.contour_plot(z, type, xbounds=x, ybounds=y,
                                    poly_cmap=colormap,
                                    **kwargs)]
    else:
        plot_list = [active_plot.contour_plot(z, type, xbounds=x, ybounds=y,
                                    colors=colormap,
                                    **kwargs)]

    return plot_list


def _get_or_create_plot_data(data, plotdata):
    """Create a new name for `data` if necessary, or check it is a valid name.
    """
    valid_names = plotdata.list_data()

    if not isinstance(data, basestring):
        name = plotdata.set_data("", data, generate_name=True)
    else:
        if data not in valid_names:
            msg = '{} is not an existing name for plot data'
            raise ValueError(msg.format(data))

        name = data

    return name


# EOF

########NEW FILE########
__FILENAME__ = plot_window
""" Defines the PlotWindow class.
"""

from enable.api import Window
from chaco.shell.scaly_plot import ScalyPlot

from traits.etsconfig.api import ETSConfig

if ETSConfig.toolkit == "wx":

    import wx
    class PlotWindow(wx.Frame):
        """ A window for holding top-level plot containers.

        Contains many utility methods for controlling the appearance of the
        window, which mostly pass through to underlying WX calls.
        """

        def __init__(self, is_image=False, bgcolor="white",
                     image_default_origin="top left", *args, **kw):

            kw.setdefault("size", (600,600))
            wx.Frame.__init__(self, None, *args, **kw )

            # Some defaults which should be overridden by preferences.
            self.bgcolor = bgcolor
            self.image_default_origin = image_default_origin

            # Create an empty top-level container
            if is_image:
                top_container = self._create_top_img_container()
            else:
                top_container = self._create_top_container()

            # The PlotSession of which we are a part.  We need to know this in order
            # to notify it of our being closed, etc.
            self.session = None


            # Create the Enable Window object, and store a reference to it.
            # (This will be handy later.)  The Window requires a WX parent object
            # as its first argument, so we just pass 'self'.
            self.plot_window = Window(self, component=top_container)

            # We'll create a default sizer to put our plot_window in.
            sizer = wx.BoxSizer(wx.HORIZONTAL)

            # Since Window is an Enable object, we need to get its corresponding
            # WX control.  This is stored in its ".control" attribute.
            sizer.Add(self.plot_window.control, 1, wx.EXPAND)

            # Hook up event handlers for destroy, etc.
            wx.EVT_WINDOW_DESTROY(self, self._on_window_close)

            # More WX boilerplate.
            self.SetSizer(sizer)
            self.SetAutoLayout(True)
            self.Show(True)
            return

        def get_container(self):
            return self.plot_window.component

        def set_container(self, container):
            self.plot_window.component = container

        def iconize(self, iconize):
            """Iconizes the window if *iconize* is True.
            """
            self.Iconize(iconize)

        def maximize(self, maximize):
            """ If *maximize* is True, maximizes the window size; restores if False.
            """
            self.Maximize(maximize)

        def set_size(self, width, height):
            self.SetSize((width, height))

        def set_title(self, title):
            self.SetTitle(title)

        def raise_window(self):
            """Raises this window to the top of the window hierarchy.
            """
            self.Raise()

        def close(self):
            self.Close()

        # This is a Python property because this is not a HasTraits subclass.
        container = property(get_container, set_container)

        #------------------------------------------------------------------------
        # Private methods
        #------------------------------------------------------------------------

        def _create_top_container(self):
            plot = ScalyPlot(
                padding=50,
                fill_padding=True,
                bgcolor=self.bgcolor,
                use_backbuffer=True,
            )
            return plot

        def _create_top_img_container(self):
            plot = ScalyPlot(
                padding=50,
                fill_padding=True,
                bgcolor=self.bgcolor,
                use_backbuffer=True,
                default_origin=self.image_default_origin,
            )
            return plot


        def _on_window_close(self, event):
            if self.session:
                try:
                    ndx = self.session.windows.index(self)
                    self.session.del_window(ndx)
                except ValueError:
                    pass

elif ETSConfig.toolkit == "qt4":

    from pyface.qt import QtCore, QtGui

    class PlotWindow(QtGui.QFrame):
        """ A window for holding top-level plot containers.

        Contains many utility methods for controlling the appearance of the
        window, which mostly pass through to underlying Qt calls.
        """

        def __init__(self, is_image=False, bgcolor="white",
                     image_default_origin="top left", *args, **kw):

            if 'size' in kw and isinstance(kw['size'], tuple):
                # Convert to a QSize.
                kw['size'] = QtCore.QSize(*kw['size'])
            super(PlotWindow, self).__init__(None, *args, **kw )

            # Some defaults which should be overridden by preferences.
            self.bgcolor = bgcolor
            self.image_default_origin = image_default_origin

            # Create an empty top-level container
            if is_image:
                top_container = self._create_top_img_container()
            else:
                top_container = self._create_top_container()

            # The PlotSession of which we are a part.  We need to know this in order
            # to notify it of our being closed, etc.
            self.session = None

            # Create the Enable Window object, and store a reference to it.
            # (This will be handy later.)  The Window requires a parent object
            # as its first argument, so we just pass 'self'.
            self.plot_window = Window(self, component=top_container)

            layout = QtGui.QVBoxLayout()
            layout.setContentsMargins(0, 0, 0, 0)
            layout.addWidget(self.plot_window.control)
            self.setLayout(layout)

            size = kw.get("size", QtCore.QSize(600,600))
            self.set_size(size.width(), size.height())

            self.show()

        def get_container(self):
            return self.plot_window.component

        def set_container(self, container):
            self.plot_window.component = container

        def iconize(self, iconize):
            """Iconizes the window if *iconize* is True.
            """
            if iconize:
                self.showMinimized()
            else:
                self.showNormal()

        def maximize(self, maximize):
            """ If *maximize* is True, maximizes the window size; restores if False.
            """
            if maximize:
                self.showMaximized()
            else:
                self.showNormal()

        def set_size(self, width, height):
            self.resize(width, height)

        def set_title(self, title):
            self.setWindowTitle(title)

        def raise_window(self):
            """Raises this window to the top of the window hierarchy.
            """
            self.raise_()

        # This is a Python property because this is not a HasTraits subclass.
        container = property(get_container, set_container)

        #------------------------------------------------------------------------
        # Private methods
        #------------------------------------------------------------------------

        def _create_top_container(self):
            plot = ScalyPlot(
                padding=50,
                fill_padding=True,
                bgcolor=self.bgcolor,
                use_backbuffer=True,
            )
            return plot

        def _create_top_img_container(self):
            plot = ScalyPlot(
                padding=50,
                fill_padding=True,
                bgcolor=self.bgcolor,
                use_backbuffer=True,
                default_origin=self.image_default_origin,
            )
            return plot

        def closeEvent(self, event):
            if self.session:
                try:
                    ndx = self.session.windows.index(self)
                    self.session.del_window(ndx)
                except ValueError:
                    pass

else:
    pass


# EOF

########NEW FILE########
__FILENAME__ = preferences
""" Defines the Preferences class for the Chaco shell.
"""

from enable.api import white_color_trait
from traits.api import Enum, HasTraits, Int, Str


class Preferences(HasTraits):
    """ Contains all the preferences that configure the Chaco shell session.
    """

    # Width of the plot window, in pixels.
    window_width = Int(600)

    # Height of the plot window, in pixels.
    window_height = Int(600)

    # The type of plot to display.
    plot_type = Enum("line", "scatter")

    # Default name to use for the plot window.
    default_window_name = Str("Chaco Plot")

    # The default background color.
    bgcolor = white_color_trait

    # The default location of the origin for new image plots
    image_default_origin = Enum("top left", "bottom left",
                                "bottom right", "top right")

    @classmethod
    def from_file(cls, filename):
        """ Creates a new preferences object from a file on disk.
        """
        prefs = cls()
        prefs.load(filename)
        return prefs


    def load(self, filename):
        """ Loads a preferences file; existing settings are overwritten.
        """
        pass


    def save(self, filename):
        """ Saves the preferences to *filename*.
        """
        pass


# EOF

########NEW FILE########
__FILENAME__ = scaly_plot
""" A Plot which uses ScaleSystems for its ticks.
"""

from traits.api import Any

from chaco.api import (DataRange2D, LinearMapper, LogMapper,
    PlotGrid, Plot, PlotAxis)
from chaco.scales_tick_generator import ScalesTickGenerator
from chaco.scales.api import DefaultScale, LogScale, ScaleSystem


def add_default_axes(plot, orientation="normal", vtitle="", htitle=""):
    """
    Creates left and bottom axes for a plot.  Assumes that the index is
    horizontal and value is vertical by default; set orientation to
    something other than "normal" if they are flipped.
    """
    if orientation in ("normal", "h"):
        v_mapper = plot.value_mapper
        h_mapper = plot.index_mapper
    else:
        v_mapper = plot.index_mapper
        h_mapper = plot.value_mapper

    yticks = ScalesTickGenerator()
    left = PlotAxis(
        orientation='left',
        title=vtitle,
        mapper=v_mapper,
        component=plot,
        tick_generator=yticks,
    )

    xticks = ScalesTickGenerator()
    bottom = PlotAxis(
        orientation='bottom',
        title=htitle,
        mapper=h_mapper,
        component=plot,
        tick_generator=xticks,
    )

    plot.underlays.append(left)
    plot.underlays.append(bottom)
    return left, bottom


class ScalyPlot(Plot):
    x_axis = Any()
    y_axis = Any()
    x_ticks = Any()
    y_ticks = Any()
    linear_scale_factory = Any()
    log_scale_factory = Any()

    def _linear_scale_default(self):
        return self._make_scale("linear")

    def _log_scale_default(self):
        return self._make_scale("log")

    def _make_scale(self, scale_type="linear"):
        """ Returns a new linear or log scale """
        if scale_type == "linear":
            if self.linear_scale_factory is not None:
                return self.linear_scale_factory()
            else:
                return ScaleSystem(DefaultScale())
        else:
            if self.log_scale_factory is not None:
                return self.log_scale_factory()
            else:
                return ScaleSystem(LogScale())

    def _init_components(self):
        # Since this is called after the HasTraits constructor, we have to make
        # sure that we don't blow away any components that the caller may have
        # already set.

        if self.range2d is None:
            self.range2d = DataRange2D()

        if self.index_mapper is None:
            if self.index_scale == "linear":
                imap = LinearMapper(range=self.range2d.x_range)
            else:
                imap = LogMapper(range=self.range2d.x_range)
            self.index_mapper = imap

        if self.value_mapper is None:
            if self.value_scale == "linear":
                vmap = LinearMapper(range=self.range2d.y_range)
            else:
                vmap = LogMapper(range=self.range2d.y_range)
            self.value_mapper = vmap

        if self.x_ticks is None:
            self.x_ticks = ScalesTickGenerator(scale=self._make_scale(self.index_scale))
        if self.y_ticks is None:
            self.y_ticks = ScalesTickGenerator(scale=self._make_scale(self.value_scale))

        if self.x_grid is None:
            self.x_grid = PlotGrid(mapper=self.x_mapper, orientation="vertical",
                                  line_color="lightgray", line_style="dot",
                                  component=self, tick_generator=self.x_ticks)
        if self.y_grid is None:
            self.y_grid = PlotGrid(mapper=self.y_mapper, orientation="horizontal",
                                  line_color="lightgray", line_style="dot",
                                  component=self, tick_generator=self.y_ticks)
        if self.x_axis is None:
            self.x_axis = PlotAxis(mapper=self.x_mapper, orientation="bottom",
                                  component=self, tick_generator=self.x_ticks)
        if self.y_axis is None:
            self.y_axis = PlotAxis(mapper=self.y_mapper, orientation="left",
                                  component=self, tick_generator=self.y_ticks)

    def _index_scale_changed(self, old, new):
        Plot._index_scale_changed(self, old, new)
        # Now adjust the ScaleSystems.
        self.x_ticks.scale = self._make_scale(self.index_scale)

    def _value_scale_changed(self, old, new):
        Plot._value_scale_changed(self, old, new)
        # Now adjust the ScaleSystems.
        self.y_ticks.scale = self._make_scale(self.value_scale)

########NEW FILE########
__FILENAME__ = session
""" Defines the PlotSession class.
"""

# Enthoght library imports
from chaco.array_plot_data import ArrayPlotData
from chaco.default_colormaps import *
from traits.api import Any, Bool, Dict, HasTraits, Instance, Int, \
                                 List, Property, Trait, Str


# Local, relative imports
from plot_window import PlotWindow
from preferences import Preferences


class PlotSession(HasTraits):
    """
    Encapsulates all of the session-level globals, including preferences,
    windows, etc.
    """

    # The preferences object in effect for this session.
    prefs = Instance(Preferences, args=())

    # The list of currently active windows.
    windows = List(PlotWindow)

    # A dict mapping names to windows.
    window_map = Dict(Str, PlotWindow)

    # The current hold state.
    hold = Bool(False)

    # The session holds a single ArrayPlotData instance to which it adds unnamed
    # arrays that are provided to various plotting commands.
    data = Instance(ArrayPlotData, args=())


    #------------------------------------------------------------------------
    # "active" pointers
    #------------------------------------------------------------------------

    # The index of the active window.
    active_window_index = Trait(None, None, Int)

    # The active window.
    active_window = Property

    # The active colormap.
    colormap = Trait(jet, Any)


    def new_window(self, name=None, title=None, is_image=False):
        """Creates a new window and returns the index into the **windows** list
        for the new window.
        """
        new_win = PlotWindow(
            is_image=is_image,
            size=(self.prefs.window_width, self.prefs.window_height),
            bgcolor=self.prefs.bgcolor,
            image_default_origin=self.prefs.image_default_origin,
        )
        new_win.data = self.data
        new_win.get_container().data = self.data
        new_win.session = self

        if title is not None:
            new_win.set_title(title)
        elif name != None:
            new_win.set_title(name)
        else:
            new_win.set_title(self.prefs.default_window_name)

        self.windows.append(new_win)
        if name != None:
            self.window_map[name] = new_win
        return len(self.windows)-1

    def get_window(self, ident):
        """ Retrieves a window either by index or by name """
        if isinstance(ident, basestring):
            return self.window_map.get(ident, None)
        elif type(ident) == int and ident < len(self.windows):
            return self.windows[ident]
        else:
            return None

    def del_window(self, ident):
        """ Deletes the specified window.

        Parameters
        ----------
        ident : string or number
            The name of the window in **window_map**, or the index of the
            window in **windows**.
        """
        if isinstance(ident, basestring):
            if ident in self.window_map:
                win = self.window_map[ident]
                del self.window_map[ident]
            else:
                return
        elif type(ident) == int:
            if ident >= len(self.windows):
                print "No such window %d." % ident

            win = self.windows.pop(ident)
            if len(self.windows) == 0:
                self.active_window = None
            elif self.active_window_index >= ident:
                self.active_window_index -= 1

            if win in self.window_map.values():
                # we have to go through the whole dict and remove all keys
                # that correspond to the deleted window
                for k, v in self.window_map.items():
                    if v == win:
                        del self.window_map[k]
        else:
            return

    def _get_active_window(self):
        if self.active_window_index is not None:
            return self.windows[self.active_window_index]
        else:
            return None

    def _set_active_window(self, win):
        if win in self.windows:
            self.active_window_index = self.windows.index(win)
        elif win is None:
            self.active_window_index = None
        else:
            raise RuntimeError, "That window is not part of this session."

    def _colormap_changed(self):
        plots = []
        for w in self.windows:
            container = w.get_container()
            for vals in container.plots.values():
                plots.extend(vals)
        for p in plots:
            if hasattr(p, "color_mapper"):
                p.color_mapper = self.colormap(p.color_mapper.range)
                p.invalidate_draw()
                p.request_redraw()
            elif hasattr(p, "colors"):
                if isinstance(p.colors, basestring) or \
                   isinstance(p.colors, AbstractColormap):
                    p.colors = color_map_dict[self.colormap]


# EOF

########NEW FILE########
__FILENAME__ = make_data_sources_test_case

import unittest

import numpy as np
from numpy.testing.utils import assert_almost_equal
from chaco.shell.plot_maker import make_data_sources

class MakeDataSourcesTestCase(unittest.TestCase):

    def test_1D_single(self):
        session = None
        ary = np.array([3.0, 2.1, 1.3, 1.8, 5.7])
        sources = make_data_sources(session, "none", ary)
        assert_almost_equal(sources[0][0].get_data(), np.arange(len(ary)))
        assert_almost_equal(sources[0][1].get_data(), ary)
        return

    def test_1d_multiple(self):
        session = None
        index = np.arange(-np.pi, np.pi, np.pi/30.0)
        s = np.sin(index)
        c = np.cos(index)
        t = np.tan(index)
        sources = make_data_sources(session, "ascending", index, s, c, t)
        assert_almost_equal(sources[0][0].get_data(), index)
        self.assert_(sources[0][0] == sources[1][0])
        self.assert_(sources[0][0] == sources[2][0])
        assert_almost_equal(sources[0][1].get_data(), s)
        assert_almost_equal(sources[1][1].get_data(), c)
        assert_almost_equal(sources[2][1].get_data(), t)
        return


if __name__ == "__main__":
    unittest.main()

# EOF

########NEW FILE########
__FILENAME__ = test_tutorial_example
""" Test script-oriented example from interactive plotting tutorial

source: docs/source/user_manual/chaco_tutorial.rst

"""
import unittest
from numpy import linspace, pi, sin
from chaco.shell import plot, title, ytitle


class InteractiveTestCase(unittest.TestCase):

    def test_script(self):
        x = linspace(-2*pi, 2*pi, 100)
        y = sin(x)
        plot(x, y, "r-")
        title("First plot")
        ytitle("sin(x)")

if __name__ == "__main__":
    unittest.main()

########NEW FILE########
__FILENAME__ = simple_plot_frame
""" Defines the (deprecated) SimplePlotFrame class.
"""

#################################################################################
#
# NOTE: PlotFrames are deprecated.  There is no need to use them any more.
# This class will be removed sometime in the near future.
#
#################################################################################

from __future__ import with_statement

# Enthought library imports
from traits.api import Bool

# Local, relative imports
from base_plot_frame import BasePlotFrame
from plot_containers import OverlayPlotContainer

class SimplePlotFrame(BasePlotFrame):
    """
    A plot frame with just a single, center container that takes up the entire
    frame.

    NOTE: PlotFrames are deprecated.  There is no need to use them any more.
    This class will be removed sometime in the future.
    """

    # This frame has only one position for plot components. Overrides
    # PlotFrame.
    slot_names = ("center")

    # Default width and height. Class attribute.
    default_bounds = (500, 500)

    # This frame does not resize to fit components. Overrides PlotFrame.
    fit_components = ""

    # This frame maximizes itself within the window, if it is a top-level
    # component. Overrides Enable Container.
    fit_window = True

    #------------------------------------------------------------------------
    # Private traits
    #------------------------------------------------------------------------

    # Does the component need to do a layout call?
    _layout_needed = Bool(True)


    def __init__(self, **kwtraits):
        # Delay setting the bounds until after base class initialization
        if kwtraits.has_key("bounds"):
            bounds = kwtraits.pop("bounds")
        else:
            bounds = list(self.default_bounds)
        BasePlotFrame.__init__(self, **kwtraits)
        self.set_slot("center", OverlayPlotContainer(resizable="hv"))
        self.bounds = bounds
        return

    #------------------------------------------------------------------------
    # Protected methods
    #------------------------------------------------------------------------

    def _draw_component(self, gc, view_bounds=None, mode="normal"):
        """ Draws the component.

        This method is preserved for backwards compatibility with _old_draw().
        Overrides PlotComponent.
        """
        with gc:
            # Translate to our .position, because even though we are supposed
            # to be a top-level Chaco component, we might still be contained
            # within other Enable components.
            gc.translate_ctm(*self.position)
            with gc:
                self.center.draw(gc, view_bounds, mode)
        return

    def get_preferred_size(self):
        """ Returns the size (width,height) that is preferred for this component.

        Overrides PlotComponent.
        """
        size = [0,0]
        component_pref_size = None
        if "h" not in self.resizable:
            if "h" in self.fit_components:
                component_pref_size = self.center.get_preferred_size()
                size[0] = component_pref_size[0]
            else:
                size[0] = self.default_bounds[0]
        if "v" not in self.resizable:
            if "v" in self.fit_components:
                if not component_pref_size:
                    component_pref_size = self.center.get_preferred_size()
                size[1] = component_pref_size[1]
            else:
                size[1] = self.default_bounds[1]
        return size

    def _do_layout(self):
        """
        Performs a layout and sets the size and positions on this frame's
        containers, given its width and height.
        """
        component = self.center

        preferred_size = None
        if "h" in component.resizable:
            component.outer_width = self.width
        elif "h" in self.fit_components:
            preferred_size = component.get_preferred_size()
            component.outer_width = preferred_size[0]
            self.width = preferred_size[0]
        else:
            # We are not autosizing to our component, and it's not going to
            # auto-size to our bounds, so do nothing.
            pass

        if "v" in component.resizable:
            component.outer_height = self.height
        elif "v" in self.fit_components:
            if preferred_size is None:
                preferred_size = component.get_preferred_size()
            component.outer_height = preferred_size[1]
            self.height = preferred_size[1]
        else:
            # We are not autosizing to our component, and it's not going to
            # auto-size to our bounds, so do nothing.
            pass

        component.outer_position = [0,0]
        component.do_layout()
        return

    ### Persistence ###########################################################
    #_pickles = ()

    def __getstate__(self):
        state = super(SimplePlotFrame,self).__getstate__()
        for key in ['_layout_needed']:
            if state.has_key(key):
                del state[key]

        return state


# EOF

########NEW FILE########
__FILENAME__ = speedups

# This contains python implementations of all the speedups
from _speedups_fallback import *


# cython implementation of speedups. Import these if we can.
try:
    from _cython_speedups import *
except ImportError:
    pass




#try:
#    from numpy import asarray
#    import _speedups

#    def scatterplot_gather_points(index, index_low, index_high,
#                                  value, value_low, value_high,
#                                  index_mask=None, index_sel=None, index_sel_mask=None,
#                                  value_mask=None, value_sel=None, value_sel_mask=None):
#        if index_low is None:
#            index_low = -inf
#        if index_high is None:
#            index_high = inf
#        if value_low is None:
#            value_low = -inf
#        if value_high is None:
#            value_high = inf
#        if index_mask is not None:
#            index_mask = asarray(index_mask, dtype=bool)
#        if value_mask is not None:
#            value_mask = asarray(value_mask, dtype=bool)
#        if index_sel_mask is not None:
#            index_sel_mask = asarray(index_sel_mask, dtype=bool)
#        if value_sel_mask is not None:
#            value_sel_mask = asarray(value_sel_mask, dtype=bool)

#        return _speedups.scatterplot_gather_points(index, index_low, index_high,
#                      value, value_low, value_high,
#                      index_mask=index_mask, index_sel=index_sel,
#                      index_sel_mask=index_sel_mask,
#                      value_mask=value_mask, value_sel=value_sel,
#                      value_sel_mask=value_sel_mask)


#except ImportError:
#    from _speedups_fallback import *



########NEW FILE########
__FILENAME__ = subdivision_cells
""" Defines cell-related classes and functions.
"""
from numpy import take, array, concatenate, nonzero

from traits.api import HasStrictTraits, Instance, Delegate, Array, List, \
                             Tuple, Property, Trait, Any, Disallow

from datamapper import AbstractDataMapper, right_shift, left_shift, sort_points


def find_runs(int_array, order='ascending'):
    """
    find_runs(int_array, order=<'ascending'|'flat'|'descending'>) -> list_of_int_arrays

    Given an integer array sorted in ascending, descending, or flat order, this
    function returns a list of continuous runs of integers inside the list.
    For example::

        find_runs([1,2,3,6,7,8,9,10,11,15])

    returns [ [1,2,3], [6,7,8,9,10,11], [15] ]
    and::

        find_runs([0,0,0,1,1,1,1,0,0,0,0])

    returns [ [0,0,0], [1,1,1,1], [0,0,0,0] ]
    """
    ranges = arg_find_runs(int_array, order)
    if ranges:
        return [int_array[i:j] for (i,j) in ranges]
    else:
        return []

def arg_find_runs(int_array, order='ascending'):
    """
    This function is like find_runs(), but it returns a list of tuples
    indicating the start and end indices of runs in the input *int_array*.
    """
    if len(int_array) == 0:
        return []
    assert len(int_array.shape)==1, "find_runs() requires a 1D integer array."
    if order == 'ascending':
        increment = 1
    elif order == 'descending':
        increment = -1
    else:
        increment = 0
    rshifted = right_shift(int_array, int_array[0]-increment)
    start_indices = concatenate([[0], nonzero(int_array - (rshifted+increment))[0]])
    end_indices = left_shift(start_indices, len(int_array))
    return zip(start_indices, end_indices)


class AbstractCell(HasStrictTraits):
    """ Abstract class for grid cells in a uniform subdivision.

    Individual subclasses store points in different, possibly optimized
    fashion, and performance may be drastically different between different
    cell subclasses for a given set of data.
    """
    # The parent of this cell.
    parent = Instance(AbstractDataMapper)

    # The sort traits characterizes the internal points list.
    _sort_order = Delegate('parent')

    # The point array for this cell. This attribute delegates to parent._data,
    # which references the actual point array. For the sake of simplicity,
    # cells assume that _data is sorted in fashion indicated by **_sort_order**.
    # If this doesn't hold, then each cell needs to have its own duplicate
    # copy of the sorted data.
    data = Delegate('parent', '_data')

    # A list of indices into **data** that reflect the points inside this cell.
    indices = Property

    # Shadow trait for **indices**.
    _indices = Any

    def add_indices(self, indices):
        """ Adds a list of integer indices to the existing list of indices.
        """
        raise NotImplementedError

    def get_points(self):
        """ Returns a list of points that was previously set.

        This operation might be large and expensive; in general, use
        _get_indices() instead.
        """
        raise NotImplementedError

    def reverse_indices(self):
        """ Tells the cell to manipulate its indices so that they index to the
        same values in a reversed data array.

        Generally this method handles the situation when the parent's _data
        array has been flipped due to a sort order change.

        The length of _data must not have changed; otherwise there is no way to
        know the proper way to manipulate indices.
        """
        raise NotImplementedError

    def _set_indices(self, indices):
        raise NotImplementedError

    def _get_indices(self):
        """  Returns the list of indices into _data that reflect the points
        inside this cell.
        """
        raise NotImplementedError


class Cell(AbstractCell):
    """
    A basic cell that stores its point indices as an array of integers.
    """
    # A list of indices into **data** that reflect the points inside this cell
    # (overrides AbstractCell).
    indices = Property(Array)

    # A 1-D array of indices into _data.
    _indices = Array

    def __init__(self, **kw):
        self._indices = array([])
        super(AbstractCell, self).__init__(**kw)

    def add_indices(self, indices):
        """ Adds a list of integer indices to the existing list of indices.

        Implements AbstractCell.
        """
        self._indices = concatenate([self._indices, indices])
        return

    def get_points(self):
        """ Returns a list of points that was previously set.

        Implements AbstractCell.
        """
        return take(self.data, self._indices)

    def reverse_indices(self):
        """ Tells the cell to manipulate its indices so that they index to the
        same values in a reversed data array.

        Implements AbstractCell.
        """
        length = len(self.data)
        self._indices = [length-i-1 for i in self._indices]
        return

    def _set_indices(self, indices):
        self._indices = indices
        return

    def _get_indices(self):
        return self._indices



class RangedCell(AbstractCell):
    """ A cell optimized for storing lists of continuous points.

    Rather than storing each individual point index as an element in an array,
    RangedCell stores a list of index ranges; each range is a (start,end) tuple).
    """

    # A list of indices into **data** that reflect the points inside this cell
    # (overrides AbstractCell).
    indices = Property

    # Don't use the _indices shadow trait; rather, the getters and setters
    # for 'index' procedurally generate indices from **ranges**.
    _indices = Disallow

    # Ranges are an additional interface on RangedCells.
    ranges = Property(List(Tuple))

    # Shadow trait for ranges.
    _ranges = List(Tuple)

    #---------------------------------------------------------------------
    # AbstractCell methods
    #---------------------------------------------------------------------

    def add_indices(self, indices):
        """ Adds a list of integer indices to the existing list of indices.

        Implements AbstractCell.
        """
        self.add_ranges(find_runs(indices))
        return

    def get_points(self):
        """ Returns a list of points that was previously set.

        Implements AbstractCell.
        """
        return take(self.data, self.indices)

    def reverse_indices(self):
        """ Tells the cell to manipulate its indices so that they index to the
        same values in a reversed data array.

        Implements AbstractCell.
        """
        length = len(self.data)
        self._ranges = [(length-end-1, length-start-1) for (start,end) in self._ranges]
        return

    def _set_indices(self, indices):
        self._ranges = find_runs(indices)
        return

    def _get_indices(self):
        list_of_indices = [range(i,j) for (i,j) in self._ranges]
        return sum(list_of_indices, [])


    #---------------------------------------------------------------------
    # additional RangedCell methods
    #---------------------------------------------------------------------

    def get_ranges(self):
        """ Returns a list of tuples representing the (start,end) indices of
        continuous ranges of points in self._data.
        """
        return self._ranges()

    def add_ranges(self, ranges):
        """ Adds a list of ranges ((start,end) tuples) to the current list.

        This method doesn't check for duplicate or overlapping ranges.
        """
        if self._ranges:
            self._ranges.extend(ranges)
        else:
            self._ranges = ranges
        return
#EOF

########NEW FILE########
__FILENAME__ = subdivision_mapper
""" Defines the SubdivisionDataMapper and SubdivisionLineDataMapper classes.
"""
# Major library imports
import math
from numpy import array, arange, concatenate, searchsorted, nonzero, transpose, \
                  argsort, zeros, sort, vstack
import numpy

# Enthought library imports
from traits.api import List, Array, Tuple, Int, Float

# Local, relative imports
from datamapper import AbstractDataMapper, right_shift, left_shift, \
                       sort_points, ArraySortTrait, \
                       array_zip
from subdivision_cells import AbstractCell, Cell, RangedCell, find_runs, \
                              arg_find_runs


class SubdivisionDataMapper(AbstractDataMapper):
    """
    A data mapper that uses a uniform grid of rectangular cells. It doesn't make
    any assumptions about the continuity of the input data set, and explicitly
    stores each point in the data set in its cell.

    If the incoming data is ordered in some fashion such that most cells end
    up with large ranges of data, then it's better to use the
    SubdivisionLineDataMapper subclass.
    """
    celltype = Cell
    _last_region = List(Tuple)
    _cellgrid = Array   # a Numeric array of Cell objects
    _points_per_cell = Int(100)   # number of datapoints/cell to shoot for
    _cell_lefts = Array    # locations of left edge for all cells
    _cell_bottoms = Array  # locations of bottom edge for all cells
    _cell_extents = Tuple(Float, Float)         # the width and height of a cell

    #-------------------------------------------------------------------
    # Public AbstractDataMapper methods
    #-------------------------------------------------------------------

    def get_points_near(self, pointlist, radius=0.0):
        if radius != 0:
            # tmp is a list of list of arrays
            d = 2*radius
            cell_points = [ self.get_points_in_rect((px-radius,py-radius,d,d))
                                for (px,py) in pointlist ]
        else:
            indices = self._get_indices_for_points(pointlist)
            cells = [self._cellgrid[i,j] for (i,j) in indices]
            self._last_region = self._cells_to_rects(indices)
            # unique-ify the list of cells
            cell_points = [c.get_points() for c in set(cells)]
        return vstack(cell_points)


    def get_points_in_rect(self, rect):
        x_span = (rect[0], rect[0]+rect[2])
        y_span = (rect[1], rect[1]+rect[3])
        min_i, max_i = searchsorted(self._cell_lefts, x_span) - 1
        min_j, max_j = searchsorted(self._cell_bottoms, y_span) - 1
        cellpts = [ self._cellgrid[i,j].get_points()
                        for i in range(min_i, max_i+1) \
                            for j in range(min_j, max_j+1) ]
        self._last_region = ( self._cell_lefts[min_i], self._cell_bottoms[min_j], \
                              (max_i - min_i + 1) * self._cell_extents[0], \
                              (max_j - min_j + 1) * self._cell_extents[1] )
        return vstack(cellpts)


    def get_last_region(self):
        return self._last_region

    #-------------------------------------------------------------------
    # AbstractDataMapper's abstract private methods
    #-------------------------------------------------------------------

    def _update_datamap(self):
        self._last_region = []
        # Create a new grid of the appropriate size, initialize it with new
        # Cell instance (of type self.celltype), and perform point insertion
        # on the new data.
        if self._data is None:
            self._cellgrid = array([], dtype=object)
            self._cell_lefts = array([])
            self._cell_bottoms = array([])
        else:
            num_x_cells, num_y_cells = self._calc_grid_dimensions()
            self._cellgrid = zeros((num_x_cells, num_y_cells), dtype=object)
            for i in range(num_x_cells):
                for j in range(num_y_cells):
                    self._cellgrid[i,j] = self.celltype(parent=self)
            ll, ur = self._extents
            cell_width = ur[0]/num_x_cells
            cell_height = ur[1]/num_y_cells

            # calculate the left and bottom edges of all the cells and store
            # them in two arrays
            self._cell_lefts = arange(ll[0], ll[0]+ur[0]-cell_width/2, step=cell_width)
            self._cell_bottoms = arange(ll[1], ll[1]+ur[1]-cell_height/2, step=cell_height)

            self._cell_extents = (cell_width, cell_height)

            # insert the data points
            self._basic_insertion(self.celltype)
        return

    def _clear(self):
        self._last_region = []
        self._cellgrid = []
        self._cell_lefts = []
        self._cell_bottoms = []
        self._cell_extents = (0,0)
        return

    def _sort_order_changed(self, old, new):
        # since trait event notification only happens if the value has changed,
        # and there are only two types of sorting, it's safe to just reverse our
        # internal _data object
        self._data = self._data[::-1]
        for cell in self._cellgrid:
            # since cellgrid is a Numeric array, iterating over it produces
            # a length-1 array
            cell[0].reverse_indices()
        return


    #-------------------------------------------------------------------
    # helper private methods
    #-------------------------------------------------------------------

    def _calc_grid_dimensions(self):
        numpoints = self._data.shape[0]
        numcells = numpoints / self._points_per_cell
        ll, ur = self._extents
        aspect_ratio = (ur[0]-ll[0]) / (ur[1]-ll[1])
        num_y_cells = int(math.sqrt(numcells / aspect_ratio))
        num_x_cells = int(aspect_ratio * num_y_cells)
        if num_y_cells == 0:
            num_y_cells += 1
        if num_y_cells*num_x_cells*self._points_per_cell < numpoints:
            num_x_cells += 1
        return (num_x_cells, num_y_cells)

    def _basic_insertion(self, celltype):
        # generate a list of which cell each point in self._data belongs in
        cell_indices = self._get_indices_for_points(self._data)

        # We now look for ranges of points belonging to the same cell.
        # 1. shift lengthwise and difference; runs of cells with the same
        # (i,j) indices will be zero, and nonzero value for i or j will
        # indicate a transition to a new cell.  (Just like find_runs().)
        differences = cell_indices[1:] - cell_indices[:-1]

        # Since nonzero() only works for 1D arrays, we merge the X and Y columns
        # together to detect any point where either X or Y are nonzero.  We have
        # to add 1 because we shifted cell_indices before differencing (above).
        diff_indices = nonzero(differences[:,0] + differences[:,1])[0] + 1

        start_indices = concatenate([[0], diff_indices])
        end_indices = concatenate([diff_indices, [len(self._data)]])

        for start,end in zip(start_indices, end_indices):
            gridx, gridy = cell_indices[start]  # can use 'end' here just as well
            if celltype == RangedCell:
                self._cellgrid[gridx,gridy].add_ranges([(start,end)])
            else:
                self._cellgrid[gridx,gridy].add_indices(range(start,end))
        return

    def _get_indices_for_points(self, pointlist):
        """
        Given an input Nx2 array of points, returns a list Nx2 corresponding
        to the column and row indices into the cell grid.
        """
        x_array = searchsorted(self._cell_lefts, pointlist[:,0]) - 1
        y_array = searchsorted(self._cell_bottoms, pointlist[:,1]) - 1
        return array_zip(x_array, y_array)


    def _cells_to_rects(self, cells):
        """
        Converts the extents of a list of cell grid coordinates (i,j) into
        a list of rect tuples (x,y,w,h).  The set should be disjoint, but may
        or may not be minimal.
        """
        # Since this function is generally used to generate clipping regions
        # or other screen-related graphics, we should try to return large
        # rectangular blocks if possible.
        # For now, we just look for horizontal runs and return those.
        cells = array(cells)
        y_sorted = sort_points(cells, index=1)  # sort acoording to row
        rownums = sort(array(tuple(set(cells[:,1]))))

        row_start_indices = searchsorted(y_sorted[:,1], rownums)
        row_end_indices = left_shift(row_start_indices, len(cells))

        rects = []
        for rownum, start, end in zip(rownums, row_start_indices, row_end_indices):
            # y_sorted is sorted by the J (row) coordinate, so after we
            # extract the column indices, we need to sort them before
            # passing them to find_runs().
            grid_column_indices = sort(y_sorted[start:end][:,0])
            #pdb.set_trace()
            #print grid_column_indices.shape
            for span in find_runs(grid_column_indices):
                x = self._cell_lefts[span[0]]
                y = self._cell_bottoms[rownum]
                w = (span[-1] - span[0] + 1) * self._cell_extents[0]
                h = self._cell_extents[1]
                rects.append((x,y,w,h))
        return rects

    #~ def _array_insertion(self, celltype):
        #~ # use searchsorted() to determine where the borders split the
        #~ # data array
        #~ x_bins = searchsorted(data[:,0], self._cell_lefts[1:])
        #~ x_bins_rshift = right_shift(x_bins, 0)
        #~ grid_x = 0
        #~ for x_index_range in zip(x_bins_rshift, x_bins):
            #~ # now do the same thing in y; the tricky part is remembering
            #~ # to use axis=1 since everything happens on the y-coordinate
            #~ columnpoints = data[x_index_range[0] : x_index_range[1]]
            #~ columnpoints = take(columnpoints, argsort(columnpoints[:,1]))

            #~ # use searchsorted() to determine where the cell bottoms split the
            #~ # set of column points.
            #~ y_bins = searchsorted(columnpoints[:,1], self._cell_bottoms)
            #~ y_bins_rshift = right_shift(y_bins, 0)
            #~ grid_y = 0
            #~ for startndx, endndx in zip(y_bins_rshift, y_bins):
                #~ if startndx != endndx:
                    #~ cell = self._cellgrid[grid_x, grid_y]
                    #~ cellpts = columnpoints[startndx:endndx]
                    #~ if cell.sort_order == 'none':
                        #~ cell.points = cellpts
                    #~ elif cell.sort_order == 'ascending':
                        #~ cell.points = find_runs(sort_points(cellpts))
                    #~ elif cell.sort_order == 'descending':
                        #~ cell.points = find_runs(sort_points(cellpts)[::-1], 'descending')
                    #~ else:
                        #~ raise RuntimeError, "Invalid sort_order: " + cell.sort_order
        #~ return

class SubdivisionLineDataMapper(SubdivisionDataMapper):
    """ A subdivision data mapper that uses ranged cells.
    """
    celltype = RangedCell


#EOF

########NEW FILE########
__FILENAME__ = svg_graphics_context
""" Defines the PlotGraphicsContext class.
"""
from __future__ import with_statement

from kiva.svg import GraphicsContext

class SVGGraphicsContext(GraphicsContext):
    """ A Kiva graphics context, which facilitates rendering plots and plot
    components into an offscreen or memory buffer.

    Its only real difference from a Kiva graphics context is that this
    class correctly offsets the coordinate frame by (0.5, 0.5) and increases
    the actual size of the image by 1 pixel in each dimension. When rendering
    into on-screen windows through Enable, this transformation step is handled
    by Enable.
    """
    # FIXME: Right now this does not resize correctly.  (But you shouldn't
    # resize your GC, anyway!)

    def __init__(self, size_or_ary, dpi=72.0, *args, **kw):
        scale = dpi / 72.0
        if type(size_or_ary) in (list, tuple) and len(size_or_ary) == 2:
            size_or_ary = (size_or_ary[0]*scale + 1, size_or_ary[1]*scale + 1)

        super(SVGGraphicsContext, self).__init__(size_or_ary, *args, **kw)
        self.translate_ctm(0.5, 0.5)
        self.scale_ctm(scale, scale)
        return

    def render_component(self, component, container_coords=False):
        """ Renders the given component.

        Parameters
        ----------
        component : Component
            The component to be rendered.
        container_coords : Boolean
            Whether to use coordinates of the component's container

        Description
        -----------
        If *container_coords* is False, then the (0,0) coordinate of this
        graphics context corresponds to the lower-left corner of the
        component's **outer_bounds**. If *container_coords* is True, then the
        method draws the component as it appears inside its container, i.e., it
        treats (0,0) of the graphics context as the lower-left corner of the
        container's outer bounds.
        """

        x, y = component.outer_position
        if not container_coords:
            x = -x
            y = -y

        # Compute the new x and y scale from the translation
        width, height = self.width(), self.height()
        width_scale = (width - x) / float(width)
        height_scale = (height - y) / float(height)

        with self:
            self.translate_ctm(x, y)
            self.scale_ctm(width_scale, height_scale)
            component.draw(self, view_bounds=(0, 0, width, height))
        return

    def clip_to_rect(self, x, y, width, height):
        """ Offsets the coordinate frame by (0.5, 0.5) and increases the actual
        size of the image by 1 pixel in each dimension.

        Overrides Kiva GraphicsContext.
        """
        GraphicsContext.clip_to_rect(self, x-0.5, y-0.5, width+1, height+1)

# EOF


########NEW FILE########
__FILENAME__ = arraydatasource_test_case
"""
Test of basic dataseries behavior.
"""

import unittest

from numpy import arange, array, allclose, empty, isnan, nan
from chaco.api import ArrayDataSource, PointDataSource


class ArrayDataTestCase(unittest.TestCase):
    def test_basic_set_get(self):
        myarray = arange(10)
        sd = ArrayDataSource(myarray)
        self.assertTrue(allclose(myarray, sd._data))
        self.assert_(sd.value_dimension == "scalar")
        return

    def test_bounds(self):
        # ascending
        myarray = arange(10)
        sd = ArrayDataSource(myarray, sort_order="ascending")
        bounds = sd.get_bounds()
        self.assert_(bounds == (0,9))

        # descending
        myarray = arange(10)[::-1]
        sd = ArrayDataSource(myarray, sort_order="descending")
        bounds = sd.get_bounds()
        self.assert_(bounds == (0,9))

        # no order
        myarray = array([12,3,0,9,2,18,3])
        sd = ArrayDataSource(myarray, sort_order="none")
        bounds = sd.get_bounds()
        self.assert_(bounds == (0,18))
        return

    def test_data_size(self):
        # We know that ScalarData always returns the exact length of its data
        myarray = arange(913)
        sd = ArrayDataSource(myarray)
        self.assert_(len(myarray) == sd.get_size())
        return

    def test_bounds_all_nans(self):
        myarray = empty(10)
        myarray[:] = nan
        sd = ArrayDataSource(myarray)
        bounds = sd.get_bounds()
        self.assertTrue(isnan(bounds[0]))
        self.assertTrue(isnan(bounds[1]))


class PointDataTestCase(unittest.TestCase):
    # Since PointData is mostly the same as ScalarData, the key things to
    # test are functionality that use _compute_bounds() and reverse_map().
    def create_array(self):
        return array(zip(range(10), range(0, 100, 10)))

    def test_basic_set_get(self):
        myarray = self.create_array()
        pd = PointDataSource(myarray)
        self.assertTrue(allclose(myarray,pd._data))
        self.assert_(pd.value_dimension == "point")
        return

    def test_bounds(self):
        myarray = self.create_array()
        pd = PointDataSource(myarray)
        self.assertEqual(pd.get_bounds(),((0,0), (9,90)))
        return

if __name__ == '__main__':
    import nose
    nose.run()

########NEW FILE########
__FILENAME__ = array_plot_data_test_case
import contextlib
from traits.testing.unittest_tools import unittest

import numpy

from chaco.api import ArrayPlotData
from traits.api import HasTraits, Instance, List, on_trait_change


class ArrayPlotDataEventsCollector(HasTraits):
    plot_data = Instance(ArrayPlotData)

    data_changed_events = List

    @on_trait_change('plot_data:data_changed')
    def _got_data_changed_event(self, event):
        self.data_changed_events.append(event)


class ArrayPlotDataTestCase(unittest.TestCase):
    @contextlib.contextmanager
    def monitor_events(self, plot_data):
        """
        Context manager to collect data_changed events.

        """
        collector = ArrayPlotDataEventsCollector(plot_data=plot_data)
        yield collector.data_changed_events

    def test_data_changed_events(self):
        # Test data.
        grumpy = numpy.ones((3, 4))
        grumpy_too = numpy.zeros(16)

        plot_data = ArrayPlotData()

        with self.monitor_events(plot_data) as events:
            plot_data.set_data('Grumpy', grumpy)
            self.assertEqual(events, [{'added': ['Grumpy']}])

        # While we're here, check that get_data works as advertised.
        grumpy_out = plot_data.get_data('Grumpy')
        self.assertIs(grumpy_out, grumpy)

        with self.monitor_events(plot_data) as events:
            plot_data.set_data('Grumpy', grumpy_too)
            self.assertEqual(events, [{'changed': ['Grumpy']}])

        with self.monitor_events(plot_data) as events:
            plot_data.del_data('Grumpy')
            self.assertEqual(events, [{'removed': ['Grumpy']}])


if __name__ == '__main__':
    import nose
    nose.run()

########NEW FILE########
__FILENAME__ = base_utils_test_case
"""
Unit tests for utility functions in chaco.base
"""

import unittest
from math import sqrt
from numpy import arange, array
from numpy.testing import assert_equal, assert_almost_equal

from chaco.api import bin_search, find_runs, reverse_map_1d, point_line_distance

class BinSearchTestCase(unittest.TestCase):
    def test_ascending_data(self):
        ary = arange(10.0)
        # inside bounds
        self.assert_(bin_search(ary, 0.0, 1) == 0)
        self.assert_(bin_search(ary, 5.0, 1) == 5)
        self.assert_(bin_search(ary, 9.0, 1) == 9)
        # out of bounds
        self.assert_(bin_search(ary, 10.0, 1) == -1)
        self.assert_(bin_search(ary, -1.0, 1) == -1)
        self.assert_(bin_search(ary, 9.00001, 1) == -1)
        self.assert_(bin_search(ary, -0.00001, 1) == -1)
        # rounding
        self.assert_(bin_search(ary, 5.1, 1) == 5)
        self.assert_(bin_search(ary, 4.9, 1) == 4)
        return

    def test_descending_data(self):
        ary = arange(10.0, 0.0, -1.0)
        # inside bounds
        self.assert_(bin_search(ary, 10.0, -1) == 0)
        self.assert_(bin_search(ary, 5.0, -1) == 5)
        self.assert_(bin_search(ary, 1.0, -1) == 9)
        # out of bounds
        self.assert_(bin_search(ary, 10.1, -1) == -1)
        self.assert_(bin_search(ary, 0.9, -1) == -1)
        # rounding
        self.assert_(bin_search(ary, 5.1, -1) == 4)
        self.assert_(bin_search(ary, 4.9, -1) == 5)
        return

class ReverseMap1DTestCase(unittest.TestCase):

    def test_ascending(self):
        ary = arange(10.0)
        rmap = lambda x: reverse_map_1d(ary, x, 'ascending')

        # inside bounds
        self.assert_(rmap(0.0) == 0)
        self.assert_(rmap(5.0) == 5)
        self.assert_(rmap(9.0) == 9)

        # out of bounds
        self.assertRaises(IndexError, rmap, 10.0)
        self.assertRaises(IndexError, rmap, -1.0)

        # rounding
        self.assert_(rmap(3.4) == 3)
        self.assert_(rmap(3.5) == 3)
        self.assert_(rmap(3.6) == 4)
        return

    def test_ascending_floor(self):
        ary = arange(10.0)
        rmap = lambda x: reverse_map_1d(ary, x, 'ascending', floor_only=True)

        # test rounding
        self.assert_(rmap(3.4) == 3)
        self.assert_(rmap(3.5) == 3)
        self.assert_(rmap(3.6) == 3)
        return

    def test_descending(self):
        ary = arange(10.0, 0.0, -1.0)
        rmap = lambda x: reverse_map_1d(ary, x, 'descending')

        # inside bounds
        self.assert_(rmap(10.0) == 0)
        self.assert_(rmap(5.0) == 5)
        self.assert_(rmap(1.0) == 9)

        # out of bounds
        self.assertRaises(IndexError, rmap, 0.0)
        self.assertRaises(IndexError, rmap, 11.0)

        # rounding
        self.assert_(rmap(8.6) == 1)
        self.assert_(rmap(8.5) == 1)
        self.assert_(rmap(8.4) == 2)
        return

    def test_descending_floor(self):
        ary = arange(10.0, 0.0, -1.0)
        rmap = lambda x: reverse_map_1d(ary, x, 'descending', floor_only=True)

        # test rounding
        self.assert_(rmap(8.6) == 1)
        self.assert_(rmap(8.5) == 1)
        self.assert_(rmap(8.4) == 1)
        return


class FindRunsTestCase(unittest.TestCase):
    def test_find_runs_middle(self):
        x = array([0,8,7,8,9,2,3,4,10])
        assert_equal(find_runs(x) , [[0], [8], [7,8,9], [2,3,4], [10]])

    def test_find_runs_start(self):
        x = array([3,4,5,12,9,17])
        assert_equal(find_runs(x) , [[3,4,5],[12],[9],[17]])

    def test_find_runs_end(self):
        x = array([18,23,24,25])
        assert_equal(find_runs(x) , [[18],[23,24,25]])

    def test_find_runs_offset(self):
        # because of the nature of the find_runs algorithm, there may be
        # fencepost errors with runs that start at x[1] or x[-2]
        x = array([10,12,13,14,28,16])
        assert_equal(find_runs(x) , [[10],[12,13,14],[28],[16]])
        x = array([10,15,16,17,34])
        assert_equal(find_runs(x) , [[10],[15,16,17],[34]])

    def test_find_runs_none(self):
        x = array([])
        assert_equal(find_runs(x) , [])
        x = array([12,15,27])
        assert_equal(find_runs(x) , [[12],[15],[27]])

    def test_find_runs_descending(self):
        x = array([30,41,40,39,38,37,12])
        assert_equal(find_runs(x, order='descending') , \
                            [[30], [41,40,39,38,37], [12]])


class PointLineDistanceTestCase(unittest.TestCase):

    def test_horizontal_line(self):
        p1 = (10.0, 10.0)
        p2 = (60.0, 10.0)
        test = (35.0, 30.0)
        dist = point_line_distance(test, p1, p2)
        assert_equal(dist, 20.0)

    def test_vertical_line(self):
        p1 = (10.0, 10.0)
        p2 = (10.0, 60.0)
        test = (30.0, 35.0)
        dist = point_line_distance(test, p1, p2)
        assert_equal(dist, 20.0)

    def test_diag_lines(self):
        p1 = (0.0, 0.0)
        p2 = (10.0, 10.0)
        test = (0.0, 5.0)
        dist = point_line_distance(test, p1, p2)
        assert_almost_equal(dist, 2.5 * sqrt(2.0))

    def test_point_on_line(self):
        p1 = (-5.0, 5.0)
        p2 = (10.0, -10.0)
        test = (3.0, -3.0)
        dist = point_line_distance(test, p1, p2)
        assert_almost_equal(dist, 0.0)


if __name__ == '__main__':
    import nose
    nose.run()

########NEW FILE########
__FILENAME__ = border_test_case
""" Needed Tests

    Component.draw_border() tests
    --------------------
        DONE *. draw_border output should match a similar draw_rect output
"""

import nose
import unittest

from numpy import array, alltrue, ravel

# Chaco imports
from chaco.api import Plot, PlotGraphicsContext


class DrawBorderTestCase(unittest.TestCase):
    def assertRavelEqual(self, x, y):
        self.assert_(alltrue(ravel(x) == ravel(y)), "\n%s\n !=\n%s" % (x, y))

    def test_draw_border_simple(self):
        """ Borders should have the correct height and width.
        """
        size = (5,5)
        container = Plot(padding=1, border_visible=True)
        container.outer_bounds = list(size)
        gc = PlotGraphicsContext(size)
        gc.render_component(container)

        desired = array(((255, 255, 255, 255, 255, 255),
                         (255,   0,   0,   0,   0, 255),
                         (255,   0, 255, 255,   0, 255),
                         (255,   0, 255, 255,   0, 255),
                         (255,   0,   0,   0,   0, 255),
                         (255, 255, 255, 255, 255, 255)))

        actual = gc.bmp_array[:,:,0]
        self.assertRavelEqual(actual, desired)


if __name__ == "__main__":
    unittest.main()

########NEW FILE########
__FILENAME__ = colormapper_test_case
import unittest

from numpy import allclose, array, ravel

from chaco.api import ArrayDataSource, ColorMapper, DataRange1D


class LinearSegmentedColormapTestCase(unittest.TestCase):

    def setUp(self):
        """ Set up called before each test case. """

        _gray_data =  {'red':   [(0., 0, 0), (1., 1.0, 1.0)],
                       'green': [(0., 0, 0), (1., 1.0, 1.0)],
                       'blue':  [(0., 0, 0), (1., 1.0, 1.0)]}

        self.colormap = ColorMapper.from_segment_map(_gray_data)
        self.colormap.range = DataRange1D()

    def test_simple_map(self):

        a = ArrayDataSource(array([0.0, 0.5, 1.0]))
        self.colormap.range.add(a)
        b = self.colormap.map_screen(a.get_data())
        self.colormap.range.remove(a)

        expected = array([0.0, 0.5, 1.0])

        close = allclose(ravel(b[:,:1]), expected, atol=0.02)
        self.assert_(close,
            "Simple map failed.  Expected %s.  Got %s" % (expected, b[:,:1]))

        return

    def test_change_min_max(self):
        """ Test that changing min_value and max_value does not break map. """

        datarange = self.colormap.range

        # Perform a dummy mapping.
        a = ArrayDataSource(array([0.0, 0.5, 1.0]))
        datarange.add(a)
        b = self.colormap.map_screen(a.get_data())
        datarange.remove(a)

        # Update the min_value.
        datarange.low = -1.0

        # Test that the map still works.
        a = ArrayDataSource(array([-1.0, 0.0, 1.0]))
        datarange.add(a)
        b = self.colormap.map_screen(a.get_data())
        datarange.remove(a)
        expected = array([0.0, 0.5, 1.0])

        close = allclose(ravel(b[:,:1]), expected, atol=0.02)
        self.assert_(close,
            "Changing min value broke map.  Expected %s.  Got %s" % (expected, b[:,:1]))

        # Update the max_value.
        datarange.high = 0.0
        # Test that the map still works.
        a = ArrayDataSource(array([-1.0, -0.5, 0.0]))
        datarange.add(a)
        b = self.colormap.map_screen(a.get_data())
        datarange.remove(a)
        expected = array([0.0, 0.5, 1.0])

        close = allclose(ravel(b[:,:1]), expected, atol=0.02)
        self.assert_(close,
            "Changing min value broke map.  Expected %s.  Got %s" % (expected, b[:,:1]))


        return

    def test_array_factory(self):
        """ Test that the array factory creates valid colormap. """

        colors = array([[0.0,0.0,0.0], [1.0,1.0,1.0]])
        cm = ColorMapper.from_palette_array(colors)
        cm.range = DataRange1D()

        ar = ArrayDataSource(array([0.0, 0.5, 1.0]))
        cm.range.add(ar)
        b = cm.map_screen(ar.get_data())
        cm.range.remove(ar)

        expected = array([0.0, 0.5, 1.0])

        self.assertTrue(allclose(ravel(b[:,:1]), expected, atol=0.02),
            "Array factory failed.  Expected %s.  Got %s" % (expected, b[:,:1]))

        return

    def test_alpha_palette(self):
        """ Create a colormap with a varying alpha channel from a palette array.
        """
        cm = ColorMapper.from_palette_array([[0.0,0.0,0.0,0.5],[1.0,1.0,1.0,1.0]])
        sd = {'alpha': [(0.0, 0.5, 0.5), (1.0, 1.0, 1.0)],
              'blue': [(0.0, 0.0, 0.0), (1.0, 1.0, 1.0)],
              'green': [(0.0, 0.0, 0.0), (1.0, 1.0, 1.0)],
              'red': [(0.0, 0.0, 0.0), (1.0, 1.0, 1.0)]}
        assert cm._segmentdata == sd

    def test_alpha_segment_data(self):
        """ Create a colormap with a varying alpha channel from segment data.
        """
        sd = {'alpha': [(0.0, 0.5, 0.5), (1.0, 1.0, 1.0)],
              'blue': [(0.0, 0.0, 0.0), (1.0, 1.0, 1.0)],
              'green': [(0.0, 0.0, 0.0), (1.0, 1.0, 1.0)],
              'red': [(0.0, 0.0, 0.0), (1.0, 1.0, 1.0)]}
        cm = ColorMapper.from_segment_map(sd)
        assert cm._segmentdata == sd

    def test_no_alpha(self):
        """ Check that the defaults when no alpha is specified are correct.
        """
        sd = {'alpha': [(0.0, 1.0, 1.0), (1.0, 1.0, 1.0)],
              'blue': [(0.0, 0.0, 0.0), (1.0, 1.0, 1.0)],
              'green': [(0.0, 0.0, 0.0), (1.0, 1.0, 1.0)],
              'red': [(0.0, 0.0, 0.0), (1.0, 1.0, 1.0)]}
        assert self.colormap._segmentdata == sd


##     def test_no_interpolation(self):
##         grayscale_colors = array([[0.0,0.0,0.0,1.0], [1.0, 1.0, 1.0, 1.0]])
##         grayscale_bins = array([0.0, 1.0])
##         grayscale_steps = array([1])

##         colormap = LinearSegmentedColormap(
##             grayscale_colors, grayscale_bins, grayscale_steps
##         )

##         a = array([0.0, 0.25, 0.75, 1.0])
##         b = colormap.map_array(a)
##         result = ravel(b[:,:1])
##         expected = array([0.0, 0.0, 1.0, 1.0])

##         close = allclose(result, expected, atol=0.02)
##         self.assert_(close,
##             "Map with no interpolation broken.  Expected %s.  Got %s" % (expected, result))

##     def test_value_bands(self):

##         grayscale_colors = array([[0.0,0.0,0.0,1.0], [1.0, 1.0, 1.0, 1.0]])
##         grayscale_bins = array([0.0, 1.0])
##         grayscale_steps = array([1])

##         colormap = LinearSegmentedColormap(
##             grayscale_colors, grayscale_bins, grayscale_steps
##         )

##         colormap._recalculate()

##         print '**************', colormap._color_bands, colormap._value_bands

if __name__ == '__main__':
    import nose
    nose.run()

########NEW FILE########
__FILENAME__ = component_tests
from enable.api import Component


def test_padding_init():
    """ Make sure that padding traits passed to the constructor get set in the
    correct order.
    """
    c = Component()
    assert c.padding_top == 0
    assert c.padding_bottom == 0
    assert c.padding_left == 0
    assert c.padding_right == 0
    c = Component(padding=50)
    assert c.padding_top == 50
    assert c.padding_bottom == 50
    assert c.padding_left == 50
    assert c.padding_right == 50
    c = Component(padding=50, padding_top=15)
    assert c.padding_top == 15
    assert c.padding_bottom == 50
    assert c.padding_left == 50
    assert c.padding_right == 50
    c = Component(padding=50, padding_bottom=15)
    assert c.padding_top == 50
    assert c.padding_bottom == 15
    assert c.padding_left == 50
    assert c.padding_right == 50
    c = Component(padding=50, padding_left=15)
    assert c.padding_top == 50
    assert c.padding_bottom == 50
    assert c.padding_left == 15
    assert c.padding_right == 50
    c = Component(padding=50, padding_right=15)
    assert c.padding_top == 50
    assert c.padding_bottom == 50
    assert c.padding_left == 50
    assert c.padding_right == 15

def test_padding_trait_default():
    class PaddedComponent(Component):
        padding_top = 50
    c = PaddedComponent()
    assert c.padding_top == 50
    assert c.padding_bottom == 0
    assert c.padding_left == 0
    assert c.padding_right == 0
    c = PaddedComponent(padding_left=15)
    assert c.padding_top == 50
    assert c.padding_bottom == 0
    assert c.padding_left == 15
    assert c.padding_right == 0


########NEW FILE########
__FILENAME__ = datarange_1d_test_case

import unittest

from numpy import arange, array, zeros, inf
from numpy.testing import assert_equal

from traits.api import HasTraits, Instance, Bool, on_trait_change

from chaco.api import DataRange1D, ArrayDataSource


class Foo(HasTraits):
    """
    This class is used to test the firing of the `updated` event of DataRange1D.
    """

    range = Instance(DataRange1D)

    range_updated = Bool(False)

    @on_trait_change('range.updated')
    def range_changed(self):
        self.range_updated = True


class DataRangeTestCase(unittest.TestCase):

    def test_empty_range(self):
        r = DataRange1D()
        self.assertEqual(r.low, -inf)
        self.assertEqual(r.high, inf)
        self.assertEqual(r.low_setting, "auto")
        self.assertEqual(r.high_setting, "auto")
        r.low = 5.0
        r.high = 10.0
        self.assertEqual(r.low_setting, 5.0)
        self.assertEqual(r.high_setting, 10.0)
        self.assertEqual(r.low, 5.0)
        self.assertEqual(r.high, 10.0)
        return

    def test_set_bounds1(self):
        """Change both low and high with set_bounds()."""
        foo = Foo(range=DataRange1D(low=0.0, high=1.0))
        # Paranoid check first (not the main point of this test):
        self.assertEqual(foo.range.low, 0.0)
        self.assertEqual(foo.range.high, 1.0)
        # Now reset foo's range_updated flag and set the bounds with set_bounds().
        foo.range_updated = False
        foo.range.set_bounds(-1.0, 2.0)
        # Verify the values.
        self.assertEqual(foo.range.low, -1.0)
        self.assertEqual(foo.range.high, 2.0)
        # Verify that the `updated` event fired.
        self.assert_(foo.range_updated)

    def test_set_bounds2(self):
        """Change only the high value with set_bounds()."""
        foo = Foo(range=DataRange1D(low=0.0, high=1.0))
        # Paranoid check first (not the main point of this test):
        self.assertEqual(foo.range.low, 0.0)
        self.assertEqual(foo.range.high, 1.0)
        # Now reset foo's range_updated flag and set the bounds with set_bounds().
        foo.range_updated = False
        foo.range.set_bounds(0.0, 2.0)
        # Verify the values.
        self.assertEqual(foo.range.low, 0.0)
        self.assertEqual(foo.range.high, 2.0)
        # Verify that the `updated` event fired.
        self.assert_(foo.range_updated)

    def test_set_bounds3(self):
        """Change only the low value with set_bounds()."""
        foo = Foo(range=DataRange1D(low=0.0, high=1.0))
        # Paranoid check first (not the main point of this test):
        self.assertEqual(foo.range.low, 0.0)
        self.assertEqual(foo.range.high, 1.0)
        # Now reset foo's range_updated flag and set the bounds with set_bounds().
        foo.range_updated = False
        foo.range.set_bounds(0.5, 1.0)
        # Verify the values.
        self.assertEqual(foo.range.low, 0.5)
        self.assertEqual(foo.range.high, 1.0)
        # Verify that the `updated` event fired.
        self.assert_(foo.range_updated)

    def test_set_bounds4(self):
        """Set set_bounds() with high='track'."""
        foo = Foo(range=DataRange1D(tracking_amount=1.0))
        foo.range.low_setting = 0.0
        foo.range.high_setting = 'track'
        # Paranoid check first (not the main point of this test):
        self.assertEqual(foo.range.low, 0.0)
        self.assertEqual(foo.range.high, 1.0)
        # Now reset foo's range_updated flag and set the bounds with set_bounds().
        foo.range_updated = False
        foo.range.set_bounds(100.0, 'track')
        print foo.range.low, foo.range.high
        # Verify the values.
        self.assertEqual(foo.range.low, 100.0)
        self.assertEqual(foo.range.high, 101.0)
        # Verify that the `updated` event fired.
        self.assert_(foo.range_updated)

    def test_set_bounds5(self):
        """Set set_bounds() with low='track'."""
        foo = Foo(range=DataRange1D(tracking_amount=1.0))
        foo.range.low_setting = 'track'
        foo.range.high_setting = 1.0
        # Paranoid check first (not the main point of this test):
        self.assertEqual(foo.range.low, 0.0)
        self.assertEqual(foo.range.high, 1.0)
        # Now reset foo's range_updated flag and set the bounds with set_bounds().
        foo.range_updated = False
        foo.range.set_bounds('track', 100.0)
        # Verify the values.
        self.assertEqual(foo.range.low, 99.0)
        self.assertEqual(foo.range.high, 100.0)
        # Verify that the `updated` event fired.
        self.assert_(foo.range_updated)

    def test_set_tracking_amount(self):
        """Test setting the tracking amount using the set_tracking_amount() method."""
        foo = Foo(range=DataRange1D(tracking_amount=1.0))
        foo.range.low_setting = 'track'
        foo.range.high_setting = 1.0
        # Paranoid check first (not the main point of this test):
        self.assertEqual(foo.range.low, 0.0)
        self.assertEqual(foo.range.high, 1.0)
        # Now reset foo's range_updated flag and change the tracking amount.
        foo.range_updated = False
        foo.range.set_tracking_amount(2.0)
        # Verify the values.
        self.assertEqual(foo.range.low, -1.0)
        self.assertEqual(foo.range.high, 1.0)
        # Verify that the `updated` event fired.
        self.assert_(foo.range_updated)

    def test_scale_tracking_amount(self):
        """Test setting the tracking amount using the scale_tracking_amount() method."""
        foo = Foo(range=DataRange1D(tracking_amount=1.0))
        foo.range.low_setting = 'track'
        foo.range.high_setting = 1.0
        # Paranoid check first (not the main point of this test):
        self.assertEqual(foo.range.low, 0.0)
        self.assertEqual(foo.range.high, 1.0)
        # Now reset foo's range_updated flag and change the tracking amount.
        foo.range_updated = False
        foo.range.scale_tracking_amount(0.5)
        # Verify the values.
        self.assertEqual(foo.range.low, 0.5)
        self.assertEqual(foo.range.high, 1.0)
        # Verify that the `updated` event fired.
        self.assert_(foo.range_updated)

    def test_single_source(self):
        r = DataRange1D()
        ary = arange(10.0)
        ds = ArrayDataSource(ary)
        r.sources.append(ds)
        self.assertEqual(r.low, 0.0)
        self.assertEqual(r.high, 9.0)

        r.low = 3.0
        r.high = 6.0
        self.assertEqual(r.low_setting, 3.0)
        self.assertEqual(r.high_setting, 6.0)
        self.assertEqual(r.low, 3.0)
        self.assertEqual(r.high, 6.0)

        r.refresh()
        self.assertEqual(r.low_setting, 3.0)
        self.assertEqual(r.high_setting, 6.0)
        self.assertEqual(r.low, 3.0)
        self.assertEqual(r.high, 6.0)

        r.low = "auto"
        self.assertEqual(r.low_setting, "auto")
        self.assertEqual(r.low, 0.0)
        return

    def test_constant_value(self):
        r = DataRange1D()
        ary = array([3.14])
        ds = ArrayDataSource(ary)
        r.add(ds)
        # A constant value > 1.0, by default, gets a range that brackets
        # it to the nearest power of ten above and below
        self.assertEqual(r.low, 1.0)
        self.assertEqual(r.high, 10.0)

        r.remove(ds)
        ds = ArrayDataSource(array([31.4]))
        r.add(ds)
        self.assertEqual(r.low, 10.0)
        self.assertEqual(r.high, 100.0)

        r.remove(ds)
        ds = ArrayDataSource(array([0.125]))
        r.add(ds)
        self.assertEqual(r.low, 0.0)
        self.assertEqual(r.high, 0.25)

        r.remove(ds)
        ds = ArrayDataSource(array([-0.125]))
        r.add(ds)
        self.assertEqual(r.low, -0.25)
        self.assertEqual(r.high, 0.0)
        return


    def test_multi_source(self):
        ds1 = ArrayDataSource(array([3, 4, 5, 6, 7]))
        ds2 = ArrayDataSource(array([5, 10, 15, 20]))
        r = DataRange1D(ds1, ds2)
        self.assertEqual(r.low, 3.0)
        self.assertEqual(r.high, 20.0)
        return

    def test_clip_data(self):
        r = DataRange1D(low=2.0, high=10.0)
        ary = array([1, 3, 4, 9.8, 10.2, 12])
        assert_equal(r.clip_data(ary) , array([3.0,4.0,9.8]))

        r = DataRange1D(low=10, high=20)
        ary = array([5, 10, 15, 20, 25, 30])
        assert_equal(r.clip_data(ary) , array([10, 15, 20]))
        assert_equal(r.clip_data(ary[::-1]) , array([20, 15, 10]))

        r = DataRange1D(low=2.0, high=2.5)
        assert_equal(len(r.clip_data(ary)) , 0)
        return

    def test_mask_data(self):
        r = DataRange1D(low=2.0, high=10.0)
        ary = array([1, 3, 4, 9.8, 10.2, 12])
        assert_equal(r.mask_data(ary) , array([0,1,1,1,0,0], 'b'))

        r = DataRange1D(low=10, high=20)
        ary = array([5, 10, 15, 20, 25, 30])
        target_mask = array([0,1,1,1,0,0], 'b')
        assert_equal(r.mask_data(ary) , target_mask)
        assert_equal(r.mask_data(ary[::-1]) , target_mask[::-1])

        r = DataRange1D(low=2.0, high=2.5)
        assert_equal(r.mask_data(ary) , zeros(len(ary)))
        return

    def test_bound_data(self):
        r = DataRange1D(low=2.9, high=6.1)
        ary = arange(10)
        assert_equal(r.bound_data(ary) , (3,6))

        # test non-monotonic data
        ary = array([-5,-4,-7,-8,-2,1,2,3,4,5,4,3,8,9,10,9,8])
        bounds = r.bound_data(ary)
        assert_equal(bounds , (7,11))
        return

    def test_custom_bounds_func(self):
        def custom_func(low, high, margin, tight_bounds):
            assert_equal(low, 0.0)
            assert_equal(high, 9.0)
            assert_equal(tight_bounds, False)
            assert_equal(margin, 1.0)
            return -999., 999.

        r = DataRange1D(tight_bounds=False, margin=1.0, bounds_func=custom_func)
        ary = arange(10.0)
        ds = ArrayDataSource(ary)
        r.sources.append(ds)
        assert_equal(r.low, -999.)
        assert_equal(r.high, 999.)

    def test_inf_in_source(self):
        r = DataRange1D()
        ary1 = array([1.0, inf])
        ds1 = ArrayDataSource(ary1)
        r.sources.append(ds1)
        self.assertEqual(r.low, 1.0)
        self.assertEqual(r.high, inf)
        data = array([-100.0, 0.0, 100.0])
        assert_equal(r.clip_data(data) , array([100.0]))

        r = DataRange1D()
        ary2 = array([-inf, 1.0])
        ds2 = ArrayDataSource(ary2)
        r.sources.append(ds2)
        self.assertEqual(r.low, -inf)
        self.assertEqual(r.high, 1.0)

        r.sources.append(ds1)
        self.assertEqual(r.low, -inf)
        self.assertEqual(r.high, inf)


if __name__ == '__main__':
    import nose
    nose.run()

########NEW FILE########
__FILENAME__ = datarange_2d_test_case

import unittest

from numpy import alltrue, arange, array, ravel, transpose, zeros, inf, isinf
from numpy.testing import assert_equal, assert_

from chaco.api import DataRange2D, GridDataSource, PointDataSource


class DataRange2DTestCase(unittest.TestCase):

    def test_empty_range(self):
        r = DataRange2D()
        assert_ary_(r.low,array([-inf,-inf]))
        assert_ary_(r.high,array([inf,inf]))
        self.assert_(r.low_setting == ('auto','auto'))
        self.assert_(r.high_setting == ('auto', 'auto'))
        r.low  = array([5.0,5.0])
        r.high = array([10.0,10.0])
        assert_ary_(r.low_setting, array([5.0,5.0]))
        assert_ary_(r.high_setting, array([10.0,10.0]))
        assert_ary_(r.low,array([5.0,5.0]))
        assert_ary_(r.high, array([10.0,10.0]))
        return

    def test_single_source(self):
        r = DataRange2D()
        x = arange(10.)
        y = arange(0.,100.,10.)
        ds = PointDataSource(transpose(array([x,y])), sort_order="none")
        r.add(ds)
        assert_ary_(r.low, array([0.,0.]))
        assert_ary_(r.high, array([9.0,90.0]))

        r.low = [3.0,30.0]
        r.high = [6.0,60.0]
        assert_ary_(r.low_setting, array([3.0,30.0]))
        assert_ary_(r.high_setting, array([6.0,60.0]))
        assert_ary_(r.low, array([3.0,30.0]))
        assert_ary_(r.high, array([6.0,60.0]))

        r.refresh()
        assert_ary_(r.low_setting, array([3.0,30.0]))
        assert_ary_(r.high_setting, array([6.0,60.0]))
        assert_ary_(r.low, array([3.0,30.0]))
        assert_ary_(r.high, array([6.0,60.0]))

        r.low = ('auto', 'auto')
        self.assert_(r.low_setting == ('auto', 'auto'))
        assert_ary_(r.low, array([0.0,0.0]))
        return

    def test_constant_values(self):
        r = DataRange2D()
        ds = PointDataSource(array([[5.0,5.0]]), sort_order="none")
        r.add(ds)
        # A constant value > 1.0, by default, gets a range that brackets
        # it to the nearest power of ten above and below
        assert_ary_(r.low, array([1.0,1.0]))
        assert_ary_(r.high, array([10.0,10.0]))

        r.remove(ds)
        ds = PointDataSource(array([[31.4,9.7]]))
        r.add(ds)

        assert_ary_(r.low, array([10.0,1.0]))
        assert_ary_(r.high, array([100.0,10.0]))

        r.remove(ds)
        ds = PointDataSource(array([[0.125,0.125]]))
        r.add(ds)
        assert_ary_(r.low, array([0.0, 0.0]))
        assert_ary_(r.high, array([0.25, 0.25]))

        r.remove(ds)
        ds = PointDataSource(array([[-0.125, -0.125]]))
        r.add(ds)
        assert_ary_(r.low, array([-0.25, -0.25]))
        assert_ary_(r.high, array([0.0, 0.0]))
        return


    def test_multi_source(self):
        x = arange(10.)
        y = arange(0.,100.,10.)
        foo = transpose(array([x,y]))
        bar = transpose(array([y,x]))
        ds1 = PointDataSource(foo)
        ds2 = PointDataSource(bar)
        r = DataRange2D(ds1, ds2)
        assert_ary_(r.low, [0.0,0.0])
        assert_ary_(r.high, [90.,90.])
        return

    def test_grid_source(self):
        test_xd1 = array([1,2,3])
        test_yd1 = array([1.5, 0.5, -0.5, -1.5])
        test_sort_order1 = ('ascending', 'descending')
        test_xd2 = array([0,50,100])
        test_yd2 = array([0.5, 0.75, 1])
        ds1 = GridDataSource(xdata=test_xd1, ydata=test_yd1,
                            sort_order=test_sort_order1)
        ds2 = GridDataSource(xdata=test_xd2, ydata=test_yd2)

        r = DataRange2D()

        r.add(ds1)
        assert_ary_(r.low, array([1,-1.5]))
        assert_ary_(r.high, array([3,1.5]))

        r.add(ds2)
        assert_ary_(r.low, array([0.0,-1.5]))
        assert_ary_(r.high, array([100,1.5]))

        r.remove(ds1)
        assert_ary_(r.low, array([0,0.5]))
        assert_ary_(r.high, array([100,1]))

        r.remove(ds2)
        assert_ary_(r.low, array([-inf,-inf]))
        assert_ary_(r.high, array([inf,inf]))


    def test_set_bounds(self):
        test_xd = array([-10,10])
        test_yd = array([-10,10])
        ds = GridDataSource(xdata=test_xd, ydata=test_yd)

        r = DataRange2D()

        r.set_bounds((-1,-2), (3,4))
        assert_ary_(r.low, array([-1,-2]))
        assert_ary_(r.high, array([3,4]))

        r.add(ds)
        assert_ary_(r.low, array([-1,-2]))

        r.low_setting = ('auto','auto')
        assert_ary_(r.low, array([-10,-10]))
        assert_ary_(r.high, array([3,4]))

        r.high_setting = ('auto','auto')
        assert_ary_(r.low, array([-10,-10]))
        assert_ary_(r.high, array([10,10]))

        r.set_bounds((-100,-100), (100,100))
        assert_ary_(r.low, array([-100,-100]))
        assert_ary_(r.high, array([100,100]))


    def test_clip_data(self):
        r = DataRange2D(low=[2.0,5.0], high=[10.0,8.0])
        x= arange(10.0)
        y= arange(0.,20.,2.)
        ary= transpose(array([x,y]))
        assert_equal(r.clip_data(ary) , array([[3.,6.],[4.,8.]]))

        r = DataRange2D(low=[10.,10.], high=[20.,20.])
        x= arange(10.0,30.,2.)
        y= arange(0.,40.,4.)
        ary = transpose(array([x,y]))
        assert_equal(r.clip_data(ary) , array([[16.,12.],[18.,16.],[20.,20.]]))
        assert_equal(r.clip_data(ary[::-1]) , array([[20,20], [18,16], [16,12]]))

        return

    def test_mask_data(self):
        r = DataRange2D(low=[2.0,5.0], high=[10.0,18.0])
        x = array([1, 3, 4, 9.8, 10.2, 12])
        y = array([5, 3, 7, 12, 18, 6])
        ary = transpose(array([x,y]))
        assert_equal(r.mask_data(ary) , array([0,0,1,1,0,0], 'b'))

        r = DataRange2D(low=[10.,15.], high=[20.,25.])
        x = array([5, 10, 15, 20, 25, 30])
        y = array([5, 10, 15, 20, 25, 30])
        ary = transpose(array([x,y]))
        target_mask = array([0,0,1,1,0,0], 'b')
        assert_equal(r.mask_data(ary) , target_mask)
        assert_equal(r.mask_data(ary[::-1]) , target_mask[::-1])

        r = DataRange2D(low=[2.0,5.0], high=[2.5,9.0])
        assert_equal(r.mask_data(ary) , zeros(len(ary)))
        return

def assert_close_(desired,actual):
    diff_allowed = 1e-5
    diff = abs(ravel(actual) - ravel(desired))
    for d in diff:
        if not isinf(d):
            assert_(alltrue(d <= diff_allowed))
            return

def assert_ary_(desired, actual):
    if (desired == 'auto'):
        assert_equal(actual, 'auto')
    for d in range(len(desired)):
        assert_equal(desired[d], actual[d])
    return



if __name__ == '__main__':
    import nose
    nose.run()

########NEW FILE########
__FILENAME__ = data_view_test_case

import unittest

from chaco.api import DataRange2D, DataView, GridDataSource


class DataViewTestCase(unittest.TestCase):

    def test_empty(self):
        dv = DataView()
        self.assert_(dv.orientation=="h")
        self.assert_(dv.index_scale=="linear")
        self.assert_(dv.bgcolor=="white")
        self.assert_(dv.overlay_border==True)

        self.assert_(dv.range2d.x_range==dv.index_range)
        self.assert_(dv.range2d.y_range==dv.value_range)

    def test_orientation(self):
        dv = DataView()
        x_mapper_start = dv.x_mapper
        y_mapper_start = dv.y_mapper
        dv.orientation = "v"
        self.assert_(dv.x_mapper is y_mapper_start)
        self.assert_(dv.y_mapper is x_mapper_start)

    def test_range2d_changed(self):
        dv = DataView()
        ds = GridDataSource()
        dv.range2d.add(ds)
        old_range = dv.range2d
        r = DataRange2D()

        self.assert_(dv.range2d.sources==[ds])
        dv.range2d = r
        self.assert_(dv.range2d.sources==[ds])
        self.assert_(old_range.sources==[])
        self.assert_(dv.range2d.x_range is dv.index_mapper.range)
        self.assert_(dv.range2d.y_range is dv.value_mapper.range)

if __name__ == '__main__':
    import nose
    nose.run()

########NEW FILE########
__FILENAME__ = grid_data_source_test_case

import unittest

from numpy import alltrue, array, ravel, isinf

from chaco.api import GridDataSource


class GridDataSourceTestCase(unittest.TestCase):

    def test_empty(self):
        ds = GridDataSource()
        self.assert_(ds.sort_order == ('none', 'none'))
        self.assert_(ds.index_dimension == 'image')
        self.assert_(ds.value_dimension == 'scalar')
        self.assert_(ds.metadata == {"selections":[], "annotations":[]})
        xdata, ydata = ds.get_data()
        assert_ary_(xdata.get_data(), array([]))
        assert_ary_(ydata.get_data(), array([]))
        self.assert_(ds.get_bounds() == ((0,0),(0,0)))

    def test_init(self):
        test_xd = array([1,2,3])
        test_yd = array([1.5, 0.5, -0.5, -1.5])
        test_sort_order = ('ascending', 'descending')

        ds = GridDataSource(xdata=test_xd, ydata=test_yd,
                            sort_order=test_sort_order)

        self.assert_(ds.sort_order == test_sort_order)
        xd, yd = ds.get_data()
        assert_ary_(xd.get_data(), test_xd)
        assert_ary_(yd.get_data(), test_yd)
        self.assert_(ds.get_bounds() == ((min(test_xd),min(test_yd)),
                                         (max(test_xd),max(test_yd))))

    def test_set_data(self):
        ds = GridDataSource(xdata=array([1,2,3]),
                            ydata=array([1.5, 0.5, -0.5, -1.5]),
                            sort_order=('ascending', 'descending'))

        test_xd = array([0,2,4])
        test_yd = array([0,1,2,3,4,5])
        test_sort_order = ('none', 'none')

        ds.set_data(xdata=test_xd, ydata=test_yd, sort_order=('none', 'none'))

        self.assert_(ds.sort_order == test_sort_order)
        xd, yd = ds.get_data()
        assert_ary_(xd.get_data(), test_xd)
        assert_ary_(yd.get_data(), test_yd)
        self.assert_(ds.get_bounds() == ((min(test_xd),min(test_yd)),
                                         (max(test_xd),max(test_yd))))




def assert_close_(desired,actual):
    diff_allowed = 1e-5
    diff = abs(ravel(actual) - ravel(desired))
    for d in diff:
        if not isinf(d):
            assert alltrue(d <= diff_allowed)
            return

def assert_ary_(desired, actual):
    if (desired == 'auto'):
        assert actual == 'auto'
    for d in range(len(desired)):
        assert desired[d] == actual[d]
    return


if __name__ == '__main__':
    import nose
    nose.run()

########NEW FILE########
__FILENAME__ = grid_mapper_test_case

import unittest
from numpy import array, transpose
from numpy.testing import assert_equal

from chaco.api import GridDataSource, DataRange2D, GridMapper

class GridMapperTestCase(unittest.TestCase):

    def test_basic(self):
        x_ary = array([5.0, 6.0, 7.0, 8.0, 9.0, 10.0])
        y_ary = array([1.0, 1.0, 2.0, 2.0, 3.0, 3.0])
        ds = GridDataSource(xdata=x_ary, ydata=y_ary)
        r = DataRange2D(ds)
        mapper = GridMapper(range=r)
        mapper.x_low_pos=50
        mapper.x_high_pos=100
        mapper.y_low_pos=0
        mapper.y_high_pos=10
        result = mapper.map_screen(transpose((x_ary, y_ary)))
        assert_equal(result, [(50,0), (60,0), (70,5),
                              (80,5), (90,10), (100,10)])


if __name__ == '__main__':
    import nose
    nose.run()

########NEW FILE########
__FILENAME__ = hittest_test_case
"""
Test cases for the LinePlot's hittest() function
"""

import unittest
from numpy import arange, array, linalg
from chaco.api import (ArrayDataSource, ArrayPlotData,
                       Plot, LinearMapper, DataRange1D)

class HittestTestCase(unittest.TestCase):
    def make_plot(self, orientation):
        # make some data points
        x = arange(3)
        x = ArrayDataSource(x, sort_order="ascending")
        y = array([2,0,1])

        # Plot the data
        pd = ArrayPlotData(x=x, y=y)

        plot = Plot(pd, orientation=orientation)
        line_plot = plot.plot(("x", "y"))[0]

        # Construct a fake screen space for the plots
        # otherwise would need to actually display the plots to get this
        index_mapper = LinearMapper(data_range=DataRange1D(low=0,high=2),
                                    high_pos=380, low_pos=20)
        value_mapper = LinearMapper(data_range=DataRange1D(low=0,high=2),
                                    high_pos=380, low_pos=20)
        plot.index_mapper = index_mapper
        plot.value_mapper = value_mapper
        line_plot.index_mapper = index_mapper
        line_plot.value_mapper = value_mapper

        return  plot, line_plot

    def test_horizontal(self):
        plot, line_plot = self.make_plot("h")

        self._test_plot(plot, line_plot, point=[0.5,1])
        self._test_plot(plot, line_plot, point=[1,0])

    def test_vertical(self):
        plot, line_plot = self.make_plot("v")

        self._test_plot(plot, line_plot, point=[0.5,1])
        self._test_plot(plot, line_plot, point=[1,0])

    def _test_plot(self, plot, line_plot, point):
        threshold = 2 # In pixels

        screen_pt = plot.map_screen(point).flatten()
        result = line_plot.hittest(screen_pt, threshold=threshold)

        self.assertTrue(result is not None)

        # Check that the result is close by threshold in screenspace
        screen_result = plot.map_screen(result)

        self.assertTrue(linalg.norm(screen_pt - screen_result) < threshold)

        # check the return_distance = True case:
        x, y, d = line_plot.hittest(screen_pt, threshold=threshold,
                                    return_distance=True)
        self.assertEqual(x, result[0])
        self.assertEqual(y, result[1])
        self.assertTrue(d < threshold)

if __name__ == '__main__':
    import nose
    nose.run()

########NEW FILE########
__FILENAME__ = instantiation_order_test_case
"""
Tests that various plot and data objects can be instantiated, assigned, and
re-assigned in any order.
"""

import unittest

from numpy import array
from chaco.api import ArrayDataSource, DataRange1D, \
                                 LinearMapper

class DataPipelineTestCase(unittest.TestCase):
    def test_piecewise_construction(self):
        ary = array([1,2,3,4,5,6,7])
        ds = ArrayDataSource()
        ds.set_data(ary)
        r = DataRange1D()
        r.add(ds)
        self.assert_(r.low_setting == "auto")
        self.assert_(r.high_setting == "auto")
        self.assert_(r.low == 1)
        self.assert_(r.high == 7)

        mapper = LinearMapper()
        mapper.range = r
        mapper.low_pos = 1.0
        mapper.high_pos = 7.0
        screen_pts = mapper.map_screen(array([1,3,7]))
        self.assert_(tuple(screen_pts) == (1.0, 3.0, 7.0))
        return

    def test_reverse_construction(self):
        mapper = LinearMapper()
        r = DataRange1D()
        ds = ArrayDataSource()
        ary = array([1,2,3,4,5,6,7])

        mapper.range = r
        mapper.low_pos = 1.0
        mapper.high_pos = 7.0
        r.add(ds)
        ds.set_data(ary)

        self.assert_(r.low == 1)
        self.assert_(r.high == 7)
        screen_pts = mapper.map_screen(array([1,3,7]))
        self.assert_(tuple(screen_pts) == (1.0, 3.0, 7.0))
        return


if __name__ == '__main__':
    import nose
    nose.run()

########NEW FILE########
__FILENAME__ = linearmapper_test_case

import unittest
from numpy import array
from numpy.testing import assert_equal


from chaco.api import ArrayDataSource, DataRange1D, LinearMapper

class LinearMapperTestCase(unittest.TestCase):

    def test_basic(self):
        ary = array([5.0, 6.0, 7.0, 8.0, 9.0, 10.0])
        ds = ArrayDataSource(ary)
        r = DataRange1D(ds)
        mapper = LinearMapper(range=r, low_pos=50, high_pos=100)
        result = mapper.map_screen(ary)
        assert_equal(result , array([50, 60, 70, 80, 90, 100]))
        return

    def test_reversed(self):
        ary = array([5.0, 6.0, 7.0, 8.0, 9.0, 10.0])
        ds = ArrayDataSource(ary)
        r = DataRange1D(ds)
        mapper = LinearMapper(range=r, low_pos=100, high_pos=0)
        result = mapper.map_screen(ary)
        assert_equal(result , array([100, 80, 60, 40, 20, 0]))
        return

if __name__ == '__main__':
    import nose
    nose.run()

########NEW FILE########
__FILENAME__ = logmapper_test_case

import unittest
from numpy import array, nan
from numpy.testing import assert_array_almost_equal, assert_equal

from chaco.api import ArrayDataSource, DataRange1D, LogMapper

class LogMapperTestCase(unittest.TestCase):

    def test_basic(self):
        ary = array([1.0, 10.0, 100.0, 1000.0, 10000.0])
        ds = ArrayDataSource(ary)
        r = DataRange1D(ds)
        mapper = LogMapper(range=r, low_pos=50, high_pos=90)
        result = mapper.map_screen(ary)
        assert_equal(result, array([50, 60, 70, 80, 90]))
        return

    def test_reversed(self):
        ary = array([1.0, 10.0, 100.0, 1000.0, 10000.0])
        ds = ArrayDataSource(ary)
        r = DataRange1D(ds)
        mapper = LogMapper(range=r, low_pos=100, high_pos=0)
        result = mapper.map_screen(ary)
        assert_array_almost_equal(result, array([100, 75, 50, 25, 0]))
        return

    def test_fractional(self):
        ary = array([0.0001, 0.001, 0.01])
        ds = ArrayDataSource(ary)
        r = DataRange1D(ds)
        mapper = LogMapper(range=r, low_pos=0, high_pos=20)
        result = mapper.map_screen(ary)
        assert_array_almost_equal(result, [0, 10, 20])
        return

    def test_zero(self):
        ary = array([0.0, 1.0, 10.0, 100.0, 1000.0])
        ds = ArrayDataSource(ary)
        r = DataRange1D(ds)
        mapper = LogMapper(range=r, low_pos=0, high_pos=30)
        result = mapper.map_screen(ary)
        assert_array_almost_equal(result, [0, 0, 10, 20, 30])
        return

    def test_negative(self):
        ary = array([1.0, -1.0, -2.0, 10.0, 100.0, 1000.0])
        ds = ArrayDataSource(ary)
        r = DataRange1D(ds)
        mapper = LogMapper(range=r, low_pos=0, high_pos=30)
        result = mapper.map_screen(ary)
        assert_array_almost_equal(result, [0, 0, 0, 10, 20, 30])
        return

    def test_fill_value(self):
        ary = array([1.0, -1.0, -2.0, 10.0, 100.0, 1000.0])
        ds = ArrayDataSource(ary)
        r = DataRange1D(ds)
        mapper = LogMapper(range=r, low_pos=0, high_pos=30)
        # This causes out-of-bounds values to be treated as the value 100.0
        mapper.fill_value = 100.0
        result = mapper.map_screen(ary)
        assert_array_almost_equal(result, [0, 20, 20, 10, 20, 30])
        return

    def test_nan(self):
        ary = array([1.0, nan, 10.0, nan, 100.0, 1000.0])
        ds = ArrayDataSource(ary)
        r = DataRange1D(ds)
        mapper = LogMapper(range=r, low_pos=0, high_pos=30)
        mapper.fill_value = 100.0
        result = mapper.map_screen(ary)
        assert_array_almost_equal(result, [0, 20, 10, 20, 20, 30])
        return


if __name__ == '__main__':
    import nose
    nose.run()

########NEW FILE########
__FILENAME__ = plotcontainer_test_case
import sys
import unittest

from chaco.api import HPlotContainer, OverlayPlotContainer, \
                                PlotComponent, VPlotContainer, GridContainer
from traits.api import Any, Tuple

SizePrefs = GridContainer.SizePrefs


class ContainerTestCase(unittest.TestCase):
    def assert_tuple(self, t1, t2):
        self.assertEquals(len(t1), len(t2))
        for i in xrange(len(t1)):
            self.assertEquals(t1[i], t2[i])


class StaticPlotComponent(PlotComponent):
    """ A plotcomponent with fixed dimensions """

    def __init__(self, bounds, *args, **kw):
        kw["bounds"] = bounds
        if not kw.has_key("resizable"):
            kw["resizable"] = ""
        PlotComponent.__init__(self, *args, **kw)
        return

class ResizablePlotComponent(PlotComponent):
    """ A resizable PlotComponent with a fixed preferred size. """

    # An optional trait for expressing the preferred size of this component,
    # regardless of whether or not it is resizable.
    fixed_preferred_size = Any

    # Override default value in PlotComponent
    resizable = "hv"

    def __init__(self, preferred_size=None, *args, **kw):
        if preferred_size is not None:
            self.fixed_preferred_size = preferred_size
        PlotComponent.__init__(self, *args, **kw)

    def get_preferred_size(self):
        if self.fixed_preferred_size is not None:
            return self.fixed_preferred_size
        else:
            return PlotComponent.get_preferred_size(self)


class OverlayPlotContainerTestCase(ContainerTestCase):

    def test_basics(self):
        container = OverlayPlotContainer(resizable='', bounds=[100.0,200.0])
        self.assert_tuple(container.get_preferred_size(), (100.0,200.0))
        self.assertEquals(container._layout_needed, True)
        container.do_layout()
        self.assertEquals(container._layout_needed, False)
        return

    def test_fixed_size_component(self):
        container = OverlayPlotContainer(resizable='', bounds=[200.0,300.0])
        # non-resizable component
        component = PlotComponent(resizable='', position=[50.0,60.0], bounds=[100.0,110.0])
        self.assertEquals(container._layout_needed, True)
        container.do_layout()
        container.add(component)
        self.assertEquals(container._layout_needed, True)
        container.do_layout()
        self.assertEquals(container._layout_needed, False)

        # check the results of the layout
        self.assert_tuple(container.get_preferred_size(), (200.0,300.0))
        self.assert_tuple(component.position, (50.0,60.0))
        self.assert_tuple(component.bounds, (100.0,110.0))
        return

    def test_resizable_component(self):
        container = OverlayPlotContainer(resizable='', bounds=[200.0,300.0])
        component = PlotComponent(resizable='hv', position=[50.0,56.0], bounds=[100.0,110.0])
        container.add(component)
        container.do_layout()
        self.assert_tuple(component.position, (0.0,0.0))
        self.assert_tuple(component.bounds, (200.0,300.0))

        comp2 = PlotComponent(resizable="h", position=[10,20], bounds=[100,150])
        container.add(comp2)
        container.do_layout()
        self.assert_tuple(comp2.position, (0.0, 20.0))
        self.assert_tuple(comp2.bounds, (200.0, 150.0))

        comp3 = PlotComponent(resizable="v", position=[30,40], bounds=[100,150])
        container.add(comp3)
        container.do_layout()
        self.assert_tuple(comp3.position, (30.0, 0.0))
        self.assert_tuple(comp3.bounds, (100,300))
        return

    def test_min_size(self):
        container = OverlayPlotContainer(resizable='', bounds=[50.0,50.0])
        component = PlotComponent(resizable='', position=[50.0,60.0],
                                  bounds=[100.0, 110.0])
        container.add(component)
        container.do_layout()
        self.assert_tuple(component.position, (50.0,60.0))
        self.assert_tuple(component.bounds, (100.0,110.0))
        return

    def test_multiple_min_size(self):
        comp1 = StaticPlotComponent([200, 50])
        comp2 = StaticPlotComponent([60, 300])
        container = OverlayPlotContainer(resizable='hv', bounds=[30,30])
        container.fit_components = "hv"
        container.add(comp1, comp2)
        container.do_layout()
        self.assert_tuple(container.get_preferred_size(), (200,300))
        self.assert_tuple(comp1.bounds, (200,50))
        self.assert_tuple(comp2.bounds, (60,300))
        return

class HPlotContainerTestCase(ContainerTestCase):

    def test_stack_nonresize(self):
        # Assuming resizable='' for all plot containers and components
        container = HPlotContainer(bounds=[300,100])
        comp1 = StaticPlotComponent([100,70])
        comp2 = StaticPlotComponent([90,80])
        comp3 = StaticPlotComponent([80,90])
        container.add(comp1, comp2, comp3)
        container.do_layout()
        self.assert_tuple(container.get_preferred_size(), (270,90))
        self.assert_tuple(container.bounds, (300,100))
        self.assert_tuple(comp1.position, (0,0))
        self.assert_tuple(comp2.position, (100,0))
        self.assert_tuple(comp3.position, (190,0))
        return

    def test_stack_one_resize(self):
        "Checks stacking with 1 resizable component thrown in"
        container = HPlotContainer(bounds=[300,100])
        comp1 = StaticPlotComponent([100,70])
        comp2 = StaticPlotComponent([90,80])
        comp3 = StaticPlotComponent([80,90], resizable='hv')
        comp4 = StaticPlotComponent([40,50])
        container.add(comp1, comp2, comp3, comp4)
        container.do_layout()
        self.assert_tuple(container.get_preferred_size(), (230,80))
        self.assert_tuple(container.bounds, (300,100))
        self.assert_tuple(comp1.position, (0,0))
        self.assert_tuple(comp2.position, (100,0))
        self.assert_tuple(comp3.position, (190,0))
        self.assert_tuple(comp4.position, (260,0))
        return

    def test_valign(self):
        container = HPlotContainer(bounds=[300,200], valign="center")
        comp1 = StaticPlotComponent([200,100])
        container.add(comp1)
        container.do_layout()
        self.failUnlessEqual(comp1.position, [0,50])
        container.valign="top"
        container.do_layout(force=True)
        self.failUnlessEqual(comp1.position, [0,100])
        return


class VPlotContainerTestCase(ContainerTestCase):
    # These tests are mostly transposes of the values in HPlotContainer

    def test_stack_nonresize(self):
        container = VPlotContainer(bounds=[100,300])
        comp1 = StaticPlotComponent([70,100])
        comp2 = StaticPlotComponent([80,90])
        comp3 = StaticPlotComponent([90,80])
        container.add(comp1, comp2, comp3)
        container.do_layout()
        self.assert_tuple(container.get_preferred_size(), (90, 270))
        self.assert_tuple(container.bounds, (100,300))
        self.assert_tuple(comp1.position, (0,0))
        self.assert_tuple(comp2.position, (0,100))
        self.assert_tuple(comp3.position, (0,190))
        return

    def test_stack_one_resize(self):
        "Checks stacking with 1 resizable component thrown in"
        container = VPlotContainer(bounds=[100,300])
        comp1 = StaticPlotComponent([70,100])
        comp2 = StaticPlotComponent([80,90])
        comp3 = StaticPlotComponent([90,80], resizable='hv')
        comp4 = StaticPlotComponent([50,40])
        container.add(comp1, comp2, comp3, comp4)
        container.do_layout()
        self.assert_tuple(container.get_preferred_size(), (80,230))
        self.assert_tuple(container.bounds, (100,300))
        self.assert_tuple(comp1.position, (0,0))
        self.assert_tuple(comp2.position, (0,100))
        self.assert_tuple(comp3.position, (0,190))
        self.assert_tuple(comp4.position, (0,260))
        return

    def test_halign(self):
        container = VPlotContainer(bounds=[200,300], halign="center")
        comp1 = StaticPlotComponent([100,200])
        container.add(comp1)
        container.do_layout()
        self.failUnlessEqual(comp1.position, [50,0])
        container.halign="right"
        container.do_layout(force=True)
        self.failUnlessEqual(comp1.position, [100,0])
        return

    def test_fit_components(self):
        container = VPlotContainer(bounds=[200,300], resizable="v", fit_components="v")
        comp1 = StaticPlotComponent([50,100], padding=5)
        comp2 = StaticPlotComponent([50,120], padding=5)
        container.add(comp1)
        container.add(comp2)
        self.assert_tuple(container.get_preferred_size(), (200,240))
        # The container should not change its size as a result of its fit_components
        # being set.
        self.assert_tuple(container.bounds, (200,300))
        container.bounds = container.get_preferred_size()
        container.do_layout()

        container.padding = 8
        self.assert_tuple(container.get_preferred_size(), (216,256))
        container.do_layout()
        self.assert_tuple(comp1.outer_position, (0,0))
        self.assert_tuple(comp2.outer_position, (0,110))



class SizePrefsTestCase(unittest.TestCase):
    def assert_tuple(self, t1, t2):
        self.assertEquals(t1[0], t2[0])
        self.assertEquals(t1[1], t2[1])

    def test_sequential_non_resizable(self):
        prefs = SizePrefs(4, "h")
        components = [StaticPlotComponent([100,100]) for i in range(4)]
        for i, c in enumerate(components):
            prefs.update_from_component(c, i)
        pref_size = prefs.get_preferred_size()
        self.assert_tuple(pref_size, (100,100,100,100))
        sizes = prefs.compute_size_array(400)
        self.assert_tuple(sizes, (100,100,100,100))
        sizes2 = prefs.compute_size_array(500)
        self.assert_tuple(sizes, (100,100,100,100))

    def test_overlapping_non_resizable(self):
        prefs = SizePrefs(1, "h")
        prefs.update_from_component(StaticPlotComponent([100,10]), 0)
        prefs.update_from_component(StaticPlotComponent([200,10]), 0)
        prefs.update_from_component(StaticPlotComponent([300,10]), 0)
        pref_size = prefs.get_preferred_size()
        self.assertEquals(pref_size[0], 300)
        sizes = prefs.compute_size_array(400)
        self.assertEquals(sizes[0], 400)

    def test_sequential_resizable(self):
        prefs = SizePrefs(3, "v")
        prefs.update_from_component(ResizablePlotComponent([10,100]), 0)
        prefs.update_from_component(ResizablePlotComponent([10,200]), 1)
        prefs.update_from_component(ResizablePlotComponent([10,300]), 2)
        pref_size = prefs.get_preferred_size()
        self.assert_tuple(pref_size, (100,200,300))
        sizes = prefs.compute_size_array(600)
        self.assert_tuple(sizes, [100, 200, 300])
        sizes2 = prefs.compute_size_array(60)
        self.assert_tuple(sizes2, [10, 20, 30])
        sizes3 = prefs.compute_size_array(6000)
        self.assert_tuple(sizes3, [1000, 2000, 3000])

    def test_overlapping_resizable(self):
        prefs = SizePrefs(2, "h")
        prefs.update_from_component(ResizablePlotComponent([50, 10]), 0)
        prefs.update_from_component(ResizablePlotComponent([100, 10]), 0)
        prefs.update_from_component(ResizablePlotComponent([80, 10]), 1)
        pref_size = prefs.get_preferred_size()
        self.assert_tuple(pref_size, (100,80))
        sizes = prefs.compute_size_array(180)
        self.assert_tuple(sizes, (100, 80))
        sizes2 = prefs.compute_size_array(360)
        self.assert_tuple(sizes2, (200, 160))

    def test_sequential_fully_resizable(self):
        prefs = SizePrefs(3, "h")
        for i in range(3):
            prefs.update_from_component(ResizablePlotComponent(), i)
        pref_size = prefs.get_preferred_size()
        self.assert_tuple(pref_size, (0,0,0))
        sizes = prefs.compute_size_array(60)
        self.assert_tuple(sizes, (20, 20, 20))

    def test_overlapping_fully_resizable(self):
        prefs = SizePrefs(1, "h")
        for i in range(3):
            prefs.update_from_component(ResizablePlotComponent(), 0)
        pref_size = prefs.get_preferred_size()
        self.assertEquals(pref_size[0], 0)
        sizes = prefs.compute_size_array(60)
        self.assertEquals(sizes[0], 60)

    def test_sequential_mixed_resizable(self):
        # Tests a sequence of resizable and fully resizable components.
        prefs = SizePrefs(3, "h")
        prefs.update_from_component(ResizablePlotComponent(), 0)
        prefs.update_from_component(ResizablePlotComponent([100,10]), 1)
        prefs.update_from_component(ResizablePlotComponent(), 2)
        pref_size = prefs.get_preferred_size()
        self.assert_tuple(pref_size, (0, 100, 0))
        sizes = prefs.compute_size_array(50)
        self.assert_tuple(sizes, (0, 50, 0))
        sizes2 = prefs.compute_size_array(100)
        self.assert_tuple(sizes2, (0, 100, 0))
        sizes3 = prefs.compute_size_array(200)
        self.assert_tuple(sizes3, (50, 100, 50))

    def test_overlapping_mixed_resizable(self):
        # Tests a sequence of overlapping resizable and fully resizable components.
        prefs = SizePrefs(4, "h")
        # Slot 1
        prefs.update_from_component(ResizablePlotComponent([100,10]), 0)
        prefs.update_from_component(ResizablePlotComponent(), 0)
        # Slot 2
        prefs.update_from_component(ResizablePlotComponent(), 1)
        prefs.update_from_component(ResizablePlotComponent([50,10]), 1)
        # Slot 3
        prefs.update_from_component(ResizablePlotComponent(), 2)
        prefs.update_from_component(ResizablePlotComponent([40,10]), 2)
        # Slot 4
        prefs.update_from_component(ResizablePlotComponent(), 3)
        prefs.update_from_component(ResizablePlotComponent(), 3)
        pref_size = prefs.get_preferred_size()
        self.assert_tuple(pref_size, (100, 50, 40, 0))
        sizes = prefs.compute_size_array(95)
        self.assert_tuple(sizes, (50, 25, 20, 0))
        sizes2 = prefs.compute_size_array(230)
        self.assert_tuple(sizes2, (100, 50, 40, 40))

    def test_sequential_mixed_resizable_static(self):
        # Tests a sequence of static and resizable components.
        prefs = SizePrefs(3, "h")
        prefs.update_from_component(StaticPlotComponent([100,10]), 0)
        prefs.update_from_component(ResizablePlotComponent([50,10]), 1)
        prefs.update_from_component(ResizablePlotComponent([75,10]), 2)
        pref_size = prefs.get_preferred_size()
        self.assert_tuple(pref_size, (100,50,75))
        sizes = prefs.compute_size_array(225)
        self.assert_tuple(sizes, (100,50,75))
        sizes2 = prefs.compute_size_array(350)
        self.assert_tuple(sizes2, (100,100,150))

    def test_sequential_mixed_resizable_static2(self):
        # Tests a sequence of non-overlapping static, resizable, and fully
        # resizable components.
        prefs = SizePrefs(4, "h")
        prefs.update_from_component(StaticPlotComponent([100,10]), 0)
        prefs.update_from_component(ResizablePlotComponent([50,10]), 1)
        prefs.update_from_component(ResizablePlotComponent([75,10]), 2)
        prefs.update_from_component(ResizablePlotComponent(), 3)
        pref_size = prefs.get_preferred_size()
        self.assert_tuple(pref_size, (100,50,75,0))
        sizes = prefs.compute_size_array(300)
        self.assert_tuple(sizes, (100,50,75,75))

    def test_overlapping_mixed_resizable_static(self):
        prefs = SizePrefs(5, "h")
        # Slot 1 - static and smaller resizable
        prefs.update_from_component(StaticPlotComponent([100,10]), 0)
        prefs.update_from_component(ResizablePlotComponent([50,10]), 0)
        # Slot 2 - static and larger resizable
        prefs.update_from_component(StaticPlotComponent([30,10]), 1)
        prefs.update_from_component(ResizablePlotComponent([60,10]), 1)
        # Slot 3 - static and fully resizable
        prefs.update_from_component(StaticPlotComponent([50,10]), 2)
        prefs.update_from_component(ResizablePlotComponent(), 2)
        # Slot 4 - resizable and fully resizable
        prefs.update_from_component(ResizablePlotComponent([90,10]), 3)
        prefs.update_from_component(ResizablePlotComponent(), 3)
        # Slot 5 - fully resizable
        prefs.update_from_component(ResizablePlotComponent(), 4)

        pref_size = prefs.get_preferred_size()
        self.assert_tuple(pref_size, (100, 60, 50, 90, 0))

        # Test scaling down of resizable components in slots 2 and 4
        sizes = prefs.compute_size_array(180 + 60)
        self.assert_tuple(sizes, (100, 30+15, 50, 45, 0))

        # Test scaling up of fully resizable component in slot 5, and proper
        # allocation of slot 2's resizable component's full preferred size.
        sizes2 = prefs.compute_size_array(300 + 35)
        self.assert_tuple(sizes2, (100, 60, 50, 90, 35))



class GridContainerTestCase(ContainerTestCase):

    def test_empty_container(self):
        cont = GridContainer(shape=(1,1))
        cont.bounds = [100,100]
        cont.do_layout()
        return

    def test_all_empty_cells(self):
        cont = GridContainer(shape=(2,2), spacing=(0,0))
        cont.component_grid = [[None, None], [None, None]]
        size = cont.get_preferred_size()
        self.assert_tuple(size, (0,0))
        cont.bounds = (100,100)
        cont.do_layout()
        return

    def test_some_empty_cells(self):
        cont = GridContainer(shape=(2,2), spacing=(0,0))
        a = StaticPlotComponent([100,30])
        b = StaticPlotComponent([50,40])
        cont.component_grid = [[a, None], [None, b]]
        size = cont.get_preferred_size()
        self.assert_tuple(size, (150, 70))
        cont.bounds = size
        cont.do_layout()
        self.assert_tuple(a.outer_position, (0, 40))
        self.assert_tuple(a.outer_bounds, (100, 30))
        self.assert_tuple(b.outer_position, (100,0))
        self.assert_tuple(b.outer_bounds, (50, 40))

    def test_single_cell(self):
        cont = GridContainer(shape=(1,1))
        comp1 = StaticPlotComponent([200,300])
        cont.add(comp1)
        cont.do_layout()
        # it would be nice to make all boolean tests here trigger
        # assert failures, maybe using Pypy?
        self.assert_tuple(comp1.position, (0,0))
        self.assert_tuple(comp1.bounds, (200,300))
        return

    def test_nonresizable_container(self):
        cont = GridContainer(shape=(1,1), resizable="")
        comp1 = StaticPlotComponent([200,300])
        cont.add(comp1)
        cont.do_layout()
        self.assert_tuple(comp1.position, (0,0))
        self.assert_tuple(comp1.bounds, (200,300))
        return

    def test_row(self):
        cont = GridContainer(shape=(1,3), halign="center", valign="center")
        c1 = StaticPlotComponent([50,50])
        c2 = StaticPlotComponent([30,30])
        c3 = StaticPlotComponent([0,0], resizable="hv")
        cont.add(c1, c2, c3)
        cont.bounds = list(cont.get_preferred_size())
        cont.do_layout()
        self.assert_tuple(c1.position, (0,0))
        self.assert_tuple(c1.bounds, (50,50))
        self.assert_tuple(c2.position, (50,10))
        self.assert_tuple(c2.bounds, (30,30))
        self.assert_tuple(c3.position, (80,0))
        self.assert_tuple(c3.bounds, (0,50))

        cont.bounds = [100, 50]
        cont.do_layout()
        self.assert_tuple(c1.position, (0,0))
        self.assert_tuple(c1.bounds, (50,50))
        self.assert_tuple(c2.position, (50,10))
        self.assert_tuple(c2.bounds, (30,30))
        self.assert_tuple(c3.position, (80,0))
        self.assert_tuple(c3.bounds, (20,50))
        return

    def test_two_by_two(self):
        """ Tests a 2x2 grid of components """
        cont = GridContainer(shape=(2,2), halign="center", valign="center")
        ul = StaticPlotComponent([50,50])     # upper-left component
        lr = StaticPlotComponent([100,100])   # lower-right component
        top = StaticPlotComponent([0,0], resizable="hv")
        left = StaticPlotComponent([0,0], resizable="hv")
        cont.component_grid = [[ul, top], [left, lr]]
        cont.bounds = [150, 150]
        cont.do_layout()
        self.assert_tuple(ul.position, (0,100))
        self.assert_tuple(ul.bounds, (50,50))
        self.assert_tuple(top.position, (50,100))
        self.assert_tuple(top.bounds, (100, 50))
        self.assert_tuple(left.position, (0,0))
        self.assert_tuple(left.bounds, (50,100))
        self.assert_tuple(lr.position, (50,0))
        self.assert_tuple(lr.bounds, (100,100))
        return

    def test_spacing(self):
        cont = GridContainer(shape=(2,2), spacing=(10,10),
                             halign="center", valign="center")
        ul = StaticPlotComponent([50,50])     # upper-left component
        lr = StaticPlotComponent([100,100])   # lower-right component
        top = StaticPlotComponent([0,0], resizable="hv")
        left = StaticPlotComponent([0,0], resizable="hv")
        cont.component_grid = [[ul, top], [left, lr]]
        cont.bounds = [190, 190]
        cont.do_layout()
        self.assert_tuple(ul.position, (10,130))
        self.assert_tuple(ul.bounds, (50,50))
        self.assert_tuple(top.position, (80,130))
        self.assert_tuple(top.bounds, (100, 50))
        self.assert_tuple(left.position, (10,10))
        self.assert_tuple(left.bounds, (50,100))
        self.assert_tuple(lr.position, (80,10))
        self.assert_tuple(lr.bounds, (100,100))
        return

    def test_resizable(self):
        cont = GridContainer(shape=(2,2), spacing=(0,0),
                             halign="center", valign="center")
        ul = StaticPlotComponent([0,0], resizable="hv")
        lr = StaticPlotComponent([0,0], resizable="hv")
        top = StaticPlotComponent([0,0], resizable="hv")
        left = StaticPlotComponent([0,0], resizable="hv")
        cont.component_grid = [[ul, top], [left, lr]]
        cont.bounds = [200, 200]
        cont.do_layout()
        self.assert_tuple(ul.position, (0,100))
        self.assert_tuple(ul.bounds, (100,100))
        self.assert_tuple(top.position, (100,100))
        self.assert_tuple(top.bounds, (100, 100))
        self.assert_tuple(left.position, (0,0))
        self.assert_tuple(left.bounds, (100,100))
        self.assert_tuple(lr.position, (100,0))
        self.assert_tuple(lr.bounds, (100,100))
        return

    def test_resizable2(self):
        # Tests a resizable component that also has a preferred size
        cont = GridContainer(shape=(2,2), spacing=(0,0),
                             halign="center", valign="center")
        ul = StaticPlotComponent([150,150], resizable="hv")
        lr = StaticPlotComponent([0,0], resizable="hv")
        top = StaticPlotComponent([0,0], resizable="hv")
        left = StaticPlotComponent([0,0], resizable="hv")
        cont.component_grid = [[ul, top], [left, lr]]
        cont.bounds = [200, 200]
        cont.do_layout()
        self.assert_tuple(ul.position, (0,100))
        self.assert_tuple(ul.bounds, (100,100))
        self.assert_tuple(top.position, (100,100))
        self.assert_tuple(top.bounds, (100,100))
        self.assert_tuple(left.position, (0,0))
        self.assert_tuple(left.bounds, (100,100))
        self.assert_tuple(lr.position, (100,0))
        self.assert_tuple(lr.bounds, (100,100))

    def test_resizable_mixed(self):
        """ Tests mixing resizable and non-resizable components """
        cont = GridContainer(shape=(2,2), spacing=(10,10),
                             halign="center", valign="center")
        ul = StaticPlotComponent([0,0], resizable="hv")
        lr = StaticPlotComponent([0,0], resizable="hv")
        top = StaticPlotComponent([0,0], resizable="hv")
        left = StaticPlotComponent([100,100], resizable="")
        cont.component_grid = [[ul, top], [left, lr]]
        cont.bounds = [240, 240]
        cont.do_layout()
        self.assert_tuple(ul.position, (10,130))
        self.assert_tuple(ul.bounds, (100,100))
        self.assert_tuple(top.position, (130,130))
        self.assert_tuple(top.bounds, (100, 100))
        self.assert_tuple(left.position, (10,10))
        self.assert_tuple(left.bounds, (100,100))
        self.assert_tuple(lr.position, (130,10))
        self.assert_tuple(lr.bounds, (100,100))
        return

    def test_resizable_mixed2(self):
        # Tests laying out resizable components with preferred
        # sized alongside non-resizable components.
        cont = GridContainer(shape=(2,2), spacing=(0,0),
                             halign="center", valign="center")
        ul = ResizablePlotComponent([150,150])
        lr = StaticPlotComponent([50,50], resizable="")
        top = StaticPlotComponent([0,0], resizable="hv")
        left = StaticPlotComponent([0,0], resizable="hv")
        cont.component_grid = [[ul, top], [left, lr]]
        cont.bounds = [200, 200]
        cont.do_layout()
        self.assert_tuple(ul.position, (0,50))
        self.assert_tuple(ul.bounds, (150,150))
        self.assert_tuple(top.position, (150,50))
        self.assert_tuple(top.bounds, (50,150))
        self.assert_tuple(left.position, (0,0))
        self.assert_tuple(left.bounds, (150,50))
        self.assert_tuple(lr.position, (150,0))
        self.assert_tuple(lr.bounds, (50,50))

    def test_resizable_mixed_h(self):
        # Tests the layout of a non-resizable component, a resizable with a
        # preferred size, and a fully resizable component in a horizontal
        # GridContainer
        cont = GridContainer(shape=(3,1), spacing=(0,0),
                             halign="center", valign="center")
        left = StaticPlotComponent([50,10], resizable="")
        middle = ResizablePlotComponent([100,10])
        right = StaticPlotComponent([0,0], resizable="hv")

        cont.component_grid = [[left, middle, right]]
        cont.bounds = [200, 10]
        cont.do_layout()
        self.assert_tuple(left.position, (0,0))
        self.assert_tuple(left.bounds, (50,10))
        self.assert_tuple(middle.position, (50,0))
        self.assert_tuple(middle.bounds, (100,10))
        self.assert_tuple(right.position, (150,0))
        self.assert_tuple(right.bounds, (50,10))

    def test_non_resizable(self):
        cont = GridContainer(shape=(2,2), spacing=(10,10),
                             halign="center", valign="center")
        ul = StaticPlotComponent([100,100], resizable="")
        ur = StaticPlotComponent([100,100], resizable="")
        ll = StaticPlotComponent([100,100], resizable="")
        lr = StaticPlotComponent([100,100], resizable="")
        cont.component_grid = [[ul, ur], [ll, lr]]

        cont.bounds = [240, 240]
        cont.do_layout()
        self.assert_tuple(ul.position, (10,130))
        self.assert_tuple(ul.bounds, (100,100))
        self.assert_tuple(ur.position, (130,130))
        self.assert_tuple(ur.bounds, (100, 100))
        self.assert_tuple(ll.position, (10,10))
        self.assert_tuple(ll.bounds, (100,100))
        self.assert_tuple(lr.position, (130,10))
        self.assert_tuple(lr.bounds, (100,100))

        cont.bounds = [280, 280]
        cont.do_layout()
        self.assert_tuple(ul.position, (20,160))
        self.assert_tuple(ul.bounds, (100,100))
        self.assert_tuple(ur.position, (160,160))
        self.assert_tuple(ur.bounds, (100, 100))
        self.assert_tuple(ll.position, (20,20))
        self.assert_tuple(ll.bounds, (100,100))
        self.assert_tuple(lr.position, (160,20))
        self.assert_tuple(lr.bounds, (100,100))

if __name__ == '__main__':
    import nose
    nose.run()

########NEW FILE########
__FILENAME__ = scatterplot_renderers_test_case
import unittest

from numpy import alltrue
from enable.compiled_path import CompiledPath

# Chaco imports
from chaco.api import create_scatter_plot, PlotGraphicsContext


class DrawScatterplotCase(unittest.TestCase):
    def test_scatter_fast(self):
        """ Coverage test to check basic case works """
        size = (50, 50)
        scatterplot = create_scatter_plot(
            data=[range(10), range(10)],
            border_visible=False,
        )
        scatterplot.outer_bounds = list(size)
        gc = PlotGraphicsContext(size)
        gc.render_component(scatterplot)
        actual = gc.bmp_array[:, :, :]
        self.assertFalse(alltrue(actual == 255))

    def test_scatter_circle(self):
        """ Coverage test to check circles work """
        size = (50, 50)
        scatterplot = create_scatter_plot(
            data=[range(10), range(10)],
            marker="circle",
            border_visible=False,
        )
        scatterplot.outer_bounds = list(size)
        gc = PlotGraphicsContext(size)
        gc.render_component(scatterplot)
        actual = gc.bmp_array[:, :, :]
        self.assertFalse(alltrue(actual == 255))

    def test_scatter_custom(self):
        """ Coverage test to check custom markers work """
        # build path
        path = CompiledPath()
        path.move_to(-5, -5)
        path.line_to(5, 5)
        path.line_to(5, -5)
        path.line_to(-5, 5)
        path.line_to(-5, -5)

        size = (50, 50)
        scatterplot = create_scatter_plot(
            data=[range(10), range(10)],
            marker='custom',
            border_visible=False,
        )
        scatterplot.custom_symbol = path
        scatterplot.outer_bounds = list(size)
        gc = PlotGraphicsContext(size)
        gc.render_component(scatterplot)
        actual = gc.bmp_array[:, :, :]
        self.assertFalse(alltrue(actual == 255))

    def test_scatter_slow(self):
        """ Coverage test to check multiple marker size works """
        size = (50, 50)
        scatterplot = create_scatter_plot(
            data=[range(10), range(10)],
            border_visible=False,
            marker_size=range(1, 11),
        )
        scatterplot.outer_bounds = list(size)
        gc = PlotGraphicsContext(size)
        gc.render_component(scatterplot)
        actual = gc.bmp_array[:, :, :]
        self.assertFalse(alltrue(actual == 255))


if __name__ == "__main__":
    unittest.main()

########NEW FILE########
__FILENAME__ = serializable_base


from traits.api import Bool, HasTraits, Str, Float, Enum, List, Int
from chaco.serializable import Serializable

class Root(HasTraits):
    name = Str
    x = Float(0.0)
    y = Float(0.0)

class Shape(Serializable, Root):
    color = Enum("red", "green", "blue")
    filled = Bool(True)
    tools = List
    _pickles = ("tools", "filled", "color", "x")

class Circle(Shape):
    radius = Float(10.0)
    _pickles = ("radius",)

class Poly(Shape):
    numsides = Int(5)
    length = Float(5.0)
    _pickles = ("numsides", "length")

# EOF

########NEW FILE########
__FILENAME__ = serializable_test_case

from cPickle import loads, dumps
import unittest

# pickling child classes doesn't work well in the unittest framework unless
# the classes to be pickled are in a different file
from serializable_base import Circle, Poly

class SimpleSerializationTestCase(unittest.TestCase):

    def compare_traits(self, a, b, trait_names=None):
        "Checks the traits of objects 'a' and 'b' and makes sure they all match."
        if trait_names is None:
            trait_names = a.trait_names()
        for name in trait_names:
            if name in ("trait_added", "trait_modified"):
                continue
            o1 = getattr(a,name)
            o2 = getattr(b,name)
            if isinstance(o1, list) or isinstance(o1, tuple):
                print "Warning: Cowardly refusing to do deep compares"
            else:
                self.assert_(o1 == o2)
        return

    def test_basic_save(self):
        c = Circle(radius=5.0, name="c1", x=1.0, y=2.0)
        c2 = loads(dumps(c))
        for attrib in ("tools", "filled", "color", "x", "radius"):
            self.assert_(getattr(c, attrib) == getattr(c2, attrib))
        self.failUnlessEqual(c2.y, 2.0)
        return

    def test_basic_save2(self):
        p = Poly(numside=3, name="poly", x=3.0, y=4.0)
        p2 = loads(dumps(p))
        for attrib in ("tools", "filled", "color", "x", "numsides", "length"):
            self.assert_(getattr(p, attrib) == getattr(p2, attrib))
        self.failUnlessEqual(p2.y, 4.0)
        return


class PlotSerializationTestCase(unittest.TestCase):
    pass


if __name__ == '__main__':
    import nose
    nose.run()

########NEW FILE########
__FILENAME__ = speedups_test_case

import unittest

from numpy import alltrue, array, ravel, zeros, isinf, linspace

#from chaco import _speedups as speedups
#from chaco import _speedups_fallback as fallback


def assert_close(desired,actual):
    diff_allowed = 1e-5
    diff = abs(ravel(actual) - ravel(desired))
    for d in diff:
        if not isinf(d):
            assert alltrue(d <= diff_allowed)
            return

class GatherPointsBase(object):

    # The module to look for the gather_points function in; subclasses
    # should override this.
    module = None

    def test_basic(self):
        index = linspace(0.0, 20.0, 21)
        value = linspace(0.0, 1.0, 21)
        points, selection = self.func(index, 4.5, 14.5, value, -1.0, 2.4)
        desired = array([[5, 6, 7, 8, 9, 10, 11, 12, 13, 14],
            [0.25, 0.3, 0.35, 0.4, 0.45, 0.5, 0.55, 0.6, 0.65, 0.8]]).T
        self.assert_(selection == None)
        assert_close(desired, points)

    def test_masked(self):
        index = linspace(0.0, 10.0, 11)
        value = linspace(0.0, 1.0, 11)
        index_mask = zeros(11, dtype=bool)
        index_mask[2:6] = 1
        value_mask = zeros(11, dtype=bool)
        value_mask[4:8] = 1

        points, selection = self.func(index, 0, 10, value, 0, 1,
                                index_mask = index_mask)
        desired = array([[2, 3, 4, 5], [0.2, 0.3, 0.4, 0.5]]).T
        assert_close(desired, points)

        points, selection = self.func(index, 0, 10, value, 0, 1,
                                index_mask = index_mask,
                                value_mask = value_mask)
        desired = array([[4, 0.4], [5, 0.5]])
        assert_close(desired, points)


    def test_selection(self):
        pass

    def test_selection_range(self):
        pass

    def _get_func(self):
        return self.module.scatterplot_gather_points
    func = property(_get_func)


#class SpeedupsTestCase(GatherPointsBase, unittest.TestCase):
#    module = speedups


#class SpeedupsFallbackTestCase(SpeedupsTestCase):
#    module = fallback


#def timing_test_gather_points():
#    import time
#    from numpy import sin, pi

#    numpoints = 10000
#    numruns = 10

#    x = linspace(-8*pi, 8*pi, numpoints)
#    y = sin(x)
#    args = (x, -30, 30, y, -0.5, 0.5)

#    funcs = {"Fallback": fallback.scatterplot_gather_points,
#             "C-based": speedups.scatterplot_gather_points}
#
#    for name, func in funcs.items():
#        now = time.time()
#        for i in range(numruns):
#            points, selection = func(*args)
#        print "%s (%d pts, %d runs):" % (name, numpoints, numruns), (time.time() - now)
#    return



########NEW FILE########
__FILENAME__ = _tools
from contextlib import contextmanager

import sys
import traceback


# ######### Testing tools

@contextmanager
def store_exceptions_on_all_threads():
    """Context manager that captures all exceptions, even those coming from
    the UI thread. On exit, the first exception is raised (if any).
    """

    exceptions = []

    def excepthook(type, value, tb):
        exceptions.append(value)
        message = 'Uncaught exception:\n'
        message += ''.join(traceback.format_exception(type, value, tb))
        sys.stderr.write(message)

    try:
        sys.excepthook = excepthook
        yield
    finally:
        if len(exceptions) > 0:
            raise exceptions[0]
        sys.excepthook = sys.__excepthook__


@contextmanager
def assert_raises(ExceptionClass):
    try:
        yield
    except ExceptionClass:
        pass
    else:
        msg = 'Test should have failed with {}.'
        raise Exception(msg.format(ExceptionClass.__name__))

########NEW FILE########
__FILENAME__ = create_2d_test_case
from __future__ import with_statement

from chaco.api import Plot, ArrayPlotData

from traits.api import HasTraits, Instance
from enable.component_editor import ComponentEditor
from traitsui.api import Item, View

import numpy as np

import nose
from chaco.tests._tools import store_exceptions_on_all_threads, assert_raises


class PlotViewer(HasTraits):
    plot = Instance(Plot)
    traits_view = View(Item('plot', editor=ComponentEditor()))


def test_bounds_2d_case():
    # test for bug: contour and image plots should support the case where
    # xbounds and ybounds are 2d arrays resulting from meshgrids

    xs = np.linspace(-10,10,200)
    ys = np.linspace(-10,10,400)
    x, y = np.meshgrid(xs,ys)
    z = x + y

    plotdata = ArrayPlotData()
    plotdata.set_data("z", z)

    plot = Plot(plotdata)
    plot.contour_plot("z", xbounds=x, ybounds=y)

    # try to display it, that's when the exception is raised
    with store_exceptions_on_all_threads():
        pv = PlotViewer(plot=plot)
        pv.edit_traits()


def test_process_2d_bounds():
    # behavior: _process_2d_bounds accepts all possible ways to set x and y
    # bounds in 2d plots and returns a 1d array with equally spaced
    # intervals between the lower and upper bound of the data. The number
    # of elements in the 1d array must be of one element larger than the
    # shape of the data, because it includes the upper bound.

    height, width = 20, 10
    array_data = np.ones(shape=(height, width))
    plot = Plot()

    # bounds is None : infer from array_data shape
    xs = plot._process_2d_bounds(None, array_data, 1)
    assert xs.shape[0] == width + 1
    ys = plot._process_2d_bounds(None, array_data, 0)
    assert ys.shape[0] == height + 1

    # bounds is a tuple : it defines lower and upper range
    bounds = (1.0, 100.0)
    xs = plot._process_2d_bounds(bounds, array_data, 1)
    assert xs.shape[0] == width + 1
    assert xs[0] == bounds[0] and xs[-1] == bounds[1]

    # bounds is a 1D array: the first and last elements are used to create
    # equally spaced intervals. Bounds must be of one element larger than the
    # corresponding axis in array_data, or it will raise a Value error
    bounds = np.zeros((height+1, ))
    bounds[0], bounds[-1] = 0.2, 21.3
    ys = plot._process_2d_bounds(bounds, array_data, 0)
    assert ys.shape[0] == height + 1
    assert ys[0] == bounds[0] and ys[-1] == bounds[-1]
    with assert_raises(ValueError):
        bounds = np.zeros((width // 2, ))
        plot._process_2d_bounds(bounds, array_data, 0)

    # bounds is a 2D array: the first and last elements along the appropriate
    # axis are used to create equally spaced intervals.
    # The size of the bounds must be the same as the data array, or this
    # sill raise a ValueError
    xbounds, ybounds = np.meshgrid(np.arange(width), np.arange(height))

    xs = plot._process_2d_bounds(xbounds, array_data, 1)
    assert xs.shape[0] == width + 1
    assert xs[0] == xbounds[0,0] and xs[-2] == xbounds[0,-1]
    with assert_raises(ValueError):
        plot._process_2d_bounds(xbounds[:5,:], array_data, 1)

    ys = plot._process_2d_bounds(ybounds, array_data, 0)
    assert ys.shape[0] == height + 1
    assert ys[0] == ybounds[0,0] and ys[-2] == ybounds[-1,0]


if __name__ == '__main__':
    nose.main()

########NEW FILE########
__FILENAME__ = highlight_tool_test_case
from traits.api import HasTraits, Instance
from traitsui.api import Item, View
from enable.component_editor import ComponentEditor

from chaco.api import Plot, ArrayPlotData
from chaco.tools.highlight_tool import HighlightTool

import numpy as np

import nose


class PlotViewer(HasTraits):
    plot = Instance(Plot)
    traits_view = View(Item('plot', editor=ComponentEditor()))


class MockEvent(HasTraits):
    pass


def test_highlight_on_log_plot():
    # test for bug: the highlight tool raises an exception when used on
    # a loglog plot

    x = np.linspace(1, 15, 200)

    plotdata = ArrayPlotData()
    plotdata.set_data("x", x)
    plotdata.set_data("y", x*x)

    plot = Plot(plotdata)
    plot.plot(("x", "y"), index_scale='log', value_scale='log')

    # necessary for the machinery involved in _find_curve
    plot.datasources["x"].sort_order = 'ascending'
    plot.datasources["y"].sort_order = 'ascending'

    # add the highlight tool
    htool = HighlightTool(plot, threshold=20.)
    plot.tools.append(htool)

    # we create a view of the plot so that the screen bounds are set
    pv = PlotViewer(plot=plot)
    pv.edit_traits()

    # this should not raise an exception
    event = MockEvent(x=170., y=60.)
    htool._find_curve(plot.plots['plot0'], event)


if __name__ == '__main__':
    nose.main()

########NEW FILE########
__FILENAME__ = text_box_overlay
""" Defines the TextBoxOverlay class.
"""
from __future__ import with_statement

# Enthought library imports
from enable.api import ColorTrait
from kiva.trait_defs.kiva_font_trait import KivaFont
from traits.api import Any, Enum, Int, Str, Float, Trait, Bool

# Local, relative imports
from abstract_overlay import AbstractOverlay
from label import Label


class TextBoxOverlay(AbstractOverlay):
    """ Draws a box with text in it.
    """

    #### Configuration traits #################################################

    # The text to display in the box.
    text = Str

    # The font to use for the text.
    font = KivaFont("modern 12")

    # The background color for the box (overrides AbstractOverlay).
    bgcolor = ColorTrait("transparent")

    # The alpha value to apply to **bgcolor**
    alpha = Trait(1.0, None, Float)

    # The color of the outside box.
    border_color = ColorTrait("dodgerblue")

    # The color of the text.
    text_color = ColorTrait("black")

    # The thickness of box border.
    border_size = Int(1)

    # The border visibility. Defaults to true to duplicate previous behavior.
    border_visible = Bool(True)

    # Number of pixels of padding around the text within the box.
    padding = Int(5)

    # The maximum width of the displayed text. This affects the width of the
    # text only, not the text box, which includes margins around the text and
    # `padding`.
    # A `max_text_width` of 0.0 means that the width will not be restricted.
    max_text_width = Float(0.0)

    # Alignment of the text in the box:
    #
    # * "ur": upper right
    # * "ul": upper left
    # * "ll": lower left
    # * "lr": lower right
    align = Enum("ur", "ul", "ll", "lr")

    # This allows subclasses to specify an alternate position for the root
    # of the text box.  Must be a sequence of length 2.
    alternate_position = Any

    #### Public 'AbstractOverlay' interface ###################################

    def overlay(self, component, gc, view_bounds=None, mode="normal"):
        """ Draws the box overlaid on another component.

        Overrides AbstractOverlay.
        """

        if not self.visible:
            return

        # draw the label on a transparent box. This allows us to draw
        # different shapes and put the text inside it without the label
        # filling a rectangle on top of it
        label = Label(text=self.text, font=self.font, bgcolor="transparent",
                      color=self.text_color, max_width=self.max_text_width,
                      margin=5)
        width, height = label.get_width_height(gc)

        valign, halign = self.align

        if self.alternate_position:
            x, y = self.alternate_position
            if valign == "u":
                y += self.padding
            else:
                y -= self.padding + height

            if halign == "r":
                x += self.padding
            else:
                x -= self.padding + width
        else:
            if valign == "u":
                y = component.y2 - self.padding - height
            else:
                y = component.y + self.padding

            if halign == "r":
                x = component.x2 - self.padding - width
            else:
                x = component.x + self.padding

        # attempt to get the box entirely within the component
        x_min, y_min, x_max, y_max = (component.x,
                                      component.y,
                                      component.x + component.width,
                                      component.y + component.height)
        if x + width > x_max:
            x = max(x_min, x_max - width)
        if y + height > y_max:
            y = max(y_min, y_max - height)
        elif y < y_min:
            y = y_min

        # apply the alpha channel
        color = self.bgcolor_
        if self.bgcolor != "transparent":
            if self.alpha:
                color = list(self.bgcolor_)
                if len(color) == 4:
                    color[3] = self.alpha
                else:
                    color += [self.alpha]

        with gc:
            gc.translate_ctm(x, y)

            gc.set_line_width(self.border_size)
            gc.set_stroke_color(self.border_color_)
            gc.set_fill_color(color)

            if self.border_visible:
                # draw a rounded rectangle.
                x = y = 0
                end_radius = 8.0
                gc.begin_path()
                gc.move_to(x + end_radius, y)
                gc.arc_to(x + width, y,
                          x + width,
                          y + end_radius, end_radius)
                gc.arc_to(x + width,
                          y + height,
                          x + width - end_radius,
                          y + height, end_radius)
                gc.arc_to(x, y + height,
                          x, y,
                          end_radius)
                gc.arc_to(x, y,
                          x + width + end_radius,
                          y, end_radius)
                gc.draw_path()

            label.draw(gc)

########NEW FILE########
__FILENAME__ = ticks
#-------------------------------------------------------------------------------
#
#
#  Written by: David C. Morrill (based on similar routines written by Eric Jones)
#
#  Date: 2007-05-01
#
#  (c) Copyright 2002-7 by Enthought, Inc.
#
#-------------------------------------------------------------------------------
""" Tick generator classes and helper functions for calculating axis
tick-related values (i.e., bounds and intervals).

"""
# Major library imports
from numpy import arange, argsort, array, ceil, concatenate, equal, finfo, \
    float64, floor, linspace, log10, minimum, ndarray, newaxis, \
    putmask, shape

# Enthought library imports
from traits.api import HasTraits, Any

class AbstractTickGenerator(HasTraits):
    """ Abstract class for tick generators.
    """
    def get_ticks(self, data_low, data_high, bounds_low, bounds_high, interval,
                  use_endpoints=False, scale='linear'):
        """ Returns a list of ticks points in data space.

        Parameters
        ----------
        data_low, data_high : float
            The actual minimum and maximum of index values of the entire
            dataset.
        bounds_low, bounds_high : "auto", "fit", float
            The range for which ticks should be generated.
        interval : "auto", float
            If the value is a positive number, it specifies the length
            of the tick interval; a negative integer specifies the
            number of tick intervals; 'auto' specifies that the number and
            length of the tick intervals are automatically calculated, based
            on the range of the axis.
        use_endpoints : Boolean
            If True, the lower and upper bounds of the data are used as the
            lower and upper end points of the axis. If False, the end points
            might not fall exactly on the bounds.
        scale : 'linear' or 'log'
            The type of scale the ticks are for.

        Returns
        -------
        tick_list : array of floats
            Where ticks are to be placed.


        Example
        -------
        If the range of x-values in a line plot span from -15.0 to +15.0, but
        the plot is currently displaying only the region from 3.1 to 6.83, and
        the user wants the interval to be automatically computed to be some
        nice value, then call get_ticks() thusly::

            get_ticks(-15.0, 15.0, 3.1, 6.83, "auto")

        A reasonable return value in this case would be::

            [3.5, 4.0, 4.5, 5.0, 5.5, 6.0, 6.5]
        """

        raise NotImplementedError


class DefaultTickGenerator(AbstractTickGenerator):
    """ An implementation of AbstractTickGenerator that simply uses the
    auto_ticks() and log_auto_ticks() functions.
    """
    def get_ticks(self, data_low, data_high, bounds_low,
                  bounds_high, interval, use_endpoints=False,
                  scale='linear'):
        if scale == 'linear':
            return array(auto_ticks(data_low, data_high, bounds_low, bounds_high,
                         interval, use_endpoints=False), float64)
        elif scale == 'log':
            return array(log_auto_ticks(data_low, data_high, bounds_low, bounds_high,
                                              interval, use_endpoints=False), float64)

class ShowAllTickGenerator(AbstractTickGenerator):
    """ Uses the abstract interface, but returns all "positions" instead
        of decimating the ticks.

        You must provide a sequence of values as a *positions* keyword argument
        to the constructor.
    """
    # A sequence of positions for ticks.
    positions = Any

    def get_ticks(self, data_low, data_high, bounds_low, bounds_high, interval,
                  use_endpoints=False, scale='linear'):
        """ Returns an array based on **positions**.
        """
        # ignore all the high, low, etc. data and just return every position
        return array(self.positions, float64)

#-------------------------------------------------------------------------------
#  Code imported from plt/plot_utility.py:
#-------------------------------------------------------------------------------

def auto_ticks ( data_low, data_high, bound_low, bound_high, tick_interval,
                 use_endpoints = True):
    """ Finds locations for axis tick marks.

        Calculates the locations for tick marks on an axis. The *bound_low*,
        *bound_high*, and *tick_interval* parameters specify how the axis end
        points and tick interval are calculated.

        Parameters
        ----------

        data_low, data_high : number
            The minimum and maximum values of the data along this axis.
            If any of the bound settings are 'auto' or 'fit', the axis
            traits are calculated automatically from these values.
        bound_low, bound_high : 'auto', 'fit', or a number.
            The lower and upper bounds of the axis. If the value is a number,
            that value is used for the corresponding end point. If the value is
            'auto', then the end point is calculated automatically. If the
            value is 'fit', then the axis bound is set to the corresponding
            *data_low* or *data_high* value.
        tick_interval : can be 'auto' or a number
            If the value is a positive number, it specifies the length
            of the tick interval; a negative integer specifies the
            number of tick intervals; 'auto' specifies that the number and
            length of the tick intervals are automatically calculated, based
            on the range of the axis.
        use_endpoints : Boolean
            If True, the lower and upper bounds of the data are used as the
            lower and upper end points of the axis. If False, the end points
            might not fall exactly on the bounds.

        Returns
        -------
        An array of tick mark locations. The first and last tick entries are the
        axis end points.
    """

    is_auto_low  = (bound_low  == 'auto')
    is_auto_high = (bound_high == 'auto')

    if isinstance(bound_low, basestring):
        lower = data_low
    else:
        lower = float( bound_low )

    if isinstance(bound_high, basestring):
        upper = data_high
    else:
        upper = float( bound_high )

    if (tick_interval == 'auto') or (tick_interval == 0.0):
        rng = abs( upper - lower )

        if rng == 0.0:
            tick_interval = 0.5
            lower         = data_low  - 0.5
            upper         = data_high + 0.5
        elif is_base2( rng ) and is_base2( upper ) and rng > 4:
            if rng == 2:
                tick_interval = 1
            elif rng == 4:
                tick_interval = 4
            else:
                tick_interval = rng / 4   # maybe we want it 8?
        else:
            tick_interval = auto_interval( lower, upper )
    elif tick_interval < 0:
        intervals     = -tick_interval
        tick_interval = tick_intervals( lower, upper, intervals )
        if is_auto_low and is_auto_high:
            is_auto_low = is_auto_high = False
            lower = tick_interval * floor( lower / tick_interval )
            while ((abs( lower ) >= tick_interval) and
                   ((lower + tick_interval * (intervals - 1)) >= upper)):
                lower -= tick_interval
            upper = lower + tick_interval * intervals

    # If the lower or upper bound are set to 'auto',
    # calculate them based on the newly chosen tick_interval:
    if is_auto_low or is_auto_high:
        delta = 0.01 * tick_interval * (data_low == data_high)
        auto_lower, auto_upper = auto_bounds( data_low - delta,
                                              data_high + delta, tick_interval )
        if is_auto_low:
            lower = auto_lower
        if is_auto_high:
            upper = auto_upper

    # Compute the range of ticks values:
    start = floor( lower / tick_interval ) * tick_interval
    end   = floor( upper / tick_interval ) * tick_interval
    # If we return the same value for the upper bound and lower bound, the
    # layout code will not be able to lay out the tick marks (divide by zero).
    if start == end:
        lower = start = start - tick_interval
        upper = end = start - tick_interval

    if upper > end:
        end += tick_interval
    ticks = arange( start, end + (tick_interval / 2.0), tick_interval )

    if len( ticks ) < 2:
        ticks = array( ( ( lower - lower * 1.0e-7 ), lower ) )
    if (not is_auto_low) and use_endpoints:
        ticks[0] = lower
    if (not is_auto_high) and use_endpoints:
        ticks[-1] = upper

    return [tick for tick in ticks if tick >= bound_low and tick <= bound_high]

#--------------------------------------------------------------------------------
#  Determine if a number is a power of 2:
#--------------------------------------------------------------------------------

def is_base2 ( range ):
    """ Returns True if *range* is a positive base-2 number (2, 4, 8, 16, ...).
    """
    if range <= 0.0:
        return False
    else:
        lg = log2( range )
        return ((lg == floor( lg )) and (lg > 0.0))

#--------------------------------------------------------------------------------
#  Compute n log 2:
#--------------------------------------------------------------------------------

def log2 ( num ):
    """ Returns the base 2 logarithm of a number (or array).

    """
    #    !! 1e-16 is here to prevent errors when log is 0
    if num == 0.0:
        num += 1.0e-16
    elif type( num ) is ndarray:
        putmask( num, equal( num, 0.0), 1.0e-16 )
    return log10( num ) / log10( 2 )

#--------------------------------------------------------------------------------
#  Compute the best tick interval for a specified data range:
#--------------------------------------------------------------------------------

def heckbert_interval(data_low, data_high, numticks=8):
    """
    Returns a "nice" range and interval for a given data range and a preferred
    number of ticks.  From Paul Heckbert's algorithm in Graphics Gems.
    """
    range = _nice(data_high - data_low)
    d = _nice(range / (numticks-1), round=True)
    graphmin = floor(data_low / d) * d
    graphmax = ceil(data_high / d) * d
    #nfrac = max(-floor(log10(d)), 0)
    return graphmin, graphmax, d


def _nice(x, round=False):
    """ if round is False, then use ceil(range) """
    expv = floor(log10(x))
    f = x / pow(10, expv)
    if round:
        if f < 1.5:
            nf = 1.0
        elif f < 3.0:
            nf = 2.0
        elif f < 7.0:
            nf = 5.0;
        else:
            nf = 10.0
    else:
        if f <= 1.0:
            nf = 1.0
        elif f <= 2.0:
            nf = 2.0
        elif f <= 5.0:
            nf = 5.0
        else:
            nf = 10.0
    return nf * pow(10, expv)


def auto_interval ( data_low, data_high ):
    """ Calculates the tick interval for a range.

        The boundaries for the data to be plotted on the axis are::

            data_bounds = (data_low,data_high)

        The function chooses the number of tick marks, which can be between
        3 and 9 marks (including end points), and chooses tick intervals at
        1, 2, 2.5, 5, 10, 20, ...

        Returns
        -------
        interval : float
            tick mark interval for axis
    """
    range = float( data_high ) - float( data_low )

    # We'll choose from between 2 and 8 tick marks.
    # Preference is given to more ticks:
    #   Note reverse order and see kludge below...
    divisions = arange( 8.0, 2.0, -1.0 ) # ( 7, 6, ..., 3 )

    # Calculate the intervals for the divisions:
    candidate_intervals = range / divisions

    # Get magnitudes and mantissas for each candidate:
    magnitudes = 10.0 ** floor( log10( candidate_intervals ) )
    mantissas  = candidate_intervals / magnitudes

    # List of "pleasing" intervals between ticks on graph.
    # Only the first magnitude are listed, higher mags others are inferred:
    magic_intervals = array( ( 1.0, 2.0, 2.5, 5.0, 10.0 ) )

    # Calculate the absolute differences between the candidates
    # (with magnitude removed) and the magic intervals:
    differences = abs( magic_intervals[:,newaxis] - mantissas )

    # Find the division and magic interval combo that produce the
    # smallest differences:

    # KLUDGE: 'argsort' doesn't preserve the order of equal values,
    # so we subtract a small, index dependent amount from each difference
    # to force correct ordering.
    sh    = shape( differences )
    small = 2.2e-16 * arange( sh[1] ) * arange( sh[0] )[:,newaxis]
    small = small[::-1,::-1] #reverse the order
    differences = differences - small

    # ? Numeric should allow keyword "axis" ? comment out for now
    #best_mantissa = minimum.reduce(differences,axis=0)
    #best_magic = minimum.reduce(differences,axis=-1)
    best_mantissa  = minimum.reduce( differences,  0 )
    best_magic     = minimum.reduce( differences, -1 )
    magic_index    = argsort( best_magic )[0]
    mantissa_index = argsort( best_mantissa )[0]

    # The best interval is the magic_interval multiplied by the magnitude
    # of the best mantissa:
    interval  = magic_intervals[ magic_index ]
    magnitude = magnitudes[ mantissa_index ]
    result    = interval * magnitude
    if result == 0.0:
        result = finfo(float).eps
    return result

#--------------------------------------------------------------------------------
#  Compute the best tick interval length to achieve a specified number of tick
#  intervals:
#--------------------------------------------------------------------------------

def tick_intervals ( data_low, data_high, intervals ):
    """ Computes the best tick interval length to achieve a specified number of
    tick intervals.

    Parameters
    ----------
    data_low, data_high : number
        The minimum and maximum values of the data along this axis.
        If any of the bound settings are 'auto' or 'fit', the axis
        traits are calculated automatically from these values.
    intervals : number
        The desired number of intervals

    Returns
    -------
    Returns a float indicating the tick interval length.
    """
    range     = float( data_high - data_low )
    if range == 0.0:
        range = 1.0
    interval  = range / intervals
    factor    = 10.0 ** floor( log10( interval ) )
    interval /= factor

    if interval < 2.0:
        interval = 2.0
        index    = 0
    elif interval < 2.5:
        interval = 2.5
        index    = 1
    elif interval < 5.0:
        interval = 5.0
        index    = 2
    else:
        interval = 10.0
        index    = 3

    while True:
        result = interval * factor
        if ((floor( data_low / result ) * result) + (intervals * result) >=
             data_high):
            return result
        index     = (index + 1) % 4
        interval *= ( 2.0, 1.25, 2.0, 2.0 )[ index ]



def log_auto_ticks(data_low, data_high,
                   bound_low, bound_high,
                   tick_interval, use_endpoints = True):
    """Like auto_ticks(), but for log scales."""
    tick_goal = 15
    magic_numbers = [1, 2, 5]
    explicit_ticks = False

    if data_low<=0.0:
        return []

    if tick_interval != 'auto':
        if tick_interval < 0:
            tick_goal = -tick_interval
        else:
            magic_numbers = [tick_interval]
            explicit_ticks = True

    if data_low>data_high:
        data_low, data_high = data_high, data_low

    log_low = log10(data_low)
    log_high = log10(data_high)
    log_interval = log_high-log_low

    if log_interval < 1.0:
        # If less than a factor of 10 separates the data, just use the normal
        # linear approach
        return auto_ticks(data_low, data_high,
                          bound_low, bound_high,
                          tick_interval,
                          use_endpoints = False)

    elif log_interval < (tick_goal+1)/2 or explicit_ticks:
        # If there's enough space, try to put lines at the magic number multipliers
        # inside each power of ten

        # Try each interval to see how many ticks we get
        for interval in magic_numbers:
            ticklist = []
            for exp in range(int(floor(log_low)), int(ceil(log_high))):
                for multiplier in linspace(interval, 10.0, round(10.0/interval),
                                           endpoint=1):
                    tick = 10**exp*multiplier
                    if tick >= data_low and tick <= data_high:
                        ticklist.append(tick)
            if len(ticklist)<tick_goal+3 or explicit_ticks:
                return ticklist
    else:
        # We put lines at every power of ten or less
        startlog = ceil(log_low)
        endlog = floor(log_high)
        interval = ceil((endlog-startlog)/9.0)
        expticks = arange(startlog, endlog, interval)
        # There's no function that is like arange but inclusive, so
        # we have to check whether the endpoint should be included.
        if (endlog-startlog) % interval == 0.0:
            expticks = concatenate([expticks, [endlog]])
        return 10**expticks


#-------------------------------------------------------------------------------
#  Compute the best lower and upper axis bounds for a range of data:
#-------------------------------------------------------------------------------

def auto_bounds ( data_low, data_high, tick_interval ):
    """ Calculates appropriate upper and lower bounds for the axis from
        the data bounds and the given axis interval.

        The boundaries  hit either exactly on the lower and upper values
        or on the tick mark just beyond the lower and upper values.
    """
    return ( calc_bound( data_low,  tick_interval, False ),
             calc_bound( data_high, tick_interval, True  ) )

#-------------------------------------------------------------------------------
#  Compute the best axis endpoint for a specified data value:
#-------------------------------------------------------------------------------

def calc_bound ( end_point, tick_interval, is_upper ):
    """ Finds an axis end point that includes the value *end_point*.

    If the tick mark interval results in a tick mark hitting directly on the
    end point, *end_point* is returned.  Otherwise, the location of the tick
    mark just past *end_point* is returned. The *is_upper* parameter
    specifies whether *end_point* is at the upper (True) or lower (False)
    end of the axis.
    """
    quotient, remainder = divmod( end_point, tick_interval )
    if ((remainder == 0.0) or
        (((tick_interval - remainder) / tick_interval) < 0.00001)):
        return end_point

    c1 = (quotient + 1.0) * tick_interval
    c2 = quotient         * tick_interval
    if is_upper:
        return max( c1, c2 )
    return min( c1, c2 )

########NEW FILE########
__FILENAME__ = toolbar_plot
from chaco.api import Plot
from chaco.tools.toolbars.plot_toolbar import PlotToolbar
from traits.api import Type, DelegatesTo, Instance, Enum, \
        on_trait_change

class ToolbarPlot(Plot):
    # Should we turn on the auto-hide feature on the toolbar?
    auto_hide = DelegatesTo('toolbar')

    toolbar = Instance(PlotToolbar)

    toolbar_class = Type(PlotToolbar)
    toolbar_added = False

    # Location of the default toolbar that is created if a toolbar
    # is not specified with the `toolbar` attribute.  Changing this
    # attribute after the ToolbarPlot instance is created has no effect;
    # use obj.toolbar.location to dynamically change the location of the
    # instance `obj`s toolbar.
    toolbar_location = Enum('top', 'right', 'bottom', 'left')

    def __init__(self, *args, **kw):

        # initialize the toolbar class before super() has a chance to create
        # the default using the default class. This can happen because of
        # ordering issues

        if "toolbar_class" in kw:
            self.toolbar_class = kw.pop("toolbar_class")

        super(ToolbarPlot, self).__init__(*args, **kw)

        self.toolbar.component = self
        self.add_toolbar()

    def _toolbar_default(self):
        return self.toolbar_class(self, location=self.toolbar_location)

    def add_toolbar(self):
        if not self.toolbar_added:
            self.overlays.append(self.toolbar)
            self.toolbar_added = True
            self.request_redraw()

    def remove_toolbar(self):
        if self.toolbar_added and self.auto_hide:
            self.overlays.remove(self.toolbar)
            self.toolbar_added = False
            self.request_redraw()

    def _bounds_changed(self, old, new):
        self.toolbar.do_layout(force=True)
        super(ToolbarPlot, self)._bounds_changed(old, new)

    @on_trait_change('toolbar')
    def _toolbar_changed(self, name, obj, old, new):
        if self.toolbar_added:
            # fixup the new toolbar's component to match the old one
            new.component = old.component

            self.overlays.remove(old)
            self.toolbar_added = False
            self.add_toolbar()

########NEW FILE########
__FILENAME__ = api
from better_zoom import BetterZoom
from better_selecting_zoom import BetterSelectingZoom
from broadcaster import BroadcasterTool
from dataprinter import DataPrinter
from data_label_tool import DataLabelTool
from enable.tools.drag_tool import DragTool
from draw_points_tool import DrawPointsTool
from drag_zoom import DragZoom
from highlight_tool import HighlightTool
from image_inspector_tool import ImageInspectorTool, ImageInspectorOverlay
from lasso_selection import LassoSelection
from legend_tool import LegendTool
from legend_highlighter import LegendHighlighter
from line_inspector import LineInspector
from line_segment_tool import LineSegmentTool
from move_tool import MoveTool
from pan_tool import PanTool
from point_marker import PointMarker
from range_selection import RangeSelection
from range_selection_2d import RangeSelection2D
from range_selection_overlay import RangeSelectionOverlay
from regression_lasso import RegressionLasso, RegressionOverlay
from save_tool import SaveTool
from scatter_inspector import ScatterInspector
from select_tool import SelectTool
from simple_inspector import SimpleInspectorTool
from tool_states import ZoomState, PanState, GroupedToolState, SelectedZoomState
from tracking_pan_tool import TrackingPanTool
from tracking_zoom import TrackingZoom
from traits_tool import TraitsTool
from zoom_tool import ZoomTool
# EOF

########NEW FILE########
__FILENAME__ = base_zoom_tool
""" Defines the base class for various types of zoom tools.
"""
import warnings
warnings.warn("BaseZoomTool has been deprecated, use BetterZoomTool", DeprecationWarning)


from numpy import allclose, inf

# Enthought library imports
from traits.api import Enum, Float, HasTraits

class BaseZoomTool(HasTraits):
    """ Defines traits and methods to actually perform the logic of zooming
    onto a plot.
    """

    # If the tool only applies to a particular axis, this attribute is used to
    # determine which mapper and range to use.
    axis = Enum("index", "value")

    # The maximum ratio between the original data space bounds and the zoomed-in
    # data space bounds.  If None, then there is no limit (not advisable!).
    max_zoom_in_factor = Float(1e5, allow_none=True)

    # The maximum ratio between the zoomed-out data space bounds and the original
    # bounds.  If None, then there is no limit.
    max_zoom_out_factor = Float(1e5, allow_none=True)

    def _zoom_limit_reached(self, orig_low, orig_high, new_low, new_high, mapper=None):
        """ Returns True if the new low and high exceed the maximum zoom
        limits
        """
        orig_bounds = orig_high - orig_low

        if orig_bounds == inf:
            # There isn't really a good way to handle the case when the
            # original bounds were infinite, since any finite zoom
            # range will certainly exceed whatever zoom factor is set.
            # If this is the case, we skip the zoom factor checks,
            # and move on to the domain limits checks
            pass
        else:
            new_bounds = new_high - new_low
            if allclose(orig_bounds, 0.0):
                return True
            if allclose(new_bounds, 0.0):
                return True
            if (new_bounds / orig_bounds) > self.max_zoom_out_factor or \
               (orig_bounds / new_bounds) > self.max_zoom_in_factor:
                return True

        return False

    #------------------------------------------------------------------------
    # Utility methods for computing axes, coordinates, etc.
    #------------------------------------------------------------------------

    def _get_mapper(self):
        """ Returns the mapper for the component associated with this tool.

        The zoom tool really only cares about this, so subclasses can easily
        customize SimpleZoom to work with all sorts of components just by
        overriding this method.
        """
        if self.component is not None:
            return getattr(self.component, self.axis + "_mapper")
        else:
            return None


    def _get_axis_coord(self, event, axis="index"):
        """ Returns the coordinate of the event along the axis of interest
        to the tool (or along the orthogonal axis, if axis="value").
        """
        event_pos = (event.x, event.y)
        if axis == "index":
            return event_pos[ self._determine_axis() ]
        else:
            return event_pos[ 1 - self._determine_axis() ]

    def _determine_axis(self):
        """ Determines whether the index of the coordinate along the axis of
        interest is the first or second element of an (x,y) coordinate tuple.
        """
        if self.axis == "index":
            if self.component.orientation == "h":
                return 0
            else:
                return 1
        else:   # self.axis == "value"
            if self.component.orientation == "h":
                return 1
            else:
                return 0

    def _map_coordinate_box(self, start, end):
        """ Given start and end points in screen space, returns corresponding
        low and high points in data space.
        """
        low = [0,0]
        high = [0,0]
        for axis_index, mapper in [(0, self.component.x_mapper), \
                                   (1, self.component.y_mapper)]:
            low_val = mapper.map_data(start[axis_index])
            high_val = mapper.map_data(end[axis_index])

            if low_val > high_val:
                low_val, high_val = high_val, low_val
            low[axis_index] = low_val
            high[axis_index] = high_val
        return low, high


########NEW FILE########
__FILENAME__ = better_selecting_zoom
from __future__ import with_statement

import numpy

from chaco.abstract_overlay import AbstractOverlay
from enable.api import ColorTrait, KeySpec
from traits.api import Bool, Enum, Trait, Int, Float, Tuple, Instance, Property
from traits.util.deprecated import deprecated

from better_zoom import BetterZoom
from tool_states import SelectedZoomState

class BetterSelectingZoom(AbstractOverlay, BetterZoom):
    """ Zooming tool which allows the user to draw a box which defines the
        desired region to zoom in to
    """

    # The selection mode:
    #
    # range:
    #   Select a range across a single index or value axis.
    # box:
    #   Perform a "box" selection on two axes.
    tool_mode = Enum("box", "range")

    # Is the tool always "on"? If True, left-clicking always initiates
    # a zoom operation; if False, the user must press a key to enter zoom mode.
    always_on = Bool(False)

    # Defines a meta-key, that works with always_on to set the zoom mode. This
    # is useful when the zoom tool is used in conjunction with the pan tool.
    always_on_modifier = Enum('control', 'shift', 'control', 'alt')

    # The mouse button that initiates the drag.  If "None", then the tool
    # will not respond to drag.  (It can still respond to mousewheel events.)
    drag_button = Enum("left", "right", None)

    # The minimum amount of screen space the user must select in order for
    # the tool to actually take effect.
    minimum_screen_delta = Int(10)


    #-------------------------------------------------------------------------
    # deprecated interaction controls, used for API compatability with
    # SimpleZoom
    #-------------------------------------------------------------------------

    # Conversion ratio from wheel steps to zoom factors.
    wheel_zoom_step = Property(Float, depends_on='zoom_factor')

    # The key press to enter zoom mode, if **always_on** is False.  Has no effect
    # if **always_on** is True.
    enter_zoom_key = Instance(KeySpec, args=("z",))

    # The key press to leave zoom mode, if **always_on** is False.  Has no effect
    # if **always_on** is True.
    exit_zoom_key = Instance(KeySpec, args=("z",))

    # Disable the tool after the zoom is completed?
    disable_on_complete = Property()


    #-------------------------------------------------------------------------
    # Appearance properties (for Box mode)
    #-------------------------------------------------------------------------

    # The pointer to use when drawing a zoom box.
    pointer = "magnifier"

    # The color of the selection box.
    color = ColorTrait("lightskyblue")

    # The alpha value to apply to **color** when filling in the selection
    # region.  Because it is almost certainly useless to have an opaque zoom
    # rectangle, but it's also extremely useful to be able to use the normal
    # named colors from Enable, this attribute allows the specification of a
    # separate alpha value that replaces the alpha value of **color** at draw
    # time.
    alpha = Trait(0.4, None, Float)

    # The color of the outside selection rectangle.
    border_color = ColorTrait("dodgerblue")

    # The thickness of selection rectangle border.
    border_size = Int(1)

    # The possible event states of this zoom tool.
    event_state = Enum("normal", "selecting", "pre_selecting")

    # The (x,y) screen point where the mouse went down.
    _screen_start = Trait(None, None, Tuple)

    # The (x,,y) screen point of the last seen mouse move event.
    _screen_end = Trait(None, None, Tuple)

    # If **always_on** is False, this attribute indicates whether the tool
    # is currently enabled.
    _enabled = Bool(False)

    #-------------------------------------------------------------------------
    # Private traits
    #-------------------------------------------------------------------------

    # the original numerical screen ranges
    _orig_low_setting = Tuple
    _orig_high_setting = Tuple

    def __init__(self, component=None, *args, **kw):
        # Since this class uses multiple inheritance (eek!), lets be
        # explicit about the order of the parent class constructors
        AbstractOverlay.__init__(self, component, *args, **kw)
        BetterZoom.__init__(self, component, *args, **kw)
        # Store the original range settings
        x_range = self._get_x_mapper().range
        y_range = self._get_y_mapper().range
        self._orig_low_setting = (x_range.low_setting, y_range.low_setting)
        self._orig_high_setting = (x_range.high_setting, y_range.high_setting)

    def reset(self, event=None):
        """ Resets the tool to normal state, with no start or end position.
        """
        self.event_state = "normal"
        self._screen_start = None
        self._screen_end = None

    #--------------------------------------------------------------------------
    #  BetterZoom interface
    #--------------------------------------------------------------------------

    def normal_key_pressed(self, event):
        """ Handles a key being pressed when the tool is in the 'normal'
        state.
        """
        if not self.always_on:
            if self.enter_zoom_key.match(event) and not self._enabled:
                self.event_state = 'pre_selecting'
                event.window.set_pointer(self.pointer)
                event.window.set_mouse_owner(self, event.net_transform())
                self._enabled = True
                event.handled = True
            elif self.exit_zoom_key.match(event) and self._enabled:
                self.state = 'normal'
                self._end_select(event)
                event.handled = True

        if not event.handled:
            super(BetterSelectingZoom, self).normal_key_pressed(event)

    def normal_left_down(self, event):
        """ Handles the left mouse button being pressed while the tool is
        in the 'normal' state.

        If the tool is enabled or always on, it starts selecting.
        """
        if self._is_enabling_event(event):
            self._start_select(event)
            event.handled = True

        return

    def normal_right_down(self, event):
        """ Handles the right mouse button being pressed while the tool is
        in the 'normal' state.

        If the tool is enabled or always on, it starts selecting.
        """
        if self._is_enabling_event(event):
            self._start_select(event)
            event.handled = True

        return

    def pre_selecting_left_down(self, event):
        """ The user pressed the key to turn on the zoom mode,
            now handle the click to start the select mode
        """
        self._start_select(event)
        event.handled = True

    def pre_selecting_key_pressed(self, event):
        """ Handle key presses, specifically the exit zoom key
        """
        if self.exit_zoom_key.match(event) and self._enabled:
            self._end_selecting(event)

    def selecting_key_pressed(self, event):
        """ Handle key presses, specifically the exit zoom key
        """
        if self.exit_zoom_key.match(event) and self._enabled:
            self._end_selecting(event)

    def selecting_mouse_move(self, event):
        """ Handles the mouse moving when the tool is in the 'selecting' state.

        The selection is extended to the current mouse position.
        """
        # Take into account when we update the current endpoint, but only
        # if we are in box select mode.  The way we handle aspect ratio
        # is to find the largest rectangle of the specified aspect which
        # will fit within the rectangle defined by the start coords and
        # the current mouse position.
        if self.tool_mode == "box" and self.aspect_ratio is not None:
            x1, y1 = self._screen_start
            x2, y2 = event.x, event.y
            if (y2 - y1) == 0:
                x2 = x1
                y2 = y1
            else:
                width = abs(x2 - x1)
                height = abs(y2 - y1)
                drawn_aspect = width / height
                if drawn_aspect > self.aspect_ratio:
                    # Drawn box is wider, so use its height to compute the
                    # restricted width
                    x2 = x1 + height * self.aspect_ratio * (1 if x2 > x1 else -1)
                else:
                    # Drawn box is taller, so use its width to compute the
                    # restricted height
                    y2 = y1 + width / self.aspect_ratio * (1 if y2 > y1 else -1)
            self._screen_end = (x2, y2)
        else:
            self._screen_end = (event.x, event.y)
        self.component.request_redraw()
        event.handled = True
        return

    def selecting_left_up(self, event):
        """ Handles the left mouse button being released when the tool is in
        the 'selecting' state.

        Finishes selecting and does the zoom.
        """
        if self.drag_button in ("left", None):
            self._end_select(event)
        return

    def selecting_right_up(self, event):
        """ Handles the right mouse button being released when the tool is in
        the 'selecting' state.

        Finishes selecting and does the zoom.
        """
        if self.drag_button == "right":
            self._end_select(event)
        return

    def selecting_mouse_leave(self, event):
        """ Handles the mouse leaving the plot when the tool is in the
        'selecting' state.

        Ends the selection operation without zooming.
        """
        self._end_selecting(event)
        return

    #--------------------------------------------------------------------------
    #  AbstractOverlay interface
    #--------------------------------------------------------------------------

    def overlay(self, component, gc, view_bounds=None, mode="normal"):
        """ Draws this component overlaid on another component.

        Overrides AbstractOverlay.
        """
        if self.event_state == "selecting":
            if self.tool_mode == "range":
                self._overlay_range(component, gc)
            else:
                self._overlay_box(component, gc)
        return

    #--------------------------------------------------------------------------
    #  private interface
    #--------------------------------------------------------------------------

    @deprecated
    def _get_disable_on_complete(self):
        return True

    @deprecated
    def _set_disable_on_complete(self, value):
        return

    @deprecated
    def _get_wheel_zoom_step(self):
        return self.zoom_factor - 1.0

    @deprecated
    def _set_wheel_zoom_step(self, value):
        self.zoom_factor = value + 1.0

    def _is_enabling_event(self, event):
        if self.always_on:
            enabled = True
        else:
            if self.always_on_modifier == 'shift':
                enabled = event.shift_down
            elif self.always_on_modifier == 'control':
                enabled = event.control_down
            elif self.always_on_modifier == 'alt':
                enabled = event.alt_down

        if enabled:
            if event.right_down and self.drag_button == 'right':
                return True
            if event.left_down and self.drag_button == 'left':
                return True

        return False

    def _start_select(self, event):
        """ Starts selecting the zoom region
        """
        if self.component.active_tool in (None, self):
            self.component.active_tool = self
        else:
            self._enabled = False
        self._screen_start = (event.x, event.y)
        self._screen_end = None
        self.event_state = "selecting"
        event.window.set_pointer(self.pointer)
        event.window.set_mouse_owner(self, event.net_transform())
        self.selecting_mouse_move(event)
        return

    def _end_select(self, event):
        """ Ends selection of the zoom region, adds the new zoom range to
        the zoom stack, and does the zoom.
        """
        self._screen_end = (event.x, event.y)

        start = numpy.array(self._screen_start)
        end = numpy.array(self._screen_end)

        if sum(abs(end - start)) < self.minimum_screen_delta:
            self._end_selecting(event)
            event.handled = True
            return

        low, high = self._map_coordinate_box(self._screen_start, self._screen_end)

        x_range = self._get_x_mapper().range
        y_range = self._get_y_mapper().range

        prev = (x_range.low, x_range.high, y_range.low, y_range.high)

        if self.tool_mode == 'range':
            axis = self._determine_axis()
            if axis == 1:
                # vertical
                next = (x_range.low, x_range.high, low[1], high[1])
            else:
                # horizontal
                next = (low[0], high[0], y_range.low, y_range.high)

        else:
            next = (low[0], high[0], low[1], high[1])

        zoom_state = SelectedZoomState(prev, next)
        zoom_state.apply(self)
        self._append_state(zoom_state)

        self._end_selecting(event)
        event.handled = True
        return

    def _end_selecting(self, event=None):
        """ Ends selection of zoom region, without zooming.
        """
        self.reset()
        self._enabled = False
        if self.component.active_tool == self:
            self.component.active_tool = None
        if event and event.window:
            event.window.set_pointer("arrow")

        self.component.request_redraw()
        if event and event.window.mouse_owner == self:
            event.window.set_mouse_owner(None)
        return

    def _overlay_box(self, component, gc):
        """ Draws the overlay as a box.
        """
        if self._screen_start and self._screen_end:
            with gc:
                gc.set_antialias(0)
                gc.set_line_width(self.border_size)
                gc.set_stroke_color(self.border_color_)
                gc.clip_to_rect(component.x, component.y, component.width, component.height)
                x, y = self._screen_start
                x2, y2 = self._screen_end
                rect = (x, y, x2-x+1, y2-y+1)
                if self.color != "transparent":
                    if self.alpha:
                        color = list(self.color_)
                        if len(color) == 4:
                            color[3] = self.alpha
                        else:
                            color += [self.alpha]
                    else:
                        color = self.color_
                    gc.set_fill_color(color)
                    gc.draw_rect(rect)
                else:
                    gc.rect(*rect)
                    gc.stroke_path()
        return

    def _overlay_range(self, component, gc):
        """ Draws the overlay as a range.
        """
        axis_ndx = self._determine_axis()
        lower_left = [0,0]
        upper_right = [0,0]
        lower_left[axis_ndx] = self._screen_start[axis_ndx]
        lower_left[1-axis_ndx] = self.component.position[1-axis_ndx]
        upper_right[axis_ndx] = self._screen_end[axis_ndx] - self._screen_start[axis_ndx]
        upper_right[1-axis_ndx] = self.component.bounds[1-axis_ndx]

        with gc:
            gc.set_antialias(0)
            gc.set_alpha(self.alpha)
            gc.set_fill_color(self.color_)
            gc.set_stroke_color(self.border_color_)
            gc.clip_to_rect(component.x, component.y, component.width, component.height)
            gc.draw_rect((lower_left[0], lower_left[1], upper_right[0], upper_right[1]))

        return

    def _determine_axis(self):
        """ Determines whether the index of the coordinate along the axis of
        interest is the first or second element of an (x,y) coordinate tuple.
        """
        if self.axis == "index":
            if self.component.orientation == "h":
                return 0
            else:
                return 1
        else:
            if self.component.orientation == "h":
                return 1
            else:
                return 0

    def _map_coordinate_box(self, start, end):
        """ Given start and end points in screen space, returns corresponding
        low and high points in data space.
        """
        low = [0,0]
        high = [0,0]
        for axis_index, mapper in [(0, self.component.x_mapper), \
                                   (1, self.component.y_mapper)]:
            # Ignore missing axis mappers (ColorBar instances only have one).
            if not mapper:
                continue
            low_val = mapper.map_data(start[axis_index])
            high_val = mapper.map_data(end[axis_index])

            if low_val > high_val:
                low_val, high_val = high_val, low_val
            low[axis_index] = low_val
            high[axis_index] = high_val
        return low, high

    def _reset_range_settings(self):
        """ Reset the range settings to their original values """
        x_range = self._get_x_mapper().range
        y_range = self._get_y_mapper().range
        x_range.low_setting, y_range.low_setting = self._orig_low_setting
        x_range.high_setting, y_range.high_setting = self._orig_high_setting

    #--------------------------------------------------------------------------
    #  overloaded
    #--------------------------------------------------------------------------

    def _prev_state_pressed(self):
        super(BetterSelectingZoom, self)._prev_state_pressed()
        # Reset the range settings
        if self._history_index == 0:
            self._reset_range_settings()

    def _reset_state_pressed(self):
        super(BetterSelectingZoom, self)._reset_state_pressed()
        # Reset the range settings
        self._reset_range_settings()

########NEW FILE########
__FILENAME__ = better_zoom
import numpy

from chaco.grid_mapper import GridMapper
from enable.api import BaseTool, KeySpec
from traits.api import Enum, Float, Instance, Bool, HasTraits, List

from tool_history_mixin import ToolHistoryMixin
from tool_states import ZoomState, PanState, GroupedToolState, ToolState


class BetterZoom(BaseTool, ToolHistoryMixin):

    # Keys to zoom in/out
    zoom_in_key = Instance(KeySpec, args=("+",), kw={'ignore': ['shift']})
    zoom_out_key = Instance(KeySpec, args=("-",))

    # Keys to zoom in/out in x direction only
    zoom_in_x_key = Instance(KeySpec, args=("Right", "shift"))
    zoom_out_x_key = Instance(KeySpec, args=("Left", "shift"))

    # Keys to zoom in/out in y direction only
    zoom_in_y_key = Instance(KeySpec, args=("Up", "shift"))
    zoom_out_y_key = Instance(KeySpec, args=("Down", "shift"))

    # Key to go to the previous state in the history.
    prev_state_key = Instance(KeySpec, args=("z", "control"))

    # Key to go to the next state in the history.
    next_state_key = Instance(KeySpec, args=("y", "control"))

    # Enable the mousewheel for zooming?
    enable_wheel = Bool(True)

    # if the mouse pointer should be used to control the center
    # of the zoom action
    zoom_to_mouse = Bool(True)

    # if the mouse pointer should be used to control the center
    # of the zoom action even for key events based zoom
    keys_zoom_to_mouse = Bool(True)

    # The axis to which the selection made by this tool is perpendicular. This
    # only applies in 'range' mode.
    axis = Enum("both", "index", "value")

    # The maximum ratio between the original data space bounds and the zoomed-in
    # data space bounds.  If No limit is desired, set to inf
    x_max_zoom_factor = Float(1e5)
    y_max_zoom_factor = Float(1e5)

    # The maximum ratio between the zoomed-out data space bounds and the original
    # bounds.  If No limit is desired, set to -inf
    x_min_zoom_factor = Float(1e-5)
    y_min_zoom_factor = Float(1e-5)

    # The amount to zoom in by. The zoom out will be inversely proportional
    zoom_factor = Float(2.0)

    # The zoom factor on each axis
    _index_factor = Float(1.0)
    _value_factor = Float(1.0)

    # inherited from ToolHistoryMixin, but requires instances of ZoomState
    _history = List(ToolState, [ZoomState((1.0, 1.0), (1.0, 1.0))])

    def _do_zoom(self, new_index_factor, new_value_factor):
        if self.zoom_to_mouse:
            location = self.position
            x_map = self._get_x_mapper()
            y_map = self._get_y_mapper()

            cx = (x_map.range.high + x_map.range.low)/2
            if self._index_factor == new_index_factor:
                nextx = cx
            else:
                x = x_map.map_data(location[0])
                nextx = x + (cx - x)*(self._index_factor/new_index_factor)

            cy = (y_map.range.high + y_map.range.low)/2
            if self._value_factor == new_value_factor:
                nexty = cy
            else:
                y = y_map.map_data(location[1])
                nexty = y + (cy - y)*(self._value_factor/new_value_factor)

            pan_state = PanState((cx,cy), (nextx, nexty))
            zoom_state = ZoomState((self._index_factor, self._value_factor),
                                   (new_index_factor, new_value_factor))

            states = GroupedToolState([pan_state, zoom_state])
            states.apply(self)
            self._append_state(states)

        else:

            zoom_state = ZoomState((self._index_factor, self._value_factor),
                                   (new_index_factor, new_value_factor))

            zoom_state.apply(self)
            self._append_state(zoom_state)

    #--------------------------------------------------------------------------
    #  public interface
    #--------------------------------------------------------------------------

    def zoom_in(self, factor=0):
        if factor == 0:
            factor = self.zoom_factor

        new_index_factor = self._index_factor * factor
        new_value_factor = self._value_factor * factor

        if self.axis == 'value':
            new_index_factor = self._index_factor
        elif self.axis == 'index':
            new_value_factor = self._value_factor

        if self.component.orientation == 'h':
            if self._zoom_limit_reached(new_index_factor, 'x'):
                return
            if self._zoom_limit_reached(new_value_factor, 'y'):
                return
        else:
            if self._zoom_limit_reached(new_index_factor, 'y'):
                return
            if self._zoom_limit_reached(new_value_factor, 'x'):
                return
        self._do_zoom(new_index_factor, new_value_factor)

    def zoom_out(self, factor=0):
        if factor == 0:
            factor = self.zoom_factor

        new_index_factor = self._index_factor / factor
        new_value_factor = self._value_factor / factor

        if self.axis == 'value':
            new_index_factor = self._index_factor
        elif self.axis == 'index':
            new_value_factor = self._value_factor

        if self.component.orientation == 'h':
            if self._zoom_limit_reached(new_index_factor, 'x'):
                return
            if self._zoom_limit_reached(new_value_factor, 'y'):
                return
        else:
            if self._zoom_limit_reached(new_index_factor, 'y'):
                return
            if self._zoom_limit_reached(new_value_factor, 'x'):
                return

        self._do_zoom(new_index_factor, new_value_factor)

    def zoom_in_x(self, factor=0):
        if factor == 0:
            factor = self.zoom_factor

        if self.component.orientation == 'h':
            new_index_factor = self._index_factor * factor
            new_value_factor = self._value_factor
            if self._zoom_limit_reached(new_index_factor, 'x'):
                return
        else:
            new_index_factor = self._index_factor
            new_value_factor = self._value_factor * factor
            if self._zoom_limit_reached(new_value_factor, 'x'):
                return

        self._do_zoom(new_index_factor, new_value_factor)

    def zoom_out_x(self, factor=0):
        if factor == 0:
            factor = self.zoom_factor

        if self.component.orientation == 'h':
            new_index_factor = self._index_factor / factor
            new_value_factor = self._value_factor
            if self._zoom_limit_reached(new_index_factor, 'x'):
                return
        else:
            new_index_factor = self._index_factor
            new_value_factor = self._value_factor / factor
            if self._zoom_limit_reached(new_value_factor, 'x'):
                return
        self._do_zoom(new_index_factor, new_value_factor)


    def zoom_in_y(self, factor=0):
        if factor == 0:
            factor = self.zoom_factor

        if self.component.orientation == 'v':
            new_index_factor = self._index_factor * factor
            new_value_factor = self._value_factor
            if self._zoom_limit_reached(new_index_factor, 'y'):
                return
        else:
            new_index_factor = self._index_factor
            new_value_factor = self._value_factor * factor
            if self._zoom_limit_reached(new_value_factor, 'y'):
                return

        self._do_zoom(new_index_factor, new_value_factor)

    def zoom_out_y(self, factor=0):
        if factor == 0:
            factor = self.zoom_factor

        if self.component.orientation == 'v':
            new_index_factor = self._index_factor / factor
            new_value_factor = self._value_factor
            if self._zoom_limit_reached(new_index_factor, 'y'):
                return
        else:
            new_index_factor = self._index_factor
            new_value_factor = self._value_factor / factor
            if self._zoom_limit_reached(new_value_factor, 'y'):
                return

        self._do_zoom(new_index_factor, new_value_factor)

    #--------------------------------------------------------------------------
    #  BaseTool interface
    #--------------------------------------------------------------------------

    def normal_key_pressed(self, event):
        """ Handles a key being pressed when the tool is in the 'normal'
        state.
        """
        if not self.keys_zoom_to_mouse:
            self.position = self._center_screen()
        if self.zoom_in_key.match(event):
            self.zoom_in()
            event.handled = True
        elif self.zoom_out_key.match(event):
            self.zoom_out()
            event.handled = True
        elif self.zoom_in_x_key.match(event):
            self.zoom_in_x(self.zoom_factor)
            event.handled = True
        elif self.zoom_out_x_key.match(event):
            self.zoom_out_x(self.zoom_factor)
            event.handled = True
        elif self.zoom_in_y_key.match(event):
            self.zoom_in_y(self.zoom_factor)
            event.handled = True
        elif self.zoom_out_y_key.match(event):
            self.zoom_out_y(self.zoom_factor)
            event.handled = True

        ToolHistoryMixin.normal_key_pressed(self, event)

        return

    def normal_mouse_wheel(self, event):
        if not self.enable_wheel:
            return

        if event.mouse_wheel != 0:
            if event.mouse_wheel > 0:
                self.zoom_in()
            else:
                self.zoom_out()
            event.handled = True

    def normal_mouse_move(self, event):
        self.position = (event.x, event.y)

    def normal_mouse_enter(self, event):
        """ Try to set the focus to the window when the mouse enters, otherwise
            the keypress events will not be triggered.
        """
        if self.component._window is not None:
            self.component._window._set_focus()

    #--------------------------------------------------------------------------
    #  private interface
    #--------------------------------------------------------------------------

    def _center_screen(self):
        return self.component.bounds[0]/2, self.component.bounds[1]/2

    def _zoom_limit_reached(self, factor, xy_axis):
        """ Returns True if the new low and high exceed the maximum zoom
        limits
        """

        if xy_axis == 'x':
            if factor <= self.x_max_zoom_factor and factor >= self.x_min_zoom_factor:
                return False
            return True
        else:
            if factor <= self.y_max_zoom_factor and factor >= self.y_min_zoom_factor:
                return False
            return True

    def _zoom_in_mapper(self, mapper, factor):

        high = mapper.range.high
        low = mapper.range.low
        range = high-low

        center = (low + high)/2.0

        new_range = range/factor
        mapper.range.high = center + new_range/2
        mapper.range.low = center - new_range/2

    def _get_x_mapper(self):
        if isinstance(self.component.index_mapper, GridMapper):
            if self.component.orientation == "h":
                return self.component.index_mapper._xmapper
            return self.component.index_mapper._ymapper
        else:
            if self.component.orientation == "h":
                return self.component.index_mapper
            return self.component.value_mapper

    def _get_y_mapper(self):
        if isinstance(self.component.index_mapper, GridMapper):
            if self.component.orientation == "h":
                return self.component.index_mapper._ymapper
            return self.component.index_mapper._xmapper
        else:
            if self.component.orientation == "h":
                return self.component.value_mapper
            return self.component.index_mapper

    #--------------------------------------------------------------------------
    #  ToolHistoryMixin interface
    #--------------------------------------------------------------------------

    def _next_state_pressed(self):
        """ Called when the tool needs to advance to the next state in the
        stack.

        The **_history_index** will have already been set to the index
        corresponding to the next state.
        """

        self._current_state().apply(self)

    def _prev_state_pressed(self):
        """ Called when the tool needs to advance to the previous state in the
        stack.

        The **_history_index** will have already been set to the index
        corresponding to the previous state.
        """
        self._history[self._history_index+1].revert(self)

    def _reset_state_pressed(self):
        """ Called when the tool needs to reset its history.

        The history index will have already been set to 0.
        """
        for state in self._history[::-1]:
            state.revert(self)
        self._history = []

########NEW FILE########
__FILENAME__ = broadcaster
""" Defines the BroadcasterTool class.
"""
from enable.api import BaseTool
from traits.api import Dict, List

class BroadcasterTool(BaseTool):
    """ A simple tool that keeps a list of other tools, and broadcasts events it
    receives to all of the tools.
    """

    # The tools to which this tool broadcasts events.
    tools = List

    # Mapping from tools to transforms, for tools that can be mouse owners.
    # (See enable.AbstractWindow.)
    mouse_owners = Dict

    def dispatch(self, event, suffix):
        """ Dispatches a mouse event based on the current event state.

        Overrides BaseTool.
        """
        handled = False   # keeps track of whether any tool handled this event

        if event.window.mouse_owner == self:
            tools = self.mouse_owners.keys()
            mouse_owned = True
        else:
            tools = self.tools
            mouse_owned = False

        for tool in tools:
            if mouse_owned:
                event.window.set_mouse_owner(tool, self.mouse_owners[tool])

            tool.dispatch(event, suffix)
            if event.handled:
                handled = True
                event.handled = False

            if mouse_owned and event.window.mouse_owner is None:
                # The tool owned the mouse before handling the previous event,
                # and now doesn't, so remove it from the list of mouse_owners
                del self.mouse_owners[tool]

            elif not mouse_owned and event.window.mouse_owner == tool:
                # The tool is a new mouse owner
                self.mouse_owners[tool] = event.window.mouse_owner_transform

        if len(self.mouse_owners) == 0:
            if event.window.mouse_owner == self:
                event.window.set_mouse_owner(None)
        else:
            event.window.set_mouse_owner(self, event.net_transform())

        event.handled = handled

########NEW FILE########
__FILENAME__ = cursor_tool
"""
Defines some chaco tools to provide draggable cursor functionality

For XY-plots, the cursor tool requires the index_sort flag to be set
to either 'ascending' or 'descending'.

TODO:

- add some visual feedback to the user when a cursor is "grabbed"
    (e.g. highlight the cursor line)

- update cursor position to the "selections" metadata on the owning
    plot component

"""
from __future__ import with_statement

# Major library imports
import numpy

# Enthought library imports
from enable.tools.drag_tool import DragTool
from traits.api import Int, Property, cached_property, Float,\
                                Bool, Instance, Tuple, Disallow

# Chaco imports
from chaco.scatter_markers import CircleMarker
from chaco.base_xy_plot import BaseXYPlot
from chaco.base_2d_plot import Base2DPlot
from line_inspector import LineInspector


def CursorTool(component, *args, **kwds):
    """
    Factory function returning either a CursorTool1D or CursorTool2D instance
    depending on whether the provided plot component is an XY-plot or a 2D plot.
    """
    if isinstance(component, BaseXYPlot):
        return CursorTool1D(component, *args, **kwds)
    elif isinstance(component, Base2DPlot):
        return CursorTool2D(component, *args, **kwds)
    else:
        raise NotImplementedError("cursors available for BaseXYPlot and Base2DPlot only")


class BaseCursorTool(LineInspector, DragTool):
    """
    Abstract base class for CursorTool objects
    """

    #if true, draw a small circle at the cursor/line intersection
    show_marker = Bool(True)

    #the radius of the marker in pixels
    marker_size = Float(3.0)

    #the marker object. this should probably be private
    marker = Instance(CircleMarker, ())

    #pick threshold, in screen units (pixels)
    threshold = Float(5.0)

    #The current index-value of the cursor. Over-ridden in subclasses
    current_index = Disallow

    #The current position of the cursor in data units
    current_position = Property(depends_on=['current_index'])

    #Stuff from line_inspector which is not required
    axis = Disallow
    inspect_mode = Disallow
    is_interactive = Disallow
    is_listener = Disallow
    write_metadata = Disallow
    metadata_name = Disallow

    def _draw_marker(self, gc, sx, sy):
        """
        Ruthlessly hijacked from the scatterplot.py class. This design is silly; the
        choice of rendering path should be encapsulated within the GC.
        """
        if sx < self.component.x or sx > self.component.x2 or \
            sy < self.component.y or sy > self.component.y2:
            return

        marker = self.marker
        marker_size = self.marker_size
        points = [(sx,sy)]

        with gc:
            gc.set_fill_color(self.color_)

            gc.begin_path()

            # This is the fastest method - use one of the kiva built-in markers
            if hasattr(gc, "draw_marker_at_points") \
                and (gc.draw_marker_at_points(points,
                                              marker_size,
                                              marker.kiva_marker) != 0):
                    pass

            # The second fastest method - draw the path into a compiled path, then
            # draw the compiled path at each point
            elif hasattr(gc, 'draw_path_at_points'):
                #if debug:
                #    import pdb; pdb.set_trace()
                path = gc.get_empty_path()
                marker.add_to_path(path, marker_size)
                mode = marker.draw_mode
                if not marker.antialias:
                    gc.set_antialias(False)
                gc.draw_path_at_points(points, path, mode)

            # Neither of the fast functions worked, so use the brute-force, manual way
            else:
                if not marker.antialias:
                    gc.set_antialias(False)
                for sx,sy in points:
                    with gc:
                        gc.translate_ctm(sx, sy)
                        # Kiva GCs have a path-drawing interface
                        marker.add_to_path(gc, marker_size)
                        gc.draw_path(marker.draw_mode)
        return

    def normal_mouse_move(self, event):
        """ Handles the mouse being moved.
        """
        return

    def normal_mouse_leave(self, event):
        """ Handles the mouse leaving the plot.
        """
        return


class CursorTool1D(BaseCursorTool):
    """
    This tools provides a draggable cursor bound to a XY plot component instance.

    Note, be sure to select an drag_button which does not conflict with other tools
    (e.g. the PanTool).

    """

    #The current index-value of the cursor
    current_index = Int(0)


    #if true, draws a line parallel to the index-axis
    #through the cursor intersection point
    show_value_line = Bool(True)

    def _current_index_changed(self):
        self.component.request_redraw()

    @cached_property
    def _get_current_position(self):
        plot = self.component
        ndx = self.current_index
        x = plot.index.get_data()[ndx]
        y = plot.value.get_data()[ndx]
        return x,y

    def _set_current_position(self, traitname, args):
        plot = self.component
        ndx = plot.index.reverse_map(args[0])
        if ndx is not None:
            self.current_index = ndx

    def draw(self, gc, view_bounds=None):
        """ Draws this tool on a graphics context.

        Overrides LineInspector, BaseTool.
        """
        # We draw at different points depending on whether or not we are
        # interactive.  If both listener and interactive are true, then the
        # selection metadata on the plot component takes precendence.
        plot = self.component
        if plot is None:
            return

        sx, sy = plot.map_screen(self.current_position)
        orientation = plot.orientation

        if orientation == "h" and sx is not None:
            self._draw_vertical_line(gc, sx)
        elif sy is not None:
            self._draw_horizontal_line(gc, sy)

        if self.show_marker:
            self._draw_marker(gc, sx, sy)

        if self.show_value_line:
            if orientation == "h" and sy is not None:
                self._draw_horizontal_line(gc, sy)
            elif sx is not None:
                self._draw_vertical_line(gc, sx)

    def is_draggable(self, x, y):
        plot = self.component
        if plot is not None:
            orientation = plot.orientation
            sx, sy = plot.map_screen(self.current_position)
            if orientation=='h' and numpy.abs(sx-x) <= self.threshold:
                return True
            elif orientation=='v' and numpy.abs(sy-y) <= self.threshold:
                return True
        return False

    def dragging(self, event):
        x,y = event.x, event.y
        plot = self.component
        ndx = plot.map_index((x, y), threshold=0.0, index_only=True)
        if ndx is None:
            return
        self.current_index = ndx
        plot.request_redraw()


class CursorTool2D(BaseCursorTool):
    _dragV = Bool(False)
    _dragH = Bool(False)

    current_index = Tuple(0,0)

    def _current_index_changed(self):
        self.component.request_redraw()

    @cached_property
    def _get_current_position(self):
        plot = self.component
        ndx, ndy = self.current_index
        xdata, ydata = plot.index.get_data()
        x = xdata.get_data()[ndx]
        y = ydata.get_data()[ndy]
        return x,y

    def _set_current_position(self, traitname, args):
        plot = self.component
        xds, yds = plot.index.get_data()
        ndx = xds.reverse_map(args[0])
        ndy = yds.reverse_map(args[1])
        if ndx is not None and ndy is not None:
            self.current_index = ndx, ndy

    def is_draggable(self, x, y):
        plot = self.component
        if plot is not None:
            orientation = plot.orientation
            sx, sy = plot.map_screen([self.current_position])[0]
            self._dragV = self._dragH = False
            if orientation=='h':
                if numpy.abs(sx-x) <= self.threshold:
                    self._dragH = True
                if numpy.abs(sy-y) <= self.threshold:
                    self._dragV = True
            else:
                if numpy.abs(sx-x) <= self.threshold:
                    self._dragV = True
                if numpy.abs(sy-y) <= self.threshold:
                    self._dragH = True
            return self._dragV or self._dragH
        return False

    def draw(self, gc, view_bounds=None):
        """ Draws this tool on a graphics context.

        Overrides LineInspector, BaseTool.
        """
        # We draw at different points depending on whether or not we are
        # interactive.  If both listener and interactive are true, then the
        # selection metadata on the plot component takes precendence.
        plot = self.component
        if plot is None:
            return
        sx, sy = plot.map_screen([self.current_position])[0]
        orientation = plot.orientation

        if orientation == "h":
            if sx is not None:
                self._draw_vertical_line(gc, sx)
            if sy is not None:
                self._draw_horizontal_line(gc, sy)
        else:
            if sx is not None:
                self._draw_horizontal_line(gc, sx)
            if sy is not None:
                self._draw_vertical_line(gc, sy)

        if self.show_marker and sx is not None and sy is not None:
            self._draw_marker(gc, sx, sy)

    def dragging(self, event):
        x,y = event.x, event.y
        plot = self.component
        ndx = plot.map_index((x, y), threshold=0.0, index_only=True)
        if ndx is None:
            return
        newx, newy = self.current_index
        if self._dragH and ndx[0] is not None:
            newx = ndx[0]
        if self._dragV and ndx[1] is not None:
            newy = ndx[1]
        self.current_index = newx, newy
        plot.request_redraw()

########NEW FILE########
__FILENAME__ = dataprinter
""" Defines the DataPrinter tool class.
"""
# Enthought library imports
from traits.api import Str
from enable.api import BaseTool

# Chaco imports
from chaco.api import BaseXYPlot


class DataPrinter(BaseTool):
    """ Simple listener tool that prints the (x,y) data space position of the
    point under the cursor.
    """

    # This tool is a listener, and does not display anything (overrides BaseTool).
    visible = False

    # Turn off drawing, because the tool prints to stdout.
    draw_mode = "none"

    # The string to format the (x,y) value in data space.
    format = Str("(%.3f, %.3f)")

    def normal_mouse_move(self, event):
        """ Handles the mouse being moved in the 'normal' state.

        Prints the data space position of the current mouse position.
        """
        plot = self.component
        if plot is not None:
            if isinstance(plot, BaseXYPlot):
                ndx = plot.map_index((event.x, event.y), index_only = True)
                x = plot.index.get_data()[ndx]
                y = plot.value.get_data()[ndx]
                print self.format % (x,y)
            else:
                print "dataprinter: don't know how to handle plots of type",
                print plot.__class__.__name__
        return


# EOF

########NEW FILE########
__FILENAME__ = data_label_tool
""" Defines the DataLabelTool class.
"""
# Major library imports
from numpy import array, asarray, argmin, sqrt

# Enthought library imports
from traits.api import Any, Bool, Enum
from enable.tools.drag_tool import DragTool


class DataLabelTool(DragTool):
    """ A tool for dragging a data label.

    Attach this tool to a DataLabel object by setting the tool's **component**
    to the DataLabel.
    """

    # The mouse button that initiates the drag.
    drag_button = Enum("left", "right")

    # Use the root of the label's arrow (if any) as the closest corner of the
    # label?
    auto_arrow_root = Bool(True)

    # The original position of the label with respect to the data point.
    _original_offset = Any

    # This is used in the auto_arrow_root = 'corners' case.
    _corner_names = ("bottom left", "bottom right", "top right", "top left",
                     "top center", "bottom center", "left center", "right center")

    def is_draggable(self, x, y):
        """ Returns whether the (x,y) position is in a region that is OK to
        drag.

        Overrides DragTool.
        """
        if self.component:
            label = self.component
            return (x >= label.x and x <= label.x2 and \
                    y >= label.y and y <= label.y2)
        else:
            return False


    def drag_start(self, event):
        """ Called when the drag operation starts.

        Implements DragTool.
        """
        if self.component:
            label = self.component
            pointx, pointy = label.component.map_screen(label.data_point)
            self._original_offset = (label.x - pointx, label.y - pointy)
            event.window.set_mouse_owner(self, event.net_transform())
            event.handled = True
        return


    def dragging(self, event):
        """ This method is called for every mouse_move event that the tool
        receives while the user is dragging the mouse.

        Implements DragTool. Moves and redraws the label.
        """
        if self.component:
            label = self.component
            dx = int(event.x - self.mouse_down_position[0])
            dy = int(event.y - self.mouse_down_position[1])

            label.label_position = (self._original_offset[0] + dx,
                                    self._original_offset[1] + dy)

            if self.auto_arrow_root:
                # Determine which corner is closest to the point
                p = asarray(label.component.map_screen(label.data_point))
                x, y = label.position
                x2 = label.x2
                y2 = label.y2
                xmid = (x+x2)/2
                ymid = (y+y2)/2
                anchors = array(((x, y), (x2, y), (x2, y2), (x, y2),
                                (xmid, y2), (xmid, y), (x, ymid), (x2, ymid)))
                diff = anchors - p
                closest = argmin((diff ** 2).sum(axis=-1))
                label.arrow_root = self._corner_names[closest]

            event.handled = True
            label.request_redraw()
        return


    def drag_end(self, event):
        """ Called when a mouse event causes the drag operation to end.

        Implements DragTool.
        """
        if self.component:
            if event.window.mouse_owner == self:
                event.window.set_mouse_owner(None)
            event.handled = True
            self.component.request_redraw()
        return

########NEW FILE########
__FILENAME__ = drag_tool

# This is a duplicate of the enable.DragTool class and will be
# removed in future versions.  Please import DragTool directly
# from enable.

import warnings
warnings.warn("chaco.tools.DragTool has been removed."
              "Use enable.tools.DragTool instead.", DeprecationWarning)

from enable.tools.drag_tool import DragTool


########NEW FILE########
__FILENAME__ = drag_zoom
""" Defines a the DragZoom tool class
"""

# Enthought library imports
from enable.tools.drag_tool import DragTool
from traits.api import Bool, Enum, Float, Tuple

# Chaco imports
from better_zoom import BetterZoom


class DragZoom(DragTool, BetterZoom):
    """ A zoom tool that zooms continuously with a mouse drag movement, instead
    of using a zoom box or range.

    By default, the tool maintains aspect ratio and zooms the plot's X and Y
    axes by the same amount as the user drags up and down.  (In this default
    configuration, the horizontal position of the drag motion has no effect.)

    By setting **maintain_aspect_ratio** to False, this tool will separably zoom
    the X and Y axis ranges by the (possibly different) horizontal and vertical
    drag motions.  This is similar to the drag zoom interaction in Matplotlib.

    By setting single_axis to True, dragging will only zoom in the axis specified
    by the axis attribute.

    By setting restrict_domain to True, the zoom will be limited to the domain
    of the axis mappers.
    """

    # The mouse button that initiates the drag
    drag_button = Enum("left", "right", "middle")

    # Scaling factor on the zoom "speed".  A speed of 1.0 implies a zoom rate of
    # 5% for every 10 pixels.
    speed = Float(1.0)

    # Whether or not to preserve the aspect ratio of X to Y while zooming in.
    # (See class docstring for more info.)
    maintain_aspect_ratio = Bool(True)

    # The pointer to use when we're in the act of zooming
    drag_pointer = "magnifier"

    # Whether or not to zoom in one axis only
    single_axis = Bool(False)

    # Whether to restrict zoom to the domain of the mappers
    restrict_domain = Bool(False)

    zoom_to_mouse = Bool(False)

    #------------------------------------------------------------------------------
    # Private traits
    #------------------------------------------------------------------------------

    # (x,y) of the point where the mouse button was pressed.
    _original_xy = Tuple()

    # Data coordinates of **_original_xy**.  This may be either (index,value)
    # or (value,index) depending on the component's orientation.
    _original_data = Tuple()

    # A tuple of ((x,y), (x2,y2)) of the original, unzoomed screen bounds
    _orig_screen_bounds = Tuple()

    # The x and y positions of the previous mouse event.  The zoom rate is
    # based on the percentage change in position between the previous position
    # and the current mouse position, possibly in both axes.
    _prev_x = Float()
    _prev_y = Float()

    def __init__(self, component=None, *args, **kw):
        super(DragZoom, self).__init__(component, *args, **kw)
        c = component
        if c is not None:
            self._orig_screen_bounds = ((c.x, c.y), (c.x2, c.y2))

    def dragging(self, event):

        # Compute the zoom amount based on the pixel difference between
        # the previous mouse event and the current one.

        if self.maintain_aspect_ratio:
            zoom_x = zoom_y = self._calc_zoom(self._prev_y, event.y)
        else:
            zoom_x = self._calc_zoom(self._prev_x, event.x)
            zoom_y = self._calc_zoom(self._prev_y, event.y)

        # invert the zoom so scrolling up zooms in
        zoom_x = 1.0/zoom_x
        zoom_y = 1.0/zoom_y

        self.zoom_in_x(zoom_x)
        self.zoom_in_y(zoom_y)

        return

    def drag_start(self, event, capture_mouse=True):
        self._original_xy = (event.x, event.y)
        c = self.component
        self._orig_screen_bounds = ((c.x,c.y), (c.x2,c.y2))
        self._original_data = (c.x_mapper.map_data(event.x), c.y_mapper.map_data(event.y))
        self._prev_x = event.x
        self._prev_y = event.y
        if capture_mouse:
            event.window.set_pointer(self.drag_pointer)
            event.window.set_mouse_owner(self, event.net_transform())
        event.handled = True
        return

    def drag_end(self, event):
        event.window.set_pointer("arrow")
        if event.window.mouse_owner == self:
            event.window.set_mouse_owner(None)
        event.handled = True
        return

    def _calc_zoom(self, original, clicked):
        """ Returns the amount to scale the range based on the original
        cursor position and a new, updated position.
        """
        # We express the built-in zoom scaling as 0.05/10 to indicate a scaling
        # of 5% every 10 pixels, per the docstring for the 'speed' trait.
        return 1.0 - self.speed * (clicked - original) * (0.05/10)

########NEW FILE########
__FILENAME__ = draw_points_tool
""" Defines the DrawPointsTool class.
"""
# Major library imports
from numpy import array, float64, hstack

# Enthought library imports
from traits.api import Instance, Bool
from enable.api import BaseTool

# Chaco import
from chaco.api import ArrayDataSource


class DrawPointsTool(BaseTool):
    """ A tool that draws points onto a rectangular plot as they are clicked.
    """

    # A data source for the x-dimension of the drawn points.
    xdata = Instance(ArrayDataSource)
    # A data source for the y-dimension of the drawn points.
    ydata = Instance(ArrayDataSource)
    # Is this the active tool?
    activated = Bool(True)

    #It would be nice to set the pointer to a cross

    def __init__(self, **kwtraits):
        BaseTool.__init__(self, **kwtraits)
        self.xdata = self.component.value1
        self.ydata = self.component.value2
        return

    def normal_left_down(self, event):
        """ Handles the left mouse button being clicked when the tool is in the
        'normal' state.

        Maps the event position into data space, adds the point to the points
        for this tool, and redraws.
        """
        x,y = event.x, event.y
        data_x, data_y = self.component.map_data((x,y))
        self._append_data(self.xdata, data_x)
        self._append_data(self.ydata, data_y)
        self.component.request_redraw()
        return

    def _activate(self):
        self.activated = True
        return

    def _deactivate(self):
        self.activated = False
        return

    def _append_data(self, datasource, data):
        olddata = array(datasource.get_data(), float64)
        newdata = hstack((olddata, data))
        datasource.set_data(newdata)
        return


#EOF



########NEW FILE########
__FILENAME__ = highlight_tool
""" Defines the HighlightTool class.
"""
# Major library imports
from numpy import ones

# Enthought library imports
from traits.api import Enum, Float, Str
from enable.api import BaseTool

# Chaco imports
from chaco.api import BasePlotContainer


class HighlightTool(BaseTool):
    """ A tool that enables the user to select a plot to be highlighted on the
    graph by clicking on it.
    """

    # The name of the data source metadata which controls selections.
    metadata_name = Str('selections')

    # The mouse button that initiates the selection.
    drag_button = Enum("left", "right")

    # Threshold distance for hit-testing.
    threshold = Float(20.0)

    #---------------------------------------------------------------------
    # Inherited BaseTool traits
    #---------------------------------------------------------------------

    # This tool is not drawn. Overrides BaseTool.
    draw_mode = "none"

    # This tool is not visible. Overrides BaseTool.
    visible = False

    def normal_left_down(self, event):
        """ Handles the left mouse button being pressed.

        If the left mouse button initiates the selection, this method does so.
        """
        if self.drag_button == "left":
            self._highlight(event)
        return

    def normal_right_down(self, event):
        """ Handles the right mouse button being pressed.

        If the right mouse button initiates the selection, this method does so.
        """
        if self.drag_button == "right":
            self._highlight(event)
        return

    def _highlight(self, event):
        if isinstance(self.component, BasePlotContainer):
            event.offset_xy(self.component.x, self.component.y)
            closest_plot = self._find_curve(self.component.components, event)
            if closest_plot:
                index = closest_plot.index
                index.metadata[self.metadata_name] = ones(len(index.get_data()), dtype=bool)
                closest_plot.request_redraw()
            else:
                # If we are attached to a plot container, then we can deselect
                # all of the plots in the container
                for p in self.component.components:
                    if self.metadata_name in p.index.metadata:
                        del p.index.metadata[self.metadata_name]
                        p.request_redraw()
            event.pop()

        elif hasattr(self.component, "hittest"):
            hit_point = self.component.hittest((event.x, event.y), self.threshold)
            index = self.component.index
            if hit_point is not None:
                index.metadata[self.metadata_name] = ones(len(index.get_data()), dtype=bool)
                self.component.request_redraw()
            elif self.metadata_name in index.metadata:
                del index.metadata[self.metadata_name]
                self.component.request_redraw()

        event.handled = True
        return


    def _find_curve(self, plots, event):
        # need to change to use distance - not just return first plot within threshold
        for p in plots:
            if hasattr(p, "hittest"):
                cpoint = p.hittest((event.x,event.y), self.threshold)
                if cpoint:
                    return p
        return None

#EOF

########NEW FILE########
__FILENAME__ = image_inspector_tool
""" Defines the ImageInspectorTool, ImageInspectorOverlay, and
ImageInspectorColorbarOverlay classes.
"""
# Enthought library imports
from enable.api import BaseTool, KeySpec
from traits.api import Any, Bool, Enum, Event, Tuple

# Chaco imports
from chaco.api import AbstractOverlay, ImagePlot, TextBoxOverlay


class ImageInspectorTool(BaseTool):
    """ A tool that captures the color and underlying values of an image plot.
    """

    # This event fires whenever the mouse moves over a new image point.
    # Its value is a dict with a key "color_value", and possibly a key
    # "data_value" if the plot is a color-mapped image plot.
    new_value = Event

    # Indicates whether overlays listening to this tool should be visible.
    visible = Bool(True)

    # Stores the last mouse position.  This can be used by overlays to
    # position themselves around the mouse.
    last_mouse_position = Tuple

    # This key will show and hide any ImageInspectorOverlays associated
    # with this tool.
    inspector_key = KeySpec('p')

    # Stores the value of self.visible when the mouse leaves the tool,
    # so that it can be restored when the mouse enters again.
    _old_visible = Enum(None, True, False) #Trait(None, Bool(True))

    def normal_key_pressed(self, event):
        if self.inspector_key.match(event):
            self.visible = not self.visible
            event.handled = True

    def normal_mouse_leave(self, event):
        if self._old_visible is None:
            self._old_visible = self.visible
            self.visible = False

    def normal_mouse_enter(self, event):
        if self._old_visible is not None:
            self.visible = self._old_visible
            self._old_visible = None

    def normal_mouse_move(self, event):
        """ Handles the mouse being moved.

        Fires the **new_value** event with the data (if any) from the event's
        position.
        """
        plot = self.component
        if plot is not None:
            if isinstance(plot, ImagePlot):
                ndx = plot.map_index((event.x, event.y))
                if ndx == (None, None):
                    self.new_value = None
                    return

                x_index, y_index = ndx
                image_data = plot.value
                if hasattr(plot, "_cached_mapped_image") and \
                       plot._cached_mapped_image is not None:
                    self.new_value = \
                            dict(indices=ndx,
                                 data_value=image_data.data[y_index, x_index],
                                 color_value=plot._cached_mapped_image[y_index,
                                                                       x_index])

                else:
                    self.new_value = \
                        dict(indices=ndx,
                             color_value=image_data.data[y_index, x_index])

                self.last_mouse_position = (event.x, event.y)
        return


class ImageInspectorOverlay(TextBoxOverlay):
    """ An overlay that displays a box containing values from an
    ImageInspectorTool instance.
    """
    # An instance of ImageInspectorTool; this overlay listens to the tool
    # for changes, and updates its displayed text accordingly.
    image_inspector = Any

    # Anchor the text to the mouse?  (If False, then the text is in one of the
    # corners.)  Use the **align** trait to determine which corner.
    tooltip_mode = Bool(False)

    # The default state of the overlay is invisible (overrides PlotComponent).
    visible = False

    # Whether the overlay should auto-hide and auto-show based on the
    # tool's location, or whether it should be forced to be hidden or visible.
    visibility = Enum("auto", True, False)

    def _image_inspector_changed(self, old, new):
        if old:
            old.on_trait_event(self._new_value_updated, 'new_value', remove=True)
            old.on_trait_change(self._tool_visible_changed, "visible", remove=True)
        if new:
            new.on_trait_event(self._new_value_updated, 'new_value')
            new.on_trait_change(self._tool_visible_changed, "visible")
            self._tool_visible_changed()

    def _new_value_updated(self, event):
        if event is None:
            self.text = ""
            if self.visibility == "auto":
                self.visible = False
            return
        elif self.visibility == "auto":
            self.visible = True

        if self.tooltip_mode:
            self.alternate_position = self.image_inspector.last_mouse_position
        else:
            self.alternate_position = None

        d = event
        newstring = ""
        if 'indices' in d:
            newstring += '(%d, %d)' % d['indices'] + '\n'
        if 'color_value' in d:
            newstring += "(%d, %d, %d)" % tuple(map(int,d['color_value'][:3])) + "\n"
        if 'data_value' in d:
            newstring += str(d['data_value'])

        self.text = newstring
        self.component.request_redraw()

    def _visible_changed(self):
        self.component.request_redraw()

    def _tool_visible_changed(self):
        self.visibility = self.image_inspector.visible
        if self.visibility != "auto":
            self.visible = self.visibility


class ImageInspectorColorbarOverlay(AbstractOverlay):
    pass

########NEW FILE########
__FILENAME__ = lasso_selection
""" Defines the LassoSelection controller class.
"""
# Major library imports
import numpy
from numpy import array, empty, sometrue, transpose, vstack, zeros

# Enthought library imports
from traits.api import Any, Array, Enum, Event, Bool, Instance, \
                                 Property, Str, Trait, List
from kiva.agg import points_in_polygon

# Chaco imports
from chaco.api import AbstractController, AbstractDataSource, \
        BaseXYPlot, Base2DPlot


class LassoSelection(AbstractController):
    """ A controller that represents the interaction of "lassoing" a set of
    points.

    "Lassoing" means drawing an arbitrary selection region around the points
    by dragging the mouse along the outline of the region.
    """
    # An Nx2 array of points in data space representing all selected points.
    dataspace_points = Property(Array)

    # A list of all the selection polygons.
    disjoint_selections = Property(List)

    # Fires whenever **dataspace_points** changes, necessitating a redraw of the
    # selection region.
    updated = Event

    # Fires when the selection mask changes.
    selection_changed = Event

    # Fires when the user release the mouse button and finalizes the selection.
    selection_completed = Event

    # If True, the selection mask is updated as the mouse moves, rather
    # than only at the beginning and end of the selection operation.
    incremental_select = Bool(False)

    # The selection mode of the lasso pointer: "include", "exclude" or
    # "invert" points from the selection. The "include" and "exclude"
    # settings essentially invert the selection mask. The "invert" setting
    # differs from "exclude" in that "invert" inverses the selection of all
    # points the the lasso'ed polygon, while "exclude" operates only on
    # points included in a previous selection.
    selection_mode = Enum("include", "exclude", "invert")

    # The data source that the mask of selected points is attached to.  Note
    # that the indices in this data source must match the indices of the data
    # in the plot.
    selection_datasource = Instance(AbstractDataSource)

    # The name of the metadata on the datasource that we will write
    # the selection mask to
    metadata_name = Str("selection")

    # Mapping from screen space to data space. By default, it is just
    # self.component.
    plot = Property

    # The button which this tool responds to
    drag_button = Enum("left", "right")

    # The possible event states of this selection tool (overrides
    # enable.Interactor).
    #
    # normal:
    #     Nothing has been selected, and the user is not dragging the mouse.
    # selecting:
    #     The user is dragging the mouse and is actively changing the
    #     selection region.
    event_state = Enum('normal', 'selecting')

    #----------------------------------------------------------------------
    # Private Traits
    #----------------------------------------------------------------------

    # The PlotComponent associated with this tool.
    _plot = Trait(None, Any)

    # To support multiple selections, a list of cached selections and the
    # active selection are maintained. A single list is not used because the
    # active selection is re-created every time a new point is added via
    # the vstack function.
    _active_selection = Array
    _previous_selections = List(Array)

    #----------------------------------------------------------------------
    # Properties
    #----------------------------------------------------------------------

    def _get_dataspace_points(self):
        """ Returns a complete list of all selected points.

            This property exists for backwards compatibility, as the
            disjoint_selections property is almost always the preferred
            method of accessingselected points
        """
        composite = empty((0,2))
        for region in self.disjoint_selections:
            if len(region) > 0:
                composite = vstack((composite, region))

        return composite

    def _get_disjoint_selections(self):
        """ Returns a list of all disjoint selections composed of
            the previous selections and the active selection
        """
        if len(self._active_selection) == 0:
            return self._previous_selections
        else:
            return self._previous_selections + [self._active_selection]

    #----------------------------------------------------------------------
    # Event Handlers
    #----------------------------------------------------------------------

    def normal_left_down(self, event):
        if self.drag_button == "left":
            return self.normal_mouse_down(event)

    def normal_right_down(self, event):
        if self.drag_button == "right":
            return self.normal_mouse_down(event)

    def normal_mouse_down(self, event):
        """ Handles the left mouse button being pressed while the tool is
        in the 'normal' state.

        Puts the tool into 'selecting' mode, and starts defining the selection.
        """
        # We may want to generalize this for the n-dimensional case...

        self._active_selection = empty((0,2), dtype=numpy.bool)

        if self.selection_datasource is not None:
            self.selection_datasource.metadata[self.metadata_name] = zeros(len(self.selection_datasource.get_data()), dtype=numpy.bool)
        self.selection_mode = "include"
        self.event_state = 'selecting'
        self.selecting_mouse_move(event)

        if (not event.shift_down) and (not event.control_down):
            self._previous_selections = []
        else:
            if event.control_down:
                self.selection_mode = "exclude"
            else:
                self.selection_mode = "include"
        self.trait_property_changed("disjoint_selections", [], self.disjoint_selections)
        return

    def selecting_left_up(self, event):
        if self.drag_button == "left":
            return self.selecting_mouse_up(event)

    def selecting_right_up(self, event):
        if self.drag_button == "right":
            return self.selecting_mouse_up(event)

    def selecting_mouse_up(self, event):
        """ Handles the mouse button coming up in the 'selecting' state.

        Completes the selection and switches to the 'normal' state.
        """
        self.event_state = 'normal'
        self.selection_completed = True
        self._update_selection()

        self._previous_selections.append(self._active_selection)
        self._active_selection = empty((0,2), dtype=numpy.bool)
        return

    def selecting_mouse_move(self, event):
        """ Handles the mouse moving when the tool is in the 'selecting' state.

        The selection is extended to the current mouse position.
        """
        # Translate the event's location to be relative to this container
        xform = self.component.get_event_transform(event)
        event.push_transform(xform, caller=self)
        new_point = self._map_data(array((event.x, event.y)))
        self._active_selection = vstack((self._active_selection, array((new_point,))))
        self.updated = True
        if self.incremental_select:
            self._update_selection()
        # Report None for the previous selections
        self.trait_property_changed("disjoint_selections", None)
        return

    def selecting_mouse_leave(self, event):
        """ Handles the mouse leaving the plot when the tool is in the
        'selecting' state.

        Ends the selection operation.
        """
        # Treat this as if it were a selecting_mouse_up event
        return self.selecting_mouse_up(event)

    def normal_key_pressed(self, event):
        """ Handles the user pressing a key in the 'normal' state.

        If the user presses the Escape key, the tool is reset.
        """
        if event.character == "Esc":
            self._reset()
        elif event.character == 'a' and event.control_down:
            self._reset()
            self._select_all()
        elif event.character == 'i' and event.control_down:
            self.selecting_mouse_up(None)
            self.selection_mode = 'invert'
            self._select_all()
        return

    #----------------------------------------------------------------------
    # Protected Methods
    #----------------------------------------------------------------------

    def _dataspace_points_default(self):
        return empty((0,2), dtype=numpy.bool)

    def _reset(self):
        """ Resets the selection
        """
        self.event_state='normal'
        self._active_selection = empty((0,2), dtype=numpy.bool)
        self._previous_selections = []
        self._update_selection()

    def _select_all(self):
        """ Selects all points in the plot. This is done by making a rectangle
            using the corners of the plot, which is simple but effective. A
            much cooler, but more time-intensive solution would be to make
            a selection polygon representing the convex hull.
        """
        points = [self._map_data(array((self.plot.x, self.plot.y2))),
                  self._map_data(array((self.plot.x2, self.plot.y2))),
                  self._map_data(array((self.plot.x2, self.plot.y))),
                  self._map_data(array((self.plot.x, self.plot.y)))]

        self._active_selection = numpy.array(points)
        self._update_selection()


    def _update_selection(self):
        """ Sets the selection datasource's metadata to a mask of all
        the points selected
        """
        if self.selection_datasource is None:
            return

        selected_mask = zeros(self.selection_datasource._data.shape, dtype=numpy.bool)
        data = self._get_data()

        # Compose the selection mask from the cached selections first, then
        # the active selection, taking into account the selection mode only
        # for the active selection

        for selection in self._previous_selections:
            selected_mask |= (points_in_polygon(data, selection, False))

        if self.selection_mode == 'exclude':
            selected_mask |= (points_in_polygon(data, self._active_selection, False))
            selected_mask = 1 - selected_mask

        elif self.selection_mode == 'invert':
            selected_mask = -1 * (selected_mask -points_in_polygon(data, self._active_selection, False))
        else:
            selected_mask |= (points_in_polygon(data, self._active_selection, False))

        if sometrue(selected_mask != self.selection_datasource.metadata[self.metadata_name]):
            self.selection_datasource.metadata[self.metadata_name] = selected_mask
            self.selection_changed = True
        return

    def _map_screen(self, points):
        """ Maps a point in data space to a point in screen space on the plot.

        Normally this method is a pass-through, but it may do more in
        specialized plots.
        """
        return self.plot.map_screen(points)[:,:2]

    def _map_data(self, point):
        """ Maps a point in screen space to data space.

        Normally this method is a pass-through, but for plots that have more
        data than just (x,y), proper transformations need to happen here.
        """
        if isinstance(self.plot, Base2DPlot):
            # Base2DPlot.map_data takes an array of points, for some reason
            return self.plot.map_data([point])[0]
        elif isinstance(self.plot, BaseXYPlot):
            return self.plot.map_data(point, all_values=True)[:2]
        else:
            raise RuntimeError("LassoSelection only supports BaseXY and Base2D plots")

    def _get_data(self):
        """ Returns the datapoints in the plot, as an Nx2 array of (x,y).
        """
        return transpose(array((self.plot.index.get_data(), self.plot.value.get_data())))


    #------------------------------------------------------------------------
    # Property getter/setters
    #------------------------------------------------------------------------

    def _get_plot(self):
        if self._plot is not None:
            return self._plot
        else:
            return self.component

    def _set_plot(self, val):
        self._plot = val
        return



########NEW FILE########
__FILENAME__ = legend_highlighter
import operator

# ETS imports
from chaco.tools.api import LegendTool
from traits.api import List, Float


def get_hit_plots(legend, event):
    if legend is None or not legend.is_in(event.x, event.y):
        return []

    try:
        # FIXME: The size of the legend is not being computed correctly, so
        # always look at the front of the label where we know we'll get a hit.
        label = legend.get_label_at(legend.x + 20, event.y)

    except:
        raise
        label = None

    if label is None:
        return []
    try:
        ndx = legend._cached_labels.index(label)
        label_name = legend._cached_label_names[ndx]
        renderers = legend.plots[label_name]
        return renderers
    except (ValueError, KeyError):
        return []


class LegendHighlighter(LegendTool):
    """ A tool for legends that allows clicking on the legend to show
    or hide certain plots.
    """

    #: Which mousebutton to use to move the legend
    drag_button = "right"

    #: What to divide the alpha value by when plot is not selected
    dim_factor = Float(3.0)

    #: How much to scale the line when it is selected or deselected
    line_scale = Float(2.0)

    # The currently selected renderers
    _selected_renderers = List

    def normal_left_down(self, event):
        if not self.component.is_in(event.x, event.y):
            return

        plots = get_hit_plots(self.component, event)

        if len(plots) > 0:
            plot = plots[0]

            if event.shift_down:
                # User in multi-select mode by using [shift] key.
                if plot in self._selected_renderers:
                    self._selected_renderers.remove(plot)
                else:
                    self._selected_renderers.append(plot)

            else:
                # User in single-select mode.
                add_plot = plot not in self._selected_renderers
                self._selected_renderers = []
                if add_plot:
                    self._selected_renderers.append(plot)

            if self._selected_renderers:
                self._set_states(self.component.plots)
            else:
                self._reset_selects(self.component.plots)
            plot.request_redraw()

        event.handled = True

    def _reset_selects(self, plots):
        """ Set all renderers to their default values. """
        for plot in reduce(operator.add, plots.values()):
            if not hasattr(plot, '_orig_alpha'):
                plot._orig_alpha = plot.alpha
                plot._orig_line_width = plot.line_width
            plot.alpha = plot._orig_alpha
            plot.line_width = plot._orig_line_width
        return

    def _set_states(self, plots):
        """ Decorates a plot to indicate it is selected """
        for plot in reduce(operator.add, plots.values()):
            if not hasattr(plot, '_orig_alpha'):
                # FIXME: These attributes should be put into the class def.
                plot._orig_alpha = plot.alpha
                plot._orig_line_width = plot.line_width
            if plot in self._selected_renderers:
                plot.line_width = plot._orig_line_width * self.line_scale
                plot.alpha = plot._orig_alpha
            else:
                plot.alpha = plot._orig_alpha / self.dim_factor
                plot.line_width = plot._orig_line_width / self.line_scale
        # Move the selected renderers to the front
        if len(self._selected_renderers) > 0:
            container = self._selected_renderers[0].container
            components = container.components[:]
            for renderer in self._selected_renderers:
                components.remove(renderer)
            components += self._selected_renderers
            container._components = components

########NEW FILE########
__FILENAME__ = legend_tool
""" Defines the LegendTool class.
"""

# Enthought library imports
from traits.api import Bool, Enum
from enable.tools.drag_tool import DragTool


class LegendTool(DragTool):
    """ A tool for interacting with legends.

    Attach this tool to a legend by setting the tool's **component**
    to the legend.
    """

    # The mouse button that initiates the drag.
    drag_button = Enum("left", "right")

    # Whether to change the legend's **align** property in accord with
    # the quadrant into which it is dropped.
    auto_align = Bool(True)


    def is_draggable(self, x, y):
        """ Returns whether the (x,y) position is in a region that is OK to
        drag.

        Overrides DragTool.
        """
        if self.component:
            legend = self.component
            return (x >= legend.x and x <= legend.x2 and \
                    y >= legend.y and y <= legend.y2)
        else:
            return False


    def drag_start(self, event):
        """ Called when the drag operation starts.

        Implements DragTool.
        """
        if self.component:
            self.original_padding = self.component.padding
            event.window.set_mouse_owner(self, event.net_transform())
            event.handled = True
        return


    def dragging(self, event):
        """ This method is called for every mouse_move event that the tool
        receives while the user is dragging the mouse.

        Implements DragTool. Moves the legend by aligning it to a corner of its
        overlay component.
        """
        # To properly move a legend (which aligns itself to a corner of its overlay
        # component), we need to modify the padding amounts as opposed to modifying
        # the position directly.
        if self.component:
            legend = self.component
            valign, halign = legend.align
            left, right, top, bottom = self.original_padding

            dy = int(event.y - self.mouse_down_position[1])
            if valign == "u":
                # we subtract dy because if the mouse moves downwards, dy is
                # negative but the top padding has increased
                legend.padding_top = top - dy
            else:
                legend.padding_bottom = bottom + dy

            dx = int(event.x - self.mouse_down_position[0])
            if halign == "r":
                legend.padding_right = right - dx
            else:
                legend.padding_left = left + dx

            event.handled = True
            legend.request_redraw()
        return


    def drag_end(self, event):
        """ Called when a mouse event causes the drag operation to end.

        Implements DragTool.
        """
        # Make sure we have both a legend and that the legend is overlaying
        # a component
        if self.auto_align and self.component and self.component.component:
            # Determine which boundaries of the legend's overlaid component are
            # closest to the center of the legend
            legend = self.component
            component = legend.component

            left = int(legend.x - component.x)
            right = int(component.x2 - legend.x2)
            if left < right:
                halign = "l"
                legend.padding_left = left
            else:
                halign = "r"
                legend.padding_right = right

            bottom = int(legend.y - component.y)
            top = int(component.y2 - legend.y2)
            if bottom < top:
                valign = "l"
                legend.padding_bottom = bottom
            else:
                valign = "u"
                legend.padding_top = top

            legend.align = valign + halign
            if event.window.mouse_owner == self:
                event.window.set_mouse_owner(None)
            event.handled = True
            legend.request_redraw()
        return

# EOF

########NEW FILE########
__FILENAME__ = line_inspector
""" Defines the LineInspector tool class.
"""
from __future__ import with_statement

# Enthought library imports
from enable.api import BaseTool, ColorTrait, LineStyle
from traits.api import Any, Bool, Enum, Float, Str, Trait

# Chaco imports
from chaco.api import BaseXYPlot, Base2DPlot


class LineInspector(BaseTool):
    """ A simple tool to draw a line parallel to the index or the value axis of
    an X-Y plot.

    This tool supports only plots with a 1-D index.
    """

    # The axis that this tool is parallel to.
    axis = Enum("index", "value", "index_x", "index_y")

    # The possible inspection modes of the tool.
    #
    # space:
    #    The tool maps from screen space into the data space of the plot.
    # indexed:
    #    The tool maps from screen space to an index into the plot's index array.
    inspect_mode = Enum("space", "indexed")

    # Respond to user mouse events?
    is_interactive = Bool(True)

    # Does the tool respond to updates in the metadata on the data source
    # and update its own position?
    is_listener = Bool(False)

    # If interactive, does the line inspector write the current data space point
    # to the appropriate data source's metadata?
    write_metadata = Bool(False)

    # The name of the metadata field to listen or write to.
    metadata_name = Str("selections")

    #------------------------------------------------------------------------
    # Override default values of inherited traits in BaseTool
    #------------------------------------------------------------------------

    # This tool is visible (overrides BaseTool).
    visible = True
    # This tool is drawn as an overlay (overrides BaseTool).
    draw_mode = "overlay"

    # TODO:STYLE

    # Color of the line.
    color = ColorTrait("black")
    # Width in pixels of the line.
    line_width = Float(1.0)
    # Dash style of the line.
    line_style = LineStyle("solid")

    # Last recorded position of the mouse
    _last_position = Trait(None, Any)

    def draw(self, gc, view_bounds=None):
        """ Draws this tool on a graphics context.

        Overrides BaseTool.
        """
        # We draw at different points depending on whether or not we are
        # interactive.  If both listener and interactive are true, then the
        # selection metadata on the plot component takes precendence.
        plot = self.component
        if plot is None:
            return

        if self.is_listener:
            tmp = self._get_screen_pts()
        elif self.is_interactive:
            tmp = self._last_position

        if tmp:
            sx, sy = tmp
        else:
            return

        if self.axis == "index" or self.axis == "index_x":
            if plot.orientation == "h" and sx is not None:
                self._draw_vertical_line(gc, sx)
            elif sy is not None:
                self._draw_horizontal_line(gc, sy)
        else:   # self.axis == "value"
            if plot.orientation == "h" and sy is not None:
                self._draw_horizontal_line(gc, sy)
            elif sx is not None:
                self._draw_vertical_line(gc, sx)
        return

    def do_layout(self, *args, **kw):
        pass

    def overlay(self, component, gc, view_bounds=None, mode="normal"):
        """ Draws this component overlaid on a graphics context.
        """
        self.draw(gc, view_bounds)
        return

    def normal_mouse_move(self, event):
        """ Handles the mouse being moved.
        """
        if not self.is_interactive:
            return
        plot = self.component
        if plot is not None:
            self._last_position = (event.x, event.y)
            if isinstance(plot, BaseXYPlot):
                if self.write_metadata:
                    if self.inspect_mode == "space":
                        index_coord, value_coord = \
                            self._map_to_data(event.x, event.y)
                        plot.index.metadata[self.metadata_name] = index_coord
                        plot.value.metadata[self.metadata_name] = value_coord
                    else:
                        ndx = plot.map_index((event.x, event.y),
                                             threshold=5.0, index_only=True)
                        if ndx:
                            plot.index.metadata[self.metadata_name] = ndx
                            plot.value.metadata[self.metadata_name] = ndx
            elif isinstance(plot, Base2DPlot):
                if self.write_metadata:
                    try:
                        old_x_data, old_y_data = \
                            plot.index.metadata[self.metadata_name]
                    except:
                        old_x_data, old_y_data = (None, None)

                    if self.inspect_mode == "space":
                        if plot.orientation == "h":
                            x_coord, y_coord = \
                                plot.map_data([(event.x, event.y)])[0]
                        else:
                            y_coord, x_coord = \
                                plot.map_data([(event.x, event.y)])[0]
                        if self.axis == "index_x":
                            metadata = x_coord, old_y_data
                        elif self.axis == "index_y":
                            metadata = old_x_data, y_coord
                    else:
                        if plot.orientation == "h":
                            x_ndx, y_ndx =  plot.map_index((event.x, event.y),
                                                           threshold=5.0)
                        else:
                            y_ndx, x_ndx = plot.map_index((event.x, event.y),
                                                          threshold=5.0)
                        if self.axis == "index_x":
                            metadata = x_ndx, old_y_data
                        elif self.axis == "index_y":
                            metadata = old_x_data, y_ndx

                    plot.index.metadata[self.metadata_name] = metadata

            plot.request_redraw()
        return

    def normal_mouse_leave(self, event):
        """ Handles the mouse leaving the plot.
        """
        if not self.is_interactive:
            return
        self._last_position = None
        plot = self.component
        if plot is not None:
            if self.write_metadata:
                if isinstance(plot, BaseXYPlot):
                    plot.index.metadata.pop(self.metadata_name, None)
                    plot.value.metadata.pop(self.metadata_name, None)
                elif isinstance(plot, Base2DPlot):
                    plot.index.metadata.pop(self.metadata_name, None)
            plot.request_redraw()
        return

    #------------------------------------------------------------------------
    # Private methods
    #------------------------------------------------------------------------

    def _get_screen_pts(self):
        """ Returns the screen-space coordinates of the selected point on
        the plot component as a tuple (x, y).

        A dimension that doesn't have a selected point has the value None at
        its index in the tuple, or won't have the key.
        """
        plot = self.component
        if plot is None:
            return

        retval = [None, None]

        if isinstance(plot, BaseXYPlot):
            index_coord = plot.index.metadata.get(self.metadata_name, None)
            value_coord = plot.value.metadata.get(self.metadata_name, None)

            if index_coord not in (None, []):
                if self.inspect_mode == "indexed":
                    index_coord = plot.index.get_data()[index_coord]
                retval[0] = plot.index_mapper.map_screen(index_coord)

            if value_coord not in (None, []):
                if self.inspect_mode == "indexed":
                    value_coord = plot.index.get_data()[value_coord]
                retval[1] = plot.value_mapper.map_screen(value_coord)

        elif isinstance(plot, Base2DPlot):
            try:
                x_coord, y_coord = plot.index.metadata[self.metadata_name]
            except:
                x_coord, y_coord = (None, None)

            if x_coord not in (None, []):
                if self.inspect_mode == "indexed":
                    x_coord = plot.index.get_data()[0].get_data()[x_coord]
                retval[0] = plot.index_mapper._xmapper.map_screen(x_coord)

            if y_coord not in (None, []):
                if self.inspect_mode == "indexed":
                    y_coord = plot.index.get_data()[1].get_data()[y_coord]
                retval[1] = plot.index_mapper._ymapper.map_screen(y_coord)

        if plot.orientation == "h":
            return retval
        else:
            return retval[1], retval[0]

    def _map_to_data(self, x, y):
        """ Returns the data space coordinates of the given x and y.

        Takes into account orientation of the plot and the axis setting.
        """

        plot = self.component
        if plot.orientation == "h":
            index = plot.index_mapper.map_data(x)
            value = plot.value_mapper.map_data(y)
        else:
            index = plot.index_mapper.map_data(y)
            value = plot.value_mapper.map_data(x)
        return index, value

    def _draw_vertical_line(self, gc, sx):
        """ Draws a vertical line through screen point (sx,sy) having the height
        of the tool's component.
        """
        if sx < self.component.x or sx > self.component.x2:
            return

        with gc:
            gc.set_stroke_color(self.color_)
            gc.set_line_width(self.line_width)
            gc.set_line_dash(self.line_style_)
            gc.move_to(sx, self.component.y)
            gc.line_to(sx, self.component.y2)
            gc.stroke_path()
        return

    def _draw_horizontal_line(self, gc, sy):
        """ Draws a horizontal line through screen point (sx,sy) having the
        width of the tool's component.
        """
        if sy < self.component.y or sy > self.component.y2:
            return

        with gc:
            gc.set_stroke_color(self.color_)
            gc.set_line_width(self.line_width)
            gc.set_line_dash(self.line_style_)
            gc.move_to(self.component.x, sy)
            gc.line_to(self.component.x2, sy)
            gc.stroke_path()
        return



# EOF

########NEW FILE########
__FILENAME__ = line_segment_tool
""" Defines the LineSegmentTool class.
"""
from __future__ import with_statement

# Major library imports
from numpy import array

# Enthought library imports
from enable.api import Component, Pointer, Line
from traits.api import Any, Bool, Enum, Instance, Int, List, Trait, Tuple

# Chaco imports
from chaco.api import AbstractOverlay



class LineSegmentTool(AbstractOverlay):
    """ The base class for tools that allow the user to draw a
    series of points connected by lines.
    """

    # The component that this tool overlays
    component = Instance(Component)

    # The current line segment being drawn.
    line = Instance(Line, args=())

    # A list of the points in data space as (index,value)
    points = List

    # The event states are:
    #
    # normal:
    #     The user may have selected points, and is moving the cursor around.
    # selecting:
    #     The user has clicked down but hasn't let go of the button yet,
    #     and can still drag the point around.
    # dragging:
    #     The user has clicked on an existing point and is dragging it
    #     around.  When the user releases the mouse button, the tool returns
    #     to the "normal" state
    event_state = Enum("normal", "selecting", "dragging")

    # The pixel distance from a vertex that is considered 'on' the vertex.
    proximity_distance = Int(4)

    # The data (index, value) position of the mouse cursor; this is used by various
    # draw() routines.
    mouse_position = Trait(None, None, Tuple)

    # The index of the vertex being dragged, if any.
    _dragged = Trait(None, None, Int)

    # Is the point being dragged is a newly placed point? This informs the
    # "dragging" state about what to do if the user presses Escape while
    # dragging.
    _drag_new_point = Bool(False)

    # The previous event state that the tool was in. This is used for states
    # that can be canceled (e.g., by pressing the Escape key), so that the
    # tool can revert to the correct state.
    _prev_event_state = Any

    # The cursor shapes to use for various modes

    # Cursor shape for non-tool use.
    original_cursor = Pointer("arrow")
    # Cursor shape for drawing.
    normal_cursor = Pointer("pencil")
    # Cursor shape for deleting points.
    delete_cursor = Pointer("bullseye")
    # Cursor shape for moving points.
    move_cursor = Pointer("sizing")


    #------------------------------------------------------------------------
    # Traits inherited from Component
    #------------------------------------------------------------------------

    # The tool is initially invisible, because there is nothing to draw.
    visible = Bool(False)

    #------------------------------------------------------------------------
    # Public methods
    #------------------------------------------------------------------------

    def __init__(self, component=None, **kwtraits):
        if "component" in kwtraits:
            component = kwtraits["component"]
        super(LineSegmentTool, self).__init__(**kwtraits)
        self.component = component
        self.reset()
        self.line.line_dash = (4.0, 2.0)
        return

    #------------------------------------------------------------------------
    # Drawing tool methods
    #------------------------------------------------------------------------

    def reset(self):
        """ Resets the tool, throwing away any points, and making the tool
        invisible.
        """
        self.points = []
        self.event_state = "normal"
        self.visible = False
        self.request_redraw()
        return

    def _activate(self):
        """
        Called by a PlotComponent when this becomes the active tool.
        """
        pass

    def _deactivate(self, component=None):
        """
        Called by a PlotComponent when this is no longer the active tool.
        """
        self.reset()
        #self.component.window.set_pointer("arrow")
        return

    #------------------------------------------------------------------------
    # PointLine methods
    #------------------------------------------------------------------------

    def add_point(self, point):
        """ Given a screen-space *point* (x,y), adds the corresponding data
        space point to the list for this tool.
        """
        self.points.append(self._map_data(point))
        return

    def get_point(self, index):
        """ Retrieves the indexed point and returns its screen space value.
        """
        return self._map_screen(self.points[index])

    def set_point(self, index, point):
        """ Sets the data-space *index* for a screen-space *point*.
        """
        self.points[index] = self._map_data(point)
        return

    def remove_point(self, index):
        """ Removes the point for a given *index* from this tool's list of
        points.
        """
        del self.points[index]
        return

    #------------------------------------------------------------------------
    # "normal" state
    #------------------------------------------------------------------------

    def normal_left_down(self, event):
        """ Handles the left mouse button being pressed while the tool is
        in the 'normal' state.

        For an existing point, if the user is pressing the Control key, the
        point is deleted. Otherwise, the user can drag the point.

        For a new point, the point is added, and the user can drag it.
        """
        # Determine if the user is dragging/deleting an existing point, or
        # creating a new one
        over = self._over_point(event, self.line.points)
        if over is not None:
            if event.control_down:
                # Delete the point
                self.points.pop(over)
                self.line.points = list(self.component.map_screen(array(self.points)))
                self.request_redraw()
            else:
                self.event_state = "dragging"
                self._dragged = over
                self._drag_new_point = False
                self.dragging_mouse_move(event)
        else:
            self.points.append(self._map_data((event.x, event.y)))
            self._dragged = -1
            self._drag_new_point = True
            self.visible = True
            self.event_state = "dragging"
            self.dragging_mouse_move(event)
        return

    def normal_mouse_move(self, event):
        """ Handles the user moving the mouse in the 'normal' state.

        When the user moves the cursor over an existing point, if the Control
        key is pressed, the cursor changes to the **delete_cursor**, indicating
        that the point can be deleted. Otherwise, the cursor changes to the
        **move_cursor**, indicating that the point can be moved.

        When the user moves the cursor over any other point, the cursor
        changes to (or stays) the **normal_cursor**.
        """
        # If the user moves over an existing point, change the cursor to be the
        # move_cursor; otherwise, set it to the normal cursor
        over = self._over_point(event, self.line.points)
        if over is not None:
            if event.control_down:
                event.window.set_pointer(self.delete_cursor)
            else:
                event.window.set_pointer(self.move_cursor)
        else:
            event.handled = False
            event.window.set_pointer(self.normal_cursor)
        self.request_redraw()
        return

    def normal_draw(self, gc):
        """ Draws the line.
        """
        self.line.points = list(self.component.map_screen(array(self.points)))
        self.line._draw(gc)
        return

    def normal_key_pressed(self, event):
        """ Handles the user pressing a key in the 'normal' state.

        If the user presses the Enter key, the tool is reset.
        """
        if event.character == "Enter":
            self._finalize_selection()
            self.reset()
        return

    def normal_mouse_leave(self, event):
        """ Handles the user moving the cursor away from the tool area.
        """
        event.window.set_pointer("arrow")
        return

    #------------------------------------------------------------------------
    # "dragging" state
    #------------------------------------------------------------------------
    def dragging_mouse_move(self, event):
        """ Handles the user moving the mouse while in the 'dragging' state.

        The screen is updated to show the new mouse position as the end of the
        line segment being drawn.
        """
        mouse_position = self._map_data((event.x, event.y))
        self.points[self._dragged] = mouse_position
        self.line.points = list(self.component.map_screen(array(self.points)))
        self.request_redraw()
        return

    def dragging_draw(self, gc):
        """ Draws the polygon in the 'dragging' state.
        """
        self.line._draw(gc)
        return

    def dragging_left_up(self, event):
        """ Handles the left mouse coming up in the 'dragging' state.

        Switches to 'normal' state.
        """
        self.event_state = "normal"
        self._dragged = None
        self.updated = self
        return

    def dragging_key_pressed(self, event):
        """ Handles a key being pressed in the 'dragging' state.

        If the key is "Esc", the drag operation is canceled.
        """
        if event.character == "Esc":
            self._cancel_drag()
        return

    def dragging_mouse_leave(self, event):
        """ Handles the mouse leaving the tool area in the 'dragging' state.

        The drag is canceled and the cursor changes to an arrow.
        """
        self._cancel_drag()
        event.window.set_pointer("arrow")
        return

    def _cancel_drag(self):
        """ Cancels a drag operation.
        """
        if self._dragged != None:
            if self._drag_new_point:
                # Only remove the point if it was a newly-placed point
                self.points.pop(self._dragged)
            self._dragged = None
        self.mouse_position = None
        self.event_state = "normal"
        self.request_redraw()
        return

    #------------------------------------------------------------------------
    # override AbstractOverlay methods
    #------------------------------------------------------------------------

    def overlay(self, component, gc, view_bounds, mode="normal"):
        """ Draws this component overlaid on another component.

        Implements AbstractOverlay.
        """
        draw_func = getattr(self, self.event_state + "_draw", None)
        if draw_func:
            with gc:
                gc.clip_to_rect(component.x, component.y, component.width-1, component.height-1)
                draw_func(gc)
        return

    def request_redraw(self):
        """ Requests that the component redraw itself.

        Overrides Enable Component.
        """
        self.component.invalidate_draw()
        self.component.request_redraw()
        return

    #------------------------------------------------------------------------
    # Private methods
    #------------------------------------------------------------------------

    def _map_data(self, point):
        """ Maps values from screen space into data space.
        """
        x_mapper = self.component.x_mapper
        y_mapper = self.component.y_mapper
        if self.component.orientation == 'h':
            ndx = x_mapper.map_data(point[0])
            val = y_mapper.map_data(point[1])
        else:
            val = x_mapper.map_data(point[0])
            ndx = y_mapper.map_data(point[1])
        return (ndx, val)

    def _map_screen(self, point):
        """ Maps values from data space into screen space.
        """
        x_mapper = self.component.x_mapper
        y_mapper = self.component.y_mapper
        if self.component.orientation == 'h':
            x = x_mapper.map_screen(point[0])
            y = y_mapper.map_screen(point[1])
        else:
            x = x_mapper.map_screen(point[1])
            y = y_mapper.map_screen(point[0])
        return (x, y)


    def _is_near_point(self, point, event):
        """ Determines if the pointer is near a specified point.
        """
        event_point = (event.x, event.y)

        return ((abs( point[0] - event_point[0] ) + \
                 abs( point[1] - event_point[1] )) <= self.proximity_distance)

    def _over_point(self, event, points):
        """ Return the index of a point in *points* that *event* is 'over'.

        Returns None if there is no such point.
        """
        for i, point in enumerate(points):
            if self._is_near_point(point, event):
                result = i
                break
        else:
            result = None
        return result

    def _finalize_selection(self):
        """
        Abstract method called to take action after the line selection is complete
        """
        pass

    #------------------------------------------------------------------------
    # Trait event handlers
    #------------------------------------------------------------------------

    def _component_changed(self, old, new):
        if new:
            self.container = new
        return


# EOF

########NEW FILE########
__FILENAME__ = move_tool
""" Defines the MoveTool class.
"""
# Enthought library imports
from traits.api import Tuple
from enable.tools.drag_tool import DragTool


class MoveTool(DragTool):
    """ A tool for moving a plot component.
    """

    # The (x,y) offset of the start of the drag relative to the component.
    _offset = Tuple((0,0))

    def drag_start(self, event):
        """ Called when the drag operation starts.

        Implements DragTool.
        """
        self._offset = (event.x - self.component.x, event.y - self.component.y)
        event.handled = True

    def dragging(self, event):
        """ This method is called for every mouse_move event that the tool
        receives while the user is dragging the mouse.

        Implements DragTool. Moves the component.
        """
        c = self.component
        c.position = [event.x - self._offset[0], event.y - self._offset[1]]
        if getattr(c, "x_mapper", None):
            c.x_mapper.updated = True
        if getattr(c, "y_mapper", None):
            c.y_mapper.updated = True
        if getattr(c, "vgrid", None):
            c.vgrid.invalidate()
        if getattr(c, "hgrid", None):
            c.hgrid.invalidate()
        event.handled = True
        c.request_redraw()


########NEW FILE########
__FILENAME__ = pan_tool
""" Defines the PanTool class.
"""

from numpy import inf

# Enthought library imports
from enable.api import BaseTool, Pointer, KeySpec
from traits.api import Bool, Enum, Float, Tuple, Instance


class PanTool(BaseTool):
    """ A tool that enables the user to pan a plot by clicking a mouse
    button and dragging.
    """

    # The mouse button that initiates the drag operation.
    drag_button = Enum("left", "middle", "right")

    # The cursor to use when panning.
    drag_pointer = Pointer("hand")

    # Scaling factor on the panning "speed".
    speed = Float(1.0)

    # The modifier key that, if depressed when the drag is initiated, constrains
    # the panning to happen in the only direction of largest initial motion.
    # It is possible to permanently restrict this tool to always drag along one
    # direction.  To do so, set constrain=True, constrain_key=None, and
    # constrain_direction to the desired direction.
    constrain_key = Enum(None, "shift", "control", "alt")

    # Keys to Pan via keyboard
    pan_right_key = Instance(KeySpec, args=("Right",))
    pan_left_key = Instance(KeySpec, args=("Left",))
    pan_up_key = Instance(KeySpec, args=("Up",))
    pan_down_key = Instance(KeySpec, args=("Down",))

    # number of pixels the keys should pan
    # disabled if 0.0
    pan_keys_step = Float(0.0)

    # Constrain the panning to one direction?
    constrain = Bool(False)

    # The direction of constrained draw. A value of None means that the user
    # has initiated the drag and pressed the constrain_key, but hasn't moved
    # the mouse yet; the magnitude of the components of the next mouse_move
    # event will determine the constrain_direction.
    constrain_direction = Enum(None, "x", "y")

    # Restrict to the bounds of the plot data
    restrict_to_data = Bool(False)

    # (x,y) of the point where the mouse button was pressed.
    _original_xy = Tuple

    # Data coordinates of **_original_xy**.  This may be either (index,value)
    # or (value,index) depending on the component's orientation.
    _original_data = Tuple

    # Was constrain=True triggered by the **contrain_key**? If False, it was
    # set programmatically.
    _auto_constrain = Bool(False)


    #------------------------------------------------------------------------
    # Inherited BaseTool traits
    #------------------------------------------------------------------------

    # The tool does not have a visual representation (overrides
    # BaseTool).
    draw_mode = "none"

    # The tool is not visible (overrides BaseTool).
    visible = False

    # The possible event states of this tool (overrides enable.Interactor).
    event_state = Enum("normal", "panning")

    def normal_key_pressed(self, event):
        """ Handles a key being pressed when the tool is in the 'normal'
        state.
        """
        if self.pan_keys_step == 0.0:
            return
        src = self.component.bounds[0]/2, self.component.bounds[1]/2
        dest = src
        if self.pan_left_key.match(event):
            dest = (src[0] - self.pan_keys_step,
                    src[1])
        elif self.pan_right_key.match(event):
            dest = (src[0] + self.pan_keys_step,
                    src[1])
        elif self.pan_down_key.match(event):
            dest = (src[0],
                    src[1] - self.pan_keys_step)
        elif self.pan_up_key.match(event):
            dest = (src[0],
                    src[1] + self.pan_keys_step)
        if src != dest:
            self._original_xy = src
            event.x = dest[0]
            event.y = dest[1]
            self.panning_mouse_move(event)
        return

    def normal_left_down(self, event):
        """ Handles the left mouse button being pressed when the tool is in
        the 'normal' state.

        Starts panning if the left mouse button is the drag button.
        """
        if self.drag_button == "left":
            self._start_pan(event)
        return

    def normal_right_down(self, event):
        """ Handles the right mouse button being pressed when the tool is in
        the 'normal' state.

        Starts panning if the right mouse button is the drag button.
        """
        if self.drag_button == "right":
            self._start_pan(event)
        return

    def normal_middle_down(self, event):
        """ Handles the middle mouse button being pressed when the tool is in
        the 'normal' state.

        Starts panning if the middle mouse button is the drag button.
        """
        if self.drag_button == "middle":
            self._start_pan(event)
        return

    def panning_left_up(self, event):
        """ Handles the left mouse button coming up when the tool is in the
        'panning' state.

        Stops panning if the left mouse button is the drag button.
        """
        if self.drag_button == "left":
            self._end_pan(event)
        return

    def panning_right_up(self, event):
        """ Handles the right mouse button coming up when the tool is in the
        'panning' state.

        Stops panning if the right mouse button is the drag button.
        """
        if self.drag_button == "right":
            self._end_pan(event)
        return

    def panning_middle_up(self, event):
        """ Handles the middle mouse button coming up when the tool is in the
        'panning' state.

        Stops panning if the middle mouse button is the drag button.
        """
        if self.drag_button == "middle":
            self._end_pan(event)
        return

    def panning_mouse_move(self, event):
        """ Handles the mouse being moved when the tool is in the 'panning'
        state.
        """
        plot = self.component

        if self._auto_constrain and self.constrain_direction is None:
            # Determine the constraint direction
            x_orig, y_orig = self._original_xy
            if abs(event.x - x_orig) > abs(event.y - y_orig):
                self.constrain_direction = "x"
            else:
                self.constrain_direction = "y"

        direction_info = [("x", "width", 0), ("y", "height", 1)]
        for direction, bound_name, index in direction_info:
            if not self.constrain or self.constrain_direction == direction:
                mapper = getattr(plot, direction + "_mapper")
                domain_min, domain_max = mapper.domain_limits
                eventpos = getattr(event, direction)
                origpos = self._original_xy[index]

                screenlow, screenhigh = mapper.screen_bounds
                screendelta = self.speed * (eventpos - origpos)

                newlow = mapper.map_data(screenlow - screendelta)
                newhigh = mapper.map_data(screenhigh - screendelta)

                # Don't set the range in this dimension if the panning
                # would exceed the domain limits.
                # To do this offset properly, we would need to iteratively
                # solve for a root using map_data on successive trial
                # values.  As a first approximation, we're just going to
                # use a linear approximation, which works perfectly for
                # linear mappers (which is used 99% of the time).
                if domain_min is None:
                    if self.restrict_to_data:
                        domain_min = min([source.get_data().min()
                                          for source in mapper.range.sources])
                    else:
                        domain_min = -inf
                if domain_max is None:
                    if self.restrict_to_data:
                        domain_max = max([source.get_data().max()
                                          for source in mapper.range.sources])
                    else:
                        domain_max = inf

                if (newlow <= domain_min) and (newhigh >= domain_max):
                    # Don't do anything; effectively, freeze the pan
                    continue

                if newlow <= domain_min:
                    newlow = domain_min
                    # Calculate delta in screen space, which is always linear.
                    screen_delta = mapper.map_screen(domain_min) - screenlow
                    newhigh = mapper.map_data(screenhigh + screen_delta)
                elif newhigh >= domain_max:
                    newhigh = domain_max
                    # Calculate delta in screen space, which is always linear.
                    screen_delta = mapper.map_screen(domain_max) - screenhigh
                    newlow = mapper.map_data(screenlow + screen_delta)

                # Use .set_bounds() so that we don't generate two range_changed
                # events on the DataRange
                mapper.range.set_bounds(newlow, newhigh)

        event.handled = True

        self._original_xy = (event.x, event.y)
        plot.request_redraw()
        return

    def panning_mouse_leave(self, event):
        """ Handles the mouse leaving the plot when the tool is in the 'panning'
        state.

        Ends panning.
        """
        return self._end_pan(event)

    def _start_pan(self, event, capture_mouse=True):
        self._original_xy = (event.x, event.y)
        if self.constrain_key is not None:
            if getattr(event, self.constrain_key + "_down"):
                self.constrain = True
                self._auto_constrain = True
                self.constrain_direction = None
        self.event_state = "panning"
        if capture_mouse:
            event.window.set_pointer(self.drag_pointer)
            event.window.set_mouse_owner(self, event.net_transform())
        event.handled = True
        return

    def _end_pan(self, event):
        if self._auto_constrain:
            self.constrain = False
            self.constrain_direction = None
        self.event_state = "normal"
        event.window.set_pointer("arrow")
        if event.window.mouse_owner == self:
            event.window.set_mouse_owner(None)
        event.handled = True
        return

# EOF

########NEW FILE########
__FILENAME__ = pan_tool2

from numpy import inf

from enable.api import Pointer
from enable.tools.drag_tool import DragTool
from traits.api import Bool, Enum, Float, Tuple


class PanTool(DragTool):
    """ An implementation of a pan tool based on the DragTool instead of
    a bare BaseTool
    """

    # The cursor to use when panning.
    drag_pointer = Pointer("hand")

    # Scaling factor on the panning "speed".
    speed = Float(1.0)

    # The modifier key that, if depressed when the drag is initiated, constrains
    # the panning to happen in the only direction of largest initial motion.
    # It is possible to permanently restrict this tool to always drag along one
    # direction.  To do so, set constrain=True, constrain_key=None, and
    # constrain_direction to the desired direction.
    constrain_key = Enum(None, "shift", "control", "alt")

    # Constrain the panning to one direction?
    constrain = Bool(False)

    # The direction of constrained draw. A value of None means that the user
    # has initiated the drag and pressed the constrain_key, but hasn't moved
    # the mouse yet; the magnitude of the components of the next mouse_move
    # event will determine the constrain_direction.
    constrain_direction = Enum(None, "x", "y")

    # Restrict to the bounds of the plot data
    restrict_to_data = Bool(False)

    # (x,y) of the point where the mouse button was pressed.
    _original_xy = Tuple

    # Data coordinates of **_original_xy**.  This may be either (index,value)
    # or (value,index) depending on the component's orientation.
    _original_data = Tuple

    # Was constrain=True triggered by the **contrain_key**? If False, it was
    # set programmatically.
    _auto_constrain = Bool(False)

    #------------------------------------------------------------------------
    # Inherited BaseTool traits
    #------------------------------------------------------------------------

    # The tool does not have a visual representation (overrides
    # BaseTool).
    draw_mode = "none"

    # The tool is not visible (overrides BaseTool).
    visible = False

    # The possible event states of this tool (overrides enable.Interactor).
    #event_state = Enum("normal", "panning")


    def drag_start(self, event):
        """ Called when the drag operation starts """
        self._start_pan(event)

    def dragging(self, event):
        plot = self.component

        if self._auto_constrain and self.constrain_direction is None:
            # Determine the constraint direction
            if abs(event.x - self._original_xy[0]) > abs(event.y - self._original_xy[1]):
                self.constrain_direction = "x"
            else:
                self.constrain_direction = "y"

        for direction, bound_name, ndx in [("x","width",0), ("y","height",1)]:
            if not self.constrain or self.constrain_direction == direction:
                mapper = getattr(plot, direction + "_mapper")
                range = mapper.range
                domain_min, domain_max = mapper.domain_limits
                eventpos = getattr(event, direction)
                origpos = self._original_xy[ndx]

                screenlow, screenhigh = mapper.screen_bounds
                screendelta = self.speed * (eventpos - origpos)
                #if getattr(plot, direction + "_direction", None) == "flipped":
                #    screendelta = -screendelta

                newlow = mapper.map_data(screenlow - screendelta)
                newhigh = mapper.map_data(screenhigh - screendelta)

                # Don't set the range in this dimension if the panning
                # would exceed the domain limits.
                # To do this offset properly, we would need to iteratively
                # solve for a root using map_data on successive trial
                # values.  As a first approximation, we're just going to
                # use a linear approximation, which works perfectly for
                # linear mappers (which is used 99% of the time).
                if domain_min is None:
                    if self.restrict_to_data:
                        domain_min = min([source.get_data().min() for source in range.sources])
                    else:
                        domain_min = -inf
                if domain_max is None:
                    if self.restrict_to_data:
                        domain_max = max([source.get_data().max() for source in range.sources])
                    else:
                        domain_max = inf
                if (newlow <= domain_min) and (newhigh >= domain_max):
                    # Don't do anything; effectively, freeze the pan
                    continue
                if newlow <= domain_min:
                    delta = newhigh - newlow
                    newlow = domain_min
                    # Don't let the adjusted newhigh exceed domain_max; this
                    # can happen with a nonlinear mapper.
                    newhigh = min(domain_max, domain_min + delta)
                elif newhigh >= domain_max:
                    delta = newhigh - newlow
                    newhigh = domain_max
                    # Don't let the adjusted newlow go below domain_min; this
                    # can happen with a nonlinear mapper.
                    newlow = max(domain_min, domain_max - delta)

                # Use .set_bounds() so that we don't generate two range_changed
                # events on the DataRange
                range.set_bounds(newlow, newhigh)

        event.handled = True

        self._original_xy = (event.x, event.y)
        plot.request_redraw()
        return

    def drag_cancel(self, event):
        # We don't do anything for "cancelling" of the drag event because its
        # transient states during the drag are generally valid and useful
        # terminal states unto themselves.
        pass

    def drag_end(self, event):
        return self._end_pan(event)

    def _start_pan(self, event, capture_mouse=True):
        self._original_xy = (event.x, event.y)
        if self.constrain_key is not None:
            if getattr(event, self.constrain_key + "_down"):
                self.constrain = True
                self._auto_constrain = True
                self.constrain_direction = None
        self.event_state = "panning"
        if capture_mouse:
            event.window.set_pointer(self.drag_pointer)
            event.window.set_mouse_owner(self, event.net_transform())
        event.handled = True
        return

    def _end_pan(self, event):
        if self._auto_constrain:
            self.constrain = False
            self.constrain_direction = None
        self.event_state = "normal"
        event.window.set_pointer("arrow")
        if event.window.mouse_owner == self:
            event.window.set_mouse_owner(None)
        event.handled = True
        return



########NEW FILE########
__FILENAME__ = point_marker
""" Defines the PointMarker tool class.
"""
from __future__ import with_statement

# Major library imports
from numpy import array, take, transpose

# Enthought library imports
from enable.api import BaseTool, ColorTrait
from traits.api import Enum, Float


class PointMarker(BaseTool):
    """ This tool looks at an XY plot's index data source and draws a
    line corresponding to the index indicated by the "selections" metadata.
    """

    # The axis that this tool is parallel to.
    axis = Enum("index", "value")

    # This tool is visible (overrides BaseTool).
    visible = True
    # This tool is drawn as an overlay (overrides BaseTool).
    draw_mode = "overlay"

    # TODO:STYLE

    # The color of the line.
    color = ColorTrait("red")
    # The width of the line, in pixels.
    line_width = Float(1.0)

    def draw(self, gc, view_bounds=None):
        """ Draws this tool on a graphics context.

        Implements BaseTool.
        """
        # Draw the component in interactive mode
        plot = self.component
        if plot is not None:
            # selections should be a list of indices on the datasource
            indices = getattr(plot, self.axis).metadata["selections"]

            if len(indices) == 0:
                return

            index_pts = take(plot.index.get_data(), indices)
            value_pts = take(plot.value.get_data(), indices)
            data_pts = transpose(array((index_pts, value_pts)))
            screen_pts = plot.map_screen(data_pts)

            if self.axis == "index":
                if plot.orientation == "h":
                    self._draw_vertical_lines(gc, screen_pts)
                else:
                    self._draw_horizontal_lines(gc, screen_pts)
            else:   # self.axis == "value"
                if plot.orientation == "h":
                    self._draw_horizontal_lines(gc, screen_pts)
                else:
                    self._draw_vertical_lines(gc, screen_pts)
        return

    #------------------------------------------------------------------------
    # Private methods
    #------------------------------------------------------------------------

    def _draw_vertical_lines(self, gc, points):
        with gc:
            gc.set_stroke_color(self.color_)
            for pt in points:
                gc.move_to(int(pt[0])+0.5, self.component.y)
                gc.line_to(int(pt[0])+0.5, self.component.y2)
            gc.stroke_path()
        return

    def _draw_horizontal_lines(self, gc, points):
        with gc:
            gc.set_stroke_color(self.color_)
            for pt in points:
                gc.move_to(self.component.x, int(pt[1])+0.5)
                gc.line_to(self.component.x2, int(pt[1])+0.5)
            gc.stroke_path()
        return



# EOF

########NEW FILE########
__FILENAME__ = range_selection
""" Defines the RangeSelection controller class.
"""
# Major library imports
from numpy import array

# Enthought library imports
from traits.api import Any, Array, Bool, Enum, Event, Float, Int, Instance, \
                         List, Property, Str, Trait, Tuple
from enable.api import KeySpec

# Chaco imports
from chaco.api import AbstractController


class RangeSelection(AbstractController):
    """ Selects a range along the index or value axis.

    The user right-click-drags to select a region, which stays selected until
    the user left-clicks to deselect.
    """

    # The axis to which this tool is perpendicular.
    axis = Enum("index", "value")

    # The selected region, expressed as a tuple in data space.  This updates
    # and fires change-events as the user is dragging.
    selection = Property

    selection_mode = Enum("set", "append")

    # This event is fired whenever the user completes the selection, or when a
    # finalized selection gets modified.  The value of the event is the data
    # space range.
    selection_completed = Event

    # The name of the metadata on the datasource that we will write
    # self.selection to
    metadata_name = Str("selections")

    # Either "set" or "append", depending on whether self.append_key was
    # held down
    selection_mode_metadata_name = Str("selection_mode")

    # The name of the metadata on the datasource that we will set to a numpy
    # boolean array for masking the datasource's data
    mask_metadata_name = Str("selection_masks")

    # The possible event states of this selection tool (overrides
    # enable.Interactor).
    #
    # normal:
    #     Nothing has been selected, and the user is not dragging the mouse.
    # selecting:
    #     The user is dragging the mouse and actively changing the
    #     selection region; resizing of an existing selection also
    #     uses this mode.
    # selected:
    #     The user has released the mouse and a selection has been
    #     finalized.  The selection remains until the user left-clicks
    #     or self.deselect() is called.
    # moving:
    #   The user moving (not resizing) the selection range.
    event_state = Enum("normal", "selecting", "selected", "moving")

    #------------------------------------------------------------------------
    # Traits for overriding default object relationships
    #
    # By default, the RangeSelection assumes that self.component is a plot
    # and looks for the mapper and the axis_index on it.  If this is not the
    # case, then any (or all) three of these can be overriden by directly
    # assigning values to them.  To unset them and have them revert to default
    # behavior, assign "None" to them.
    #------------------------------------------------------------------------

    # The plot associated with this tool By default, this is just
    # self.component.
    plot = Property

    # The mapper for associated with this tool. By default, this is the mapper
    # on **plot** that corresponds to **axis**.
    mapper = Property

    # The index to use for **axis**. By default, this is self.plot.orientation,
    # but it can be overriden and set to 0 or 1.
    axis_index = Property

    # List of listeners that listen to selection events.
    listeners = List

    #------------------------------------------------------------------------
    # Configuring interaction control
    #------------------------------------------------------------------------

    # Can the user resize the selection once it has been drawn?
    enable_resize = Bool(True)

    # The pixel distance between the mouse event and a selection endpoint at
    # which the user action will be construed as a resize operation.
    resize_margin = Int(7)

    # Allow the left button begin a selection?
    left_button_selects = Bool(False)

    # Disable all left-mouse button interactions?
    disable_left_mouse = Bool(False)

    # Allow the tool to be put into the deselected state via mouse clicks
    allow_deselection = Bool(True)

    # The minimum span, in pixels, of a selection region.  Any attempt to
    # select a region smaller than this will be treated as a deselection.
    minimum_selection = Int(5)

    # The key which, if held down while the mouse is being dragged, will
    # indicate that the selection should be appended to an existing selection
    # as opposed to overwriting it.
    append_key = Instance(KeySpec, args=(None, "control"))

    #------------------------------------------------------------------------
    # Private traits
    #------------------------------------------------------------------------

    # The value of the override plot to use, if any.  If None, then uses
    # self.component.
    _plot = Trait(None, Any)

    # The value of the override mapper to use, if any.  If None, then uses the
    # mapper on self.component.
    _mapper = Trait(None, Any)

    # Shadow trait for the **axis_index** property.
    _axis_index = Trait(None, None, Int)

    # The data space start and end coordinates of the selected region,
    # expressed as a list.
    _selection = Trait(None, None, Tuple, List, Array)

    # The selection in mask form.
    _selection_mask = Array

    # The end of the selection that is being actively modified by the mouse.
    _drag_edge = Enum("high", "low")

    #------------------------------------------------------------------------
    # These record the mouse position when the user is moving (not resizing)
    # the selection
    #------------------------------------------------------------------------

    # The position of the initial user click for moving the selection.
    _down_point = Array  # (x,y)

    # The data space coordinates of **_down_point**.
    _down_data_coord = Float

    # The original selection when the mouse went down to move the selection.
    _original_selection = Any

    #------------------------------------------------------------------------
    # Public methods
    #------------------------------------------------------------------------

    def deselect(self, event=None):
        """ Deselects the highlighted region.

        This method essentially resets the tool. It takes the event causing the
        deselection as an optional argument.
        """
        self.selection = None
        self.selection_completed = None
        self.event_state = "normal"
        self.component.request_redraw()
        if event:
            event.window.set_pointer("arrow")
            event.handled = True
        return

    #------------------------------------------------------------------------
    # Event handlers for the "selected" event state
    #------------------------------------------------------------------------

    def selected_left_down(self, event):
        """ Handles the left mouse button being pressed when the tool is in
        the 'selected' state.

        If the user is allowed to resize the selection, and the event occurred
        within the resize margin of an endpoint, then the tool switches to the
        'selecting' state so that the user can resize the selection.

        If the event is within the bounds of the selection region, then the
        tool switches to the 'moving' states.

        Otherwise, the selection becomes deselected.
        """
        if self.disable_left_mouse:
            return

        screen_bounds = self._get_selection_screencoords()
        if screen_bounds is None:
            self.deselect(event)
            return
        low = min(screen_bounds)
        high = max(screen_bounds)
        tmp = (event.x, event.y)
        ndx = self._determine_axis()
        mouse_coord = tmp[ndx]

        if self.enable_resize:
            if (abs(mouse_coord - high) <= self.resize_margin) or \
                            (abs(mouse_coord - low) <= self.resize_margin):
                return self.selected_right_down(event)

        if tmp[self.axis_index] >= low and tmp[self.axis_index] <= high:
            self.event_state = "moving"
            self._down_point = array([event.x, event.y])
            self._down_data_coord = \
                self.mapper.map_data(self._down_point)[self.axis_index]
            self._original_selection = array(self.selection)
        elif self.allow_deselection:
            self.deselect(event)
        else:
            # Treat this as a combination deselect + left down
            self.deselect(event)
            self.normal_left_down(event)
        event.handled = True
        return

    def selected_right_down(self, event):
        """ Handles the right mouse button being pressed when the tool is in
        the 'selected' state.

        If the user is allowed to resize the selection, and the event occurred
        within the resize margin of an endpoint, then the tool switches to the
        'selecting' state so that the user can resize the selection.

        Otherwise, the selection becomes deselected, and a new selection is
        started..
        """
        if self.enable_resize:
            coords = self._get_selection_screencoords()
            if coords is not None:
                start, end = coords
                tmp = (event.x, event.y)
                ndx = self._determine_axis()
                mouse_coord = tmp[ndx]
                # We have to do a little swapping; the "end" point
                # is always what gets updated, so if the user
                # clicked on the starting point, we have to reverse
                # the sense of the selection.
                if abs(mouse_coord - end) <= self.resize_margin:
                    self.event_state = "selecting"
                    self._drag_edge = "high"
                    self.selecting_mouse_move(event)
                elif abs(mouse_coord - start) <= self.resize_margin:
                    self.event_state = "selecting"
                    self._drag_edge = "low"
                    self.selecting_mouse_move(event)
                #elif self.allow_deselection:
                #    self.deselect(event)
                else:
                    # Treat this as a combination deselect + right down
                    self.deselect(event)
                    self.normal_right_down(event)
        else:
            # Treat this as a combination deselect + right down
            self.deselect(event)
            self.normal_right_down(event)
        event.handled = True
        return

    def selected_mouse_move(self, event):
        """ Handles the mouse moving when the tool is in the 'selected' srate.

        If the user is allowed to resize the selection, and the event
        occurred within the resize margin of an endpoint, then the cursor
        changes to indicate that the selection could be resized.

        Otherwise, the cursor is set to an arrow.
        """
        if self.enable_resize:
            # Change the mouse cursor when the user moves within the
            # resize margin
            coords = self._get_selection_screencoords()
            if coords is not None:
                start, end = coords
                tmp = (event.x, event.y)
                ndx = self._determine_axis()
                mouse_coord = tmp[ndx]
                if abs(mouse_coord - end) <= self.resize_margin or \
                        abs(mouse_coord - start) <= self.resize_margin:
                    self._set_sizing_cursor(event)
                    return
        event.window.set_pointer("arrow")
        event.handled = True
        return

    def selected_mouse_leave(self, event):
        """ Handles the mouse leaving the plot when the tool is in the
        'selected' state.

        Sets the cursor to an arrow.
        """
        event.window.set_pointer("arrow")
        return

    #------------------------------------------------------------------------
    # Event handlers for the "moving" event state
    #------------------------------------------------------------------------

    def moving_left_up(self, event):
        """ Handles the left mouse button coming up when the tool is in the
        'moving' state.

        Switches the tool to the 'selected' state.
        """
        if self.disable_left_mouse:
            return

        self.event_state = "selected"
        self.selection_completed = self.selection
        self._down_point = []
        event.handled = True
        return

    def moving_mouse_move(self, event):
        """ Handles the mouse moving when the tool is in the 'moving' state.

        Moves the selection range by an amount corresponding to the amount
        that the mouse has moved since its button was pressed. If the new
        selection range overlaps the endpoints of the data, it is truncated to
        that endpoint.
        """
        cur_point = array([event.x, event.y])
        cur_data_point = self.mapper.map_data(cur_point)[self.axis_index]
        original_selection = self._original_selection
        new_selection = original_selection + (cur_data_point -
                                              self._down_data_coord)
        selection_data_width = original_selection[1] - original_selection[0]

        range = self.mapper.range
        if min(new_selection) < range.low:
            new_selection = (range.low, range.low + selection_data_width)
        elif max(new_selection) > range.high:
            new_selection = (range.high - selection_data_width, range.high)

        self.selection = new_selection
        self.selection_completed = new_selection
        self.component.request_redraw()
        event.handled = True
        return

    def moving_mouse_leave(self, event):
        """ Handles the mouse leaving the plot while the tool is in the
        'moving' state.

        If the mouse was within the selection region when it left, the method
        does nothing.

        If the mouse was outside the selection region whe it left, the event is
        treated as moving the selection to the minimum or maximum.
        """
        axis_index = self.axis_index
        low = self.plot.position[axis_index]
        high = low + self.plot.bounds[axis_index] - 1

        pos = self._get_axis_coord(event)
        if pos >= low and pos <= high:
            # the mouse left but was within the mapping range, so don't do
            # anything
            return
        else:
            # the mouse left and exceeds the mapping range, so we need to slam
            # the selection all the way to the minimum or the maximum
            self.moving_mouse_move(event)
        return

    def moving_mouse_enter(self, event):
        if not event.left_down:
            return self.moving_left_up(event)
        return

    #------------------------------------------------------------------------
    # Event handlers for the "normal" event state
    #------------------------------------------------------------------------

    def normal_left_down(self, event):
        """ Handles the left mouse button being pressed when the tool is in
        the 'normal' state.

        If the tool allows the left mouse button to start a selection, then
        it does so.
        """
        if self.left_button_selects:
            return self.normal_right_down(event)

    def normal_right_down(self, event):
        """ Handles the right mouse button being pressed when the tool is in
        the 'normal' state.

        Puts the tool into 'selecting' mode, changes the cursor to show that it
        is selecting, and starts defining the selection.

        """
        pos = self._get_axis_coord(event)
        mapped_pos = self.mapper.map_data(pos)
        self.selection = (mapped_pos, mapped_pos)
        self._set_sizing_cursor(event)
        self._down_point = array([event.x, event.y])
        self.event_state = "selecting"
        if self.append_key is not None and self.append_key.match(event):
            self.selection_mode = "append"
        else:
            self.selection_mode = "set"
        self.selecting_mouse_move(event)
        return

    #------------------------------------------------------------------------
    # Event handlers for the "selecting" event state
    #------------------------------------------------------------------------

    def selecting_mouse_move(self, event):
        """ Handles the mouse being moved when the tool is in the 'selecting'
        state.

        Expands the selection range at the appropriate end, based on the new
        mouse position.
        """
        if self.selection is not None:
            axis_index = self.axis_index
            low = self.plot.position[axis_index]
            high = low + self.plot.bounds[axis_index] - 1
            tmp = self._get_axis_coord(event)
            if tmp >= low and tmp <= high:
                new_edge = self.mapper.map_data(self._get_axis_coord(event))
                #new_edge = self._map_data(self._get_axis_coord(event))
                if self._drag_edge == "high":
                    low_val = self.selection[0]
                    if new_edge >= low_val:
                        self.selection = (low_val, new_edge)
                    else:
                        self.selection = (new_edge, low_val)
                        self._drag_edge = "low"
                else:
                    high_val = self.selection[1]
                    if new_edge <= high_val:
                        self.selection = (new_edge, high_val)
                    else:
                        self.selection = (high_val, new_edge)
                        self._drag_edge = "high"

                self.component.request_redraw()
            event.handled = True
        return

    def selecting_button_up(self, event):
        # Check to see if the selection region is bigger than the minimum
        event.window.set_pointer("arrow")

        end = self._get_axis_coord(event)

        if len(self._down_point) == 0:
            cancel_selection = False
        else:
            start = self._down_point[self.axis_index]
            self._down_point = []
            cancel_selection = self.minimum_selection > abs(start - end)

        if cancel_selection:
            self.deselect(event)
            event.handled = True
        else:
            self.event_state = "selected"

            # Fire the "completed" event
            self.selection_completed = self.selection
            event.handled = True
        return

    def selecting_right_up(self, event):
        """ Handles the right mouse button coming up when the tool is in the
        'selecting' state.

        Switches the tool to the 'selected' state and completes the selection.
        """
        self.selecting_button_up(event)

    def selecting_left_up(self, event):
        """ Handles the left mouse button coming up when the tool is in the
        'selecting' state.

        Switches the tool to the 'selected' state.
        """
        if self.disable_left_mouse:
            return
        self.selecting_button_up(event)

    def selecting_mouse_leave(self, event):
        """ Handles the mouse leaving the plot when the tool is in the
        'selecting' state.

        Determines whether the event's position is outside the component's
        bounds, and if so, clips the selection. Sets the cursor to an arrow.
        """
        axis_index = self.axis_index
        low = self.plot.position[axis_index]
        high = low + self.plot.bounds[axis_index] - 1

        old_selection = self.selection
        selection_low = old_selection[0]
        selection_high = old_selection[1]

        pos = self._get_axis_coord(event)
        if pos >= high:
            selection_high = self.mapper.map_data(high)
        elif pos <= low:
            selection_low = self.mapper.map_data(low)

        self.selection = (selection_low, selection_high)
        event.window.set_pointer("arrow")
        self.component.request_redraw()
        return

    def selecting_mouse_enter(self, event):
        """ Handles the mouse entering the plot when the tool is in the
        'selecting' state.

        If the mouse does not have the right mouse button down, this event
        is treated as if the right mouse button was released. Otherwise,
        the method sets the cursor to show that it is selecting.
        """
        # If we were in the "selecting" state when the mouse left, and
        # the mouse has entered without a button being down,
        # then treat this like we got a button up event.
        if not (event.right_down or event.left_down):
            return self.selecting_button_up(event)
        else:
            self._set_sizing_cursor(event)
        return

    #------------------------------------------------------------------------
    # Property getter/setters
    #------------------------------------------------------------------------

    def _get_plot(self):
        if self._plot is not None:
            return self._plot
        else:
            return self.component

    def _set_plot(self, val):
        self._plot = val
        return

    def _get_mapper(self):
        if self._mapper is not None:
            return self._mapper
        else:
            return getattr(self.plot, self.axis + "_mapper")

    def _set_mapper(self, new_mapper):
        self._mapper = new_mapper
        return

    def _get_axis_index(self):
        if self._axis_index is None:
            return self._determine_axis()
        else:
            return self._axis_index

    def _set_axis_index(self, val):
        self._axis_index = val
        return

    def _get_selection(self):
        selection = getattr(self.plot, self.axis).metadata[self.metadata_name]
        return selection

    def _set_selection(self, val):
        oldval = self._selection
        self._selection = val

        datasource = getattr(self.plot, self.axis, None)

        if datasource is not None:

            mdname = self.metadata_name

            # Set the selection range on the datasource
            datasource.metadata[mdname] = val
            datasource.metadata_changed = {mdname: val}

            # Set the selection mask on the datasource
            selection_masks = \
                datasource.metadata.setdefault(self.mask_metadata_name, [])
            for index in range(len(selection_masks)):
                if id(selection_masks[index]) == id(self._selection_mask):
                    del selection_masks[index]
                    break

            # Set the selection mode on the datasource
            datasource.metadata[self.selection_mode_metadata_name] = \
                      self.selection_mode

            if val is not None:
                low, high = val
                data_pts = datasource.get_data()
                new_mask = (data_pts >= low) & (data_pts <= high)
                selection_masks.append(new_mask)
                self._selection_mask = new_mask
            datasource.metadata_changed = {self.mask_metadata_name: val}

        self.trait_property_changed("selection", oldval, val)

        for l in self.listeners:
            if hasattr(l, "set_value_selection"):
                l.set_value_selection(val)

        return

    #------------------------------------------------------------------------
    # Private methods
    #------------------------------------------------------------------------

    def _get_selection_screencoords(self):
        """ Returns a tuple of (x1, x2) screen space coordinates of the start
        and end selection points.

        If there is no current selection, then it returns None.
        """
        selection = self.selection
        if selection is not None and len(selection) == 2:
            return self.mapper.map_screen(array(selection))
        else:
            return None

    def _set_sizing_cursor(self, event):
        """ Sets the correct cursor shape on the window of the event, given the
        tool's orientation and axis.
        """
        if self.axis_index == 0:
            # horizontal range selection, so use left/right arrow
            event.window.set_pointer("size left")
        else:
            # vertical range selection, so use up/down arrow
            event.window.set_pointer("size top")
        return

    def _get_axis_coord(self, event, axis="index"):
        """ Returns the coordinate of the event along the axis of interest
        to this tool (or along the orthogonal axis, if axis="value").
        """
        event_pos = (event.x, event.y)
        if axis == "index":
            return event_pos[self.axis_index]
        else:
            return event_pos[1 - self.axis_index]

    def _determine_axis(self):
        """ Determines whether the index of the coordinate along this tool's
        axis of interest is the first or second element of an (x,y) coordinate
        tuple.

        This method is only called if self._axis_index hasn't been set (or is
        None).
        """
        if self.axis == "index":
            if self.plot.orientation == "h":
                return 0
            else:
                return 1
        else:   # self.axis == "value"
            if self.plot.orientation == "h":
                return 1
            else:
                return 0

    def __mapper_changed(self):
        self.deselect()
        return

    def _axis_changed(self, old, new):
        if old is not None:
            self.plot.on_trait_change(self.__mapper_changed,
                                      old + "_mapper", remove=True)
        if new is not None:
            self.plot.on_trait_change(self.__mapper_changed,
                                      old + "_mapper", remove=True)
        return


# EOF

########NEW FILE########
__FILENAME__ = range_selection_2d
""" Defines the RangeSelection controller class.
"""
# Major library imports
import numpy

# Chaco imports
from range_selection import RangeSelection


class RangeSelection2D(RangeSelection):
    """ Selects a range along the index or value axis for plots on 2D data,
        such as image plots

    The user right-click-drags to select a region, which stays selected until
    the user left-clicks to deselect.
    """


    #------------------------------------------------------------------------
    # Event handlers for the "selected" event state
    #------------------------------------------------------------------------

    def selected_left_down(self, event):
        """ Handles the left mouse button being pressed when the tool is in
        the 'selected' state.

        If the user is allowed to resize the selection, and the event occurred
        within the resize margin of an endpoint, then the tool switches to the
        'selecting' state so that the user can resize the selection.

        If the event is within the bounds of the selection region, then the tool
        switches to the 'moving' states.

        Otherwise, the selection becomes deselected.
        """
        screen_bounds = self._get_selection_screencoords()
        if screen_bounds is None:
            self.deselect(event)
            return
        low = min(screen_bounds)
        high = max(screen_bounds)
        tmp = (event.x, event.y)
        ndx = self._determine_axis()
        mouse_coord = tmp[ndx]

        if self.enable_resize:
            if (abs(mouse_coord - high) <= self.resize_margin) or \
                            (abs(mouse_coord - low) <= self.resize_margin):
                return self.selected_right_down(event)

        if tmp[self.axis_index] >= low and tmp[self.axis_index] <= high:
            self.event_state = "moving"
            self._down_point = numpy.array([event.x, event.y])
            self._down_data_coord = self._map_data([self._down_point])[0][self.axis_index]

            self._original_selection = numpy.array(self.selection)
        elif self.allow_deselection:
            self.deselect(event)
        else:
            # Treat this as a combination deselect + left down
            self.deselect(event)
            self.normal_left_down(event)
        event.handled = True
        return

    def selected_right_down(self, event):
        """ Handles the right mouse button being pressed when the tool is in
        the 'selected' state.

        If the user is allowed to resize the selection, and the event occurred
        within the resize margin of an endpoint, then the tool switches to the
        'selecting' state so that the user can resize the selection.

        Otherwise, the selection becomes deselected, and a new selection is
        started..
        """
        if self.enable_resize:
            coords = self._get_selection_screencoords()
            if coords is not None:
                start, end = coords
                tmp = (event.x, event.y)
                ndx = self._determine_axis()
                mouse_coord = tmp[ndx]
                # We have to do a little swapping; the "end" point
                # is always what gets updated, so if the user
                # clicked on the starting point, we have to reverse
                # the sense of the selection.
                if abs(mouse_coord - end) <= self.resize_margin:
                    self.event_state = "selecting"
                    self._drag_edge = "high"
                    self.selecting_mouse_move(event)
                elif abs(mouse_coord - start) <= self.resize_margin:
                    self.event_state = "selecting"
                    self._drag_edge = "low"
                    self.selecting_mouse_move(event)
                elif self.allow_deselection:
                    self.deselect(event)
                else:
                    # Treat this as a combination deselect + right down
                    self.deselect(event)
                    self.normal_right_down(event)
        else:
            # Treat this as a combination deselect + right down
            self.deselect(event)
            self.normal_right_down(event)
        event.handled = True
        return

    def selected_mouse_move(self, event):
        """ Handles the mouse moving when the tool is in the 'selected' state.

        If the user is allowed to resize the selection, and the event
        occurred within the resize margin of an endpoint, then the cursor
        changes to indicate that the selection could be resized.

        Otherwise, the cursor is set to an arrow.
        """
        if self.enable_resize:
            # Change the mouse cursor when the user moves within the resize margin
            coords = self._get_selection_screencoords()
            if coords is not None:
                start, end = coords
                tmp = (event.x, event.y)
                ndx = self._determine_axis()
                mouse_coord = tmp[ndx]
                if abs(mouse_coord - end) <= self.resize_margin or \
                                    abs(mouse_coord - start) <= self.resize_margin:
                    self._set_sizing_cursor(event)
                    return
        event.window.set_pointer("arrow")
        event.handled = True
        return

    #------------------------------------------------------------------------
    # Event handlers for the "moving" event state
    #------------------------------------------------------------------------

    def moving_mouse_move(self, event):
        """ Handles the mouse moving when the tool is in the 'moving' state.

        Moves the selection range by an amount corresponding to the amount
        that the mouse has moved since its button was pressed. If the new
        selection range overlaps the endpoints of the data, it is truncated to
        that endpoint.
        """
        cur_point = numpy.array([event.x, event.y])
        cur_data_point = self._map_data([cur_point])[0]
        original_selection = self._original_selection
        new_selection = original_selection + (cur_data_point[self.axis_index] \
                                              - self._down_data_coord)
        selection_data_width = original_selection[1] - original_selection[0]

        range = self.mapper.range
        range_low = range.low[self.axis_index]
        range_high = range.high[self.axis_index]
        if min(new_selection) < range_low:
            new_selection = (range_low, range_low + selection_data_width)
        elif max(new_selection) > range_high:
            new_selection = (range_high - selection_data_width, range_high)

        self.selection = new_selection
        self.selection_completed = new_selection
        self.component.request_redraw()
        event.handled = True
        return

    #------------------------------------------------------------------------
    # Event handlers for the "normal" event state
    #------------------------------------------------------------------------

    def normal_right_down(self, event):
        """ Handles the right mouse button being pressed when the tool is in
        the 'normal' state.

        Puts the tool into 'selecting' mode, changes the cursor to show that it
        is selecting, and starts defining the selection.

        """
        x_pos = self._get_axis_coord(event, "index")
        y_pos = self._get_axis_coord(event, "value")
        self._down_point = numpy.array([x_pos, y_pos])
        mapped_pos = self._map_data([(x_pos,y_pos)])[0][self.axis_index]

        self.selection = (mapped_pos, mapped_pos)

        self._set_sizing_cursor(event)
        self.event_state = "selecting"
        self.selecting_mouse_move(event)
        return

    #------------------------------------------------------------------------
    # Event handlers for the "selecting" event state
    #------------------------------------------------------------------------

    def selecting_mouse_move(self, event):
        """ Handles the mouse being moved when the tool is in the 'selecting'
        state.

        Expands the selection range at the appropriate end, based on the new
        mouse position.
        """
        if self.selection is not None:
            axis_index = self.axis_index
            low = self.plot.position[axis_index]
            high = low + self.plot.bounds[axis_index] - 1
            tmp = self._get_axis_coord(event)
            if tmp >= low and tmp <= high:
                x_pos = self._get_axis_coord(event, "index")
                y_pos = self._get_axis_coord(event, "value")
                new_edge = self._map_data([(x_pos,y_pos)])[0][self.axis_index]

                if self._drag_edge == "high":
                    low_val = self.selection[0]

                    # the selection should be a range consisting of 2 points,
                    # if it appears that only 1 point is selected, move one
                    # edge over a pixel
                    if new_edge == low_val:
                        new_edge = self._map_data([(x_pos+1,y_pos+1)])[0][self.axis_index]

                    if new_edge > low_val:
                        self.selection = (low_val, new_edge)
                    else:
                        self.selection = (new_edge, low_val)
                        self._drag_edge = "low"
                else:
                    high_val = self.selection[1]

                    # the selection should be a range consisting of 2 points,
                    # if it appears that only 1 point is selected, move one
                    # edge over a pixel
                    if new_edge == high_val:
                        new_edge = self._map_data([(x_pos-1,y_pos-1)])[0][self.axis_index]

                    if new_edge < high_val:
                        self.selection = (new_edge, high_val)
                    else:
                        self.selection = (high_val, new_edge)
                        self._drag_edge = "high"

                self.component.request_redraw()
            event.handled = True
        return

    def selecting_mouse_leave(self, event):
        """ Handles the mouse leaving the plot when the tool is in the
        'selecting' state.

        Determines whether the event's position is outside the component's
        bounds, and if so, clips the selection. Sets the cursor to an arrow.
        """
        axis_index = self.axis_index
        low = self.plot.position[axis_index]
        high = low + self.plot.bounds[axis_index] - 1

        old_selection = self.selection
        selection_low = old_selection[0]
        selection_high = old_selection[1]

        pos = self._get_axis_coord(event)
        if pos >= high:
            if self.axis == 'index':
                selection_high = self._map_data([(high, 0)])[0][self.axis_index]
            else:
                selection_high = self._map_data([(0, high)])[0][self.axis_index]
        elif pos <= low:
            if self.axis == 'index':
                selection_low = self._map_data([(low, 0)])[0][self.axis_index]
            else:
                selection_low = self._map_data([(0, low)])[0][self.axis_index]

        self.selection = (selection_low, selection_high)
        event.window.set_pointer("arrow")
        self.component.request_redraw()
        return

    #------------------------------------------------------------------------
    # Private methods
    #------------------------------------------------------------------------

    def _map_data(self, screen_pts):
        return self.mapper.map_data(screen_pts)

    def _map_screen(self, data_pts):
        return self.mapper.map_screen(data_pts)

    def _get_selection_screencoords(self):
        """ Returns a tuple of (x1, x2) screen space coordinates of the start
        and end selection points.

        If there is no current selection, then it returns None.
        """
        selection = self.selection
        if selection is not None and len(selection) == 2:
            if self.axis == 'index':
                return [x for x,y in self._map_screen([(x,0) for x in self.selection])]
            else:
                return [y for x,y in self._map_screen([(0,y) for y in self.selection])]

        else:
            return None

########NEW FILE########
__FILENAME__ = range_selection_overlay
""" Defines the RangeSelectionOverlay class.
"""
from __future__ import with_statement

# Major library imports
from numpy import arange, array

# Enthought library imports
from enable.api import ColorTrait, LineStyle
from traits.api import Enum, Float, Property, Str, Instance, \
        cached_property
from chaco.api import AbstractOverlay, arg_find_runs, GridMapper, AbstractMapper


class RangeSelectionOverlay(AbstractOverlay):
    """ Highlights the selection region on a component.

    Looks at a given metadata field of self.component for regions to draw as
    selected.
    """

    # The axis to which this tool is perpendicular.
    axis = Enum("index", "value")

    # Mapping from screen space to data space. By default, it is just
    # self.component.
    plot = Property(depends_on='component')

    # The mapper (and associated range) that drive this RangeSelectionOverlay.
    # By default, this is the mapper on self.plot that corresponds to self.axis.
    mapper = Instance(AbstractMapper)

    # The element of an (x,y) tuple that corresponds to the axis index.
    # By default, this is set based on self.asix and self.plot.orientation,
    # but it can be overriden and set to 0 or 1.
    axis_index = Property

    # The name of the metadata to look at for dataspace bounds. The metadata
    # can be either a tuple (dataspace_start, dataspace_end) in "selections" or
    # a boolean array mask of seleted dataspace points with any other name
    metadata_name = Str("selections")

    #------------------------------------------------------------------------
    # Appearance traits
    #------------------------------------------------------------------------

    # The color of the selection border line.
    border_color = ColorTrait("dodgerblue")
    # The width, in pixels, of the selection border line.
    border_width = Float(1.0)
    # The line style of the selection border line.
    border_style = LineStyle("solid")
    # The color to fill the selection region.
    fill_color = ColorTrait("lightskyblue")
    # The transparency of the fill color.
    alpha = Float(0.3)

    #------------------------------------------------------------------------
    # AbstractOverlay interface
    #------------------------------------------------------------------------

    def overlay(self, component, gc, view_bounds=None, mode="normal"):
        """ Draws this component overlaid on another component.

        Overrides AbstractOverlay.
        """
        axis_ndx = self.axis_index
        lower_left = [0,0]
        upper_right = [0,0]

        # Draw the selection
        coords = self._get_selection_screencoords()
        for coord in coords:
            start, end = coord
            lower_left[axis_ndx] = start
            lower_left[1-axis_ndx] = component.position[1-axis_ndx]
            upper_right[axis_ndx] = end - start
            upper_right[1-axis_ndx] = component.bounds[1-axis_ndx]

            with gc:
                gc.clip_to_rect(component.x, component.y, component.width, component.height)
                gc.set_alpha(self.alpha)
                gc.set_fill_color(self.fill_color_)
                gc.set_stroke_color(self.border_color_)
                gc.set_line_width(self.border_width)
                gc.set_line_dash(self.border_style_)
                gc.draw_rect((lower_left[0], lower_left[1],
                             upper_right[0], upper_right[1]))

    #------------------------------------------------------------------------
    # Private methods
    #------------------------------------------------------------------------

    def _get_selection_screencoords(self):
        """ Returns a tuple of (x1, x2) screen space coordinates of the start
        and end selection points.

        If there is no current selection, then returns an empty list.
        """
        ds = getattr(self.plot, self.axis)
        selection = ds.metadata.get(self.metadata_name, None)
        if selection is None:
            return []

        # "selections" metadata must be a tuple
        if self.metadata_name == "selections" or \
                (selection is not None and isinstance(selection, tuple)):
            if selection is not None and len(selection) == 2:
                return [self.mapper.map_screen(array(selection))]
            else:
                return []
        # All other metadata is interpreted as a mask on dataspace
        else:
            ar = arange(0,len(selection), 1)
            runs = arg_find_runs(ar[selection])
            coords = []
            for inds in runs:
                start = ds._data[ar[selection][inds[0]]]
                end = ds._data[ar[selection][inds[1]-1]]
                coords.append(self.mapper.map_screen(array((start, end))))
            return coords

    def _determine_axis(self):
        """ Determines which element of an (x,y) coordinate tuple corresponds
        to the tool's axis of interest.

        This method is only called if self._axis_index hasn't been set (or is
        None).
        """
        if self.axis == "index":
            if self.plot.orientation == "h":
                return 0
            else:
                return 1
        else:   # self.axis == "value"
            if self.plot.orientation == "h":
                return 1
            else:
                return 0

    #------------------------------------------------------------------------
    # Trait event handlers
    #------------------------------------------------------------------------

    def _component_changed(self, old, new):
        self._attach_metadata_handler(old, new)
        return

    def _axis_changed(self, old, new):
        self._attach_metadata_handler(old, new)
        return

    def _attach_metadata_handler(self, old, new):
        # This is used to attach a listener to the datasource so that when
        # its metadata has been updated, we catch the event and update properly
        if not self.plot:
            return

        datasource = getattr(self.plot, self.axis)
        if old:
            datasource.on_trait_change(self._metadata_change_handler, "metadata_changed",
                                        remove=True)
        if new:
            datasource.on_trait_change(self._metadata_change_handler, "metadata_changed")
        return

    def _metadata_change_handler(self, event):
        self.component.request_redraw()
        return

    #------------------------------------------------------------------------
    # Default initializers
    #------------------------------------------------------------------------

    def _mapper_default(self):
        # If the plot's mapper is a GridMapper, return either its
        # x mapper or y mapper

        mapper = getattr(self.plot, self.axis + "_mapper")

        if isinstance(mapper, GridMapper):
            if self.axis == 'index':
                return mapper._xmapper
            else:
                return mapper._ymapper
        else:
            return mapper

    #------------------------------------------------------------------------
    # Property getter/setters
    #------------------------------------------------------------------------

    @cached_property
    def _get_plot(self):
        return self.component

    @cached_property
    def _get_axis_index(self):
        return self._determine_axis()

# EOF

########NEW FILE########
__FILENAME__ = rect_zoom
""" Defines the RectZoomTool class.
"""
from zoom_tool import ZoomTool

class RectZoomTool(ZoomTool):
    """
    Allows the user to drag a zoom box around a region of the plot.

    This is a subclass of ZoomTool, with different default values for some
    traits.
    """

    # Selects a box in two dimensions (overrides SimpleZoom).
    tool_mode = "box"

    # The tool is always on; left-clicking initiates a zoom (overrides
    # SimpleZoom).
    always_on = True


########NEW FILE########
__FILENAME__ = regression_lasso
""" Defines the RegressionLasso class.
"""
from __future__ import with_statement

# Major library imports
from numpy import compress, polyfit
from math import fabs

# Enthought library imports
from enable.api import ColorTrait, LineStyle
from traits.api import Any, Float, Instance

# Chaco imports
from chaco.api import LassoOverlay, Label
from chaco.tools.api import LassoSelection


class RegressionLasso(LassoSelection):
    """ A controller for "lassoing" a selection of points in a regression plot.
    """
    # The regression updates as more points are added (overrides LassoSelection).
    incremental_select = True

    # Tuple (slope, intercept) of the line that fits the data.
    fit_params = Any

    # The center point of the selected points, in data space.
    centroid = Any

    def _selection_changed_fired(self, event):
        indices = self.selection_datasource.metadata["selection"]
        if any(indices):
            x = compress(indices, self.component.index.get_data())
            y = compress(indices, self.component.value.get_data())
            if len(x) < 2 or len(y) < 2:
                self.fit_params = None
                self.centroid = None
            else:
                self.fit_params = tuple(polyfit(x,y,1))
                self.centroid = (sum(x)/len(x)), (sum(y)/len(y))
        else:
            self.fit_params = None
            self.centroid = None
        return


class RegressionOverlay(LassoOverlay):

    line_color = ColorTrait("black")
    line_style = LineStyle("dash")
    line_width = Float(2.0)

    _label = Instance(Label, kw=dict(bgcolor="white", border_color="black",
                                 font="modern 14", border_width=1))

    def _draw_component(self, gc, view_bounds=None, mode="normal"):
        LassoOverlay._draw_component(self, gc, view_bounds, mode)
        selection = self.lasso_selection

        if selection.fit_params is not None:
            # draw the label overlay
            self._label.component = self.component
            c = self.component

            if selection.fit_params[1] < 0:
                operator = "-"
            else:
                operator = "+"
            self._label.text = "%.2fx "%selection.fit_params[0] + operator + \
                               " %.2f" % fabs(selection.fit_params[1])
            w, h = self._label.get_width_height(gc)
            x = (c.x+c.x2)/2 - w/2
            y = c.y + 5  # add some padding on the bottom
            with gc:
                gc.translate_ctm(x, y)
                self._label.draw(gc)

            # draw the line
            slope, y0 = selection.fit_params
            f = lambda x: slope*x + y0
            cx, cy = c.map_screen([selection.centroid])[0]
            left = c.x
            right = c.x2

            left_x = c.map_data([left, c.y])[0]
            right_x = c.map_data([right, c.y])[0]
            left_y = f(left_x)
            right_y = f(right_x)

            left_pt, right_pt = c.map_screen([[left_x, left_y], [right_x, right_y]])

            with gc:
                gc.set_line_dash(self.line_style_)
                gc.set_stroke_color(self.line_color_)
                gc.set_line_width(self.line_width)
                gc.move_to(*left_pt)
                gc.line_to(*right_pt)
                gc.stroke_path()

        return

########NEW FILE########
__FILENAME__ = save_tool
""" Defines the SaveTool class.
"""

# Major library imports
import os.path

# Enthought library imports
from traits.api import Enum, Str, Tuple
from enable.api import BaseTool


class SaveTool(BaseTool):
    """ This tool allows the user to press Ctrl+S to save a snapshot image of
    the plot component.
    """

    # The file that the image is saved in.  The format will be deduced from
    # the extension.
    filename = Str("saved_plot.png")

    #-------------------------------------------------------------------------
    # PDF format options
    # This mirror the traits in PdfPlotGraphicsContext.
    #-------------------------------------------------------------------------

    pagesize = Enum("letter", "A4")
    dest_box = Tuple((0.5, 0.5, -0.5, -0.5))
    dest_box_units = Enum("inch", "cm", "mm", "pica")

    #-------------------------------------------------------------------------
    # Override default trait values inherited from BaseTool
    #-------------------------------------------------------------------------

    # This tool does not have a visual representation (overrides BaseTool).
    draw_mode = "none"

    # This tool is not visible (overrides BaseTool).
    visible = False

    def normal_key_pressed(self, event):
        """ Handles a key-press when the tool is in the 'normal' state.

        Saves an image of the plot if the keys pressed are Control and S.
        """
        if self.component is None:
            return

        if event.character == "s" and event.control_down:
            if os.path.splitext(self.filename)[-1] == ".pdf":
                self._save_pdf()
            else:
                self._save_raster()
            event.handled = True
        return

    def _save_raster(self):
        """ Saves an image of the component.
        """
        from chaco.api import PlotGraphicsContext
        gc = PlotGraphicsContext((int(self.component.outer_width), int(self.component.outer_height)))
        self.component.draw(gc, mode="normal")
        gc.save(self.filename)
        return

    def _save_pdf(self):
        from chaco.pdf_graphics_context import PdfPlotGraphicsContext
        gc = PdfPlotGraphicsContext(filename=self.filename,
                pagesize = self.pagesize,
                dest_box = self.dest_box,
                dest_box_units = self.dest_box_units)
        gc.render_component(self.component)
        gc.save()

# EOF

########NEW FILE########
__FILENAME__ = scatter_inspector
""" Defines the ScatterInspector tool class.
"""

# Enthought library imports
from traits.api import Bool, Str

# Local, relative imports
from select_tool import SelectTool


class ScatterInspector(SelectTool):
    """ A tool for inspecting scatter plots.

    It writes the index of the point under the cursor to the metadata of the
    index and value data sources, and allows clicking to select the point.
    Other components can listen for metadata updates on the data sources.

    By default, it writes the index of the point under the cursor to the "hover"
    key in metadata, and the index of a clicked point to "selection".
    """

    # If persistent_hover is False, then a point will be de-hovered as soon as
    # the mouse leaves its hittesting area.  If persistent_hover is True, then
    # a point does no de-hover until another point get hover focus.
    persistent_hover = Bool(False)

    # The names of the data source metadata for hover and selection.
    hover_metadata_name = Str('hover')
    selection_metadata_name = Str('selections')

    #------------------------------------------------------------------------
    # Override/configure inherited traits
    #------------------------------------------------------------------------

    # This tool is not visible
    visible = False

    # This tool does not have a visual reprentation
    draw_mode = "none"

    def normal_mouse_move(self, event):
        """ Handles the mouse moving when the tool is in the 'normal' state.

        If the cursor is within **threshold** of a data point, the method
        writes the index to the plot's data sources' "hover" metadata.
        """
        plot = self.component
        index = plot.map_index((event.x, event.y), threshold=self.threshold)
        if index is not None:
            plot.index.metadata[self.hover_metadata_name] = [index]
            if hasattr(plot, "value"):
                plot.value.metadata[self.hover_metadata_name] = [index]
        elif not self.persistent_hover:
            plot.index.metadata.pop(self.hover_metadata_name, None)
            if hasattr(plot, "value"):
                plot.value.metadata.pop(self.hover_metadata_name, None)
        return

    def _get_selection_state(self, event):
        plot = self.component
        index = plot.map_index((event.x, event.y), threshold=self.threshold)
        #index_md = plot.index.metadata.get(self.selection_metadata_name, None)
        #value_md = plot.value.metadata.get(self.selection_metadata_name, None)

        already_selected = False
        for name in ('index', 'value'):
            if not hasattr(plot, name):
                continue
            md = getattr(plot, name).metadata
            if md is None or self.selection_metadata_name not in md:
                continue
            if index in md[self.selection_metadata_name]:
                already_selected = True
                break
        return already_selected, (index is not None)

    def _get_selection_token(self, event):
        plot = self.component
        index = plot.map_index((event.x, event.y), threshold=self.threshold)
        return index

    def _deselect(self, index=None):
        """ Deselects a particular index.  If no index is given, then
        deselects all points.
        """
        plot = self.component
        for name in ('index', 'value'):
            if not hasattr(plot, name):
                continue
            md = getattr(plot, name).metadata
            if not self.selection_metadata_name in md:
                pass
            elif index in md[self.selection_metadata_name]:
                new_list = md[self.selection_metadata_name][:]
                new_list.remove(index)
                md[self.selection_metadata_name] = new_list
                getattr(plot, name).metadata_changed = True
        return

    def _select(self, index, append=True):
        plot = self.component
        for name in ('index', 'value'):
            if not hasattr(plot, name):
                continue
            md = getattr(plot, name).metadata
            selection = md.get(self.selection_metadata_name, None)

            # If no existing selection
            if selection is None:
                md[self.selection_metadata_name] = [index]
            # check for list-like object supporting append
            else:
                if append:
                    if index not in md[self.selection_metadata_name]:
                        new_list = md[self.selection_metadata_name] + [index]
                        md[self.selection_metadata_name] = new_list
                        # Manually trigger the metadata_changed event on
                        # the datasource.  Datasources only automatically
                        # fire notifications when the values inside the
                        # metadata dict change, but they do not listen
                        # for further changes on those values.
                        getattr(plot, name).metadata_changed = True
                else:
                    md[self.selection_metadata_name] = [index]
        return


# EOF

########NEW FILE########
__FILENAME__ = select_tool


# Enthought library imports
from enable.api import BaseTool, KeySpec
from traits.api import Enum, Float, Instance


class SelectTool(BaseTool):
    """ Base class for tools that handle some level of click-to-select
    interaction.  Handles the logic of different kinds of selection
    modes.  Subclasses only need to implement a few concrete methods
    to handle actual selection/deselection.
    """

    # The threshold, in pixels, around the cursor location to search for points.
    threshold = Float(5.0)

    # How selections are handled:
    #
    # "toggle"
    #     The user clicks on points (while optionally holding down a modifier
    #     key) to select or deselect them. If the point is already selected,
    #     clicking it again deselects it. The modifier key to use is set by
    #     **multiselect_modifier**. The only way to deselect points is by
    #     clicking on them; clicking on a screen space outside of the plot does
    #     not deselect points.
    # "multi"
    #     Like **toggle** mode, except that the user can deselect all points
    #     at once by clicking on the plot area away from a point.
    # "single"
    #     The user can only select a single point at a time.
    # "off"
    #     The user cannot select points via clicking.
    selection_mode = Enum("toggle", "multi", "single", "off")

    # The modifier key to use to multi-select points.  Only used in **toggle**
    # and **multi** selection modes.
    multiselect_modifier = Instance(KeySpec, args=(None, "control"), allow_none=True)


    def _get_selection_state(self, event):
        """ Returns a tuple reflecting the current selection state

        Parameters
        ----------
        event : enable KeyEvent or MouseEvent

        Returns
        -------
        (already_selected, clicked) : tuple of Bool
            clicked is True if the item corresponding to the input event has
            just been clicked.
            already_selected indicates that the item corresponding to the
            input event is already selected.

        """
        raise NotImplementedError

    def _get_selection_token(self, event):
        """ Returns a token corresponding to the selection event.  This token
        is passed in to the select and deselect methods.  By default, this
        just returns the event itself.
        """
        return event

    def _select(self, token, append=True):
        """ Selects the given token.
        """
        raise NotImplementedError

    def _deselect(self, token, append=True):
        """ Deselects the given token.
        """
        raise NotImplementedError

    def normal_left_down(self, event):
        """ Handles the left mouse button being pressed when the tool is in the
        'normal' state.

        If selecting is enabled and the cursor is within **threshold** of a
        data point, the method calls the subclass's _select" or _deselect
        methods to perform the appropriate action, given the current
        selection_mode.
        """
        if self.selection_mode != "off":
            already_selected, clicked = self._get_selection_state(event)
            modifier_down = self.multiselect_modifier.match(event)
            token = self._get_selection_token(event)

            if (self.selection_mode == "single") or\
                    (self.selection_mode == "multi" and not modifier_down):
                if clicked and not already_selected:
                    if self.selection_mode == "single" or not modifier_down:
                        self._select(token, append=False)
                    else:
                        self._select(token, append=True)
                    event.handled = True
                else:
                    self._deselect(token)

            else:  # multi or toggle, and modifier_down is true
                if clicked:
                    if already_selected:
                        self._deselect(token)
                    else:
                        self._select(token)
                    event.handled = True
            return




########NEW FILE########
__FILENAME__ = simple_inspector
"""Simple Inspector tool for plots

This module provides a simple tool that reports the data-space coordinates of
the current mouse cursor position in a plot.  It is intended for use with
SimpleInspectorOverlay, but other objects can potentially hook into its API.
"""

from chaco.image_plot import ImagePlot
from enable.api import BaseTool, KeySpec
from traits.api import Bool, Event, Tuple, Enum, Callable

class SimpleInspectorTool(BaseTool):
    """ Simple inspector tool for plots

    This is a simple tool that reports the data-space coordinates of the
    current mouse cursor position in a plot.

    Interested overlays and other objects can listen for new_value events,
    which is a dictionary of data about the current location in data space,
    and can look at the last_mouse_position trait which holds the mouse
    position in screen space.

    The tool also provides a visible trait which listeners can use to hide
    themselves.  By default the 'p' key toggles this.

    Instances can provide a value_generator function that performs computations
    to generate additional values in the dictionary that is passed to the
    new_value event.  Subclasses can override gather_values() to similar
    effect.
    """

    # This event fires whenever the mouse moves over a new image point.
    # Its value is a dict with default keys "x", "y", "index" and "value".
    new_value = Event

    # Indicates whether overlays listening to this tool should be visible.
    visible = Bool(True)

    # Stores the last mouse position.  This can be used by overlays to
    # position themselves around the mouse.
    last_mouse_position = Tuple

    # This key will show and hide any overlays listening to this tool.
    inspector_key = KeySpec('p')

    # A callable that computes other values for the new_value event
    # this takes a dictionary as an argument, and returns a dictionary
    value_generator = Callable

    # Private Trails ########################################################

    # Stores the value of self.visible when the mouse leaves the tool,
    # so that it can be restored when the mouse enters again.
    _old_visible = Enum(None, True, False) #Trait(None, Bool(True))

    #########################################################################
    # SimpleInspectorTool API
    #########################################################################

    def gather_values(self, event):
        """ Generate the values for the new_value dictionary.

        By default this returns a dictionary with keys "x", "y", "index" and
        "value".  If there is a value_generator callable, this will be called
        to modify the dictionary.

        Parameters
        ----------

        event
            The mouse_move event.

        Returns
        -------

        A dictionary.
        """
        x, y, index, value = self.map_to_data(event.x, event.y)
        d = {'index': index, 'value': value, 'x': x, 'y': y}

        if isinstance(self.component, ImagePlot):
            x_ndx, y_ndx = self.component.map_index((event.x, event.y),
                                                    outside_returns_none=False)

            # FIXME: off-by-one error. The size of the index is +1 to the size of
            # the image array
            if y_ndx == self.component.value.data.shape[0]:
                y_ndx -= 1
            if x_ndx == self.component.value.data.shape[1]:
                x_ndx += 1

            z =  self.component.value.data[y_ndx, x_ndx]
            d['z'] = z
            d['color'] = z

        if self.value_generator is not None:
            d = self.value_generator(d)
        return d

    def map_to_data(self, x, y):
        """ Returns the data space coordinates of the given x and y.

        Takes into account orientation of the plot and the axis setting.
        """

        plot = self.component
        if plot.orientation == "h":
            index = x = plot.x_mapper.map_data(x)
            value = y = plot.y_mapper.map_data(y)
        else:
            index = y = plot.y_mapper.map_data(y)
            value = x = plot.x_mapper.map_data(x)
        return x, y, index, value

    #########################################################################
    # Component API
    #########################################################################

    def normal_key_pressed(self, event):
        if self.inspector_key.match(event):
            self.visible = not self.visible

    def normal_mouse_leave(self, event):
        if self._old_visible is None:
            self._old_visible = self.visible
            self.visible = False

    def normal_mouse_enter(self, event):
        if self._old_visible is not None:
            self.visible = self._old_visible
            self._old_visible = None

    def normal_mouse_move(self, event):
        plot = self.component
        if plot is not None:
            self.new_value = self.gather_values(event)
            self.last_mouse_position = (event.x, event.y)

########NEW FILE########
__FILENAME__ = simple_zoom
""" Defines the SimpleZoom class.
"""
from __future__ import with_statement

import warnings
warnings.warn("SimpleZoom has been deprecated, use ZoomTool", DeprecationWarning)

from numpy import array

# Enthought library imports
from enable.api import ColorTrait, KeySpec
from traits.api \
    import Bool, Enum, Float, Instance, Int, Str, Trait, Tuple

# Chaco imports
from chaco.abstract_overlay import AbstractOverlay
from base_zoom_tool import BaseZoomTool
from tool_history_mixin import ToolHistoryMixin

class SimpleZoom(AbstractOverlay, ToolHistoryMixin, BaseZoomTool):
    """ Selects a range along the index or value axis.

    The user left-click-drags to select a region to zoom in.
    Certain keyboard keys are mapped to performing zoom actions as well.

    Implements a basic "zoom stack" so the user move go backwards and forwards
    through previous zoom regions.
    """

    # The selection mode:
    #
    # range:
    #   Select a range across a single index or value axis.
    # box:
    #   Perform a "box" selection on two axes.
    tool_mode = Enum("box", "range")

    # Is the tool always "on"? If True, left-clicking always initiates
    # a zoom operation; if False, the user must press a key to enter zoom mode.
    always_on = Bool(False)

    # Defines a meta-key, that works with always_on to set the zoom mode. This
    # is useful when the zoom tool is used in conjunction with the pan tool.
    always_on_modifier = Enum(None, 'shift', 'control', 'alt')

    #-------------------------------------------------------------------------
    # Zoom control
    #-------------------------------------------------------------------------

    # The axis to which the selection made by this tool is perpendicular. This
    # only applies in 'range' mode.
    axis = Enum("index", "value")

    #-------------------------------------------------------------------------
    # Interaction control
    #-------------------------------------------------------------------------

    # Enable the mousewheel for zooming?
    enable_wheel = Bool(True)

    # The mouse button that initiates the drag.  If "None", then the tool
    # will not respond to drag.  (It can still respond to mousewheel events.)
    drag_button = Enum("left", "right", None)

    # Conversion ratio from wheel steps to zoom factors.
    wheel_zoom_step = Float(1.0)

    # The key press to enter zoom mode, if **always_on** is False.  Has no effect
    # if **always_on** is True.
    enter_zoom_key = Instance(KeySpec, args=("z",))

    # The key press to leave zoom mode, if **always_on** is False.  Has no effect
    # if **always_on** is True.
    exit_zoom_key = Instance(KeySpec, args=("z",))

    # Disable the tool after the zoom is completed?
    disable_on_complete = Bool(True)

    # The minimum amount of screen space the user must select in order for
    # the tool to actually take effect.
    minimum_screen_delta = Int(10)

    #-------------------------------------------------------------------------
    # Appearance properties (for Box mode)
    #-------------------------------------------------------------------------

    # The pointer to use when drawing a zoom box.
    pointer = "magnifier"

    # The color of the selection box.
    color = ColorTrait("lightskyblue")

    # The alpha value to apply to **color** when filling in the selection
    # region.  Because it is almost certainly useless to have an opaque zoom
    # rectangle, but it's also extremely useful to be able to use the normal
    # named colors from Enable, this attribute allows the specification of a
    # separate alpha value that replaces the alpha value of **color** at draw
    # time.
    alpha = Trait(0.4, None, Float)

    # The color of the outside selection rectangle.
    border_color = ColorTrait("dodgerblue")

    # The thickness of selection rectangle border.
    border_size = Int(1)

    # The possible event states of this zoom tool.
    event_state = Enum("normal", "selecting")

    #------------------------------------------------------------------------
    # Key mappings
    #------------------------------------------------------------------------

    # The key that cancels the zoom and resets the view to the original defaults.
    cancel_zoom_key = Instance(KeySpec, args=("Esc",))

    #------------------------------------------------------------------------
    # Private traits
    #------------------------------------------------------------------------

    # If **always_on** is False, this attribute indicates whether the tool
    # is currently enabled.
    _enabled = Bool(False)

    # the original numerical screen ranges
    _orig_low_setting = Trait(None, Tuple, Float, Str)
    _orig_high_setting = Trait(None, Tuple, Float, Str)

    # The (x,y) screen point where the mouse went down.
    _screen_start = Trait(None, None, Tuple)

    # The (x,,y) screen point of the last seen mouse move event.
    _screen_end = Trait(None, None, Tuple)

    def __init__(self, component=None, *args, **kw):
        # Support AbstractController-style constructors so that this can be
        # handed in the component it will be overlaying in the constructor
        # without using kwargs.
        self.component = component
        super(SimpleZoom, self).__init__(*args, **kw)
        self._reset_state_to_current()
        if self.tool_mode == "range":
            mapper = self._get_mapper()
            self._orig_low_setting = mapper.range.low_setting
            self._orig_high_setting = mapper.range.high_setting
        else:
            x_range = self.component.x_mapper.range
            y_range = self.component.y_mapper.range
            self._orig_low_setting = (x_range.low_setting, y_range.low_setting)
            self._orig_high_setting = \
                (x_range.high_setting, y_range.high_setting)
        component.on_trait_change(self._reset_state_to_current,
                                  "index_data_changed")
        return

    def enable(self, event=None):
        """ Provides a programmatic way to enable this tool, if
        **always_on** is False.

        Calling this method has the same effect as if the user pressed the
        **enter_zoom_key**.
        """
        if self.component.active_tool != self:
            self.component.active_tool = self
        self._enabled = True
        if event and event.window:
            event.window.set_pointer(self.pointer)
        return

    def disable(self, event=None):
        """ Provides a programmatic way to enable this tool, if **always_on**
        is False.

        Calling this method has the same effect as if the user pressed the
        **exit_zoom_key**.
        """
        self.reset()
        self._enabled = False
        if self.component.active_tool == self:
            self.component.active_tool = None
        if event and event.window:
            event.window.set_pointer("arrow")
        return

    def reset(self, event=None):
        """ Resets the tool to normal state, with no start or end position.
        """
        self.event_state = "normal"
        self._screen_start = None
        self._screen_end = None

    def deactivate(self, component):
        """ Called when this is no longer the active tool.
        """
        # Required as part of the AbstractController interface.
        return self.disable()

    def overlay(self, component, gc, view_bounds=None, mode="normal"):
        """ Draws this component overlaid on another component.

        Overrides AbstractOverlay.
        """
        if self.event_state == "selecting":
            if self.tool_mode == "range":
                self.overlay_range(component, gc)
            else:
                self.overlay_box(component, gc)
        return

    def overlay_box(self, component, gc):
        """ Draws the overlay as a box.
        """
        if self._screen_start and self._screen_end:
            with gc:
                gc.set_antialias(0)
                gc.set_line_width(self.border_size)
                gc.set_stroke_color(self.border_color_)
                gc.clip_to_rect(component.x, component.y, component.width, component.height)
                x, y = self._screen_start
                x2, y2 = self._screen_end
                rect = (x, y, x2-x+1, y2-y+1)
                if self.color != "transparent":
                    if self.alpha:
                        color = list(self.color_)
                        if len(color) == 4:
                            color[3] = self.alpha
                        else:
                            color += [self.alpha]
                    else:
                        color = self.color_
                    gc.set_fill_color(color)
                    gc.rect(*rect)
                    gc.draw_path()
                else:
                    gc.rect(*rect)
                    gc.stroke_path()
        return

    def overlay_range(self, component, gc):
        """ Draws the overlay as a range.
        """
        axis_ndx = self._determine_axis()
        lower_left = [0,0]
        upper_right = [0,0]
        lower_left[axis_ndx] = self._screen_start[axis_ndx]
        lower_left[1-axis_ndx] = self.component.position[1-axis_ndx]
        upper_right[axis_ndx] = self._screen_end[axis_ndx] - self._screen_start[axis_ndx]
        upper_right[1-axis_ndx] = self.component.bounds[1-axis_ndx]

        with gc:
            gc.set_antialias(0)
            gc.set_alpha(self.alpha)
            gc.set_fill_color(self.color_)
            gc.set_stroke_color(self.border_color_)
            gc.clip_to_rect(component.x, component.y, component.width, component.height)
            gc.rect(lower_left[0], lower_left[1], upper_right[0], upper_right[1])
            gc.draw_path()

        return

    def normal_left_down(self, event):
        """ Handles the left mouse button being pressed while the tool is
        in the 'normal' state.

        If the tool is enabled or always on, it starts selecting.
        """
        if self._is_enabling_event(event):
            self._start_select(event)
            event.handled = True

        return

    def normal_right_down(self, event):
        """ Handles the right mouse button being pressed while the tool is
        in the 'normal' state.

        If the tool is enabled or always on, it starts selecting.
        """
        if self._is_enabling_event(event):
            self._start_select(event)
            event.handled = True

        return

    def selecting_mouse_move(self, event):
        """ Handles the mouse moving when the tool is in the 'selecting' state.

        The selection is extended to the current mouse position.
        """
        self._screen_end = (event.x, event.y)
        self.component.request_redraw()
        event.handled = True
        return

    def selecting_left_up(self, event):
        """ Handles the left mouse button being released when the tool is in
        the 'selecting' state.

        Finishes selecting and does the zoom.
        """
        if self.drag_button == "left":
            self._end_select(event)
        return

    def selecting_right_up(self, event):
        """ Handles the right mouse button being released when the tool is in
        the 'selecting' state.

        Finishes selecting and does the zoom.
        """
        if self.drag_button == "right":
            self._end_select(event)
        return

    def selecting_mouse_leave(self, event):
        """ Handles the mouse leaving the plot when the tool is in the
        'selecting' state.

        Ends the selection operation without zooming.
        """
        self._end_selecting(event)
        return

    def selecting_key_pressed(self, event):
        """ Handles a key being pressed when the tool is in the 'selecting'
        state.

        If the key pressed is the **cancel_zoom_key**, then selecting is
        canceled.
        """
        if self.cancel_zoom_key.match(event):
            self._end_selecting(event)
            event.handled = True
        return

    def _start_select(self, event):
        """ Starts selecting the zoom region
        """
        if self.component.active_tool in (None, self):
            self.component.active_tool = self
        else:
            self._enabled = False
        self._screen_start = (event.x, event.y)
        self._screen_end = None
        self.event_state = "selecting"
        event.window.set_pointer(self.pointer)
        event.window.set_mouse_owner(self, event.net_transform())
        self.selecting_mouse_move(event)
        return

    def _end_select(self, event):
        """ Ends selection of the zoom region, adds the new zoom range to
        the zoom stack, and does the zoom.
        """
        self._screen_end = (event.x, event.y)

        start = array(self._screen_start)
        end = array(self._screen_end)

        if sum(abs(end - start)) < self.minimum_screen_delta:
            self._end_selecting(event)
            event.handled = True
            return

        if self.tool_mode == "range":
            mapper = self._get_mapper()
            axis = self._determine_axis()
            low = mapper.map_data(self._screen_start[axis])
            high = mapper.map_data(self._screen_end[axis])

            if low > high:
                low, high = high, low
        else:
            low, high = self._map_coordinate_box(self._screen_start, self._screen_end)

        new_zoom_range = (low, high)
        self._append_state(new_zoom_range)
        self._do_zoom()
        self._end_selecting(event)
        event.handled = True
        return

    def _end_selecting(self, event=None):
        """ Ends selection of zoom region, without zooming.
        """
        if self.disable_on_complete:
            self.disable(event)
        else:
            self.reset()
        self.component.request_redraw()
        if event and event.window.mouse_owner == self:
            event.window.set_mouse_owner(None)
        return

    def _do_zoom(self):
        """ Does the zoom operation.

        This method does not handle zooms triggered by scrolling the mouse wheel.
        Those are handled by `normal_mouse_wheel()`.
        """
        # Sets the bounds on the component using _history_index.
        low, high = self._current_state()
        orig_low, orig_high = self._history[0]

        if self._history_index == 0:
            # Reset to the original range(s).
            if self.tool_mode == "range":
                # "range" mode; reset the one axis.
                mapper = self._get_mapper()
                mapper.range.low_setting = self._orig_low_setting
                mapper.range.high_setting = self._orig_high_setting
            else:
                # "box" mode; reset both axes.
                x_range = self.component.x_mapper.range
                y_range = self.component.y_mapper.range
                x_range.low_setting, y_range.low_setting = \
                    self._orig_low_setting
                x_range.high_setting, y_range.high_setting = \
                    self._orig_high_setting

                # resetting the ranges will allow 'auto' to pick the values
                x_range.reset()
                y_range.reset()

        else:
            # Do a new zoom.
            if self.tool_mode == "range":
                # "range" mode; zoom the one axis.
                mapper = self._get_mapper()
                if self._zoom_limit_reached(orig_low, orig_high, low, high, mapper):
                    self._pop_state()
                    return
                mapper.range.low = low
                mapper.range.high = high
            else:
                # "box" mode; zoom both axes.
                for ndx in (0, 1):
                    mapper = (self.component.x_mapper, self.component.y_mapper)[ndx]
                    if self._zoom_limit_reached(orig_low[ndx], orig_high[ndx],
                                                low[ndx], high[ndx], mapper):
                        # pop _current_state off the stack and leave the actual
                        # bounds unmodified.
                        self._pop_state()
                        return
                x_range = self.component.x_mapper.range
                y_range = self.component.y_mapper.range
                x_range.low, y_range.low = low
                x_range.high, y_range.high = high

        self.component.request_redraw()
        return

    def normal_key_pressed(self, event):
        """ Handles a key being pressed when the tool is in 'normal' state.

        If the tool is not always on, this method handles turning it on and
        off when the appropriate keys are pressed. Also handles keys to
        manipulate the tool history.
        """
        if not self.always_on:
            if not self._enabled and self.enter_zoom_key.match(event):
                if self.component.active_tool in (None, self):
                    self.component.active_tool = self
                    self._enabled = True
                    event.window.set_pointer(self.pointer)
                else:
                    self._enabled = False
                return
            elif self._enabled and self.exit_zoom_key.match(event):
                self._enabled = False
                event.window.set_pointer("arrow")
                return

        self._history_handle_key(event)

        if event.handled:
            self.component.request_redraw()
        return

    def normal_mouse_wheel(self, event):
        """ Handles the mouse wheel being used when the tool is in the 'normal'
        state.

        Scrolling the wheel "up" zooms in; scrolling it "down" zooms out.
        """
        if self.enable_wheel and event.mouse_wheel != 0:
            if event.mouse_wheel > 0:
                # zoom in
                zoom = 1.0 / (1.0 + 0.5 * self.wheel_zoom_step)
            elif event.mouse_wheel < 0:
                # zoom out
                zoom = 1.0 + 0.5 * self.wheel_zoom_step

            # We'll determine the current position of the cursor in screen coordinates,
            # and only afterwards map to dataspace.
            c = self.component
            screenlow_pt, screenhigh_pt = (c.x, c.y), (c.x2, c.y2)
            mouse_pos = (event.x, event.y)

            if self.tool_mode == "range":
                mapper_list = [(self._determine_axis(), self._get_mapper())]
            else:
                mapper_list = [(0, c.x_mapper), (1, c.y_mapper)]

            orig_low, orig_high = self._history[0]

            # If any of the axes reaches its zoom limit, we should cancel the zoom.
            # We should first calculate the new ranges and store them. If none of
            # the axes reach zoom limit, we can apply the new ranges.
            todo_list = []
            for ndx, mapper in mapper_list:
                screenrange = mapper.screen_bounds
                mouse_val = mouse_pos[ndx]
                newscreenlow = mouse_val + zoom * (screenlow_pt[ndx] - mouse_val)
                newscreenhigh = mouse_val + zoom * (screenhigh_pt[ndx] - mouse_val)

                newlow = mapper.map_data(newscreenlow)
                newhigh = mapper.map_data(newscreenhigh)

                if type(orig_high) in (tuple,list):
                    ol, oh = orig_low[ndx], orig_high[ndx]
                else:
                    ol, oh = orig_low, orig_high

                if self._zoom_limit_reached(ol, oh, newlow, newhigh, mapper):
                    # Ignore other axes, we're done.
                    event.handled = True
                    return
                todo_list.append((mapper,newlow,newhigh))

            # Check the domain limits on each dimension, and rescale the zoom
            # amount if necessary.
            for ndx, (mapper, newlow, newhigh) in enumerate(todo_list):
                if newlow > newhigh:
                    # This happens when the orientation of the axis is reversed.
                    newlow, newhigh = newhigh, newlow
                domain_min, domain_max = getattr(mapper, "domain_limits", (None,None))
                if domain_min is not None and newlow < domain_min:
                    newlow = domain_min
                if domain_max is not None and newhigh > domain_max:
                    newhigh = domain_max
                todo_list[ndx] = (mapper, newlow, newhigh)

            # All axes can be rescaled, do it.
            for mapper, newlow, newhigh in todo_list:
                if newlow > newhigh:
                    newlow, newhigh = newhigh, newlow
                mapper.range.set_bounds(newlow, newhigh)

            event.handled = True
            c.request_redraw()
        return

    def _is_enabling_event(self, event):
        always_on = self.always_on
        if self.always_on_modifier == 'shift':
            always_on = always_on and event.shift_down
        elif self.always_on_modifier == 'control':
            always_on = always_on and event.control_down
        elif self.always_on_modifier == 'alt':
            always_on = always_on and event.alt_down

        if always_on or self._enabled:
            if event.right_down and self.drag_button == 'right':
                return True
            if event.left_down and self.drag_button == 'left':
                return True

        return False

    def _component_changed(self):
        if self.traits_inited() and self._get_mapper() is not None:
            self._reset_state_to_current()
        return

    def _tool_mode_changed(self, old, new):
        if not self.traits_inited():
            return

        # The history must be reset because the different tool modes keep
        # different state types in the history
        self._reset_state_to_current()

    #------------------------------------------------------------------------
    # Implementation of PlotComponent interface
    #------------------------------------------------------------------------

    def _activate(self):
        """ Called by PlotComponent to set this as the active tool.
        """
        self.enable()

    #------------------------------------------------------------------------
    # implementations of abstract methods on ToolHistoryMixin
    #------------------------------------------------------------------------

    def _reset_state_to_current(self):
        """ Clears the tool history, and sets the current state to be the
        first state in the history.
        """
        if self.tool_mode == "range":
            mapper = self._get_mapper()
            if mapper is not None:
                self._reset_state((mapper.range.low,
                                   mapper.range.high))
        else:
            if self.component.x_mapper is not None:
                x_range = self.component.x_mapper.range
                xlow = x_range.low
                xhigh = x_range.high
            else:
                xlow = "auto"
                xhigh = "auto"

            if self.component.y_mapper is not None:
                y_range = self.component.y_mapper.range
                ylow = y_range.low
                yhigh = y_range.high
            else:
                ylow = "auto"
                yhigh = "auto"

            self._reset_state(((xlow, ylow),
                               (xhigh, yhigh)))

    def _reset_state_pressed(self):
        """ Called when the tool needs to reset its history.

        The history index will have already been set to 0. Implements
        ToolHistoryMixin.
        """
        # First zoom to the set state (ZoomTool handles setting the index=0).
        self._do_zoom()

        # Now reset the state to the current bounds settings.
        self._reset_state_to_current()
        return

    def _prev_state_pressed(self):
        """ Called when the tool needs to advance to the previous state in the
        stack.

        The history index will have already been set to the index corresponding
        to the prev state. Implements ToolHistoryMixin.
        """
        self._do_zoom()
        return

    def _next_state_pressed(self):
        """ Called when the tool needs to advance to the next state in the stack.

        The history index will have already been set to the index corresponding
        to the next state. Implements ToolHistoryMixin.
        """
        self._do_zoom()
        return

    ### Persistence ###########################################################

    def __getstate__(self):
        dont_pickle = [
            'always_on',
            'always_on_modifier',
            'enter_zoom_key',
            'exit_zoom_key',
            'minimum_screen_delta',
            'event_state',
            'reset_zoom_key',
            'prev_zoom_key',
            'next_zoom_key',
            'pointer',
            '_enabled',
            '_screen_start',
            '_screen_end']
        state = super(SimpleZoom,self).__getstate__()
        for key in dont_pickle:
            if state.has_key(key):
                del state[key]

        return state


########NEW FILE########
__FILENAME__ = plot_toolbar
from __future__ import with_statement

import numpy

from chaco.abstract_overlay import AbstractOverlay
from chaco.tools.toolbars.toolbar_buttons import ToolbarButton, \
        IndexAxisLogButton, ValueAxisLogButton, SaveAsButton, \
        CopyToClipboardButton, ZoomResetButton, ExportDataToClipboardButton
from enable.api import Container
from enable.tools.api import HoverTool
from traits.api import Bool, Float, on_trait_change, List, \
        Tuple, Type, Enum


class PlotToolbarHover(HoverTool):
    _last_xy = Tuple()

    def _is_in(self, x, y):
        return self.component.is_in(x, y)

    def normal_mouse_move(self, event):
        self._last_xy = (event.x, event.y)
        super(PlotToolbarHover, self).normal_mouse_move(event)

    def on_hover(self):
        """ This gets called when all the conditions of the hover action have
        been met, and the tool determines that the mouse is, in fact, hovering
        over a target region on the component.

        By default, this method call self.callback (if one is configured).
        """
        for component in self.component.components:
            if component.is_in(*self._last_xy):
                self.callback(component.label)
                return

        self.callback('')


class PlotToolbar(Container, AbstractOverlay):
    """ A toolbar for embedding buttons in
    """

    buttons = List(Type(ToolbarButton))

    # Should the toolbar be hidden
    hiding = Bool(True)

    # should the toolbar go automatically go back into hiding when the mouse
    # is not hovering over it
    auto_hide = Bool(True)

    # the radius used to determine how round to make the toolbar's edges
    end_radius = Float(4.0)

    # button spacing is defined as the number of pixels on either side of
    # a button. The gap between 2 buttons will be 2 x the button spacing
    button_spacing = Float(5.0)

    # how many pixels to put before and after the set of buttons
    horizontal_padding = Float(5.0)

    # how many pixels to put on top and bottom the set of buttons
    vertical_padding = Float(5.0)

    # The edge against which the toolbar is placed.
    location = Enum('top', 'right', 'bottom', 'left')

    # Should tooltips be shown?
    show_tooltips = Bool(False)

    ############################################################
    # PlotToolbar API
    ############################################################

    def __init__(self, component=None, *args, **kw):
        super(PlotToolbar, self).__init__(*args, **kw)
        self.component = component

        if component is not None and hasattr(component, 'toolbar_location'):
            self.location = component.toolbar_location

        for buttontype in self.buttons:
            self.add_button(buttontype())

        hover_tool = PlotToolbarHover(component=self, callback=self.on_hover)
        self.tools.append(hover_tool)

        if self.location in ['top', 'bottom']:
            self._calculate_width()
        else:
            self._calculate_height()

    def _buttons_default(self):
        return [IndexAxisLogButton, ValueAxisLogButton,
                SaveAsButton, CopyToClipboardButton,
                ExportDataToClipboardButton, ZoomResetButton]

    def add_button(self, button):
        """ adds a button to the toolbar
        """
        self.add(button)
        button.toolbar_overlay = self
        self._layout_needed = True
        return

    def normal_mouse_move(self, event):
        """ handler for normal mouse move
        """
        self.on_hover('')
        if self.hiding:
            self.hiding = False

    def on_hover(self, tooltip):
        if self.show_tooltips:
            self.component.window.set_tooltip(tooltip)

    def normal_left_down(self, event):
        """ handler for a left mouse click
        """
        if self.hiding:
            return
        else:
            for button in self.components:
                if button.is_in(event.x, event.y):
                    button.perform(event)
                    event.handled = True
                    break

    ############################################################
    # AbstractOverlay API
    ############################################################

    def overlay(self, other_component, gc, view_bounds=None, mode="normal"):
        """ Draws this component overlaid on another component.
        """

        starting_color = numpy.array([0.0, 1.0, 1.0, 1.0, 0.5])
        ending_color = numpy.array([1.0, 0.0, 0.0, 0.0, 0.5])

        x = self.x
        y = self.y
        height = self.height

        with gc:
            gc.begin_path()
            gc.move_to(x + self.end_radius, y)
            gc.arc_to(x + self.width, y,
                    x + self.width, y + self.end_radius,
                    self.end_radius)
            gc.arc_to(x + self.width, y + height,
                    x + self.width - self.end_radius, y + height,
                    self.end_radius)
            gc.arc_to(x, y + height,
                    x, y + height - self.end_radius,
                    self.end_radius)
            gc.arc_to(x, y,
                    x + self.end_radius, y,
                    self.end_radius)

            if self.location in ['top', 'bottom']:
                gc.linear_gradient(x, y, x, y + 100,
                        numpy.array([starting_color, ending_color]),
                        "pad")
            else:
                gc.linear_gradient(x, y, x + 100, y,
                        numpy.array([starting_color, ending_color]),
                        "pad")

            gc.draw_path()

            if not self.hiding:
                for button in self.components:
                    button.draw(gc)

    def is_in(self, x, y):
        if (x >= self.x and x <= self.x2) and (y >= self.y and y <= self.y2):
            return True
        return False

    def _do_layout(self, component=None):
        if component is None:
            component = self.component

        if self.location in ['top', 'bottom']:
            if self.hiding:
                self.height = height = 10
            else:
                tallest_button = max([button.height
                                      for button in self.components])
                self.height = height = (tallest_button +
                                        self.vertical_padding * 2)
        else:
            if self.hiding:
                self.width = width = 10
            else:
                widest_button = max([button.width
                                     for button in self.components])
                self.width = width = (widest_button +
                                      self.horizontal_padding * 2)

        if component is not None:
            # Overlay positions are not relative to the component's position,
            # so we have to add in the component's position
            cx, cy = component.outer_position
            if self.location is 'top':
                self.x = (cx + (component.width - self.width) / 2
                          + component.padding_left)
                self.y = (cy + component.height + component.padding_bottom
                          - height - 2)
            elif self.location is 'bottom':
                self.x = (cx + (component.width - self.width) / 2
                          + component.padding_left)
                self.y = cy + component.padding_bottom + 2
            elif self.location is 'left':
                self.x = cx + component.padding_left + 2
                self.y = (cy + (component.height - self.height) / 2
                          + component.padding_bottom)
            else:  # 'right'
                self.x = (cx + component.width + component.padding_left
                          - width - 2)
                self.y = (cy + (component.height - self.height) / 2
                          + component.padding_bottom)

        if self.location in ['top', 'bottom']:
            v_position = self.y + self.vertical_padding * 2

            last_button_position = (self.x + self.horizontal_padding
                                    + self.button_spacing)
            for button in self.components:
                button.x = last_button_position
                button.y = v_position
                last_button_position += button.width + self.button_spacing * 2
        else:
            # location is 'left' or 'right'
            h_position = self.x + self.horizontal_padding

            last_button_position = (self.y + self.vertical_padding
                                    + self.button_spacing)
            for button in reversed(self.components):
                h_offset = (self.width - button.width) / 2
                button.y = last_button_position
                button.x = h_position + h_offset
                last_button_position += button.height + self.button_spacing * 2

    def _dispatch_stateful_event(self, event, suffix):
        if self.is_in(event.x, event.y):
            if suffix == 'mouse_move':
                self.normal_mouse_move(event)
            elif suffix == 'left_down':
                self.normal_left_down(event)
                event.handled = True
        else:
            if self.auto_hide:
                self.hiding = True

        return

    ############################################################
    # Trait handlers
    ############################################################

    @on_trait_change('components, location')
    def _calculate_width(self):
        if self.location in ['top', 'bottom']:
            width = self.horizontal_padding * 2
            for button in self.components:
                width += button.width + self.button_spacing * 2

            self.width = max(10, width)
            self._layout_needed = True
            self.request_redraw()

    @on_trait_change('components, location')
    def _calculate_height(self):
        if self.location in ['left', 'right']:
            height = self.vertical_padding * 2
            for button in self.components:
                height += button.height + self.button_spacing * 2

            self.height = max(10, height)
            self._layout_needed = True
            self.request_redraw()

    @on_trait_change('hiding')
    def _hiding_changed(self):
        self._layout_needed = True
        self.request_redraw()

    @on_trait_change('auto_hide')
    def _auto_hide_changed(self):
        self.hiding = self.auto_hide
        self.request_redraw()

########NEW FILE########
__FILENAME__ = toolbar_buttons
import numpy

from traits.etsconfig.api import ETSConfig
from enable.tools.toolbars.toolbar_buttons import Button
from chaco.tools.zoom_tool import ZoomTool
from chaco.plot_graphics_context import PlotGraphicsContext
from kiva.image import Image
from pyface.image_resource import ImageResource
from pyface.api import FileDialog, OK, error
from traits.api import Instance, Str, Property, cached_property, \
    List, Int, Enum


class ToolbarButton(Button):
    image = Str()
    _image = Instance(Image)

    color = 'black'

    width = Property(Int, depends_on='label, image')
    height = Property(Int, depends_on='label, image')

    # bounds are used for hit testing
    bounds = Property(List, depends_on='label, image')

    def __init__(self, *args, **kw):
        super(ToolbarButton, self).__init__(*args, **kw)

        image_resource = ImageResource(self.image)
        self._image = Image(image_resource.absolute_path)

    @cached_property
    def _get_width(self):
        gc = PlotGraphicsContext((100, 100), dpi=72)
        gc.set_font(self.label_font)
        (w, h, descent, leading) = gc.get_full_text_extent(self.label)
        return max(self._image.width(), w)

    @cached_property
    def _get_height(self):
        gc = PlotGraphicsContext((100, 100), dpi=72)
        gc.set_font(self.label_font)
        (w, h, descent, leading) = gc.get_full_text_extent(self.label)
        return self._image.height() + h

    @cached_property
    def _get_bounds(self):
        return [self.width, self.height]

    def _draw_actual_button(self, gc):
        x_offset = self.x + (self.width - self._image.width()) / 2
        gc.draw_image(self._image,
                      (x_offset, self.y + 2, self._image.width(),
                       self._image.height()))

        if self.label is not None and len(self.label) > 0:
            gc.set_font(self.label_font)

            (w, h, descent, leading) = gc.get_full_text_extent(self.label)
            if w < self.width:
                x_offset = self.x + (self.width - w) / 2
            else:
                x_offset = self.x

            gc.set_text_position(x_offset, self.y - 8)
            gc.show_text(self.label)


class IndexAxisLogButton(ToolbarButton):
    label = 'X Log Scale'
    tooltip = 'Change index axis scale'
    image = 'zoom-fit-width'

    def perform(self, event):
        if self.container.component.index_scale == 'linear':
            self.container.component.index_scale = 'log'
        else:
            self.container.component.index_scale = 'linear'
        self.container.request_redraw()
        return


class ValueAxisLogButton(ToolbarButton):
    label = 'Y Log Scale'
    tooltip = 'Change value axis scale'
    image = 'zoom-fit-height'

    def perform(self, event):
        if self.container.component.value_scale == 'linear':
            self.container.component.value_scale = 'log'
        else:
            self.container.component.value_scale = 'linear'
        self.container.request_redraw()
        return


class ZoomResetButton(ToolbarButton):
    label = 'Zoom Reset'
    tooltip = 'Zoom Reset'
    image = 'zoom-original'

    def perform(self, event):
        plot_component = self.container.component

        for overlay in plot_component.overlays:
            if isinstance(overlay, ZoomTool):
                overlay._reset_state_pressed()

        self.container.request_redraw()


class SaveAsButton(ToolbarButton):
    label = 'Save As'
    tooltip = 'Save As'
    image = 'document-save'

    def perform(self, event):

        plot_component = self.container.component

        filter = 'PNG file (*.png)|*.png|\nTIFF file (*.tiff)|*.tiff|'
        dialog = FileDialog(action='save as', wildcard=filter)

        if dialog.open() != OK:
            return

        # Remove the toolbar before saving the plot, so the output doesn't
        # include the toolbar.
        plot_component.remove_toolbar()

        filename = dialog.path

        width, height = plot_component.outer_bounds

        gc = PlotGraphicsContext((width, height), dpi=72)
        gc.render_component(plot_component)
        try:
            gc.save(filename)
        except KeyError, e:
            errmsg = ("The filename must have an extension that matches "
                      "a graphics format, such as '.png' or '.tiff'.")
            if str(e.message) != '':
                errmsg = ("Unknown filename extension: '%s'\n" %
                          str(e.message)) + errmsg

            error(None, errmsg, title="Invalid Filename Extension")

        # Restore the toolbar.
        plot_component.add_toolbar()


class CopyToClipboardButton(ToolbarButton):
    label = "Copy Image"
    tooltip = 'Copy to the clipboard'
    image = 'edit-copy'

    def perform(self, event):
        plot_component = self.container.component

        # Remove the toolbar before saving the plot, so the output doesn't
        # include the toolbar.
        plot_component.remove_toolbar()

        width, height = plot_component.outer_bounds

        gc = PlotGraphicsContext((width, height), dpi=72)
        gc.render_component(plot_component)

        if ETSConfig.toolkit == 'wx':
            self._perform_wx(width, height, gc)
        else:
            pass

        # Restore the toolbar.
        plot_component.add_toolbar()

    def _perform_wx(self, width, height, gc):
        import wx

        bitmap = wx.BitmapFromBufferRGBA(width + 1, height + 1,
                                         gc.bmp_array.flatten())
        data = wx.BitmapDataObject()
        data.SetBitmap(bitmap)
        if wx.TheClipboard.Open():
            wx.TheClipboard.SetData(data)
            wx.TheClipboard.Close()
        else:
            wx.MessageBox("Unable to open the clipboard.", "Error")


class ExportDataToClipboardButton(ToolbarButton):
    label = "Copy Data"
    tooltip = 'Copy data to the clipboard'
    image = 'application-vnd-ms-excel'

    orientation = Enum('v', 'h')

    def perform(self, event):
        if ETSConfig.toolkit == 'wx':
            self._perform_wx()
        elif ETSConfig.toolkit == 'qt4':
            self._perform_qt()
        else:
            pass

    def _get_data_from_plots(self):
        values = []
        indices = []
        for renderers in self.container.component.plots.values():
            for renderer in renderers:
                indices.append(renderer.index.get_data())
                values.append(renderer.value.get_data())
        return indices, values

    def _serialize_data(self, indices, values):

        # if all of rows are the same length, use faster algorithms,
        # otherwise go element by element adding the necessary empty strings
        if len(set([len(l) for l in values])) == 1:
            data = [indices[0]] + values
            if self.orientation == 'v':
                data = numpy.array(data).T.tolist()

            data_str = ''
            for row in data:
                data_str += ','.join(['%f' % v for v in row]) + '\n'
            return data_str

        else:
            # There might not be a single solution which fits all cases,
            # so this is left to specific implementations to override
            raise NotImplementedError()

    def _perform_wx(self):
        import wx

        indices, values = self._get_data_from_plots()
        data_str = self._serialize_data(indices, values)
        data_obj = wx.TextDataObject(data_str)

        if wx.TheClipboard.Open():
            wx.TheClipboard.SetData(data_obj)
            wx.TheClipboard.Close()
        else:
            wx.MessageBox("Unable to open the clipboard.", "Error")

    def _perform_qt(self):
        from pyface.qt import QtGui

        indices, values = self._get_data_from_plots()
        data_str = self._serialize_data(indices, values)

        QtGui.QApplication.clipboard().setText(data_str)
########NEW FILE########
__FILENAME__ = tool_history_mixin
""" Defines the ToolHistoryMixin class.
"""
from traits.api import HasTraits, Instance, Int, List
from enable.api import KeySpec


class ToolHistoryMixin(HasTraits):
    """ A mix-in class for tools to maintain a tool state history and to move
    backwards and forwards through that history stack.

    This mix-in listens for keypressed events; to handle keypresses in a
    subclass, call self._history_handle_key(event) to have this mix-in properly
    process the event.
    """

    # Key to go to the original or start state in the history.
    reset_state_key = Instance(KeySpec, args=("Esc",))

    # Key to go to the previous state in the history.
    prev_state_key = Instance(KeySpec, args=("Left", "control"))

    # Key to go to the next state in the history.
    next_state_key = Instance(KeySpec, args=("Right", "control"))

    # The state stack.
    _history = List

    # The current index into _history
    _history_index = Int

    #------------------------------------------------------------------------
    # Abstract methods that subclasses must implement to handle keypresses
    #------------------------------------------------------------------------

    def _next_state_pressed(self):
        """ Called when the tool needs to advance to the next state in the
        stack.

        The **_history_index** will have already been set to the index
        corresponding to the next state.
        """
        pass

    def _prev_state_pressed(self):
        """ Called when the tool needs to advance to the previous state in the
        stack.

        The **_history_index** will have already been set to the index
        corresponding to the previous state.
        """
        pass

    def _reset_state_pressed(self):
        """ Called when the tool needs to reset its history.

        The history index will have already been set to 0.
        """
        pass


    #------------------------------------------------------------------------
    # Protected methods for subclasses to use
    #------------------------------------------------------------------------

    def _current_state(self):
        """ Returns the current history state.
        """
        return self._history[self._history_index]

    def _reset_state(self, state):
        """ Clears the history stack and sets the first or original state in
        the history to *state*.
        """
        self._history = [state]
        self._history_index = 0
        return

    def _append_state(self, state, set_index=True):
        """ Clears the history after the current **_history_index**, and
        appends the given state to the history.

        If *set_index* is True, the method sets the **_history_index** to
        match the new, truncated history. If it is False, the history index
        is unchanged.
        """
        new_history = self._history[:self._history_index+1] + [state]
        self._history = new_history
        if set_index:
            self._history_index = len(self._history) - 1
        return

    def _pop_state(self):
        """ Pops the most last state off the history stack.

        If the history index points to the end of the stack, then it is
        adjusted; otherwise, the index is unaffected. If the stack is empty,
        the method raises an IndexError.

        Returns the popped state.
        """
        if len(self._history) == 0:
            raise IndexError("Unable to pop empty history stack.")

        if self._history_index == len(self._history) - 1:
            self._history_index -= 1

        return self._history.pop()

    #------------------------------------------------------------------------
    # Private methods / event handlers
    #------------------------------------------------------------------------

    def normal_key_pressed(self, event):
        """ Handles a key being pressed, and takes appropriate action if it is
        one of the history keys defined for this class.
        """
        self._history_handle_key(event)
        return

    def _history_handle_key(self, event):
        if self.reset_state_key is not None and self.reset_state_key.match(event):
            self._history_index = 0
            self._reset_state_pressed()
            event.handled = True
        elif self.prev_state_key is not None and self.prev_state_key.match(event):
            if self._history_index > 0:
                self._history_index -= 1
                self._prev_state_pressed()
            event.handled = True
        elif self.next_state_key is not None and self.next_state_key.match(event):
            if self._history_index <= len(self._history) - 2:
                self._history_index += 1
                self._next_state_pressed()
            event.handled = True
        else:
            return




# EOF

########NEW FILE########
__FILENAME__ = tool_states
from chaco.grid_mapper import GridMapper
from traits.api import HasTraits

class ToolState(HasTraits):

    def __init__(self, prev, next):
        self.prev = prev
        self.next = next

    def apply(self, tool):
        raise NotImplementedError()

    def revert(self, tool):
        raise NotImplementedError()

class GroupedToolState(ToolState):

    def __init__(self, states):
        self.states = states

    def apply(self, tool):
        for state in self.states:
            state.apply(tool)

    def revert(self, tool):
        for state in self.states[::-1]:
            state.revert(tool)

class PanState(ToolState):


    def apply(self, tool):
        if isinstance(tool.component.index_mapper, GridMapper):
            index_mapper = tool.component.index_mapper._xmapper
            value_mapper = tool.component.index_mapper._ymapper
        else:
            index_mapper = tool.component.index_mapper
            value_mapper = tool.component.value_mapper
        if self.next[0] != self.prev[0]:
            high = index_mapper.range.high
            low = index_mapper.range.low
            range = high-low

            index_mapper.range.high = self.next[0] + range/2
            index_mapper.range.low = self.next[0] - range/2

        if self.next[1] != self.prev[1]:
            high = value_mapper.range.high
            low = value_mapper.range.low
            range = high-low

            value_mapper.range.high = self.next[1] + range/2
            value_mapper.range.low = self.next[1] - range/2

    def revert(self, tool):
        if isinstance(tool.component.index_mapper, GridMapper):
            index_mapper = tool.component.index_mapper._xmapper
            value_mapper = tool.component.index_mapper._ymapper
        else:
            index_mapper = tool.component.index_mapper
            value_mapper = tool.component.value_mapper

        if self.next[0] != self.prev[0]:
            high = index_mapper.range.high
            low = index_mapper.range.low
            range = high-low

            index_mapper.range.high = self.prev[0] + range/2
            index_mapper.range.low = self.prev[0] - range/2

        if self.next[1] != self.prev[1]:
            high = value_mapper.range.high
            low = value_mapper.range.low
            range = high-low

            value_mapper.range.high = self.prev[1] + range/2
            value_mapper.range.low = self.prev[1] - range/2

class ZoomState(ToolState):
    """ A zoom state which can be applied and reverted.

        This class exists so that subclasses can introduce new types
        of events which can be applied and reverted in the same manner.
        This greatly eases the code for managing history
    """
    def apply(self, zoom_tool):
        index_factor = self.next[0]/self.prev[0]
        value_factor = self.next[1]/self.prev[1]

        if isinstance(zoom_tool.component.index_mapper, GridMapper):
            index_mapper = zoom_tool.component.index_mapper._xmapper
            value_mapper = zoom_tool.component.index_mapper._ymapper
        else:
            index_mapper = zoom_tool.component.index_mapper
            value_mapper = zoom_tool.component.value_mapper

        if index_factor != 1.0:
            zoom_tool._zoom_in_mapper(index_mapper, index_factor)
        if value_factor != 1.0:
            zoom_tool._zoom_in_mapper(value_mapper, value_factor)

        zoom_tool._index_factor = self.next[0]
        zoom_tool._value_factor = self.next[1]

        # TODO: Clip to domain bounds by inserting a pan tool and altering the
        # index factor and value factor


    def revert(self, zoom_tool):
        if isinstance(zoom_tool.component.index_mapper, GridMapper):
            index_mapper = zoom_tool.component.index_mapper._xmapper
            value_mapper = zoom_tool.component.index_mapper._ymapper
        else:
            index_mapper = zoom_tool.component.index_mapper
            value_mapper = zoom_tool.component.value_mapper

        zoom_tool._zoom_in_mapper(index_mapper,
                                  self.prev[0]/self.next[0])
        zoom_tool._zoom_in_mapper(value_mapper,
                                  self.prev[1]/self.next[1])

        zoom_tool._index_factor = self.prev[0]
        zoom_tool._value_factor = self.prev[1]

class SelectedZoomState(ZoomState):
    def apply(self, zoom_tool):
        x_mapper = zoom_tool._get_x_mapper()
        y_mapper = zoom_tool._get_y_mapper()

        x_mapper.range.low = self.next[0]
        x_mapper.range.high = self.next[1]
        y_mapper.range.low = self.next[2]
        y_mapper.range.high = self.next[3]

    def revert(self, zoom_tool):
        x_mapper = zoom_tool._get_x_mapper()
        y_mapper = zoom_tool._get_y_mapper()

        x_mapper.range.low = self.prev[0]
        x_mapper.range.high = self.prev[1]
        y_mapper.range.low = self.prev[2]
        y_mapper.range.high = self.prev[3]

########NEW FILE########
__FILENAME__ = tracking_pan_tool
""" Defines the TrackingPanTool class.
"""
# Chaco imports
from chaco.tools.api import PanTool

class TrackingPanTool(PanTool):
    """ Allows the user to pan around a plot.

    The user clicks a mouse button and drags to pan; the tool then returns to
    a tracking state.
    """

    def _end_pan(self, event):
        plot = self.component
        xrange = plot.x_mapper.range
        yrange = plot.y_mapper.range

        if not self.constrain or self.constrain_direction == "x":
            high = xrange.high
            low = xrange.low
            if xrange.default_state == 'low_track':
                hi_val = max([source.get_bounds()[1] for source in xrange.sources])
                if hi_val >= low and hi_val <= high:
                    xrange.set_bounds('track','auto')
            elif xrange.default_state == 'high_track':
                lo_val = min([source.get_bounds()[0] for source in xrange.sources])
                if lo_val >= low and lo_val <= high:
                    xrange.set_bounds('auto','track')

        if not self.constrain or self.constrain_direction == "y":
            high = yrange.high
            low = yrange.low
            if yrange.default_state == 'low_track':
                hi_val = max([source.get_bounds()[1] for source in yrange.sources])
                if hi_val >= low and hi_val <= high:
                    yrange.set_bounds('track','auto')
            elif yrange.default_state == 'high_track':
                lo_val = min([source.get_bounds()[0] for source in yrange.sources])
                if lo_val >= low and lo_val <= high:
                    yrange.set_bounds('auto','track')

        if self._auto_constrain:
            self.constrain = False
            self.constrain_direction = None
        self.event_state = "normal"
        event.window.set_pointer("arrow")
        if event.window.mouse_owner == self:
            event.window.set_mouse_owner(None)


        event.handled = True
        return

# EOF

########NEW FILE########
__FILENAME__ = tracking_zoom
""" Defines the TrackingZoom class.
"""

# Chaco imports
from zoom_tool import ZoomTool

class TrackingZoom(ZoomTool):
    """ Allows the user to zoom in or out on a plot that is using tracking.

    The **default_state** of the data range determines the tracking behavior.
    For example, if the data range's **default_state** is "low_track",
    the range's high value snaps to the right edge and the tracking, low, value
    follows it by the data range's **tracking_amount** value (and vice versa
    for "high_track").
    """


    def normal_mouse_wheel(self, event):
        """ Handles the mouse wheel being used when the tool is in the 'normal'
        state.

        Overrides ZoomTool
        """
        if self.enable_wheel and event.mouse_wheel != 0:
            if event.mouse_wheel > 0:
                # zoom in
                zoom = 1.0 / (1.0 + 0.5 * self.wheel_zoom_step)
            elif event.mouse_wheel < 0:
                # zoom out
                zoom = 1.0 + 0.5 * self.wheel_zoom_step

            # We'll determine the current position of the cursor in dataspace,
            # then zoom in while trying to maintain the mouse screen coordinates
            # in the new range.
            c = self.component
            low_pt, high_pt = self._map_coordinate_box((c.x, c.y), (c.x2, c.y2))
            mouse_pos = (c.x_mapper.map_data(event.x), c.y_mapper.map_data(event.y))

            if self.tool_mode == "range":
                datarange_list = [(self._determine_axis(), self._get_mapper().range)]
            else:
                datarange_list = [(0, c.x_mapper.range), (1, c.y_mapper.range)]

            orig_low, orig_high = self._history[0]
            for ndx, datarange in datarange_list:
                mouse_val = mouse_pos[ndx]
                newlow = mouse_val - zoom * (mouse_val - low_pt[ndx])
                newhigh = mouse_val + zoom * (high_pt[ndx] - mouse_val)

                if type(orig_high) in (tuple,list):
                    ol, oh = orig_low[ndx], orig_high[ndx]
                else:
                    ol, oh = orig_low, orig_high

                if self._zoom_limit_reached(ol, oh, newlow, newhigh):
                    event.handled = True
                    return

                if datarange.default_state == 'low_track':
                    hi = max([source.get_bounds()[1] for source in datarange.sources])
                    #is hi in the current view?
                    if hi >= low_pt[ndx] and hi <= high_pt[ndx]:
                        datarange.scale_tracking_amount(zoom)
                        newhigh = 'auto'
                        newlow = 'track'

                elif datarange.default_state == 'high_track':
                    lo = min([source.get_bounds()[0] for source in datarange.sources])
                    #is lo in the current view?
                    if lo >= low_pt[ndx] and lo <= high_pt[ndx]:
                        datarange.scale_tracking_amount(zoom)
                        newlow = 'auto'
                        newhigh = 'track'

                datarange.set_bounds(newlow, newhigh)
            event.handled = True
            self.component.request_redraw()
        return

########NEW FILE########
__FILENAME__ = traits_tool
""" Defines the TraitsTool and Fifo classes, and get_nested_components90
function.
"""
# Enthought library imports
from enable.api import BaseTool, Container
from traits.api import List, Dict, Str

# Chaco imports
from chaco.api import PlotAxis, ColorBar


class Fifo(object):
    """ Slightly-modified version of the Fifo class from the Python cookbook:
        http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/68436
    """
    def __init__(self):
        self.nextin = 0
        self.nextout = 0
        self.data = {}
    def append(self, value):
        self.data[self.nextin] = value
        self.nextin += 1
    def extend(self, values):
        if len(values) > 0:
            for i,val in enumerate(values):
                self.data[i+self.nextin] = val
            self.nextin += i+1
    def isempty(self):
        return self.nextout >= self.nextin
    def pop(self):
        value = self.data[self.nextout]
        del self.data[self.nextout]
        self.nextout += 1
        return value


def get_nested_components(container, classes):
    """ Returns a list of fundamental plotting components from a container
    with nested containers.

    Performs a breadth-first search of the containment hierarchy. Each element
    in the returned list is a tuple (component, (x,y)) where (x,y) is the
    coordinate frame offset of the component from the top-level container.
    """
    components = []
    worklist = Fifo()
    worklist.append((container, (0,0)))
    while 1:
        item, offset = worklist.pop()
        if isinstance(item, Container):
            new_offset = (offset[0]+item.x, offset[1]+item.y)
            for c in item.components:
                worklist.append((c, new_offset))
            for overlay in item.overlays + item.underlays:
                components.append((overlay, offset))
        elif any([isinstance(item, klass) for klass in classes]):
            components.append((item, offset))
            for overlay in item.overlays + item.underlays:
                components.append((overlay, offset))
        if worklist.isempty():
            break
    return components


class TraitsTool(BaseTool):
    """ Tool to edit the traits of plots, grids, and axes.
    """

    # This tool does not have a visual representation (overrides BaseTool).
    draw_mode = "none"
    # This tool is not visible (overrides BaseTool).
    visible = False

    # The classes of components that should trigger a traits view
    classes = List([PlotAxis, ColorBar])

    # A dict of Class : View providing alternate views for a particular component
    views = Dict

    # The event to trigger the edit on
    event = Str('left_dclick')

    def _dispatch_stateful_event(self, event, suffix):
        """If the event type matches the specification in *event*, look for a component that
           matches one of the classes in *classes* in our containment hierarchy.  If one is found,
           edit it using either the default editor, or an alternate editor specified in *views*
        """
        if suffix != self.event:
            return

        x = event.x
        y = event.y

        # First determine what component or components we are going to hittest
        # on.  If our component is an Axis or PlotRenderer of any sort,
        # then that is the only candidate.  If our component is a container,
        # then we add its non-container components to the list of candidates;
        # any nested containers are lower priority than primary plot components.
        candidates = get_nested_components(self.component, [Container] + self.classes)

        # Hittest against all the candidate and take the first one
        item = None
        for candidate, offset in candidates:
            if candidate.is_in(x-offset[0], y-offset[1]):
                item=candidate
                break

        if item is not None:
            self.component.active_tool = self
            if item.__class__ in self.views:
                item.edit_traits(kind="livemodal",
                                 view=self.views[item.__class__],
                                 parent=event.window.control)
            else:
                item.edit_traits(kind="livemodal",
                                 parent=event.window.control)
            event.handled = True
            self.component.active_tool = None
            item.request_redraw()

        return



# EOF

########NEW FILE########
__FILENAME__ = zoom_tool
from better_selecting_zoom import BetterSelectingZoom as ZoomTool

########NEW FILE########
__FILENAME__ = tooltip
""" Defines the ToolTip class.
"""

from __future__ import with_statement

from numpy import array

# Enthought library imports
from enable.api import black_color_trait, white_color_trait
from enable.font_metrics_provider import font_metrics_provider
from kiva.trait_defs.kiva_font_trait import KivaFont
from traits.api import Any, Bool, List, Int, Float, on_trait_change


# Local imports
from abstract_overlay import AbstractOverlay
from plot_component import PlotComponent
from label import Label


class ToolTip(AbstractOverlay):
    """ An overlay that is a toolip.
    """
    # The font to render the tooltip.
    font = KivaFont('modern 10')

    # The color of the text in the tooltip
    text_color = black_color_trait

    # The ammount of space between the border and the text.
    border_padding = Int(4)

    # The number of pixels between lines.
    line_spacing = Int(4)

    # List of text strings to put in the tooltip.
    lines = List

    # Angle to rotate (counterclockwise) in degrees. NB this will *only*
    # currently affect text, so probably only useful if borders and background
    # are disabled
    rotate_angle = Float(0.0)

    # Should the tooltip automatically reposition itself to remain visible
    # and unclipped on its overlaid component?
    auto_adjust = Bool(True)

    # The tooltip is a fixed size. (Overrides PlotComponent.)
    resizable = ""

    # Use a visible border. (Overrides Enable Component.)
    border_visible = True

    # Use a white background color (overrides AbstractOverlay).
    bgcolor = white_color_trait

    #----------------------------------------------------------------------
    # Private Traits
    #----------------------------------------------------------------------

    _font_metrics_provider = Any()

    _text_props_valid = Bool(False)

    _max_line_width = Float(0.0)

    _total_line_height = Float(0.0)

    def draw(self, gc, view_bounds=None, mode='normal'):
        """ Draws the plot component.

        Overrides PlotComponent.
        """
        self.overlay(self, gc, view_bounds=view_bounds, mode='normal')
        return

    def overlay(self, component, gc, view_bounds=None, mode='normal'):
        """ Draws the tooltip overlaid on another component.

        Overrides AbstractOverlay.
        """
        self.do_layout()
        PlotComponent._draw(self, gc, view_bounds, mode)
        return

    def _draw_overlay(self, gc, view_bounds=None, mode='normal'):
        """ Draws the overlay layer of a component.

        Overrides PlotComponent.
        """
        with gc:
            edge_space = self.border_width + self.border_padding
            gc.translate_ctm(self.x + edge_space, self.y)
            y = self.height - edge_space
            for i, label in enumerate(self._cached_labels):
                label_height = self._cached_line_sizes[i][1]
                y -= label_height
                gc.translate_ctm(0,y)
                label.draw(gc)
                gc.translate_ctm(0,-y)
                y -= self.line_spacing
        return


    def _do_layout(self):
        """Computes the size of the tooltip, and creates the label objects
        for each line.

        Overrides PlotComponent.
        """
        if not self._text_props_valid:
            self._recompute_text()

        outer_bounds = [self._max_line_width + 2*self.border_padding + self.hpadding,
                             self._total_line_height + 2*self.border_padding + self.vpadding]

        self.outer_bounds = outer_bounds

        if self.auto_adjust and self.component is not None:
            new_pos = list(self.outer_position)
            for dimindex in (0,1):
                pos = self.position[dimindex]
                extent = outer_bounds[dimindex]
                c_min = self.component.position[dimindex]
                c_max = c_min + self.component.bounds[dimindex]
                # Is the tooltip just too wide/tall?
                if extent > (c_max - c_min):
                    new_pos[dimindex] = c_min
                # Does it extend over the c_max edge?  (right/top)
                elif pos + extent > c_max:
                    new_pos[dimindex] = c_max - extent

                # Does it extend over the c_min edge? This is not an elif so
                # that we can fix the situation where the c_max edge adjustment
                # above pushes the position negative.
                if new_pos[dimindex] < c_min:
                    new_pos[dimindex] = c_min

            self.outer_position = new_pos

        self._layout_needed = False

    def _recompute_text(self):
        labels = [Label(text=line, font=self.font, margin=0,
                        bgcolor='transparent', border_width=0,
                        color=self.text_color, rotate_angle=self.rotate_angle)
                    for line in self.lines]
        dummy_gc = self._font_metrics_provider
        line_sizes = array([label.get_width_height(dummy_gc)
                            for label in labels])
        self._cached_labels = labels
        self._cached_line_sizes = line_sizes
        self._max_line_width = max(line_sizes[:,0])
        self._total_line_height = sum(line_sizes[:,1]) + \
                                  len(line_sizes-1)*self.line_spacing
        self._layout_needed = True
        return

    def __font_metrics_provider_default(self):
        return font_metrics_provider()

    @on_trait_change("font,text_color,lines,lines_items")
    def _invalidate_text_props(self):
        self._text_props_valid = False
        self._layout_needed = True

    @on_trait_change("border_padding,line_spacing,lines,lines_items,padding")
    def _invalidate_layout(self):
        self._layout_needed = True
        self.request_redraw()

########NEW FILE########
__FILENAME__ = transform_color_mapper
from numpy import clip, isinf, ones_like, empty

from chaco.api import ColorMapper
from traits.api import Trait, Callable, Tuple, Float, on_trait_change

from speedups import map_colors, map_colors_uint8

class TransformColorMapper(ColorMapper):
    """This class adds arbitrary data transformations to a ColorMapper.
    
    The default ColorMapper is basically a linear mapper from data space to
    color space.  A TransformColorMapper allows a nonlinear mapper to be
    created.
    
    A ColorMapper works by linearly transforming the data from data space to the
    unit interval [0,1], and then linearly mapping that interval to the color
    space.
    
    A TransformColorMapper allows an arbitrary transform to be inserted at two
    places in this process.  First, an initial transformation, `data_func` can
    be applied to the data *before* is it mapped to [0,1].  Then another
    function, `unit_func`, can be applied to the transformed data on [0,1]
    before it is mapped to color space.  Normally, a `unit_func` is map of the
    unit interval [0,1] to itself (e.g. x^2 or sin(pi*x/2)).
    """

    data_func = Trait(None, None, Callable)
    
    unit_func = Trait(None, None, Callable)
    
    transformed_bounds = Tuple(Trait(None, None, Float),
                               Trait(None, None, Float))
    
    #-------------------------------------------------------------------
    # Trait handlers
    #-------------------------------------------------------------------       

    @on_trait_change('data_func, range.updated')
    def _update_transformed_bounds(self):

        if self.range is None:
            # The ColorMapper doesn't have a range yet, so don't do anything.
            # This apparently occurs during initialization.
            return
        if self.data_func is not None:
            low = self.range.low
            high = self.range.high
            trans_low = self.data_func(low)
            trans_high = self.data_func(high)
            self.transformed_bounds = (trans_low, trans_high)
        else:
            self.transformed_bounds = (None, None)
        self.updated = True

    def _unit_func_changed(self):
        self.updated = True

    #-------------------------------------------------------------------
    # Class methods
    #-------------------------------------------------------------------

    @classmethod
    def from_color_mapper(cls, color_mapper, data_func=None, unit_func=None,
                          **traits):
        """ Create a TransformColorMapper from an existing ColorMapper instance.
        """
        segdata = color_mapper._segmentdata
        return cls.from_segment_map(segdata, range=color_mapper.range,
                                    data_func=data_func, unit_func=unit_func,
                                    **traits)

    @classmethod
    def from_color_map(cls, color_map, data_func=None, unit_func=None,
                       **traits):
        """Create a TransformColorMapper from a colormap generator function.
        
        The return value is an instance of TransformColorMapper, *not* a factory
        function, so this does not provide a direct replacement for a standard
        colormap factory function.  For that, use the class method
        TransoformColorMapper.factory_from_color_map().
        """
        # Call the colormap factory function to create an instance of a
        # ColorMapper.
        color_mapper = color_map(None, **traits)
        segdata = color_mapper._segmentdata
        return cls.from_segment_map(segdata, range=color_mapper.range,
                                    data_func=data_func, unit_func=unit_func,
                                    **traits)

    @classmethod
    def factory_from_color_map(cls, color_map, data_func=None, unit_func=None,
                               **traits):
        """
        Create a TransformColorMapper factory function from a standard colormap
        factory function.
        
        WARNING: This function is untested; I realized I didn't need it shortly
        after writing it, so I haven't tried it yet. --WW
        """
        # Call the colormap factory function to create an instance of a
        # ColorMapper.
        color_mapper = color_map(None, **traits)

        def factory(range, **traits):
            tcm = cls.from_color_mapper(color_mapper,
                            data_func=data_func, unit_func=unit_func, **traits)
            return tcm

        return factory

    #-------------------------------------------------------------------
    # ColorMapper interface (these override methods from ColorMapper)
    #-------------------------------------------------------------------

    def map_screen(self, data_array):
        """ Maps an array of data values to an array of colors.
        """

        norm_data = self._compute_normalized_data(data_array)
        # The data are normalized, so we can pass low = 0, high = 1
        rgba = map_colors(norm_data, self.steps, 0, 1, self._red_lut,
                self._green_lut, self._blue_lut, self._alpha_lut)
        return rgba


    def map_index(self, data_array):
        """ Maps an array of values to their corresponding color band index. 
        """
        norm_data = self._compute_normalized_data(data_array)
        indices = (norm_data * (self.steps-1)).astype(int)
        return indices

    def map_uint8(self, data_array):
        """ Maps an array of data values to an array of colors.
        """
        norm_data = self._compute_normalized_data(data_array)
        rgba = map_colors_uint8(norm_data, self.steps, 0.0, 1.0,
                self._red_lut_uint8, self._green_lut_uint8,
                self._blue_lut_uint8, self._alpha_lut_uint8)

        return rgba

    #-------------------------------------------------------------------
    # Private methods
    #-------------------------------------------------------------------

    def _compute_normalized_data(self, data_array):
        """
        Apply `data_func`, then linearly scale to the unit interval, and
        then apply `unit_func`.
        """
        
        # FIXME: Deal with nans?

        if self._dirty:
            self._recalculate()

        if self.data_func is not None:
            data_array = self.data_func(data_array)
            low, high = self.transformed_bounds
        else:
            low, high = self.range.low, self.range.high
        range_diff = high - low

        # Linearly transform the values to the unit interval.        

        if range_diff == 0.0 or isinf(range_diff):
            # Handle null range, or infinite range (which can happen during 
            # initialization before range is connected to a data source).
            norm_data = 0.5*ones_like(data_array)
        else:
            norm_data = empty(data_array.shape, dtype='float32')
            norm_data[:] = data_array
            norm_data -= low
            norm_data /= range_diff
            clip(norm_data, 0.0, 1.0, norm_data)

        if self.unit_func is not None:
            norm_data = self.unit_func(norm_data)

        return norm_data

########NEW FILE########
__FILENAME__ = axis_ui
""" This file contains the ui specifications for the chaco.axis.Axis objects.

    Much of it is defined in re-usable chunks so that elements of it can be
    used in UIs of objects that contain an axis.

"""

# Enthought Imports
from traitsui.api import View, Group, VGroup, HGroup, Item, TextEditor

title_group = Group(
                    Item("title", label="Text", editor=TextEditor()),
                    # Fix me: We really don't have an reasonable font editor.
                    #Item("title_font", label="Font", style="custom"),
                    Item("title_color", label="Color", style="simple"),
              )

axis_line_group = Group(
                        Item("axis_line_visible", label="Visible"),
                        Group(
                              Item("axis_line_color", label="Color", style="simple"),
                              Item("axis_line_weight", label="Thickness"),
                              # Line Style
                              enabled_when='object.axis_line_visible==True',
                        ),
                  )

tick_labels_group = Group(
                          # fix me: We need a 'Visible' trait on that determines
                          #         whether tick labels are visible or not.
                          # Visible -- The rest should be in a group that is enabled
                          #            by this.
                          # Fix me: Need an reasonable font editor.
                          #Item("tick_label_font", label="Font"),
                          Item("tick_label_color", label="Color", style="simple"),
                          # Fix me: set the rotation of the label.
                          # Rotation
                          # Fix me: Set the offset (in pixels?) of the label to
                          #         allow people to "bump" them up or down.
                          # Offset
                          # Fix me: Are labels next to the axis or off the side of the
                          #         plot?
                          # relative_to: axis|plot_min|plot_max
                   )

tick_lines_group = Group(
                         Item("tick_visible", label="Visible"),
                         Group(
                               # These are the only non-axis part of the view...
                               HGroup(
                                      # fix me: THe enabled_when is not working
                                      #         correctly. This failure began
                                      #         when we switched to using context.
                                      Item("tick_interval_ui", label="Interval",
                                           enabled_when = "object.tick_interval_auto_ui == False"),
                                      Item("tick_interval_auto_ui", label="Auto"),
                               ),
                               Item("tick_color", label="Color", style="simple"),
                               Item("tick_weight", label="Thickness"),
                               #HGroup(
                                      Item("tick_in", label="Tick in (pixels)"),
                                      Item("tick_out", label="Tick out (pixels)"),
                               #),
                               enabled_when="object.tick_visible==True",
                         ),
                    )

tick_lines_group = Group(
                         Item("tick_visible", label="Visible"),
                         Group(
                               Item("tick_color", label="Color", style="simple"),
                               Item("tick_weight", label="Thickness"),
                               Item("tick_in", label="Tick in (pixels)"),
                               Item("tick_out", label="Tick out (pixels)"),
                               # Fix me: We really need to split out the tick interval
                               #         into a UI like this.
                               #HGroup(
                               #       Item("tick_interval_ui", label="Interval",
                               #            enabled_when = "object.tick_interval_auto_ui == False"),
                               #       Item("tick_interval_auto_ui", label="Auto"),
                               #),
                               Item(label="Note: Tick Interval not currently settable."),
                               enabled_when="object.tick_visible==True",
                         ),
                    )

# We are missing a group to specify the "scale" or "range" setting


# The main view for an axis...

default_view = View(
                    VGroup(Group(title_group, label='Title', show_border=True),
                           Group(axis_line_group, label='Axis Line', show_border=True),
                           HGroup(
                                  Group(tick_lines_group,
                                        label='Tick Lines', show_border=True),
                                  Group(tick_labels_group,
                                        label='Labels', show_border=True),
                                  label='Ticks',
                           ),
                           layout="tabbed",
                    ),
                    buttons = ["OK", "Cancel"],
              )

# Fix me: Should we do something here where we register this with the Axis object?

########NEW FILE########
__FILENAME__ = plot_window
# Enthought library imports
from traits.api import Instance, HasTraits
from traitsui.api import View, Item
from enable.api import Container
from enable.component_editor import ComponentEditor

class PlotWindow(HasTraits):
    plot = Instance(Container)

    traits_view = View(Item('plot',
                            editor=ComponentEditor(),
                            height=300,
                            width=500,
                            show_label=False,
                            ),
                       title='Chaco Plot',
                       resizable=True
                       )

########NEW FILE########
__FILENAME__ = popupable_plot
# Enthought library imports
from traits.api import List
from chaco.api import VPlotContainer
from chaco.plot import Plot
from chaco.tools.api import PanTool, ZoomTool
from chaco.ui.plot_window import PlotWindow

from traitsui.wx.constants import WindowColor

class PopupablePlot(Plot):
    """A Plot class that pops up in a new window on double click"""
    # FIXME: It would be nice to queue up other types of commands and settings
    command_queue = List()

    def normal_left_dclick(self, event):
        plot = Plot(self.data)
        for data, kw in self.command_queue:
            plot.plot(data, **kw)
            plot.title = self.title

        plot.title = self.title
        container = VPlotContainer(bgcolor=WindowColor)
        container.add(plot)
        plot.tools.append(PanTool(plot))
        plot.overlays.append(ZoomTool(plot))
        window = PlotWindow(plot=container)
        window.edit_traits(kind='live', parent=event.window.control)

    def plot(self, data, **kw):
        """Queue up the plot commands"""
        self.command_queue.append((data, kw))
        super(PopupablePlot, self).plot(data, **kw)
        return



########NEW FILE########
__FILENAME__ = variable_size_scatterplot
""" The base ScatterPlot class now accepts variable sized markers.

This definition remains for backwards compatibility.
"""
from chaco.scatterplot import ScatterPlot


# TODO: This should be officially deprecated.
class VariableSizeScatterPlot(ScatterPlot):
    pass

########NEW FILE########
__FILENAME__ = _speedups_fallback
"""
Module that implements pure-python equivalents of the functions in the
_speedups extension module.
"""

from numpy import clip, invert, isnan, isinf, array, transpose, zeros, \
    compress, where, take, float32, ones_like
import numpy as np

import operator

def array_combine(a, b, op=operator.and_, func=lambda x: x):
    """ Returns op(func(a), func(b)) if a and b are both not None;
    if one is None, then returns func() on the non-None array;
    if both are None, then returns None.
    """
    if a is not None and b is not None:
        return op(func(a), func(b))
    elif a is not None:
        return func(a)
    elif b is not None:
        return func(b)
    else:
        return None


def scatterplot_gather_points(index, index_low, index_high,
                              value, value_low, value_high,
                              index_mask=None, index_sel=None, index_sel_mask=None,
                              value_mask=None, value_sel=None, value_sel_mask=None):
    """
    Takes index and value arrays, masks, and optional selection arrays,
    and returns the list of points and corresponding selection mask for
    those points.

    Parameters
    ----------
    index : float array (1D)
       Array of indexes of the points
    index_low : float or None
       The minimum acceptable value in the index array
    index_high : float or None
       The maximum acceptable value in the index array
    value : float array (1D)
       Array of values of the points
    value_low : float or None
       The minimum acceptable value in the value array
    value_high : float or None
       The maximum acceptable value in the value array

    Optional Parameters
    -------------------
    index_mask : bool or int array (1D)
      Mask array for the indexes
    index_sel : sequence of ints
       A list/tuple/array of indices of selected positions in the index array
    index_sel_mask : array of ints or bools
       An mask array with True values indicating which points are selected
    value_mask : bool or int array (1D)
       Mask array for the values
    value_sel : sequence of ints
       A list/tuple/array of indices of selected positions in the value array
    value_sel_mask : array of ints or bools
       An mask array with True values indicating which points are selected

    Returns
    -------
    points : float array (Nx2)
       The points that match all the masking criteria
    sel_mask : bool array (1D)
       Mask indicating which indices in **points** are selected
    """

    index_range_mask = (index_low < index) & (index < index_high)
    value_range_mask = (value_low < value) & (value < value_high)

    nan_mask = array_combine(index_mask, value_mask,
                    func = lambda x: invert(isnan(x)) & x)

    if nan_mask is not None:
        point_mask = nan_mask & index_range_mask & value_range_mask
    else:
        point_mask = index_range_mask & value_range_mask
    points = transpose(array((index, value)))

    # Handle the selection mask
    selection_mask = array_combine(index_sel_mask, value_sel_mask)

    if index_sel is None and value_sel is None:
        pass
    else:
        if index_sel is not None and value_sel is not None:
            mask2 = zeros(len(index), int)
            mask2[index_sel] = 1
            mask2[value_sel] &= 1
        elif index_sel is not None:
            mask2 = zeros(len(index), int)
            mask2[index_sel] = 1
        elif value_sel is not None:
            mask2 = zeros(len(index), int)
            mask2[value_sel] = 1
        if selection_mask is None:
            selection_mask = mask2
        else:
            selection_mask &= mask2

    points = compress(point_mask, points, axis=0)
    if selection_mask is not None:
        selections = compress(point_mask, selection_mask)
    else:
        selections = None
    return points, selections



def apply_selection_fade(mapped_image, mask, fade_alpha, fade_background):
    '''Apply a selection fade to a colormapped image.

    Parameters
    ----------
    mapped_image : ndarray of uint8, shape (N,M,4)
        The digitized rgba values
    mask : ndarray of bool, shape (N,M,4)
        The array of masked pixels
    fade_alpha : float
        The alpha value for the fade
    fade_background : rgb888 tuple
        The fade background

    '''
    imask = invert(mask)
    if fade_alpha == 0:
        mapped_image[imask,0:3] = fade_background
    else:
        ialpha = (1.0 - fade_alpha)
        background = tuple(ialpha * x for x in fade_background)
        image_region = mapped_image[imask,0:3]
        image_region *= fade_alpha
        image_region += background
        mapped_image[imask,0:3] = image_region


def map_colors(data_array, steps, low, high, red_lut, green_lut, blue_lut,
        alpha_lut):
    '''Map colors from color lookup tables to a data array.

    This is used in ColorMapper.map_screen

    Parameters
    ----------
    data_array : ndarray
        The data array
    steps: int
        The number of steps in the color map (depth)
    low : float
        The low end of the data range
    high : float
        The high end of the data range
    red_lut : ndarray of float32
        The red channel lookup table
    green_lut : ndarray of float32
        The green channel lookup table
    blue_lut : ndarray of float32
        The blue channel lookup table
    alpha_lut : ndarray of float32
        The alpha channel lookup table
    
    Returns
    -------
    rgba: ndarray of float32
        The rgba values of data_array according to the lookup tables. The shape
        of this array is equal to data_array.shape + (4,).

    '''
    range_diff = high - low

    if range_diff == 0.0 or isinf(range_diff):
        # Handle null range, or infinite range (which can happen during 
        # initialization before range is connected to a data source).
        norm_data = 0.5*ones_like(data_array)
    else:
        norm_data = clip((data_array - low) / range_diff, 0.0, 1.0)


    nanmask = isnan(norm_data)
    norm_data = where(nanmask, 0, (norm_data * (steps-1)).astype(int))
    rgba = zeros(norm_data.shape+(4,), float32)
    rgba[...,0] = where(nanmask, 0, take(red_lut, norm_data))
    rgba[...,1] = where(nanmask, 0, take(green_lut, norm_data))
    rgba[...,2] = where(nanmask, 0, take(blue_lut, norm_data))
    rgba[...,3] = where(nanmask, 0, take(alpha_lut, norm_data))

    return rgba

def map_colors_uint8(data_array, steps, low, high, red_lut, green_lut, blue_lut,
        alpha_lut):
    '''Map colors from color lookup tables to a data array.

    This is used in ColorMapper.map_screen

    Parameters
    ----------
    data_array : ndarray
        The data array
    steps: int
        The number of steps in the color map (depth)
    low : float
        The low end of the data range
    high : float
        The high end of the data range
    red_lut : ndarray of uint8
        The red channel lookup table
    green_lut : ndarray of uint8
        The green channel lookup table
    blue_lut : ndarray of uint8
        The blue channel lookup table
    alpha_lut : ndarray of uint8
        The alpha channel lookup table
    
    Returns
    -------
    rgba: ndarray of uint8
        The rgba values of data_array according to the lookup tables. The shape
        of this array is equal to data_array.shape + (4,).

    '''
    range_diff = high - low

    if range_diff == 0.0 or isinf(range_diff):
        # Handle null range, or infinite range (which can happen during 
        # initialization before range is connected to a data source).
        norm_data = 0.5*ones_like(data_array)
    else:
        norm_data = clip((data_array - low) / range_diff, 0.0, 1.0)


    nanmask = isnan(norm_data)
    norm_data = where(nanmask, 0, (norm_data * (steps-1)).astype('uint8'))
    rgba = zeros(norm_data.shape+(4,), dtype='uint8')
    rgba[...,0] = where(nanmask, 0, take(red_lut, norm_data))
    rgba[...,1] = where(nanmask, 0, take(green_lut, norm_data))
    rgba[...,2] = where(nanmask, 0, take(blue_lut, norm_data))
    rgba[...,3] = where(nanmask, 0, take(alpha_lut, norm_data))

    return rgba


########NEW FILE########
__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# Chaco documentation build configuration file, created by
# sphinx-quickstart on Mon Jul 21 21:01:40 2008.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# The contents of this file are pickled, so don't put values in the namespace
# that aren't pickleable (module imports are okay, they're removed automatically).
#
# All configuration values have a default value; values that are commented out
# serve to show the default value.

import sys, os

# If your extensions are in another directory, add it here. If the directory
# is relative to the documentation root, use os.path.abspath to make it
# absolute, like shown here.
sys.path.append(os.path.abspath('sphinxext'))

# General configuration
# ---------------------

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc', 'traitsdoc']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The master toctree document.
master_doc = 'index'

# General substitutions.
project = 'chaco'
copyright = '2008-2013, Enthought, Inc.'

# The default replacements for |version| and |release|, also used in various
# other places throughout the built documents.
d = {}
execfile(os.path.join('..', '..', 'chaco', '__init__.py'), d)
version = release = d['__version__']

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
today_fmt = '%B %d, %Y'

# List of documents that shouldn't be included in the build.
#unused_docs = []

# List of directories, relative to source directories, that shouldn't be searched
# for source files.
#exclude_dirs = []

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'


# Options for HTML output
# -----------------------

# The style sheet to use for HTML and HTML Help pages. A file of that name
# must exist either in Sphinx' static/ path, or in one of the custom paths
# given in html_static_path.
html_style = 'default.css'

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (within the static path) to place at the top of
# the sidebar.
html_logo = '_static/e-logo-rev.png'

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
html_favicon = 'et.ico'

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
html_use_modindex = False

# If false, no index is generated.
html_use_index = False

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, the reST sources are included in the HTML build as _sources/<name>.
#html_copy_source = False

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# If nonempty, this is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = ''

# Output file base name for HTML help builder.
htmlhelp_basename = 'Chacodoc'


# Options for LaTeX output
# ------------------------

# The paper size ('letter' or 'a4').
#latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
#latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, document class [howto/manual]).
latex_documents = [
  ('index', 'Chaco.tex', 'Chaco Documentation', 'Enthought', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# Additional stuff for the LaTeX preamble.
#latex_preamble = ''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_use_modindex = True

########NEW FILE########
__FILENAME__ = comment_eater
from cStringIO import StringIO
import compiler
import inspect
import textwrap
import tokenize

from compiler_unparse import unparse


class Comment(object):
    """ A comment block.
    """
    is_comment = True
    def __init__(self, start_lineno, end_lineno, text):
        # int : The first line number in the block. 1-indexed.
        self.start_lineno = start_lineno
        # int : The last line number. Inclusive!
        self.end_lineno = end_lineno
        # str : The text block including '#' character but not any leading spaces.
        self.text = text
        # int: NL sentinel to check how many continues newlines we have
        #      encountered.
        self.NLs = 0

    def add(self, string, start, end, line):
        """ Add a new comment line.
        """
        self.start_lineno = min(self.start_lineno, start[0])
        self.end_lineno = max(self.end_lineno, end[0])
        self.text += string

        if string == '\n':
            self.NLs += 1
        else:
            self.NLs = 0

    def __repr__(self):
        return '%s(%r, %r, %r)' % (self.__class__.__name__, self.start_lineno,
            self.end_lineno, self.text)


class NonComment(object):
    """ A non-comment block of code.
    """
    is_comment = False
    def __init__(self, start_lineno, end_lineno):
        self.start_lineno = start_lineno
        self.end_lineno = end_lineno

    def add(self, string, start, end, line):
        """ Add lines to the block.
        """
        if string.strip():
            # Only add if not entirely whitespace.
            self.start_lineno = min(self.start_lineno, start[0])
            self.end_lineno = max(self.end_lineno, end[0])

    def __repr__(self):
        return '%s(%r, %r)' % (self.__class__.__name__, self.start_lineno,
            self.end_lineno)


class CommentBlocker(object):
    """ Pull out contiguous comment blocks.
    """
    def __init__(self):
        # Start with a dummy.
        self.current_block = NonComment(0, 0)

        # All of the blocks seen so far.
        self.blocks = []

        # The index mapping lines of code to their associated comment blocks.
        self.index = {}

    def process_file(self, file):
        """ Process a file object.
        """
        for token in tokenize.generate_tokens(file.next):
            self.process_token(*token)
        self.make_index()

    def process_token(self, kind, string, start, end, line):
        """ Process a single token.
        """
        block = self.current_block
        if (block.is_comment) and block.NLs < 2 :
            if kind in (tokenize.COMMENT, tokenize.NL):
                block.add(string, start, end, line)
            else:
                self.new_noncomment(start[0], end[0])
        else:
            if kind == tokenize.COMMENT:
                self.new_comment(string, start, end, line)
            else:
                block.add(string, start, end, line)

    def new_noncomment(self, start_lineno, end_lineno):
        """ We are transitioning from a noncomment to a comment.
        """
        block = NonComment(start_lineno, end_lineno)
        self.blocks.append(block)
        self.current_block = block

    def new_comment(self, string, start, end, line):
        """ Possibly add a new comment.

        Only adds a new comment if this comment is the only thing on the line.
        Otherwise, it extends the noncomment block.
        """
        prefix = line[:start[1]]
        if prefix.strip():
            # Oops! Trailing comment, not a comment block.
            self.current_block.add(string, start, end, line)
        else:
            # A comment block.
            block = Comment(start[0], end[0], string)
            self.blocks.append(block)
            self.current_block = block

    def make_index(self):
        """ Make the index mapping lines of actual code to their associated
        prefix comments.
        """
        for prev, block in zip(self.blocks[:-1], self.blocks[1:]):
            if not block.is_comment:
                self.index[block.start_lineno] = prev

    def search_for_comment(self, lineno, default=None):
        """ Find the comment block just before the given line number.

        Returns None (or the specified default) if there is no such block.
        """
        if not self.index:
            self.make_index()
        block = self.index.get(lineno, None)
        text = getattr(block, 'text', default)
        return text


def strip_comment_marker(text):
    """ Strip # markers at the front of a block of comment text.
    """
    lines = []
    for line in text.splitlines():
        lines.append(line.lstrip('#'))
    text = textwrap.dedent('\n'.join(lines))
    return text


def get_class_traits(klass):
    """ Yield all of the documentation for trait definitions on a class object.
    """
    # FIXME: gracefully handle errors here or in the caller?
    source = inspect.getsource(klass)
    cb = CommentBlocker()
    cb.process_file(StringIO(source))
    mod_ast = compiler.parse(source)
    class_ast = mod_ast.node.nodes[0]
    for node in class_ast.code.nodes:
        # FIXME: handle other kinds of assignments?
        if isinstance(node, compiler.ast.Assign):
            name = node.nodes[0].name
            rhs = unparse(node.expr).strip()
            doc = strip_comment_marker(cb.search_for_comment(node.lineno, default=''))
            yield name, rhs, doc


########NEW FILE########
__FILENAME__ = compiler_unparse
""" Turn compiler.ast structures back into executable python code.

    The unparse method takes a compiler.ast tree and transforms it back into
    valid python code.  It is incomplete and currently only works for
    import statements, function calls, function definitions, assignments, and
    basic expressions.

    Inspired by python-2.5-svn/Demo/parser/unparse.py

    fixme: We may want to move to using _ast trees because the compiler for
           them is about 6 times faster than compiler.compile.
"""

import sys
import cStringIO
from compiler.ast import Const, Name, Tuple, Div, Mul, Sub, Add

def unparse(ast, single_line_functions=False):
    s = cStringIO.StringIO()
    UnparseCompilerAst(ast, s, single_line_functions)
    return s.getvalue().lstrip()

op_precedence = { 'compiler.ast.Power':3, 'compiler.ast.Mul':2, 'compiler.ast.Div':2,
                  'compiler.ast.Add':1, 'compiler.ast.Sub':1 }

class UnparseCompilerAst:
    """ Methods in this class recursively traverse an AST and
        output source code for the abstract syntax; original formatting
        is disregarged.
    """

    #########################################################################
    # object interface.
    #########################################################################

    def __init__(self, tree, file = sys.stdout, single_line_functions=False):
        """ Unparser(tree, file=sys.stdout) -> None.

            Print the source for tree to file.
        """
        self.f = file
        self._single_func = single_line_functions
        self._do_indent = True
        self._indent = 0
        self._dispatch(tree)
        self._write("\n")
        self.f.flush()

    #########################################################################
    # Unparser private interface.
    #########################################################################

    ### format, output, and dispatch methods ################################

    def _fill(self, text = ""):
        "Indent a piece of text, according to the current indentation level"
        if self._do_indent:
            self._write("\n"+"    "*self._indent + text)
        else:
            self._write(text)

    def _write(self, text):
        "Append a piece of text to the current line."
        self.f.write(text)

    def _enter(self):
        "Print ':', and increase the indentation."
        self._write(": ")
        self._indent += 1

    def _leave(self):
        "Decrease the indentation level."
        self._indent -= 1

    def _dispatch(self, tree):
        "_dispatcher function, _dispatching tree type T to method _T."
        if isinstance(tree, list):
            for t in tree:
                self._dispatch(t)
            return
        meth = getattr(self, "_"+tree.__class__.__name__)
        if tree.__class__.__name__ == 'NoneType' and not self._do_indent:
            return
        meth(tree)


    #########################################################################
    # compiler.ast unparsing methods.
    #
    # There should be one method per concrete grammar type. They are
    # organized in alphabetical order.
    #########################################################################

    def _Add(self, t):
        self.__binary_op(t, '+')

    def _And(self, t):
        self._write(" (")
        for i, node in enumerate(t.nodes):
            self._dispatch(node)
            if i != len(t.nodes)-1:
                self._write(") and (")
        self._write(")")

    def _AssAttr(self, t):
        """ Handle assigning an attribute of an object
        """
        self._dispatch(t.expr)
        self._write('.'+t.attrname)

    def _Assign(self, t):
        """ Expression Assignment such as "a = 1".

            This only handles assignment in expressions.  Keyword assignment
            is handled separately.
        """
        self._fill()
        for target in t.nodes:
            self._dispatch(target)
            self._write(" = ")
        self._dispatch(t.expr)
        if not self._do_indent:
            self._write('; ')

    def _AssName(self, t):
        """ Name on left hand side of expression.

            Treat just like a name on the right side of an expression.
        """
        self._Name(t)

    def _AssTuple(self, t):
        """ Tuple on left hand side of an expression.
        """

        # _write each elements, separated by a comma.
        for element in t.nodes[:-1]:
            self._dispatch(element)
            self._write(", ")

        # Handle the last one without writing comma
        last_element = t.nodes[-1]
        self._dispatch(last_element)

    def _AugAssign(self, t):
        """ +=,-=,*=,/=,**=, etc. operations
        """

        self._fill()
        self._dispatch(t.node)
        self._write(' '+t.op+' ')
        self._dispatch(t.expr)
        if not self._do_indent:
            self._write(';')

    def _Bitand(self, t):
        """ Bit and operation.
        """

        for i, node in enumerate(t.nodes):
            self._write("(")
            self._dispatch(node)
            self._write(")")
            if i != len(t.nodes)-1:
                self._write(" & ")

    def _Bitor(self, t):
        """ Bit or operation
        """

        for i, node in enumerate(t.nodes):
            self._write("(")
            self._dispatch(node)
            self._write(")")
            if i != len(t.nodes)-1:
                self._write(" | ")

    def _CallFunc(self, t):
        """ Function call.
        """
        self._dispatch(t.node)
        self._write("(")
        comma = False
        for e in t.args:
            if comma: self._write(", ")
            else: comma = True
            self._dispatch(e)
        if t.star_args:
            if comma: self._write(", ")
            else: comma = True
            self._write("*")
            self._dispatch(t.star_args)
        if t.dstar_args:
            if comma: self._write(", ")
            else: comma = True
            self._write("**")
            self._dispatch(t.dstar_args)
        self._write(")")

    def _Compare(self, t):
        self._dispatch(t.expr)
        for op, expr in t.ops:
            self._write(" " + op + " ")
            self._dispatch(expr)

    def _Const(self, t):
        """ A constant value such as an integer value, 3, or a string, "hello".
        """
        self._dispatch(t.value)

    def _Decorators(self, t):
        """ Handle function decorators (eg. @has_units)
        """
        for node in t.nodes:
            self._dispatch(node)

    def _Dict(self, t):
        self._write("{")
        for  i, (k, v) in enumerate(t.items):
            self._dispatch(k)
            self._write(": ")
            self._dispatch(v)
            if i < len(t.items)-1:
                self._write(", ")
        self._write("}")

    def _Discard(self, t):
        """ Node for when return value is ignored such as in "foo(a)".
        """
        self._fill()
        self._dispatch(t.expr)

    def _Div(self, t):
        self.__binary_op(t, '/')

    def _Ellipsis(self, t):
        self._write("...")

    def _From(self, t):
        """ Handle "from xyz import foo, bar as baz".
        """
        # fixme: Are From and ImportFrom handled differently?
        self._fill("from ")
        self._write(t.modname)
        self._write(" import ")
        for i, (name,asname) in enumerate(t.names):
            if i != 0:
                self._write(", ")
            self._write(name)
            if asname is not None:
                self._write(" as "+asname)

    def _Function(self, t):
        """ Handle function definitions
        """
        if t.decorators is not None:
            self._fill("@")
            self._dispatch(t.decorators)
        self._fill("def "+t.name + "(")
        defaults = [None] * (len(t.argnames) - len(t.defaults)) + list(t.defaults)
        for i, arg in enumerate(zip(t.argnames, defaults)):
            self._write(arg[0])
            if arg[1] is not None:
                self._write('=')
                self._dispatch(arg[1])
            if i < len(t.argnames)-1:
                self._write(', ')
        self._write(")")
        if self._single_func:
            self._do_indent = False
        self._enter()
        self._dispatch(t.code)
        self._leave()
        self._do_indent = True

    def _Getattr(self, t):
        """ Handle getting an attribute of an object
        """
        if isinstance(t.expr, (Div, Mul, Sub, Add)):
            self._write('(')
            self._dispatch(t.expr)
            self._write(')')
        else:
            self._dispatch(t.expr)

        self._write('.'+t.attrname)

    def _If(self, t):
        self._fill()

        for i, (compare,code) in enumerate(t.tests):
            if i == 0:
                self._write("if ")
            else:
                self._write("elif ")
            self._dispatch(compare)
            self._enter()
            self._fill()
            self._dispatch(code)
            self._leave()
            self._write("\n")

        if t.else_ is not None:
            self._write("else")
            self._enter()
            self._fill()
            self._dispatch(t.else_)
            self._leave()
            self._write("\n")

    def _IfExp(self, t):
        self._dispatch(t.then)
        self._write(" if ")
        self._dispatch(t.test)

        if t.else_ is not None:
            self._write(" else (")
            self._dispatch(t.else_)
            self._write(")")

    def _Import(self, t):
        """ Handle "import xyz.foo".
        """
        self._fill("import ")

        for i, (name,asname) in enumerate(t.names):
            if i != 0:
                self._write(", ")
            self._write(name)
            if asname is not None:
                self._write(" as "+asname)

    def _Keyword(self, t):
        """ Keyword value assignment within function calls and definitions.
        """
        self._write(t.name)
        self._write("=")
        self._dispatch(t.expr)

    def _List(self, t):
        self._write("[")
        for  i,node in enumerate(t.nodes):
            self._dispatch(node)
            if i < len(t.nodes)-1:
                self._write(", ")
        self._write("]")

    def _Module(self, t):
        if t.doc is not None:
            self._dispatch(t.doc)
        self._dispatch(t.node)

    def _Mul(self, t):
        self.__binary_op(t, '*')

    def _Name(self, t):
        self._write(t.name)

    def _NoneType(self, t):
        self._write("None")

    def _Not(self, t):
        self._write('not (')
        self._dispatch(t.expr)
        self._write(')')

    def _Or(self, t):
        self._write(" (")
        for i, node in enumerate(t.nodes):
            self._dispatch(node)
            if i != len(t.nodes)-1:
                self._write(") or (")
        self._write(")")

    def _Pass(self, t):
        self._write("pass\n")

    def _Printnl(self, t):
        self._fill("print ")
        if t.dest:
            self._write(">> ")
            self._dispatch(t.dest)
            self._write(", ")
        comma = False
        for node in t.nodes:
            if comma: self._write(', ')
            else: comma = True
            self._dispatch(node)

    def _Power(self, t):
        self.__binary_op(t, '**')

    def _Return(self, t):
        self._fill("return ")
        if t.value:
            if isinstance(t.value, Tuple):
                text = ', '.join([ name.name for name in t.value.asList() ])
                self._write(text)
            else:
                self._dispatch(t.value)
            if not self._do_indent:
                self._write('; ')

    def _Slice(self, t):
        self._dispatch(t.expr)
        self._write("[")
        if t.lower:
            self._dispatch(t.lower)
        self._write(":")
        if t.upper:
            self._dispatch(t.upper)
        #if t.step:
        #    self._write(":")
        #    self._dispatch(t.step)
        self._write("]")

    def _Sliceobj(self, t):
        for i, node in enumerate(t.nodes):
            if i != 0:
                self._write(":")
            if not (isinstance(node, Const) and node.value is None):
                self._dispatch(node)

    def _Stmt(self, tree):
        for node in tree.nodes:
            self._dispatch(node)

    def _Sub(self, t):
        self.__binary_op(t, '-')

    def _Subscript(self, t):
        self._dispatch(t.expr)
        self._write("[")
        for i, value in enumerate(t.subs):
            if i != 0:
                self._write(",")
            self._dispatch(value)
        self._write("]")

    def _TryExcept(self, t):
        self._fill("try")
        self._enter()
        self._dispatch(t.body)
        self._leave()

        for handler in t.handlers:
            self._fill('except ')
            self._dispatch(handler[0])
            if handler[1] is not None:
                self._write(', ')
                self._dispatch(handler[1])
            self._enter()
            self._dispatch(handler[2])
            self._leave()

        if t.else_:
            self._fill("else")
            self._enter()
            self._dispatch(t.else_)
            self._leave()

    def _Tuple(self, t):

        if not t.nodes:
            # Empty tuple.
            self._write("()")
        else:
            self._write("(")

            # _write each elements, separated by a comma.
            for element in t.nodes[:-1]:
                self._dispatch(element)
                self._write(", ")

            # Handle the last one without writing comma
            last_element = t.nodes[-1]
            self._dispatch(last_element)

            self._write(")")

    def _UnaryAdd(self, t):
        self._write("+")
        self._dispatch(t.expr)

    def _UnarySub(self, t):
        self._write("-")
        self._dispatch(t.expr)

    def _With(self, t):
        self._fill('with ')
        self._dispatch(t.expr)
        if t.vars:
            self._write(' as ')
            self._dispatch(t.vars.name)
        self._enter()
        self._dispatch(t.body)
        self._leave()
        self._write('\n')

    def _int(self, t):
        self._write(repr(t))

    def __binary_op(self, t, symbol):
        # Check if parenthesis are needed on left side and then dispatch
        has_paren = False
        left_class = str(t.left.__class__)
        if (left_class in op_precedence.keys() and
            op_precedence[left_class] < op_precedence[str(t.__class__)]):
            has_paren = True
        if has_paren:
            self._write('(')
        self._dispatch(t.left)
        if has_paren:
            self._write(')')
        # Write the appropriate symbol for operator
        self._write(symbol)
        # Check if parenthesis are needed on the right side and then dispatch
        has_paren = False
        right_class = str(t.right.__class__)
        if (right_class in op_precedence.keys() and
            op_precedence[right_class] < op_precedence[str(t.__class__)]):
            has_paren = True
        if has_paren:
            self._write('(')
        self._dispatch(t.right)
        if has_paren:
            self._write(')')

    def _float(self, t):
        # if t is 0.1, str(t)->'0.1' while repr(t)->'0.1000000000001'
        # We prefer str here.
        self._write(str(t))

    def _str(self, t):
        self._write(repr(t))

    def _tuple(self, t):
        self._write(str(t))

    #########################################################################
    # These are the methods from the _ast modules unparse.
    #
    # As our needs to handle more advanced code increase, we may want to
    # modify some of the methods below so that they work for compiler.ast.
    #########################################################################

#    # stmt
#    def _Expr(self, tree):
#        self._fill()
#        self._dispatch(tree.value)
#
#    def _Import(self, t):
#        self._fill("import ")
#        first = True
#        for a in t.names:
#            if first:
#                first = False
#            else:
#                self._write(", ")
#            self._write(a.name)
#            if a.asname:
#                self._write(" as "+a.asname)
#
##    def _ImportFrom(self, t):
##        self._fill("from ")
##        self._write(t.module)
##        self._write(" import ")
##        for i, a in enumerate(t.names):
##            if i == 0:
##                self._write(", ")
##            self._write(a.name)
##            if a.asname:
##                self._write(" as "+a.asname)
##        # XXX(jpe) what is level for?
##
#
#    def _Break(self, t):
#        self._fill("break")
#
#    def _Continue(self, t):
#        self._fill("continue")
#
#    def _Delete(self, t):
#        self._fill("del ")
#        self._dispatch(t.targets)
#
#    def _Assert(self, t):
#        self._fill("assert ")
#        self._dispatch(t.test)
#        if t.msg:
#            self._write(", ")
#            self._dispatch(t.msg)
#
#    def _Exec(self, t):
#        self._fill("exec ")
#        self._dispatch(t.body)
#        if t.globals:
#            self._write(" in ")
#            self._dispatch(t.globals)
#        if t.locals:
#            self._write(", ")
#            self._dispatch(t.locals)
#
#    def _Print(self, t):
#        self._fill("print ")
#        do_comma = False
#        if t.dest:
#            self._write(">>")
#            self._dispatch(t.dest)
#            do_comma = True
#        for e in t.values:
#            if do_comma:self._write(", ")
#            else:do_comma=True
#            self._dispatch(e)
#        if not t.nl:
#            self._write(",")
#
#    def _Global(self, t):
#        self._fill("global")
#        for i, n in enumerate(t.names):
#            if i != 0:
#                self._write(",")
#            self._write(" " + n)
#
#    def _Yield(self, t):
#        self._fill("yield")
#        if t.value:
#            self._write(" (")
#            self._dispatch(t.value)
#            self._write(")")
#
#    def _Raise(self, t):
#        self._fill('raise ')
#        if t.type:
#            self._dispatch(t.type)
#        if t.inst:
#            self._write(", ")
#            self._dispatch(t.inst)
#        if t.tback:
#            self._write(", ")
#            self._dispatch(t.tback)
#
#
#    def _TryFinally(self, t):
#        self._fill("try")
#        self._enter()
#        self._dispatch(t.body)
#        self._leave()
#
#        self._fill("finally")
#        self._enter()
#        self._dispatch(t.finalbody)
#        self._leave()
#
#    def _excepthandler(self, t):
#        self._fill("except ")
#        if t.type:
#            self._dispatch(t.type)
#        if t.name:
#            self._write(", ")
#            self._dispatch(t.name)
#        self._enter()
#        self._dispatch(t.body)
#        self._leave()
#
#    def _ClassDef(self, t):
#        self._write("\n")
#        self._fill("class "+t.name)
#        if t.bases:
#            self._write("(")
#            for a in t.bases:
#                self._dispatch(a)
#                self._write(", ")
#            self._write(")")
#        self._enter()
#        self._dispatch(t.body)
#        self._leave()
#
#    def _FunctionDef(self, t):
#        self._write("\n")
#        for deco in t.decorators:
#            self._fill("@")
#            self._dispatch(deco)
#        self._fill("def "+t.name + "(")
#        self._dispatch(t.args)
#        self._write(")")
#        self._enter()
#        self._dispatch(t.body)
#        self._leave()
#
#    def _For(self, t):
#        self._fill("for ")
#        self._dispatch(t.target)
#        self._write(" in ")
#        self._dispatch(t.iter)
#        self._enter()
#        self._dispatch(t.body)
#        self._leave()
#        if t.orelse:
#            self._fill("else")
#            self._enter()
#            self._dispatch(t.orelse)
#            self._leave
#
#    def _While(self, t):
#        self._fill("while ")
#        self._dispatch(t.test)
#        self._enter()
#        self._dispatch(t.body)
#        self._leave()
#        if t.orelse:
#            self._fill("else")
#            self._enter()
#            self._dispatch(t.orelse)
#            self._leave
#
#    # expr
#    def _Str(self, tree):
#        self._write(repr(tree.s))
##
#    def _Repr(self, t):
#        self._write("`")
#        self._dispatch(t.value)
#        self._write("`")
#
#    def _Num(self, t):
#        self._write(repr(t.n))
#
#    def _ListComp(self, t):
#        self._write("[")
#        self._dispatch(t.elt)
#        for gen in t.generators:
#            self._dispatch(gen)
#        self._write("]")
#
#    def _GeneratorExp(self, t):
#        self._write("(")
#        self._dispatch(t.elt)
#        for gen in t.generators:
#            self._dispatch(gen)
#        self._write(")")
#
#    def _comprehension(self, t):
#        self._write(" for ")
#        self._dispatch(t.target)
#        self._write(" in ")
#        self._dispatch(t.iter)
#        for if_clause in t.ifs:
#            self._write(" if ")
#            self._dispatch(if_clause)
#
#    def _IfExp(self, t):
#        self._dispatch(t.body)
#        self._write(" if ")
#        self._dispatch(t.test)
#        if t.orelse:
#            self._write(" else ")
#            self._dispatch(t.orelse)
#
#    unop = {"Invert":"~", "Not": "not", "UAdd":"+", "USub":"-"}
#    def _UnaryOp(self, t):
#        self._write(self.unop[t.op.__class__.__name__])
#        self._write("(")
#        self._dispatch(t.operand)
#        self._write(")")
#
#    binop = { "Add":"+", "Sub":"-", "Mult":"*", "Div":"/", "Mod":"%",
#                    "LShift":">>", "RShift":"<<", "BitOr":"|", "BitXor":"^", "BitAnd":"&",
#                    "FloorDiv":"//", "Pow": "**"}
#    def _BinOp(self, t):
#        self._write("(")
#        self._dispatch(t.left)
#        self._write(")" + self.binop[t.op.__class__.__name__] + "(")
#        self._dispatch(t.right)
#        self._write(")")
#
#    boolops = {_ast.And: 'and', _ast.Or: 'or'}
#    def _BoolOp(self, t):
#        self._write("(")
#        self._dispatch(t.values[0])
#        for v in t.values[1:]:
#            self._write(" %s " % self.boolops[t.op.__class__])
#            self._dispatch(v)
#        self._write(")")
#
#    def _Attribute(self,t):
#        self._dispatch(t.value)
#        self._write(".")
#        self._write(t.attr)
#
##    def _Call(self, t):
##        self._dispatch(t.func)
##        self._write("(")
##        comma = False
##        for e in t.args:
##            if comma: self._write(", ")
##            else: comma = True
##            self._dispatch(e)
##        for e in t.keywords:
##            if comma: self._write(", ")
##            else: comma = True
##            self._dispatch(e)
##        if t.starargs:
##            if comma: self._write(", ")
##            else: comma = True
##            self._write("*")
##            self._dispatch(t.starargs)
##        if t.kwargs:
##            if comma: self._write(", ")
##            else: comma = True
##            self._write("**")
##            self._dispatch(t.kwargs)
##        self._write(")")
#
#    # slice
#    def _Index(self, t):
#        self._dispatch(t.value)
#
#    def _ExtSlice(self, t):
#        for i, d in enumerate(t.dims):
#            if i != 0:
#                self._write(': ')
#            self._dispatch(d)
#
#    # others
#    def _arguments(self, t):
#        first = True
#        nonDef = len(t.args)-len(t.defaults)
#        for a in t.args[0:nonDef]:
#            if first:first = False
#            else: self._write(", ")
#            self._dispatch(a)
#        for a,d in zip(t.args[nonDef:], t.defaults):
#            if first:first = False
#            else: self._write(", ")
#            self._dispatch(a),
#            self._write("=")
#            self._dispatch(d)
#        if t.vararg:
#            if first:first = False
#            else: self._write(", ")
#            self._write("*"+t.vararg)
#        if t.kwarg:
#            if first:first = False
#            else: self._write(", ")
#            self._write("**"+t.kwarg)
#
##    def _keyword(self, t):
##        self._write(t.arg)
##        self._write("=")
##        self._dispatch(t.value)
#
#    def _Lambda(self, t):
#        self._write("lambda ")
#        self._dispatch(t.args)
#        self._write(": ")
#        self._dispatch(t.body)




########NEW FILE########
__FILENAME__ = docscrape
"""Extract reference documentation from the NumPy source tree.

"""

import inspect
import textwrap
import re
import pydoc
from StringIO import StringIO
from warnings import warn

class Reader(object):
    """A line-based string reader.

    """
    def __init__(self, data):
        """
        Parameters
        ----------
        data : str
           String with lines separated by '\n'.

        """
        if isinstance(data,list):
            self._str = data
        else:
            self._str = data.split('\n') # store string as list of lines

        self.reset()

    def __getitem__(self, n):
        return self._str[n]

    def reset(self):
        self._l = 0 # current line nr

    def read(self):
        if not self.eof():
            out = self[self._l]
            self._l += 1
            return out
        else:
            return ''

    def seek_next_non_empty_line(self):
        for l in self[self._l:]:
            if l.strip():
                break
            else:
                self._l += 1

    def eof(self):
        return self._l >= len(self._str)

    def read_to_condition(self, condition_func):
        start = self._l
        for line in self[start:]:
            if condition_func(line):
                return self[start:self._l]
            self._l += 1
            if self.eof():
                return self[start:self._l+1]
        return []

    def read_to_next_empty_line(self):
        self.seek_next_non_empty_line()
        def is_empty(line):
            return not line.strip()
        return self.read_to_condition(is_empty)

    def read_to_next_unindented_line(self):
        def is_unindented(line):
            return (line.strip() and (len(line.lstrip()) == len(line)))
        return self.read_to_condition(is_unindented)

    def peek(self,n=0):
        if self._l + n < len(self._str):
            return self[self._l + n]
        else:
            return ''

    def is_empty(self):
        return not ''.join(self._str).strip()


class NumpyDocString(object):
    def __init__(self,docstring):
        docstring = docstring.split('\n')

        # De-indent paragraph
        try:
            indent = min(len(s) - len(s.lstrip()) for s in docstring
                         if s.strip())
        except ValueError:
            indent = 0

        for n,line in enumerate(docstring):
            docstring[n] = docstring[n][indent:]

        self._doc = Reader(docstring)
        self._parsed_data = {
            'Signature': '',
            'Summary': '',
            'Extended Summary': [],
            'Parameters': [],
            'Returns': [],
            'Raises': [],
            'Warns': [],
            'Other Parameters': [],
            'Attributes': [],
            'Methods': [],
            'See Also': [],
            'Notes': [],
            'References': '',
            'Examples': '',
            'index': {}
            }

        self._parse()

    def __getitem__(self,key):
        return self._parsed_data[key]

    def __setitem__(self,key,val):
        if not self._parsed_data.has_key(key):
            warn("Unknown section %s" % key)
        else:
            self._parsed_data[key] = val

    def _is_at_section(self):
        self._doc.seek_next_non_empty_line()

        if self._doc.eof():
            return False

        l1 = self._doc.peek().strip()  # e.g. Parameters

        if l1.startswith('.. index::'):
            return True

        l2 = self._doc.peek(1).strip() #    ----------
        return l2.startswith('-'*len(l1))

    def _strip(self,doc):
        i = 0
        j = 0
        for i,line in enumerate(doc):
            if line.strip(): break

        for j,line in enumerate(doc[::-1]):
            if line.strip(): break

        return doc[i:len(doc)-j]

    def _read_to_next_section(self):
        section = self._doc.read_to_next_empty_line()

        while not self._is_at_section() and not self._doc.eof():
            if not self._doc.peek(-1).strip(): # previous line was empty
                section += ['']

            section += self._doc.read_to_next_empty_line()

        return section

    def _read_sections(self):
        while not self._doc.eof():
            data = self._read_to_next_section()
            name = data[0].strip()

            if name.startswith('..'): # index section
                yield name, data[1:]
            elif len(data) < 2:
                yield StopIteration
            else:
                yield name, self._strip(data[2:])

    def _parse_param_list(self,content):
        r = Reader(content)
        params = []
        while not r.eof():
            header = r.read().strip()
            if ' : ' in header:
                arg_name, arg_type = header.split(' : ')[:2]
            else:
                arg_name, arg_type = header, ''

            desc = r.read_to_next_unindented_line()
            for n,line in enumerate(desc):
                desc[n] = line.strip()
            desc = desc #'\n'.join(desc)

            params.append((arg_name,arg_type,desc))

        return params

    def _parse_see_also(self, content):
        """
        func_name : Descriptive text
            continued text
        another_func_name : Descriptive text
        func_name1, func_name2, func_name3

        """
        functions = []
        current_func = None
        rest = []
        for line in content:
            if not line.strip(): continue
            if ':' in line:
                if current_func:
                    functions.append((current_func, rest))
                r = line.split(':', 1)
                current_func = r[0].strip()
                r[1] = r[1].strip()
                if r[1]:
                    rest = [r[1]]
                else:
                    rest = []
            elif not line.startswith(' '):
                if current_func:
                    functions.append((current_func, rest))
                    current_func = None
                    rest = []
                if ',' in line:
                    for func in line.split(','):
                        func = func.strip()
                        if func:
                            functions.append((func, []))
                elif line.strip():
                    current_func = line.strip()
            elif current_func is not None:
                rest.append(line.strip())
        if current_func:
            functions.append((current_func, rest))
        return functions

    def _parse_index(self, section, content):
        """
        .. index: default
           :refguide: something, else, and more

        """
        def strip_each_in(lst):
            return [s.strip() for s in lst]

        out = {}
        section = section.split('::')
        if len(section) > 1:
            out['default'] = strip_each_in(section[1].split(','))[0]
        for line in content:
            line = line.split(':')
            if len(line) > 2:
                out[line[1]] = strip_each_in(line[2].split(','))
        return out

    def _parse_summary(self):
        """Grab signature (if given) and summary"""
        if self._is_at_section():
            return

        summary = self._doc.read_to_next_empty_line()
        summary_str = " ".join([s.strip() for s in summary]).strip()
        if re.compile('^([\w., ]+=)?\s*[\w\.]+\(.*\)$').match(summary_str):
            self['Signature'] = summary_str
            if not self._is_at_section():
                self['Summary'] = self._doc.read_to_next_empty_line()
        else:
            self['Summary'] = summary

        if not self._is_at_section():
            self['Extended Summary'] = self._read_to_next_section()

    def _parse(self):
        self._doc.reset()
        self._parse_summary()

        for (section,content) in self._read_sections():
            if not section.startswith('..'):
                section = ' '.join([s.capitalize() for s in section.split(' ')])
            if section in ('Parameters', 'Attributes', 'Methods',
                           'Returns', 'Raises', 'Warns'):
                self[section] = self._parse_param_list(content)
            elif section.startswith('.. index::'):
                self['index'] = self._parse_index(section, content)
            elif section == 'See Also':
                self['See Also'] = self._parse_see_also(content)
            else:
                self[section] = content

    # string conversion routines

    def _str_header(self, name, symbol='-'):
        return [name, len(name)*symbol]

    def _str_indent(self, doc, indent=4):
        out = []
        for line in doc:
            out += [' '*indent + line]
        return out

    def _str_signature(self):
        if self['Signature']:
            return [self['Signature'].replace('*','\*')] + ['']
        else:
            return ['']

    def _str_summary(self):
        if self['Summary']:
            return self['Summary'] + ['']
        else:
            return []

    def _str_extended_summary(self):
        if self['Extended Summary']:
            return self['Extended Summary'] + ['']
        else:
            return []

    def _str_param_list(self, name):
        out = []
        if self[name]:
            out += self._str_header(name)
            for param,param_type,desc in self[name]:
                out += ['%s : %s' % (param, param_type)]
                out += self._str_indent(desc)
            out += ['']
        return out

    def _str_section(self, name):
        out = []
        if self[name]:
            out += self._str_header(name)
            out += self[name]
            out += ['']
        return out

    def _str_see_also(self, func_role):
        if not self['See Also']: return []
        out = []
        out += self._str_header("See Also")
        last_had_desc = True
        for func, desc in self['See Also']:
            if func_role:
                link = ':%s:`%s`' % (func_role, func)
            else:
                link = "`%s`_" % func
            if desc or last_had_desc:
                out += ['']
                out += [link]
            else:
                out[-1] += ", %s" % link
            if desc:
                out += self._str_indent(desc)
                last_had_desc = True
            else:
                last_had_desc = False
        out += ['']
        return out

    def _str_index(self):
        idx = self['index']
        out = []
        out += ['.. index:: %s' % idx.get('default','')]
        for section, references in idx.iteritems():
            if section == 'default':
                continue
            out += ['   :%s: %s' % (section, ', '.join(references))]
        return out

    def __str__(self, func_role=''):
        out = []
        out += self._str_signature()
        out += self._str_summary()
        out += self._str_extended_summary()
        for param_list in ('Parameters','Returns','Raises'):
            out += self._str_param_list(param_list)
        out += self._str_see_also(func_role)
        for s in ('Notes','References','Examples'):
            out += self._str_section(s)
        out += self._str_index()
        return '\n'.join(out)


def indent(str,indent=4):
    indent_str = ' '*indent
    if str is None:
        return indent_str
    lines = str.split('\n')
    return '\n'.join(indent_str + l for l in lines)

def header(text, style='-'):
    return text + '\n' + style*len(text) + '\n'


class FunctionDoc(NumpyDocString):
    def __init__(self, func, role='func'):
        self._f = func
        self._role = role # e.g. "func" or "meth"
        try:
            NumpyDocString.__init__(self,inspect.getdoc(func) or '')
        except ValueError, e:
            print '*'*78
            print "ERROR: '%s' while parsing `%s`" % (e, self._f)
            print '*'*78
            #print "Docstring follows:"
            #print doclines
            #print '='*78

        if not self['Signature']:
            func, func_name = self.get_func()
            try:
                # try to read signature
                argspec = inspect.getargspec(func)
                argspec = inspect.formatargspec(*argspec)
                argspec = argspec.replace('*','\*')
                signature = '%s%s' % (func_name, argspec)
            except TypeError, e:
                signature = '%s()' % func_name
            self['Signature'] = signature

    def get_func(self):
        func_name = getattr(self._f, '__name__', self.__class__.__name__)
        if hasattr(self._f, '__class__') or inspect.isclass(self._f):
            func = getattr(self._f, '__call__', self._f.__init__)
        else:
            func = self._f
        return func, func_name

    def __str__(self):
        out = ''

        func, func_name = self.get_func()
        signature = self['Signature'].replace('*', '\*')

        roles = {'func': 'function',
                 'meth': 'method'}

        if self._role:
            if not roles.has_key(self._role):
                print "Warning: invalid role %s" % self._role
            out += '.. %s:: %s\n    \n\n' % (roles.get(self._role,''),
                                             func_name)

        out += super(FunctionDoc, self).__str__(func_role=self._role)
        return out


class ClassDoc(NumpyDocString):
    def __init__(self,cls,modulename='',func_doc=FunctionDoc):
        if not inspect.isclass(cls):
            raise ValueError("Initialise using a class. Got %r" % cls)
        self._cls = cls

        if modulename and not modulename.endswith('.'):
            modulename += '.'
        self._mod = modulename
        self._name = cls.__name__
        self._func_doc = func_doc

        NumpyDocString.__init__(self, pydoc.getdoc(cls))

    @property
    def methods(self):
        return [name for name,func in inspect.getmembers(self._cls)
                if not name.startswith('_') and callable(func)]

    def __str__(self):
        out = ''
        out += super(ClassDoc, self).__str__()
        out += "\n\n"

        #for m in self.methods:
        #    print "Parsing `%s`" % m
        #    out += str(self._func_doc(getattr(self._cls,m), 'meth')) + '\n\n'
        #    out += '.. index::\n   single: %s; %s\n\n' % (self._name, m)

        return out



########NEW FILE########
__FILENAME__ = docscrape_sphinx
import re, textwrap
from docscrape import NumpyDocString, FunctionDoc, ClassDoc

class SphinxDocString(NumpyDocString):
    # string conversion routines
    def _str_header(self, name, symbol='`'):
        return ['.. rubric:: ' + name, '']

    def _str_field_list(self, name):
        return [':' + name + ':']

    def _str_indent(self, doc, indent=4):
        out = []
        for line in doc:
            out += [' '*indent + line]
        return out

    def _str_signature(self):
        return ['']
        if self['Signature']:
            return ['``%s``' % self['Signature']] + ['']
        else:
            return ['']

    def _str_summary(self):
        return self['Summary'] + ['']

    def _str_extended_summary(self):
        return self['Extended Summary'] + ['']

    def _str_param_list(self, name):
        out = []
        if self[name]:
            out += self._str_field_list(name)
            out += ['']
            for param,param_type,desc in self[name]:
                out += self._str_indent(['**%s** : %s' % (param.strip(),
                                                          param_type)])
                out += ['']
                out += self._str_indent(desc,8)
                out += ['']
        return out

    def _str_section(self, name):
        out = []
        if self[name]:
            out += self._str_header(name)
            out += ['']
            content = textwrap.dedent("\n".join(self[name])).split("\n")
            out += content
            out += ['']
        return out

    def _str_see_also(self, func_role):
        out = []
        if self['See Also']:
            see_also = super(SphinxDocString, self)._str_see_also(func_role)
            out = ['.. seealso::', '']
            out += self._str_indent(see_also[2:])
        return out

    def _str_index(self):
        idx = self['index']
        out = []
        if len(idx) == 0:
            return out

        out += ['.. index:: %s' % idx.get('default','')]
        for section, references in idx.iteritems():
            if section == 'default':
                continue
            elif section == 'refguide':
                out += ['   single: %s' % (', '.join(references))]
            else:
                out += ['   %s: %s' % (section, ','.join(references))]
        return out

    def _str_references(self):
        out = []
        if self['References']:
            out += self._str_header('References')
            if isinstance(self['References'], str):
                self['References'] = [self['References']]
            out.extend(self['References'])
            out += ['']
        return out

    def __str__(self, indent=0, func_role="func"):
        out = []
        out += self._str_signature()
        out += self._str_index() + ['']
        out += self._str_summary()
        out += self._str_extended_summary()
        for param_list in ('Parameters', 'Attributes', 'Methods',
                           'Returns','Raises'):
            out += self._str_param_list(param_list)
        out += self._str_see_also("obj")
        out += self._str_section('Notes')
        out += self._str_references()
        out += self._str_section('Examples')
        out = self._str_indent(out,indent)
        return '\n'.join(out)

class SphinxFunctionDoc(SphinxDocString, FunctionDoc):
    pass

class SphinxClassDoc(SphinxDocString, ClassDoc):
    pass

########NEW FILE########
__FILENAME__ = numpydoc
import os, re, pydoc
from docscrape_sphinx import SphinxDocString, SphinxClassDoc, SphinxFunctionDoc
import inspect

def mangle_docstrings(app, what, name, obj, options, lines,
                      reference_offset=[0]):
    if what == 'module':
        # Strip top title
        title_re = re.compile(r'^\s*[#*=]{4,}\n[a-z0-9 -]+\n[#*=]{4,}\s*',
                              re.I|re.S)
        lines[:] = title_re.sub('', "\n".join(lines)).split("\n")
    else:
        doc = get_doc_object(obj, what)
        lines[:] = str(doc).split("\n")

    if app.config.numpydoc_edit_link and hasattr(obj, '__name__') and \
           obj.__name__:
        v = dict(full_name=obj.__name__)
        lines += [''] + (app.config.numpydoc_edit_link % v).split("\n")

    # replace reference numbers so that there are no duplicates
    references = []
    for l in lines:
        l = l.strip()
        if l.startswith('.. ['):
            try:
                references.append(int(l[len('.. ['):l.index(']')]))
            except ValueError:
                print "WARNING: invalid reference in %s docstring" % name

    # Start renaming from the biggest number, otherwise we may
    # overwrite references.
    references.sort()
    if references:
        for i, line in enumerate(lines):
            for r in references:
                new_r = reference_offset[0] + r
                lines[i] = lines[i].replace('[%d]_' % r,
                                            '[%d]_' % new_r)
                lines[i] = lines[i].replace('.. [%d]' % r,
                                            '.. [%d]' % new_r)

    reference_offset[0] += len(references)

def get_doc_object(obj, what=None):
    if what is None:
        if inspect.isclass(obj):
            what = 'class'
        elif inspect.ismodule(obj):
            what = 'module'
        elif callable(obj):
            what = 'function'
        else:
            what = 'object'
    if what == 'class':
        return SphinxClassDoc(obj, '', func_doc=SphinxFunctionDoc)
    elif what in ('function', 'method'):
        return SphinxFunctionDoc(obj, '')
    else:
        return SphinxDocString(pydoc.getdoc(obj))

def mangle_signature(app, what, name, obj, options, sig, retann):
    # Do not try to inspect classes that don't define `__init__`
    if (inspect.isclass(obj) and
        'initializes x; see ' in pydoc.getdoc(obj.__init__)):
        return '', ''

    if not (callable(obj) or hasattr(obj, '__argspec_is_invalid_')): return
    if not hasattr(obj, '__doc__'): return

    doc = SphinxDocString(pydoc.getdoc(obj))
    if doc['Signature']:
        sig = re.sub("^[^(]*", "", doc['Signature'])
        return sig, ''

def initialize(app):
    try:
        app.connect('autodoc-process-signature', mangle_signature)
    except:
        monkeypatch_sphinx_ext_autodoc()

    fn = app.config.numpydoc_phantom_import_file
    if (fn and os.path.isfile(fn)):
        print "[numpydoc] Phantom importing modules from", fn, "..."
        import_phantom_module(fn)

def setup(app):
    app.connect('autodoc-process-docstring', mangle_docstrings)
    app.connect('builder-inited', initialize)
    app.add_config_value('numpydoc_phantom_import_file', None, True)
    app.add_config_value('numpydoc_edit_link', None, True)

    app.add_directive('autosummary', autosummary_directive, 1, (0, 0, False))
    app.add_role('autolink', autolink_role)

#------------------------------------------------------------------------------
# .. autosummary::
#------------------------------------------------------------------------------
from docutils.statemachine import ViewList
from docutils import nodes

import sphinx.addnodes, sphinx.roles
from sphinx.util import patfilter
import posixpath

def autosummary_directive(dirname, arguments, options, content, lineno,
                          content_offset, block_text, state, state_machine):
    """
    Pretty table containing short signatures and summaries of functions etc.

    autosummary also generates a (hidden) toctree:: node.

    """

    # XXX: make the signatures and signature abbreviations optional

    names = []
    names += [x for x in content if x.strip()]

    result, warnings, titles = get_autosummary(names, state.document)

    node = nodes.paragraph()
    state.nested_parse(result, 0, node)

    env = state.document.settings.env
    suffix = env.config.source_suffix
    all_docnames = env.found_docs.copy()
    dirname = posixpath.dirname(env.docname)

    docnames = []
    doctitles = {}
    for name in titles.keys():
        docname = 'generated/' + name
        doctitles[docname] = ""
        doctitles[docname + '.xhtml'] = ""
        if docname.endswith(suffix):
            docname = docname[:-len(suffix)]
        docname = posixpath.normpath(posixpath.join(dirname, docname))
        if docname not in env.found_docs:
            warnings.append(state.document.reporter.warning(
                'toctree references unknown document %r' % docname,
                line=lineno))
        docnames.append(docname)

    tocnode = sphinx.addnodes.toctree()
    tocnode['includefiles'] = docnames
    tocnode['includetitles'] = doctitles
    tocnode['maxdepth'] = -1
    tocnode['glob'] = None

    return warnings + node.children + [tocnode]

def get_autosummary(names, document):
    """
    Generate a proper table node for autosummary:: directive.

    Parameters
    ----------
    names : list of str
        Names of Python objects to be imported and added to the table.
    document : document
        Docutils document object

    """
    result = ViewList()
    warnings = []
    titles = {}

    prefixes = ['']
    prefixes.insert(0, document.settings.env.currmodule)

    rows = []

    for name in names:
        try:
            obj, real_name = import_by_name(name, prefixes=prefixes)
        except ImportError:
            warnings.append(document.reporter.warning(
                'failed to import %s' % name))
            rows.append((":obj:`%s`" % name, ""))
            continue

        doc = get_doc_object(obj)

        if doc['Summary']:
            titles[real_name] = " ".join(doc['Summary'])
        else:
            titles[real_name] = ""

        col1 = ":obj:`%s`" % name
        if doc['Signature']:
            sig = re.sub('^[a-zA-Z_0-9.-]*', '',
                         doc['Signature'].replace('*', r'\*'))
            if '=' in sig:
                # abbreviate optional arguments
                sig = re.sub(r', ([a-zA-Z0-9_]+)=', r'[, \1=', sig, count=1)
                sig = re.sub(r'\(([a-zA-Z0-9_]+)=', r'([\1=', sig, count=1)
                sig = re.sub(r'=[^,)]+,', ',', sig)
                sig = re.sub(r'=[^,)]+\)$', '])', sig)
                # shorten long strings
                sig = re.sub(r'(\[.{16,16}[^,)]*?),.*?\]\)', r'\1, ...])', sig)
            else:
                sig = re.sub(r'(\(.{16,16}[^,)]*?),.*?\)', r'\1, ...)', sig)
            col1 += " " + sig
        col2 = titles[real_name]

        rows.append((col1, col2))

    if not rows:
        return result, warnings, titles

    max_name_len = max([len(x[0]) for x in rows])
    row_fmt = "%%-%ds  %%s" % max_name_len
    table_banner = ('='*max_name_len) + '  ' + '==============='

    result.append(table_banner, '<autosummary>')
    for row in rows:
        result.append(row_fmt % row, '<autosummary>')
    result.append(table_banner, '<autosummary>')
    result.append('', '<autosummary>')

    return result, warnings, titles

def import_by_name(name, prefixes=[None]):
    """
    Import a Python object that has the given name, under one of the prefixes.

    Parameters
    ----------
    name : str
        Name of a Python object, eg. 'numpy.ndarray.view'
    prefixes : list of (str or None), optional
        Prefixes to prepend to the name (None implies no prefix).
        The first prefixed name that results to successful import is used.

    Returns
    -------
    obj
        The imported object
    name
        Name of the imported object (useful if `prefixes` was used)

    """
    for prefix in prefixes:
        try:
            if prefix:
                prefixed_name = '.'.join([prefix, name])
            else:
                prefixed_name = name
            return _import_by_name(prefixed_name), prefixed_name
        except ImportError:
            pass
    raise ImportError

def _import_by_name(name):
    """Import a Python object given its full name"""
    try:
        name_parts = name.split('.')
        last_j = 0
        modname = None
        for j in reversed(range(1, len(name_parts)+1)):
            last_j = j
            modname = '.'.join(name_parts[:j])
            try:
                __import__(modname)
            except ImportError:
                continue
            if modname in sys.modules:
                break

        if last_j < len(name_parts):
            obj = sys.modules[modname]
            for obj_name in name_parts[last_j:]:
                obj = getattr(obj, obj_name)
            return obj
        else:
            return sys.modules[modname]
    except (ValueError, ImportError, AttributeError, KeyError), e:
        raise ImportError(e)

#------------------------------------------------------------------------------
# :autolink: (smart default role)
#------------------------------------------------------------------------------

def autolink_role(typ, rawtext, etext, lineno, inliner,
                  options={}, content=[]):
    """
    Smart linking role.

    Expands to ":obj:`text`" if `text` is an object that can be imported;
    otherwise expands to "*text*".
    """
    r = sphinx.roles.xfileref_role('obj', rawtext, etext, lineno, inliner,
                                   options, content)
    pnode = r[0][0]

    prefixes = [None]
    #prefixes.insert(0, inliner.document.settings.env.currmodule)
    try:
        obj, name = import_by_name(pnode['reftarget'], prefixes)
    except ImportError:
        content = pnode[0]
        r[0][0] = nodes.emphasis(rawtext, content[0].astext(),
                                 classes=content['classes'])
    return r

#------------------------------------------------------------------------------
# Monkeypatch sphinx.ext.autodoc to accept argspecless autodocs (Sphinx < 0.5)
#------------------------------------------------------------------------------

def monkeypatch_sphinx_ext_autodoc():
    global _original_format_signature
    import sphinx.ext.autodoc

    if sphinx.ext.autodoc.format_signature is our_format_signature:
        return

    print "[numpydoc] Monkeypatching sphinx.ext.autodoc ..."
    _original_format_signature = sphinx.ext.autodoc.format_signature
    sphinx.ext.autodoc.format_signature = our_format_signature

def our_format_signature(what, obj):
    r = mangle_signature(None, what, None, obj, None, None, None)
    if r is not None:
        return r[0]
    else:
        return _original_format_signature(what, obj)

#------------------------------------------------------------------------------
# Creating 'phantom' modules from an XML description
#------------------------------------------------------------------------------
import imp, sys, compiler, types

def import_phantom_module(xml_file):
    """
    Insert a fake Python module to sys.modules, based on a XML file.

    The XML file is expected to conform to Pydocweb DTD. The fake
    module will contain dummy objects, which guarantee the following:

    - Docstrings are correct.
    - Class inheritance relationships are correct (if present in XML).
    - Function argspec is *NOT* correct (even if present in XML).
      Instead, the function signature is prepended to the function docstring.
    - Class attributes are *NOT* correct; instead, they are dummy objects.

    Parameters
    ----------
    xml_file : str
        Name of an XML file to read

    """
    import lxml.etree as etree

    object_cache = {}

    tree = etree.parse(xml_file)
    root = tree.getroot()

    # Sort items so that
    # - Base classes come before classes inherited from them
    # - Modules come before their contents
    all_nodes = dict([(n.attrib['id'], n) for n in root])

    def _get_bases(node, recurse=False):
        bases = [x.attrib['ref'] for x in node.findall('base')]
        if recurse:
            j = 0
            while True:
                try:
                    b = bases[j]
                except IndexError: break
                if b in all_nodes:
                    bases.extend(_get_bases(all_nodes[b]))
                j += 1
        return bases

    type_index = ['module', 'class', 'callable', 'object']

    def base_cmp(a, b):
        x = cmp(type_index.index(a.tag), type_index.index(b.tag))
        if x != 0: return x

        if a.tag == 'class' and b.tag == 'class':
            a_bases = _get_bases(a, recurse=True)
            b_bases = _get_bases(b, recurse=True)
            x = cmp(len(a_bases), len(b_bases))
            if x != 0: return x
            if a.attrib['id'] in b_bases: return -1
            if b.attrib['id'] in a_bases: return 1

        return cmp(a.attrib['id'].count('.'), b.attrib['id'].count('.'))

    nodes = root.getchildren()
    nodes.sort(base_cmp)

    # Create phantom items
    for node in nodes:
        name = node.attrib['id']
        doc = (node.text or '').decode('string-escape') + "\n"
        if doc == "\n": doc = ""

        # create parent, if missing
        parent = name
        while True:
            parent = '.'.join(parent.split('.')[:-1])
            if not parent: break
            if parent in object_cache: break
            obj = imp.new_module(parent)
            object_cache[parent] = obj
            sys.modules[parent] = obj

        # create object
        if node.tag == 'module':
            obj = imp.new_module(name)
            obj.__doc__ = doc
            sys.modules[name] = obj
        elif node.tag == 'class':
            bases = [object_cache[b] for b in _get_bases(node)
                     if b in object_cache]
            bases.append(object)
            init = lambda self: None
            init.__doc__ = doc
            obj = type(name, tuple(bases), {'__doc__': doc, '__init__': init})
            obj.__name__ = name.split('.')[-1]
        elif node.tag == 'callable':
            funcname = node.attrib['id'].split('.')[-1]
            argspec = node.attrib.get('argspec')
            if argspec:
                argspec = re.sub('^[^(]*', '', argspec)
                doc = "%s%s\n\n%s" % (funcname, argspec, doc)
            obj = lambda: 0
            obj.__argspec_is_invalid_ = True
            obj.func_name = funcname
            obj.__name__ = name
            obj.__doc__ = doc
            if inspect.isclass(object_cache[parent]):
                obj.__objclass__ = object_cache[parent]
        else:
            class Dummy(object): pass
            obj = Dummy()
            obj.__name__ = name
            obj.__doc__ = doc
            if inspect.isclass(object_cache[parent]):
                obj.__get__ = lambda: None
        object_cache[name] = obj

        if parent:
            if inspect.ismodule(object_cache[parent]):
                obj.__module__ = parent
                setattr(object_cache[parent], name.split('.')[-1], obj)

    # Populate items
    for node in root:
        obj = object_cache.get(node.attrib['id'])
        if obj is None: continue
        for ref in node.findall('ref'):
            if node.tag == 'class':
                if ref.attrib['ref'].startswith(node.attrib['id'] + '.'):
                    setattr(obj, ref.attrib['name'],
                            object_cache.get(ref.attrib['ref']))
            else:
                setattr(obj, ref.attrib['name'],
                        object_cache.get(ref.attrib['ref']))

########NEW FILE########
__FILENAME__ = traitsdoc
import inspect
import os
import pydoc

import docscrape
from docscrape_sphinx import SphinxClassDoc, SphinxFunctionDoc
import numpydoc
import comment_eater

class SphinxTraitsDoc(SphinxClassDoc):
    def __init__(self, cls, modulename='', func_doc=SphinxFunctionDoc):
        if not inspect.isclass(cls):
            raise ValueError("Initialise using a class. Got %r" % cls)
        self._cls = cls

        if modulename and not modulename.endswith('.'):
            modulename += '.'
        self._mod = modulename
        self._name = cls.__name__
        self._func_doc = func_doc

        docstring = pydoc.getdoc(cls)
        docstring = docstring.split('\n')

        # De-indent paragraph
        try:
            indent = min(len(s) - len(s.lstrip()) for s in docstring
                         if s.strip())
        except ValueError:
            indent = 0

        for n,line in enumerate(docstring):
            docstring[n] = docstring[n][indent:]

        self._doc = docscrape.Reader(docstring)
        self._parsed_data = {
            'Signature': '',
            'Summary': '',
            'Description': [],
            'Extended Summary': [],
            'Parameters': [],
            'Returns': [],
            'Raises': [],
            'Warns': [],
            'Other Parameters': [],
            'Traits': [],
            'Methods': [],
            'See Also': [],
            'Notes': [],
            'References': '',
            'Example': '',
            'Examples': '',
            'index': {}
            }

        self._parse()

    def _str_summary(self):
        return self['Summary'] + ['']

    def _str_extended_summary(self):
        return self['Description'] + self['Extended Summary'] + ['']

    def __str__(self, indent=0, func_role="func"):
        out = []
        out += self._str_signature()
        out += self._str_index() + ['']
        out += self._str_summary()
        out += self._str_extended_summary()
        for param_list in ('Parameters', 'Traits', 'Methods',
                           'Returns','Raises'):
            out += self._str_param_list(param_list)
        out += self._str_see_also("obj")
        out += self._str_section('Notes')
        out += self._str_references()
        out += self._str_section('Example')
        out += self._str_section('Examples')
        out = self._str_indent(out,indent)
        return '\n'.join(out)

def looks_like_issubclass(obj, classname):
    """ Return True if the object has a class or superclass with the given class
    name.

    Ignores old-style classes.
    """
    t = obj
    if t.__name__ == classname:
        return True
    for klass in t.__mro__:
        if klass.__name__ == classname:
            return True
    return False

def get_doc_object(obj, what=None):
    if what is None:
        if inspect.isclass(obj):
            what = 'class'
        elif inspect.ismodule(obj):
            what = 'module'
        elif callable(obj):
            what = 'function'
        else:
            what = 'object'
    if what == 'class':
        doc = SphinxTraitsDoc(obj, '', func_doc=numpydoc.SphinxFunctionDoc)
        if looks_like_issubclass(obj, 'HasTraits'):
            for name, trait, comment in comment_eater.get_class_traits(obj):
                # Exclude private traits.
                if not name.startswith('_'):
                    doc['Traits'].append((name, trait, comment.splitlines()))
        return doc
    elif what in ('function', 'method'):
        return numpydoc.SphinxFunctionDoc(obj, '')
    else:
        return numpydoc.SphinxDocString(pydoc.getdoc(obj))

def initialize(app):
    try:
        app.connect('autodoc-process-signature', numpydoc.mangle_signature)
    except:
        numpydoc.monkeypatch_sphinx_ext_autodoc()

    # Monkeypatch numpydoc
    numpydoc.get_doc_object = get_doc_object

    fn = app.config.numpydoc_phantom_import_file
    if (fn and os.path.isfile(fn)):
        print "[numpydoc] Phantom importing modules from", fn, "..."
        numpydoc.import_phantom_module(fn)

def setup(app):
    app.connect('autodoc-process-docstring', numpydoc.mangle_docstrings)
    app.connect('builder-inited', initialize)
    app.add_config_value('numpydoc_phantom_import_file', None, True)
    app.add_config_value('numpydoc_edit_link', None, True)

    app.add_directive('autosummary', numpydoc.autosummary_directive, 1, (0, 0, False))
    app.add_role('autolink', numpydoc.autolink_role)



########NEW FILE########
__FILENAME__ = asynchronous_updates
"""
Perform expensive calculations based on user interactions while keeping the GUI
responsive. This makes use of asynchronous programming tools in the encore
package.

Move the slider to blur the image. Note the slider stays responsive even though
the blurring may lag the slider. Uncheck "Asynchronous" and note that the
slider movement is no longer responsive - the blurring occurs on the main
thread and interrupts the movement of the slider.
"""
# Major library imports
from numpy import ogrid, pi, sin

# Enthought library imports
from enable.api import Component, ComponentEditor
from traits.api import (Array, Bool, DelegatesTo, HasTraits, Instance, Range,
                        on_trait_change)
from traits.trait_notifiers import ui_dispatch
from traitsui.api import Item, Group, View

try:
    from encore.concurrent.futures.enhanced_thread_pool_executor import \
        EnhancedThreadPoolExecutor
    from encore.concurrent.futures.asynchronizer import Asynchronizer
except ImportError:
    import sys
    sys.exit('You need futures and encore installed to run this demo.')

# Chaco imports
from chaco.api import ArrayPlotData, Plot, VPlotContainer, gray


class BlurPlotController(HasTraits):
    """ Plot controller class for an image plot and its blurred output """

    #==========================================================================
    # Synchronization logic
    #==========================================================================

    # Flag indicating whether updates are asynchronous.
    asynchronous = Bool(True)

    # The executor. This provides a thread pool on which to process operations.
    _executor = Instance(EnhancedThreadPoolExecutor)

    # The asynchronizer. This dispatches calls to the executor while dropping
    # calls that cannot be handled fast enough.
    _asynchronizer = Instance(Asynchronizer)

    def __executor_default(self):
        # TIP: The executor should be 'shutdown' when no longer needed to avoid
        # creating multiple idle threads. This is not necessary in a small
        # demo.
        return EnhancedThreadPoolExecutor(max_workers=1)

    def __asynchronizer_default(self):
        # TIP: Multiple Asynchronizers can share the same executor.  If you
        # have multiple calls that need to be "asynchronized", each should have
        # its own asynchronizer.
        return Asynchronizer(self._executor)

    @on_trait_change('blur_level, image', post_init=True)
    def _recalculate_blurred_image(self):
        """ Blur the image either synchronously or with the asynchronizer """
        image = self.image
        blur_level = self.blur_level

        if self.asynchronous:
            # The 'submit' call is non-blocking, and returns almost
            # immediately.  The asynchronizer will pass
            # self._blur_and_notify_plot and its arguments (the "job") to the
            # executor to be run on one of the executor's worker threads when
            # the asynchronizer's current job (if any) is complete. If another
            # job (presumably with a different blur_level) comes in before this
            # happens, this job will never be executed.
            self._asynchronizer.submit(self._blur_and_notify_plot, image,
                                       blur_level)
        else:
            # This happens on the calling thread, which is the GUI thread when
            # a change in 'blur_level' comes from the GUI (as in this demo).
            # The GUI must wait for these calls to complete before it can
            # process further user input.  If the calls are slow, the GUI will
            # become unresponsive.
            self.blurred_image = blur_image(image, blur_level)
            self.plot_data.set_data("blurred_image", self.blurred_image)

    def _blur_and_notify_plot(self, image, blur_level):
        """ Do the work of blurring the image and notifying the plot """
        self.blurred_image = blur_image(image, blur_level)

        # Calling 'self.plot_data.set_data' will update the blurred plot.  In
        # general, it is not safe to send visual updates when not on the GUI
        # thread. Since this call is being executed on one of the executor's
        # worker threads, we must re-dispatch the data update to the UI thread
        # or suffer undefined consequences (possibly crashes).
        ui_dispatch(self.plot_data.set_data, "blurred_image",
                    self.blurred_image)

    #==========================================================================
    # Visualization logic - useful, but not the point of the demo
    #==========================================================================

    # An image array to display
    image = Array

    # The blurred image to display
    blurred_image = Array

    # The level of blurring to apply
    blur_level = Range(low=0, high=5)

    # The plot data
    plot_data = Instance(ArrayPlotData)

    # The plot component
    component = Instance(Component)

    def _image_default(self):
        x, y = ogrid[-pi:pi:1024j, 0:2*pi:1024j]
        z = (sin(11*x**2)**2 * sin(5*y**2))**2
        return z

    def _blurred_image_default(self):
        return self.image

    def _plot_data_default(self):
        pd = ArrayPlotData()
        pd.set_data("image", self.image)
        pd.set_data("blurred_image", self.blurred_image)
        return pd

    def _component_default(self):
        padding = (25, 5, 5, 25)
        image_plot = Plot(self.plot_data, padding=padding)
        image_plot.img_plot("image",
                            origin="top left",
                            xbounds=(-pi, pi),
                            ybounds=(-pi, pi),
                            colormap=gray)

        blurred_image_plot = Plot(self.plot_data, padding=padding)
        blurred_image_plot.img_plot("blurred_image",
                                    origin="top left",
                                    xbounds=(-pi, pi),
                                    ybounds=(-pi, pi),
                                    colormap=gray)

        container = VPlotContainer()
        container.add(blurred_image_plot)
        container.add(image_plot)
        return container


def blur_image(image, blur_level):
    """ Blur the image using a potentially time-consuming algorithm """

    blurred_image = image.copy()
    for _ in xrange(blur_level**2):
        blurred_image[1:-1, 1:-1] += (
            blurred_image[:-2, 1:-1] +  # top
            blurred_image[2:, 1:-1] +  # bottom
            blurred_image[1:-1, :-2] +  # left
            blurred_image[1:-1, 2:] +  # right
            blurred_image[:-2, :-2] +  # top-left
            blurred_image[:-2, 2:] +  # top-right
            blurred_image[2:, :-2] +  # bottom-left
            blurred_image[2:, 2:]  # bottom-right
        )
        blurred_image /= 9

    return blurred_image


#==============================================================================
# Attributes to use for the plot view.
#==============================================================================
size = (800, 600)
title = "Image with asynchronous blurring"


#==============================================================================
# Demo class that is used by the demo.py application.
#==============================================================================
class Demo(HasTraits):

    plot_controller = Instance(BlurPlotController, ())

    component = DelegatesTo('plot_controller')

    blur_level = DelegatesTo('plot_controller')

    asynchronous = DelegatesTo('plot_controller')

    traits_view = View(
        Group(
            Item(
                'component',
                editor=ComponentEditor(size=size),
                show_label=False
            ),
            Group(
                Item('asynchronous'),
                Item('blur_level'),
                orientation="horizontal"
            ),
            orientation="vertical"
        ),
        resizable=True,
        title=title
    )


demo = Demo()

if __name__ == "__main__":
    demo.configure_traits()

########NEW FILE########
__FILENAME__ = cmap_variable_sized_scatter
"""
Draws a scatterplot of a set of random points of variable size and color.
 - This uses the non-standard renderer, VariableSizeScatterPlot
 - Left-drag pans the plot.
 - Mousewheel up and down zooms the plot in and out.
 - Pressing "z" brings up the Zoom Box, and you can click-drag a rectangular
   region to zoom.  If you use a sequence of zoom boxes, pressing control-y and
   control-z  (Meta-y and Meta-z on Mac) moves you forwards and backwards
   through the "zoom history".
"""

# Major library imports
import numpy

# Enthought library imports
from enable.api import Component, ComponentEditor
from traits.api import HasTraits, Instance
from traitsui.api import Item, Group, View

# Chaco imports
from chaco.api import ArrayPlotData, Plot, ColormappedScatterPlot, \
        LinearMapper, ArrayDataSource, jet, DataRange1D
from chaco.tools.api import PanTool, ZoomTool

#===============================================================================
# # Create the Chaco plot.
#===============================================================================
def _create_plot_component():

    # Create some data
    numpts = 1000
    x = numpy.arange(0, numpts)
    y = numpy.random.random(numpts)
    marker_size = numpy.random.normal(4.0, 4.0, numpts)
    color = numpy.random.random(numpts)

    # Create a plot data object and give it this data
    pd = ArrayPlotData()
    pd.set_data("index", x)
    pd.set_data("value", y)

    # Because this is a non-standard renderer, we can't call plot.plot, which
    # sets up the array data sources, mappers and default index/value ranges.
    # So, its gotta be done manually for now.

    index_ds = ArrayDataSource(x)
    value_ds = ArrayDataSource(y)
    color_ds = ArrayDataSource(color)

    # Create the plot
    plot = Plot(pd)
    plot.index_range.add(index_ds)
    plot.value_range.add(value_ds)

    # Create the index and value mappers using the plot data ranges
    imapper = LinearMapper(range=plot.index_range)
    vmapper = LinearMapper(range=plot.value_range)

    # Create the scatter renderer
    scatter = ColormappedScatterPlot(
                    index=index_ds,
                    value=value_ds,
                    color_data=color_ds,
                    color_mapper=jet(range=DataRange1D(low=0.0, high=1.0)),
                    fill_alpha=0.4,
                    index_mapper = imapper,
                    value_mapper = vmapper,
                    marker='circle',
                    marker_size=marker_size)

    # Append the renderer to the list of the plot's plots
    plot.add(scatter)
    plot.plots['var_size_scatter'] = [scatter]

    # Tweak some of the plot properties
    plot.title = "Variable Size and Color Scatter Plot"
    plot.line_width = 0.5
    plot.padding = 50

    # Attach some tools to the plot
    plot.tools.append(PanTool(plot, constrain_key="shift"))
    zoom = ZoomTool(component=plot, tool_mode="box", always_on=False)
    plot.overlays.append(zoom)

    return plot

#===============================================================================
# Attributes to use for the plot view.
size = (650, 650)
title = "Variable size and color scatter plot"
bg_color="lightgray"

#===============================================================================
# # Demo class that is used by the demo.py application.
#===============================================================================
class Demo(HasTraits):
    plot = Instance(Component)

    traits_view = View(
                    Group(
                        Item('plot', editor=ComponentEditor(size=size,
                                                            bgcolor=bg_color),
                             show_label=False),
                        orientation = "vertical"),
                    resizable=True, title=title
                    )

    def _plot_default(self):
         return _create_plot_component()

demo = Demo()

if __name__ == "__main__":
    demo.configure_traits()

#--EOF---

########NEW FILE########
__FILENAME__ = data_cube
"""
Allows isometric viewing of a 3D data cube.

Click or click-drag in any data window to set the slice to view.
"""

# Outstanding TODOs:
#  - need to add line inspectors to side and bottom plots, and synchronize
#    with center plot
#  - need to set the various image plots to use the same colormap instance,
#    and that colormap's range needs to be set to min/max of the entire cube
#  - refactor create_window() so there is less code duplication
#  - try to eliminate the use of model.xs, ys, zs in favor of bounds tuples
from numpy import amin, amax, zeros, fromfile, transpose, uint8

# Standard library imports
import os, sys, shutil

# Major library imports
from numpy import arange, linspace, nanmin, nanmax, newaxis, pi, sin, cos

# Enthought library imports
from chaco.api import ArrayPlotData, Plot, GridPlotContainer, \
                                 BaseTool, DataRange1D
from chaco.default_colormaps import *
from chaco.tools.api import LineInspector, ZoomTool
from enable.example_support import DemoFrame, demo_main
from enable.api import Window
from traits.api import Any, Array, Bool, Callable, CFloat, CInt, \
        Event, Float, HasTraits, Int, Trait, on_trait_change

# Will hold the path that the user chooses to download to. Will be an empty
# string if the user decides to download to the current directory.
dl_path = ''

# Determines if the script should ask the user if they would like to remove the
# downloaded data.  This defaults to False, because data deletion is
# irreversible, and in the worst case, the user will have to remove it
# manually themselves.
run_cleanup = False

class Model(HasTraits):
    npts_x = CInt(256)
    npts_y = CInt(256)
    npts_z = CInt(109)

    min_x = CFloat(-2*pi)
    max_x = CFloat(2*pi)
    min_y = CFloat(-2*pi)
    max_y = CFloat(2*pi)
    min_z = CFloat(-pi)
    max_z = CFloat(pi)

    xs = Array
    ys = Array
    vals = Array

    minval = Float
    maxval = Float

    model_changed = Event

    def __init__(self, *args, **kwargs):
        super(Model, self).__init__(*args, **kwargs)
        self.compute_model()

    @on_trait_change("npts_+", "min_+", "max_+")
    def compute_model(self):
        def vfunc(x, y, z):
            return sin(x*z) * cos(y)*sin(z) + sin(0.5*z)

        # Create the axes
        self.xs = linspace(self.min_x, self.max_x, self.npts_x)
        self.ys = linspace(self.min_y, self.max_y, self.npts_y)
        self.zs = linspace(self.min_z, self.max_z, self.npts_z)

        # Generate a cube of values by using newaxis to span new dimensions
        self.vals = vfunc(self.xs[:, newaxis, newaxis],
                          self.ys[newaxis, :, newaxis],
                          self.zs[newaxis, newaxis, :])

        self.minval = nanmin(self.vals)
        self.maxval = nanmax(self.vals)
        self.model_changed = True


class BrainModel(Model):
    def __init__(self, *args, **kwargs):
        download_data()
        super(BrainModel, self).__init__(*args, **kwargs)

    def compute_model(self):
        global dl_path
        mrbrain_path = os.path.join(dl_path, 'voldata', 'MRbrain.')
        nx = 256
        ny = 256
        nz = 109
        full_arr = zeros((nx, ny, nz), dtype='f')
        for i in range(1, 110):
            arr = fromfile(mrbrain_path + str(i), dtype='>u2')
            arr.shape = (256,256)
            full_arr[:,:,i-1] = arr
        self.vals = full_arr

        # Create the axes
        self.xs = arange(nx)
        self.ys = arange(ny)
        self.zs = arange(nz)

        # Generate a cube of values by using newaxis to span new dimensions
        self.minval = nanmin(self.vals)
        self.maxval = nanmax(self.vals)
        self.model_changed = True


class ImageIndexTool(BaseTool):
    """ A tool to set the slice of a cube based on the user's mouse movements
    or clicks.
    """

    # This callback will be called with the index into self.component's
    # index and value:
    #     callback(tool, x_index, y_index)
    # where *tool* is a reference to this tool instance.  The callback
    # can then use tool.token.
    callback = Any()

    # This callback (if it exists) will be called with the integer number
    # of mousewheel clicks
    wheel_cb = Any()

    # This token can be used by the callback to decide how to process
    # the event.
    token  = Any()

    # Whether or not to update the slice info; we enter select mode when
    # the left mouse button is pressed and exit it when the mouse button
    # is released
    # FIXME: This is not used right now.
    select_mode = Bool(False)

    def normal_left_down(self, event):
        self._update_slices(event)

    def normal_right_down(self, event):
        self._update_slices(event)

    def normal_mouse_move(self, event):
        if event.left_down or event.right_down:
            self._update_slices(event)

    def _update_slices(self, event):
            plot = self.component
            ndx = plot.map_index((event.x, event.y),
                                 threshold=5.0, index_only=True)
            if ndx:
                self.callback(self, *ndx)

    def normal_mouse_wheel(self, event):
        if self.wheel_cb is not None:
            self.wheel_cb(self, event.mouse_wheel)


class PlotFrame(DemoFrame):

    # These are the indices into the cube that each of the image plot views
    # will show; the default values are non-zero just to make it a little
    # interesting.
    slice_x = 10
    slice_y = 10
    slice_z = 10

    num_levels = Int(15)
    colormap = Any
    colorcube = Any

    #---------------------------------------------------------------------------
    # Private Traits
    #---------------------------------------------------------------------------

    _cmap = Trait(jet, Callable)

    def _index_callback(self, tool, x_index, y_index):
        plane = tool.token
        if plane == "xy":
            self.slice_x = x_index
            self.slice_y = y_index
        elif plane == "yz":
            # transposed because the plot is oriented vertically
            self.slice_z = x_index
            self.slice_y = y_index
        elif plane == "xz":
            self.slice_x = x_index
            self.slice_z = y_index
        else:
            warnings.warn("Unrecognized plane for _index_callback: %s" % plane)
        self._update_images()
        self.center.invalidate_and_redraw()
        self.right.invalidate_and_redraw()
        self.bottom.invalidate_and_redraw()
        return

    def _wheel_callback(self, tool, wheelamt):
        plane_slice_dict = {"xy": ("slice_z", 2),
                            "yz": ("slice_x", 0),
                            "xz": ("slice_y", 1)}
        attr, shape_ndx = plane_slice_dict[tool.token]
        val = getattr(self, attr)
        max = self.model.vals.shape[shape_ndx]
        if val + wheelamt > max:
            setattr(self, attr, max-1)
        elif val + wheelamt < 0:
            setattr(self, attr, 0)
        else:
            setattr(self, attr, val + wheelamt)

        self._update_images()
        self.center.invalidate_and_redraw()
        self.right.invalidate_and_redraw()
        self.bottom.invalidate_and_redraw()
        return

    def _create_window(self):
        # Create the model
        #try:
        #    self.model = model = BrainModel()
        #    cmap = bone
        #except SystemExit:
        #    sys.exit()
        #except:
        #    print "Unable to load BrainModel, using generated data cube."
        self.model = model = Model()
        cmap = jet
        self._update_model(cmap)

        datacube = self.colorcube

        # Create the plot
        self.plotdata = ArrayPlotData()
        self._update_images()

        # Center Plot
        centerplot = Plot(self.plotdata, padding=0)
        imgplot = centerplot.img_plot("xy",
                                xbounds=(model.xs[0], model.xs[-1]),
                                ybounds=(model.ys[0], model.ys[-1]),
                                colormap=cmap)[0]
        self._add_plot_tools(imgplot, "xy")
        self.center = imgplot

        # Right Plot
        rightplot = Plot(self.plotdata, width=150, resizable="v", padding=0)
        rightplot.value_range = centerplot.value_range
        imgplot = rightplot.img_plot("yz",
                                xbounds=(model.zs[0], model.zs[-1]),
                                ybounds=(model.ys[0], model.ys[-1]),
                                colormap=cmap)[0]
        self._add_plot_tools(imgplot, "yz")
        self.right = imgplot

        # Bottom Plot
        bottomplot = Plot(self.plotdata, height=150, resizable="h", padding=0)
        bottomplot.index_range = centerplot.index_range
        imgplot = bottomplot.img_plot("xz",
                                xbounds=(model.xs[0], model.xs[-1]),
                                ybounds=(model.zs[0], model.zs[-1]),
                                colormap=cmap)[0]
        self._add_plot_tools(imgplot, "xz")
        self.bottom = imgplot

        # Create Container and add all Plots
        container = GridPlotContainer(padding=20, fill_padding=True,
                                      bgcolor="white", use_backbuffer=True,
                                      shape=(2,2), spacing=(12,12))
        container.add(centerplot)
        container.add(rightplot)
        container.add(bottomplot)

        self.container = container
        return Window(self, -1, component=container)

    def _add_plot_tools(self, imgplot, token):
        """ Add LineInspectors, ImageIndexTool, and ZoomTool to the image plots. """

        imgplot.overlays.append(ZoomTool(component=imgplot, tool_mode="box",
                                           enable_wheel=False, always_on=False))
        imgplot.overlays.append(LineInspector(imgplot, axis="index_y", color="white",
            inspect_mode="indexed", write_metadata=True, is_listener=True))
        imgplot.overlays.append(LineInspector(imgplot, axis="index_x", color="white",
            inspect_mode="indexed", write_metadata=True, is_listener=True))
        imgplot.tools.append(ImageIndexTool(imgplot, token=token,
            callback=self._index_callback, wheel_cb=self._wheel_callback))

    def _update_model(self, cmap):
        range = DataRange1D(low=amin(self.model.vals),
                            high=amax(self.model.vals))
        self.colormap = cmap(range)
        self.colorcube = (self.colormap.map_screen(self.model.vals) * 255).astype(uint8)

    def _update_images(self):
        """ Updates the image data in self.plotdata to correspond to the
        slices given.
        """
        cube = self.colorcube
        pd = self.plotdata
        # These are transposed because img_plot() expects its data to be in
        # row-major order
        pd.set_data("xy", transpose(cube[:, :, self.slice_z], (1,0,2)))
        pd.set_data("xz", transpose(cube[:, self.slice_y, :], (1,0,2)))
        pd.set_data("yz", cube[self.slice_x, :, :])

def download_data():
    global dl_path, run_cleanup

    print 'Please enter the location of the "voldata" subdirectory containing'
    print 'the data files for this demo, or enter a path to download to (7.8MB).'
    print 'Press <ENTER> to download to the current directory.'
    dl_path = raw_input('Path: ').strip().rstrip("/").rstrip("\\")

    if not dl_path.endswith("voldata"):
        voldata_path = os.path.join(dl_path, 'voldata')
    else:
        voldata_path = dl_path
    tar_path = os.path.join(dl_path, 'MRbrain.tar.gz')

    data_good = True
    try:
        for i in range(1,110):
            if not os.path.isfile(os.path.join(voldata_path, "MRbrain.%d" % i)):
                data_good = False
                break
        else:
            data_good = True
    except:
        data_good = False

    if not data_good:
        import urllib
        import tarfile

        if len(dl_path) > 0 and not os.path.exists(dl_path):
            print 'The given path does not exist.'
            run_cleanup = False
            sys.exit()

        if not os.path.isabs(dl_path):
            print 'Downloading to: ' + os.path.join(os.getcwd(), dl_path)
        else:
            print 'Downloading to: ' + dl_path

        try:
            # download and extract the file
            print "Downloading data, Please Wait (7.8MB)"
            opener = urllib.urlopen('http://www-graphics.stanford.edu/data/voldata/MRbrain.tar.gz')
        except:
            print 'Download error. Opening backup data.'
            run_cleanup = False
            raise

        try:
            open(tar_path, 'wb').write(opener.read())
        except:
            print 'Cannot write to the destination directory specified. ' \
                  'Opening backup data.'
            run_cleanup = False
            raise

        tar_file = tarfile.open(tar_path)
        try:
            os.mkdir(voldata_path)
        except:
            pass
        tar_file.extractall(voldata_path)
        tar_file.close()
        os.unlink(tar_path)
    else:
        print 'Previously downloaded data detected.'

def cleanup_data():
    global dl_path

    answer = raw_input('Remove downloaded files? [Y/N]: ')
    if answer.lower() == 'y':
        try:
            shutil.rmtree(os.path.join(dl_path, 'voldata'))
        except:
            pass

if __name__ == "__main__":
    # Save demo so that it doesn't get garbage collected when run within
    # existing event loop (i.e. from ipython).
    demo = demo_main(PlotFrame, size=(800,700), title="Cube analyzer")
    if run_cleanup:
        cleanup_data()


########NEW FILE########
__FILENAME__ = data_stream
"""
Visualization of simulated live data stream

Shows how Chaco and Traits can be used to easily build a data
acquisition and visualization system.

Two frames are opened: one has the plot and allows configuration of
various plot properties, and one which simulates controls for the hardware
device from which the data is being acquired; in this case, it is a mockup
random number generator whose mean and standard deviation can be controlled
by the user.
"""

# Major library imports
import numpy as np

# Enthought imports
from traits.api import (Array, Callable, Enum, Float, HasTraits, Instance, Int,
                        Trait)
from traitsui.api import Group, HGroup, Item, View, spring, Handler
from pyface.timer.api import Timer

# Chaco imports
from chaco.chaco_plot_editor import ChacoPlotItem


class Viewer(HasTraits):
    """ This class just contains the two data arrays that will be updated
    by the Controller.  The visualization/editor for this class is a
    Chaco plot.
    """
    index = Array

    data = Array

    plot_type = Enum("line", "scatter")

    view = View(ChacoPlotItem("index", "data",
                              type_trait="plot_type",
                              resizable=True,
                              x_label="Time",
                              y_label="Signal",
                              color="blue",
                              bgcolor="white",
                              border_visible=True,
                              border_width=1,
                              padding_bg_color="lightgray",
                              width=800,
                              height=380,
                              marker_size=2,
                              show_label=False),
                HGroup(spring, Item("plot_type", style='custom'), spring),
                resizable = True,
                buttons = ["OK"],
                width=800, height=500)


class Controller(HasTraits):

    # A reference to the plot viewer object
    viewer = Instance(Viewer)

    # Some parameters controller the random signal that will be generated
    distribution_type = Enum("normal", "lognormal")
    mean = Float(0.0)
    stddev = Float(1.0)

    # The max number of data points to accumulate and show in the plot
    max_num_points = Int(100)

    # The number of data points we have received; we need to keep track of
    # this in order to generate the correct x axis data series.
    num_ticks = Int(0)

    # private reference to the random number generator.  this syntax
    # just means that self._generator should be initialized to
    # random.normal, which is a random number function, and in the future
    # it can be set to any callable object.
    _generator = Trait(np.random.normal, Callable)

    view = View(Group('distribution_type',
                      'mean',
                      'stddev',
                      'max_num_points',
                      orientation="vertical"),
                      buttons=["OK", "Cancel"])

    def timer_tick(self, *args):
        """
        Callback function that should get called based on a timer tick.  This
        will generate a new random data point and set it on the `.data` array
        of our viewer object.
        """
        # Generate a new number and increment the tick count
        new_val = self._generator(self.mean, self.stddev)
        self.num_ticks += 1

        # grab the existing data, truncate it, and append the new point.
        # This isn't the most efficient thing in the world but it works.
        cur_data = self.viewer.data
        new_data = np.hstack((cur_data[-self.max_num_points+1:], [new_val]))
        new_index = np.arange(self.num_ticks - len(new_data) + 1,
                              self.num_ticks + 0.01)

        self.viewer.index = new_index
        self.viewer.data = new_data
        return

    def _distribution_type_changed(self):
        # This listens for a change in the type of distribution to use.
        if self.distribution_type == "normal":
            self._generator = np.random.normal
        else:
            self._generator = np.random.lognormal


class DemoHandler(Handler):

    def closed(self, info, is_ok):
        """ Handles a dialog-based user interface being closed by the user.
        Overridden here to stop the timer once the window is destroyed.
        """

        info.object.timer.Stop()
        return


class Demo(HasTraits):
    controller = Instance(Controller)
    viewer = Instance(Viewer, ())
    timer = Instance(Timer)
    view = View(Item('controller', style='custom', show_label=False),
                Item('viewer', style='custom', show_label=False),
                handler=DemoHandler,
                resizable=True)

    def edit_traits(self, *args, **kws):
        # Start up the timer! We should do this only when the demo actually
        # starts and not when the demo object is created.
        self.timer=Timer(100, self.controller.timer_tick)
        return super(Demo, self).edit_traits(*args, **kws)

    def configure_traits(self, *args, **kws):
        # Start up the timer! We should do this only when the demo actually
        # starts and not when the demo object is created.
        self.timer=Timer(100, self.controller.timer_tick)
        return super(Demo, self).configure_traits(*args, **kws)

    def _controller_default(self):
        return Controller(viewer=self.viewer)


# NOTE: examples/demo/demo.py looks for a 'demo' or 'popup' or 'modal popup'
# keyword when it executes this file, and displays a view for it.
popup=Demo()


if __name__ == "__main__":
    popup.configure_traits()

########NEW FILE########
__FILENAME__ = javascript_hover_tools
"""
Demo of a javascript inspector tool that shows a black bar over the active
value axis, as well as the values at the current index, with the numbers
shown in the colors matching the legend.

To Use
------
Run Python on this file which will generate six files,
    plot_hover_coords.html
    plot_hover_coords.png
    plot_hover2_coords.png
    hover_coords.js
    plot_hover_coords_png_hover_data.js
    plot_hover2_coords_png_hover_data.js

Alternatively, if you pass in '-e' or '--embedded' on the command-line, then
a single HTML file will be created that has all JavaScript and images
directly embedded into it.

The script should automatically load your webbrowser on the output file,
but if it does not, then manually open the file hover_coords_plot.html in
your browser to see the output.

Author: Judah De Paula <judah@enthought.com>
Date: November 21, 2008.
"""
# Standard library imports
import os, sys, webbrowser, cStringIO
from base64 import encodestring

# Major library imports
import Image
from numpy import arange, searchsorted, where, array, vstack, linspace
from scipy.special import jn

# Chaco imports
from chaco.api \
    import ArrayPlotData, Plot, PlotGraphicsContext, LinePlot
from chaco.example_support import COLOR_PALETTE


#-- Constants -----------------------------------------------------------------
DPI = 72.0


#------------------------------------------------------------------------------
#  File templates:
#     In a real application, these templates should be their own files,
#     and a real templating engine (ex. Mako) would make things more flexible.
#------------------------------------------------------------------------------
html_template_keys = {'filename1' : 'plot_hover_coords.png',
                      'filename2' : 'plot_hover2_coords.png',
                      'file1_src' : 'plot_hover_coords.png',
                      'file2_src' : 'plot_hover2_coords.png',
                      'hover_coords' :'src="hover_coords.js">',
                      'data1' :'src="plot_hover_coords_png_hover_data.js">',
                      'data2' :'src="plot_hover2_coords_png_hover_data.js">' }


# Turns into index.html.
html_template = """
<html>
<head>
    <script type="text/javascript" %(hover_coords)s </script>
    <script type="text/javascript" %(data1)s </script>
    <script type="text/javascript" %(data2)s </script>
</head>
<body>
<!------------------ What gets shown onmouseover. ------------------>
<div id="Hover"
     style="background-color: White; color: Black; padding:
            5px; position: absolute; visibility: hidden;"> 0
</div>

<div id="BlackPixel"
     style="background-color: White; color: Black; padding:
            0px; position: absolute; visibility: hidden;">
     <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAIAAACQd1PeAAAAAXNSR0IArs4c6QAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAxJREFUCNdjYGBgAAAABAABJzQnCgAAAABJRU5ErkJggg=="
          width="1"
          height="100"
          alt="black_pixel.inline"
          id="black_pixel.inline" />
</div>
<!------------------ Demo plot ------------------------------------->
<div class = "tabbertab">

    <img src="%(file1_src)s"
         alt="%(filename1)s"
         id="%(filename1)s"
         onmouseover="javascript:ShowHovers('%(filename1)s',
                                            'Hover', 'BlackPixel')"
         onmouseout="javascript:HideHovers(event,
                                           'Hover', 'BlackPixel')" />

    <img src="%(file2_src)s"
         alt="%(filename2)s"
         id="%(filename2)s"
         onmouseover="javascript:ShowHovers('%(filename2)s',
                                            'Hover', 'BlackPixel')"
         onmouseout="javascript:HideHovers(event,
                                           'Hover', 'BlackPixel')" />
</div>
</body>
</html>
"""


# Turns into plot_hover_coords_png_hover_data.js
javascript_data_template = """
// Create a new "CursorData" object
obj = Object();
obj.height = %(height)s;
obj.border_width = %(border_width)s;
obj.padding_top = %(padding_top)s + 1;
obj.padding_left = %(padding_left)s;
obj.padding_bottom = %(padding_bottom)s;
obj.colors = Array( %(colors)s );

// Store it in the global CursorData, using the unique array_id as a key.
GlobalCursorData["%(array_id)s"] = obj

// Store all the data in the array
obj.data = Array( %(data_s)s );
"""


# Turns into hover_coords.js.  Absolutely no string substitution is done.
hover_coords_js_file = """
<!------------------ Javascript hover functions ----------------->
<!-- Depends upon *_hover_data.js files.                       -->
<!--------------------------------------------------------------->

/*
   Global variables
*/

// Maps an image name to a CursorData object that contains an array of
// data and plot visual attributes like height, padding, and border width.
GlobalCursorData = Array();

// The hash key into GlobalCursorArray that corresponds to the the current
// plot that the mouse is over.
var CurrentPlotKey = "";

// The ID of the <div> box that contains the cursor line image.
var BoxElementID;

// The ID of the <img> of the cursor line image.
var LineElementID;

// The number of pixels to offset the readout box from cursor position
var _xOffset = 15;
var _yOffset = 15;


/*
   Convert an array of floats into an HTML formatted string ready for
   the screen.
 */
function FormatToHTML(data) {
    var colors = GlobalCursorData[CurrentPlotKey].colors;
    var s = '<font size=2 face="Courier New">';
    for (var count = 0; count < data.length; count++) {
        s = s + '<font color=' + colors[count] + '>' + data[count] + '</font><br>';
    }
    if (data.length > 0) {
        s = s.substr(0, s.length-4);
    }
    s += "</font>"
    return s;
}


/*
   Slightly more clever get x function than the default.  Limited testing.
*/
function GetMouseX(event) {
    if (!event) {
        event = window.event;
    }
    if (event.clientX) {
        return event.clientX +
               (document.documentElement.scrollLeft
                ? document.documentElement.scrollLeft
                : document.body.scrollLeft);
    } else if (event.pageX) {
        return event.pageX;
    } else {
        return 0;
    }
}


/*
   Slightly more clever get y function than the default.  Limited testing.
*/
function GetMouseY(event) {
    if (!event) {
        event = window.event;
    }
    if (event.clientY) {
        return event.clientY +
               (document.documentElement.scrollTop
                ? document.documentElement.scrollTop
                : document.body.scrollTop);
    } else if (event.pageY) {
        return event.pageY;
    } else {
        return 0;
    }
}


/*
   Uses data registered by external *hover_data.js files.

   Cannot figure out how to get relative coordinates.  Have to calculate
   it instead using the reference image element registered with the
   hover IDs.
*/
function ScreenXToImageX(mouseX) {
    var referenceX = document.getElementById(CurrentPlotKey);
    var cursor_data = GlobalCursorData[CurrentPlotKey];
    var relativeX = mouseX - cursor_data.padding_left
                           - cursor_data.border_width
                           - referenceX.x;
    return relativeX;
}


/*
   Uses data registered by external *hover_data.js files.

   The Screen pixel coordinate that the data pixels in the plot start.
*/
function ScreenYPlotStart(event) {
    var referenceElement = document.getElementById(CurrentPlotKey);
    var cursor_data = GlobalCursorData[CurrentPlotKey];
    return referenceElement.y + cursor_data.padding_top
                              + cursor_data.border_width;
}


/*
   Uses data registered by external *hover_data.js files.

   Given the browser X coordinate compute the plot screen X coordinate
   and use that value to index into the data array of plot values for
   that index.
*/
function ScreenXToDataY(mouseX) {
    var dataY;
    var relativeX = ScreenXToImageX(mouseX);
    var cursor_data = GlobalCursorData[CurrentPlotKey];

    if (relativeX >= 0 && relativeX < cursor_data.data.length) {
        dataY = cursor_data.data[relativeX];
    // Hack to have bar hidden on the left and right side of images.
        document.getElementById(LineElementID).style.visibility = 'visible';
        document.getElementById(BoxElementID).style.visibility = 'visible';
    } else {
        dataY = 0;
        // Hack to have bar hidden on the left and right side of images.
        document.getElementById(LineElementID).style.visibility = 'hidden';
        document.getElementById(BoxElementID).style.visibility = 'hidden';
    }
    return dataY;
}


/*
   Uses data registered by external *hover_data.js files.

   Every time the mouse moves over the image, Follow() changes the hovering
   object attributes so they move to the new location.
*/
function Follow(event) {
    // Move the box
    var referenceElement = document.getElementById(CurrentPlotKey);
    var element = document.getElementById(BoxElementID);
    if (element != null) {
        var style = element.style;
        // ScreenXToDataY() hacked to have better control of line visibility.
        //style.visibility = 'visible';
        style.left = (parseInt(GetMouseX(event)) + _xOffset) + 'px';
        style.top = (parseInt(GetMouseY(event)) + _yOffset) + 'px';
    element.innerHTML = FormatToHTML(ScreenXToDataY(GetMouseX(event)));
    }

    // Move the line
    var element = document.getElementById(LineElementID);
    var image_element = document.getElementById("black_pixel.inline");
    if (element != null) {
        var style = element.style;
        // ScreenXToDataY() hacked to have better control of line visibility.
        //style.visibility = 'visible';
        style.left = parseInt(GetMouseX(event)) + 'px';
        style.top = parseInt(ScreenYPlotStart()) + 'px';
        element.height = GlobalCursorData[CurrentPlotKey].height - 1;
        image_element.height = element.height;
    }
}


/*
   Abstracted out Show() that assigns the Follow() to mouse movements.
*/
function Show(referenceElementID) {
    var referenceElement = document.getElementById(referenceElementID);
    if (referenceElement) {
        referenceElement.onmousemove = Follow;
    }
}


/*
   Abstracted out Hide() that assigns the Follow() to mouse movements.
   Turns the hover object invisible and disables the Follow() listener.
   FIXME:  The listener is turned off for both hover objects even though
   only one object is hidden by this call.
*/
function Hide(referenceElementID, elementID) {
    var divStyle = document.getElementById(elementID).style;
    var referenceElement = document.getElementById(referenceElementID);
    divStyle.visibility = 'hidden';
    referenceElement.onmousemove = '';
}


/*
   Main entry point for onmouseover event of images.  Sets the globals
   to the active image the mouse just entered and turns on the hovers.
*/
function ShowHovers(referenceElementID, boxElementID, lineElementID) {
    //_dataIndex = plot_names.indexOf(referenceElementID);
    CurrentPlotKey = referenceElementID;
    BoxElementID = boxElementID;
    LineElementID = lineElementID;
    Show(CurrentPlotKey);
    Show(CurrentPlotKey);
}


/*
   Main event call point for onmouseout event for images
*/
function HideHovers(event, boxElementID, lineElementID) {
    var relatedTarget = event.relatedTarget;
    if ((relatedTarget == null) ||
        (relatedTarget.id != boxElementID) &&
        (relatedTarget.id != lineElementID) &&
        (relatedTarget.id != 'black_pixel.inline')) {
        Hide(CurrentPlotKey, boxElementID);
        Hide(CurrentPlotKey, lineElementID);
    }
}
"""


#------------------------------------------------------------------------------
#  Data generation functions for *_hover_data.js files.
#------------------------------------------------------------------------------

def get_pixel_data(segment, renderer, screen_width):
    """
    Take a segment of points and use a renderer to map them to screen coords.

    Algorithm
    ---------
    Fast little function that only works if the samples are sorted.
    FIXME: Need more explanation.
    """
    screen_points = renderer.map_screen(segment)

    if len(screen_points) == 0:
        return array([])

    s_index = screen_points[:,0].astype(int)
    d_value = segment[:,1]
    if len(s_index) != len(d_value):
        raise ValueError('Data-to-screen mapping not 1-to-1.')
    indices = searchsorted(s_index, arange(0, screen_width))
    indices[where(indices == 0)] = 1
    return d_value[indices-1]


def write_hover_coords(container, array_id, script_filename=None):
    """
    Create a JavaScript formatted file of screen index to data values.

    Parameters
    ----------
    container : Plot
        Chaco container object such as a plot that contain renderers
        and border padding information.
    array_id : str
        An identifier that will be used as the key when assigning the
        data array to the global list of data arrays.  This identifier
        should be unique among all the scripts that will be loaded in
        a single HTML file.
    script_filename : str
        Full path to the desired output javascript file.  If no name
        is passed in, then no file is written.

    Returns
    -------
    Returns the JavaScript data file as a string.

    Description
    -----------
    To have a PNG plot show the values of the curves in a browser,
    JavaScript is used to get the screen X/Y and convert the X into the
    corresponding plot data values.  This function creates that mapping
    array.  A couple of extra padding variables are also exported so the
    JavaScript can do some additional offset calculations.
    """
    screen_width = container.width
    # For every renderer in the plot, create an array of the same length
    # as the screen width that contains the data value for each screen
    # position.  Stack all of these arrays together into the 2D 'pixel_data'
    # array, then pass it into the template for the hover_data javascript file.
    segment_data = []
    colors = []
    for renderer_name in sorted(container.legend.plots.keys()):
        renderer = container.legend.plots[renderer_name][0]
        data_points = renderer._cached_data_pts
        if not isinstance(renderer, LinePlot):
            data_points = [data_points]
        for segment in data_points:
            segment_data.append(get_pixel_data(segment, renderer, screen_width))
        colors.append(renderer.color_)

    if len(segment_data) > 0:
        pixel_data = vstack(segment_data).T
    else:
        pixel_data = array([]).reshape(0, 2)

    # Fill out a template using the just-created data.
    colstrings = []
    for color in colors:
        if len(color) == 4:
            alpha = color[3]
        else:
            alpha = 1
        r, g, b = [int(component * alpha * 255) for component in color[:3]]
        colstrings.append('"#%02x%02x%02x"' % (r,g,b))
    colors = ",".join(colstrings);

    line_template = ",".join(['"%1.2f"'] * pixel_data.shape[1])
    data_s = ''
    for row in pixel_data[:-1]:
        data_s += '[' + line_template % tuple(row) +  '],'
    if len(pixel_data) > 0:
        data_s += '[' + line_template % tuple(row) + ']'

    template_keys = dict(height = container.height,
                         padding_top = container.padding_top,
                         padding_left = container.padding_left,
                         padding_bottom = container.padding_bottom,
                         border_width = container.border_width,
                         array_id = array_id,
                         pixel_data = pixel_data,
                         colors = colors,
                         data_s = data_s)

    # Write out and return the result.
    output = javascript_data_template % template_keys
    if script_filename:
        f = open(script_filename, 'wt')
        f.write(output)
        f.close()

    return output


#------------------------------------------------------------------------------
#  Plot and renderer generation functions.
#------------------------------------------------------------------------------
def create_plot(num_plots=8, type='line'):
    """ Create a single plot object, with multiple renderers. """
    # This is a bit of a hack to work around that line widths don't scale
    # with the GraphicsContext's CTM.
    dpi_scale = DPI / 72.0
    numpoints = 100
    low = -5
    high = 15.0
    x = linspace(low, high, numpoints)
    pd = ArrayPlotData(index=x)
    p = Plot(pd, bgcolor="white", padding=50, border_visible=True)
    for i in range(1,num_plots+2):
        pd.set_data("y" + str(i), jn(i,x))
        p.plot(("index", "y" + str(i)), color=tuple(COLOR_PALETTE[i]),
               width = 2.0 * dpi_scale, type=type)
    p.x_grid.visible = True
    p.x_grid.line_width *= dpi_scale
    p.y_grid.visible = True
    p.y_grid.line_width *= dpi_scale
    p.legend.visible = True
    return p


def draw_plot(filename, size=(800,600), num_plots=8, type='line', key=''):
    """ Save the plot, and generate the hover_data file. """
    container = create_plot(num_plots, type)
    container.outer_bounds = list(size)
    container.do_layout(force=True)
    gc = PlotGraphicsContext(size, dpi=DPI)
    gc.render_component(container)
    if filename:
        gc.save(filename)
        script_filename = filename[:-4] + "_png_hover_data.js"
    else:
        script_filename = None
    plot = make_palettized_png_str(gc)
    script_data = write_hover_coords(container, key, script_filename)
    return (plot, script_data)


def make_palettized_png_str(gc):
    """ Generate a png file in a string, base64 encoded. """
    format = gc.format()[:-2].upper()
    if format != "RGBA":
        gc = gc.convert_pixel_format("rgba32")
    img = Image.fromstring("RGBA",
                           (gc.width(), gc.height()), gc.bmp_array.tostring())
    img2 = img.convert("P")
    output_buf = cStringIO.StringIO()
    img2.save(output_buf, 'png')
    output = encodestring(output_buf.getvalue())
    output_buf.close()
    return output


#------------------------------------------------------------------------------
#  Main
#------------------------------------------------------------------------------
def main(embedded=False):
    """
    Create the files and load the output in a webbrowser.
    """
    # 1. Create the JavaScript hover tool file.
    #    Only doing this to keep the demo file self-contained.
    target_path = os.path.join(os.getcwd(), 'hover_coords.js')
    if embedded:
        html_template_keys['hover_coords'] = '>\n%s\n' % hover_coords_js_file
    else:
        f = open(target_path, 'wt')
        f.write(hover_coords_js_file)
        f.close()

    # 2. Create the dynamically generated JavaScript data files.
    if embedded:
        html_template_keys['file1_src'] = None
        html_template_keys['file2_src'] = None
    file1_strs = draw_plot(html_template_keys['file1_src'],
                           size=(800, 600),
                           key=html_template_keys['filename1'])
    file2_strs = draw_plot(html_template_keys['file2_src'],
                           size=(600, 400),
                           num_plots = 4,
                           type='scatter',
                           key=html_template_keys['filename2'])

    # 3. Choose the correct src type for the HTML file if embedded.
    if embedded:
        src1 = 'data:image/png;base64,' + file1_strs[0]
        html_template_keys['file1_src'] = src1
        src2 = 'data:image/png;base64,' + file2_strs[0]
        html_template_keys['file2_src'] = src2
        html_template_keys['data1'] = '>\n%s\n' % file1_strs[1]
        html_template_keys['data2'] = '>\n%s\n' % file2_strs[1]

    # 4. Create the HTML file.
    out_html = os.path.join(os.getcwd(), 'plot_hover_coords.html')
    f = open(out_html, 'wt')
    f.write(html_template % html_template_keys)
    f.close()

    # 5. Load the finished product.
    try:
        webbrowser.open(out_html)
    except Exception, e:
        print 'Browser did not open properly.  Exception %s.  The results' \
              'can be viewed with the file plot_hover_coords.html.' % str(e)
        raise
    return

#===============================================================================
# # Demo class that is used by the demo.py application.
#===============================================================================
# NOTE: The Demo class is being created for the purpose of running this
# example using a TraitsDemo-like app (see examples/demo/demo.py in Traits3).
# The demo.py file looks for a 'demo' or 'popup' or 'modal popup' keyword
# when it executes this file, and displays a view for it.

# NOTE2: In this case, Demo class is just a mock object. Essentially we want to
# execute main instead of displaying a UI for Demo: so we hack this by
# overriding configure_traits and edit_traits to return a blank UI.

from traits.api import HasTraits
from traitsui.api import UI, Handler

class Demo(HasTraits):

    def configure_traits(self, *args, **kws):
        main(embedded=True)
        return True

    def edit_traits(self, *args, **kws):
        main(embedded=True)
        return UI(handler=Handler())

popup = Demo()

if __name__ == "__main__":
    if '-e' in sys.argv or '--embedded' in sys.argv:
        main(embedded=True)
    else:
        main(embedded=False)
#-- eof -----------------------------------------------------------------------

########NEW FILE########
__FILENAME__ = scalar_image_function_inspector
"""
Colormap of a scalar value field with cross sections that can be animated

A complex example showing interaction between a Traits-based interactive model,
interactive plot parameters, and multiple Chaco components.

Renders a colormapped image of a scalar value field, and a cross section
chosen by a line interactor.

Animation must be disabled (unchecked) before the model can be edited.
"""

from __future__ import with_statement

# Standard library imports
from optparse import OptionParser
import sys
import random

# Major library imports
from numpy import array, linspace, meshgrid, nanmin, nanmax,  pi, errstate

# Enthought library imports
from chaco.api import ArrayPlotData, ColorBar, ContourLinePlot, \
                                 ContourPolyPlot, DataRange1D, VPlotContainer, \
                                 DataRange2D, GridMapper, GridDataSource, \
                                 HPlotContainer, ImageData, LinearMapper, \
                                 OverlayPlotContainer, Plot, PlotAxis
from chaco import default_colormaps
from enable.component_editor import ComponentEditor
from chaco.tools.api import LineInspector, PanTool, ZoomTool
from traits.api import Array, Callable, CFloat, CInt, Enum, Event, Float, \
    HasTraits, Int, Instance, Str, Trait, on_trait_change, Button, Bool, \
    DelegatesTo
from traitsui.api import Group, HGroup, Item, View, UItem, spring

from pyface.timer.api import Timer

# Remove the most boring colormaps from consideration:
colormaps = default_colormaps.color_map_name_dict.keys()
for boring in 'bone gray yarg gist_gray gist_yarg Greys'.split():
    colormaps.remove(boring)

class Model(HasTraits):

    #Traits view definitions:
    traits_view = View(
        Group(Item('function'),
              HGroup(Item('npts_x', label="Number X Points"),
                     Item('npts_y', label="Number Y Points")),
              HGroup(Item('min_x', label="Min X value"),
                     Item('max_x', label="Max X value")),
              HGroup(Item('min_y', label="Min Y value"),
                     Item('max_y', label="Max Y value"))),
                     buttons=["OK", "Cancel"])

    function = Str("tanh(x**2+y)*cos(y)*jn(0,x+y*2)")

    npts_x = CInt(400)
    npts_y = CInt(200)

    min_x = CFloat(-2*pi)
    max_x = CFloat(2*pi)
    min_y = CFloat(-1.5*pi)
    max_y = CFloat(1.5*pi)

    xs = Array
    ys = Array
    zs = Array

    minz = Float
    maxz = Float

    model_changed = Event

    def __init__(self, *args, **kwargs):
        super(Model, self).__init__(*args, **kwargs)
        self.compute_model()

    def compute_model(self):
        # The xs and ys used for the image plot range need to be the
        # edges of the cells.
        self.xs = linspace(self.min_x, self.max_x, self.npts_x+1)
        self.ys = linspace(self.min_y, self.max_y, self.npts_y+1)

        # The grid of points at which we will evaluate the 2D function
        # is located at cell centers, so use halfsteps from the
        # min/max values (which are edges)
        xstep = (self.max_x - self.min_x) / self.npts_x
        #ystep = (self.max_y - self.min_y) / self.npts_y
        gridx = linspace(self.min_x+xstep/2, self.max_x-xstep/2, self.npts_x)
        gridy = linspace(self.min_y+xstep/2, self.max_y-xstep/2, self.npts_y)
        x, y = meshgrid(gridx, gridy)
        try:
            d = dict(x=x, y=y)
            exec "from scipy import *" in d
            exec "from scipy.special import *" in d
            self.zs = eval(self.function, d)
            self.minz = nanmin(self.zs)
            self.maxz = nanmax(self.zs)
            self.model_changed = True
            self._function = self.function
        except:
            self.set(function = self._function, trait_change_notify=False)

    def _anytrait_changed(self, name, value):
        if name in ['function', 'npts_x', 'npts_y',
                    'min_x', 'max_x', 'min_y', 'max_y']:
            self.compute_model()


class PlotUI(HasTraits):
    
    # container for all plots
    container = Instance(HPlotContainer)
    
    # Plot components within this container:
    polyplot = Instance(ContourPolyPlot)
    lineplot = Instance(ContourLinePlot)
    cross_plot = Instance(Plot)
    cross_plot2 = Instance(Plot)
    colorbar = Instance(ColorBar)
    
    # plot data
    pd = Instance(ArrayPlotData)

    # view options
    num_levels = Int(15)
    colormap = Enum(colormaps)
    
    #Traits view definitions:
    traits_view = View(
        Group(UItem('container', editor=ComponentEditor(size=(800,600)))),
        resizable=True)

    plot_edit_view = View(
        Group(Item('num_levels'),
              Item('colormap')),
              buttons=["OK","Cancel"])

    
    #---------------------------------------------------------------------------
    # Private Traits
    #---------------------------------------------------------------------------

    _image_index = Instance(GridDataSource)
    _image_value = Instance(ImageData)

    _cmap = Trait(default_colormaps.jet, Callable)

    #---------------------------------------------------------------------------
    # Public View interface
    #---------------------------------------------------------------------------

    def __init__(self, *args, **kwargs):
        super(PlotUI, self).__init__(*args, **kwargs)
        # FIXME: 'with' wrapping is temporary fix for infinite range in initial 
        # color map, which can cause a distracting warning print. This 'with'
        # wrapping should be unnecessary after fix in color_mapper.py.
        with errstate(invalid='ignore'):
            self.create_plot()

    def create_plot(self):

        # Create the mapper, etc
        self._image_index = GridDataSource(array([]),
                                          array([]),
                                          sort_order=("ascending","ascending"))
        image_index_range = DataRange2D(self._image_index)
        self._image_index.on_trait_change(self._metadata_changed,
                                          "metadata_changed")

        self._image_value = ImageData(data=array([]), value_depth=1)
        image_value_range = DataRange1D(self._image_value)



        # Create the contour plots
        self.polyplot = ContourPolyPlot(index=self._image_index,
                                        value=self._image_value,
                                        index_mapper=GridMapper(range=
                                            image_index_range),
                                        color_mapper=\
                                            self._cmap(image_value_range),
                                        levels=self.num_levels)

        self.lineplot = ContourLinePlot(index=self._image_index,
                                        value=self._image_value,
                                        index_mapper=GridMapper(range=
                                            self.polyplot.index_mapper.range),
                                        levels=self.num_levels)


        # Add a left axis to the plot
        left = PlotAxis(orientation='left',
                        title= "y",
                        mapper=self.polyplot.index_mapper._ymapper,
                        component=self.polyplot)
        self.polyplot.overlays.append(left)

        # Add a bottom axis to the plot
        bottom = PlotAxis(orientation='bottom',
                          title= "x",
                          mapper=self.polyplot.index_mapper._xmapper,
                          component=self.polyplot)
        self.polyplot.overlays.append(bottom)


        # Add some tools to the plot
        self.polyplot.tools.append(PanTool(self.polyplot,
                                           constrain_key="shift"))
        self.polyplot.overlays.append(ZoomTool(component=self.polyplot,
                                            tool_mode="box", always_on=False))
        self.polyplot.overlays.append(LineInspector(component=self.polyplot,
                                               axis='index_x',
                                               inspect_mode="indexed",
                                               write_metadata=True,
                                               is_listener=True,
                                               color="white"))
        self.polyplot.overlays.append(LineInspector(component=self.polyplot,
                                               axis='index_y',
                                               inspect_mode="indexed",
                                               write_metadata=True,
                                               color="white",
                                               is_listener=True))

        # Add these two plots to one container
        contour_container = OverlayPlotContainer(padding=20,
                                                 use_backbuffer=True,
                                                 unified_draw=True)
        contour_container.add(self.polyplot)
        contour_container.add(self.lineplot)


        # Create a colorbar
        cbar_index_mapper = LinearMapper(range=image_value_range)
        self.colorbar = ColorBar(index_mapper=cbar_index_mapper,
                                 plot=self.polyplot,
                                 padding_top=self.polyplot.padding_top,
                                 padding_bottom=self.polyplot.padding_bottom,
                                 padding_right=40,
                                 resizable='v',
                                 width=30)

        self.pd = ArrayPlotData(line_index = array([]),
                                line_value = array([]),
                                scatter_index = array([]),
                                scatter_value = array([]),
                                scatter_color = array([]))

        self.cross_plot = Plot(self.pd, resizable="h")
        self.cross_plot.height = 100
        self.cross_plot.padding = 20
        self.cross_plot.plot(("line_index", "line_value"),
                             line_style="dot")
        self.cross_plot.plot(("scatter_index","scatter_value","scatter_color"),
                             type="cmap_scatter",
                             name="dot",
                             color_mapper=self._cmap(image_value_range),
                             marker="circle",
                             marker_size=8)

        self.cross_plot.index_range = self.polyplot.index_range.x_range

        self.pd.set_data("line_index2", array([]))
        self.pd.set_data("line_value2", array([]))
        self.pd.set_data("scatter_index2", array([]))
        self.pd.set_data("scatter_value2", array([]))
        self.pd.set_data("scatter_color2", array([]))

        self.cross_plot2 = Plot(self.pd, width = 140, orientation="v", 
                                resizable="v", padding=20, padding_bottom=160)
        self.cross_plot2.plot(("line_index2", "line_value2"),
                             line_style="dot")
        self.cross_plot2.plot(("scatter_index2",
                               "scatter_value2",
                               "scatter_color2"),
                             type="cmap_scatter",
                             name="dot",
                             color_mapper=self._cmap(image_value_range),
                             marker="circle",
                             marker_size=8)

        self.cross_plot2.index_range = self.polyplot.index_range.y_range



        # Create a container and add components
        self.container = HPlotContainer(padding=40, fill_padding=True,
                                        bgcolor = "white", use_backbuffer=False)
        inner_cont = VPlotContainer(padding=0, use_backbuffer=True)
        inner_cont.add(self.cross_plot)
        inner_cont.add(contour_container)
        self.container.add(self.colorbar)
        self.container.add(inner_cont)
        self.container.add(self.cross_plot2)


    def update(self, model):
        self.minz = model.minz
        self.maxz = model.maxz
        self.colorbar.index_mapper.range.low = self.minz
        self.colorbar.index_mapper.range.high = self.maxz
        self._image_index.set_data(model.xs, model.ys)
        self._image_value.data = model.zs
        self.pd.update_data(line_index=model.xs, line_index2=model.ys)
        self.container.invalidate_draw()
        self.container.request_redraw()


    #---------------------------------------------------------------------------
    # Event handlers
    #---------------------------------------------------------------------------

    def _metadata_changed(self, old, new):
        """ This function takes out a cross section from the image data, based
        on the line inspector selections, and updates the line and scatter
        plots."""

        self.cross_plot.value_range.low = self.minz
        self.cross_plot.value_range.high = self.maxz
        self.cross_plot2.value_range.low = self.minz
        self.cross_plot2.value_range.high = self.maxz
        if self._image_index.metadata.has_key("selections"):
            x_ndx, y_ndx = self._image_index.metadata["selections"]
            if y_ndx and x_ndx:
                xdata, ydata = self._image_index.get_data()
                xdata, ydata = xdata.get_data(), ydata.get_data()
                self.pd.update_data(
                    line_value=self._image_value.data[y_ndx,:],
                    line_value2=self._image_value.data[:,x_ndx],
                    scatter_index=array([xdata[x_ndx]]),
                    scatter_index2=array([ydata[y_ndx]]),
                    scatter_value=array([self._image_value.data[y_ndx, x_ndx]]),
                    scatter_value2=array([self._image_value.data[y_ndx, x_ndx]]),
                    scatter_color=array([self._image_value.data[y_ndx, x_ndx]]),
                    scatter_color2=array([self._image_value.data[y_ndx, x_ndx]])
                )
        else:
            self.pd.update_data({"scatter_value": array([]),
                "scatter_value2": array([]), "line_value": array([]),
                "line_value2": array([])})

    def _colormap_changed(self):
        self._cmap = default_colormaps.color_map_name_dict[self.colormap]
        if self.polyplot is not None:
            value_range = self.polyplot.color_mapper.range
            self.polyplot.color_mapper = self._cmap(value_range)
            value_range = self.cross_plot.color_mapper.range
            self.cross_plot.color_mapper = self._cmap(value_range)
            # FIXME: change when we decide how best to update plots using
            # the shared colormap in plot object
            self.cross_plot.plots["dot"
                                  ][0].color_mapper = self._cmap(value_range)
            self.cross_plot2.plots["dot"
                                   ][0].color_mapper = self._cmap(value_range)
            self.container.request_redraw()

    def _num_levels_changed(self):
        if self.num_levels > 3:
            self.polyplot.levels = self.num_levels
            self.lineplot.levels = self.num_levels



            
# HasTraits class that supplies the callable for the timer event.
class TimerController(HasTraits):

    # The plot view which will be affected by timed animation
    view = Instance(PlotUI)
    
    # The ModelView instance that contains the animation options:
    model_view = Instance('ModelView')
    
    # Whether the view is animated:
    animated = DelegatesTo('model_view')
    
    # whether color change is animated on each boundary:
    animate_left = DelegatesTo('model_view')
    animate_right = DelegatesTo('model_view')
    animate_top = DelegatesTo('model_view')
    animate_bottom = DelegatesTo('model_view')
    
    # current increments of selected point, for animation
    x_delta = Int
    y_delta = Int
    
    # Possible directions for 2D animated motion.
    # One tuple will be selected randomly from these on each bounce.
    # In each tuple, the first integer is the absolute value of
    # the new delta of the component that reached a boundary.
    # The second integer is the new delta of the other component.
    motions = ((1,1), (1,2), (1,3), (2,1), (3,1), (3,2), (2,3),
               (1,-1),(1,-2),(1,-3),(2,-1),(3,-1),(3,-2),(2,-2)
              )

    def onTimer(self, *args):
        """ 
        Callback function which responds to each timer tick
        and animates the moving selection point and colors.
        """

        def randomize(new_direction=1, color_change=False):
            """
            Randomize 2D motion, and colors if desired.
            Parameters:
            
              * new_direction is the sign of the new motion delta for
                the component that reached the boundary (the primary bounce 
                direction.)
                
              * color_change is whether to change the colormap if allowed.
              
            Returns a pair of integers, which are the new motion deltas,
            respectively, for primary bounce direction and the other.
            
            """
            if color_change:
                self.view.colormap = random.choice(colormaps)
            result0, result1 = random.choice(self.motions)
            return result0 * new_direction, result1
        
        
        if self.animated:
            metadata = self.view._image_index.metadata
            indices = metadata.get("selections", ())
            if len(indices) == 2:
                # Indices are (x,y) but limits are (y,x)
                x, y = indices
                ylim, xlim = self.view._image_value.data.shape
                y += self.y_delta
                if y < 0:
                    y = 0
                    self.y_delta, self.x_delta = randomize(1, 
                                                           self.animate_bottom)
                elif y >= ylim:
                    y = ylim-1
                    self.y_delta, self.x_delta = randomize(-1, 
                                                           self.animate_top)
                else:
                    x += self.x_delta
                    if x < 0:
                        x = 0
                        self.x_delta, self.y_delta = randomize(1, 
                                                            self.animate_left)
                    elif x >= xlim:
                        x = xlim-1
                        self.x_delta, self.y_delta = randomize(-1, 
                                                            self.animate_right)
                
            else:
                x,y = 0,0
                self.x_delta, self.y_delta = random.choice(self.motions)
                self.y_delta = 1
            metadata['selections'] = x,y
            

class ModelView(HasTraits):

    model = Instance(Model)
    view = Instance(PlotUI)
    timer = Instance(Timer)
    timer_controller = Instance(TimerController, ())
    
    edit_model = Button
    edit_view = Button
    animated = Bool(False)
    
    # Whether to animate colors on a bounce of each side:
    animate_left = Bool(False)
    animate_right = Bool(False)
    animate_top = Bool(False)
    animate_bottom = Bool(False)
    
    traits_view = View(UItem('@view'),
                       HGroup(UItem('edit_model', enabled_when='not animated'),
                              UItem('edit_view'),
                              Item('animated'),
                              Item('animate_left', enabled_when='animated',
                                   label='Change colors at:  Left'),
                              Item('animate_right', enabled_when='animated',
                                   label='Right'),
                              Item('animate_top', enabled_when='animated',
                                   label='Top'),
                              Item('animate_bottom', enabled_when='animated',
                                   label='Bottom'),
                              spring),
                       title = "Function Inspector",
                       resizable=True)

    @on_trait_change('model, model.model_changed, view')
    def update_view(self):
        if self.model is not None and self.view is not None:
            self.view.update(self.model)
            
    def _edit_model_fired(self):
        self.model.configure_traits()
        
    def _edit_view_fired(self):
        self.view.configure_traits(view="plot_edit_view")
            
    def _start_timer(self):
        # Start up the timer! We should do this only when the demo actually
        # starts and not when the demo object is created.
        # FIXME: close timer on exit.
        self.timer_controller.view = self.view
        self.timer_controller.model_view = self
        self.timer = Timer(40, self.timer_controller.onTimer)
        
    def edit_traits(self, *args, **kws):
        self._start_timer()
        return super(ModelView, self).edit_traits(*args, **kws)

    def configure_traits(self, *args, **kws):
        self._start_timer()
        return super(ModelView, self).configure_traits(*args, **kws)
            
def show_plot(**kwargs):
    model = Model(**kwargs)
    view = PlotUI(**kwargs)
    modelview=ModelView(model=model, view=view)
    modelview.configure_traits()

def main(argv=None):

    if argv is None:
        argv = sys.argv

    usage = "usage: %prog [options]"
    parser = OptionParser(usage=usage, version="%prog 1.0")

    parser.add_option("-c", "--colormap",
                  action="store", type="string", dest="colormap", default="jet",
                  metavar="CMAP", help="choose a default colormapper")

    parser.add_option("-n", "--nlevels",
                  action="store", type="int", dest="num_levels", default=15,
                  help="number countour levels to plot [default: %default]")

    parser.add_option("-f", "--function",
                  action="store", type="string", dest="function",
                  default="tanh(x**2+y)*cos(y)*jn(0,x+y*2)",
                  help="function of x and y [default: %default]")

    opts, args = parser.parse_args(argv[1:])

    if len(args) > 0:
        parser.error("Incorrect number of arguments")

    show_plot(colormap=opts.colormap, num_levels=opts.num_levels,
              function=opts.function)

if __name__ == "__main__":
    sys.exit(main())

########NEW FILE########
__FILENAME__ = scalar_image_function_inspector_old
"""
Renders a colormapped image of a scalar value field, and a cross section
chosen by a line interactor.
"""

# Standard library imports
from optparse import OptionParser
import sys

# Major library imports
from numpy import array, linspace, meshgrid, nanmin, nanmax,  pi, zeros

# Enthought library imports
from chaco.api import ArrayDataSource, ArrayPlotData, ColorBar, ContourLinePlot, \
                                 ColormappedScatterPlot, CMapImagePlot, \
                                 ContourPolyPlot, DataRange1D, VPlotContainer, \
                                 DataRange2D, GridMapper, GridDataSource, \
                                 HPlotContainer, ImageData, LinearMapper, \
                                 LinePlot, OverlayPlotContainer, Plot, PlotAxis
from chaco.default_colormaps import *
from enable.component_editor import ComponentEditor
from chaco.tools.api import LineInspector, PanTool, RangeSelection, \
                                   RangeSelectionOverlay, ZoomTool
from enable.api import Window
from traits.api import Any, Array, Callable, CFloat, CInt, Enum, Event, Float, HasTraits, \
                             Int, Instance, Str, Trait, on_trait_change
from traitsui.api import Group, Handler, HGroup, Item, View
from traitsui.menu import Action, CloseAction, Menu, \
                                     MenuBar, NoButtons, Separator


class Model(HasTraits):

    #Traits view definitions:
    traits_view = View(
        Group(Item('function'),
              HGroup(Item('npts_x', label="Number X Points"),
                     Item('npts_y', label="Number Y Points")),
              HGroup(Item('min_x', label="Min X value"),
                     Item('max_x', label="Max X value")),
              HGroup(Item('min_y', label="Min Y value"),
                     Item('max_y', label="Max Y value"))),
                     buttons=["OK", "Cancel"])

    function = Str("tanh(x**2+y)*cos(y)*jn(0,x+y*2)")

    npts_x = CInt(400)
    npts_y = CInt(200)

    min_x = CFloat(-2*pi)
    max_x = CFloat(2*pi)
    min_y = CFloat(-1.5*pi)
    max_y = CFloat(1.5*pi)

    xs = Array
    ys = Array
    zs = Array

    minz = Float
    maxz = Float

    model_changed = Event

    def __init__(self, *args, **kwargs):
        super(Model, self).__init__(*args, **kwargs)
        self.compute_model()

    def compute_model(self):
        # The xs and ys used for the image plot range need to be the
        # edges of the cells.
        self.xs = linspace(self.min_x, self.max_x, self.npts_x+1)
        self.ys = linspace(self.min_y, self.max_y, self.npts_y+1)

        # The grid of points at which we will evaluate the 2D function
        # is located at cell centers, so use halfsteps from the
        # min/max values (which are edges)
        xstep = (self.max_x - self.min_x) / self.npts_x
        ystep = (self.max_y - self.min_y) / self.npts_y
        gridx = linspace(self.min_x+xstep/2, self.max_x-xstep/2, self.npts_x)
        gridy = linspace(self.min_y+xstep/2, self.max_y-xstep/2, self.npts_y)
        x, y = meshgrid(gridx, gridy)
        try:
            d = dict(x=x, y=y)
            exec "from scipy import *" in d
            exec "from scipy.special import *" in d
            self.zs = eval(self.function, d)
            self.minz = nanmin(self.zs)
            self.maxz = nanmax(self.zs)
            self.model_changed = True
            self._function = self.function
        except:
            self.set(function = self._function, trait_change_notify=False)

    def _anytrait_changed(self, name, value):
        if name in ['function', 'npts_x', 'npts_y',
                    'min_x', 'max_x', 'min_y', 'max_y']:
            self.compute_model()


class PlotUI(HasTraits):

    #Traits view definitions:
    traits_view = View(
        Group(Item('container',
                   editor=ComponentEditor(size=(800,600)),
                   show_label=False)),
        buttons=NoButtons,
        resizable=True)

    plot_edit_view = View(
        Group(Item('num_levels'),
              Item('colormap')),
              buttons=["OK","Cancel"])


    num_levels = Int(15)
    colormap = Enum(color_map_name_dict.keys())

    #---------------------------------------------------------------------------
    # Private Traits
    #---------------------------------------------------------------------------

    _image_index = Instance(GridDataSource)
    _image_value = Instance(ImageData)

    _cmap = Trait(jet, Callable)

    #---------------------------------------------------------------------------
    # Public View interface
    #---------------------------------------------------------------------------

    def __init__(self, *args, **kwargs):
        super(PlotUI, self).__init__(*args, **kwargs)
        self.create_plot()

    def create_plot(self):

        # Create the mapper, etc
        self._image_index = GridDataSource(array([]),
                                          array([]),
                                          sort_order=("ascending","ascending"))
        image_index_range = DataRange2D(self._image_index)
        self._image_index.on_trait_change(self._metadata_changed,
                                          "metadata_changed")

        self._image_value = ImageData(data=array([]), value_depth=1)
        image_value_range = DataRange1D(self._image_value)



        # Create the contour plots
        self.polyplot = ContourPolyPlot(index=self._image_index,
                                        value=self._image_value,
                                        index_mapper=GridMapper(range=
                                            image_index_range),
                                        color_mapper=\
                                            self._cmap(image_value_range),
                                        levels=self.num_levels)

        self.lineplot = ContourLinePlot(index=self._image_index,
                                        value=self._image_value,
                                        index_mapper=GridMapper(range=
                                            self.polyplot.index_mapper.range),
                                        levels=self.num_levels)


        # Add a left axis to the plot
        left = PlotAxis(orientation='left',
                        title= "y",
                        mapper=self.polyplot.index_mapper._ymapper,
                        component=self.polyplot)
        self.polyplot.overlays.append(left)

        # Add a bottom axis to the plot
        bottom = PlotAxis(orientation='bottom',
                          title= "x",
                          mapper=self.polyplot.index_mapper._xmapper,
                          component=self.polyplot)
        self.polyplot.overlays.append(bottom)


        # Add some tools to the plot
        self.polyplot.tools.append(PanTool(self.polyplot,
                                           constrain_key="shift"))
        self.polyplot.overlays.append(ZoomTool(component=self.polyplot,
                                            tool_mode="box", always_on=False))
        self.polyplot.overlays.append(LineInspector(component=self.polyplot,
                                               axis='index_x',
                                               inspect_mode="indexed",
                                               write_metadata=True,
                                               is_listener=False,
                                               color="white"))
        self.polyplot.overlays.append(LineInspector(component=self.polyplot,
                                               axis='index_y',
                                               inspect_mode="indexed",
                                               write_metadata=True,
                                               color="white",
                                               is_listener=False))

        # Add these two plots to one container
        contour_container = OverlayPlotContainer(padding=20,
                                                 use_backbuffer=True,
                                                 unified_draw=True)
        contour_container.add(self.polyplot)
        contour_container.add(self.lineplot)


        # Create a colorbar
        cbar_index_mapper = LinearMapper(range=image_value_range)
        self.colorbar = ColorBar(index_mapper=cbar_index_mapper,
                                 plot=self.polyplot,
                                 padding_top=self.polyplot.padding_top,
                                 padding_bottom=self.polyplot.padding_bottom,
                                 padding_right=40,
                                 resizable='v',
                                 width=30)

        self.pd = ArrayPlotData(line_index = array([]),
                                line_value = array([]),
                                scatter_index = array([]),
                                scatter_value = array([]),
                                scatter_color = array([]))

        self.cross_plot = Plot(self.pd, resizable="h")
        self.cross_plot.height = 100
        self.cross_plot.padding = 20
        self.cross_plot.plot(("line_index", "line_value"),
                             line_style="dot")
        self.cross_plot.plot(("scatter_index","scatter_value","scatter_color"),
                             type="cmap_scatter",
                             name="dot",
                             color_mapper=self._cmap(image_value_range),
                             marker="circle",
                             marker_size=8)

        self.cross_plot.index_range = self.polyplot.index_range.x_range

        self.pd.set_data("line_index2", array([]))
        self.pd.set_data("line_value2", array([]))
        self.pd.set_data("scatter_index2", array([]))
        self.pd.set_data("scatter_value2", array([]))
        self.pd.set_data("scatter_color2", array([]))

        self.cross_plot2 = Plot(self.pd, width = 140, orientation="v", resizable="v", padding=20, padding_bottom=160)
        self.cross_plot2.plot(("line_index2", "line_value2"),
                             line_style="dot")
        self.cross_plot2.plot(("scatter_index2","scatter_value2","scatter_color2"),
                             type="cmap_scatter",
                             name="dot",
                             color_mapper=self._cmap(image_value_range),
                             marker="circle",
                             marker_size=8)

        self.cross_plot2.index_range = self.polyplot.index_range.y_range



        # Create a container and add components
        self.container = HPlotContainer(padding=40, fill_padding=True,
                                        bgcolor = "white", use_backbuffer=False)
        inner_cont = VPlotContainer(padding=0, use_backbuffer=True)
        inner_cont.add(self.cross_plot)
        inner_cont.add(contour_container)
        self.container.add(self.colorbar)
        self.container.add(inner_cont)
        self.container.add(self.cross_plot2)


    def update(self, model):
        self.minz = model.minz
        self.maxz = model.maxz
        self.colorbar.index_mapper.range.low = self.minz
        self.colorbar.index_mapper.range.high = self.maxz
        self._image_index.set_data(model.xs, model.ys)
        self._image_value.data = model.zs
        self.pd.set_data("line_index", model.xs)
        self.pd.set_data("line_index2", model.ys)
        self.container.invalidate_draw()
        self.container.request_redraw()


    #---------------------------------------------------------------------------
    # Event handlers
    #---------------------------------------------------------------------------

    def _metadata_changed(self, old, new):
        """ This function takes out a cross section from the image data, based
        on the line inspector selections, and updates the line and scatter
        plots."""

        self.cross_plot.value_range.low = self.minz
        self.cross_plot.value_range.high = self.maxz
        self.cross_plot2.value_range.low = self.minz
        self.cross_plot2.value_range.high = self.maxz
        if self._image_index.metadata.has_key("selections"):
            x_ndx, y_ndx = self._image_index.metadata["selections"]
            if y_ndx and x_ndx:
                self.pd.set_data("line_value",
                                 self._image_value.data[y_ndx,:])
                self.pd.set_data("line_value2",
                                 self._image_value.data[:,x_ndx])
                xdata, ydata = self._image_index.get_data()
                xdata, ydata = xdata.get_data(), ydata.get_data()
                self.pd.set_data("scatter_index", array([xdata[x_ndx]]))
                self.pd.set_data("scatter_index2", array([ydata[y_ndx]]))
                self.pd.set_data("scatter_value",
                    array([self._image_value.data[y_ndx, x_ndx]]))
                self.pd.set_data("scatter_value2",
                    array([self._image_value.data[y_ndx, x_ndx]]))
                self.pd.set_data("scatter_color",
                    array([self._image_value.data[y_ndx, x_ndx]]))
                self.pd.set_data("scatter_color2",
                    array([self._image_value.data[y_ndx, x_ndx]]))
        else:
            self.pd.set_data("scatter_value", array([]))
            self.pd.set_data("scatter_value2", array([]))
            self.pd.set_data("line_value", array([]))
            self.pd.set_data("line_value2", array([]))

    def _colormap_changed(self):
        self._cmap = color_map_name_dict[self.colormap]
        if hasattr(self, "polyplot"):
            value_range = self.polyplot.color_mapper.range
            self.polyplot.color_mapper = self._cmap(value_range)
            value_range = self.cross_plot.color_mapper.range
            self.cross_plot.color_mapper = self._cmap(value_range)
            # FIXME: change when we decide how best to update plots using
            # the shared colormap in plot object
            self.cross_plot.plots["dot"][0].color_mapper = self._cmap(value_range)
            self.cross_plot2.plots["dot"][0].color_mapper = self._cmap(value_range)
            self.container.request_redraw()

    def _num_levels_changed(self):
        if self.num_levels > 3:
            self.polyplot.levels = self.num_levels
            self.lineplot.levels = self.num_levels



class Controller(Handler):

    #---------------------------------------------------------------------------
    # State traits
    #---------------------------------------------------------------------------

    model = Instance(Model)
    view = Instance(PlotUI)

    #---------------------------------------------------------------------------
    # Handler interface
    #---------------------------------------------------------------------------

    def init(self, info):
        self.model = info.object.model
        self.view = info.object.view
        self.model.on_trait_change(self._model_changed, "model_changed")


    #---------------------------------------------------------------------------
    # Public Controller interface
    #---------------------------------------------------------------------------

    def edit_model(self, ui_info):
        self.model.configure_traits()

    def edit_plot(self, ui_info):
        self.view.configure_traits(view="plot_edit_view")


    #---------------------------------------------------------------------------
    # Private Controller interface
    #---------------------------------------------------------------------------

    def _model_changed(self):
        if self.view is not None:
            self.view.update(self.model)

class ModelView(HasTraits):

    model = Instance(Model)
    view = Instance(PlotUI)
    traits_view = View(Item('@view',
                            show_label=False),
                       menubar=MenuBar(Menu(Action(name="Edit Model",
                                                   action="edit_model"),
                                            Action(name="Edit Plot",
                                                   action="edit_plot"),
                                            CloseAction,
                                            name="File")),
                       handler = Controller,
                       title = "Function Inspector",
                       resizable=True)

    @on_trait_change('model, view')
    def update_view(self):
        if self.model is not None and self.view is not None:
            self.view.update(self.model)

options_dict = {'colormap' : "jet",
                'num_levels' : 15,
                'function' : "tanh(x**2+y)*cos(y)*jn(0,x+y*2)"}
model=Model(**options_dict)
view=PlotUI(**options_dict)
popup = ModelView(model=model, view=view)

def show_plot(**kwargs):
    model = Model(**kwargs)
    view = PlotUI(**kwargs)
    modelview=ModelView(model=model, view=view)
    modelview.configure_traits()

def main(argv=None):

    if argv is None:
        argv = sys.argv

    usage = "usage: %prog [options]"
    parser = OptionParser(usage=usage, version="%prog 1.0")

    parser.add_option("-c", "--colormap",
                  action="store", type="string", dest="colormap", default="jet",
                  metavar="CMAP", help="choose a default colormapper")

    parser.add_option("-n", "--nlevels",
                  action="store", type="int", dest="num_levels", default=15,
                  help="number countour levels to plot [default: %default]")

    parser.add_option("-f", "--function",
                  action="store", type="string", dest="function",
                  default="tanh(x**2+y)*cos(y)*jn(0,x+y*2)",
                  help="function of x and y [default: %default]")

    opts, args = parser.parse_args(argv[1:])

    if len(args) > 0:
        parser.error("Incorrect number of arguments")

    show_plot(colormap=opts.colormap, num_levels=opts.num_levels,
              function=opts.function)

if __name__ == "__main__":
    sys.exit(main())

########NEW FILE########
__FILENAME__ = spectrum
#!/usr/bin/env python
"""
This plot displays the audio waveform, spectrum, and spectrogram from the 
microphone.

Based on updating_plot.py
"""
import sys

# Major library imports
try:
    import pyaudio
except ImportError:
    sys.exit('You need pyaudio installed to run this demo.')

from numpy import zeros, linspace, short, fromstring, hstack, transpose
from scipy import fft

# Enthought library imports
from chaco.default_colormaps import hot
from enable.api import Component, ComponentEditor
from traits.api import HasTraits, Instance
from traitsui.api import Item, Group, View, Handler
from pyface.timer.api import Timer

# Chaco imports
from chaco.api import Plot, ArrayPlotData, HPlotContainer

NUM_SAMPLES = 1024
SAMPLING_RATE = 11025
SPECTROGRAM_LENGTH = 100

#============================================================================
# Create the Chaco plot.
#============================================================================

def _create_plot_component(obj):
    # Setup the spectrum plot
    frequencies = linspace(0.0, float(SAMPLING_RATE)/2, num=NUM_SAMPLES/2)
    obj.spectrum_data = ArrayPlotData(frequency=frequencies)
    empty_amplitude = zeros(NUM_SAMPLES/2)
    obj.spectrum_data.set_data('amplitude', empty_amplitude)

    obj.spectrum_plot = Plot(obj.spectrum_data)
    obj.spectrum_plot.plot(("frequency", "amplitude"), name="Spectrum",
                           color="red")
    obj.spectrum_plot.padding = 50
    obj.spectrum_plot.title = "Spectrum"
    spec_range = obj.spectrum_plot.plots.values()[0][0].value_mapper.range
    spec_range.low = 0.0
    spec_range.high = 5.0
    obj.spectrum_plot.index_axis.title = 'Frequency (Hz)'
    obj.spectrum_plot.value_axis.title = 'Amplitude'

    # Time Series plot
    times = linspace(0.0, float(NUM_SAMPLES)/SAMPLING_RATE, num=NUM_SAMPLES)
    obj.time_data = ArrayPlotData(time=times)
    empty_amplitude = zeros(NUM_SAMPLES)
    obj.time_data.set_data('amplitude', empty_amplitude)

    obj.time_plot = Plot(obj.time_data)
    obj.time_plot.plot(("time", "amplitude"), name="Time", color="blue")
    obj.time_plot.padding = 50
    obj.time_plot.title = "Time"
    obj.time_plot.index_axis.title = 'Time (seconds)'
    obj.time_plot.value_axis.title = 'Amplitude'
    time_range = obj.time_plot.plots.values()[0][0].value_mapper.range
    time_range.low = -0.2
    time_range.high = 0.2

    # Spectrogram plot
    spectrogram_data = zeros(( NUM_SAMPLES/2, SPECTROGRAM_LENGTH))
    obj.spectrogram_plotdata = ArrayPlotData()
    obj.spectrogram_plotdata.set_data('imagedata', spectrogram_data)
    spectrogram_plot = Plot(obj.spectrogram_plotdata)
    max_time = float(SPECTROGRAM_LENGTH * NUM_SAMPLES) / SAMPLING_RATE
    max_freq = float(SAMPLING_RATE / 2)
    spectrogram_plot.img_plot('imagedata',
                              name='Spectrogram',
                              xbounds=(0, max_time),
                              ybounds=(0, max_freq),
                              colormap=hot,
                              )
    range_obj = spectrogram_plot.plots['Spectrogram'][0].value_mapper.range
    range_obj.high = 5
    range_obj.low = 0.0
    spectrogram_plot.title = 'Spectrogram'
    obj.spectrogram_plot = spectrogram_plot

    container = HPlotContainer()
    container.add(obj.spectrum_plot)
    container.add(obj.time_plot)
    container.add(spectrogram_plot)

    return container

_stream = None
def get_audio_data():
    global _stream
    if _stream is None:
        pa = pyaudio.PyAudio()
        _stream = pa.open(format=pyaudio.paInt16, channels=1, rate=SAMPLING_RATE,
                     input=True, frames_per_buffer=NUM_SAMPLES)
    audio_data  = fromstring(_stream.read(NUM_SAMPLES), dtype=short)
    normalized_data = audio_data / 32768.0
    return (abs(fft(normalized_data))[:NUM_SAMPLES/2], normalized_data)


# HasTraits class that supplies the callable for the timer event.
class TimerController(HasTraits):

    def onTimer(self, *args):
        spectrum, time = get_audio_data()
        self.spectrum_data.set_data('amplitude', spectrum)
        self.time_data.set_data('amplitude', time)
        spectrogram_data = self.spectrogram_plotdata.get_data('imagedata')
        spectrogram_data = hstack((spectrogram_data[:,1:],
                                   transpose([spectrum])))

        self.spectrogram_plotdata.set_data('imagedata', spectrogram_data)
        self.spectrum_plot.request_redraw()
        return

#============================================================================
# Attributes to use for the plot view.
size = (900,500)
title = "Audio Spectrum"

#============================================================================
# Demo class that is used by the demo.py application.
#============================================================================

class DemoHandler(Handler):

    def closed(self, info, is_ok):
        """ Handles a dialog-based user interface being closed by the user.
        Overridden here to stop the timer once the window is destroyed.
        """

        info.object.timer.Stop()
        return

class Demo(HasTraits):

    plot = Instance(Component)

    controller = Instance(TimerController, ())

    timer = Instance(Timer)

    traits_view = View(
                    Group(
                        Item('plot', editor=ComponentEditor(size=size),
                             show_label=False),
                        orientation = "vertical"),
                    resizable=True, title=title,
                    width=size[0], height=size[1],
                    handler=DemoHandler
                    )

    def __init__(self, **traits):
        super(Demo, self).__init__(**traits)
        self.plot = _create_plot_component(self.controller)

    def edit_traits(self, *args, **kws):
        # Start up the timer! We should do this only when the demo actually
        # starts and not when the demo object is created.
        self.timer = Timer(20, self.controller.onTimer)
        return super(Demo, self).edit_traits(*args, **kws)

    def configure_traits(self, *args, **kws):
        # Start up the timer! We should do this only when the demo actually
        # starts and not when the demo object is created.
        self.timer = Timer(20, self.controller.onTimer)
        return super(Demo, self).configure_traits(*args, **kws)

popup = Demo()

if __name__ == "__main__":
    try:
        popup.configure_traits()
    finally:
        if _stream is not None:
            _stream.close()

########NEW FILE########
__FILENAME__ = spec_waterfall
"""
This plot displays the audio spectrum from the microphone.

Based on updating_plot.py
"""
# Major library imports
import pyaudio
from numpy import zeros, linspace, short, fromstring, transpose, array
from scipy import fft

# Enthought library imports
from enable.api import Window, Component, ComponentEditor
from traits.api import HasTraits, Instance, List
from traitsui.api import Item, Group, View, Handler
from pyface.timer.api import Timer

# Chaco imports
from chaco.api import (Plot, ArrayPlotData, HPlotContainer, VPlotContainer,
    AbstractMapper, LinePlot, LinearMapper, DataRange1D)

NUM_SAMPLES = 1024
SAMPLING_RATE = 11025
SPECTROGRAM_LENGTH = 50

class WaterfallRenderer(LinePlot):

    # numpy arrays of the same length
    values = List(args=[])

    # Maps each array in values into a contrained, short screen space
    y2_mapper = Instance(AbstractMapper)

    _cached_data_pts = List()
    _cached_screen_pts = List()

    def _gather_points(self):
        if not self._cache_valid:
            if not self.index or len(self.values) == 0:
                return

            index = self.index.get_data()
            values = self.values

            numindex = len(index)
            if numindex == 0 or all(len(v)==0 for v in values) or all(numindex != len(v) for v in values):
                self._cached_data_pts = []
                self._cache_valid = True

            self._cached_data_pts = [transpose(array((index, v))) for v in values]
            self._cache_value = True
        return

    def get_screen_points(self):
        self._gather_points()
        return [self.map_screen(pts, i) for i, pts in enumerate(self._cached_data_pts)]

    def map_screen(self, data_array, data_offset=None):
        """ data_offset, if provided, is a float that will be mapped
        into screen space using self.value_mapper and then added to
        mapping data_array with y2_mapper.  If data_offset is not
        provided, then y2_mapper is used.
        """
        if len(data_array) == 0:
            return []
        x_ary, y_ary = transpose(data_array)
        sx = self.index_mapper.map_screen(x_ary)
        if data_offset is not None:
            dy = self.value_mapper.map_screen(data_offset)
            sy = self.y2_mapper.map_screen(y_ary) + dy
        else:
            sy = self.value_mapper.map_screen(y_ary)

        if self.orientation == "h":
            return transpose(array((sx, sy)))
        else:
            return transpose(array((sy, sx)))

#============================================================================
# Create the Chaco plot.
#============================================================================

def _create_plot_component(obj):
    # Setup the spectrum plot
    frequencies = linspace(0.0, float(SAMPLING_RATE)/2, num=NUM_SAMPLES/2)
    obj.spectrum_data = ArrayPlotData(frequency=frequencies)
    empty_amplitude = zeros(NUM_SAMPLES/2)
    obj.spectrum_data.set_data('amplitude', empty_amplitude)

    obj.spectrum_plot = Plot(obj.spectrum_data)
    spec_renderer = obj.spectrum_plot.plot(("frequency", "amplitude"), name="Spectrum",
                           color="red")[0]
    obj.spectrum_plot.padding = 50
    obj.spectrum_plot.title = "Spectrum"
    spec_range = obj.spectrum_plot.plots.values()[0][0].value_mapper.range
    spec_range.low = 0.0
    spec_range.high = 5.0
    obj.spectrum_plot.index_axis.title = 'Frequency (hz)'
    obj.spectrum_plot.value_axis.title = 'Amplitude'

    # Time Series plot
    times = linspace(0.0, float(NUM_SAMPLES)/SAMPLING_RATE, num=NUM_SAMPLES)
    obj.time_data = ArrayPlotData(time=times)
    empty_amplitude = zeros(NUM_SAMPLES)
    obj.time_data.set_data('amplitude', empty_amplitude)

    obj.time_plot = Plot(obj.time_data)
    obj.time_plot.plot(("time", "amplitude"), name="Time", color="blue")
    obj.time_plot.padding = 50
    obj.time_plot.title = "Time"
    obj.time_plot.index_axis.title = 'Time (seconds)'
    obj.time_plot.value_axis.title = 'Amplitude'
    time_range = obj.time_plot.plots.values()[0][0].value_mapper.range
    time_range.low = -0.2
    time_range.high = 0.2

    # Spectrogram plot
    values = [zeros(NUM_SAMPLES/2) for i in xrange(SPECTROGRAM_LENGTH)]
    p = WaterfallRenderer(index = spec_renderer.index, values = values,
            index_mapper = LinearMapper(range = obj.spectrum_plot.index_mapper.range),
            value_mapper = LinearMapper(range = DataRange1D(low=0, high=SPECTROGRAM_LENGTH)),
            y2_mapper = LinearMapper(low_pos=0, high_pos=8,
                            range=DataRange1D(low=0, high=15)),
            )
    spectrogram_plot = p
    obj.spectrogram_plot = p
    dummy = Plot()
    dummy.padding = 50
    dummy.index_axis.mapper.range = p.index_mapper.range
    dummy.index_axis.title = "Frequency (hz)"
    dummy.add(p)

    container = HPlotContainer()
    container.add(obj.spectrum_plot)
    container.add(obj.time_plot)

    c2 = VPlotContainer()
    c2.add(dummy)
    c2.add(container)

    return c2


def get_audio_data():
    pa = pyaudio.PyAudio()
    stream = pa.open(format=pyaudio.paInt16, channels=1, rate=SAMPLING_RATE,
                     input=True, frames_per_buffer=NUM_SAMPLES)
    audio_data  = fromstring(stream.read(NUM_SAMPLES), dtype=short)
    stream.close()
    normalized_data = audio_data / 32768.0
    return (abs(fft(normalized_data))[:NUM_SAMPLES/2], normalized_data)


# HasTraits class that supplies the callable for the timer event.
class TimerController(HasTraits):

    def onTimer(self, *args):
        spectrum, time = get_audio_data()
        self.spectrum_data.set_data('amplitude', spectrum)
        self.time_data.set_data('amplitude', time)
        spec_data = self.spectrogram_plot.values[1:] + [spectrum]
        self.spectrogram_plot.values = spec_data
        self.spectrum_plot.request_redraw()
        return

#============================================================================
# Attributes to use for the plot view.
size = (900,850)
title = "Audio Spectrum Waterfall"

#============================================================================
# Demo class that is used by the demo.py application.
#============================================================================

class DemoHandler(Handler):

    def closed(self, info, is_ok):
        """ Handles a dialog-based user interface being closed by the user.
        Overridden here to stop the timer once the window is destroyed.
        """

        info.object.timer.Stop()
        return

class Demo(HasTraits):

    plot = Instance(Component)

    controller = Instance(TimerController, ())

    timer = Instance(Timer)

    traits_view = View(
                    Group(
                        Item('plot', editor=ComponentEditor(size=size),
                             show_label=False),
                        orientation = "vertical"),
                    resizable=True, title=title,
                    width=size[0], height=size[1]+25,
                    handler=DemoHandler
                    )

    def __init__(self, **traits):
        super(Demo, self).__init__(**traits)
        self.plot = _create_plot_component(self.controller)

    def edit_traits(self, *args, **kws):
        # Start up the timer! We should do this only when the demo actually
        # starts and not when the demo object is created.
        self.timer = Timer(20, self.controller.onTimer)
        return super(Demo, self).edit_traits(*args, **kws)

    def configure_traits(self, *args, **kws):
        # Start up the timer! We should do this only when the demo actually
        # starts and not when the demo object is created.
        self.timer = Timer(20, self.controller.onTimer)
        return super(Demo, self).configure_traits(*args, **kws)


popup = Demo()

if __name__ == "__main__":
    popup.configure_traits()

########NEW FILE########
__FILENAME__ = aspect_ratio
"""
Controlling aspect ratio

Demonstrates various ways that Chaco can control aspect ratios in plots.

Left-drag pans the plot.

Mousewheel up and down zooms the plot in and out.
"""

# Major library imports
from itertools import chain
from numpy import sort, isfinite
from numpy.random import random


# Enthought library imports
from enable.api import ComponentEditor
from traits.api import Any, Bool, BaseFloat, HasTraits
from traitsui.api import Item, HGroup, VGroup, View

# Chaco imports
from chaco.api import ArrayPlotData, Plot
from chaco.tools.api import PanTool, ZoomTool

class AspectRatio(BaseFloat):
    "A new Trait for defining aspect ratios"

    default_value = 1.0

    info_text = "a nonzero floating point number"

    def validate(self, object, name, value):
        value = super(AspectRatio, self).validate(object, name, value)
        if value != 0.0 and isfinite(value):
            return value
        else:
            self.error(object, name, value)


class MyPlot(HasTraits):

    plot = Any()
    screen_enabled = Bool(False)
    screen_aspect = AspectRatio()
    fixed_x = Bool(False)
    fixed_y = Bool(False)
    traits_view = View(
                    VGroup(
                        HGroup(
                            Item("screen_enabled", label="Screen"),
                            Item("screen_aspect", label="aspect ratio (w/h)")
                            ),
                        HGroup(
                            Item("fixed_x", label="Data X fixed"),
                            Item("fixed_y", label="Data Y fixed")
                            ),
                        Item("plot", editor=ComponentEditor(size=(100,100)),
                             show_label=False)
                        ),
                    width=600, height=600, resizable=True,
                    title="Aspect Ratio Example")


    def __init__(self, *args, **kw):
        HasTraits.__init__(self, *args, **kw)
        numpoints = 200
        plotdata = ArrayPlotData(x=sort(random(numpoints)), y=random(numpoints))
        plot = Plot(plotdata)
        plot.plot(("x", "y"), type="scatter")
        plot.tools.append(PanTool(plot))
        plot.overlays.append(ZoomTool(plot))
        self.plot = plot

    def _screen_enabled_changed(self):
        if self.screen_enabled:
            self.plot.aspect_ratio = self.screen_aspect
        else:
            self.plot.aspect_ratio = None
        self.plot.request_redraw()

    def _screen_aspect_changed(self):
        if self.screen_enabled:
            self.plot.aspect_ratio = self.screen_aspect
            self.plot.request_redraw()

    def _fixed_x_changed(self):
        self.plot.x_mapper.stretch_data = not self.fixed_x
        # Also have to change all the renderers' mappers
        for renderer in chain(*self.plot.plots.values()):
            renderer.index_mapper.stretch_data = not self.fixed_x
        self.plot.request_redraw()

    def _fixed_y_changed(self):
        self.plot.y_mapper.stretch_data = not self.fixed_y
        for renderer in chain(*self.plot.plots.values()):
            renderer.value_mapper.stretch_data = not self.fixed_y
        self.plot.request_redraw()

#===============================================================================
# # Create the demo object to be used by the demo.py application.
#===============================================================================
demo = myplot = MyPlot()

if __name__ == "__main__":
    myplot.configure_traits()
########NEW FILE########
__FILENAME__ = bar_plot_configurable
"""Demonstrate a simple bar plot.  The UI allows you to change
some of the attributes of the plot.
"""

import numpy as np

from traits.api import HasTraits, Instance, Range
from traitsui.api import View, UItem, Item, Group, VGroup
from chaco.api import ArrayDataSource, DataRange1D, LinearMapper, BarPlot
from enable.api import ComponentEditor


class BarPlotDemo(HasTraits):

    # The bar plot renderer.
    bar_plot = Instance(BarPlot)

    # Assorted styles that will be set on `bar_plot`.    
    bar_width = Range(0.0, 1.0, 0.8)
    line_width = Range(0.0, 10.0, 5.0)
    alpha = Range(0.0, 1.0, 1.0)
    line_color_alpha = Range(0.0, 1.0, 1.0)
    fill_color_alpha = Range(0.0, 1.0, 1.0)

    traits_view = \
        View(
            VGroup(
                Group(
                    UItem('bar_plot', 
                          editor=ComponentEditor(), 
                          style='custom'),
                ),
                VGroup(
                    Item('bar_width'),
                    Item('line_width'),
                    Item('line_color_alpha'),
                    Item('fill_color_alpha'),
                    Item('alpha'),
                ),
            ),
            resizable=True,
        )

    #----------------------------------------------------------------------
    # Default values
    #----------------------------------------------------------------------

    def _bar_plot_default(self):

        # Default data
        idx = np.array([1, 2, 3, 4, 5])
        vals = np.array([2, 4, 7, 4, 3])

        # Mappers
        index = ArrayDataSource(idx)
        index_range = DataRange1D(index, low=0.5, high=5.5)
        index_mapper = LinearMapper(range=index_range)

        value = ArrayDataSource(vals)
        value_range = DataRange1D(value, low=0)
        value_mapper = LinearMapper(range=value_range)

        # The bar plot
        plot = BarPlot(index=index, value=value,
                       value_mapper=value_mapper,
                       index_mapper=index_mapper,
                       line_color="black",
                       fill_color="cornflowerblue",
                       bgcolor="white",
                       bar_width=self.bar_width,
                       line_width=self.line_width,
                       )
        return plot


    #----------------------------------------------------------------------
    # Trait change handlers
    #----------------------------------------------------------------------

    def _line_color_alpha_changed(self):
        alpha = self.line_color_alpha
        color = self.bar_plot.line_color_
        self.bar_plot.line_color = color[:3] + (alpha,)

    def _fill_color_alpha_changed(self):
        alpha = self.fill_color_alpha
        color = self.bar_plot.fill_color_
        self.bar_plot.fill_color = color[:3] + (alpha,)

    def _alpha_changed(self):
        self.bar_plot.alpha = self.alpha

    def _bar_width_changed(self):
        self.bar_plot.bar_width = self.bar_width

    def _line_width_changed(self):
        self.bar_plot.line_width = self.line_width

demo = BarPlotDemo()

if __name__ == "__main__":
    demo.configure_traits()

########NEW FILE########
__FILENAME__ = bar_plot_stacked
"""
Simple example of a stacked bar chart
"""

# Major library imports
import numpy

# Enthought library imports
from enable.api import ComponentEditor
from traits.api import HasTraits, Instance
from traitsui.api import UItem, View

# Chaco imports
from chaco.api import LabelAxis, Plot, ArrayPlotData

class PlotExample(HasTraits):
    plot = Instance(Plot)
    traits_view = View(UItem('plot', editor=ComponentEditor()),
                       width=400, height=400, resizable=True, 
                      )

    def __init__(self, index, series_a, series_b, series_c, **kw):
        super(PlotExample, self).__init__(**kw)

        plot_data = ArrayPlotData(index=index)
        plot_data.set_data('series_a', series_a)
        plot_data.set_data('series_b', series_b)
        plot_data.set_data('series_c', series_c)
        self.plot = Plot(plot_data)
        self.plot.plot(('index', 'series_a'), type='bar', bar_width=0.8, color='auto')
        self.plot.plot(('index', 'series_b'), type='bar', bar_width=0.8, color='auto')
        self.plot.plot(('index', 'series_c'), type='bar', bar_width=0.8, color='auto')

        # set the plot's value range to 0, otherwise it may pad too much
        self.plot.value_range.low = 0

        # replace the index values with some nicer labels
        label_axis = LabelAxis(self.plot, orientation='bottom',
                               title='Months',
                               positions = range(1, 10),
                               labels = ['jan', 'feb', 'march', 'april', 'may'],
                               small_haxis_style=True)

        self.plot.underlays.remove(self.plot.index_axis)
        self.plot.index_axis = label_axis
        self.plot.underlays.append(label_axis)


index = numpy.array([1,2,3,4,5])
demo = PlotExample(index, index*10, index*5, index*2)

if __name__ == "__main__":
    demo.configure_traits()

########NEW FILE########
__FILENAME__ = bounded_grids
#!/usr/bin/env python
"""
Demonstrates how to limit the extent of grid lines
"""

# Major library imports
from numpy import array, linspace, zeros
from scipy.special import jn

# Enthought library imports
from enable.api import Component, ComponentEditor
from traits.api import HasTraits, Instance
from traitsui.api import UItem, View

# Chaco imports
from chaco.api import ArrayPlotData, HPlotContainer, Plot
from chaco.tools.api import PanTool, ZoomTool

#===============================================================================
# # Create the Chaco plot.
#===============================================================================
def _create_plot_component():

    # Create some x-y data series to plot
    x = linspace(-2.0, 10.0, 100)
    pd = ArrayPlotData(index = x)
    for i in range(5):
        pd.set_data("y" + str(i), jn(i,x))

    # Create some line plots of some of the data
    plot = Plot(pd, title="Line Plot", padding=50, border_visible=True)
    plot.legend.visible = True
    plot.plot(("index", "y0", "y1", "y2"), name="j_n, n<3", color="auto")
    plot.plot(("index", "y3"), name="j_3", color="auto")

    plot.x_grid.line_color = "black"
    plot.y_grid.line_color = "black"
    xmin, xmax = 1.0, 6.0
    ymin, ymax = 0.2, 0.80001
    plot.x_grid.set(data_min = xmin, data_max = xmax,
            transverse_bounds = (ymin, ymax),
            transverse_mapper = plot.y_mapper)

    plot.y_grid.set(data_min = ymin, data_max = ymax,
            transverse_bounds = (xmin, xmax),
            transverse_mapper = plot.x_mapper)

    # Attach some tools to the plot
    plot.tools.append(PanTool(plot))
    zoom = ZoomTool(component=plot, tool_mode="box", always_on=False)
    plot.overlays.append(zoom)

    # A second plot whose vertical grid lines are clipped to the jn(3) function
    def my_bounds_func(ticks):
        """ Returns y_low and y_high for each grid tick in the array **ticks** """
        tmp = array([zeros(len(ticks)),jn(3, ticks)]).T
        return tmp

    func_plot = Plot(pd, padding=50, border_visible=True)
    func_plot.plot(("index", "y3"), color="red")
    func_plot.x_grid.set(transverse_bounds = my_bounds_func,
                    transverse_mapper = func_plot.y_mapper,
                    line_color="black")
    func_plot.tools.append(PanTool(func_plot))

    container = HPlotContainer()
    container.add(plot)
    container.add(func_plot)

    return container

#===============================================================================
# Attributes to use for the plot view.
size=(900,500)
title="Grids with bounded extents"

#===============================================================================
# # Demo class that is used by the demo.py application.
#===============================================================================
class Demo(HasTraits):
    plot = Instance(Component)

    traits_view = View(UItem('plot', editor=ComponentEditor()),
                       width=size[0], height=size[1], resizable=True,
                       title=title
                       )

    def _plot_default(self):
         return _create_plot_component()

demo = Demo()

if __name__ == "__main__":
    demo.configure_traits()


########NEW FILE########
__FILENAME__ = candle
"""
Demonstrates candlestick plots.

 - Left-drag pans the plot.
 - Mousewheel up and down zooms the plot in and out.
 - Pressing "z" brings up the Zoom Box, and you can click-drag a rectangular
   region to zoom.  If you use a sequence of zoom boxes, pressing alt-left-arrow
   and alt-right-arrow moves you forwards and backwards through the "zoom
   history".
"""

# Major library imports
from numpy import abs, arange, cumprod, random, vstack

# Enthought library imports
from enable.api import Component, ComponentEditor
from traits.api import HasTraits, Instance
from traitsui.api import UItem, View

# Chaco imports
from chaco.api import ArrayPlotData, Plot
from chaco.tools.api import PanTool, ZoomTool

#===============================================================================
# # Create the Chaco plot.
#===============================================================================

def _create_data(numpoints):
    index = arange(numpoints)

    returns = random.lognormal(0.00, 0.04, size=numpoints)
    average = 100.0 * cumprod(returns)
    high = average + abs(random.normal(0, 20.0, size=numpoints))
    low = average - abs(random.normal(0, 20.0, size=numpoints))
    delta = high - low
    open = low + delta * random.uniform(0.05, 0.95, size=numpoints)
    close = low + delta * random.uniform(0.05, 0.95, size=numpoints)
    sorted_vals = vstack((open, high, low, close, average))
    sorted_vals.sort(0)
    return index, sorted_vals

def _create_plot_component():

    # Create some data
    index, sorted_vals = _create_data(200)

    # Create a plot data obect and give it this data
    pd = ArrayPlotData(index = index,
                       min = sorted_vals[0],
                       bar_min = sorted_vals[1],
                       average = sorted_vals[2],
                       bar_max = sorted_vals[3],
                       max = sorted_vals[4])

    # Create the plot
    plot = Plot(pd)
    plot.candle_plot(("index", "min", "bar_min", "average", "bar_max", "max"),
                     color = "lightgray",
                     bar_line_color = "black",
                     stem_color = "blue",
                     center_color = "red",
                     center_width = 2)

    # Tweak some of the plot properties
    plot.title = "Candlestick Plot"
    plot.line_width = 0.5
    plot.padding = 50

    # Attach some tools to the plot
    plot.tools.append(PanTool(plot, constrain_key="shift"))
    zoom = ZoomTool(component=plot, tool_mode="box", always_on=False)
    plot.overlays.append(zoom)

    return plot

#===============================================================================
# Attributes to use for the plot view.
size = (650, 650)
title = "Candlestick plot"

#===============================================================================
# # Demo class that is used by the demo.py application.
#===============================================================================
class Demo(HasTraits):
    plot = Instance(Component)

    traits_view = View(UItem('plot', editor=ComponentEditor()),
                       width=size[0], height=size[1], resizable=True,
                       title=title
                       )

    def _plot_default(self):
         return _create_plot_component()

demo = Demo()

if __name__ == "__main__":
    demo.configure_traits()

#--EOF---

########NEW FILE########
__FILENAME__ = cmap_image_aspect_ratio
#!/usr/bin/env python
"""
Draws a colormapped image plot
 - Left-drag pans the plot.
 - Mousewheel up and down zooms the plot in and out.
 - Pressing "z" brings up the Zoom Box, and you can click-drag a rectangular
   region to zoom.  If you use a sequence of zoom boxes, pressing alt-left-arrow
   and alt-right-arrow moves you forwards and backwards through the "zoom
   history".
"""

# Major library imports
from numpy import exp, linspace, meshgrid

# Enthought library imports
from enable.api import Component, ComponentEditor
from traits.api import HasTraits, Instance
from traitsui.api import Item, Group, View

# Chaco imports
from chaco.api import ArrayPlotData, jet, Plot
from chaco.tools.api import PanTool, ZoomTool

#===============================================================================
# # Create the Chaco plot.
#===============================================================================
def _create_plot_component():
    # Create a scalar field to colormap
    xs = linspace(0, 10, 600)
    ys = linspace(0, 5, 600)
    x, y = meshgrid(xs,ys)
    z = exp(-(x**2+y**2)/100)

    # Create a plot data object and give it this data
    pd = ArrayPlotData()
    pd.set_data("imagedata", z)

    # Create the plot
    plot = Plot(pd)
    img_plot = plot.img_plot("imagedata",
                             xbounds=(0, 10),
                             ybounds=(0, 5),
                             colormap=jet)[0]
    img_plot.index_mapper.aspect_ratio = 0.5
    img_plot.index_mapper.maintain_aspect_ratio = True
    print 'here'

    # Tweak some of the plot properties
    plot.title = "My First Image Plot"
    plot.padding = 50

    # Attach some tools to the plot
    plot.tools.append(PanTool(plot))
    zoom = ZoomTool(component=img_plot, tool_mode="box", always_on=False)
    img_plot.overlays.append(zoom)
    return plot


#===============================================================================
# Attributes to use for the plot view.
size=(800,600)
title="Basic Colormapped Image Plot"

#===============================================================================
# # Demo class that is used by the demo.py application.
#===============================================================================
class Demo(HasTraits):
    plot = Instance(Component)

    traits_view = View(
                    Group(
                        Item('plot', editor=ComponentEditor(size=size),
                             show_label=False),
                        orientation = "vertical"),
                    resizable=True, title=title
                    )
    def _plot_default(self):
         return _create_plot_component()

demo = Demo()

if __name__ == "__main__":
    demo.configure_traits()


########NEW FILE########
__FILENAME__ = cmap_image_plot
#!/usr/bin/env python
"""
Draws a colormapped image plot
 - Left-drag pans the plot.
 - Mousewheel up and down zooms the plot in and out.
 - Pressing "z" brings up the Zoom Box, and you can click-drag a rectangular
   region to zoom.  If you use a sequence of zoom boxes, pressing alt-left-arrow
   and alt-right-arrow moves you forwards and backwards through the "zoom
   history".
"""

# Major library imports
from numpy import exp, linspace, meshgrid

# Enthought library imports
from enable.api import Component, ComponentEditor
from traits.api import HasTraits, Instance
from traitsui.api import Item, Group, View

# Chaco imports
from chaco.api import ArrayPlotData, jet, Plot
from chaco.tools.api import PanTool, ZoomTool

#===============================================================================
# # Create the Chaco plot.
#===============================================================================
def _create_plot_component():
    # Create a scalar field to colormap
    xs = linspace(0, 10, 600)
    ys = linspace(0, 5, 600)
    x, y = meshgrid(xs,ys)
    z = exp(-(x**2+y**2)/100)

    # Create a plot data object and give it this data
    pd = ArrayPlotData()
    pd.set_data("imagedata", z)

    # Create the plot
    plot = Plot(pd)
    img_plot = plot.img_plot("imagedata",
                             xbounds=(0, 10),
                             ybounds=(0, 5),
                             colormap=jet)[0]

    # Tweak some of the plot properties
    plot.title = "My First Image Plot"
    plot.padding = 50

    # Attach some tools to the plot
    plot.tools.append(PanTool(plot))
    zoom = ZoomTool(component=img_plot, tool_mode="box", always_on=False)
    img_plot.overlays.append(zoom)
    return plot


#===============================================================================
# Attributes to use for the plot view.
size=(800,600)
title="Basic Colormapped Image Plot"

#===============================================================================
# # Demo class that is used by the demo.py application.
#===============================================================================
class Demo(HasTraits):
    plot = Instance(Component)

    traits_view = View(
                    Group(
                        Item('plot', editor=ComponentEditor(size=size),
                             show_label=False),
                        orientation = "vertical"),
                    resizable=True, title=title
                    )
    def _plot_default(self):
         return _create_plot_component()

demo = Demo()

if __name__ == "__main__":
    demo.configure_traits()


########NEW FILE########
__FILENAME__ = cmap_image_select
#!/usr/bin/env python
"""
Draws a colormapped image plot
 - Left-drag pans the plot.
 - Mousewheel up and down zooms the plot in and out.
 - Pressing "z" brings up the Zoom Box, and you can click-drag a rectangular
   region to zoom.  If you use a sequence of zoom boxes, pressing alt-left-arrow
   and alt-right-arrow moves you forwards and backwards through the "zoom
   history".
"""

# Major library imports
from numpy import linspace, meshgrid, pi
from scipy.special import jn

# Enthought library imports
from enable.api import Component, ComponentEditor
from traits.api import HasTraits, Instance
from traitsui.api import Item, Group, View

# Chaco imports
from chaco.api import ArrayPlotData, ColorBar, HPlotContainer, jet, \
                                 LinearMapper, Plot
from chaco.tools.api import PanTool, RangeSelection, \
                                       RangeSelectionOverlay, ZoomTool

#===============================================================================
# # Create the Chaco plot.
#===============================================================================
def _create_plot_component():
    # Create a scalar field to colormap# Create a scalar field to colormap
    xbounds = (-2*pi, 2*pi, 600)
    ybounds = (-1.5*pi, 1.5*pi, 300)
    xs = linspace(*xbounds)
    ys = linspace(*ybounds)
    x, y = meshgrid(xs,ys)
    z = jn(2, x)*y*x

    # Create a plot data obect and give it this data
    pd = ArrayPlotData()
    pd.set_data("imagedata", z)

    # Create the plot
    plot = Plot(pd)
    plot.img_plot("imagedata",
                  name="my_plot",
                  xbounds=xbounds[:2],
                  ybounds=ybounds[:2],
                  colormap=jet)

    # Tweak some of the plot properties
    plot.title = "Selectable Image Plot"
    plot.padding = 50

    # Right now, some of the tools are a little invasive, and we need the
    # actual CMapImage object to give to them
    my_plot = plot.plots["my_plot"][0]

    # Attach some tools to the plot
    plot.tools.append(PanTool(plot))
    zoom = ZoomTool(component=plot, tool_mode="box", always_on=False)
    plot.overlays.append(zoom)

    # Create the colorbar, handing in the appropriate range and colormap
    colormap = my_plot.color_mapper
    colorbar = ColorBar(index_mapper=LinearMapper(range=colormap.range),
                        color_mapper=colormap,
                        plot=my_plot,
                        orientation='v',
                        resizable='v',
                        width=30,
                        padding=20)
    colorbar.padding_top = plot.padding_top
    colorbar.padding_bottom = plot.padding_bottom

    # create a range selection for the colorbar
    range_selection = RangeSelection(component=colorbar)
    colorbar.tools.append(range_selection)
    colorbar.overlays.append(RangeSelectionOverlay(component=colorbar,
                                                   border_color="white",
                                                   alpha=0.8,
                                                   fill_color="lightgray"))

    # we also want to the range selection to inform the cmap plot of
    # the selection, so set that up as well
    range_selection.listeners.append(my_plot)

    # Create a container to position the plot and the colorbar side-by-side
    container = HPlotContainer(use_backbuffer = True)
    container.add(plot)
    container.add(colorbar)
    container.bgcolor = "lightgray"

    #my_plot.set_value_selection((-1.3, 6.9))

    return container
#===============================================================================
# Attributes to use for the plot view.
size=(800,600)
title="Colormapped Image Plot"

#===============================================================================
# # Demo class that is used by the demo.py application.
#===============================================================================
class Demo(HasTraits):
    plot = Instance(Component)

    traits_view = View(
                    Group(
                        Item('plot', editor=ComponentEditor(size=size),
                             show_label=False),
                        orientation = "vertical"),
                    resizable=True, title=title
                    )
    def _plot_default(self):
         return _create_plot_component()

demo = Demo()

if __name__ == "__main__":
    demo.configure_traits()


########NEW FILE########
__FILENAME__ = cmap_scatter
"""
Scatterplot with range-selectable data points

Draws a colormapped scatterplot of random data.

In addition to normal zooming and panning on the plot, the user can select
a range of data values by right-dragging in the color bar.

Left-click in the color bar to cancel the range selection.
"""

# Major library imports
from numpy import exp, sort
from numpy.random import random

# Enthought library imports
from enable.api import Component, ComponentEditor, Window
from traits.api import HasTraits, Instance
from traitsui.api import Item, VGroup, View, Label

# Chaco imports
from chaco.api import ArrayPlotData, ColorBar, \
                                 ColormappedSelectionOverlay, HPlotContainer, \
                                 jet, LinearMapper, Plot
from chaco.tools.api import PanTool, ZoomTool, RangeSelection, \
                                       RangeSelectionOverlay

#===============================================================================
# # Create the Chaco plot.
#===============================================================================
def _create_plot_component():

    # Create some data
    numpts = 1000
    x = sort(random(numpts))
    y = random(numpts)
    color = exp(-(x**2 + y**2))

    # Create a plot data obect and give it this data
    pd = ArrayPlotData()
    pd.set_data("index", x)
    pd.set_data("value", y)
    pd.set_data("color", color)

    # Create the plot
    plot = Plot(pd)
    plot.plot(("index", "value", "color"),
              type="cmap_scatter",
              name="my_plot",
              color_mapper=jet,
              marker = "square",
              fill_alpha = 0.5,
              marker_size = 6,
              outline_color = "black",
              border_visible = True,
              bgcolor = "white")

    # Tweak some of the plot properties
    plot.title = "Colormapped Scatter Plot with Range-selectable Data Points"
    plot.padding = 50
    plot.x_grid.visible = False
    plot.y_grid.visible = False
    plot.x_axis.font = "modern 16"
    plot.y_axis.font = "modern 16"

    # Right now, some of the tools are a little invasive, and we need the
    # actual ColomappedScatterPlot object to give to them
    cmap_renderer = plot.plots["my_plot"][0]

    # Attach some tools to the plot
    plot.tools.append(PanTool(plot, constrain_key="shift"))
    zoom = ZoomTool(component=plot, tool_mode="box", always_on=False)
    plot.overlays.append(zoom)
    selection = ColormappedSelectionOverlay(cmap_renderer, fade_alpha=0.35,
                                            selection_type="mask")
    cmap_renderer.overlays.append(selection)

    # Create the colorbar, handing in the appropriate range and colormap
    colorbar = create_colorbar(plot.color_mapper)
    colorbar.plot = cmap_renderer
    colorbar.padding_top = plot.padding_top
    colorbar.padding_bottom = plot.padding_bottom

    # Create a container to position the plot and the colorbar side-by-side
    container = HPlotContainer(use_backbuffer = True)
    container.add(plot)
    container.add(colorbar)
    container.bgcolor = "lightgray"
    return container

def create_colorbar(colormap):
    colorbar = ColorBar(index_mapper=LinearMapper(range=colormap.range),
                        color_mapper=colormap,
                        orientation='v',
                        resizable='v',
                        width=30,
                        padding=20)
    colorbar.tools.append(RangeSelection(component=colorbar))
    colorbar.overlays.append(RangeSelectionOverlay(component=colorbar,
                                                   border_color="white",
                                                   alpha=0.8,
                                                   fill_color="lightgray"))
    return colorbar

#===============================================================================
# Attributes to use for the plot view.
size=(650,650)
title="Colormapped scatter plot"

#===============================================================================
# # Demo class that is used by the demo.py application.
#===============================================================================
class Demo(HasTraits):
    plot = Instance(Component)

    traits_view = View(
                    VGroup(
                        Label('Right-drag on colorbar to select data range'),
                        Item('plot', editor=ComponentEditor(size=size),
                             show_label=False),
                        ),
                    resizable=True, 
                    title=title
                    )
    def _plot_default(self):
         return _create_plot_component()

demo = Demo()

if __name__ == "__main__":
    demo.configure_traits()

########NEW FILE########
__FILENAME__ = contour_cmap_plot
"""
Renders some contoured and colormapped images of a scalar value field.
 - Left-drag pans the plot.
 - Mousewheel up and down zooms the plot in and out.
 - Pressing "z" brings up the Zoom Box, and you can click-drag a rectangular
   region to zoom.  If you use a sequence of zoom boxes, pressing alt-left-arrow   and alt-right-arrow moves you forwards and backwards through the "zoom
   history".
"""

# Major library imports
from numpy import cos, linspace, log, meshgrid, pi, sin

# Enthought library imports
from enable.api import Component, ComponentEditor
from traits.api import HasTraits, Instance
from traitsui.api import Item, Group, View

# Chaco imports
from chaco.api import ArrayPlotData, ColorBar, gmt_drywet, \
                                 HPlotContainer, LinearMapper, Plot
from chaco.tools.api import PanTool, ZoomTool


#===============================================================================
# # Create the Chaco plot.
#===============================================================================
def _create_plot_component():

    # Create a scalar field to colormap
    x_extents = (-2*pi, 2*pi)
    y_extents = (-1.5*pi, 1.5*pi)
    xs = linspace(-2*pi, 2*pi, 200)
    ys = linspace(-1.5*pi, 1.5*pi, 100)
    x, y = meshgrid(xs,ys)
    zs = sin(log(abs((x+1)**4)+0.05))*cos(y)*1.1*(-y) + \
            sin(((x+1)**2 + y**2)/4)

    # Create a plot data obect and give it this data
    pd = ArrayPlotData()
    pd.set_data("imagedata", zs)

    # Create the left plot, a colormap and simple contours
    lplot = Plot(pd)
    lplot.img_plot("imagedata",
                   name="cm_plot",
                   xbounds=x_extents,
                   ybounds=y_extents,
                   colormap=gmt_drywet)
    lplot.contour_plot("imagedata",
                       type="line",
                       xbounds=x_extents,
                       ybounds=y_extents)

    # Tweak some of the plot properties
    lplot.title = "Colormap and contours"
    lplot.padding = 20
    lplot.bg_color = "white"
    lplot.fill_padding = True

    # Add some tools to the plot
    zoom = ZoomTool(lplot, tool_mode="box", always_on=False)
    lplot.overlays.append(zoom)
    lplot.tools.append(PanTool(lplot, constrain_key="shift"))

    # Right now, some of the tools are a little invasive, and we need the
    # actual CMapImage object to give to them
    cm_plot = lplot.plots["cm_plot"][0]

    # Create the colorbar, handing in the appropriate range and colormap
    colormap = cm_plot.color_mapper
    colorbar = ColorBar(index_mapper=LinearMapper(range=colormap.range),
                        color_mapper=colormap,
                        plot=cm_plot,
                        orientation='v',
                        resizable='v',
                        width=30,
                        padding=20)
    colorbar.padding_top = lplot.padding_top
    colorbar.padding_bottom = lplot.padding_bottom

    # Create the left plot, contours of varying color and width
    rplot = Plot(pd, range2d=lplot.range2d)
    rplot.contour_plot("imagedata",
                       type="line",
                       xbounds=x_extents,
                       ybounds=y_extents,
                       bgcolor="black",
                       levels=15,
                       styles="solid",
                       widths=list(linspace(4.0, 0.1, 15)),
                       colors=gmt_drywet)

    # Add some tools to the plot
    zoom = ZoomTool(rplot, tool_mode="box", always_on=False)
    rplot.overlays.append(zoom)
    rplot.tools.append(PanTool(rplot, constrain_key="shift"))

    # Tweak some of the plot properties
    rplot.title = "Varying contour lines"
    rplot.padding = 20
    rplot.bg_color = "white"
    rplot.fill_padding = True

    # Create a container and add our plots
    container = HPlotContainer(padding=40, fill_padding=True,
                               bgcolor = "white", use_backbuffer=True)
    container.add(colorbar)
    container.add(lplot)
    container.add(rplot)
    return container

#===============================================================================
# Attributes to use for the plot view.
size=(950,650)
title="Some contour plots"
bg_color="lightgray"

#===============================================================================
# # Demo class that is used by the demo.py application.
#===============================================================================
class Demo(HasTraits):
    plot = Instance(Component)

    traits_view = View(
                    Group(
                        Item('plot', editor=ComponentEditor(size=size,
                                                            bgcolor=bg_color),
                             show_label=False),
                        orientation = "vertical"),
                    resizable=True, title=title
                    )
    def _plot_default(self):
         return _create_plot_component()

demo = Demo()

if __name__ == "__main__":
    demo.configure_traits()

# EOF

########NEW FILE########
__FILENAME__ = contour_plot
#!/usr/bin/env python
"""
Draws a contour polygon plot with a contour line plot on top
 - Left-drag pans the plot.
 - Mousewheel up and down zooms the plot in and out.
 - Pressing "z" brings up the Zoom Box, and you can click-drag a rectangular
   region to zoom.  If you use a sequence of zoom boxes, pressing alt-left-arrow
   and alt-right-arrow moves you forwards and backwards through the "zoom
   history".
"""

# Major library imports
from numpy import cosh, exp, linspace, meshgrid, pi, tanh

# Enthought library imports
from enable.api import Component, ComponentEditor
from traits.api import HasTraits, Instance
from traitsui.api import Item, Group, View

# Chaco imports
from chaco.api import ArrayPlotData, jet, Plot
from chaco.tools.api import PanTool, ZoomTool

#===============================================================================
# # Create the Chaco plot.
#===============================================================================
def _create_plot_component():

    # Create a scalar field to contour
    xs = linspace(-2*pi, 2*pi, 600)
    ys = linspace(-1.5*pi, 1.5*pi, 300)
    x, y = meshgrid(xs,ys)
    z = tanh(x*y/6)*cosh(exp(-y**2)*x/3)
    z = x*y

    # Create a plot data obect and give it this data
    pd = ArrayPlotData()
    pd.set_data("imagedata", z)

    # Create a contour polygon plot of the data
    plot = Plot(pd, default_origin="top left")
    plot.contour_plot("imagedata",
                      type="poly",
                      poly_cmap=jet,
                      xbounds=(xs[0], xs[-1]),
                      ybounds=(ys[0], ys[-1]))

    # Create a contour line plot for the data, too
    plot.contour_plot("imagedata",
                      type="line",
                      xbounds=(xs[0], xs[-1]),
                      ybounds=(ys[0], ys[-1]))

    # Tweak some of the plot properties
    plot.title = "My First Contour Plot"
    plot.padding = 50
    plot.bg_color = "white"
    plot.fill_padding = True

    # Attach some tools to the plot
    plot.tools.append(PanTool(plot))
    zoom = ZoomTool(component=plot, tool_mode="box", always_on=False)
    plot.overlays.append(zoom)
    return plot

#===============================================================================
# Attributes to use for the plot view.
size = (800, 600)
title = "Basic Contour Plot"

#===============================================================================
# # Demo class that is used by the demo.py application.
#===============================================================================
class Demo(HasTraits):
    plot = Instance(Component)

    traits_view = View(
                    Group(
                        Item('plot', editor=ComponentEditor(size=size),
                             show_label=False),
                        orientation = "vertical"),
                    resizable=True, title=title
                    )

    def _plot_default(self):
         return _create_plot_component()

demo = Demo()

if __name__ == "__main__":
    demo.configure_traits()

#--EOF---

########NEW FILE########
__FILENAME__ = draw_layers
#!/usr/bin/env python
"""
Demonstrates the use of drawing layers in Chaco.

Three classes of functions are plotted: bessels, sines,
and Struve functions.
"""

# Major library imports
from numpy import linspace, sin
from scipy.special import jn, struve

# Enthought library imports
from enable.api import Component, ComponentEditor
from traits.api import HasTraits, Instance
from traitsui.api import Item, Group, View

# Chaco imports
from chaco.api import ArrayPlotData, Plot
from chaco.tools.api import PanTool, ZoomTool

#===============================================================================
# # Create the Chaco plot.
#===============================================================================
def _create_plot_component():

    x = linspace(-2.0, 10.0, 100)
    pd = ArrayPlotData(x = x)

    # Create some line plots of some of the data
    plot = Plot(pd, padding=50, border_visible=True, overlay_border=True)
    plot.legend.visible = True

    # Extend the plot's list of drawing layers
    ndx = plot.draw_order.index("plot")
    plot.draw_order[ndx:ndx] = ["bessel", "sine", "struve"]

    # Draw struve
    for i in range(3):
        y_name = "struve" + str(i)
        pd.set_data(y_name, struve(i, x))
        renderer = plot.plot(("x", y_name), color="blue", name=y_name, line_width=2)[0]
        renderer.set(draw_layer = "struve", unified_draw=True)

    # Draw bessels
    for i in range(3):
        y_name = "bessel" + str(i)
        pd.set_data(y_name, jn(i,x))
        renderer = plot.plot(("x", y_name), color="green", name=y_name, line_width=2)[0]
        renderer.set(draw_layer = "bessel", unified_draw=True)

    # Draw sines
    for i in range(3):
        y_name = "sine" + str(i)
        pd.set_data(y_name, sin(x * (i+1) / 1.5))
        renderer = plot.plot(("x", y_name), color="red", name=y_name, line_width=2)[0]
        renderer.set(draw_layer="sine", unified_draw=True)

    # Attach some tools to the plot
    plot.tools.append(PanTool(plot))
    zoom = ZoomTool(component=plot, tool_mode="box", always_on=False)
    plot.overlays.append(zoom)

    return plot

#===============================================================================
# Attributes to use for the plot view.
size=(900,500)
title="Draw order demonstration"

#===============================================================================
# # Demo class that is used by the demo.py application.
#===============================================================================
class Demo(HasTraits):
    plot = Instance(Component)

    traits_view = View(
                    Group(
                        Item('plot', editor=ComponentEditor(size=size),
                             show_label=False),
                        orientation = "vertical"),
                    resizable=True, title=title
                    )

    def _plot_default(self):
         return _create_plot_component()

demo = Demo()

if __name__ == "__main__":
    demo.configure_traits()

#--EOF---

########NEW FILE########
__FILENAME__ = grid_container
"""
Grid containing plots with resize restrictions

The ability of Plots to resize, when their container resizes, can be explicitly
restricted in either direction. This can place *implicit* restrictions on
other plots in the grid.

In this example, the upper left plot is explicitly restricted from resizing 
horizontally. The bottom center plot is explicitly restricted from resizing 
at all.

The resulting implicit restrictions on the other 4 plots are generally
intuitive, except that when the window gets too small to respect all of the
restrictions, the results are OS and GUI-backend-dependent, not easily 
predictable.

"""

# Major library imports
from numpy import linspace
from scipy.special import jn

from chaco.example_support import COLOR_PALETTE

# Enthought library imports
from enable.api import Component, ComponentEditor
from traits.api import HasTraits, Instance
from traitsui.api import Item, Group, View

# Chaco imports
from chaco.api import ArrayPlotData, GridContainer, Plot, PlotLabel
from chaco.tools.api import PanTool, ZoomTool



#===============================================================================
# # Create the Chaco plot.
#===============================================================================
def _create_plot_component():
    # Create a GridContainer to hold all of our plots: 2 rows, 3 columns:
    container = GridContainer(padding=40, fill_padding=True,
                              bgcolor="lightgray", use_backbuffer=True,
                              shape=(2,3), spacing=(20,20))

    # Create the initial series of data
    x = linspace(-5, 15.0, 100)
    pd = ArrayPlotData(index = x)

    # Plot some bessel functions and add the plots to our container
    for i in range(6):
        pd.set_data("y" + str(i), jn(i,x))
        plot = Plot(pd)
        plot.plot(("index", "y" + str(i)),
                  color=tuple(COLOR_PALETTE[i]), line_width=2.0,
                  bgcolor = "white", border_visible=True)

        # Tweak some of the plot properties
        plot.border_width = 1
        plot.padding = 0
        plot.padding_top = 30

        # Attach some tools to the plot
        plot.tools.append(PanTool(plot))
        zoom = ZoomTool(plot, tool_mode="box", always_on=False)
        plot.overlays.append(zoom)

        # Add to the grid container (
        container.add(plot)

    # Set the upper-left plot to only be resizable vertically, and to have a
    # fixed horizontal width. This also constrains the width of the first column.
    ul_plot = container.components[0]
    ul_plot.set(resizable="v", width=200)
    ul_plot.overlays.append(PlotLabel("Not horizontally resizable",
                                      component=ul_plot))

    # Set the bottom center plot to have a fixed width and height.
    # This also constrains the height of the bottom row and the width of
    # the middle column.
    cplot = container.components[4]
    cplot.set(resizable="", bounds=[400,400])
    cplot.overlays.append(PlotLabel("Not resizable", component=cplot))

    container.padding_top = 50
    container.overlays.append(
        PlotLabel('Resize the window - some plots resize, others cannot '
                  '(see source code)',
                  component=container,
                  font = "swiss 16",
                  overlay_position = "top"))
        
    return container

#===============================================================================
# Attributes to use for the plot view.
size=(1000,800)
title="Resizable Grid Container"

#===============================================================================
# # Demo class that is used by the demo.py application.
#===============================================================================
class Demo(HasTraits):
    plot = Instance(Component)

    traits_view = \
        View(
            Group(
                Item('plot', editor=ComponentEditor(size=size),
                        show_label=False),
                orientation = "vertical"
                ),
            resizable=True, title=title )

    def _plot_default(self):
         return _create_plot_component()

demo = Demo()

if __name__ == "__main__":
    demo.configure_traits()

########NEW FILE########
__FILENAME__ = grid_container_aspect_ratio
"""
Grid containing plots with fixed aspect ratios

Each plot in this example has a specified aspect ratio which will not
change no matter how the window is resized.
"""

# Major library imports
from numpy import linspace
from scipy.special import jn

from chaco.example_support import COLOR_PALETTE

# Enthought library imports
from enable.api import Component, ComponentEditor
from traits.api import HasTraits, Instance
from traitsui.api import Item, Group, View

# Chaco imports
from chaco.api import ArrayPlotData, GridContainer, Plot
from chaco.tools.api import PanTool, ZoomTool


#===============================================================================
# # Create the Chaco plot.
#===============================================================================
def _create_plot_component():
    # Create a GridContainer to hold all of our plots
    container = GridContainer(padding=20, fill_padding=True,
                              bgcolor="lightgray", use_backbuffer=True,
                              shape=(3,3), spacing=(12,12))

    # Create the initial series of data
    x = linspace(-5, 15.0, 100)
    pd = ArrayPlotData(index = x)

    # Plot some bessel functions and add the plots to our container
    for i in range(9):
        pd.set_data("y" + str(i), jn(i,x))
        plot = Plot(pd)
        plot.plot(("index", "y" + str(i)),
                  color=tuple(COLOR_PALETTE[i]), line_width=2.0,
                  bgcolor = "white", border_visible=True)

        # Tweak some of the plot properties
        plot.border_width = 1
        plot.padding = 10

        # Set each plot's aspect ratio based on its position in the
        # 3x3 grid of plots.
        n,m = divmod(i, 3)
        plot.aspect_ratio = float(n+1) / (m+1)

        # Attach some tools to the plot
        plot.tools.append(PanTool(plot))
        zoom = ZoomTool(plot, tool_mode="box", always_on=False)
        plot.overlays.append(zoom)

        # Add to the grid container
        container.add(plot)
    return container

#===============================================================================
# Attributes to use for the plot view.
size=(1000,800)
title="Grid Container with Fixed Aspect ratios"

#===============================================================================
# # Demo class that is used by the demo.py application.
#===============================================================================
class Demo(HasTraits):
    plot = Instance(Component)

    traits_view = View(
                    Group(
                        Item('plot', editor=ComponentEditor(size=size),
                             show_label=False),
                        orientation = "vertical"),
                    resizable=True, title=title
                    )
    def _plot_default(self):
         return _create_plot_component()

demo = Demo()

if __name__ == "__main__":
    demo.configure_traits()

########NEW FILE########
__FILENAME__ = hittest_tool
#!/usr/bin/env python
"""
Draws a random x-y lineplot and makes a tool which
shows the closet point on the lineplot to the mouse position.
"""
#Major library imports
from numpy.random import random_sample
from numpy import arange

#Enthought library imports
from enable.api import Component, ComponentEditor, BaseTool
from traits.api import HasTraits, Instance, Any, Int
from traitsui.api import View, UItem

#Chaco imports
from chaco.api import Plot, ArrayPlotData, AbstractOverlay, ArrayDataSource


#===============================================================================
# # Create the Chaco custom tool
#===============================================================================
class HittestTool(BaseTool, AbstractOverlay):
    '''This tool uses LinePlot.hittest() to get the closest point
    on the line to the mouse position and to draw it to the screen.
    Also implements an Overlay in order to draw the point.
    '''
    # A reference to the lineplot the tool acts on
    line_plot = Any()
    
    # Whether to draw the overlay
    visible=True

    # The point to draw on the plot, or None if no point
    pt = Any()

    # How many pixels away we may be from the line in order to do 
    threshold = Int(40)

    def normal_mouse_move(self, event):
        # Compute the nearest point and draw it whenever the mouse moves
        x,y = event.x, event.y

        if self.line_plot.orientation == "h":
            x,y = self.component.map_data((x,y))
        else:
            x,y = self.component.map_data((y,x))

        x,y = self.line_plot.map_screen((x,y))
        self.pt = self.line_plot.hittest((x,y), threshold=self.threshold)
        self.request_redraw()

    def overlay(self, plot, gc, view_bounds=None, mode="normal"):
        # If we have a point, draw it to the screen as a small square
        if self.pt is not None:
            x,y = plot.map_screen(self.pt)
            gc.draw_rect((int(x)-2, int(y)-2, 4, 4))

#===============================================================================
# # Create the Chaco plot.
#===============================================================================

def _create_plot_component():
    # make 10 random points
    x = arange(10)
    x = ArrayDataSource(x, sort_order="ascending")
    y = random_sample(10)

    # Plot the data
    pd = ArrayPlotData(x=x, y=y)

    plot = Plot(pd)
    plot.orientation = 'v'
    line_plot = plot.plot(("x", "y"))[0]

    # Add the tool to the plot both as a tool and as an overlay
    tool = HittestTool(component=plot, line_plot=line_plot)
    plot.tools.append(tool)
    plot.overlays.append(tool)

    return plot

#===============================================================================
# Attributes to use for the plot view.
#===============================================================================
size = (800,600)
title="LinePlot Hittest Demo"

#===============================================================================
# # Demo class that is used by the demo.py application.
#===============================================================================
class Demo(HasTraits):
    plot = Instance(Component)

    traits_view = View(
        UItem("plot", editor=ComponentEditor(size=size)),
        resizable=True,
        title=title
    )

    def _plot_default(self):
        return _create_plot_component()

demo = Demo()

if __name__ == '__main__':
    demo.configure_traits()

#--EOF---

########NEW FILE########
__FILENAME__ = horizon_plot
"""
Implementation of a sample horizon plot, showing both negative and positive
values in the same banded region.
"""

# Major library imports
from numpy import cumprod, linspace, random
import time

# Enthought library imports
from enable.api import Component, ComponentEditor
from traits.api import HasTraits, Instance
from traitsui.api import Item, Group, View

# Chaco imports
from chaco.api import ArrayDataSource, LinearMapper, DataRange1D, \
                      HPlotContainer, OverlayPlotContainer, PlotGrid, PlotAxis, \
                      FilledLinePlot, BandedMapper, HorizonPlot, \
                      ColorBar, RdBu as cmap
from chaco.tools.api import PanTool

from chaco.scales.api import CalendarScaleSystem
from chaco.scales_tick_generator import ScalesTickGenerator

def create_dates(numpoints, units="days"):
    """ Returns **numpoints** number of dates that evenly bracket the current
    date and time.  **units** should be one of "weeks", "days", "hours"
    "minutes", or "seconds".
    """
    units_map = { "weeks" : 7*24*3600,
                  "days" : 24*3600,
                  "hours" : 3600,
                  "minutes" : 60, 
                  "seconds" : 1 } 
    now = time.time()
    dt = units_map[units]
    dates = linspace(now, now+numpoints*dt, numpoints)
    return dates

#===============================================================================
# # Create the Chaco plot.
#===============================================================================
def _create_plot_components():
    # Create the data and datasource objects
    # In order for the date axis to work, the index data points need to
    # be in units of seconds since the epoch.  This is because we are using
    # the CalendarScaleSystem, whose formatters interpret the numerical values
    # as seconds since the epoch.
    high = 1.
    numpoints = 5000

    random.seed(1000)

    index = create_dates(numpoints)
    price = 100*cumprod(random.lognormal(0.0, 0.04, size=numpoints))
    changes = price/price[0] - 1.

    index_ds = ArrayDataSource(index)
    value_ds = ArrayDataSource(changes, sort_order="none")
    value_range = DataRange1D(value_ds, low=-high, high=high)
    
    index_mapper = LinearMapper(range=DataRange1D(index_ds), stretch_data=False)
    
    horizon = HorizonPlot(
            bands = 4,
            index = index_ds,
            value = value_ds,
            index_mapper = index_mapper,
            value_mapper = BandedMapper(range=DataRange1D(low=0, high=high)),
            color_mapper = cmap(range=value_range),
            )
    horizon.tools.append(PanTool(horizon, constrain=True, constrain_direction="x"))
    axis = PlotAxis(mapper = horizon.value_mapper, component=horizon, orientation="left",
                   tick_label_position="outside")
    horizon.overlays.append(axis)

    bottom_axis = PlotAxis(horizon, orientation="bottom",
                      tick_generator=ScalesTickGenerator(scale=CalendarScaleSystem()))
    horizon.overlays.append(bottom_axis)

    
    filled = FilledLinePlot(
            index = index_ds,
            value = value_ds,
            index_mapper = index_mapper,
            value_mapper = LinearMapper(range=value_range, stretch_data=False),
            fill_color = (0.81960784,  0.89803922,  0.94117647),
            edge_color = 'transparent',
            )
    filled.tools.append(PanTool(filled, constrain=True, constrain_direction="x"))
    axis = PlotAxis(mapper = filled.value_mapper, component=filled, orientation="left",
                   tick_label_position="outside")
    filled.overlays.append(axis)

    grid = PlotGrid(mapper = filled.value_mapper, component=filled, orientation='horizontal',
                    line_color='lightgray', line_style="dot",)
    filled.underlays.append(grid)

    colormap = horizon.color_mapper
    colorbar = ColorBar(index_mapper=LinearMapper(range=colormap.range),
                        color_mapper=colormap,
                        orientation='v',
                        resizable='v',
                        width=20,
                        padding=20)
    
    padding = (40, 20, 0, 0)
    over1 = HPlotContainer(use_backbuffer=True, padding=padding, padding_top=20)
    over1.add(filled)
    over1.add(colorbar)

    over2 = OverlayPlotContainer(padding = padding, padding_bottom=40)
    over2.add(horizon)

    return over1, over2


filled_size=(800,220)
horizon_size=(800,70)
title="Horizon plot example"

#===============================================================================
# # Demo class that is used by the demo.py application.
#===============================================================================
class Demo(HasTraits):
    filled = Instance(Component)
    horizon = Instance(Component)

    traits_view = View(
                    Group(
                        Item('filled', editor=ComponentEditor(size=filled_size),
                             show_label=False),
                        Item('horizon', editor=ComponentEditor(size=horizon_size),
                             show_label=False),
                        orientation = "vertical"),
                    resizable=False, title=title,
                    width=filled_size[0], height=filled_size[1]+horizon_size[1],
                    )

demo = Demo()

if __name__ == "__main__":

    filled, horizon = _create_plot_components()
    demo.set(horizon=horizon, filled=filled)
    demo.configure_traits()

#--EOF---

########NEW FILE########
__FILENAME__ = image_from_file
#!/usr/bin/env python
"""
Loads and saves RGB images from disk
 - Left-drag pans the plot.
 - Mousewheel up and down zooms the plot in and out.
 - Pressing "z" brings up the Zoom Box, and you can click-drag a rectangular
   region to zoom.  If you use a sequence of zoom boxes, pressing alt-left-arrow
   and alt-right-arrow moves you forwards and backwards through the "zoom
   history".
"""

# Standard library imports
import os, sys

# Major library imports

# Enthought library imports
from traits.util.resource import find_resource
from traits.api import File, HasTraits, Instance
from traitsui.api import Handler, Item, View
from traitsui.menu \
    import Action, CloseAction, Menu, MenuBar, OKCancelButtons, Separator

# Chaco imports
from chaco.api \
    import ArrayPlotData, ImageData, Plot, PlotGraphicsContext
from enable.component_editor import ComponentEditor
from chaco.tools.api import PanTool, ZoomTool


#-------------------------------------------------------------------------------
# Class 'DemoView'
#-------------------------------------------------------------------------------

class DemoView(HasTraits):

    ### Public Traits ##########################################################

    # A Plot Data object to hold our image data
    pd = Instance(ArrayPlotData, ())

    # A Plot object to plot our image data
    plot = Instance(Plot)


    ### Private Traits #########################################################

    # File name to load image from
    resource_path = os.path.join('examples','basic','capitol.jpg')
    alt_path = 'capitol.jpg'
    image_path = find_resource('Chaco', resource_path, alt_path=alt_path,
        return_path=True)
    _load_file = File(image_path)

    # File name to save image to
    _save_file = File


    ### Traits Views ###########################################################

    # This view is for a file dialog to select the 'load' filename
    load_file_view = View(
        Item('_load_file'),
        buttons=OKCancelButtons,
        kind='livemodal',  # NB must use livemodal, plot objects don't copy well
        width=400,
        resizable=True,
    )

    # This view is for a file dialog to select the 'save' filename
    save_file_view = View(
        Item('_save_file'),
        buttons=OKCancelButtons,
        kind='livemodal',  # NB must use livemodal, plot objects don't copy well
        width=400,
        resizable=True,
    )

    #---------------------------------------------------------------------------
    # Public 'DemoView' interface
    #---------------------------------------------------------------------------

    def __init__(self, *args, **kwargs):
        super(DemoView, self).__init__(*args, **kwargs)

        # Create the plot object, set some options, and add some tools
        plot = self.plot = Plot(self.pd, default_origin="top left")
        plot.x_axis.orientation = "top"
        plot.padding = 50
        plot.padding_top = 75
        plot.tools.append(PanTool(plot))
        zoom = ZoomTool(component=plot, tool_mode="box", always_on=False)
        plot.overlays.append(zoom)

        # Load the default image
        self._load()

        # Plot the image plot with this image
        self.plot.img_plot("imagedata")

    def default_traits_view(self):
        """ Returns the default view to use for this class.
        """
        # NOTE: I moved the view to this method so we can declare a handler
        # for the view. Alternatively, we could move the DemoController class
        # to the top and declare view=Instance(HasTraits) instead.
        traits_view = View(
            Item('plot',
                 editor=ComponentEditor(),
                 show_label=False,
            ),
            menubar=MenuBar(
                Menu(Action(name="Save Plot", action="save"), # see Controller for
                     Action(name="Load Plot", action="load"), # these callbacks
                     Separator(),
                     CloseAction,
                     name="File",
                ),
            ),
            width=600,
            height=600,
            resizable=True,
            handler=DemoController
        )
        return traits_view

    #---------------------------------------------------------------------------
    # Private 'DemoView' interface
    #---------------------------------------------------------------------------

    def _save(self):
        # Create a graphics context of the right size
        win_size = self.plot.outer_bounds
        plot_gc = PlotGraphicsContext(win_size)

        # Have the plot component into it
        plot_gc.render_component(self.plot)

        # Save out to the user supplied filename
        plot_gc.save(self._save_file)

    def _load(self):
        try:
            # Load the image with the user supplied filename
            image = ImageData.fromfile(self._load_file)

            # Update the plot data. NB we must extract _data from the image
            # for the time being, until ImageData is made more friendly
            self.pd.set_data("imagedata", image._data)

            # Set the title and redraw
            self.plot.title = os.path.basename(self._load_file)
            self.plot.request_redraw()
        except:
            # If loading fails, simply do nothing
            pass


#-------------------------------------------------------------------------------
# Class 'DemoController'
#-------------------------------------------------------------------------------

class DemoController(Handler):

    # The HasTraits object we are a controller for
    view = Instance(DemoView)

    #---------------------------------------------------------------------------
    # Public 'DemoController' interface
    #---------------------------------------------------------------------------

    def init(self, info):
        """ Initializes the controls of a user interface.
        Overridden here to assign the 'view' trait.
        """
        self.view = info.object

    def save(self, ui_info):
        """
        Callback for the 'Save Image' menu option.
        """
        ui = self.view.edit_traits(view='save_file_view')
        if ui.result == True:
            self.view._save()

    def load(self, ui_info):
        """
        Callback for the 'Load Image' menu option.
        """
        ui = self.view.edit_traits(view='load_file_view')
        if ui.result == True:
            self.view._load()


#===============================================================================
# # popup object that is used by the demo.py application.
#===============================================================================
# Note: we declare a 'popup' rather than a 'demo' since the menubar doesn't seem
# to show up in a 'panel' mode.
popup = DemoView()

#-------------------------------------------------------------------------------
# Function 'main'
#-------------------------------------------------------------------------------

def main(argv=None):
    view = DemoView()
    view.configure_traits()


#-------------------------------------------------------------------------------

if __name__ == "__main__":
    sys.exit(main())

########NEW FILE########
__FILENAME__ = image_inspector
#!/usr/bin/env python
"""
Demonstrates the ImageInspectorTool and overlay on a colormapped image
plot.  The underlying plot is similar to the one in cmap_image_plot.py.

 - Left-drag pans the plot.
 - Mousewheel up and down zooms the plot in and out.
 - Pressing "z" brings up the Zoom Box, and you can click-drag a rectangular
   region to zoom.  If you use a sequence of zoom boxes, pressing alt-left-arrow
   and alt-right-arrow moves you forwards and backwards through the "zoom
   history".

 - Pressing "p" will toggle the display of the image inspector overlay.
"""

# Major library imports
from numpy import linspace, meshgrid, pi, sin

# Enthought library imports
from enable.api import Component, ComponentEditor
from traits.api import HasTraits, Instance
from traitsui.api import Item, Group, View

# Chaco imports
from chaco.api import ArrayPlotData, jet, Plot
from chaco.tools.api import PanTool, ZoomTool
from chaco.tools.image_inspector_tool import ImageInspectorTool, \
     ImageInspectorOverlay

#===============================================================================
# # Create the Chaco plot.
#===============================================================================
def _create_plot_component():# Create a scalar field to colormap
    xbounds = (-2*pi, 2*pi, 600)
    ybounds = (-1.5*pi, 1.5*pi, 300)
    xs = linspace(*xbounds)
    ys = linspace(*ybounds)
    x, y = meshgrid(xs,ys)
    z = sin(x)*y

    # Create a plot data obect and give it this data
    pd = ArrayPlotData()
    pd.set_data("imagedata", z)

    # Create the plot
    plot = Plot(pd)
    img_plot = plot.img_plot("imagedata",
                             xbounds = xbounds[:2],
                             ybounds = ybounds[:2],
                             colormap=jet)[0]

    # Tweak some of the plot properties
    plot.title = "My First Image Plot"
    plot.padding = 50

    # Attach some tools to the plot
    plot.tools.append(PanTool(plot))
    zoom = ZoomTool(component=plot, tool_mode="box", always_on=False)
    plot.overlays.append(zoom)
    imgtool = ImageInspectorTool(img_plot)
    img_plot.tools.append(imgtool)
    overlay = ImageInspectorOverlay(component=img_plot, image_inspector=imgtool,
                                    bgcolor="white", border_visible=True)

    img_plot.overlays.append(overlay)
    return plot

#===============================================================================
# Attributes to use for the plot view.
size = (800, 600)
title="Inspecting a Colormapped Image Plot"

#===============================================================================
# # Demo class that is used by the demo.py application.
#===============================================================================
class Demo(HasTraits):
    plot = Instance(Component)

    traits_view = View(
                    Group(
                        Item('plot', editor=ComponentEditor(size=size),
                             show_label=False),
                        orientation = "vertical"),
                    resizable=True, title=title
                    )

    def _plot_default(self):
         return _create_plot_component()

demo = Demo()

if __name__ == "__main__":
    demo.configure_traits()

#--EOF---

########NEW FILE########
__FILENAME__ = image_lasso
#!/usr/bin/env python
"""
Demonstrates the LassoTool and overlay on a colormapped image
plot.  The underlying plot is similar to the one in cmap_image_plot.py.

Use Shift-drag to select multiple disjoint regions.
"""

# Major library imports
from numpy import linspace, meshgrid, pi, sin

# Enthought library imports
from enable.api import Component, ComponentEditor
from traits.api import HasTraits, Instance
from traitsui.api import Item, Group, View

# Chaco imports
from chaco.api import ArrayPlotData, jet, Plot, LassoOverlay
from chaco.tools.api import LassoSelection, LassoSelection

#===============================================================================
# # Create the Chaco plot.
#===============================================================================

def lasso_updated(lasso_tool, name, old, new_selections):
    # new_selections is a list of arrays of coordinates in dataspace.  It is a
    # list because the LassoSelection supports multiple, disjoint selection regions.
    for i, selection in enumerate(new_selections):
        print "Selection region", i

        # We first map to screen because the selection is stored as coordinates
        # in data space
        screen_pts = lasso_tool.plot.map_screen(selection)

        # Now map each point into the grid index
        for x, y in screen_pts:
            print "\t", lasso_tool.plot.map_index((x, y))
    return

def _create_plot_component():# Create a scalar field to colormap
    xbounds = (-2*pi, 2*pi, 600)
    ybounds = (-1.5*pi, 1.5*pi, 300)
    xs = linspace(*xbounds)
    ys = linspace(*ybounds)
    x, y = meshgrid(xs,ys)
    z = sin(x)*y

    # Create a plot data obect and give it this data
    pd = ArrayPlotData()
    pd.set_data("imagedata", z)

    # Create the plot
    plot = Plot(pd)
    img_plot = plot.img_plot("imagedata",
                             xbounds=xbounds[:2],
                             ybounds=ybounds[:2],
                             colormap=jet)[0]

    # Tweak some of the plot properties
    plot.title = "Image Plot with Lasso"
    plot.padding = 50

    lasso_selection = LassoSelection(component=img_plot)
    lasso_selection.on_trait_change(lasso_updated, "disjoint_selections")
    lasso_overlay = LassoOverlay(lasso_selection = lasso_selection, component=img_plot)
    img_plot.tools.append(lasso_selection)
    img_plot.overlays.append(lasso_overlay)
    return plot

#===============================================================================
# Attributes to use for the plot view.
size = (800, 600)
title="Image Plot with Lasso"

#===============================================================================
# # Demo class that is used by the demo.py application.
#===============================================================================
class Demo(HasTraits):
    plot = Instance(Component)

    traits_view = View(
                    Group(
                        Item('plot', editor=ComponentEditor(size=size),
                             show_label=False),
                        orientation = "vertical"),
                    resizable=True, title=title
                    )

    def _plot_default(self):
         return _create_plot_component()

demo = Demo()

if __name__ == "__main__":
    demo.configure_traits()

# EOF

########NEW FILE########
__FILENAME__ = image_plot
#!/usr/bin/env python
"""
Draws an simple RGB image
 - Left-drag pans the plot.
 - Mousewheel up and down zooms the plot in and out.
 - Pressing "z" brings up the Zoom Box, and you can click-drag a rectangular
   region to zoom.  If you use a sequence of zoom boxes, pressing alt-left-arrow
   and alt-right-arrow moves you forwards and backwards through the "zoom
   history".
"""

# Major library imports
from numpy import zeros, uint8

# Enthought library imports
from enable.api import Component, ComponentEditor
from traits.api import HasTraits, Instance
from traitsui.api import Item, Group, View

# Chaco imports
from chaco.api import ArrayPlotData, Plot
from chaco.tools.api import PanTool, ZoomTool
from chaco.tools.image_inspector_tool import ImageInspectorTool, \
     ImageInspectorOverlay

#===============================================================================
# # Create the Chaco plot.
#===============================================================================
def _create_plot_component():

    # Create some RGBA image data
    image = zeros((200,400,4), dtype=uint8)
    image[:,0:40,0] += 255     # Vertical red stripe
    image[0:25,:,1] += 255     # Horizontal green stripe; also yellow square
    image[-80:,-160:,2] += 255 # Blue square
    image[:,:,3] = 255

    # Create a plot data obect and give it this data
    pd = ArrayPlotData()
    pd.set_data("imagedata", image)

    # Create the plot
    plot = Plot(pd, default_origin="top left")
    plot.x_axis.orientation = "top"
    img_plot = plot.img_plot("imagedata")[0]

    # Tweak some of the plot properties
    plot.bgcolor = "white"

    # Attach some tools to the plot
    plot.tools.append(PanTool(plot, constrain_key="shift"))
    plot.overlays.append(ZoomTool(component=plot,
                                    tool_mode="box", always_on=False))

    imgtool = ImageInspectorTool(img_plot)
    img_plot.tools.append(imgtool)
    plot.overlays.append(ImageInspectorOverlay(component=img_plot,
                                               image_inspector=imgtool))
    return plot

#===============================================================================
# Attributes to use for the plot view.
size = (600, 600)
title="Simple image plot"
bg_color="lightgray"

#===============================================================================
# # Demo class that is used by the demo.py application.
#===============================================================================
class Demo(HasTraits):
    plot = Instance(Component)

    traits_view = View(
                    Group(
                        Item('plot', editor=ComponentEditor(size=size,
                                                            bgcolor=bg_color),
                             show_label=False),
                        orientation = "vertical"),
                    resizable=True, title=title
                    )

    def _plot_default(self):
         return _create_plot_component()

demo = Demo()

if __name__ == "__main__":
    demo.configure_traits()

#--EOF---

########NEW FILE########
__FILENAME__ = inset_plot
#!/usr/bin/env python
""" Overlaid inset plots.

A modification of line_plot1.py that shows the second plot as a subwindow
of the first.  You can pan and zoom the second plot just like the first,
and you can move it around my right-click and dragging in the smaller plot.
"""

# Major library imports
from numpy import linspace
from scipy.special import jn

# Enthought library imports
from enable.api import Component, ComponentEditor
from traits.api import HasTraits, Instance
from traitsui.api import Item, Group, View

# Chaco imports
from chaco.api import ArrayPlotData, OverlayPlotContainer, Plot
from chaco.tools.api import PanTool, ZoomTool, MoveTool

#===============================================================================
# # Create the Chaco plot.
#===============================================================================
def _create_plot_component():
    # Create some x-y data series to plot
    x = linspace(-2.0, 10.0, 100)
    pd = ArrayPlotData(index = x)
    for i in range(5):
        pd.set_data("y" + str(i), jn(i,x))

    # Create some line plots of some of the data
    plot1 = Plot(pd)
    plot1.plot(("index", "y0", "y1", "y2"), name="j_n, n<3", color="red")
    plot1.plot(("index", "y3"), name="j_3", color="blue")

    # Tweak some of the plot properties
    plot1.title = "Inset Plot"
    plot1.padding = 50

    # Attach some tools to the plot
    plot1.tools.append(PanTool(plot1))
    zoom = ZoomTool(component=plot1, tool_mode="box", always_on=False)
    plot1.overlays.append(zoom)

    # Create a second scatter plot of one of the datasets, linking its
    # range to the first plot
    plot2 = Plot(pd, range2d=plot1.range2d, padding=50)
    plot2.plot(('index', 'y3'), type="scatter", color="blue", marker="circle")
    plot2.set(resizable = "",
              bounds = [250, 250],
              position = [550,150],
              bgcolor = "white",
              border_visible = True,
              unified_draw = True
              )
    plot2.tools.append(PanTool(plot2))
    plot2.tools.append(MoveTool(plot2, drag_button="right"))
    zoom = ZoomTool(component=plot2, tool_mode="box", always_on=False)
    plot2.overlays.append(zoom)

    # Create a container and add our plots
    container = OverlayPlotContainer()
    container.add(plot1)
    container.add(plot2)
    return container

#===============================================================================
# Attributes to use for the plot view.
size=(900,500)
title="Inset plots"

#===============================================================================
# # Demo class that is used by the demo.py application.
#===============================================================================
class Demo(HasTraits):
    plot = Instance(Component)

    traits_view = View(
                    Group(
                        Item('plot', editor=ComponentEditor(size=size),
                             show_label=False),
                        orientation = "vertical"),
                    resizable=True, title=title
                    )

    def _plot_default(self):
         return _create_plot_component()

demo = Demo()

if __name__ == "__main__":
    demo.configure_traits()

#--EOF

########NEW FILE########
__FILENAME__ = line_drawing
"""
Line drawing tool

Demonstrates using a line segment drawing tool on top of the
scatter plot from simple_scatter.py.

Pan using right-drag.
Zoom interactions are the same as in simple_line.py.

Line segment drawing:
    - left click places a new point
    - moving over an existing point and left-dragging will reposition that point
    - moving over an existing point and ctrl-left-clicking will delete that point
    - pressing "Enter" will "finalize" the selection.  This means that the
      tool's _finalize_selection() method will be called, and the list of
      drawn points will be reset.  By default, _finalize_selection() does nothing,
      but subclasses can customize this.
"""

# Major library imports
from numpy import sort
from numpy.random import random

# Enthought library imports
from enable.api import Component, ComponentEditor
from traits.api import HasTraits, Instance
from traitsui.api import Item, Group, View

# Chaco imports
from chaco.api import ArrayPlotData, Plot
from chaco.tools.api import LineSegmentTool, PanTool, ZoomTool


class MyLineDrawer(LineSegmentTool):
    """
    This class demonstrates how to customize the behavior of the
    LineSegmentTool via subclassing.
    """

    def _finalize_selection(self):
        print "Dataspace points:"
        for point in self.points:
            print "\t", point

#===============================================================================
# # Create the Chaco plot.
#===============================================================================
def _create_plot_component():

    # Create some data
    numpts = 1000
    x = sort(random(numpts))
    y = random(numpts)

    # Create a plot data obect and give it this data
    pd = ArrayPlotData()
    pd.set_data("index", x)
    pd.set_data("value", y)

    # Create the plot
    plot = Plot(pd)
    plot.plot(("index", "value"),
              type="scatter",
              name="my_plot",
              marker="square",
              index_sort="ascending",
              color="lightblue",
              outline_color="none",
              marker_size=3,
              bgcolor="white")

    # Tweak some of the plot properties
    plot.title = "Click to add points, press Enter to finalize selection"
    plot.padding = 50
    plot.line_width = 1

    # Attach some tools to the plot
    pan = PanTool(plot, drag_button="right", constrain_key="shift")
    plot.tools.append(pan)
    zoom = ZoomTool(component=plot, tool_mode="box", always_on=False)
    plot.overlays.append(zoom)
    plot.overlays.append(MyLineDrawer(plot))
    return plot

#===============================================================================
# Attributes to use for the plot view.
size=(650,650)
title="Line drawing example"
bg_color="lightgray"

#===============================================================================
# # Demo class that is used by the demo.py application.
#===============================================================================
class Demo(HasTraits):
    plot = Instance(Component)

    traits_view = View(
                    Group(
                        Item('plot', editor=ComponentEditor(size=size,
                                                            bgcolor=bg_color),
                             show_label=False),
                        orientation = "vertical"),
                    resizable=True, title=title
                    )

    def _plot_default(self):
         return _create_plot_component()

demo = Demo()

if __name__ == "__main__":
    demo.configure_traits()

########NEW FILE########
__FILENAME__ = line_plot1
#!/usr/bin/env python
"""
Draws some x-y line and scatter plots. On the left hand plot:
 - Left-drag pans the plot.
 - Mousewheel up and down zooms the plot in and out.
 - Pressing "z" brings up the Zoom Box, and you can click-drag a rectangular
   region to zoom.  If you use a sequence of zoom boxes, pressing alt-left-arrow
   and alt-right-arrow moves you forwards and backwards through the "zoom
   history".
"""

# Major library imports
from numpy import linspace
from scipy.special import jn

# Enthought library imports
from enable.api import Component, ComponentEditor
from traits.api import HasTraits, Instance
from traitsui.api import Item, Group, View

# Chaco imports
from chaco.api import ArrayPlotData, HPlotContainer, Plot
from chaco.tools.api import PanTool, ZoomTool

#===============================================================================
# # Create the Chaco plot.
#===============================================================================
def _create_plot_component():

    # Create some x-y data series to plot
    x = linspace(-2.0, 10.0, 100)
    pd = ArrayPlotData(index = x)
    for i in range(5):
        pd.set_data("y" + str(i), jn(i,x))

    # Create some line plots of some of the data
    plot1 = Plot(pd, title="Line Plot", padding=50, border_visible=True)
    plot1.legend.visible = True
    plot1.plot(("index", "y0", "y1", "y2"), name="j_n, n<3", color="red")
    plot1.plot(("index", "y3"), name="j_3", color="blue")

    # Attach some tools to the plot
    plot1.tools.append(PanTool(plot1))
    zoom = ZoomTool(component=plot1, tool_mode="box", always_on=False)
    plot1.overlays.append(zoom)

    # Create a second scatter plot of one of the datasets, linking its
    # range to the first plot
    plot2 = Plot(pd, range2d=plot1.range2d, title="Scatter plot", padding=50,
                 border_visible=True)
    plot2.plot(('index', 'y3'), type="scatter", color="blue", marker="circle")

    # Create a container and add our plots
    container = HPlotContainer()
    container.add(plot1)
    container.add(plot2)

    return container

#===============================================================================
# Attributes to use for the plot view.
size=(900,500)
title="Basic x-y plots"

#===============================================================================
# # Demo class that is used by the demo.py application.
#===============================================================================
class Demo(HasTraits):
    plot = Instance(Component)

    traits_view = View(
                    Group(
                        Item('plot', editor=ComponentEditor(size=size),
                             show_label=False),
                        orientation = "vertical"),
                    resizable=True, title=title
                    )

    def _plot_default(self):
         return _create_plot_component()

demo = Demo()

if __name__ == "__main__":
    demo.configure_traits()

#--EOF---

########NEW FILE########
__FILENAME__ = line_plot_hold
#!/usr/bin/env python
"""
Demonstrates the different 'hold' styles of LinePlot
"""

# Major library imports
from numpy import linspace
from scipy.special import jn

# Enthought library imports
from enable.api import Component, ComponentEditor
from traits.api import HasTraits, Instance
from traitsui.api import Item, Group, View

# Chaco imports
from chaco.api import ArrayPlotData, HPlotContainer, Plot
from chaco.tools.api import PanTool, ZoomTool

def attach_tools(plot):
    plot.tools.append(PanTool(plot))
    zoom = ZoomTool(component=plot, tool_mode="box", always_on=False)
    plot.overlays.append(zoom)

#===============================================================================
# # Create the Chaco plot.
#===============================================================================
def _create_plot_component():

    # Create some x-y data series to plot
    x = linspace(-2.0, 10.0, 40)
    pd = ArrayPlotData(index = x, y0=jn(0,x))

    # Create some line plots of some of the data
    plot1 = Plot(pd, title="render_style = hold", padding=50, border_visible=True,
                 overlay_border = True)
    plot1.legend.visible = True
    lineplot = plot1.plot(("index", "y0"), name="j_0", color="red", render_style="hold")

    # Attach some tools to the plot
    attach_tools(plot1)

    # Create a second scatter plot of one of the datasets, linking its
    # range to the first plot
    plot2 = Plot(pd, range2d=plot1.range2d, title="render_style = connectedhold",
                 padding=50, border_visible=True, overlay_border=True)
    plot2.plot(('index', 'y0'), color="blue", render_style="connectedhold")
    attach_tools(plot2)

    # Create a container and add our plots
    container = HPlotContainer()
    container.add(plot1)
    container.add(plot2)
    return container

#===============================================================================
# Attributes to use for the plot view.
size=(900,500)
title="Line plots with hold"

#===============================================================================
# # Demo class that is used by the demo.py application.
#===============================================================================
class Demo(HasTraits):
    plot = Instance(Component)

    traits_view = View(
                    Group(
                        Item('plot', editor=ComponentEditor(size=size),
                             show_label=False),
                        orientation = "vertical"),
                    resizable=True, title=title
                    )

    def _plot_default(self):
         return _create_plot_component()

demo = Demo()

if __name__ == "__main__":
    demo.configure_traits()

#--EOF---

########NEW FILE########
__FILENAME__ = log_plot
#!/usr/bin/env python
""" Basic x-y log plots.

Draws some x-y log plots. (No Tools)

"""

# Major library imports
from numpy import exp, linspace, sqrt
from scipy.special import gamma

# Enthought library imports
from enable.api import Component, ComponentEditor
from traits.api import HasTraits, Instance
from traitsui.api import Item, Group, View

# Chaco imports
from chaco.api import ArrayPlotData, Plot
from chaco.tools.api import PanTool, ZoomTool

#===============================================================================
# # Create the Chaco plot.
#===============================================================================
def _create_plot_component():

    # Create some x-y data series to plot
    x = linspace(1.0, 8.0, 200)
    pd = ArrayPlotData(index = x)
    pd.set_data("y0", sqrt(x))
    pd.set_data("y1", x)
    pd.set_data("y2", x**2)
    pd.set_data("y3", exp(x))
    pd.set_data("y4", gamma(x))
    pd.set_data("y5", x**x)

    # Create some line plots of some of the data
    plot = Plot(pd)
    plot.plot(("index", "y0"), line_width=2, name="sqrt(x)", color="purple")
    plot.plot(("index", "y1"), line_width=2, name="x", color="blue")
    plot.plot(("index", "y2"), line_width=2, name="x**2", color="green")
    plot.plot(("index", "y3"), line_width=2, name="exp(x)", color="gold")
    plot.plot(("index", "y4"), line_width=2, name="gamma(x)",color="orange")
    plot.plot(("index", "y5"), line_width=2, name="x**x", color="red")

    # Set the value axis to display on a log scale
    plot.value_scale = "log"

    # Tweak some of the plot properties
    plot.title = "Log Plot"
    plot.padding = 50
    plot.legend.visible = True

    # Attach some tools to the plot
    plot.tools.append(PanTool(plot))
    zoom = ZoomTool(component=plot, tool_mode="box", always_on=False)
    plot.overlays.append(zoom)

    return plot

#===============================================================================
# Attributes to use for the plot view.
size=(900,500)
title="Basic x-y log plots"

#===============================================================================
# # Demo class that is used by the demo.py application.
#===============================================================================
class Demo(HasTraits):
    plot = Instance(Component)

    traits_view = View(
                    Group(
                        Item('plot', editor=ComponentEditor(size=size),
                             show_label=False),
                        orientation = "vertical"),
                    resizable=True, title=title
                    )

    def _plot_default(self):
         return _create_plot_component()

demo = Demo()

if __name__ == "__main__":
    demo.configure_traits()

#--EOF---

########NEW FILE########
__FILENAME__ = nans_plot
#!/usr/bin/env python
""" Plot data with NaNs.

This plot displays chaco's ability to handle data interlaced with NaNs.
 - Left-drag pans the plot.
 - Mousewheel up and down zooms the plot in and out.
 - Pressing "z" brings up the Zoom Box, and you can click-drag a rectangular
   region to zoom.  If you use a sequence of zoom boxes, pressing alt-left-arrow
   and alt-right-arrow moves you forwards and backwards through the "zoom
   history".
"""

# Major library imports
from numpy import linspace, nan
from scipy.special import jn

# Enthought library imports
from enable.api import Component, ComponentEditor
from traits.api import HasTraits, Instance
from traitsui.api import Item, Group, View

# Chaco imports
from chaco.api import ArrayPlotData, Plot
from chaco.tools.api import PanTool, ZoomTool

#===============================================================================
# # Create the Chaco plot.
#===============================================================================
def _create_plot_component():

    # Create some x-y data series (with NaNs) to plot
    x = linspace(-5.0, 15.0, 500)
    x[75:125] = nan
    x[200:250] = nan
    x[300:330] = nan
    pd = ArrayPlotData(index = x)
    pd.set_data("value1", jn(0, x))
    pd.set_data("value2", jn(1, x))

    # Create some line and scatter plots of the data
    plot = Plot(pd)
    plot.plot(("index", "value1"), name="j_0(x)", color="red", width=2.0)
    plot.plot(("index", "value2"), type="scatter", marker_size=1,
              name="j_1(x)", color="green")

    # Tweak some of the plot properties
    plot.title = "Plots with NaNs"
    plot.padding = 50
    plot.legend.visible = True

    # Attach some tools to the plot
    plot.tools.append(PanTool(plot))
    zoom = ZoomTool(component=plot, tool_mode="box", always_on=False)
    plot.overlays.append(zoom)

    return plot

#===============================================================================
# Attributes to use for the plot view.
size = (800, 700)
title = "Nan Test"

#===============================================================================
# # Demo class that is used by the demo.py application.
#===============================================================================
class Demo(HasTraits):
    plot = Instance(Component)

    traits_view = View(
                    Group(
                        Item('plot', editor=ComponentEditor(size=size),
                             show_label=False),
                        orientation = "vertical"),
                    resizable=True, title=title
                    )

    def _plot_default(self):
         return _create_plot_component()

demo = Demo()

if __name__ == "__main__":
    demo.configure_traits()

#--EOF---

########NEW FILE########
__FILENAME__ = polygon_move
#!/usr/bin/env python
""" Polygon plot with drag-move.

Shares same basic interactions as polygon_plot.py, but adds a new one:
 - Right click and drag to move a polygon around.
"""

# Major library imports
from numpy import transpose

# Enthought library imports
from enable.api import Component, ComponentEditor
from traits.api import HasTraits, Instance, Enum, CArray
from traitsui.api import Item, Group, View

# Chaco imports
from chaco.api import ArrayPlotData, Plot
from chaco.base import n_gon
from chaco.tools.api import PanTool, ZoomTool, DragTool

class DataspaceMoveTool(DragTool):
    """
    Modifies the data values of a plot.  Only works on instances
    of BaseXYPlot or its subclasses
    """

    event_state = Enum("normal", "dragging")
    _prev_pt = CArray

    def is_draggable(self, x, y):
        return self.component.hittest((x,y))

    def drag_start(self, event):
        data_pt = self.component.map_data((event.x, event.y), all_values=True)
        self._prev_pt = data_pt
        event.handled = True

    def dragging(self, event):
        plot = self.component
        cur_pt = plot.map_data((event.x, event.y), all_values=True)
        dx = cur_pt[0] - self._prev_pt[0]
        dy = cur_pt[1] - self._prev_pt[1]
        index = plot.index.get_data() + dx
        value = plot.value.get_data() + dy
        plot.index.set_data(index, sort_order=plot.index.sort_order)
        plot.value.set_data(value, sort_order=plot.value.sort_order)
        self._prev_pt = cur_pt
        event.handled = True
        plot.request_redraw()


#===============================================================================
# # Create the Chaco plot.
#===============================================================================
def _create_plot_component():

    # Use n_gon to compute center locations for our polygons
    points = n_gon(center=(0,0), r=4, nsides=8)

    # Choose some colors for our polygons
    colors = {3:0xaabbcc,   4:'orange', 5:'yellow',    6:'lightgreen',
              7:'green', 8:'blue',   9:'lavender', 10:'purple'}

        # Create a PlotData object to store the polygon data
    pd = ArrayPlotData()

    # Create a Polygon Plot to draw the regular polygons
    polyplot = Plot(pd)

    # Store path data for each polygon, and plot
    nsides = 3
    for p in points:
        npoints = n_gon(center=p, r=2, nsides=nsides)
        nxarray, nyarray = transpose(npoints)
        pd.set_data("x" + str(nsides), nxarray)
        pd.set_data("y" + str(nsides), nyarray)
        plot = polyplot.plot(("x"+str(nsides), "y"+str(nsides)),
                      type="polygon",
                      face_color=colors[nsides],
                      hittest_type="poly")[0]
        plot.tools.append(DataspaceMoveTool(plot, drag_button="right"))
        nsides = nsides + 1

    # Tweak some of the plot properties
    polyplot.padding = 50
    polyplot.title = "Polygon Plot"

    # Attach some tools to the plot
    polyplot.tools.append(PanTool(polyplot))
    zoom = ZoomTool(polyplot, tool_mode="box", always_on=False)
    polyplot.overlays.append(zoom)

    return polyplot

#===============================================================================
# Attributes to use for the plot view.
size=(800,800)
title="Polygon Plot"

#===============================================================================
# # Demo class that is used by the demo.py application.
#===============================================================================
class Demo(HasTraits):
    plot = Instance(Component)

    traits_view = View(
                    Group(
                        Item('plot', editor=ComponentEditor(size=size),
                             show_label=False),
                        orientation = "vertical"),
                    resizable=True, title=title
                    )

    def _plot_default(self):
         return _create_plot_component()

demo = Demo()

if __name__ == "__main__":
    demo.configure_traits()

#--EOF---

########NEW FILE########
__FILENAME__ = polygon_plot_demo
""" Simple polygon plot.

The UI allows you to change some of the attributes of the plot.

"""

import numpy as np

from traits.api import HasTraits, Instance, Range
from traitsui.api import View, UItem, Item, Group, HGroup, VGroup, spring
from chaco.api import Plot, ArrayPlotData, PolygonPlot
from enable.api import ComponentEditor, LineStyle


class PolygonPlotDemo(HasTraits):

    # The main plot container.
    plot = Instance(Plot)

    # Data holder for `plot`.
    apd = Instance(ArrayPlotData)

    # The polygon plot renderer.
    polygon_plot = Instance(PolygonPlot)

    # Assorted styles that will be set on `polygon_plot`.    
    edge_style = LineStyle
    edge_width = Range(value=1, low=0, high=8)
    edge_alpha = Range(value=1.0, low=0.0, high=1.0)
    face_alpha = Range(value=0.4, low=0.0, high=1.0)
    alpha = Range(value=1.0, low=0.0, high=1.0)

    traits_view = \
        View(
            VGroup(
                Group(
                    UItem('plot', editor=ComponentEditor(), style='custom'),
                ),
                VGroup(
                    HGroup(
                        Item('edge_style'),
                        spring,
                    ),
                    Item('edge_width'),
                    Item('edge_alpha'),
                    Item('face_alpha'),
                    Item('alpha'),
                ),
            ),
            resizable=True,
        )

    #----------------------------------------------------------------------
    # Default values
    #----------------------------------------------------------------------

    def _apd_default(self):
        # Create the data to plot.
        px = np.array([0.5, 1.0, 2.0, 2.5, 2.0, 1.5, 0.5, 0.0])
        py = np.array([0.0, 0.8, 0.5, 3.0, 3.5, 2.0, 3.0, 0.5])

        # Create the ArrayPlotData container used by the Plot.
        apd = ArrayPlotData(px=px, py=py)
        return apd

    def _plot_default(self):
        plot = Plot(self.apd, title='PolygonPlot Demo')
        return plot

    def _polygon_plot_default(self):
        p = self.plot.plot(('px', 'py'),
                  type='polygon',
                  face_color=(0,0.8,1) + (self.face_alpha,),
                  edge_color=(0,0,0) + (self.edge_alpha,),
                  edge_style=self.edge_style,
                  alpha=self.alpha)
        return p[0]

    #----------------------------------------------------------------------
    # Trait change handlers
    #----------------------------------------------------------------------

    def _edge_style_changed(self):
        self.polygon_plot.edge_style = self.edge_style

    def _edge_width_changed(self):
        self.polygon_plot.edge_width = self.edge_width

    def _edge_alpha_changed(self):
        self.polygon_plot.edge_color = self.polygon_plot.edge_color[:3] + (self.edge_alpha,)

    def _face_alpha_changed(self):
        self.polygon_plot.face_color = self.polygon_plot.face_color[:3] + (self.face_alpha,)

    def _alpha_changed(self):
        self.polygon_plot.alpha = self.alpha


demo = PolygonPlotDemo()
# Hack to force initial rendering of the plot.
demo.face_alpha = 0.5


if __name__ == "__main__":
    demo.configure_traits()

########NEW FILE########
__FILENAME__ = regression
"""
Regression Selection tool

Hold down the left mouse button to use the mouse to draw a selection region
around some points, and a line fit is drawn through the center of the points.
The parameters of the line are displayed at the bottom of the plot region.  You
can do this repeatedly to draw different regions.

Hold the right mouse button down and drag to pan.

Use the mousewheel to zoom in and out.
"""

# Major library imports
from numpy.random import random

# Enthought library imports
from enable.api import Component, ComponentEditor
from traits.api import HasTraits, Instance
from traitsui.api import Item, Group, View

# Chaco imports
from chaco.api import ArrayPlotData, Plot
from chaco.tools.api import PanTool, ZoomTool, RegressionLasso, \
        RegressionOverlay

#===============================================================================
# # Create the Chaco plot.
#===============================================================================
def _create_plot_component():
    pd = ArrayPlotData(x=random(100), y=random(100))

    # Create some line plots of some of the data
    plot = Plot(pd)

    # Create a scatter plot and get a reference to it (separate from the
    # Plot object) because we'll need it for the regression tool below.
    scatterplot = plot.plot(("x", "y"), color="blue", type="scatter")[0]

    # Tweak some of the plot properties
    plot.padding = 50

    # Attach some tools to the plot
    plot.tools.append(PanTool(plot, drag_button="right"))
    plot.overlays.append(ZoomTool(plot))

    # Add the regression tool and overlay.  These need to be added
    # directly to the scatterplot instance (and not the Plot instance).
    regression = RegressionLasso(scatterplot,
        selection_datasource=scatterplot.index)
    scatterplot.tools.append(regression)
    scatterplot.overlays.append(RegressionOverlay(scatterplot,
                                                  lasso_selection=regression))
    return plot

#===============================================================================
# Attributes to use for the plot view.
size = (600, 600)
title = "Regression Selection"

#===============================================================================
# # Demo class that is used by the demo.py application.
#===============================================================================
class Demo(HasTraits):
    plot = Instance(Component)

    traits_view = View(
                    Group(
                        Item('plot', editor=ComponentEditor(size=size),
                             show_label=False),
                        orientation = "vertical"),
                    resizable=True, title=title
                    )

    def _plot_default(self):
         return _create_plot_component()

demo = Demo()

if __name__ == "__main__":
    demo.configure_traits()

########NEW FILE########
__FILENAME__ = scatter
"""
Scatter plot with panning and zooming

Shows a scatter plot of a set of random points, 
with basic Chaco panning and zooming.

Interacting with the plot:

  - Left-mouse-drag pans the plot.
  - Mouse wheel up and down zooms the plot in and out.
  - Pressing "z" brings up the Zoom Box, and you can click-drag a rectangular
    region to zoom. If you use a sequence of zoom boxes, pressing alt-left-arrow
    and alt-right-arrow moves you forwards and backwards through the "zoom
    history".
"""

# Major library imports
from numpy import sort
from numpy.random import random

# Enthought library imports
from enable.api import Component, ComponentEditor
from traits.api import HasTraits, Instance
from traitsui.api import Item, Group, View

# Chaco imports
from chaco.api import ArrayPlotData, Plot
from chaco.tools.api import PanTool, ZoomTool

#===============================================================================
# # Create the Chaco plot.
#===============================================================================
def _create_plot_component():

    # Create some data
    numpts = 5000
    x = sort(random(numpts))
    y = random(numpts)

    # Create a plot data object and give it this data
    pd = ArrayPlotData()
    pd.set_data("index", x)
    pd.set_data("value", y)

    # Create the plot
    plot = Plot(pd)
    plot.plot(("index", "value"),
              type="scatter",
              marker="circle",
              index_sort="ascending",
              color="orange",
              marker_size=3,
              bgcolor="white")

    # Tweak some of the plot properties
    plot.title = "Scatter Plot"
    plot.line_width = 0.5
    plot.padding = 50

    # Attach some tools to the plot
    plot.tools.append(PanTool(plot, constrain_key="shift"))
    zoom = ZoomTool(component=plot, tool_mode="box", always_on=False)
    plot.overlays.append(zoom)

    return plot

#===============================================================================
# Attributes to use for the plot view.
size = (650, 650)
title = "Basic scatter plot"
bg_color="lightgray"

#===============================================================================
# # Demo class that is used by the demo.py application.
#===============================================================================
class Demo(HasTraits):
    plot = Instance(Component)

    traits_view = View(
                    Group(
                        Item('plot', editor=ComponentEditor(size=size,
                                                            bgcolor=bg_color),
                             show_label=False),
                        orientation = "vertical"),
                    resizable=True, title=title
                    )

    def _plot_default(self):
         return _create_plot_component()

demo = Demo()

if __name__ == "__main__":
    demo.configure_traits()

#--EOF---

########NEW FILE########
__FILENAME__ = scatter_alpha
"""
Scatter plot demonstrating varying alpha

Shows a scatter plot of a set of random points,
with basic Chaco panning and zooming.  Has a slider
which varies the alpha interactively, fading the plot
in and out.
"""

# Major library imports
from numpy import sort
from numpy.random import random

# Enthought library imports
from enable.api import Component, ComponentEditor
from traits.api import DelegatesTo, HasTraits, Instance
from traitsui.api import Item, Group, View, RangeEditor

# Chaco imports
from chaco.api import ArrayPlotData, Plot
from chaco.tools.api import PanTool, ZoomTool

#===============================================================================
# # Create the Chaco plot.
#===============================================================================
def _create_plot_component():

    # Create some data
    numpts = 5000
    x = sort(random(numpts))
    y = random(numpts)

    # Create a plot data object and give it this data
    pd = ArrayPlotData()
    pd.set_data("index", x)
    pd.set_data("value", y)

    # Create the plot
    plot = Plot(pd)

    # Tweak some of the plot properties
    plot.title = "Scatter Plot"
    plot.line_width = 0.5
    plot.padding = 50

    # Attach some tools to the plot
    plot.tools.append(PanTool(plot, constrain_key="shift"))
    zoom = ZoomTool(component=plot, tool_mode="box", always_on=False)
    plot.overlays.append(zoom)

    return plot


def _create_scatter_renderer(plot):
    renderer = plot.plot(("index", "value"),
                          type="scatter",
                          marker="circle",
                          index_sort="ascending",
                          color="orange",
                          marker_size=3,
                          bgcolor="white")[0]

    return renderer

#===============================================================================
# Attributes to use for the plot view.
size = (650, 650)
title = "Basic scatter plot"
bg_color="lightgray"

#===============================================================================
# # Demo class that is used by the demo.py application.
#===============================================================================
class Demo(HasTraits):
    plot = Instance(Component)

    scatter_renderer = Instance(Component)

    alpha = DelegatesTo('scatter_renderer')

    traits_view = View(
                    Group(
                        Item('plot', editor=ComponentEditor(size=size,
                                                            bgcolor=bg_color),
                             show_label=False),
                        Group(
                            Item('alpha', editor=RangeEditor(low=0.0, high=1.0)),
                        ),
                        orientation = "vertical"),
                    resizable=True, title=title
                    )

    def _plot_default(self):
         return _create_plot_component()

    def _scatter_renderer_default(self):
        renderer = _create_scatter_renderer(self.plot)
        return renderer

demo = Demo()

if __name__ == "__main__":
    demo.configure_traits()

#--EOF---

########NEW FILE########
__FILENAME__ = scatter_custom_marker
"""
Scatter plot with custom markers

Chaco supports a wide range of custom markers.

Interacting with the plot:

  - Left-mouse-drag pans the plot.
  - Mouse wheel up and down zooms the plot in and out.
  - Pressing "z" brings up the Zoom Box, and you can click-drag a rectangular
    region to zoom. If you use a sequence of zoom boxes, pressing alt-left-arrow
    and alt-right-arrow moves you forwards and backwards through the "zoom
    history".
"""

# Major library imports
from numpy import sort
from numpy.random import random

# Enthought library imports
from enable.api import Component, ComponentEditor
from enable.compiled_path import CompiledPath
from traits.api import HasTraits, Instance
from traitsui.api import Item, Group, View

# Chaco imports
from chaco.api import ArrayPlotData, Plot
from chaco.tools.api import PanTool, ZoomTool


def make_custom_marker():
    path = CompiledPath()
    path.move_to(-5,-5)
    path.line_to(5, 5)
    path.line_to(5, -5)
    path.line_to(-5, 5)
    path.line_to(-5, -5)
    return path

#===============================================================================
# # Create the Chaco plot.
#===============================================================================
def _create_plot_component():

    # Create some data
    numpts = 300
    x = sort(random(numpts))
    y = random(numpts)

    # create a custom marker
    marker = make_custom_marker()

    # Create a plot data obect and give it this data
    pd = ArrayPlotData()
    pd.set_data("index", x)
    pd.set_data("value", y)

    # Create the plot
    plot = Plot(pd)
    plot.plot(("index", "value"),
              type="scatter",
              marker="custom",
              custom_symbol=marker,
              index_sort="ascending",
              color="orange",
              marker_size=3,
              bgcolor="white")

    # Tweak some of the plot properties
    plot.title = "Scatter plot with custom markers"
    plot.line_width = 0.5
    plot.padding = 50

    # Attach some tools to the plot
    plot.tools.append(PanTool(plot, constrain_key="shift"))
    zoom = ZoomTool(component=plot, tool_mode="box", always_on=False)
    plot.overlays.append(zoom)

    return plot

#===============================================================================
# Attributes to use for the plot view.
size = (650, 650)
title = "Scatter plot w/ custom markers"
bg_color="lightgray"

#===============================================================================
# # Demo class that is used by the demo.py application.
#===============================================================================
class Demo(HasTraits):
    plot = Instance(Component)

    traits_view = View(
                    Group(
                        Item('plot', editor=ComponentEditor(size=size,
                                                            bgcolor=bg_color),
                             show_label=False),
                        orientation = "vertical"),
                    resizable=True, title=title
                    )

    def _plot_default(self):
         return _create_plot_component()

demo = Demo()

if __name__ == "__main__":
    demo.configure_traits()

#--EOF---

########NEW FILE########
__FILENAME__ = scatter_inspector
"""
Scattergram inspector tool

Allows the user to highlight and/or select individual points of a scattergram.

When the mouse hovers over a scatter point, it changes temporarily. If you click
on a point, you select and mark (or unselect and unmark) the point.
"""

# Major library imports
from numpy import random

# Enthought library imports
from enable.api import Component, ComponentEditor
from traits.api import HasTraits, Instance
from traitsui.api import Item, Group, View

# Chaco imports
from chaco.api import ArrayPlotData, Plot, ScatterInspectorOverlay
from chaco.tools.api import PanTool, ZoomTool, ScatterInspector

#===============================================================================
# # Create the Chaco plot.
#===============================================================================
def _create_plot_component():

    # Create a random scattering of XY pairs
    x = random.uniform(0.0, 10.0, 50)
    y = random.uniform(0.0, 5.0, 50)
    pd = ArrayPlotData(x = x, y = y)
    plot = Plot(pd, border_visible=True, overlay_border=True)

    scatter = plot.plot(("x", "y"), type="scatter", color="lightblue")[0]

    # Tweak some of the plot properties
    plot.set(title="Scatter Inspector Demo", padding=50)

    # Attach some tools to the plot
    plot.tools.append(PanTool(plot))
    plot.overlays.append(ZoomTool(plot))

    # Attach the inspector and its overlay
    scatter.tools.append(ScatterInspector(scatter))
    overlay = ScatterInspectorOverlay(scatter,
                    hover_color="red",
                    hover_marker_size=6,
                    selection_marker_size=6,
                    selection_color="yellow",
                    selection_outline_color="purple",
                    selection_line_width=3)
    scatter.overlays.append(overlay)

    return plot

#===============================================================================
# Attributes to use for the plot view.
size=(900,500)
title="Tooltip demo"

#===============================================================================
# # Demo class that is used by the demo.py application.
#===============================================================================
class Demo(HasTraits):
    plot = Instance(Component)

    traits_view = View(
                    Group(
                        Item('plot', editor=ComponentEditor(size=size),
                             show_label=False),
                        orientation = "vertical"),
                    resizable=True, title=title
                    )

    def _plot_default(self):
         return _create_plot_component()

demo = Demo()

if __name__ == "__main__":
    demo.configure_traits()

########NEW FILE########
__FILENAME__ = scatter_select
"""
Lasso selection of data points

Draws a simple scatterplot of random data.  Drag the mouse to use the lasso
selector, which allows you to circle all the points in a region.

Upon completion of the lasso operation, the indices of the selected points are
printed to the console.

Uncomment 'lasso_selection.incremental_select' line (line 74) to see the
indices of the selected points computed in real time.
"""

import sys

# Major library imports
from numpy import sort, compress, arange
from numpy.random import random

# Enthought library imports
from enable.api import Component, ComponentEditor
from traits.api import HasTraits, Instance
from traitsui.api import Item, Group, View

# Chaco imports
from chaco.api import ArrayPlotData, Plot, LassoOverlay
from chaco.tools.api import LassoSelection, ScatterInspector

#===============================================================================
# # Create the Chaco plot.
#===============================================================================
def _create_plot_component():

    # Create some data
    npts = 2000
    x = sort(random(npts))
    y = random(npts)

    # Create a plot data obect and give it this data
    pd = ArrayPlotData()
    pd.set_data("index", x)
    pd.set_data("value", y)

    # Create the plot
    plot = Plot(pd)
    plot.plot(("index", "value"),
              type="scatter",
              name="my_plot",
              marker="circle",
              index_sort="ascending",
              color="red",
              marker_size=4,
              bgcolor="white")

    # Tweak some of the plot properties
    plot.title = "Scatter Plot With Lasso Selection"
    plot.line_width = 1
    plot.padding = 50

    # Right now, some of the tools are a little invasive, and we need the
    # actual ScatterPlot object to give to them
    my_plot = plot.plots["my_plot"][0]

    # Attach some tools to the plot
    lasso_selection = LassoSelection(component=my_plot,
                                     selection_datasource=my_plot.index,
                                     drag_button="left")
                                     #drag_button="right")
    my_plot.active_tool = lasso_selection
    my_plot.tools.append(ScatterInspector(my_plot))
    lasso_overlay = LassoOverlay(lasso_selection=lasso_selection,
                                 component=my_plot)
    my_plot.overlays.append(lasso_overlay)

    # Uncomment this if you would like to see incremental updates:
    #lasso_selection.incremental_select = True

    return plot


#===============================================================================
# Attributes to use for the plot view.
size=(650,650)
title="Scatter plot with selection"
bg_color="lightgray"

#===============================================================================
# # Demo class that is used by the demo.py application.
#===============================================================================
class Demo(HasTraits):
    plot = Instance(Component)

    traits_view = View(
                    Group(
                        Item('plot', editor=ComponentEditor(size=size),
                             show_label=False),
                        orientation = "vertical"),
                    resizable=True, title=title
                    )

    def _selection_changed(self):
        mask = self.index_datasource.metadata['selection']
        print "New selection: "
        print compress(mask, arange(len(mask)))
        # Ensure that the points are printed immediately:
        sys.stdout.flush()
        

    def _plot_default(self):
         plot = _create_plot_component()

         # Retrieve the plot hooked to the LassoSelection tool.
         my_plot = plot.plots["my_plot"][0]
         lasso_selection = my_plot.active_tool

         # Set up the trait handler for the selection
         self.index_datasource = my_plot.index
         lasso_selection.on_trait_change(self._selection_changed,
                                        'selection_changed')

         return plot

demo = Demo()

if __name__ == "__main__":
    demo.configure_traits()

########NEW FILE########
__FILENAME__ = scatter_toggle
#!/usr/bin/env python
"""
Scatter plot with point selection

Draws a simple scatter plot of random data. The user can click on points to
select or unselect them.

    - Left-click on a point to select or unselect it.
    - Left-drag to pan.
    - Mouse wheel to zoom
    
"""
# FIXME: the 'z' zoom interaction is ill-behaved.

# Major library imports
from numpy import sort
from numpy.random import random

# Enthought library imports
from enable.api import Component, ComponentEditor
from traits.api import HasTraits, Instance
from traitsui.api import Item, VGroup, View, Label, HGroup, spring

# Chaco imports
from chaco.api import AbstractDataSource, ArrayPlotData, Plot, \
    ScatterInspectorOverlay
from chaco.tools.api import ScatterInspector, PanTool, ZoomTool

#===============================================================================
# # Create the Chaco plot.
#===============================================================================
def _create_plot_component():

    # Create some data
    npts = 100
    x = sort(random(npts))
    y = random(npts)

    # Create a plot data obect and give it this data
    pd = ArrayPlotData()
    pd.set_data("index", x)
    pd.set_data("value", y)

    # Create the plot
    plot = Plot(pd)
    plot.plot(("index", "value"),
              type="scatter",
              name="my_plot",
              marker="circle",
              index_sort="ascending",
              color="slategray",
              marker_size=6,
              bgcolor="white")

    # Tweak some of the plot properties
    plot.title = "Scatter Plot With Selection"
    plot.line_width = 1
    plot.padding = 50

    # Right now, some of the tools are a little invasive, and we need the
    # actual ScatterPlot object to give to them
    my_plot = plot.plots["my_plot"][0]

    # Attach some tools to the plot
    my_plot.tools.append(ScatterInspector(my_plot, selection_mode="toggle",
                                          persistent_hover=False))
    my_plot.overlays.append(
            ScatterInspectorOverlay(my_plot,
                hover_color = "transparent",
                hover_marker_size = 10,
                hover_outline_color = "purple",
                hover_line_width = 2,
                selection_marker_size = 8,
                selection_color = "lawngreen")
            )

    my_plot.tools.append(PanTool(my_plot))
    my_plot.overlays.append(ZoomTool(my_plot, drag_button="right"))

    return plot

#===============================================================================
# Attributes to use for the plot view.
size=(650,650)
title="Scatter plot with selection"
bg_color="lightgray"

#===============================================================================
# # Demo class that is used by the demo.py application.
#===============================================================================
class Demo(HasTraits):
    plot = Instance(Component)

    traits_view = View(
                    VGroup(
                        HGroup(spring, Label('Click point to select/unselect'), 
                            spring),
                        Item('plot', editor=ComponentEditor(size=size,
                                                            bgcolor=bg_color),
                             show_label=False),
                        orientation = "vertical"),
                    resizable=True, title=title
                    )

    def _metadata_handler(self):
        sel_indices = self.index_datasource.metadata.get('selections', [])
        print "Selection indices:", sel_indices

        hover_indices = self.index_datasource.metadata.get('hover', [])
        print "Hover indices:", hover_indices

    def _plot_default(self):
        plot = _create_plot_component()

        # Retrieve the plot hooked to the tool.
        my_plot = plot.plots["my_plot"][0]

        # Set up the trait handler for the selection
        self.index_datasource = my_plot.index
        self.index_datasource.on_trait_change(self._metadata_handler,
                                              "metadata_changed")

        return plot

demo = Demo()

if __name__ == "__main__":
    demo.configure_traits()

# EOF

########NEW FILE########
__FILENAME__ = scatter_variable_size
"""
Draws a scatterplot of a set of random points of variable size.
 - Left-drag pans the plot.
 - Mousewheel up and down zooms the plot in and out.
 - Pressing "z" brings up the Zoom Box, and you can click-drag a rectangular
   region to zoom.  If you use a sequence of zoom boxes, pressing alt-left-arrow
   and alt-right-arrow moves you forwards and backwards through the "zoom
   history".
"""

# Major library imports
import numpy

# Enthought library imports
from enable.api import Component, ComponentEditor
from traits.api import HasTraits, Instance
from traitsui.api import Item, Group, View

# Chaco imports
from chaco.api import ArrayPlotData, Plot
from chaco.tools.api import PanTool, ZoomTool

#===============================================================================
# # Create the Chaco plot.
#===============================================================================
def _create_plot_component():

    # Create some data
    numpts = 1000
    x = numpy.arange(0, numpts)
    y = numpy.random.random(numpts)
    marker_size = numpy.random.normal(4.0, 4.0, numpts)

    # Create a plot data object and give it this data
    pd = ArrayPlotData()
    pd.set_data("index", x)
    pd.set_data("value", y)

    # Create the plot
    plot = Plot(pd)
    plot.plot(("index", "value"),
              type="scatter",
              marker="circle",
              index_sort="ascending",
              color=(1.0, 0.0, 0.74, 0.4),
              marker_size=marker_size,
              bgcolor="white")

    # Tweak some of the plot properties
    plot.title = "Scatter Plot"
    plot.line_width = 0.5
    plot.padding = 50

    # Attach some tools to the plot
    plot.tools.append(PanTool(plot, constrain_key="shift"))
    zoom = ZoomTool(component=plot, tool_mode="box", always_on=False)
    plot.overlays.append(zoom)

    return plot

#===============================================================================
# Attributes to use for the plot view.
size = (650, 650)
title = "Basic scatter plot"
bg_color="lightgray"

#===============================================================================
# # Demo class that is used by the demo.py application.
#===============================================================================
class Demo(HasTraits):
    plot = Instance(Component)

    traits_view = View(
                    Group(
                        Item('plot', editor=ComponentEditor(size=size,
                                                            bgcolor=bg_color),
                             show_label=False),
                        orientation = "vertical"),
                    resizable=True, title=title
                    )

    def _plot_default(self):
         return _create_plot_component()

demo = Demo()

if __name__ == "__main__":
    demo.configure_traits()

#--EOF---

########NEW FILE########
__FILENAME__ = scrollbar
#!/usr/bin/env python
""" Plot with pan-zoom interaction.

Draws some x-y line and scatter plots. On the left hand plot:
 - Left-drag pans the plot.
 - Mousewheel up and down zooms the plot in and out.
 - Pressing "z" brings up the Zoom Box, and you can click-drag a rectangular
   region to zoom.  If you use a sequence of zoom boxes, pressing alt-left-arrow
   and alt-right-arrow moves you forwards and backwards through the "zoom
   history".
"""

# Major library imports
from numpy import linspace
from scipy.special import jn

# Enthought library imports
from enable.api import Component, ComponentEditor
from traits.api import HasTraits, Instance
from traitsui.api import Item, Group, View

# Chaco imports
from chaco.api import ArrayPlotData, VPlotContainer, \
    Plot
from chaco.plotscrollbar import PlotScrollBar
from chaco.tools.api import PanTool, ZoomTool

#===============================================================================
# # Create the Chaco plot.
#===============================================================================
def _create_plot_component():

    # Create some x-y data series to plot
    x = linspace(-2.0, 10.0, 100)
    pd = ArrayPlotData(index = x)
    for i in range(5):
        pd.set_data("y" + str(i), jn(i,x))

    # Create some line plots of some of the data
    plot1 = Plot(pd, padding=50)
    plot1.plot(("index", "y0", "y1", "y2"), name="j_n, n<3", color="red")
    plot1.plot(("index", "y3"), name="j_3", color="blue")

    # Attach some tools to the plot
    plot1.tools.append(PanTool(plot1))
    zoom = ZoomTool(component=plot1, tool_mode="box", always_on=False)
    plot1.overlays.append(zoom)

    # Add the scrollbar
    hscrollbar = PlotScrollBar(component=plot1, axis="index", resizable="h",
                               height=15)
    plot1.padding_top = 0
    hscrollbar.force_data_update()

    # Create a container and add our plots
    container = VPlotContainer()
    container.add(plot1)
    container.add(hscrollbar)

    return container

#===============================================================================
# Attributes to use for the plot view.
size=(900,500)
title="Scrollbar example"

#===============================================================================
# # Demo class that is used by the demo.py application.
#===============================================================================
class Demo(HasTraits):
    plot = Instance(Component)

    traits_view = View(
                    Group(
                        Item('plot', editor=ComponentEditor(size=size),
                             show_label=False),
                        orientation = "vertical"),
                    resizable=True, title=title
                    )

    def _plot_default(self):
         return _create_plot_component()

demo = Demo()

if __name__ == "__main__":
    demo.configure_traits()

#--EOF---

########NEW FILE########
__FILENAME__ = tabbed_plots
"""
Tabbed plots with linked (shared) data ranges

Shows how to place plots in separate tabs. Also shows how two plots can
dynamically display the same range of data, so that a zoom or pan in one
plot will automatically be shown in the other.

In this example, the top panel plots a sin function. The bottom panel contains 
two tabs, plotting a tan function and a mixed trig function respectively.

The three plots are linked. The sin and mixed plots share both x- and y-axis
data ranges. The tan plot shares only its x-axis with the other two. 

Mousewheel zooms in or out. Left-mouse-drag pans. 
Typing "z", then left-mouse-drag, zooms to a specified region.

If you zoom or pan one plot, you will see changes in one or both axis ranges
of the other plots.
"""

from numpy import linspace, pi, sin, tan, cos

from traits.api import HasTraits, Instance
from traitsui.api import UItem, Tabbed, View, VGroup

from chaco.api import Plot, AbstractPlotData, ArrayPlotData
from chaco.tools.api import PanTool, ZoomTool
from enable.component_editor import ComponentEditor


class TabbedPlots(HasTraits):

    data = Instance(AbstractPlotData)

    plot_sin = Instance(Plot)
    plot_tan = Instance(Plot)
    plot_mixed = Instance(Plot)

    view = View(
        VGroup(
            # UItem is an unlabeled item
            UItem('plot_sin', editor=ComponentEditor(), dock='tab'),
            Tabbed(
                UItem('plot_tan', editor=ComponentEditor(), dock='tab'),
                UItem('plot_mixed', editor=ComponentEditor(), dock='tab'))
            ),
        title='Tabbed plots with shared data ranges',
        width=0.67,
        height=0.4,
        resizable=True
    )

    def create_plot(self, data, name, color):
        p = Plot(self.data)
        p.plot(data, name=name, color=color)
        p.tools.append(PanTool(p))
        p.overlays.append(ZoomTool(p))
        return p

    def create_plots(self):
        self.plot_sin = self.create_plot(("x", "ysin"), "sin plot", "red")
        self.plot_tan = self.create_plot(("x", "ytan"), "tan plot", "blue")
        self.plot_mixed = self.create_plot(("x", "ymix"), "mixed plot", "green")

        # The mixed plot will share both x and y ranges with the sin plot.
        # This 2d range is a single object shared by both plots. For its
        # initial value, we will use the range of the mixed plot, whose y-range
        # is auto-set to slightly larger than that of the sin plot.
        self.plot_sin.range2d = self.plot_mixed.range2d
        
        # The sin & mixed plots will share only their x range with the tan plot.
        # Again, this x-axis range is a single object shared by all 3 plots. 
        # It is contained within the 2d range shared by the sin and mixed plots.
        # (The independent variable, in this case x, is called "index" in chaco.
        # The dependent variable is called "value".)
        self.plot_tan.index_range = self.plot_sin.index_range

    def _data_changed(self):
        self.create_plots()


#===============================================================================
# # demo object that is used by the demo.py application.
#===============================================================================
x = linspace(-2*pi, 2*pi, 100)
demo = TabbedPlots(
            data = ArrayPlotData(x=x, 
                                 ysin=sin(x), 
                                 ytan=tan(x),
                                 ymix=sin(x)**2 + cos(x)))

if __name__ == "__main__":
    demo.configure_traits()

########NEW FILE########
__FILENAME__ = traits_editor
""" 1D Function plotter.

This example creates a simple 1D function examiner, illustrating the use of
ChacoPlotEditors for displaying simple plot relations, as well as TraitsUI
integration. Any 1D numpy/scipy.special function should work in the function
text box.
 - Left-drag pans the plot.
 - Mousewheel up and down zooms the plot in and out.
 - Pressing "z" brings up the Zoom Box, and you can click-drag a rectangular
   region to zoom.  If you use a sequence of zoom boxes, pressing alt-left-arrow
   and alt-right-arrow moves you forwards and backwards through the "zoom
   history".
"""

# Major library imports
from numpy import linspace, pi

# Enthought library imports
from traits.api import Array, Dict, Enum, HasTraits, Str
from traitsui.api import Item, View

# Chaco imports
from chaco.chaco_plot_editor import ChacoPlotEditor, \
                                                ChacoPlotItem


class Foo(HasTraits):

    # Public Traits
    xdata = Array
    plot_type = Enum("scatter", "line")
    eq = Str("sin(x)")

    # Default TraitsUI view
    traits_view = View(
                       ChacoPlotItem("xdata", "_ydata",
                                      type_trait="plot_type",

                                      # Basic axis and label properties
                                      show_label=False,
                                      resizable=True,
                                      orientation="h",
                                      x_label = "Index data",
                                      y_label = "Value data",

                                      # Plot properties
                                      color = "green",
                                      bgcolor = "white",

                                      # Specific to scatter plot
                                      marker = "circle",
                                      marker_size = 2,
                                      outline_color = "none",

                                      # Border, padding properties
                                      border_visible=True,
                                      border_width=1,
                                      padding_bg_color = "lightgray"),
                Item("plot_type"),
                Item("eq"),
                resizable=True,
                width=500, height=500)


    # Private Traits
    _d = Dict
    _ydata = Array

    def __init__(self, **kwtraits):
        super(Foo, self).__init__(**kwtraits)
        self._d = dict(x=self.xdata)
        exec "from scipy import *" in self._d
        exec "from scipy.special import *" in self._d
        self._ydata = eval(self.eq, self._d)

    def _eq_changed(self, old, new):
        try:
            self._ydata = eval(new, self._d)
        except:
            pass

#===============================================================================
# # demo object that is used by the demo.py application.
#===============================================================================
demo = Foo(xdata=linspace(-2*pi, 2*pi ,100), eq="sin(x)")

if __name__ == "__main__":
    demo.edit_traits(kind="modal")

########NEW FILE########
__FILENAME__ = zoomable_colorbar
"""
Scatterplot with zoomable/pannable colormap

Draws a colormapped scatterplot of random data. The colormap is dynamically
adjustable.

In addition to normal zooming and panning on the plot, the user can also
pan and zoom the colorbar to change the color mapping of the data values.

Left click will pan the colorbar's data region.  Right-drag will
select a zoom range.  Mousewheel up and down will zoom in and out on
the data bounds of the color bar.
"""

# Major library imports
from numpy import exp, sort
from numpy.random import random

# Enthought library imports
from enable.api import Component, ComponentEditor
from traits.api import HasTraits, Instance
from traitsui.api import Item, Group, View

# Chaco imports
from chaco.api import ArrayPlotData, ColorBar, \
                                 HPlotContainer, \
                                 LinearMapper, Plot, gist_earth
from chaco.tools.api import PanTool, ZoomTool

#===============================================================================
# # Create the Chaco plot.
#===============================================================================
def _create_plot_component():

    # Create some data
    numpts = 1000
    x = sort(random(numpts))
    y = random(numpts)
    color = exp(-(x**2 + y**2))

    # Create a plot data obect and give it this data
    pd = ArrayPlotData()
    pd.set_data("index", x)
    pd.set_data("value", y)
    pd.set_data("color", color)

    # Create the plot
    plot = Plot(pd)
    plot.plot(("index", "value", "color"),
              type="cmap_scatter",
              name="my_plot",
              color_mapper=gist_earth,
              marker = "square",
              fill_alpha = 0.5,
              marker_size = 8,
              outline_color = "black",
              border_visible = True,
              bgcolor = "white")

    # Tweak some of the plot properties
    plot.title = "Colormapped Scatter Plot with Pan/Zoom Color Bar"
    plot.padding = 50
    plot.x_grid.visible = False
    plot.y_grid.visible = False
    plot.x_axis.font = "modern 16"
    plot.y_axis.font = "modern 16"

    # Add pan and zoom to the plot
    plot.tools.append(PanTool(plot, constrain_key="shift"))
    zoom = ZoomTool(plot)
    plot.overlays.append(zoom)

    # Create the colorbar, handing in the appropriate range and colormap
    colorbar = ColorBar(index_mapper=LinearMapper(range=plot.color_mapper.range),
                        color_mapper=plot.color_mapper,
                        orientation='v',
                        resizable='v',
                        width=30,
                        padding=20)
    colorbar.plot = plot
    colorbar.padding_top = plot.padding_top
    colorbar.padding_bottom = plot.padding_bottom

    # Add pan and zoom tools to the colorbar
    colorbar.tools.append(PanTool(colorbar, constrain_direction="y", constrain=True))
    zoom_overlay = ZoomTool(colorbar, axis="index", tool_mode="range",
                            always_on=True, drag_button="right")
    colorbar.overlays.append(zoom_overlay)

    # Create a container to position the plot and the colorbar side-by-side
    container = HPlotContainer(plot, colorbar, use_backbuffer=True, bgcolor="lightgray")

    return container

#===============================================================================
# Attributes to use for the plot view.
size=(650,650)
title="Colormapped scatter plot"

#===============================================================================
# # Demo class that is used by the demo.py application.
#===============================================================================
class Demo(HasTraits):
    plot = Instance(Component)

    traits_view = View(
                    Group(
                        Item('plot', editor=ComponentEditor(size=size),
                             show_label=False),
                        orientation = "vertical"),
                    resizable=True, title=title
                    )

    def _plot_default(self):
         return _create_plot_component()

demo = Demo()

if __name__ == "__main__":
    demo.configure_traits()

########NEW FILE########
__FILENAME__ = bigdata
"""
Demonstrates chaco performance with large datasets.

There are 10 plots with 100,000 points each.  Right-click and drag to
create a range selection region.  The region can be moved around and
resized (drag the edges).  These interactions are very fast because
of the backbuffering built into chaco.

Zooming with the mousewheel and the zoombox (as described in simple_line.py)
is also available, but panning is not.
"""

# Major library imports
from scipy.special import jn
from numpy import arange

from chaco.example_support import COLOR_PALETTE
# Enthought library imports
from enable.api import Component, ComponentEditor
from traits.api import Bool, HasTraits, Instance
from traitsui.api import UItem, View

# Chaco imports
from chaco.api import OverlayPlotContainer, create_line_plot, add_default_axes, \
                                 add_default_grids
from chaco.tools.api import RangeSelection, RangeSelectionOverlay, ZoomTool

#===============================================================================
# # Create the Chaco plot.
#===============================================================================

# Do the plots use downsampling?
use_downsampling = False

def _create_plot_component(use_downsampling=False):

    container = OverlayPlotContainer(padding=40, bgcolor="lightgray",
                                     use_backbuffer = True,
                                     border_visible = True,
                                     fill_padding = True)

    numpoints = 100000
    low = -5
    high = 15.0
    x = arange(low, high+0.001, (high-low)/numpoints)

    # Plot some bessel functionsless ../en
    value_mapper = None
    index_mapper = None
    for i in range(10):
        y = jn(i, x)
        plot = create_line_plot((x,y), color=tuple(COLOR_PALETTE[i]), width=2.0)
        plot.use_downsampling = use_downsampling

        if value_mapper is None:
            index_mapper = plot.index_mapper
            value_mapper = plot.value_mapper
            add_default_grids(plot)
            add_default_axes(plot)
        else:
            plot.value_mapper = value_mapper
            value_mapper.range.add(plot.value)
            plot.index_mapper = index_mapper
            index_mapper.range.add(plot.index)
        if i%2 == 1:
            plot.line_style = "dash"
        plot.bgcolor = "white"
        container.add(plot)

    selection_overlay = RangeSelectionOverlay(component = plot)
    plot.tools.append(RangeSelection(plot))
    zoom = ZoomTool(plot, tool_mode="box", always_on=False)
    plot.overlays.append(selection_overlay)
    plot.overlays.append(zoom)

    return container

#===============================================================================
# Attributes to use for the plot view.
size = (600, 500)
title = "Million Point Plot"

#===============================================================================
# # Demo class that is used by the demo.py application.
#===============================================================================
class Demo(HasTraits):
    plot = Instance(Component)

    # FIXME: I am putting this in here just for consistency: however the plots
    # in Chaco don't have an implementation for downsampling yet, and so, this
    # trait is not exposed in the UI.
    use_downsampling = Bool

    traits_view = View(UItem('plot', editor=ComponentEditor()),
                       width=size[0], height=size[1], resizable=True,
                       title=title
                       )

    def _plot_default(self):
        return _create_plot_component(self.use_downsampling)

    def _use_downsampling_default(self):
        return use_downsampling

demo = Demo()

if __name__ == "__main__":
    demo.configure_traits()

#--EOF---

########NEW FILE########
__FILENAME__ = axis_tool

from enable.api import BaseTool, ColorTrait
from traits.api import Any, Bool, Dict, Enum, HasTraits, Int, List, Trait, Tuple

class RangeController(HasTraits):

    canvas = Any

    # The list of active plots and which of their ranges was set
    plots_ranges = List

    # Stores the old ranges
    _ranges = Dict

    def notify(self, axistool, rangename, type, event):
        plot = axistool.component
        range = getattr(plot, rangename)
        if (type == "down") and ((plot, rangename) not in self.plots_ranges):
            if len(self.plots_ranges) > 0:
                src_plot, src_rangename = self.plots_ranges[0]
                src_range = getattr(src_plot, src_rangename)
                self.link(src_range, plot, rangename)
            self.plots_ranges.append((plot, rangename))
        else:
            if (plot, rangename) in self.plots_ranges:
                if len(self.plots_ranges) > 1:
                    self.unlink(plot, rangename)
                self.plots_ranges.remove((plot, rangename))
        return True

    def link(self, src_range, dst_plot, dst_rangename):
        self._ranges[(dst_plot, dst_rangename)] = getattr(dst_plot, dst_rangename)
        setattr(dst_plot, dst_rangename, src_range)
        dst_plot.request_redraw()

    def unlink(self, plot, rangename):
        setattr(plot, rangename, self._ranges.pop((plot, rangename)))
        plot.request_redraw()


class AxisTool(BaseTool):

    # The object to notify when we've been clicked
    # We notify by calling its .notify method, which should have the
    # signature:
    #     should_handle_event = notify(axis_tool, axis, down_or_up, event)
    #
    # It should return a bool indicating whether or not we should process the
    # event.
    range_controller = Any

    down_tick_color = ColorTrait("red")
    down_axis_line_color = ColorTrait("red")
    down_tick_label_color = ColorTrait("red")
    down_bgcolor = ColorTrait("lightgray")
    down_border_visible = Bool(True)
    down_border_color = Trait(None, None, ColorTrait)

    _cached_tick_color = ColorTrait
    _cached_axis_line_color = ColorTrait
    _cached_tick_labl_color = ColorTrait
    _cached_bgcolor = ColorTrait
    _cached_border_visible = Bool(True)
    _cached_border_color = ColorTrait

    attr_list = ("tick_color", "axis_line_color", "tick_label_color", "bgcolor",
                 "border_visible", "border_color")

    def normal_left_down(self, event):
        if self.component is None:
            return
        plot = self.component
        if plot.index_axis.is_in(event.x, event.y):
            axis = plot.index_axis
            rangename = "index_range"
        elif plot.value_axis.is_in(event.x, event.y):
            axis = plot.value_axis
            rangename = "value_range"
        else:
            return

        # If we have a controller, we let it decide whether
        # or not we get to handle the event.
        if self.range_controller is not None:
            should_handle = self.range_controller.notify(self, rangename, "down", event)
            if not should_handle:
                return

        for attr in self.attr_list:
            cached = "_cached_" + attr
            down = "down_" + attr
            setattr(self, cached, getattr(axis, attr))
            if getattr(self, down) is not None:
                setattr(axis, attr, getattr(self, down))

        axis.request_redraw()
        plot._debug = True
        event.handled = True
        return

    def normal_left_up(self, event):
        if self.component is None:
            return
        plot = self.component
        if plot.index_axis.is_in(event.x, event.y):
            axis = plot.index_axis
            rangename = "index_range"
        elif plot.value_axis.is_in(event.x, event.y):
            axis = plot.value_axis
            rangename = "value_range"
        else:
            return

        if self.range_controller is not None:
            should_handle = self.range_controller.notify(self, rangename, "up", event)
            if not should_handle:
                return

        for attr in self.attr_list:
            cached = "_cached_" + attr
            setattr(axis, attr, getattr(self, cached))

        axis.request_redraw()
        event.handled = True
        return


class MPAxisTool(AxisTool):

    cur_bid = Int(-1)
    _last_blob_pos = Tuple

    def normal_blob_down(self, event):
        if self.cur_bid == -1:
            self.cur_bid = event.bid
            if hasattr(event, "bid"):
                event.window.capture_blob(self, event.bid,
                                          event.net_transform())
            self.normal_left_down(event)
            self._last_blob_pos = (event.x, event.y)

    def normal_blob_up(self, event):
        print "Axis blob up"
        if event.bid == self.cur_bid:
            if hasattr(event, "bid"):
                event.window.release_blob(event.bid)
            self.cur_bid = -1
            event.x, event.y = self._last_blob_pos
            self.normal_left_up(event)


########NEW FILE########
__FILENAME__ = canvas
#!/usr/bin/env python
"""
The main app for the PlotCanvas application
"""

# FIXME - this is broken

MULTITOUCH = False
DEBUG = False

# Major library imports
from copy import copy
from numpy import arange, fabs, linspace, pi, sin
from numpy import random
from scipy.special import jn


# Enthought library imports
from enable.api import Viewport, Window
from enable.tools.api import MoveTool, ResizeTool, ViewportPanTool
from enable.example_support import DemoFrame, demo_main
from traits.api import Any, Bool, Enum, Float, HasTraits, Instance, \
                                 List, Str


# Chaco imports
from chaco.api import AbstractOverlay, ArrayPlotData, \
        Plot, jet, ScatterPlot, LinePlot, LinearMapper
from chaco.tools.api import PanTool, ZoomTool , LegendTool

# Canvas imports
from chaco.plot_canvas import PlotCanvas
from chaco.plot_canvas_toolbar import PlotCanvasToolbar, PlotToolbarButton
from transient_plot_overlay import TransientPlotOverlay
from axis_tool import AxisTool, RangeController, MPAxisTool
from plot_clone_tool import PlotCloneTool, MPPlotCloneTool
from data_source_button import ButtonController, DataSourceButton
from mp_move_tool import MPMoveTool
from mp_viewport_pan_tool import MPViewportPanTool
#from canvas_grid import CanvasGrid

# Multitouch imports
if MULTITOUCH:
    from mptools import MPPanTool, MPDragZoom, MPLegendTool, \
            MPPanZoom, MPRangeSelection
    #AxisTool = MPAxisTool
    PlotCloneTool = MPPlotCloneTool

NUMPOINTS = 250
DATA = {
    "GOOG": random.uniform(-2.0, 10.0, NUMPOINTS),
    "MSFT": random.uniform(-2.0, 10.0, NUMPOINTS),
    "AAPL": random.uniform(-2.0, 10.0, NUMPOINTS),
    "YHOO": random.uniform(-2.0, 10.0, NUMPOINTS),
    "CSCO": random.uniform(-2.0, 10.0, NUMPOINTS),
    "INTC": random.uniform(-2.0, 10.0, NUMPOINTS),
    "ORCL": random.uniform(-2.0, 10.0, NUMPOINTS),
    "HPQ": random.uniform(-2.0, 10.0, NUMPOINTS),
    "DELL": random.uniform(-2.0, 10.0, NUMPOINTS),
    }



def add_basic_tools(plot):
    plot.tools.append(PanTool(plot))
    plot.tools.append(MoveTool(plot, drag_button="right"))
    zoom = ZoomTool(component=plot, tool_mode="box", always_on=False)
    plot.overlays.append(zoom)

def do_plot(name, pd):
    xname = name + "_x"
    yname = name + "_y"
    pd.set_data(xname, range(len(DATA[name])))
    pd.set_data(yname, DATA[name])

    plot = Plot(pd, padding = 30,
                unified_draw = True,
                border_visible = True,
                )
    plot.x_axis.visible = False
    plot.title = name
    plot.plot((xname, yname), name=name, type="line", color="blue",)
    return plot

def clone_renderer(r):
    """ Returns a clone of plot renderer r """
    basic_traits = ["orientation", "line_width", "color", "outline_color",
                    "bgcolor", "border_visible", "border_color", "visible",
                    "fill_padding", "resizable", "aspect_ratio",
                    "draw_layer", "draw_order", "border_width", "resizable",
                    "index", "value",]

    scatter_traits = ["custom_symbol", "marker", "marker_size", "selection_marker",
                      "selection_marker_size", "selection_line_width",
                      "selection_color"]

    line_traits = ["selected_color", "selected_line_style", "metadata_name",
                   "render_style"]

    if isinstance(r, ScatterPlot):
        return r.clone_traits(basic_traits + scatter_traits)
    elif isinstance(r, LinePlot):
        return r.clone_traits(basic_traits + line_traits)

def clone_plot(clonetool, drop_position):
    # A little sketchy...
    canvas = clonetool.component.container.component.component

    # Create a new Plot object
    oldplot = clonetool.component
    newplot = Plot(oldplot.data)
    basic_traits = ["orientation", "default_origin", "bgcolor", "border_color",
                    "border_width", "border_visible", "draw_layer", "unified_draw",
                    "fit_components", "fill_padding", "visible", "aspect_ratio",
                    "title"]

    for attr in basic_traits:
        setattr(newplot, attr, getattr(oldplot, attr))

    # copy the ranges
    dst = newplot.range2d
    src = oldplot.range2d
    #for attr in ('_low_setting', '_low_value', '_high_setting', '_high_value'):
    #    setattr(dst, attr, getattr(src, attr))
    dst._xrange.sources = copy(src._xrange.sources)
    dst._yrange.sources = copy(src._yrange.sources)

    newplot.padding = oldplot.padding
    newplot.bounds = oldplot.bounds[:]
    newplot.resizable = ""
    newplot.position = drop_position

    newplot.datasources = copy(oldplot.datasources)

    for name, renderers in oldplot.plots.items():
        newrenderers = []
        for renderer in renderers:
            new_r = clone_renderer(renderer)
            new_r.index_mapper = LinearMapper(range=newplot.index_range)
            new_r.value_mapper = LinearMapper(range=newplot.value_range)
            new_r._layout_needed = True
            new_r.invalidate_draw()
            new_r.resizable = "hv"
            newrenderers.append(new_r)
        newplot.plots[name] = newrenderers
    #newplot.plots = copy(oldplot.plots)

    for name, renderers in newplot.plots.items():
        newplot.add(*renderers)

    newplot.index_axis.title = oldplot.index_axis.title
    newplot.index_axis.unified_draw = True
    newplot.value_axis.title = oldplot.value_axis.title
    newplot.value_axis.unified_draw = True

    # Add new tools to the new plot
    newplot.tools.append(AxisTool(component=newplot,
        range_controller=canvas.range_controller))

    # Add tools to the new plot
    pan_traits = ["drag_button", "constrain", "constrain_key", "constrain_direction",
                  "speed"]
    zoom_traits = ["tool_mode", "always_on", "axis", "enable_wheel", "drag_button",
                   "wheel_zoom_step", "enter_zoom_key", "exit_zoom_key", "pointer",
                   "color", "alpha", "border_color", "border_size", "disable_on_complete",
                   "minimum_screen_delta", "max_zoom_in_factor", "max_zoom_out_factor"]
    move_traits = ["drag_button", "end_drag_on_leave", "cancel_keys", "capture_mouse",
                   "modifier_key"]

    if not MULTITOUCH:
        for tool in oldplot.tools:
            if isinstance(tool, PanTool):
                newtool = tool.clone_traits(pan_traits)
                newtool.component = newplot
                break
        else:
            newtool = PanTool(newplot)
        # Reconfigure the pan tool to always use the left mouse, because we will
        # put plot move on the right mouse button
        newtool.drag_button = "left"
        newplot.tools.append(newtool)

        for tool in oldplot.tools:
            if isinstance(tool, MoveTool):
                newtool = tool.clone_traits(move_traits)
                newtool.component = newplot
                break
        else:
            newtool = MoveTool(newplot, drag_button="right")
        newplot.tools.append(newtool)

        for tool in oldplot.tools:
            if isinstance(tool, ZoomTool):
                newtool = tool.clone_traits(zoom_traits)
                newtool.component = newplot
                break
        else:
            newtool = ZoomTool(newplot)
        newplot.tools.append(newtool)

    else:
        pz = MPPanZoom(newplot)
        #pz.pan.constrain = True
        #pz.pan.constrain_direction = "x"
        #pz.zoom.mode = "range"
        #pz.zoom.axis = "index"
        newplot.tools.append(MPPanZoom(newplot))
        #newplot.tools.append(MTMoveTool(

    newplot._layout_needed = True

    clonetool.dest.add(newplot)
    newplot.invalidate_draw()
    newplot.request_redraw()
    canvas.request_redraw()
    return


def make_toolbar(canvas):
    # Create the toolbar
    toolbar = PlotCanvasToolbar(bounds=[70, 200],
                                position=[50,350],
                                fill_padding=True,
                                bgcolor="lightgrey",
                                padding = 5,
                                align = "left",
                                )

    # Create the scatterplot
    pd = ArrayPlotData()
    scatterplot = Plot(pd, padding=15, bgcolor="white", unified_draw=True,
                       border_visible=True)
    if not MULTITOUCH:
        scatterplot.tools.append(PanTool(scatterplot, drag_button="right"))
        scatterplot.tools.append(ZoomTool(scatterplot))
    else:
        scatterplot.tools.append(MPPanZoom(scatterplot))
    scatterplot.overlays.append(PlotCloneTool(scatterplot, dest=canvas,
                                              plot_cloner=clone_plot))

    # Create the overlay
    overlay = TransientPlotOverlay(component=toolbar,
                                   overlay_component=scatterplot,
                                   bounds=[350,350],
                                   border_visible=True,
                                   visible = False,  # initially invisible
                                   )
    scatterplot.container = overlay

    # Create buttons
    controller = ButtonController()
    for name in DATA.keys():
        plot = do_plot(name, pd)
        if MULTITOUCH:
            plot.tools.append(MPPanZoom(plot))
        else:
            plot.tools.append(PanTool(plot, drag_button="right", constrain=True,
                                      constrain_direction="x"))
            plot.tools.append(ZoomTool(plot, tool_mode="range", axis="index",
                                         always_on=False))
        plot.overlays.append(PlotCloneTool(plot, dest=canvas,
                                           plot_cloner=clone_plot))
        plot_overlay = TransientPlotOverlay(component=toolbar,
                                            overlay_component=plot,
                                            border_visible=True,
                                            visible=False,
                                            )
        plot.container = plot_overlay
        button = DataSourceButton(label=name,
                                  bounds=[80,46],
                                  padding = 5,
                                  button_controller = controller,
                                  #canvas = canvas,
                                  plot_overlay = plot_overlay,
                                  plotname = name)
        toolbar.add(button)
        canvas.overlays.append(plot_overlay)
    controller.plot = scatterplot
    controller.plot_overlay = overlay
    canvas.overlays.append(overlay)

    return toolbar


class PlotFrame(DemoFrame):

    def _create_viewport(self):
        # Create a container and add our plots
        canvas = PlotCanvas()
        canvas.range_controller = RangeController(cavas = canvas)

        toolbar = make_toolbar(canvas)
        toolbar.component = canvas
        canvas.overlays.append(toolbar)

        viewport = Viewport(component=canvas)
        if MULTITOUCH:
            viewport.tools.append(MPViewportPanTool(viewport))
        else:
            viewport.tools.append(ViewportPanTool(viewport, drag_button="right"))
        return viewport

    def _create_window_mt(self):
        viewport = self._create_viewport()

        from enactable.configuration import arg_parser, get_global_config
        from enactable.enable.enable_blob_listener import BlobWindow
        from enactable.enable.blobprovider import NetworkBlobProvider
        parser = arg_parser()
        args = parser.parse_args()
        cfg = get_global_config()
        tconf = cfg.tconf
        tconf.from_arguments(args)

        provider = NetworkBlobProvider(host=tconf.Server.host, port=tconf.Server.port)
        provider.start()
        return BlobWindow(self, -1, component=viewport, blob_provider=provider)

    def _create_window_simple(self):
        viewport = self._create_viewport()
        return Window(self, -1, component=viewport)

    def _create_window(self):
        if MULTITOUCH:
            return self._create_window_mt()
        else:
            return self._create_window_simple()

if __name__ == "__main__":
    # Save demo so that it doesn't get garbage collected when run within
    # existing event loop (i.e. from ipython).
    demo = demo_main(PlotFrame, size=(1000,700), title="PlotCanvas")

# EOF

########NEW FILE########
__FILENAME__ = cliptest
#!/usr/bin/env python
"""
The main app for the PlotCanvas application
"""

from __future__ import with_statement

# Enthought library imports
from traits.api import Float
from enable.api import Window, Container, Component, Pointer
from enable.tools.api import MoveTool
from enable.example_support import DemoFrame, demo_main


class Box(Component):
    """
    The box moves wherever the user clicks and drags.
    """
    normal_pointer = Pointer("arrow")
    moving_pointer = Pointer("hand")

    offset_x = Float
    offset_y = Float

    fill_color = (0.8, 0.0, 0.1, 1.0)
    moving_color = (0.0, 0.8, 0.1, 1.0)

    resizable = ""

    def __init__(self, *args, **kw):
        Component.__init__(self, *args, **kw)

    def _draw_mainlayer(self, gc, view_bounds=None, mode="default"):
        with gc:
            gc.set_fill_color(self.fill_color)
            dx, dy = self.bounds
            x, y = self.position
            gc.clip_to_rect(x, y, dx, dy)
            gc.rect(x, y, dx, dy)
            gc.fill_path()

            ## draw line around outer box
            #gc.set_stroke_color((0,0,0,1))
            #gc.rect(self.outer_x, self.outer_y, self.outer_width, self.outer_height)
            #gc.stroke_path()

        return

    def normal_left_down(self, event):
        self.event_state = "moving"
        event.window.set_pointer(self.moving_pointer)
        event.window.set_mouse_owner(self, event.net_transform())
        self.offset_x = event.x - self.x
        self.offset_y = event.y - self.y
        event.handled = True
        return

    def moving_mouse_move(self, event):
        self.position = [event.x-self.offset_x, event.y-self.offset_y]
        event.handled = True
        self.request_redraw()
        return

    def moving_left_up(self, event):
        self.event_state = "normal"
        event.window.set_pointer(self.normal_pointer)
        event.window.set_mouse_owner(None)
        event.handled = True
        self.request_redraw()
        return

    def moving_mouse_leave(self, event):
        self.moving_left_up(event)
        event.handled = True
        return

class MainFrame(DemoFrame):
    def _create_window(self):
        a = Box(bounds=[75, 75], position=[50,50], fill_color=(1, 0, 0, 1))
        b = Box(bounds=[75, 75], position=[200,50], fill_color=(0, 1, 0, 1))
        c = Box(bounds=[75, 75], position=[50,200], fill_color=(0, 0, 1, 1))
        cont = Container(a, b, c, bounds=[400,400], border_visible=True, bgcolor="lightgray")
        #cont.unified_draw = True
        #cont.draw_layer = "background"
        cont2 = Container(bounds=[300,300], border_visible=True, bgcolor="cyan")
        cont.tools.append(MoveTool(cont, drag_button="left"))
        cont2.tools.append(MoveTool(cont2, drag_button="left"))
        outer = Container(cont, cont2, fit_window=True)
        return Window(self, -1, component=outer)


if __name__ == "__main__":
    # Save demo so that it doesn't get garbage collected when run within
    # existing event loop (i.e. from ipython).
    demo = demo_main(MainFrame, size=(800,800), title="ClipTest")


########NEW FILE########
__FILENAME__ = data_source_button

from random import choice
from traits.api import Any, Enum, HasTraits, Instance, Int, List, Str
from chaco.example_support import COLOR_PALETTE
from chaco.api import Plot
from chaco.plot_canvas_toolbar import PlotToolbarButton

DEBUG = False

class ButtonController(HasTraits):
    """ Tells buttons what to do

    Buttons defer to this when they are activated.
    """

    modifier = Enum("control", "shift", "alt")

    # The list of buttons that are currently "down"
    active_buttons = List

    # A reference to the Plot object that displays scatterplots of multiple
    # dataseries
    plot = Instance(Plot)

    # The transient plot overlay housing self.plot
    plot_overlay = Any

    # The name of the scatter plot in the Plot
    _scatterplot_name = "ButtonControllerPlot"

    def notify(self, button, type, event):
        """ Informs the controller that the particular **button** just
        got an event.  **Type** is either "up" or "down".  Event is the
        actual mouse event.
        """
        #control_down = getattr(event, self.modifier + "_down", False)
        control_down = True
        if DEBUG:
            print "[notify]", button.plotname, type, "control:", control_down
        if type == "down":
            if control_down and button in self.active_buttons:
                self.button_deselected(button)
            else:
                if not control_down:
                    # Deselect all current buttons and select the new one
                    [self.button_deselected(b) for b in self.active_buttons \
                            if b is not button]
                self.button_selected(button)
        else:  # type == "up"
            #if not control_down:
            if 1:
                self.button_deselected(button)
        return

    def button_selected(self, button):
        if DEBUG:
            print "active:", [b.plotname for b in self.active_buttons]
            print "new button selected:", button.plotname
        if button in self.active_buttons:
            return
        numbuttons = len(self.active_buttons)
        if numbuttons == 0:
            self.active_buttons.append(button)
            button.show_overlay()
        elif numbuttons == 1:
            self.active_buttons[0].hide_overlay()
            self.active_buttons.append(button)
            self.show_scatterplot(*self.active_buttons)
        elif numbuttons == 2:
            # Replace the last active button with the new one
            self.active_buttons[1].button_state = "up"
            self.active_buttons[1] = button
            self.hide_scatterplot()
            self.show_scatterplot(*self.active_buttons)
        else:
            return
        button.button_state = "down"
        return

    def button_deselected(self, button):
        if DEBUG:
            print "active:", [b.plotname for b in self.active_buttons]
            print "new button deselected:", button.plotname
        if button not in self.active_buttons:
            button.button_state = "up"
            return
        numbuttons = len(self.active_buttons)
        if numbuttons == 1:
            if button in self.active_buttons:
                self.active_buttons.remove(button)
            button.hide_overlay()
        elif numbuttons == 2:
            if button in self.active_buttons:
                self.active_buttons.remove(button)
                self.hide_scatterplot()
                remaining_button = self.active_buttons[0]
                remaining_button.show_overlay()
        else:
            return
        button.button_state = "up"
        return

    def show_scatterplot(self, b1, b2):
        if len(self.plot.plots) > 0:
            self.plot.delplot(*self.plot.plots.keys())

        cur_plot = self.plot.plot((b1.plotname+"_y", b2.plotname+"_y"),
                                  name=self._scatterplot_name,
                                  type="scatter",
                                  marker="square",
                                  color=tuple(choice(COLOR_PALETTE)),
                                  marker_size=8,
                                  )
        self.plot.index_axis.title = b1.plotname
        #self.plot.value_axis.title = b2.plotname
        self.plot.title = b1.plotname + " vs. " + b2.plotname
        self.plot_overlay.visible = True
        self.plot.request_redraw()

    def hide_scatterplot(self):
        if self._scatterplot_name in self.plot.plots:
            self.plot.delplot(self._scatterplot_name)
            self.plot.index_range.set_bounds("auto", "auto")
            self.plot.value_range.set_bounds("auto", "auto")
        self.plot_overlay.visible = False



class DataSourceButton(PlotToolbarButton):

    # A TransientPlotOverlay containing the timeseries plot of this datasource
    plot_overlay = Any

    plotname = Str

    canvas = Any

    #overlay_bounds = List()

    # Can't call this "controller" because it conflicts with old tool dispatch
    button_controller = Instance(ButtonController)

    # Override inherited trait
    label_color = (0,0,0,1)

    resizable = ""

    cur_bid = Int(-1)

    # The overlay to display when the user holds the mouse down over us.
    #_overlay = Instance(AbstractOverlay)

    def normal_left_down(self, event):
        self.button_state = "down"
        self.button_controller.notify(self, "down", event)
        event.handled = True
        self.request_redraw()

    def normal_left_up(self, event):
        self.button_state = "up"
        self.button_controller.notify(self, "up", event)
        event.handled = True
        self.request_redraw()

    def normal_blob_down(self, event):
        if self.cur_bid == -1:
            self.cur_bid = event.bid
            self.normal_left_down(event)
            if hasattr(event, "bid"):
                event.window.capture_blob(self, event.bid,
                                          event.net_transform())

    def normal_blob_up(self, event):
        if event.bid == self.cur_bid:
            if hasattr(event, "bid"):
                event.window.release_blob(event.bid)
            self.cur_bid = -1
            self.normal_left_up(event)

    def normal_mouse_leave(self, event):
        if event.left_down:
            return self.normal_left_up(event)

    def normal_mouse_enter(self, event):
        if event.left_down:
            return self.normal_left_down(event)

    def show_overlay(self):
        if self.plot_overlay is not None:
            self._do_layout()
            self.plot_overlay.visible = True
        self.request_redraw()
        return

    def hide_overlay(self):
        if self.plot_overlay is not None:
            self.plot_overlay.visible = False
        self.request_redraw()
        return

    def _do_layout(self):
        if self.canvas is not None:
            boff = self.canvas.bounds_offset
            self.plot_overlay.offset = (boff[0],
                    boff[1] + self.y - self.container.y + self.height/2)
        self.plot_overlay.do_layout()

########NEW FILE########
__FILENAME__ = mptools
""" A collection of Chaco tools that respond to a multi-pointer interface
"""
from numpy import asarray, dot, sqrt

# Enthought library imports
from traits.api import Delegate, Dict, Enum, Instance, Int, Property, Trait, Tuple, CArray

# Chaco imports
from chaco.api import BaseTool
from chaco.tools.api import PanTool, DragZoom, LegendTool, RangeSelection


BOGUS_BLOB_ID = -1

def l2norm(v):
    return sqrt(dot(v,v))

class MPPanTool(PanTool):
    cur_bid = Int(BOGUS_BLOB_ID)

    def normal_blob_down(self, event):
        if self.cur_bid == BOGUS_BLOB_ID:
            self.cur_bid = event.bid
            self._start_pan(event, capture_mouse=False)
            event.window.capture_blob(self, event.bid, event.net_transform())

    def panning_blob_up(self, event):
        if event.bid == self.cur_bid:
            self.cur_bid = BOGUS_BLOB_ID
            self._end_pan(event)

    def panning_blob_move(self, event):
        if event.bid == self.cur_bid:
            self._dispatch_stateful_event(event, "mouse_move")

    def panning_mouse_leave(self, event):
        """ Handles the mouse leaving the plot when the tool is in the 'panning'
        state.

        Don't end panning.
        """
        return

    def _end_pan(self, event):
        if hasattr(event, "bid"):
            event.window.release_blob(event.bid)
        PanTool._end_pan(self, event)


class MPDragZoom(DragZoom):

    speed = 1.0

    # The original dataspace points where blobs 1 and 2 went down
    _orig_low = CArray #Trait(None, None, Tuple)
    _orig_high = CArray #Trait(None, None, Tuple)

    # Dataspace center of the zoom action
    _center_pt = Trait(None, None, Tuple)

    # Maps blob ID numbers to the (x,y) coordinates that came in.
    _blobs = Dict()

    # Maps blob ID numbers to the (x0,y0) coordinates from blob_move events.
    _moves = Dict()

    # Properties to convert the dictionaries to map from blob ID numbers to
    # a single coordinate appropriate for the axis the range selects on.
    _axis_blobs = Property(Dict)
    _axis_moves = Property(Dict)

    def _convert_to_axis(self, d):
        """ Convert a mapping of ID to (x,y) tuple to a mapping of ID to just
        the coordinate appropriate for the selected axis.
        """
        if self.axis == 'index':
            idx = self.axis_index
        else:
            idx = 1-self.axis_index
        d2 = {}
        for id, coords in d.items():
            d2[id] = coords[idx]
        return d2

    def _get__axis_blobs(self):
        return self._convert_to_axis(self._blobs)

    def _get__axis_moves(self):
        return self._convert_to_axis(self._moves)

    def drag_start(self, event, capture_mouse=False):
        bid1, bid2 = sorted(self._moves)
        xy01, xy02 = self._moves[bid1], self._moves[bid2]
        self._orig_low, self._orig_high = map(asarray,
            self._map_coordinate_box(xy01, xy02))
        self.orig_center = (self._orig_high + self._orig_low) / 2.0
        self.orig_diag = l2norm(self._orig_high - self._orig_low)

        #DragZoom.drag_start(self, event, capture_mouse)
        self._original_xy = xy02
        c = self.component
        self._orig_screen_bounds = ((c.x,c.y), (c.x2,c.y2))
        self._original_data = (c.x_mapper.map_data(xy02[0]), c.y_mapper.map_data(xy02[1]))
        self._prev_y = xy02[1]
        if capture_mouse:
            event.window.set_pointer(self.drag_pointer)

    def normal_blob_down(self, event):
        if len(self._blobs) < 2:
            self._blobs[event.bid] = (event.x, event.y)
            event.window.capture_blob(self, event.bid,
                transform=event.net_transform())
            event.handled = True

    def normal_blob_up(self, event):
        self._handle_blob_leave(event)

    def normal_blob_move(self, event):
        self._handle_blob_move(event)

    def normal_blob_frame_end(self, event):
        if len(self._moves) == 2:
            self.event_state = "dragging"
            self.drag_start(event, capture_mouse=False)

    def dragging_blob_move(self, event):
        self._handle_blob_move(event)

    def dragging_blob_frame_end(self, event):
        # Get dataspace coordinates of the previous and new coordinates
        bid1, bid2 = sorted(self._moves)
        p1, p2 = self._blobs[bid1], self._blobs[bid2]
        low, high = map(asarray, self._map_coordinate_box(p1, p2))

        # Compute the amount of translation
        center = (high + low) / 2.0
        translation = center - self.orig_center

        # Computing the zoom factor.  We have the coordinates of the original
        # blob_down events, and we have a new box as well.  For now, just use
        # the relative sizes of the diagonals.
        diag = l2norm(high - low)
        zoom = self.speed * self.orig_diag / diag

        # The original screen bounds are used to test if we've reached max_zoom
        orig_screen_low, orig_screen_high = \
                map(asarray, self._map_coordinate_box(*self._orig_screen_bounds))
        new_low = center - zoom * (center - orig_screen_low) - translation
        new_high = center + zoom * (orig_screen_high - center) - translation

        for ndx in (0,1):
            if self._zoom_limit_reached(orig_screen_low[ndx],
                    orig_screen_high[ndx], new_low[ndx], new_high[ndx]):
                return

        c = self.component
        c.x_mapper.range.set_bounds(new_low[0], new_high[0])
        c.y_mapper.range.set_bounds(new_low[1], new_high[1])

        self.component.request_redraw()

    def dragging_blob_up(self, event):
        self._handle_blob_leave(event)

    def _handle_blob_move(self, event):
        if event.bid not in self._blobs:
            return
        self._blobs[event.bid] = event.x, event.y
        self._moves[event.bid] = event.x0, event.y0
        event.handled = True

    def _handle_blob_leave(self, event):
        if event.bid in self._blobs:
            del self._blobs[event.bid]
            self._moves.pop(event.bid, None)
            event.window.release_blob(event.bid)
        if len(self._blobs) < 2:
            self.event_state = "normal"


class MPPanZoom(BaseTool):
    """ This tool wraps a pan and a zoom tool, and automatically switches
    behavior back and forth depending on how many blobs are tracked on
    screen.
    """

    pan = Instance(MPPanTool)

    zoom = Instance(MPDragZoom)

    event_state = Enum("normal", "pan", "zoom")

    _blobs = Delegate('zoom')
    _moves = Delegate('zoom')

    def _dispatch_stateful_event(self, event, suffix):
        self.zoom.dispatch(event, suffix)
        event.handled = False
        self.pan.dispatch(event, suffix)
        if len(self._blobs) == 2:
            self.event_state = 'zoom'
        elif len(self._blobs) == 1:
            self.event_state = 'pan'
        elif len(self._blobs) == 0:
            self.event_state = 'normal'
        else:
            assert len(self._blobs) <= 2
        if suffix == 'blob_up':
            event.window.release_blob(event.bid)
        elif suffix == 'blob_down':
            event.window.release_blob(event.bid)
            event.window.capture_blob(self, event.bid, event.net_transform())
            event.handled = True

    def _component_changed(self, old, new):
        self.pan.component = new
        self.zoom.component = new

    def _pan_default(self):
        return MPPanTool(self.component)

    def _zoom_default(self):
        return MPDragZoom(self.component)


class MPLegendTool(LegendTool):

    event_state = Enum("normal", "dragging")

    cur_bid = Int(-1)

    def normal_blob_down(self, event):
        if self.cur_bid == -1 and self.is_draggable(event.x, event.y):
            self.cur_bid = event.bid
            self.drag_start(event)

    def dragging_blob_up(self, event):
        if event.bid == self.cur_bid:
            self.cur_bid = -1
            self.drag_end(event)

    def dragging_blob_move(self, event):
        if event.bid == self.cur_bid:
            self.dragging(event)

    def drag_start(self, event):
        if self.component:
            self.original_padding = self.component.padding
            if hasattr(event, "bid"):
                event.window.capture_blob(self, event.bid,
                                          event.net_transform())
            else:
                event.window.set_mouse_owner(self, event.net_transform())
            self.mouse_down_position = (event.x,event.y)
            self.event_state = "dragging"
            event.handled = True
        return

    def drag_end(self, event):
        if hasattr(event, "bid"):
            event.window.release_blob(event.bid)
        self.event_state = "normal"
        LegendTool.drag_end(self, event)



class MPRangeSelection(RangeSelection):

    # Maps blob ID numbers to the (x,y) coordinates that came in.
    _blobs = Dict()

    # Maps blob ID numbers to the (x0,y0) coordinates from blob_move events.
    _moves = Dict()

    # Properties to convert the dictionaries to map from blob ID numbers to
    # a single coordinate appropriate for the axis the range selects on.
    _axis_blobs = Property(Dict)
    _axis_moves = Property(Dict)

    def _convert_to_axis(self, d):
        """ Convert a mapping of ID to (x,y) tuple to a mapping of ID to just
        the coordinate appropriate for the selected axis.
        """
        if self.axis == 'index':
            idx = self.axis_index
        else:
            idx = 1-self.axis_index
        d2 = {}
        for id, coords in d.items():
            d2[id] = coords[idx]
        return d2

    def _get__axis_blobs(self):
        return self._convert_to_axis(self._blobs)

    def _get__axis_moves(self):
        return self._convert_to_axis(self._moves)

    def normal_blob_down(self, event):
        if len(self._blobs) < 2:
            self._blobs[event.bid] = (event.x, event.y)
            event.window.capture_blob(self, event.bid,
                transform=event.net_transform())
            event.handled = True

    def normal_blob_up(self, event):
        self._handle_blob_leave(event)

    def normal_blob_frame_end(self, event):
        if len(self._blobs) == 2:
            self.event_state = "selecting"
            #self.drag_start(event, capture_mouse=False)
            #self.selecting_mouse_move(event)
            self._set_sizing_cursor(event)
            self.selection = sorted(self._axis_blobs.values())

    def selecting_blob_move(self, event):
        if event.bid in self._blobs:
            self._blobs[event.bid] = event.x, event.y
            self._moves[event.bid] = event.x0, event.y0

    def selecting_blob_up(self, event):
        self._handle_blob_leave(event)

    def selecting_blob_frame_end(self, event):
        if self.selection is None:
            return
        elif len(self._blobs) == 2:
            axis_index = self.axis_index
            low = self.plot.position[axis_index]
            high = low + self.plot.bounds[axis_index] - 1
            p1, p2 = self._axis_blobs.values()
            # XXX: what if p1 or p2 is out of bounds?
            m1 = self.mapper.map_data(p1)
            m2 = self.mapper.map_data(p2)
            low_val = min(m1, m2)
            high_val = max(m1, m2)
            self.selection = (low_val, high_val)
            self.component.request_redraw()
        elif len(self._moves) == 1:
            id, p0 = self._axis_moves.items()[0]
            m0 = self.mapper.map_data(p0)
            low, high = self.selection
            if low <= m0 <= high:
                m1 = self.mapper.map_data(self._axis_blobs[id])
                dm = m1 - m0
                self.selection = (low+dm, high+dm)

    def selected_blob_down(self, event):
        if len(self._blobs) < 2:
            self._blobs[event.bid] = (event.x, event.y)
            event.window.capture_blob(self, event.bid,
                transform=event.net_transform())
            event.handled = True

    def selected_blob_move(self, event):
        if event.bid in self._blobs:
            self._blobs[event.bid] = event.x, event.y
            self._moves[event.bid] = event.x0, event.y0

    def selected_blob_frame_end(self, event):
        self.selecting_blob_frame_end(event)

    def selected_blob_up(self, event):
        self._handle_blob_leave(event)

    def _handle_blob_leave(self, event):
        self._moves.pop(event.bid, None)
        if event.bid in self._blobs:
            del self._blobs[event.bid]
            event.window.release_blob(event.bid)

        # Treat the blob leave as a selecting_mouse_up event
        self.selecting_right_up(event)

        if len(self._blobs) < 2:
            self.event_state = "selected"


########NEW FILE########
__FILENAME__ = mp_move_tool

from traits.api import Int
from enable.tools.api import MoveTool

class MPMoveTool(MoveTool):

    cur_bid = Int(-1)

    def normal_blob_down(self, event):
        if self.cur_bid == -1:
            self.cur_bid = event.bid
            self.normal_left_down(event)

    def dragging_blob_up(self, event):
        if event.bid == self.cur_bid:
            self.cur_bid = -1
            self.normal_left_up(event)




########NEW FILE########
__FILENAME__ = mp_viewport_pan_tool

from traits.api import Int, Tuple
from enable.tools.api import ViewportPanTool

class MPViewportPanTool(ViewportPanTool):

    cur_bid = Int(-1)

    _last_blob_pos = Tuple

    def normal_blob_down(self, event):
        if self.cur_bid == -1 and self.is_draggable(event.x, event.y):
            self.cur_bid = event.bid
            self.drag_start(event)

    def dragging_blob_up(self, event):
        if event.bid == self.cur_bid:
            self.cur_bid = -1
            self.drag_end(event)

    def dragging_blob_move(self, event):
        if event.bid == self.cur_bid:
            self._last_blob_pos = (event.x, event.y)
            self.dragging(event)

    def drag_start(self, event):
        if self.component:
            self.original_padding = self.component.padding
            if hasattr(event, "bid"):
                event.window.capture_blob(self, event.bid,
                                          event.net_transform())
            else:
                event.window.set_mouse_owner(self, event.net_transform())
            self._last_blob_pos = (event.x, event.y)
            self.mouse_down_position = (event.x,event.y)
            self.event_state = "dragging"
            event.handled = True
            ViewportPanTool.drag_start(self, event)
        return

    def drag_end(self, event):
        event.x, event.y = self._last_blob_pos
        if hasattr(event, "bid"):
            event.window.release_blob(event.bid)
        self.event_state = "normal"
        ViewportPanTool.drag_end(self, event)


########NEW FILE########
__FILENAME__ = plot_clone_tool
""" Makes a copy of the plot in the overlay and adds it to the canvas.
"""

from __future__ import with_statement

# Enthought library imports
from traits.api import Bool, Callable, Enum, Float, Instance, Int, Trait, Tuple
from enable.api import Container

# Chaco imports
from chaco.api import AbstractOverlay
from enable.tools.api import DragTool


class PlotCloneTool(AbstractOverlay, DragTool):
    """ On a drag operation, draws an overlay of self.component underneath
    the cursor.  On drag_end, a copy of the plot is dropped onto the
    self.dest container.
    """

    # The container to add the cloned plot to
    dest = Instance(Container)

    # A function that gets called on drag_end.  It gets passed this tool
    # and the position at which to place the new cloned plot.
    plot_cloner = Callable

    # The amount to fade the plot when we draw as overlay
    alpha = Float(0.5)

    # The possible event states for this tool.
    event_state = Enum("normal", "dragging")

    capture_mouse = True

    # The (x,y) position of the "last" mouse position we received
    _offset = Trait(None, None, Tuple)

    # The relative position of the mouse_down_position to the origin
    # of the plot's coordinate system
    _offset_from_plot = Tuple

    # This is set to True before we attempt to move the plot, so that
    # we do not get called again, in case we are an overlay on the plot
    # we are drawing.
    _recursion_check = Bool(False)

    def overlay(self, component, gc, view_bounds=None, mode="normal"):
        if self._recursion_check:
            return
        else:
            if self._offset is not None and (self._offset[0] > 10 or
                    self._offset[1] > 10):
                with gc:
                    gc.clear_clip_path()
                    gc.translate_ctm(*self._offset)
                    gc.set_alpha(self.alpha)
                    self._recursion_check = True
                    self.component._draw(gc, view_bounds, mode)
                    self._recursion_check = False

    def drag_start(self, event):
        """ Called when the drag operation starts.

        Implements DragTool.
        """
        self._offset = (event.x - self.mouse_down_position[0],
                        event.y - self.mouse_down_position[1])
        self._offset_from_plot = (self.mouse_down_position[0] - self.component.x,
                                  self.mouse_down_position[1] - self.component.y)
        self.visible = True
        event.handled = True

    def dragging(self, event):
        self._offset = (event.x - self.mouse_down_position[0],
                        event.y - self.mouse_down_position[1])
        self.component.request_redraw()

    def drag_end(self, event):
        if self.plot_cloner is not None:
            # Recreate the event transform history and figure out the coordinates
            # of the event in the Canvas's coordinate system
            offset = self._offset_from_plot
            drop_position = (event.x - offset[0], event.y - offset[1])
            self.plot_cloner(self, drop_position)
        self._offset = None
        self.visible = False
        self.component.request_redraw()


class MPPlotCloneTool(PlotCloneTool):

    cur_bid = Int(-1)

    _last_blob_pos = Tuple

    def normal_blob_down(self, event):
        if self.cur_bid == -1 and self.is_draggable(event.x, event.y):
            self.cur_bid = event.bid
            self.drag_start(event)

    def dragging_blob_up(self, event):
        if event.bid == self.cur_bid:
            self.cur_bid = -1
            self.drag_end(event)

    def dragging_blob_move(self, event):
        if event.bid == self.cur_bid:
            self.dragging(event)
            self._last_blob_pos = (event.x, event.y)

    def drag_start(self, event):
        if self.component:
            self.original_padding = self.component.padding
            if hasattr(event, "bid"):
                event.window.capture_blob(self, event.bid,
                                          event.net_transform())
            else:
                event.window.set_mouse_owner(self, event.net_transform())
            self.mouse_down_position = (event.x,event.y)
            self.event_state = "dragging"
            event.handled = True
        PlotCloneTool.drag_start(self, event)
        return

    def drag_end(self, event):
        if hasattr(event, "bid"):
            event.window.release_blob(event.bid)
        self.event_state = "normal"
        if self.plot_cloner is not None:
            offset = self._offset_from_plot
            drop_position = self._last_blob_pos
            if len(drop_position) == 2:
                self.plot_cloner(self, (drop_position[0] - offset[0],
                                        drop_position[1] - offset[1]))
        self._offset = None

########NEW FILE########
__FILENAME__ = transient_plot_overlay

from __future__ import with_statement

from enable.api import Component
from traits.api import Enum, Float, Instance, Trait, Tuple

from chaco.api import AbstractOverlay, BasePlotContainer


class TransientPlotOverlay(BasePlotContainer, AbstractOverlay):
    """ Allows an arbitrary plot component to be overlaid on top of another one.
    """

    # The PlotComponent to draw as an overlay
    overlay_component = Instance(Component)

    # Where this overlay should draw relative to our .component
    align = Enum("right", "left", "top", "bottom")

    # The amount of space between the overlaying component and the underlying
    # one.  This is either horizontal or vertical (depending on the value of
    # self.align), but is not both.
    margin = Float(10)

    # An offset to apply in X and Y
    offset = Trait(None, None, Tuple)

    # Override default values of some inherited traits
    unified_draw = True
    resizable = ""

    def _bounds_default(self):
        return [450, 250]

    def _clear_bounds(self, gc, view_bounds):
        if view_bounds is None:
            view_bounds = (0,0, self.width, self.height)
        gc.clip_to_rect(*view_bounds)
        gc.set_fill_color((1.0,1.0,1.0,1.0))
        gc.begin_path()
        gc.rect(*view_bounds)
        gc.fill_path()

    def overlay(self, component, gc, view_bounds=None, mode="normal"):
        self._do_layout()
        with gc:
            self._clear_bounds(gc, view_bounds)
            self.overlay_component._draw(gc, view_bounds, mode)

    # TODO: Implement this more intelligently than the one in BasePlotContainer
    #def get_preferred_size(self):
    #    pass

    def _do_layout(self):
        component = self.component
        bounds = self.outer_bounds

        if self.align in ("right", "left"):
            y = component.outer_y -(bounds[1] - component.outer_height) / 2
            if self.align == "right":
                x = component.outer_x2 + self.margin
            else:
                x = component.outer_x - bounds[0] - self.margin

        else:   # "top", "bottom"
            x = component.outer_x -(bounds[0] - component.outer_width) / 2
            if self.align == "top":
                y = component.outer_y2 + self.margin
            else:
                y = component.outer_y - bounds[1] - self.margin

        if self.offset is not None:
            x += self.offset[0]
            y += self.offset[1]

        overlay_component = self.overlay_component
        overlay_component.outer_bounds = self.outer_bounds
        overlay_component.outer_position = [x, y]
        overlay_component._layout_needed = True
        overlay_component.do_layout()

    def dispatch(self, event, suffix):
        if self.visible and self.overlay_component.is_in(event.x, event.y):
            return self.overlay_component.dispatch(event, suffix)



########NEW FILE########
__FILENAME__ = chaco_trait_editor
""" An example of how to use Chaco to render a visual Traits UI editor.
This particular editor allows the user to set two endpoints of an
interval.
"""
from __future__ import with_statement

from traits.etsconfig.api import ETSConfig
if ETSConfig.toolkit == 'wx':
    from traitsui.wx.editor import Editor
else:
    from traitsui.qt4.editor import Editor

from traitsui.editor_factory import EditorFactory

from enable.window import Window
from enable.api import ColorTrait

from chaco.api import OverlayPlotContainer, create_line_plot, \
     LinePlot
from chaco.tools.api import RangeSelection, RangeSelectionOverlay

from traits.api import Int, TraitType, Instance, Float

from math import pi


class Interval(TraitType):
    """Trait that represents an interval.

    """
    info_text = "an interval (x,y) where x < y"

    def __init__(self, low=0, high=1, **metadata):
        value = (low, high)
        TraitType.__init__(self, value, **metadata)
        self.value = (low, high)

    def validate(self, object, name, value):
        low, high = value

        if low <= high:
            return value

        self.error(object, name, value)

    def create_editor(self):
        return IntervalEditor()


class IntervalEditorFactory(EditorFactory):
    width = Int(300)
    height = Int(40)

    def simple_editor(self, ui, object, name, description, parent):
        trait = object.trait(name).trait_type
        low, high = trait.value
        return IntervalEditorImpl(parent, factory=self, ui=ui,
                                  object=object, name=name,
                                  description=description,
                                  low=low,
                                  high=high)

class RangeKnobsOverlay(RangeSelectionOverlay):
    radius = Float(3)
    low_color = ColorTrait("red")
    high_color = ColorTrait("red")

    # Override the default alpha and border color, inherited from
    # RangeSelectionOverlay; these are more appropriate for our application.
    alpha = Float(0.8)
    border_color = ColorTrait("black")

    def overlay(self, component, gc, view_bounds=None, mode="normal"):
        mid_y = component.position[1] + component.bounds[1]/2
        # Draw each of a possibly disjoint set of selections
        coords = self._get_selection_screencoords()
        for coord in coords:
            start, end = coord
            with gc:
                gc.set_alpha(self.alpha)
                gc.set_stroke_color(self.border_color_)
                gc.set_line_width(self.border_width)

                gc.rect(start + self.radius, mid_y - 1,
                        (end - start - 2*self.radius), 2)
                gc.draw_path()

                gc.set_fill_color(self.low_color_)
                self._circle(gc, start, mid_y, self.radius)
                # Have to stroke/fill the path before we change out the
                # fill color
                gc.draw_path()

                gc.set_fill_color(self.high_color_)
                self._circle(gc, end, mid_y, self.radius)
                gc.draw_path()

    def _circle(self, gc, x, y, radius):
        with gc:
            gc.translate_ctm(x, y)
            gc.arc(0, 0, 2*radius, 0, 2*pi)


class IntervalEditorImpl(Editor):
    low = Int
    high = Int
    plot = Instance(LinePlot)

    def init(self, parent):
        factory = self.factory
        container = OverlayPlotContainer(bgcolor='transparent',
                                         padding=0, spacing=0)

        window = Window(parent, component=container)

        interval = self.high - self.low
        data = ([self.low, self.high], [0.5]*2)
        plot = create_line_plot(data, color='black', bgcolor="sys_window")
        plot.x_mapper.range.low = self.low - interval*0.1
        plot.x_mapper.range.high = self.high + interval*0.1
        plot.y_mapper.range.high = 1.0
        plot.y_mapper.range.low = 0.0

        range_selection = RangeSelection(plot, left_button_selects=True)
        # Do not allow the user to reset the range
        range_selection.event_state = "selected"
        range_selection.deselect = lambda x: None
        range_selection.on_trait_change(self.update_interval, 'selection')

        plot.tools.append(range_selection)
        plot.overlays.append(RangeKnobsOverlay(plot))
        self.plot = plot
        container.add(self.plot)

        # To set the low and high, we're actually going to set the
        # 'selection' metadata on the line plot to the tuple (low,high).
        plot.index.metadata["selections"] = (0, 1.0)

        # Tell the editor what to display
        self.control = window.control
        if ETSConfig.toolkit == 'wx':
            self.control.SetSize((factory.width, factory.height))
        else:
            self.control.setMaximumSize(factory.width, factory.height)

    def update_interval(self, value):
        low, high = value

        low = max(low, 0)
        high = min(high, 1)

        self.plot.index.metadata['selections'] = (low, high)
        self.value = (low, high)

    def update_editor(self):
        pass

# The user normally uses the factory as if it were an editor, e.g.:
#
#   View(Item('interval', editor=IntervalEditor()))
#
IntervalEditor = IntervalEditorFactory



# --- Demonstration ---

if __name__ == "__main__":
    from traits.api import HasTraits
    from traitsui.api import View, Item
    class IntervalTest(HasTraits):
        interval = Interval(low=0, high=1)

        traits_view = View(Item('interval',
                                editor=IntervalEditor()
                                ),
                           resizable=True)

    it = IntervalTest()
    it.configure_traits()

########NEW FILE########
__FILENAME__ = coordinate_line_overlay_demo
"""
Demonstration of the Chaco overlay CoordinateLineOverlay.

A CoordinateLineOverlay is a Chaco overlay that draws "infinite"
vertical and horizontal lines in a Chaco Plot.  In this demo,
two instances of CoordinateLineOverlay are added to the overlays
of a Plot containing a single line plot.

Zoom out, pan around, and notice that the blue solid lines and
the red dashed lines are always drawn all the way across the
window.  They do not have end points.
"""

import numpy as np

from traits.api import HasTraits, Instance, Array
from traitsui.api import View, HGroup, UItem

from enable.api import ComponentEditor

from chaco.api import Plot, ArrayPlotData
from chaco.tools.api import PanTool, ZoomTool
from chaco.overlays.coordinate_line_overlay import CoordinateLineOverlay


class PlotExample(HasTraits):

    # 1D arrays of coordinates where a line should be drawn.
    x1 = Array(dtype=np.float64)
    y1 = Array(dtype=np.float64)
    x2 = Array(dtype=np.float64)
    y2 = Array(dtype=np.float64)

    time_plot = Instance(Plot)

    time_plot_data = Instance(ArrayPlotData)

    # These is used in `time_plot` to mark special times.
    line_overlay1 = Instance(CoordinateLineOverlay)
    line_overlay2 = Instance(CoordinateLineOverlay)

    traits_view = \
        View(
            HGroup(
                UItem('time_plot', editor=ComponentEditor(height=20)),
            ),
            title="Demo",
            width=1000, height=640, resizable=True,
        )

    #------------------------------------------------------------------------
    # Trait change handlers
    #------------------------------------------------------------------------

    def _x1_changed(self):
        self.line_overlay1.index_data = self.x1

    def _y1_changed(self):
        self.line_overlay1.value_data = self.y1

    def _x2_changed(self):
        self.line_overlay2.index_data = self.x2

    def _y2_changed(self):
        self.line_overlay2.value_data = self.y2

    #------------------------------------------------------------------------
    # Trait defaults
    #------------------------------------------------------------------------

    def _x1_default(self):
        return np.array([1.8, 8.4])

    def _x2_default(self):
        return np.array([3.25])

    def _y2_default(self):
        return np.array([5.25])

    def _time_plot_data_default(self):
        t = np.linspace(0, 10, 201)
        y = (0.5 * t + 0.1 * np.sin(0.4 * 2 * np.pi * t) +
                0.3 * (t + 2) * (8 - t) * np.cos(0.33 * 2 * np.pi * t))
        data = ArrayPlotData(t=t, y=y)
        return data

    def _time_plot_default(self):
        time_plot = Plot(self.time_plot_data)

        time_plot.plot(('t', 'y'))

        time_plot.index_axis.title = "Time"

        time_plot.tools.append(PanTool(time_plot))

        zoomtool = ZoomTool(time_plot, drag_button='right',
                                                    always_on=True)
        time_plot.overlays.append(zoomtool)

        lines1 = CoordinateLineOverlay(component=time_plot,
                    index_data=self.x1,
                    value_data=self.y1,
                    color=(0.75, 0.25, 0.25, 0.75),
                    line_style='dash', line_width=1)
        time_plot.underlays.append(lines1)
        self.line_overlay1 = lines1

        lines2 = CoordinateLineOverlay(component=time_plot,
                    index_data=self.x2,
                    value_data=self.y2,
                    color=(0.2, 0.5, 1.0, 0.75),
                    line_width=3)
        time_plot.underlays.append(lines2)
        self.line_overlay2 = lines2

        return time_plot


demo = PlotExample()


if __name__ == "__main__":
    ##demo.edit_traits()
    demo.configure_traits()

########NEW FILE########
__FILENAME__ = cursor_tool_demo
"""
Cursor tool

A cursor tool lets you drag vertical and horizontal lines whose intersection
defines one point on the plot.

Left-button drag to move the cursors round.

Right-drag to pan the plots. 'z'-key to Zoom

"""
# Major library imports
import numpy

# Enthought library imports
from chaco.api import create_line_plot, OverlayPlotContainer, \
             HPlotContainer, Plot, ArrayPlotData, jet
from chaco.tools.api import PanTool, ZoomTool
from chaco.tools.cursor_tool import CursorTool, BaseCursorTool
from enable.component_editor import ComponentEditor
from traits.api import HasTraits, Instance, DelegatesTo
from traitsui.api import View, Item, HGroup, VGroup


class CursorTest(HasTraits):
    plot = Instance(HPlotContainer)
    cursor1 = Instance(BaseCursorTool)
    cursor2 = Instance(BaseCursorTool)

    cursor1pos = DelegatesTo('cursor1', prefix='current_position')
    cursor2pos = DelegatesTo('cursor2', prefix='current_position')

    def __init__(self):
        #The delegates views don't work unless we caller the superclass __init__
        super(CursorTest, self).__init__()

        container = HPlotContainer(padding=0, spacing=20)
        self.plot = container
        #a subcontainer for the first plot.
        #I'm not sure why this is required. Without it, the layout doesn't work right.
        subcontainer = OverlayPlotContainer(padding=40)
        container.add(subcontainer)

        #make some data
        index = numpy.linspace(-10,10,512)
        value = numpy.sin(index)

        #create a LinePlot instance and add it to the subcontainer
        line = create_line_plot([index, value], add_grid=True,
                                add_axis=True, index_sort='ascending',
                                orientation = 'h')
        subcontainer.add(line)

        #here's our first cursor.
        csr = CursorTool(line,
                        drag_button="left",
                        color='blue')
        self.cursor1 = csr
        #and set it's initial position (in data-space units)
        csr.current_position = 0.0, 0.0

        #this is a rendered component so it goes in the overlays list
        line.overlays.append(csr)

        #some other standard tools
        line.tools.append(PanTool(line, drag_button="right"))
        line.overlays.append(ZoomTool(line))

        #make some 2D data for a colourmap plot
        xy_range = (-5, 5)
        x = numpy.linspace(xy_range[0], xy_range[1] ,100)
        y = numpy.linspace(xy_range[0], xy_range[1] ,100)
        X,Y = numpy.meshgrid(x, y)
        Z = numpy.sin(X)*numpy.arctan2(Y,X)

        #easiest way to get a CMapImagePlot is to use the Plot class
        ds = ArrayPlotData()
        ds.set_data('img', Z)

        img = Plot(ds, padding=40)
        cmapImgPlot = img.img_plot("img",
                     xbounds = xy_range,
                     ybounds = xy_range,
                     colormap = jet)[0]

        container.add(img)

        #now make another cursor
        csr2 = CursorTool(cmapImgPlot,
                           drag_button='left',
                           color='white',
                           line_width=2.0
                           )
        self.cursor2 = csr2

        csr2.current_position = 1.0, 1.5

        cmapImgPlot.overlays.append(csr2)

        #add some standard tools. Note, I'm assigning the PanTool to the
        #right mouse-button to avoid conflicting with the cursors
        cmapImgPlot.tools.append(PanTool(cmapImgPlot, drag_button="right"))
        cmapImgPlot.overlays.append(ZoomTool(cmapImgPlot))


    traits_view = View(VGroup(
                            HGroup(Item('plot',
                                        editor=ComponentEditor(),
                                        resizable=True, springy=True,
                                        show_label=False),
                                        springy=True),
                            HGroup(Item('cursor1pos', width=300),
                                   Item('cursor2pos', width=300))),
                        title="Cursor Tool Demo",
                        resizable=True,
                        width=800,
                        height=420)

#===============================================================================
# # demo object that is used by the demo.py application.
#===============================================================================
demo = CursorTest()

if __name__=='__main__':
    demo.configure_traits()


########NEW FILE########
__FILENAME__ = data_labels
#!/usr/bin/env python
"""
Draws a line plot with several points labelled.  Demonstrates how to annotate
plots.

Left-drag pans the plot.

Mousewheel up and down zooms the plot in and out.

Pressing "z" brings up the Zoom Box, and you can click-drag a rectangular
region to zoom.  If you use a sequence of zoom boxes, pressing control-y
and control-z (Meta-y and Meta-z on Mac) moves you forwards and backwards
through the "zoom history".

Right-drag is enabled on some of the labels.
"""

# Major library imports
from numpy import linspace
from scipy.special import jn

# Enthought library imports
from enable.api import Component, ComponentEditor
from traits.api import Float, HasTraits, Instance, Int
from traitsui.api import Item, View

# Chaco imports
from chaco.api import create_line_plot, add_default_axes, add_default_grids, \
                      OverlayPlotContainer, DataLabel
from chaco.example_support import COLOR_PALETTE
from chaco.tools.api import PanTool, ZoomTool, DataLabelTool


class PlotExample(HasTraits):
    plot = Instance(Component)
    numpoints = Int(100)
    low = Float(-5.0)
    high = Float(15.0)

    traits_view = View(Item('plot', editor=ComponentEditor(),
                            show_label=False),
                       width=800, height=700, resizable=True,
                       title="Data label example")

    def _plot_default(self):

        container = OverlayPlotContainer(padding=50, fill_padding=True,
                                         bgcolor="lightgray",
                                         use_backbuffer=True)

        # Create the initial X-series of data
        numpoints = self.numpoints
        low = self.low
        high = self.high
        x = linspace(low, high, numpoints + 1)
        y = jn(0, x)
        plot = create_line_plot((x, y), color=tuple(COLOR_PALETTE[0]),
                                width=2.0)
        plot.index.sort_order = "ascending"
        plot.bgcolor = "white"
        plot.border_visible = True
        add_default_grids(plot)
        add_default_axes(plot)

        # Add some tools
        plot.tools.append(PanTool(plot))
        zoom = ZoomTool(plot, tool_mode="box", always_on=False)
        plot.overlays.append(zoom)

        # Add a dynamic label.  This can be dragged and moved around using the
        # right mouse button.  Note the use of padding to offset the label
        # from its data point.
        label = DataLabel(component=plot, data_point=(x[40], y[40]),
                          label_position="top left", padding=40,
                          bgcolor="lightgray",
                          border_visible=False)
        plot.overlays.append(label)
        tool = DataLabelTool(label, drag_button="right", auto_arrow_root=True)
        label.tools.append(tool)

        # Add some static labels.
        label2 = DataLabel(component=plot, data_point=(x[20], y[20]),
                           label_position="bottom right",
                           border_visible=False,
                           bgcolor="transparent",
                           marker_color="blue",
                           marker_line_color="transparent",
                           marker="diamond",
                           font='modern 14',
                           arrow_visible=False)
        plot.overlays.append(label2)

        label3 = DataLabel(component=plot, data_point=(x[80], y[80]),
                           label_position="top", padding_bottom=20,
                           marker_color="transparent",
                           marker_size=8,
                           marker="circle",
                           arrow_visible=False)
        plot.overlays.append(label3)

        # This label uses label_style='bubble'.
        label4 = DataLabel(component=plot, data_point=(x[60], y[60]),
                           border_padding=10,
                           marker_color="red",
                           marker_size=3,
                           label_position=(20, 50),
                           label_style='bubble',
                           label_text="Something interesting",
                           label_format="at x=%(x).2f, y=%(y).2f",
                           font='modern 18',
                           bgcolor=(1, 1, 0.75, 1),
                          )
        plot.overlays.append(label4)
        tool4 = DataLabelTool(label4, drag_button="right",
                              auto_arrow_root=True)
        label4.tools.append(tool4)

        # Another 'bubble' label.  This one sets arrow_min_length=20, so
        # the arrow is not drawn when the label is close to the data point.
        label5 = DataLabel(component=plot, data_point=(x[65], y[65]),
                           border_padding=10,
                           marker_color="green",
                           marker_size=4,
                           show_label_coords=False,
                           label_style='bubble',
                           label_position=(25, 5),
                           label_text="Label with\narrow_min_length=20",
                           border_visible=False,
                           arrow_min_length=20,
                           font='modern 14',
                           bgcolor=(0.75, 0.75, 0.75, 1),
                          )
        plot.overlays.append(label5)
        tool5 = DataLabelTool(label5, drag_button="right",
                              auto_arrow_root=True)
        label5.tools.append(tool5)

        container.add(plot)

        return container

demo = PlotExample()

if __name__ == "__main__":
    demo.configure_traits()

########NEW FILE########
__FILENAME__ = data_view
"""
Example of how to use a DataView and bare renderers to create plots
"""

from numpy import linspace, sin, cos

# Enthought library imports.
from chaco.api import DataView, ArrayDataSource, ScatterPlot, \
                      LinePlot, LinearMapper
from chaco.tools.api import PanTool, ZoomTool
from enable.api import Component, ComponentEditor
from traits.api import HasTraits, Instance
from traitsui.api import UItem, View

class PlotExample(HasTraits):
    plot = Instance(Component)

    traits_view = View(UItem('plot', editor=ComponentEditor()),
                       width=700, height=600, resizable=True,
                       title="Dataview + renderer example"
                       )

    def _plot_default(self):
        x = linspace(-5, 10, 500)
        y = sin(x)
        y2 = 0.5 * cos(2*x)

        view = DataView(border_visible = True)
        scatter = ScatterPlot(index = ArrayDataSource(x),
                              value = ArrayDataSource(y),
                              marker = "square",
                              color = "red",
                              outline_color = "transparent",
                              index_mapper = LinearMapper(range=view.index_range),
                              value_mapper = LinearMapper(range=view.value_range))

        line = LinePlot(index = scatter.index,
                        value = ArrayDataSource(y2),
                        color = "blue",
                        index_mapper = LinearMapper(range=view.index_range),
                        value_mapper = LinearMapper(range=view.value_range))

        # Add the plot's index and value datasources to the dataview's
        # ranges so that it can auto-scale and fit appropriately
        view.index_range.sources.append(scatter.index)
        view.value_range.sources.append(scatter.value)
        view.value_range.sources.append(line.value)

        # Add the renderers to the dataview.  The z-order is determined
        # by the order in which renderers are added.
        view.add(scatter)
        view.add(line)
        view.tools.append(PanTool(view))
        view.overlays.append(ZoomTool(view))

        return view


demo = PlotExample()

if __name__ == "__main__":
    demo.configure_traits()

########NEW FILE########
__FILENAME__ = demo
#-------------------------------------------------------------------------------
#
#  Copyright (c) 2009-2010, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: Vibha Srinivasan
#  Date: 02/03/2009
#
#-------------------------------------------------------------------------------

""" Run the Chaco demo.
"""

from traitsui.extras.demo import demo

# Uncomment the config_filename portion to see a tree editor based on the
# examples.cfg file.
demo(use_files=True,
     config_filename='demo.cfg',
     title = 'Chaco Demos'
    )


########NEW FILE########
__FILENAME__ = depth
import numpy
from chaco.api import ToolbarPlot, ArrayPlotData
from chaco.tools.api import LineInspector
from enable.component_editor import ComponentEditor
from traits.api import HasTraits, Instance
from traitsui.api import UItem, View

class MyPlot(HasTraits):
    """ Plot where depth is the index such that the plot is vertical
        and the origin is the upper left
    """
    plot = Instance(ToolbarPlot)

    traits_view = View(UItem('plot', editor=ComponentEditor()),
                       width=600, height=600, resizable=True
                      )

    def __init__(self, depth, data_series, **kw):
        super(MyPlot, self).__init__(**kw)

        plot_data = ArrayPlotData(index=depth)
        plot_data.set_data('data_series', data_series)
        self.plot = ToolbarPlot(plot_data, orientation='v', origin='top left')
        line = self.plot.plot(('index', 'data_series'))[0]

        line_inspector = LineInspector(component=line, write_metadata=True)
        line.tools.append(line_inspector)
        line.overlays.append(line_inspector)


depth = numpy.arange(1.0, 100.0, 0.1)
data_series = numpy.sin(depth) + depth/10.0

my_plot = MyPlot(depth, data_series)
my_plot.configure_traits()

########NEW FILE########
__FILENAME__ = domain_limits
import numpy

from chaco.plot import Plot, ArrayPlotData
from chaco.api import ToolbarPlot
from chaco.tools.api import PanTool, ZoomTool
from enable.api import ComponentEditor
from traits.api import Instance, HasTraits
from traitsui.api import View, Item


class ExamplePlotApp(HasTraits):

    plot = Instance(Plot)

    traits_view = View(Item('plot', editor=ComponentEditor(),
                            width = 600, height = 600,
                            show_label=False),
                            resizable=True)

    def __init__(self, index, series1, series2, **kw):
        super(ExamplePlotApp, self).__init__(**kw)
        plot_data = ArrayPlotData(index=index)
        plot_data.set_data('series1', series1)
        plot_data.set_data('series2', series2)

        self.plot = ToolbarPlot(plot_data)
        line_plot = self.plot.plot(('index', 'series1'), color='auto')[0]

        # Add pan and zoom tools
        line_plot.tools.append(PanTool(line_plot))
        line_plot.tools.append(ZoomTool(line_plot))

        # Set the domain_limits
        line_plot.index_mapper.domain_limits = (3.3, 6.6)

index = numpy.arange(1.0, 10., 0.01)
series1 = (100.0 + index) / (100.0 - 20*index**2 + 5.0*index**4)
series2 = (100.0 + index) / (100.0 - 20*index**2 + 5.0*index**3)
demo = ExamplePlotApp(index, series1, series2)

if __name__== '__main__':
    demo.configure_traits()

########NEW FILE########
__FILENAME__ = edit_line
#!/usr/bin/env python
"""
Allows editing of a line plot.

Left-dragging a point will move its position.

Right-drag pans the plot.

Mousewheel up and down zooms the plot in and out.

Pressing "z" brings up the Zoom Box, and you can click-drag a rectangular
region to zoom.  If you use a sequence of zoom boxes, pressing control-y and
control-z  (use Meta-y and Meta-z on Mac) moves you forwards and backwards
through the "zoom history".
"""

# Major library imports
from numpy import linspace
from scipy.special import jn

from chaco.example_support import COLOR_PALETTE

# Enthought library imports
from enable.tools.api import DragTool
from enable.api import Component, ComponentEditor
from traits.api import HasTraits, Instance, Int, Tuple
from traitsui.api import UItem, View

# Chaco imports
from chaco.api import add_default_axes, add_default_grids, \
        OverlayPlotContainer, PlotLabel, ScatterPlot, create_line_plot
from chaco.tools.api import PanTool, ZoomTool



class PointDraggingTool(DragTool):

    component = Instance(Component)

    # The pixel distance from a point that the cursor is still considered
    # to be 'on' the point
    threshold = Int(5)

    # The index of the point being dragged
    _drag_index = Int(-1)

    # The original dataspace values of the index and value datasources
    # corresponding to _drag_index
    _orig_value = Tuple

    def is_draggable(self, x, y):
        # Check to see if (x,y) are over one of the points in self.component
        if self._lookup_point(x, y) is not None:
            return True
        else:
            return False

    def normal_mouse_move(self, event):
        plot = self.component

        ndx = plot.map_index((event.x, event.y), self.threshold)
        if ndx is None:
            if plot.index.metadata.has_key('selections'):
                del plot.index.metadata['selections']
        else:
            plot.index.metadata['selections'] = [ndx]

        plot.invalidate_draw()
        plot.request_redraw()


    def drag_start(self, event):
        plot = self.component
        ndx = plot.map_index((event.x, event.y), self.threshold)
        if ndx is None:
            return
        self._drag_index = ndx
        self._orig_value = (plot.index.get_data()[ndx], plot.value.get_data()[ndx])

    def dragging(self, event):
        plot = self.component

        data_x, data_y = plot.map_data((event.x, event.y))

        plot.index._data[self._drag_index] = data_x
        plot.value._data[self._drag_index] = data_y
        plot.index.data_changed = True
        plot.value.data_changed = True
        plot.request_redraw()

    def drag_cancel(self, event):
        plot = self.component
        plot.index._data[self._drag_index] = self._orig_value[0]
        plot.value._data[self._drag_index] = self._orig_value[1]
        plot.index.data_changed = True
        plot.value.data_changed = True
        plot.request_redraw()

    def drag_end(self, event):
        plot = self.component
        if plot.index.metadata.has_key('selections'):
            del plot.index.metadata['selections']
        plot.invalidate_draw()
        plot.request_redraw()

    def _lookup_point(self, x, y):
        """ Finds the point closest to a screen point if it is within self.threshold

        Parameters
        ==========
        x : float
            screen x-coordinate
        y : float
            screen y-coordinate

        Returns
        =======
        (screen_x, screen_y, distance) of datapoint nearest to the input *(x,y)*.
        If no data points are within *self.threshold* of *(x,y)*, returns None.
        """

        if hasattr(self.component, 'get_closest_point'):
            # This is on BaseXYPlots
            return self.component.get_closest_point((x,y), threshold=self.threshold)

        return None


#===============================================================================
# # Create the Chaco plot.
#===============================================================================
def _create_plot_component():

    container = OverlayPlotContainer(padding = 50, fill_padding = True,
                                     bgcolor = "lightgray", use_backbuffer=True)

    # Create the initial X-series of data
    numpoints = 30
    low = -5
    high = 15.0
    x = linspace(low, high, numpoints)
    y = jn(0, x)

    lineplot = create_line_plot((x,y), color=tuple(COLOR_PALETTE[0]), width=2.0)
    lineplot.selected_color = "none"
    scatter = ScatterPlot(index = lineplot.index,
                       value = lineplot.value,
                       index_mapper = lineplot.index_mapper,
                       value_mapper = lineplot.value_mapper,
                       color = tuple(COLOR_PALETTE[0]),
                       marker_size = 5)
    scatter.index.sort_order = "ascending"

    scatter.bgcolor = "white"
    scatter.border_visible = True

    add_default_grids(scatter)
    add_default_axes(scatter)

    scatter.tools.append(PanTool(scatter, drag_button="right"))

    # The ZoomTool tool is stateful and allows drawing a zoom
    # box to select a zoom region.
    zoom = ZoomTool(scatter, tool_mode="box", always_on=False)
    scatter.overlays.append(zoom)

    scatter.tools.append(PointDraggingTool(scatter))

    container.add(lineplot)
    container.add(scatter)

    # Add the title at the top
    container.overlays.append(PlotLabel("Line Editor",
                              component=container,
                              font = "swiss 16",
                              overlay_position="top"))

    return container


#===============================================================================
# Attributes to use for the plot view.
size=(800,700)
title="Simple line plot"

#===============================================================================
# # Demo class that is used by the demo.py application.
#===============================================================================
class Demo(HasTraits):
    plot = Instance(Component)

    traits_view = View(UItem('plot', editor=ComponentEditor()),
                       width=size[0], height=size[1], resizable=True,
                       title=title
                       )

    def _plot_default(self):
         return _create_plot_component()

demo = Demo()

if __name__ == "__main__":
    demo.configure_traits()

#--EOF---

########NEW FILE########
__FILENAME__ = correlations

from numpy import linspace, random, zeros, arange, cumprod
import time

# ETS imports (non-chaco)
from enable.component_editor import ComponentEditor
from traits.api import HasTraits, Instance, Int, List, Str, Enum, \
        on_trait_change, Any, DelegatesTo
from traitsui.api import Item, View, HSplit, VGroup, EnumEditor

# Chaco imports
from chaco.api import ArrayPlotData, Plot, PlotAxis, \
        ScatterInspectorOverlay
from chaco.scales.api import CalendarScaleSystem
from chaco.scales_tick_generator import ScalesTickGenerator
from chaco.example_support import COLOR_PALETTE
from chaco.tools.api import PanTool, ZoomTool, RangeSelection, \
        RangeSelectionOverlay, LegendTool


def create_dates(numpoints, units="days"):
    """ Returns **numpoints** number of dates that evenly bracket the current
    date and time.  **units** should be one of "weeks", "days", "hours"
    "minutes", or "seconds".
    """
    units_map = { "weeks" : 7*24*3600,
                  "days" : 24*3600,
                  "hours" : 3600,
                  "minutes" : 60,
                  "seconds" : 1 }
    now = time.time()
    dt = units_map[units]
    dates = linspace(now, now+numpoints*dt, numpoints)
    return dates

class PlotApp(HasTraits):

    plotdata = Instance(ArrayPlotData)
    numpoints = Int(300)
    symbols = List()

    sym1 = Enum(values="symbols")
    sym2 = Enum(values="symbols")

    returns_plot = Instance(Plot)
    times_ds = Any()   # arraydatasource for the time axis data
    corr_plot = Instance(Plot)
    corr_renderer = Any()

    traits_view = View(
            HSplit(
                Item('returns_plot', editor=ComponentEditor(),
                    show_label = False),
                VGroup(
                    VGroup(
                        Item('sym1', width=-225),
                        Item('sym2', width=-225),
                    ),
                    Item('corr_plot', editor=ComponentEditor(),
                        show_label = False, width=-275),
                ),
            ),
            width=1024, height=500,
            resizable=True,
            title = "Correlations of returns")

    def __init__(self, *symbols, **kwtraits):
        super(PlotApp, self).__init__(symbols=list(symbols), **kwtraits)
        self._create_data(*symbols)
        self._create_returns_plot()
        self._create_corr_plot()
        if len(self.symbols) > 1:
            self.sym2 = self.symbols[1]

        return

    def _create_returns_plot(self):
        plot = Plot(self.plotdata)
        plot.legend.visible = True
        #FIXME: The legend move tool doesn't seem to quite work right now
        #plot.legend.tools.append(LegendTool(plot.legend))
        plot.x_axis = None
        x_axis = PlotAxis(plot, orientation="bottom",
                        tick_generator=ScalesTickGenerator(scale=CalendarScaleSystem()))
        plot.overlays.append(x_axis)
        plot.x_grid.tick_generator = x_axis.tick_generator
        for i, name in enumerate(self.plotdata.list_data()):
            if name == "times":
                continue
            renderer = plot.plot(("times", name), type="line", name=name,
                                  color=tuple(COLOR_PALETTE[i]))[0]

        # Tricky: need to set auto_handle_event on the RangeSelection
        # so that it passes left-clicks to the PanTool
        # FIXME: The range selection is still getting the initial left down
        renderer.tools.append(RangeSelection(renderer, left_button_selects = False,
            auto_handle_event = False))
        plot.tools.append(PanTool(plot, drag_button="left", constrain=True,
            constrain_direction="x"))
        plot.overlays.append(ZoomTool(plot, tool_mode="range", max_zoom_out=1.0))
        # Attach the range selection to the last renderer; any one will do
        self._range_selection_overlay = RangeSelectionOverlay(renderer,
                                    metadata_name="selections")
        renderer.overlays.append(self._range_selection_overlay)
        # Grab a reference to the Time axis datasource and add a listener to its
        # selections metadata
        self.times_ds = renderer.index
        self.times_ds.on_trait_change(self._selections_changed, 'metadata_changed')
        self.returns_plot = plot

    def _create_corr_plot(self):
        plot = Plot(self.plotdata, padding=0)
        plot.padding_left = 25
        plot.padding_bottom = 25
        plot.tools.append(PanTool(plot))
        plot.overlays.append(ZoomTool(plot))
        self.corr_plot = plot

    def _create_data(self, *names):
        numpoints = self.numpoints
        plotdata = ArrayPlotData(times = create_dates(numpoints))
        for name in names:
            plotdata.set_data(name, cumprod(random.lognormal(0.0, 0.04, size=numpoints)))
        self.plotdata = plotdata

    def _selections_changed(self, event):
        if self.corr_renderer is None:
            return
        if not isinstance(event, dict) or "selections" not in event:
            return
        corr_index = self.corr_renderer.index
        selections = event["selections"]
        if selections is None:
            corr_index.metadata.pop("selections", None)
            return
        else:
            low, high = selections
            data = self.times_ds.get_data()
            low_ndx = data.searchsorted(low)
            high_ndx = data.searchsorted(high)
            corr_index.metadata["selections"] = arange(low_ndx, high_ndx+1, 1, dtype=int)
            self.corr_plot.request_redraw()

    @on_trait_change("sym1,sym2")
    def _update_corr_symbols(self):
        plot = self.corr_plot
        if self.corr_renderer is not None:
            # Remove the old one
            plot.remove(self.corr_renderer)
            self.corr_renderer = None

        self.corr_renderer = plot.plot((self.sym1, self.sym2),
                                type="scatter", color="blue")[0]
        self.corr_renderer.overlays.append(ScatterInspectorOverlay(self.corr_renderer,
                selection_color = "lightgreen"))
        plot.request_redraw()


demo = PlotApp("AAPL", "GOOG", "MSFT")
if __name__ == "__main__":
    demo.configure_traits()


########NEW FILE########
__FILENAME__ = stock_prices
"""
Implementation of a standard financial plot visualization using Chaco
renderers and scales.

In the main price plot area, mouse wheel zooms and mouse drag pans (if
the plot is not at the edge of the time series data).  In the bottom
overview plot area, right-click-drag selects a range of times to display
on the top two plots.  Once a region is selected, it can be moved
around by left-dragging or resized by left-dragging one of its
edges.
"""

# Major library imports
from numpy import abs, cumprod, linspace, random
import time

from enable.example_support import DemoFrame, demo_main

# Enthought library imports
from enable.api import Window

# Chaco imports
from chaco.api import ArrayDataSource, BarPlot, DataRange1D, \
        LinePlot, LinearMapper, VPlotContainer, PlotAxis, \
        FilledLinePlot, add_default_grids
from chaco.tools.api import PanTool, ZoomTool, RangeSelection, \
        RangeSelectionOverlay

from chaco.scales.api import CalendarScaleSystem
from chaco.scales_tick_generator import ScalesTickGenerator


def create_dates(numpoints, units="days"):
    """ Returns **numpoints** number of dates that evenly bracket the current
    date and time.  **units** should be one of "weeks", "days", "hours"
    "minutes", or "seconds".
    """
    units_map = { "weeks" : 7*24*3600,
                  "days" : 24*3600,
                  "hours" : 3600,
                  "minutes" : 60,
                  "seconds" : 1 }
    now = time.time()
    dt = units_map[units]
    dates = linspace(now, now+numpoints*dt, numpoints)
    return dates


class PlotFrame(DemoFrame):

    def _create_price_plots(self, times, prices, mini_height=75):
        """ Creates the two plots of prices and returns them.  One of the
        plots can be zoomed and panned, and the other plot (smaller) always
        shows the full data.

        *dates* and *prices* are two data sources.
        """

        # Create the price plot
        price_plot = FilledLinePlot(index = times, value = prices,
                        index_mapper = LinearMapper(range=DataRange1D(times)),
                        value_mapper = LinearMapper(range=DataRange1D(prices)),
                        edge_color = "blue",
                        face_color = "paleturquoise",
                        bgcolor = "white",
                        border_visible = True)

        # Add pan and zoom
        price_plot.tools.append(PanTool(price_plot, constrain=True,
                                        constrain_direction="x"))
        price_plot.overlays.append(ZoomTool(price_plot, drag_button="right",
                                              always_on=True,
                                              tool_mode="range",
                                              axis="index",
                                              max_zoom_out_factor=1.0,
                                             ))

        # Create the miniplot
        miniplot = LinePlot(index = times, value = prices,
                        index_mapper = LinearMapper(range=DataRange1D(times)),
                        value_mapper = LinearMapper(range=DataRange1D(prices)),
                        color = "black",
                        border_visible = True,
                        bgcolor = "white",
                        height = mini_height,
                        resizable = "h")

        # Add a range overlay to the miniplot that is hooked up to the range
        # of the main price_plot
        range_tool = RangeSelection(miniplot)
        miniplot.tools.append(range_tool)
        range_overlay = RangeSelectionOverlay(miniplot, metadata_name="selections")
        miniplot.overlays.append(range_overlay)
        range_tool.on_trait_change(self._range_selection_handler, "selection")

        # Attach a handler that sets the tool when the plot's index range changes
        self.range_tool = range_tool
        price_plot.index_range.on_trait_change(self._plot_range_handler, "updated")

        return price_plot, miniplot


    def _range_selection_handler(self, event):
        # The event obj should be a tuple (low, high) in data space
        if event is not None:
            low, high = event
            self.price_plot.index_range.low = low
            self.price_plot.index_range.high = high
        else:
            self.price_plot.index_range.set_bounds("auto", "auto")

    def _plot_range_handler(self, event):
        if event is not None:
            low, high = event
            if "auto" not in (low, high):
                self.range_tool.selection = (low, high)

    def _create_vol_plot(self, times, volumes, height=100):
        "Creates and returns the volume plot"
        index_range = self.price_plot.index_range
        vol_plot = BarPlot(index = times, value = volumes,
                       index_mapper = LinearMapper(range=index_range),
                       value_mapper = LinearMapper(range=DataRange1D(volumes)),
                       line_color = "transparent",
                       fill_color = "black",
                       bar_width = 1.0,
                       bar_width_type = "screen",
                       antialias = False,
                       height = 100,
                       resizable = "h",
                       bgcolor = "white",
                       border_visible = True)
        vol_plot.tools.append(PanTool(vol_plot, constrain=True,
                                      constrain_direction="x"))
        return vol_plot

    def _create_window(self):

        # Create the data and datasource objects
        # In order for the date axis to work, the index data points need to
        # be in units of seconds since the epoch.  This is because we are using
        # the CalendarScaleSystem, whose formatters interpret the numerical values
        # as seconds since the epoch.
        numpoints = 500
        index = create_dates(numpoints)
        returns = random.lognormal(0.01, 0.1, size=numpoints)
        price = 100.0 * cumprod(returns)
        volume = abs(random.normal(1000.0, 1500.0, size=numpoints) + 2000.0)

        time_ds = ArrayDataSource(index)
        vol_ds = ArrayDataSource(volume, sort_order="none")
        price_ds = ArrayDataSource(price, sort_order="none")

        # Create the price plots
        price_plot, mini_plot = self._create_price_plots(time_ds, price_ds)
        price_plot.index_mapper.domain_limits = (index[0], index[-1])
        self.price_plot = price_plot
        self.mini_plot = mini_plot

        # Create the volume plot
        vol_plot = self._create_vol_plot(time_ds, vol_ds)
        vol_plot.index_mapper.domain_limits = (index[0], index[-1])

        # Set the plot's bottom axis to use the Scales ticking system
        ticker = ScalesTickGenerator(scale=CalendarScaleSystem())
        for plot in price_plot, mini_plot, vol_plot:
            bottom_axis = PlotAxis(plot, orientation="bottom",
                                   tick_generator = ticker)
            plot.overlays.append(bottom_axis)
            plot.overlays.append(PlotAxis(plot, orientation="left"))
            hgrid, vgrid = add_default_grids(plot)
            vgrid.tick_generator = bottom_axis.tick_generator

        container = VPlotContainer(bgcolor = "lightgray",
                                   spacing = 40,
                                   padding = 50,
                                   fill_padding=False)
        container.add(mini_plot, vol_plot, price_plot)

        return Window(self, -1, component=container)

if __name__ == "__main__":
    # Save demo so that it doesn't get garbage collected when run within
    # existing event loop (i.e. from ipython).
    demo = demo_main(PlotFrame, size=(800,600),
                     title="Stock price and volume")

########NEW FILE########
__FILENAME__ = financial_plot
"""
Implementation of a standard financial plot visualization using Chaco
renderers and scales.
"""

# Major library imports
from numpy import abs, arange, cumprod, random

# Enthought library imports
from enable.api import Component, ComponentEditor
from traits.api import HasTraits, Instance
from traitsui.api import Item, Group, View

# Chaco imports
from chaco.api import ArrayDataSource, BarPlot, DataRange1D, \
        LinearMapper, VPlotContainer, PlotAxis, FilledLinePlot, \
        add_default_grids, PlotLabel
from chaco.tools.api import PanTool, ZoomTool

#===============================================================================
# # Create the Chaco plot.
#===============================================================================
def _create_plot_component():

    # Create the data and datasource objects
    numpoints = 500
    index = arange(numpoints)
    returns = random.lognormal(0.01, 0.1, size=numpoints)
    price = 100.0 * cumprod(returns)
    volume = abs(random.normal(1000.0, 1500.0, size=numpoints) + 2000.0)

    time_ds = ArrayDataSource(index)
    vol_ds = ArrayDataSource(volume, sort_order="none")
    price_ds = ArrayDataSource(price, sort_order="none")

    xmapper = LinearMapper(range=DataRange1D(time_ds))
    vol_mapper = LinearMapper(range=DataRange1D(vol_ds))
    price_mapper = LinearMapper(range=DataRange1D(price_ds))

    price_plot = FilledLinePlot(index = time_ds, value = price_ds,
                                index_mapper = xmapper,
                                value_mapper = price_mapper,
                                edge_color = "blue",
                                face_color = "paleturquoise",
                                alpha = 0.5,
                                bgcolor = "white",
                                border_visible = True)
    add_default_grids(price_plot)
    price_plot.overlays.append(PlotAxis(price_plot, orientation='left'))
    price_plot.overlays.append(PlotAxis(price_plot, orientation='bottom'))
    price_plot.tools.append(PanTool(price_plot, constrain=True,
                                    constrain_direction="x"))
    price_plot.overlays.append(ZoomTool(price_plot, drag_button="right",
                                          always_on=True,
                                          tool_mode="range",
                                          axis="index"))

    vol_plot = BarPlot(index = time_ds, value = vol_ds,
                       index_mapper = xmapper,
                       value_mapper = vol_mapper,
                       line_color = "transparent",
                       fill_color = "black",
                       bar_width = 1.0,
                       bar_width_type = "screen",
                       antialias = False,
                       height = 100,
                       resizable = "h",
                       bgcolor = "white",
                       border_visible = True)

    add_default_grids(vol_plot)
    vol_plot.underlays.append(PlotAxis(vol_plot, orientation='left'))
    vol_plot.tools.append(PanTool(vol_plot, constrain=True,
                                  constrain_direction="x"))

    container = VPlotContainer(bgcolor = "lightblue",
                               spacing = 20,
                               padding = 50,
                               fill_padding=False)
    container.add(vol_plot)
    container.add(price_plot)
    container.overlays.append(PlotLabel("Financial Plot",
                                        component=container,
                                        #font="Times New Roman 24"))
                                        font="Arial 24"))
    return container

#===============================================================================
# Attributes to use for the plot view.
size=(800,600)
title="Financial plot example"

#===============================================================================
# # Demo class that is used by the demo.py application.
#===============================================================================
class Demo(HasTraits):
    plot = Instance(Component)

    traits_view = View(
                    Group(
                        Item('plot', editor=ComponentEditor(size=size),
                             show_label=False),
                        orientation = "vertical"),
                    resizable=True, title=title,
                    width=size[0], height=size[1]
                    )

    def _plot_default(self):
         return _create_plot_component()

demo = Demo()

if __name__ == "__main__":
    demo.configure_traits()

#--EOF---

########NEW FILE########
__FILENAME__ = financial_plot_dates
"""
Implementation of a standard financial plot visualization using Chaco
renderers and scales.  This differs from the financial_plot.py example
in that it uses a date-oriented axis.
"""

# Major library imports
from numpy import abs, cumprod, linspace, random
import time

# Enthought library imports
from enable.api import Component, ComponentEditor
from traits.api import HasTraits, Instance
from traitsui.api import Item, Group, View

# Chaco imports
from chaco.api import ArrayDataSource, BarPlot, DataRange1D, \
        LinearMapper, VPlotContainer, PlotAxis, \
        FilledLinePlot, add_default_grids, PlotLabel
from chaco.tools.api import PanTool, ZoomTool


from chaco.scales.api import CalendarScaleSystem
from chaco.scales_tick_generator import ScalesTickGenerator


def create_dates(numpoints, units="days"):
    """ Returns **numpoints** number of dates that evenly bracket the current
    date and time.  **units** should be one of "weeks", "days", "hours"
    "minutes", or "seconds".
    """
    units_map = { "weeks" : 7*24*3600,
                  "days" : 24*3600,
                  "hours" : 3600,
                  "minutes" : 60,
                  "seconds" : 1 }
    now = time.time()
    dt = units_map[units]
    dates = linspace(now, now+numpoints*dt, numpoints)
    return dates

#===============================================================================
# # Create the Chaco plot.
#===============================================================================
def _create_plot_component():

    # Create the data and datasource objects
    # In order for the date axis to work, the index data points need to
    # be in units of seconds since the epoch.  This is because we are using
    # the CalendarScaleSystem, whose formatters interpret the numerical values
    # as seconds since the epoch.
    numpoints = 500
    index = create_dates(numpoints)
    returns = random.lognormal(0.01, 0.1, size=numpoints)
    price = 100.0 * cumprod(returns)
    volume = abs(random.normal(1000.0, 1500.0, size=numpoints) + 2000.0)

    time_ds = ArrayDataSource(index)
    vol_ds = ArrayDataSource(volume, sort_order="none")
    price_ds = ArrayDataSource(price, sort_order="none")

    xmapper = LinearMapper(range=DataRange1D(time_ds))
    vol_mapper = LinearMapper(range=DataRange1D(vol_ds))
    price_mapper = LinearMapper(range=DataRange1D(price_ds))

    price_plot = FilledLinePlot(index = time_ds, value = price_ds,
                                index_mapper = xmapper,
                                value_mapper = price_mapper,
                                edge_color = "blue",
                                face_color = "paleturquoise",
                                bgcolor = "white",
                                border_visible = True)
    price_plot.overlays.append(PlotAxis(price_plot, orientation='left')),

    # Set the plot's bottom axis to use the Scales ticking system
    bottom_axis = PlotAxis(price_plot, orientation="bottom",# mapper=xmapper,
                    tick_generator=ScalesTickGenerator(scale=CalendarScaleSystem()))
    price_plot.overlays.append(bottom_axis)
    hgrid, vgrid = add_default_grids(price_plot)
    vgrid.tick_generator = bottom_axis.tick_generator

    price_plot.tools.append(PanTool(price_plot, constrain=True,
                                    constrain_direction="x"))
    price_plot.overlays.append(ZoomTool(price_plot, drag_button="right",
                                          always_on=True,
                                          tool_mode="range",
                                          axis="index",
                                          max_zoom_out_factor=10.0,
                                         ))

    vol_plot = BarPlot(index = time_ds, value = vol_ds,
                       index_mapper = xmapper,
                       value_mapper = vol_mapper,
                       line_color = "transparent",
                       fill_color = "black",
                       bar_width = 1.0,
                       bar_width_type = "screen",
                       antialias = False,
                       height = 100,
                       resizable = "h",
                       bgcolor = "white",
                       border_visible = True)

    hgrid, vgrid = add_default_grids(vol_plot)
    # Use the same tick generator as the x-axis on the price plot
    vgrid.tick_generator = bottom_axis.tick_generator
    vol_plot.underlays.append(PlotAxis(vol_plot, orientation='left'))
    vol_plot.tools.append(PanTool(vol_plot, constrain=True,
                                  constrain_direction="x"))

    container = VPlotContainer(bgcolor = "lightblue",
                               spacing = 40,
                               padding = 50,
                               fill_padding=False)
    container.add(vol_plot)
    container.add(price_plot)
    container.overlays.append(PlotLabel("Financial Plot with Date Axis",
                                        component=container,
                                        #font="Times New Roman 24"))
                                        font="Arial 24"))

    return container

#===============================================================================
# Attributes to use for the plot view.
size=(800,600)
title="Financial plot example"

#===============================================================================
# # Demo class that is used by the demo.py application.
#===============================================================================
class Demo(HasTraits):
    plot = Instance(Component)

    traits_view = View(
                    Group(
                        Item('plot', editor=ComponentEditor(size=size),
                             show_label=False),
                        orientation = "vertical"),
                    resizable=True, title=title,
                    width=size[0], height=size[1]
                    )

    def _plot_default(self):
         return _create_plot_component()

demo = Demo()

if __name__ == "__main__":
    demo.configure_traits()

#--EOF---

########NEW FILE########
__FILENAME__ = functionplotter
#!/usr/bin/env python
"""
Demonstrates use of the FunctionDataSource that depends on an external range
and returns different data depending on that range.
"""

# Major library imports
from numpy import linspace, sin, ceil

# Enthought library imports
from enable.api import Component, ComponentEditor
from traits.api import HasTraits, Instance, Int
from traitsui.api import Item, Group, HGroup, View

# Chaco imports
from chaco.api import ScatterPlot, DataView, LinePlot
from chaco.tools.api import PanTool, ZoomTool
from chaco.function_data_source import FunctionDataSource


class PlotExample(HasTraits):
    plot = Instance(Component)
    numpoints = Int(500)

    traits_view = View(
        Group(
            Item('plot', editor=ComponentEditor(), show_label=False),
            HGroup(
                HGroup(
                    Item('object.plot.x_mapper.range.low_setting', label='Low'),
                    Item('object.plot.x_mapper.range.high_setting', label='High'),
                    label='X', show_border=True
                ),
                HGroup(
                    Item('object.plot.y_mapper.range.low_setting', label='Low'),
                    Item('object.plot.y_mapper.range.high_setting', label='High'),
                    label='Y', show_border=True
                ),
            ),
            orientation = "vertical"), resizable=True, title="Function Plot",
            width=900, height=600
        )

    def xfunc(self, low, high):
        dx = (high - low) / self.numpoints
        real_low = ceil(low/dx) * dx
        real_high = ceil(high/dx) * dx
        return linspace(real_low, real_high, self.numpoints)

    def yfunc(self, low, high):
        x = self.xfunc(low, high)
        return sin(1.0/x)

    def _plot_default(self):
        container = DataView()

        xds = FunctionDataSource(func = self.xfunc)
        yds = FunctionDataSource(func = self.yfunc)

        xmapper = container.x_mapper
        ymapper = container.y_mapper

        xds.data_range = xmapper.range
        yds.data_range = xmapper.range

        xmapper.range.set_bounds(-5, 10)
        ymapper.range.set_bounds(-1, 1.2)

        plot = ScatterPlot(index = xds, value = yds, index_mapper = xmapper,
                           value_mapper = ymapper,
                           color = "green",
                           marker = "circle",
                           marker_size = 3,
                           line_width = 0)

        plot2 = LinePlot(index = xds, value = yds, index_mapper = xmapper,
                        value_mapper = ymapper,
                        color = "lightgray")

        container.add(plot2, plot)
        plot.tools.append(PanTool(plot, constrain_direction="x", constrain=True))
        plot.tools.append(ZoomTool(plot, axis="index", tool_mode="range"))

        return container


demo = PlotExample()

if __name__ == "__main__":
    demo.configure_traits()


########NEW FILE########
__FILENAME__ = logo
""" LOGO overlay """

from __future__ import with_statement

from numpy import array, cos, invert, isnan, nan, pi, sin, vstack
from traits.api import Array, Enum, Float, Range
from traitsui.api import Group, Item, View
from enable.api import ColorTrait
from chaco.api import arg_find_runs, AbstractOverlay


class Turtle(AbstractOverlay):
    x = Float
    y = Float
    angle = Range(0.0, 360.0, value=90.0)    # degrees, clockwise
    color = ColorTrait("blue")
    line_color = ColorTrait("green")
    size = Float(10.0)
    path = Array

    _pen = Enum("down", "up")

    view = View(Group("x", "y", "angle", Item("color", style="custom"),
                      Item("line_color", style="custom"), "size",
                      orientation="vertical"))

    def __init__(self, component=None, **traits):
        super(Turtle, self).__init__(component=component, **traits)
        if 'path' not in traits:
            self.path = array([self.x, self.y], ndmin=2)

    def overlay(self, other_component, gc, view_bounds=None, mode="normal"):
        self.render(gc, other_component)

    def render_turtle(self, gc, component):
        with gc:
            x, y = component.map_screen(array([self.x, self.y], ndmin=2))[0]
            gc.translate_ctm(x, y)
            angle = self.angle * pi / 180.0
            gc.rotate_ctm(angle)
            gc.set_stroke_color(self.color_)
            gc.set_fill_color(self.color_)
            gc.begin_path()
            gc.lines([[-0.707*self.size, 0.707*self.size],
                      [-0.707*self.size, -0.707*self.size],
                      [self.size, 0.0]])
            gc.fill_path()

    def render(self, gc, component):
        # Uses the component to map our path into screen space
        nan_mask = invert(isnan(self.path[:,0])).astype(int)
        blocks = [b for b in arg_find_runs(nan_mask, "flat") if nan_mask[b[0]] != 0]
        screen_pts = component.map_screen(self.path)
        with gc:
            gc.clip_to_rect(component.x, component.y, component.width, component.height)
            gc.set_stroke_color(self.line_color_)
            for start, end in blocks:
                gc.begin_path()
                gc.lines(screen_pts[start:end])
                gc.stroke_path()
            self.render_turtle(gc, component)

    def pendown(self):
        self._pen = "down"
        self.path = vstack((self.path, [self.x, self.y]))

    def penup(self):
        self.path = vstack((self.path, [nan,nan]))
        self._pen = "up"

    def forward(self, amt):
        angle = self.angle * pi / 180.0
        self.x += amt * cos(angle)
        self.y += amt * sin(angle)
        if self._pen == "down":
            self.path = vstack((self.path, [self.x, self.y]))

    def back(self, amt):
        self.forward(-amt)

    def left(self, angle):
        self.angle = (self.angle + angle) % 360

    def right(self, angle):
        self.angle = ((self.angle - angle) + 360) % 360

    def clear(self):
        self.path = array([self.x, self.y], ndmin=2)

    def reset(self):
        self.x = self.y = 0.0
        self.angle = 90.0
        self.clear()

    def _anytrait_changed(self, trait, val):
        self.component.request_redraw()




########NEW FILE########
__FILENAME__ = multiaxis
#!/usr/bin/env python
"""
Draws several overlapping line plots like simple_line.py, but uses a separate
Y range for each plot.  Also has a second Y-axis on the right hand side.
Demonstrates use of the BroadcasterTool.

Left-drag pans the plot.

Right-click and dragging on the legend allows you to reposition the legend.

Double-clicking on line or scatter plots brings up a traits editor for the plot.
"""

# Major library imports
from numpy import arange
from scipy.special import jn

from chaco.example_support import COLOR_PALETTE
# Enthought library imports
from enable.api import Component, ComponentEditor
from traits.api import HasTraits, Instance
from traitsui.api import Item, Group, View

# Chaco imports
from chaco.api import create_line_plot, add_default_axes, \
                                add_default_grids, OverlayPlotContainer, \
                                PlotLabel, Legend, PlotAxis
from chaco.tools.api import PanTool, LegendTool, TraitsTool, \
                                      BroadcasterTool

#===============================================================================
# # Create the Chaco plot.
#===============================================================================
def _create_plot_component():

    container = OverlayPlotContainer(padding = 50, fill_padding = True,
                                     bgcolor = "lightgray", use_backbuffer=True)

    # Create the initial X-series of data
    numpoints = 100
    low = -5
    high = 15.0
    x = arange(low, high+0.001, (high-low)/numpoints)

    # Plot some bessel functions
    plots = {}
    broadcaster = BroadcasterTool()
    for i in range(4):
        y = jn(i, x)
        plot = create_line_plot((x,y), color=tuple(COLOR_PALETTE[i]), width=2.0)
        plot.index.sort_order = "ascending"
        plot.bgcolor = "white"
        plot.border_visible = True
        if i == 0:
            add_default_grids(plot)
            add_default_axes(plot)

        # Create a pan tool and give it a reference to the plot it should
        # manipulate, but don't attach it to the plot.  Instead, attach it to
        # the broadcaster.
        pan = PanTool(plot)
        broadcaster.tools.append(pan)

        container.add(plot)
        plots["Bessel j_%d"%i] = plot

    # Add an axis on the right-hand side that corresponds to the second plot.
    # Note that it uses plot.value_mapper instead of plot0.value_mapper.
    plot1 = plots["Bessel j_1"]
    axis = PlotAxis(plot1, orientation="right")
    plot1.underlays.append(axis)

    # Add the broadcast tool to the container, instead of to an
    # individual plot
    container.tools.append(broadcaster)

    legend = Legend(component=container, padding=10, align="ur")
    legend.tools.append(LegendTool(legend, drag_button="right"))
    container.overlays.append(legend)

    # Set the list of plots on the legend
    legend.plots = plots

    # Add the title at the top
    container.overlays.append(PlotLabel("Bessel functions",
                              component=container,
                              font = "swiss 16",
                              overlay_position="top"))

    # Add the traits inspector tool to the container
    container.tools.append(TraitsTool(container))

    return container

#===============================================================================
# Attributes to use for the plot view.
size=(800,700)
title="Multi-Y plot"

#===============================================================================
# # Demo class that is used by the demo.py application.
#===============================================================================
class Demo(HasTraits):
    plot = Instance(Component)

    traits_view = View(
                    Group(
                        Item('plot', editor=ComponentEditor(size=size),
                             show_label=False),
                        orientation = "vertical"),
                    resizable=True, title=title,
                    width=size[0], height=size[1]
                    )

    def _plot_default(self):
        return _create_plot_component()

demo = Demo()

if __name__ == "__main__":
    demo.configure_traits()

#--EOF---

########NEW FILE########
__FILENAME__ = multiaxis_using_Plot
#!/usr/bin/env python
"""
Draws some x-y line and scatter plots. On the left hand plot:
 - Left-drag pans the plot.
 - Mousewheel up and down zooms the plot in and out.
 - Pressing "z" brings up the Zoom Box, and you can click-drag a rectangular
   region to zoom.  If you use a sequence of zoom boxes, pressing alt-left-arrow
   and alt-right-arrow moves you forwards and backwards through the "zoom
   history".
"""

# Major library imports
from numpy import linspace
from scipy.special import jn

from chaco.example_support import COLOR_PALETTE
# Enthought library imports
from enable.api import Component, ComponentEditor
from traits.api import HasTraits, Instance
from traitsui.api import Item, Group, View

# Chaco imports
from chaco.api import ArrayPlotData, Plot
from chaco.tools.api import BroadcasterTool, PanTool, ZoomTool
from chaco.api import create_line_plot, add_default_axes

#===============================================================================
# # Create the Chaco plot.
#===============================================================================
def _create_plot_component():

    # Create some x-y data series to plot
    x = linspace(-2.0, 10.0, 100)
    pd = ArrayPlotData(index = x)
    for i in range(5):
        pd.set_data("y" + str(i), jn(i,x))

    # Create some line plots of some of the data
    plot1 = Plot(pd)
    plot1.plot(("index", "y0", "y1", "y2"), name="j_n, n<3", color="red")

    # Tweak some of the plot properties
    plot1.title = "My First Line Plot"
    plot1.padding = 50
    plot1.padding_top = 75
    plot1.legend.visible = True

    x = linspace(-5, 15.0, 100)
    y = jn(5, x)
    foreign_plot = create_line_plot((x,y), color=tuple(COLOR_PALETTE[0]), width=2.0)
    left, bottom = add_default_axes(foreign_plot)
    left.orientation = "right"
    bottom.orientation = "top"
    plot1.add(foreign_plot)

    # Attach some tools to the plot
    broadcaster = BroadcasterTool()
    broadcaster.tools.append(PanTool(plot1))
    broadcaster.tools.append(PanTool(foreign_plot))

    for c in (plot1, foreign_plot):
        zoom = ZoomTool(component=c, tool_mode="box", always_on=False)
        broadcaster.tools.append(zoom)

    plot1.tools.append(broadcaster)

    return plot1

#===============================================================================
# Attributes to use for the plot view.
size=(900,500)
title="Multi-Y plot"

#===============================================================================
# # Demo class that is used by the demo.py application.
#===============================================================================
class Demo(HasTraits):
    plot = Instance(Component)

    traits_view = View(
                    Group(
                        Item('plot', editor=ComponentEditor(size=size),
                             show_label=False),
                        orientation = "vertical"),
                    resizable=True, title=title,
                    width=size[0], height=size[1]
                    )

    def _plot_default(self):
         return _create_plot_component()

demo = Demo()

if __name__ == "__main__":
    demo.configure_traits()

#--EOF---

########NEW FILE########
__FILENAME__ = multi_line_plot
import numpy as np

from chaco.api import LinearMapper, Plot, ArrayDataSource, DataRange1D
from chaco.multi_array_data_source import MultiArrayDataSource
from chaco.multi_line_plot import MultiLinePlot
from enable.api import ComponentEditor
from traits.api import Instance, HasTraits
from traitsui.api import View, UItem

class MyPlot(HasTraits):
    """ Displays a plot with a few buttons to control which overlay
        to display
    """
    plot = Instance(Plot)

    traits_view = View(UItem('plot', editor=ComponentEditor()),
                       width=700, height=600, resizable=True
                       )

    def __init__(self, x_index, y_index, data, **kw):
        super(MyPlot, self).__init__(**kw)

        # Create the data source for the MultiLinePlot.
        ds = MultiArrayDataSource(data=data)

        xs = ArrayDataSource(x_index, sort_order='ascending')
        xrange = DataRange1D()
        xrange.add(xs)

        ys = ArrayDataSource(y_index, sort_order='ascending')
        yrange = DataRange1D()
        yrange.add(ys)

        mlp = MultiLinePlot(
                        index = xs,
                        yindex = ys,
                        index_mapper = LinearMapper(range=xrange),
                        value_mapper = LinearMapper(range=yrange),
                        value=ds,
                        global_max = np.nanmax(data),
                        global_min = np.nanmin(data),
                        **kw)

        self.plot = Plot()
        self.plot.add(mlp)


x_index = np.arange(0,100, 1)
y_index = np.arange(0,1000, 10)
data = np.sin(np.arange(0,x_index.size*y_index.size))
# add a random chunk of nan values
data[1532:1588] = np.nan
data = data.reshape(x_index.size, y_index.size)

my_plot = MyPlot(x_index, y_index, data)
my_plot.configure_traits()

########NEW FILE########
__FILENAME__ = multi_line_plot_demo
import numpy as np

from traits.api import Instance, HasTraits, Range, Array
from traitsui.api import View, Item, HGroup, VGroup, Group

from enable.api import ComponentEditor

from chaco.api import LinearMapper, Plot, ArrayDataSource, DataRange1D, PlotAxis
from chaco.multi_array_data_source import MultiArrayDataSource
from chaco.multi_line_plot import MultiLinePlot


class DataModel(HasTraits):
    """This is the data to be plotted in the demo."""

    # The x values of the data (1D numpy array).
    x_index = Array()

    # The channel numbers (1D numpy array).
    y_index = Array()

    # The data.  The shape of this 2D array must be (y_index.size, x_index.size)
    data = Array()


class MultiLinePlotDemo(HasTraits):
    """Demonstrates the MultiLinePlot.

    This demo assumes that 'model', an instance of DataModel containing the 2D
    data to be plotted, will be given to the constructor, and will not change
    later.
    """

    model = Instance(DataModel)

    plot = Instance(Plot)

    multi_line_plot_renderer = Instance(MultiLinePlot)

    # Drives multi_line_plot_renderer.normalized_amplitude
    amplitude = Range(-1.5, 1.5, value=-0.5)

    # Drives multi_line_plot_renderer.offset
    offset = Range(-1.0, 1.0, value=0)

    traits_view = \
        View(
            VGroup(
                Group(
                    Item('plot', editor=ComponentEditor(), show_label=False),
                ),
                HGroup(
                    Item('amplitude', springy=True),
                    Item('offset', springy=True),
                    springy=True,
                ),
                HGroup(
                    Item('object.multi_line_plot_renderer.color', springy=True),
                    Item('object.multi_line_plot_renderer.line_style', springy=True),
                    springy=True,
                ),
            ),
            width=800,
            height=500,
            resizable=True,
        )


    #-----------------------------------------------------------------------
    # Trait defaults
    #-----------------------------------------------------------------------

    def _multi_line_plot_renderer_default(self):
        """Create the default MultiLinePlot instance."""

        xs = ArrayDataSource(self.model.x_index, sort_order='ascending')
        xrange = DataRange1D()
        xrange.add(xs)

        ys = ArrayDataSource(self.model.y_index, sort_order='ascending')
        yrange = DataRange1D()
        yrange.add(ys)

        # The data source for the MultiLinePlot.
        ds = MultiArrayDataSource(data=self.model.data)

        multi_line_plot_renderer = \
            MultiLinePlot(
                index = xs,
                yindex = ys,
                index_mapper = LinearMapper(range=xrange),
                value_mapper = LinearMapper(range=yrange),
                value=ds,
                global_max = self.model.data.max(),
                global_min = self.model.data.min())

        return multi_line_plot_renderer

    def _plot_default(self):
        """Create the Plot instance."""

        plot = Plot(title="MultiLinePlot Demo")
        plot.add(self.multi_line_plot_renderer)

        x_axis = PlotAxis(component=plot,
                            mapper=self.multi_line_plot_renderer.index_mapper,
                            orientation='bottom',
                            title='t (seconds)')
        y_axis = PlotAxis(component=plot,
                            mapper=self.multi_line_plot_renderer.value_mapper,
                            orientation='left',
                            title='channel')
        plot.overlays.extend([x_axis, y_axis])
        return plot

    #-----------------------------------------------------------------------
    # Trait change handlers
    #-----------------------------------------------------------------------

    def _amplitude_changed(self, amp):
        self.multi_line_plot_renderer.normalized_amplitude = amp

    def _offset_changed(self, off):
        self.multi_line_plot_renderer.offset = off
        # FIXME:  The change does not trigger a redraw.  Force a redraw by
        # faking an amplitude change.
        self.multi_line_plot_renderer._amplitude_changed()


if __name__ == "__main__":
    # Sample rate.
    fs = 500
    # Total time.
    T = 5.0
    num_samples = fs * T
    t = np.arange(num_samples) / fs

    channels = np.arange(12)
    # Frequencies of the sine functions in each channel.
    freqs = 3*(channels[:,None] + 1)
    y = np.sin(freqs * t)

    # Create an instance of DataModel.  This is the data to
    # be plotted with a MultiLinePlot.
    data = DataModel(x_index=t, y_index=channels, data=y)

    # Create the demo class, and show it.
    demo = MultiLinePlotDemo(model=data)
    demo.configure_traits()

########NEW FILE########
__FILENAME__ = noninteractive
#!/usr/bin/env python
"""
This demonstrates how to create a plot offscreen and save it to an image
file on disk.
"""
# Standard library imports
import os
import sys

# Major library imports
from numpy import linspace
from scipy.special import jn

# Enthought library imports
from traits.etsconfig.api import ETSConfig

# Chaco imports
from chaco.api import ArrayPlotData, Plot, PlotGraphicsContext
from chaco.example_support import COLOR_PALETTE

DPI = 72.0

# This is a bit of a hack, to work around the fact that line widths don't scale
# with the GraphicsContext's CTM.
dpi_scale = DPI / 72.0


def create_plot():
    numpoints = 100
    low = -5
    high = 15.0
    x = linspace(low, high, numpoints)
    pd = ArrayPlotData(index=x)
    p = Plot(pd, bgcolor="oldlace", padding=50, border_visible=True)
    for i in range(10):
        pd.set_data("y" + str(i), jn(i, x))
        p.plot(("index", "y" + str(i)), color=tuple(COLOR_PALETTE[i]),
               width=2.0 * dpi_scale)
    p.x_grid.visible = True
    p.x_grid.line_width *= dpi_scale
    p.y_grid.visible = True
    p.y_grid.line_width *= dpi_scale
    p.legend.visible = True
    return p


def draw_plot(filename, size=(800, 600)):
    container = create_plot()
    container.outer_bounds = list(size)
    container.do_layout(force=True)
    gc = PlotGraphicsContext(size, dpi=DPI)
    gc.render_component(container)
    gc.save(filename)
    return


def draw_svg(filename, size=(800, 600)):
    from chaco.svg_graphics_context import SVGGraphicsContext
    container = create_plot()
    container.bounds = list(size)
    container.do_layout(force=True)
    gc = SVGGraphicsContext(size)
    gc.render_component(container)
    gc.save(filename)


def draw_pdf(filename, size=(800, 600)):
    from chaco.pdf_graphics_context import PdfPlotGraphicsContext
    container = create_plot()
    container.outer_bounds = list(size)
    container.do_layout(force=True)
    gc = PdfPlotGraphicsContext(filename=filename,
                                dest_box=(0.5, 0.5, 5.0, 5.0))

    for i in range(2):
        # draw the plot
        gc.render_component(container)

        #Start a new page for subsequent draw commands.
        gc.add_page()

    gc.save()


def get_directory(filename):
    print 'Please enter a path in which to place generated plots.'
    print 'Press <ENTER> to generate in the current directory.'
    path = raw_input('Path: ').strip()

    if len(path) > 0 and not os.path.exists(path):
        print 'The given path does not exist.'
        sys.exit()

    if not os.path.isabs(path):
        print 'Creating image: ' + os.path.join(os.getcwd(), path, filename)
    else:
        print 'Creating image: ' + os.path.join(path, filename)

    return os.path.join(path, filename)


if __name__ == "__main__":
    if ETSConfig.kiva_backend == 'svg':
        # Render the plot as a SVG
        draw_svg(get_directory('noninteractive.svg'), size=(800, 600))
    elif ETSConfig.kiva_backend == 'pdf':
        # Render the plot as a PDF, requires on ReportLab
        draw_pdf(get_directory('noninteractive.pdf'))
    else:
        draw_plot(get_directory('noninteractive.png'), size=(800, 600))

# EOF

########NEW FILE########
__FILENAME__ = nonlinear_color_mapping
#!/usr/bin/env python
"""
    Demonstrates usage of the TransformColorMapper class.
    - The colorbar is zoomable and panable.
"""

# Major library imports
from numpy import linspace, meshgrid, pi, cos, sin, log10

# Enthought library imports
from enable.api import Component, ComponentEditor
from traits.api import HasTraits, Instance, Property, Float, \
            Enum, Array, Tuple, Int, Callable, cached_property
from traitsui.api import Item, UItem, HGroup, View, RangeEditor

# Chaco imports
from chaco.api import ArrayPlotData, Plot, ColorBar, HPlotContainer, \
                      LinearMapper, LogMapper, CMapImagePlot, \
                      TransformColorMapper, jet
from chaco.tools.api import PanTool, ZoomTool


class DataGrid(HasTraits):
    """Holds a grid of 2D data that represents a function z = f(x,y)."""

    #------------------------------------------------------
    # Primary Traits
    #------------------------------------------------------

    # (xmin, ymin xmax, ymax)
    domain_bounds = Tuple(Float, Float, Float, Float)
    
    # grid dimensions: (Nx, Ny)
    grid_size = Tuple(Int, Int)

    # The function to evaluate on the grid.
    func = Callable

    #------------------------------------------------------
    # Properties
    #------------------------------------------------------

    # 1D array of x coordinates.
    x_array = Property(Array, depends_on=['domain_bounds, grid_size'])
    
    # 1D array of y coordinates.
    y_array = Property(Array, depends_on=['domain_bounds, grid_size'])

    # 2D array of function values, z = f(x,y)
    data = Property(Array, depends_on=['func, x_array, y_array'])

    data_min = Property(Float, depends_on=['data'])
    data_max = Property(Float, depends_on=['data'])

    #------------------------------------------------------
    # Trait handlers
    #------------------------------------------------------
       
    @cached_property
    def _get_x_array(self):
        xmin = self.domain_bounds[0]
        xmax = self.domain_bounds[2]
        nx = self.grid_size[0]
        x_array = linspace(xmin, xmax, nx)
        return x_array

    @cached_property
    def _get_y_array(self):
        ymin = self.domain_bounds[1]
        ymax = self.domain_bounds[3]
        ny = self.grid_size[1]
        y_array = linspace(ymin, ymax, ny)
        return y_array
    
    @cached_property
    def _get_data(self):
        # This might be called with func == None during initialization.
        if self.func is None:
            return None
        # Create a scalar field to colormap.
        xs = self.x_array
        ys = self.y_array
        x, y = meshgrid(xs,ys)
        z = self.func(x,y)[:-1,:-1]
        return z

    @cached_property
    def _get_data_min(self):
        return self.data.min()

    @cached_property
    def _get_data_max(self):
        return self.data.max()    


def _create_plot_component(model):

    # Create a plot data object and give it the model's data array.
    pd = ArrayPlotData()
    pd.set_data("imagedata", model.data)

    # Create the "main" Plot.
    plot = Plot(pd, padding=50)

    # Use a TransformColorMapper for the color map.
    tcm = TransformColorMapper.from_color_map(jet)

    # Create the image plot renderer in the main plot.
    renderer = plot.img_plot("imagedata", 
                    xbounds=model.x_array,
                    ybounds=model.y_array,
                    colormap=tcm)[0]

    # Create the colorbar.
    lm = LinearMapper(range=renderer.value_range,
                      domain_limits=(renderer.value_range.low,
                                     renderer.value_range.high))
    colorbar = ColorBar(index_mapper=lm,
                        plot=plot,
                        orientation='v',
                        resizable='v',
                        width=30,
                        padding=20)

    colorbar.padding_top = plot.padding_top
    colorbar.padding_bottom = plot.padding_bottom

    # Add pan and zoom tools to the colorbar.
    colorbar.tools.append(PanTool(colorbar,
                                  constrain_direction="y",
                                  constrain=True))
    zoom_overlay = ZoomTool(colorbar, axis="index", tool_mode="range",
                            always_on=True, drag_button="right")
    colorbar.overlays.append(zoom_overlay)

    # Create a container to position the plot and the colorbar side-by-side
    container = HPlotContainer(use_backbuffer = True)
    container.add(plot)
    container.add(colorbar)

    return container


class DataGridView(HasTraits):

    # The DataGrid instance plotted by this view.
    model = Instance(DataGrid)

    colormap_scale = Enum('linear [default]', 'log [data_func]',
                            'power [data_func]', 'power [unit_func]',
                            'cos [unit_func]', 'sin [unit_func]')
    
    power = Float(1.0)
    
    colorbar_scale = Enum('linear', 'log')

    plot = Instance(Component)
    
    img_renderer = Property(Instance(CMapImagePlot), depends_on=['plot'])
    
    colorbar = Property(Instance(ColorBar), depends_on=['plot'])


    traits_view = View(
                    HGroup(
                        Item('colormap_scale'),
                        Item('power',
                                editor=RangeEditor(low=0.1,
                                                high=3.0,
                                                format="%4.2f"),
                                visible_when='colormap_scale.startswith("power")',
                                springy=True),
                        Item('colorbar_scale'),
                        springy=True),
                    UItem('plot',editor=ComponentEditor()),
                    width=750, height=500, resizable=True,        
                    title="TransformColorMapper Demo",
                    )


    def _plot_default(self):
        return _create_plot_component(self.model)

    def _get_main_plot(self):
        return self.plot.components[0]

    def _get_img_renderer(self):
        return self.plot.components[0].components[0]

    def _get_colorbar(self):
        return self.plot.components[1]

    def _colormap_scale_changed(self):
        if self.colormap_scale == 'linear [default]':
            self.img_renderer.color_mapper.data_func = None
            self.img_renderer.color_mapper.unit_func = None
        elif self.colormap_scale == 'log [data_func]':
            self.img_renderer.color_mapper.data_func = log10
            self.img_renderer.color_mapper.unit_func = None
        elif self.colormap_scale == 'power [data_func]':
            self.img_renderer.color_mapper.data_func = lambda x: x**self.power
            self.img_renderer.color_mapper.unit_func = None
        elif self.colormap_scale == 'power [unit_func]':
            self.img_renderer.color_mapper.data_func = None
            self.img_renderer.color_mapper.unit_func = lambda x: x**self.power            
        elif self.colormap_scale == 'cos [unit_func]':
            self.img_renderer.color_mapper.data_func = None
            self.img_renderer.color_mapper.unit_func = lambda x: cos(0.5*pi*x) 
        elif self.colormap_scale == 'sin [unit_func]':
            self.img_renderer.color_mapper.data_func = None
            self.img_renderer.color_mapper.unit_func = lambda x: sin(0.5*pi*x)
        # FIXME: This call to request_redraw() should not be necessary.
        self.img_renderer.request_redraw()

    def _power_changed(self):
        if self.colormap_scale == 'power [data_func]':
            self.img_renderer.color_mapper.data_func = lambda x: x**self.power
        elif self.colormap_scale == 'power [unit_func]':
            self.img_renderer.color_mapper.unit_func = lambda x: x**self.power
        self.img_renderer.request_redraw()

    def _colorbar_scale_changed(self):
        rng = self.colorbar.index_mapper.range
        dlim = self.colorbar.index_mapper.domain_limits
        if self.colorbar_scale == 'linear':
            new_mapper = LinearMapper(range=rng, domain_limits=dlim)
        else:  # 'log'
            new_mapper = LogMapper(range=rng, domain_limits=dlim)
        self.colorbar.index_mapper = new_mapper



if __name__ == "__main__":
    grid = DataGrid(
                func = lambda x,y: 3.0**(x**2 + 2*(cos(2*pi*y)-1)),
                domain_bounds=(0.0,0.0, 2.0,2.0),
                grid_size=(200, 200))
    #print "data bounds: ", grid.data_min, grid.data_max
    demo = DataGridView(model=grid)
    demo.configure_traits()

########NEW FILE########
__FILENAME__ = qt_example
"""
Example of how to directly embed Chaco into Qt widgets.

The actual plot being created is drawn from the basic/line_plot1.py code.
"""
from traits.etsconfig.etsconfig import ETSConfig
ETSConfig.toolkit = "qt4"

from numpy import linspace
from scipy.special import jn
from pyface.qt import QtGui
from pyface.util.guisupport import get_app_qt4, start_event_loop_qt4

from enable.api import Window

from chaco.api import ArrayPlotData, Plot
from chaco.tools.api import PanTool, ZoomTool


def create_chaco_plot(parent):
    x = linspace(-2.0, 10.0, 100)
    pd = ArrayPlotData(index = x)
    for i in range(5):
        pd.set_data("y" + str(i), jn(i,x))

    # Create some line plots of some of the data
    plot = Plot(pd, title="Line Plot", padding=50, border_visible=True)
    plot.legend.visible = True
    plot.plot(("index", "y0", "y1", "y2"), name="j_n, n<3", color="red")
    plot.plot(("index", "y3"), name="j_3", color="blue")

    # Attach some tools to the plot
    plot.tools.append(PanTool(plot))
    zoom = ZoomTool(component=plot, tool_mode="box", always_on=False)
    plot.overlays.append(zoom)

    # This Window object bridges the Enable and Qt4 worlds, and handles events
    # and drawing.  We can create whatever hierarchy of nested containers we
    # want, as long as the top-level item gets set as the .component attribute
    # of a Window.
    return Window(parent, -1, component=plot)


def main():
    app = get_app_qt4()
    main_window = QtGui.QMainWindow()
    main_window.resize(500,500)

    enable_window = create_chaco_plot(main_window)

    # The .control attribute references a QWidget that gives Chaco events
    # and that Chaco paints into.
    main_window.setCentralWidget(enable_window.control)

    main_window.show()
    start_event_loop_qt4(app)
    return main_window


if __name__ == "__main__":
    # Save window so that it doesn't get garbage collected when run within
    # existing event loop (i.e. from ipython).
    window = main()

########NEW FILE########
__FILENAME__ = quiver
"""
Draws a vector or "quiver" plot of a set of random points.
 - Left-drag pans the plot.
 - Mousewheel up and down zooms the plot in and out.
 - Pressing "z" brings up the Zoom Box, and you can click-drag a rectangular
   region to zoom.  If you use a sequence of zoom boxes, pressing alt-left-arrow
   and alt-right-arrow moves you forwards and backwards through the "zoom
   history".
"""

# Major library imports
from numpy import array, sort
from numpy.random import random

# Enthought library imports
from enable.api import Component, ComponentEditor
from traits.api import HasTraits, Instance, Int
from traitsui.api import Item, View

# Chaco imports
from chaco.api import add_default_grids, add_default_axes, ArrayPlotData, \
    Plot, OverlayPlotContainer
from chaco.tools.api import PanTool, ZoomTool


class PlotExample(HasTraits):
    plot = Instance(Component)
    numpts = Int(400)
    vectorlen = Int(15)

    traits_view = View(Item('plot', editor=ComponentEditor(), show_label=False),
                       width=600, height=600)

    def _plot_default(self):
        # Create starting points for the vectors.
        numpts = self.numpts
        x = sort(random(numpts))
        y = random(numpts)

        # Create vectors.
        vectorlen = self.vectorlen
        vectors = array((random(numpts)*vectorlen, random(numpts)*vectorlen)).T

        data = ArrayPlotData()
        data.set_data('index', x)
        data.set_data('value', y)
        data.set_data('vectors', vectors)
        quiverplot = Plot(data)
        quiverplot.quiverplot(('index', 'value', 'vectors'))

        # Attach some tools to the plot
        quiverplot.tools.append(PanTool(quiverplot, constrain_key="shift"))
        zoom = ZoomTool(quiverplot)
        quiverplot.overlays.append(zoom)

        container = OverlayPlotContainer(quiverplot, padding=50)

        return container


demo = PlotExample()

if __name__ == "__main__":
    demo.configure_traits()

########NEW FILE########
__FILENAME__ = range_selection_demo
"""
Range Selection tool

Displays a line plot, on which you can select an arbitrary range of x-values.

Left-drag will create a horizontal range selection; 
this selection can then be dragged
around, or resized by dragging its edges.
"""

# Major library imports
from numpy import arange
from scipy.special import jn

# Enthought library imports
from enable.api import Component, ComponentEditor
from traits.api import HasTraits, Instance
from traitsui.api import Item, Group, View

# Chaco imports
from chaco.api import create_line_plot, add_default_axes, add_default_grids
from chaco.tools.api import RangeSelection, RangeSelectionOverlay



#===============================================================================
# # Create the Chaco plot.
#===============================================================================
def _create_plot_component():

    numpoints = 100
    low = -5
    high = 15.001
    x = arange(low, high, (high-low)/numpoints)

    # Plot a bessel function
    y = jn(0, x)
    plot = create_line_plot((x,y), color=(0,0,1,1), width=2.0, index_sort="ascending")
    value_range = plot.value_mapper.range
    plot.active_tool = RangeSelection(plot, left_button_selects = True)
    plot.overlays.append(RangeSelectionOverlay(component=plot))
    plot.bgcolor = "white"
    plot.padding = 50
    add_default_grids(plot)
    add_default_axes(plot)

    return plot


#===============================================================================
# Attributes to use for the plot view.
size=(600,500)
title="Simple line plot"

#===============================================================================
# # Demo class that is used by the demo.py application.
#===============================================================================
class Demo(HasTraits):
    plot = Instance(Component)

    traits_view = View(
                    Group(
                        Item('plot', editor=ComponentEditor(size=size),
                             show_label=False),
                        orientation = "vertical"),
                    resizable=True, title=title,
                    width=size[0], height=size[1]
                    )

    def _plot_default(self):
         return _create_plot_component()

demo = Demo()

if __name__ == "__main__":
    demo.configure_traits()

########NEW FILE########
__FILENAME__ = scales_test
#!/usr/bin/env python
"""
Draws several overlapping line plots.

Left-drag pans the plot.

Mousewheel up and down zooms the plot in and out.

Pressing "z" brings up the Zoom Box, and you can click-drag a rectangular
region to zoom. If you use a sequence of zoom boxes, pressing control-y and
control-z (Meta-y and Meta-z on Mac) moves you forwards and backwards
through the "zoom history".

Right-click and dragging on the legend allows you to reposition the legend.

Double-clicking on line or scatter plots brings up a traits editor for the plot.
"""

# Major library imports
from numpy import linspace
from scipy.special import jn
from time import time

from chaco.example_support import COLOR_PALETTE
# Enthought library imports
from enable.api import Component, ComponentEditor
from traits.api import HasTraits, Instance
from traitsui.api import Item, Group, View

# Chaco imports
from chaco.api import create_line_plot, OverlayPlotContainer, PlotLabel, \
                                 create_scatter_plot, Legend, PlotGrid
from chaco.tools.api import PanTool, ZoomTool, \
                                       LegendTool, TraitsTool

from chaco.scales.api import CalendarScaleSystem
from chaco.scales_tick_generator import ScalesTickGenerator
from chaco.axis import PlotAxis

#===============================================================================
# # Create the Chaco plot.
#===============================================================================

def add_default_axes(plot, orientation="normal", vtitle="",htitle=""):
    """
    Creates left and bottom axes for a plot.  Assumes that the index is
    horizontal and value is vertical by default; set orientation to
    something other than "normal" if they are flipped.
    """
    if orientation in ("normal", "h"):
        v_mapper = plot.value_mapper
        h_mapper = plot.index_mapper
    else:
        v_mapper = plot.index_mapper
        h_mapper = plot.value_mapper

    left = PlotAxis(orientation='left',
                    title= vtitle,
                    mapper=v_mapper,
                    component=plot)

    bottom = PlotAxis(orientation='bottom',
                      title= htitle,
                      mapper=h_mapper,
                      component=plot)

    plot.underlays.append(left)
    plot.underlays.append(bottom)
    return left, bottom


def add_default_grids(plot, orientation="normal", tick_gen=None):
    """
    Creates horizontal and vertical gridlines for a plot.  Assumes that the
    index is horizontal and value is vertical by default; set orientation to
    something other than "normal" if they are flipped.
    """
    if orientation in ("normal", "h"):
        v_mapper = plot.index_mapper
        h_mapper = plot.value_mapper
    else:
        v_mapper = plot.value_mapper
        h_mapper = plot.index_mapper

    vgrid = PlotGrid(mapper=v_mapper, orientation='vertical',
                     component=plot,
                     line_color="lightgray", line_style="dot",
                     tick_generator = tick_gen)

    hgrid = PlotGrid(mapper=h_mapper, orientation='horizontal',
                     component=plot,
                     line_color="lightgray", line_style="dot",
                     tick_generator = ScalesTickGenerator())

    plot.underlays.append(vgrid)
    plot.underlays.append(hgrid)
    return hgrid, vgrid

def _create_plot_component():
    container = OverlayPlotContainer(padding = 50, fill_padding = True,
                                     bgcolor = "lightgray", use_backbuffer=True)

    # Create the initial X-series of data
    numpoints = 100
    low = -5
    high = 15.0
    x = linspace(low, high, numpoints)

    now = time()
    timex = linspace(now, now+7*24*3600, numpoints)

    # Plot some bessel functions
    value_mapper = None
    index_mapper = None
    plots = {}
    for i in range(10):
        y = jn(i, x)
        if i%2 == 1:
            plot = create_line_plot((timex,y), color=tuple(COLOR_PALETTE[i]), width=2.0)
            plot.index.sort_order = "ascending"
        else:
            plot = create_scatter_plot((timex,y), color=tuple(COLOR_PALETTE[i]))
        plot.bgcolor = "white"
        plot.border_visible = True
        if i == 0:
            value_mapper = plot.value_mapper
            index_mapper = plot.index_mapper
            left, bottom = add_default_axes(plot)
            left.tick_generator = ScalesTickGenerator()
            bottom.tick_generator = ScalesTickGenerator(scale=CalendarScaleSystem())
            add_default_grids(plot, tick_gen=bottom.tick_generator)
        else:
            plot.value_mapper = value_mapper
            value_mapper.range.add(plot.value)
            plot.index_mapper = index_mapper
            index_mapper.range.add(plot.index)

        if i==0:
            plot.tools.append(PanTool(plot))
            zoom = ZoomTool(plot, tool_mode="box", always_on=False)
            plot.overlays.append(zoom)
            # Add a legend in the upper right corner, and make it relocatable
            legend = Legend(component=plot, padding=10, align="ur")
            legend.tools.append(LegendTool(legend, drag_button="right"))
            plot.overlays.append(legend)

        container.add(plot)
        plots["Bessel j_%d"%i] = plot

    # Set the list of plots on the legend
    legend.plots = plots

    # Add the title at the top
    container.overlays.append(PlotLabel("Bessel functions",
                              component=container,
                              font = "swiss 16",
                              overlay_position="top"))

    # Add the traits inspector tool to the container
    container.tools.append(TraitsTool(container))

    return container

#===============================================================================
# Attributes to use for the plot view.
size=(800,700)
title="Simple line plot"

#===============================================================================
# # Demo class that is used by the demo.py application.
#===============================================================================
class Demo(HasTraits):
    plot = Instance(Component)

    traits_view = View(
                    Group(
                        Item('plot', editor=ComponentEditor(size=size),
                             show_label=False),
                        orientation = "vertical"),
                    resizable=True, title=title,
                    width=size[0], height=size[1]
                    )

    def _plot_default(self):
         return _create_plot_component()

demo = Demo()

if __name__ == "__main__":
    demo.configure_traits()

#--EOF---

########NEW FILE########
__FILENAME__ = add_tool
"""This example demonstrates customizing a plot object with a plot tool
using the chaco.shell subpackage.

The functions in the chaco.shell package allow us to quickly generate plots
with some basic interactivity without using the object-oriented core of Chaco.
"""

# Major library imports
from numpy import linspace, meshgrid, sin

# Enthought library imports
from chaco.shell import show, title, pcolor, colormap, curplot
from chaco.default_colormaps import jet

# Crate some scalar data
xs = linspace(0,10,200)
ys = linspace(0,20,400)
x,y = meshgrid(xs,ys)
z = sin(x)*y

# Create a pseudo-color-map
pcolor(x, y, z, name='sin_x_times_y')

# Change the color mapping
colormap(jet)

# Add some titles
title("pseudo colormap image plot")


# From the current plot object, grab the first plot
img_plot = curplot().plots['sin_x_times_y'][0]

# Add a custom tool - in this case, an ImageInspector
from chaco.tools.api import ImageInspectorTool, ImageInspectorOverlay

tool = ImageInspectorTool(img_plot)
img_plot.tools.append(tool)
overlay = ImageInspectorOverlay(img_plot, image_inspector=tool,
                                bgcolor="white", border_visible=True)
img_plot.overlays.append(overlay)


# If running this from the command line and outside of a wxPython
# application or process, the show() command is necessary to keep
# the plot from disappearing instantly.  If a wxPython mainloop
# is already running, then this command is not necessary.
show()

########NEW FILE########
__FILENAME__ = contour
"""This example demonstrates creating a contour plot using the chaco
shell subpackage.
"""

# Major library imports
from numpy import linspace, meshgrid, sin
from scipy.special import jn

# Enthought library imports
from chaco.shell import show, title, contour


# Crate some scalar data
xs = linspace(-10,10,200)
ys = linspace(-10,10,400)
x,y = meshgrid(xs,ys)
z = sin(x)*x*jn(0,y)

# Create a contour line plot
contour(x,y,z, bgcolor="black")

# Add some titles
title("contour line plot")

#This command is only necessary if running from command line
show()

########NEW FILE########
__FILENAME__ = contourf
"""This example demonstrates creating a filled contour plot using the chaco
shell subpackage.
"""

# Major library Imports
from numpy import linspace, meshgrid, tanh

# Enthought Library Imports
from chaco.shell import contourf, colormap, title, show
from chaco.default_colormaps import jet


# Crate some scalar data
xs = linspace(-10,10,200)
ys = linspace(-10,10,400)
x, y = meshgrid(xs,ys)
z = x * tanh(y)

# Create a filled contour plot
contourf(x,y,z)
colormap(jet)

# Add some titles
title("filled contour plot")

#This command is only necessary if running from command line
show()

########NEW FILE########
__FILENAME__ = dates
"""This example demonstrates using dates as labels for the axis ticks using
the chaco shell subpackage.

Try zooming in and out using the mouse wheel and see the resolution of
the dates gradually changing from days to years.
"""

# Major library imports
from numpy import linspace, pi, sin

# Enthought library imports
from chaco.shell import show, plot, title, curplot
from chaco.scales.api import CalendarScaleSystem

# Create some data
numpoints = 100
x = linspace(-2*pi, 2*pi, numpoints)
y1 = sin(x)

# Create the dates
import time
now = time.time()
dt = 24 * 3600    # data points are spaced by 1 day
dates = linspace(now, now + numpoints*dt, numpoints)

# Create some line plots
plot(dates, y1, "b-", bgcolor="white")

# Add some titles
title("Plotting Dates")

# Set the plot's horizontal axis to be a time scale
curplot().x_axis.tick_generator.scale = CalendarScaleSystem()

#This command is only necessary if running from command line
show()


########NEW FILE########
__FILENAME__ = imshow
# Standard library imports
import os.path
import sys

# Enthought library imports
from traits.util.resource import find_resource
from chaco.shell import imread, imshow, title, show

# Get the image file using the find_resource module
image_path = os.path.join('examples','basic','capitol.jpg')
alt_path = os.path.join('..','basic','capitol.jpg')
image_file = find_resource('Chaco', image_path, alt_path=alt_path)

# Check to see if the image was found
if image_file is None:
    print 'The image "capitol.jpg" could not be found.'
    sys.exit()

# Create the image
image = imread(image_file)

# Create the plot
imshow(image, origin="top left")

# Alternatively, you can call imshow using the path to the image file
#imshow(alt_path)

# Add a title
title("Simple Image Plot")

# This command is only necessary if running from command line
show()

########NEW FILE########
__FILENAME__ = lines
"""This example displays some line plots in different colors and styles using
the chaco.shell subpackage.

The functions in the chaco.shell package allow us to quickly generate plots
with some basic interactivity without using the object-oriented core of Chaco.
"""

from numpy import linspace, pi, sin, cos
from chaco.shell import plot, hold, title, show

# Create some data
x = linspace(-2*pi, 2*pi, 100)
y1 = sin(x)
y2 = cos(x)

# Create some line plots using the plot() command and using
# Matlab-style format specifiers
plot(x, y1, "b-", bgcolor="white")
hold()
plot(x, y2, "g-.", marker_size=2)

# Set the plot title
title("simple line plots")

# If running this from the command line and outside of a wxPython
# application or process, the show() command is necessary to keep
# the plot from disappearing instantly.  If a wxPython mainloop
# is already running, then this command is not necessary.
show()

########NEW FILE########
__FILENAME__ = loglog
"""This example shows how to createa log-log plot using the chaco
`shell` subpackage."""

# Major library imports
from numpy import linspace, exp

# Enthought library imports
from chaco.shell import show, title, loglog, hold


# Create some data
x = linspace(1, 15, 200)

# Create some line plots
loglog(x, x**2, "b-.", name="y=x**2", bgcolor="white")
hold(True)
loglog(x, x**4+3*x+2, "r-", name="y=x**4+3x+2", bgcolor="white")
loglog(x, exp(x), "g-", name="y=exp(x)", bgcolor="white")
loglog(x, x, "m--", name="y=x", bgcolor="white")

# Add some titles
title("simple loglog plots")

#This command is only necessary if running from command line
show()

########NEW FILE########
__FILENAME__ = pcolor
"""This example displays a pseudo-color map using the chaco.shell subpackage.

The functions in the chaco.shell package allow us to quickly generate plots
with some basic interactivity without using the object-oriented core of Chaco.
"""

# Major library imports
from numpy import linspace, meshgrid, sin

# Enthought library imports
from chaco.shell import show, title, pcolor, colormap
from chaco.default_colormaps import jet


# Crate some scalar data
xs = linspace(0,10,200)
ys = linspace(0,20,400)
x,y = meshgrid(xs,ys)
z = sin(x) * y

# Create a pseudo-color-map
pcolor(x,y,z)

#change the color mapping
colormap(jet)

# Add some titles
title("pseudo colormap image plot")

# If running this from the command line and outside of a wxPython
# application or process, the show() command is necessary to keep
# the plot from disappearing instantly.  If a wxPython mainloop
# is already running, then this command is not necessary.
show()

########NEW FILE########
__FILENAME__ = scatter
"""This example shows how to create a scatter plot using the `shell` package.
"""

# Major library imports
from numpy import linspace, random, pi

# Enthought library imports
from chaco.shell import plot, hold, title, show


# Create some data
x = linspace(-2*pi, 2*pi, 100)
y1 = random.random(100)
y2 = random.random(100)

# Create some scatter plots
plot(x, y1, "b.")
hold(True)
plot(x, y2, "g+", marker_size=2)

# Add some titles
title("simple scatter plots")

# This command is only necessary if running from command line
show()

########NEW FILE########
__FILENAME__ = semilog
"""This example shows how to create a semi-log plot using the `shell` package.
"""

# Major library imports
from numpy import linspace, exp

# Enthought library imports
from chaco.shell import semilogy, hold, title, show


# Create some data
x = linspace(1, 10, 200)

# Create some line plots
semilogy(x, exp(x), "b-", name="y=exp(x)", bgcolor="white")
hold(True)
semilogy(x, x**x, "r--", name="y=x**x")
semilogy(x, x, "g-", name="y=x")

# Add some titles
title("simple semilog plots")

#This command is only necessary if running from command line
show()


########NEW FILE########
__FILENAME__ = simple_line
"""
Draw overlapping line plots (Bessel functions)

Draws overlapping line plots with legends. Some are drawn as lines, 
some as points only.

Left-drag pans the plot.

Right-drag (in the Y direction) zooms the plot in and out.

Mousewheel up and down zooms the plot in and out.

Pressing "z" brings up the Zoom Box, and you can click-drag a rectangular
region to zoom. 

Right-drag on the legend allows you to reposition it.
"""

# Major library imports
from numpy import arange
from scipy.special import jn

# Enthought library imports
from enable.api import Component, ComponentEditor
from traits.api import Float, HasTraits, Int, Instance
from traitsui.api import Item, Group, View

# Chaco imports
from chaco.api import create_line_plot, add_default_axes, add_default_grids, \
        OverlayPlotContainer, PlotLabel, create_scatter_plot, Legend
from chaco.tools.api import PanTool, ZoomTool, LegendTool, TraitsTool, DragZoom
from chaco.example_support import COLOR_PALETTE


class OverlappingPlotContainer(OverlayPlotContainer):
    """Simple container for creating a series of plots"""

    numpoints = Int(100)
    low = Float(-5.0)
    high = Float(15.0)
    num_funs = Int(10)

    def __init__(self, *args, **kws):
        super(OverlayPlotContainer, self).__init__(*args, **kws)
        self._setup_plots()

    def _setup_plots(self):
        """Creates series of Bessel function plots"""
        plots = {}
        x = arange(self.low, self.high + 0.001,
                   (self.high - self.low) / self.numpoints)

        for i in range(self.num_funs):
            y = jn(i, x)
            if i % 2 == 1:
                plot = create_line_plot((x, y),
                                        color=tuple(COLOR_PALETTE[i]),
                                        width=2.0)
            else:
                plot = create_scatter_plot((x, y),
                                            color=tuple(COLOR_PALETTE[i]))

            if i == 0:
                value_mapper, index_mapper, legend = \
                    self._setup_plot_tools(plot)
            else:
                self._setup_mapper(plot, value_mapper, index_mapper)

            self.add(plot)
            plots["Bessel j_%d" % i] = plot

        # Set the list of plots on the legend
        legend.plots = plots

        # Add the title at the top
        self.overlays.append(PlotLabel("Bessel functions",
                                       component=self,
                                       font="swiss 16",
                                       overlay_position="top"))

        # Add the traits inspector tool to the container
        self.tools.append(TraitsTool(self))

    def _setup_plot_tools(self, plot):
        """Sets up the background, and several tools on a plot"""
        # Make a white background with grids and axes
        plot.bgcolor = "white"
        add_default_grids(plot)
        add_default_axes(plot)

        # Allow white space around plot
        plot.index_range.tight_bounds = False
        plot.index_range.refresh()
        plot.value_range.tight_bounds = False
        plot.value_range.refresh()

        # The PanTool allows panning around the plot
        plot.tools.append(PanTool(plot))

        # The ZoomTool tool is stateful and allows drawing a zoom
        # box to select a zoom region.
        zoom = ZoomTool(plot, tool_mode="box", always_on=False)
        plot.overlays.append(zoom)

        # The DragZoom tool just zooms in and out as the user drags
        # the mouse vertically.
        dragzoom = DragZoom(plot, drag_button="right")
        plot.tools.append(dragzoom)

        # Add a legend in the upper right corner, and make it relocatable
        legend = Legend(component=plot, padding=10, align="ur")
        legend.tools.append(LegendTool(legend, drag_button="right"))
        plot.overlays.append(legend)

        return plot.value_mapper, plot.index_mapper, legend

    def _setup_mapper(self, plot, value_mapper, index_mapper):
        """Sets up a mapper for given plot"""
        plot.value_mapper = value_mapper
        value_mapper.range.add(plot.value)
        plot.index_mapper = index_mapper
        index_mapper.range.add(plot.index)


size = (800, 700)
title = "Simple Line Plot"


class PlotExample(HasTraits):
    plot = Instance(Component)

    traits_view = View(
                    Group(
                        Item('plot', editor=ComponentEditor(size=size),
                             show_label=False),
                        orientation="vertical"),
                    resizable=True, title=title,
                    width=size[0], height=size[1]
                    )

    def _plot_default(self):
        return OverlappingPlotContainer(padding=50, fill_padding=True,
                                     bgcolor="lightgray", use_backbuffer=True)


demo = PlotExample()


if __name__ == "__main__":
    demo.configure_traits()

########NEW FILE########
__FILENAME__ = simple_polar
"""
Draws a static polar plot.
"""

# Major library imports
from numpy import arange, pi, cos

# Enthought library imports
from enable.api import Component, ComponentEditor
from traits.api import HasTraits, Instance
from traitsui.api import Item, Group, View

# Chaco imports
from chaco.api import create_polar_plot

#===============================================================================
# # Create the Chaco plot.
#===============================================================================
def _create_plot_component():

    # Create theta data
    numpoints = 5000
    low = 0
    high = 2*pi
    theta = arange(low, high, (high-low) / numpoints)

    # Create the radius data
    radius = cos(3*theta)

    # Create a new polar plot with radius and theta data
    plot = create_polar_plot((radius,theta),color=(0.0,0.0,1.0,1), width=4.0)

    return plot

#===============================================================================
# Attributes to use for the plot view.
size=(600,600)
title="Simple Polar Plot"

#===============================================================================
# # Demo class that is used by the demo.py application.
#===============================================================================
class Demo(HasTraits):
    plot = Instance(Component)

    traits_view = View(
                    Group(
                        Item('plot', editor=ComponentEditor(size=size),
                             show_label=False),
                        orientation = "vertical"),
                    resizable=True, title=title,
                    width=size[0], height=size[1]
                    )

    def _plot_default(self):
         return _create_plot_component()

demo = Demo()

if __name__ == "__main__":
    demo.configure_traits()

# EOF#######################

########NEW FILE########
__FILENAME__ = stacked_axis
#!/usr/bin/env python
"""
Displays multiple data sets with different scales in the same plot area,
and shows a separate, distinct, axis for each plot.

Interactions are the same as in multiaxis.py
"""

# Major library imports
from numpy import linspace
from scipy.special import jn

from chaco.example_support import COLOR_PALETTE
# Enthought library imports
from enable.api import Component, ComponentEditor
from traits.api import HasTraits, Instance
from traitsui.api import Item, Group, View

# Chaco imports
from chaco.api import HPlotContainer, \
    OverlayPlotContainer, PlotAxis, PlotGrid
from chaco.tools.api import BroadcasterTool, PanTool
from chaco.api import create_line_plot

#===============================================================================
# # Create the Chaco plot.
#===============================================================================
def _create_plot_component():

    # Create some x-y data series to plot
    plot_area = OverlayPlotContainer(border_visible=True)
    container = HPlotContainer(padding=50, bgcolor="transparent")
    #container.spacing = 15

    x = linspace(-2.0, 10.0, 100)
    for i in range(5):
        color = tuple(COLOR_PALETTE[i])
        y = jn(i, x)
        renderer = create_line_plot((x, y), color=color)
        plot_area.add(renderer)
        #plot_area.padding_left = 20

        axis = PlotAxis(orientation="left", resizable="v",
                    mapper = renderer.y_mapper,
                    axis_line_color=color,
                    tick_color=color,
                    tick_label_color=color,
                    title_color=color,
                    bgcolor="transparent",
                    title = "jn_%d" % i,
                    border_visible = True,)
        axis.bounds = [60,0]
        axis.padding_left = 10
        axis.padding_right = 10

        container.add(axis)

        if i == 4:
            # Use the last plot's X mapper to create an X axis and a
            # vertical grid
            x_axis = PlotAxis(orientation="bottom", component=renderer,
                        mapper=renderer.x_mapper)
            renderer.overlays.append(x_axis)
            grid = PlotGrid(mapper=renderer.x_mapper, orientation="vertical",
                    line_color="lightgray", line_style="dot")
            renderer.underlays.append(grid)

    # Add the plot_area to the horizontal container
    container.add(plot_area)

    # Attach some tools to the plot
    broadcaster = BroadcasterTool()
    for plot in plot_area.components:
        broadcaster.tools.append(PanTool(plot))

    # Attach the broadcaster to one of the plots.  The choice of which
    # plot doesn't really matter, as long as one of them has a reference
    # to the tool and will hand events to it.
    plot.tools.append(broadcaster)

    return container

#===============================================================================
# Attributes to use for the plot view.
size=(900,500)
title="Multi-Y plot"

#===============================================================================
# # Demo class that is used by the demo.py application.
#===============================================================================
class Demo(HasTraits):
    plot = Instance(Component)

    traits_view = View(
                    Group(
                        Item('plot', editor=ComponentEditor(size=size),
                             show_label=False),
                        orientation = "vertical"),
                    resizable=True, title=title,
                    width=size[0], height=size[1]
                    )

    def _plot_default(self):
        return _create_plot_component()

demo = Demo()

if __name__ == "__main__":
    demo.configure_traits()

#--EOF---


########NEW FILE########
__FILENAME__ = status_overlay

import numpy

from chaco.api import Plot, ArrayPlotData
from chaco.layers.api import ErrorLayer, WarningLayer, StatusLayer
from enable.component_editor import ComponentEditor
from traits.api import HasTraits, Instance, Button
from traitsui.api import UItem, View, HGroup

class MyPlot(HasTraits):
    """ Displays a plot with a few buttons to control which overlay
        to display
    """
    plot = Instance(Plot)
    status_overlay = Instance(StatusLayer)

    error_button = Button('Error')
    warn_button = Button('Warning')
    no_problem_button = Button('No problem')

    traits_view = View( HGroup(UItem('error_button'),
                               UItem('warn_button'),
                               UItem('no_problem_button')),
                        UItem('plot', editor=ComponentEditor()),
                        width=700, height=600, resizable=True,        
                        )

    def __init__(self, index, data_series, **kw):
        super(MyPlot, self).__init__(**kw)

        plot_data = ArrayPlotData(index=index)
        plot_data.set_data('data_series', data_series)
        self.plot = Plot(plot_data)
        self.plot.plot(('index', 'data_series'))

    def _error_button_fired(self, event):
        """ removes the old overlay and replaces it with
            an error overlay
        """
        self.clear_status()

        self.status_overlay = ErrorLayer(component=self.plot,
                                            align='ul', scale_factor=0.25)
        self.plot.overlays.append(self.status_overlay)

        self.plot.request_redraw()

    def _warn_button_fired(self, event):
        """ removes the old overlay and replaces it with
            an warning overlay
        """
        self.clear_status()

        self.status_overlay = WarningLayer(component=self.plot,
                                            align='ur', scale_factor=0.25)
        self.plot.overlays.append(self.status_overlay)

        self.plot.request_redraw()

    def _no_problem_button_fired(self, event):
        """ removes the old overlay
        """
        self.clear_status()
        self.plot.request_redraw()

    def clear_status(self):
        if self.status_overlay in self.plot.overlays:
            # fade_out will remove the overlay when its done
            self.status_overlay.fade_out()

index = numpy.array([1,2,3,4,5])
data_series = index**2

my_plot = MyPlot(index, data_series)
my_plot.configure_traits()

########NEW FILE########
__FILENAME__ = toolbar_plot
"""Toolbar Plot

A toolbar plot is the same as a regular Plot, but also provides a 
usually hidden drop-down toolbar with configurable buttons.

The toolbar appears when the mouse hovers over the top of the plot area.

This toolbar provides buttons for X log scale, Y log scale, Save as,
Copy image, Copy data, and Zoom reset.

"""

import numpy

from chaco.plot import Plot, ArrayPlotData
from chaco.api import ToolbarPlot
from enable.api import ComponentEditor
from traits.api import Instance, HasTraits
from traitsui.api import View, Item


class ExamplePlotApp(HasTraits):

    plot = Instance(Plot)

    traits_view = View(Item('plot', editor=ComponentEditor(),
                            width = 600, height = 600,
                            show_label=False),
                            resizable=True)

    def __init__(self, index, series1, series2, **kw):
        super(ExamplePlotApp, self).__init__(**kw)
        plot_data = ArrayPlotData(index=index)
        plot_data.set_data('series1', series1)
        plot_data.set_data('series2', series2)

        self.plot = ToolbarPlot(plot_data)
        self.plot.plot(('index', 'series1'), color='auto')
        self.plot.plot(('index', 'series2'), color='auto')

index = numpy.arange(1.0, 10., 0.01)
series1 = (100.0 + index) / (100.0 - 20*index**2 + 5.0*index**4)
series2 = (100.0 + index) / (100.0 - 20*index**2 + 5.0*index**3)
demo = ExamplePlotApp(index, series1, series2)

if __name__== '__main__':
    demo.configure_traits()

########NEW FILE########
__FILENAME__ = tornado
""" Tornado plot example from Brennan Williams """

# Major library imports
from numpy import linspace, pi, sin, ones

# Enthought library imports
from enable.api import Component, ComponentEditor
from traits.api import HasTraits, Instance
from traitsui.api import Item, View

# Chaco imports
from chaco.api import ArrayDataSource, BarPlot, DataRange1D, LabelAxis, \
                      LinearMapper, OverlayPlotContainer, PlotAxis
from chaco.example_support import COLOR_PALETTE

class PlotExample(HasTraits):
    plot = Instance(Component)

    traits_view = View(Item('plot', editor=ComponentEditor(), show_label=False),
                    resizable=True, title="Tornado Plot",
                    width=800, height=600
                    )

    def _plot_default(self):
        container = OverlayPlotContainer(bgcolor = "white")
        plots = self._make_curves()
        for plot in plots:
            plot.padding = 60
            container.add(plot)

        bottom_axis = PlotAxis(plot, orientation='bottom')

        label_list=['var a', 'var b', 'var c', 'var d', 'var e', 'var f',
                    'var g', 'var h', 'var i']
        vertical_axis = LabelAxis(plot, orientation='left',
                                title='Categories',
                                positions = range(1, 10),
                                labels=label_list)
        vertical2_axis = LabelAxis(plot, orientation='right',
                                   positions = range(1, 10),
                                   labels=label_list)

        plot.underlays.append(vertical_axis)
        plot.underlays.append(vertical2_axis)
        plot.underlays.append(bottom_axis)

        return container

    def _get_points(self):
        index = linspace(pi/4, 3*pi/2, 9)
        data = sin(index) + 2
        return (range(1, 10), data)

    def _make_curves(self):
        (index_points, value_points) = self._get_points()
        size = len(index_points)

        middle_value=2500000.0
        mid_values=middle_value*ones(size)
        low_values=mid_values-10000.0*value_points
        high_values=mid_values+20000.0*value_points

        idx = ArrayDataSource(index_points)
        vals = ArrayDataSource(low_values, sort_order="none")

        idx2 = ArrayDataSource(index_points)
        vals2 = ArrayDataSource(high_values, sort_order="none")

        starting_vals = ArrayDataSource(mid_values, sort_order="none")

        # Create the index range
        index_range = DataRange1D(idx, low=0.5, high=9.5)
        index_mapper = LinearMapper(range=index_range)

        # Create the value range
        value_range = DataRange1D(vals, vals2, low_setting='auto',
                                  high_setting='auto', tight_bounds=False)
        value_mapper = LinearMapper(range=value_range,tight_bounds=False)

        # Create the plot
        plot1 = BarPlot(index=idx, value=vals,
                        value_mapper=value_mapper,
                        index_mapper=index_mapper,
                        starting_value=starting_vals,
                        line_color='black',
                        orientation='v',
                        fill_color=tuple(COLOR_PALETTE[6]),
                        bar_width=0.8, antialias=False)

        plot2 = BarPlot(index=idx2, value=vals2,
                        value_mapper=value_mapper,
                        index_mapper=index_mapper,
                        starting_value=starting_vals,
                        line_color='black',
                        orientation='v',
                        fill_color=tuple(COLOR_PALETTE[1]),
                        bar_width=0.8, antialias=False)

        return [plot1, plot2]


demo = PlotExample()

if __name__ == "__main__":
    demo.configure_traits()

########NEW FILE########
__FILENAME__ = two_plots
""" Demonstrates plots sharing datasources, ranges, etc. """

# Major library imports
from numpy import arange
from scipy.special import jn

# Enthought library imports
from enable.api import Component, ComponentEditor
from traits.api import HasTraits, Instance
from traitsui.api import Item, Group, View

# Chaco imports
from chaco.api import HPlotContainer, ArrayPlotData, Plot
from chaco.tools.api import LineInspector, ZoomTool, PanTool


#==============================================================================
# # Create the Chaco plot.
#==============================================================================

def _create_plot_component():

    # Create the index
    numpoints = 100
    low = -5
    high = 15.0
    x = arange(low, high, (high - low) / numpoints)
    plotdata = ArrayPlotData(x=x, y1=jn(0, x), y2=jn(1, x))

    # Create the left plot
    left_plot = Plot(plotdata)
    left_plot.x_axis.title = "X"
    left_plot.y_axis.title = "j0(x)"
    renderer = left_plot.plot(("x", "y1"), type="line", color="blue",
                              width=2.0)[0]
    renderer.overlays.append(LineInspector(renderer, axis='value',
                                            write_metadata=True,
                                            is_listener=True))
    renderer.overlays.append(LineInspector(renderer, axis="index",
                                            write_metadata=True,
                                            is_listener=True))
    left_plot.overlays.append(ZoomTool(left_plot, tool_mode="range"))
    left_plot.tools.append(PanTool(left_plot))

    # Create the right plot
    right_plot = Plot(plotdata)
    right_plot.index_range = left_plot.index_range
    right_plot.orientation = "v"
    right_plot.x_axis.title = "j1(x)"
    right_plot.y_axis.title = "X"
    renderer2 = right_plot.plot(("x", "y2"), type="line", color="red",
                                width=2.0)[0]
    renderer2.index = renderer.index
    renderer2.overlays.append(LineInspector(renderer2, write_metadata=True,
                              is_listener=True))
    renderer2.overlays.append(LineInspector(renderer2, axis="value",
                              is_listener=True))
    right_plot.overlays.append(ZoomTool(right_plot, tool_mode="range"))
    right_plot.tools.append(PanTool(right_plot))

    container = HPlotContainer(background="lightgray")
    container.add(left_plot)
    container.add(right_plot)

    return container


#==============================================================================
# Attributes to use for the plot view.
size = (750, 500)
title = "Two Plots"


#==============================================================================
# # Demo class that is used by the demo.py application.
#==============================================================================

class Demo(HasTraits):

    plot = Instance(Component)

    traits_view = View(
                    Group(
                        Item('plot', editor=ComponentEditor(size=size),
                             show_label=False),
                        orientation="vertical"),
                    resizable=True, title=title,
                    )

    def _plot_default(self):
        return _create_plot_component()

demo = Demo()

if __name__ == "__main__":
    demo.configure_traits()

########NEW FILE########
__FILENAME__ = updating_plot1
#!/usr/bin/env python
"""
Demonstrates the plot responding to data updates while remaining responsive
to user interaction.  Panning and Zooming work as described in simple_line.py

There is a timer set which modifies the data that is passed to the plot.
Since the axes and grids automatically determine their range from the
dataset, they rescale each time the data changes.  This gives the zooming
in and out behavior.  As soon as the user interacts with the plot by panning
or manually zooming, the bounds of the axes are no longer "auto", and it
becomes more apparent that the plot's data is actually changing as a
function of time.

Original inspiration for this demo from Bas van Dijk.
"""
# Major library imports
from numpy import arange
from scipy.special import jn

from enable.example_support import DemoFrame, demo_main

# Enthought library imports
from enable.api import Window
from pyface.timer.api import Timer

# Chaco imports
from chaco.api import create_line_plot, add_default_axes, add_default_grids
from chaco.tools.api import PanTool, ZoomTool


class PlotFrame(DemoFrame):

    def _create_data(self):
        numpoints = 100
        low = -5
        high = 15.0
        x = arange(low, high, (high-low)/numpoints)
        y = jn(0, x)   # use the j0 bessel function

        self.numpoints = numpoints
        self.x_values = x
        self.y_values = y
        self.current_index = numpoints/2
        self.increment = 2
        return

    def _create_window(self):
        self._create_data()
        x = self.x_values[:self.current_index]
        y = self.y_values[:self.current_index]

        plot = create_line_plot((x,y), color="red", width=2.0)
        plot.padding = 50
        plot.fill_padding = True
        plot.bgcolor = "white"
        left, bottom = add_default_axes(plot)
        hgrid, vgrid = add_default_grids(plot)
        bottom.tick_interval = 2.0
        vgrid.grid_interval = 2.0


        self.plot = plot
        plot.tools.append(PanTool(component=plot))
        plot.overlays.append(ZoomTool(component=plot, tool_mode="box",
                                        always_on=False))

        self.timer = Timer(50.0, self.onTimer)
        return Window(self, -1, component=plot)

    def onTimer(self, *args):
        # adjust the index and increment
        if self.current_index <= self.numpoints/8:
            self.increment = 2
        elif self.current_index == self.numpoints:
            self.increment = -2

        self.current_index += self.increment
        if self.current_index > self.numpoints:
            self.current_index = self.numpoints

        self.plot.index.set_data(self.x_values[:self.current_index])
        self.plot.value.set_data(self.y_values[:self.current_index])
        self.plot.request_redraw()
        return


if __name__ == "__main__":
    # Save demo so that it doesn't get garbage collected when run within
    # existing event loop (i.e. from ipython).
    demo = demo_main(PlotFrame, size=(600, 500), title="Simple line plot")

########NEW FILE########
__FILENAME__ = updating_plot2
#!/usr/bin/env python
"""
A modification of updating_plot.py to show 6 different plots whose data
are being modified.

Click and drag any of the plots to reposition them.
Right-click and drag inside the plots to pan them.
Mousewheel up and down to zoom.  Zoom box is availble (see
description in simple_line.py).
"""
# Major library imports
from numpy import arange
from scipy.special import jn

# Enthought library imports
from enable.api import Window
from enable.example_support import DemoFrame, demo_main
from traits.api import HasTraits
from pyface.timer.api import Timer

# Chaco imports
from chaco.api import create_line_plot, OverlayPlotContainer
from chaco.tools.api import MoveTool, PanTool, ZoomTool


COLOR_PALETTE = ("mediumslateblue", "maroon", "darkgreen", "goldenrod",
                 "purple", "indianred")

PLOT_SIZE = 250


class AnimatedPlot(HasTraits):

    def __init__(self, x, y, color="blue", bgcolor="white"):
        self.x_values = x[:]
        self.y_values = y[:]
        self.numpoints = len(self.x_values)

        plot = create_line_plot((self.x_values,self.y_values), color=color,
                                bgcolor=bgcolor, add_grid=True, add_axis=True)
        plot.resizable = ""
        plot.bounds = [PLOT_SIZE, PLOT_SIZE]

        plot.tools.append(PanTool(plot, drag_button="right"))
        plot.tools.append(MoveTool(plot))
        plot.overlays.append(ZoomTool(plot, tool_mode="box", always_on=False))

        plot.unified_draw = True
        self.plot = plot

        self.current_index = self.numpoints/2
        self.increment = 2

    def timer_tick(self):
        if self.current_index <= self.numpoints/3:
            self.increment = 2
        elif self.current_index == self.numpoints:
            self.increment = -2
        self.current_index += self.increment
        if self.current_index > self.numpoints:
            self.current_index = self.numpoints
        self.plot.index.set_data(self.x_values[:self.current_index])
        self.plot.value.set_data(self.y_values[:self.current_index])
        self.plot.request_redraw()


class PlotFrame(DemoFrame):

    def _create_window(self):
        numpoints = 50
        low = -5
        high = 15.0
        x = arange(low, high, (high-low)/numpoints)
        container = OverlayPlotContainer(bgcolor="lightgray")

        self.animated_plots = []
        for i, color in enumerate(COLOR_PALETTE):
            animated_plot = AnimatedPlot(x, jn(i,x), color)
            container.add(animated_plot.plot)
            self.animated_plots.append(animated_plot)

        for i, a_plot in enumerate(self.animated_plots):
            a_plot.plot.position = [50 + (i%3)*(PLOT_SIZE+50),
                                    50 + (i//3)*(PLOT_SIZE+50)]

        self.timer = Timer(100.0, self.onTimer)
        self.container = container
        return Window(self, -1, component=container)

    def onTimer(self, *args):
        for plot in self.animated_plots:
            plot.timer_tick()
        return


if __name__ == "__main__":
    # Save demo so that it doesn't get garbage collected when run within
    # existing event loop (i.e. from ipython).
    demo = demo_main(PlotFrame, size=(950, 650), title="Updating line plot")

########NEW FILE########
__FILENAME__ = updating_plot3
#!/usr/bin/env python
"""
A modification of updating_plot2.py.  Now instead of each plot having its
own dataspace, the data space "views" of all six plots are linked together,
so panning and zooming in one plot will also affect all the others.
"""
# Major library imports
from numpy import arange
from scipy.special import jn

# Enthought library imports
from enable.api import Window
from enable.example_support import DemoFrame, demo_main
from traits.api import HasTraits
from pyface.timer.api import Timer

# Chaco imports
from chaco.api import create_line_plot, OverlayPlotContainer, ArrayDataSource
from chaco.tools.api import MoveTool, PanTool, ZoomTool


COLOR_PALETTE = ("mediumslateblue", "maroon", "darkgreen", "goldenrod",
                 "purple", "indianred")

PLOT_SIZE = 250


class AnimatedPlot(HasTraits):

    def __init__(self, x, y, color="blue", bgcolor="white"):
        self.y_values = y[:]
        if type(x) == ArrayDataSource:
            self.x_values = x.get_data()[:]
            plot = create_line_plot((x, self.y_values), color=color,
                                    bgcolor=bgcolor, add_grid=True,
                                    add_axis=True)
        else:
            self.x_values = x[:]
            plot = create_line_plot((self.x_values,self.y_values), color=color,
                                    bgcolor=bgcolor, add_grid=True,
                                    add_axis=True)

        plot.resizable = ""
        plot.bounds = [PLOT_SIZE, PLOT_SIZE]
        plot.unified_draw = True

        plot.tools.append(PanTool(plot, drag_button="right"))
        plot.tools.append(MoveTool(plot))
        plot.overlays.append(ZoomTool(plot, tool_mode="box", always_on=False))

        self.plot = plot
        self.numpoints = len(self.x_values)
        self.current_index = self.numpoints/2
        self.increment = 2

    def timer_tick(self):
        if self.current_index <= self.numpoints/3:
            self.increment = 2
        elif self.current_index == self.numpoints:
            self.increment = -2
        self.current_index += self.increment
        if self.current_index > self.numpoints:
            self.current_index = self.numpoints
        self.plot.index.set_data(self.x_values[:self.current_index])
        self.plot.value.set_data(self.y_values[:self.current_index])
        self.plot.request_redraw()


class PlotFrame(DemoFrame):

    def _create_window(self):
        numpoints = 50
        low = -5
        high = 15.0
        x = arange(low, high, (high-low)/numpoints)
        container = OverlayPlotContainer(bgcolor="lightgray")

        common_index = None
        index_range = None
        value_range = None
        self.animated_plots = []
        for i, color in enumerate(COLOR_PALETTE):
            if not common_index:
                animated_plot = AnimatedPlot(x, jn(i,x), color)
                common_index = animated_plot.plot.index
                index_range = animated_plot.plot.index_mapper.range
                value_range = animated_plot.plot.value_mapper.range
            else:
                animated_plot = AnimatedPlot(common_index, jn(i,x), color)
                animated_plot.plot.index_mapper.range = index_range
                animated_plot.plot.value_mapper.range = value_range
            container.add(animated_plot.plot)
            self.animated_plots.append(animated_plot)

        for i, a_plot in enumerate(self.animated_plots):
            a_plot.plot.position = [50 + (i%3)*(PLOT_SIZE+50),
                                    50 + (i//3)*(PLOT_SIZE+50)]

        self.timer = Timer(100.0, self.onTimer)
        self.container = container
        return Window(self, -1, component=container)

    def onTimer(self, *args):
        for plot in self.animated_plots:
            plot.timer_tick()
        return


if __name__ == "__main__":
    # Save demo so that it doesn't get garbage collected when run within
    # existing event loop (i.e. from ipython).
    demo = demo_main(PlotFrame, size=(950, 650), title="Updating line plot")

########NEW FILE########
__FILENAME__ = updating_plot4
#!/usr/bin/env python
"""
A modification of updating_plot3.py.

Three of the plots are now oriented vertically, but the dataspace of all
6 plots is still linked.  Panning along the X axis of a vertical plot
will move the Y axis of one of the horizontally-oriented plots, and vice
versa.
"""
# Major library imports
from numpy import arange
from scipy.special import jn

# Enthought library imports
from enable.api import Window
from enable.example_support import DemoFrame, demo_main
from traits.api import HasTraits
from pyface.timer.api import Timer

# Chaco imports
from chaco.api import create_line_plot, OverlayPlotContainer, ArrayDataSource
from chaco.tools.api import MoveTool, PanTool, ZoomTool


COLOR_PALETTE = ("mediumslateblue", "maroon", "darkgreen", "goldenrod",
                 "purple", "indianred")

PLOT_SIZE = 250


class AnimatedPlot(HasTraits):

    def __init__(self, x, y, color="blue", bgcolor="white", orientation="h"):
        self.y_values = y[:]
        if type(x) == ArrayDataSource:
            self.x_values = x.get_data()[:]
            plot = create_line_plot((x, self.y_values), color=color,
                                    bgcolor=bgcolor, add_grid=True,
                                    add_axis=True, orientation=orientation)
        else:
            self.x_values = x[:]
            plot = create_line_plot((self.x_values,self.y_values), color=color,
                                    bgcolor=bgcolor, add_grid=True,
                                    add_axis=True, orientation=orientation)

        plot.resizable = ""
        plot.bounds = [PLOT_SIZE, PLOT_SIZE]
        plot.unified_draw = True

        plot.tools.append(PanTool(plot, drag_button="right"))
        plot.tools.append(MoveTool(plot))
        plot.overlays.append(ZoomTool(plot, tool_mode="box", always_on=False))

        self.plot = plot
        self.numpoints = len(self.x_values)
        self.current_index = self.numpoints/2
        self.increment = 2

    def timer_tick(self):
        if self.current_index <= self.numpoints/3:
            self.increment = 2
        elif self.current_index == self.numpoints:
            self.increment = -2
        self.current_index += self.increment
        if self.current_index > self.numpoints:
            self.current_index = self.numpoints
        self.plot.index.set_data(self.x_values[:self.current_index])
        self.plot.value.set_data(self.y_values[:self.current_index])
        self.plot.request_redraw()


class PlotFrame(DemoFrame):

    def _create_window(self):
        numpoints = 50
        low = -5
        high = 15.0
        x = arange(low, high, (high-low)/numpoints)
        container = OverlayPlotContainer(bgcolor="lightgray")

        common_index = None
        index_range = None
        value_range = None
        self.animated_plots = []
        for i, color in enumerate(COLOR_PALETTE):
            if not common_index:
                animated_plot = AnimatedPlot(x, jn(i,x), color)
                plot = animated_plot.plot
                common_index = plot.index
                index_range = plot.index_mapper.range
                value_range = plot.value_mapper.range
            else:
                if i % 2 == 1:
                    orientation = "v"
                else:
                    orientation = "h"
                animated_plot = AnimatedPlot(common_index, jn(i,x), color,
                                             orientation=orientation)
                plot = animated_plot.plot
                plot.index_mapper.range = index_range
                plot.value_mapper.range = value_range

            container.add(plot)
            self.animated_plots.append(animated_plot)

        for i, a_plot in enumerate(self.animated_plots):
            a_plot.plot.position = [50 + (i%3)*(PLOT_SIZE+50),
                                    50 + (i//3)*(PLOT_SIZE+50)]

        self.timer = Timer(100.0, self.onTimer)
        self.container = container
        return Window(self, -1, component=container)

    def onTimer(self, *args):
        for plot in self.animated_plots:
            plot.timer_tick()
        return


if __name__ == "__main__":
    # Save demo so that it doesn't get garbage collected when run within
    # existing event loop (i.e. from ipython).
    demo = demo_main(PlotFrame, size=(950, 650), title="Updating line plot")

########NEW FILE########
__FILENAME__ = updating_plot5
#!/usr/bin/env python
"""
A modification of updating_plot4.py, except now all the plots are transparent,
and the three horizontally oriented plots have linked data views, while
the vertical plots are all independent.
"""
# Major library imports
from numpy import arange
from scipy.special import jn

# Enthought library imports
from enable.api import Window
from enable.example_support import DemoFrame, demo_main
from traits.api import HasTraits
from pyface.timer.api import Timer

# Chaco imports
from chaco.api import create_line_plot, OverlayPlotContainer, ArrayDataSource
from chaco.tools.api import MoveTool, PanTool, ZoomTool


COLOR_PALETTE = ("mediumslateblue", "maroon", "darkgreen", "goldenrod",
                 "purple", "indianred")

PLOT_SIZE = 250


class AnimatedPlot(HasTraits):

    def __init__(self, x, y, color="blue", bgcolor="none", orientation="h"):
        self.y_values = y[:]
        if type(x) == ArrayDataSource:
            self.x_values = x.get_data()[:]
            plot = create_line_plot((x, self.y_values), color=color,
                                    bgcolor=bgcolor, add_grid=True,
                                    add_axis=True, orientation=orientation)
        else:
            self.x_values = x[:]
            plot = create_line_plot((self.x_values,self.y_values), color=color,
                                    bgcolor=bgcolor, add_grid=True,
                                    add_axis=True, orientation=orientation)

        plot.resizable = ""
        plot.bounds = [PLOT_SIZE, PLOT_SIZE]
        plot.unified_draw = True

        plot.tools.append(PanTool(plot, drag_button="right"))
        plot.tools.append(MoveTool(plot))
        plot.overlays.append(ZoomTool(plot, tool_mode="box", always_on=False))

        self.plot = plot
        self.numpoints = len(self.x_values)
        self.current_index = self.numpoints/2
        self.increment = 2

    def timer_tick(self):
        if self.current_index <= self.numpoints/3:
            self.increment = 2
        elif self.current_index == self.numpoints:
            self.increment = -2
        self.current_index += self.increment
        if self.current_index > self.numpoints:
            self.current_index = self.numpoints
        self.plot.index.set_data(self.x_values[:self.current_index])
        self.plot.value.set_data(self.y_values[:self.current_index])
        self.plot.request_redraw()


class PlotFrame(DemoFrame):

    def _create_window(self):
        numpoints = 50
        low = -5
        high = 15.0
        x = arange(low, high, (high-low)/numpoints)
        container = OverlayPlotContainer(bgcolor="lightgray")

        common_index = None
        index_range = None
        value_range = None
        self.animated_plots = []
        for i, color in enumerate(COLOR_PALETTE):
            if i == 0:
                animated_plot = AnimatedPlot(x, jn(i,x), color)
                plot = animated_plot.plot
                common_index = plot.index
                index_range = plot.index_mapper.range
                value_range = plot.value_mapper.range
            elif i % 2 == 0:
                animated_plot = AnimatedPlot(common_index, jn(i,x), color)
                plot = animated_plot.plot
                plot.index_mapper.range = index_range
                plot.value_mapper.range = value_range
            else:
                animated_plot = AnimatedPlot(x, jn(i,x), color, orientation="v")
                plot = animated_plot.plot

            container.add(plot)
            self.animated_plots.append(animated_plot)

        for i, a_plot in enumerate(self.animated_plots):
            a_plot.plot.position = [50 + (i%3)*(PLOT_SIZE+50),
                                    50 + (i//3)*(PLOT_SIZE+50)]

        self.timer = Timer(100.0, self.onTimer)
        self.container = container
        return Window(self, -1, component=container)

    def onTimer(self, *args):
        for plot in self.animated_plots:
            plot.timer_tick()
        return


if __name__ == "__main__":
    # Save demo so that it doesn't get garbage collected when run within
    # existing event loop (i.e. from ipython).
    demo = demo_main(PlotFrame, size=(950, 650), title="Updating line plot")

########NEW FILE########
__FILENAME__ = vertical_plot
"""
Draw multiple side-by-side plots

Draws a static plot of bessel functions, oriented vertically, side-by-side.

You can experiment with using different orientations of containers or plots
by modifying lines 26 and 27.
"""

# Major library imports
from numpy import arange
from scipy.special import jn

from chaco.example_support import COLOR_PALETTE

# Enthought library imports
from enable.api import Component, ComponentEditor
from traits.api import HasTraits, Instance
from traitsui.api import Item, Group, View
from chaco.api import PlotLabel, VPlotContainer, HPlotContainer, \
    create_line_plot

# ======================================================================
# Change one or both of these to experiment with different orientations
# of the plot containers and the lines within each plot:
container_class = HPlotContainer # HPlotContainer or VPlotContainer
plot_orientation = 'v' # 'v' or 'h'
# ======================================================================

#===============================================================================
# # Create the Chaco plot.
#===============================================================================
def _create_plot_component():
    numpoints = 100
    low = -5
    high = 15.0
    x = arange(low, high, (high-low)/numpoints)
    container = container_class(resizable = "hv", bgcolor="lightgray",
                                fill_padding=True, padding = 10)

    # Plot some bessel functions
    value_range = None
    for i in range(10):
        y = jn(i, x)
        plot = create_line_plot((x,y), color=tuple(COLOR_PALETTE[i]), width=2.0,
                                orientation=plot_orientation)
        plot.origin_axis_visible = True
        plot.origin = "top left"
        plot.padding_left = 10
        plot.padding_right = 10
        plot.border_visible = True
        plot.bgcolor = "white"
        if value_range is None:
            value_range = plot.value_mapper.range
        else:
            plot.value_range = value_range
            value_range.add(plot.value)
        if i%2 == 1:
            plot.line_style = "dash"
        container.add(plot)

    container.padding_top = 50
    container.overlays.append(PlotLabel("Bessel Functions in a Strip Plot",
                                        component=container,
                                        font = "swiss 16",
                                        overlay_position = "top"))

    return container

#===============================================================================
# Attributes to use for the plot view.
size=(800,600)
title="Vertical Line Plot"

#===============================================================================
# # Demo class that is used by the demo.py application.
#===============================================================================
class Demo(HasTraits):
    plot = Instance(Component)

    traits_view = View(
                    Group(
                        Item('plot', editor=ComponentEditor(size=size),
                             show_label=False),
                        orientation = "vertical"),
                    resizable=True, title=title,
                    width=size[0], height=size[1]
                    )

    def _plot_default(self):
         return _create_plot_component()

demo = Demo()

if __name__ == "__main__":
    demo.configure_traits()

########NEW FILE########
__FILENAME__ = cmap_scatter
#!/usr/bin/env python
"""
Draws a colormapped scatterplot of some random data.

Interactions are the same as simple_line, and additionally, range selection
is available on the colorbar.  Right-click-drag will select a range of
colors on the colormap.  This range can be dragged around, and the main
plot will respond accordingly.  Left-click anywhere on the colorbar to
cancel the range selection.
"""

# Major library imports
from numpy import exp, sort
from numpy.random import random

# VTK-related stuff
from tvtk.api import tvtk
from mayavi import mlab
from enable.vtk_backend.vtk_window import EnableVTKWindow


# Chaco imports
from chaco.api import ArrayPlotData, ColorBar, \
    ColormappedSelectionOverlay, OverlayPlotContainer, \
    jet, LinearMapper, Plot
from chaco.tools.api import PanTool, ZoomTool, RangeSelection, \
    RangeSelectionOverlay, MoveTool

#===============================================================================
# # Create the Chaco plot.
#===============================================================================
def create_plot():

    # Create some data
    numpts = 200
    x = sort(random(numpts))
    y = random(numpts)
    color = exp(-(x**2 + y**2))

    # Create a plot data obect and give it this data
    pd = ArrayPlotData()
    pd.set_data("index", x)
    pd.set_data("value", y)
    pd.set_data("color", color)

    # Create the plot
    plot = Plot(pd)
    plot.plot(("index", "value", "color"),
              type="cmap_scatter",
              name="my_plot",
              color_mapper=jet,
              marker = "square",
              fill_alpha = 0.5,
              marker_size = 6,
              outline_color = "black",
              border_visible = True,
              bgcolor = "white")

    # Tweak some of the plot properties
    plot.title = "Colormapped Scatter Plot"
    plot.padding = 50
    plot.x_grid.visible = False
    plot.y_grid.visible = False
    plot.x_axis.font = "modern 16"
    plot.y_axis.font = "modern 16"

    # Set colors
    #plot.title_color = "white"
    #for axis in plot.x_axis, plot.y_axis:
    #    axis.set(title_color="white", tick_label_color="white")

    # Right now, some of the tools are a little invasive, and we need the
    # actual ColomappedScatterPlot object to give to them
    cmap_renderer = plot.plots["my_plot"][0]

    # Attach some tools to the plot
    plot.tools.append(PanTool(plot, constrain_key="shift"))
    zoom = ZoomTool(component=plot, tool_mode="box", always_on=False)
    plot.overlays.append(zoom)
    selection = ColormappedSelectionOverlay(cmap_renderer, fade_alpha=0.35,
                                            selection_type="mask")
    cmap_renderer.overlays.append(selection)
    plot.tools.append(MoveTool(plot, drag_button="right"))
    return plot

def create_colorbar(colormap):
    colorbar = ColorBar(index_mapper=LinearMapper(range=colormap.range),
                    color_mapper=colormap, orientation='v', resizable='',
                    height=400, width=30, padding=20)
    colorbar.tools.append(RangeSelection(component=colorbar))
    colorbar.overlays.append(RangeSelectionOverlay(component=colorbar,
           border_color="white", alpha=0.8, fill_color="lightgray"))
    colorbar.tools.append(MoveTool(colorbar, drag_button="left"))
    return colorbar

def start_vtk(component):
    f = mlab.figure(size=(700,500))
    m = mlab.test_mesh()
    scene = mlab.gcf().scene
    render_window = scene.render_window
    renderer = scene.renderer
    rwi = scene.interactor
    window = EnableVTKWindow(rwi, renderer,
            component = component,
            istyle_class = tvtk.InteractorStyleTrackballCamera,
            bgcolor = "transparent",
            event_passthrough = True,
            )
    mlab.show()

def main():
    plot = create_plot()
    plot.bounds = [400,300]
    plot.outer_position = [30,30]
    plot.resizable = ""
    cmap_renderer = plot.plots["my_plot"][0]

    # Create the colorbar, handing in the appropriate range and colormap
    colorbar = create_colorbar(plot.color_mapper)
    colorbar.outer_position = [450,30]
    colorbar.plot = cmap_renderer
    colorbar.padding_top = plot.padding_top
    colorbar.padding_bottom = plot.padding_bottom

    container = OverlayPlotContainer(bgcolor = "transparent",
                    fit_window = True)
    container.add(plot)
    container.add(colorbar)

    start_vtk(container)


if __name__ == "__main__":
    main()


########NEW FILE########
__FILENAME__ = spectrum
#!/usr/bin/env python
"""
This plot displays the audio spectrum from the microphone.

Based on updating_plot.py
"""

# Major library imports
import pyaudio
from numpy import zeros, linspace, short, fromstring, hstack, transpose
from scipy import fft

# Enthought library imports
from chaco.default_colormaps import jet
from traits.api import HasTraits, Any

# Chaco imports
from chaco.api import Plot, ArrayPlotData, OverlayPlotContainer
from chaco.tools.api import MoveTool, PanTool, ZoomTool

NUM_SAMPLES = 1024
SAMPLING_RATE = 11025
SPECTROGRAM_LENGTH = 100


def create_plot_component(obj):
    # Setup the spectrum plot
    frequencies = linspace(0., float(SAMPLING_RATE)/2, num=NUM_SAMPLES/2)
    obj.spectrum_data = ArrayPlotData(frequency=frequencies)
    empty_amplitude = zeros(NUM_SAMPLES/2)
    obj.spectrum_data.set_data('amplitude', empty_amplitude)

    obj.spectrum_plot = Plot(obj.spectrum_data)
    obj.spectrum_plot.plot(("frequency", "amplitude"), name="Spectrum",
                           color="red")
    obj.spectrum_plot.padding = 50
    obj.spectrum_plot.title = "Spectrum"
    spec_range = obj.spectrum_plot.plots.values()[0][0].value_mapper.range
    spec_range.low = 0.0
    spec_range.high = 5.0
    obj.spectrum_plot.index_axis.title = 'Frequency (hz)'
    obj.spectrum_plot.value_axis.title = 'Amplitude'

    # Time Series plot
    times = linspace(0., float(NUM_SAMPLES)/SAMPLING_RATE, num=NUM_SAMPLES)
    obj.time_data = ArrayPlotData(time=times)
    empty_amplitude = zeros(NUM_SAMPLES)
    obj.time_data.set_data('amplitude', empty_amplitude)

    obj.time_plot = Plot(obj.time_data)
    obj.time_plot.plot(("time", "amplitude"), name="Time", color="blue")
    obj.time_plot.padding = 50
    obj.time_plot.title = "Time"
    obj.time_plot.index_axis.title = 'Time (seconds)'
    obj.time_plot.value_axis.title = 'Amplitude'
    time_range = obj.time_plot.plots.values()[0][0].value_mapper.range
    time_range.low = -0.2
    time_range.high = 0.2

    # Spectrogram plot
    spectrogram_data = zeros(( NUM_SAMPLES/2, SPECTROGRAM_LENGTH))
    obj.spectrogram_plotdata = ArrayPlotData()
    obj.spectrogram_plotdata.set_data('imagedata', spectrogram_data)
    spectrogram_plot = Plot(obj.spectrogram_plotdata)
    spectrogram_time = linspace(
        0.0, float(SPECTROGRAM_LENGTH*NUM_SAMPLES)/float(SAMPLING_RATE),
        num=SPECTROGRAM_LENGTH)
    spectrogram_freq = linspace(0.0, float(SAMPLING_RATE/2), num=NUM_SAMPLES/2)
    xbounds = (spectrogram_time[0], spectrogram_time[-1])
    ybounds = (spectrogram_freq[0], spectrogram_freq[-1])
    spectrogram_plot.img_plot('imagedata',
                              name='Spectrogram',
                              xbounds=xbounds,
                              ybounds=ybounds,
                              colormap=jet,
                              )
    range_obj = spectrogram_plot.plots['Spectrogram'][0].value_mapper.range
    range_obj.high = 5
    range_obj.low = 0.0
    spectrogram_plot.title = 'Spectrogram'
    obj.spectrogram_plot = spectrogram_plot

    return obj.spectrum_plot, obj.time_plot, obj.spectrogram_plot

_stream = None
def get_audio_data():
    global _stream
    if _stream is None:
        # The audio stream is opened the first time this function gets called.
        # The stream is always closed (if it was opened) in a try finally
        # block at the end of this file,
        pa = pyaudio.PyAudio()
        _stream = pa.open(format=pyaudio.paInt16, channels=1,
                          rate=SAMPLING_RATE,
                          input=True, frames_per_buffer=NUM_SAMPLES)

    audio_data  = fromstring(_stream.read(NUM_SAMPLES), dtype=short)
    normalized_data = audio_data / 32768.0
    return (abs(fft(normalized_data))[:NUM_SAMPLES/2], normalized_data)

class TimerController(HasTraits):
    interactor = Any()
    timer_id = Any()

    def on_timer(self, vtk_obj=None, eventname=""):
        try:
            spectrum, time = get_audio_data()
        except IOError:
            return
        self.spectrum_data.set_data('amplitude', spectrum)
        self.time_data.set_data('amplitude', time)
        spectrogram_data = self.spectrogram_plotdata.get_data('imagedata')
        spectrogram_data = hstack((spectrogram_data[:,1:],
                                   transpose([spectrum])))

        self.spectrogram_plotdata.set_data('imagedata', spectrogram_data)
        self.spectrum_plot.request_redraw()
        return

def main():
    from tvtk.api import tvtk
    from mayavi import mlab
    from enable.vtk_backend.vtk_window import EnableVTKWindow
    f = mlab.figure(size=(900,850))
    m = mlab.test_mesh()
    scene = mlab.gcf().scene
    render_window = scene.render_window
    renderer = scene.renderer
    rwi = scene.interactor

    # Create the plot
    timer_controller = TimerController()
    plots = create_plot_component(timer_controller)
    specplot, timeplot, spectrogram = plots

    for i, p in enumerate(plots):
        p.set(resizable = "", bounds = [200,200], outer_x = 0,
                bgcolor = "transparent",
                )
        p.outer_y = i*250
        p.tools.append(MoveTool(p, drag_button="right"))
        p.tools.append(PanTool(p))
        p.tools.append(ZoomTool(p))

    spectrogram.tools[-1].set(tool_mode="range", axis="value")
    spectrogram.tools[-2].set(constrain=True, constrain_direction="y")

    container = OverlayPlotContainer(bgcolor = "transparent",
                    fit_window = True)
    container.add(*plots)
    container.timer_callback = timer_controller.on_timer

    window = EnableVTKWindow(rwi, renderer,
            component = container,
            istyle_class = tvtk.InteractorStyleTrackballCamera,
            bgcolor = "transparent",
            event_passthrough = True,
            )

    mlab.show()

if __name__ == "__main__":
    main()


########NEW FILE########
__FILENAME__ = vtk_example

from numpy import linspace
from scipy.special import jn

from tvtk.api import tvtk
from mayavi import mlab
from enable.vtk_backend.vtk_window import EnableVTKWindow
from chaco.api import ArrayPlotData, Plot, OverlayPlotContainer
from chaco.tools.api import PanTool, ZoomTool, MoveTool

def main():
    # Create some x-y data series to plot
    x = linspace(-2.0, 10.0, 100)
    pd = ArrayPlotData(index = x)
    for i in range(5):
        pd.set_data("y" + str(i), jn(i,x))

    # Create some line plots of some of the data
    plot = Plot(pd, bgcolor="none", padding=30, border_visible=True,
                 overlay_border=True, use_backbuffer=False)
    plot.legend.visible = True
    plot.plot(("index", "y0", "y1", "y2"), name="j_n, n<3", color="auto")
    plot.plot(("index", "y3"), name="j_3", color="auto")
    plot.tools.append(PanTool(plot))
    zoom = ZoomTool(component=plot, tool_mode="box", always_on=False)
    plot.overlays.append(zoom)

    # Create the mlab test mesh and get references to various parts of the
    # VTK pipeline
    f = mlab.figure(size=(600,500))
    m = mlab.test_mesh()
    scene = mlab.gcf().scene
    render_window = scene.render_window
    renderer = scene.renderer
    rwi = scene.interactor

    plot.resizable = ""
    plot.bounds = [200,200]
    plot.padding = 25
    plot.bgcolor = "lightgray"
    plot.outer_position = [30,30]
    plot.tools.append(MoveTool(component=plot,drag_button="right"))

    container = OverlayPlotContainer(bgcolor = "transparent",
                    fit_window = True)
    container.add(plot)

    # Create the Enable Window
    window = EnableVTKWindow(rwi, renderer,
            component=container,
            #istyle_class = tvtk.InteractorStyleSwitch,
            #istyle_class = tvtk.InteractorStyle,
            istyle_class = tvtk.InteractorStyleTrackballCamera,
            bgcolor = "transparent",
            event_passthrough = True,
            )

    mlab.show()
    return window, render_window

if __name__=="__main__":
    main()


########NEW FILE########
__FILENAME__ = vtk_example

from numpy import linspace
from scipy.special import jn

from tvtk.api import tvtk
from mayavi import mlab
from enable.vtk_backend.vtk_window import EnableVTKWindow
from chaco.api import ArrayPlotData, Plot, OverlayPlotContainer
from chaco.tools.api import PanTool, ZoomTool, MoveTool

def main():
    # Create some x-y data series to plot
    x = linspace(-2.0, 10.0, 100)
    pd = ArrayPlotData(index = x)
    for i in range(5):
        pd.set_data("y" + str(i), jn(i,x))

    # Create some line plots of some of the data
    plot = Plot(pd, bgcolor="none", padding=30, border_visible=True,
                 overlay_border=True, use_backbuffer=False)
    plot.legend.visible = True
    plot.plot(("index", "y0", "y1", "y2"), name="j_n, n<3", color="auto")
    plot.plot(("index", "y3"), name="j_3", color="auto")
    plot.tools.append(PanTool(plot))
    zoom = ZoomTool(component=plot, tool_mode="box", always_on=False)
    plot.overlays.append(zoom)

    # Create the mlab test mesh and get references to various parts of the
    # VTK pipeline
    f = mlab.figure(size=(600,500))
    m = mlab.test_mesh()
    scene = mlab.gcf().scene
    render_window = scene.render_window
    renderer = scene.renderer
    rwi = scene.interactor

    plot.resizable = ""
    plot.bounds = [200,200]
    plot.padding = 25
    plot.outer_position = [30,30]
    plot.tools.append(MoveTool(component=plot,drag_button="right"))

    container = OverlayPlotContainer(bgcolor = "transparent",
                    fit_window = True)
    container.add(plot)

    # Create the Enable Window
    window = EnableVTKWindow(rwi, renderer,
            component=container,
            #istyle_class = tvtk.InteractorStyleSwitch,
            #istyle_class = tvtk.InteractorStyle,
            istyle_class = tvtk.InteractorStyleTrackballCamera,
            bgcolor = "transparent",
            event_passthrough = True,
            )

    mlab.show()
    return window, render_window

if __name__=="__main__":
    main()


########NEW FILE########
__FILENAME__ = world_map
#!/usr/bin/env python
"""
Displays a world map with locations plotted on top. Locations are expected to
be tuples of latitude, longitude where West and South are expressed as
negative values.
 - Mousewheel up and down zooms the plot in and out.
 - Pressing "z" brings up the Zoom Box, and you can click-drag a rectangular
   region to zoom.  If you use a sequence of zoom boxes, pressing alt-left-arrow
   and alt-right-arrow moves you forwards and backwards through the "zoom
   history".
"""

# Standard library imports
import os.path
import urllib

# Major library imports
import numpy

# ETS imports
from chaco.api import Plot, ArrayPlotData, ImageData
from chaco.tools.api import ZoomTool
from enable.component_editor import ComponentEditor
from traits.api import HasTraits, Instance, Str
from traitsui.api import Item, View

class WorldMapPlot(HasTraits):

    ### Public Traits ##########################################################

    # The plot which will be displayed
    plot = Instance(Plot)

    # The URL which points to the world map image to be downloaded
    image_url = Str("http://eoimages.gsfc.nasa.gov/ve//2433/land_shallow_topo_2048.jpg")


    ### Private Traits #########################################################

    # The path to where the image exists on the filesystem
    image_path = Str()

    # The view
    traits_view = View(Item('plot', editor=ComponentEditor(),
                            width=800, height=400, show_label=False),
                       resizable=True)

    #---------------------------------------------------------------------------
    # Public interface
    #---------------------------------------------------------------------------

    def __init__(self, **kw):
        super(WorldMapPlot, self).__init__(**kw)

        self._download_map_image()
        image = ImageData.fromfile(self.image_path)

        # For now, the locations are hardcoded, though this can be changed
        # eassily to take command line args, read from a file, or by other
        # means
        austin_loc = (30.16, -97.44)

        locations_x = numpy.array([austin_loc[1]])
        locations_y = numpy.array([austin_loc[0]])

        # transform each of the locations to the image data space, including
        # moving the origin from bottom left to top left
        locations_x = (locations_x + 180) * image.data.shape[1]/360
        locations_y = (locations_y*-1 + 90) * image.data.shape[0]/180

        # Create the plott data, adding the image and the locations
        plot_data = ArrayPlotData()
        plot_data.set_data("imagedata", image._data)
        plot_data.set_data("locations_x", locations_x)
        plot_data.set_data("locations_y", locations_y)

        # Create the plot with the origin as top left, which matches
        # how the image data is aligned
        self.plot = Plot(plot_data, default_origin="top left")
        self.plot.img_plot('imagedata')

        # Plot the locations as a scatter plot to be overlayed on top
        # of the map
        loc_plot = self.plot.plot(('locations_x',  'locations_y'),
                                    type='scatter', size=3, color='yellow',
                                    marker='dot')[0]

        loc_plot.x_mapper.range.high = image.data.shape[1]
        loc_plot.x_mapper.range.low = 0
        loc_plot.y_mapper.range.high = image.data.shape[0]
        loc_plot.y_mapper.range.low = -0

        # set up any tools, in this case just the zoom tool
        zoom = ZoomTool(component=self.plot, tool_mode="box", always_on=False)
        self.plot.overlays.append(zoom)

    #---------------------------------------------------------------------------
    # Protected interface
    #---------------------------------------------------------------------------

    def _download_map_image(self):
        """ Downloads a map from the image_url attribute. This is done
            primarily to keep the redistributable Chaco package as small
            as possible
        """
        example_dir = os.path.dirname(__file__)
        self.image_path = os.path.join(example_dir, 'data',
                                        os.path.split(self.image_url)[1])

        if not os.path.exists(self.image_path):
            print "Downloading map image"
            urllib.urlretrieve(self.image_url, self.image_path)

#===============================================================================
# demo object that is used by the demo.py application.
#===============================================================================
demo = WorldMapPlot()

if __name__ == "__main__":
    demo.configure_traits()

########NEW FILE########
__FILENAME__ = xray_plot
"""
Implementation of a plot using a custom overlay and tool
"""

from __future__ import with_statement

import numpy

from traits.api import HasTraits, Instance, Enum
from traitsui.api import View, Item
from enable.api import ComponentEditor
from chaco.api import Plot, ArrayPlotData, AbstractOverlay
from enable.api import BaseTool
from enable.markers import DOT_MARKER, DotMarker


class BoxSelectTool(BaseTool):
    """ Tool for selecting all points within a box

        There are 2 states for this tool, normal and selecting. While the
        left mouse button is down the metadata on the datasources will be
        updated with the current selected bounds.

        Note that the tool does not actually store the selected point, but the
        bounds of the box.
    """

    event_state = Enum("normal", "selecting")

    def normal_left_down(self, event):
        self.event_state = "selecting"
        self.selecting_mouse_move(event)

    def selecting_left_up(self, event):
        self.event_state = "normal"

    def selecting_mouse_move(self, event):
        x1, y1 = self.map_to_data(event.x - 25, event.y - 25)
        x2, y2 = self.map_to_data(event.x + 25, event.y + 25)

        index_datasource = self.component.index
        index_datasource.metadata['selections'] = (x1, x2)

        value_datasource = self.component.value
        value_datasource.metadata['selections'] = (y1, y2)

        self.component.request_redraw()

    def map_to_data(self, x, y):
        """ Returns the data space coordinates of the given x and y.

        Takes into account orientation of the plot and the axis setting.
        """

        plot = self.component
        if plot.orientation == "h":
            index = plot.x_mapper.map_data(x)
            value = plot.y_mapper.map_data(y)
        else:
            index = plot.y_mapper.map_data(y)
            value = plot.x_mapper.map_data(x)

        return index, value


class XRayOverlay(AbstractOverlay):
    """ Overlay which draws scatter markers on top of plot data points.

        This overlay should be combined with a tool which updates the
        datasources metadata with selection bounds.
    """

    marker = DotMarker()

    def overlay(self, component, gc, view_bounds=None, mode='normal'):
        x_range = self._get_selection_index_screen_range()
        y_range = self._get_selection_value_screen_range()

        if len(x_range) == 0:
            return

        x1, x2 = x_range
        y1, y2 = y_range

        with gc:
            gc.set_alpha(0.8)
            gc.set_fill_color((1.0, 1.0, 1.0))
            gc.rect(x1, y1, x2 - x1, y2 - y1)
            gc.draw_path()

        pts = self._get_selected_points()
        if len(pts) == 0:
            return
        screen_pts = self.component.map_screen(pts)
        if hasattr(gc, 'draw_marker_at_points'):
            gc.draw_marker_at_points(screen_pts, 3, DOT_MARKER)
        else:
            gc.save_state()
            for sx, sy in screen_pts:
                gc.translate_ctm(sx, sy)
                gc.begin_path()
                self.marker.add_to_path(gc, 3)
                gc.draw_path(self.marker.draw_mode)
                gc.translate_ctm(-sx, -sy)
            gc.restore_state()

    def _get_selected_points(self):
        """ gets all the points within the bounds defined in the datasources
            metadata
        """
        index_datasource = self.component.index
        index_selection = index_datasource.metadata['selections']
        index = index_datasource.get_data()

        value_datasource = self.component.value
        value_selection = value_datasource.metadata['selections']
        value = value_datasource.get_data()

        x_indices = numpy.where((index > index_selection[0]) &
                                (index < index_selection[-1]))
        y_indices = numpy.where((value > value_selection[0]) &
                                (value < value_selection[-1]))

        indices = list(set(x_indices[0]) & set(y_indices[0]))

        sel_index = index[indices]
        sel_value = value[indices]

        return zip(sel_index, sel_value)

    def _get_selection_index_screen_range(self):
        """ maps the selected bounds which were set by the tool into screen
            space. The screen space points can be used for drawing the overlay
        """
        index_datasource = self.component.index
        index_mapper = self.component.index_mapper
        index_selection = index_datasource.metadata['selections']
        return tuple(index_mapper.map_screen(numpy.array(index_selection)))

    def _get_selection_value_screen_range(self):
        """ maps the selected bounds which were set by the tool into screen
            space. The screen space points can be used for drawing the overlay
        """
        value_datasource = self.component.value
        value_mapper = self.component.value_mapper
        value_selection = value_datasource.metadata['selections']
        return tuple(value_mapper.map_screen(numpy.array(value_selection)))


class PlotExample(HasTraits):

    plot = Instance(Plot)

    traits_view = View(Item('plot', editor=ComponentEditor()),
                       width=600, height=600)

    def __init__(self, index, value, *args, **kw):
        super(PlotExample, self).__init__(*args, **kw)

        plot_data = ArrayPlotData(index=index)
        plot_data.set_data('value', value)

        self.plot = Plot(plot_data)
        line = self.plot.plot(('index', 'value'))[0]

        line.overlays.append(XRayOverlay(line))
        line.tools.append(BoxSelectTool(line))

index = numpy.arange(0, 25, 0.25)
value = numpy.sin(index) + numpy.arange(0, 10, 0.1)

example = PlotExample(index, value)
example.configure_traits()

########NEW FILE########
__FILENAME__ = grid_plot_factory

# Local relative imports
from chaco.api import ArrayDataSource, DataRange1D, LinearMapper, LinePlot, \
                                 ScatterPlot, PlotAxis, PlotGrid


def create_gridded_line_plot(x, y, orientation="h", color="red", width=1.0,
                             dash="solid", value_mapper_class=LinearMapper,
                             padding=30):

    assert len(x) == len(y)

    # If you know it is monotonically increasing, sort_order can
    # be set to 'ascending'
    index = ArrayDataSource(x,sort_order='none')
    value = ArrayDataSource(y, sort_order="none")

    index_range = DataRange1D(tight_bounds = False)
    index_range.add(index)
    index_mapper = LinearMapper(range=index_range)

    value_range = DataRange1D(tight_bounds = False)
    value_range.add(value)
    value_mapper = value_mapper_class(range=value_range)

    plot = LinePlot(index=index, value=value,
                    index_mapper = index_mapper,
                    value_mapper = value_mapper,
                    orientation = orientation,
                    color = color,
                    line_width = width,
                    line_style = dash,
                    padding = [40, 15, 15, 20],   # left, right, top, bottom
                    border_visible = True,
                    border_width = 1,
                    bgcolor = "white",
                    use_backbuffer = True,
                    backbuffer_padding = False,
                    unified_draw = True,
                    draw_layer = "plot",
                    overlay_border = True)

    vertical_grid = PlotGrid(component = plot,
                             mapper=index_mapper,
                             orientation='vertical',
                             line_color="gray",
                             line_style='dot',
                             use_draw_order = True)

    horizontal_grid = PlotGrid(component = plot,
                               mapper=value_mapper,
                               orientation='horizontal',
                               line_color="gray",
                               line_style='dot',
                               use_draw_order = True)

    vertical_axis = PlotAxis(orientation='left',
                             mapper=plot.value_mapper,
                             use_draw_order = True)

    horizontal_axis = PlotAxis(orientation='bottom',
                               title='Time (s)',
                               mapper=plot.index_mapper,
                               use_draw_order = True)

    plot.underlays.append(vertical_grid)
    plot.underlays.append(horizontal_grid)

    # Have to add axes to overlays because we are backbuffering the main plot,
    # and only overlays get to render in addition to the backbuffer.
    plot.overlays.append(vertical_axis)
    plot.overlays.append(horizontal_axis)
    return plot

def create_gridded_scatter_plot(x, y, orientation="h", color="red", width=1.0,
                                fill_color="red", marker="square", marker_size=2,
                                value_mapper_class=LinearMapper, padding=30):

    assert len(x) == len(y)

    # If you know it is monotonically increasing, sort_order can
    # be set to 'ascending'
    index = ArrayDataSource(x,sort_order='none')
    value = ArrayDataSource(y, sort_order="none")

    index_range = DataRange1D(tight_bounds = False)
    index_range.add(index)
    index_mapper = LinearMapper(range=index_range)

    value_range = DataRange1D(tight_bounds = False)
    value_range.add(value)
    value_mapper = value_mapper_class(range=value_range)

    plot = ScatterPlot(index=index, value=value,
                        index_mapper = index_mapper,
                        value_mapper = value_mapper,
                        orientation = orientation,
                        color = color,
                        fill_color=fill_color,
                        marker=marker,
                        marker_size=marker_size,
                        padding = [40, 15, 15, 20],   # left, right, top, bottom
                        border_visible = True,
                        border_width = 1,
                        bgcolor = "white",
                        use_backbuffer = True,
                        backbuffer_padding = False,
                        unified_draw = True,
                        draw_layer = "plot",
                        overlay_border = True)

    vertical_grid = PlotGrid(component = plot,
                             mapper=index_mapper,
                             orientation='vertical',
                             line_color="gray",
                             line_style='dot',
                             use_draw_order = True)

    horizontal_grid = PlotGrid(component = plot,
                               mapper=value_mapper,
                               orientation='horizontal',
                               line_color="gray",
                               line_style='dot',
                               use_draw_order = True)

    vertical_axis = PlotAxis(orientation='left',
                             mapper=plot.value_mapper,
                             use_draw_order = True)

    horizontal_axis = PlotAxis(orientation='bottom',
                               title='Time (s)',
                               mapper=plot.index_mapper,
                               use_draw_order = True)

    plot.underlays.append(vertical_grid)
    plot.underlays.append(horizontal_grid)

    # Have to add axes to overlays because we are backbuffering the main plot,
    # and only overlays get to render in addition to the backbuffer.
    plot.overlays.append(vertical_axis)
    plot.overlays.append(horizontal_axis)
    return plot




########NEW FILE########
__FILENAME__ = wav_to_numeric
#! /bin/env python

# Standard library imports
import os.path
import wave
import numpy

# Enthought library imports
from traits.util.resource import find_resource

def wav_to_numeric( fname, max_frames=-1 ):
  f = wave.open( fname, 'rb' )
  sampleRate = f.getframerate()
  channels = f.getnchannels()

  if max_frames < 0:
      max_frames = f.getnframes()

  frames = f.readframes(max_frames)

  if f.getsampwidth() == 2:
      data = numpy.fromstring(frames, numpy.uint16).astype(numpy.float64) - (2**15 - 0.5)
  else:
      data = numpy.fromstring(frames, numpy.uint8).astype(numpy.float64) - 127.5

  if channels == 2:
      left = data[0::2]
      right = data[1::2]

      data = left

  index = numpy.arange(len(data)) * 1.0/sampleRate

  return index, data

def test():
    sample_path = os.path.join('examples','data','sample.wav')
    alt_path = os.path.join('..','data','sample.wav')
    fname = find_resource('Chaco', sample_path, alt_path=alt_path,
        return_path=True)
    index, data = wav_to_numeric(fname)
    print data[:100]
    return index, data

if __name__== '__main__':
    test()


########NEW FILE########
__FILENAME__ = zoom_overlay

from __future__ import with_statement

from numpy import array, amax, amin

from enable.api import ColorTrait, Component
from traits.api import Float, Instance, Int
from chaco.api import AbstractOverlay, BaseXYPlot


class ZoomOverlay(AbstractOverlay):
    """
    Draws a trapezoidal selection overlay from the source plot to the
    destination plot.  Assumes that the source plot lies above the destination
    plot.
    """

    source = Instance(BaseXYPlot)
    destination = Instance(Component)

    border_color = ColorTrait((0, 0, 0.7, 1))
    border_width = Int(1)
    fill_color = ColorTrait("dodgerblue")
    alpha = Float(0.3)

    def calculate_points(self, component):
        """
        Calculate the overlay polygon based on the selection and the location
        of the source and destination plots.
        """
        # find selection range on source plot
        x_start, x_end = self._get_selection_screencoords()
        if x_start > x_end:
            x_start, x_end = x_end, x_start

        y_end = self.source.y
        y_start = self.source.y2

        left_top = array([x_start, y_start])
        left_mid = array([x_start, y_end])
        right_top = array([x_end, y_start])
        right_mid = array([x_end, y_end])

        # Offset y because we want to avoid overlapping the trapezoid with the topmost
        # pixels of the destination plot.
        y = self.destination.y2 + 1

        left_end = array([self.destination.x, y])
        right_end = array([self.destination.x2, y])

        polygon = array((left_top, left_mid, left_end,
                         right_end,right_mid, right_top))
        left_line = array((left_top, left_mid, left_end))
        right_line = array((right_end,right_mid, right_top))

        return left_line, right_line, polygon

    def overlay(self, component, gc, view_bounds=None, mode="normal"):
        """
        Draws this overlay onto 'component', rendering onto 'gc'.
        """

        tmp = self._get_selection_screencoords()
        if tmp is None:
            return

        left_line, right_line, polygon = self.calculate_points(component)

        with gc:
            gc.translate_ctm(*component.position)
            gc.set_alpha(self.alpha)
            gc.set_fill_color(self.fill_color_)
            gc.set_line_width(self.border_width)
            gc.set_stroke_color(self.border_color_)
            gc.begin_path()
            gc.lines(polygon)
            gc.fill_path()

            gc.begin_path()
            gc.lines(left_line)
            gc.lines(right_line)
            gc.stroke_path()

        return

    def _get_selection_screencoords(self):
        """
        Returns a tuple of (x1, x2) screen space coordinates of the start
        and end selection points.  If there is no current selection, then
        returns None.
        """
        selection = self.source.index.metadata["selections"]
        if selection is not None and len(selection) == 2:
            mapper = self.source.index_mapper
            return mapper.map_screen(array(selection))
        else:
            return None

    #------------------------------------------------------------------------
    # Trait event handlers
    #------------------------------------------------------------------------

    def _source_changed(self, old, new):
        if old is not None and old.controller is not None:
            old.controller.on_trait_change(self._selection_update_handler, "selection",
                                           remove=True)
        if new is not None and new.controller is not None:
            new.controller.on_trait_change(self._selection_update_handler, "selection")
        return

    def _selection_update_handler(self, value):
        if value is not None and self.destination is not None:
            r = self.destination.index_mapper.range
            start, end = amin(value), amax(value)
            r.low = start
            r.high = end

        self.source.request_redraw()
        self.destination.request_redraw()
        return

########NEW FILE########
__FILENAME__ = zoom_plot
"""
The main executable file for the zoom_plot demo.

Right-click and drag on the upper plot to select a region to view in detail
in the lower plot.  The selected region can be moved around by dragging,
or resized by clicking on one of its edges and dragging. The ZoomPlot class
encapsulates the creation of a zoom plot and exposes some of the attributes and
methods necessary for deep interaction with the plot.
"""
# Standard library imports
import os

# Major library imports
from numpy import sin, pi, linspace

# Enthought imports
from enable.api import Component, ComponentEditor
from traits.api import HasTraits, Instance
from traitsui.api import Item, Group, View
from traits.util.resource import find_resource

# Chaco imports
from chaco.api import VPlotContainer, ArrayPlotData, Plot, PlotGrid, PlotAxis
from chaco.tools.api import RangeSelection

# Relative imports
from zoom_overlay import ZoomOverlay

sample_path = os.path.join('examples','data','sample.wav')
alt_path = os.path.join('..','data','sample.wav')
fname = find_resource('Chaco', sample_path, alt_path=alt_path,
    return_path=True)
numpts = 3000

def read_music_data():
    from wav_to_numeric import wav_to_numeric
    index, data = wav_to_numeric(fname)
    return index[:numpts], data[:numpts]


class ZoomPlot(HasTraits):
    '''Encapsulation of the zoom plot concept.

    This class organzies the data, plot container and ZoomOverlay required for
    a zoom plot. ZoomPlot represents the first step towards a reusable and
    extensible generalization of the zoom plot.

    '''

    data = Instance(ArrayPlotData)

    plot = Instance(Component)
    
    def update_data(self, x, y):
        '''Update the data in the plot windows'''
        # FIXME: This isn't forcing the update, so the crufty code below is used.
        #self.plot.data['x'] = x
        #self.plot.data['y'] = y
        self.plot.components[0].index.set_data(x)
        self.plot.components[0].value.set_data(y)
        self.plot.components[1].index.set_data(x)
        self.plot.components[1].value.set_data(y)

    def _data_default(self):
        x = linspace(0, 4*pi, 1201)
        y = sin(x**2)

        data = ArrayPlotData(x=x, y=y)
        
        return data

    def _plot_default(self):
        plotter = Plot(data=self.data)
        main_plot = plotter.plot(['x','y'])[0]
        self.configure_plot(main_plot, xlabel='')

        plotter2 = Plot(data=self.data)
        zoom_plot = plotter2.plot(['x','y'])[0]
        self.configure_plot(zoom_plot)
        
        outer_container = VPlotContainer(padding=20,
                                         fill_padding=True,
                                         spacing=0,
                                         stack_order='top_to_bottom',
                                         bgcolor='lightgray',
                                         use_backbuffer=True)

        outer_container.add(main_plot)
        outer_container.add(zoom_plot)
        # FIXME: This is set to the windows bg color.  Should get from the system.
        #outer_container.bgcolor = (236/255., 233/255., 216/255., 1.0)

        main_plot.controller = RangeSelection(main_plot)
        
        zoom_overlay = ZoomOverlay(source=main_plot, destination=zoom_plot)
        outer_container.overlays.append(zoom_overlay)

        return outer_container

    @staticmethod
    def configure_plot(plot, xlabel='Time (s)'):
        """ Set up colors, grids, etc. on plot objects.
        """
        plot.bgcolor = 'white'
        plot.border_visible = True
        plot.padding = [40, 15, 15, 20]
        plot.color = 'darkred'
        plot.line_width = 1.1
        
        vertical_grid = PlotGrid(component=plot,
                                mapper=plot.index_mapper,
                                orientation='vertical',
                                line_color="gray",
                                line_style='dot',
                                use_draw_order = True)

        horizontal_grid = PlotGrid(component=plot,
                                mapper=plot.value_mapper,
                                orientation='horizontal',
                                line_color="gray",
                                line_style='dot',
                                use_draw_order = True)

        vertical_axis = PlotAxis(orientation='left',
                                mapper=plot.value_mapper,
                                use_draw_order = True)
        
        horizontal_axis = PlotAxis(orientation='bottom',
                                title=xlabel,
                                mapper=plot.index_mapper,
                                use_draw_order = True)

        plot.underlays.append(vertical_grid)
        plot.underlays.append(horizontal_grid)

        # Have to add axes to overlays because we are backbuffering the main plot,
        # and only overlays get to render in addition to the backbuffer.
        plot.overlays.append(vertical_axis)
        plot.overlays.append(horizontal_axis)
        
#===============================================================================
# Attributes to use for the plot view.
size = (800, 600)
title = fname

#===============================================================================
# # Demo class that is used by the demo.py application.
#===============================================================================
class ZoomPlotView(HasTraits):

    zoom_plot = Instance(ZoomPlot, ())
    
    traits_view = View(
                    Group(
                        Item('object.zoom_plot.plot', editor=ComponentEditor(size=size), 
                             show_label=False),
                        orientation = "vertical"),
                    resizable=True, title='Zoom Plot',
                    width=size[0], height=size[1]
                    )

demo = ZoomPlotView()
# Configure the zoom plot by giving it data
try:
    x,y = read_music_data()
    demo.zoom_plot.update_data(x, y)
except:
    # Use the defaults
    pass

if __name__ == "__main__":
    demo.configure_traits()

#--EOF---

########NEW FILE########
__FILENAME__ = connected_orientation

from numpy import linspace, sin

from chaco.api import ArrayPlotData, HPlotContainer, Plot
from chaco.tools.api import PanTool, ZoomTool
from enable.component_editor import ComponentEditor
from traits.api import HasTraits, Instance
from traitsui.api import Item, View

class FlippedExample(HasTraits):

    container = Instance(HPlotContainer)

    traits_view = View(Item('container', editor=ComponentEditor(), show_label=False),
                       width=1000, height=600, resizable=True,
                       title="Connected Range, Flipped")

    def __init__(self):
        # Create the data and the PlotData object
        x = linspace(-14, 14, 100)
        y = sin(x) * x**3
        plotdata = ArrayPlotData(x = x, y = y)

        # Create the scatter plot
        scatter = Plot(plotdata)
        scatter.plot(("x", "y"), type="scatter", color="blue")

        # Create the line plot, rotated and vertically oriented
        line = Plot(plotdata, orientation="v", default_origin="top left")
        line.plot(("x", "y"), type="line", color="blue")

        # Create a horizontal container and put the two plots inside it
        self.container = HPlotContainer(scatter, line)

        # Add pan/zoom so we can see they are connected
        scatter.tools.append(PanTool(scatter))
        scatter.tools.append(ZoomTool(scatter))
        line.tools.append(PanTool(line))
        line.tools.append(ZoomTool(line))

        # Set the two plots' ranges to be the same
        scatter.range2d = line.range2d

#===============================================================================
# demo object that is used by the demo.py application.
#===============================================================================
demo = FlippedExample()
if __name__ == "__main__":
    demo.configure_traits()

########NEW FILE########
__FILENAME__ = connected_range

from numpy import linspace, sin

from chaco.api import ArrayPlotData, HPlotContainer, Plot
from chaco.tools.api import PanTool, ZoomTool
from enable.component_editor import ComponentEditor
from traits.api import HasTraits, Instance
from traitsui.api import Item, View

class ConnectedRange(HasTraits):

    container = Instance(HPlotContainer)

    traits_view = View(Item('container', editor=ComponentEditor(), show_label=False),
                       width=1000, height=600, resizable=True,
                       title="Connected Range")

    def __init__(self):
        # Create the data and the PlotData object
        x = linspace(-14, 14, 100)
        y = sin(x) * x**3
        plotdata = ArrayPlotData(x = x, y = y)

        # Create the scatter plot
        scatter = Plot(plotdata)
        scatter.plot(("x", "y"), type="scatter", color="blue")

        # Create the line plot
        line = Plot(plotdata)
        line.plot(("x", "y"), type="line", color="blue")

        # Create a horizontal container and put the two plots inside it
        self.container = HPlotContainer(scatter, line)

        # Add pan/zoom so we can see they are connected
        scatter.tools.append(PanTool(scatter))
        scatter.tools.append(ZoomTool(scatter))
        line.tools.append(PanTool(line))
        line.tools.append(ZoomTool(line))

        # Set the two plots' ranges to be the same
        scatter.range2d = line.range2d


#===============================================================================
# demo object that is used by the demo.py application.
#===============================================================================
demo=ConnectedRange()
if __name__ == "__main__":
    demo.configure_traits()

########NEW FILE########
__FILENAME__ = connected_single_range

from numpy import linspace, sin

from chaco.api import ArrayPlotData, HPlotContainer, Plot
from chaco.tools.api import PanTool, ZoomTool
from enable.component_editor import ComponentEditor
from traits.api import HasTraits, Instance
from traitsui.api import Item, View

class ConnectedRange(HasTraits):

    container = Instance(HPlotContainer)

    traits_view = View(Item('container', editor=ComponentEditor(), show_label=False),
                       width=1000, height=600, resizable=True,
                       title="Connected Range")

    def __init__(self):
        # Create the data and the PlotData object
        x = linspace(-14, 14, 100)
        y = sin(x) * x**3
        plotdata = ArrayPlotData(x = x, y = y)

        # Create the scatter plot
        scatter = Plot(plotdata)
        scatter.plot(("x", "y"), type="scatter", color="blue")

        # Create the line plot
        line = Plot(plotdata)
        line.plot(("x", "y"), type="line", color="blue")

        # Create a horizontal container and put the two plots inside it
        self.container = HPlotContainer(scatter, line)

        # Add pan/zoom so we can see they are connected
        scatter.tools.append(PanTool(scatter))
        scatter.tools.append(ZoomTool(scatter))
        line.tools.append(PanTool(line))
        line.tools.append(ZoomTool(line))

        # Set the two plots' ranges to be the same
        scatter.index_range = line.index_range

#===============================================================================
# demo object that is used by the demo.py application.
#===============================================================================
demo=ConnectedRange()
if __name__ == "__main__":
    demo.configure_traits()

########NEW FILE########
__FILENAME__ = connected_widgets

from numpy import linspace, sin

from chaco.api import ArrayPlotData, Plot
from chaco.tools.api import PanTool, ZoomTool
from enable.component_editor import ComponentEditor
from traits.api import Enum, HasTraits, Instance
from traitsui.api import Item, View

class PlotEditor(HasTraits):

    plot = Instance(Plot)
    plot_type = Enum("scatter", "line")
    orientation = Enum("horizontal", "vertical")
    traits_view = View(Item('orientation', label="Orientation"),
                       Item('plot', editor=ComponentEditor(), show_label=False),
                       width=500, height=500, resizable=True,
                       title="Chaco Plot")

    def __init__(self, *args, **kw):
        HasTraits.__init__(self, *args, **kw)
        # Create the data and the PlotData object
        x = linspace(-14, 14, 100)
        y = sin(x) * x**3
        plotdata = ArrayPlotData(x = x, y = y)
        # Create the scatter plot
        plot = Plot(plotdata)
        plot.plot(("x", "y"), type=self.plot_type, color="blue")
        plot.tools.append(PanTool(plot))
        plot.tools.append(ZoomTool(plot))
        self.plot = plot

    def _orientation_changed(self):
        if self.orientation == "vertical":
            self.plot.orientation = "v"
        else:
            self.plot.orientation = "h"

if __name__ == "__main__":
    # Create the two plots
    scatter = PlotEditor(plot_type = "scatter")
    line = PlotEditor(plot_type = "line")
    # Hook up their ranges
    scatter.plot.range2d = line.plot.range2d
    # Bring up both plots by calling edit_traits().  (We call configure_traits()
    # on the second one so that the application main loop stays running.)
    line.edit_traits()
    scatter.configure_traits()


########NEW FILE########
__FILENAME__ = container

from numpy import linspace, sin

from chaco.api import ArrayPlotData, HPlotContainer, Plot
from enable.component_editor import ComponentEditor
from traits.api import HasTraits, Instance
from traitsui.api import Item, View

class ContainerExample(HasTraits):

    plot = Instance(HPlotContainer)

    traits_view = View(Item('plot', editor=ComponentEditor(), show_label=False),
                       width=1000, height=600, resizable=True,
                       title="Chaco Plot")

    def __init__(self):
        # Create the data and the PlotData object
        x = linspace(-14, 14, 100)
        y = sin(x) * x**3
        plotdata = ArrayPlotData(x = x, y = y)
        # Create the scatter plot
        scatter = Plot(plotdata)
        scatter.plot(("x", "y"), type="scatter", color="blue")
        # Create the line plot
        line = Plot(plotdata)
        line.plot(("x", "y"), type="line", color="blue")
        # Create a horizontal container and put the two plots inside it
        container = HPlotContainer(scatter, line)
        self.plot = container

#===============================================================================
# demo object that is used by the demo.py application.
#===============================================================================
demo=ContainerExample()
if __name__ == "__main__":
    demo.configure_traits()


########NEW FILE########
__FILENAME__ = container_nospace

from numpy import linspace, sin

from chaco.api import ArrayPlotData, HPlotContainer, Plot
from enable.component_editor import ComponentEditor
from traits.api import HasTraits, Instance
from traitsui.api import Item, View

class ContainerExample(HasTraits):

    plot = Instance(HPlotContainer)

    traits_view = View(Item('plot', editor=ComponentEditor(), show_label=False),
                       width=1000, height=600, resizable=True)

    def __init__(self):
        # Create the data and the PlotData object
        x = linspace(-14, 14, 100)
        y = sin(x) * x**3
        plotdata = ArrayPlotData(x = x, y = y)
        # Create the scatter plot
        scatter = Plot(plotdata)
        scatter.plot(("x", "y"), type="scatter", color="blue")
        # Create the line plot
        line = Plot(plotdata)
        line.plot(("x", "y"), type="line", color="blue")
        # Create a horizontal container and put the two plots inside it
        container = HPlotContainer(scatter, line)
        container.spacing = 0
        scatter.padding_right = 0
        line.padding_left = 0
        line.y_axis.orientation = "right"

        self.plot = container

#===============================================================================
# demo object that is used by the demo.py application.
#===============================================================================
demo=ContainerExample()
if __name__ == "__main__":
    demo.configure_traits()

########NEW FILE########
__FILENAME__ = container_vertical

from numpy import linspace, sin

from chaco.api import ArrayPlotData, VPlotContainer, Plot
from enable.component_editor import ComponentEditor
from traits.api import HasTraits, Instance
from traitsui.api import Item, View

class ContainerExample2(HasTraits):

    plot = Instance(VPlotContainer)

    traits_view = View(Item('plot', editor=ComponentEditor(), show_label=False),
                       width=600, height=800, resizable=True)

    def __init__(self):
        # Create the data and the PlotData object
        x = linspace(-14, 14, 100)
        y = sin(x) * x**3
        plotdata = ArrayPlotData(x = x, y = y)
        # Create the scatter plot
        scatter = Plot(plotdata)
        scatter.plot(("x", "y"), type="scatter", color="blue")
        # Create the line plot
        line = Plot(plotdata)
        line.plot(("x", "y"), type="line", color="blue")
        # Create a vertical container and put the two plots inside it
        container = VPlotContainer(scatter, line)
        self.plot = container

#===============================================================================
# demo object that is used by the demo.py application.
#===============================================================================
demo=ContainerExample2()
if __name__ == "__main__":
    demo.configure_traits()



########NEW FILE########
__FILENAME__ = custom_overlay

from numpy import linspace, sin

from chaco.api import ArrayPlotData, Plot, AbstractOverlay
from chaco.tools.api import PanTool
from enable.component_editor import ComponentEditor
from enable.api import ColorTrait
from traits.api import Button, Float, Range, HasTraits, Instance
from traitsui.api import Item, View, Group, HGroup, RangeEditor, \
                                    spring, Handler

class CustomOverlay(AbstractOverlay):
    x = Float(10, editor=RangeEditor(low=1.0, high=600, mode="slider"))
    y = Float(10, editor=RangeEditor(low=1.0, high=500, mode="slider"))
    width = Range(10.0, 300, editor=RangeEditor(low=10.0, high=300, mode="slider"))
    height = Range(10.0, 300, editor=RangeEditor(low=10.0, high=300, mode="slider"))
    color = ColorTrait("red")

    traits_view = View(Group(
                        Item("x"), Item("y"), Item("width"), Item("height"),
                        Item("color"), orientation = "vertical"
                        ))

    def overlay(self, component, gc, view_bounds=None, mode="normal"):
        gc.set_fill_color(self.color_)
        x = self.x + component.x
        y = self.y + component.y
        gc.rect(x, y, self.width, self.height)
        gc.fill_path()

    def _anytrait_changed(self):
        self.component.request_redraw()

class ScatterPlotHandler(Handler):

    def object_edit_overlay_changed(self, info):
        info.object.plot.overlays[-1].edit_traits(parent=info.ui.control)
        return

class ScatterPlot(HasTraits):

    plot = Instance(Plot)

    edit_overlay = Button('Edit Overlay')

    traits_view = View(Item('plot', editor=ComponentEditor(), show_label=False),
                       HGroup(spring,
                              Item('edit_overlay', show_label=False,
                                   emphasized=True,
                                   height=50),
                              spring),
                       handler = ScatterPlotHandler,
                       width=800, height=600, resizable=True)

    def _plot_default(self):
        # Create the data and the PlotData object
        x = linspace(-14, 14, 100)
        y = sin(x) * x**3
        plotdata = ArrayPlotData(x = x, y = y)
        # Create a Plot and associate it with the PlotData
        plot = Plot(plotdata)
        # Create a scatter plot in the Plot
        plot.plot(("x", "y"), type="scatter", color="blue")
        plot.tools.append(PanTool(plot))
        # Add our custom tool to the plot
        plot.overlays.append(CustomOverlay(plot))
        return plot

#===============================================================================
# demo object that is used by the demo.py application.
#===============================================================================
demo = ScatterPlot()
if __name__ == "__main__":
    demo.configure_traits()

########NEW FILE########
__FILENAME__ = custom_overlay_dataspace

from numpy import linspace, sin

from chaco.api import ArrayPlotData, Plot, AbstractOverlay
from chaco.tools.api import PanTool
from enable.component_editor import ComponentEditor
from enable.api import ColorTrait
from traits.api import Button, CArray, Bool, Float, Range, HasTraits,\
                                 Instance
from traitsui.api import Item, View, Group, RangeEditor, \
                                    HGroup, Handler, spring

class CustomOverlay(AbstractOverlay):
    x = Float(10, editor=RangeEditor(low=1.0, high=600, mode="slider"))
    y = Float(10, editor=RangeEditor(low=1.0, high=500, mode="slider"))
    width = Range(10.0, 300, editor=RangeEditor(low=10.0, high=300, mode="slider"))
    height = Range(10.0, 300, editor=RangeEditor(low=10.0, high=300, mode="slider"))
    color = ColorTrait("red")
    dataspace = Bool(False)

    _anchor = CArray

    traits_view = View(Group(
                        Item("x"), Item("y"), Item("width"), Item("height"),
                        Item("color"),
                        Item("dataspace", label="Data space?"),
                        orientation = "vertical"
                        ))

    def overlay(self, component, gc, view_bounds=None, mode="normal"):
        if self.dataspace:
            self.x, self.y = component.map_screen(self._anchor)
        gc.set_fill_color(self.color_)
        x = self.x + component.x
        y = self.y + component.y
        gc.rect(x, y, self.width, self.height)
        gc.fill_path()

    def _anytrait_changed(self):
        self.component.request_redraw()

    def _dataspace_changed(self):
        if self.dataspace:
            # Map our current x,y point into data space
            self._anchor = self.component.map_data((self.x, self.y))

class ScatterPlotHandler(Handler):

    def object_edit_overlay_changed(self, info):
        info.object.plot.overlays[-1].edit_traits(parent=info.ui.control)
        return

class ScatterPlot(HasTraits):

    plot = Instance(Plot)

    edit_overlay = Button('Edit Overlay')

    traits_view = View(Item('plot', editor=ComponentEditor(), show_label=False),
                       HGroup(spring,
                              Item('edit_overlay', show_label=False,
                                   emphasized=True,
                                   height=50),
                              spring),
                       handler = ScatterPlotHandler,
                       width=800, height=600, resizable=True)

    def _plot_default(self):
        # Create the data and the PlotData object
        x = linspace(-14, 14, 100)
        y = sin(x) * x**3
        plotdata = ArrayPlotData(x = x, y = y)
        # Create a Plot and associate it with the PlotData
        plot = Plot(plotdata)
        # Create a scatter plot in the Plot
        plot.plot(("x", "y"), type="scatter", color="blue")
        plot.tools.append(PanTool(plot))
        # Add our custom tool to the plot
        plot.overlays.append(CustomOverlay(plot))
        return plot

#===============================================================================
# demo object that is used by the demo.py application.
#===============================================================================
demo = ScatterPlot()
if __name__ == "__main__":
    demo.configure_traits()

########NEW FILE########
__FILENAME__ = custom_overlay_movetool

from numpy import linspace, sin

from chaco.api import ArrayPlotData, Plot, AbstractOverlay
from chaco.tools.api import PanTool, MoveTool
from enable.component_editor import ComponentEditor
from enable.api import ColorTrait
from traits.api import Button, CArray, Bool, Float, Range, \
                                 HasTraits, Instance, Property
from traitsui.api import Item, View, Group, RangeEditor, \
                                    HGroup, Handler, spring

class CustomOverlay(AbstractOverlay):
    x = Float(10, editor=RangeEditor(low=1.0, high=600, mode="slider"))
    y = Float(10, editor=RangeEditor(low=1.0, high=500, mode="slider"))
    width = Range(10.0, 300, editor=RangeEditor(low=10.0, high=300, mode="slider"))
    height = Range(10.0, 300, editor=RangeEditor(low=10.0, high=300, mode="slider"))
    color = ColorTrait("red")
    dataspace = Bool(False)
    position = Property

    _anchor = CArray

    traits_view = View(Group(
                        Item("x"), Item("y"), Item("width"), Item("height"),
                        Item("color"),
                        Item("dataspace", label="Data space?"),
                        orientation = "vertical"
                        ))

    def overlay(self, component, gc, view_bounds=None, mode="normal"):
        if self.dataspace:
            self.x, self.y = component.map_screen(self._anchor)
        gc.set_fill_color(self.color_)
        x = self.x + component.x
        y = self.y + component.y
        gc.rect(x, y, self.width, self.height)
        gc.fill_path()

    def _get_position(self):
        return [self.x, self.y]

    def _set_position(self, newpos):
        self.x, self.y = newpos

    def _anytrait_changed(self):
        self.component.request_redraw()

    def _dataspace_changed(self):
        if self.dataspace:
            # Map our current x,y point into data space
            self._anchor = self.component.map_data((self.x, self.y))

class ScatterPlotHandler(Handler):

    def object_edit_overlay_changed(self, info):
        info.object.plot.overlays[-1].edit_traits(parent=info.ui.control)
        return

class ScatterPlot(HasTraits):

    plot = Instance(Plot)

    edit_overlay = Button('Edit Overlay')

    traits_view = View(Item('plot', editor=ComponentEditor(), show_label=False),
                       HGroup(spring,
                              Item('edit_overlay', show_label=False,
                                   emphasized=True,
                                   height=50),
                              spring),
                       handler = ScatterPlotHandler,
                       width=800, height=600, resizable=True)

    def _plot_default(self):
        # Create the data and the PlotData object
        x = linspace(-14, 14, 100)
        y = sin(x) * x**3
        plotdata = ArrayPlotData(x = x, y = y)
        # Create a Plot and associate it with the PlotData
        plot = Plot(plotdata)
        # Create a scatter plot in the Plot
        plot.plot(("x", "y"), type="scatter", color="blue")
        plot.tools.append(PanTool(plot))
        # Add our custom overlay to the plot
        overlay = CustomOverlay(plot)
        # Add the MoveTool to the overlay so it can be dragged around usin gthe
        # right mouse button.
        overlay.tools.append(MoveTool(overlay, drag_button="right"))
        plot.overlays.append(overlay)
        return plot

#===============================================================================
# demo object that is used by the demo.py application.
#===============================================================================
demo = ScatterPlot()
if __name__ == "__main__":
    demo.configure_traits()

########NEW FILE########
__FILENAME__ = custom_tool

from numpy import linspace, sin

from chaco.api import ArrayPlotData, Plot
from enable.api import BaseTool
from enable.component_editor import ComponentEditor
from traits.api import Enum, HasTraits, Instance
from traitsui.api import Item, View

class CustomTool(BaseTool):

    event_state = Enum("normal", "mousedown")

    def normal_mouse_move(self, event):
        print "Screen:", event.x, event.y

    def normal_left_down(self, event):
        self.event_state = "mousedown"
        event.handled = True

    def mousedown_mouse_move(self, event):
        print "Data:", self.component.map_data((event.x, event.y))

    def mousedown_left_up(self, event):
        self.event_state = "normal"
        event.handled = True


class ScatterPlot(HasTraits):

    plot = Instance(Plot)

    traits_view = View(Item('plot', editor=ComponentEditor(), show_label=False),
                       width=800, height=600, resizable=True,
                       title="Custom Tool")

    def _plot_default(self):
        # Create the data and the PlotData object
        x = linspace(-14, 14, 100)
        y = sin(x) * x**3
        plotdata = ArrayPlotData(x = x, y = y)
        # Create a Plot and associate it with the PlotData
        plot = Plot(plotdata)
        # Create a scatter plot in the Plot
        plot.plot(("x", "y"), type="scatter", color="blue")
        # Add our custom tool to the plot
        plot.tools.append(CustomTool(plot))
        return plot

#===============================================================================
# demo object that is used by the demo.py application.
#===============================================================================
demo=ScatterPlot()
if __name__ == "__main__":
    demo.edit_traits(kind="livemodal")


########NEW FILE########
__FILENAME__ = custom_tool_click

from numpy import linspace, sin

from chaco.api import ArrayPlotData, Plot
from enable.api import BaseTool
from enable.component_editor import ComponentEditor
from traits.api import Enum, HasTraits, Instance
from traitsui.api import Item, View

class CustomTool(BaseTool):

    def normal_mouse_move(self, event):
        print "Screen point:", event.x, event.y

    def normal_left_down(self, event):
        print "Mouse went down at", event.x, event.y

    def normal_left_up(self, event):
        print "Mouse went up at:", event.x, event.y

class ScatterPlot(HasTraits):

    plot = Instance(Plot)

    traits_view = View(Item('plot', editor=ComponentEditor(), show_label=False),
                       width=800, height=600, resizable=True,
                       title="Custom Tool")

    def _plot_default(self):
        # Create the data and the PlotData object
        x = linspace(-14, 14, 100)
        y = sin(x) * x**3
        plotdata = ArrayPlotData(x = x, y = y)
        # Create a Plot and associate it with the PlotData
        plot = Plot(plotdata)
        # Create a scatter plot in the Plot
        plot.plot(("x", "y"), type="scatter", color="blue")
        # Add our custom tool to the plot
        plot.tools.append(CustomTool(plot))
        return plot

#===============================================================================
# demo object that is used by the demo.py application.
#===============================================================================
demo=ScatterPlot()
if __name__ == "__main__":
    demo.edit_traits(kind="livemodal")

########NEW FILE########
__FILENAME__ = custom_tool_screen

from numpy import linspace, sin

from chaco.api import ArrayPlotData, Plot
from enable.api import BaseTool
from enable.component_editor import ComponentEditor
from traits.api import Enum, HasTraits, Instance
from traitsui.api import Item, View

class CustomTool(BaseTool):

    def normal_mouse_move(self, event):
        print "Screen point:", event.x, event.y

class ScatterPlot(HasTraits):

    plot = Instance(Plot)

    traits_view = View(Item('plot', editor=ComponentEditor(), show_label=False),
                       width=800, height=600, resizable=True,
                       title="Custom Tool")

    def _plot_default(self):
        # Create the data and the PlotData object
        x = linspace(-14, 14, 100)
        y = sin(x) * x**3
        plotdata = ArrayPlotData(x = x, y = y)
        # Create a Plot and associate it with the PlotData
        plot = Plot(plotdata)
        # Create a scatter plot in the Plot
        plot.plot(("x", "y"), type="scatter", color="blue")
        # Add our custom tool to the plot
        plot.tools.append(CustomTool(plot))
        return plot

#===============================================================================
# demo object that is used by the demo.py application.
#===============================================================================
demo=ScatterPlot()
if __name__ == "__main__":
    demo.edit_traits(kind="livemodal")

########NEW FILE########
__FILENAME__ = data_chooser

from numpy import linspace
from scipy.special import jn

from chaco.api import ArrayPlotData, Plot
from enable.component_editor import ComponentEditor
from traits.api import Dict, Enum, HasTraits, Instance
from traitsui.api import Item, View

class DataChooser(HasTraits):

    plot = Instance(Plot)
    data_name = Enum("jn0", "jn1", "jn2")
    traits_view = View(Item('data_name', label="Y data"),
                       Item('plot', editor=ComponentEditor(), show_label=False),
                       width=800, height=600, resizable=True,
                       title="Data Chooser")

    def __init__(self):
        x = linspace(-5, 10, 100)
        self.data = {"jn0": jn(0, x),
                     "jn1": jn(1, x),
                     "jn2": jn(2, x)}

        # Create the data and the PlotData object
        self.plotdata = ArrayPlotData(x=x, y=self.data["jn0"])

        # Create a Plot and associate it with the PlotData
        plot = Plot(self.plotdata)
        # Create a line plot in the Plot
        plot.plot(("x", "y"), type="line", color="blue")
        self.plot = plot

    def _data_name_changed(self, old, new):
        self.plotdata.set_data("y", self.data[self.data_name])


#===============================================================================
# demo object that is used by the demo.py application.
#===============================================================================
demo=DataChooser()
if __name__ == "__main__":
    demo.configure_traits()


########NEW FILE########
__FILENAME__ = first_plot

from numpy import linspace, sin
from chaco.api import ArrayPlotData, Plot
from enable.component_editor import ComponentEditor
from traits.api import HasTraits, Instance
from traitsui.api import Item, View

class LinePlot(HasTraits):

    plot = Instance(Plot)

    traits_view = View(
            Item('plot', editor=ComponentEditor(),
                 show_label=False),
            width=500, height=500,
            resizable=True,
            title = "Chaco Plot")

    def __init__(self):
        # Create the data and the PlotData object
        x = linspace(-14, 14, 100)
        y = sin(x) * x**3
        plotdata = ArrayPlotData(x = x, y = y)
        # Create a Plot and associate it with the PlotData
        plot = Plot(plotdata)
        # Create a line plot in the Plot
        plot.plot(("x", "y"), type="line", color="blue")
        # Set the title
        plot.title = "sin(x) * x^3"
        # Assign it to our self.plot attribute
        self.plot = plot

#===============================================================================
# demo object that is used by the demo.py application.
#===============================================================================
demo=LinePlot()
if __name__ == "__main__":
    demo.configure_traits()


########NEW FILE########
__FILENAME__ = image

from numpy import linspace, meshgrid, exp

from chaco.api import ArrayPlotData, Plot, jet
from enable.component_editor import ComponentEditor
from traits.api import HasTraits, Instance
from traitsui.api import Item, View

class ImagePlot(HasTraits):

    plot = Instance(Plot)

    traits_view = View(Item('plot', editor=ComponentEditor(), show_label=False),
                       width=600, height=600,
                       resizable=True,
                       title="Chaco Plot")

    def __init__(self):
        # Create the data and the PlotData object.  For a 2D plot, we need to
        # take the row of X points and Y points and create a grid from them
        # using meshgrid().
        x = linspace(0, 10, 50)
        y = linspace(0, 5, 50)
        xgrid, ygrid = meshgrid(x, y)
        z = exp(-(xgrid*xgrid + ygrid*ygrid) / 100)
        plotdata = ArrayPlotData(imagedata = z)
        # Create a Plot and associate it with the PlotData
        plot = Plot(plotdata)
        # Create an image plot in the Plot
        plot.img_plot("imagedata", colormap=jet)
        self.plot = plot

#===============================================================================
# demo object that is used by the demo.py application.
#===============================================================================
demo = ImagePlot()
if __name__ == "__main__":
    demo.configure_traits()


########NEW FILE########
__FILENAME__ = overlapping

from numpy import linspace, cos, sin

from chaco.api import ArrayPlotData, Plot
from enable.component_editor import ComponentEditor
from traits.api import HasTraits, Instance
from traitsui.api import Item, View

class OverlappingExample(HasTraits):

    plot = Instance(Plot)

    traits_view = View(Item('plot', editor=ComponentEditor(), show_label=False),
                       width=800, height=600, resizable=True,
                       title="Chaco Plot")

    def __init__(self):
        # Create the data and the PlotData object
        x = linspace(-14, 14, 100)
        y = x/2 * sin(x)
        y2 = cos(x)
        plotdata = ArrayPlotData(x=x, y=y, y2=y2)
        # Create a Plot and associate it with the PlotData
        plot = Plot(plotdata)
        # Create a scatter plot in the Plot
        plot.plot(("x", "y"), type="scatter", color="blue")
        # Create an overlapping line plot
        plot.plot(("x", "y2"), type="line", color="red")
        self.plot = plot

#===============================================================================
# demo object that is used by the demo.py application.
#===============================================================================
demo = OverlappingExample()
if __name__ == "__main__":
    demo.configure_traits()


########NEW FILE########
__FILENAME__ = ploteditor

from numpy import linspace, sin

from chaco.api import ArrayPlotData, Plot
from chaco.tools.api import PanTool, ZoomTool
from enable.component_editor import ComponentEditor
from traits.api import Enum, HasTraits, Instance
from traitsui.api import Item, Group, View

class PlotEditor(HasTraits):

    plot = Instance(Plot)
    plot_type = Enum("scatter", "line")
    orientation = Enum("horizontal", "vertical")
    traits_view = View(Item('orientation', label="Orientation"),
                       Item('plot', editor=ComponentEditor(), show_label=False),
                       width=500, height=500, resizable=True)

    def __init__(self, *args, **kw):
        HasTraits.__init__(self, *args, **kw)
        # Create the data and the PlotData object
        x = linspace(-14, 14, 100)
        y = sin(x) * x**3
        plotdata = ArrayPlotData(x = x, y = y)
        # Create the scatter plot
        plot = Plot(plotdata)
        plot.plot(("x", "y"), type=self.plot_type, color="blue")
        plot.tools.append(PanTool(plot))
        plot.tools.append(ZoomTool(plot))
        self.plot = plot

    def _orientation_changed(self):
        if self.orientation == "vertical":
            self.plot.orientation = "v"
        else:
            self.plot.orientation = "h"
        self.plot.request_redraw()


#===============================================================================
# demo object that is used by the demo.py application.
#===============================================================================
class Demo(HasTraits):

    # Scatter plot.
    scatter_plot = Instance(PlotEditor)

    # Line plot.
    line_plot = Instance(PlotEditor)

    traits_view = View(Group(
                             Item('@scatter_plot', show_label=False),
                             label='Scatter'),
                        Group(Item('@line_plot', show_label= False ),
                              label='Line'),
                              title='Chaco Plot',
                              resizable=True)

    def __init__(self, *args, **kws):
        super(Demo, self). __init__(*args, **kws)
        #Hook up the ranges.
        self.scatter_plot.plot.range2d = self.line_plot.plot.range2d

    def _scatter_plot_default(self):
        return PlotEditor(plot_type="scatter")

    def _line_plot_default(self):
        return PlotEditor(plot_type="line")

demo = Demo()
if __name__ == "__main__":
    demo.configure_traits()


########NEW FILE########
__FILENAME__ = scatter

from numpy import linspace, sin
from chaco.api import ArrayPlotData, Plot
from enable.component_editor import ComponentEditor
from traits.api import HasTraits, Instance
from traitsui.api import Item, View

class ScatterPlot(HasTraits):

    plot = Instance(Plot)

    traits_view = View(
            Item('plot', editor=ComponentEditor(),
                 show_label=False),
            width=500, height=500,
            resizable=True,
            title="Chaco Plot")

    def __init__(self):
        # Create the data and the PlotData object
        x = linspace(-14, 14, 100)
        y = sin(x) * x**3
        plotdata = ArrayPlotData(x = x, y = y)
        # Create a Plot and associate it with the PlotData
        plot = Plot(plotdata)
        # Create a scatter plot in the Plot
        plot.plot(("x", "y"), type="scatter", color="blue")
        self.plot = plot

#===============================================================================
# demo object that is used by the demo.py application.
#===============================================================================
demo = ScatterPlot()

if __name__ == "__main__":
    demo.configure_traits()


########NEW FILE########
__FILENAME__ = tools

from numpy import linspace, sin

from chaco.api import ArrayPlotData, Plot
from chaco.tools.api import PanTool, ZoomTool, DragZoom
from enable.component_editor import ComponentEditor
from traits.api import HasTraits, Instance
from traitsui.api import Item, View

class ToolsExample(HasTraits):

    plot = Instance(Plot)
    traits_view = View(Item('plot', editor=ComponentEditor(), show_label=False),
                       width=800, height=600, resizable=True,
                       title="Pan & Zoom")

    def __init__(self):
        # Create the data and the PlotData object
        x = linspace(-14, 14, 500)
        y = sin(x) * x**3
        plotdata = ArrayPlotData(x = x, y = y)
        # Create a Plot and associate it with the PlotData
        plot = Plot(plotdata)
        # Create a line plot in the Plot
        plot.plot(("x", "y"), type="line", color="blue")
        # Add the pan and zoom tools
        plot.tools.append(PanTool(plot))
        plot.tools.append(ZoomTool(plot))
        plot.tools.append(DragZoom(plot, drag_button="right"))
        self.plot = plot

#===============================================================================
# demo object that is used by the demo.py application.
#===============================================================================
demo = ToolsExample()

if __name__ == "__main__":
    demo.configure_traits()


########NEW FILE########
__FILENAME__ = tool_chooser

from numpy import linspace, sin

from chaco.api import ArrayPlotData, Plot
from chaco.tools.api import PanTool, ZoomTool, DragZoom
from enable.component_editor import ComponentEditor
from traits.api import HasTraits, Instance, List
from traitsui.api import Item, View, CheckListEditor

class ToolChooserExample(HasTraits):

    plot = Instance(Plot)
    tools = List(editor=CheckListEditor(values = ["PanTool", "ZoomTool", "DragZoom"]))
    traits_view = View(Item("tools", label="Tools", style="custom"),
                       Item('plot', editor=ComponentEditor(), show_label=False),
                       width=800, height=600, resizable=True,
                       title="Tool Chooser")

    def __init__(self):
        # Create the data and the PlotData object
        x = linspace(-14, 14, 500)
        y = sin(x) * x**3
        plotdata = ArrayPlotData(x = x, y = y)
        # Create a Plot and associate it with the PlotData
        plot = Plot(plotdata)
        # Create a line plot in the Plot
        plot.plot(("x", "y"), type="line", color="blue")
        self.plot = plot

    def _tools_changed(self):
        classes = [eval(class_name) for class_name in self.tools]

        # Remove all tools from the plot
        plot_tools = self.plot.tools
        for tool in plot_tools:
            plot_tools.remove(tool)

        # Create new instances for the selected tool classes
        for cls in classes:
            self.plot.tools.append(cls(self.plot))


#===============================================================================
# demo object that is used by the demo.py application.
#===============================================================================
demo = ToolChooserExample()

if __name__ == "__main__":
    demo.configure_traits()


########NEW FILE########
__FILENAME__ = traits_example

from numpy import linspace, sin

from enable.api import ColorTrait
from chaco.api import ArrayPlotData, Plot, marker_trait
from enable.component_editor import ComponentEditor
from traits.api import HasTraits, Instance, Int
from traitsui.api import Group, Item, View

class ScatterPlotTraits(HasTraits):

    plot = Instance(Plot)
    color = ColorTrait("blue")
    marker = marker_trait
    marker_size = Int(4)

    traits_view = View(
        Group(Item('color', label="Color", style="custom"),
            Item('marker', label="Marker"),
            Item('marker_size', label="Size"),
            Item('plot', editor=ComponentEditor(), show_label=False),
            orientation = "vertical"),
                    width=800, height=600, resizable=True,
                    title="Chaco Plot"
                    )

    def __init__(self):
        # Create the data and the PlotData object
        x = linspace(-14, 14, 100)
        y = sin(x) * x**3
        plotdata = ArrayPlotData(x = x, y = y)
        # Create a Plot and associate it with the PlotData
        plot = Plot(plotdata)
        # Create a line plot in the Plot
        self.renderer = plot.plot(("x", "y"), type="scatter", color="blue")[0]
        self.plot = plot

    def _color_changed(self):
        self.renderer.color = self.color

    def _marker_changed(self):
        self.renderer.marker = self.marker

    def _marker_size_changed(self):
        self.renderer.marker_size = self.marker_size

#===============================================================================
# demo object that is used by the demo.py application.
#===============================================================================
demo = ScatterPlotTraits()

if __name__ == "__main__":
    demo.configure_traits()


########NEW FILE########
__FILENAME__ = traits_image

from numpy import linspace, meshgrid, exp

from chaco.api import ArrayPlotData, Plot, jet
from enable.component_editor import ComponentEditor
from traits.api import Enum, HasTraits, Instance
from traitsui.api import Group, Item, View

class ImagePlotTraits(HasTraits):

    plot = Instance(Plot)
    origin = Enum("bottom left", "top left", "bottom right", "top right")

    traits_view = View(
                    Group(
                        Item('origin', label="Data origin"),
                        Item('plot', editor=ComponentEditor(), show_label=False),
                        orientation = "vertical"),
                    width=600, height=600, resizable=True,
                    title="Chaco Plot"
                    )

    def __init__(self):
        # Create the data and the PlotData object.  For a 2D plot, we need to
        # take the row of X points and Y points and create a grid from them
        # using meshgrid().
        x = linspace(0, 8, 50)
        y = linspace(0, 6, 50)
        xgrid, ygrid = meshgrid(x, y)
        z = exp(-(xgrid*xgrid + ygrid*ygrid) / 100)
        plotdata = ArrayPlotData(imagedata = z)
        # Create a Plot and associate it with the PlotData
        plot = Plot(plotdata)
        # Create an image plot in the Plot
        self.renderer = plot.img_plot("imagedata", name="plot1",
                                      xbounds=xgrid, ybounds=ygrid, colormap=jet)[0]
        self.plot = plot

    def _origin_changed(self):
        self.renderer.origin = self.origin
        self.plot.request_redraw()

#===============================================================================
# demo object that is used by the demo.py application.
#===============================================================================
demo = ImagePlotTraits()

if __name__ == "__main__":
    demo.configure_traits()


########NEW FILE########
__FILENAME__ = tutor
#-------------------------------------------------------------------------------
#
#  Copyright (c) 2009-2010, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Author: Vibha Srinivasan
#  Date: 02/03/2009
#
#-------------------------------------------------------------------------------

""" Run the Chaco demo.
"""

from traitsui.extras.demo import demo

# Uncomment the config_filename portion to see a tree editor based on the
# examples.cfg file.
demo(use_files=True,
     config_filename='tutorials.cfg',
     title = 'Chaco Tutorials'
    )


########NEW FILE########
__FILENAME__ = tutorial1
"""Tutorial 1. Creating a plot and saving it as an image to disk."""

import os
import sys
from scipy import arange, pi, sin

from chaco import api as chaco

# First, we create two arrays of data, x and y.  'x' will be a sequence of
# 100 points spanning the range -2pi to 2pi, and 'y' will be sin(x).
numpoints = 100
step = 4*pi / numpoints
x = arange(-2*pi, 2*pi+step/2, step)
y = sin(x)


# Now that we have our data, we can use a factory function to create the
# line plot for us.  Chaco provides a few factories to simplify creating common
# plot types (line, scatter, etc.).  In later tutorials we'll see what the
# factories are actually doing, and how to manually assemble plotting
# primitives in more powerful ways.  For now, factories suit our needs.
myplot = chaco.create_line_plot((x,y), bgcolor="white", add_grid=True, add_axis=True)

# We now need to set the plot's size, and add a little padding for the axes.
# (Normally, when Chaco plots are placed inside WX windows, the bounds are
# set automatically by the window.)
myplot.padding = 50
myplot.bounds = [400,400]


def main():
    # Now we create a canvas of the appropriate size and ask it to render
    # our component.  (If we wanted to display this plot in a window, we
    # would not need to create the graphics context ourselves; it would be
    # created for us by the window.)
    plot_gc = chaco.PlotGraphicsContext(myplot.outer_bounds)
    plot_gc.render_component(myplot)

    # Get the directory to save the image in
    print 'Please enter a path in which to place generated plots.'
    print 'Press <ENTER> to generate in the current directory.'
    path = raw_input('Path: ').strip()
    path = os.path.expanduser(path)

    if len(path) > 0 and not os.path.exists(path):
        print 'The given path does not exist.'
        sys.exit()

    # The file name to save the plot as
    file_name = "tutorial1.png"

    if not os.path.isabs(path):
        print 'Creating image: ' + os.path.join(os.getcwd(), path, file_name)
    else:
        print 'Creating image: ' + os.path.join(path, file_name)

    # Finally, we tell the graphics context to save itself to disk as an image.
    plot_gc.save(os.path.join(path, file_name))

if __name__ == '__main__':
    main()

########NEW FILE########
__FILENAME__ = tutorial10
"""Tutorial 10. Demonstration that the views are linked, but the data is not."""


from chaco.tools.api import LineInspector

from tutorial9b import PlotExample2


class PlotExample3(PlotExample2):
    def _container_default(self):
        container = super(PlotExample3, self)._container_default()

        rplot, lplot = self.right_plot, self.left_plot
        lplot.overlays.append(LineInspector(component=lplot,
                write_metadata=True, is_listener=True))
        rplot.overlays.append(LineInspector(component=rplot,
                write_metadata=True, is_listener=True))

        return container

demo = PlotExample3()

if __name__ == "__main__":
    demo.configure_traits()

########NEW FILE########
__FILENAME__ = tutorial10b
"""Tutorial 10b. Connecting the plots at the data source level"""


from chaco.tools.api import LineInspector

from tutorial9b import PlotExample2


class PlotExample3(PlotExample2):
    def _container_default(self):
        container = super(PlotExample3, self)._container_default()

        rplot, lplot = self.right_plot, self.left_plot
        lplot.overlays.append(LineInspector(component=lplot,
                write_metadata=True, is_listener=True))
        rplot.overlays.append(LineInspector(component=rplot,
                write_metadata=True, is_listener=True))
        rplot.index = lplot.index

        return container

demo = PlotExample3()

if __name__ == "__main__":
    demo.configure_traits()

########NEW FILE########
__FILENAME__ = tutorial11
"""Tutorial 11: Demonstration of index and value.

We are going to change the orientation of the right_plot, but all of our
dataspace linking will still work. This is why it's good to work with index and
value instead of hardcoding to X and Y. We'll also add another LineInspector to
each plot to form a full crosshair.
"""

from chaco.tools.api import LineInspector

from tutorial10b import PlotExample3


class PlotExample4(PlotExample3):
    def _container_default(self):
        container = super(PlotExample4, self)._container_default()

        rplot, lplot = self.right_plot, self.left_plot
        rplot.orientation = "v"
        rplot.hgrid.mapper = rplot.index_mapper
        rplot.vgrid.mapper = rplot.value_mapper
        rplot.y_axis.mapper = rplot.index_mapper
        rplot.x_axis.mapper = rplot.value_mapper


        lplot.overlays.append(LineInspector(component=lplot,
             axis="value", write_metadata=True, is_listener=True, color="blue"))
        lplot.overlays.append(LineInspector(component=lplot,
             axis="value", write_metadata=True, is_listener=True, color="blue"))

        rplot.overlays.append(LineInspector(component=rplot,
             axis="value", write_metadata=True, is_listener=True, color="blue"))
        rplot.overlays.append(LineInspector(component=rplot,
             axis="value", write_metadata=True, is_listener=True, color="blue"))

        return container


demo = PlotExample4()

if __name__ == "__main__":
    demo.configure_traits()

########NEW FILE########
__FILENAME__ = tutorial2
"""Tutorial 2. Creating a plot in window.

Using a traitsui view, a plot can be placed as a configurable item that is
viewed when configure_traits is called.
"""

from enable.api import ComponentEditor
from traits.api import HasTraits
from traitsui.api import Item, View


from tutorial1 import myplot

class PlotExample(HasTraits):
    plot = myplot

    traits_view = View(Item('plot', editor=ComponentEditor(), show_label=False),
                       title="Chaco Tutorial")

demo = PlotExample()

if __name__ == "__main__":
    demo.configure_traits()

########NEW FILE########
__FILENAME__ = tutorial2_ipython
"""Tutorial 2 (IPython) - Getting at our first plot using IPython

This addendum to Tutorial 2 demonstrates the dynamic nature of the various
components in Chaco.

To run this tutorial, change to the directory where this file is located,
then invoke IPython:

  ipython --gui=wx

Then just run this tutorial:

  run tutorial2_ipython.py

Once this executes, you will have a Chaco plot window open, and all of the
functions defined in this file will be available at the IPython prompt.
(The "plot" variables will also be defined.)

You can configure some aspects of your plot by using the functions.
"""

from tutorial2 import demo

demo.configure_traits()
plot = demo.plot

def xtitle(text):
    plot.x_axis.title = text
    plot.request_redraw()

def ytitle(text):
    plot.y_axis.title = text
    plot.request_redraw()

def xrange(low, high):
    plot.x_mapper.range.low = low
    plot.x_mapper.range.high = high

def yrange(low, high):
    plot.y_mapper.range.low = low
    plot.y_mapper.range.high = high



########NEW FILE########
__FILENAME__ = tutorial3
"""Tutorial 3. Adding an interactor

In general, there are two things that need to happen in order to hook up a
tool or interactor.  The component needs to have the interactor added to
its list of tools (so that it can forward events to the interactor), and
the interactor also needs a reference to the component or plot that it
will be attached to.

Here we add a PanTool to the demo from tutorial 2.  All we need to do is to
create a new tool and attach it to the plot object. We add thePanTool wich
allows left-clicking and dragging to move the plot around.
"""

from chaco.tools.api import PanTool

from tutorial2 import demo

plot = demo.plot
plot.tools.append(PanTool(plot))

if __name__ == "__main__":
    demo.configure_traits()

########NEW FILE########
__FILENAME__ = tutorial4
"""Tutorial 4. Adding a zoom tool

The ZoomTool tool has a visual component, so it needs to be added to the
list of overlays instead of the list of bare tools.
"""

from chaco.tools.api import ZoomTool

from tutorial2 import demo

plot = demo.plot
plot.overlays.append(ZoomTool(plot, tool_mode="box", always_on=True))

if __name__ == "__main__":
    demo.configure_traits()

########NEW FILE########
__FILENAME__ = tutorial5
"""Tutorial 5. Coordinating different tools

We can add multiple tools on the sample plot
"""

from tutorial2 import demo

from chaco.tools.api import PanTool, ZoomTool

plot = demo.plot
plot.tools.append(PanTool(plot))
plot.overlays.append(ZoomTool(plot, tool_mode="box", always_on=False))

if __name__ == "__main__":
    demo.configure_traits()

########NEW FILE########
__FILENAME__ = tutorial6
"""Tutorial 6. Writing a tool

We write an interactor tha prints out all the events it receives.
"""
from chaco.api import AbstractController

from tutorial2 import demo

class EventPrinter(AbstractController):
    def dispatch(self, event, suffix):
        print suffix, "event received at (%d,%d)" % (event.x, event.y)

plot = demo.plot
plot.tools.append(EventPrinter(plot))

if __name__ == "__main__":
    demo.configure_traits()

########NEW FILE########
__FILENAME__ = tutorial7
"""Tutorial 7. Writing a tool (cont.) - Looking at data space"""

from chaco.api import AbstractController

from tutorial2 import demo

class DataPrinter(AbstractController):
    def dispatch(self, event, suffix):
        x = self.component.x_mapper.map_data(event.x)
        y = self.component.y_mapper.map_data(event.y)
        print suffix, "event received at (%f,%f)" % (x, y)

plot = demo.plot
plot.tools.append(DataPrinter(component=plot))

if __name__ == "__main__":
    demo.configure_traits()

########NEW FILE########
__FILENAME__ = tutorial8
"""Tutorial 8. Putting two plots on the screen

This tutorial sets up for showing how Chaco allows easily opening multiple
views into a single dataspace, which is demonstrated in later tutorials.
"""

from scipy import arange
from scipy.special import jn

from enable.api import ComponentEditor
from traits.api import HasTraits, Instance
from traitsui.api import Item, View

from chaco.api import create_line_plot, HPlotContainer
from chaco.tools.api import PanTool


class PlotExample(HasTraits):
    container = Instance(HPlotContainer)

    traits_view = View(Item('container', editor=ComponentEditor(),
                            show_label=False, width=800, height=600),
                       title="Chaco Tutorial")

    def _container_default(self):
        x = arange(-5.0, 15.0, 20.0/100)

        y = jn(0, x)
        left_plot = create_line_plot((x,y), bgcolor="white",
                                     add_grid=True, add_axis=True)
        left_plot.tools.append(PanTool(left_plot))
        self.left_plot = left_plot

        y = jn(1, x)
        right_plot = create_line_plot((x,y), bgcolor="white",
                                      add_grid=True, add_axis=True)
        right_plot.tools.append(PanTool(right_plot))
        right_plot.y_axis.orientation = "right"
        self.right_plot = right_plot

        # Tone down the colors on the grids
        right_plot.hgrid.line_color = (0.3,0.3,0.3,0.5)
        right_plot.vgrid.line_color = (0.3,0.3,0.3,0.5)
        left_plot.hgrid.line_color = (0.3,0.3,0.3,0.5)
        left_plot.vgrid.line_color = (0.3,0.3,0.3,0.5)

        container = HPlotContainer(spacing=20, padding=50, bgcolor="lightgray")
        container.add(left_plot)
        container.add(right_plot)
        return container

demo = PlotExample()

if __name__ == "__main__":
    demo.configure_traits()

########NEW FILE########
__FILENAME__ = tutorial9
"""Tutorial 9. Link the horizontal ranges of the two plots."""


from tutorial8 import PlotExample


class PlotExample2(PlotExample):
    def _container_default(self):
        container = super(PlotExample2, self)._container_default()

        rplot, lplot = self.right_plot, self.left_plot
        rplot.index_mapper.range = lplot.index_mapper.range
        lplot.value_mapper.range.low = min(rplot.value_mapper.range.low,
                                           lplot.value_mapper.range.low,)
        rplot.value_mapper.range = lplot.value_mapper.range

        return container

demo = PlotExample2()

if __name__ == "__main__":
    demo.configure_traits()

########NEW FILE########
__FILENAME__ = tutorial9b
"""Tutorial 9b. Synchronize the Y data space as well,and add some tools."""


from chaco.tools.api import ZoomTool

from tutorial8 import PlotExample


class PlotExample2(PlotExample):
    def _container_default(self):
        container = super(PlotExample2, self)._container_default()

        rplot, lplot = self.right_plot, self.left_plot
        rplot.index_mapper.range = lplot.index_mapper.range
        rplot.value_mapper.range = lplot.value_mapper.range

        lplot.overlays.append(ZoomTool(lplot, tool_mode="box",always_on=False))
        rplot.overlays.append(ZoomTool(rplot, tool_mode="box",always_on=False))

        return container

demo = PlotExample2()

if __name__ == "__main__":
    demo.configure_traits()

########NEW FILE########
__FILENAME__ = grid_plot_container
from numpy import linspace
from scipy.special import jn

from chaco.api import ArrayPlotData, Plot, GridPlotContainer
from chaco.example_support import COLOR_PALETTE

from enable.component_editor import ComponentEditor

from traits.api import HasTraits, Instance
from traitsui.api import Item, View


class GridContainerExample(HasTraits):

    plot = Instance(GridPlotContainer)

    traits_view = View(
        Item('plot', editor=ComponentEditor(), show_label=False),
        width=1000, height=600, resizable=True
    )

    def _plot_default(self):
        # Create a GridContainer to hold all of our plots: 2 rows, 3 columns
        container = GridPlotContainer(shape=(2,3),
                                      spacing=(10,5),
                                      valign='top',
                                      bgcolor='lightgray')

        # Create x data
        x = linspace(-5, 15.0, 100)
        pd = ArrayPlotData(index = x)

        # Plot some Bessel functions and add the plots to our container
        for i in range(6):
            data_name = 'y{}'.format(i)
            pd.set_data(data_name, jn(i,x))

            plot = Plot(pd)
            plot.plot(('index', data_name),
                      color=COLOR_PALETTE[i],
                      line_width=3.0)

            # Set each plot's aspect based on its position in the grid
            plot.set(height=((i % 3) + 1) * 50.0,
                     resizable='h')

            # Add to the grid container
            container.add(plot)

        return container

if __name__ == '__main__':
    demo = GridContainerExample()
    demo.configure_traits()


########NEW FILE########
__FILENAME__ = h_plot_container
from numpy import linspace, sin

from chaco.api import ArrayPlotData, HPlotContainer, Plot
from enable.component_editor import ComponentEditor
from traits.api import HasTraits, Instance
from traitsui.api import Item, View

class ContainerExample(HasTraits):

    plot = Instance(HPlotContainer)

    traits_view = View(Item('plot', editor=ComponentEditor(), show_label=False),
                       width=1000, height=600, resizable=True)

    def __init__(self):
        # Create the data and the PlotData object
        x = linspace(-14, 14, 100)
        y = sin(x) * x**3
        plotdata = ArrayPlotData(x = x, y = y)

        # Create a scatter plot
        scatter_plot = Plot(plotdata)
        scatter_plot.plot(("x", "y"), type="scatter", color="blue")

        # Create a line plot
        line_plot = Plot(plotdata)
        line_plot.plot(("x", "y"), type="line", color="blue")

        # Create a horizontal container and put the two plots inside it
        container = HPlotContainer(line_plot, scatter_plot, spacing=100)
        self.plot = container

if __name__ == "__main__":
    demo = ContainerExample()
    demo.configure_traits()


########NEW FILE########
__FILENAME__ = h_plot_container_add_multiple_times
"""Shows that adding the same plot to two different containers removes it from
one and adds it to the other.
"""

from numpy import linspace, sin

from chaco.api import ArrayPlotData, HPlotContainer, VPlotContainer, Plot
from enable.component_editor import ComponentEditor
from traits.api import HasTraits, Instance
from traitsui.api import Item, View

class ContainerExample(HasTraits):

    plot = Instance(VPlotContainer)

    traits_view = View(Item('plot', editor=ComponentEditor(), show_label=False),
                       resizable=True)

    def __init__(self):
        # Create the data and the PlotData object
        x = linspace(-14, 14, 100)
        y = sin(x) * x**3
        plotdata = ArrayPlotData(x = x, y = y)

        # Create a scatter plot
        scatter_plot = Plot(plotdata)
        scatter_plot.plot(("x", "y"), type="scatter", color="blue")

        # Create a line plot
        line_plot1 = Plot(plotdata)
        line_plot1.plot(("x", "y"), type="line", color="blue")
        line_plot2 = Plot(plotdata)
        line_plot2.plot(("x", "y"), type="line", color="red")

        # Create a vertical container containing two horizontal containers
        h_container1 = HPlotContainer()
        h_container2 = HPlotContainer()
        outer_container = VPlotContainer(h_container1, h_container2,
                                         stack_order="top_to_bottom")

        # Add the two plots to the first container
        h_container1.add(scatter_plot, line_plot1, line_plot2)

        # Now add the first line plot to the second container => it is removed
        # from the first, as each plot can only have one container
        h_container2.add(line_plot1)

        self.plot = outer_container

if __name__ == "__main__":
    demo = ContainerExample()
    demo.configure_traits()


########NEW FILE########
__FILENAME__ = h_plot_container_colorbar
from chaco.api import ArrayPlotData, HPlotContainer, Plot, jet, ColorBar
from enable.component_editor import ComponentEditor
from traits.api import HasTraits, Instance
from traitsui.api import Item, View

import numpy as np
from chaco.linear_mapper import LinearMapper

N_POINTS = 100

class ColorbarExample(HasTraits):

    plot = Instance(HPlotContainer)

    traits_view = View(Item('plot', editor=ComponentEditor(), show_label=False),
                       width=600, height=600, resizable=True)

    def __init__(self):
        # Create some data
        x = np.random.random(N_POINTS)
        y = np.random.random(N_POINTS)
        color = np.exp(-(x**2 + y**2))

        # Create a plot data object and give it this data
        data = ArrayPlotData(index=x, value=y, color=color)

        # Create the plot
        plot = Plot(data)
        plot.plot(("index", "value", "color"), type="cmap_scatter",
                  color_mapper=jet)

        # Create the colorbar, handing in the appropriate range and colormap
        colormap = plot.color_mapper
        colorbar = ColorBar(index_mapper=LinearMapper(range=colormap.range),
                            color_mapper=colormap,
                            orientation='v',
                            resizable='v',
                            width=30,
                            padding=20)

        colorbar.padding_top = plot.padding_top
        colorbar.padding_bottom = plot.padding_bottom

        # Create a container to position the plot and the colorbar side-by-side
        container = HPlotContainer(plot, colorbar)
        self.plot = container

if __name__ == "__main__":
    demo = ColorbarExample()
    demo.configure_traits()

########NEW FILE########
__FILENAME__ = overlay_container_inset
from numpy import linspace
from scipy.special import jn

from chaco.api import ArrayPlotData, Plot, OverlayPlotContainer
from chaco.tools.api import ZoomTool, PanTool

from enable.component_editor import ComponentEditor

from traits.api import HasTraits, Instance
from traitsui.api import Item, View


class OverlayContainerExample(HasTraits):

    plot = Instance(OverlayPlotContainer)

    traits_view = View(
        Item('plot', editor=ComponentEditor(), show_label=False),
        width=800, height=600, resizable=True
    )

    def _plot_default(self):
        # Create data
        x = linspace(-5, 15.0, 100)
        y = jn(3, x)
        pd = ArrayPlotData(index=x, value=y)

        zoomable_plot = Plot(pd)
        zoomable_plot.plot(('index', 'value'),
                           name='external', color='red', line_width=3)

        # Attach tools to the plot
        zoom = ZoomTool(component=zoomable_plot,
                        tool_mode="box", always_on=False)
        zoomable_plot.overlays.append(zoom)
        zoomable_plot.tools.append(PanTool(zoomable_plot))

        # Create a second inset plot, not resizable, not zoom-able
        inset_plot = Plot(pd)
        inset_plot.plot(('index', 'value'), color='blue')
        inset_plot.set(resizable = '',
                       bounds = [250, 150],
                       position = [450, 350],
                       border_visible = True
                       )

        # Create a container and add our plots
        container = OverlayPlotContainer()
        container.add(zoomable_plot)
        container.add(inset_plot)
        return container

if __name__ == '__main__':
    demo = OverlayContainerExample()
    demo.configure_traits()


########NEW FILE########
__FILENAME__ = create_plot_snapshots
"""Create examples of all XY plots in Chaco for the user guide.

Relies on sklearn for the datasets.
"""

from functools import partial

from chaco.array_data_source import ArrayDataSource
from chaco.axis import PlotAxis
from chaco.cmap_image_plot import CMapImagePlot
from chaco.contour_line_plot import ContourLinePlot
from chaco.contour_poly_plot import ContourPolyPlot
from chaco.data_range_1d import DataRange1D
from chaco.data_range_2d import DataRange2D
from chaco.grid import PlotGrid
from chaco.jitterplot import JitterPlot
from chaco.lineplot import LinePlot
from chaco.multi_array_data_source import MultiArrayDataSource
from chaco.plot_graphics_context import PlotGraphicsContext
from chaco.polar_line_renderer import PolarLineRenderer
from chaco.polar_mapper import PolarMapper
from chaco.polygon_plot import PolygonPlot
from chaco.quiverplot import QuiverPlot
from chaco.scatterplot import ScatterPlot
from chaco.linear_mapper import LinearMapper
from chaco.candle_plot import CandlePlot
from chaco.colormapped_scatterplot import ColormappedScatterPlot
import chaco.default_colormaps as dc
from enable.colors import color_table

import scipy.stats
import scipy.stats
import numpy as np
import sklearn.datasets as datasets
from chaco.errorbar_plot import ErrorBarPlot
from chaco.filled_line_plot import FilledLinePlot
from chaco.image_plot import ImagePlot
from chaco.grid_data_source import GridDataSource
from chaco.grid_mapper import GridMapper
from chaco.image_data import ImageData
from chaco.barplot import BarPlot
from chaco.multi_line_plot import MultiLinePlot
from plot_window import PlotWindow


AXIS_WIDTH = 2

PLOT_DEFAULTS = {
    'color': 'blue',
    'line_width': 3.0,
    'border_visible': True,
    'border_width': AXIS_WIDTH
}

AXIS_DEFAULTS = {
    'axis_line_weight': AXIS_WIDTH,
    'tick_weight': AXIS_WIDTH,
    'tick_label_font': 'modern 16',
    'title_font': 'modern 20',
}


def get_data_sources(x=None, y=None):
    y = np.asarray(y)

    if x is None:
        x = np.arange(len(y))
    else:
        x = np.asarray(x)

    y_source = ArrayDataSource(y)
    x_source = ArrayDataSource(x)

    return x_source, y_source


def get_mappers(x_source, y_source):

    def _1D_mapper(source):
        data_range = DataRange1D()
        data_range.add(source)
        return LinearMapper(range=data_range)

    return _1D_mapper(x_source), _1D_mapper(y_source)


def add_axes(plot, x_label='', y_label=''):
    y_axis = PlotAxis(orientation='left',
                      title=y_label,
                      mapper=plot.y_mapper,
                      component=plot,
                      **AXIS_DEFAULTS)

    x_axis = PlotAxis(orientation='bottom',
                      title=x_label,
                      mapper=plot.x_mapper,
                      component=plot,
                      **AXIS_DEFAULTS)

    plot.underlays.append(x_axis)
    plot.underlays.append(y_axis)


def save_plot(plot, filename):
    width, height = plot.outer_bounds
    plot.do_layout(force=True)

    gc = PlotGraphicsContext((width, height), dpi=72.0*2)
    gc.render_component(plot)

    gc.save(filename)


# ---- factories for example plots

def get_line_plot(render_style):
    prices = datasets.fetch_mldata('regression-datasets stock')

    x, y = get_data_sources(y=prices['data'][:70,0])
    x_mapper, y_mapper = get_mappers(x, y)

    line_plot = LinePlot(
        index=x, value=y,
        index_mapper=x_mapper, value_mapper=y_mapper,
        render_style=render_style,
        **PLOT_DEFAULTS
    )

    add_axes(line_plot, x_label='Days', y_label='Stock price')

    return line_plot

get_line_plot_connected = partial(get_line_plot, "connectedpoints")
get_line_plot_hold = partial(get_line_plot, "hold")
get_line_plot_connectedhold = partial(get_line_plot, "connectedhold")


def get_scatter_plot():
    boston = datasets.load_boston()
    prices = boston['target']
    lower_status = boston['data'][:,-1]

    x, y = get_data_sources(x=lower_status, y=prices)
    x_mapper, y_mapper = get_mappers(x, y)

    scatter_plot = ScatterPlot(
        index=x, value=y,
        index_mapper=x_mapper, value_mapper=y_mapper,
        marker='circle',
        **PLOT_DEFAULTS
    )
    scatter_plot.line_width = 1.0

    add_axes(scatter_plot, x_label='Percent lower status in the population',
             y_label='Median house prices')

    return scatter_plot


def get_cmap_scatter_plot():
    boston = datasets.load_boston()
    prices = boston['target']
    lower_status = boston['data'][:,-1]
    nox = boston['data'][:,4]

    x, y = get_data_sources(x=lower_status, y=prices)
    x_mapper, y_mapper = get_mappers(x, y)

    color_source = ArrayDataSource(nox)
    color_mapper = dc.reverse(dc.RdYlGn)(
        DataRange1D(low=nox.min(), high=nox.max())
    )

    scatter_plot = ColormappedScatterPlot(
        index=x, value=y,
        index_mapper=x_mapper, value_mapper=y_mapper,
        color_data=color_source,
        color_mapper=color_mapper,
        marker='circle',
        title='Color represents nitric oxides concentration',
        render_method='bruteforce',
        **PLOT_DEFAULTS
    )

    add_axes(scatter_plot, x_label='Percent lower status in the population',
             y_label='Median house prices')

    return scatter_plot


def get_4d_scatter_plot():
    boston = datasets.load_boston()
    prices = boston['target']
    lower_status = boston['data'][:,-1]
    tax = boston['data'][:,9]
    nox = boston['data'][:,4]

    x, y = get_data_sources(x=lower_status, y=prices)
    x_mapper, y_mapper = get_mappers(x, y)

    color_source = ArrayDataSource(nox)
    color_mapper = dc.reverse(dc.RdYlGn)(
        DataRange1D(low=nox.min(), high=nox.max())
    )

    # normalize between 0 and 10
    marker_size = tax / tax.max() * 10.

    scatter_plot = ColormappedScatterPlot(
        index=x, value=y,
        index_mapper=x_mapper, value_mapper=y_mapper,
        color_data=color_source,
        color_mapper=color_mapper,
        fill_alpha = 0.8,
        marker='circle',
        marker_size=marker_size,
        title='Size represents property-tax rate, '
              'color nitric oxides concentration',
        render_method='bruteforce',
        **PLOT_DEFAULTS
    )

    add_axes(scatter_plot, x_label='Percent lower status in the population',
             y_label='Median house prices')

    return scatter_plot


def get_variable_size_scatter_plot():
    boston = datasets.load_boston()
    prices = boston['target']
    lower_status = boston['data'][:,-1]
    tax = boston['data'][:,9]

    x, y = get_data_sources(x=lower_status, y=prices)
    x_mapper, y_mapper = get_mappers(x, y)

    # normalize between 0 and 10
    marker_size = tax / tax.max() * 10.

    scatter_plot = ScatterPlot(
        index=x, value=y,
        index_mapper=x_mapper, value_mapper=y_mapper,
        marker='circle',
        marker_size=marker_size,
        title='Size represents property-tax rate',
        **PLOT_DEFAULTS
    )
    scatter_plot.color = (0.0, 1.0, 0.3, 0.4)

    add_axes(scatter_plot, x_label='Percent lower status in the population',
             y_label='Median house prices')

    return scatter_plot


def get_jitter_plot():
    boston = datasets.load_boston()
    prices = boston['target']

    x, y = get_data_sources(y=prices)
    x_mapper, y_mapper = get_mappers(x, y)

    jitter_plot = JitterPlot(
        index=y,
        mapper=y_mapper,
        marker='circle',
        jitter_width=100,
        **PLOT_DEFAULTS
    )
    jitter_plot.line_width = 1.

    x_axis = PlotAxis(orientation='bottom',
                      title='Median house prices',
                      mapper=jitter_plot.mapper,
                      component=jitter_plot,
                      **AXIS_DEFAULTS)

    jitter_plot.underlays.append(x_axis)

    return jitter_plot


def get_candle_plot():
    means = np.array([0.2, 0.8, 0.5])
    stds =  np.array([1.0, 0.3, 0.5])
    data = scipy.stats.norm(loc=means, scale=stds).rvs((100, 3))

    x = ArrayDataSource(np.arange(3))
    center = ArrayDataSource(data.mean(0))
    bar_min = ArrayDataSource(data.mean(0)-data.std(0))
    bar_max = ArrayDataSource(data.mean(0)+data.std(0))
    stem_min = ArrayDataSource(data.min(0))
    stem_max = ArrayDataSource(data.max(0))

    x_range = DataRange1D(low=-1, high=3)
    y_range = DataRange1D(tight_bounds=False)
    y_range.add(center, bar_min, bar_max, stem_min, stem_max)

    candle_plot = CandlePlot(
        index=x,
        index_mapper=LinearMapper(range=x_range),
        value_mapper=LinearMapper(range=y_range),
        center_values=center,
        bar_min=bar_min,
        bar_max=bar_max,
        min_values=stem_min,
        max_values=stem_max,
        center_color='yellow',
        bar_color='orange',
        **PLOT_DEFAULTS
    )

    add_axes(candle_plot, x_label='Items', y_label='Values')

    return candle_plot


def get_errorbar_plot():
    x = np.linspace(1., 5., 10)
    y = 3.2 * x**2 + 4.0
    y_with_noise = (y[None,:]
                    + scipy.stats.norm(loc=0, scale=2.8).rvs((10, 1)))

    means = y_with_noise.mean(0)
    stds = y_with_noise.std(0)

    x, y = get_data_sources(x=x, y=means)

    low = ArrayDataSource(means - stds)
    high = ArrayDataSource(means + stds)

    x_range = DataRange1D(low=0, high=6)
    y_range = DataRange1D(tight_bounds=False)
    y_range.add(y, low, high)

    errorbar_plot = ErrorBarPlot(
        index=x, value=y,
        index_mapper=LinearMapper(range=x_range),
        value_mapper=LinearMapper(range=y_range),
        value_low=low,
        value_high=high,
        endcap_size=11.,
        **PLOT_DEFAULTS
    )

    add_axes(errorbar_plot, x_label='Test values', y_label='Measured')

    return errorbar_plot


def get_filled_line_plot():
    prices = datasets.fetch_mldata('regression-datasets stock')

    x, y = get_data_sources(y=prices['data'][:70,0])
    x_mapper, y_mapper = get_mappers(x, y)

    line_plot = FilledLinePlot(
        index=x, value=y,
        index_mapper=x_mapper, value_mapper=y_mapper,
        fill_color='lightgreen',
        edge_width=3.0,
        **PLOT_DEFAULTS
    )

    add_axes(line_plot, x_label='Days', y_label='Stock price')

    return line_plot


def get_image_plot():
    # Create some RGBA image data
    image = np.zeros((200,400,4), dtype=np.uint8)
    image[:,0:40,0] += 255     # Vertical red stripe
    image[0:25,:,1] += 255     # Horizontal green stripe; also yellow square
    image[-80:,-160:,2] += 255 # Blue square
    image[:,:,3] = 255

    index = GridDataSource(np.linspace(0, 4., 400), np.linspace(-1, 1., 200))
    index_mapper = GridMapper(range=DataRange2D(low=(0,-1), high=(4.,1.)))

    image_source = ImageData(data=image, value_depth=4)

    image_plot = ImagePlot(
        index=index,
        value=image_source,
        index_mapper=index_mapper,
        **PLOT_DEFAULTS
    )

    add_axes(image_plot, x_label='x', y_label='y')

    return image_plot


def get_image_from_file():
    import os.path
    filename = os.path.join('..', '..', '..',
                            'demo','basic','capitol.jpg')
    image_source = ImageData.fromfile(filename)

    w, h = image_source.get_width(), image_source.get_height()
    index = GridDataSource(np.arange(w), np.arange(h))
    index_mapper = GridMapper(range=DataRange2D(low=(0, 0),
                                                high=(w-1, h-1)))

    image_plot = ImagePlot(
        index=index,
        value=image_source,
        index_mapper=index_mapper,
        origin='top left',
        **PLOT_DEFAULTS
    )

    add_axes(image_plot, x_label='x', y_label='y')

    return image_plot


def get_cmap_image_plot():
    # Create a scalar field to colormap
    NPOINTS = 200

    xs = np.linspace(-2 * np.pi, +2 * np.pi, NPOINTS)
    ys = np.linspace(-1.5*np.pi, +1.5*np.pi, NPOINTS)
    x, y = np.meshgrid(xs, ys)
    z = scipy.special.jn(2, x)*y*x

    index = GridDataSource(xdata=xs, ydata=ys)
    index_mapper = GridMapper(range=DataRange2D(index))

    color_source = ImageData(data=z, value_depth=1)
    color_mapper = dc.Spectral(DataRange1D(color_source))

    cmap_plot = CMapImagePlot(
        index=index,
        index_mapper=index_mapper,
        value=color_source,
        value_mapper=color_mapper,
        **PLOT_DEFAULTS
    )

    add_axes(cmap_plot, x_label='x', y_label='y')

    return cmap_plot


def get_contour_line_plot():
    NPOINTS_X, NPOINTS_Y = 600, 300

    # Create a scalar field to contour
    xs = np.linspace(-2 * np.pi, +2 * np.pi, NPOINTS_X)
    ys = np.linspace(-1.5*np.pi, +1.5*np.pi, NPOINTS_Y)
    x, y = np.meshgrid(xs, ys)
    z = scipy.special.jn(2, x)*y*x

    # FIXME: we have set the xbounds and ybounds manually to work around
    # a bug in CountourLinePlot, see comment in contour_line_plot.py at
    # line 112 (the workaround is the +1 at the end)
    xs_bounds = np.linspace(xs[0], xs[-1], z.shape[1]+1)
    ys_bounds = np.linspace(ys[0], ys[-1], z.shape[0]+1)
    index = GridDataSource(xdata=xs_bounds, ydata=ys_bounds)
    index_mapper = GridMapper(range=DataRange2D(index))

    value = ImageData(data=z, value_depth=1)
    color_mapper = dc.Blues(DataRange1D(value))

    contour_plot = ContourLinePlot(
        index = index,
        index_mapper = index_mapper,
        value = value,
        colors = color_mapper,
        widths = range(1, 11),
        **PLOT_DEFAULTS
    )

    add_axes(contour_plot, x_label='x', y_label='y')

    return contour_plot


def get_contour_poly_plot():
    NPOINTS_X, NPOINTS_Y = 600, 300

    # Create a scalar field to contour
    xs = np.linspace(-2 * np.pi, +2 * np.pi, NPOINTS_X)
    ys = np.linspace(-1.5*np.pi, +1.5*np.pi, NPOINTS_Y)
    x, y = np.meshgrid(xs, ys)
    z = scipy.special.jn(2, x)*y*x

    # FIXME: we have set the xbounds and ybounds manually to work around
    # a bug in CountourLinePlot, see comment in contour_line_plot.py at
    # line 112 (the workaround is the +1 at the end)
    xs_bounds = np.linspace(xs[0], xs[-1], z.shape[1]+1)
    ys_bounds = np.linspace(ys[0], ys[-1], z.shape[0]+1)
    index = GridDataSource(xdata=xs_bounds, ydata=ys_bounds)
    index_mapper = GridMapper(range=DataRange2D(index))

    value = ImageData(data=z, value_depth=1)
    color_mapper = dc.Blues(DataRange1D(value))

    contour_plot = ContourPolyPlot(
        index = index,
        index_mapper = index_mapper,
        value = value,
        colors = color_mapper,
        **PLOT_DEFAULTS
    )

    add_axes(contour_plot, x_label='x', y_label='y')

    return contour_plot


def get_polygon_plot():
    xs = np.array([0.5, 2.0, 4.0, 5.5, 4.0, 1.5, 0.5, 0.0])
    ys = np.array([0.0, 0.8, 0.5, 3.0, 3.5, 2.0, 3.0, 0.5])

    x, y = get_data_sources(xs, ys)
    x_mapper, y_mapper = get_mappers(x, y)

    polygon_plot = PolygonPlot(
        index = x,
        value = y,
        index_mapper = x_mapper,
        value_mapper = y_mapper,
        edge_width = 4.0,
        face_color = 'orange',
        **PLOT_DEFAULTS
    )

    add_axes(polygon_plot, x_label='x', y_label='y')

    return polygon_plot


def get_bar_plot():
    boston = datasets.load_boston()
    prices = boston['target']

    ys, bin_edges = np.histogram(prices, bins=10)
    ys = ys.astype('d') / ys.sum()
    xs = (bin_edges[:-1] + bin_edges[1:]) / 2.0

    x, y = get_data_sources(x=xs, y=ys)
    x_mapper, y_mapper = get_mappers(x, y)

    # we need to make the range of the x coordinate a bit larger, otherwise
    # half of the first and last bar are cut
    delta = bin_edges[1] - bin_edges[0]
    x_mapper.range.low = xs[0] - delta / 2.
    x_mapper.range.high = xs[-1] + delta / 2.

    y_mapper.range.high += 0.02

    bar_plot = BarPlot(
        index = x,
        value = y,
        index_mapper = x_mapper,
        value_mapper = y_mapper,
        fill_color = 'blue',
        bar_width = 3.0,
        **PLOT_DEFAULTS
    )

    add_axes(bar_plot, x_label='Median house prices', y_label='Frequency')

    return bar_plot


def get_quiver_plot():
    NPOINTS = 250

    # points are distributed uniformly between -1 and 1
    xs = np.random.uniform(low=-1.0, high=1.0, size=(NPOINTS,))
    ys = np.random.uniform(low=-1.0, high=1.0, size=(NPOINTS,))

    x, y = get_data_sources(x=xs, y=ys)
    x_mapper, y_mapper = get_mappers(x, y)

    # vectors are tangent to a circle centered in (0, 0) and the size depends
    # on the radius
    r = np.sqrt(xs*xs + ys*ys) * 20.0
    v = r * np.array([-np.sin(np.arctan2(ys, xs)),
                      np.cos(np.arctan2(ys, xs))])
    v_source = MultiArrayDataSource(v.T)

    quiver_plot = QuiverPlot(
        index = x,
        value = y,
        vectors = v_source,
        index_mapper = x_mapper,
        value_mapper = y_mapper,
        aspect_ratio = 1.0
    )


    add_axes(quiver_plot, x_label='x', y_label='y')

    return quiver_plot


def get_polar_plot():
    # Create theta
    N_POINTS = 5000
    low, high = 0, np.pi
    theta = np.arange(low, high, (high-low) / N_POINTS)

    # Create the radius data
    radius = np.cos(3*theta)

    # FIXME: at the moment PolarMapper does not actually do anything, so
    # we need to transform to Cartesian coordinates by hand
    xs = radius * np.cos(theta)
    ys = radius * np.sin(theta)

    x, y = get_data_sources(xs, ys)
    index_mapper = PolarMapper(range=DataRange1D(x))
    value_mapper = PolarMapper(range=DataRange1D(y))

    polar_plot = PolarLineRenderer(
        index=x, value=y,
        index_mapper = index_mapper,
        value_mapper = value_mapper,
        aspect_ratio = 1.0,
        **PLOT_DEFAULTS
    )
    polar_plot.border_visible = False

    return polar_plot


def get_multiline_plot():
    prices = datasets.fetch_mldata('regression-datasets stock')

    T, N_LINES = 70, 5

    prices_data = prices['data'][:T,:N_LINES]
    prices_data -= prices_data[0,:]

    # data sources for the two axes
    xs = ArrayDataSource(np.arange(T))
    ys = ArrayDataSource(np.arange(N_LINES))
    y_range = DataRange1D(low=-0.5, high=N_LINES - 0.5)
    y_mapper = LinearMapper(range=y_range)

    # data source for the multiple lines
    lines_source = MultiArrayDataSource(data=prices_data.T)

    colors = ['blue', 'green', 'yellow', 'orange', 'red']
    def color_generator(color_idx):
        return color_table[colors[color_idx]]

    multiline_plot = MultiLinePlot(
        index = xs,
        yindex = ys,
        index_mapper = LinearMapper(range=DataRange1D(xs)),
        value_mapper = y_mapper,
        value = lines_source,
        normalized_amplitude = 1.0,
        use_global_bounds = False,
        color_func = color_generator,
        **PLOT_DEFAULTS
    )

    add_axes(multiline_plot, x_label='Days', y_label='Stock price changes')

    y_grid = PlotGrid(mapper=y_mapper, orientation="horizontal",
                      line_style="dot", component=multiline_plot)
    multiline_plot.overlays.append(y_grid)

    return multiline_plot


all_examples = {
    'line': get_line_plot_connected,
    'line_hold': get_line_plot_hold,
    'line_connectedhold': get_line_plot_connectedhold,
    'scatter': get_scatter_plot,
    'cmap_scatter': get_cmap_scatter_plot,
    '4d_scatter': get_4d_scatter_plot,
    'vsize_scatter': get_variable_size_scatter_plot,
    'jitter': get_jitter_plot,
    'candle': get_candle_plot,
    'errorbar': get_errorbar_plot,
    'filled_line': get_filled_line_plot,
    'image': get_image_plot,
    'image_from_file': get_image_from_file,
    'cmap_image': get_cmap_image_plot,
    'contour_line': get_contour_line_plot,
    'contour_poly': get_contour_poly_plot,
    'polygon': get_polygon_plot,
    'bar': get_bar_plot,
    'quiver': get_quiver_plot,
    'polar': get_polar_plot,
    'multiline': get_multiline_plot,
}


if __name__ == '__main__':
    name = 'vsize_scatter'

    factory_func = all_examples[name]
    plot = factory_func()

    window = PlotWindow(plot=plot)
    ui = window.edit_traits()

    filename = '{}_plot.png'.format(name)
    save_plot(window.container, filename)



########NEW FILE########
__FILENAME__ = plot_window
from chaco.api import PlotComponent
from chaco.data_view import DataView
from enable.component_editor import ComponentEditor
from traits.api import HasTraits, Instance
from traits.has_traits import on_trait_change
from traitsui.api import Item, View

class PlotWindow(HasTraits):

    plot = Instance(PlotComponent)
    container = Instance(DataView)

    @on_trait_change('plot')
    def _update_container(self):
        self.container = DataView(
            padding=(80,20,20,60),  # make some space for axis labels
            border_visible=False
        )

        self.container.add(self.plot)
        self.container.aspect_ratio = self.plot.aspect_ratio

        # remove axes etc
        self.container.underlays = []



    traits_view = View(Item('container',
                            editor=ComponentEditor(),
                            show_label=False),
                       width=600, height=400, resizable=True)

########NEW FILE########
