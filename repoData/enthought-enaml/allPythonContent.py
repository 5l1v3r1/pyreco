__FILENAME__ = conf
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
# -*- coding: utf-8 -*-
#
# Enaml documentation build configuration file, created by
# sphinx-quickstart on Mon Aug 22 09:16:47 2011.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

## from enaml.import_hooks import EnamlImporter
## EnamlImporter.install()

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
sys.path.insert(0, os.path.abspath('.'))
sys.path.insert(0, os.path.abspath('./sphinxext'))
sys.path.insert(0, os.path.abspath('./developer_guide'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
needs_sphinx = '1.0.7'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = [
    'sphinx.ext.autodoc',
    'sphinx.ext.doctest',
    'sphinx.ext.intersphinx',
    'sphinx.ext.todo',
    'sphinx.ext.coverage',
    'sphinx.ext.pngmath',
    'sphinx.ext.ifconfig',
    'sphinx.ext.viewcode',
    'sphinx.ext.graphviz',
    'sphinx.ext.inheritance_diagram',
    'sphinx.ext.autosummary',
    'refactordoc',
    'enamldoc.sphinx_ext',
    ]

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'enaml'
copyright = u'2012, Enthought, Inc.'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '0.6.3'
# The full version, including alpha/beta/rc tags.
release = '0.6.3'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_templates']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []

todo_include_todos = True

autodoc_member_order = 'bysource'
autodoc_default_flags = [
    'members',
    #'undoc-members',
    'special-members',
    'show-inheritance',
    ]

##inheritance_node_attrs = dict(shape='ellipse', fontsize=14, height=0.75,
##                              color='dodgerblue1', style='filled')

#: rankdir ['LR', 'TB', 'BT', 'RL']
inheritance_graph_attrs = dict(
    rankdir="LR",
    width="8.0",
    #size='"8.0, 20.0"',
    fontsize=14,
    ratio='compress'
    )

autosummary_generate = True

# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'enthought_doc'
#'default'
#'agogo'
#

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
## html_theme_options = {
##     'pagewidth' : '70em',
##     'sidebarwidth' : '20em'
##     }

# Add any paths that contain custom themes here, relative to this directory.
html_theme_path = ['./']

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
html_logo = '_static/e-logo-rev.png'

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
html_favicon = 'et.ico'

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
html_domain_indices = True

# If false, no index is generated.
html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'enamldoc'


# -- Options for LaTeX output --------------------------------------------------

# The paper size ('letter' or 'a4').
#latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
#latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'enaml.tex', u'Enaml Documentation',
   u'Enthought, Inc.', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
latex_use_parts = True

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Additional stuff for the LaTeX preamble.
#latex_preamble = ''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'enaml', u'enaml Documentation',
     [u'Enthought, Inc.'], 1)
]


# -- Options for Epub output ---------------------------------------------------

# Bibliographic Dublin Core info.
epub_title = u'Enaml'
epub_author = u'Chris Colbert'
epub_publisher = u'Enthought, Inc.'
epub_copyright = u'2012, Enthought, Inc.'

# The language of the text. It defaults to the language option
# or en if the language is not set.
#epub_language = ''

# The scheme of the identifier. Typical schemes are ISBN or URL.
#epub_scheme = ''

# The unique identifier of the text. This can be a ISBN number
# or the project homepage.
#epub_identifier = ''

# A unique identification for the text.
#epub_uid = ''

# HTML files that should be inserted before the pages created by sphinx.
# The format is a list of tuples containing the path and title.
#epub_pre_files = []

# HTML files shat should be inserted after the pages created by sphinx.
# The format is a list of tuples containing the path and title.
#epub_post_files = []

# A list of files that should not be packed into the epub file.
#epub_exclude_files = []

# The depth of the table of contents in toc.ncx.
#epub_tocdepth = 3

# Allow duplicate toc entries.
#epub_tocdup = True


# Example configuration for intersphinx: refer to the Python standard library.
intersphinx_mapping = {
    'python' : ('http://docs.python.org/', None),
    'traits' : ('http://github.enthought.com/traits/', None)
    }

rst_epilog = """
.. |Enaml| replace:: Enaml
"""

########NEW FILE########
__FILENAME__ = preamble
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------

########NEW FILE########
__FILENAME__ = traits_class
#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from traits.api import HasTraits, Float


class Myclass(HasTraits):
    """ This is a example class

    It is used to demonstrate the proposed guidelines for documenting traits
    based classes in an "sphinx-friendly" way.

    The traits are documented close to their definition by using a special
    comment ``#:`` prefix.

    """

    #: The x Float trait (default = 150.0)
    x = Float(150.0)

    # This is a comment autodoc ignores it
    #: The y Float trait (default = 0.0)
    y = Float(0.0)


class Otherclass(HasTraits):
    """ This is another example class using traits

    It is used to demonstrate the alternative method for documenting traits
    based classes in an "sphinx-friendly" way.

    The traits are documented at the start of the class definition.

    Attributes
    ----------
    x : Float, default = 150.0
        The x Float trait

    y : Float, default = 150.0
        The y Float trait

    """

    x = Float(150.0)

    # This is a comment autodoc ignores it
    y = Float(0.0)

########NEW FILE########
__FILENAME__ = base_doc
# -*- coding: UTF-8 -*-
#------------------------------------------------------------------------------
#  file: base_doc.py
#  License: LICENSE.TXT
#  Author: Ioannis Tziakos
#
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
import re

from fields import Field
from line_functions import is_empty, get_indent, fix_backspace

#------------------------------------------------------------------------------
#  Classes
#------------------------------------------------------------------------------

class BaseDoc(object):
    """Base abstract docstring refactoring class.

    The class' main purpose is to parse the dosctring and find the
    sections that need to be refactored. It also provides a number of
    methods to help with the refactoring. Subclasses should provide
    the methods responsible for refactoring the sections.

    Attributes
    ----------
    docstring : list
        A list of strings (lines) that holds docstrings

    index : int
        The current zero-based line number of the docstring that is
        proccessed.

    verbose : bool
        When set the class prints a lot of info about the proccess
        during runtime.

    headers : dict
        The sections that the class refactors. Each entry in the
        dictionary should have as key the name of the section in the
        form that it appears in the docstrings. The value should be
        the postfix of the method, in the subclasses, that is
        responsible for refactoring (e.g. {'Methods': 'method'}).

    """

    def __init__(self, lines, headers = None, verbose=False):
        """ Initialize the class

        The method setups the class attributes and starts parsing the
        docstring to find and refactor the sections.

        Arguments
        ---------
        lines : list of strings
            The docstring to refactor

        headers : dict
            The sections for which the class has custom refactor methods.
            Each entry in the dictionary should have as key the name of
            the section in the form that it appears in the docstrings.
            The value should be the postfix of the method, in the
            subclasses, that is responsible for refactoring (e.g.
            {'Methods': 'method'}).

        verbose : bool
            When set the class logs info about the proccess
            during runtime.

        """
        try:
            self._docstring = lines.splitlines()
        except AttributeError:
            self._docstring = lines
        self.verbose = verbose
        self.headers = {} if headers is None else headers
        self.index = 0
        self.parse()

    def parse(self):
        """ Parse the docstring.

        The docstring is parsed for sections. If a section is found then
        the corresponding refactoring method is called.

        """
        self.index = 0
        self.seek_to_next_non_empty_line()
        while not self.eol:
            header = self.is_section()
            if header:
                self.remove_if_empty(self.index + 2)  # Remove space after header
                self._refactor(header)
            else:
                self.index += 1
                self.seek_to_next_non_empty_line()

    def _refactor(self, header):
        """Call the heading refactor method.

        The name of the refctoring method is constructed using the form
        _refactor_<header>. Where <header> is the value corresponding to
        ``self.headers[header]``. If there is no custom method for the
        section then the self._refactor_header() is called with the
        found header name as input.

        """
        refactor_postfix = self.headers.get(header, 'header')
        method_name = ''.join(('_refactor_', refactor_postfix))
        method = getattr(self, method_name)
        method(header)

    def _refactor_header(self, header):
        """ Refactor the header section using the rubric directive.

        The method has been tested and supports refactoring single word
        headers, two word headers and headers that include a backslash
        ''\''.

        Arguments
        ---------
        header : string
            The header string to use with the rubric directive.

        """
        index = self.index
        indent = get_indent(self.peek())
        self.remove_lines(index, 2)
        descriptions = []
        header = fix_backspace(header)
        descriptions += [indent + '.. rubric:: {0}'.format(header), '']
        self.insert_lines(descriptions, index)
        self.index += len(descriptions)
        return descriptions


    def extract_fields(self, indent='', field_type=None):
        """Extract the fields from the docstring

        Parse the fields in the description of a section into tuples of
        name, type and description in a list of strings. The parsed lines
        are also removed from original list.

        Arguments
        ---------
        indent : str, optional
            the indent argument is used to make sure that only the lines
            with the same indent are considered when checking for a
            field header line. The value is used to define the field
            checking function.

        field_check : function
            Optional function to use for checking if the next line is a
            field. The signature of the function is ``foo(line)`` and it
            should return ``True`` if the line contains a valid field
            The default function is checking for fields of the following
            formats::

                <name> : <type>

            or::

                <name> :

            Where the name has to be one word.

        Returns
        -------
        parameters : list of tuples
            list of parsed parameter tuples as returned from the
            :meth:`~BaseDocstring.parse_field` method.

        """
        field_type = Field if (field_type is None) else field_type
        is_field = field_type.is_field
        fields = []
        while (not self.eol) and (is_field(self.peek(), indent) or
                                  is_field(self.peek(1), indent)):
            self.remove_if_empty(self.index)
            field_block = self.get_next_block()
            field = field_type.parse(field_block)
            fields.append(field)
        return fields

    def get_next_block(self):
        """ Get the next field block from the docstring.

        The method reads the next block in the docstring. The first line
        assumed to be the field header and the following lines to belong to
        the description::

            <header line>
                <descrition>

        The end of the field is designated by a line with the same indent
        as the field header or two empty lines are found in sequence. Thus,
        there are two valid field layouts:

        1. No lines between fields::

            <field1>
                <description1>
            <fieldd2>
                <description2>

        2. One line between fields::

            <field1>
                <description1>

            <field2>
                <description2>

        """
        start = self.index
        field_header = self.read()
        indent = get_indent(field_header) + ' '
        field = [field_header]
        while (not self.eol):
            peek_0 = self.peek()
            peek_1 = self.peek(1)
            if (is_empty(peek_0) and (not peek_1.startswith(indent))) \
                or \
                ((not is_empty(peek_0)) and (not peek_0.startswith(indent))):
                break
            else:
                line = self.read()
                field.append(line.rstrip())

        self.remove_lines(start, len(field))
        self.index = start
        return field

    def is_section(self):
        """Check if the line defines a section.

        """
        if self.eol:
            return False

        header = self.peek()
        line2 = self.peek(1)
        if self.verbose:
            print 'current line is: {0} at index {1}'.format(header, self.index)

        # check for underline type format
        underline = re.match(r'\s*\S+\s*\Z', line2)
        if underline is None:
            return False
        # is the nextline an rst underline?
        striped_header = header.rstrip()
        expected_underline1 = re.sub(r'[A-Za-z\\]|\b\s', '-', striped_header)
        expected_underline2 = re.sub(r'[A-Za-z\\]|\b\s', '=', striped_header)
        if ((underline.group().rstrip() == expected_underline1) or
            (underline.group().rstrip() == expected_underline2)):
            return header.strip()
        else:
            return False

    def insert_lines(self, lines, index):
        """ Insert refactored lines

        Arguments
        ---------
        new_lines : list
            The list of lines to insert

        index : int
            Index to start the insertion
        """
        docstring = self.docstring
        for line in reversed(lines):
            docstring.insert(index, line)

    def seek_to_next_non_empty_line(self):
        """ Goto the next non_empty line

        """
        docstring = self.docstring
        for line in docstring[self.index:]:
            if not is_empty(line):
                break
            self.index += 1


    def get_next_paragraph(self):
        """ Get the next paragraph designated by an empty line.

        """
        docstring = self.docstring
        lines = []
        start = self.index
        while (not self.eol) and (not is_empty(self.peek())):
            line = self.read()
            lines.append(line)
        del docstring[start:self.index]
        return lines

    def read(self):
        """ Return the next line and advance the index.

        """
        index = self.index
        line = self._docstring[index]
        self.index += 1
        return line

    def remove_lines(self, index, count=1):
        """ Removes the lines for the docstring

        """
        docstring = self.docstring
        del docstring[index:(index + count)]

    def remove_if_empty(self, index=None):
        """ Remove the line from the docstring if it is empty.

        """
        if is_empty(self.docstring[index]):
            self.remove_lines(index)

    def peek(self, ahead=0):
        """ Peek ahead a number of lines

        The function retrieves the line that is ahead of the current
        index. If the index is at the end of the list then it returns an
        empty string.

        Arguments
        ---------
        ahead : int
            The number of lines to look ahead.


        """
        position = self.index + ahead
        try:
            line = self.docstring[position]
        except IndexError:
            line = ''
        return line

    @property
    def eol(self):
        return self.index >= len(self.docstring)

    @property
    def docstring(self):
        """ Get the docstring lines.

        """
        return self._docstring


########NEW FILE########
__FILENAME__ = class_doc
# -*- coding: UTF-8 -*-
#------------------------------------------------------------------------------
#  file: class_doc.py
#  License: LICENSE.TXT
#  Author: Ioannis Tziakos
#
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from base_doc import BaseDoc
from line_functions import get_indent, replace_at, add_indent
from fields import (max_header_length, max_desc_length,
                    max_name_length, MethodField, AttributeField)


class ClassDoc(BaseDoc):
    """Docstring refactoring for classes"""

    def __init__(self, lines, headers=None, verbose=False):

        if headers is None:
            headers = {'Attributes': 'attributes', 'Methods': 'methods',
                       'See Also': 'header', 'Abstract Methods': 'methods',
                       'Notes':'notes'}

        super(ClassDoc, self).__init__(lines, headers, verbose)
        return

    def _refactor_attributes(self, header):
        """Refactor the attributes section to sphinx friendly format"""

        if self.verbose:
            print '{0} Section'.format(header)

        index = self.index
        self.remove_lines(index, 2)
        indent = get_indent(self.peek())
        fields = self.extract_fields(indent, AttributeField)

        descriptions = []
        for field in fields:
            descriptions += field.to_rst(len(indent))
        self.insert_lines(descriptions[:-1], index)
        self.index += len(descriptions)
        return

    def _refactor_methods(self, header):
        """Refactor the methods section to sphinx friendly format.

        """
        if self.verbose:
            print '{0} section'.format(header)

        index = self.index
        self.remove_lines(index, 2)
        indent = get_indent(self.peek())
        method_fields = self.extract_fields(indent, MethodField)

        lines = []
        if len(method_fields) > 0 :
            name_length = max_name_length(method_fields)
            method_length = max_header_length(method_fields)
            desc_length = max_desc_length(method_fields)

            first_column = len(indent)
            second_column = first_column + method_length + name_length + 13
            first_column_str = '=' * (method_length + name_length + 12)
            second_column_str = '=' * desc_length

            border = '{0}{1} {2}'.format(indent,
                                              first_column_str,
                                              second_column_str)
            length = len(border)
            empty = length * ' '
            headings = empty[:]
            headings = replace_at('Methods', headings, first_column)
            headings = replace_at('Description', headings, second_column)
            lines.append(border)
            lines.append(headings)
            lines.append(border)
            for field in method_fields:
                lines += field.to_rst(length, first_column, second_column)
            lines.append(border)

        lines = [line.rstrip() for line in lines]
        self.insert_lines(lines, index)
        self.index += len(lines)
        return

    def _refactor_notes(self, header):
        """Refactor the note section to use the rst ``.. note`` directive.

        """
        descriptions = []
        index = self.index
        self.remove_lines(index, 2)
        indent = get_indent(self.peek())
        paragraph = self.get_next_paragraph()
        descriptions.append(indent + '.. note::')
        descriptions += add_indent(paragraph)
        self.insert_lines(descriptions, index)
        self.index += len(descriptions)
        return descriptions

########NEW FILE########
__FILENAME__ = enaml_decl_doc
# -*- coding: UTF-8 -*-
#------------------------------------------------------------------------------
#  file: class_doc.py
#  License: LICENSE.TXT
#  Author: Ioannis Tziakos
#
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from base_doc import BaseDoc
from line_functions import get_indent, replace_at, add_indent, fix_backspace
from fields import AttributeField


class EnamlDeclDoc(BaseDoc):
    """Docstring refactoring for classes"""

    def __init__(self, lines, headers=None, verbose=False):

        if headers is None:
            headers = {'Input Attributes': 'attributes',
                       'Synchronized Attributes': 'attributes',
                       'Output Attributes': 'attributes',
                       'Public Attributes': 'attributes'}

        super(EnamlDeclDoc, self).__init__(lines, headers, verbose)
        return

    def _refactor_attributes(self, header):
        """Refactor the attributes section to sphinx friendly format"""

        if self.verbose:
            print '{0} Section'.format(header)

        index = self.index
        self.remove_lines(index, 2)
        indent = get_indent(self.peek())
        fields = self.extract_fields(indent, AttributeField)
        header = fix_backspace(header)
        lines = [indent + ':{0}:'.format(header), '']
        for field in fields:
            lines += field.to_rst(len(indent) + 4)
        self.insert_lines(lines[:-1], index)
        self.index += len(lines)
        return

    def _refactor_notes(self, header):
        """Refactor the note section to use the rst ``.. note`` directive.

        """
        descriptions = []
        index = self.index
        self.remove_lines(index, 2)
        indent = get_indent(self.peek())
        paragraph = self.get_next_paragraph()
        descriptions.append(indent + '.. note::')
        descriptions += add_indent(paragraph)
        self.insert_lines(descriptions, index)
        self.index += len(descriptions)
        return descriptions

########NEW FILE########
__FILENAME__ = fields
# -*- coding: UTF-8 -*-
#------------------------------------------------------------------------------
#  file: fields.py
#  License: LICENSE.TXT
#  Author: Ioannis Tziakos
#
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
import collections
import re

from line_functions import add_indent, is_empty, remove_indent, replace_at


class Field(collections.namedtuple('Field', ('name','signature','desc'))):
    """ A docstring field.

    The class is based on the nametuple class and represents the logic
    to check, parse and refactor a docstring field.

    Attributes
    ----------
    name : str
        The name if the field, usssualy the name of a parameter of atrribute.

    signature : str
        The signature of the field. Commonly is the class type of an argument
        or the signature of a function.

    desc : str
        The description of the field. Given the type of the field this is a
        single paragraph or a block of rst source.

    """

    @classmethod
    def is_field(cls, line, indent=''):
        """ Check if the line is a field header.
        """
        regex = indent + r'\*?\*?\w+\s:(\s+|$)'
        match = re.match(regex, line)
        return match

    @classmethod
    def parse(cls, lines):
        """Parse a field definition for a set of lines.

        The field is assumed to be in one of the following formats::

            <name> : <type>
                <description>

        or::

            <name> :
                <description>

        or::

            <name>
                <description>

        Arguments
        ---------
        lines :
            docstring lines of the field without any empty lines before or
            after.

        Returns
        -------
        field :
            Field or subclass of Field

        """
        header = lines[0].strip()
        if ' :' in header:
            arg_name, arg_type = re.split('\s\:\s?', header, maxsplit=1)
        else:
            arg_name, arg_type = header, ''
        if len(lines) > 1:
            lines = [line.rstrip() for line in lines]
            return cls(arg_name.strip(), arg_type.strip(), lines[1:])
        else:
            return cls(arg_name.strip(), arg_type.strip(), [''])


    def to_rst(self, indent=4):
        """ Outputs field in rst as an itme in a definition list.

        Arguments
        ---------
        indent : int
            The indent to use for the decription block.


        Returns
        -------
        lines : list
            A list of string lines of formated rst.

        Example
        -------

        >>> Field('Ioannis', 'Ιωάννης', 'Is the greek guy.')
        >>> print Field.to_rst()
        Ioannis (Ιωάννης)
            Is the greek guy.

        """
        lines = []
        header = '{0} ({1})'.format(self.name, self.signature)
        lines.append(header)
        lines += add_indent(self.desc, indent)
        return lines

class AttributeField(Field):
    """ Field for the argument function docstrings """

    def to_rst(self, indent=4):
        """ Outputs field in rst using the ``:param:`` role.

        Arguments
        ---------
        indent : int
            The indent to use for the decription block.

        Example
        -------

        >>> Field('indent', 'int', 'The indent to use for the decription block.')
        >>> print Field.to_rst()
        :param indent: The indent to use for the description block
        :type indent: int

        """
        lines = []
        _type = self.signature
        annotation = '{0}    :annotation: = {1}'
        type_str = '' if is_empty(_type) else annotation.format(indent * ' ', _type)
        directive = '{0}.. attribute:: {1}'
        lines += [directive.format(indent * ' ', self.name), type_str]
        if type_str != '':
            lines.append('')
        lines += self.desc
        lines.append('')
        return lines


class ArgumentField(Field):
    """ Field for the argument function docstrings """

    def to_rst(self, indent=4):
        """ Outputs field in rst using the ``:param:`` role.

        Arguments
        ---------
        indent : int
            The indent to use for the decription block.

        Example
        -------

        >>> Field('indent', 'int', 'The indent to use for the decription block.')
        >>> print Field.to_rst()
        :param indent: The indent to use for the description block
        :type indent: int

        """
        lines = []
        name = self.name.replace('*','\*')  # Fix cases like *args and **kwargs
        indent_str = ' ' * indent
        param_str = '{0}:param {1}: {2}'.format(indent_str, name, self.desc[0].strip())
        type_str = '{0}:type {1}: {2}'.format(indent_str, name, self.signature)
        lines.append(param_str)
        lines += self.desc[1:]
        if len(self.signature) > 0:
            lines.append(type_str)
        return lines

class ListItemField(Field):
    """ Field that in rst is formated as an item in the list ignoring any
    field.type information.

    """

    def to_rst(self, indent=4, prefix=''):
        """ Outputs field in rst using as items in an list.

        Arguments
        ---------
        indent : int
            The indent to use for the decription block.

        prefix : str
            The prefix to use. For example if the item is part of a numbered
            list then ``prefix='# '``.

        Example
        -------


        Note
        ----
        The field descrption is reformated into a line.

        """
        indent_str = ' ' * indent
        rst_pattern = '{0}{1}**{2}**{3}' if is_empty(self.desc[0]) else \
                       '{0}{1}**{2}** -- {3}'
        description = '' if is_empty(self.desc[0]) else \
                      ' '.join(remove_indent(self.desc))
        return [rst_pattern.format(indent_str, prefix, self.name, description)]


class ListItemWithTypeField(Field):
    """ Field for the return section of the function docstrings """
    def to_rst(self, indent=4, prefix=''):
        indent_str = ' ' * indent
        _type = '' if self.signature == '' else '({0})'.format(self.signature)
        rst_pattern = '{0}{1}**{2}** {3}{4}' if is_empty(self.desc[0]) else \
                       '{0}{1}**{2}** {3} -- {4}'
        description = '' if is_empty(self.desc[0]) else \
                    ' '.join(remove_indent(self.desc))
        return [rst_pattern.format(indent_str, prefix, self.name, _type, description)]


class FunctionField(Field):
    """ A field that represents a function """

    @classmethod
    def is_field(cls, line, indent=''):
        regex = indent + r'\w+\(.*\)\s*'
        match = re.match(regex, line)
        return match

    def to_rst(self, length, first_column, second_column):
                split_result = re.split('\((.*)\)', self.name)
                method_name = split_result[0]
                method_text = ':meth:`{0} <{1}>`'.format(self.name, method_name)
                summary = ' '.join([line.strip() for line in self.desc])
                line = ' ' * length
                line = replace_at(method_text, line, first_column)
                line = replace_at(summary, line, second_column)
                return [line]

MethodField = FunctionField

#------------------------------------------------------------------------------
#  Functions to work with fields
#------------------------------------------------------------------------------

def max_name_length(method_fields):
    """ Find the max length of the function name in a list of method fields.

    Arguments
    ---------
    fields : list
        The list of the parsed fields.

    """
    return max([field[0].find('(') for field in method_fields])

def max_header_length(fields):
    """ Find the max length of the header in a list of fields.

    Arguments
    ---------
    fields : list
        The list of the parsed fields.

    """
    return max([len(field[0]) for field in fields])

def max_desc_length(fields):
    """ Find the max length of the description in a list of fields.

    Arguments
    ---------
    fields : list
        The list of the parsed fields.

    """
    return max([len(' '.join([line.strip() for line in field[2]]))
                for field in fields])

########NEW FILE########
__FILENAME__ = function_doc
# -*- coding: UTF-8 -*-
#------------------------------------------------------------------------------
#  file: function_doc.py
#  License: LICENSE.TXT
#  Author: Ioannis Tziakos
#
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from base_doc import BaseDoc
from line_functions import get_indent, add_indent
from fields import ArgumentField, ListItemWithTypeField, ListItemField


class FunctionDoc(BaseDoc):
    """Docstring refactoring for functions"""

    def __init__(self, lines, headers=None, verbose=False):

        if headers is None:
            headers = {'Returns': 'returns', 'Arguments': 'arguments',
                       'Parameters': 'arguments', 'Raises': 'raises',
                       'Yields': 'returns', 'Notes':'notes'}

        super(FunctionDoc, self).__init__(lines, headers, verbose)
        return

    def _refactor_returns(self, header):
        """Refactor the return section to sphinx friendly format.

        """
        index = self.index
        self.remove_lines(index, 2)
        indent = get_indent(self.peek())
        fields = self.extract_fields(indent, field_type=ListItemWithTypeField)
        lines = [indent + ':returns:']
        prefix = '' if len(fields) == 1 else '- '
        for field in fields:
            lines += field.to_rst(len(indent) + 4, prefix)
        self.insert_lines(lines, index)
        self.index += len(lines)
        return

    def _refactor_raises(self, header):
        """Refactor the raises section to sphinx friendly format"""
        index = self.index
        self.remove_lines(index, 2)
        indent = get_indent(self.peek())
        fields = self.extract_fields(indent, field_type=ListItemField)
        lines = [indent + ':raises:']
        prefix = '' if len(fields) == 1 else '- '
        for field in fields:
            lines += field.to_rst(len(indent) + 4, prefix)
        self.insert_lines(lines, index)
        self.index += len(lines)
        return

    def _refactor_arguments(self, header):
        """Refactor the argument section to sphinx friendly format
        """
        index = self.index
        self.remove_lines(index, 2)
        indent = get_indent(self.peek())
        fields = self.extract_fields(indent, field_type=ArgumentField)
        lines = []
        for field in fields:
            lines += field.to_rst(len(indent))
        self.insert_lines(lines, index)
        self.index += len(lines)
        return

    def _refactor_notes(self, header):
        """Refactor the argument section to sphinx friendly format.

        """
        if self.verbose:
            print 'Refactoring Notes'

        descriptions = []
        index = self.index
        self.remove_lines(index, 2)
        indent = get_indent(self.peek())
        paragraph = self.get_next_paragraph()
        descriptions.append(indent + '.. note::')
        descriptions += add_indent(paragraph)
        self.insert_lines(descriptions, index)
        self.index += len(descriptions)
        return descriptions


########NEW FILE########
__FILENAME__ = line_functions
# -*- coding: UTF-8 -*-
#------------------------------------------------------------------------------
#  file: line_functions.py
#  License: LICENSE.TXT
#  Author: Ioannis Tziakos
#
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
#!/usr/bin/env python
import re

#------------------------------------------------------------------------------
#  Precompiled regexes
#------------------------------------------------------------------------------
indent_regex = re.compile(r'\s+')

#------------------------------------------------------------------------------
#  Functions to manage indention
#------------------------------------------------------------------------------

def add_indent(lines, indent=4):
    """ Add spaces to indent a list of lines.

    Arguments
    ---------
    lines : list
        The list of strings to indent.

    indent : int
        The number of spaces to add.

    Returns
    -------
    lines : list
        The indented strings (lines).

    .. note:: Empty strings are not changed

    """
    indent_str = ' ' * indent
    output = []
    for line in lines:
        if is_empty(line):
            output.append(line)
        else:
            output.append(indent_str + line)
    return output

def remove_indent(lines):
    """ Remove all indentation from the lines.

    """
    return [line.lstrip() for line in lines]

def get_indent(line):
    """ Return the indent portion of the line.

    """
    indent = indent_regex.match(line)
    if indent is None:
        return ''
    else:
        return indent.group()

#------------------------------------------------------------------------------
#  Functions to detect line type
#------------------------------------------------------------------------------

def is_empty(line):
    return not line.strip()

#------------------------------------------------------------------------------
#  Functions to adjust strings
#------------------------------------------------------------------------------

def fix_star(word):
    return word.replace('*','\*')

def fix_backspace(word):
    return word.replace('\\', '\\\\')

def replace_at(word, line, index):
    """ Replace the text in-line.

    The text in line is replaced (not inserted) with the word. The
    replacement starts at the provided index. The result is cliped to
    the input length

    Arguments
    ---------
    word : str
        The text to copy into the line.

    line : str
        The line where the copy takes place.

    index : int
        The index to start coping.

    Returns
    -------
    result : str
        line of text with the text replaced.

    """
    word_length = len(word)
    result = line[:index] + word + line[(index + word_length):]
    return result[:len(line)]



########NEW FILE########
__FILENAME__ = application
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from abc import ABCMeta, abstractmethod
from heapq import heappush, heappop
from itertools import count
import logging
from threading import Lock


logger = logging.getLogger(__name__)


class ScheduledTask(object):
    """ An object representing a task in the scheduler.

    """
    #: A sentinel object indicating that the result of the task is
    #: undefined or that the task has not yet been executed.
    undefined = object()

    def __init__(self, callback, args, kwargs):
        """ Initialize a ScheduledTask.

        Parameters
        ----------
        callback : callable
            The callable to run when the task is executed.

        args : tuple
            The tuple of positional arguments to pass to the callback.

        kwargs : dict
            The dict of keyword arguments to pass to the callback.

        """
        self._callback = callback
        self._args = args
        self._kwargs = kwargs
        self._result = self.undefined
        self._valid = True
        self._pending = True
        self._notify = None

    #--------------------------------------------------------------------------
    # Private API
    #--------------------------------------------------------------------------
    def _execute(self):
        """ Execute the underlying task. This should only been called
        by the scheduler loop.

        """
        try:
            if self._valid:
                self._result = self._callback(*self._args, **self._kwargs)
                if self._notify is not None:
                    self._notify(self._result)
        finally:
            self._notify = None
            self._pending = False

    #--------------------------------------------------------------------------
    # Public API
    #--------------------------------------------------------------------------
    def notify(self, callback):
        """ Set a callback to be run when the task is executed.

        Parameters
        ----------
        callback : callable
            A callable which accepts a single argument which is the
            results of the task. It will be invoked immediate after
            the task is executed, on the main event loop thread.

        """
        self._notify = callback

    def pending(self):
        """ Returns True if this task is pending execution, False
        otherwise.

        """
        return self._pending

    def unschedule(self):
        """ Unschedule the task so that it will not be executed. If
        the task has already been executed, this call has no effect.

        """
        self._valid = False

    def result(self):
        """ Returns the result of the task, or ScheduledTask.undefined
        if the task has not yet been executed, was unscheduled before
        execution, or raised an exception on execution.

        """
        return self._result


class Application(object):
    """ The application object which manages the top-level communication
    protocol for serving Enaml views.

    """
    __metaclass__ = ABCMeta

    #: Private storage for the singleton application instance.
    _instance = None

    @staticmethod
    def instance():
        """ Get the global Application instance.

        Returns
        -------
        result : Application or None
            The global application instance, or None if one has not yet
            been created.

        """
        return Application._instance

    def __new__(cls, *args, **kwargs):
        """ Create a new Enaml Application.

        There may be only one application instance in existence at any
        point in time. Attempting to create a new Application when one
        exists will raise an exception.

        """
        if Application._instance is not None:
            raise RuntimeError('An Application instance already exists')
        self = super(Application, cls).__new__(cls)
        Application._instance = self
        return self

    def __init__(self, factories):
        """ Initialize an Enaml Application.

        Parameters
        ----------
        factories : iterable
            An iterable of SessionFactory instances that will be used
            to create the sessions for the application.

        """
        self._all_factories = []
        self._named_factories = {}
        self._task_heap = []
        self._counter = count()
        self._heap_lock = Lock()
        self.add_factories(factories)

    #--------------------------------------------------------------------------
    # Private API
    #--------------------------------------------------------------------------
    def _process_task(self, task):
        """ Processes the given task, then dispatches the next task.

        """
        try:
            task._execute()
        finally:
            self._next_task()

    def _next_task(self):
        """ Pulls the next task off the heap and processes it on the
        main gui thread.

        """
        heap = self._task_heap
        with self._heap_lock:
            if heap:
                priority, ignored, task = heappop(heap)
                self.deferred_call(self._process_task, task)

    #--------------------------------------------------------------------------
    # Abstract API
    #--------------------------------------------------------------------------
    @abstractmethod
    def start_session(self, name):
        """ Start a new session of the given name.

        This method will create a new session object for the requested
        session type and return the new session_id. If the session name
        is invalid, an exception will be raised.

        Parameters
        ----------
        name : str
            The name of the session to start.

        Returns
        -------
        result : str
            The unique identifier for the created session.

        """
        raise NotImplementedError

    @abstractmethod
    def end_session(self, session_id):
        """ End the session with the given session id.

        This method will close down the existing session. If the session
        id is not valid, an exception will be raised.

        Parameters
        ----------
        session_id : str
            The unique identifier for the session to close.

        """
        raise NotImplementedError

    @abstractmethod
    def session(self, session_id):
        """ Get the session for the given session id.

        Parameters
        ----------
        session_id : str
            The unique identifier for the session to retrieve.

        Returns
        -------
        result : Session or None
            The session object with the given id, or None if the id
            does not correspond to an active session.

        """
        raise NotImplementedError

    @abstractmethod
    def sessions(self):
        """ Get the currently active sessions for the application.

        Returns
        -------
        result : list
            The list of currently active sessions for the application.

        """
        raise NotImplementedError

    @abstractmethod
    def start(self):
        """ Start the application's main event loop.

        """
        raise NotImplementedError

    @abstractmethod
    def stop(self):
        """ Stop the application's main event loop.

        """
        raise NotImplementedError

    @abstractmethod
    def deferred_call(self, callback, *args, **kwargs):
        """ Invoke a callable on the next cycle of the main event loop
        thread.

        Parameters
        ----------
        callback : callable
            The callable object to execute at some point in the future.

        *args, **kwargs
            Any additional positional and keyword arguments to pass to
            the callback.

        """
        raise NotImplementedError

    @abstractmethod
    def timed_call(self, ms, callback, *args, **kwargs):
        """ Invoke a callable on the main event loop thread at a
        specified time in the future.

        Parameters
        ----------
        ms : int
            The time to delay, in milliseconds, before executing the
            callable.

        callback : callable
            The callable object to execute at some point in the future.

        *args, **kwargs
            Any additional positional and keyword arguments to pass to
            the callback.

        """
        raise NotImplementedError

    @abstractmethod
    def is_main_thread(self):
        """ Indicates whether the caller is on the main gui thread.

        Returns
        -------
        result : bool
            True if called from the main gui thread. False otherwise.

        """
        raise NotImplementedError

    #--------------------------------------------------------------------------
    # Public API
    #--------------------------------------------------------------------------
    def schedule(self, callback, args=None, kwargs=None, priority=0):
        """ Schedule a callable to be executed on the event loop thread.

        This call is thread-safe.

        Parameters
        ----------
        callback : callable
            The callable object to be executed.

        args : tuple, optional
            The positional arguments to pass to the callable.

        kwargs : dict, optional
            The keyword arguments to pass to the callable.

        priority : int, optional
            The queue priority for the callable. Smaller values indicate
            lower priority, larger values indicate higher priority. The
            default priority is zero.

        Returns
        -------
        result : ScheduledTask
            A task object which can be used to unschedule the task or
            retrieve the results of the callback after the task has
            been executed.

        """
        if args is None:
            args = ()
        if kwargs is None:
            kwargs = {}
        task = ScheduledTask(callback, args, kwargs)
        heap = self._task_heap
        with self._heap_lock:
            needs_start = len(heap) == 0
            item = (-priority, self._counter.next(), task)
            heappush(heap, item)
        if needs_start:
            if self.is_main_thread():
                self._next_task()
            else:
                self.deferred_call(self._next_task)
        return task

    def has_pending_tasks(self):
        """ Get whether or not the application has pending tasks.

        Returns
        -------
        result : bool
            True if there are pending tasks. False otherwise.

        """
        heap = self._task_heap
        with self._heap_lock:
            has_pending = len(heap) > 0
        return has_pending

    def add_factories(self, factories):
        """ Add session factories to the application.

        Parameters
        ----------
        factories : iterable
            An iterable of SessionFactory instances to add to the
            application.

        """
        all_factories = self._all_factories
        named_factories = self._named_factories
        for factory in factories:
            name = factory.name
            if name in named_factories:
                msg = 'Multiple session factories named `%s`; ' % name
                msg += 'replacing previous value.'
                logger.warn(msg)
                old_factory = named_factories.pop(name)
                all_factories.remove(old_factory)
            all_factories.append(factory)
            named_factories[name] = factory

    def discover(self):
        """ Get a dictionary of session information for the application.

        Returns
        -------
        result : list
            A list of dicts of information about the available sessions.

        """
        info = [
            {'name': fact.name, 'description': fact.description}
            for fact in self._all_factories
        ]
        return info

    def destroy(self):
        """ Destroy this application instance.

        Once an application is created, it must be destroyed before a
        new application can be instantiated.

        """
        for session in self.sessions():
            self.end_session(session.session_id)
        self._all_factories = []
        self._named_factories = {}
        Application._instance = None


#------------------------------------------------------------------------------
# Helper Functions
#------------------------------------------------------------------------------
def deferred_call(callback, *args, **kwargs):
    """ Invoke a callable on the next cycle of the main event loop
    thread.

    This is a convenience function for invoking the same method on the
    current application instance. If an application instance does not
    exist, a RuntimeError will be raised.

    Parameters
    ----------
    callback : callable
        The callable object to execute at some point in the future.

    *args, **kwargs
        Any additional positional and keyword arguments to pass to
        the callback.

    """
    app = Application.instance()
    if app is None:
        raise RuntimeError('Application instance does not exist')
    app.deferred_call(callback, *args, **kwargs)


def timed_call(ms, callback, *args, **kwargs):
    """ Invoke a callable on the main event loop thread at a specified
    time in the future.

    This is a convenience function for invoking the same method on the
    current application instance. If an application instance does not
    exist, a RuntimeError will be raised.

    Parameters
    ----------
    ms : int
        The time to delay, in milliseconds, before executing the
        callable.

    callback : callable
        The callable object to execute at some point in the future.

    *args, **kwargs
        Any additional positional and keyword arguments to pass to
        the callback.

    """
    app = Application.instance()
    if app is None:
        raise RuntimeError('Application instance does not exist')
    app.timed_call(ms, callback, *args, **kwargs)


def is_main_thread():
    """ Indicates whether the caller is on the main gui thread.

    This is a convenience function for invoking the same method on the
    current application instance. If an application instance does not
    exist, a RuntimeError will be raised.

    Returns
    -------
    result : bool
        True if called from the main gui thread. False otherwise.

    """
    app = Application.instance()
    if app is None:
        raise RuntimeError('Application instance does not exist')
    return app.is_main_thread()


def schedule(callback, args=None, kwargs=None, priority=0):
    """ Schedule a callable to be executed on the event loop thread.

    This call is thread-safe.

    This is a convenience function for invoking the same method on the
    current application instance. If an application instance does not
    exist, a RuntimeError will be raised.

    Parameters
    ----------
    callback : callable
        The callable object to be executed.

    args : tuple, optional
        The positional arguments to pass to the callable.

    kwargs : dict, optional
        The keyword arguments to pass to the callable.

    priority : int, optional
        The queue priority for the callable. Smaller values indicate
        lower priority, larger values indicate higher priority. The
        default priority is zero.

    Returns
    -------
    result : ScheduledTask
        A task object which can be used to unschedule the task or
        retrieve the results of the callback after the task has
        been executed.

    """
    app = Application.instance()
    if app is None:
        raise RuntimeError('Application instance does not exist')
    return app.schedule(callback, args, kwargs, priority)


########NEW FILE########
__FILENAME__ = callableref
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from weakref import ref


class CallableRef(object):
    """ An object which will weakly wrap a callable object.

    This class is useful when weakrefs to callable objects need to be
    used alongside regular callables. It exposes a callable interface
    which will dererence the underlying callable before calling it.

    """
    __slots__ = '_objref'

    def __init__(self, obj, callback=None):
        """ Initialize a CallableRef.

        Parameters
        ----------
        obj : callable
            The callable object which should be weakly wrapped.

        callback : callable or None
            An optional callable to invoke when the object has been
            garbage collected. It will be passed the weakref instance
            for associated with the dead object.

        Notes
        -----
        Instances of this class will compare equally to equivalent
        CallableRef instances as well as weakref instances which
        compare equally to the internal weakref.

        """
        self._objref = ref(obj, callback)

    def __eq__(self, other):
        """ Custom equality checking for a CallableRef.

        This will return True for an equivalent CallableRef *or* a
        weakref pointing to the same underlying callable.

        """
        if isinstance(other, CallableRef):
            return self._objref == other._objref
        if isinstance(other, ref):
            return self._objref == other
        return False

    def __call__(self, *args, **kwargs):
        """ Invoke the underlying callable.

        Parameters
        ----------
        *args, **kwargs
            The positional and keyword arguments to pass to the
            callable.

        Returns
        -------
        result : object
            The results of the callable, or None if it has already been
            garbage collected.

        """
        obj = self._objref()
        if obj is not None:
            return obj(*args, **kwargs)


# Use the faster version of CallableRef if it's available.
try:
    from enaml.extensions.callableref import CallableRef
except ImportError:
    pass


########NEW FILE########
__FILENAME__ = colors
#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
""" A utility module for dealing with CSS3 color strings.

"""
from colorsys import hls_to_rgb
import re


#: Regex sub-expressions used for building more complex expression.
_int = r'\s*((?:\+|\-)?[0-9]+)\s*'
_real = r'\s*((?:\+|\-)?[0-9]*(?:\.[0-9]+)?)\s*'
_perc = r'\s*((?:\+|\-)?[0-9]*(?:\.[0-9]+)?)%\s*'

#: Regular expressions used by the parsing routines.
_HEX_RE = re.compile(r'^#([A-Fa-f0-9]{3}|[A-Fa-f0-9]{6})$', re.UNICODE)
_RGB_NUM_RE = re.compile(r'^rgb\(%s,%s,%s\)$' % (_int, _int, _int), re.UNICODE)
_RGB_PER_RE = re.compile(r'^rgb\(%s,%s,%s\)$' % (_perc, _perc, _perc), re.UNICODE)
_RGBA_NUM_RE = re.compile(r'^rgba\(%s,%s,%s,%s\)$' % (_int, _int, _int, _real), re.UNICODE)
_RGBA_PER_RE = re.compile(r'^rgba\(%s,%s,%s,%s\)$' % (_perc, _perc, _perc, _real), re.UNICODE)
_HSL_RE = re.compile(r'^hsl\(%s,%s,%s\)$' % (_real, _perc, _perc), re.UNICODE)
_HSLA_RE = re.compile(r'^hsla\(%s,%s,%s,%s\)$' % (_real, _perc, _perc, _real), re.UNICODE)


#: A table of all 147 named SVG colors supported by CSS3. These values
#: will be converted to a floating point rgba color table immediately
#: after the definition.
_SVG_COLORS = {
    'aliceblue': (240, 248, 255),
    'antiquewhite': (250, 235, 215),
    'aqua': (0, 255, 255),
    'aquamarine': (127, 255, 212),
    'azure': (240, 255, 255),
    'beige': (245, 245, 220),
    'bisque': (255, 228, 196),
    'black': (0, 0, 0),
    'blanchedalmond': (255, 235, 205),
    'blue': (0, 0, 255),
    'blueviolet': (138, 43, 226),
    'brown': (165, 42, 42),
    'burlywood': (222, 184, 135),
    'cadetblue': (95, 158, 160),
    'chartreuse': (127, 255, 0),
    'chocolate': (210, 105, 30),
    'coral': (255, 127, 80),
    'cornflowerblue': (100, 149, 237),
    'cornsilk': (255, 248, 220),
    'crimson': (220, 20, 60),
    'cyan': (0, 255, 255),
    'darkblue': (0, 0, 139),
    'darkcyan': (0, 139, 139),
    'darkgoldenrod': (184, 134, 11),
    'darkgray': (169, 169, 169),
    'darkgreen': (0, 100, 0),
    'darkgrey': (169, 169, 169),
    'darkkhaki': (189, 183, 107),
    'darkmagenta': (139, 0, 139),
    'darkolivegreen': (85, 107, 47),
    'darkorange': (255, 140, 0),
    'darkorchid': (153, 50, 204),
    'darkred': (139, 0, 0),
    'darksalmon': (233, 150, 122),
    'darkseagreen': (143, 188, 143),
    'darkslateblue': (72, 61, 139),
    'darkslategray': (47, 79, 79),
    'darkslategrey': (47, 79, 79),
    'darkturquoise': (0, 206, 209),
    'darkviolet': (148, 0, 211),
    'deeppink': (255, 20, 147),
    'deepskyblue': (0, 191, 255),
    'dimgray': (105, 105, 105),
    'dimgrey': (105, 105, 105),
    'dodgerblue': (30, 144, 255),
    'firebrick': (178, 34, 34),
    'floralwhite': (255, 250, 240),
    'forestgreen': (34, 139, 34),
    'fuchsia': (255, 0, 255),
    'gainsboro': (220, 220, 220),
    'ghostwhite': (248, 248, 255),
    'gold': (255, 215, 0),
    'goldenrod': (218, 165, 32),
    'gray': (128, 128, 128),
    'grey': (128, 128, 128),
    'green': (0, 128, 0),
    'greenyellow': (173, 255, 47),
    'honeydew': (240, 255, 240),
    'hotpink': (255, 105, 180),
    'indianred': (205, 92, 92),
    'indigo': (75, 0, 130),
    'ivory': (255, 255, 240),
    'khaki': (240, 230, 140),
    'lavender': (230, 230, 250),
    'lavenderblush': (255, 240, 245),
    'lawngreen': (124, 252, 0),
    'lemonchiffon': (255, 250, 205),
    'lightblue': (173, 216, 230),
    'lightcoral': (240, 128, 128),
    'lightcyan': (224, 255, 255),
    'lightgoldenrodyellow': (250, 250, 210),
    'lightgray': (211, 211, 211),
    'lightgreen': (144, 238, 144),
    'lightgrey': (211, 211, 211),
    'lightpink': (255, 182, 193),
    'lightsalmon': (255, 160, 122),
    'lightseagreen': (32, 178, 170),
    'lightskyblue': (135, 206, 250),
    'lightslategray': (119, 136, 153),
    'lightslategrey': (119, 136, 153),
    'lightsteelblue': (176, 196, 222),
    'lightyellow': (255, 255, 224),
    'lime': (0, 255, 0),
    'limegreen': (50, 205, 50),
    'linen': (250, 240, 230),
    'magenta': (255, 0, 255),
    'maroon': (128, 0, 0),
    'mediumaquamarine': (102, 205, 170),
    'mediumblue': (0, 0, 205),
    'mediumorchid': (186, 85, 211),
    'mediumpurple': (147, 112, 219),
    'mediumseagreen': (60, 179, 113),
    'mediumslateblue': (123, 104, 238),
    'mediumspringgreen': (0, 250, 154),
    'mediumturquoise': (72, 209, 204),
    'mediumvioletred': (199, 21, 133),
    'midnightblue': (25, 25, 112),
    'mintcream': (245, 255, 250),
    'mistyrose': (255, 228, 225),
    'moccasin': (255, 228, 181),
    'navajowhite': (255, 222, 173),
    'navy': (0, 0, 128),
    'oldlace': (253, 245, 230),
    'olive': (128, 128, 0),
    'olivedrab': (107, 142, 35),
    'orange': (255, 165, 0),
    'orangered': (255, 69, 0),
    'orchid': (218, 112, 214),
    'palegoldenrod': (238, 232, 170),
    'palegreen': (152, 251, 152),
    'paleturquoise': (175, 238, 238),
    'palevioletred': (219, 112, 147),
    'papayawhip': (255, 239, 213),
    'peachpuff': (255, 218, 185),
    'peru': (205, 133, 63),
    'pink': (255, 192, 203),
    'plum': (221, 160, 221),
    'powderblue': (176, 224, 230),
    'purple': (128, 0, 128),
    'red': (255, 0, 0),
    'rosybrown': (188, 143, 143),
    'royalblue': (65, 105, 225),
    'saddlebrown': (139, 69, 19),
    'salmon': (250, 128, 114),
    'sandybrown': (244, 164, 96),
    'seagreen': (46, 139, 87),
    'seashell': (255, 245, 238),
    'sienna': (160, 82, 45),
    'silver': (192, 192, 192),
    'skyblue': (135, 206, 235),
    'slateblue': (106, 90, 205),
    'slategray': (112, 128, 144),
    'slategrey': (112, 128, 144),
    'snow': (255, 250, 250),
    'springgreen': (0, 255, 127),
    'steelblue': (70, 130, 180),
    'tan': (210, 180, 140),
    'teal': (0, 128, 128),
    'thistle': (216, 191, 216),
    'tomato': (255, 99, 71),
    'turquoise': (64, 224, 208),
    'violet': (238, 130, 238),
    'wheat': (245, 222, 179),
    'white': (255, 255, 255),
    'whitesmoke': (245, 245, 245),
    'yellow': (255, 255, 0),
    'yellowgreen': (154, 205, 50),
}


#: Convert the svg color table into a floating point rgba color table.
_COLOR_TABLE = {}
for key, value in _SVG_COLORS.iteritems():
    r, g, b = value
    r /= 255.0
    g /= 255.0
    b /= 255.0
    _COLOR_TABLE[key] = (r, g, b, 1.0)


def _parse_hex_color(color):
    """ Parse a CSS color string which starts with the '#' character.

    """
    int_ = int
    match = _HEX_RE.match(color)
    if match is not None:
        hex_str = match.group(1)
        if len(hex_str) == 3:
            r = int_(hex_str[0], 16)
            r |= (r << 4)
            g = int_(hex_str[1], 16)
            g |= (g << 4)
            b = int_(hex_str[2], 16)
            b |= (b << 4)
        else:
            r = int_(hex_str[:2], 16)
            g = int_(hex_str[2:4], 16)
            b = int_(hex_str[4:6], 16)
        return (r / 255.0, g / 255.0, b / 255.0, 1.0)


def _parse_rgb_color(color):
    """ Parse a CSS color string which starts with the 'r' character.

    """
    int_ = int
    min_ = min
    max_ = max
    match = _RGB_NUM_RE.match(color)
    if match is not None:
        rs, gs, bs = match.groups()
        r = max_(0, min_(255, int_(rs))) / 255.0
        g = max_(0, min_(255, int_(gs))) / 255.0
        b = max_(0, min_(255, int_(bs))) / 255.0
        return (r, g, b, 1.0)

    float_ = float
    match = _RGB_PER_RE.match(color)
    if match is not None:
        rs, gs, bs = match.groups()
        r = max_(0.0, min_(100.0, float_(rs))) / 100.0
        g = max_(0.0, min_(100.0, float_(gs))) / 100.0
        b = max_(0.0, min_(100.0, float_(bs))) / 100.0
        return (r, g, b, 1.0)

    match = _RGBA_NUM_RE.match(color)
    if match is not None:
        rs, gs, bs, as_ = match.groups()
        r = max_(0, min_(255, int_(rs))) / 255.0
        g = max_(0, min_(255, int_(gs))) / 255.0
        b = max_(0, min_(255, int_(bs))) / 255.0
        a = max_(0.0, min_(1.0, float_(as_)))
        return (r, g, b, a)

    match = _RGBA_PER_RE.match(color)
    if match is not None:
        rs, gs, bs, as_ = match.groups()
        r = max_(0.0, min_(100.0, float_(rs))) / 100.0
        g = max_(0.0, min_(100.0, float_(gs))) / 100.0
        b = max_(0.0, min_(100.0, float_(bs))) / 100.0
        a = max_(0.0, min_(1.0, float_(as_)))
        return (r, g, b, a)


def _parse_hsl_color(color):
    """ Parse a CSS color string that starts with the 'h' character.

    """
    float_ = float
    min_ = min
    max_ = max
    match = _HSL_RE.match(color)
    if match is not None:
        hs, ss, ls = match.groups()
        h = ((float_(hs) % 360.0 + 360.0) % 360.0) / 360.0
        s = max_(0.0, min_(100.0, float_(ss))) / 100.0
        l = max_(0.0, min_(100.0, float_(ls))) / 100.0
        r, g, b = hls_to_rgb(h, l, s)
        return (r, g, b, 1.0)

    match = _HSLA_RE.match(color)
    if match is not None:
        hs, ss, ls, as_ = match.groups()
        h = ((float_(hs) % 360.0 + 360.0) % 360.0) / 360.0
        s = max_(0.0, min_(100.0, float_(ss))) / 100.0
        l = max_(0.0, min_(100.0, float_(ls))) / 100.0
        a = max_(0.0, min_(1.0, float_(as_)))
        r, g, b = hls_to_rgb(h, l, s)
        return (r, g, b, a)


#: A dispatch table of color parser functions.
_COLOR_PARSERS = {
    '#': _parse_hex_color,
    'r': _parse_rgb_color,
    'h': _parse_hsl_color,
}


def parse_color(color):
    """ Parse a color string into a tuple of RGBA values.

    Parameters
    ----------
    color : string
        A CSS3 string representation of the color.

    Returns
    -------
    result : tuple or None
        A tuple of RGBA values. All values are floats in the range
        0.0 - 1.0. If the string is invalid, None will be returned.

    """
    if color in _COLOR_TABLE:
        return _COLOR_TABLE[color]
    color = color.strip()
    if color:
        key = color[0]
        if key in _COLOR_PARSERS:
            return _COLOR_PARSERS[key](color)


def composite_colors(first, second):
    """ Composite two colors together using their given alpha.

    The first color will be composited on top of the second color.

    Parameters
    ----------
    first : tuple
        The rgba tuple of the first color. All values are floats in
        the range 0.0 - 1.0.

    second : tuple
        The rgba tuple of the second color. The format of this tuple
        is the same as the first color.

    Returns
    -------
    result : tuple
        The composited rgba color tuple.

    """
    r1, g1, b1, a1 = first
    r2, g2, b2, a2 = second
    y = a2 * (1.0 - a1)
    ro = r1 * a1 + r2 * y
    go = g1 * a1 + g2 * y
    bo = b1 * a1 + b2 * y
    ao = a1 + y
    return (ro, go, bo, ao)


########NEW FILE########
__FILENAME__ = abstract_expressions
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from abc import ABCMeta, abstractmethod


class AbstractExpression(object):
    """ An abstract interface definition for creating expressions.

    Expressions are registered with `Declarative` instances using the
    `bind_expression` method to provide computed attribute values.

    """
    __metaclass__ = ABCMeta

    @abstractmethod
    def eval(self, obj, name):
        """ Evaluate and return the results of the expression.

        Parameters
        ----------
        obj : Declarative
            The declarative object which owns the expression.

        name : str
            The attribute name on `obj` for which this expression is
            providing the value.

        """
        raise NotImplementedError


class AbstractListener(object):
    """ An interface definition for creating attribute listeners.

    Listeners are registered with `Declarative` instances using the
    `bind_listener` method to track changes to their attributes.

    """
    __metaclass__ = ABCMeta

    @abstractmethod
    def value_changed(self, obj, name, old, new):
        """ Called when the attribute on the object has changed.

        Parameters
        ----------
        obj : Declarative
            The Declarative object which owns the attribute.

        name : str
            The name of the attribute which changed.

        old : object
            The old value of the attribute.

        new : object
            The new value of the attribute.

        """
        raise NotImplementedError


########NEW FILE########
__FILENAME__ = api
#------------------------------------------------------------------------------
#  Copyright (c) 2013, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from .conditional import Conditional
from .declarative import Declarative
from .include import Include
from .looper import Looper
from .messenger import Messenger
from .object import Object
from .templated import Templated


########NEW FILE########
__FILENAME__ = byteplay
# byteplay - Python bytecode assembler/disassembler.
# Copyright (C) 2006-2010 Noam Yorav-Raphael
# Homepage: http://code.google.com/p/byteplay
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA

# Many thanks to Greg X for adding support for Python 2.6 and 2.7!

__version__ = '0.2'

__all__ = ['opmap', 'opname', 'opcodes',
           'cmp_op', 'hasarg', 'hasname', 'hasjrel', 'hasjabs',
           'hasjump', 'haslocal', 'hascompare', 'hasfree', 'hascode',
           'hasflow', 'getse',
           'Opcode', 'SetLineno', 'Label', 'isopcode', 'Code',
           'CodeList', 'printcodelist']

import opcode
from dis import findlabels
import types
from array import array
import operator
import itertools
import sys
import warnings
from cStringIO import StringIO

######################################################################
# Define opcodes and information about them

python_version = '.'.join(str(x) for x in sys.version_info[:2])
if python_version not in ('2.4', '2.5', '2.6', '2.7'):
    warnings.warn("byteplay doesn't support Python version "+python_version)

class Opcode(int):
    """An int which represents an opcode - has a nicer repr."""
    def __repr__(self):
        return opname[self]
    __str__ = __repr__

class CodeList(list):
    """A list for storing opcode tuples - has a nicer __str__."""
    def __str__(self):
        f = StringIO()
        printcodelist(self, f)
        return f.getvalue()

opmap = dict((name.replace('+', '_'), Opcode(code))
             for name, code in opcode.opmap.iteritems()
             if name != 'EXTENDED_ARG')
opname = dict((code, name) for name, code in opmap.iteritems())
opcodes = set(opname)

def globalize_opcodes():
    for name, code in opmap.iteritems():
        globals()[name] = code
        __all__.append(name)
globalize_opcodes()

cmp_op = opcode.cmp_op

hasarg = set(x for x in opcodes if x >= opcode.HAVE_ARGUMENT)
hasconst = set(Opcode(x) for x in opcode.hasconst)
hasname = set(Opcode(x) for x in opcode.hasname)
hasjrel = set(Opcode(x) for x in opcode.hasjrel)
hasjabs = set(Opcode(x) for x in opcode.hasjabs)
hasjump = hasjrel.union(hasjabs)
haslocal = set(Opcode(x) for x in opcode.haslocal)
hascompare = set(Opcode(x) for x in opcode.hascompare)
hasfree = set(Opcode(x) for x in opcode.hasfree)
hascode = set([MAKE_FUNCTION, MAKE_CLOSURE])

class _se:
    """Quick way of defining static stack effects of opcodes"""
    # Taken from assembler.py by Phillip J. Eby
    NOP       = 0,0

    POP_TOP   = 1,0
    ROT_TWO   = 2,2
    ROT_THREE = 3,3
    ROT_FOUR  = 4,4
    DUP_TOP   = 1,2

    UNARY_POSITIVE = UNARY_NEGATIVE = UNARY_NOT = UNARY_CONVERT = \
        UNARY_INVERT = GET_ITER = LOAD_ATTR = 1,1

    IMPORT_FROM = 1,2

    BINARY_POWER = BINARY_MULTIPLY = BINARY_DIVIDE = BINARY_FLOOR_DIVIDE = \
        BINARY_TRUE_DIVIDE = BINARY_MODULO = BINARY_ADD = BINARY_SUBTRACT = \
        BINARY_SUBSCR = BINARY_LSHIFT = BINARY_RSHIFT = BINARY_AND = \
        BINARY_XOR = BINARY_OR = COMPARE_OP = 2,1

    INPLACE_POWER = INPLACE_MULTIPLY = INPLACE_DIVIDE = \
        INPLACE_FLOOR_DIVIDE = INPLACE_TRUE_DIVIDE = INPLACE_MODULO = \
        INPLACE_ADD = INPLACE_SUBTRACT = INPLACE_LSHIFT = INPLACE_RSHIFT = \
        INPLACE_AND = INPLACE_XOR = INPLACE_OR = 2,1

    SLICE_0, SLICE_1, SLICE_2, SLICE_3 = \
        (1,1),(2,1),(2,1),(3,1)
    STORE_SLICE_0, STORE_SLICE_1, STORE_SLICE_2, STORE_SLICE_3 = \
        (2,0),(3,0),(3,0),(4,0)
    DELETE_SLICE_0, DELETE_SLICE_1, DELETE_SLICE_2, DELETE_SLICE_3 = \
        (1,0),(2,0),(2,0),(3,0)

    STORE_SUBSCR = 3,0
    DELETE_SUBSCR = STORE_ATTR = 2,0
    DELETE_ATTR = STORE_DEREF = 1,0
    PRINT_NEWLINE = 0,0
    PRINT_EXPR = PRINT_ITEM = PRINT_NEWLINE_TO = IMPORT_STAR = 1,0
    STORE_NAME = STORE_GLOBAL = STORE_FAST = 1,0
    PRINT_ITEM_TO = 2,0

    LOAD_LOCALS = LOAD_CONST = LOAD_NAME = LOAD_GLOBAL = LOAD_FAST = \
        LOAD_CLOSURE = LOAD_DEREF = BUILD_MAP = 0,1

    DELETE_FAST = DELETE_GLOBAL = DELETE_NAME = 0,0

    EXEC_STMT = 3,0
    BUILD_CLASS = 3,1

    STORE_MAP = MAP_ADD = 2,0
    SET_ADD = 1,0

    if   python_version == '2.4':
      YIELD_VALUE = 1,0
      IMPORT_NAME = 1,1
      LIST_APPEND = 2,0
    elif python_version == '2.5':
      YIELD_VALUE = 1,1
      IMPORT_NAME = 2,1
      LIST_APPEND = 2,0
    elif python_version == '2.6':
      YIELD_VALUE = 1,1
      IMPORT_NAME = 2,1
      LIST_APPEND = 2,0
    elif python_version == '2.7':
      YIELD_VALUE = 1,1
      IMPORT_NAME = 2,1
      LIST_APPEND = 1,0


_se = dict((op, getattr(_se, opname[op]))
           for op in opcodes
           if hasattr(_se, opname[op]))

hasflow = opcodes - set(_se) - \
          set([CALL_FUNCTION, CALL_FUNCTION_VAR, CALL_FUNCTION_KW,
               CALL_FUNCTION_VAR_KW, BUILD_TUPLE, BUILD_LIST,
               UNPACK_SEQUENCE, BUILD_SLICE, DUP_TOPX,
               RAISE_VARARGS, MAKE_FUNCTION, MAKE_CLOSURE])
if python_version == '2.7':
  hasflow = hasflow - set([BUILD_SET])

def getse(op, arg=None):
    """Get the stack effect of an opcode, as a (pop, push) tuple.

    If an arg is needed and is not given, a ValueError is raised.
    If op isn't a simple opcode, that is, the flow doesn't always continue
    to the next opcode, a ValueError is raised.
    """
    try:
        return _se[op]
    except KeyError:
        # Continue to opcodes with an effect that depends on arg
        pass

    if arg is None:
        raise ValueError, "Opcode stack behaviour depends on arg"

    def get_func_tup(arg, nextra):
        if arg > 0xFFFF:
            raise ValueError, "Can only split a two-byte argument"
        return (nextra + 1 + (arg & 0xFF) + 2*((arg >> 8) & 0xFF),
                1)

    if op == CALL_FUNCTION:
        return get_func_tup(arg, 0)
    elif op == CALL_FUNCTION_VAR:
        return get_func_tup(arg, 1)
    elif op == CALL_FUNCTION_KW:
        return get_func_tup(arg, 1)
    elif op == CALL_FUNCTION_VAR_KW:
        return get_func_tup(arg, 2)

    elif op == BUILD_TUPLE:
        return arg, 1
    elif op == BUILD_LIST:
        return arg, 1
    elif python_version == '2.7' and op == BUILD_SET:
        return arg, 1
    elif op == UNPACK_SEQUENCE:
        return 1, arg
    elif op == BUILD_SLICE:
        return arg, 1
    elif op == DUP_TOPX:
        return arg, arg*2
    elif op == RAISE_VARARGS:
        return 1+arg, 1
    elif op == MAKE_FUNCTION:
        return 1+arg, 1
    elif op == MAKE_CLOSURE:
        if python_version == '2.4':
            raise ValueError, "The stack effect of MAKE_CLOSURE depends on TOS"
        else:
            return 2+arg, 1
    else:
        raise ValueError, "The opcode %r isn't recognized or has a special "\
              "flow control" % op

class SetLinenoType(object):
    def __repr__(self):
        return 'SetLineno'
SetLineno = SetLinenoType()

class Label(object):
    pass

def isopcode(obj):
    """Return whether obj is an opcode - not SetLineno or Label"""
    return obj is not SetLineno and not isinstance(obj, Label)

# Flags from code.h
CO_OPTIMIZED              = 0x0001      # use LOAD/STORE_FAST instead of _NAME
CO_NEWLOCALS              = 0x0002      # only cleared for module/exec code
CO_VARARGS                = 0x0004
CO_VARKEYWORDS            = 0x0008
CO_NESTED                 = 0x0010      # ???
CO_GENERATOR              = 0x0020
CO_NOFREE                 = 0x0040      # set if no free or cell vars
CO_GENERATOR_ALLOWED      = 0x1000      # unused
# The future flags are only used on code generation, so we can ignore them.
# (It does cause some warnings, though.)
CO_FUTURE_DIVISION        = 0x2000
CO_FUTURE_ABSOLUTE_IMPORT = 0x4000
CO_FUTURE_WITH_STATEMENT  = 0x8000


######################################################################
# Define the Code class

class Code(object):
    """An object which holds all the information which a Python code object
    holds, but in an easy-to-play-with representation.

    The attributes are:

    Affecting action
    ----------------
    code - list of 2-tuples: the code
    freevars - list of strings: the free vars of the code (those are names
               of variables created in outer functions and used in the function)
    args - list of strings: the arguments of the code
    varargs - boolean: Does args end with a '*args' argument
    varkwargs - boolean: Does args end with a '**kwargs' argument
    newlocals - boolean: Should a new local namespace be created.
                (True in functions, False for module and exec code)

    Not affecting action
    --------------------
    name - string: the name of the code (co_name)
    filename - string: the file name of the code (co_filename)
    firstlineno - int: the first line number (co_firstlineno)
    docstring - string or None: the docstring (the first item of co_consts,
                if it's str or unicode)

    code is a list of 2-tuples. The first item is an opcode, or SetLineno, or a
    Label instance. The second item is the argument, if applicable, or None.
    code can be a CodeList instance, which will produce nicer output when
    being printed.
    """
    def __init__(self, code, freevars, args, varargs, varkwargs, newlocals,
                 name, filename, firstlineno, docstring):
        self.code = code
        self.freevars = freevars
        self.args = args
        self.varargs = varargs
        self.varkwargs = varkwargs
        self.newlocals = newlocals
        self.name = name
        self.filename = filename
        self.firstlineno = firstlineno
        self.docstring = docstring

    @staticmethod
    def _findlinestarts(code):
        """Find the offsets in a byte code which are start of lines in the
        source.

        Generate pairs (offset, lineno) as described in Python/compile.c.

        This is a modified version of dis.findlinestarts, which allows multiple
        "line starts" with the same line number.
        """
        byte_increments = [ord(c) for c in code.co_lnotab[0::2]]
        line_increments = [ord(c) for c in code.co_lnotab[1::2]]

        lineno = code.co_firstlineno
        addr = 0
        for byte_incr, line_incr in zip(byte_increments, line_increments):
            if byte_incr:
                yield (addr, lineno)
                addr += byte_incr
            lineno += line_incr
        yield (addr, lineno)

    @classmethod
    def from_code(cls, co):
        """Disassemble a Python code object into a Code object."""
        co_code = co.co_code
        labels = dict((addr, Label()) for addr in findlabels(co_code))
        linestarts = dict(cls._findlinestarts(co))
        cellfree = co.co_cellvars + co.co_freevars

        code = CodeList()
        n = len(co_code)
        i = 0
        extended_arg = 0
        while i < n:
            op = Opcode(ord(co_code[i]))
            if i in labels:
                code.append((labels[i], None))
            if i in linestarts:
                code.append((SetLineno, linestarts[i]))
            i += 1
            if op in hascode:
                lastop, lastarg = code[-1]
                if lastop != LOAD_CONST:
                    raise ValueError, \
                          "%s should be preceded by LOAD_CONST code" % op
                code[-1] = (LOAD_CONST, Code.from_code(lastarg))
            if op not in hasarg:
                code.append((op, None))
            else:
                arg = ord(co_code[i]) + ord(co_code[i+1])*256 + extended_arg
                extended_arg = 0
                i += 2
                if op == opcode.EXTENDED_ARG:
                    extended_arg = arg << 16
                elif op in hasconst:
                    code.append((op, co.co_consts[arg]))
                elif op in hasname:
                    code.append((op, co.co_names[arg]))
                elif op in hasjabs:
                    code.append((op, labels[arg]))
                elif op in hasjrel:
                    code.append((op, labels[i + arg]))
                elif op in haslocal:
                    code.append((op, co.co_varnames[arg]))
                elif op in hascompare:
                    code.append((op, cmp_op[arg]))
                elif op in hasfree:
                    code.append((op, cellfree[arg]))
                else:
                    code.append((op, arg))

        varargs = bool(co.co_flags & CO_VARARGS)
        varkwargs = bool(co.co_flags & CO_VARKEYWORDS)
        newlocals = bool(co.co_flags & CO_NEWLOCALS)
        args = co.co_varnames[:co.co_argcount + varargs + varkwargs]
        if co.co_consts and isinstance(co.co_consts[0], basestring):
            docstring = co.co_consts[0]
        else:
            docstring = None
        return cls(code = code,
                   freevars = co.co_freevars,
                   args = args,
                   varargs = varargs,
                   varkwargs = varkwargs,
                   newlocals = newlocals,
                   name = co.co_name,
                   filename = co.co_filename,
                   firstlineno = co.co_firstlineno,
                   docstring = docstring,
                   )

    def __eq__(self, other):
        if (self.freevars != other.freevars or
            self.args != other.args or
            self.varargs != other.varargs or
            self.varkwargs != other.varkwargs or
            self.newlocals != other.newlocals or
            self.name != other.name or
            self.filename != other.filename or
            self.firstlineno != other.firstlineno or
            self.docstring != other.docstring or
            len(self.code) != len(other.code)
            ):
            return False

        # Compare code. This isn't trivial because labels should be matching,
        # not equal.
        labelmapping = {}
        for (op1, arg1), (op2, arg2) in itertools.izip(self.code, other.code):
            if isinstance(op1, Label):
                if labelmapping.setdefault(op1, op2) is not op2:
                    return False
            else:
                if op1 != op2:
                    return False
                if op1 in hasjump:
                    if labelmapping.setdefault(arg1, arg2) is not arg2:
                        return False
                elif op1 in hasarg:
                    if arg1 != arg2:
                        return False
        return True

    def _compute_flags(self):
        opcodes = set(op for op, arg in self.code if isopcode(op))

        optimized = (STORE_NAME not in opcodes and
                     LOAD_NAME not in opcodes and
                     DELETE_NAME not in opcodes)
        generator = (YIELD_VALUE in opcodes)
        nofree = not (opcodes.intersection(hasfree))

        flags = 0
        if optimized: flags |= CO_OPTIMIZED
        if self.newlocals: flags |= CO_NEWLOCALS
        if self.varargs: flags |= CO_VARARGS
        if self.varkwargs: flags |= CO_VARKEYWORDS
        if generator: flags |= CO_GENERATOR
        if nofree: flags |= CO_NOFREE
        return flags

    def _compute_stacksize(self):
        """Get a code list, compute its maximal stack usage."""
        # This is done by scanning the code, and computing for each opcode
        # the stack state at the opcode.
        code = self.code

        # A mapping from labels to their positions in the code list
        label_pos = dict((op, pos)
                         for pos, (op, arg) in enumerate(code)
                         if isinstance(op, Label))

        # sf_targets are the targets of SETUP_FINALLY opcodes. They are recorded
        # because they have special stack behaviour. If an exception was raised
        # in the block pushed by a SETUP_FINALLY opcode, the block is popped
        # and 3 objects are pushed. On return or continue, the block is popped
        # and 2 objects are pushed. If nothing happened, the block is popped by
        # a POP_BLOCK opcode and 1 object is pushed by a (LOAD_CONST, None)
        # operation.
        #
        # Our solution is to record the stack state of SETUP_FINALLY targets
        # as having 3 objects pushed, which is the maximum. However, to make
        # stack recording consistent, the get_next_stacks function will always
        # yield the stack state of the target as if 1 object was pushed, but
        # this will be corrected in the actual stack recording.

        sf_targets = set(label_pos[arg]
                         for op, arg in code
                         if op == SETUP_FINALLY)

        # What we compute - for each opcode, its stack state, as an n-tuple.
        # n is the number of blocks pushed. For each block, we record the number
        # of objects pushed.
        stacks = [None] * len(code)

        def get_next_stacks(pos, curstack):
            """Get a code position and the stack state before the operation
            was done, and yield pairs (pos, curstack) for the next positions
            to be explored - those are the positions to which you can get
            from the given (pos, curstack).

            If the given position was already explored, nothing will be yielded.
            """
            op, arg = code[pos]

            if isinstance(op, Label):
                # We should check if we already reached a node only if it is
                # a label.
                if pos in sf_targets:
                    curstack = curstack[:-1] + (curstack[-1] + 2,)
                if stacks[pos] is None:
                    stacks[pos] = curstack
                else:
                    if stacks[pos] != curstack:
                        raise ValueError, "Inconsistent code"
                    return

            def newstack(n):
                # Return a new stack, modified by adding n elements to the last
                # block
                if curstack[-1] + n < 0:
                    raise ValueError, "Popped a non-existing element"
                return curstack[:-1] + (curstack[-1]+n,)

            if not isopcode(op):
                # label or SetLineno - just continue to next line
                yield pos+1, curstack

            elif op in (STOP_CODE, RETURN_VALUE, RAISE_VARARGS):
                # No place in particular to continue to
                pass

            elif op == MAKE_CLOSURE and python_version == '2.4':
                # This is only relevant in Python 2.4 - in Python 2.5 the stack
                # effect of MAKE_CLOSURE can be calculated from the arg.
                # In Python 2.4, it depends on the number of freevars of TOS,
                # which should be a code object.
                if pos == 0:
                    raise ValueError, \
                          "MAKE_CLOSURE can't be the first opcode"
                lastop, lastarg = code[pos-1]
                if lastop != LOAD_CONST:
                    raise ValueError, \
                          "MAKE_CLOSURE should come after a LOAD_CONST op"
                try:
                    nextrapops = len(lastarg.freevars)
                except AttributeError:
                    try:
                        nextrapops = len(lastarg.co_freevars)
                    except AttributeError:
                        raise ValueError, \
                              "MAKE_CLOSURE preceding const should "\
                              "be a code or a Code object"

                yield pos+1, newstack(-arg-nextrapops)

            elif op not in hasflow:
                # Simple change of stack
                pop, push = getse(op, arg)
                yield pos+1, newstack(push - pop)

            elif op in (JUMP_FORWARD, JUMP_ABSOLUTE):
                # One possibility for a jump
                yield label_pos[arg], curstack

            elif python_version < '2.7' and op in (JUMP_IF_FALSE, JUMP_IF_TRUE):
                # Two possibilities for a jump
                yield label_pos[arg], curstack
                yield pos+1, curstack

            elif python_version >= '2.7' and op in (POP_JUMP_IF_FALSE, POP_JUMP_IF_TRUE):
                # Two possibilities for a jump
                yield label_pos[arg], newstack(-1)
                yield pos+1, newstack(-1)

            elif python_version >= '2.7' and op in (JUMP_IF_TRUE_OR_POP, JUMP_IF_FALSE_OR_POP):
                # Two possibilities for a jump
                yield label_pos[arg], curstack
                yield pos+1, newstack(-1)

            elif op == FOR_ITER:
                # FOR_ITER pushes next(TOS) on success, and pops TOS and jumps
                # on failure
                yield label_pos[arg], newstack(-1)
                yield pos+1, newstack(1)

            elif op == BREAK_LOOP:
                # BREAK_LOOP jumps to a place specified on block creation, so
                # it is ignored here
                pass

            elif op == CONTINUE_LOOP:
                # CONTINUE_LOOP jumps to the beginning of a loop which should
                # already ave been discovered, but we verify anyway.
                # It pops a block.
                if python_version == '2.6':
                  pos, stack = label_pos[arg], curstack[:-1]
                  if stacks[pos] != stack: #this could be a loop with a 'with' inside
                    yield pos, stack[:-1] + (stack[-1]-1,)
                  else:
                    yield pos, stack
                else:
                  yield label_pos[arg], curstack[:-1]

            elif op == SETUP_LOOP:
                # We continue with a new block.
                # On break, we jump to the label and return to current stack
                # state.
                yield label_pos[arg], curstack
                yield pos+1, curstack + (0,)

            elif op == SETUP_EXCEPT:
                # We continue with a new block.
                # On exception, we jump to the label with 3 extra objects on
                # stack
                yield label_pos[arg], newstack(3)
                yield pos+1, curstack + (0,)

            elif op == SETUP_FINALLY:
                # We continue with a new block.
                # On exception, we jump to the label with 3 extra objects on
                # stack, but to keep stack recording consistent, we behave as
                # if we add only 1 object. Extra 2 will be added to the actual
                # recording.
                yield label_pos[arg], newstack(1)
                yield pos+1, curstack + (0,)

            elif python_version == '2.7' and op == SETUP_WITH:
                yield label_pos[arg], curstack
                yield pos+1, newstack(-1) + (1,)

            elif op == POP_BLOCK:
                # Just pop the block
                yield pos+1, curstack[:-1]

            elif op == END_FINALLY:
                # Since stack recording of SETUP_FINALLY targets is of 3 pushed
                # objects (as when an exception is raised), we pop 3 objects.
                yield pos+1, newstack(-3)

            elif op == WITH_CLEANUP:
                # Since WITH_CLEANUP is always found after SETUP_FINALLY
                # targets, and the stack recording is that of a raised
                # exception, we can simply pop 1 object and let END_FINALLY
                # pop the remaining 3.
                if python_version == '2.7':
                  yield pos+1, newstack(2)
                else:
                  yield pos+1, newstack(-1)

            else:
                assert False, "Unhandled opcode: %r" % op


        # Now comes the calculation: open_positions holds positions which are
        # yet to be explored. In each step we take one open position, and
        # explore it by adding the positions to which you can get from it, to
        # open_positions. On the way, we update maxsize.
        # open_positions is a list of tuples: (pos, stack state)
        maxsize = 0
        open_positions = [(0, (0,))]
        while open_positions:
            pos, curstack = open_positions.pop()
            maxsize = max(maxsize, sum(curstack))
            open_positions.extend(get_next_stacks(pos, curstack))

        return maxsize

    def to_code(self):
        """Assemble a Python code object from a Code object."""
        co_argcount = len(self.args) - self.varargs - self.varkwargs
        co_stacksize = self._compute_stacksize()
        co_flags = self._compute_flags()

        co_consts = [self.docstring]
        co_names = []
        co_varnames = list(self.args)

        co_freevars = tuple(self.freevars)

        # We find all cellvars beforehand, for two reasons:
        # 1. We need the number of them to construct the numeric argument
        #    for ops in "hasfree".
        # 2. We need to put arguments which are cell vars in the beginning
        #    of co_cellvars
        cellvars = set(arg for op, arg in self.code
                       if isopcode(op) and op in hasfree
                       and arg not in co_freevars)
        co_cellvars = [x for x in self.args if x in cellvars]

        def index(seq, item, eq=operator.eq, can_append=True):
            """Find the index of item in a sequence and return it.
            If it is not found in the sequence, and can_append is True,
            it is appended to the sequence.

            eq is the equality operator to use.
            """
            for i, x in enumerate(seq):
                if eq(x, item):
                    return i
            else:
                if can_append:
                    seq.append(item)
                    return len(seq) - 1
                else:
                    raise IndexError, "Item not found"

        # List of tuples (pos, label) to be filled later
        jumps = []
        # A mapping from a label to its position
        label_pos = {}
        # Last SetLineno
        lastlineno = self.firstlineno
        lastlinepos = 0

        co_code = array('B')
        co_lnotab = array('B')
        for i, (op, arg) in enumerate(self.code):
            if isinstance(op, Label):
                label_pos[op] = len(co_code)

            elif op is SetLineno:
                incr_lineno = arg - lastlineno
                incr_pos = len(co_code) - lastlinepos
                lastlineno = arg
                lastlinepos = len(co_code)

                if incr_lineno == 0 and incr_pos == 0:
                    co_lnotab.append(0)
                    co_lnotab.append(0)
                else:
                    while incr_pos > 255:
                        co_lnotab.append(255)
                        co_lnotab.append(0)
                        incr_pos -= 255
                    while incr_lineno > 255:
                        co_lnotab.append(incr_pos)
                        co_lnotab.append(255)
                        incr_pos = 0
                        incr_lineno -= 255
                    if incr_pos or incr_lineno:
                        co_lnotab.append(incr_pos)
                        co_lnotab.append(incr_lineno)

            elif op == opcode.EXTENDED_ARG:
                raise ValueError, "EXTENDED_ARG not supported in Code objects"

            elif not op in hasarg:
                co_code.append(op)

            else:
                if op in hasconst:
                    if isinstance(arg, Code) and i < len(self.code)-1 and \
                       self.code[i+1][0] in hascode:
                        arg = arg.to_code()
                    arg = index(co_consts, arg, operator.is_)
                elif op in hasname:
                    arg = index(co_names, arg)
                elif op in hasjump:
                    # arg will be filled later
                    jumps.append((len(co_code), arg))
                    arg = 0
                elif op in haslocal:
                    arg = index(co_varnames, arg)
                elif op in hascompare:
                    arg = index(cmp_op, arg, can_append=False)
                elif op in hasfree:
                    try:
                        arg = index(co_freevars, arg, can_append=False) \
                              + len(cellvars)
                    except IndexError:
                        arg = index(co_cellvars, arg)
                else:
                    # arg is ok
                    pass

                if arg > 0xFFFF:
                    co_code.append(opcode.EXTENDED_ARG)
                    co_code.append((arg >> 16) & 0xFF)
                    co_code.append((arg >> 24) & 0xFF)
                co_code.append(op)
                co_code.append(arg & 0xFF)
                co_code.append((arg >> 8) & 0xFF)

        for pos, label in jumps:
            jump = label_pos[label]
            if co_code[pos] in hasjrel:
                jump -= pos+3
            if jump > 0xFFFF:
                raise NotImplementedError, "Extended jumps not implemented"
            co_code[pos+1] = jump & 0xFF
            co_code[pos+2] = (jump >> 8) & 0xFF

        co_code = co_code.tostring()
        co_lnotab = co_lnotab.tostring()

        co_consts = tuple(co_consts)
        co_names = tuple(co_names)
        co_varnames = tuple(co_varnames)
        co_nlocals = len(co_varnames)
        co_cellvars = tuple(co_cellvars)

        return types.CodeType(co_argcount, co_nlocals, co_stacksize, co_flags,
                              co_code, co_consts, co_names, co_varnames,
                              self.filename, self.name, self.firstlineno, co_lnotab,
                              co_freevars, co_cellvars)


def printcodelist(codelist, to=sys.stdout):
    """Get a code list. Print it nicely."""

    labeldict = {}
    pendinglabels = []
    for i, (op, arg) in enumerate(codelist):
        if isinstance(op, Label):
            pendinglabels.append(op)
        elif op is SetLineno:
            pass
        else:
            while pendinglabels:
                labeldict[pendinglabels.pop()] = i

    lineno = None
    islabel = False
    for i, (op, arg) in enumerate(codelist):
        if op is SetLineno:
            lineno = arg
            print >> to
            continue

        if isinstance(op, Label):
            islabel = True
            continue

        if lineno is None:
            linenostr = ''
        else:
            linenostr = str(lineno)
            lineno = None

        if islabel:
            islabelstr = '>>'
            islabel = False
        else:
            islabelstr = ''

        if op in hasconst:
            argstr = repr(arg)
        elif op in hasjump:
            try:
                argstr = 'to ' + str(labeldict[arg])
            except KeyError:
                argstr = repr(arg)
        elif op in hasarg:
            argstr = str(arg)
        else:
            argstr = ''

        print >> to, '%3s     %2s %4d %-20s %s' % (
            linenostr,
            islabelstr,
            i,
            op,
            argstr)

def recompile(filename):
    """Create a .pyc by disassembling the file and assembling it again, printing
    a message that the reassembled file was loaded."""
    # Most of the code here based on the compile.py module.
    import os
    import imp
    import marshal
    import struct

    f = open(filename, 'U')
    try:
        timestamp = long(os.fstat(f.fileno()).st_mtime)
    except AttributeError:
        timestamp = long(os.stat(filename).st_mtime)
    codestring = f.read()
    f.close()
    if codestring and codestring[-1] != '\n':
        codestring = codestring + '\n'
    try:
        codeobject = compile(codestring, filename, 'exec')
    except SyntaxError:
        print >> sys.stderr, "Skipping %s - syntax error." % filename
        return
    cod = Code.from_code(codeobject)
    message = "reassembled %r imported.\n" % filename
    cod.code[:0] = [ # __import__('sys').stderr.write(message)
        (LOAD_GLOBAL, '__import__'),
        (LOAD_CONST, 'sys'),
        (CALL_FUNCTION, 1),
        (LOAD_ATTR, 'stderr'),
        (LOAD_ATTR, 'write'),
        (LOAD_CONST, message),
        (CALL_FUNCTION, 1),
        (POP_TOP, None),
        ]
    codeobject2 = cod.to_code()
    fc = open(filename+'c', 'wb')
    fc.write('\0\0\0\0')
    fc.write(struct.pack('<l', timestamp))
    marshal.dump(codeobject2, fc)
    fc.flush()
    fc.seek(0, 0)
    fc.write(imp.get_magic())
    fc.close()

def recompile_all(path):
    """recursively recompile all .py files in the directory"""
    import os
    if os.path.isdir(path):
        for root, dirs, files in os.walk(path):
            for name in files:
                if name.endswith('.py'):
                    filename = os.path.abspath(os.path.join(root, name))
                    print >> sys.stderr, filename
                    recompile(filename)
    else:
        filename = os.path.abspath(path)
        recompile(filename)

def main():
    import os
    if len(sys.argv) != 2 or not os.path.exists(sys.argv[1]):
        print """\
Usage: %s dir

Search recursively for *.py in the given directory, disassemble and assemble
them, adding a note when each file is imported.

Use it to test byteplay like this:
> byteplay.py Lib
> make test

Some FutureWarnings may be raised, but that's expected.

Tip: before doing this, check to see which tests fail even without reassembling
them...
""" % sys.argv[0]
        sys.exit(1)
    recompile_all(sys.argv[1])

if __name__ == '__main__':
    main()

########NEW FILE########
__FILENAME__ = code_tracing
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from .byteplay import (
    LOAD_ATTR, LOAD_CONST, ROT_TWO, DUP_TOP, CALL_FUNCTION, POP_TOP, LOAD_FAST,
    BUILD_TUPLE, ROT_THREE, UNPACK_SEQUENCE, DUP_TOPX, BINARY_SUBSCR, GET_ITER,
    LOAD_NAME, RETURN_VALUE
)


class CodeTracer(object):
    """ A base class for implementing code tracers.

    This class defines the interface for a code tracer object, which is
    an object which can be passed as the first argument to a code object
    which has been transformed to enable tracing. Methods on the tracer
    are called with relevant arguments from the Python stack when that
    particular code segment is executing. The return value of a tracer
    method is ignored; exceptions are propagated.

    """
    def load_attr(self, obj, attr):
        """ Called before the LOAD_ATTR opcode is executed.

        Parameters
        ----------
        obj : object
            The object which owns the attribute.

        attr : str
            The attribute being loaded.

        """
        pass

    def call_function(self, func, argtuple, argspec):
        """ Called before the CALL_FUNCTION opcode is executed.

        Parameters
        ----------
        func : object
            The object being called.

        argtuple : tuple
            The argument tuple from the stack (see notes).

        argspec : int
            The argument tuple specification.

        Notes
        -----
        The `argstuple` contains both positional and keyword argument
        information. `argspec` is an int which specifies how to parse
        the information. The lower 16bits of `argspec` are significant.
        The lowest 8 bits are the number of positional arguments which
        are the first n items in `argtuple`. The second 8 bits are the
        number of keyword arguments which follow the positional args in
        `argtuple` and alternate name -> value. `argtuple` can be parsed
        into a conventional tuple and dict with the following:

            nargs = argspec & 0xFF
            args = argtuple[:nargs]
            kwargs = dict(zip(argtuple[nargs::2], argtuple[nargs+1::2]))

        """
        pass

    def binary_subscr(self, obj, idx):
        """ Called before the BINARY_SUBSCR opcode is executed.

        Parameters
        ----------
        obj : object
            The object being indexed.

        idx : object
            The index.

        """
        pass

    def get_iter(self, obj):
        """ Called before the GET_ITER opcode is executed.

        Parameters
        ----------
        obj : object
            The object which should return an iterator.

        """
        pass


class CodeInverter(object):
    """ A base class for implementing code inverters.

    This class defines the interface for a code inverter object, which is
    an object which can be passed as the first argument to a code object
    which has been transformed to enable inversion. The methods on the
    inverter are called with relevant arguments from the Python stack
    when that particular code segment is executing. The return values of
    a tracer method is ignored; exceptions are propagated.

    The default behavior of an inverter is to raise. Implementations
    must provide their own code in order to enable inversion.

    """
    def fail(self):
        """ Called by handlers to raise an inversion exception.

        """
        raise RuntimeError("can't assign to expression")

    def load_name(self, name, value):
        """ Called before the LOAD_NAME opcode is executed.

        This method should perform a STORE_NAME operation.

        Parameters
        ----------
        name : str
            The name being loaded.

        value : object
            The value to store.

        """
        self.fail()

    def load_attr(self, obj, attr, value):
        """ Called before the LOAD_ATTR opcode is executed.

        This method should perform a STORE_ATTR operation.

        Parameters
        ----------
        obj : object
            The object which owns the attribute.

        attr : str
            The attribute being loaded.

        value : object
            The value to store

        """
        self.fail()

    def call_function(self, func, argtuple, argspec, value):
        """ Called before the CALL_FUNCTION opcode is executed.

        This method should perform an appropriate store operation.

        Parameters
        ----------
        func : object
            The object being called.

        argtuple : tuple
            The argument tuple from the stack (see Notes).

        argspec : int
            The argument tuple specification.

        value : object
            The value to store.

        Notes
        -----
        The semantics of the arguments is identical to the method
        `call_function` on the `CodeTracer` type.

        """
        self.fail()

    def binary_subscr(self, obj, idx, value):
        """ Called before the BINARY_SUBSCR opcode is executed.

        This method should perform a STORE_SUBSCR operation.

        Parameters
        ----------
        obj : object
            The object being indexed.

        idx : object
            The index.

        value : object
            The value to store.

        """
        self.fail()


def inject_tracing(codelist):
    """ Inject tracing code into the given code list.

    This will inject the bytecode operations required to trace the
    execution of the code using a `CodeTracer` object. The generated
    opcodes expect a fast local '_[tracer]' to be available when the
    code is executed.

    Parameters
    ----------
    codelist : list
        The list of byteplay code ops to modify.

    Returns
    -------
    result : list
        A *new* list of code ops which implement the desired behavior.

    """
    # This builds a mapping of code idx to a list of ops, which are the
    # tracing bytecode instructions which will be inserted into the code
    # object being transformed. The ops assume that a tracer object is
    # available in the fast locals using a non-clashable name. All of
    # the ops have a net-zero effect on the execution stack. Provided
    # that the tracer has no visible side effects, the tracing is
    # transparent.
    inserts = {}
    for idx, (op, op_arg) in enumerate(codelist):
        if op == LOAD_ATTR:
            code = [                        # obj
                (DUP_TOP, None),            # obj -> obj
                (LOAD_FAST, '_[tracer]'),   # obj -> obj -> tracer
                (LOAD_ATTR, 'load_attr'),   # obj -> obj -> tracefunc
                (ROT_TWO, None),            # obj -> tracefunc -> obj
                (LOAD_CONST, op_arg),       # obj -> tracefunc -> obj -> attr
                (CALL_FUNCTION, 0x0002),    # obj -> retval
                (POP_TOP, None),            # obj
            ]
            inserts[idx] = code
        elif op == CALL_FUNCTION:
            # This computes the number of objects on the stack between
            # TOS and the object being called. Only the last 16bits of
            # the op_arg are signifcant. The lowest 8 are the number of
            # positional args on the stack, the upper 8 is the number of
            # kwargs. For kwargs, the number of items on the stack is
            # twice this number since the values on the stack alternate
            # name, value.
            n_stack_args = (op_arg & 0xFF) + 2 * ((op_arg >> 8) & 0xFF)
            code = [                                # func -> arg(0) -> arg(1) -> ... -> arg(n-1)
                (BUILD_TUPLE, n_stack_args),        # func -> argtuple
                (DUP_TOPX, 2),                      # func -> argtuple -> func -> argtuple
                (LOAD_FAST, '_[tracer]'),           # func -> argtuple -> func -> argtuple -> tracer
                (LOAD_ATTR, 'call_function'),       # func -> argtuple -> func -> argtuple -> tracefunc
                (ROT_THREE, None),                  # func -> argtuple -> tracefunc -> func -> argtuple
                (LOAD_CONST, op_arg),               # func -> argtuple -> tracefunc -> func -> argtuple -> argspec
                (CALL_FUNCTION, 0x0003),            # func -> argtuple -> retval
                (POP_TOP, None),                    # func -> argtuple
                (UNPACK_SEQUENCE, n_stack_args),    # func -> arg(n-1) -> arg(n-2) -> ... -> arg(0)
                (BUILD_TUPLE, n_stack_args),        # func -> reversedargtuple
                (UNPACK_SEQUENCE, n_stack_args),    # func -> arg(0) -> arg(1) -> ... -> arg(n-1)
            ]
            inserts[idx] = code
        elif op == BINARY_SUBSCR:
            code = [                            # obj -> idx
                (DUP_TOPX, 2),                  # obj -> idx -> obj -> idx
                (LOAD_FAST, '_[tracer]'),       # obj -> idx -> obj -> idx -> tracer
                (LOAD_ATTR, 'binary_subscr'),   # obj -> idx -> obj -> idx -> tracefunc
                (ROT_THREE, None),              # obj -> idx -> tracefunc -> obj -> idx
                (CALL_FUNCTION, 0x0002),        # obj -> idx -> retval
                (POP_TOP, None),                # obj -> idx
            ]
            inserts[idx] = code
        elif op == GET_ITER:
            code = [                        # obj
                (DUP_TOP, None),            # obj -> obj
                (LOAD_FAST, '_[tracer]'),   # obj -> obj -> tracer
                (LOAD_ATTR, 'get_iter'),    # obj -> obj -> tracefunc
                (ROT_TWO, None),            # obj -> tracefunc -> obj
                (CALL_FUNCTION, 0x0001),    # obj -> retval
                (POP_TOP, None),            # obj
            ]
            inserts[idx] = code

    # Create a new code list which interleaves the generated code with
    # the original code at the appropriate location.
    new_code = []
    for idx, code_op in enumerate(codelist):
        if idx in inserts:
            new_code.extend(inserts[idx])
        new_code.append(code_op)

    return new_code


def inject_inversion(codelist):
    """ Inject inversion code into the given code list.

    This will inject the bytecode operations required to invert the
    execution of the code using a `CodeInverter` object. The generated
    opcodes expect the fast local '_[inverter]' and '_[value]' to be
    available when the code is executed.

    Parameters
    ----------
    codelist : list
        The list of byteplay code ops to modify.

    Returns
    -------
    result : list
        A *new* list of code ops which implement the desired behavior.

    Raises
    ------
    ValueError
        The given code is not suitable for inversion.

    """
    opcode, oparg = codelist[-2]
    new_code = codelist[:-2]
    if opcode == LOAD_NAME and len(codelist) == 3:
        new_code.extend([                   #:
            (LOAD_FAST, '_[inverter]'),     #: inverter
            (LOAD_ATTR, 'load_name'),       #: invertfunc
            (LOAD_CONST, oparg),            #: invertfunc -> name
            (LOAD_FAST, '_[value]'),        #: invertfunc -> name - > value
            (CALL_FUNCTION, 0x0002),        #: retval
            (RETURN_VALUE, None),           #:
        ])
    elif opcode == LOAD_ATTR:
        new_code.extend([                   #: obj
            (LOAD_FAST, '_[inverter]'),     #: obj -> inverter
            (LOAD_ATTR, 'load_attr'),       #: obj -> invertfunc
            (ROT_TWO, None),                #: invertfunc -> obj
            (LOAD_CONST, oparg),            #: invertfunc -> obj -> attr
            (LOAD_FAST, '_[value]'),        #: invertfunc -> obj -> attr -> value
            (CALL_FUNCTION, 0x0003),        #: retval
            (RETURN_VALUE, None),           #:
        ])
    elif opcode == CALL_FUNCTION:
        n_stack_args = (oparg & 0xFF) + 2 * ((oparg >> 8) & 0xFF)
        new_code.extend([                   #: func -> arg(0) -> arg(1) -> ... -> arg(n-1)
            (BUILD_TUPLE, n_stack_args),    #: func -> argtuple
            (LOAD_FAST, '_[inverter]'),     #: func -> argtuple -> inverter
            (LOAD_ATTR, 'call_function'),   #: func -> argtuple -> invertfunc
            (ROT_THREE, None),              #: invertfunc -> func -> argtuple
            (LOAD_CONST, oparg),            #: invertfunc -> func -> argtuple -> argspec
            (LOAD_FAST, '_[value]'),        #: invertfunc -> func -> argtuple -> argspec -> value
            (CALL_FUNCTION, 0x0004),        #: retval
            (RETURN_VALUE, None),           #:
        ])
    elif opcode == BINARY_SUBSCR:
        new_code.extend([                   #: obj -> index
            (LOAD_FAST, '_[inverter]'),     #: obj -> index -> inverter
            (LOAD_ATTR, 'binary_subscr'),   #: obj -> index -> invertfunc
            (ROT_THREE, None),              #: invertfunc -> obj -> index
            (LOAD_FAST, '_[value]'),        #: invertfunc -> obj -> index -> value
            (CALL_FUNCTION, 0x0003),        #: retval
            (RETURN_VALUE, None),           #:
        ])
    else:
        raise ValueError("can't invert code")

    return new_code


########NEW FILE########
__FILENAME__ = compiler_helpers
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from .declarative import Declarative
from .enaml_def import EnamlDef


def _make_enamldef_helper_(name, base, description, f_globals):
    """ A compiler helper function for creating a new EnamlDef type.

    This function is called by the bytecode generated by the Enaml
    compiler when an enaml module is imported. It is used to make new
    types from the 'enamldef' keyword.

    This helper will raise an exception if the base type is of an
    incompatible type.

    Parameters
    ----------
    name : str
        The name to use when generating the new type.

    base : type
        The base class to use for the new type. This must be a subclass
        of Declarative.

    description : dict
        The description dictionay by the Enaml compiler. This dict will
        be used during instantiation to populate new instances with
        children and bound expressions.

    f_globals : dict
        The dictionary of globals for objects created by this class.

    Returns
    -------
    result : EnamlDef
        A new enamldef subclass of the given base class.

    """
    if not isinstance(base, type) or not issubclass(base, Declarative):
        msg = "can't derive enamldef from '%s'"
        raise TypeError(msg % base)
    dct = {
        '__module__': f_globals.get('__name__', ''),
        '__doc__': description.get('__doc__', ''),
    }
    decl_cls = EnamlDef(name, (base,), dct)
    decl_cls._descriptions += ((description, f_globals),)
    return decl_cls


########NEW FILE########
__FILENAME__ = conditional
#------------------------------------------------------------------------------
#  Copyright (c) 2013, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from traits.api import Bool, Tuple, Property

from .declarative import scope_lookup
from .templated import Templated


class Conditional(Templated):
    """ A templated object that represents conditional objects.

    When the `condition` attribute is True, the conditional will create
    its template items and insert them into its parent; when False, the
    old items will be destroyed.

    Creating a `Conditional` without a parent is a programming error.

    """
    #: The condition variable. If this is True, a copy of the children
    #: will be inserted into the parent. Otherwise, the old copies will
    #: be destroyed.
    condition = Bool(True)

    #: A read-only property which returns the tuple of items created
    #: by the conditional when `condition` is True.
    items = Property(fget=lambda self: self._items, depends_on='_items')

    #: Private internal storage for the `items` property.
    _items = Tuple

    #--------------------------------------------------------------------------
    # Lifetime API
    #--------------------------------------------------------------------------
    def post_initialize(self):
        """ A reimplemented initialization method.

        This method will create and initialize the conditional items
        using the children of the conditional as a template.

        """
        self._refresh_conditional_items()
        super(Conditional, self).post_initialize()

    def pre_destroy(self):
        """ A pre destroy handler.

        The conditional will destroy all of its items, provided that
        the items are not already destroyed and the parent is not in
        the process of being destroyed.

        """
        super(Conditional, self).pre_destroy()
        if len(self._items) > 0:
            parent = self.parent
            if not parent.is_destroying:
                with parent.children_event_context():
                    for item in self._items:
                        if not item.is_destroyed:
                            item.destroy()

    def post_destroy(self):
        """ A post destroy handler.

        The conditional will release all references to items after it
        has been destroyed.

        """
        super(Conditional, self).post_destroy()
        self._items = ()

    #--------------------------------------------------------------------------
    # Private API
    #--------------------------------------------------------------------------
    def _condition_changed(self, condition):
        """ A private change handler for the `condition` attribute.

        If the iterable changes while the looper is active, the items
        will be refreshed.

        """
        if self.is_active:
            self._refresh_conditional_items()

    def _refresh_conditional_items(self):
        """ A private method which refreshes the conditional items.

        This method destroys the old items and creates and initializes
        the new items.

        """
        items = []
        condition = self.condition
        templates = self._templates

        if condition and len(templates) > 0:
            # Each template is a 3-tuple of identifiers, globals, and
            # list of description dicts. There will only typically be
            # one template, but more can exist if the conditional was
            # subclassed via enamldef to provided default children.
            for identifiers, f_globals, descriptions in templates:
                # Each conditional gets a new scope derived from the
                # existing scope. This also allows the new children
                # to add their own independent identifiers. The items
                # are constructed with no parent since they are
                # parented via `insert_children` later on.
                scope = identifiers.copy()
                for descr in descriptions:
                    cls = scope_lookup(descr['type'], f_globals, descr)
                    instance = cls()
                    with instance.children_event_context():
                        instance.populate(descr, scope, f_globals)
                    items.append(instance)

        old_items = self._items
        self._items = items = tuple(items)
        if len(old_items) > 0 or len(items) > 0:
            with self.parent.children_event_context():
                if len(old_items) > 0:
                    for old in old_items:
                        if not old.is_destroyed:
                            old.destroy()
                if len(items) > 0:
                    self.parent.insert_children(self, items)
                    for item in items:
                        item.initialize()


########NEW FILE########
__FILENAME__ = declarative
#------------------------------------------------------------------------------
#  Copyright (c) 2013, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from types import FunctionType

from traits.api import (
    Any, Property, Disallow, ReadOnly, CTrait, Instance, Uninitialized,
)

from .dynamic_scope import DynamicAttributeError
from .exceptions import DeclarativeNameError, OperatorLookupError
from .object import Object
from .operator_context import OperatorContext
from .trait_types import EnamlInstance, EnamlEvent


#------------------------------------------------------------------------------
# UserAttribute and UserEvent
#------------------------------------------------------------------------------
class UserAttribute(EnamlInstance):
    """ An EnamlInstance subclass which implements the `attr` keyword.

    """
    def get(self, obj, name):
        """ The trait getter method.

        This returns the value from the object's dict, or raises an
        uninitialized error if the value doesn't exist.

        """
        dct = obj.__dict__
        if name not in dct:
            self.uninitialized_error(obj, name)
        return dct[name]

    def set(self, obj, name, value):
        """ The trait setter method.

        This sets the value in the object's dict if it is valid, and
        emits a change notification if the value has changed. The first
        time the value is set the change notification will carry None
        as the old value.

        """
        value = self.validate(obj, name, value)
        dct = obj.__dict__
        if name not in dct:
            old = None
        else:
            old = dct[name]
        dct[name] = value
        if old != value:
            obj.trait_property_changed(name, old, value)

    def uninitialized_error(self, obj, name):
        """ Raise a DynamicAttributeError for an object and attr name.

        """
        msg = "cannot access the uninitialized '%s' attribute of the %s object"
        raise DynamicAttributeError(msg % (name, obj))


class UserEvent(EnamlEvent):
    """ An EnamlEvent subclass which implements the `event` keyword.

    This subclass contains no additional logic. Its type is simply used
    to distinguish between events declared by the framework, and events
    declared by the user.

    """
    pass


#------------------------------------------------------------------------------
# Declarative Helpers
#------------------------------------------------------------------------------
def _compute_default(obj, name):
    """ Compute the default value for an expression.

    This is a private function used by Declarative for allowing default
    values of attributes to be provided by bound expression objects
    without requiring an explicit initialization graph.

    """
    try:
        return obj.eval_expression(name)
    except DynamicAttributeError:
        raise  # Reraise a propagating initialization error.
    except Exception:
        import traceback
        # XXX I'd rather not hack into Declarative's private api.
        expr = obj._expressions[name]
        filename = expr._func.func_code.co_filename
        lineno = expr._func.func_code.co_firstlineno
        args = (filename, lineno, traceback.format_exc())
        msg = ('Error initializing expression (%r line %s). Orignal '
               'exception was:\n%s')
        raise DynamicAttributeError(msg % args)


_quiet = set()
def _set_quiet(obj, name, value):
    """ Quietly set the named value on the object.

    This is a private function used by Declarative for allowing default
    values of attributes to be provided by bound expression objects
    without requiring an explicit initialization graph. This is a
    workaround for bug: https://github.com/enthought/traits/issues/26

    """
    q = _quiet
    owned = obj not in q
    if owned:
        obj._trait_change_notify(False)
        q.add(obj)
    setattr(obj, name, value)
    if owned:
        obj._trait_change_notify(True)
        q.discard(obj)


def _wired_getter(obj, name):
    """ The wired default expression getter.

    This is a private function used by Declarative for allowing default
    values of attributes to be provided by bound expression objects
    without requiring an explicit initialization graph.

    """
    itraits = obj._instance_traits()
    itraits[name] = itraits[name]._shadowed
    val = _compute_default(obj, name)
    if val is not NotImplemented:
        _set_quiet(obj, name, val)
    return getattr(obj, name, val)


def _wired_setter(obj, name, value):
    """ The wired default expression setter.

    This is a private function used by Declarative for allowing default
    values of attributes to be provided by bound expression objects
    without requiring an explicit initialization graph.

    """
    itraits = obj._instance_traits()
    itraits[name] = itraits[name]._shadowed
    setattr(obj, name, value)


def _wire_default(obj, name):
    """ Wire an expression trait for default value computation.

    This is a private function used by Declarative for allowing default
    values of attributes to be provided by bound expression objects
    without requiring an explicit initialization graph.

    """
    # This is a low-level performance hack that bypasses a mountain
    # of traits cruft and performs the minimum work required to make
    # traits do what we want. The speedup of this over `add_trait` is
    # substantial.
    # A new 'event' trait type (defaults are overridden)
    trait = CTrait(4)
    # Override defaults with 2-arg getter, 3-arg setter, no validator
    trait.property(_wired_getter, 2, _wired_setter, 3, None, 0)
    # Provide a handler else dynamic creation kills performance
    trait.handler = Any
    shadow = obj._trait(name, 2)
    trait._shadowed = shadow
    trait._notifiers = shadow._notifiers
    obj._instance_traits()[name] = trait


class ListenerNotifier(object):
    """ A lightweight trait change notifier used by Declarative.

    """
    def __call__(self, obj, name, old, new):
        """ Called by traits to dispatch the notifier.

        """
        if old is not Uninitialized:
            obj.run_listeners(name, old, new)

    def equals(self, other):
        """ Compares this notifier against another for equality.

        """
        return False

# Only a single instance of ListenerNotifier is needed.
ListenerNotifier = ListenerNotifier()


def scope_lookup(name, scope, description):
    """ A function which retrieves a name from a scope.

    If the lookup fails, a DeclarativeNameError is raised. This can
    be used to lookup names for a description dict from a global scope
    with decent error reporting when the lookup fails.

    Parameters
    ----------
    name : str
        The name to retreive from the scope.

    scope : mapping
        A mapping object.

    description : dict
        The description dictionary associated with the lookup.

    """
    try:
        item = scope[name]
    except KeyError:
        lineno = description['lineno']
        filename = description['filename']
        block = description['block']
        raise DeclarativeNameError(name, filename, lineno, block)
    return item


def setup_bindings(instance, bindings, identifiers, f_globals):
    """ Setup the expression bindings for a declarative instance.

    Parameters
    ----------
    instance : Declarative
        The declarative instance which owns the bindings.

    bindings : list
        A list of binding dicts created by the enaml compiler.

    identifiers : dict
        The identifiers scope to associate with the bindings.

    f_globals : dict
        The globals dict to associate with the bindings.

    """
    operators = instance.operators
    for binding in bindings:
        opname = binding['operator']
        try:
            operator = operators[opname]
        except KeyError:
            filename = binding['filename']
            lineno = binding['lineno']
            block = binding['block']
            raise OperatorLookupError(opname, filename, lineno, block)
        code = binding['code']
        # If the code is a tuple, it represents a delegation
        # expression which is a combination of subscription
        # and update functions.
        if isinstance(code, tuple):
            sub_code, upd_code = code
            func = FunctionType(sub_code, f_globals)
            func._update = FunctionType(upd_code, f_globals)
        else:
            func = FunctionType(code, f_globals)
        operator(instance, binding['name'], func, identifiers)


#------------------------------------------------------------------------------
# Declarative
#------------------------------------------------------------------------------
class Declarative(Object):
    """ The most base class of the Enaml declarative objects.

    This class provides the core functionality required of declarative
    Enaml types. It can be used directly in a declarative Enaml object
    tree to store and react to state changes. It has no concept of a
    visual representation; that functionality is added by subclasses.

    """
    #: A readonly property which returns the current instance of the
    #: component. This allows declarative Enaml expressions to access
    #: 'self' according to Enaml's dynamic scoping rules.
    self = Property(fget=lambda self: self)

    #: The operator context used to build out this instance. This is
    #: assigned during object instantiation. It should not be edited
    #: by user code.
    operators = ReadOnly

    #: The dictionary of bound expression objects. XXX These dicts are
    #: typically small and waste space. We need to switch to a more
    #: space efficient hash table at some point in the future. For
    #: pathological cases of large numbers of objects, the savings
    #: can be as high as 20% of the heap size.
    _expressions = Instance(dict, ())

    #: The dictionary of bound listener objects. XXX These dicts are
    #: typically small and waste space. We need to switch to a more
    #: space efficient hash table at some point in the future. For
    #: pathological cases of large numbers of objects, the savings
    #: can be as high as 20% of the heap size.
    _listeners = Instance(dict, ())

    def __init__(self, parent=None, **kwargs):
        """ Initialize a declarative component.

        Parameters
        ----------
        parent : Object or None, optional
            The Object instance which is the parent of this object, or
            None if the object has no parent. Defaults to None.

        **kwargs
            Additional keyword arguments needed for initialization.

        """
        super(Declarative, self).__init__(parent, **kwargs)
        self.operators = OperatorContext.active_context()

    #--------------------------------------------------------------------------
    # Declarative API
    #--------------------------------------------------------------------------
    def populate(self, description, identifiers, f_globals):
        """ Populate this declarative instance from a description.

        This method is called when the object was created from within
        a declarative context. In particular, there are two times when
        it may be called:

            - The first is when a type created from the `enamldef`
              keyword is instatiated; in this case, the method is
              invoked by the EnamlDef metaclass.

            - The second occurs when the object is instantiated by
              its parent from within its parent's `populate` method.

        In the first case, the description dict will contain the key
        `enamldef: True`, indicating that the object is being created
        from a "top-level" `enamldef` block.

        In the second case, the dict will have the key `enamldef: False`
        indicating that the object is being populated as a declarative
        child of some other parent.

        Subclasses may reimplement this method to gain custom control
        over how the children for its instances are created.

        *** This method may be called multiple times ***

        Consider the following sample:

        enamldef Foo(PushButton):
            text = 'bar'

        enamldef Bar(Foo):
            fgcolor = 'red'

        enamldef Main(Window):
            Container:
                Bar:
                    bgcolor = 'blue'

        The instance of `Bar` which is created as the `Container` child
        will have its `populate` method called three times: the first
        to populate the data from the `Foo` block, the second to populate
        the data from the `Bar` block, and the third to populate the
        data from the `Main` block.

        Parameters
        ----------
        description : dict
            The description dictionary for the instance.

        identifiers : dict
            The dictionary of identifiers to use for the bindings.

        f_globals : dict
            The dictionary of globals for the scope in which the object
            was declared.

        Notes
        -----
        The caller of this method should enter the child event context
        of the instance before invoking the method. This reduces the
        number of child events which are generated during startup.

        """
        ident = description['identifier']
        if ident:
            identifiers[ident] = self
        bindings = description['bindings']
        if len(bindings) > 0:
            setup_bindings(self, bindings, identifiers, f_globals)
        children = description['children']
        if len(children) > 0:
            for child in children:
                cls = scope_lookup(child['type'], f_globals, child)
                instance = cls(self)
                with instance.children_event_context():
                    instance.populate(child, identifiers, f_globals)

    #--------------------------------------------------------------------------
    # Private API
    #--------------------------------------------------------------------------
    @classmethod
    def _add_user_attribute(cls, name, attr_type, is_event):
        """ A private classmethod used by the Enaml compiler machinery.

        This method is used to add user attributes and events to custom
        derived enamldef classes. If the attribute already exists on the
        class and is not a user defined attribute, an exception will be
        raised. The only method of overriding standard trait attributes
        is through traditional subclassing.

        Parameters
        ----------
        name : str
            The name of the attribute to add to the class.

        attr_type : type
            The type of the attribute.

        is_event : bool
            True if the attribute should be a UserEvent, False if it
            should be a UserAttribute.

        """
        class_traits = cls.__class_traits__
        if name in class_traits:
            trait_type = class_traits[name].trait_type
            if trait_type is not Disallow:
                if not isinstance(trait_type, (UserAttribute, UserEvent)):
                    msg = ("can't add '%s' attribute. The '%s' attribute on "
                           "enamldef '%s.%s' already exists.")
                    items = (name, name, cls.__module__, cls.__name__)
                    raise TypeError(msg % items)

        trait_cls = UserEvent if is_event else UserAttribute
        try:
            user_trait = trait_cls(attr_type)
        except TypeError:
            msg = ("'%s' is not a valid type for the '%s' attribute "
                   "declaration on enamldef '%s.%s'")
            items = (attr_type, name, cls.__module__, cls.__name__)
            raise TypeError(msg % items)

        # XXX HasTraits.add_class_trait will raise an exception if the
        # the trait is already defined. There does not appear to be a
        # way to turn this off, nor does there appear to be a way to
        # formally remove a class trait. So, we just do what the traits
        # metaclass does when adding traits and directly add the ctrait
        # to the appropriate class dictionaries. The add_class_trait
        # classmethod does some extra work to make sure that the trait
        # is added to all subclasses, but that does not appear to be
        # needed in this case, since this method will only be called by
        # the compiler machinery for brand new subclasses.
        ctrait = user_trait.as_ctrait()
        class_traits[name] = ctrait
        cls.__base_traits__[name] = ctrait
        if '@' in cls.__prefix_traits__:
            anytrait_handler = cls.__prefix_traits__['@']
            ctrait._notifiers(1).append(anytrait_handler)

    #--------------------------------------------------------------------------
    # Public API
    #--------------------------------------------------------------------------
    def bind_expression(self, name, expression):
        """ Bind an expression to the given attribute name.

        This method can be called to bind a value-providing expression
        to the given attribute name. If the named attribute does not
        exist, an exception is raised.

        Parameters
        ----------
        name : string
            The name of the attribute on which to bind the expression.

        expression : AbstractExpression
            A concrete implementation of AbstractExpression. This value
            is not type checked for performance reasons. It is assumed
            that the caller provides a correct value.

        """
        curr = self._trait(name, 2)
        if curr is None or curr.trait_type is Disallow:
            msg = "Cannot bind expression. %s object has no attribute '%s'"
            raise AttributeError(msg % (self, name))
        dct = self._expressions
        if name not in dct:
            _wire_default(self, name)
        dct[name] = expression

    def bind_listener(self, name, listener):
        """ A private method used by the Enaml execution engine.

        This method is called by the Enaml operators to bind the given
        listener object to the given attribute name. If the attribute
        does not exist, an exception is raised. A strong reference to
        the listener object is kept internally.

        Parameters
        ----------
        name : string
            The name of the attribute on which to bind the listener.

        listener : AbstractListener
            A concrete implementation of AbstractListener. This value
            is not type checked for performance reasons. It is assumed
            that the caller provides a correct value.

        """
        curr = self._trait(name, 2)
        if curr is None or curr.trait_type is Disallow:
            msg = "Cannot bind listener. %s object has no attribute '%s'"
            raise AttributeError(msg % (self, name))
        dct = self._listeners
        if name not in dct:
            dct[name] = [listener]
            self.add_notifier(name, ListenerNotifier)
        else:
            dct[name].append(listener)

    def eval_expression(self, name):
        """ Evaluate a bound expression with the given name.

        Parameters
        ----------
        name : str
            The name of the attribute with the bound expression.

        Returns
        -------
        result : object or NotImplemented
            The result of evaluating the expression, or NotImplemented
            if there is no expression bound to the given name.

        """
        dct = self._expressions
        if name in dct:
            return dct[name].eval(self, name)
        return NotImplemented

    def refresh_expression(self, name):
        """ Refresh the value of a bound expression.

        Parameters
        ----------
        name : str
            The attribute name to which the invalid expression is bound.

        """
        value = self.eval_expression(name)
        if value is not NotImplemented:
            setattr(self, name, value)

    def run_listeners(self, name, old, new):
        """ Run the listeners bound to the given attribute name.

        Parameters
        ----------
        name : str
            The name of the attribute with the bound listeners.

        old : object
            The old value to pass to the listeners.

        new : object
            The new value to pass to the listeners.

        """
        dct = self._listeners
        if name in dct:
            for listener in dct[name]:
                listener.value_changed(self, name, old, new)


########NEW FILE########
__FILENAME__ = dynamic_scope
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from abc import ABCMeta, abstractmethod


#------------------------------------------------------------------------------
# Abstract Scope Listener
#------------------------------------------------------------------------------
class AbstractScopeListener(object):
    """ An abstract interface definition for scope listeners.

    A scope listener will be notified when an attribute is accessed via
    dynamic scoping.

    """
    __metaclass__ = ABCMeta

    @abstractmethod
    def dynamic_load(self, obj, name, value):
        """ Called after the scope dynamically loads an attribute.

        Parameters
        ----------
        obj : object
            The object which owns the attribute.

        name : str
            The name of the attribute loaded.

        value : object
            The value of the loaded attribute.

        """
        raise NotImplementedError


#------------------------------------------------------------------------------
# Dynamic Scope
#------------------------------------------------------------------------------
class DynamicAttributeError(AttributeError):
    """ A custom Attribute error for use with dynamic scoping.

    DynamicScope operates by catching AttributeError and converting it
    into a key error. This DynamicAttributeError can be raised by user
    code in order to escape the trapping and bubble up.

    """
    pass


class DynamicScope(object):
    """ A custom mapping object that implements Enaml's dynamic scope.

    The __getitem__ method of this object is called when LOAD_NAME
    opcode is encountered in a code object which has been transformed
    by the Enaml compiler chain.

    Notes
    -----
    Strong references are kept to all objects passed to the constructor,
    so these scope objects should be created as needed and discarded in
    order to avoid unnecessary reference cycles.

    """
    def __init__(self, obj, identifiers, overrides, listener):
        """ Initialize a DynamicScope.

        Parameters
        ----------
        obj : Declarative
            The Declarative object which owns the executing code.

        identifiers : dict
            The identifiers available to the executing code.

        overrides : dict
            A dict of objects which should have higher precedence than
            the identifiers.

        listener : DynamicScopeListener or None
            A listener which should be notified when a name is loaded
            via dynamic scoping.

        """
        self._obj = obj
        self._identifiers = identifiers
        self._overrides = overrides
        self._listener = listener

    def __getitem__(self, name):
        """ Lookup and return an item from the scope.

        Parameters
        ----------
        name : str
            The name of the item to retrieve from the scope.

        Raises
        ------
        KeyError
            The named item is not contained in the scope.

        """
        dct = self._overrides
        if name in dct:
            return dct[name]
        dct = self._identifiers
        if name in dct:
            return dct[name]
        parent = self._obj
        while parent is not None:
            try:
                value = getattr(parent, name)
            except DynamicAttributeError:
                raise
            except AttributeError:
                parent = parent.parent
            else:
                listener = self._listener
                if listener is not None:
                    listener.dynamic_load(parent, name, value)
                return value
        raise KeyError(name)

    def __setitem__(self, name, value):
        """ Set an item in the scope.

        Parameters
        ----------
        name : str
            The name of the item to set in the scope.

        value : object
            The object to set in the scope.

        """
        # This method is required for pdb to function properly.
        self._overrides[name] = value

    def __contains__(self, name):
        """ Returns True if the name is in scope, False otherwise.

        """
        # This method is required for pdb to function properly.
        if isinstance(name, basestring):
            # Temporarily disable the listener during scope testing.
            listener = self._listener
            self._listener = None
            try:
                self.__getitem__(name)
            except KeyError:
                res = False
            else:
                res = True
            finally:
                self._listener = listener
        else:
            res = False
        return res


#------------------------------------------------------------------------------
# Nonlocals
#------------------------------------------------------------------------------
class Nonlocals(object):
    """ An object which implements userland dynamic scoping.

    An instance of this object is made available with the `nonlocals`
    magic name in the scope of an expression.

    """
    def __init__(self, obj, listener):
        """ Initialize a nonlocal scope.

        Parameters
        ----------
        obj : Declarative
            The Declarative object which owns the executing code.

        listener : DynamicScopeListener or None
            A listener which should be notified when a name is loaded
            via dynamic scoping.

        """
        self._nls_obj = obj
        self._nls_listener = listener

    def __repr__(self):
        """ A pretty representation of the NonlocalScope.

        """
        return 'Nonlocals[%s]' % self._obj

    def __call__(self, level=0):
        """ Get a new nonlocals object for the given offset.

        Parameters
        ----------
        level : int, optional
            The number of levels up the tree to offset. The default is
            zero and indicates no offset. The level must be >= 0.

        """
        if not isinstance(level, int) or level < 0:
            msg = ('The nonlocal scope level must be an int >= 0. '
                   'Got %r instead.')
            raise ValueError(msg % level)
        offset = 0
        target = self._nls_obj
        while target is not None and offset != level:
            target = target.parent
            offset += 1
        if offset != level:
            msg = 'Scope level %s is out of range'
            raise ValueError(msg % level)
        return Nonlocals(target, self._nls_listener)

    def __getattr__(self, name):
        """ A convenience method which allows accessing items in the
        scope via getattr instead of getitem.

        """
        try:
            return self.__getitem__(name)
        except KeyError:
            msg = "%s has no attribute '%s'" % (self, name)
            raise AttributeError(msg)

    def __setattr__(self, name, value):
        """ A convenience method which allows setting items in the
        scope via setattr instead of setitem.

        """
        if name in ('_nls_obj', '_nls_listener'):
            super(Nonlocals, self).__setattr__(name, value)
        else:
            try:
                self.__setitem__(name, value)
            except KeyError:
                msg = "%s has no attribute '%s'" % (self, name)
                raise AttributeError(msg)

    def __getitem__(self, name):
        """ Lookup and return an item from the nonlocals.

        Parameters
        ----------
        name : str
            The name of the item to retrieve from the nonlocals.

        Raises
        ------
        KeyError
            The named item is not contained in the nonlocals.

        """
        parent = self._nls_obj
        while parent is not None:
            try:
                value = getattr(parent, name)
            except DynamicAttributeError:
                raise
            except AttributeError:
                parent = parent.parent
            else:
                listener = self._nls_listener
                if listener is not None:
                    listener.dynamic_load(parent, name, value)
                return value
        raise KeyError(name)

    def __setitem__(self, name, value):
        """ Sets the value of the nonlocal.

        Parameters
        ----------
        name : str
            The name of the item to set in the nonlocals.

        value : object
            The value to set in the nonlocals.

        Raises
        ------
        KeyError
            The named item is not contained in the nonlocals.

        """
        parent = self._nls_obj
        while parent is not None:
            # It's not sufficient to try to do setattr(...) here and
            # catch the AttributeError, because HasStrictTraits raises
            # a TraitError in these cases and it becomes impossible
            # to distinguish that error from a trait typing error
            # without checking the message of the exception.
            try:
                getattr(parent, name)
            except DynamicAttributeError:
                pass # ignore uninitialized attribute errors
            except AttributeError:
                parent = parent.parent
                continue
            setattr(parent, name, value)
            return
        raise KeyError(name)

    def __contains__(self, name):
        """ True if the name is in the nonlocals, False otherwise.

        """
        if isinstance(name, basestring):
            # Temporarily disable the listener during scope testing.
            listener = self._nls_listener
            self._nls_listener = None
            try:
                self.__getitem__(name)
            except KeyError:
                res = False
            else:
                res = True
            finally:
                self._nls_listener = listener
        else:
            res = False
        return res


########NEW FILE########
__FILENAME__ = enaml_ast
#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
class ASTNode(object):
    """ The base Enaml AST node.

    Attributes
    ----------
    lineno : int
        The line number in the source code that created this node.

    """
    def __init__(self, lineno):
        self.lineno = lineno

    def __repr__(self):
        return self.__class__.__name__

    def __str__(self):
        return repr(self)


class Module(ASTNode):
    """ An AST node representing an Enaml module.

    Attributes
    ----------
    doc : str
        The module's documentation string.

    body : list
        A list of ast nodes comprising the body of the module.

    """
    def __init__(self, body, lineno):
        super(Module, self).__init__(lineno)
        self.body = body


class Python(ASTNode):
    """ An AST node representing a chunk of pure Python code.

    Attributes
    ----------
    py_ast : ast.AST
        A Python ast node.

    """
    def __init__(self, py_ast, lineno):
        super(Python, self).__init__(lineno)
        self.py_ast = py_ast


class Declaration(ASTNode):
    """ An AST node representing an Enaml declaration.

    Attributes
    ----------
    name : str
        The name of the declaration.

    base : str
        The name of the base type.

    identifier : str
        The local identifier to use for instances of the declaration.

    doc : str
        The documentation string for the declaration.

    body : list
        A list of AST nodes that comprise the body of the declaration.

    """
    def __init__(self, name, base, identifier, doc, body, lineno):
        super(Declaration, self).__init__(lineno)
        self.name = name
        self.base = base
        self.identifier = identifier
        self.doc = doc
        self.body = body


class Instantiation(ASTNode):
    """ An AST node representing a declaration instantiation.

    Attributes
    ----------
    name : str
        The name of declaration being instantiated.

    identifier : str
        The local identifier to use for the new instance.

    body : list
        A list of AST nodes which comprise the instantiation body.

    """
    def __init__(self, name, identifier, body, lineno):
        super(Instantiation, self).__init__(lineno)
        self.name = name
        self.identifier = identifier
        self.body = body


class AttributeDeclaration(ASTNode):
    """ An AST node which represents an attribute declaration.

    Attributes
    ----------
    name : str
        The name of the attribute being declared.

    type : str
        A string representing the type of the attribute, or None if no
        type was given. If None the attribute can be of any type.

    default : AttributeBinding or None
        The default binding of the attribute, or None if no default
        is provided.

    is_event : boolean
        Whether or not this declaration represents an event.
        i.e. was declared with 'event' instead of 'attr'.

    """
    def __init__(self, name, type, default, is_event, lineno):
        super(AttributeDeclaration, self).__init__(lineno)
        self.name = name
        self.type = type
        self.default = default
        self.is_event = is_event


class AttributeBinding(ASTNode):
    """ An AST node which represents an expression attribute binding.

    Attributes
    ----------
    name : str
        The name of the attribute being bound.

    binding : BoundExpression
        The BoundExpression ast node which represents the binding.

    """
    def __init__(self, name, binding, lineno):
        super(AttributeBinding, self).__init__(lineno)
        self.name = name
        self.binding = binding


class BoundExpression(ASTNode):
    """ An ast node which represents a bound expression.

    Attributes
    ----------
    op : str
        The name of the operator that will perform the binding.

    expr : Python
        A Python ast node that reprents the bound expression.

    """
    def __init__(self, op, expr, lineno):
        super(BoundExpression, self).__init__(lineno)
        self.op = op
        self.expr = expr


########NEW FILE########
__FILENAME__ = enaml_compiler
#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
import ast
import sys
import types

from .byteplay import (
    Code, LOAD_FAST, CALL_FUNCTION, LOAD_GLOBAL, STORE_FAST, LOAD_CONST,
    LOAD_ATTR, RETURN_VALUE, POP_TOP, STORE_NAME, LOAD_NAME, DUP_TOP,
    DELETE_NAME, DELETE_FAST, SetLineno
)
from .code_tracing import inject_tracing, inject_inversion


# Increment this number whenever the compiler changes the code which it
# generates. This number is used by the import hooks to know which version
# of a .enamlc file is valid for the Enaml compiler version in use. If
# this number is not incremented on change, it may result in .enamlc
# files which fail on import.
#
# Version History
# ---------------
# 1 : Initial compiler version - 2 February 2012
# 2 : Update line number handling - 26 March 2012
#     When compiling code objects with mode='eval', Python ignores the
#     line number specified by the ast. The workaround is to compile the
#     code object, then make a new copy of it with the proper firstlineno
#     set via the types.CodeType constructor.
# 3 : Update the generated code to remove the toolkit - 21 June 2012
#     This updates the compiler for the coming switch to async UI's
#     which will see the removal of the Toolkit concept. The only
#     magic scope maintained is for that of operators.
# 4 : Update component building - 27 July 2012
#     This updates the compiler to handle the new Enaml creation semantics
#     that don't rely on __enaml_call__. Instead the parent is passed
#     directly to the component cls which is a subclass of Declarative.
#     That class handles calling the builder functions upon instance
#     creation. This allows us to get rid of the EnamlDef class and
#     make enamldef constructs proper subclasses of Declarative.
# 5 : Change the import names - 28 July 2012
#     This changes the imported helper name from _make_decl_subclass_
#     to _make_enamldef_helper_ which is more descriptive, but equally
#     mangled. It also updates the method name used on the Declarative
#     component for adding attribute from _add_decl_attr to the more
#     descriptive _add_user_attribute. Finally, it adds the eval_compile
#     function for compiling Python code in 'eval' mode with proper line
#     number handling.
# 6 : Compile with code tracing - 24 November 2012
#     This updates the compiler to generate code using the idea of code
#     tracing instead of monitors and inverters. The compiler compiles
#     the expressions into functions which are augmented to accept
#     additional arguments. These arguments are tracer objects which will
#     have methods called in response to bytecode ops executing. These
#     methods can then attach listeners as necessary. This is an easier
#     paradigm to develop with than the previous incarnation. This new
#     way also allows the compiler to generate the final code objects
#     upfront, instead of needed to specialize at runtime for a given
#     operator context. This results in a much smaller footprint since
#     then number of code objects created is n instead of n x m.
# 7 : Fix bug with local deletes - 10 December 2012
#     This fixes a bug in the locals optimization where the DELETE_NAME
#     opcode was not being replaced with DELETE_FAST.
# 8 : Generate description dicts instead of builders - 27 January 2013
#     This updates the compiler to generate marshalable description
#     dicts instead of builder functions. The responsibility of building
#     out the object tree has been shifted to the Declarative class. This
#     is a touch slower, but provides a ton more flexibility and enables
#     templated components like `Looper` and `Conditional`.
COMPILER_VERSION = 8


# The Enaml compiler translates an Enaml AST into a decription dict
# which contains information about the tree, including code objects
# which were compiled with support for runtime introspection. The
# reason dictionaries are used instead of the AST nodes is because
# the dictionaries can be marshaled into a .enamlc file, which is
# faster on subsequent loading than reparsing the entire file.
#
#
# Given this sample declaration in Enaml::
#
# FooWindow(Window): foo:
#     attr a = '12'
#     PushButton: btn:
#         text = 'clickme'
#
# The compiler generates a new class called FooWindow which uses Window
# as the base class. The new class is given the following description
# dictionary to use when populating new instances. The block and filename
# information is repeated for each logical production because it makes
# easier for runtime code to generate useful exceptions without needed
# to pass the entire parse tree around at every step. The code objects
# in the binding dictionaries have had their bytecode rewritten to
# support Enaml's runtime introspection facilities.
#
# description = {
#     'enamldef': True,
#     'type': 'FooWindow',
#     'base': 'Window',
#     'doc': '',
#     'lineno': 1,
#     'identifier': 'foo',
#     'filename': 'sample.enaml',
#     'block': 'FooWindow',
#     'children': [
#         { 'enamldef': False,
#           'type': 'PushButton',
#           'lineno': 3,
#           'identifier': 'btn',
#           'filename': 'sample.enaml',
#           'block': 'FooWindow',
#           'children': [],
#           'bindings': [
#               { 'operator': '__operator_Equal__',
#                 'code': <codeobject>,
#                 'name': 'text',
#                 'lineno': 4,
#                 'filename': 'sample.enaml',
#                 'block': 'FooWindow',
#               },
#           ],
#         },
#     ],
#     'bindings': [
#         { 'operator': '__operator_Equal__',
#           'code': <codeobject>,
#           'name': 'a',
#           'lineno': 2,
#           'filename': 'sample.enaml',
#           'block': 'FooWindow',
#         },
#     ],
# }


#------------------------------------------------------------------------------
# Compiler Helpers
#------------------------------------------------------------------------------
# Code that will be executed at the top of every enaml module
STARTUP = ['from enaml.core.compiler_helpers import _make_enamldef_helper_']


# Cleanup code that will be included in every compiled enaml module
CLEANUP = ['del _make_enamldef_helper_']


def update_firstlineno(code, firstlineno):
    """ Returns a new code object with an updated first line number.

    """
    return types.CodeType(
        code.co_argcount, code.co_nlocals, code.co_stacksize, code.co_flags,
        code.co_code, code.co_consts, code.co_names, code.co_varnames,
        code.co_filename, code.co_name, firstlineno, code.co_lnotab,
        code.co_freevars, code.co_cellvars,
    )


#------------------------------------------------------------------------------
# Expression Compilers
#------------------------------------------------------------------------------
def replace_global_loads(codelist, explicit=None):
    """ A code transformer which rewrites LOAD_GLOBAL opcodes.

    This transform will replace the LOAD_GLOBAL opcodes with LOAD_NAME
    opcodes. The operation is performed in-place.

    Parameters
    ----------
    codelist : list
        The list of byteplay code ops to modify.

    explicit : set or None
        The set of global names declared explicitly and which should
        remain untransformed.

    """
    # Replacing LOAD_GLOBAL with LOAD_NAME enables dynamic scoping by
    # way of a custom locals mapping. The `call_func` function in the
    # `funchelper` module enables passing a locals map to a function.
    explicit = explicit or set()
    for idx, (op, op_arg) in enumerate(codelist):
        if op == LOAD_GLOBAL and op_arg not in explicit:
            codelist[idx] = (LOAD_NAME, op_arg)


def optimize_locals(codelist):
    """ Optimize the given code object for fast locals access.

    All STORE_NAME opcodes will be replaced with STORE_FAST. Names which
    are stored and then loaded via LOAD_NAME are rewritten to LOAD_FAST
    and DELETE_NAME is rewritten to DELETE_FAST. This transformation is
    applied in-place.

    Parameters
    ----------
    codelist : list
        The list of byteplay code ops to modify.

    """
    fast_locals = set()
    for idx, (op, op_arg) in enumerate(codelist):
        if op == STORE_NAME:
            fast_locals.add(op_arg)
            codelist[idx] = (STORE_FAST, op_arg)
    for idx, (op, op_arg) in enumerate(codelist):
        if op == LOAD_NAME and op_arg in fast_locals:
            codelist[idx] = (LOAD_FAST, op_arg)
        elif op == DELETE_NAME and op_arg in fast_locals:
            codelist[idx] = (DELETE_FAST, op_arg)


def compile_simple(py_ast, filename):
    """ Compile an ast into a code object implementing operator `=`.

    Parameters
    ----------
    py_ast : ast.Expression
        A Python ast Expression node.

    filename : str
        The filename which generated the expression.

    Returns
    -------
    result : types.CodeType
        A Python code object which implements the desired behavior.

    """
    code = compile(py_ast, filename, mode='eval')
    code = update_firstlineno(code, py_ast.lineno)
    bp_code = Code.from_code(code)
    replace_global_loads(bp_code.code)
    optimize_locals(bp_code.code)
    bp_code.newlocals = False
    return bp_code.to_code()


def compile_notify(py_ast, filename):
    """ Compile an ast into a code object implementing operator `::`.

    Parameters
    ----------
    py_ast : ast.Module
        A Python ast Module node.

    filename : str
        The filename which generated the expression.

    Returns
    -------
    result : types.CodeType
        A Python code object which implements the desired behavior.

    """
    explicit_globals = set()
    for node in ast.walk(py_ast):
        if isinstance(node, ast.Global):
            explicit_globals.update(node.names)
    code = compile(py_ast, filename, mode='exec')
    bp_code = Code.from_code(code)
    replace_global_loads(bp_code.code, explicit_globals)
    optimize_locals(bp_code.code)
    bp_code.newlocals = False
    return bp_code.to_code()


def compile_subscribe(py_ast, filename):
    """ Compile an ast into a code object implementing operator `<<`.

    Parameters
    ----------
    py_ast : ast.Expression
        A Python ast Expression node.

    filename : str
        The filename which generated the expression.

    Returns
    -------
    result : types.CodeType
        A Python code object which implements the desired behavior.

    """
    code = compile(py_ast, filename, mode='eval')
    code = update_firstlineno(code, py_ast.lineno)
    bp_code = Code.from_code(code)
    replace_global_loads(bp_code.code)
    optimize_locals(bp_code.code)
    bp_code.code = inject_tracing(bp_code.code)
    bp_code.newlocals = False
    bp_code.args = ('_[tracer]',) + bp_code.args
    return bp_code.to_code()


def compile_update(py_ast, filename):
    """ Compile an ast into a code object implementing operator `>>`.

    Parameters
    ----------
    py_ast : ast.Expression
        A Python ast Expression node.

    filename : str
        The filename which generated the expression.

    Returns
    -------
    result : types.CodeType
        A Python code object which implements the desired behavior.

    """
    code = compile(py_ast, filename, mode='eval')
    code = update_firstlineno(code, py_ast.lineno)
    bp_code = Code.from_code(code)
    replace_global_loads(bp_code.code)
    optimize_locals(bp_code.code)
    bp_code.code = inject_inversion(bp_code.code)
    bp_code.newlocals = False
    bp_code.args = ('_[inverter]', '_[value]') + bp_code.args
    return bp_code.to_code()


def compile_delegate(py_ast, filename):
    """ Compile an ast into a code object implementing operator `:=`.

    This will generate two code objects: one which is equivalent to
    operator `<<` and another which is equivalent to `>>`.

    Parameters
    ----------
    py_ast : ast.Expression
        A Python ast Expression node.

    filename : str
        The filename which generated the expression.

    Returns
    -------
    result : tuple
        A 2-tuple of types.CodeType equivalent to operators `<<` and
        `>>` respectively.

    """
    code = compile(py_ast, filename, mode='eval')
    code = update_firstlineno(code, py_ast.lineno)
    bp_code = Code.from_code(code)
    bp_code.newlocals = False
    codelist = bp_code.code[:]
    bp_args = tuple(bp_code.args)
    replace_global_loads(codelist)
    optimize_locals(codelist)
    sub_list = inject_tracing(codelist)
    bp_code.code = sub_list
    bp_code.args = ('_[tracer]',) + bp_args
    sub_code = bp_code.to_code()
    upd_list = inject_inversion(codelist)
    bp_code.code = upd_list
    bp_code.args = ('_[inverter]', '_[value]') + bp_args
    upd_code = bp_code.to_code()
    return (sub_code, upd_code)


COMPILE_OP_MAP = {
    '__operator_Equal__': compile_simple,
    '__operator_ColonColon__': compile_notify,
    '__operator_LessLess__': compile_subscribe,
    '__operator_GreaterGreater__': compile_update,
    '__operator_ColonEqual__': compile_delegate,
}


#------------------------------------------------------------------------------
# Node Visitor
#------------------------------------------------------------------------------
class _NodeVisitor(object):
    """ A node visitor class that is used as base class for the various
    Enaml compilers.

    """
    def visit(self, node):
        """ The main visitor dispatch method.

        Unhandled nodes will raise an error.

        """
        name = 'visit_%s' % node.__class__.__name__
        try:
            method = getattr(self, name)
        except AttributeError:
            method = self.default_visit
        method(node)

    def visit_nonstrict(self, node):
        """ A nonstrict visitor dispatch method.

        Unhandled nodes will be ignored.

        """
        name = 'visit_%s' % node.__class__.__name__
        try:
            method = getattr(self, name)
        except AttributeError:
            pass
        else:
            method(node)

    def default_visit(self, node):
        """ The default visitor method. Raises an error since there
        should not be any unhandled nodes.

        """
        raise ValueError('Unhandled Node %s.' % node)


#------------------------------------------------------------------------------
# Declaration Compiler
#------------------------------------------------------------------------------
class DeclarationCompiler(_NodeVisitor):
    """ A visitor which compiles a Declaration node into a code object.

    """
    @classmethod
    def compile(cls, node, filename):
        """ The main entry point of the DeclarationCompiler.

        This compiler compiles the given Declaration node into a
        description dictionary which can be used to build out the
        component tree at run time.

        Top assist with debugging, every production generated by the
        compiler has the filename, lineno, and block from where it was
        generated.

        Parameters
        ----------
        node : Declaration
            The Declaration node to compiler.

        filename : str
            The string filename to use for the description.

        """
        compiler = cls(filename)
        compiler.visit(node)
        return compiler.stack.pop()

    def __init__(self, filename):
        """ Initialize a DeclarationCompiler.

        Parameters
        ----------
        filename : str
            The filename string to use for the descriptions.

        """
        self.filename = filename
        self.block = '<undefined>'
        self.stack = []

    def visit_Declaration(self, node):
        """ Creates the description dict for a declaration.

        This method will create the root description dict, push it onto
        the stack, then dispatch to the node's body nodes.

        """
        self.block = node.name
        obj = {
            'enamldef': True,
            'type': node.name,
            'base': node.base,
            'doc': node.doc,
            'lineno': node.lineno,
            'identifier': node.identifier,
            'filename': self.filename,
            'block': self.block,
            'children': [],
            'bindings': [],
        }
        self.stack.append(obj)
        for item in node.body:
            self.visit(item)

    def visit_AttributeDeclaration(self, node):
        """ Add an attribute declaration to the description.

        The attributes will have already been added to the subclass, so
        this visitor just dispatches to any default bindings which may
        exist on the attribute declaration, since the binding happens
        at instantiation time via operators.

        """
        default = node.default
        if default is not None:
            self.visit(node.default)

    def visit_AttributeBinding(self, node):
        """ Add an attribute binding to the description.

        This visitor creates the binding dict for the given node and
        adds it to the bindings list for the object at the top of the
        stack. It compiles the python ast for the bound expression into
        a code object that has been hooked for the given operator.

        """
        obj = self.stack[-1]
        py_ast = node.binding.expr.py_ast
        op = node.binding.op
        op_compiler = COMPILE_OP_MAP[op]
        code = op_compiler(py_ast, self.filename)
        binding = {
            'operator': op,
            'code': code,
            'name': node.name,
            'lineno': node.binding.lineno,
            'filename': self.filename,
            'block': self.block,
        }
        obj['bindings'].append(binding)

    def visit_Instantiation(self, node):
        """ Create the description for an instantiation.

        This visitor creates a new dictionary for the object, pushes
        it onto the stack, dispatches to the body nodes, then pops
        the item and adds it to the children of the object at the top
        of the stack.

        """
        obj = {
            'enamldef': False,
            'type': node.name,
            'lineno': node.lineno,
            'identifier': node.identifier,
            'filename': self.filename,
            'block': self.block,
            'children': [],
            'bindings': [],
        }
        self.stack.append(obj)
        for item in node.body:
            self.visit(item)
        self.stack.pop()
        self.stack[-1]['children'].append(obj)


#------------------------------------------------------------------------------
# Enaml Compiler
#------------------------------------------------------------------------------
class EnamlCompiler(_NodeVisitor):
    """ A visitor that will compile an enaml module ast node.

    The entry point is the `compile` classmethod which will compile
    the ast into an appropriate python code object for a module.

    """
    @classmethod
    def compile(cls, module_ast, filename):
        """ The main entry point of the compiler.

        Parameters
        ----------
        module_ast : Instance(enaml_ast.Module)
            The enaml module ast node that should be compiled.

        filename : str
            The string filename of the module ast being compiled.

        """

        # Protect against unicode filenames, which are incompatible
        # with code objects created via types.CodeType
        if isinstance(filename, unicode):
            filename = filename.encode(sys.getfilesystemencoding())

        # Generate the startup code for the module
        module_ops = [(SetLineno, 1)]
        for start in STARTUP:
            start_code = compile(start, filename, mode='exec')
            bp_code = Code.from_code(start_code)
            # Skip the SetLineo and ReturnValue codes
            module_ops.extend(bp_code.code[1:-2])

        # Add in the code ops for the module
        compiler = cls(filename)
        compiler.visit(module_ast)
        module_ops.extend(compiler.code_ops)

        # Generate the cleanup code for the module
        for end in CLEANUP:
            end_code = compile(end, filename, mode='exec')
            bp_code = Code.from_code(end_code)
            # Skip the SetLineo and ReturnValue codes
            module_ops.extend(bp_code.code[1:-2])

        # Add in the final return value ops
        module_ops.extend([
            (LOAD_CONST, None),
            (RETURN_VALUE, None),
        ])

        # Generate and return the module code object.
        mod_code = Code(
            module_ops, [], [], False, False, False, '',  filename, 0, '',
        )
        return mod_code.to_code()

    def __init__(self, filename):
        """ Initialize an EnamlCompiler.

        Parameters
        ----------
        filename : str
            The string filename of the module ast being compiled.

        """
        self.filename = filename
        self.code_ops = []

    def visit_Module(self, node):
        """ The Module node visitor method.

        This visitor dispatches to all of the body nodes of the module.

        """
        for item in node.body:
            self.visit(item)

    def visit_Python(self, node):
        """ The Python node visitor method.

        This visitor adds a chunk of raw Python into the module.

        """
        py_code = compile(node.py_ast, self.filename, mode='exec')
        bp_code = Code.from_code(py_code)
        # Skip the SetLineo and ReturnValue codes
        self.code_ops.extend(bp_code.code[1:-2])

    def visit_Declaration(self, node):
        """ The Declaration node visitor.

        This generates the bytecode ops whic create a new type for the
        enamldef and then adds the user defined attributes and events.
        It also dispatches to the DeclarationCompiler which will create
        the builder function for the new type.

        """
        code_ops = self.code_ops
        name = node.name
        description = DeclarationCompiler.compile(node, self.filename)
        code_ops.extend([
            (SetLineno, node.lineno),
            (LOAD_NAME, '_make_enamldef_helper_'),  # Foo = _make_enamldef_helper_(name, base, description, globals)
            (LOAD_CONST, name),
            (LOAD_NAME, node.base),
            (LOAD_CONST, description),  # description is a marshalable dict
            (LOAD_NAME, 'globals'),
            (CALL_FUNCTION, 0x0000),
            (CALL_FUNCTION, 0x0004),
            (STORE_NAME, name),
        ])

        # We now have a new Declarative subclass stored at 'name' to
        # which we need to add any user defined attributes and events.
        code_ops.extend([
            (LOAD_NAME, name),
            (LOAD_ATTR, '_add_user_attribute'),
        ])

        # Dispatch to add any class-level info contained within the
        # declaration body. Visit nonstrict since not all child nodes
        # are valid at the class-level. The '_add_user_attribute'
        # class method is left on the top of the stack and popped
        # at the end of the visitors.
        for child_node in node.body:
            self.visit_nonstrict(child_node)

        code_ops.append((POP_TOP, None))

    def visit_AttributeDeclaration(self, node):
        """ Creates the bytecode ops for an attribute declaration.

        This will add the ops to add the user attrs and events to
        the new type.

        """
        attr_type = node.type or 'object'
        self.code_ops.extend([
            (SetLineno, node.lineno),
            (DUP_TOP, None),                # cls._add_user_attribute(name, type, is_event)
            (LOAD_CONST, node.name),
            (LOAD_NAME, attr_type),
            (LOAD_CONST, node.is_event),
            (CALL_FUNCTION, 0x0003),
            (POP_TOP, None),
        ])


########NEW FILE########
__FILENAME__ = enaml_def
#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from traits.api import MetaHasTraits


class EnamlDef(MetaHasTraits):
    """ The type of an enamldef.

    This is a metaclass used to create types for the 'enamldef' keyword.
    The metaclass assists with instantiating instances of these types
    and ensure they are properly populated using the description dicts
    created by the enaml compiler.

    """
    # Seed the class hierarchy with an empty descriptions tuple. The
    # compiler helper will add to this tuple when a new subclass is
    # created. The content will be 2-tuples of (description, globals)
    # which are the description dicts and the global scope for that
    # dict created by the enaml compiler.
    _descriptions = ()

    def __repr__(cls):
        """ A nice repr for a type created by the `enamldef` keyword.

        """
        return "<enamldef '%s.%s'>" % (cls.__module__, cls.__name__)

    def __call__(cls, parent=None, **kwargs):
        """ Create a new instance of a declarative type.

        This method ensures that the new instance is populated with the
        description dicts created by the enaml compiler. It also delays
        the application of any given keyword arguments until after the
        instance is fully populated.

        Parameters
        ----------
        parent : Declarative, optional
            The parent of the instance being created.

        **kwargs
            Additional keyword arguments to apply to the instance.

        Returns
        -------
        result : Declarative
            A new declarative instance for the given class.

        """
        # The only code that should be using this metaclass to create
        # classes is the compiler helper `_make_enamldef_helper_`. It
        # is therefore safe to assume `cls` is a Declarative subclass
        # and the new instances will behave appropriately.
        self = cls.__new__(cls)
        ob_type = type(self)
        if not issubclass(ob_type, cls):
            return self
        ob_type.__init__(self, parent=parent)
        descriptions = ob_type._descriptions
        if len(descriptions) > 0:
            with self.children_event_context():
                # Each description is an independent `enamldef` block
                # which gets its own independent identifiers scope.
                for description, f_globals in descriptions:
                    identifiers = {}
                    self.populate(description, identifiers, f_globals)
        if len(kwargs) > 0:
            for key, value in kwargs.iteritems():
                setattr(self, key, value)
        return self


########NEW FILE########
__FILENAME__ = exceptions
#------------------------------------------------------------------------------
#  Copyright (c) 2013, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
def _format_source_error(filename, lineno, block):
    """ A helper function which generates an error string.

    This function handles the work of reading the lines of the file
    which bracket the error, and formatting a string which points to
    the offending line. The output is similar to:

    File "foo.py", line 42, in bar()
           41 def bar():
    ---->  42     a = a + 1
           43     return a

    Parameters
    ----------
    filename : str
        The full path to the offending file.

    lineno : int
        The line number of the offending like.

    block : str
        The name of the block scope in which the error occured. In the
        sample above, the block scope is 'bar'.

    Returns
    -------
    result : str
        A nicely formatted string for including in an exception. If the
        file cannot be opened, the source lines will note be included.

    """
    text = 'File "%s", line %d, in %s()' % (filename, lineno, block)
    start_lineno = max(0, lineno - 1)
    end_lineno = start_lineno + 2
    lines = []
    try:
        with open(filename, 'r') as f:
            for idx, line in enumerate(f, 1):
                if idx >= start_lineno and idx <= end_lineno:
                    lines.append((idx, line))
                elif idx > end_lineno:
                    break
    except IOError:
        pass
    if len(lines) > 0:
        digits = str(len(str(end_lineno)))
        line_templ = '\n----> %' + digits + 'd %s'
        other_templ = '\n      %' + digits + 'd %s'
        for lno, line in lines:
            line = line.rstrip()
            if lno == lineno:
                text += line_templ % (lno, line)
            else:
                text += other_templ % (lno, line)
    return text


class DeclarativeNameError(NameError):
    """ A NameError subclass which nicely formats the exception.

    This class is intended for used by Declarative and its subclasses to
    report errors for failed global lookups when building out the object
    tree.

    """
    def __init__(self, name, filename, lineno, block):
        """ Initialize a DeclarativeNameError.

        Parameters
        ----------
        name : str
            The name of global symbol which was not found.

        filename : str
            The filename where the lookup failed.

        lineno : int
            The line number of the error.

        block : str
            The name of the lexical block in which the lookup failed.

        """
        super(DeclarativeNameError, self).__init__(name)
        self.name = name
        self.filename = filename
        self.lineno = lineno
        self.block = block

    def __str__(self):
        """ A nicely formatted representaion of the exception.

        """
        text = '%s\n\n' % self.name
        text += _format_source_error(self.filename, self.lineno, self.block)
        text += "\n\nNameError: global name '%s' is not defined" % self.name
        return text


class OperatorLookupError(LookupError):
    """ A LookupError subclass which nicely formats the exception.

    This class is intended for used by Declarative and its subclasses to
    report errors for failed operator lookups when building the object
    tree.

    """
    op_map = {
        '__operator_Equal__': '=',
        '__operator_LessLess__': '<<',
        '__operator_ColonColon__': '::',
        '__operator_ColonEqual__': ':=',
        '__operator_GreaterGreater__': '>>',
    }

    def __init__(self, operator, filename, lineno, block):
        """ Initialize an OperatorLookupError.

        Parameters
        ----------
        operator : str
            The name of the operator which was not found.

        filename : str
            The filename where the lookup failed.

        lineno : int
            The line number of the error.

        block : str
            The name of the lexical block in which the lookup failed.

        """
        super(OperatorLookupError, self).__init__(operator)
        self.operator = operator
        self.filename = filename
        self.lineno = lineno
        self.block = block

    def __str__(self):
        """ A nicely formatted representaion of the exception.

        """
        op = self.operator
        text = '%s\n\n' % op
        text += _format_source_error(self.filename, self.lineno, self.block)
        optext = "'%s'" % op
        if op in self.op_map:
            optext += " ( %s )" % self.op_map[op]
        text += "\n\nOperatorLookupError: failed to load operator %s" % optext
        return text


########NEW FILE########
__FILENAME__ = expressions
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from collections import namedtuple
from weakref import ref

from traits.api import HasTraits, Disallow, TraitListObject, TraitDictObject

from .abstract_expressions import AbstractExpression, AbstractListener
from .code_tracing import CodeTracer, CodeInverter
from .dynamic_scope import DynamicScope, AbstractScopeListener, Nonlocals
from .funchelper import call_func


#------------------------------------------------------------------------------
# Traits Code Tracer
#------------------------------------------------------------------------------
class TraitsTracer(CodeTracer):
    """ A CodeTracer for tracing expressions which use Traits.

    This tracer maintains a running set of `traced_items` which are the
    (obj, name) pairs of traits items discovered during tracing.

    """
    def __init__(self):
        """ Initialize a TraitsTracer.

        """
        self.traced_items = set()

    #--------------------------------------------------------------------------
    # Private API
    #--------------------------------------------------------------------------
    def _trace_trait(self, obj, name):
        """ Add the trait object and name pair to the traced items.

        Parameters
        ----------
        obj : HasTraits
            The traits object owning the attribute.

        name : str
            The trait name to for which to bind a handler.

        """
        # Traits will happily force create a trait for things which aren't
        # actually traits. This tries to avoid most of that when possible.
        trait = obj.trait(name)
        if trait is not None and trait.trait_type is not Disallow:
            self.traced_items.add((obj, name))

    #--------------------------------------------------------------------------
    # AbstractScopeListener Interface
    #--------------------------------------------------------------------------
    def dynamic_load(self, obj, attr, value):
        """ Called when an object attribute is dynamically loaded.

        This will trace the object if it is a HasTraits instance.
        See also: `AbstractScopeListener.dynamic_load`.

        """
        if isinstance(obj, HasTraits):
            self._trace_trait(obj, attr)

    #--------------------------------------------------------------------------
    # CodeTracer Interface
    #--------------------------------------------------------------------------
    def load_attr(self, obj, attr):
        """ Called before the LOAD_ATTR opcode is executed.

        This will trace the object if it is a HasTraits instance.
        See also: `CodeTracer.dynamic_load`.

        """
        if isinstance(obj, HasTraits):
            self._trace_trait(obj, attr)

    def call_function(self, func, argtuple, argspec):
        """ Called before the CALL_FUNCTION opcode is executed.

        This will trace the func is the builtin `getattr` and the object
        is a HasTraits instance. See also: `CodeTracer.call_function`

        """
        nargs = argspec & 0xFF
        nkwargs = (argspec >> 8) & 0xFF
        if (func is getattr and (nargs == 2 or nargs == 3) and nkwargs == 0):
            obj, attr = argtuple[0], argtuple[1]
            if isinstance(obj, HasTraits) and isinstance(attr, basestring):
                self._trace_trait(obj, attr)

    def binary_subscr(self, obj, idx):
        """ Called before the BINARY_SUBSCR opcode is executed.

        This will trace the object if it is a `TraitListObject` or a
        `TraitDictObject`. See also: `CodeTracer.get_iter`.

        """
        if isinstance(obj, (TraitListObject, TraitDictObject)):
            traits_obj = obj.object()
            if traits_obj is not None:
                if obj.name_items:
                    self._trace_trait(traits_obj, obj.name_items)

    def get_iter(self, obj):
        """ Called before the GET_ITER opcode is executed.

        This will trace the object if it is a `TraitListObject`
        See also: `CodeTracer.get_iter`.

        """
        if isinstance(obj, TraitListObject):
            traits_obj = obj.object()
            if traits_obj is not None:
                if obj.name_items:
                    self._trace_trait(traits_obj, obj.name_items)


AbstractScopeListener.register(TraitsTracer)


#------------------------------------------------------------------------------
# Standard Code Inverter
#------------------------------------------------------------------------------
class StandardInverter(CodeInverter):
    """ The standard code inverter for Enaml expressions.

    """
    def __init__(self, nonlocals):
        """ Initialize a StandardInverter.

        Parameters
        ----------
        nonlocals : Nonlocals
            The nonlocal scope for the executing expression.

        """
        self._nonlocals = nonlocals

    #--------------------------------------------------------------------------
    # CodeInverter Interface
    #--------------------------------------------------------------------------
    def load_name(self, name, value):
        """ Called before the LOAD_NAME opcode is executed.

        This method performs STORE_NAME by storing to the nonlocals.
        See also: `CodeInverter.load_name`.

        """
        self._nonlocals[name] = value

    def load_attr(self, obj, attr, value):
        """ Called before the LOAD_ATTR opcode is executed.

        This method performs STORE_ATTR via the builtin `setattr`.
        See also: `CodeInverter.load_attr`.

        """
        setattr(obj, attr, value)

    def call_function(self, func, argtuple, argspec, value):
        """ Called before the CALL_FUNCTION opcode is executed.

        This method inverts a call to the builtin `getattr` into a call
        to the builtin `setattr`. All other calls will raise.
        See also: `CodeInverter.call_function`.

        """
        nargs = argspec & 0xFF
        nkwargs = (argspec >> 8) & 0xFF
        if (func is getattr and (nargs == 2 or nargs == 3) and nkwargs == 0):
            obj, attr = argtuple[0], argtuple[1]
            setattr(obj, attr, value)
        else:
            self.fail()

    def binary_subscr(self, obj, idx, value):
        """ Called before the BINARY_SUBSCR opcode is executed.

        This method performs a STORE_SUBSCR operation through standard
        setitem semantics. See also: `CodeInverter.binary_subscr`.

        """
        obj[idx] = value


#------------------------------------------------------------------------------
# Base Expression
#------------------------------------------------------------------------------
class BaseExpression(object):
    """ The base class of the standard Enaml expression classes.

    """
    __slots__ = ('_func', '_f_locals')

    def __init__(self, func, f_locals):
        """ Initialize a BaseExpression.

        Parameters
        ----------
        func : types.FunctionType
            A function created by the Enaml compiler with bytecode that
            has been patched to support the semantics required of the
            expression.

        f_locals : dict
            The dictionary of local identifiers for the function.

        """
        self._func = func
        self._f_locals = f_locals


#------------------------------------------------------------------------------
# Simple Expression
#------------------------------------------------------------------------------
class SimpleExpression(BaseExpression):
    """ An implementation of AbstractExpression for the `=` operator.

    """
    __slots__ = ()

    #--------------------------------------------------------------------------
    # AbstractExpression Interface
    #--------------------------------------------------------------------------
    def eval(self, owner, name):
        """ Evaluate and return the expression value.

        """
        overrides = {'nonlocals': Nonlocals(owner, None)}
        scope = DynamicScope(owner, self._f_locals, overrides, None)
        with owner.operators:
            return call_func(self._func, (), {}, scope)


AbstractExpression.register(SimpleExpression)


#------------------------------------------------------------------------------
# Notification Expression
#------------------------------------------------------------------------------
NotificationEvent = namedtuple('NotificationEvent', 'obj name old new')


class NotificationExpression(BaseExpression):
    """ An implementation of AbstractListener for the `::` operator.

    """
    __slots__ = ()

    #--------------------------------------------------------------------------
    # AbstractListener Interface
    #--------------------------------------------------------------------------
    def value_changed(self, owner, name, old, new):
        """ Called when the attribute on the owner has changed.

        """
        overrides = {
            'event': NotificationEvent(owner, name, old, new),
            'nonlocals': Nonlocals(owner, None),
        }
        scope = DynamicScope(owner, self._f_locals, overrides, None)
        with owner.operators:
            call_func(self._func, (), {}, scope)


AbstractListener.register(NotificationExpression)


#------------------------------------------------------------------------------
# Update Expression
#------------------------------------------------------------------------------
class UpdateExpression(BaseExpression):
    """ An implementation of AbstractListener for the `>>` operator.

    """
    __slots__ = ()

    #--------------------------------------------------------------------------
    # AbstractListener Interface
    #--------------------------------------------------------------------------
    def value_changed(self, owner, name, old, new):
        """ Called when the attribute on the owner has changed.

        """
        nonlocals = Nonlocals(owner, None)
        overrides = {'nonlocals': nonlocals}
        inverter = StandardInverter(nonlocals)
        scope = DynamicScope(owner, self._f_locals, overrides, None)
        with owner.operators:
            call_func(self._func, (inverter, new), {}, scope)


AbstractListener.register(UpdateExpression)


#------------------------------------------------------------------------------
# Subcsription Expression
#------------------------------------------------------------------------------
class SubscriptionNotifier(object):
    """ A simple object used for attaching notification handlers.

    """
    __slots__ = ('owner', 'name', 'keyval', '__weakref__')

    def __init__(self, owner, name, keyval):
        """ Initialize a SubscriptionNotifier.

        Parameters
        ----------
        owner : Declarative
            The declarative object which owns the expression.

        name : str
            The name to which the expression is bound.

        keyval : object
            An object to use for testing equivalency of notifiers.

        """
        self.owner = ref(owner)
        self.name = name
        self.keyval = keyval

    def notify(self):
        """ Notify that the expression is invalid.

        """
        owner = self.owner()
        if owner is not None:
            owner.refresh_expression(self.name)


class SubscriptionExpression(BaseExpression):
    """ An implementation of AbstractExpression for the `<<` operator.

    """
    __slots__ = ('_notifier')

    def __init__(self, func, f_locals):
        """ Initialize a SubscriptionExpression.

        """
        super(SubscriptionExpression, self).__init__(func, f_locals)
        self._notifier = None

    #--------------------------------------------------------------------------
    # AbstractExpression Interface
    #--------------------------------------------------------------------------
    def eval(self, owner, name):
        """ Evaluate and return the expression value.

        """
        tracer = TraitsTracer()
        overrides = {'nonlocals': Nonlocals(owner, tracer)}
        scope = DynamicScope(owner, self._f_locals, overrides, tracer)
        with owner.operators:
            result = call_func(self._func, (tracer,), {}, scope)

        # In most cases, the objects comprising the dependencies of an
        # expression will not change during subsequent evaluations of
        # the expression. Rather than creating a new notifier on each
        # pass and repeating the work of creating the change handlers,
        # a key for the dependencies is computed and a new notifier is
        # created only when the key changes. The key uses the id of an
        # object instead of the object itself so strong references to
        # the object are not maintained by the expression. A sorted
        # tuple is used instead of a frozenset to reduced the memory
        # footprint. It is slightly slower to compute but ~5x smaller.
        traced = tracer.traced_items
        keyval = tuple(sorted((id(obj), attr) for obj, attr in traced))
        notifier = self._notifier
        if notifier is None or keyval != notifier.keyval:
            notifier = SubscriptionNotifier(owner, name, keyval)
            self._notifier = notifier
            handler = notifier.notify
            for obj, attr in traced:
                obj.on_trait_change(handler, attr)

        return result


AbstractExpression.register(SubscriptionExpression)


#------------------------------------------------------------------------------
# Delegation Expression
#------------------------------------------------------------------------------
class DelegationExpression(SubscriptionExpression):
    """ An expression and listener implementation for the `:=` operator.

    """
    __slots__ = ()

    #--------------------------------------------------------------------------
    # AbstractListener Interface
    #--------------------------------------------------------------------------
    def value_changed(self, owner, name, old, new):
        """ Called when the attribute on the owner has changed.

        """
        nonlocals = Nonlocals(owner, None)
        inverter = StandardInverter(nonlocals)
        overrides = {'nonlocals': nonlocals}
        scope = DynamicScope(owner, self._f_locals, overrides, None)
        with owner.operators:
            call_func(self._func._update, (inverter, new), {}, scope)


AbstractListener.register(DelegationExpression)


########NEW FILE########
__FILENAME__ = funchelper
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from types import FunctionType
from ctypes import (
    pythonapi, py_object, c_int, c_size_t, Structure, ARRAY, c_void_p
)


PyEval_EvalCodeEx = pythonapi.PyEval_EvalCodeEx
PyEval_EvalCodeEx.restype = py_object
PyEval_EvalCodeEx.argtypes = [
    py_object,      # code object
    py_object,      # globals dict
    py_object,      # locals mapping
    c_void_p,       # args array (PyObject**)
    c_int,          # num args
    c_void_p,       # keywords array (PyObject**)
    c_int,          # num keywords
    c_void_p,       # defaults array (PyObject**)
    c_int,          # num defaults
    py_object,      # closure
]


class PyTupleObject(Structure):
    _fields_ = [
        ('ob_refcnt', c_size_t),
        ('ob_type', py_object),
        ('ob_size', c_size_t),
        ('ob_item', ARRAY(py_object, 1)),
    ]
OB_ITEM_OFFSET = PyTupleObject.ob_item.offset


def call_func(func, args, kwargs, f_locals=None):
    """ Call a function which has been modified by the Enaml compiler
    to support tracing and dynamic scoping.

    Parameters
    ----------
    func : types.FunctionType
        The Python function to call.

    args : tuple
        The tuple of arguments to pass to the function.

    kwargs : dict
        The dictionary of keywords to pass to the function.

    f_locals : mapping, optional
        An optional locals mapping to use with the function.

    Returns
    -------
    result : object
        The result of calling the function.

    """
    if not isinstance(func, FunctionType):
        raise TypeError('function must be a Python function')

    if not isinstance(args, tuple):
        raise TypeError('arguments must be a tuple')

    if not isinstance(kwargs, dict):
        raise TypeError('keywords must be a dict')

    if f_locals is None:
        f_locals = py_object()
    elif not hasattr(f_locals, '__getitem__'):
        raise TypeError('locals must be a mapping')

    num_args = len(args)
    args_array = c_void_p(id(args) + OB_ITEM_OFFSET)

    if kwargs:
        keywords = []
        for key, value in kwargs.iteritems:
            keywords.append(key)
            keywords.append(value)
        keywords = tuple(keywords)
        num_keywords = len(keywords) / 2
    else:
        keywords = ()
        num_keywords = 0
    keywords_array = c_void_p(id(keywords) + OB_ITEM_OFFSET)

    defaults = func.func_defaults or ()
    num_defaults = len(defaults)
    defaults_array = c_void_p(id(defaults) + OB_ITEM_OFFSET)

    result = PyEval_EvalCodeEx(
        func.func_code,
        func.func_globals,
        f_locals,
        args_array,
        num_args,
        keywords_array,
        num_keywords,
        defaults_array,
        num_defaults,
        func.func_closure
    )

    return result


# Use the faster version of `call_func` if it's available.
try:
    from enaml.extensions.funchelper import call_func
except ImportError:
    pass


########NEW FILE########
__FILENAME__ = import_hooks
#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from abc import ABCMeta, abstractmethod
from collections import defaultdict, namedtuple
import imp
import marshal
import os
import struct
import sys
import types

from .enaml_compiler import EnamlCompiler, COMPILER_VERSION
from .parser import parse

from ..utils import abstractclassmethod


# The magic number as symbols for the current Python interpreter. These
# define the naming scheme used when create cached files and directories.
MAGIC = imp.get_magic()
try:
    MAGIC_TAG = 'enaml-py%s%s-cv%s' % (
        sys.version_info.major, sys.version_info.minor, COMPILER_VERSION,
    )
except AttributeError: 
    # Python 2.6 compatibility
    MAGIC_TAG = 'enaml-py%s%s-cv%s' % (
        sys.version_info[0], sys.version_info[1], COMPILER_VERSION,
    )
CACHEDIR = '__enamlcache__'


#------------------------------------------------------------------------------
# Import Helpers
#------------------------------------------------------------------------------
EnamlFileInfo = namedtuple('EnamlFileInfo', 'src_path, cache_path, cache_dir')


def make_file_info(src_path):
    """ Create an EnamlFileInfo object for the given src_path.

    Parameters
    ----------
    src_path : string
        The full path to the .enaml file.
    
    Returns
    -------
    result : FileInfo
        A properly populated EnamlFileInfo object.
    
    """
    root, tail = os.path.split(src_path)
    fnroot, _ = os.path.splitext(tail)
    cache_dir = os.path.join(root, CACHEDIR)
    fn = ''.join((fnroot, '.', MAGIC_TAG, os.path.extsep, 'enamlc'))
    cache_path = os.path.join(cache_dir, fn)
    return EnamlFileInfo(src_path, cache_path, cache_dir)


#------------------------------------------------------------------------------
# Abstract Enaml Importer
#------------------------------------------------------------------------------
class AbstractEnamlImporter(object):
    """ An abstract base class which defines the api required to 
    implement an Enaml importer.

    """
    __metaclass__ = ABCMeta

    # Count the number of times an importer has been installed. 
    # Only uninstall it when the count hits 0 again. This permits 
    # proper nesting of import contexts.
    _install_count = defaultdict(int)

    @classmethod
    def install(cls):
        """ Appends this importer into sys.meta_path.

        """
        cls._install_count[cls] += 1
        if cls not in sys.meta_path:
            sys.meta_path.append(cls)
    
    @classmethod
    def uninstall(cls):
        """ Removes this importer from sys.meta_path.

        """
        cls._install_count[cls] -= 1
        if cls._install_count[cls] <= 0 and cls in sys.meta_path:
            sys.meta_path.remove(cls)

    #--------------------------------------------------------------------------
    # Python Import API
    #--------------------------------------------------------------------------
    @classmethod
    def find_module(cls, fullname, path=None):
        """ Finds the given Enaml module and returns an importer, or
        None if the module is not found.

        """
        loader = cls.locate_module(fullname, path)
        if loader is not None:
            if not isinstance(loader, AbstractEnamlImporter):
                msg = 'Enaml imports received invalid loader object %s'
                raise ImportError(msg % loader)
            return loader

    def load_module(self, fullname):
        """ Loads and returns the Python module for the given enaml path.
        If a module already exisist in sys.path, the existing module is
        reused, otherwise a new one is created.

        """
        code, path = self.get_code()
        if fullname in sys.modules:
            mod = sys.modules[fullname]
        else:
            mod = sys.modules[fullname] = types.ModuleType(fullname)
        mod.__loader__ = self
        mod.__file__ = path
        # Even though the import hook is already installed, this is a 
        # safety net to avoid potentially hard to find bugs if code has
        # manually installed and removed a hook. The contract here is 
        # that the import hooks are always installed when executing the
        # module code of an Enaml file.
        with imports():
            exec code in mod.__dict__
        return mod

    #--------------------------------------------------------------------------
    # Abstract API
    #--------------------------------------------------------------------------
    @abstractclassmethod
    def locate_module(cls, fullname, path=None):
        """ Searches for the given Enaml module and returns an instance 
        of AbstractEnamlImporter on success.

        Paramters
        ---------
        fullname : string
            The fully qualified name of the module.
        
        path : string or None
            The subpackage __path__ for submodules and subpackages
            or None if a top-level module.

        Returns
        -------
        result : Instance(AbstractEnamlImporter) or None
            If the Enaml module is located an instance of the importer
            that will perform the rest of the operations is returned. 
            Otherwise, returns None.
        
        """
        raise NotImplementedError

    @abstractmethod
    def get_code(self):
        """ Loads and returns the code object for the Enaml module and
        the full path to the module for use as the __file__ attribute 
        of the module.

        Returns
        -------
        result : (code, path)
            The Python code object for the .enaml module, and the full
            path to the module as a string.

        """
        raise NotImplementedError


#------------------------------------------------------------------------------
# Default Enaml Importer
#------------------------------------------------------------------------------
class EnamlImporter(AbstractEnamlImporter):
    """ The standard Enaml importer which can import Enaml modules from
    standard locations on the python path and compile them appropriately
    to .enamlc files.

    This importer adopts the Python 3 conventions and scheme for creating
    the cached files and setting the __file__ attribute on the module.
    See this discussion thread for more info:
    http://www.mail-archive.com/python-dev@python.org/msg45203.html

    """
    @classmethod
    def locate_module(cls, fullname, path=None):
        """ Searches for the given Enaml module and returns an instance 
        of this class on success.

        Paramters
        ---------
        fullname : string
            The fully qualified name of the module.
        
        path : list or None
            The subpackage __path__ for submodules and subpackages
            or None if a top-level module.

        Returns
        -------
        results : Instance(AbstractEnamlImporter) or None
            If the Enaml module is located an instance of the importer
            that will perform the rest of the operations is returned. 
            Otherwise, returns None.
        
        """
        # We're looking inside a package and 'path' the package path
        if path is not None:
            modname = fullname.rsplit('.', 1)[-1]
            leaf = ''.join((modname, os.path.extsep, 'enaml'))
            for stem in path:
                enaml_path = os.path.join(stem, leaf)
                file_info = make_file_info(enaml_path)  
                if (os.path.exists(file_info.src_path) or
                    os.path.exists(file_info.cache_path)):
                    return cls(file_info)

        # We're trying a load a package
        elif '.' in fullname:
            return
        
        # We're doing a direct import
        else:
            leaf = fullname + os.path.extsep + 'enaml'
            for stem in sys.path:
                enaml_path = os.path.join(stem, leaf)
                file_info = make_file_info(enaml_path) 
                if (os.path.exists(file_info.src_path) or
                    os.path.exists(file_info.cache_path)):
                    return cls(file_info)
    
    def __init__(self, file_info):
        """ Initialize an importer object.

        Parameters
        ----------
        file_info : EnamlFileInfo
            An instance of EnamlFileInfo.
        
        """
        self.file_info = file_info

    def _load_cache(self, file_info):
        """ Loads and returns the code object for the given file info.

        Parameters
        ----------
        file_info : EnamlFileInfo
            The file info object for the file.
        
        Returns
        -------
        result : types.CodeType
            The code object for the file.

        """
        with open(file_info.cache_path, 'rb') as cache_file:
            cache_file.read(8)
            code = marshal.load(cache_file)
        return code

    def _write_cache(self, code, ts, file_info):
        """ Write the cached file for then given info, creating the 
        cache directory if needed. This call will suppress any 
        IOError or OSError exceptions.
        
        Parameters
        ----------
        code : types.CodeType
            The code object to write to the cache.
        
        ts : int
            The integer timestamp for the file.
        
        file_info : EnamlFileInfo
            The file info object for the file.
        
        """
        try:
            if not os.path.exists(file_info.cache_dir):
                os.mkdir(file_info.cache_dir)
            with open(file_info.cache_path, 'w+b') as cache_file:
                cache_file.write(MAGIC)
                cache_file.write(struct.pack('i', ts))
                marshal.dump(code, cache_file)
        except (OSError, IOError):
            pass

    def _get_magic_info(self, file_info):
        """ Loads and returns the magic info for the given path.

        Parameters
        ----------
        file_info : EnamlFileInfo
            The file info object for the file.
        
        Returns
        -------
        result : (magic, timestamp)
            The magic string and integer timestamp for the file.

        """
        with open(file_info.cache_path, 'rb') as cache_file:
            magic = cache_file.read(4)
            timestamp = struct.unpack('i', cache_file.read(4))[0]
        return (magic, timestamp)

    def get_code(self):
        """ Loads and returns the code object for the Enaml module and
        the full path to the module for use as the __file__ attribute 
        of the module.

        Returns
        -------
        result : (code, path)
            The Python code object for the .enaml module, and the full
            path to the module as a string.

        """
        # If the .enaml file does not exists, just use the .enamlc file.
        # We can presume that the latter exists because it was already
        # checked by the loader. Should the situation ever arise that
        # it was deleted between then and now, an IOError is more 
        # informative than an ImportError.
        file_info = self.file_info
        if not os.path.exists(file_info.src_path):
            code = self._load_cache(file_info)
            return (code, file_info.src_path)

        # Use the cached file if it exists and is current
        src_mod_time = int(os.path.getmtime(file_info.src_path))
        if os.path.exists(file_info.cache_path):
            magic, ts = self._get_magic_info(file_info)
            if magic == MAGIC and src_mod_time <= ts:
                code = self._load_cache(file_info)
                return (code, file_info.src_path)

        # Otherwise, compile from source and attempt to cache
        with open(file_info.src_path, 'rU') as src_file:
            src = src_file.read()
        ast = parse(src)
        code = EnamlCompiler.compile(ast, file_info.src_path)
        self._write_cache(code, src_mod_time, file_info)
        return (code, file_info.src_path)


#------------------------------------------------------------------------------
# Enaml Imports Context
#------------------------------------------------------------------------------
class imports(object):
    """ A context manager that hooks/unhooks the enaml meta path
    importer for the duration of the block. The helps user avoid
    unintended consequences of a having a meta path importer slow
    down all of their other imports.

    """
    #: The framework-wide importers in use. We always have the default
    #: importer available, unless it is explicitly removed.
    __importers = [EnamlImporter]

    @classmethod
    def get_importers(cls):
        """ Returns a tuple of currently active importers in use for the
        framework.

        """
        return tuple(cls.__importers)

    @classmethod
    def add_importer(cls, importer):
        """ Add an importer to the list of importers for use with the 
        framework. It must be a subclass of AbstractEnamlImporter.
        The most recently appended importer is used first. If the 
        importer has already been added, this is a no-op. To move
        an importer up in precedence, remove it and add it again.

        """
        if not issubclass(importer, AbstractEnamlImporter):
            msg = ('An Enaml importer must be a subclass of '
                   'AbstractEnamlImporter. Got %s instead.')
            raise TypeError(msg % importer)
        importers = cls.__importers
        if importer not in importers:
            importers.append(importer)
    
    @classmethod
    def remove_importer(cls, importer):
        """ Removes the importer from the list of active importers. 
        If the importer is not in the list, this is a no-op.

        """
        importers = cls.__importers
        if importer in importers:
            importers.remove(importer)

    def __init__(self):
        """ Initializes an Enaml import context.

        """
        self.importers = self.get_importers()

    def __enter__(self):
        """ Installs the current importer upon entering the context.

        """
        # Install the importers reversed so that the newest ones 
        # get first crack at the import on sys.meta_path.
        for importer in reversed(self.importers):
            importer.install()
    
    def __exit__(self, *args, **kwargs):
        """ Uninstalls the current importer when leaving the context.

        """
        # We removed in standard order since thats a more efficient
        # operation on sys.meta_path.
        for importer in self.importers:
            importer.uninstall()


########NEW FILE########
__FILENAME__ = include
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from traits.api import List, Instance, Bool

from .declarative import Declarative
from .object import Object


class Include(Declarative):
    """ An object which dynamically inserts children into its parent.

    The `Include` object is used to cleanly and easily insert objects
    into the children of its parent. `Object` instances assigned to the
    `objects` list of the `Include` will be parented with the parent of
    the `Include`. The parent of an `Include` should be an instance of
    `Messenger`; if this condition does not hold, the behavior will be
    undefined.

    """
    #: The list of objects belonging to this Include. Objects in this
    #: list will be automatically parented with the Include's parent.
    objects = List(Instance(Object))

    #: A boolean flag indicating whether to destroy the old objects that
    #: are removed from the parent. The default is True.
    destroy_old = Bool(True)

    def pre_initialize(self):
        """ A pre-initialization handler.

        This method will add the include objects to the parent of the
        include and ensure that they are initialized.

        """
        super(Include, self).pre_initialize()
        self.parent.insert_children(self, self.objects)
        for obj in self.objects:
            obj.initialize()

    def parent_event(self, event):
        """ Handle a `ParentEvent` for the Include.

        If the object state is `active` the current include objects will
        be reparented to the new parent.

        """
        if self.is_active:
            old = event.old
            new = event.new
            with new.children_event_context():
                with old.children_event_context():
                    if new is None:
                        for obj in self.objects:
                            obj.set_parent(None)
                    else:
                        new.insert_children(self, self.objects)

    def _objects_changed(self, old, new):
        """ A change handler for the `objects` list of the Include.

        If the object state is 'active' objects which are removed will
        be unparented and objects which are added will be reparented.
        Old objects will be destroyed if the `destroy_old` flag is set
        to True.

        """
        if self.is_active:
            parent = self.parent
            if parent is not None:
                with parent.children_event_context():
                    new_set = set(new)
                    if self.destroy_old:
                        for obj in old:
                            if obj not in new_set:
                                obj.destroy()
                    else:
                        for obj in old:
                            if obj not in new_set:
                                obj.set_parent(None)
                    if new_set:
                        parent.insert_children(self, self.objects)

    def _objects_items_changed(self, event):
        """ Handle the `objects` list changing in-place.

        If the object state is 'active' objects which are removed will
        be unparented and objects which are added will be reparented.
        Old objects will be destroyed if the `destroy_old` flag is set
        to True.

        """
        if self.is_active:
            parent = self.parent
            if parent is not None:
                with parent.children_event_context():
                    add_set = set(event.added)
                    if self.destroy_old:
                        for obj in event.removed:
                            if obj not in add_set:
                                obj.destroy()
                    else:
                        for obj in event.removed:
                            if obj not in add_set:
                                obj.set_parent(None)
                    if add_set:
                        parent.insert_children(self, self.objects)


########NEW FILE########
__FILENAME__ = lexer
#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
import os
import tokenize

import ply.lex as lex


# Get a save directory for the lex and parse tables
_lex_dir = os.path.join(os.path.dirname(__file__), 'parse_tab')
_lex_module = 'enaml.core.parse_tab.lextab'


#------------------------------------------------------------------------------
# Lexing Helpers
#------------------------------------------------------------------------------
class ParsingError(Exception):
    """ A helper class to bubble up exceptions out of the parsers
    control to be re-raised at the parsing entry point. It avoids
    problems with raise SyntaxErrors from within Ply parsing rules.

    """
    def __init__(self, exc_class, *args, **kwargs):
        self.exc_class = exc_class
        self.args = args
        self.kwargs = kwargs

    def __call__(self):
        return self.exc_class(*self.args, **self.kwargs)


def _parsing_error(klass, message, token):
    """ Create and raise a parsing error for the syntax_error and
    indentation_error functions below.

    Parameters
    ----------
    klass : Exception class
        The exception type to raise.
    
    message : string
        The message to pass to the exception.
    
    token : LexToken
        The current lextoken for the error.
    
    """
    filename = token.lexer.filename
    lexdata = token.lexer.lexdata
    lineno = token.lineno
    text = lexdata.splitlines()[lineno - 1] 
    info = (filename, lineno, 0, text)
    raise ParsingError(klass, message, info)


def syntax_error(message, token):
    """ Raise a ParsingError which will be converted into an proper
    SyntaxError during parsing.

    Parameters
    ----------
    message : string
        The message to pass to the IndentationError
    
    token : LexToken
        The current lextoken for the error.

    """
    _parsing_error(SyntaxError, message, token)


def indentation_error(message, token):
    """ Raise a ParsingError which will be converted into an proper
    IndentationError during parsing.

    Parameters
    ----------
    message : string
        The message to pass to the IndentationError
    
    token : LexToken
        The current lextoken for the error.

    """
    _parsing_error(IndentationError, message, token)


#------------------------------------------------------------------------------
# Enaml Lexer
#------------------------------------------------------------------------------
class EnamlLexer(object):

    operators = (
        (r'@', 'AT'),
        (r'&', 'AMPER'),
        (r'&=', 'AMPEREQUAL'),
        (r'\^', 'CIRCUMFLEX'),
        (r'\^=', 'CIRCUMFLEXEQUAL'),
        (r':', 'COLON'),
        (r'\.', 'DOT'),
        (r'//', 'DOUBLESLASH'),
        (r'//=', 'DOUBLESLASHEQUAL'),
        (r'\*\*', 'DOUBLESTAR'),
        (r'\*\*=', 'DOUBLESTAREQUAL'),
        (r'==', 'EQEQUAL'),
        (r'=', 'EQUAL'),
        (r'>', 'GREATER'),
        (r'>=', 'GREATEREQUAL'),
        (r'<<', 'LEFTSHIFT'),
        (r'<<=', 'LEFTSHIFTEQUAL'),
        (r'<', 'LESS'),
        (r'<=', 'LESSEQUAL'),
        (r'-', 'MINUS'),
        (r'-=', 'MINUSEQUAL'),
        (r'!=', 'NOTEQUAL'),
        (r'%', 'PERCENT'),
        (r'%=', 'PERCENTEQUAL'),
        (r'\+', 'PLUS'),
        (r'\+=', 'PLUSEQUAL'),
        (r'>>', 'RIGHTSHIFT'),
        (r'>>=', 'RIGHTSHIFTEQUAL'),
        (r';', 'SEMI'),
        (r'/', 'SLASH'),
        (r'/=', 'SLASHEQUAL',),
        (r'\*', 'STAR'),
        (r'\*=', 'STAREQUAL'),
        (r'~', 'TILDE'),
        (r'\|', 'VBAR'),
        (r'\|=', 'VBAREQUAL'),
        (r'::', 'DOUBLECOLON'),
        (r'\.\.\.', 'ELLIPSIS'),
        (r':=', 'COLONEQUAL'),
    )

    tokens = (
        'COMMA',
        'DEDENT',
        'ENDMARKER',
        'INDENT',
        'LBRACE',
        'LPAR',
        'LSQB',
        'NAME',
        'NEWLINE',
        'NUMBER',
        'RBRACE',
        'RPAR',
        'RSQB',
        'STRING',
        'WS',

        # string token sentinels
        'STRING_START_SINGLE',
        'STRING_START_TRIPLE',
        'STRING_CONTINUE',
        'STRING_END',

    )

    reserved = {
        'and': 'AND',
        'as': 'AS',
        'assert': 'ASSERT',
        'break': 'BREAK',
        'class': 'CLASS',
        'continue': 'CONTINUE',
        'def': 'DEF',
        'del': 'DEL',
        'elif': 'ELIF',
        'else': 'ELSE',
        'enamldef': 'ENAMLDEF',
        'exec': 'EXEC',
        'except': 'EXCEPT',
        'finally': 'FINALLY',
        'from': 'FROM',
        'for': 'FOR',
        'global': 'GLOBAL',
        'if': 'IF',
        'import': 'IMPORT',
        'in': 'IN',
        'is': 'IS',
        'lambda': 'LAMBDA',
        'not': 'NOT',
        'or': 'OR',
        'pass': 'PASS',
        'print': 'PRINT',
        'raise': 'RAISE',
        'return': 'RETURN',
        'try': 'TRY',
        'while': 'WHILE',
        'with': 'WITH',
        'yield': 'YIELD',
    }

    tokens = (tokens + 
              tuple(val[1] for val in operators) + 
              tuple(reserved.values()))

    #--------------------------------------------------------------------------
    # Lexer States
    #--------------------------------------------------------------------------
    states = (
        ('SINGLEQ1', 'exclusive'),
        ('SINGLEQ2', 'exclusive'),
        ('TRIPLEQ1', 'exclusive'),
        ('TRIPLEQ2', 'exclusive'),
    )

    #--------------------------------------------------------------------------
    # Default Rules
    #--------------------------------------------------------------------------
    t_COMMA = r','
    t_NUMBER = tokenize.Number

    # Generate the token matching rules for the operators
    for tok_pattern, tok_name in operators:
        tok_name = 't_' + tok_name
        locals()[tok_name] = tok_pattern
    
    def t_comment(self, t):
        r'[ ]*\#[^\r\n]*'
        pass
   
    def t_WS(self, t):
        r' [ \t\f]+ '
        value = t.value

        # A formfeed character may be present at the start of the
        # line; it will be ignored for the indentation calculations
        # above. Formfeed characters occurring elsewhere in the
        # leading whitespace have an undefined effect (for instance,
        # they may reset the space count to zero). 
        value = value.rsplit("\f", 1)[-1]

        # First, tabs are replaced (from left to right) by one to eight
        # spaces such that the total number of characters up to and
        # including the replacement is a multiple of eight (this is
        # intended to be the same rule as used by Unix). The total number
        # of spaces preceding the first non-blank character then
        # determines the line's indentation. Indentation cannot be split
        # over multiple physical lines using backslashes; the whitespace
        # up to the first backslash determines the indentation.
        pos = 0
        while True:
            pos = value.find("\t")
            if pos == -1:
                break
            n = 8 - (pos % 8)
            value = value[:pos] + " " * n + value[pos+1:]

        if self.at_line_start and self.paren_count == 0:
            return t

    # string continuation - ignored beyond the tokenizer level
    def t_escaped_newline(self, t):
        r"\\\n"
        t.type = "STRING_CONTINUE"
        # Raw strings don't escape the newline
        assert not self.is_raw, "only occurs outside of quoted strings"
        t.lexer.lineno += 1

    def t_newline(self, t):
        r'\n+'
        t.lexer.lineno += len(t.value)
        t.type = 'NEWLINE'
        if self.paren_count == 0:
            return t
    
    def t_LPAR(self, t):
        r'\('
        self.paren_count += 1
        return t

    def t_RPAR(self, t):
        r'\)'
        self.paren_count -= 1
        return t
    
    def t_LBRACE(self, t):
        r'\{'
        self.paren_count += 1
        return t

    def t_RBRACE(self, t):
        r'\}'
        self.paren_count -= 1
        return t
    
    def t_LSQB(self, t):
        r'\['
        self.paren_count += 1
        return t

    def t_RSQB(self, t):
        r'\]'
        self.paren_count -= 1
        return t

    #--------------------------------------------------------------------------
    # State string escapes
    #--------------------------------------------------------------------------
    def t_SINGLEQ1_SINGLEQ2_TRIPLEQ1_TRIPLEQ2_escaped(self, t):
        r"\\(.|\n)"
        t.type = "STRING_CONTINUE"
        t.lexer.lineno += t.value.count("\n")
        return t

    #--------------------------------------------------------------------------
    # TRIPLEQ1 strings
    #--------------------------------------------------------------------------
    def t_start_triple_quoted_q1_string(self, t):
        r"[uU]?[rR]?'''"
        t.lexer.push_state("TRIPLEQ1")
        t.type = "STRING_START_TRIPLE"
        if "r" in t.value or "R" in t.value:
            self.is_raw = True
        t.value = t.value.split("'", 1)[0]
        return t
    
    def t_TRIPLEQ1_simple(self, t):
        r"[^'\\]+"
        t.type = "STRING_CONTINUE"
        t.lexer.lineno += t.value.count("\n")
        return t

    def t_TRIPLEQ1_q1_but_not_triple(self, t):
        r"'(?!'')"
        t.type = "STRING_CONTINUE"
        return t

    def t_TRIPLEQ1_end(self, t):
        r"'''"
        t.type = "STRING_END"
        t.lexer.pop_state()
        self.is_raw = False
        return t
    
    # supress PLY warning
    t_TRIPLEQ1_ignore = ''

    def t_TRIPLEQ1_error(self, t):
        syntax_error('invalid syntax', t)

    #--------------------------------------------------------------------------
    # TRIPLEQ2 strings
    #--------------------------------------------------------------------------
    def t_start_triple_quoted_q2_string(self, t):
        r'[uU]?[rR]?"""'
        t.lexer.push_state("TRIPLEQ2")
        t.type = "STRING_START_TRIPLE"
        if "r" in t.value or "R" in t.value:
            self.is_raw = True
        t.value = t.value.split('"', 1)[0]
        return t

    def t_TRIPLEQ2_simple(self, t):
        r'[^"\\]+'
        t.type = "STRING_CONTINUE"
        t.lexer.lineno += t.value.count("\n")
        return t

    def t_TRIPLEQ2_q2_but_not_triple(self, t):
        r'"(?!"")'
        t.type = "STRING_CONTINUE"
        return t

    def t_TRIPLEQ2_end(self, t):
        r'"""'
        t.type = "STRING_END"
        t.lexer.pop_state()
        self.is_raw = False
        return t

    # supress PLY warning
    t_TRIPLEQ2_ignore = ''

    def t_TRIPLEQ2_error(self, t):
        syntax_error('invalid syntax', t)

    #--------------------------------------------------------------------------
    # SINGLEQ1 strings
    #--------------------------------------------------------------------------
    def t_start_single_quoted_q1_string(self, t):
        r"[uU]?[rR]?'"
        t.lexer.push_state("SINGLEQ1")
        t.type = "STRING_START_SINGLE"
        if "r" in t.value or "R" in t.value:
            self.is_raw = True
        t.value = t.value.split("'", 1)[0]
        return t

    def t_SINGLEQ1_simple(self, t):
        r"[^'\\\n]+"
        t.type = "STRING_CONTINUE"
        return t

    def t_SINGLEQ1_end(self, t):
        r"'"
        t.type = "STRING_END"
        t.lexer.pop_state()
        self.is_raw = False
        return t
    
    # supress PLY warning
    t_SINGLEQ1_ignore = ''
    
    def t_SINGLEQ1_error(self, t):
        syntax_error('EOL while scanning single quoted string.', t)

    #--------------------------------------------------------------------------
    # SINGLEQ2 strings
    #--------------------------------------------------------------------------
    def t_start_single_quoted_q2_string(self, t):
        r'[uU]?[rR]?"'
        t.lexer.push_state("SINGLEQ2")
        t.type = "STRING_START_SINGLE"
        if "r" in t.value or "R" in t.value:
            self.is_raw = True
        t.value = t.value.split('"', 1)[0]
        return t

    def t_SINGLEQ2_simple(self, t):
        r'[^"\\\n]+'
        t.type = "STRING_CONTINUE"
        return t

    def t_SINGLEQ2_end(self, t):
        r'"'
        t.type = "STRING_END"
        t.lexer.pop_state()
        self.is_raw = False
        return t
    
    # supress PLY warning
    t_SINGLEQ2_ignore = ''
    
    def t_SINGLEQ2_error(self, t):
        syntax_error('EOL while scanning single quoted string.', t)
    
    #--------------------------------------------------------------------------
    # Miscellaneous Token Rules
    #--------------------------------------------------------------------------
    # This is placed after the string rules so r"" is not matched as a name.
    def t_NAME(self, t):
        r'[a-zA-Z_][a-zA-Z0-9_]*'
        t.type = self.reserved.get(t.value, "NAME")
        return t

    def t_error(self, t):
        syntax_error('invalid syntax', t)
        
    #--------------------------------------------------------------------------
    # Normal Class Items
    #--------------------------------------------------------------------------
    def __init__(self, filename='Enaml'):
        self.lexer = lex.lex(
            module=self, outputdir=_lex_dir, lextab=_lex_module, optimize=1,
        )
        self.token_stream = None
        self.filename = filename

        # Ply has a bit of an inconsistency when using a class as a 
        # lexer instead of a module. The .lexer attribute of tokens 
        # created by the ply lexer are set to that ply lexer instance, 
        # but the .lexer attribute of tokens created by the ply parser 
        # are set to the instance of this class. So, when the p_error 
        # function is called in the parser, we can't be sure which lexer
        # will be set on the error token. Since we need the filename in
        # that function, we add it as an attribute on both lexers.
        self.lexer.filename = filename

    def input(self, txt):
        self.lexer.input(txt)
        self.next_token = self.make_token_stream().next

        # State initialization
        self.paren_count = 0
        self.is_raw = False
        self.at_line_start = False

    def token(self):
        try:
            tok = self.next_token()
            return tok
        except StopIteration:
            pass
   
    def dedent(self, lineno):
        # Synthesize a DEDENT Token
        tok = lex.LexToken()
        tok.type = 'DEDENT'
        tok.value = None
        tok.lineno = lineno
        tok.lexpos = -1
        tok.lexer = self.lexer
        return tok

    def indent(self, lineno):
        # Synthesize an INDENT Token.
        tok = lex.LexToken()
        tok.type = 'INDENT'
        tok.value = None
        tok.lineno = lineno
        tok.lexpos = -1
        tok.lexer = self.lexer
        return tok

    def newline(self, lineno):
        tok = lex.LexToken()
        tok.type = 'NEWLINE'
        tok.value = '\n'
        tok.lineno = lineno
        tok.lexpos = -1
        tok.lexer = self.lexer
        return tok

    def make_token_stream(self):
        token_stream = iter(self.lexer.token, None)
        token_stream = self.create_strings(token_stream)
        token_stream = self.annotate_indentation_state(token_stream)
        token_stream = self.synthesize_indentation_tokens(token_stream)
        token_stream = self.add_endmarker(token_stream)
        return token_stream

    def create_strings(self, token_stream):
        for tok in token_stream:
            if not tok.type.startswith("STRING_START_"):
                yield tok
                continue

            # This is a string start; process until string end
            start_tok = tok
            string_toks = []
            for tok in token_stream:
                if tok.type == "STRING_END":
                    break
                else:
                    assert tok.type == "STRING_CONTINUE", tok.type
                    string_toks.append(tok)
            else:
                # Reached end of input without string termination
                msg = 'EOF while scanning %s-quoted string.'
                if start_tok.type == 'STRING_START_TRIPLE':
                    msg = msg % 'triple'
                else:
                    msg = msg % 'single'
                syntax_error(msg, start_tok)

            # Parse the quoted string.
            #
            # The four combinations are:
            #  "ur"  - raw_unicode_escape
            #  "u"   - unicode_escape
            #  "r"   - no need to do anything
            #  ""    - string_escape
            s = "".join(tok.value for tok in string_toks)
            quote_type = start_tok.value.lower()
            if quote_type == "":
                s = s.decode("string_escape")
            elif quote_type == "u":
                s = s.decode("unicode_escape")
            elif quote_type == "ur":
                s = s.decode("raw_unicode_escape")
            elif quote_type == "r":
                s = s
            else:
                msg = 'Unknown string quote type: %r' % quote_type
                raise AssertionError(msg)

            start_tok.type = "STRING"
            start_tok.value = s

            yield start_tok

    # Keep track of indentation state
    #
    # I implemented INDENT / DEDENT generation as a post-processing filter
    #
    # The original lex token stream contains WS and NEWLINE characters.
    # WS will only occur before any other tokens on a line.
    #
    # I have three filters.  One tags tokens by adding two attributes.
    # "must_indent" is True if the token must be indented from the
    # previous code.  The other is "at_line_start" which is True for WS
    # and the first non-WS/non-NEWLINE on a line.  It flags the check to
    # see if the new line has changed indication level.
    #
    # Python's syntax has three INDENT states
    #  0) no colon hence no need to indent
    #  1) "if 1: go()" - simple statements have a COLON but no need for an indent
    #  2) "if 1:\n  go()" - complex statements have a COLON NEWLINE and must indent
    # 
    # We only care about whitespace at the start of a line
    def annotate_indentation_state(self, token_stream):
        NO_INDENT = 0
        MAY_INDENT = 1
        MUST_INDENT = 2
        
        self.at_line_start = at_line_start = True
        indent = NO_INDENT
        
        for token in token_stream:
            token.at_line_start = at_line_start

            # The double colon serves double purpose: in slice operations
            # and also as the notification operator. In the case of a 
            # slice operation, newline continuation is already allowed
            # by suppressing NEWLINE tokens in a multiline expression.
            # So, we can treat double colon the same as colon here for
            # handling the logic surrounding indentation state.
            if token.type in ("COLON", "DOUBLECOLON"):
                at_line_start = False
                indent = MAY_INDENT
                token.must_indent = False
            
            elif token.type == "NEWLINE":
                at_line_start = True
                if indent == MAY_INDENT:
                    indent = MUST_INDENT
                token.must_indent = False

            elif token.type == "WS":
                assert token.at_line_start == True
                at_line_start = True
                token.must_indent = False

            else:
                # A real token; only indent after COLON NEWLINE
                if indent == MUST_INDENT:
                    token.must_indent = True
                else:
                    token.must_indent = False
                at_line_start = False
                indent = NO_INDENT

            yield token
            self.at_line_start = at_line_start

    def synthesize_indentation_tokens(self, token_stream):
        # A stack of indentation levels; will never pop item 0
        levels = [0]
        depth = 0
        prev_was_ws = False

        # In case the token stream is empty for a completely
        # empty file.
        token = None

        for token in token_stream:
            # WS only occurs at the start of the line
            # There may be WS followed by NEWLINE so
            # only track the depth here.  Don't indent/dedent
            # until there's something real.
            if token.type == 'WS':
                assert depth == 0
                depth = len(token.value)
                prev_was_ws = True
                # WS tokens are never passed to the parser
                continue

            if token.type == 'NEWLINE':
                depth = 0
                if prev_was_ws or token.at_line_start:
                    # ignore blank lines
                    continue
                # pass the other cases on through
                yield token
                continue
            
            # then it must be a real token (not WS, not NEWLINE)
            # which can affect the indentation level
            prev_was_ws = False

            if token.must_indent:
                # The current depth must be larger than the previous level
                if not (depth > levels[-1]):
                    indentation_error('expected an indented block', token)
                levels.append(depth)
                yield self.indent(token.lineno)

            elif token.at_line_start:
                # Must be on the same level or one of the previous levels
                if depth == levels[-1]:
                    # At the same level
                    pass
                elif depth > levels[-1]:
                    # indentation increase but not in new block
                    indentation_error('unexpected indent', token)
                else:
                    # Back up; but only if it matches a previous level
                    try:
                        i = levels.index(depth)
                    except ValueError:
                        msg = ('unindent does not match any outer level '
                               'of indentation.')
                        indentation_error(msg, token)
                    for _ in range(i + 1, len(levels)):
                        yield self.dedent(token.lineno)
                        levels.pop()

            yield token

        # If the current token is WS (which is only emitted at the start
        # of a line), then the token before that was a newline unless
        # we're on line number 1. If that's the case, then we don't 
        # need another newline token.
        if token is None:
            yield self.newline(-1)
        elif token.type != 'NEWLINE':
            if token.type != 'WS' or token.lineno == 1:
                yield self.newline(-1)

        # Must dedent any remaining levels
        if len(levels) > 1:
            assert token is not None
            for _ in range(1, len(levels)):
                yield self.dedent(token.lineno)
        
    def add_endmarker(self, token_stream):
        for tok in token_stream:
            yield tok

        end_marker = lex.LexToken()
        end_marker.type = 'ENDMARKER'
        end_marker.value = None
        end_marker.lineno = -1
        end_marker.lexpos = -1
        end_marker.lexer = self.lexer
        yield end_marker


########NEW FILE########
__FILENAME__ = looper
#------------------------------------------------------------------------------
#  Copyright (c) 2013, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from collections import Iterable

from traits.api import Instance, Property, Tuple

from .declarative import scope_lookup
from .templated import Templated


class Looper(Templated):
    """ A templated object that repeats its templates over an iterable.

    The children of a `Looper` are used as a template when creating new
    objects for each item in the given `iterable`. Each iteration of the
    loop will be given an indenpendent scope which is the union of the
    outer scope and any identifiers created during the iteration. This
    scope will also contain `loop_index` and `loop_item` variables which
    are the index and value of the iterable, respectively.

    All items created by the looper will be added as children of the
    parent of the `Looper`. The `Looper` keeps ownership of all items
    it creates. When the iterable for the looper is changed, the old
    items will be destroyed.

    Creating a `Looper` without a parent is a programming error.

    """
    #: The iterable to use when creating the items for the looper.
    iterable = Instance(Iterable)

    #: A read-only property which returns the tuple of items created
    #: by the looper when it passes over the objects in the iterable.
    #: Each item in the tuple represents one iteration of the loop and
    #: is a tuple of the items generated during that iteration.
    items = Property(fget=lambda self: self._items, depends_on='_items')

    #: Private storage for the `items` property.
    _items = Tuple

    #--------------------------------------------------------------------------
    # Lifetime API
    #--------------------------------------------------------------------------
    def post_initialize(self):
        """ A reimplemented initialization method.

        This method will create and initialize the loop items using the
        looper templates to generate the items.

        """
        self._refresh_loop_items()
        super(Looper, self).post_initialize()

    def pre_destroy(self):
        """ A pre destroy handler.

        The looper will destroy all of its items, provided that the
        items are not already destroyed and the parent is not in the
        process of being destroyed.

        """
        super(Looper, self).pre_destroy()
        if len(self._items) > 0:
            parent = self.parent
            if not parent.is_destroying:
                with parent.children_event_context():
                    for iteration in self._items:
                        for item in iteration:
                            if not item.is_destroyed:
                                item.destroy()

    def post_destroy(self):
        """ A post destroy handler.

        The looper will release all references to items after it has
        been destroyed.

        """
        super(Looper, self).post_destroy()
        self.iterable = None
        self._items = ()

    #--------------------------------------------------------------------------
    # Private API
    #--------------------------------------------------------------------------
    def _iterable_changed(self):
        """ A private change handler for the `iterable` attribute.

        If the iterable changes while the looper is active, the loop
        items will be refreshed.

        """
        if self.is_active:
            self._refresh_loop_items()

    def _refresh_loop_items(self):
        """ A private method which refreshes the loop items.

        This method destroys the old items and creates and initializes
        the new items.

        """
        items = []
        iterable = self.iterable
        templates = self._templates

        if iterable is not None and len(templates) > 0:
            for loop_index, loop_item in enumerate(iterable):
                # Each template is a 3-tuple of identifiers, globals, and
                # list of description dicts. There will only typically be
                # one template, but more can exist if the looper was
                # subclassed via enamldef to provided default children.
                iteration = []
                for identifiers, f_globals, descriptions in templates:
                    # Each iteration of the loop gets a new scope which
                    # is the union of the existing scope and the loop
                    # variables. This also allows the loop children to
                    # add their own independent identifiers. The loop
                    # items are constructed with no parent since they
                    # are parented via `insert_children` later on.
                    scope = identifiers.copy()
                    scope['loop_index'] = loop_index
                    scope['loop_item'] = loop_item
                    for descr in descriptions:
                        cls = scope_lookup(descr['type'], f_globals, descr)
                        instance = cls()
                        with instance.children_event_context():
                            instance.populate(descr, scope, f_globals)
                        iteration.append(instance)
                items.append(tuple(iteration))

        old_items = self._items
        self._items = items = tuple(items)
        if len(old_items) > 0 or len(items) > 0:
            with self.parent.children_event_context():
                if len(old_items) > 0:
                    for iteration in old_items:
                        for old in iteration:
                            if not old.is_destroyed:
                                old.destroy()
                if len(items) > 0:
                    flat = sum(items, ())
                    self.parent.insert_children(self, flat)
                    for item in flat:
                        item.initialize()


########NEW FILE########
__FILENAME__ = messenger
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from traits.api import Instance, Uninitialized

from enaml.utils import LoopbackGuard

from .declarative import Declarative
from .object import Object


class PublishAttributeNotifier(object):
    """ A lightweight trait change notifier used by Messenger.

    """
    def __call__(self, obj, name, old, new):
        """ Called by traits to dispatch the notifier.

        """
        if old is not Uninitialized and name not in obj.loopback_guard:
            obj.send_action('set_' + name, {name: new})

    def equals(self, other):
        """ Compares this notifier against another for equality.

        """
        return False

# Only a single instance of PublishAttributeNotifier is needed.
PublishAttributeNotifier = PublishAttributeNotifier()


class ChildrenChangedTask(object):
    """ A task for posting a children changed event to a client.

    Instances of this class can be posted to the `batch_action_task`
    method of Object to send a 'children_changed' action to a client
    object. This task will ensure that new children are initialized
    and activated using session object of the provided parent.

    """
    def __init__(self, parent, event):
        """ Initialize a ChildrenChangedTask.

        Parameters
        ----------
        parent : Object
            The object to which the children event was posted.

        event : ChildrenEvent
            The children event posted to the parent.

        """
        self._parent = parent
        self._event = event

    def __call__(self):
        """ Create the content dictionary for the task.

        This method will also initialize and activate any new objects
        which were added to the parent.

        """
        event = self._event
        content = {}
        new_set = set(event.new)
        old_set = set(event.old)
        added = new_set - old_set
        removed = old_set - new_set
        for obj in added:
            if obj.is_inactive:
                obj.initialize()
        content['order'] = [
            c.object_id for c in event.new if isinstance(c, Messenger)
        ]
        content['removed'] = [
            c.object_id for c in removed if isinstance(c, Messenger)
        ]
        content['added'] = [
            c.snapshot() for c in added if isinstance(c, Messenger)
        ]
        session = self._parent.session
        for obj in added:
            if obj.is_initialized:
                obj.activate(session)
        return content


class Messenger(Declarative):
    """ A base class for creating messaging enabled Enaml objects.

    This is a Declarative subclass which provides convenient APIs for
    sharing state between a server-side Enaml object and a client-side
    implementation of that object.

    """
    #: A loopback guard which can be used to prevent a notification
    #: cycle when setting attributes from within an action handler.
    loopback_guard = Instance(LoopbackGuard, ())

    #--------------------------------------------------------------------------
    # Lifetime API
    #--------------------------------------------------------------------------
    def post_initialize(self):
        """ A reimplemented post initialization method.

        This method calls the `bind` method after calling the superclass
        class version.

        """
        super(Messenger, self).post_initialize()
        self.bind()

    def bind(self):
        """ Called during initialization pass to bind change handlers.

        This method is called at the end of widget initialization to
        provide a subclass the opportunity to setup any required change
        notification handlers for publishing their state to the client.

        """
        pass

    #--------------------------------------------------------------------------
    # Snapshot API
    #--------------------------------------------------------------------------
    def snapshot(self):
        """ Get a dictionary representation of the widget tree.

        This method can be called to get a dictionary representation of
        the current state of the widget tree which can be used by client
        side implementation to construct their own implementation tree.

        Returns
        -------
        result : dict
            A serializable dictionary representation of the widget tree
            from this widget down.

        """
        snap = {}
        snap['object_id'] = self.object_id
        snap['name'] = self.name
        snap['class'] = self.class_name()
        snap['bases'] = self.base_names()
        snap['children'] = [c.snapshot() for c in self.snap_children()]
        return snap

    def snap_children(self):
        """ Get an iterable of children to include in the snapshot.

        The default implementation returns the list of children which
        are instances of Messenger. Subclasses may reimplement this
        method if more control is needed.

        Returns
        -------
        result : list
            The list of children which are instances of Messenger.

        """
        return [c for c in self.children if isinstance(c, Messenger)]

    def class_name(self):
        """ Get the name of the class for this instance.

        Returns
        -------
        result : str
            The name of the class of this instance.

        """
        return type(self).__name__

    def base_names(self):
        """ Get the list of base class names for this instance.

        Returns
        -------
        result : list
            The list of string names for the base classes of this
            instance. The list starts with the parent class of this
            instance and terminates with Object.

        """
        names = []
        for base in type(self).mro()[1:]:
            names.append(base.__name__)
            if base is Object:
                break
        return names

    #--------------------------------------------------------------------------
    # Messaging Support
    #--------------------------------------------------------------------------
    def set_guarded(self, **attrs):
        """ Set attribute values from within a loopback guard.

        This is a convenience method provided for subclasses to set the
        values of attributes from within a loopback guard. This prevents
        the change from being published back to client and reduces the
        chances of getting hung in a feedback loop.

        Parameters
        ----------
        **attrs
            The attributes to set on the object from within a loopback
            guard context.

        """
        with self.loopback_guard(*attrs):
            for name, value in attrs.iteritems():
                setattr(self, name, value)

    def publish_attributes(self, *attrs):
        """ A convenience method provided for subclasses to publish
        attribute changes as actions to the client.

        The action name is created by prefixing 'set_' to the name of
        the changed attribute. This method is suitable for most cases
        of simple attribute publishing. More complex cases will need
        to implement their own dispatching handlers. The handler for
        the changes will only send the action message if the attribute
        name is not held by the loopback guard.

        Parameters
        ----------
        *attrs
            The string names of the attributes to publish to the client.
            The values of these attributes should be JSON serializable.
            More complex values should use their own dispatch handlers.

        """
        for attr in attrs:
            self.add_notifier(attr, PublishAttributeNotifier)

    def children_event(self, event):
        """ Handle a `ChildrenEvent` for the widget.

        If the widget state is 'active', a `children_changed` action
        will be sent to the client widget. The action is sent before
        the superclass' handler is called, and will therefore precede
        the trait change notification.

        """
        super(Messenger, self).children_event(event)
        # Children events are fired all the time during initialization,
        # so only batch the children task if the widget is activated.
        # The children may not be fully instantiated when this event is
        # fired, and they may still be executing their constructor. The
        # batched task allows the children to finish initializing before
        # their snapshot is taken.
        if self.is_active:
            task = ChildrenChangedTask(self, event)
            self.batch_action_task('children_changed', task)


########NEW FILE########
__FILENAME__ = object
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from collections import defaultdict, deque, namedtuple
import logging
import re

from traits.api import (
    HasStrictTraits, Disallow, Property, Str, Enum, ReadOnly, Any,
)

from enaml.utils import make_dispatcher, id_generator

from .trait_types import EnamlEvent


logger = logging.getLogger(__name__)


#: The dispatch function for action dispatching.
dispatch_action = make_dispatcher('on_action_', logger)


#: A namedtuple which contains information about a child change event.
#: The `old` slot will be the ordered list of old children. The `new`
#: slot will be the ordered list of new children.
ChildrenEvent = namedtuple('ChildrenEvent', 'old new')


#: A namedtuple which contains information about a parent change event.
#: The `old` slot will be the old parent and the `new` slot will be
#: the new parent.
ParentEvent = namedtuple('ParentEvent', 'old new')


#: The identifier generator for object instances.
object_id_generator = id_generator('o_')


class ChildrenEventContext(object):
    """ A context manager which will emit a child event on an Object.

    This context manager will automatically emit the child event on an
    Object when the context is exited. This context manager can also be
    safetly nested; only the top-level context for a given object will
    emit the child event, effectively collapsing all transient state.

    """
    #: Class level storage for tracking nested context managers.
    _counters = defaultdict(int)

    def __init__(self, parent):
        """ Initialize a ChildrenEventContext.

        Parameters
        ----------
        parent : Object or None
            The Object on which to emit a child event on context exit.
            To make it easier for reparenting operations, the parent
            can be None.

        """
        self._parent = parent

    def __enter__(self):
        """ Enter the children event context.

        This method will snap the current child state of the parent and
        use it to diff the state on context exit.

        """
        parent = self._parent
        counters = self._counters
        count = counters[parent]
        counters[parent] = count + 1
        if count == 0 and parent is not None:
            self._old = parent._children

    def __exit__(self, exc_type, exc_value, traceback):
        """ Exit the children event context.

        If this context manager is the top-level manager for the parent
        object *and* no exception occured in the context, then a child
        event will be emitted on the parent. Any exception raised during
        the context is propagated.

        """
        parent = self._parent
        counters = self._counters
        counters[parent] -= 1
        if counters[parent] == 0:
            del counters[parent]
            if exc_type is None and parent is not None:
                old = self._old
                new = parent._children
                if old != new:
                    evt = ChildrenEvent(old, new)
                    parent.children_event(evt)


class Object(HasStrictTraits):
    """ The most base class of the Enaml object hierarchy.

    An Enaml Object provides supports parent-children relationships and
    provides facilities for initializing, navigating, searching, and
    destroying the tree. It also contains methods for sending messages
    between objects when the object is part of a session.

    """
    #: An optional name to give to this object to assist in finding it
    #: in the tree (see . the 'find' method. Note that there is no
    #: guarantee of uniqueness for an object `name`. It is left to the
    #: developer to choose an appropriate name.
    name = Str

    #: A read-only property which returns the object's parent. This
    #: will be an instance Object or None if there is no parent. A
    #: strong reference is kept to the parent object.
    parent = Property(fget=lambda self: self._parent)

    #: A read-only property which returns the objects children. This
    #: will be an iterable of Object instances. A strong reference is
    #: kept to all child objects.
    children = Property(fget=lambda self: self._children)

    #: An event fired when an the oject has been initialized. It is
    #: emitted once during an object's lifetime, when the object is
    #: initialized by a Session.
    initialized = EnamlEvent

    #: An event fired when an object has been activated. It is emitted
    #: once during an object's lifetime, when the object is activated
    #: by a Session.
    activated = EnamlEvent

    #: An event fired when an object is being destroyed. This event
    #: is fired once during the object lifetime, just before the
    #: object is removed from the tree structure.
    destroyed = EnamlEvent

    #: A read-only property which returns the object's session. This
    #: will be an instance of Session or None if there is no session.
    #: A strong reference is kept to the session object. This value
    #: should not be manipulated by user code.
    session = Property(fget=lambda self: self._session)

    #: A read-only value which returns the object's identifier. This
    #: will be computed the first time it is requested. The default
    #: value is guaranteed to be unique for the current process. The
    #: initial value may be supplied by user code if more control is
    #: required, with proper care that the value is a unique string.
    object_id = ReadOnly
    def _object_id_default(self):
        return object_id_generator.next()

    #: The current state of the object in terms of its lifetime within
    #: a session. This value should not be manipulated by user code.
    state = Enum(
        'inactive', 'initializing', 'initialized', 'activating', 'active',
        'destroying', 'destroyed',
    )

    #: A read-only property which is True if the object is inactive.
    is_inactive = Property(fget=lambda self: self.state == 'inactive')

    #: A read-only property which is True if the object is initializing.
    is_initializing = Property(fget=lambda self: self.state == 'initializing')

    #: A read-only property which is True if the object is initialized.
    is_initialized = Property(fget=lambda self: self.state == 'initialized')

    #: A read-only property which is True if the object is activating.
    is_activating = Property(fget=lambda self: self.state == 'activating')

    #: A read-only property which is True if the object is active.
    is_active = Property(fget=lambda self: self.state == 'active')

    #: A read-only property which is True if the object is destroying.
    is_destroying = Property(fget=lambda self: self.state == 'destroying')

    #: A read-only property which is True if the object is destroyed.
    is_destroyed = Property(fget=lambda self: self.state == 'destroyed')

    #: Private storage traits. These should *never* be manipulated by
    #: user code. For performance reasons, these are not type-checked.
    _parent = Any       # Object or None
    _children = Any     # tuple of Object
    _session = Any      # Session or None

    def __init__(self, parent=None, **kwargs):
        """ Initialize an Object.

        Parameters
        ----------
        parent : Object or None, optional
            The Object instance which is the parent of this object, or
            None if the object has no parent. Defaults to None.

        **kwargs
            Additional keyword arguments to apply to the object after
            the parent has been set.

        """
        super(Object, self).__init__()
        self._parent = None
        self._children = ()
        if parent is not None:
            self.set_parent(parent)
        if kwargs:
            # `trait_set` is slow, don't use it here.
            for key, value in kwargs.iteritems():
                setattr(self, key, value)

    #--------------------------------------------------------------------------
    # Lifetime API
    #--------------------------------------------------------------------------
    def initialize(self):
        """ Called by a Session to initialize the object tree.

        This method is called by a Session object to allow the object
        tree to perform initialization before the object is activated
        for messaging.

        """
        self.state = 'initializing'
        self.pre_initialize()
        for child in self.children:
            child.initialize()
        self.state = 'initialized'
        self.post_initialize()

    def pre_initialize(self):
        """ Called during the initialization pass before any children
        are initialized.

        The object `state` during this call will be 'initializing'.

        """
        pass

    def post_initialize(self):
        """ Called during the initialization pass after all children
        have been initialized.

        The object `state` during this call will be 'initialized'. The
        default implementation of this method emits the `initialized`
        event.

        """
        self.initialized()

    def activate(self, session):
        """ Called by a Session to activate the object tree.

        This method is called by a Session object to activate the object
        tree for messaging.

        Parameters
        ----------
        session : Session
            The session to use for messaging with this object tree.

        """
        self.state = 'activating'
        self.pre_activate(session)
        self._session = session
        session.register(self)
        for child in self._children:
            child.activate(session)
        self.state = 'active'
        self.post_activate(session)

    def pre_activate(self, session):
        """ Called during the activation pass before any children are
        activated.

        The object `state` during this call will be 'activating'.

        Parameters
        ----------
        session : Session
            The session to use for messaging with this object tree.

        """
        pass

    def post_activate(self, session):
        """ Called during the activation pass after all children are
        activated.

        The object `state` during this call will be 'active'. The
        default implementation emits the `activated` event.

        Parameters
        ----------
        session : Session
            The session to use for messaging with this object tree.

        """
        self.activated()

    def destroy(self):
        """ Destroy this object and all of its children recursively.

        This will emit the `destroyed` event before any change to the
        object tree is made. After this returns, the object should be
        considered invalid and should no longer be used.

        """
        # Only send the destroy message if the object's parent is not
        # being destroyed. This reduces the number of messages since
        # the automatic destruction of children is assumed.
        parent = self._parent
        if parent is None or not parent.is_destroying:
            self.batch_action('destroy', {})
        self.state = 'destroying'
        self.pre_destroy()
        if self._children:
            for child in self._children:
                child.destroy()
            self._children = ()
        if parent is not None:
            if parent.is_destroying:
                self._parent = None
            else:
                self.set_parent(None)
        session = self._session
        if session is not None:
            session.unregister(self)
        self.state = 'destroyed'
        self.post_destroy()

    def pre_destroy(self):
        """ Called during the destruction pass before any children are
        destroyed.

        The object `state` during this call will be 'destroying'. The
        default implementation emits the `destroyed` event.

        """
        self.destroyed()

    def post_destroy(self):
        """ Called during the destruction pass after all children are
        destroyed.

        The object `state` during this call will be 'destroyed'. This
        allows subclasses to perform cleanup once the object has been
        fully removed from the hierarchy.

        """
        pass

    #--------------------------------------------------------------------------
    # Parenting API
    #--------------------------------------------------------------------------
    def set_parent(self, parent):
        """ Set the parent for this object.

        If the parent is not None, the child will be appended to the end
        of the parent's children. If the parent is already the parent of
        this object, then this method is a no-op. If this object already
        has a parent, then it will be properly reparented.

        Parameters
        ----------
        parent : Object or None
            The Object instance to use for the parent, or None if this
            object should be unparented.

        Notes
        -----
        It is the responsibility of the caller to initialize and activate
        the object as needed, if it is reparented dynamically at runtime.

        """
        old_parent = self._parent
        if parent is old_parent:
            return
        if parent is self:
            raise ValueError('cannot use `self` as Object parent')
        if parent is not None and not isinstance(parent, Object):
            raise TypeError('parent must be an Object or None')
        self._parent = parent
        self.parent_event(ParentEvent(old_parent, parent))
        if old_parent is not None:
            old_kids = old_parent._children
            idx = old_kids.index(self)
            with old_parent.children_event_context():
                old_parent._children = old_kids[:idx] + old_kids[idx + 1:]
        if parent is not None:
            with parent.children_event_context():
                parent._children += (self,)

    def insert_children(self, before, insert):
        """ Insert children into this object at the given location.

        The children will be automatically parented and inserted into
        the object's children. If any children are already children of
        this object, then they will be moved appropriately.

        Parameters
        ----------
        before : Object or None
            A child object to use as the marker for inserting the new
            children. The new children will be inserted directly before
            this marker. If the Object is None or not a child, then the
            new children will be added to the end of the children.

        insert : iterable
            An iterable of Object children to insert into this object.

        Notes
        -----
        It is the responsibility of the caller to initialize and activate
        the object as needed, if it is reparented dynamically at runtime.

        """
        insert_tup = tuple(insert)
        insert_set = set(insert_tup)
        if self in insert_set:
            raise ValueError('cannot use `self` as Object child')
        if len(insert_tup) != len(insert_set):
            raise ValueError('cannot insert duplicate children')
        if not all(isinstance(child, Object) for child in insert_tup):
            raise TypeError('children must be an Object instances')

        new = []
        added = False
        for child in self._children:
            if child in insert_set:
                continue
            if child is before:
                new.extend(insert_tup)
                added = True
            new.append(child)
        if not added:
            new.extend(insert_tup)

        for child in insert_tup:
            old_parent = child._parent
            if old_parent is not self:
                child._parent = self
                child.parent_event(ParentEvent(old_parent, self))
                if old_parent is not None:
                    old_kids = old_parent._children
                    idx = old_kids.index(child)
                    old_kids = old_kids[:idx] + old_kids[idx + 1:]
                    with old_parent.children_event_context():
                        old_parent._children = old_kids

        with self.children_event_context():
            self._children = tuple(new)

    def parent_event(self, event):
        """ Handle a `ParentEvent` posted to this object.

        This event handler is called when the parent on the object has
        changed, but before the children of the new parent have been
        updated. There is no guarantee that the parent has been fully
        initialized when this is called. Sublasses may reimplement this
        method as required. The default implementation emits the trait
        change notification, so subclasses which override the default
        must be sure to call the superclass version, or emit the trait
        change themselves.

        Parameters
        ----------
        event : ParentEvent
            The event for the parent change of this object.

        """
        self.trait_property_changed('parent', event.old, event.new)

    def children_event(self, event):
        """ Handle a `ChildrenEvent` posted to this object.

        This event handler is called by a `ChildrenEventContext` when
        the last nested context is exited. There is no guarantee that
        the children will be fully initialized when this is called.
        Sublasses may reimplement this method as required. The default
        implementation emits the trait change notification, so
        subclasses which override the default must be sure to call the
        superclass version, or emit the trait change themselves.

        Parameters
        ----------
        event : ChildrenEvent
            The event for the children change of this object.

        """
        self.trait_property_changed('children', event.old, event.new)

    def children_event_context(self):
        """ Get a context manager for sending children events.

        This method should be called and entered whenever the children
        of an object are changed. The returned context manager will
        collapse all nested changes into a single aggregate event.

        Returns
        -------
        result : ChildrenEventContext
            The context manager which should be entered before changing
            the children of the object.

        """
        return ChildrenEventContext(self)

    #--------------------------------------------------------------------------
    # Messaging API
    #--------------------------------------------------------------------------
    def send_action(self, action, content):
        """ Send an action to the client of this object.

        The action will only be sent if the current state of the object
        is `active`. Subclasses may reimplement this method if more
        control is needed.

        Parameters
        ----------
        action : str
            The name of the action which the client should perform.

        content : dict
            The content data for the action.

        """
        if self.is_active:
            self._session.send(self.object_id, action, content)

    def batch_action(self, action, content):
        """ Batch an action to be sent to the client at a later time.

        The action will only be batched if the current state of the
        object is `active`. Subclasses may reimplement this method
        if more control is needed.

        Parameters
        ----------
        action : str
            The name of the action which the client should perform.

        content : dict
            The content data for the action.

        """
        if self.is_active:
            self._session.batch(self.object_id, action, content)

    def batch_action_task(self, action, task):
        """ Similar to `batch_action` but takes a callable task.

        The task will only be batched if the current state of the
        object is `active`. Subclasses may reimplement this method
        if more control is needed.

        Parameters
        ----------
        action : str
            The name of the action which the client should perform.

        task : callable
            A callable which will be invoked at a later time. It must
            return the content dictionary for the action.

        """
        if self.is_active:
            self._session.batch_task(self.object_id, action, task)

    def receive_action(self, action, content):
        """ Receive an action from the client of this object.

        The default implementation will dynamically dispatch the action
        to specially named handlers if the current state of the object
        is 'active'. Subclasses may reimplement this method if more
        control is needed.

        Parameters
        ----------
        action : str
            The name of the action to perform.

        content : dict
            The content data for the action.

        """
        if self.is_active:
            dispatch_action(self, action, content)

    #--------------------------------------------------------------------------
    # Object Tree API
    #--------------------------------------------------------------------------
    def root_object(self):
        """ Get the root object for this hierarchy.

        Returns
        -------
        result : Object
            The top-most object in the hierarchy to which this object
            belongs.

        """
        obj = self
        while obj._parent is not None:
            obj = obj._parent
        return obj

    def traverse(self, depth_first=False):
        """ Yield all of the objects in the tree, from this object down.

        Parameters
        ----------
        depth_first : bool, optional
            If True, yield the nodes in depth first order. If False,
            yield the nodes in breadth first order. Defaults to False.

        """
        if depth_first:
            stack = [self]
            stack_pop = stack.pop
            stack_extend = stack.extend
        else:
            stack = deque([self])
            stack_pop = stack.popleft
            stack_extend = stack.extend
        while stack:
            obj = stack_pop()
            yield obj
            stack_extend(obj._children)

    def traverse_ancestors(self, root=None):
        """ Yield all of the objects in the tree, from this object up.

        Parameters
        ----------
        root : Object, optional
            The object at which to stop traversal. Defaults to None.

        """
        parent = self._parent
        while parent is not root and parent is not None:
            yield parent
            parent = parent._parent

    def find(self, name, regex=False):
        """ Find the first object in the subtree with the given name.

        This method will traverse the tree of objects, breadth first,
        from this object downward, looking for an object with the given
        name. The first object with the given name is returned, or None
        if no object is found with the given name.

        Parameters
        ----------
        name : string
            The name of the object for which to search.

        regex : bool, optional
            Whether the given name is a regex string which should be
            matched against the names of children instead of tested
            for equality. Defaults to False.

        Returns
        -------
        result : Object or None
            The first object found with the given name, or None if no
            object is found with the given name.

        """
        if regex:
            rgx = re.compile(name)
            match = lambda n: bool(rgx.match(n))
        else:
            match = lambda n: n == name
        for obj in self.traverse():
            if match(obj.name):
                return obj

    def find_all(self, name, regex=False):
        """ Find all objects in the subtree with the given name.

        This method will traverse the tree of objects, breadth first,
        from this object downward, looking for a objects with the given
        name. All of the objects with the given name are returned as a
        list.

        Parameters
        ----------
        name : string
            The name of the objects for which to search.

        regex : bool, optional
            Whether the given name is a regex string which should be
            matched against the names of objects instead of testing
            for equality. Defaults to False.

        Returns
        -------
        result : list of Object
            The list of objects found with the given name, or an empty
            list if no objects are found with the given name.

        """
        if regex:
            rgx = re.compile(name)
            match = lambda n: bool(rgx.match(n))
        else:
            match = lambda n: n == name
        res = []
        push = res.append
        for obj in self.traverse():
            if match(obj.name):
                push(obj)
        return res

    #--------------------------------------------------------------------------
    # HasTraits Fixes
    #--------------------------------------------------------------------------
    #: The HasTraits class defines a class attribute 'set' which is a
    #: deprecated alias for the 'trait_set' method. The problem is that
    #: having that as an attribute interferes with the ability of Enaml
    #: expressions to resolve the builtin 'set', since dynamic scoping
    #: takes precedence over builtins. This resets those ill-effects.
    set = Disallow

    def add_notifier(self, name, notifier):
        """ Add a notifier to a trait on the object.

        This is different from `on_trait_change` in that it allows the
        developer to provide the notifier object directly. This allows
        the possibility of more efficient notifier patterns.

        """
        self._trait(name, 2)._notifiers(1).append(notifier)


########NEW FILE########
__FILENAME__ = operators
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
""" The default Enaml operators.

The operator functions are called by the Enaml runtime to implement the
expression binding semantics of the Enaml operators. The functions are
passed a number of arguments in order to perform their work:

Parameters
----------
obj : Declarative
    The Declarative object which owns the expression which is being
    bound.

name : string
    The name of the attribute on the object which is being bound.

func : types.FunctionType
    A function with bytecode that has been patched by the Enaml compiler
    for semantics specific to the operator. The docs for each operator
    given a more complete description of this function, since it varies
    for each operator.

identifiers : dict
    The dictionary of identifiers available to the expression. This dict
    is shared amongst all expressions within a given lexical scope. It
    should therefore not be modified or copied since identifiers may
    continue to be added to this dict as runtime execution continues.

"""
from .expressions import (
    SimpleExpression, NotificationExpression, SubscriptionExpression,
    UpdateExpression, DelegationExpression
)


def op_simple(obj, name, func, identifiers):
    """ The default Enaml operator for `=` expressions.

    This operator binds an instance of SimpleExpression to the attribute
    on the object. The function takes no arguments and returns the value
    of the expression. It is patched for dynamic scoping and it should be
    invoked with `funchelper.call_func(...)`.

    """
    expr = SimpleExpression(func, identifiers)
    obj.bind_expression(name, expr)


def op_notify(obj, name, func, identifiers):
    """ The default Enaml operator for `::` expressions.

    This operator binds an instance of NotificationExpression to the
    attribute on the object. The function takes no arguments and will
    return None. It is patched for dynamic scoping and it should be
    invoked with `funchelper.call_func(...)`.

    """
    expr = NotificationExpression(func, identifiers)
    obj.bind_listener(name, expr)


def op_update(obj, name, func, identifiers):
    """ The default Enaml operator for `>>` expressions.

    This operator binds an instance of UpdateExpression to the attribute
    on the object. The function takes two arguments: a code inverter and
    the new value of the attribute, and returns None. It is patched for
    dynamic scoping and code inversion and it should be invoked with
    `funchelper.call_func(...)`.

    """
    expr = UpdateExpression(func, identifiers)
    obj.bind_listener(name, expr)


def op_subscribe(obj, name, func, identifiers):
    """ The default Enaml operator for `<<` expressions.

    This operator binds an instance of SubscriptionExpression to the
    attribute on the object. The function takes one argument: a code
    tracer, and returns the value of the expression. It is patched for
    dynamic scoping and code tracing and it should be invoked with
    `funchelper.call_func(...)`.

    """
    expr = SubscriptionExpression(func, identifiers)
    obj.bind_expression(name, expr)


def op_delegate(obj, name, func, identifiers):
    """ The default Enaml operator for `:=` expressions.

    This operator binds an instance of DelegationExpression to the
    attribute on the object. The semantics of the function are the same
    as that of `op_subscribe`. The function also has an attribute named
    `_update` which is a function implementing `op_update` semantics.
    Both functions should be invoked with `funchelper.call_func(...)`.
    In this fashion, `op_delegate` is the combination of `op_subscribe`
    and `op_update`.

    """
    expr = DelegationExpression(func, identifiers)
    obj.bind_expression(name, expr)
    obj.bind_listener(name, expr)


OPERATORS = {
    '__operator_Equal__': op_simple,
    '__operator_LessLess__': op_subscribe,
    '__operator_ColonEqual__': op_delegate,
    '__operator_ColonColon__': op_notify,
    '__operator_GreaterGreater__': op_update,
}


########NEW FILE########
__FILENAME__ = operator_context
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
class OperatorContext(dict):
    """ The Enaml operator context which provides the binding operators
    for Enaml components and a means by which developers can author
    custom operators.

    The OperatorContext is a dict subclass which is used by the Enaml
    runtime to lookup the operator functions required to bind an
    expression to an attribute of a component.

    """
    _stack_ = []

    _default_context_ = None

    @staticmethod
    def active_context():
        """ A staticmethod that returns the currently active operator
        context, or the default context if there is not active context.

        """
        stack = OperatorContext._stack_
        if not stack:
            ctxt = OperatorContext.default_context()
        else:
            ctxt = stack[-1]
        return ctxt

    @staticmethod
    def default_context():
        """ A staticmethod that returns the default operator context,
        creating one if necessary.

        """
        ctxt = OperatorContext._default_context_
        if ctxt is None:
            from enaml import default_operator_context
            ctxt = default_operator_context()
            OperatorContext._default_context_ = ctxt
        return ctxt 

    def __enter__(self):
        """ A context manager method that pushes this context onto the 
        active context stack.

        """
        OperatorContext._stack_.append(self)

    def __exit__(self, exc_type, exc_value, traceback):
        """ A context manager method that pops this context from the
        active context stack.

        """
        OperatorContext._stack_.pop()


########NEW FILE########
__FILENAME__ = parser
#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
import ast
import os

import ply.yacc as yacc

from . import enaml_ast
from .lexer import syntax_error, EnamlLexer, ParsingError


#------------------------------------------------------------------------------
# Parser Setup
#------------------------------------------------------------------------------
# Lexer tokens which need to be exposed to the parser
tokens = EnamlLexer.tokens


#------------------------------------------------------------------------------
# Parsing Helpers
#------------------------------------------------------------------------------
# Ast Context Singletons
Store = ast.Store()
Load = ast.Load()
Del = ast.Del()


# The translation table for expression operators
operator_table = {
    '=': 'Equal',
    '<': 'Less',
    '>': 'Greater',
    ':': 'Colon',
}


# The allowed ast node types for ast.Store contexts
context_allowed = set([
    ast.Attribute,
    ast.Subscript,
    ast.Name,
    ast.List,
    ast.Tuple,
])


# Python 2.6 compatibility. Transform set comprehension into set(generator)
try:
    SetComp = ast.SetComp
except AttributeError:
    def SetComp(elt, generators):
        gen = ast.GeneratorExp(elt=elt, generators=generators)
        call = ast.Call()
        call.func = ast.Name(id='set', ctx=Load)
        call.args = [gen]
        call.keywords = []
        call.starargs = None
        call.kwargs = None
        return call


# Python 2.6 compatibility. Transform dict comprehension into dict(generator)
try:
    DictComp = ast.DictComp
except AttributeError:
    def DictComp(key, value, generators):
        elt = ast.Tuple(elts=[key, value], ctx=Load)
        gen = ast.GeneratorExp(elt=elt, generators=generators)
        call = ast.Call()
        call.func = ast.Name(id='dict', ctx=Load)
        call.args = [gen]
        call.keywords = []
        call.starargs = None
        call.kwargs = None
        return call


# Python 2.6 compatibility. Transform set literal in set(list_literal)
try:
    Set = ast.Set
except AttributeError:
    def Set(elts):
        lst = ast.List(elts=elts, ctx=Load)
        call = ast.Call()
        call.func = ast.Name(id='set', ctx=Load)
        call.args = [lst]
        call.keywords = []
        call.starargs = None
        call.kwargs = None
        return call


# The disallowed ast node types for ast.Store contexts and
# the associated message tag for error reporting.
context_disallowed = {
    ast.Lambda: 'lambda',
    ast.Call: 'function call',
    ast.BoolOp: 'operator',
    ast.BinOp: 'operator',
    ast.UnaryOp: 'operator',
    ast.GeneratorExp: 'generator expression',
    ast.Yield: 'yield expression',
    ast.ListComp: 'list comprehension',
    SetComp: 'set comprehension',
    DictComp: 'dict comprehension',
    ast.Dict: 'literal',
    Set: 'literal',
    ast.Num: 'literal',
    ast.Str: 'literal',
    ast.Ellipsis: 'Ellipsis',
    ast.Compare: 'comparison',
    ast.IfExp: 'conditional expression',
}


# The node types allowed in aug assignment
aug_assign_allowed = set([
    ast.Name,
    ast.Attribute,
    ast.Subscript,
])


# The disallowed ast types on the rhs of a :: operator
notification_disallowed = {
    ast.FunctionDef: 'function definition',
    ast.ClassDef: 'class definition',
    ast.Yield: 'yield statement',
    ast.Return: 'return statement',
}


# A mapping of aug assignment operators to ast types
augassign_table = {
    '&=': ast.BitAnd(),
    '^=': ast.BitXor(),
    '//=': ast.FloorDiv(),
    '<<=': ast.LShift(),
    '-=': ast.Sub(),
    '%=': ast.Mod(),
    '+=': ast.Add(),
    '>>=': ast.RShift(),
    '/=': ast.Div(),
    '*=': ast.Mult(),
    '|=': ast.BitOr(),
    '**=': ast.Pow(),
}


class FakeToken(object):
    """ A fake token used to store the lexer before calling the
    syntax error functions.

    """
    def __init__(self, lexer, lineno):
        self.lexer = lexer
        self.lineno = lineno


def translate_operator(op):
    """ Converts a symbolic operator into a string of the form
    __operator_<name>__ where <name> is result of translating the
    symbolic operator using the operator_table.

    """
    op_table = operator_table
    name = ''.join(op_table[char] for char in op)
    return '__operator_%s__' % name


def set_context(node, ctx, p):
    """ Recursively sets the context of the node to the given context
    which should be Store or Del. If the node is not one of the allowed
    types for the context, an erro is raised with an appropriate message.

    """
    # XXX passing the yacc production object to raise the error
    # message is a bit flakey and gets things wrong occasionally
    # when there are blank lines around the error. We can do better.
    items = None
    err_msg = ''
    node_type = type(node)
    if node_type in context_allowed:
        node.ctx = ctx
        if ctx == Store:
            if node_type == ast.Tuple:
                if len(node.elts) == 0:
                    err_msg = '()'
                else:
                    items = node.elts
            elif node_type == ast.List:
                items = node.elts
    elif node_type in context_disallowed:
        err_msg = context_disallowed[node_type]
    else:
        msg = 'unexpected expression in assignment %d (line %d)'
        raise SystemError(msg % (node_type.__name__, node.lineno))

    if err_msg:
        m = 'assign to' if ctx == Store else 'delete'
        msg = "can't %s %s" % (m, err_msg)
        tok = FakeToken(p.lexer.lexer, p.lexer.lexer.lineno - 1)
        syntax_error(msg, tok)

    if items is not None:
        for item in items:
            set_context(item, ctx, p)


def ast_for_testlist(testlist):
    """ If the testlist is a list, returns an ast.Tuple with a Load
    context, otherwise returns the orginal node.

    """
    if isinstance(testlist, list):
        value = ast.Tuple()
        value.elts = testlist
        value.ctx = Load
    else:
        value = testlist
    return value


def ast_for_dotted_name(dotted_name):
    parts = dotted_name.split('.')
    name = ast.Name(id=parts.pop(0), ctx=Load)
    res = name
    for part in parts:
        attr = ast.Attribute()
        attr.value = res
        attr.attr = part
        attr.ctx = Load
        res = attr
    return res


# The nodes which can be inverted to form an assignable expression.
_INVERTABLE = (ast.Name, ast.Attribute, ast.Call, ast.Subscript)

def validate_invertable(node, lineno, p):
    """ Validates that its possible for the compiler to generated
    inversion code for the given ast node.

    Currently, code is invertable if the expression terminates with
    a node of the following types: Name, Attribute, Call, Subscript.

    Parameters
    ----------
    node : ast.AST
        The ast expression node to validate.

    lineno : int
        The line number of the declaration.

    p : Yacc Production
        The Ply object passed to the parser rule. This is used to
        extract the filename for syntax error reporting.

    """
    if not isinstance(node, _INVERTABLE):
        msg = "can't assign to expression of this form"
        syntax_error(msg, FakeToken(p.lexer.lexer, lineno))


def build_attr_declaration(kw, name, attr_type, default, lineno, p):
    """ Builds an ast node for an attr or event declaration.

    Parameters
    ----------
    kw : string
        The keyword used in the declaration. A syntax error is raised if
        this is not 'attr' or 'event'.

    name : string
        The name of the attribute or event being declared.

    attr_type : str or None
        The type being declared, or None if not using a type.

    default : AttributeBinding or None
        The default attribute binding or None if not supply the default.

    lineno : int
        The line number of the declaration.

    p : Yacc Production
        The Ply object passed to the parser rule. This is used to
        extract the filename for syntax error reporting.

    Returns
    -------
    result : AttributeDeclaration
        The Enaml AttributeDeclaration ast node.

    """
    if kw not in ('attr', 'event'):
        msg = "Expected keyword 'attr' or 'event', got '%s' instead." % kw
        syntax_error(msg, FakeToken(p.lexer.lexer, lineno))
    if kw == 'attr':
        res = enaml_ast.AttributeDeclaration(
            name, attr_type, default, False, lineno,
        )
    else:
        res = enaml_ast.AttributeDeclaration(
            name, attr_type, default, True, lineno,
        )
    return res


class CommaSeparatedList(object):
    """ A parsing helper to delineate a comma separated list.

    """
    def __init__(self, values=None):
        self.values = values or []


class GeneratorInfo(object):
    """ A parsing helper to delineate a generator body.

    """
    def __init__(self, elt=None, generators=None):
        self.elt = elt
        self.generators = generators or []


class Arguments(object):
    """ A parsing helper object to delineate call arguments.

    """
    def __init__(self, args=None, keywords=None, starargs=None, kwargs=None):
        self.args = args or []
        self.keywords = keywords or []
        self.starargs = starargs
        self.kwargs = kwargs


#==============================================================================
# Begin Parsing Rules
#==============================================================================

#------------------------------------------------------------------------------
# Enaml Module
#------------------------------------------------------------------------------
# These special rules to handle the variations of newline and endmarkers
# are because of the various lexer states that deal with python blocks
# and enaml code, as well as completely empty files.
def p_enaml1(p):
    ''' enaml : enaml_module NEWLINE ENDMARKER
              | enaml_module ENDMARKER '''
    p[0] = p[1]


def p_enaml2(p):
    ''' enaml : NEWLINE ENDMARKER
              | ENDMARKER '''
    p[0] = enaml_ast.Module([], -1)


def p_enaml_module(p):
    ''' enaml_module : enaml_module_body '''
    # Separate the Python statements from the declarations and
    # collect them into their node
    python_nodes = []
    body_nodes = []
    for item in p[1]:
        if isinstance(item, enaml_ast.Declaration):
            if python_nodes:
                mod = ast.Module(body=python_nodes)
                body_nodes.append(enaml_ast.Python(mod, -1))
                python_nodes = []
            body_nodes.append(item)
        else:
            python_nodes.append(item)
    if python_nodes:
        mod = ast.Module(body=python_nodes)
        body_nodes.append(enaml_ast.Python(mod, -1))
    p[0] = enaml_ast.Module(body_nodes, -1)


def p_enaml_module_body1(p):
    ''' enaml_module_body : enaml_module_body enaml_module_item '''
    p[0] = p[1] + [p[2]]


def p_enaml_module_body2(p):
    ''' enaml_module_body : enaml_module_item '''
    p[0] = [p[1]]


def p_enaml_module_item2(p):
    ''' enaml_module_item : declaration '''
    p[0] = p[1]


def p_enaml_module_item1(p):
    ''' enaml_module_item : stmt '''
    p[0] = p[1]


#------------------------------------------------------------------------------
# Declaration
#------------------------------------------------------------------------------
def p_declaration1(p):
    ''' declaration : ENAMLDEF NAME LPAR NAME RPAR COLON declaration_body '''
    doc, idn, items = p[7]
    p[0] = enaml_ast.Declaration(p[2], p[4], idn, doc, items, p.lineno(1))


def p_declaration2(p):
    ''' declaration : ENAMLDEF NAME LPAR NAME RPAR COLON PASS NEWLINE '''
    p[0] = enaml_ast.Declaration(p[2], p[4], None, '', [], p.lineno(1))


def p_declaration3(p):
    ''' declaration : ENAMLDEF NAME LPAR NAME RPAR COLON NAME COLON declaration_body '''
    lineno = p.lineno(1)
    doc, idn, items = p[9]
    if idn is not None:
        msg = 'multiple identifiers declared'
        syntax_error(msg, FakeToken(p.lexer.lexer, lineno))
    p[0] = enaml_ast.Declaration(p[2], p[4], p[7], doc, items, lineno)


def p_declaration4(p):
    ''' declaration : ENAMLDEF NAME LPAR NAME RPAR COLON NAME COLON PASS NEWLINE '''
    p[0] = enaml_ast.Declaration(p[2], p[4], p[7], '', [], p.lineno(1))


def p_declaration_body1(p):
    ''' declaration_body : NEWLINE INDENT declaration_body_items DEDENT '''
    # Filter out any pass statements
    items = filter(None, p[3])
    p[0] = ('', None, items)


def p_declaration_body2(p):
    ''' declaration_body : NEWLINE INDENT identifier DEDENT '''
    p[0] = ('', p[3], [])


def p_declaration_body3(p):
    ''' declaration_body : NEWLINE INDENT identifier declaration_body_items DEDENT '''
    # Filter out any pass statements
    items = filter(None, p[4])
    p[0] = ('', p[3], items)


def p_declaration_body4(p):
    ''' declaration_body : NEWLINE INDENT STRING NEWLINE declaration_body_items DEDENT '''
    # Filter out any pass statements
    items = filter(None, p[5])
    p[0] = (p[3], None, items)


def p_declaration_body5(p):
    ''' declaration_body : NEWLINE INDENT STRING NEWLINE identifier DEDENT '''
    p[0] = (p[3], p[5], [])


def p_declaration_body6(p):
    ''' declaration_body : NEWLINE INDENT STRING NEWLINE identifier declaration_body_items DEDENT '''
    # Filter out any pass statements
    items = filter(None, p[6])
    p[0] = (p[3], p[5], items)


def p_declaration_body_items1(p):
    ''' declaration_body_items : declaration_body_item '''
    p[0] = [p[1]]


def p_declaration_body_items2(p):
    ''' declaration_body_items : declaration_body_items declaration_body_item '''
    p[0] = p[1] + [p[2]]


def p_declaration_body_item1(p):
    ''' declaration_body_item : attribute_declaration '''
    p[0] = p[1]


def p_declaration_body_item2(p):
    ''' declaration_body_item : attribute_binding '''
    p[0] = p[1]


def p_declaration_body_item3(p):
    ''' declaration_body_item : instantiation '''
    p[0] = p[1]


def p_declaration_body_item4(p):
    ''' declaration_body_item : PASS NEWLINE '''
    p[0] = None


#------------------------------------------------------------------------------
# Attribute Declaration
#------------------------------------------------------------------------------
def p_attribute_declaration1(p):
    ''' attribute_declaration : NAME NAME NEWLINE '''
    p[0] = build_attr_declaration(p[1], p[2], None, None, p.lineno(1), p)


def p_attribute_declaration2(p):
    ''' attribute_declaration : NAME NAME COLON NAME NEWLINE '''
    p[0] = build_attr_declaration(p[1], p[2], p[4], None, p.lineno(1), p)


def p_attribute_declaration3(p):
    ''' attribute_declaration : NAME NAME binding '''
    lineno = p.lineno(1)
    name = p[2]
    binding = enaml_ast.AttributeBinding(name, p[3], lineno)
    p[0] = build_attr_declaration(p[1], name, None, binding, lineno, p)


def p_attribute_declaration4(p):
    ''' attribute_declaration : NAME NAME COLON NAME binding '''
    lineno = p.lineno(1)
    name = p[2]
    binding = enaml_ast.AttributeBinding(name, p[5], lineno)
    p[0] = build_attr_declaration(p[1], name, p[4], binding, lineno, p)


#------------------------------------------------------------------------------
# Identifier
#------------------------------------------------------------------------------
def p_identifier(p):
    ''' identifier : NAME COLON NAME NEWLINE '''
    lhs = p[1]
    if lhs != 'id':
        msg = "'id' required. Got '%s' instead." % lhs
        syntax_error(msg, FakeToken(p.lexer.lexer, p.lineno(1)))
    p[0] = p[3]


#------------------------------------------------------------------------------
# Instantiation
#------------------------------------------------------------------------------
def p_instantiation1(p):
    ''' instantiation : NAME COLON instantiation_body '''
    identifier, items = p[3]
    p[0] = enaml_ast.Instantiation(p[1], identifier, items, p.lineno(1))


def p_instantiation2(p):
    ''' instantiation : NAME COLON attribute_binding '''
    p[0] = enaml_ast.Instantiation(p[1], None, [p[3]], p.lineno(1))


def p_instantiation3(p):
    ''' instantiation : NAME COLON PASS NEWLINE '''
    p[0] = enaml_ast.Instantiation(p[1], None, [], p.lineno(1))


def p_instantiation4(p):
    ''' instantiation : NAME COLON NAME COLON instantiation_body '''
    identifier, items = p[5]
    if identifier is not None:
        msg = 'multiple identifiers declared'
        syntax_error(msg, FakeToken(p.lexer.lexer, p.lineno(1)))
    p[0] = enaml_ast.Instantiation(p[1], p[3], items, p.lineno(1))


def p_instantiation5(p):
    ''' instantiation : NAME COLON NAME COLON attribute_binding '''
    p[0] = enaml_ast.Instantiation(p[1], p[3], [p[5]], p.lineno(1))


def p_instantiation6(p):
    ''' instantiation : NAME COLON NAME COLON PASS NEWLINE '''
    p[0] = enaml_ast.Instantiation(p[1], p[3], [], p.lineno(1))


def p_instantiation_body1(p):
    ''' instantiation_body : NEWLINE INDENT instantiation_body_items DEDENT '''
    # Filter out any pass statements
    items = filter(None, p[3])
    p[0] = (None, items)


def p_instantiation_body2(p):
    ''' instantiation_body : NEWLINE INDENT identifier DEDENT '''
    p[0] = (p[3], [])


def p_instantiation_body3(p):
    ''' instantiation_body : NEWLINE INDENT identifier instantiation_body_items DEDENT '''
    # Filter out any pass statements
    items = filter(None, p[4])
    p[0] = (p[3], items)


def p_instantiation_body_items1(p):
    ''' instantiation_body_items : instantiation_body_item '''
    p[0] = [p[1]]


def p_instantiation_body_items2(p):
    ''' instantiation_body_items : instantiation_body_items instantiation_body_item '''
    p[0] = p[1] + [p[2]]


def p_instantiation_body_item1(p):
    ''' instantiation_body_item : instantiation '''
    p[0] = p[1]


def p_instantiation_body_item2(p):
    ''' instantiation_body_item : attribute_binding '''
    p[0] = p[1]


def p_instantiation_body_item3(p):
    ''' instantiation_body_item : PASS NEWLINE '''
    p[0] = None


#------------------------------------------------------------------------------
# Attribute Binding
#------------------------------------------------------------------------------
def p_attribute_binding(p):
    ''' attribute_binding : NAME binding '''
    p[0] = enaml_ast.AttributeBinding(p[1], p[2], p.lineno(1))


def p_binding1(p):
    ''' binding : EQUAL test NEWLINE
                | LEFTSHIFT test NEWLINE '''
    lineno = p.lineno(1)
    operator = translate_operator(p[1])
    expr = ast.Expression(body=p[2])
    expr.lineno = lineno
    ast.fix_missing_locations(expr)
    expr_node = enaml_ast.Python(expr, lineno)
    p[0] = enaml_ast.BoundExpression(operator, expr_node, lineno)


def p_binding2(p):
    ''' binding : COLONEQUAL test NEWLINE
                | RIGHTSHIFT test NEWLINE '''
    lineno = p.lineno(1)
    validate_invertable(p[2], lineno, p)
    operator = translate_operator(p[1])
    expr = ast.Expression(body=p[2])
    expr.lineno = lineno
    ast.fix_missing_locations(expr)
    expr_node = enaml_ast.Python(expr, lineno)
    p[0] = enaml_ast.BoundExpression(operator, expr_node, lineno)


def p_binding3(p):
    ''' binding : DOUBLECOLON suite '''
    lineno = p.lineno(1)
    operator = translate_operator(p[1])
    mod = ast.Module()
    mod.body = p[2]
    for item in ast.walk(mod):
        if type(item) in notification_disallowed:
            msg = '%s not allowed in a notification block'
            msg = msg % notification_disallowed[type(item)]
            syntax_error(msg, FakeToken(p.lexer.lexer, item.lineno))
    expr_node = enaml_ast.Python(mod, lineno)
    p[0] = enaml_ast.BoundExpression(operator, expr_node, lineno)


#------------------------------------------------------------------------------
# Python Grammar
#------------------------------------------------------------------------------
def p_suite1(p):
    ''' suite : simple_stmt '''
    # stmt may be a list of simple_stmt due to this piece of grammar:
    # simple_stmt: small_stmt (';' small_stmt)* [';'] NEWLINE
    stmt = p[1]
    if isinstance(stmt, list):
        res = stmt
    else:
        res = [stmt]
    p[0] = res


def p_suite2(p):
    ''' suite : NEWLINE INDENT stmt_list DEDENT '''
    p[0] = p[3]


def p_stmt_list1(p):
    ''' stmt_list : stmt stmt_list '''
    # stmt may be a list of simple_stmt due to this piece of grammar:
    # simple_stmt: small_stmt (';' small_stmt)* [';'] NEWLINE
    stmt = p[1]
    if isinstance(stmt, list):
        res = stmt + p[2]
    else:
        res = [stmt] + p[2]
    p[0] = res


def p_stmt_list2(p):
    ''' stmt_list : stmt '''
    # stmt may be a list of simple_stmt due to this piece of grammar:
    # simple_stmt: small_stmt (';' small_stmt)* [';'] NEWLINE
    stmt = p[1]
    if isinstance(stmt, list):
        res = stmt
    else:
        res = [stmt]
    p[0] = res


def p_stmt(p):
    ''' stmt : simple_stmt
             | compound_stmt '''
    p[0] = p[1]


def p_simple_stmt1(p):
    ''' simple_stmt : small_stmt NEWLINE '''
    stmt = p[1]
    stmt.lineno = p.lineno(2)
    ast.fix_missing_locations(stmt)
    p[0] = stmt


def p_simple_stmt2(p):
    ''' simple_stmt : small_stmt_list NEWLINE '''
    lineno = p.lineno(2)
    stmts = p[1]
    for stmt in stmts:
        stmt.lineno = lineno
        ast.fix_missing_locations(stmt)
    p[0] = stmts


def p_small_stmt_list1(p):
    ''' small_stmt_list : small_stmt SEMI '''
    p[0] = [p[1]]


def p_small_stmt_list2(p):
    ''' small_stmt_list : small_stmt small_stmt_list_list '''
    p[0] = [p[1]] + p[2]


def p_small_stmt_list3(p):
    ''' small_stmt_list : small_stmt small_stmt_list_list SEMI '''
    p[0] = [p[1]] + p[2]


def p_small_stmt_list_list1(p):
    ''' small_stmt_list_list : SEMI small_stmt '''
    p[0] = [p[2]]


def p_small_stmt_list_list2(p):
    ''' small_stmt_list_list : small_stmt_list_list SEMI small_stmt '''
    p[0] = p[1] + [p[3]]


def p_small_stmt1(p):
    ''' small_stmt : expr_stmt
                   | print_stmt
                   | del_stmt
                   | pass_stmt
                   | flow_stmt
                   | import_stmt
                   | global_stmt
                   | exec_stmt
                   | assert_stmt '''
    p[0] = p[1]


def p_print_stmt1(p):
    ''' print_stmt : PRINT '''
    prnt = ast.Print()
    prnt.dest = None
    prnt.values = []
    prnt.nl = True
    p[0] = prnt


def p_print_stmt2(p):
    ''' print_stmt : PRINT test '''
    prnt = ast.Print()
    prnt.dest = None
    prnt.values = [p[2]]
    prnt.nl = True
    p[0] = prnt


def p_print_stmt3(p):
    ''' print_stmt : PRINT print_list '''
    prnt = ast.Print()
    all_values = p[2]
    good_values = [item for item in all_values if item is not None]
    if all_values[-1] is None:
        nl = False
    else:
        nl = True
    prnt.dest = None
    prnt.values = good_values
    prnt.nl = nl
    p[0] = prnt


def p_print_stmt4(p):
    ''' print_stmt : PRINT RIGHTSHIFT test '''
    prnt = ast.Print()
    prnt.dest = p[3]
    prnt.values = []
    prnt.nl = True
    p[0] = prnt


def p_print_stmt5(p):
    ''' print_stmt : PRINT RIGHTSHIFT test COMMA test '''
    prnt = ast.Print()
    prnt.dest = p[3]
    prnt.values = [p[5]]
    prnt.nl = True
    p[0] = prnt


def p_print_stmt6(p):
    ''' print_stmt : PRINT RIGHTSHIFT test COMMA print_list '''
    prnt = ast.Print()
    all_values = p[5]
    good_values = [item for item in all_values if item is not None]
    if all_values[-1] is None:
        nl = False
    else:
        nl = True
    prnt.dest = p[3]
    prnt.values = good_values
    prnt.nl = nl
    p[0] = prnt


def p_print_list1(p):
    ''' print_list : test COMMA '''
    p[0] = [p[1], None]


def p_print_list2(p):
    ''' print_list : test print_list_list '''
    p[0] = [p[1]] + p[2]


def p_print_list3(p):
    ''' print_list : test print_list_list COMMA '''
    p[0] = [p[1]] + p[2] + [None]


def p_print_list_list1(p):
    ''' print_list_list : COMMA test '''
    p[0] = [p[2]]


def p_print_list_list2(p):
    ''' print_list_list : print_list_list COMMA test '''
    p[0] = p[1] + [p[3]]


def p_del_stmt(p):
    ''' del_stmt : DEL exprlist '''
    exprlist = p[2]
    set_context(exprlist, Del, p)
    del_stmt = ast.Delete()
    del_stmt.targets = [exprlist]
    p[0] = del_stmt


def p_pass_stmt(p):
    ''' pass_stmt : PASS '''
    pass_stmt = ast.Pass()
    pass_stmt.lineno = p.lineno(1)
    p[0] = pass_stmt


def p_flow_stmt(p):
    ''' flow_stmt : break_stmt
                  | continue_stmt
                  | return_stmt
                  | raise_stmt
                  | yield_stmt '''
    p[0] = p[1]


def p_break_stmt(p):
    ''' break_stmt : BREAK '''
    break_stmt = ast.Break()
    break_stmt.lineno = p.lineno(1)
    p[0] = break_stmt


def p_continue_stmt(p):
    ''' continue_stmt : CONTINUE '''
    continue_stmt = ast.Continue()
    continue_stmt.lineno = p.lineno(1)
    p[0] = continue_stmt


def p_return_stmt1(p):
    ''' return_stmt : RETURN '''
    ret = ast.Return()
    ret.value = None
    p[0] = ret


def p_return_stmt2(p):
    ''' return_stmt : RETURN testlist '''
    value = ast_for_testlist(p[2])
    ret = ast.Return()
    ret.value = value
    p[0] = ret


def p_raise_stmt1(p):
    ''' raise_stmt : RAISE '''
    raise_stmt = ast.Raise()
    raise_stmt.type = None
    raise_stmt.inst = None
    raise_stmt.tback = None
    p[0] = raise_stmt


def p_raise_stmt2(p):
    ''' raise_stmt : RAISE test '''
    raise_stmt = ast.Raise()
    raise_stmt.type = p[2]
    raise_stmt.inst = None
    raise_stmt.tback = None
    p[0] = raise_stmt


def p_raise_stmt3(p):
    ''' raise_stmt : RAISE test COMMA test '''
    raise_stmt = ast.Raise()
    raise_stmt.type = p[2]
    raise_stmt.inst = p[4]
    raise_stmt.tback = None
    p[0] = raise_stmt


def p_raise_stmt4(p):
    ''' raise_stmt : RAISE test COMMA test COMMA test '''
    raise_stmt = ast.Raise()
    raise_stmt.type = p[2]
    raise_stmt.inst = p[4]
    raise_stmt.tback = p[6]
    p[0] = raise_stmt


def p_yield_stmt(p):
    ''' yield_stmt : yield_expr '''
    p[0] = ast.Expr(value=p[1])


def p_yield_expr1(p):
    ''' yield_expr : YIELD '''
    p[0] = ast.Yield(value=None, lineno=p.lineno(1))


def p_yield_expr2(p):
    ''' yield_expr : YIELD testlist '''
    value = ast_for_testlist(p[2])
    p[0] = ast.Yield(value=value, lineno=p.lineno(1))


def p_global_stmt1(p):
    ''' global_stmt : GLOBAL NAME '''
    global_stmt = ast.Global()
    global_stmt.names = [p[2]]
    global_stmt.lineno = p.lineno(1)
    p[0] = global_stmt


def p_global_stmt2(p):
    ''' global_stmt : GLOBAL NAME globals_list '''
    global_stmt = ast.Global()
    global_stmt.names = [p[2]] + p[3]
    global_stmt.lineno = p.lineno(1)
    p[0] = global_stmt


def p_globals_list1(p):
    ''' globals_list : COMMA NAME globals_list '''
    p[0] = [p[2]] + p[3]


def p_globals_list2(p):
    ''' globals_list : COMMA NAME '''
    p[0] = [p[2]]


def p_exec_stmt1(p):
    ''' exec_stmt : EXEC expr '''
    exec_stmt = ast.Exec()
    exec_stmt.body = p[2]
    exec_stmt.globals = None
    exec_stmt.locals = None
    p[0] = exec_stmt


def p_exec_stmt2(p):
    ''' exec_stmt : EXEC expr IN test '''
    exec_stmt = ast.Exec()
    exec_stmt.body = p[2]
    exec_stmt.globals= p[4]
    exec_stmt.locals = None
    p[0] = exec_stmt


def p_exec_stmt3(p):
    ''' exec_stmt : EXEC expr IN test COMMA test '''
    exec_stmt = ast.Exec()
    exec_stmt.body = p[2]
    exec_stmt.globals = p[4]
    exec_stmt.locals = p[6]
    p[0] = exec_stmt


def p_assert_stmt1(p):
    ''' assert_stmt : ASSERT test '''
    assert_stmt = ast.Assert()
    assert_stmt.test = p[2]
    assert_stmt.msg = None
    p[0] = assert_stmt


def p_assert_stmt2(p):
    ''' assert_stmt : ASSERT test COMMA test '''
    assert_stmt = ast.Assert()
    assert_stmt.test = p[2]
    assert_stmt.msg = p[4]
    p[0] = assert_stmt


def p_expr_stmt1(p):
    ''' expr_stmt : testlist '''
    expr = ast.Expr()
    expr.value = ast_for_testlist(p[1])
    p[0] = expr


def p_expr_stmt2(p):
    ''' expr_stmt : testlist augassign testlist
                  | testlist augassign yield_expr '''
    op, lineno = p[2]
    lhs = ast_for_testlist(p[1])
    rhs = ast_for_testlist(p[3])
    set_context(lhs, Store, p)
    if type(lhs) not in aug_assign_allowed:
        msg = 'illegal expression for augmented assignment'
        syntax_error(msg, FakeToken(p.lexer.lexer, lineno))
    aug = ast.AugAssign()
    aug.target = lhs
    aug.value = rhs
    aug.op = op
    p[0] = aug


def p_expr_stmt3(p):
    ''' expr_stmt : testlist equal_list '''
    all_items = [p[1]] + p[2]
    targets = map(ast_for_testlist, all_items)
    value = targets.pop()
    for item in targets:
        if type(item) == ast.Yield:
            msg = "assignment to yield expression not possible"
            syntax_error(msg, FakeToken(p.lexer.lexer, item.lineno))
        set_context(item, Store, p)
    assg = ast.Assign()
    assg.targets = targets
    assg.value = value
    p[0] = assg


def p_augassign(p):
    ''' augassign : AMPEREQUAL
                  | CIRCUMFLEXEQUAL
                  | DOUBLESLASHEQUAL
                  | DOUBLESTAREQUAL
                  | LEFTSHIFTEQUAL
                  | MINUSEQUAL
                  | PERCENTEQUAL
                  | PLUSEQUAL
                  | RIGHTSHIFTEQUAL
                  | SLASHEQUAL
                  | STAREQUAL
                  | VBAREQUAL '''
    lineno = p.lineno(1)
    op = augassign_table[p[1]]
    p[0] = (op, lineno)


def p_equal_list1(p):
    ''' equal_list : EQUAL testlist
                   | EQUAL yield_expr '''
    p[0] = [p[2]]


def p_equal_list2(p):
    ''' equal_list : EQUAL testlist equal_list
                   | EQUAL yield_expr equal_list '''
    p[0] = [p[2]] + p[3]


def p_testlist1(p):
    ''' testlist : test '''
    p[0] = p[1]


def p_testlist2(p):
    ''' testlist : test COMMA '''
    p[0] = [p[1]]


def p_testlist3(p):
    ''' testlist : test testlist_list '''
    p[0] = [p[1]] + p[2]


def p_testlist4(p):
    ''' testlist : test testlist_list COMMA '''
    p[0] = [p[1]] + p[2]


def p_testlist_list1(p):
    ''' testlist_list : COMMA test '''
    p[0] = [p[2]]


def p_testlist_list2(p):
    ''' testlist_list : testlist_list COMMA test '''
    p[0] = p[1] + [p[3]]


def p_compound_stmt(p):
    ''' compound_stmt : if_stmt
                      | while_stmt
                      | for_stmt
                      | try_stmt
                      | with_stmt
                      | funcdef
                      | classdef
                      | decorated '''
    p[0] = p[1]


def p_if_stmt1(p):
    ''' if_stmt : IF test COLON suite '''
    if_stmt = ast.If()
    if_stmt.test = p[2]
    if_stmt.body = p[4]
    if_stmt.lineno = p.lineno(1)
    ast.fix_missing_locations(if_stmt)
    if_stmt.orelse = []
    p[0] = if_stmt


def p_if_stmt2(p):
    ''' if_stmt : IF test COLON suite elif_stmts '''
    if_stmt = ast.If()
    if_stmt.test = p[2]
    if_stmt.body = p[4]
    if_stmt.lineno = p.lineno(1)
    if_stmt.orelse = [p[5]]
    ast.fix_missing_locations(if_stmt)
    p[0] = if_stmt


def p_if_stmt3(p):
    ''' if_stmt : IF test COLON suite else_stmt '''
    if_stmt = ast.If()
    if_stmt.test = p[2]
    if_stmt.body = p[4]
    if_stmt.lineno = p.lineno(1)
    if_stmt.orelse = p[5]
    ast.fix_missing_locations(if_stmt)
    p[0] = if_stmt


def p_if_stmt4(p):
    ''' if_stmt : IF test COLON suite elif_stmts else_stmt '''
    if_stmt = ast.If()
    if_stmt.test = p[2]
    if_stmt.body = p[4]
    if_stmt.lineno = p.lineno(1)
    elif_stmt = p[5]
    if_stmt.orelse = [elif_stmt]
    else_stmt = p[6]
    while elif_stmt.orelse:
        elif_stmt = elif_stmt.orelse[0]
    elif_stmt.orelse = else_stmt
    ast.fix_missing_locations(if_stmt)
    p[0] = if_stmt


def p_elif_stmts1(p):
    ''' elif_stmts : elif_stmts elif_stmt '''
    elif_stmt = p[1]
    elif_stmt.orelse = [p[2]]
    p[0] = elif_stmt


def p_elif_stmts2(p):
   ''' elif_stmts : elif_stmt '''
   p[0] = p[1]


def p_elif_stmt(p):
    ''' elif_stmt : ELIF test COLON suite '''
    if_stmt = ast.If()
    if_stmt.test = p[2]
    if_stmt.body = p[4]
    if_stmt.lineno = p.lineno(1)
    if_stmt.orelse = []
    ast.fix_missing_locations(if_stmt)
    p[0] = if_stmt


def p_else_stmt(p):
    ''' else_stmt : ELSE COLON suite '''
    p[0] = p[3]


def p_while_stmt1(p):
    ''' while_stmt : WHILE test COLON suite '''
    while_stmt = ast.While()
    while_stmt.test = p[2]
    while_stmt.body = p[4]
    while_stmt.orelse = []
    while_stmt.lineno = p.lineno(1)
    ast.fix_missing_locations(while_stmt)
    p[0] = while_stmt


def p_while_stmt2(p):
    ''' while_stmt : WHILE test COLON suite ELSE COLON suite '''
    while_stmt = ast.While()
    while_stmt.test = p[2]
    while_stmt.body = p[4]
    while_stmt.orelse = p[7]
    while_stmt.lineno = p.lineno(1)
    ast.fix_missing_locations(while_stmt)
    p[0] = while_stmt


def p_for_stmt1(p):
    ''' for_stmt : FOR exprlist IN testlist COLON suite '''
    for_stmt = ast.For()
    target = p[2]
    set_context(target, Store, p)
    for_stmt.target = target
    for_stmt.iter = ast_for_testlist(p[4])
    for_stmt.body = p[6]
    for_stmt.orelse = []
    for_stmt.lineno = p.lineno(1)
    ast.fix_missing_locations(for_stmt)
    p[0] = for_stmt


def p_for_stmt2(p):
    ''' for_stmt : FOR exprlist IN testlist COLON suite ELSE COLON suite '''
    for_stmt = ast.For()
    target = p[2]
    set_context(target, Store, p)
    for_stmt.target = target
    for_stmt.iter = ast_for_testlist(p[4])
    for_stmt.body = p[6]
    for_stmt.orelse = p[9]
    for_stmt.lineno = p.lineno(1)
    ast.fix_missing_locations(for_stmt)
    p[0] = for_stmt


def p_try_stmt1(p):
    ''' try_stmt : TRY COLON suite FINALLY COLON suite '''
    try_finally = ast.TryFinally()
    try_finally.body = p[3]
    try_finally.finalbody = p[6]
    try_finally.lineno = p.lineno(1)
    ast.fix_missing_locations(try_finally)
    p[0] = try_finally


def p_try_stmt2(p):
    ''' try_stmt : TRY COLON suite except_clauses '''
    try_stmt = ast.TryExcept()
    try_stmt.body = p[3]
    try_stmt.handlers = p[4]
    try_stmt.orelse = []
    try_stmt.lineno = p.lineno(1)
    ast.fix_missing_locations(try_stmt)
    p[0] = try_stmt


def p_try_stmt3(p):
    ''' try_stmt : TRY COLON suite except_clauses ELSE COLON suite '''
    try_stmt = ast.TryExcept()
    try_stmt.body = p[3]
    try_stmt.handlers = p[4]
    try_stmt.orelse = p[7]
    try_stmt.lineno = p.lineno(1)
    ast.fix_missing_locations(try_stmt)
    p[0] = try_stmt


def p_try_stmt4(p):
    ''' try_stmt : TRY COLON suite except_clauses FINALLY COLON suite '''
    lineno = p.lineno(1)
    try_finally = ast.TryFinally()
    try_stmt = ast.TryExcept()
    try_stmt.body = p[3]
    try_stmt.handlers = p[4]
    try_stmt.orelse = []
    try_stmt.lineno = lineno
    ast.fix_missing_locations(try_stmt)
    try_finally.body = [try_stmt]
    try_finally.finalbody = p[7]
    try_finally.lineno = lineno
    ast.fix_missing_locations(try_finally)
    p[0] = try_finally


def p_try_stmt5(p):
    ''' try_stmt : TRY COLON suite except_clauses ELSE COLON suite FINALLY COLON suite '''
    lineno = p.lineno(1)
    try_finally = ast.TryFinally()
    try_stmt = ast.TryExcept()
    try_stmt.body = p[3]
    try_stmt.handlers = p[4]
    try_stmt.orelse = p[7]
    try_stmt.lineno = lineno
    ast.fix_missing_locations(try_stmt)
    try_finally.body = [try_stmt]
    try_finally.finalbody = p[10]
    try_finally.lineno = lineno
    ast.fix_missing_locations(try_finally)
    p[0] = try_finally


def p_except_clauses1(p):
    ''' except_clauses : except_clause except_clauses '''
    p[0] = [p[1]] + p[2]


def p_except_clauses2(p):
    ''' except_clauses : except_clause '''
    p[0] = [p[1]]


def p_except_clause1(p):
    ''' except_clause : EXCEPT COLON suite '''
    excpt = ast.ExceptHandler()
    excpt.type = None
    excpt.name = None
    excpt.body = p[3]
    excpt.lineno = p.lineno(1)
    ast.fix_missing_locations(excpt)
    p[0] = excpt


def p_except_clause2(p):
    ''' except_clause : EXCEPT test COLON suite '''
    excpt = ast.ExceptHandler()
    excpt.type = p[2]
    excpt.name = None
    excpt.body = p[4]
    excpt.lineno = p.lineno(1)
    ast.fix_missing_locations(excpt)
    p[0] = excpt


def p_except_clause3(p):
    ''' except_clause : EXCEPT test AS test COLON suite
                      | EXCEPT test COMMA test COLON suite '''
    excpt = ast.ExceptHandler()
    excpt.type = p[2]
    name = p[4]
    set_context(name, Store, p)
    excpt.name = name
    excpt.body = p[6]
    excpt.lineno = p.lineno(1)
    ast.fix_missing_locations(excpt)
    p[0] = excpt


def p_with_stmt1(p):
    ''' with_stmt : WITH with_item COLON suite '''
    with_stmt = ast.With()
    ctxt, opt_vars = p[2]
    with_stmt.context_expr = ctxt
    with_stmt.optional_vars = opt_vars
    with_stmt.body = p[4]
    with_stmt.lineno = p.lineno(1)
    ast.fix_missing_locations(with_stmt)
    p[0] = with_stmt


def p_with_stmt2(p):
    ''' with_stmt : WITH with_item with_item_list COLON suite '''
    with_stmt = ast.With()
    ctxt, opt_vars = p[2]
    with_stmt.context_expr = ctxt
    with_stmt.optional_vars = opt_vars
    root = with_stmt
    last = with_stmt
    for ctxt, opt_vars in p[3]:
        with_stmt = ast.With()
        with_stmt.context_expr = ctxt
        with_stmt.optional_vars = opt_vars
        last.body = [with_stmt]
        last = with_stmt
    last.body = p[5]
    root.lineno = p.lineno(1)
    ast.fix_missing_locations(root)
    p[0] = root


def p_with_item1(p):
    ''' with_item : test '''
    p[0] = (p[1], None)


def p_with_item2(p):
    ''' with_item : test AS expr '''
    expr = p[3]
    set_context(expr, Store, p)
    p[0] = (p[1], expr)


def p_with_item_list1(p):
    ''' with_item_list : COMMA with_item with_item_list '''
    p[0] = [p[2]] + p[3]


def p_with_item_list2(p):
    ''' with_item_list : COMMA with_item '''
    p[0]  = [p[2]]


def p_funcdef(p):
    ''' funcdef : DEF NAME parameters COLON suite '''
    funcdef = ast.FunctionDef()
    funcdef.name = p[2]
    funcdef.args = p[3]
    funcdef.body = p[5]
    funcdef.decorator_list = []
    funcdef.lineno = p.lineno(1)
    ast.fix_missing_locations(funcdef)
    p[0] = funcdef


def p_parameters1(p):
    ''' parameters : LPAR RPAR '''
    p[0] = ast.arguments(args=[], defaults=[], vararg=None, kwarg=None)


def p_parameters2(p):
    ''' parameters : LPAR varargslist RPAR '''
    p[0] = p[2]


def p_classdef1(p):
    ''' classdef : CLASS NAME COLON suite '''
    classdef = ast.ClassDef()
    classdef.name = p[2]
    classdef.bases = []
    classdef.body = p[4]
    classdef.decorator_list = []
    classdef.lineno = p.lineno(1)
    ast.fix_missing_locations(classdef)
    p[0] = classdef


def p_classdef2(p):
    ''' classdef : CLASS NAME LPAR RPAR COLON suite '''
    classdef = ast.ClassDef()
    classdef.name = p[2]
    classdef.bases = []
    classdef.body = p[6]
    classdef.decorator_list = []
    classdef.lineno = p.lineno(1)
    ast.fix_missing_locations(classdef)
    p[0] = classdef


def p_classdef3(p):
    ''' classdef : CLASS NAME LPAR testlist RPAR COLON suite '''
    classdef = ast.ClassDef()
    classdef.name = p[2]
    bases = p[4]
    if not isinstance(bases, list):
        bases = [bases]
    classdef.bases = bases
    classdef.body = p[7]
    classdef.decorator_list = []
    classdef.lineno = p.lineno(1)
    ast.fix_missing_locations(classdef)
    p[0] = classdef


def p_decorated(p):
    ''' decorated : decorators funcdef
                  | decorators classdef '''
    decs = p[1]
    target = p[2]
    target.decorator_list = decs
    p[0] = target


def p_decorators1(p):
    ''' decorators : decorator decorators '''
    p[0] = [p[1]] + p[2]


def p_decorators2(p):
    ''' decorators : decorator '''
    p[0] = [p[1]]


def p_decorator1(p):
    ''' decorator : AT dotted_name NEWLINE '''
    name = ast_for_dotted_name(p[2])
    name.lineno = p.lineno(1)
    ast.fix_missing_locations(name)
    p[0] = name


def p_decorator2(p):
    ''' decorator : AT dotted_name LPAR RPAR NEWLINE '''
    call = ast.Call()
    call.func = ast_for_dotted_name(p[2])
    call.args = []
    call.keywords = []
    call.stargs = None
    call.kwargs = None
    call.lineno = p.lineno(1)
    ast.fix_missing_locations(call)
    p[0] = call


def p_decorator3(p):
    ''' decorator : AT dotted_name LPAR arglist RPAR NEWLINE '''
    args = p[4]
    call = ast.Call()
    call.func = ast_for_dotted_name(p[2])
    call.args = args.args
    call.keywords = args.keywords
    call.starargs = args.starargs
    call.kwargs = args.kwargs
    call.lineno = p.lineno(1)
    ast.fix_missing_locations(call)
    p[0] = call


def p_import_stmt1(p):
    ''' import_stmt : import_name '''
    p[0] = p[1]


def p_import_stmt2(p):
    ''' import_stmt : import_from '''
    p[0] = p[1]

def p_import_name(p):
    ''' import_name : IMPORT dotted_as_names '''
    imprt = ast.Import(names=p[2])
    imprt.col_offset = 0
    p[0] = imprt


def p_import_from1(p):
    ''' import_from : FROM dotted_name IMPORT STAR '''
    alias = ast.alias(name=p[4], asname=None)
    imprt = ast.ImportFrom(module=p[2], names=[alias], level=0)
    imprt.col_offset = 0
    p[0] = imprt


def p_import_from2(p):
    ''' import_from : FROM dotted_name IMPORT import_as_names '''
    imprt = ast.ImportFrom(module=p[2], names=p[4], level=0)
    imprt.col_offset = 0
    p[0] = imprt


def p_import_from3(p):
    ''' import_from : FROM dotted_name IMPORT LPAR import_as_names RPAR '''
    imprt = ast.ImportFrom(module=p[2], names=p[5], level=0)
    imprt.col_offset = 0
    p[0] = imprt


def p_import_from4(p):
    ''' import_from : FROM import_from_dots dotted_name IMPORT STAR '''
    alias = ast.alias(name=p[5], asname=None)
    imprt = ast.ImportFrom(module=p[3], names=[alias], level=len(p[2]))
    imprt.col_offset = 0
    p[0] = imprt


def p_import_from5(p):
    ''' import_from : FROM import_from_dots dotted_name IMPORT import_as_name '''
    imprt = ast.ImportFrom(module=p[3], names=[p[5]], level=len(p[2]))
    imprt.col_offset = 0
    p[0] = imprt


def p_import_from6(p):
    ''' import_from : FROM import_from_dots dotted_name IMPORT LPAR import_as_names RPAR '''
    imprt = ast.ImportFrom(module=p[3], names=p[6], level=len(p[2]))
    imprt.col_offset = 0
    p[0] = imprt


def p_import_from7(p):
    ''' import_from : FROM import_from_dots IMPORT STAR '''
    alias = ast.alias(name=p[4], asname=None)
    imprt = ast.ImportFrom(module=None, names=[alias], level=len(p[2]))
    imprt.col_offset = 0
    p[0] = imprt


def p_import_from8(p):
    ''' import_from : FROM import_from_dots IMPORT import_as_names '''
    imprt = ast.ImportFrom(module=None, names=p[4], level=len(p[2]))
    imprt.col_offset = 0
    p[0] = imprt


def p_import_from9(p):
    ''' import_from : FROM import_from_dots IMPORT LPAR import_as_names RPAR '''
    imprt = ast.ImportFrom(module=None, names=p[5], level=len(p[2]))
    imprt.col_offset = 0
    p[0] = imprt


def p_import_from_dots1(p):
    ''' import_from_dots : DOT '''
    p[0] = [p[1]]


def p_import_from_dots2(p):
    ''' import_from_dots : import_from_dots DOT '''
    p[0] = p[1] + [p[2]]


def p_import_as_name1(p):
    ''' import_as_name : NAME '''
    p[0] = ast.alias(name=p[1], asname=None)


def p_import_as_name2(p):
    ''' import_as_name : NAME AS NAME '''
    p[0] = ast.alias(name=p[1], asname=p[3])


def p_dotted_as_name1(p):
    ''' dotted_as_name : dotted_name '''
    alias = ast.alias(name=p[1], asname=None)
    p[0] = alias


def p_dotted_as_name2(p):
    ''' dotted_as_name : dotted_name AS NAME '''
    alias = ast.alias(name=p[1], asname=p[3])
    p[0] = alias


def p_import_as_names1(p):
    ''' import_as_names : import_as_name '''
    p[0] = [p[1]]


def p_import_as_names2(p):
    ''' import_as_names : import_as_name COMMA '''
    p[0] = [p[1]]


def p_import_as_names3(p):
    ''' import_as_names : import_as_name import_as_names_list '''
    p[0] = [p[1]] + p[2]


def p_import_as_names4(p):
    ''' import_as_names : import_as_name import_as_names_list COMMA '''
    p[0] = [p[1]] + p[2]


def p_import_as_names_list1(p):
    ''' import_as_names_list : COMMA import_as_name '''
    p[0] = [p[2]]


def p_import_as_names_list2(p):
    ''' import_as_names_list : import_as_names_list COMMA import_as_name '''
    p[0] = p[1] + [p[3]]


def p_dotted_as_names1(p):
    ''' dotted_as_names : dotted_as_name '''
    p[0] = [p[1]]


def p_dotted_as_names2(p):
    ''' dotted_as_names : dotted_as_name dotted_as_names_list '''
    p[0] = [p[1]] + p[2]


def p_dotted_as_names_list1(p):
    ''' dotted_as_names_list : COMMA dotted_as_name '''
    p[0] = [p[2]]


def p_dotted_as_names_star_list2(p):
    ''' dotted_as_names_list : dotted_as_names_list COMMA dotted_as_name '''
    p[0] = p[1] + [p[3]]


def p_dotted_name1(p):
    ''' dotted_name : NAME '''
    p[0] = p[1]


def p_dotted_name2(p):
    ''' dotted_name : NAME dotted_name_list '''
    p[0] = p[1] + p[2]


def p_dotted_name_list1(p):
    ''' dotted_name_list : DOT NAME '''
    p[0] = p[1] + p[2]


def p_dotted_name_list2(p):
    ''' dotted_name_list : dotted_name_list DOT NAME '''
    p[0] = p[1] + p[2] + p[3]


def p_test1(p):
    ''' test : or_test '''
    p[0] = p[1]


def p_test2(p):
    ''' test : or_test IF or_test ELSE test '''
    ifexp = ast.IfExp(body=p[1], test=p[3], orelse=p[5])
    p[0] = ifexp


def p_test3(p):
    ''' test : lambdef '''
    p[0] = p[1]


def p_or_test1(p):
    ''' or_test : and_test '''
    p[0] = p[1]


def p_or_test2(p):
    ''' or_test : and_test or_test_list '''
    values = [p[1]] + p[2]
    or_node = ast.BoolOp(op=ast.Or(), values=values)
    p[0] = or_node


def p_or_test_list1(p):
    ''' or_test_list : OR and_test '''
    p[0] = [p[2]]


def p_or_test_list2(p):
    ''' or_test_list : or_test_list OR and_test '''
    p[0] = p[1] + [p[3]]


def p_and_test1(p):
    ''' and_test : not_test '''
    p[0] = p[1]


def p_and_test2(p):
    ''' and_test : not_test and_test_list '''
    values = [p[1]] + p[2]
    and_node = ast.BoolOp(op=ast.And(), values=values)
    p[0] = and_node


def p_and_test_list1(p):
    ''' and_test_list : AND not_test '''
    p[0] = [p[2]]


def p_and_test_list2(p):
    ''' and_test_list : and_test_list AND not_test '''
    p[0] = p[1] + [p[3]]


def p_not_test(p):
    ''' not_test : comparison '''
    p[0] = p[1]


def p_not_test2(p):
    ''' not_test : NOT not_test '''
    un_node = ast.UnaryOp(op=ast.Not(), operand=p[2])
    p[0] = un_node


def p_comparison1(p):
    ''' comparison : expr '''
    p[0] = p[1]


def p_comparison2(p):
    ''' comparison : expr comparison_list '''
    left = p[1]
    ops, comparators = zip(*p[2])
    cmpr = ast.Compare(left=left, ops=list(ops), comparators=list(comparators))
    p[0] = cmpr


def p_comparison_list1(p):
    ''' comparison_list : comp_op expr '''
    p[0] = [[p[1], p[2]]]


def p_comparison_list2(p):
    ''' comparison_list : comparison_list comp_op expr '''
    p[0] = p[1] + [[p[2], p[3]]]


def p_comp_op1(p):
    ''' comp_op : LESS '''
    p[0] = ast.Lt()


def p_comp_op2(p):
    ''' comp_op : GREATER '''
    p[0] = ast.Gt()


def p_comp_op3(p):
    ''' comp_op : EQEQUAL '''
    p[0] = ast.Eq()


def p_comp_op4(p):
    ''' comp_op : GREATEREQUAL '''
    p[0] = ast.GtE()


def p_comp_op5(p):
    ''' comp_op : LESSEQUAL '''
    p[0] = ast.LtE()


def p_comp_op6(p):
    ''' comp_op : NOTEQUAL '''
    p[0] = ast.NotEq()


def p_comp_op7(p):
    ''' comp_op : IN '''
    p[0] = ast.In()


def p_comp_op8(p):
    ''' comp_op : NOT IN '''
    p[0] = ast.NotIn()


def p_comp_op9(p):
    ''' comp_op : IS '''
    p[0] = ast.Is()


def p_comp_op10(p):
    ''' comp_op : IS NOT '''
    p[0] = ast.IsNot()


def p_expr1(p):
    ''' expr : xor_expr '''
    p[0] = p[1]


def p_expr2(p):
    ''' expr : xor_expr expr_list '''
    node = p[1]
    for op, right in p[2]:
        node = ast.BinOp(left=node, op=op, right=right)
    p[0] = node


def p_expr_list1(p):
    ''' expr_list : VBAR xor_expr '''
    p[0] = [[ast.BitOr(), p[2]]]


def p_expr_list2(p):
    ''' expr_list : expr_list VBAR xor_expr '''
    p[0] = p[1] + [[ast.BitOr(), p[3]]]


def p_xor_expr1(p):
    ''' xor_expr : and_expr '''
    p[0] = p[1]


def p_xor_expr2(p):
    ''' xor_expr : and_expr xor_expr_list '''
    node = p[1]
    for op, right in p[2]:
        node = ast.BinOp(left=node, op=op, right=right)
    p[0] = node


def p_xor_expr_list1(p):
    ''' xor_expr_list : CIRCUMFLEX and_expr '''
    p[0] = [[ast.BitXor(), p[1]]]


def p_xor_expr_list2(p):
    ''' xor_expr_list : xor_expr_list CIRCUMFLEX and_expr '''
    p[0] = p[1] + [[ast.BitXor(), p[3]]]


def p_and_expr1(p):
    ''' and_expr : shift_expr '''
    p[0] = p[1]


def p_and_expr2(p):
    ''' and_expr : shift_expr and_expr_list '''
    node = p[1]
    for op, right in p[2]:
        node = ast.BinOp(left=node, op=op, right=right)
    p[0] = node


def p_and_expr_list1(p):
    ''' and_expr_list : AMPER shift_expr '''
    p[0] = [[ast.BitAnd(), p[3]]]


def p_and_expr_list2(p):
    ''' and_expr_list : and_expr_list AMPER shift_expr '''
    p[0] = p[1] + [[ast.BitAnd(), p[3]]]


def p_shift_expr1(p):
    ''' shift_expr : arith_expr '''
    p[0] = p[1]


def p_shift_expr2(p):
    ''' shift_expr : arith_expr shift_list '''
    node = p[1]
    for op, right in p[2]:
        node = ast.BinOp(left=node, op=op, right=right)
    p[0] = node


def p_shift_list1(p):
    ''' shift_list : shift_op '''
    p[0] = [p[1]]


def p_shift_list2(p):
    ''' shift_list : shift_list shift_op '''
    p[0] = p[1] + [p[2]]


def p_shift_op1(p):
    ''' shift_op : LEFTSHIFT arith_expr '''
    p[0] = [ast.LShift(), p[2]]


def p_shift_op2(p):
    ''' shift_op : RIGHTSHIFT arith_expr '''
    p[0] = [ast.RShift(), p[2]]


def p_arith_expr1(p):
    ''' arith_expr : term '''
    p[0] = p[1]


def p_arith_expr2(p):
    ''' arith_expr : term arith_expr_list '''
    node = p[1]
    for op, right in p[2]:
        node = ast.BinOp(left=node, op=op, right=right)
    p[0] = node


def p_arith_expr_list1(p):
    ''' arith_expr_list : arith_op '''
    p[0] = [p[1]]


def p_arith_expr_list2(p):
    ''' arith_expr_list : arith_expr_list arith_op '''
    p[0] = p[1] + [p[2]]


def p_arith_op1(p):
    ''' arith_op : PLUS term '''
    node = ast.Add()
    p[0] = [node, p[2]]


def p_arith_op2(p):
    ''' arith_op : MINUS term '''
    p[0] = [ast.Sub(), p[2]]


def p_term1(p):
    ''' term : factor '''
    p[0] = p[1]


def p_term2(p):
    ''' term : factor term_list '''
    node = p[1]
    for op, right in p[2]:
        node = ast.BinOp(left=node, op=op, right=right)
    p[0] = node


def p_term_list1(p):
    ''' term_list : term_op '''
    p[0] = [p[1]]


def p_term_list2(p):
    ''' term_list : term_list term_op '''
    p[0] = p[1] + [p[2]]


def p_term_op1(p):
    ''' term_op : STAR factor '''
    p[0] = [ast.Mult(), p[2]]


def p_term_op2(p):
    ''' term_op : SLASH factor '''
    p[0] = [ast.Div(), p[2]]


def p_term_op3(p):
    ''' term_op : PERCENT factor '''
    p[0] = [ast.Mod(), p[2]]


def p_term_op4(p):
    ''' term_op : DOUBLESLASH factor '''
    p[0] = [ast.FloorDiv(), p[2]]


def p_factor1(p):
    ''' factor : power '''
    p[0] = p[1]


def p_factor2(p):
    ''' factor : PLUS factor '''
    op = ast.UAdd()
    operand = p[2]
    node = ast.UnaryOp(op=op, operand=operand)
    p[0] = node


def p_factor3(p):
    ''' factor : MINUS factor '''
    op = ast.USub()
    operand = p[2]
    node = ast.UnaryOp(op=op, operand=operand)
    p[0] = node


def p_factor4(p):
    ''' factor : TILDE factor '''
    op = ast.Invert()
    operand = p[2]
    node = ast.UnaryOp(op=op, operand=operand)
    p[0] = node


def p_power1(p):
    ''' power : atom '''
    p[0] = p[1]


def p_power2(p):
    ''' power : atom DOUBLESTAR factor '''
    node = ast.BinOp(left=p[1], op=ast.Pow(), right=p[3])
    p[0] = node


def p_power3(p):
    ''' power : atom power_list '''
    root = p[1]
    for node in p[2]:
        if isinstance(node, ast.Call):
            node.func = root
        elif isinstance(node, ast.Attribute):
            node.value = root
        elif isinstance(node, ast.Subscript):
            node.value = root
        else:
            raise TypeError('Unexpected trailer node: %s' % node)
        root = node
    p[0] = root


def p_power4(p):
    ''' power : atom power_list DOUBLESTAR factor '''
    root = p[1]
    for node in p[2]:
        if isinstance(node, ast.Call):
            node.func = root
        elif isinstance(node, ast.Attribute):
            node.value = root
        elif isinstance(node, ast.Subscript):
            node.value = root
        else:
            raise TypeError('Unexpected trailer node: %s' % node)
        root = node
    power = ast.BinOp(left=root, op=ast.Pow(), right=p[4])
    p[0] = power


def p_power_list1(p):
    ''' power_list : trailer '''
    p[0] = [p[1]]


def p_power_list2(p):
    ''' power_list : power_list trailer '''
    p[0] = p[1] + [p[2]]


def p_atom1(p):
    ''' atom : LPAR RPAR '''
    p[0] = ast.Tuple(elts=[], ctx=Load)


def p_atom2(p):
    ''' atom : LPAR yield_expr RPAR '''
    p[0] = p[2]


def p_atom3(p):
    ''' atom : LPAR testlist_comp RPAR '''
    info = p[2]
    if isinstance(info, CommaSeparatedList):
        node = ast.Tuple(elts=info.values, ctx=Load)
    elif isinstance(info, GeneratorInfo):
        node = ast.GeneratorExp(elt=info.elt, generators=info.generators)
    else:
        # We have a test node by itself in parenthesis controlling
        # order of operations, so just return the node.
        node = info
    p[0] = node


def p_atom4(p):
    ''' atom : LSQB RSQB '''
    p[0] = ast.List(elts=[], ctx=Load)


def p_atom5(p):
    ''' atom : LSQB listmaker RSQB '''
    info = p[2]
    if isinstance(info, CommaSeparatedList):
        node = ast.List(elts=info.values, ctx=Load)
    elif isinstance(info, GeneratorInfo):
        node = ast.ListComp(elt=info.elt, generators=info.generators)
    else:
        raise TypeError('Unexpected node for listmaker: %s' % info)
    p[0] = node


def p_atom6(p):
    ''' atom : LBRACE RBRACE '''
    p[0] = ast.Dict(keys=[], values=[])


def p_atom7(p):
    ''' atom : LBRACE dictorsetmaker RBRACE '''
    info = p[2]
    if isinstance(info, GeneratorInfo):
        if isinstance(info.elt, tuple):
            key, value = info.elt
            generators = info.generators
            node = DictComp(key=key, value=value, generators=generators)
        else:
            node = SetComp(elt=info.elt, generators=info.generators)
    elif isinstance(info, CommaSeparatedList):
        if isinstance(info.values[0], tuple):
            keys, values = zip(*info.values)
            node = ast.Dict(keys=list(keys), values=list(values))
        else:
            node = Set(elts=info.values)
    else:
        raise TypeError('Unexpected node for dictorsetmaker: %s' % info)
    p[0] = node


def p_atom8(p):
    ''' atom : NAME '''
    p[0] = ast.Name(id=p[1], ctx=Load)


def p_atom9(p):
    ''' atom : NUMBER '''
    n = ast.Num(n=eval(p[1]))
    p[0] = n


def p_atom10(p):
    ''' atom : atom_string_list '''
    s = ast.Str(s=p[1])
    p[0] = s


def p_atom_string_list1(p):
    ''' atom_string_list : STRING '''
    p[0] = p[1]


def p_atom_string_list2(p):
    ''' atom_string_list : atom_string_list STRING '''
    p[0] = p[1] + p[2]


# We dont' allow the backqoute atom from standard Python. Just
# use repr(...). This simplifies the grammar since we don't have
# to define a testlist1.


def p_listmaker1(p):
    ''' listmaker : test list_for '''
    p[0] = GeneratorInfo(elt=p[1], generators=p[2])


def p_listmaker2(p):
    ''' listmaker : test '''
    p[0] = CommaSeparatedList(values=[p[1]])


def p_listmaker3(p):
    ''' listmaker : test COMMA '''
    p[0] = CommaSeparatedList(values=[p[1]])


def p_listmaker4(p):
    ''' listmaker : test listmaker_list '''
    values = [p[1]] + p[2]
    p[0] = CommaSeparatedList(values=values)


def p_listmaker5(p):
    ''' listmaker : test listmaker_list COMMA '''
    values = [p[1]] + p[2]
    p[0] = CommaSeparatedList(values=values)


def p_listmaker_list1(p):
    ''' listmaker_list : COMMA test '''
    p[0] = [p[2]]


def p_listmaker_list2(p):
    ''' listmaker_list : listmaker_list COMMA test '''
    p[0] = p[1] + [p[3]]


def p_testlist_comp1(p):
    ''' testlist_comp : test comp_for '''
    p[0] = GeneratorInfo(elt=p[1], generators=p[2])


def p_testlist_comp2(p):
    ''' testlist_comp : test '''
    p[0] = p[1]


def p_testlist_comp3(p):
    ''' testlist_comp : test COMMA '''
    p[0] = CommaSeparatedList(values=[p[1]])


def p_testlist_comp4(p):
    ''' testlist_comp : test testlist_comp_list '''
    values = [p[1]] + p[2]
    p[0] = CommaSeparatedList(values=values)


def p_testlist_comp5(p):
    ''' testlist_comp : test testlist_comp_list COMMA '''
    values = [p[1]] + p[2]
    p[0] = CommaSeparatedList(values=values)


def p_testlist_comp_list1(p):
    ''' testlist_comp_list : COMMA test '''
    p[0] = [p[2]]


def p_testlist_comp_list2(p):
    ''' testlist_comp_list : testlist_comp_list COMMA test '''
    p[0] = p[1] + [p[3]]


def p_trailer1(p):
    ''' trailer : LPAR RPAR '''
    p[0] = ast.Call(args=[], keywords=[], starargs=None, kwargs=None)


def p_trailer2(p):
    ''' trailer : LPAR arglist RPAR '''
    args = p[2]
    p[0] = ast.Call(args=args.args, keywords=args.keywords,
                    starargs=args.starargs, kwargs=args.kwargs)


def p_trailer3(p):
    ''' trailer : LSQB subscriptlist RSQB '''
    p[0] = ast.Subscript(slice=p[2], ctx=Load)


def p_trailer4(p):
    ''' trailer : DOT NAME '''
    p[0] = ast.Attribute(attr=p[2], ctx=Load)


def p_subscriptlist1(p):
    ''' subscriptlist : subscript '''
    p[0] = p[1]


def p_subscriptlist2(p):
    ''' subscriptlist : subscript COMMA '''
    dims = [p[1]]
    p[0] = ast.ExtSlice(dims=dims)


def p_subscriptlist3(p):
    ''' subscriptlist : subscript subscriptlist_list '''
    dims = [p[1]] + p[2]
    p[0] = ast.ExtSlice(dims=dims)


def p_subscriptlist4(p):
    ''' subscriptlist : subscript subscriptlist_list COMMA '''
    dims = [p[1]] + p[2]
    p[0] = ast.ExtSlice(dims=dims)


def p_subscriptlist_list1(p):
    ''' subscriptlist_list : COMMA subscript '''
    p[0] = [p[2]]


def p_subscript_list2(p):
    ''' subscriptlist_list : subscriptlist_list COMMA subscript '''
    p[0] = p[1] + [p[3]]


def p_subscript1(p):
    ''' subscript : ELLIPSIS '''
    p[0] = ast.Ellipsis()


def p_subcript2(p):
    ''' subscript : test '''
    p[0] = ast.Index(value=p[1])


def p_subscript3(p):
    ''' subscript : COLON '''
    p[0] = ast.Slice(lower=None, upper=None, step=None)


def p_subscript4(p):
    ''' subscript : DOUBLECOLON '''
    name = ast.Name(id='None', ctx=Load)
    p[0] = ast.Slice(lower=None, upper=None, step=name)


def p_subscript5(p):
    ''' subscript : test COLON '''
    p[0] = ast.Slice(lower=p[1], uppper=None, step=None)


def p_subscrip6(p):
    ''' subscript : test DOUBLECOLON '''
    name = ast.Name(id='None', ctx=Load)
    p[0] = ast.Slice(lower=p[1], upper=None, step=name)


def p_subscript7(p):
    ''' subscript : COLON test '''
    p[0] = ast.Slice(lower=None, upper=p[2], step=None)


def p_subscript8(p):
    ''' subscript : COLON test COLON '''
    name = ast.Name(id='None', ctx=Load)
    p[0] = ast.Slice(lower=None, upper=p[2], step=name)


def p_subscript9(p):
    ''' subscript : DOUBLECOLON test '''
    p[0] = ast.Slice(lower=None, upper=None, step=p[2])


def p_subscript10(p):
    ''' subscript : test COLON test '''
    p[0] = ast.Slice(lower=p[1], upper=p[3], step=None)


def p_subscript11(p):
    ''' subscript : test COLON test COLON '''
    name = ast.Name(id='None', ctx=Load)
    p[0] = ast.Slice(lower=p[1], upper=p[3], step=name)


def p_subscript12(p):
    ''' subscript : COLON test COLON test '''
    p[0] = ast.Slice(lower=None, upper=p[2], step=p[4])


def p_subscript13(p):
    ''' subscript : test COLON test COLON test '''
    p[0] = ast.Slice(lower=p[1], upper=p[3], step=p[5])


def p_subscript14(p):
    ''' subscript : test DOUBLECOLON test '''
    p[0] = ast.Slice(lower=p[1], upper=None, step=p[3])


def p_exprlist1(p):
    ''' exprlist : expr '''
    p[0] = p[1]


def p_exprlist2(p):
    ''' exprlist : expr COMMA '''
    tup = ast.Tuple()
    tup.elts = [p[1]]
    p[0] = tup


def p_exprlist3(p):
    ''' exprlist : expr exprlist_list '''
    tup = ast.Tuple()
    tup.elts = [p[1]] + p[2]
    p[0] = tup


def p_exprlist4(p):
    ''' exprlist : expr exprlist_list COMMA '''
    tup = ast.Tuple()
    tup.elts = [p[1]] + p[2]
    p[0] = tup


def p_exprlist_list1(p):
    ''' exprlist_list : COMMA expr '''
    p[0] = [p[2]]


def p_exprlist_list2(p):
    ''' exprlist_list : exprlist_list COMMA expr '''
    p[0] = p[1] + [p[3]]


def p_dictorsetmaker1(p):
    ''' dictorsetmaker : test COLON test comp_for '''
    p[0] = GeneratorInfo(elt=(p[1], p[3]), generators=p[4])


def p_dictorsetmaker2(p):
    ''' dictorsetmaker : test COLON test '''
    values = [(p[1], p[3])]
    p[0] = CommaSeparatedList(values=values)


def p_dictorsetmaker3(p):
    ''' dictorsetmaker : test COLON test COMMA '''
    values = [(p[1], p[3])]
    p[0] = CommaSeparatedList(values=values)


def p_dictorsetmaker4(p):
    ''' dictorsetmaker : test COLON test dosm_colon_list '''
    values = [(p[1], p[3])] + p[4]
    p[0] = CommaSeparatedList(values=values)


def p_dictorsetmaker5(p):
    ''' dictorsetmaker : test COLON test dosm_colon_list COMMA '''
    values = [(p[1], p[3])] + p[4]
    p[0] = CommaSeparatedList(values=values)


def p_dictorsetmaker6(p):
    ''' dictorsetmaker : test comp_for '''
    p[0] = GeneratorInfo(elt=p[1], generators=p[2])


def p_dictorsetmaker7(p):
    ''' dictorsetmaker : test COMMA '''
    values = [p[1]]
    p[0] = CommaSeparatedList(values=values)


def p_dictorsetmaker8(p):
    ''' dictorsetmaker : test dosm_comma_list '''
    values = [p[1]] + p[2]
    p[0] = CommaSeparatedList(values=values)


def p_dictorsetmaker9(p):
    ''' dictorsetmaker : test dosm_comma_list COMMA '''
    values = [p[1]] + p[2]
    p[0] = CommaSeparatedList(values=values)


def p_dosm_colon_list1(p):
    ''' dosm_colon_list : COMMA test COLON test '''
    p[0] = [(p[2], p[4])]


def p_dosm_colon_list2(p):
    ''' dosm_colon_list : dosm_colon_list COMMA test COLON test '''
    p[0] = p[1] + [(p[3], p[5])]


def p_dosm_comma_list1(p):
    ''' dosm_comma_list : COMMA test '''
    p[0] = [p[2]]


def p_dosm_comma_list2(p):
    ''' dosm_comma_list : dosm_comma_list COMMA test '''
    p[0] = p[1] + [p[3]]


def p_arglist1(p):
    ''' arglist : argument '''
    if isinstance(p[1], ast.keyword):
        p[0] = Arguments(keywords=[p[1]])
    else:
        p[0] = Arguments(args=[p[1]])


def p_arglist2(p):
    ''' arglist : argument COMMA '''
    if isinstance(p[1], ast.keyword):
        p[0] = Arguments(keywords=[p[1]])
    else:
        p[0] = Arguments(args=[p[1]])


def p_arglist3(p):
    ''' arglist : STAR test '''
    p[0] = Arguments(starargs=p[2])


def p_arglist4(p):
    ''' arglist : STAR test COMMA DOUBLESTAR test '''
    p[0] = Arguments(starargs=p[2], kwargs=p[5])


def p_arglist5(p):
    ''' arglist : DOUBLESTAR test '''
    p[0] = Arguments(kwargs=p[2])


def p_arglist6(p):
    ''' arglist : arglist_list argument '''
    args = []
    kws = []
    for arg in (p[1] + [p[2]]):
        if isinstance(arg, ast.keyword):
            kws.append(arg)
        else:
            args.append(arg)
    p[0] = Arguments(args=args, keywords=kws)


def p_arglist7(p):
    ''' arglist : arglist_list argument COMMA '''
    args = []
    kws = []
    for arg in (p[1] + [p[2]]):
        if isinstance(arg, ast.keyword):
            kws.append(arg)
        else:
            args.append(arg)
    p[0] = Arguments(args=args, keywords=kws)


def p_arglist8(p):
    ''' arglist : arglist_list STAR test '''
    args = []
    kws = []
    for arg in p[1]:
        if isinstance(arg, ast.keyword):
            kws.append(arg)
        else:
            args.append(arg)
    p[0] = Arguments(args=args, keywords=kws, starargs=p[3])


def p_arglist9(p):
    ''' arglist : arglist_list STAR test COMMA DOUBLESTAR test '''
    args = []
    kws = []
    for arg in p[1]:
        if isinstance(arg, ast.keyword):
            kws.append(arg)
        else:
            args.append(arg)
    p[0] = Arguments(args=args, keywords=kws, starargs=p[3], kwargs=p[6])


def p_arglist10(p):
    ''' arglist : arglist_list DOUBLESTAR test '''
    args = []
    kws = []
    for arg in p[1]:
        if isinstance(arg, ast.keyword):
            kws.append(arg)
        else:
            args.append(arg)
    p[0] = Arguments(args=args, keywords=kws, kwargs=p[3])


def p_arglist11(p):
    ''' arglist : STAR test COMMA argument '''
    keyword = p[4]
    if isinstance(keyword, ast.keyword):
        p[0] = Arguments(keywords=[keyword], starargs=p[2])
    else:
        msg = 'only named arguments may follow *expression'
        tok = FakeToken(p.lexer.lexer, p.lineno(1))
        syntax_error(msg, tok)


def p_arglist12(p):
    ''' arglist : STAR test COMMA argument COMMA DOUBLESTAR test '''
    keyword = p[4]
    if isinstance(keyword, ast.keyword):
        p[0] = Arguments(keywords=[keyword], starargs=p[2], kwargs=p[7])
    else:
        msg = 'only named arguments may follow *expression'
        tok = FakeToken(p.lexer.lexer, p.lineno(1))
        syntax_error(msg, tok)


def p_arglist13(p):
    ''' arglist : STAR test COMMA arglist_list argument '''
    keywords = p[4] + [p[5]]
    for kw in keywords:
        if not isinstance(kw, ast.keyword):
            msg = 'only named arguments may follow *expression'
            tok = FakeToken(p.lexer.lexer, p.lineno(1))
            syntax_error(msg, tok)
    p[0] = Arguments(keywords=keywords, starargs=p[2])


def p_arglist14(p):
    ''' arglist : STAR test COMMA arglist_list argument COMMA DOUBLESTAR test '''
    keywords = p[4] + [p[5]]
    for kw in keywords:
        if not isinstance(kw, ast.keyword):
            msg = 'only named arguments may follow *expression'
            tok = FakeToken(p.lexer.lexer, p.lineno(1))
            syntax_error(msg, tok)
    p[0] = Arguments(keywords=keywords, starargs=p[2], kwargs=p[8])


def p_arglist_list1(p):
    ''' arglist_list : argument COMMA '''
    p[0] = [p[1]]


def p_arglist_list2(p):
    ''' arglist_list : arglist_list argument COMMA '''
    p[0] = p[1] + [p[2]]


def p_argument1(p):
    ''' argument : test '''
    p[0] = p[1]


def p_argument2(p):
    ''' argument : test comp_for '''
    p[0] = ast.GeneratorExp(elt=p[1], generators=p[2])


# This keyword argument needs to be asserted as a NAME, but using NAME
# here causes ambiguity in the parse tables.
def p_argument3(p):
    ''' argument : test EQUAL test '''
    arg = p[1]
    assert isinstance(arg, ast.Name), 'Keyword arg must be a Name.'
    value = p[3]
    p[0] = ast.keyword(arg=arg.id, value=value)


def p_list_for1(p):
    ''' list_for : FOR exprlist IN testlist_safe '''
    target = p[2]
    set_context(target, Store, p)
    p[0] = [ast.comprehension(target=target, iter=p[4], ifs=[])]


def p_list_for2(p):
    ''' list_for : FOR exprlist IN testlist_safe list_iter '''
    target = p[2]
    set_context(target, Store, p)
    gens = []
    gens.append(ast.comprehension(target=target, iter=p[4], ifs=[]))
    for item in p[5]:
        if isinstance(item, ast.comprehension):
            gens.append(item)
        else:
            gens[-1].ifs.append(item)
    p[0] = gens


def p_list_iter1(p):
    ''' list_iter : list_for '''
    p[0] = p[1]


def p_list_iter2(p):
    ''' list_iter : list_if '''
    p[0] = p[1]


def p_list_if1(p):
    ''' list_if : IF old_test '''
    p[0] = [p[2]]


def p_list_if2(p):
    ''' list_if : IF old_test list_iter '''
    p[0] = [p[2]] + p[3]


def p_comp_for1(p):
    ''' comp_for : FOR exprlist IN or_test '''
    target = p[2]
    set_context(target, Store, p)
    p[0] = [ast.comprehension(target=target, iter=p[4], ifs=[])]


def p_comp_for2(p):
    ''' comp_for : FOR exprlist IN or_test comp_iter '''
    target = p[2]
    set_context(target, Store, p)
    gens = []
    gens.append(ast.comprehension(target=target, iter=p[4], ifs=[]))
    for item in p[5]:
        if isinstance(item, ast.comprehension):
            gens.append(item)
        else:
            gens[-1].ifs.append(item)
    p[0] = gens


def p_comp_iter1(p):
    ''' comp_iter : comp_for '''
    p[0] = p[1]


def p_comp_iter2(p):
    ''' comp_iter : comp_if '''
    p[0] = p[1]


def p_comp_if1(p):
    ''' comp_if : IF old_test '''
    p[0] = [p[2]]


def p_comp_if2(p):
    ''' comp_if : IF old_test comp_iter '''
    p[0] = [p[2]] + p[3]


def p_testlist_safe1(p):
    ''' testlist_safe : old_test '''
    p[0] = p[1]


def p_testlist_safe2(p):
    ''' testlist_safe : old_test testlist_safe_list '''
    values = [p[1]] + p[2]
    p[0] = ast.Tuple(elts=values, ctx=Load)


def p_testlist_safe3(p):
    ''' testlist_safe : old_test testlist_safe_list COMMA '''
    values = [p[1]] + p[2]
    p[0] = ast.Tuple(elts=values, ctx=Load)


def p_testlist_safe_list1(p):
    ''' testlist_safe_list : COMMA old_test '''
    p[0] = [p[2]]


def p_testlist_safe_list2(p):
    ''' testlist_safe_list : testlist_safe_list COMMA old_test '''
    p[0] = p[1] + [p[3]]


def p_old_test1(p):
    ''' old_test : or_test '''
    p[0] = p[1]


def p_old_test2(p):
    ''' old_test : old_lambdef '''
    p[0] = p[1]


def p_old_lambdef1(p):
    ''' old_lambdef : LAMBDA COLON old_test '''
    args = ast.arguments(args=[], defaults=[], kwarg=None, vararg=None)
    body = p[3]
    p[0] = ast.Lambda(args=args, body=body)


def p_old_lambdef2(p):
    ''' old_lambdef : LAMBDA varargslist COLON old_test '''
    args = p[2]
    body = p[4]
    p[0] = ast.Lambda(args=args, body=body)


def p_lambdef1(p):
    ''' lambdef : LAMBDA COLON test '''
    args = ast.arguments(args=[], defaults=[], kwarg=None, vararg=None)
    body = p[3]
    p[0] = ast.Lambda(args=args, body=body)


def p_lambdef2(p):
    ''' lambdef : LAMBDA varargslist COLON test '''
    args = p[2]
    body = p[4]
    p[0] = ast.Lambda(args=args, body=body)


def p_varargslist1(p):
    ''' varargslist : fpdef COMMA STAR NAME '''
    # def f(a, *args): pass
    # def f((a, b), *args): pass
    p[0] = ast.arguments(args=[p[1]], defaults=[], vararg=p[4], kwarg=None)


def p_varargslist2(p):
    ''' varargslist : fpdef COMMA STAR NAME COMMA DOUBLESTAR NAME '''
    # def f(a, *args, **kwargs): pass
    # def f((a, b), *args, **kwargs): pass
    p[0] = ast.arguments(args=[p[1]], defaults=[], vararg=p[4], kwarg=p[7])


def p_varargslist3(p):
    ''' varargslist : fpdef COMMA DOUBLESTAR NAME '''
    # def f(a, **kwargs): pass
    # def f((a, b), **kwargs): pass
    p[0] = ast.arguments(args=[p[1]], defaults=[], vararg=None, kwarg=p[4])


def p_varargslist4(p):
    ''' varargslist : fpdef '''
    # def f(a): pass
    # def f((a, b)): pass
    p[0] = ast.arguments(args=[p[1]], defaults=[], vararg=None, kwarg=None)


def p_varargslist5(p):
    ''' varargslist : fpdef COMMA '''
    # def f(a,): pass
    # def f((a,b),): pass
    p[0] = ast.arguments(args=[p[1]], defaults=[], vararg=None, kwarg=None)


def p_varargslist6(p):
    ''' varargslist : fpdef varargslist_list COMMA STAR NAME '''
    # def f((a, b), c, *args): pass
    # def f((a, b), c, d=4, *args): pass
    list_args, defaults = p[2]
    args = [p[1]] + list_args
    p[0] = ast.arguments(args=args, defaults=defaults, vararg=p[5], kwarg=None)


def p_varargslist7(p):
    ''' varargslist : fpdef varargslist_list COMMA STAR NAME COMMA DOUBLESTAR NAME '''
    # def f((a, b), c, *args, **kwargs): pass
    # def f((a, b), c, d=4, *args, **kwargs): pass
    list_args, defaults = p[2]
    args = [p[1]] + list_args
    p[0] = ast.arguments(args=args, defaults=defaults, vararg=p[5], kwarg=p[8])


def p_varargslist8(p):
    ''' varargslist : fpdef varargslist_list COMMA DOUBLESTAR NAME '''
    # def f((a, b), c, **kwargs): pass
    # def f((a, b), c, d=4, **kwargs): pass
    list_args, defaults = p[2]
    args = [p[1]] + list_args
    p[0] = ast.arguments(args=args, defaults=defaults, vararg=None, kwarg=p[5])


def p_varargslist9(p):
    ''' varargslist : fpdef varargslist_list '''
    # def f((a, b), c): pass
    # def f((a, b), c, d=4): pass
    list_args, defaults = p[2]
    args = [p[1]] + list_args
    p[0] = ast.arguments(args=args, defaults=defaults, vararg=None, kwarg=None)


def p_varargslist10(p):
    ''' varargslist : fpdef varargslist_list COMMA '''
    # def f((a, b), c,): pass
    # def f((a, b), c, d=4,): pass
    list_args, defaults = p[2]
    args = [p[1]] + list_args
    p[0] = ast.arguments(args=args, defaults=defaults, vararg=None, kwarg=None)


def p_varargslist11(p):
    ''' varargslist : fpdef EQUAL test COMMA STAR NAME '''
    # def f(a=1, *args): pass
    # def f((a,b)=(1,2), *args): pass
    p[0] = ast.arguments(args=[p[1]], defaults=[p[3]], vararg=p[6], kwarg=None)


def p_varargslist12(p):
    ''' varargslist : fpdef EQUAL test COMMA STAR NAME COMMA DOUBLESTAR NAME '''
    # def f(a=1, *args, **kwargs): pass
    # def f((a,b)=(1,2), *args, **kwargs): pass
    p[0] = ast.arguments(args=[p[1]], defaults=[p[3]], vararg=p[6], kwarg=p[9])


def p_varargslist13(p):
    ''' varargslist : fpdef EQUAL test COMMA DOUBLESTAR NAME '''
    # def f(a=1, **kwargs): pass
    # def f((a,b)=(1,2), **kwargs): pass
    p[0] = ast.arguments(args=[p[1]], defaults=[p[3]], vararg=None, kwarg=p[6])


def p_varargslist14(p):
    ''' varargslist : fpdef EQUAL test '''
    # def f(a=1): pass
    # def f((a,b)=(1,2)): pass
    p[0] = ast.arguments(args=[p[1]], defaults=[p[3]], vararg=None, kwarg=None)


def p_varargslist15(p):
    ''' varargslist : fpdef EQUAL test COMMA '''
    # def f(a=1,): pass
    # def f((a,b)=(1,2),): pass
    p[0] = ast.arguments(args=[p[1]], defaults=[p[3]], vararg=None, kwarg=None)


def p_varargslist16(p):
    ''' varargslist : fpdef EQUAL test varargslist_list COMMA STAR NAME '''
    # def f(a=1, b=2, *args): pass
    list_args, list_defaults = p[4]
    if len(list_args) != len(list_defaults):
        msg = 'non-default argument follows default argument.'
        tok = FakeToken(p.lexer.lexer, p.lineno(2))
        syntax_error(msg, tok)
    args = [p[1]] + list_args
    defaults = [p[3]] + list_defaults
    p[0] = ast.arguments(args=args, defaults=defaults, vararg=p[7], kwarg=None)


def p_varargslist17(p):
    ''' varargslist : fpdef EQUAL test varargslist_list COMMA STAR NAME COMMA DOUBLESTAR NAME '''
    # def f(a=1, b=2, *args, **kwargs)
    list_args, list_defaults = p[4]
    if len(list_args) != len(list_defaults):
        msg = 'non-default argument follows default argument.'
        tok = FakeToken(p.lexer.lexer, p.lineno(2))
        syntax_error(msg, tok)
    args = [p[1]] + list_args
    defaults = [p[3]] + list_defaults
    p[0] = ast.arguments(args=args, defaults=defaults, vararg=p[7], kwarg=p[10])


def p_varargslist18(p):
    ''' varargslist : fpdef EQUAL test varargslist_list COMMA DOUBLESTAR NAME '''
    # def f(a=1, b=2, **kwargs): pass
    list_args, list_defaults = p[4]
    if len(list_args) != len(list_defaults):
        msg = 'non-default argument follows default argument.'
        tok = FakeToken(p.lexer.lexer, p.lineno(2))
        syntax_error(msg, tok)
    args = [p[1]] + list_args
    defaults = [p[3]] + list_defaults
    p[0] = ast.arguments(args=args, defaults=defaults, vararg=None, kwarg=p[7])


def p_varargslist19(p):
    ''' varargslist : fpdef EQUAL test varargslist_list '''
    # def f(a=1, b=2): pass
    list_args, list_defaults = p[4]
    if len(list_args) != len(list_defaults):
        msg = 'non-default argument follows default argument.'
        tok = FakeToken(p.lexer.lexer, p.lineno(2))
        syntax_error(msg, tok)
    args = [p[1]] + list_args
    defaults = [p[3]] + list_defaults
    p[0] = ast.arguments(args=args, defaults=defaults, vararg=None, kwarg=None)


def p_varargslist20(p):
    ''' varargslist : fpdef EQUAL test varargslist_list COMMA '''
    # def f(a=1, b=2,): pass
    list_args, list_defaults = p[4]
    if len(list_args) != len(list_defaults):
        msg = 'non-default argument follows default argument.'
        tok = FakeToken(p.lexer.lexer, p.lineno(2))
        syntax_error(msg, tok)
    args = [p[1]] + list_args
    defaults = [p[3]] + list_defaults
    p[0] = ast.arguments(args=args, defaults=defaults, vararg=None, kwarg=None)


def p_varargslist21(p):
    ''' varargslist : STAR NAME '''
    # def f(*args): pass
    p[0] = ast.arguments(args=[], defaults=[], vararg=p[2], kwarg=None)


def p_varargslist22(p):
    ''' varargslist : STAR NAME COMMA DOUBLESTAR NAME '''
    # def f(*args, **kwargs): pass
    p[0] = ast.arguments(args=[], defaults=[], vararg=p[2], kwarg=p[5])


def p_varargslist23(p):
    ''' varargslist : DOUBLESTAR NAME '''
    # def f(**kwargs): pass
    p[0] = ast.arguments(args=[], defaults=[], vararg=None, kwarg=p[2])


# The varargslist_list handlers return a 2-tuple of (args, defaults) lists
def p_varargslist_list1(p):
    ''' varargslist_list : COMMA fpdef '''
    p[0] = ([p[2]], [])


def p_varargslist_list2(p):
    ''' varargslist_list : COMMA fpdef EQUAL test '''
    p[0] = ([p[2]], [p[4]])


def p_varargslist_list3(p):
    ''' varargslist_list : varargslist_list COMMA fpdef '''
    list_args, list_defaults = p[1]
    if list_defaults:
        msg = 'non-default argument follows default argument.'
        tok = FakeToken(p.lexer.lexer, p.lineno(2))
        syntax_error(msg, tok)
    args = list_args + [p[3]]
    p[0] = (args, list_defaults)


def p_varargslist_list4(p):
    ''' varargslist_list : varargslist_list COMMA fpdef EQUAL test '''
    list_args, list_defaults = p[1]
    args = list_args + [p[3]]
    defaults = list_defaults +[p[5]]
    p[0] = (args, defaults)


def p_fpdef1(p):
    ''' fpdef : NAME '''
    p[0] = ast.Name(id=p[1], ctx=ast.Param())


def p_fpdef2(p):
    ''' fpdef : LPAR fplist RPAR '''
    # fplist will return a NAME or a TUPLE, so we don't need that
    # logic here.
    p[0] = p[2]


def p_fplist1(p):
    ''' fplist : fpdef '''
    p[0] = p[1]


def p_fplist2(p):
    ''' fplist : fpdef COMMA '''
    tup = ast.Tuple()
    tup.elts = [p[1]]
    set_context(tup, Store, p)
    p[0] = tup


def p_fplist3(p):
    ''' fplist : fpdef fplist_list '''
    elts = [p[1]] + p[2]
    tup = ast.Tuple()
    tup.elts = elts
    set_context(tup, Store, p)
    p[0] = tup


def p_fplist4(p):
    ''' fplist : fpdef fplist_list COMMA '''
    elts = [p[1]] + p[2]
    tup = ast.Tuple()
    tup.elts = elts
    set_context(tup, Store, p)
    p[0] = tup


def p_fplist_list1(p):
    ''' fplist_list : COMMA fpdef '''
    p[0] = [p[2]]


def p_fplist_list2(p):
    ''' fplist_list : fplist_list COMMA fpdef '''
    p[0] = p[1] + [p[3]]


def p_error(t):
    msg = 'invalid syntax'
    lexer = t.lexer
    # Ply has a weird thing where sometimes we get the EnamlLexer and
    # other times we get the Ply lexer
    if isinstance(lexer, EnamlLexer):
        lexer = lexer.lexer
    syntax_error(msg, FakeToken(lexer, t.lineno))


#==============================================================================
# End Parsing Rules
#==============================================================================
# Get a save directory for the lex and parse tables
_parse_dir = os.path.join(os.path.dirname(__file__), 'parse_tab')
_parse_module = 'enaml.core.parse_tab.parsetab'
_parser = yacc.yacc(
    debug=0, outputdir=_parse_dir, tabmodule=_parse_module, optimize=1,
    errorlog=yacc.NullLogger(),
)


def parse(enaml_source, filename='Enaml'):
    # All errors in the parsing and lexing rules are raised as a custom
    # ParsingError. This exception object can be called to return the
    # actual exception instance that should be raised. This is done
    # because Ply enters an error recovery mode whenever a SyntaxError
    # is raised from within a rule. We don't want error recovery, we'd
    # rather just fail immediately. So this mechanism allows us to
    # stop parsing immediately and then re-raise the errors outside
    # of the control of Ply.
    try:
        lexer = EnamlLexer(filename)
        return _parser.parse(enaml_source, debug=0, lexer=lexer)
    except ParsingError as parse_error:
        raise parse_error()


########NEW FILE########
__FILENAME__ = lextab
# enaml.core.parse_tab.lextab.py. This file automatically created by PLY (version 3.4). Don't edit!
_tabversion   = '3.4'
_lextokens    = {'LPAR': 1, 'ENDMARKER': 1, 'LESS': 1, 'AMPEREQUAL': 1, 'CIRCUMFLEX': 1, 'WS': 1, 'WITH': 1, 'MINUS': 1, 'NEWLINE': 1, 'EXCEPT': 1, 'PLUS': 1, 'PERCENTEQUAL': 1, 'ELLIPSIS': 1, 'EQEQUAL': 1, 'RIGHTSHIFTEQUAL': 1, 'EXEC': 1, 'STRING_START_SINGLE': 1, 'SLASH': 1, 'PASS': 1, 'NOTEQUAL': 1, 'NAME': 1, 'INDENT': 1, 'MINUSEQUAL': 1, 'ENAMLDEF': 1, 'DEDENT': 1, 'STRING_START_TRIPLE': 1, 'STAR': 1, 'DEL': 1, 'PRINT': 1, 'DOUBLESTAR': 1, 'DEF': 1, 'CIRCUMFLEXEQUAL': 1, 'COLON': 1, 'DOUBLECOLON': 1, 'FOR': 1, 'DOUBLESTAREQUAL': 1, 'ELSE': 1, 'TRY': 1, 'AND': 1, 'LBRACE': 1, 'AS': 1, 'OR': 1, 'LEFTSHIFT': 1, 'CONTINUE': 1, 'NOT': 1, 'LAMBDA': 1, 'RAISE': 1, 'GLOBAL': 1, 'WHILE': 1, 'VBAR': 1, 'RETURN': 1, 'DOT': 1, 'LEFTSHIFTEQUAL': 1, 'TILDE': 1, 'RSQB': 1, 'PERCENT': 1, 'DOUBLESLASH': 1, 'RBRACE': 1, 'EQUAL': 1, 'PLUSEQUAL': 1, 'IMPORT': 1, 'LESSEQUAL': 1, 'LSQB': 1, 'GREATER': 1, 'VBAREQUAL': 1, 'BREAK': 1, 'STRING_CONTINUE': 1, 'STAREQUAL': 1, 'ELIF': 1, 'SLASHEQUAL': 1, 'NUMBER': 1, 'RPAR': 1, 'ASSERT': 1, 'STRING_END': 1, 'GREATEREQUAL': 1, 'SEMI': 1, 'DOUBLESLASHEQUAL': 1, 'COMMA': 1, 'CLASS': 1, 'RIGHTSHIFT': 1, 'STRING': 1, 'COLONEQUAL': 1, 'IS': 1, 'YIELD': 1, 'FINALLY': 1, 'AT': 1, 'AMPER': 1, 'IN': 1, 'IF': 1, 'FROM': 1}
_lexreflags   = 0
_lexliterals  = ''
_lexstateinfo = {'TRIPLEQ2': 'exclusive', 'TRIPLEQ1': 'exclusive', 'INITIAL': 'inclusive', 'SINGLEQ2': 'exclusive', 'SINGLEQ1': 'exclusive'}
_lexstatere   = {'TRIPLEQ2': [('(?P<t_SINGLEQ1_SINGLEQ2_TRIPLEQ1_TRIPLEQ2_escaped>\\\\(.|\\n))|(?P<t_TRIPLEQ2_simple>[^"\\\\]+)|(?P<t_TRIPLEQ2_q2_but_not_triple>"(?!""))|(?P<t_TRIPLEQ2_end>""")', [None, ('t_SINGLEQ1_SINGLEQ2_TRIPLEQ1_TRIPLEQ2_escaped', 'escaped'), None, ('t_TRIPLEQ2_simple', 'simple'), ('t_TRIPLEQ2_q2_but_not_triple', 'q2_but_not_triple'), ('t_TRIPLEQ2_end', 'end')])], 'TRIPLEQ1': [("(?P<t_SINGLEQ1_SINGLEQ2_TRIPLEQ1_TRIPLEQ2_escaped>\\\\(.|\\n))|(?P<t_TRIPLEQ1_simple>[^'\\\\]+)|(?P<t_TRIPLEQ1_q1_but_not_triple>'(?!''))|(?P<t_TRIPLEQ1_end>''')", [None, ('t_SINGLEQ1_SINGLEQ2_TRIPLEQ1_TRIPLEQ2_escaped', 'escaped'), None, ('t_TRIPLEQ1_simple', 'simple'), ('t_TRIPLEQ1_q1_but_not_triple', 'q1_but_not_triple'), ('t_TRIPLEQ1_end', 'end')])], 'INITIAL': [('(?P<t_comment>[ ]*\\#[^\\r\\n]*)|(?P<t_WS> [ \\t\\f]+ )|(?P<t_escaped_newline>\\\\\\n)|(?P<t_newline>\\n+)|(?P<t_LPAR>\\()|(?P<t_RPAR>\\))|(?P<t_LBRACE>\\{)|(?P<t_RBRACE>\\})|(?P<t_LSQB>\\[)|(?P<t_RSQB>\\])|(?P<t_start_triple_quoted_q1_string>[uU]?[rR]?\'\'\')|(?P<t_start_triple_quoted_q2_string>[uU]?[rR]?""")|(?P<t_start_single_quoted_q1_string>[uU]?[rR]?\')|(?P<t_start_single_quoted_q2_string>[uU]?[rR]?")|(?P<t_NAME>[a-zA-Z_][a-zA-Z0-9_]*)|(?P<t_NUMBER>((\\d+[jJ]|((\\d+\\.\\d*|\\.\\d+)([eE][-+]?\\d+)?|\\d+[eE][-+]?\\d+)[jJ])|((\\d+\\.\\d*|\\.\\d+)([eE][-+]?\\d+)?|\\d+[eE][-+]?\\d+)|(0[xX][\\da-fA-F]+[lL]?|0[bB][01]+[lL]?|(0[oO][0-7]+)|(0[0-7]*)[lL]?|[1-9]\\d*[lL]?)))|(?P<t_ELLIPSIS>\\.\\.\\.)|(?P<t_DOUBLESTAREQUAL>\\*\\*=)|(?P<t_DOUBLESTAR>\\*\\*)|(?P<t_LEFTSHIFTEQUAL><<=)|(?P<t_RIGHTSHIFTEQUAL>>>=)|(?P<t_VBAREQUAL>\\|=)|(?P<t_STAREQUAL>\\*=)|(?P<t_CIRCUMFLEXEQUAL>\\^=)|(?P<t_DOUBLESLASHEQUAL>//=)|(?P<t_PLUSEQUAL>\\+=)|(?P<t_VBAR>\\|)|(?P<t_LEFTSHIFT><<)|(?P<t_EQEQUAL>==)|(?P<t_PLUS>\\+)|(?P<t_PERCENTEQUAL>%=)|(?P<t_SLASHEQUAL>/=)|(?P<t_COLONEQUAL>:=)|(?P<t_NOTEQUAL>!=)|(?P<t_STAR>\\*)|(?P<t_GREATEREQUAL>>=)|(?P<t_CIRCUMFLEX>\\^)|(?P<t_DOUBLESLASH>//)|(?P<t_DOT>\\.)|(?P<t_MINUSEQUAL>-=)|(?P<t_DOUBLECOLON>::)|(?P<t_AMPEREQUAL>&=)|(?P<t_RIGHTSHIFT>>>)|(?P<t_LESSEQUAL><=)|(?P<t_EQUAL>=)|(?P<t_AMPER>&)|(?P<t_SLASH>/)|(?P<t_GREATER>>)|(?P<t_LESS><)|(?P<t_COMMA>,)|(?P<t_PERCENT>%)|(?P<t_TILDE>~)|(?P<t_SEMI>;)|(?P<t_MINUS>-)|(?P<t_COLON>:)|(?P<t_AT>@)', [None, ('t_comment', 'comment'), ('t_WS', 'WS'), ('t_escaped_newline', 'escaped_newline'), ('t_newline', 'newline'), ('t_LPAR', 'LPAR'), ('t_RPAR', 'RPAR'), ('t_LBRACE', 'LBRACE'), ('t_RBRACE', 'RBRACE'), ('t_LSQB', 'LSQB'), ('t_RSQB', 'RSQB'), ('t_start_triple_quoted_q1_string', 'start_triple_quoted_q1_string'), ('t_start_triple_quoted_q2_string', 'start_triple_quoted_q2_string'), ('t_start_single_quoted_q1_string', 'start_single_quoted_q1_string'), ('t_start_single_quoted_q2_string', 'start_single_quoted_q2_string'), ('t_NAME', 'NAME'), (None, 'NUMBER'), None, None, None, None, None, None, None, None, None, None, None, (None, 'ELLIPSIS'), (None, 'DOUBLESTAREQUAL'), (None, 'DOUBLESTAR'), (None, 'LEFTSHIFTEQUAL'), (None, 'RIGHTSHIFTEQUAL'), (None, 'VBAREQUAL'), (None, 'STAREQUAL'), (None, 'CIRCUMFLEXEQUAL'), (None, 'DOUBLESLASHEQUAL'), (None, 'PLUSEQUAL'), (None, 'VBAR'), (None, 'LEFTSHIFT'), (None, 'EQEQUAL'), (None, 'PLUS'), (None, 'PERCENTEQUAL'), (None, 'SLASHEQUAL'), (None, 'COLONEQUAL'), (None, 'NOTEQUAL'), (None, 'STAR'), (None, 'GREATEREQUAL'), (None, 'CIRCUMFLEX'), (None, 'DOUBLESLASH'), (None, 'DOT'), (None, 'MINUSEQUAL'), (None, 'DOUBLECOLON'), (None, 'AMPEREQUAL'), (None, 'RIGHTSHIFT'), (None, 'LESSEQUAL'), (None, 'EQUAL'), (None, 'AMPER'), (None, 'SLASH'), (None, 'GREATER'), (None, 'LESS'), (None, 'COMMA'), (None, 'PERCENT'), (None, 'TILDE'), (None, 'SEMI'), (None, 'MINUS'), (None, 'COLON'), (None, 'AT')])], 'SINGLEQ2': [('(?P<t_SINGLEQ1_SINGLEQ2_TRIPLEQ1_TRIPLEQ2_escaped>\\\\(.|\\n))|(?P<t_SINGLEQ2_simple>[^"\\\\\\n]+)|(?P<t_SINGLEQ2_end>")', [None, ('t_SINGLEQ1_SINGLEQ2_TRIPLEQ1_TRIPLEQ2_escaped', 'escaped'), None, ('t_SINGLEQ2_simple', 'simple'), ('t_SINGLEQ2_end', 'end')])], 'SINGLEQ1': [("(?P<t_SINGLEQ1_SINGLEQ2_TRIPLEQ1_TRIPLEQ2_escaped>\\\\(.|\\n))|(?P<t_SINGLEQ1_simple>[^'\\\\\\n]+)|(?P<t_SINGLEQ1_end>')", [None, ('t_SINGLEQ1_SINGLEQ2_TRIPLEQ1_TRIPLEQ2_escaped', 'escaped'), None, ('t_SINGLEQ1_simple', 'simple'), ('t_SINGLEQ1_end', 'end')])]}
_lexstateignore = {'TRIPLEQ2': '', 'TRIPLEQ1': '', 'INITIAL': '', 'SINGLEQ2': '', 'SINGLEQ1': ''}
_lexstateerrorf = {'TRIPLEQ2': 't_TRIPLEQ2_error', 'TRIPLEQ1': 't_TRIPLEQ1_error', 'INITIAL': 't_error', 'SINGLEQ2': 't_SINGLEQ2_error', 'SINGLEQ1': 't_SINGLEQ1_error'}

########NEW FILE########
__FILENAME__ = parsetab

# c:\Users\i341972\Desktop\git_repos\enaml\enaml\core\parse_tab\parsetab.py
# This file is automatically generated. Do not edit.
_tabversion = '3.2'

_lr_method = 'LALR'

_lr_signature = '\x7f\xdd\xc1Pb\x9c\xa9\xeb\xac\xc9\xad\xb5=\x06\x80j'
    
_lr_action_items = {'LPAR':([0,1,6,7,9,13,14,16,18,24,28,29,30,31,33,35,39,42,43,44,47,49,52,54,55,57,61,63,64,65,67,72,73,74,82,83,85,86,89,90,95,96,97,102,103,104,106,109,112,116,117,118,119,120,121,122,123,124,125,126,127,128,129,133,134,135,136,137,138,140,144,147,148,150,155,157,160,161,163,165,166,168,169,170,171,177,183,185,186,187,188,189,191,193,194,195,196,199,201,202,205,210,211,213,215,216,218,219,220,228,233,234,244,246,248,251,253,256,258,260,262,263,265,270,271,272,274,277,278,279,281,282,291,292,293,296,299,300,301,303,306,307,308,309,310,312,314,315,316,318,319,321,324,328,330,333,341,343,346,347,350,353,354,355,356,360,364,365,367,368,370,374,375,377,378,379,383,391,394,401,404,410,414,417,418,420,428,429,430,432,435,437,440,442,444,447,450,453,459,461,463,466,468,472,473,475,476,488,490,491,492,493,494,495,496,497,498,501,502,505,510,512,518,523,524,525,528,529,530,540,543,546,547,549,552,553,556,565,569,570,573,574,575,576,582,583,585,586,587,589,590,599,600,602,613,615,616,617,618,621,629,633,635,637,639,640,642,643,644,651,666,667,679,],[1,1,-140,1,1,1,-55,-143,-139,-137,-141,1,-297,1,1,-298,1,-56,1,-9,-7,1,165,171,1,1,1,-8,-142,1,-295,-296,1,1,1,1,-144,1,-138,-288,-57,1,-58,1,1,1,1,-215,1,1,-125,-116,-120,-115,1,-118,-122,-117,-121,-124,-126,-123,-119,1,1,-181,-180,242,1,-299,1,1,251,1,1,1,-293,1,1,1,165,1,1,-286,171,1,-291,-241,1,-237,-236,-244,-239,-242,-240,-238,-6,1,1,314,316,-290,1,1,-289,1,1,1,1,-216,1,1,1,1,1,171,1,1,-51,1,-294,1,1,1,-314,1,1,1,-287,-317,1,1,1,171,1,1,1,-292,1,1,-245,1,-243,1,1,1,1,1,1,1,408,411,1,-168,1,-217,1,1,1,1,1,1,-163,-158,1,1,-315,1,1,1,-371,1,1,1,-316,171,171,-153,1,-177,-145,483,1,-169,-218,1,-174,1,1,-162,1,1,1,1,-372,1,1,171,171,1,1,1,1,-150,1,-146,-147,-155,-52,1,1,-164,1,1,1,-157,1,1,1,1,1,171,1,171,-178,1,1,-149,-148,1,-10,-159,-160,-165,1,-371,1,-154,1,1,1,-179,1,-152,-11,1,1,1,1,1,-372,1,1,-151,-12,-156,1,-166,-167,1,-14,-15,1,1,1,1,1,-13,-161,-16,-17,-18,-19,]),'ENDMARKER':([0,6,8,14,16,18,24,28,41,42,44,47,63,64,73,85,89,95,97,135,136,153,196,258,328,354,355,391,401,404,417,428,432,472,475,476,488,490,493,497,524,529,530,543,546,547,549,565,574,576,582,602,613,615,617,618,629,633,643,644,651,666,667,679,],[2,-140,100,-55,-143,-139,-137,-141,152,-56,-9,-7,-8,-142,-5,-144,-138,-57,-58,-181,-180,255,-6,-51,-168,-163,-158,-153,-177,-145,-169,-174,-162,-150,-146,-147,-155,-52,-164,-157,-178,-149,-148,-10,-159,-160,-165,-154,-179,-152,-11,-151,-12,-156,-166,-167,-14,-15,-13,-161,-16,-17,-18,-19,]),'NOTEQUAL':([10,12,23,30,32,35,37,38,51,52,67,68,72,90,101,105,107,113,131,132,140,143,149,151,160,162,164,166,170,181,183,190,210,215,222,223,224,225,226,232,239,240,241,247,254,262,267,268,269,271,278,279,280,300,305,336,344,351,364,371,378,395,],[-270,-250,-264,-297,-246,-298,-278,-254,-258,-282,-295,185,-296,-288,-279,-272,-271,-251,-265,-266,-299,-247,-255,-280,-293,-260,-259,-284,-286,-281,-291,185,-290,-289,-274,-276,-277,-275,-273,-252,-267,-268,-269,-248,-256,-294,-262,-263,-261,-314,-287,-317,-283,-292,-234,-253,-249,-257,-315,-285,-316,-235,]),'AMPEREQUAL':([10,12,15,19,23,27,30,32,35,37,38,46,48,51,52,67,68,72,75,77,90,101,105,107,113,131,132,140,143,149,151,156,160,162,164,166,170,181,183,190,198,200,201,204,210,215,222,223,224,225,226,232,239,240,241,247,254,261,262,267,268,269,271,278,279,280,295,300,305,311,312,313,336,344,351,358,364,371,378,388,395,397,398,422,],[-270,-250,120,-221,-264,-219,-297,-246,-298,-278,-254,-222,-230,-258,-282,-295,-232,-296,-226,-131,-288,-279,-272,-271,-251,-265,-266,-299,-247,-255,-280,-223,-293,-260,-259,-284,-286,-281,-291,-233,-227,-133,-132,-231,-290,-289,-274,-276,-277,-275,-273,-252,-267,-268,-269,-248,-256,-224,-294,-262,-263,-261,-314,-287,-317,-283,-397,-292,-234,-228,-134,-135,-253,-249,-257,-225,-315,-285,-316,-398,-235,-229,-136,-220,]),'CIRCUMFLEX':([10,12,23,30,35,37,38,51,52,67,72,90,101,105,107,113,131,132,140,149,151,160,162,164,166,170,181,183,210,215,222,223,224,225,226,232,239,240,241,254,262,267,268,269,271,278,279,280,300,336,351,364,371,378,],[-270,112,-264,-297,-298,-278,-254,-258,-282,-295,-296,-288,-279,-272,-271,233,-265,-266,-299,-255,-280,-293,-260,-259,-284,-286,-281,-291,-290,-289,-274,-276,-277,-275,-273,-252,-267,-268,-269,-256,-294,-262,-263,-261,-314,-287,-317,-283,-292,-253,-257,-315,-285,-316,]),'WITH':([0,6,14,16,18,24,28,42,44,47,63,64,73,85,89,95,97,135,136,196,258,328,353,354,355,391,401,404,417,428,430,432,472,475,476,488,490,493,497,524,529,530,543,546,547,549,565,574,576,582,602,613,615,617,618,629,633,643,644,651,666,667,679,],[7,-140,-55,-143,-139,-137,-141,-56,-9,-7,-8,-142,7,-144,-138,-57,-58,-181,-180,-6,-51,-168,7,-163,-158,-153,-177,-145,-169,-174,7,-162,-150,-146,-147,-155,-52,-164,-157,-178,-149,-148,-10,-159,-160,-165,-154,-179,-152,-11,-151,-12,-156,-166,-167,-14,-15,-13,-161,-16,-17,-18,-19,]),'MINUS':([0,1,6,7,9,10,13,14,16,18,23,24,28,29,30,31,33,35,37,39,42,43,44,47,49,52,55,57,61,63,64,65,67,72,73,74,82,83,85,86,89,90,95,96,97,101,102,103,104,105,106,107,112,116,117,118,119,120,121,122,123,124,125,126,127,128,129,131,132,133,134,135,136,138,140,144,147,150,151,155,157,160,161,163,165,166,168,169,170,177,181,183,185,186,187,188,189,191,193,194,195,196,199,201,210,211,213,215,216,218,219,220,222,223,224,225,226,233,234,239,240,241,244,246,248,253,256,258,260,262,263,265,270,271,272,274,277,278,279,280,281,282,291,293,296,299,300,301,303,306,307,308,309,310,312,314,315,316,318,324,328,330,341,343,346,347,350,353,354,355,356,360,364,365,367,368,370,371,374,375,377,378,391,394,401,404,414,417,420,428,429,430,432,435,437,440,442,444,447,450,461,463,466,468,472,473,475,476,488,490,491,492,493,494,495,496,497,498,501,502,505,510,518,524,525,528,529,530,540,543,546,547,549,552,553,556,565,569,570,573,574,575,576,582,583,585,586,587,589,590,599,600,602,613,615,616,617,618,621,629,633,635,637,639,640,642,643,644,651,666,667,679,],[39,39,-140,39,39,-270,39,-55,-143,-139,134,-137,-141,39,-297,39,39,-298,-278,39,-56,39,-9,-7,39,-282,39,39,39,-8,-142,39,-295,-296,39,39,39,39,-144,39,-138,-288,-57,39,-58,-279,39,39,39,-272,39,-271,39,39,-125,-116,-120,-115,39,-118,-122,-117,-121,-124,-126,-123,-119,134,-266,39,39,-181,-180,39,-299,39,39,39,-280,39,39,-293,39,39,39,-284,39,39,-286,39,-281,-291,-241,39,-237,-236,-244,-239,-242,-240,-238,-6,39,39,-290,39,39,-289,39,39,39,39,-274,-276,-277,-275,-273,39,39,-267,-268,-269,39,39,39,39,39,-51,39,-294,39,39,39,-314,39,39,39,-287,-317,-283,39,39,39,39,39,39,-292,39,39,-245,39,-243,39,39,39,39,39,39,39,39,-168,39,39,39,39,39,39,39,-163,-158,39,39,-315,39,39,39,-371,-285,39,39,39,-316,-153,39,-177,-145,39,-169,39,-174,39,39,-162,39,39,39,39,-372,39,39,39,39,39,39,-150,39,-146,-147,-155,-52,39,39,-164,39,39,39,-157,39,39,39,39,39,39,-178,39,39,-149,-148,39,-10,-159,-160,-165,39,-371,39,-154,39,39,39,-179,39,-152,-11,39,39,39,39,39,-372,39,39,-151,-12,-156,39,-166,-167,39,-14,-15,39,39,39,39,39,-13,-161,-16,-17,-18,-19,]),'LESS':([10,12,23,30,32,35,37,38,51,52,67,68,72,90,101,105,107,113,131,132,140,143,149,151,160,162,164,166,170,181,183,190,210,215,222,223,224,225,226,232,239,240,241,247,254,262,267,268,269,271,278,279,280,300,305,336,344,351,364,371,378,395,],[-270,-250,-264,-297,-246,-298,-278,-254,-258,-282,-295,188,-296,-288,-279,-272,-271,-251,-265,-266,-299,-247,-255,-280,-293,-260,-259,-284,-286,-281,-291,188,-290,-289,-274,-276,-277,-275,-273,-252,-267,-268,-269,-248,-256,-294,-262,-263,-261,-314,-287,-317,-283,-292,-234,-253,-249,-257,-315,-285,-316,-235,]),'EXCEPT':([95,97,258,259,354,490,493,549,617,618,],[-57,-58,-51,356,356,-52,-164,-165,-166,-167,]),'PLUS':([0,1,6,7,9,10,13,14,16,18,23,24,28,29,30,31,33,35,37,39,42,43,44,47,49,52,55,57,61,63,64,65,67,72,73,74,82,83,85,86,89,90,95,96,97,101,102,103,104,105,106,107,112,116,117,118,119,120,121,122,123,124,125,126,127,128,129,131,132,133,134,135,136,138,140,144,147,150,151,155,157,160,161,163,165,166,168,169,170,177,181,183,185,186,187,188,189,191,193,194,195,196,199,201,210,211,213,215,216,218,219,220,222,223,224,225,226,233,234,239,240,241,244,246,248,253,256,258,260,262,263,265,270,271,272,274,277,278,279,280,281,282,291,293,296,299,300,301,303,306,307,308,309,310,312,314,315,316,318,324,328,330,341,343,346,347,350,353,354,355,356,360,364,365,367,368,370,371,374,375,377,378,391,394,401,404,414,417,420,428,429,430,432,435,437,440,442,444,447,450,461,463,466,468,472,473,475,476,488,490,491,492,493,494,495,496,497,498,501,502,505,510,518,524,525,528,529,530,540,543,546,547,549,552,553,556,565,569,570,573,574,575,576,582,583,585,586,587,589,590,599,600,602,613,615,616,617,618,621,629,633,635,637,639,640,642,643,644,651,666,667,679,],[9,9,-140,9,9,-270,9,-55,-143,-139,133,-137,-141,9,-297,9,9,-298,-278,9,-56,9,-9,-7,9,-282,9,9,9,-8,-142,9,-295,-296,9,9,9,9,-144,9,-138,-288,-57,9,-58,-279,9,9,9,-272,9,-271,9,9,-125,-116,-120,-115,9,-118,-122,-117,-121,-124,-126,-123,-119,133,-266,9,9,-181,-180,9,-299,9,9,9,-280,9,9,-293,9,9,9,-284,9,9,-286,9,-281,-291,-241,9,-237,-236,-244,-239,-242,-240,-238,-6,9,9,-290,9,9,-289,9,9,9,9,-274,-276,-277,-275,-273,9,9,-267,-268,-269,9,9,9,9,9,-51,9,-294,9,9,9,-314,9,9,9,-287,-317,-283,9,9,9,9,9,9,-292,9,9,-245,9,-243,9,9,9,9,9,9,9,9,-168,9,9,9,9,9,9,9,-163,-158,9,9,-315,9,9,9,-371,-285,9,9,9,-316,-153,9,-177,-145,9,-169,9,-174,9,9,-162,9,9,9,9,-372,9,9,9,9,9,9,-150,9,-146,-147,-155,-52,9,9,-164,9,9,9,-157,9,9,9,9,9,9,-178,9,9,-149,-148,9,-10,-159,-160,-165,9,-371,9,-154,9,9,9,-179,9,-152,-11,9,9,9,9,9,-372,9,9,-151,-12,-156,9,-166,-167,9,-14,-15,9,9,9,9,9,-13,-161,-16,-17,-18,-19,]),'PERCENTEQUAL':([10,12,15,19,23,27,30,32,35,37,38,46,48,51,52,67,68,72,75,77,90,101,105,107,113,131,132,140,143,149,151,156,160,162,164,166,170,181,183,190,198,200,201,204,210,215,222,223,224,225,226,232,239,240,241,247,254,261,262,267,268,269,271,278,279,280,295,300,305,311,312,313,336,344,351,358,364,371,378,388,395,397,398,422,],[-270,-250,125,-221,-264,-219,-297,-246,-298,-278,-254,-222,-230,-258,-282,-295,-232,-296,-226,-131,-288,-279,-272,-271,-251,-265,-266,-299,-247,-255,-280,-223,-293,-260,-259,-284,-286,-281,-291,-233,-227,-133,-132,-231,-290,-289,-274,-276,-277,-275,-273,-252,-267,-268,-269,-248,-256,-224,-294,-262,-263,-261,-314,-287,-317,-283,-397,-292,-234,-228,-134,-135,-253,-249,-257,-225,-315,-285,-316,-398,-235,-229,-136,-220,]),'IMPORT':([0,6,14,16,18,24,28,42,44,47,63,64,73,85,89,95,96,97,109,135,136,155,196,207,208,209,216,219,228,258,299,315,318,320,322,328,330,333,350,353,354,355,391,401,404,417,418,428,429,430,432,435,437,468,472,475,476,488,490,491,492,493,495,497,518,524,525,528,529,530,543,546,547,549,565,574,575,576,582,583,585,586,602,613,615,616,617,618,629,633,642,643,644,651,666,667,679,],[11,-140,-55,-143,-139,-137,-141,-56,-9,-7,-8,-142,11,-144,-138,-57,11,-58,-215,-181,-180,11,-6,319,321,-199,11,11,-216,-51,11,11,11,410,-200,-168,11,-217,11,11,-163,-158,-153,-177,-145,-169,-218,-174,11,11,-162,11,11,11,-150,-146,-147,-155,-52,11,11,-164,11,-157,11,-178,11,11,-149,-148,-10,-159,-160,-165,-154,-179,11,-152,-11,11,11,11,-151,-12,-156,11,-166,-167,-14,-15,11,-13,-161,-16,-17,-18,-19,]),'EQEQUAL':([10,12,23,30,32,35,37,38,51,52,67,68,72,90,101,105,107,113,131,132,140,143,149,151,160,162,164,166,170,181,183,190,210,215,222,223,224,225,226,232,239,240,241,247,254,262,267,268,269,271,278,279,280,300,305,336,344,351,364,371,378,395,],[-270,-250,-264,-297,-246,-298,-278,-254,-258,-282,-295,195,-296,-288,-279,-272,-271,-251,-265,-266,-299,-247,-255,-280,-293,-260,-259,-284,-286,-281,-291,195,-290,-289,-274,-276,-277,-275,-273,-252,-267,-268,-269,-248,-256,-294,-262,-263,-261,-314,-287,-317,-283,-292,-234,-253,-249,-257,-315,-285,-316,-235,]),'RBRACE':([10,12,19,23,27,30,32,35,37,38,46,48,49,51,52,67,68,72,75,90,101,105,107,113,131,132,140,143,149,151,156,158,160,162,164,166,170,181,183,190,198,204,210,215,222,223,224,225,226,232,239,240,241,247,254,261,262,263,264,266,267,268,269,271,278,279,280,295,300,305,311,336,344,351,358,359,360,361,364,371,378,388,395,397,422,438,439,440,441,485,498,521,522,537,538,539,579,588,601,603,619,627,],[-270,-250,-221,-264,-219,-297,-246,-298,-278,-254,-222,-230,160,-258,-282,-295,-232,-296,-226,-288,-279,-272,-271,-251,-265,-266,-299,-247,-255,-280,-223,262,-293,-260,-259,-284,-286,-281,-291,-233,-227,-231,-290,-289,-274,-276,-277,-275,-273,-252,-267,-268,-269,-248,-256,-224,-294,-350,-351,-349,-262,-263,-261,-314,-287,-317,-283,-397,-292,-234,-228,-253,-249,-257,-225,-355,-352,-345,-315,-285,-316,-398,-235,-229,-220,-356,-347,-346,-344,-382,-348,-394,-393,-385,-384,-383,-386,-353,-395,-387,-354,-396,]),'EXEC':([0,6,14,16,18,24,28,42,44,47,63,64,73,85,89,95,96,97,135,136,155,196,216,219,258,299,315,318,328,330,350,353,354,355,391,401,404,417,428,429,430,432,435,437,468,472,475,476,488,490,491,492,493,495,497,518,524,525,528,529,530,543,546,547,549,565,574,575,576,582,583,585,586,602,613,615,616,617,618,629,633,642,643,644,651,666,667,679,],[13,-140,-55,-143,-139,-137,-141,-56,-9,-7,-8,-142,13,-144,-138,-57,13,-58,-181,-180,13,-6,13,13,-51,13,13,13,-168,13,13,13,-163,-158,-153,-177,-145,-169,-174,13,13,-162,13,13,13,-150,-146,-147,-155,-52,13,13,-164,13,-157,13,-178,13,13,-149,-148,-10,-159,-160,-165,-154,-179,13,-152,-11,13,13,13,-151,-12,-156,13,-166,-167,-14,-15,13,-13,-161,-16,-17,-18,-19,]),'SLASH':([10,30,35,37,52,67,72,90,101,105,107,140,151,160,166,170,181,183,210,215,222,223,224,225,226,262,271,278,279,280,300,364,371,378,],[106,-297,-298,-278,-282,-295,-296,-288,-279,-272,106,-299,-280,-293,-284,-286,-281,-291,-290,-289,-274,-276,-277,-275,-273,-294,-314,-287,-317,-283,-292,-315,-285,-316,]),'PASS':([0,6,14,16,18,24,28,42,44,47,63,64,73,85,89,95,96,97,135,136,155,196,216,219,258,299,315,318,328,330,350,353,354,355,391,401,404,417,428,429,430,432,435,437,468,472,475,476,487,488,490,491,492,493,495,497,518,524,525,528,529,530,543,546,547,549,565,574,575,576,580,581,582,583,585,586,602,604,606,607,608,609,611,613,615,616,617,618,628,629,631,632,633,634,638,641,642,643,644,648,649,650,651,653,654,661,663,664,666,667,668,670,672,673,674,675,676,677,678,679,680,681,683,685,686,687,689,690,692,693,694,696,697,698,699,700,],[20,-140,-55,-143,-139,-137,-141,-56,-9,-7,-8,-142,20,-144,-138,-57,20,-58,-181,-180,20,-6,20,20,-51,20,20,20,-168,20,20,20,-163,-158,-153,-177,-145,-169,-174,20,20,-162,20,20,20,-150,-146,-147,544,-155,-52,20,20,-164,20,-157,20,-178,20,20,-149,-148,-10,-159,-160,-165,-154,-179,20,-152,610,614,-11,20,20,20,-151,-24,-22,-20,-23,610,610,-12,-156,20,-166,-167,610,-14,-21,-25,-15,610,-45,662,20,-13,-161,610,610,662,-16,-26,-28,-32,-31,-50,-17,-18,610,-49,-48,-46,-47,-30,684,691,-33,-19,-27,-29,-35,-34,-42,691,-40,-43,691,-36,-37,-41,-44,-38,691,-39,]),'NAME':([0,1,6,7,9,11,13,14,16,18,24,26,28,29,31,33,34,39,42,43,44,47,49,54,55,56,57,61,63,64,65,73,74,80,82,83,84,85,86,87,89,95,96,97,102,103,104,106,112,116,117,118,119,120,121,122,123,124,125,126,127,128,129,133,134,135,136,138,144,147,150,155,157,161,163,165,167,168,169,171,172,176,177,185,186,187,188,189,191,193,194,195,196,199,201,208,209,211,213,216,218,219,220,227,229,230,233,234,242,244,246,248,251,253,256,258,260,263,265,270,272,274,277,281,282,291,292,293,296,298,299,301,303,306,307,308,309,310,312,314,315,316,318,319,321,322,324,328,330,332,335,341,343,346,347,350,353,354,355,356,360,365,367,368,370,374,375,377,379,383,385,387,391,394,401,404,408,410,411,414,417,420,428,429,430,432,435,437,440,442,444,447,450,453,454,455,457,459,461,463,466,468,472,473,475,476,477,479,483,487,488,490,491,492,493,494,495,496,497,498,501,502,505,510,512,513,514,518,523,524,525,528,529,530,532,540,543,546,547,549,552,553,556,560,561,564,565,569,570,573,574,575,576,580,582,583,585,586,587,589,590,592,599,600,602,604,606,607,608,609,611,612,613,615,616,617,618,621,624,628,629,630,631,632,633,634,635,637,638,639,640,641,642,643,644,646,648,649,650,651,653,654,655,661,663,664,666,667,668,670,672,673,674,675,676,677,678,679,680,681,683,685,686,687,689,690,692,693,694,696,697,698,699,700,],[67,67,-140,67,67,109,67,-55,-143,-139,-137,137,-141,67,67,67,148,67,-56,67,-9,-7,67,173,67,179,67,67,-8,-142,67,67,67,202,67,67,109,-144,67,109,-138,-57,67,-58,67,67,67,67,67,67,-125,-116,-120,-115,67,-118,-122,-117,-121,-124,-126,-123,-119,67,67,-181,-180,67,67,67,67,67,67,67,67,67,279,67,67,173,289,294,67,-241,67,-237,-236,-244,-239,-242,-240,-238,-6,67,67,109,-199,67,67,67,67,67,67,331,333,109,67,67,340,67,67,67,173,67,67,-51,67,67,67,67,67,67,67,67,67,67,173,67,67,390,67,67,67,-245,67,-243,67,67,67,67,67,67,67,407,407,-200,67,-168,67,418,109,67,67,67,67,67,67,-163,-158,67,67,67,67,67,-371,67,67,67,173,173,460,462,-153,67,-177,-145,407,407,407,67,-169,67,-174,67,67,-162,67,67,67,67,-372,67,67,173,508,509,511,173,67,67,67,67,-150,67,-146,-147,407,533,407,542,-155,-52,67,67,-164,67,67,67,-157,67,67,67,67,67,173,562,563,67,173,-178,67,67,-149,-148,407,67,-10,-159,-160,-165,67,-371,67,593,594,596,-154,67,67,67,-179,67,-152,612,-11,67,67,67,67,67,-372,622,67,67,-151,-24,-22,-20,-23,630,630,636,-12,-156,67,-166,-167,67,647,612,-14,636,-21,-25,-15,630,67,67,-45,67,67,659,67,-13,-161,665,630,630,669,-16,-26,-28,671,-32,-31,-50,-17,-18,630,-49,-48,-46,-47,-30,682,688,-33,-19,-27,-29,-35,-34,-42,695,-40,-43,695,-36,-37,-41,-44,-38,695,-39,]),'INDENT':([257,541,660,],[353,580,677,]),'MINUSEQUAL':([10,12,15,19,23,27,30,32,35,37,38,46,48,51,52,67,68,72,75,77,90,101,105,107,113,131,132,140,143,149,151,156,160,162,164,166,170,181,183,190,198,200,201,204,210,215,222,223,224,225,226,232,239,240,241,247,254,261,262,267,268,269,271,278,279,280,295,300,305,311,312,313,336,344,351,358,364,371,378,388,395,397,398,422,],[-270,-250,119,-221,-264,-219,-297,-246,-298,-278,-254,-222,-230,-258,-282,-295,-232,-296,-226,-131,-288,-279,-272,-271,-251,-265,-266,-299,-247,-255,-280,-223,-293,-260,-259,-284,-286,-281,-291,-233,-227,-133,-132,-231,-290,-289,-274,-276,-277,-275,-273,-252,-267,-268,-269,-248,-256,-224,-294,-262,-263,-261,-314,-287,-317,-283,-397,-292,-234,-228,-134,-135,-253,-249,-257,-225,-315,-285,-316,-398,-235,-229,-136,-220,]),'ENAMLDEF':([0,6,14,16,18,24,28,42,44,47,63,64,73,85,89,95,97,135,136,196,258,328,354,355,391,401,404,417,428,432,472,475,476,488,490,493,497,524,529,530,543,546,547,549,565,574,576,582,602,613,615,617,618,629,633,643,644,651,666,667,679,],[26,-140,-55,-143,-139,-137,-141,-56,-9,-7,-8,-142,26,-144,-138,-57,-58,-181,-180,-6,-51,-168,-163,-158,-153,-177,-145,-169,-174,-162,-150,-146,-147,-155,-52,-164,-157,-178,-149,-148,-10,-159,-160,-165,-154,-179,-152,-11,-151,-12,-156,-166,-167,-14,-15,-13,-161,-16,-17,-18,-19,]),'DEDENT':([6,14,16,18,24,28,42,64,85,89,95,97,135,136,258,328,354,355,391,401,404,417,428,430,431,432,472,475,476,488,489,490,493,497,524,529,530,546,547,549,565,574,576,602,604,606,607,608,609,611,615,617,618,631,632,634,638,644,648,649,653,654,661,663,664,668,670,672,673,674,675,678,680,681,683,685,686,687,689,690,692,693,694,696,697,698,699,700,],[-140,-55,-143,-139,-137,-141,-56,-142,-144,-138,-57,-58,-181,-180,-51,-168,-163,-158,-153,-177,-145,-169,-174,-54,490,-162,-150,-146,-147,-155,-53,-52,-164,-157,-178,-149,-148,-159,-160,-165,-154,-179,-152,-151,-24,-22,-20,-23,629,633,-156,-166,-167,-21,-25,651,-45,-161,666,667,-26,-28,-32,-31,-50,679,-49,-48,-46,-47,-30,-33,-27,-29,-35,-34,-42,694,-40,-43,698,-36,-37,-41,-44,-38,700,-39,]),'RETURN':([0,6,14,16,18,24,28,42,44,47,63,64,73,85,89,95,96,97,135,136,155,196,216,219,258,299,315,318,328,330,350,353,354,355,391,401,404,417,428,429,430,432,435,437,468,472,475,476,488,490,491,492,493,495,497,518,524,525,528,529,530,543,546,547,549,565,574,575,576,582,583,585,586,602,613,615,616,617,618,629,633,642,643,644,651,666,667,679,],[29,-140,-55,-143,-139,-137,-141,-56,-9,-7,-8,-142,29,-144,-138,-57,29,-58,-181,-180,29,-6,29,29,-51,29,29,29,-168,29,29,29,-163,-158,-153,-177,-145,-169,-174,29,29,-162,29,29,29,-150,-146,-147,-155,-52,29,29,-164,29,-157,29,-178,29,29,-149,-148,-10,-159,-160,-165,-154,-179,29,-152,-11,29,29,29,-151,-12,-156,29,-166,-167,-14,-15,29,-13,-161,-16,-17,-18,-19,]),'DEL':([0,6,14,16,18,24,28,42,44,47,63,64,73,85,89,95,96,97,135,136,155,196,216,219,258,299,315,318,328,330,350,353,354,355,391,401,404,417,428,429,430,432,435,437,468,472,475,476,488,490,491,492,493,495,497,518,524,525,528,529,530,543,546,547,549,565,574,575,576,582,583,585,586,602,613,615,616,617,618,629,633,642,643,644,651,666,667,679,],[31,-140,-55,-143,-139,-137,-141,-56,-9,-7,-8,-142,31,-144,-138,-57,31,-58,-181,-180,31,-6,31,31,-51,31,31,31,-168,31,31,31,-163,-158,-153,-177,-145,-169,-174,31,31,-162,31,31,31,-150,-146,-147,-155,-52,31,31,-164,31,-157,31,-178,31,31,-149,-148,-10,-159,-160,-165,-154,-179,31,-152,-11,31,31,31,-151,-12,-156,31,-166,-167,-14,-15,31,-13,-161,-16,-17,-18,-19,]),'PRINT':([0,6,14,16,18,24,28,42,44,47,63,64,73,85,89,95,96,97,135,136,155,196,216,219,258,299,315,318,328,330,350,353,354,355,391,401,404,417,428,429,430,432,435,437,468,472,475,476,488,490,491,492,493,495,497,518,524,525,528,529,530,543,546,547,549,565,574,575,576,582,583,585,586,602,613,615,616,617,618,629,633,642,643,644,651,666,667,679,],[33,-140,-55,-143,-139,-137,-141,-56,-9,-7,-8,-142,33,-144,-138,-57,33,-58,-181,-180,33,-6,33,33,-51,33,33,33,-168,33,33,33,-163,-158,-153,-177,-145,-169,-174,33,33,-162,33,33,33,-150,-146,-147,-155,-52,33,33,-164,33,-157,33,-178,33,33,-149,-148,-10,-159,-160,-165,-154,-179,33,-152,-11,33,33,33,-151,-12,-156,33,-166,-167,-14,-15,33,-13,-161,-16,-17,-18,-19,]),'DOUBLESTAR':([30,35,52,54,67,72,90,140,160,165,166,170,183,210,215,251,262,271,274,278,279,292,300,316,364,370,378,382,383,442,444,459,503,512,515,523,553,558,590,595,623,],[-297,-298,168,176,-295,-296,-288,-299,-293,272,277,-286,-291,-290,-289,176,-294,-314,367,-287,-317,387,-292,272,-315,-371,-316,454,457,501,-372,514,556,561,564,176,589,592,621,624,646,]),'DEF':([0,6,14,16,18,22,24,25,28,42,44,47,63,64,73,85,89,95,97,130,135,136,196,258,317,328,353,354,355,391,401,404,417,428,430,432,470,472,475,476,488,490,493,497,524,526,529,530,543,546,547,549,565,574,576,582,602,613,615,617,618,629,633,643,644,651,666,667,679,],[34,-140,-55,-143,-139,-183,-137,34,-141,-56,-9,-7,-8,-142,34,-144,-138,-57,-58,-182,-181,-180,-6,-51,-184,-168,34,-163,-158,-153,-177,-145,-169,-174,34,-162,-185,-150,-146,-147,-155,-52,-164,-157,-178,-186,-149,-148,-10,-159,-160,-165,-154,-179,-152,-11,-151,-12,-156,-166,-167,-14,-15,-13,-161,-16,-17,-18,-19,]),'CIRCUMFLEXEQUAL':([10,12,15,19,23,27,30,32,35,37,38,46,48,51,52,67,68,72,75,77,90,101,105,107,113,131,132,140,143,149,151,156,160,162,164,166,170,181,183,190,198,200,201,204,210,215,222,223,224,225,226,232,239,240,241,247,254,261,262,267,268,269,271,278,279,280,295,300,305,311,312,313,336,344,351,358,364,371,378,388,395,397,398,422,],[-270,-250,118,-221,-264,-219,-297,-246,-298,-278,-254,-222,-230,-258,-282,-295,-232,-296,-226,-131,-288,-279,-272,-271,-251,-265,-266,-299,-247,-255,-280,-223,-293,-260,-259,-284,-286,-281,-291,-233,-227,-133,-132,-231,-290,-289,-274,-276,-277,-275,-273,-252,-267,-268,-269,-248,-256,-224,-294,-262,-263,-261,-314,-287,-317,-283,-397,-292,-234,-228,-134,-135,-253,-249,-257,-225,-315,-285,-316,-398,-235,-229,-136,-220,]),'COLON':([10,12,19,23,27,30,32,35,37,38,45,46,48,51,52,54,67,68,72,75,77,90,98,99,101,105,107,113,131,132,140,143,149,151,156,159,160,162,164,166,169,170,173,174,175,180,181,183,190,198,200,201,202,204,206,210,215,221,222,223,224,225,226,232,239,240,241,247,252,254,261,262,267,268,269,271,278,279,280,283,289,290,292,294,295,300,305,311,312,313,327,329,336,344,348,351,352,356,357,358,364,371,372,377,378,381,383,384,386,388,395,397,398,399,416,421,422,427,433,434,436,448,450,456,458,459,460,462,465,469,474,499,508,509,511,512,516,523,527,542,545,548,550,551,559,562,563,572,584,593,594,596,612,622,630,636,647,659,665,669,688,695,],[-270,-250,-221,-264,-219,-297,-246,-298,-278,-254,155,-222,-230,-258,-282,177,-295,-232,-296,-226,-131,-288,-170,219,-279,-272,-271,-251,-265,-266,-299,-247,-255,-280,-223,265,-293,-260,-259,-284,281,-286,-426,-402,293,299,-281,-291,-233,-227,-133,-132,315,-231,318,-290,-289,330,-274,-276,-277,-275,-273,-252,-267,-268,-269,-248,350,-256,-224,-294,-262,-263,-261,-314,-287,-317,-283,374,-419,-407,-403,-421,-397,-292,-234,-228,-134,-135,-171,-173,-253,-249,-175,-257,429,435,437,-225,-315,-285,447,281,-316,-427,-408,-412,-422,-398,-235,-229,-136,468,-172,487,-220,-176,491,492,495,505,281,-424,-417,-413,-399,-401,518,525,528,552,-420,-404,-406,-418,-423,573,575,581,583,585,586,587,-425,-409,-411,600,616,-414,-416,-400,641,-405,650,655,-410,676,-415,676,641,650,]),'DOUBLECOLON':([10,12,19,23,27,30,32,35,37,38,46,48,51,52,67,68,72,75,90,101,105,107,113,131,132,140,143,149,151,156,160,162,164,166,169,170,181,183,190,198,204,210,215,222,223,224,225,226,232,239,240,241,247,254,261,262,267,268,269,271,278,279,280,283,295,300,305,311,336,344,351,358,364,371,377,378,388,395,397,422,450,612,630,636,659,669,671,682,688,695,],[-270,-250,-221,-264,-219,-297,-246,-298,-278,-254,-222,-230,-258,-282,-295,-232,-296,-226,-288,-279,-272,-271,-251,-265,-266,-299,-247,-255,-280,-223,-293,-260,-259,-284,282,-286,-281,-291,-233,-227,-231,-290,-289,-274,-276,-277,-275,-273,-252,-267,-268,-269,-248,-256,-224,-294,-262,-263,-261,-314,-287,-317,-283,375,-397,-292,-234,-228,-253,-249,-257,-225,-315,-285,282,-316,-398,-235,-229,-220,282,642,642,642,642,642,642,642,642,642,]),'$end':([2,71,100,152,255,],[-4,0,-3,-2,-1,]),'FOR':([0,6,10,12,14,16,18,19,23,24,27,28,30,32,35,37,38,42,44,46,47,48,51,52,63,64,67,68,72,73,75,85,89,90,92,95,97,101,105,107,113,131,132,135,136,140,143,149,151,156,159,160,162,164,166,170,181,183,184,190,196,198,204,210,215,222,223,224,225,226,232,239,240,241,247,254,258,261,262,267,268,269,271,275,278,279,280,295,300,305,311,328,336,344,351,353,354,355,358,361,364,371,378,388,391,395,397,401,404,417,422,428,430,432,472,475,476,485,488,490,493,497,519,520,521,522,524,529,530,543,546,547,549,565,571,574,576,579,582,597,598,599,601,602,613,615,617,618,626,627,629,633,643,644,651,666,667,679,],[43,-140,-270,-250,-55,-143,-139,-221,-264,-137,-219,-141,-297,-246,-298,-278,-254,-56,-9,-222,-7,-230,-258,-282,-8,-142,-295,-232,-296,43,-226,-144,-138,-288,211,-57,-58,-279,-272,-271,-251,-265,-266,-181,-180,-299,-247,-255,-280,-223,211,-293,-260,-259,-284,-286,-281,-291,301,-233,-6,-227,-231,-290,-289,-274,-276,-277,-275,-273,-252,-267,-268,-269,-248,-256,-51,-224,-294,-262,-263,-261,-314,211,-287,-317,-283,-397,-292,-234,-228,-168,-253,-249,-257,43,-163,-158,-225,211,-315,-285,-316,-398,-153,-235,-229,-177,-145,-169,-220,-174,43,-162,-150,-146,-147,211,-155,-52,-164,-157,301,-388,-394,-393,-178,-149,-148,-10,-159,-160,-165,-154,-389,-179,-152,211,-11,301,-391,-390,-395,-151,-12,-156,-166,-167,-392,-396,-14,-15,-13,-161,-16,-17,-18,-19,]),'DOUBLESTAREQUAL':([10,12,15,19,23,27,30,32,35,37,38,46,48,51,52,67,68,72,75,77,90,101,105,107,113,131,132,140,143,149,151,156,160,162,164,166,170,181,183,190,198,200,201,204,210,215,222,223,224,225,226,232,239,240,241,247,254,261,262,267,268,269,271,278,279,280,295,300,305,311,312,313,336,344,351,358,364,371,378,388,395,397,398,422,],[-270,-250,122,-221,-264,-219,-297,-246,-298,-278,-254,-222,-230,-258,-282,-295,-232,-296,-226,-131,-288,-279,-272,-271,-251,-265,-266,-299,-247,-255,-280,-223,-293,-260,-259,-284,-286,-281,-291,-233,-227,-133,-132,-231,-290,-289,-274,-276,-277,-275,-273,-252,-267,-268,-269,-248,-256,-224,-294,-262,-263,-261,-314,-287,-317,-283,-397,-292,-234,-228,-134,-135,-253,-249,-257,-225,-315,-285,-316,-398,-235,-229,-136,-220,]),'ELSE':([10,12,23,30,32,35,37,38,46,48,51,52,67,68,72,75,90,95,97,101,105,107,113,131,132,140,143,149,151,156,160,162,164,166,170,181,183,190,198,204,210,215,222,223,224,225,226,232,239,240,241,243,247,254,258,261,262,267,268,269,271,278,279,280,300,305,311,336,344,351,354,355,358,364,371,378,391,395,397,404,432,472,475,488,490,493,529,549,602,617,618,],[-270,-250,-264,-297,-246,-298,-278,-254,-222,-230,-258,-282,-295,-232,-296,-226,-288,-57,-58,-279,-272,-271,-251,-265,-266,-299,-247,-255,-280,-223,-293,-260,-259,-284,-286,-281,-291,-233,-227,-231,-290,-289,-274,-276,-277,-275,-273,-252,-267,-268,-269,341,-248,-256,-51,-224,-294,-262,-263,-261,-314,-287,-317,-283,-292,-234,-228,-253,-249,-257,-163,433,-225,-315,-285,-316,465,-235,-229,474,-162,-150,474,545,-52,-164,-149,-165,-151,-166,-167,]),'TRY':([0,6,14,16,18,24,28,42,44,47,63,64,73,85,89,95,97,135,136,196,258,328,353,354,355,391,401,404,417,428,430,432,472,475,476,488,490,493,497,524,529,530,543,546,547,549,565,574,576,582,602,613,615,617,618,629,633,643,644,651,666,667,679,],[45,-140,-55,-143,-139,-137,-141,-56,-9,-7,-8,-142,45,-144,-138,-57,-58,-181,-180,-6,-51,-168,45,-163,-158,-153,-177,-145,-169,-174,45,-162,-150,-146,-147,-155,-52,-164,-157,-178,-149,-148,-10,-159,-160,-165,-154,-179,-152,-11,-151,-12,-156,-166,-167,-14,-15,-13,-161,-16,-17,-18,-19,]),'AND':([10,12,23,30,32,35,37,38,48,51,52,67,68,72,75,90,101,105,107,113,131,132,140,143,149,151,160,162,164,166,170,181,183,190,198,204,210,215,222,223,224,225,226,232,239,240,241,247,254,262,267,268,269,271,278,279,280,300,305,311,336,344,351,364,371,378,395,397,],[-270,-250,-264,-297,-246,-298,-278,-254,-230,-258,-282,-295,-232,-296,199,-288,-279,-272,-271,-251,-265,-266,-299,-247,-255,-280,-293,-260,-259,-284,-286,-281,-291,-233,310,-231,-290,-289,-274,-276,-277,-275,-273,-252,-267,-268,-269,-248,-256,-294,-262,-263,-261,-314,-287,-317,-283,-292,-234,-228,-253,-249,-257,-315,-285,-316,-235,-229,]),'LBRACE':([0,1,6,7,9,13,14,16,18,24,28,29,31,33,39,42,43,44,47,49,55,57,61,63,64,65,73,74,82,83,85,86,89,95,96,97,102,103,104,106,112,116,117,118,119,120,121,122,123,124,125,126,127,128,129,133,134,135,136,138,144,147,150,155,157,161,163,165,168,169,177,185,186,187,188,189,191,193,194,195,196,199,201,211,213,216,218,219,220,233,234,244,246,248,253,256,258,260,263,265,270,272,274,277,281,282,291,293,296,299,301,303,306,307,308,309,310,312,314,315,316,318,324,328,330,341,343,346,347,350,353,354,355,356,360,365,367,368,370,374,375,377,391,394,401,404,414,417,420,428,429,430,432,435,437,440,442,444,447,450,461,463,466,468,472,473,475,476,488,490,491,492,493,494,495,496,497,498,501,502,505,510,518,524,525,528,529,530,540,543,546,547,549,552,553,556,565,569,570,573,574,575,576,582,583,585,586,587,589,590,599,600,602,613,615,616,617,618,621,629,633,635,637,639,640,642,643,644,651,666,667,679,],[49,49,-140,49,49,49,-55,-143,-139,-137,-141,49,49,49,49,-56,49,-9,-7,49,49,49,49,-8,-142,49,49,49,49,49,-144,49,-138,-57,49,-58,49,49,49,49,49,49,-125,-116,-120,-115,49,-118,-122,-117,-121,-124,-126,-123,-119,49,49,-181,-180,49,49,49,49,49,49,49,49,49,49,49,49,-241,49,-237,-236,-244,-239,-242,-240,-238,-6,49,49,49,49,49,49,49,49,49,49,49,49,49,49,49,-51,49,49,49,49,49,49,49,49,49,49,49,49,49,49,49,-245,49,-243,49,49,49,49,49,49,49,49,-168,49,49,49,49,49,49,49,-163,-158,49,49,49,49,49,-371,49,49,49,-153,49,-177,-145,49,-169,49,-174,49,49,-162,49,49,49,49,-372,49,49,49,49,49,49,-150,49,-146,-147,-155,-52,49,49,-164,49,49,49,-157,49,49,49,49,49,49,-178,49,49,-149,-148,49,-10,-159,-160,-165,49,-371,49,-154,49,49,49,-179,49,-152,-11,49,49,49,49,49,-372,49,49,-151,-12,-156,49,-166,-167,49,-14,-15,49,49,49,49,49,-13,-161,-16,-17,-18,-19,]),'AS':([10,12,19,23,27,30,32,35,37,38,46,48,51,52,67,68,72,75,90,98,101,105,107,108,109,113,131,132,140,143,149,151,156,160,162,164,166,170,181,183,190,198,204,210,215,222,223,224,225,226,228,232,239,240,241,247,254,261,262,267,268,269,271,278,279,280,295,300,305,311,333,336,344,351,358,364,371,378,388,395,397,407,418,422,436,],[-270,-250,-221,-264,-219,-297,-246,-298,-278,-254,-222,-230,-258,-282,-295,-232,-296,-226,-288,218,-279,-272,-271,227,-215,-251,-265,-266,-299,-247,-255,-280,-223,-293,-260,-259,-284,-286,-281,-291,-233,-227,-231,-290,-289,-274,-276,-277,-275,-273,-216,-252,-267,-268,-269,-248,-256,-224,-294,-262,-263,-261,-314,-287,-317,-283,-397,-292,-234,-228,-217,-253,-249,-257,-225,-315,-285,-316,-398,-235,-229,479,-218,-220,494,]),'OR':([10,12,23,30,32,35,37,38,46,48,51,52,67,68,72,75,90,101,105,107,113,131,132,140,143,149,151,156,160,162,164,166,170,181,183,190,198,204,210,215,222,223,224,225,226,232,239,240,241,247,254,261,262,267,268,269,271,278,279,280,300,305,311,336,344,351,358,364,371,378,395,397,],[-270,-250,-264,-297,-246,-298,-278,-254,157,-230,-258,-282,-295,-232,-296,-226,-288,-279,-272,-271,-251,-265,-266,-299,-247,-255,-280,260,-293,-260,-259,-284,-286,-281,-291,-233,-227,-231,-290,-289,-274,-276,-277,-275,-273,-252,-267,-268,-269,-248,-256,-224,-294,-262,-263,-261,-314,-287,-317,-283,-292,-234,-228,-253,-249,-257,-225,-315,-285,-316,-235,-229,]),'LEFTSHIFT':([10,23,30,35,37,51,52,67,72,90,101,105,107,131,132,140,151,160,162,164,166,170,181,183,210,215,222,223,224,225,226,239,240,241,262,267,268,269,271,278,279,280,300,364,371,378,612,630,636,659,669,671,682,688,695,],[-270,-264,-297,-298,-278,161,-282,-295,-296,-288,-279,-272,-271,-265,-266,-299,-280,-293,-260,161,-284,-286,-281,-291,-290,-289,-274,-276,-277,-275,-273,-267,-268,-269,-294,-262,-263,-261,-314,-287,-317,-283,-292,-315,-285,-316,640,640,640,640,640,640,640,640,640,]),'CONTINUE':([0,6,14,16,18,24,28,42,44,47,63,64,73,85,89,95,96,97,135,136,155,196,216,219,258,299,315,318,328,330,350,353,354,355,391,401,404,417,428,429,430,432,435,437,468,472,475,476,488,490,491,492,493,495,497,518,524,525,528,529,530,543,546,547,549,565,574,575,576,582,583,585,586,602,613,615,616,617,618,629,633,642,643,644,651,666,667,679,],[53,-140,-55,-143,-139,-137,-141,-56,-9,-7,-8,-142,53,-144,-138,-57,53,-58,-181,-180,53,-6,53,53,-51,53,53,53,-168,53,53,53,-163,-158,-153,-177,-145,-169,-174,53,53,-162,53,53,53,-150,-146,-147,-155,-52,53,53,-164,53,-157,53,-178,53,53,-149,-148,-10,-159,-160,-165,-154,-179,53,-152,-11,53,53,53,-151,-12,-156,53,-166,-167,-14,-15,53,-13,-161,-16,-17,-18,-19,]),'NOT':([0,1,6,7,10,12,14,16,18,23,24,28,29,30,32,33,35,37,38,42,44,47,49,51,52,55,57,63,64,65,67,68,72,73,74,82,83,85,86,89,90,95,96,97,101,105,107,113,116,117,118,119,120,121,122,123,124,125,126,127,128,129,131,132,135,136,138,140,143,147,149,151,155,157,160,162,164,165,166,169,170,177,181,183,189,190,196,199,201,210,213,215,216,219,220,222,223,224,225,226,232,234,239,240,241,247,248,254,256,258,260,262,263,265,267,268,269,270,271,272,274,278,279,280,281,282,291,293,296,299,300,303,305,309,310,312,314,315,316,318,324,328,330,336,341,344,346,347,350,351,353,354,355,356,360,364,365,367,368,370,371,374,375,377,378,391,394,395,401,404,414,417,420,428,429,430,432,435,437,440,442,444,447,450,461,463,466,468,472,473,475,476,488,490,491,492,493,494,495,496,497,498,501,502,505,510,518,524,525,528,529,530,540,543,546,547,549,552,553,556,565,569,570,573,574,575,576,582,583,585,586,587,589,590,599,600,602,613,615,616,617,618,621,629,633,635,637,639,640,642,643,644,651,666,667,679,],[83,83,-140,83,-270,-250,-55,-143,-139,-264,-137,-141,83,-297,-246,83,-298,-278,-254,-56,-9,-7,83,-258,-282,83,83,-8,-142,83,-295,192,-296,83,83,83,83,-144,83,-138,-288,-57,83,-58,-279,-272,-271,-251,83,-125,-116,-120,-115,83,-118,-122,-117,-121,-124,-126,-123,-119,-265,-266,-181,-180,83,-299,-247,83,-255,-280,83,83,-293,-260,-259,83,-284,83,-286,83,-281,-291,306,192,-6,83,83,-290,83,-289,83,83,83,-274,-276,-277,-275,-273,-252,83,-267,-268,-269,-248,83,-256,83,-51,83,-294,83,83,-262,-263,-261,83,-314,83,83,-287,-317,-283,83,83,83,83,83,83,-292,83,-234,83,83,83,83,83,83,83,83,-168,83,-253,83,-249,83,83,83,-257,83,-163,-158,83,83,-315,83,83,83,-371,-285,83,83,83,-316,-153,83,-235,-177,-145,83,-169,83,-174,83,83,-162,83,83,83,83,-372,83,83,83,83,83,83,-150,83,-146,-147,-155,-52,83,83,-164,83,83,83,-157,83,83,83,83,83,83,-178,83,83,-149,-148,83,-10,-159,-160,-165,83,-371,83,-154,83,83,83,-179,83,-152,-11,83,83,83,83,83,-372,83,83,-151,-12,-156,83,-166,-167,83,-14,-15,83,83,83,83,83,-13,-161,-16,-17,-18,-19,]),'LAMBDA':([0,1,6,7,14,16,18,24,28,29,33,42,44,47,49,55,57,63,64,65,73,74,82,85,86,89,95,96,97,116,117,118,119,120,121,122,123,124,125,126,127,128,129,135,136,147,155,165,169,177,196,201,213,216,219,220,234,248,256,258,263,265,270,272,274,281,282,291,293,296,299,303,309,312,314,315,316,318,324,328,330,341,346,347,350,353,354,355,356,360,365,367,368,370,374,375,377,391,394,401,404,417,420,428,429,430,432,435,437,440,442,444,447,450,461,463,466,468,472,473,475,476,488,490,491,492,493,494,495,496,497,498,501,502,505,510,518,524,525,528,529,530,540,543,546,547,549,552,553,556,565,569,570,573,574,575,576,582,583,585,586,587,589,590,599,600,602,613,615,616,617,618,621,629,633,635,637,639,640,642,643,644,651,666,667,679,],[54,54,-140,54,-55,-143,-139,-137,-141,54,54,-56,-9,-7,54,54,54,-8,-142,54,54,54,54,-144,54,-138,-57,54,-58,54,-125,-116,-120,-115,54,-118,-122,-117,-121,-124,-126,-123,-119,-181,-180,54,54,54,54,54,-6,54,54,54,54,54,54,54,54,-51,54,54,54,54,54,54,54,54,54,54,54,54,54,54,54,54,54,54,54,-168,54,54,54,54,54,54,-163,-158,54,54,54,54,54,-371,54,54,54,-153,54,-177,-145,-169,54,-174,54,54,-162,54,54,54,54,-372,54,54,54,54,523,54,-150,54,-146,-147,-155,-52,54,54,-164,54,54,54,-157,54,54,54,54,54,54,-178,54,54,-149,-148,523,-10,-159,-160,-165,54,-371,54,-154,523,523,523,-179,54,-152,-11,54,54,54,54,54,-372,523,523,-151,-12,-156,54,-166,-167,54,-14,-15,54,54,54,54,54,-13,-161,-16,-17,-18,-19,]),'NEWLINE':([0,3,4,5,6,10,12,14,15,16,17,18,19,20,21,23,24,27,28,29,30,32,33,35,36,37,38,40,41,42,44,46,47,48,50,51,52,53,55,58,59,60,62,63,64,66,67,68,69,70,72,73,75,76,77,78,79,81,82,85,88,89,90,94,95,96,97,101,105,107,108,109,110,111,113,114,115,131,132,135,136,139,140,141,142,143,145,146,149,151,155,156,160,162,164,166,170,178,179,181,183,190,196,197,198,200,201,203,204,205,210,215,216,217,219,222,223,224,225,226,228,231,232,235,236,237,238,239,240,241,244,245,247,248,249,250,254,258,261,262,267,268,269,271,278,279,280,295,297,299,300,305,311,312,313,315,318,326,328,330,331,333,334,336,337,338,339,342,343,344,345,346,350,351,354,355,358,364,371,378,388,389,390,391,395,396,397,398,401,402,404,405,406,407,409,412,413,417,418,419,422,423,424,425,426,428,429,432,435,437,464,468,471,472,475,476,477,478,481,482,486,487,488,490,491,492,493,495,497,517,518,524,525,528,529,530,531,532,533,534,536,543,544,546,547,549,565,574,575,576,577,578,581,582,583,585,586,602,605,610,613,614,615,616,617,618,629,633,636,641,642,643,644,650,651,652,656,657,658,659,662,666,667,671,676,679,684,691,],[8,95,-188,97,-140,-270,-250,-55,-111,-143,-72,-139,-221,-85,-64,-264,-137,-219,-141,-93,-297,-246,-73,-298,-68,-278,-254,-71,153,-56,-9,-222,-7,-230,-67,-258,-282,-92,-95,-88,-69,-87,-65,-8,-142,-89,-295,-232,-91,-90,-296,-5,-226,-86,-131,-70,-187,-99,-100,-144,-66,-138,-288,-60,-57,-59,-58,-279,-272,-271,-203,-215,-189,-211,-251,-106,-114,-265,-266,-181,-180,-94,-299,-84,-338,-247,-75,-74,-255,-280,257,-223,-293,-260,-259,-284,-286,-96,-102,-281,-291,-233,-6,-109,-227,-133,-132,-101,-231,317,-290,-289,-61,-62,257,-274,-276,-277,-275,-273,-216,-212,-252,-113,-112,-128,-127,-267,-268,-269,-339,-340,-248,-79,-80,-76,-256,-51,-224,-294,-262,-263,-261,-314,-287,-317,-283,-397,-103,257,-292,-234,-228,-134,-135,257,257,-63,-168,257,-204,-217,-213,-253,-107,-130,-129,-342,-341,-249,-82,-81,257,-257,-163,-158,-225,-315,-285,-316,-398,-97,-105,-153,-235,-110,-229,-136,-177,470,-145,-205,-190,-201,-191,-196,-197,-169,-218,-214,-220,-343,-83,-78,-77,-174,257,-162,257,257,-104,257,526,-150,-146,-147,-206,-207,-194,-193,-108,541,-155,-52,257,257,-164,257,-157,-98,257,-178,257,257,-149,-148,-209,-208,-202,-192,-198,-10,582,-159,-160,-165,-154,-179,257,-152,-210,-195,541,-11,257,257,257,-151,628,632,-12,643,-156,257,-166,-167,-14,-15,653,660,257,-13,-161,660,-16,670,672,673,674,675,678,-17,-18,680,660,-19,693,697,]),'RAISE':([0,6,14,16,18,24,28,42,44,47,63,64,73,85,89,95,96,97,135,136,155,196,216,219,258,299,315,318,328,330,350,353,354,355,391,401,404,417,428,429,430,432,435,437,468,472,475,476,488,490,491,492,493,495,497,518,524,525,528,529,530,543,546,547,549,565,574,575,576,582,583,585,586,602,613,615,616,617,618,629,633,642,643,644,651,666,667,679,],[55,-140,-55,-143,-139,-137,-141,-56,-9,-7,-8,-142,55,-144,-138,-57,55,-58,-181,-180,55,-6,55,55,-51,55,55,55,-168,55,55,55,-163,-158,-153,-177,-145,-169,-174,55,55,-162,55,55,55,-150,-146,-147,-155,-52,55,55,-164,55,-157,55,-178,55,55,-149,-148,-10,-159,-160,-165,-154,-179,55,-152,-11,55,55,55,-151,-12,-156,55,-166,-167,-14,-15,55,-13,-161,-16,-17,-18,-19,]),'GLOBAL':([0,6,14,16,18,24,28,42,44,47,63,64,73,85,89,95,96,97,135,136,155,196,216,219,258,299,315,318,328,330,350,353,354,355,391,401,404,417,428,429,430,432,435,437,468,472,475,476,488,490,491,492,493,495,497,518,524,525,528,529,530,543,546,547,549,565,574,575,576,582,583,585,586,602,613,615,616,617,618,629,633,642,643,644,651,666,667,679,],[56,-140,-55,-143,-139,-137,-141,-56,-9,-7,-8,-142,56,-144,-138,-57,56,-58,-181,-180,56,-6,56,56,-51,56,56,56,-168,56,56,56,-163,-158,-153,-177,-145,-169,-174,56,56,-162,56,56,56,-150,-146,-147,-155,-52,56,56,-164,56,-157,56,-178,56,56,-149,-148,-10,-159,-160,-165,-154,-179,56,-152,-11,56,56,56,-151,-12,-156,56,-166,-167,-14,-15,56,-13,-161,-16,-17,-18,-19,]),'WHILE':([0,6,14,16,18,24,28,42,44,47,63,64,73,85,89,95,97,135,136,196,258,328,353,354,355,391,401,404,417,428,430,432,472,475,476,488,490,493,497,524,529,530,543,546,547,549,565,574,576,582,602,613,615,617,618,629,633,643,644,651,666,667,679,],[57,-140,-55,-143,-139,-137,-141,-56,-9,-7,-8,-142,57,-144,-138,-57,-58,-181,-180,-6,-51,-168,57,-163,-158,-153,-177,-145,-169,-174,57,-162,-150,-146,-147,-155,-52,-164,-157,-178,-149,-148,-10,-159,-160,-165,-154,-179,-152,-11,-151,-12,-156,-166,-167,-14,-15,-13,-161,-16,-17,-18,-19,]),'VBAR':([10,12,23,30,32,35,37,38,51,52,67,72,90,101,105,107,113,131,132,140,143,149,151,160,162,164,166,170,181,183,210,215,222,223,224,225,226,232,239,240,241,247,254,262,267,268,269,271,278,279,280,300,336,344,351,364,371,378,],[-270,-250,-264,-297,144,-298,-278,-254,-258,-282,-295,-296,-288,-279,-272,-271,-251,-265,-266,-299,246,-255,-280,-293,-260,-259,-284,-286,-281,-291,-290,-289,-274,-276,-277,-275,-273,-252,-267,-268,-269,-248,-256,-294,-262,-263,-261,-314,-287,-317,-283,-292,-253,-249,-257,-315,-285,-316,]),'STAR':([10,30,35,37,52,54,67,72,90,101,105,107,140,151,160,165,166,170,181,183,210,215,222,223,224,225,226,251,262,271,274,278,279,280,292,300,316,319,321,364,370,371,378,383,410,444,459,512,523,],[102,-297,-298,-278,-282,172,-295,-296,-288,-279,-272,102,-299,-280,-293,270,-284,-286,-281,-291,-290,-289,-274,-276,-277,-275,-273,172,-294,-314,365,-287,-317,-283,385,-292,270,406,412,-315,-371,-285,-316,455,482,-372,513,560,172,]),'DOT':([30,35,52,67,72,87,90,109,140,160,166,170,183,208,209,210,215,228,262,271,278,279,300,322,333,364,378,418,],[-297,-298,167,-295,-296,209,-288,229,-299,-293,167,-286,-291,322,-199,-290,-289,332,-294,-314,-287,-317,-292,-200,-217,-315,-316,-218,]),'LEFTSHIFTEQUAL':([10,12,15,19,23,27,30,32,35,37,38,46,48,51,52,67,68,72,75,77,90,101,105,107,113,131,132,140,143,149,151,156,160,162,164,166,170,181,183,190,198,200,201,204,210,215,222,223,224,225,226,232,239,240,241,247,254,261,262,267,268,269,271,278,279,280,295,300,305,311,312,313,336,344,351,358,364,371,378,388,395,397,398,422,],[-270,-250,129,-221,-264,-219,-297,-246,-298,-278,-254,-222,-230,-258,-282,-295,-232,-296,-226,-131,-288,-279,-272,-271,-251,-265,-266,-299,-247,-255,-280,-223,-293,-260,-259,-284,-286,-281,-291,-233,-227,-133,-132,-231,-290,-289,-274,-276,-277,-275,-273,-252,-267,-268,-269,-248,-256,-224,-294,-262,-263,-261,-314,-287,-317,-283,-397,-292,-234,-228,-134,-135,-253,-249,-257,-225,-315,-285,-316,-398,-235,-229,-136,-220,]),'TILDE':([0,1,6,7,9,13,14,16,18,24,28,29,31,33,39,42,43,44,47,49,55,57,61,63,64,65,73,74,82,83,85,86,89,95,96,97,102,103,104,106,112,116,117,118,119,120,121,122,123,124,125,126,127,128,129,133,134,135,136,138,144,147,150,155,157,161,163,165,168,169,177,185,186,187,188,189,191,193,194,195,196,199,201,211,213,216,218,219,220,233,234,244,246,248,253,256,258,260,263,265,270,272,274,277,281,282,291,293,296,299,301,303,306,307,308,309,310,312,314,315,316,318,324,328,330,341,343,346,347,350,353,354,355,356,360,365,367,368,370,374,375,377,391,394,401,404,414,417,420,428,429,430,432,435,437,440,442,444,447,450,461,463,466,468,472,473,475,476,488,490,491,492,493,494,495,496,497,498,501,502,505,510,518,524,525,528,529,530,540,543,546,547,549,552,553,556,565,569,570,573,574,575,576,582,583,585,586,587,589,590,599,600,602,613,615,616,617,618,621,629,633,635,637,639,640,642,643,644,651,666,667,679,],[61,61,-140,61,61,61,-55,-143,-139,-137,-141,61,61,61,61,-56,61,-9,-7,61,61,61,61,-8,-142,61,61,61,61,61,-144,61,-138,-57,61,-58,61,61,61,61,61,61,-125,-116,-120,-115,61,-118,-122,-117,-121,-124,-126,-123,-119,61,61,-181,-180,61,61,61,61,61,61,61,61,61,61,61,61,-241,61,-237,-236,-244,-239,-242,-240,-238,-6,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,-51,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,-245,61,-243,61,61,61,61,61,61,61,61,-168,61,61,61,61,61,61,61,-163,-158,61,61,61,61,61,-371,61,61,61,-153,61,-177,-145,61,-169,61,-174,61,61,-162,61,61,61,61,-372,61,61,61,61,61,61,-150,61,-146,-147,-155,-52,61,61,-164,61,61,61,-157,61,61,61,61,61,61,-178,61,61,-149,-148,61,-10,-159,-160,-165,61,-371,61,-154,61,61,61,-179,61,-152,-11,61,61,61,61,61,-372,61,61,-151,-12,-156,61,-166,-167,61,-14,-15,61,61,61,61,61,-13,-161,-16,-17,-18,-19,]),'RSQB':([10,12,19,23,27,30,32,35,37,38,46,48,51,52,65,67,68,72,75,90,101,105,107,113,131,132,140,143,149,151,156,160,162,164,166,170,181,182,183,184,190,198,204,210,215,222,223,224,225,226,232,239,240,241,247,254,261,262,267,268,269,271,278,279,280,281,282,283,284,285,286,295,300,302,303,304,305,311,336,344,351,358,364,371,372,373,374,375,376,377,378,388,393,394,395,397,422,447,448,449,450,451,467,504,505,506,519,520,521,522,557,566,567,568,571,597,598,599,601,625,626,627,],[-270,-250,-221,-264,-219,-297,-246,-298,-278,-254,-222,-230,-258,-282,183,-295,-232,-296,-226,-288,-279,-272,-271,-251,-265,-266,-299,-247,-255,-280,-223,-293,-260,-259,-284,-286,-281,300,-291,-301,-233,-227,-231,-290,-289,-274,-276,-277,-275,-273,-252,-267,-268,-269,-248,-256,-224,-294,-262,-263,-261,-314,-287,-317,-283,-326,-327,-325,-318,378,-324,-397,-292,-300,-302,-303,-234,-228,-253,-249,-257,-225,-315,-285,-330,-332,-328,-329,-320,-319,-316,-398,-305,-304,-235,-229,-220,-331,-333,-337,-321,-322,-306,-335,-334,-323,-376,-388,-394,-393,-336,-377,-379,-378,-389,-380,-391,-390,-395,-381,-392,-396,]),'PERCENT':([10,30,35,37,52,67,72,90,101,105,107,140,151,160,166,170,181,183,210,215,222,223,224,225,226,262,271,278,279,280,300,364,371,378,],[103,-297,-298,-278,-282,-295,-296,-288,-279,-272,103,-299,-280,-293,-284,-286,-281,-291,-290,-289,-274,-276,-277,-275,-273,-294,-314,-287,-317,-283,-292,-315,-285,-316,]),'DOUBLESLASH':([10,30,35,37,52,67,72,90,101,105,107,140,151,160,166,170,181,183,210,215,222,223,224,225,226,262,271,278,279,280,300,364,371,378,],[104,-297,-298,-278,-282,-295,-296,-288,-279,-272,104,-299,-280,-293,-284,-286,-281,-291,-290,-289,-274,-276,-277,-275,-273,-294,-314,-287,-317,-283,-292,-315,-285,-316,]),'EQUAL':([10,12,15,19,23,27,30,32,35,37,38,46,48,51,52,67,68,72,75,77,82,90,101,105,107,113,131,132,140,143,149,151,156,160,162,164,166,170,173,174,181,183,190,198,200,201,203,204,210,215,222,223,224,225,226,232,237,238,239,240,241,247,254,261,262,267,268,269,271,275,278,279,280,295,300,305,311,312,313,336,344,351,358,364,371,378,381,386,388,395,397,398,422,456,612,630,636,659,669,671,682,688,695,],[-270,-250,121,-221,-264,-219,-297,-246,-298,-278,-254,-222,-230,-258,-282,-295,-232,-296,-226,-131,-100,-288,-279,-272,-271,-251,-265,-266,-299,-247,-255,-280,-223,-293,-260,-259,-284,-286,-426,291,-281,-291,-233,-227,-133,-132,-101,-231,-290,-289,-274,-276,-277,-275,-273,-252,121,121,-267,-268,-269,-248,-256,-224,-294,-262,-263,-261,-314,368,-287,-317,-283,-397,-292,-234,-228,-134,-135,-253,-249,-257,-225,-315,-285,-316,-427,461,-398,-235,-229,-136,-220,510,639,639,639,639,639,639,639,639,639,]),'PLUSEQUAL':([10,12,15,19,23,27,30,32,35,37,38,46,48,51,52,67,68,72,75,77,90,101,105,107,113,131,132,140,143,149,151,156,160,162,164,166,170,181,183,190,198,200,201,204,210,215,222,223,224,225,226,232,239,240,241,247,254,261,262,267,268,269,271,278,279,280,295,300,305,311,312,313,336,344,351,358,364,371,378,388,395,397,398,422,],[-270,-250,123,-221,-264,-219,-297,-246,-298,-278,-254,-222,-230,-258,-282,-295,-232,-296,-226,-131,-288,-279,-272,-271,-251,-265,-266,-299,-247,-255,-280,-223,-293,-260,-259,-284,-286,-281,-291,-233,-227,-133,-132,-231,-290,-289,-274,-276,-277,-275,-273,-252,-267,-268,-269,-248,-256,-224,-294,-262,-263,-261,-314,-287,-317,-283,-397,-292,-234,-228,-134,-135,-253,-249,-257,-225,-315,-285,-316,-398,-235,-229,-136,-220,]),'ELLIPSIS':([169,377,450,],[286,286,286,]),'LESSEQUAL':([10,12,23,30,32,35,37,38,51,52,67,68,72,90,101,105,107,113,131,132,140,143,149,151,160,162,164,166,170,181,183,190,210,215,222,223,224,225,226,232,239,240,241,247,254,262,267,268,269,271,278,279,280,300,305,336,344,351,364,371,378,395,],[-270,-250,-264,-297,-246,-298,-278,-254,-258,-282,-295,194,-296,-288,-279,-272,-271,-251,-265,-266,-299,-247,-255,-280,-293,-260,-259,-284,-286,-281,-291,194,-290,-289,-274,-276,-277,-275,-273,-252,-267,-268,-269,-248,-256,-294,-262,-263,-261,-314,-287,-317,-283,-292,-234,-253,-249,-257,-315,-285,-316,-235,]),'LSQB':([0,1,6,7,9,13,14,16,18,24,28,29,30,31,33,35,39,42,43,44,47,49,52,55,57,61,63,64,65,67,72,73,74,82,83,85,86,89,90,95,96,97,102,103,104,106,112,116,117,118,119,120,121,122,123,124,125,126,127,128,129,133,134,135,136,138,140,144,147,150,155,157,160,161,163,165,166,168,169,170,177,183,185,186,187,188,189,191,193,194,195,196,199,201,210,211,213,215,216,218,219,220,233,234,244,246,248,253,256,258,260,262,263,265,270,271,272,274,277,278,279,281,282,291,293,296,299,300,301,303,306,307,308,309,310,312,314,315,316,318,324,328,330,341,343,346,347,350,353,354,355,356,360,364,365,367,368,370,374,375,377,378,391,394,401,404,414,417,420,428,429,430,432,435,437,440,442,444,447,450,461,463,466,468,472,473,475,476,488,490,491,492,493,494,495,496,497,498,501,502,505,510,518,524,525,528,529,530,540,543,546,547,549,552,553,556,565,569,570,573,574,575,576,582,583,585,586,587,589,590,599,600,602,613,615,616,617,618,621,629,633,635,637,639,640,642,643,644,651,666,667,679,],[65,65,-140,65,65,65,-55,-143,-139,-137,-141,65,-297,65,65,-298,65,-56,65,-9,-7,65,169,65,65,65,-8,-142,65,-295,-296,65,65,65,65,-144,65,-138,-288,-57,65,-58,65,65,65,65,65,65,-125,-116,-120,-115,65,-118,-122,-117,-121,-124,-126,-123,-119,65,65,-181,-180,65,-299,65,65,65,65,65,-293,65,65,65,169,65,65,-286,65,-291,-241,65,-237,-236,-244,-239,-242,-240,-238,-6,65,65,-290,65,65,-289,65,65,65,65,65,65,65,65,65,65,65,-51,65,-294,65,65,65,-314,65,65,65,-287,-317,65,65,65,65,65,65,-292,65,65,-245,65,-243,65,65,65,65,65,65,65,65,-168,65,65,65,65,65,65,65,-163,-158,65,65,-315,65,65,65,-371,65,65,65,-316,-153,65,-177,-145,65,-169,65,-174,65,65,-162,65,65,65,65,-372,65,65,65,65,65,65,-150,65,-146,-147,-155,-52,65,65,-164,65,65,65,-157,65,65,65,65,65,65,-178,65,65,-149,-148,65,-10,-159,-160,-165,65,-371,65,-154,65,65,65,-179,65,-152,-11,65,65,65,65,65,-372,65,65,-151,-12,-156,65,-166,-167,65,-14,-15,65,65,65,65,65,-13,-161,-16,-17,-18,-19,]),'GREATER':([10,12,23,30,32,35,37,38,51,52,67,68,72,90,101,105,107,113,131,132,140,143,149,151,160,162,164,166,170,181,183,190,210,215,222,223,224,225,226,232,239,240,241,247,254,262,267,268,269,271,278,279,280,300,305,336,344,351,364,371,378,395,],[-270,-250,-264,-297,-246,-298,-278,-254,-258,-282,-295,187,-296,-288,-279,-272,-271,-251,-265,-266,-299,-247,-255,-280,-293,-260,-259,-284,-286,-281,-291,187,-290,-289,-274,-276,-277,-275,-273,-252,-267,-268,-269,-248,-256,-294,-262,-263,-261,-314,-287,-317,-283,-292,-234,-253,-249,-257,-315,-285,-316,-235,]),'VBAREQUAL':([10,12,15,19,23,27,30,32,35,37,38,46,48,51,52,67,68,72,75,77,90,101,105,107,113,131,132,140,143,149,151,156,160,162,164,166,170,181,183,190,198,200,201,204,210,215,222,223,224,225,226,232,239,240,241,247,254,261,262,267,268,269,271,278,279,280,295,300,305,311,312,313,336,344,351,358,364,371,378,388,395,397,398,422,],[-270,-250,127,-221,-264,-219,-297,-246,-298,-278,-254,-222,-230,-258,-282,-295,-232,-296,-226,-131,-288,-279,-272,-271,-251,-265,-266,-299,-247,-255,-280,-223,-293,-260,-259,-284,-286,-281,-291,-233,-227,-133,-132,-231,-290,-289,-274,-276,-277,-275,-273,-252,-267,-268,-269,-248,-256,-224,-294,-262,-263,-261,-314,-287,-317,-283,-397,-292,-234,-228,-134,-135,-253,-249,-257,-225,-315,-285,-316,-398,-235,-229,-136,-220,]),'BREAK':([0,6,14,16,18,24,28,42,44,47,63,64,73,85,89,95,96,97,135,136,155,196,216,219,258,299,315,318,328,330,350,353,354,355,391,401,404,417,428,429,430,432,435,437,468,472,475,476,488,490,491,492,493,495,497,518,524,525,528,529,530,543,546,547,549,565,574,575,576,582,583,585,586,602,613,615,616,617,618,629,633,642,643,644,651,666,667,679,],[69,-140,-55,-143,-139,-137,-141,-56,-9,-7,-8,-142,69,-144,-138,-57,69,-58,-181,-180,69,-6,69,69,-51,69,69,69,-168,69,69,69,-163,-158,-153,-177,-145,-169,-174,69,69,-162,69,69,69,-150,-146,-147,-155,-52,69,69,-164,69,-157,69,-178,69,69,-149,-148,-10,-159,-160,-165,-154,-179,69,-152,-11,69,69,69,-151,-12,-156,69,-166,-167,-14,-15,69,-13,-161,-16,-17,-18,-19,]),'STAREQUAL':([10,12,15,19,23,27,30,32,35,37,38,46,48,51,52,67,68,72,75,77,90,101,105,107,113,131,132,140,143,149,151,156,160,162,164,166,170,181,183,190,198,200,201,204,210,215,222,223,224,225,226,232,239,240,241,247,254,261,262,267,268,269,271,278,279,280,295,300,305,311,312,313,336,344,351,358,364,371,378,388,395,397,398,422,],[-270,-250,117,-221,-264,-219,-297,-246,-298,-278,-254,-222,-230,-258,-282,-295,-232,-296,-226,-131,-288,-279,-272,-271,-251,-265,-266,-299,-247,-255,-280,-223,-293,-260,-259,-284,-286,-281,-291,-233,-227,-133,-132,-231,-290,-289,-274,-276,-277,-275,-273,-252,-267,-268,-269,-248,-256,-224,-294,-262,-263,-261,-314,-287,-317,-283,-397,-292,-234,-228,-134,-135,-253,-249,-257,-225,-315,-285,-316,-398,-235,-229,-136,-220,]),'ELIF':([95,97,258,404,472,475,490,529,602,],[-57,-58,-51,473,-150,473,-52,-149,-151,]),'SLASHEQUAL':([10,12,15,19,23,27,30,32,35,37,38,46,48,51,52,67,68,72,75,77,90,101,105,107,113,131,132,140,143,149,151,156,160,162,164,166,170,181,183,190,198,200,201,204,210,215,222,223,224,225,226,232,239,240,241,247,254,261,262,267,268,269,271,278,279,280,295,300,305,311,312,313,336,344,351,358,364,371,378,388,395,397,398,422,],[-270,-250,126,-221,-264,-219,-297,-246,-298,-278,-254,-222,-230,-258,-282,-295,-232,-296,-226,-131,-288,-279,-272,-271,-251,-265,-266,-299,-247,-255,-280,-223,-293,-260,-259,-284,-286,-281,-291,-233,-227,-133,-132,-231,-290,-289,-274,-276,-277,-275,-273,-252,-267,-268,-269,-248,-256,-224,-294,-262,-263,-261,-314,-287,-317,-283,-397,-292,-234,-228,-134,-135,-253,-249,-257,-225,-315,-285,-316,-398,-235,-229,-136,-220,]),'NUMBER':([0,1,6,7,9,13,14,16,18,24,28,29,31,33,39,42,43,44,47,49,55,57,61,63,64,65,73,74,82,83,85,86,89,95,96,97,102,103,104,106,112,116,117,118,119,120,121,122,123,124,125,126,127,128,129,133,134,135,136,138,144,147,150,155,157,161,163,165,168,169,177,185,186,187,188,189,191,193,194,195,196,199,201,211,213,216,218,219,220,233,234,244,246,248,253,256,258,260,263,265,270,272,274,277,281,282,291,293,296,299,301,303,306,307,308,309,310,312,314,315,316,318,324,328,330,341,343,346,347,350,353,354,355,356,360,365,367,368,370,374,375,377,391,394,401,404,414,417,420,428,429,430,432,435,437,440,442,444,447,450,461,463,466,468,472,473,475,476,488,490,491,492,493,494,495,496,497,498,501,502,505,510,518,524,525,528,529,530,540,543,546,547,549,552,553,556,565,569,570,573,574,575,576,582,583,585,586,587,589,590,599,600,602,613,615,616,617,618,621,629,633,635,637,639,640,642,643,644,651,666,667,679,],[72,72,-140,72,72,72,-55,-143,-139,-137,-141,72,72,72,72,-56,72,-9,-7,72,72,72,72,-8,-142,72,72,72,72,72,-144,72,-138,-57,72,-58,72,72,72,72,72,72,-125,-116,-120,-115,72,-118,-122,-117,-121,-124,-126,-123,-119,72,72,-181,-180,72,72,72,72,72,72,72,72,72,72,72,72,-241,72,-237,-236,-244,-239,-242,-240,-238,-6,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,-51,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,-245,72,-243,72,72,72,72,72,72,72,72,-168,72,72,72,72,72,72,72,-163,-158,72,72,72,72,72,-371,72,72,72,-153,72,-177,-145,72,-169,72,-174,72,72,-162,72,72,72,72,-372,72,72,72,72,72,72,-150,72,-146,-147,-155,-52,72,72,-164,72,72,72,-157,72,72,72,72,72,72,-178,72,72,-149,-148,72,-10,-159,-160,-165,72,-371,72,-154,72,72,72,-179,72,-152,-11,72,72,72,72,72,-372,72,72,-151,-12,-156,72,-166,-167,72,-14,-15,72,72,72,72,72,-13,-161,-16,-17,-18,-19,]),'RPAR':([1,10,12,19,23,27,30,32,35,37,38,46,48,51,52,67,68,72,75,77,82,90,91,92,93,101,105,107,113,131,132,140,143,149,151,156,160,162,164,165,166,170,173,174,181,183,190,198,200,201,203,204,210,212,213,214,215,222,223,224,225,226,232,239,240,241,247,251,254,261,262,267,268,269,271,273,275,276,278,279,280,287,288,289,290,292,294,295,300,305,311,312,313,314,316,324,325,336,340,344,349,351,358,362,363,364,366,369,370,371,378,379,380,381,383,384,386,388,395,397,398,400,403,405,407,415,422,443,444,445,446,452,453,456,458,459,460,462,477,478,480,484,485,500,507,508,509,511,512,516,521,522,531,532,533,535,537,538,539,554,555,559,562,563,577,579,591,593,594,596,601,603,620,622,627,645,647,665,],[90,-270,-250,-221,-264,-219,-297,-246,-298,-278,-254,-222,-230,-258,-282,-295,-232,-296,-226,-131,-100,-288,210,-308,215,-279,-272,-271,-251,-265,-266,-299,-247,-255,-280,-223,-293,-260,-259,271,-284,-286,-426,-402,-281,-291,-233,-227,-133,-132,-101,-231,-290,-310,-309,-307,-289,-274,-276,-277,-275,-273,-252,-267,-268,-269,-248,348,-256,-224,-294,-262,-263,-261,-314,364,-373,-357,-287,-317,-283,-428,381,-419,-407,-403,-421,-397,-292,-234,-228,-134,-135,399,402,-311,-312,-253,421,-249,427,-257,-225,-359,-361,-315,-362,-374,-358,-285,-316,-429,-430,-427,-408,-412,-422,-398,-235,-229,-136,469,471,-205,-201,-313,-220,-364,-363,-366,-375,-432,-431,-424,-417,-413,-399,-401,-206,-207,534,536,-382,-367,-433,-420,-404,-406,-418,-423,-394,-393,-209,-208,-202,578,-385,-384,-383,-360,-369,-425,-409,-411,-210,-386,-365,-414,-416,-400,-395,-387,-368,-405,-396,-370,-410,-415,]),'ASSERT':([0,6,14,16,18,24,28,42,44,47,63,64,73,85,89,95,96,97,135,136,155,196,216,219,258,299,315,318,328,330,350,353,354,355,391,401,404,417,428,429,430,432,435,437,468,472,475,476,488,490,491,492,493,495,497,518,524,525,528,529,530,543,546,547,549,565,574,575,576,582,583,585,586,602,613,615,616,617,618,629,633,642,643,644,651,666,667,679,],[74,-140,-55,-143,-139,-137,-141,-56,-9,-7,-8,-142,74,-144,-138,-57,74,-58,-181,-180,74,-6,74,74,-51,74,74,74,-168,74,74,74,-163,-158,-153,-177,-145,-169,-174,74,74,-162,74,74,74,-150,-146,-147,-155,-52,74,74,-164,74,-157,74,-178,74,74,-149,-148,-10,-159,-160,-165,-154,-179,74,-152,-11,74,74,74,-151,-12,-156,74,-166,-167,-14,-15,74,-13,-161,-16,-17,-18,-19,]),'RIGHTSHIFTEQUAL':([10,12,15,19,23,27,30,32,35,37,38,46,48,51,52,67,68,72,75,77,90,101,105,107,113,131,132,140,143,149,151,156,160,162,164,166,170,181,183,190,198,200,201,204,210,215,222,223,224,225,226,232,239,240,241,247,254,261,262,267,268,269,271,278,279,280,295,300,305,311,312,313,336,344,351,358,364,371,378,388,395,397,398,422,],[-270,-250,128,-221,-264,-219,-297,-246,-298,-278,-254,-222,-230,-258,-282,-295,-232,-296,-226,-131,-288,-279,-272,-271,-251,-265,-266,-299,-247,-255,-280,-223,-293,-260,-259,-284,-286,-281,-291,-233,-227,-133,-132,-231,-290,-289,-274,-276,-277,-275,-273,-252,-267,-268,-269,-248,-256,-224,-294,-262,-263,-261,-314,-287,-317,-283,-397,-292,-234,-228,-134,-135,-253,-249,-257,-225,-315,-285,-316,-398,-235,-229,-136,-220,]),'GREATEREQUAL':([10,12,23,30,32,35,37,38,51,52,67,68,72,90,101,105,107,113,131,132,140,143,149,151,160,162,164,166,170,181,183,190,210,215,222,223,224,225,226,232,239,240,241,247,254,262,267,268,269,271,278,279,280,300,305,336,344,351,364,371,378,395,],[-270,-250,-264,-297,-246,-298,-278,-254,-258,-282,-295,191,-296,-288,-279,-272,-271,-251,-265,-266,-299,-247,-255,-280,-293,-260,-259,-284,-286,-281,-291,191,-290,-289,-274,-276,-277,-275,-273,-252,-267,-268,-269,-248,-256,-294,-262,-263,-261,-314,-287,-317,-283,-292,-234,-253,-249,-257,-315,-285,-316,-235,]),'SEMI':([3,4,10,12,15,17,19,20,21,23,27,29,30,32,33,35,36,37,38,40,46,48,50,51,52,53,55,58,59,60,62,66,67,68,69,70,72,75,76,77,78,79,81,82,88,90,94,101,105,107,108,109,110,111,113,114,115,131,132,139,140,141,142,143,145,146,149,151,156,160,162,164,166,170,178,179,181,183,190,197,198,200,201,203,204,210,215,217,222,223,224,225,226,228,231,232,235,236,237,238,239,240,241,244,245,247,248,249,250,254,261,262,267,268,269,271,278,279,280,295,297,300,305,311,312,313,326,331,333,334,336,337,338,339,342,343,344,345,346,351,358,364,371,378,388,389,390,395,396,397,398,405,406,407,409,412,413,418,419,422,423,424,425,426,464,477,478,481,482,486,517,531,532,533,534,536,577,578,],[96,-188,-270,-250,-111,-72,-221,-85,-64,-264,-219,-93,-297,-246,-73,-298,-68,-278,-254,-71,-222,-230,-67,-258,-282,-92,-95,-88,-69,-87,-65,-89,-295,-232,-91,-90,-296,-226,-86,-131,-70,-187,-99,-100,-66,-288,216,-279,-272,-271,-203,-215,-189,-211,-251,-106,-114,-265,-266,-94,-299,-84,-338,-247,-75,-74,-255,-280,-223,-293,-260,-259,-284,-286,-96,-102,-281,-291,-233,-109,-227,-133,-132,-101,-231,-290,-289,-62,-274,-276,-277,-275,-273,-216,-212,-252,-113,-112,-128,-127,-267,-268,-269,-339,-340,-248,-79,-80,-76,-256,-224,-294,-262,-263,-261,-314,-287,-317,-283,-397,-103,-292,-234,-228,-134,-135,-63,-204,-217,-213,-253,-107,-130,-129,-342,-341,-249,-82,-81,-257,-225,-315,-285,-316,-398,-97,-105,-235,-110,-229,-136,-205,-190,-201,-191,-196,-197,-218,-214,-220,-343,-83,-78,-77,-104,-206,-207,-194,-193,-108,-98,-209,-208,-202,-192,-198,-210,-195,]),'DOUBLESLASHEQUAL':([10,12,15,19,23,27,30,32,35,37,38,46,48,51,52,67,68,72,75,77,90,101,105,107,113,131,132,140,143,149,151,156,160,162,164,166,170,181,183,190,198,200,201,204,210,215,222,223,224,225,226,232,239,240,241,247,254,261,262,267,268,269,271,278,279,280,295,300,305,311,312,313,336,344,351,358,364,371,378,388,395,397,398,422,],[-270,-250,124,-221,-264,-219,-297,-246,-298,-278,-254,-222,-230,-258,-282,-295,-232,-296,-226,-131,-288,-279,-272,-271,-251,-265,-266,-299,-247,-255,-280,-223,-293,-260,-259,-284,-286,-281,-291,-233,-227,-133,-132,-231,-290,-289,-274,-276,-277,-275,-273,-252,-267,-268,-269,-248,-256,-224,-294,-262,-263,-261,-314,-287,-317,-283,-397,-292,-234,-228,-134,-135,-253,-249,-257,-225,-315,-285,-316,-398,-235,-229,-136,-220,]),'COMMA':([10,12,19,23,27,30,32,35,37,38,46,48,51,52,67,68,72,75,77,90,92,98,99,101,105,107,108,109,111,113,131,132,140,142,143,146,149,151,156,159,160,162,164,166,170,173,174,178,179,181,183,184,190,197,198,200,204,210,212,215,222,223,224,225,226,228,231,232,239,240,241,245,247,249,250,254,261,262,264,267,268,269,271,275,276,278,279,280,281,282,283,284,286,287,289,290,295,300,304,305,311,313,325,327,329,331,333,334,336,337,342,344,345,351,358,359,361,362,364,366,369,371,372,373,374,375,376,378,380,381,384,386,388,389,390,393,395,397,398,405,407,415,418,419,422,423,424,426,436,438,439,443,446,447,448,449,451,452,456,458,460,467,478,485,500,504,505,506,507,509,516,520,521,522,531,533,537,538,539,555,557,559,562,571,577,579,588,593,598,601,603,619,626,627,],[-270,-250,-221,-264,-219,-297,-246,-298,-278,-254,-222,-230,-258,-282,-295,-232,-296,-226,201,-288,213,-170,220,-279,-272,-271,-203,-215,230,-251,-265,-266,-299,244,-247,248,-255,-280,-223,263,-293,-260,-259,-284,-286,-426,292,296,298,-281,-291,303,-233,309,-227,312,-231,-290,324,-289,-274,-276,-277,-275,-273,-216,335,-252,-267,-268,-269,343,-248,346,347,-256,-224,-294,360,-262,-263,-261,-314,-373,370,-287,-317,-283,-326,-327,-325,377,-324,379,382,383,-397,-292,394,-234,-228,-135,-312,-171,220,-204,-217,-213,-253,420,-342,-249,-82,-257,-225,-355,440,442,-315,444,-374,-285,-330,-332,-328,-329,450,-316,453,-427,459,-422,-398,463,298,-305,-235,-229,-136,477,-201,-313,-218,-214,-220,-343,-83,248,496,-356,498,503,-375,-331,-333,-337,-322,-432,-424,512,515,-306,532,-382,553,-335,-334,-323,-433,558,-423,570,-394,-393,-209,-202,-385,-384,-383,590,-336,-425,595,599,-210,-386,-353,623,-391,-395,-387,-354,-392,-396,]),'CLASS':([0,6,14,16,18,22,24,25,28,42,44,47,63,64,73,85,89,95,97,130,135,136,196,258,317,328,353,354,355,391,401,404,417,428,430,432,470,472,475,476,488,490,493,497,524,526,529,530,543,546,547,549,565,574,576,582,602,613,615,617,618,629,633,643,644,651,666,667,679,],[80,-140,-55,-143,-139,-183,-137,80,-141,-56,-9,-7,-8,-142,80,-144,-138,-57,-58,-182,-181,-180,-6,-51,-184,-168,80,-163,-158,-153,-177,-145,-169,-174,80,-162,-185,-150,-146,-147,-155,-52,-164,-157,-178,-186,-149,-148,-10,-159,-160,-165,-154,-179,-152,-11,-151,-12,-156,-166,-167,-14,-15,-13,-161,-16,-17,-18,-19,]),'RIGHTSHIFT':([10,23,30,33,35,37,51,52,67,72,90,101,105,107,131,132,140,151,160,162,164,166,170,181,183,210,215,222,223,224,225,226,239,240,241,262,267,268,269,271,278,279,280,300,364,371,378,612,630,636,659,669,671,682,688,695,],[-270,-264,-297,147,-298,-278,163,-282,-295,-296,-288,-279,-272,-271,-265,-266,-299,-280,-293,-260,163,-284,-286,-281,-291,-290,-289,-274,-276,-277,-275,-273,-267,-268,-269,-294,-262,-263,-261,-314,-287,-317,-283,-292,-315,-285,-316,635,635,635,635,635,635,635,635,635,]),'STRING':([0,1,6,7,9,13,14,16,18,24,28,29,30,31,33,35,39,42,43,44,47,49,55,57,61,63,64,65,73,74,82,83,85,86,89,95,96,97,102,103,104,106,112,116,117,118,119,120,121,122,123,124,125,126,127,128,129,133,134,135,136,138,140,144,147,150,155,157,161,163,165,168,169,177,185,186,187,188,189,191,193,194,195,196,199,201,211,213,216,218,219,220,233,234,244,246,248,253,256,258,260,263,265,270,272,274,277,281,282,291,293,296,299,301,303,306,307,308,309,310,312,314,315,316,318,324,328,330,341,343,346,347,350,353,354,355,356,360,365,367,368,370,374,375,377,391,394,401,404,414,417,420,428,429,430,432,435,437,440,442,444,447,450,461,463,466,468,472,473,475,476,488,490,491,492,493,494,495,496,497,498,501,502,505,510,518,524,525,528,529,530,540,543,546,547,549,552,553,556,565,569,570,573,574,575,576,580,582,583,585,586,587,589,590,599,600,602,613,615,616,617,618,621,629,633,635,637,639,640,642,643,644,651,666,667,679,],[35,35,-140,35,35,35,-55,-143,-139,-137,-141,35,140,35,35,-298,35,-56,35,-9,-7,35,35,35,35,-8,-142,35,35,35,35,35,-144,35,-138,-57,35,-58,35,35,35,35,35,35,-125,-116,-120,-115,35,-118,-122,-117,-121,-124,-126,-123,-119,35,35,-181,-180,35,-299,35,35,35,35,35,35,35,35,35,35,35,-241,35,-237,-236,-244,-239,-242,-240,-238,-6,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,-51,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,-245,35,-243,35,35,35,35,35,35,35,35,-168,35,35,35,35,35,35,35,-163,-158,35,35,35,35,35,-371,35,35,35,-153,35,-177,-145,35,-169,35,-174,35,35,-162,35,35,35,35,-372,35,35,35,35,35,35,-150,35,-146,-147,-155,-52,35,35,-164,35,35,35,-157,35,35,35,35,35,35,-178,35,35,-149,-148,35,-10,-159,-160,-165,35,-371,35,-154,35,35,35,-179,35,-152,605,-11,35,35,35,35,35,-372,35,35,-151,-12,-156,35,-166,-167,35,-14,-15,35,35,35,35,35,-13,-161,-16,-17,-18,-19,]),'COLONEQUAL':([612,630,636,659,669,671,682,688,695,],[637,637,637,637,637,637,637,637,637,]),'IS':([10,12,23,30,32,35,37,38,51,52,67,68,72,90,101,105,107,113,131,132,140,143,149,151,160,162,164,166,170,181,183,190,210,215,222,223,224,225,226,232,239,240,241,247,254,262,267,268,269,271,278,279,280,300,305,336,344,351,364,371,378,395,],[-270,-250,-264,-297,-246,-298,-278,-254,-258,-282,-295,189,-296,-288,-279,-272,-271,-251,-265,-266,-299,-247,-255,-280,-293,-260,-259,-284,-286,-281,-291,189,-290,-289,-274,-276,-277,-275,-273,-252,-267,-268,-269,-248,-256,-294,-262,-263,-261,-314,-287,-317,-283,-292,-234,-253,-249,-257,-315,-285,-316,-235,]),'YIELD':([0,1,6,14,16,18,24,28,42,44,47,63,64,73,85,89,95,96,97,116,117,118,119,120,121,122,123,124,125,126,127,128,129,135,136,155,196,216,219,258,299,315,318,328,330,350,353,354,355,391,401,404,417,428,429,430,432,435,437,468,472,475,476,488,490,491,492,493,495,497,518,524,525,528,529,530,543,546,547,549,565,574,575,576,582,583,585,586,602,613,615,616,617,618,629,633,642,643,644,651,666,667,679,],[82,82,-140,-55,-143,-139,-137,-141,-56,-9,-7,-8,-142,82,-144,-138,-57,82,-58,82,-125,-116,-120,-115,82,-118,-122,-117,-121,-124,-126,-123,-119,-181,-180,82,-6,82,82,-51,82,82,82,-168,82,82,82,-163,-158,-153,-177,-145,-169,-174,82,82,-162,82,82,82,-150,-146,-147,-155,-52,82,82,-164,82,-157,82,-178,82,82,-149,-148,-10,-159,-160,-165,-154,-179,82,-152,-11,82,82,82,-151,-12,-156,82,-166,-167,-14,-15,82,-13,-161,-16,-17,-18,-19,]),'FINALLY':([95,97,258,259,354,355,432,490,493,546,549,617,618,],[-57,-58,-51,357,-163,434,-162,-52,-164,584,-165,-166,-167,]),'AT':([0,6,14,16,18,22,24,28,42,44,47,63,64,73,85,89,95,97,135,136,196,258,317,328,353,354,355,391,401,404,417,428,430,432,470,472,475,476,488,490,493,497,524,526,529,530,543,546,547,549,565,574,576,582,602,613,615,617,618,629,633,643,644,651,666,667,679,],[84,-140,-55,-143,-139,84,-137,-141,-56,-9,-7,-8,-142,84,-144,-138,-57,-58,-181,-180,-6,-51,-184,-168,84,-163,-158,-153,-177,-145,-169,-174,84,-162,-185,-150,-146,-147,-155,-52,-164,-157,-178,-186,-149,-148,-10,-159,-160,-165,-154,-179,-152,-11,-151,-12,-156,-166,-167,-14,-15,-13,-161,-16,-17,-18,-19,]),'AMPER':([10,23,30,35,37,38,51,52,67,72,90,101,105,107,131,132,140,149,151,160,162,164,166,170,181,183,210,215,222,223,224,225,226,239,240,241,254,262,267,268,269,271,278,279,280,300,351,364,371,378,],[-270,-264,-297,-298,-278,150,-258,-282,-295,-296,-288,-279,-272,-271,-265,-266,-299,253,-280,-293,-260,-259,-284,-286,-281,-291,-290,-289,-274,-276,-277,-275,-273,-267,-268,-269,-256,-294,-262,-263,-261,-314,-287,-317,-283,-292,-257,-315,-285,-316,]),'IN':([10,12,23,30,32,35,37,38,51,52,67,68,72,90,101,105,107,113,114,131,132,140,142,143,149,151,154,160,162,164,166,170,181,183,190,192,210,215,222,223,224,225,226,232,239,240,241,244,245,247,254,262,267,268,269,271,278,279,280,300,305,323,336,342,343,344,351,364,371,378,392,395,423,],[-270,-250,-264,-297,-246,-298,-278,-254,-258,-282,-295,193,-296,-288,-279,-272,-271,-251,234,-265,-266,-299,-338,-247,-255,-280,256,-293,-260,-259,-284,-286,-281,-291,193,308,-290,-289,-274,-276,-277,-275,-273,-252,-267,-268,-269,-339,-340,-248,-256,-294,-262,-263,-261,-314,-287,-317,-283,-292,-234,414,-253,-342,-341,-249,-257,-315,-285,-316,466,-235,-343,]),'IF':([0,6,10,12,14,16,18,23,24,27,28,30,32,35,37,38,42,44,46,47,48,51,52,63,64,67,68,72,73,75,85,89,90,95,97,101,105,107,113,131,132,135,136,140,143,149,151,156,160,162,164,166,170,181,183,190,196,198,204,210,215,222,223,224,225,226,232,239,240,241,247,254,258,261,262,267,268,269,271,278,279,280,300,305,311,328,336,344,351,353,354,355,358,364,371,378,391,395,397,401,404,417,428,430,432,472,475,476,485,488,490,493,497,519,520,521,522,524,529,530,543,546,547,549,565,571,574,576,579,582,597,598,599,601,602,613,615,617,618,626,627,629,633,643,644,651,666,667,679,],[86,-140,-270,-250,-55,-143,-139,-264,-137,138,-141,-297,-246,-298,-278,-254,-56,-9,-222,-7,-230,-258,-282,-8,-142,-295,-232,-296,86,-226,-144,-138,-288,-57,-58,-279,-272,-271,-251,-265,-266,-181,-180,-299,-247,-255,-280,-223,-293,-260,-259,-284,-286,-281,-291,-233,-6,-227,-231,-290,-289,-274,-276,-277,-275,-273,-252,-267,-268,-269,-248,-256,-51,-224,-294,-262,-263,-261,-314,-287,-317,-283,-292,-234,-228,-168,-253,-249,-257,86,-163,-158,-225,-315,-285,-316,-153,-235,-229,-177,-145,-169,-174,86,-162,-150,-146,-147,540,-155,-52,-164,-157,569,-388,-394,-393,-178,-149,-148,-10,-159,-160,-165,-154,-389,-179,-152,540,-11,569,-391,-390,-395,-151,-12,-156,-166,-167,-392,-396,-14,-15,-13,-161,-16,-17,-18,-19,]),'FROM':([0,6,14,16,18,24,28,42,44,47,63,64,73,85,89,95,96,97,135,136,155,196,216,219,258,299,315,318,328,330,350,353,354,355,391,401,404,417,428,429,430,432,435,437,468,472,475,476,488,490,491,492,493,495,497,518,524,525,528,529,530,543,546,547,549,565,574,575,576,582,583,585,586,602,613,615,616,617,618,629,633,642,643,644,651,666,667,679,],[87,-140,-55,-143,-139,-137,-141,-56,-9,-7,-8,-142,87,-144,-138,-57,87,-58,-181,-180,87,-6,87,87,-51,87,87,87,-168,87,87,87,-163,-158,-153,-177,-145,-169,-174,87,87,-162,87,87,87,-150,-146,-147,-155,-52,87,87,-164,87,-157,87,-178,87,87,-149,-148,-10,-159,-160,-165,-154,-179,87,-152,-11,87,87,87,-151,-12,-156,87,-166,-167,-14,-15,87,-13,-161,-16,-17,-18,-19,]),}

_lr_action = { }
for _k, _v in _lr_action_items.items():
   for _x,_y in zip(_v[0],_v[1]):
      if not _x in _lr_action:  _lr_action[_x] = { }
      _lr_action[_x][_k] = _y
del _lr_action_items

_lr_goto_items = {'import_as_name':([319,321,408,410,411,477,483,532,],[405,405,405,481,405,531,405,577,]),'try_stmt':([0,73,353,430,],[6,6,6,6,]),'small_stmt':([0,73,96,155,216,219,299,315,318,330,350,353,429,430,435,437,468,491,492,495,518,525,528,575,583,585,586,616,642,],[3,3,217,3,326,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,]),'augassign':([15,],[116,]),'import_from':([0,73,96,155,216,219,299,315,318,330,350,353,429,430,435,437,468,491,492,495,518,525,528,575,583,585,586,616,642,],[4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,]),'small_stmt_list':([0,73,155,219,299,315,318,330,350,353,429,430,435,437,468,491,492,495,518,525,528,575,583,585,586,616,642,],[5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,]),'import_as_names':([319,321,408,411,483,],[409,413,480,484,535,]),'else_stmt':([404,475,],[476,530,]),'comp_op':([68,190,],[186,307,]),'parameters':([148,],[252,]),'factor':([0,1,7,9,13,29,31,33,39,43,49,55,57,61,65,73,74,82,83,86,96,102,103,104,106,112,116,121,133,134,138,144,147,150,155,157,161,163,165,168,169,177,186,199,201,211,213,216,218,219,220,233,234,244,246,248,253,256,260,263,265,270,272,274,277,281,282,291,293,296,299,301,303,307,309,310,312,314,315,316,318,324,330,341,343,346,347,350,353,356,360,365,367,368,374,375,377,394,414,420,429,430,435,437,440,442,447,450,461,463,466,468,473,491,492,494,495,496,498,501,502,505,510,518,525,528,540,552,556,569,570,573,575,583,585,586,587,589,599,600,616,621,635,637,639,640,642,],[10,10,10,101,10,10,10,10,151,10,10,10,10,181,10,10,10,10,10,10,10,222,223,224,225,10,10,10,10,10,10,10,10,10,10,10,10,10,10,280,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,371,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,]),'suite':([155,219,299,315,318,330,350,429,435,437,468,491,492,495,518,525,528,575,583,585,586,616,642,],[259,328,391,401,404,417,428,488,493,497,524,546,547,549,565,574,576,602,615,617,618,644,664,]),'globals_list':([179,390,],[297,464,]),'exec_stmt':([0,73,96,155,216,219,299,315,318,330,350,353,429,430,435,437,468,491,492,495,518,525,528,575,583,585,586,616,642,],[40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,]),'and_expr_list':([38,],[149,]),'or_test_list':([46,],[156,]),'simple_stmt':([0,73,155,219,299,315,318,330,350,353,429,430,435,437,468,491,492,495,518,525,528,575,583,585,586,616,642,],[14,14,258,258,258,258,258,258,258,14,258,14,258,258,258,258,258,258,258,258,258,258,258,258,258,258,258,]),'dotted_as_names_list':([111,],[231,]),'subscriptlist':([169,],[285,]),'testlist':([0,29,73,82,96,116,121,155,216,219,256,299,314,315,318,330,350,353,429,430,435,437,468,491,492,495,518,525,528,575,583,585,586,616,642,],[15,139,15,203,15,236,238,15,15,15,352,15,400,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,]),'classdef':([0,25,73,353,430,],[16,135,16,16,16,]),'assert_stmt':([0,73,96,155,216,219,299,315,318,330,350,353,429,430,435,437,468,491,492,495,518,525,528,575,583,585,586,616,642,],[17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,]),'for_stmt':([0,73,353,430,],[18,18,18,18,]),'lambdef':([0,1,7,29,33,49,55,57,65,73,74,82,86,96,116,121,147,155,165,169,177,201,213,216,219,220,234,248,256,263,265,270,272,274,281,282,291,293,296,299,303,309,312,314,315,316,318,324,330,341,346,347,350,353,356,360,365,367,368,374,375,377,394,420,429,430,435,437,440,442,447,450,461,463,468,473,491,492,494,495,496,498,501,502,505,510,518,525,528,552,556,575,583,585,586,587,589,616,621,635,637,639,640,642,],[19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,]),'expr_stmt':([0,73,96,155,216,219,299,315,318,330,350,353,429,430,435,437,468,491,492,495,518,525,528,575,583,585,586,616,642,],[21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,]),'decorator':([0,22,73,353,430,],[22,22,22,22,22,]),'arith_op':([23,131,],[132,239,]),'term':([0,1,7,13,29,31,33,43,49,55,57,65,73,74,82,83,86,96,112,116,121,133,134,138,144,147,150,155,157,161,163,165,169,177,186,199,201,211,213,216,218,219,220,233,234,244,246,248,253,256,260,263,265,270,272,274,281,282,291,293,296,299,301,303,307,309,310,312,314,315,316,318,324,330,341,343,346,347,350,353,356,360,365,367,368,374,375,377,394,414,420,429,430,435,437,440,442,447,450,461,463,466,468,473,491,492,494,495,496,498,501,502,505,510,518,525,528,540,552,556,569,570,573,575,583,585,586,587,589,599,600,616,621,635,637,639,640,642,],[23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,240,241,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,]),'if_stmt':([0,73,353,430,],[24,24,24,24,]),'enaml_module':([0,],[41,]),'or_test':([0,1,7,29,33,49,55,57,65,73,74,82,86,96,116,121,138,147,155,165,169,177,201,213,216,219,220,234,248,256,263,265,270,272,274,281,282,291,293,296,299,303,309,312,314,315,316,318,324,330,341,346,347,350,353,356,360,365,367,368,374,375,377,394,414,420,429,430,435,437,440,442,447,450,461,463,466,468,473,491,492,494,495,496,498,501,502,505,510,518,525,528,540,552,556,569,570,573,575,583,585,586,587,589,599,600,616,621,635,637,639,640,642,],[27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,243,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,485,27,27,27,27,27,27,27,27,27,27,27,522,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,522,27,27,522,522,522,27,27,27,27,27,27,522,522,27,27,27,27,27,27,27,]),'with_stmt':([0,73,353,430,],[28,28,28,28,]),'comp_for':([92,159,275,361,485,579,],[214,266,369,441,538,538,]),'and_test_list':([75,],[198,]),'identifier':([580,628,677,],[611,649,692,]),'trailer':([52,166,],[170,278,]),'with_item_list':([99,329,],[221,416,]),'instantiation_body_items':([677,692,],[687,699,]),'expr_list':([32,],[143,]),'varargslist_list':([174,384,],[290,458,]),'atom_string_list':([0,1,7,9,13,29,31,33,39,43,49,55,57,61,65,73,74,82,83,86,96,102,103,104,106,112,116,121,133,134,138,144,147,150,155,157,161,163,165,168,169,177,186,199,201,211,213,216,218,219,220,233,234,244,246,248,253,256,260,263,265,270,272,274,277,281,282,291,293,296,299,301,303,307,309,310,312,314,315,316,318,324,330,341,343,346,347,350,353,356,360,365,367,368,374,375,377,394,414,420,429,430,435,437,440,442,447,450,461,463,466,468,473,491,492,494,495,496,498,501,502,505,510,518,525,528,540,552,556,569,570,573,575,583,585,586,587,589,599,600,616,621,635,637,639,640,642,],[30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,]),'listmaker':([65,],[182,]),'arglist':([165,316,],[273,403,]),'exprlist_list':([142,],[245,]),'flow_stmt':([0,73,96,155,216,219,299,315,318,330,350,353,429,430,435,437,468,491,492,495,518,525,528,575,583,585,586,616,642,],[36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,]),'comp_if':([485,579,],[537,537,]),'shift_expr':([0,1,7,13,29,31,33,43,49,55,57,65,73,74,82,83,86,96,112,116,121,138,144,147,150,155,157,165,169,177,186,199,201,211,213,216,218,219,220,233,234,244,246,248,253,256,260,263,265,270,272,274,281,282,291,293,296,299,301,303,307,309,310,312,314,315,316,318,324,330,341,343,346,347,350,353,356,360,365,367,368,374,375,377,394,414,420,429,430,435,437,440,442,447,450,461,463,466,468,473,491,492,494,495,496,498,501,502,505,510,518,525,528,540,552,556,569,570,573,575,583,585,586,587,589,599,600,616,621,635,637,639,640,642,],[38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,254,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,351,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,]),'import_from_dots':([87,],[208,]),'arglist_list':([165,316,442,],[274,274,502,]),'list_iter':([519,597,],[566,625,]),'dictorsetmaker':([49,],[158,]),'list_for':([184,519,597,],[302,568,568,]),'subscript':([169,377,450,],[284,451,506,]),'decorators':([0,22,73,353,430,],[25,130,25,25,25,]),'compound_stmt':([0,73,353,430,],[42,42,42,42,]),'dosm_comma_list':([159,],[264,]),'dotted_name':([11,84,87,208,230,335,],[108,205,207,320,108,108,]),'power':([0,1,7,9,13,29,31,33,39,43,49,55,57,61,65,73,74,82,83,86,96,102,103,104,106,112,116,121,133,134,138,144,147,150,155,157,161,163,165,168,169,177,186,199,201,211,213,216,218,219,220,233,234,244,246,248,253,256,260,263,265,270,272,274,277,281,282,291,293,296,299,301,303,307,309,310,312,314,315,316,318,324,330,341,343,346,347,350,353,356,360,365,367,368,374,375,377,394,414,420,429,430,435,437,440,442,447,450,461,463,466,468,473,491,492,494,495,496,498,501,502,505,510,518,525,528,540,552,556,569,570,573,575,583,585,586,587,589,599,600,616,621,635,637,639,640,642,],[37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,]),'xor_expr_list':([12,],[113,]),'stmt':([0,73,353,430,],[44,44,430,430,]),'fplist_list':([287,],[380,]),'xor_expr':([0,1,7,13,29,31,33,43,49,55,57,65,73,74,82,83,86,96,116,121,138,144,147,155,157,165,169,177,186,199,201,211,213,216,218,219,220,234,244,246,248,256,260,263,265,270,272,274,281,282,291,293,296,299,301,303,307,309,310,312,314,315,316,318,324,330,341,343,346,347,350,353,356,360,365,367,368,374,375,377,394,414,420,429,430,435,437,440,442,447,450,461,463,466,468,473,491,492,494,495,496,498,501,502,505,510,518,525,528,540,552,556,569,570,573,575,583,585,586,587,589,599,600,616,621,635,637,639,640,642,],[32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,247,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,344,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,]),'term_list':([10,],[107,]),'comparison':([0,1,7,29,33,49,55,57,65,73,74,82,83,86,96,116,121,138,147,155,157,165,169,177,199,201,213,216,219,220,234,248,256,260,263,265,270,272,274,281,282,291,293,296,299,303,309,310,312,314,315,316,318,324,330,341,346,347,350,353,356,360,365,367,368,374,375,377,394,414,420,429,430,435,437,440,442,447,450,461,463,466,468,473,491,492,494,495,496,498,501,502,505,510,518,525,528,540,552,556,569,570,573,575,583,585,586,587,589,599,600,616,621,635,637,639,640,642,],[48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,]),'pass_stmt':([0,73,96,155,216,219,299,315,318,330,350,353,429,430,435,437,468,491,492,495,518,525,528,575,583,585,586,616,642,],[50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,]),'arith_expr':([0,1,7,13,29,31,33,43,49,55,57,65,73,74,82,83,86,96,112,116,121,138,144,147,150,155,157,161,163,165,169,177,186,199,201,211,213,216,218,219,220,233,234,244,246,248,253,256,260,263,265,270,272,274,281,282,291,293,296,299,301,303,307,309,310,312,314,315,316,318,324,330,341,343,346,347,350,353,356,360,365,367,368,374,375,377,394,414,420,429,430,435,437,440,442,447,450,461,463,466,468,473,491,492,494,495,496,498,501,502,505,510,518,525,528,540,552,556,569,570,573,575,583,585,586,587,589,599,600,616,621,635,637,639,640,642,],[51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,267,268,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,]),'declaration_body_item':([580,609,611,628,634,648,649,668,],[607,631,607,607,631,631,607,631,]),'instantiation_body_item':([677,687,692,699,],[689,696,689,696,]),'atom':([0,1,7,9,13,29,31,33,39,43,49,55,57,61,65,73,74,82,83,86,96,102,103,104,106,112,116,121,133,134,138,144,147,150,155,157,161,163,165,168,169,177,186,199,201,211,213,216,218,219,220,233,234,244,246,248,253,256,260,263,265,270,272,274,277,281,282,291,293,296,299,301,303,307,309,310,312,314,315,316,318,324,330,341,343,346,347,350,353,356,360,365,367,368,374,375,377,394,414,420,429,430,435,437,440,442,447,450,461,463,466,468,473,491,492,494,495,496,498,501,502,505,510,518,525,528,540,552,556,569,570,573,575,583,585,586,587,589,599,600,616,621,635,637,639,640,642,],[52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,]),'import_stmt':([0,73,96,155,216,219,299,315,318,330,350,353,429,430,435,437,468,491,492,495,518,525,528,575,583,585,586,616,642,],[59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,59,]),'elif_stmts':([404,],[475,]),'comp_iter':([485,579,],[539,603,]),'print_list_list':([146,426,],[249,249,]),'dotted_as_names':([11,],[110,]),'shift_op':([51,164,],[162,269,]),'attribute_declaration':([580,609,611,628,634,648,649,668,],[606,606,606,606,606,606,606,606,]),'return_stmt':([0,73,96,155,216,219,299,315,318,330,350,353,429,430,435,437,468,491,492,495,518,525,528,575,583,585,586,616,642,],[58,58,58,58,58,58,58,58,58,58,58,58,58,58,58,58,58,58,58,58,58,58,58,58,58,58,58,58,58,]),'testlist_comp':([1,],[91,]),'old_test':([466,540,569,570,573,599,600,],[520,579,597,598,601,626,627,]),'testlist_safe_list':([520,],[571,]),'instantiation':([580,609,611,628,634,648,649,668,677,687,692,699,],[604,604,604,604,604,604,604,604,686,686,686,686,]),'enaml_module_item':([0,73,],[47,196,]),'continue_stmt':([0,73,96,155,216,219,299,315,318,330,350,353,429,430,435,437,468,491,492,495,518,525,528,575,583,585,586,616,642,],[60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,]),'testlist_list':([77,],[200,]),'attribute_binding':([580,609,611,628,634,641,648,649,650,668,676,677,687,692,699,],[608,608,608,608,608,661,608,608,661,608,683,690,690,690,690,]),'dotted_as_name':([11,230,335,],[111,334,419,]),'equal_list':([15,237,238,],[115,338,339,]),'print_stmt':([0,73,96,155,216,219,299,315,318,330,350,353,429,430,435,437,468,491,492,495,518,525,528,575,583,585,586,616,642,],[62,62,62,62,62,62,62,62,62,62,62,62,62,62,62,62,62,62,62,62,62,62,62,62,62,62,62,62,62,]),'binding':([612,630,636,659,669,671,682,688,695,],[638,638,654,638,638,681,638,638,638,]),'term_op':([10,107,],[105,226,]),'declaration':([0,73,],[63,63,]),'funcdef':([0,25,73,353,430,],[64,136,64,64,64,]),'raise_stmt':([0,73,96,155,216,219,299,315,318,330,350,353,429,430,435,437,468,491,492,495,518,525,528,575,583,585,586,616,642,],[66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,66,]),'old_lambdef':([466,540,569,570,573,599,600,],[521,521,521,521,521,521,521,]),'exprlist':([31,43,211,301,],[141,154,323,392,]),'expr':([0,1,7,13,29,31,33,43,49,55,57,65,73,74,82,83,86,96,116,121,138,147,155,157,165,169,177,186,199,201,211,213,216,218,219,220,234,244,248,256,260,263,265,270,272,274,281,282,291,293,296,299,301,303,307,309,310,312,314,315,316,318,324,330,341,343,346,347,350,353,356,360,365,367,368,374,375,377,394,414,420,429,430,435,437,440,442,447,450,461,463,466,468,473,491,492,494,495,496,498,501,502,505,510,518,525,528,540,552,556,569,570,573,575,583,585,586,587,589,599,600,616,621,635,637,639,640,642,],[68,68,68,114,68,142,68,142,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,305,68,68,142,68,68,327,68,68,68,342,68,68,68,68,68,68,68,68,68,68,68,68,68,68,142,68,395,68,68,68,68,68,68,68,68,68,68,423,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,]),'declaration_body':([487,581,],[543,613,]),'except_clause':([259,354,],[354,354,]),'and_expr':([0,1,7,13,29,31,33,43,49,55,57,65,73,74,82,83,86,96,112,116,121,138,144,147,155,157,165,169,177,186,199,201,211,213,216,218,219,220,233,234,244,246,248,256,260,263,265,270,272,274,281,282,291,293,296,299,301,303,307,309,310,312,314,315,316,318,324,330,341,343,346,347,350,353,356,360,365,367,368,374,375,377,394,414,420,429,430,435,437,440,442,447,450,461,463,466,468,473,491,492,494,495,496,498,501,502,505,510,518,525,528,540,552,556,569,570,573,575,583,585,586,587,589,599,600,616,621,635,637,639,640,642,],[12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,232,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,336,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,]),'instantiation_body':([641,650,676,],[663,663,685,]),'yield_stmt':([0,73,96,155,216,219,299,315,318,330,350,353,429,430,435,437,468,491,492,495,518,525,528,575,583,585,586,616,642,],[70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,]),'arith_expr_list':([23,],[131,]),'shift_list':([51,],[164,]),'enaml':([0,],[71,]),'subscriptlist_list':([284,],[376,]),'argument':([165,274,316,442,502,],[276,366,276,500,555,]),'enaml_module_body':([0,],[73,]),'fplist':([171,],[288,]),'testlist_safe':([466,],[519,]),'not_test':([0,1,7,29,33,49,55,57,65,73,74,82,83,86,96,116,121,138,147,155,157,165,169,177,199,201,213,216,219,220,234,248,256,260,263,265,270,272,274,281,282,291,293,296,299,303,309,310,312,314,315,316,318,324,330,341,346,347,350,353,356,360,365,367,368,374,375,377,394,414,420,429,430,435,437,440,442,447,450,461,463,466,468,473,491,492,494,495,496,498,501,502,505,510,518,525,528,540,552,556,569,570,573,575,583,585,586,587,589,599,600,616,621,635,637,639,640,642,],[75,75,75,75,75,75,75,75,75,75,75,75,204,75,75,75,75,75,75,75,75,75,75,75,311,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,397,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,]),'print_list':([33,347,],[145,425,]),'break_stmt':([0,73,96,155,216,219,299,315,318,330,350,353,429,430,435,437,468,491,492,495,518,525,528,575,583,585,586,616,642,],[76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,]),'del_stmt':([0,73,96,155,216,219,299,315,318,330,350,353,429,430,435,437,468,491,492,495,518,525,528,575,583,585,586,616,642,],[88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,]),'fpdef':([54,171,251,292,379,383,453,459,512,523,],[174,287,174,386,452,456,507,386,456,174,]),'testlist_comp_list':([92,],[212,]),'small_stmt_list_list':([3,],[94,]),'list_if':([519,597,],[567,567,]),'test':([0,1,7,29,33,49,55,57,65,73,74,82,86,96,116,121,147,155,165,169,177,201,213,216,219,220,234,248,256,263,265,270,272,274,281,282,291,293,296,299,303,309,312,314,315,316,318,324,330,341,346,347,350,353,356,360,365,367,368,374,375,377,394,420,429,430,435,437,440,442,447,450,461,463,468,473,491,492,494,495,496,498,501,502,505,510,518,525,528,552,556,575,583,585,586,587,589,616,621,635,637,639,640,642,],[77,92,98,77,146,159,178,180,184,77,197,77,206,77,77,77,250,77,275,283,295,313,325,77,77,98,337,345,77,359,361,362,363,275,372,373,384,388,389,77,393,396,398,77,77,275,77,415,77,422,424,426,77,77,436,438,443,445,446,448,449,283,467,486,77,77,77,77,499,275,504,283,516,517,77,527,77,77,548,77,550,551,554,275,557,559,77,77,77,588,591,77,77,77,77,619,620,77,645,652,656,657,658,77,]),'global_stmt':([0,73,96,155,216,219,299,315,318,330,350,353,429,430,435,437,468,491,492,495,518,525,528,575,583,585,586,616,642,],[78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,]),'import_as_names_list':([405,],[478,]),'with_item':([7,220,],[99,329,]),'import_name':([0,73,96,155,216,219,299,315,318,330,350,353,429,430,435,437,468,491,492,495,518,525,528,575,583,585,586,616,642,],[79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,]),'yield_expr':([0,1,73,96,116,121,155,216,219,299,315,318,330,350,353,429,430,435,437,468,491,492,495,518,525,528,575,583,585,586,616,642,],[81,93,81,81,235,237,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,]),'except_clauses':([259,354,],[355,432,]),'comparison_list':([68,],[190,]),'and_test':([0,1,7,29,33,49,55,57,65,73,74,82,86,96,116,121,138,147,155,157,165,169,177,201,213,216,219,220,234,248,256,260,263,265,270,272,274,281,282,291,293,296,299,303,309,312,314,315,316,318,324,330,341,346,347,350,353,356,360,365,367,368,374,375,377,394,414,420,429,430,435,437,440,442,447,450,461,463,466,468,473,491,492,494,495,496,498,501,502,505,510,518,525,528,540,552,556,569,570,573,575,583,585,586,587,589,599,600,616,621,635,637,639,640,642,],[46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,261,46,46,46,46,46,46,46,46,46,46,46,358,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,]),'declaration_body_items':([580,611,628,649,],[609,634,648,668,]),'decorated':([0,73,353,430,],[85,85,85,85,]),'stmt_list':([353,430,],[431,489,]),'elif_stmt':([404,475,],[472,529,]),'dosm_colon_list':([361,],[439,]),'power_list':([52,],[166,]),'while_stmt':([0,73,353,430,],[89,89,89,89,]),'varargslist':([54,251,523,],[175,349,572,]),'dotted_name_list':([109,],[228,]),'listmaker_list':([184,],[304,]),}

_lr_goto = { }
for _k, _v in _lr_goto_items.items():
   for _x,_y in zip(_v[0],_v[1]):
       if not _x in _lr_goto: _lr_goto[_x] = { }
       _lr_goto[_x][_k] = _y
del _lr_goto_items
_lr_productions = [
  ("S' -> enaml","S'",1,None,None,None),
  ('enaml -> enaml_module NEWLINE ENDMARKER','enaml',3,'p_enaml1','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',351),
  ('enaml -> enaml_module ENDMARKER','enaml',2,'p_enaml1','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',352),
  ('enaml -> NEWLINE ENDMARKER','enaml',2,'p_enaml2','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',357),
  ('enaml -> ENDMARKER','enaml',1,'p_enaml2','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',358),
  ('enaml_module -> enaml_module_body','enaml_module',1,'p_enaml_module','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',363),
  ('enaml_module_body -> enaml_module_body enaml_module_item','enaml_module_body',2,'p_enaml_module_body1','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',384),
  ('enaml_module_body -> enaml_module_item','enaml_module_body',1,'p_enaml_module_body2','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',389),
  ('enaml_module_item -> declaration','enaml_module_item',1,'p_enaml_module_item2','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',394),
  ('enaml_module_item -> stmt','enaml_module_item',1,'p_enaml_module_item1','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',399),
  ('declaration -> ENAMLDEF NAME LPAR NAME RPAR COLON declaration_body','declaration',7,'p_declaration1','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',407),
  ('declaration -> ENAMLDEF NAME LPAR NAME RPAR COLON PASS NEWLINE','declaration',8,'p_declaration2','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',414),
  ('declaration -> ENAMLDEF NAME LPAR NAME RPAR COLON NAME COLON declaration_body','declaration',9,'p_declaration3','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',424),
  ('declaration -> ENAMLDEF NAME LPAR NAME RPAR COLON NAME COLON PASS NEWLINE','declaration',10,'p_declaration4','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',438),
  ('declaration_body -> NEWLINE INDENT declaration_body_items DEDENT','declaration_body',4,'p_declaration_body1','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',448),
  ('declaration_body -> NEWLINE INDENT identifier DEDENT','declaration_body',4,'p_declaration_body2','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',455),
  ('declaration_body -> NEWLINE INDENT identifier declaration_body_items DEDENT','declaration_body',5,'p_declaration_body3','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',460),
  ('declaration_body -> NEWLINE INDENT STRING NEWLINE declaration_body_items DEDENT','declaration_body',6,'p_declaration_body4','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',467),
  ('declaration_body -> NEWLINE INDENT STRING NEWLINE identifier DEDENT','declaration_body',6,'p_declaration_body5','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',474),
  ('declaration_body -> NEWLINE INDENT STRING NEWLINE identifier declaration_body_items DEDENT','declaration_body',7,'p_declaration_body6','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',479),
  ('declaration_body_items -> declaration_body_item','declaration_body_items',1,'p_declaration_body_items1','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',486),
  ('declaration_body_items -> declaration_body_items declaration_body_item','declaration_body_items',2,'p_declaration_body_items2','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',491),
  ('declaration_body_item -> attribute_declaration','declaration_body_item',1,'p_declaration_body_item1','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',496),
  ('declaration_body_item -> attribute_binding','declaration_body_item',1,'p_declaration_body_item2','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',501),
  ('declaration_body_item -> instantiation','declaration_body_item',1,'p_declaration_body_item3','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',506),
  ('declaration_body_item -> PASS NEWLINE','declaration_body_item',2,'p_declaration_body_item4','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',511),
  ('attribute_declaration -> NAME NAME NEWLINE','attribute_declaration',3,'p_attribute_declaration1','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',519),
  ('attribute_declaration -> NAME NAME COLON NAME NEWLINE','attribute_declaration',5,'p_attribute_declaration2','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',524),
  ('attribute_declaration -> NAME NAME binding','attribute_declaration',3,'p_attribute_declaration3','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',529),
  ('attribute_declaration -> NAME NAME COLON NAME binding','attribute_declaration',5,'p_attribute_declaration4','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',537),
  ('identifier -> NAME COLON NAME NEWLINE','identifier',4,'p_identifier','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',548),
  ('instantiation -> NAME COLON instantiation_body','instantiation',3,'p_instantiation1','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',560),
  ('instantiation -> NAME COLON attribute_binding','instantiation',3,'p_instantiation2','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',566),
  ('instantiation -> NAME COLON PASS NEWLINE','instantiation',4,'p_instantiation3','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',571),
  ('instantiation -> NAME COLON NAME COLON instantiation_body','instantiation',5,'p_instantiation4','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',576),
  ('instantiation -> NAME COLON NAME COLON attribute_binding','instantiation',5,'p_instantiation5','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',585),
  ('instantiation -> NAME COLON NAME COLON PASS NEWLINE','instantiation',6,'p_instantiation6','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',590),
  ('instantiation_body -> NEWLINE INDENT instantiation_body_items DEDENT','instantiation_body',4,'p_instantiation_body1','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',595),
  ('instantiation_body -> NEWLINE INDENT identifier DEDENT','instantiation_body',4,'p_instantiation_body2','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',602),
  ('instantiation_body -> NEWLINE INDENT identifier instantiation_body_items DEDENT','instantiation_body',5,'p_instantiation_body3','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',607),
  ('instantiation_body_items -> instantiation_body_item','instantiation_body_items',1,'p_instantiation_body_items1','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',614),
  ('instantiation_body_items -> instantiation_body_items instantiation_body_item','instantiation_body_items',2,'p_instantiation_body_items2','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',619),
  ('instantiation_body_item -> instantiation','instantiation_body_item',1,'p_instantiation_body_item1','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',624),
  ('instantiation_body_item -> attribute_binding','instantiation_body_item',1,'p_instantiation_body_item2','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',629),
  ('instantiation_body_item -> PASS NEWLINE','instantiation_body_item',2,'p_instantiation_body_item3','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',634),
  ('attribute_binding -> NAME binding','attribute_binding',2,'p_attribute_binding','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',642),
  ('binding -> EQUAL test NEWLINE','binding',3,'p_binding1','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',647),
  ('binding -> LEFTSHIFT test NEWLINE','binding',3,'p_binding1','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',648),
  ('binding -> COLONEQUAL test NEWLINE','binding',3,'p_binding2','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',659),
  ('binding -> RIGHTSHIFT test NEWLINE','binding',3,'p_binding2','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',660),
  ('binding -> DOUBLECOLON suite','binding',2,'p_binding3','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',672),
  ('suite -> simple_stmt','suite',1,'p_suite1','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',690),
  ('suite -> NEWLINE INDENT stmt_list DEDENT','suite',4,'p_suite2','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',702),
  ('stmt_list -> stmt stmt_list','stmt_list',2,'p_stmt_list1','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',707),
  ('stmt_list -> stmt','stmt_list',1,'p_stmt_list2','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',719),
  ('stmt -> simple_stmt','stmt',1,'p_stmt','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',731),
  ('stmt -> compound_stmt','stmt',1,'p_stmt','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',732),
  ('simple_stmt -> small_stmt NEWLINE','simple_stmt',2,'p_simple_stmt1','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',737),
  ('simple_stmt -> small_stmt_list NEWLINE','simple_stmt',2,'p_simple_stmt2','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',745),
  ('small_stmt_list -> small_stmt SEMI','small_stmt_list',2,'p_small_stmt_list1','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',755),
  ('small_stmt_list -> small_stmt small_stmt_list_list','small_stmt_list',2,'p_small_stmt_list2','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',760),
  ('small_stmt_list -> small_stmt small_stmt_list_list SEMI','small_stmt_list',3,'p_small_stmt_list3','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',765),
  ('small_stmt_list_list -> SEMI small_stmt','small_stmt_list_list',2,'p_small_stmt_list_list1','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',770),
  ('small_stmt_list_list -> small_stmt_list_list SEMI small_stmt','small_stmt_list_list',3,'p_small_stmt_list_list2','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',775),
  ('small_stmt -> expr_stmt','small_stmt',1,'p_small_stmt1','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',780),
  ('small_stmt -> print_stmt','small_stmt',1,'p_small_stmt1','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',781),
  ('small_stmt -> del_stmt','small_stmt',1,'p_small_stmt1','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',782),
  ('small_stmt -> pass_stmt','small_stmt',1,'p_small_stmt1','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',783),
  ('small_stmt -> flow_stmt','small_stmt',1,'p_small_stmt1','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',784),
  ('small_stmt -> import_stmt','small_stmt',1,'p_small_stmt1','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',785),
  ('small_stmt -> global_stmt','small_stmt',1,'p_small_stmt1','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',786),
  ('small_stmt -> exec_stmt','small_stmt',1,'p_small_stmt1','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',787),
  ('small_stmt -> assert_stmt','small_stmt',1,'p_small_stmt1','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',788),
  ('print_stmt -> PRINT','print_stmt',1,'p_print_stmt1','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',793),
  ('print_stmt -> PRINT test','print_stmt',2,'p_print_stmt2','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',802),
  ('print_stmt -> PRINT print_list','print_stmt',2,'p_print_stmt3','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',811),
  ('print_stmt -> PRINT RIGHTSHIFT test','print_stmt',3,'p_print_stmt4','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',826),
  ('print_stmt -> PRINT RIGHTSHIFT test COMMA test','print_stmt',5,'p_print_stmt5','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',835),
  ('print_stmt -> PRINT RIGHTSHIFT test COMMA print_list','print_stmt',5,'p_print_stmt6','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',844),
  ('print_list -> test COMMA','print_list',2,'p_print_list1','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',859),
  ('print_list -> test print_list_list','print_list',2,'p_print_list2','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',864),
  ('print_list -> test print_list_list COMMA','print_list',3,'p_print_list3','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',869),
  ('print_list_list -> COMMA test','print_list_list',2,'p_print_list_list1','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',874),
  ('print_list_list -> print_list_list COMMA test','print_list_list',3,'p_print_list_list2','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',879),
  ('del_stmt -> DEL exprlist','del_stmt',2,'p_del_stmt','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',884),
  ('pass_stmt -> PASS','pass_stmt',1,'p_pass_stmt','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',893),
  ('flow_stmt -> break_stmt','flow_stmt',1,'p_flow_stmt','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',900),
  ('flow_stmt -> continue_stmt','flow_stmt',1,'p_flow_stmt','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',901),
  ('flow_stmt -> return_stmt','flow_stmt',1,'p_flow_stmt','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',902),
  ('flow_stmt -> raise_stmt','flow_stmt',1,'p_flow_stmt','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',903),
  ('flow_stmt -> yield_stmt','flow_stmt',1,'p_flow_stmt','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',904),
  ('break_stmt -> BREAK','break_stmt',1,'p_break_stmt','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',909),
  ('continue_stmt -> CONTINUE','continue_stmt',1,'p_continue_stmt','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',916),
  ('return_stmt -> RETURN','return_stmt',1,'p_return_stmt1','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',923),
  ('return_stmt -> RETURN testlist','return_stmt',2,'p_return_stmt2','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',930),
  ('raise_stmt -> RAISE','raise_stmt',1,'p_raise_stmt1','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',938),
  ('raise_stmt -> RAISE test','raise_stmt',2,'p_raise_stmt2','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',947),
  ('raise_stmt -> RAISE test COMMA test','raise_stmt',4,'p_raise_stmt3','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',956),
  ('raise_stmt -> RAISE test COMMA test COMMA test','raise_stmt',6,'p_raise_stmt4','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',965),
  ('yield_stmt -> yield_expr','yield_stmt',1,'p_yield_stmt','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',974),
  ('yield_expr -> YIELD','yield_expr',1,'p_yield_expr1','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',979),
  ('yield_expr -> YIELD testlist','yield_expr',2,'p_yield_expr2','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',984),
  ('global_stmt -> GLOBAL NAME','global_stmt',2,'p_global_stmt1','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',990),
  ('global_stmt -> GLOBAL NAME globals_list','global_stmt',3,'p_global_stmt2','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',998),
  ('globals_list -> COMMA NAME globals_list','globals_list',3,'p_globals_list1','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1006),
  ('globals_list -> COMMA NAME','globals_list',2,'p_globals_list2','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1011),
  ('exec_stmt -> EXEC expr','exec_stmt',2,'p_exec_stmt1','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1016),
  ('exec_stmt -> EXEC expr IN test','exec_stmt',4,'p_exec_stmt2','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1025),
  ('exec_stmt -> EXEC expr IN test COMMA test','exec_stmt',6,'p_exec_stmt3','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1034),
  ('assert_stmt -> ASSERT test','assert_stmt',2,'p_assert_stmt1','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1043),
  ('assert_stmt -> ASSERT test COMMA test','assert_stmt',4,'p_assert_stmt2','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1051),
  ('expr_stmt -> testlist','expr_stmt',1,'p_expr_stmt1','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1059),
  ('expr_stmt -> testlist augassign testlist','expr_stmt',3,'p_expr_stmt2','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1066),
  ('expr_stmt -> testlist augassign yield_expr','expr_stmt',3,'p_expr_stmt2','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1067),
  ('expr_stmt -> testlist equal_list','expr_stmt',2,'p_expr_stmt3','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1083),
  ('augassign -> AMPEREQUAL','augassign',1,'p_augassign','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1099),
  ('augassign -> CIRCUMFLEXEQUAL','augassign',1,'p_augassign','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1100),
  ('augassign -> DOUBLESLASHEQUAL','augassign',1,'p_augassign','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1101),
  ('augassign -> DOUBLESTAREQUAL','augassign',1,'p_augassign','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1102),
  ('augassign -> LEFTSHIFTEQUAL','augassign',1,'p_augassign','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1103),
  ('augassign -> MINUSEQUAL','augassign',1,'p_augassign','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1104),
  ('augassign -> PERCENTEQUAL','augassign',1,'p_augassign','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1105),
  ('augassign -> PLUSEQUAL','augassign',1,'p_augassign','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1106),
  ('augassign -> RIGHTSHIFTEQUAL','augassign',1,'p_augassign','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1107),
  ('augassign -> SLASHEQUAL','augassign',1,'p_augassign','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1108),
  ('augassign -> STAREQUAL','augassign',1,'p_augassign','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1109),
  ('augassign -> VBAREQUAL','augassign',1,'p_augassign','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1110),
  ('equal_list -> EQUAL testlist','equal_list',2,'p_equal_list1','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1117),
  ('equal_list -> EQUAL yield_expr','equal_list',2,'p_equal_list1','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1118),
  ('equal_list -> EQUAL testlist equal_list','equal_list',3,'p_equal_list2','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1123),
  ('equal_list -> EQUAL yield_expr equal_list','equal_list',3,'p_equal_list2','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1124),
  ('testlist -> test','testlist',1,'p_testlist1','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1129),
  ('testlist -> test COMMA','testlist',2,'p_testlist2','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1134),
  ('testlist -> test testlist_list','testlist',2,'p_testlist3','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1139),
  ('testlist -> test testlist_list COMMA','testlist',3,'p_testlist4','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1144),
  ('testlist_list -> COMMA test','testlist_list',2,'p_testlist_list1','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1149),
  ('testlist_list -> testlist_list COMMA test','testlist_list',3,'p_testlist_list2','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1154),
  ('compound_stmt -> if_stmt','compound_stmt',1,'p_compound_stmt','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1159),
  ('compound_stmt -> while_stmt','compound_stmt',1,'p_compound_stmt','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1160),
  ('compound_stmt -> for_stmt','compound_stmt',1,'p_compound_stmt','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1161),
  ('compound_stmt -> try_stmt','compound_stmt',1,'p_compound_stmt','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1162),
  ('compound_stmt -> with_stmt','compound_stmt',1,'p_compound_stmt','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1163),
  ('compound_stmt -> funcdef','compound_stmt',1,'p_compound_stmt','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1164),
  ('compound_stmt -> classdef','compound_stmt',1,'p_compound_stmt','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1165),
  ('compound_stmt -> decorated','compound_stmt',1,'p_compound_stmt','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1166),
  ('if_stmt -> IF test COLON suite','if_stmt',4,'p_if_stmt1','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1171),
  ('if_stmt -> IF test COLON suite elif_stmts','if_stmt',5,'p_if_stmt2','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1182),
  ('if_stmt -> IF test COLON suite else_stmt','if_stmt',5,'p_if_stmt3','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1193),
  ('if_stmt -> IF test COLON suite elif_stmts else_stmt','if_stmt',6,'p_if_stmt4','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1204),
  ('elif_stmts -> elif_stmts elif_stmt','elif_stmts',2,'p_elif_stmts1','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1220),
  ('elif_stmts -> elif_stmt','elif_stmts',1,'p_elif_stmts2','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1227),
  ('elif_stmt -> ELIF test COLON suite','elif_stmt',4,'p_elif_stmt','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1232),
  ('else_stmt -> ELSE COLON suite','else_stmt',3,'p_else_stmt','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1243),
  ('while_stmt -> WHILE test COLON suite','while_stmt',4,'p_while_stmt1','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1248),
  ('while_stmt -> WHILE test COLON suite ELSE COLON suite','while_stmt',7,'p_while_stmt2','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1259),
  ('for_stmt -> FOR exprlist IN testlist COLON suite','for_stmt',6,'p_for_stmt1','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1270),
  ('for_stmt -> FOR exprlist IN testlist COLON suite ELSE COLON suite','for_stmt',9,'p_for_stmt2','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1284),
  ('try_stmt -> TRY COLON suite FINALLY COLON suite','try_stmt',6,'p_try_stmt1','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1298),
  ('try_stmt -> TRY COLON suite except_clauses','try_stmt',4,'p_try_stmt2','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1308),
  ('try_stmt -> TRY COLON suite except_clauses ELSE COLON suite','try_stmt',7,'p_try_stmt3','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1319),
  ('try_stmt -> TRY COLON suite except_clauses FINALLY COLON suite','try_stmt',7,'p_try_stmt4','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1330),
  ('try_stmt -> TRY COLON suite except_clauses ELSE COLON suite FINALLY COLON suite','try_stmt',10,'p_try_stmt5','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1347),
  ('except_clauses -> except_clause except_clauses','except_clauses',2,'p_except_clauses1','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1364),
  ('except_clauses -> except_clause','except_clauses',1,'p_except_clauses2','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1369),
  ('except_clause -> EXCEPT COLON suite','except_clause',3,'p_except_clause1','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1374),
  ('except_clause -> EXCEPT test COLON suite','except_clause',4,'p_except_clause2','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1385),
  ('except_clause -> EXCEPT test AS test COLON suite','except_clause',6,'p_except_clause3','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1396),
  ('except_clause -> EXCEPT test COMMA test COLON suite','except_clause',6,'p_except_clause3','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1397),
  ('with_stmt -> WITH with_item COLON suite','with_stmt',4,'p_with_stmt1','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1410),
  ('with_stmt -> WITH with_item with_item_list COLON suite','with_stmt',5,'p_with_stmt2','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1422),
  ('with_item -> test','with_item',1,'p_with_item1','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1442),
  ('with_item -> test AS expr','with_item',3,'p_with_item2','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1447),
  ('with_item_list -> COMMA with_item with_item_list','with_item_list',3,'p_with_item_list1','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1454),
  ('with_item_list -> COMMA with_item','with_item_list',2,'p_with_item_list2','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1459),
  ('funcdef -> DEF NAME parameters COLON suite','funcdef',5,'p_funcdef','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1464),
  ('parameters -> LPAR RPAR','parameters',2,'p_parameters1','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1476),
  ('parameters -> LPAR varargslist RPAR','parameters',3,'p_parameters2','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1481),
  ('classdef -> CLASS NAME COLON suite','classdef',4,'p_classdef1','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1486),
  ('classdef -> CLASS NAME LPAR RPAR COLON suite','classdef',6,'p_classdef2','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1498),
  ('classdef -> CLASS NAME LPAR testlist RPAR COLON suite','classdef',7,'p_classdef3','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1510),
  ('decorated -> decorators funcdef','decorated',2,'p_decorated','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1525),
  ('decorated -> decorators classdef','decorated',2,'p_decorated','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1526),
  ('decorators -> decorator decorators','decorators',2,'p_decorators1','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1534),
  ('decorators -> decorator','decorators',1,'p_decorators2','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1539),
  ('decorator -> AT dotted_name NEWLINE','decorator',3,'p_decorator1','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1544),
  ('decorator -> AT dotted_name LPAR RPAR NEWLINE','decorator',5,'p_decorator2','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1552),
  ('decorator -> AT dotted_name LPAR arglist RPAR NEWLINE','decorator',6,'p_decorator3','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1565),
  ('import_stmt -> import_name','import_stmt',1,'p_import_stmt1','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1579),
  ('import_stmt -> import_from','import_stmt',1,'p_import_stmt2','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1584),
  ('import_name -> IMPORT dotted_as_names','import_name',2,'p_import_name','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1588),
  ('import_from -> FROM dotted_name IMPORT STAR','import_from',4,'p_import_from1','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1595),
  ('import_from -> FROM dotted_name IMPORT import_as_names','import_from',4,'p_import_from2','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1603),
  ('import_from -> FROM dotted_name IMPORT LPAR import_as_names RPAR','import_from',6,'p_import_from3','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1610),
  ('import_from -> FROM import_from_dots dotted_name IMPORT STAR','import_from',5,'p_import_from4','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1617),
  ('import_from -> FROM import_from_dots dotted_name IMPORT import_as_name','import_from',5,'p_import_from5','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1625),
  ('import_from -> FROM import_from_dots dotted_name IMPORT LPAR import_as_names RPAR','import_from',7,'p_import_from6','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1632),
  ('import_from -> FROM import_from_dots IMPORT STAR','import_from',4,'p_import_from7','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1639),
  ('import_from -> FROM import_from_dots IMPORT import_as_names','import_from',4,'p_import_from8','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1647),
  ('import_from -> FROM import_from_dots IMPORT LPAR import_as_names RPAR','import_from',6,'p_import_from9','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1654),
  ('import_from_dots -> DOT','import_from_dots',1,'p_import_from_dots1','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1661),
  ('import_from_dots -> import_from_dots DOT','import_from_dots',2,'p_import_from_dots2','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1666),
  ('import_as_name -> NAME','import_as_name',1,'p_import_as_name1','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1671),
  ('import_as_name -> NAME AS NAME','import_as_name',3,'p_import_as_name2','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1676),
  ('dotted_as_name -> dotted_name','dotted_as_name',1,'p_dotted_as_name1','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1681),
  ('dotted_as_name -> dotted_name AS NAME','dotted_as_name',3,'p_dotted_as_name2','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1687),
  ('import_as_names -> import_as_name','import_as_names',1,'p_import_as_names1','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1693),
  ('import_as_names -> import_as_name COMMA','import_as_names',2,'p_import_as_names2','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1698),
  ('import_as_names -> import_as_name import_as_names_list','import_as_names',2,'p_import_as_names3','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1703),
  ('import_as_names -> import_as_name import_as_names_list COMMA','import_as_names',3,'p_import_as_names4','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1708),
  ('import_as_names_list -> COMMA import_as_name','import_as_names_list',2,'p_import_as_names_list1','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1713),
  ('import_as_names_list -> import_as_names_list COMMA import_as_name','import_as_names_list',3,'p_import_as_names_list2','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1718),
  ('dotted_as_names -> dotted_as_name','dotted_as_names',1,'p_dotted_as_names1','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1723),
  ('dotted_as_names -> dotted_as_name dotted_as_names_list','dotted_as_names',2,'p_dotted_as_names2','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1728),
  ('dotted_as_names_list -> COMMA dotted_as_name','dotted_as_names_list',2,'p_dotted_as_names_list1','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1733),
  ('dotted_as_names_list -> dotted_as_names_list COMMA dotted_as_name','dotted_as_names_list',3,'p_dotted_as_names_star_list2','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1738),
  ('dotted_name -> NAME','dotted_name',1,'p_dotted_name1','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1743),
  ('dotted_name -> NAME dotted_name_list','dotted_name',2,'p_dotted_name2','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1748),
  ('dotted_name_list -> DOT NAME','dotted_name_list',2,'p_dotted_name_list1','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1753),
  ('dotted_name_list -> dotted_name_list DOT NAME','dotted_name_list',3,'p_dotted_name_list2','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1758),
  ('test -> or_test','test',1,'p_test1','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1763),
  ('test -> or_test IF or_test ELSE test','test',5,'p_test2','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1768),
  ('test -> lambdef','test',1,'p_test3','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1774),
  ('or_test -> and_test','or_test',1,'p_or_test1','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1779),
  ('or_test -> and_test or_test_list','or_test',2,'p_or_test2','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1784),
  ('or_test_list -> OR and_test','or_test_list',2,'p_or_test_list1','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1791),
  ('or_test_list -> or_test_list OR and_test','or_test_list',3,'p_or_test_list2','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1796),
  ('and_test -> not_test','and_test',1,'p_and_test1','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1801),
  ('and_test -> not_test and_test_list','and_test',2,'p_and_test2','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1806),
  ('and_test_list -> AND not_test','and_test_list',2,'p_and_test_list1','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1813),
  ('and_test_list -> and_test_list AND not_test','and_test_list',3,'p_and_test_list2','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1818),
  ('not_test -> comparison','not_test',1,'p_not_test','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1823),
  ('not_test -> NOT not_test','not_test',2,'p_not_test2','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1828),
  ('comparison -> expr','comparison',1,'p_comparison1','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1834),
  ('comparison -> expr comparison_list','comparison',2,'p_comparison2','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1839),
  ('comparison_list -> comp_op expr','comparison_list',2,'p_comparison_list1','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1847),
  ('comparison_list -> comparison_list comp_op expr','comparison_list',3,'p_comparison_list2','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1852),
  ('comp_op -> LESS','comp_op',1,'p_comp_op1','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1857),
  ('comp_op -> GREATER','comp_op',1,'p_comp_op2','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1862),
  ('comp_op -> EQEQUAL','comp_op',1,'p_comp_op3','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1867),
  ('comp_op -> GREATEREQUAL','comp_op',1,'p_comp_op4','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1872),
  ('comp_op -> LESSEQUAL','comp_op',1,'p_comp_op5','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1877),
  ('comp_op -> NOTEQUAL','comp_op',1,'p_comp_op6','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1882),
  ('comp_op -> IN','comp_op',1,'p_comp_op7','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1887),
  ('comp_op -> NOT IN','comp_op',2,'p_comp_op8','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1892),
  ('comp_op -> IS','comp_op',1,'p_comp_op9','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1897),
  ('comp_op -> IS NOT','comp_op',2,'p_comp_op10','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1902),
  ('expr -> xor_expr','expr',1,'p_expr1','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1907),
  ('expr -> xor_expr expr_list','expr',2,'p_expr2','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1912),
  ('expr_list -> VBAR xor_expr','expr_list',2,'p_expr_list1','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1920),
  ('expr_list -> expr_list VBAR xor_expr','expr_list',3,'p_expr_list2','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1925),
  ('xor_expr -> and_expr','xor_expr',1,'p_xor_expr1','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1930),
  ('xor_expr -> and_expr xor_expr_list','xor_expr',2,'p_xor_expr2','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1935),
  ('xor_expr_list -> CIRCUMFLEX and_expr','xor_expr_list',2,'p_xor_expr_list1','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1943),
  ('xor_expr_list -> xor_expr_list CIRCUMFLEX and_expr','xor_expr_list',3,'p_xor_expr_list2','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1948),
  ('and_expr -> shift_expr','and_expr',1,'p_and_expr1','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1953),
  ('and_expr -> shift_expr and_expr_list','and_expr',2,'p_and_expr2','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1958),
  ('and_expr_list -> AMPER shift_expr','and_expr_list',2,'p_and_expr_list1','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1966),
  ('and_expr_list -> and_expr_list AMPER shift_expr','and_expr_list',3,'p_and_expr_list2','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1971),
  ('shift_expr -> arith_expr','shift_expr',1,'p_shift_expr1','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1976),
  ('shift_expr -> arith_expr shift_list','shift_expr',2,'p_shift_expr2','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1981),
  ('shift_list -> shift_op','shift_list',1,'p_shift_list1','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1989),
  ('shift_list -> shift_list shift_op','shift_list',2,'p_shift_list2','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1994),
  ('shift_op -> LEFTSHIFT arith_expr','shift_op',2,'p_shift_op1','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',1999),
  ('shift_op -> RIGHTSHIFT arith_expr','shift_op',2,'p_shift_op2','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2004),
  ('arith_expr -> term','arith_expr',1,'p_arith_expr1','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2009),
  ('arith_expr -> term arith_expr_list','arith_expr',2,'p_arith_expr2','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2014),
  ('arith_expr_list -> arith_op','arith_expr_list',1,'p_arith_expr_list1','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2022),
  ('arith_expr_list -> arith_expr_list arith_op','arith_expr_list',2,'p_arith_expr_list2','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2027),
  ('arith_op -> PLUS term','arith_op',2,'p_arith_op1','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2032),
  ('arith_op -> MINUS term','arith_op',2,'p_arith_op2','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2038),
  ('term -> factor','term',1,'p_term1','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2043),
  ('term -> factor term_list','term',2,'p_term2','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2048),
  ('term_list -> term_op','term_list',1,'p_term_list1','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2056),
  ('term_list -> term_list term_op','term_list',2,'p_term_list2','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2061),
  ('term_op -> STAR factor','term_op',2,'p_term_op1','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2066),
  ('term_op -> SLASH factor','term_op',2,'p_term_op2','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2071),
  ('term_op -> PERCENT factor','term_op',2,'p_term_op3','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2076),
  ('term_op -> DOUBLESLASH factor','term_op',2,'p_term_op4','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2081),
  ('factor -> power','factor',1,'p_factor1','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2086),
  ('factor -> PLUS factor','factor',2,'p_factor2','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2091),
  ('factor -> MINUS factor','factor',2,'p_factor3','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2099),
  ('factor -> TILDE factor','factor',2,'p_factor4','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2107),
  ('power -> atom','power',1,'p_power1','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2115),
  ('power -> atom DOUBLESTAR factor','power',3,'p_power2','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2120),
  ('power -> atom power_list','power',2,'p_power3','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2126),
  ('power -> atom power_list DOUBLESTAR factor','power',4,'p_power4','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2142),
  ('power_list -> trailer','power_list',1,'p_power_list1','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2159),
  ('power_list -> power_list trailer','power_list',2,'p_power_list2','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2164),
  ('atom -> LPAR RPAR','atom',2,'p_atom1','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2169),
  ('atom -> LPAR yield_expr RPAR','atom',3,'p_atom2','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2174),
  ('atom -> LPAR testlist_comp RPAR','atom',3,'p_atom3','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2179),
  ('atom -> LSQB RSQB','atom',2,'p_atom4','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2193),
  ('atom -> LSQB listmaker RSQB','atom',3,'p_atom5','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2198),
  ('atom -> LBRACE RBRACE','atom',2,'p_atom6','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2210),
  ('atom -> LBRACE dictorsetmaker RBRACE','atom',3,'p_atom7','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2215),
  ('atom -> NAME','atom',1,'p_atom8','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2236),
  ('atom -> NUMBER','atom',1,'p_atom9','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2241),
  ('atom -> atom_string_list','atom',1,'p_atom10','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2247),
  ('atom_string_list -> STRING','atom_string_list',1,'p_atom_string_list1','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2253),
  ('atom_string_list -> atom_string_list STRING','atom_string_list',2,'p_atom_string_list2','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2258),
  ('listmaker -> test list_for','listmaker',2,'p_listmaker1','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2268),
  ('listmaker -> test','listmaker',1,'p_listmaker2','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2273),
  ('listmaker -> test COMMA','listmaker',2,'p_listmaker3','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2278),
  ('listmaker -> test listmaker_list','listmaker',2,'p_listmaker4','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2283),
  ('listmaker -> test listmaker_list COMMA','listmaker',3,'p_listmaker5','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2289),
  ('listmaker_list -> COMMA test','listmaker_list',2,'p_listmaker_list1','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2295),
  ('listmaker_list -> listmaker_list COMMA test','listmaker_list',3,'p_listmaker_list2','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2300),
  ('testlist_comp -> test comp_for','testlist_comp',2,'p_testlist_comp1','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2305),
  ('testlist_comp -> test','testlist_comp',1,'p_testlist_comp2','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2310),
  ('testlist_comp -> test COMMA','testlist_comp',2,'p_testlist_comp3','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2315),
  ('testlist_comp -> test testlist_comp_list','testlist_comp',2,'p_testlist_comp4','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2320),
  ('testlist_comp -> test testlist_comp_list COMMA','testlist_comp',3,'p_testlist_comp5','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2326),
  ('testlist_comp_list -> COMMA test','testlist_comp_list',2,'p_testlist_comp_list1','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2332),
  ('testlist_comp_list -> testlist_comp_list COMMA test','testlist_comp_list',3,'p_testlist_comp_list2','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2337),
  ('trailer -> LPAR RPAR','trailer',2,'p_trailer1','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2342),
  ('trailer -> LPAR arglist RPAR','trailer',3,'p_trailer2','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2347),
  ('trailer -> LSQB subscriptlist RSQB','trailer',3,'p_trailer3','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2354),
  ('trailer -> DOT NAME','trailer',2,'p_trailer4','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2359),
  ('subscriptlist -> subscript','subscriptlist',1,'p_subscriptlist1','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2364),
  ('subscriptlist -> subscript COMMA','subscriptlist',2,'p_subscriptlist2','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2369),
  ('subscriptlist -> subscript subscriptlist_list','subscriptlist',2,'p_subscriptlist3','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2375),
  ('subscriptlist -> subscript subscriptlist_list COMMA','subscriptlist',3,'p_subscriptlist4','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2381),
  ('subscriptlist_list -> COMMA subscript','subscriptlist_list',2,'p_subscriptlist_list1','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2387),
  ('subscriptlist_list -> subscriptlist_list COMMA subscript','subscriptlist_list',3,'p_subscript_list2','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2392),
  ('subscript -> ELLIPSIS','subscript',1,'p_subscript1','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2397),
  ('subscript -> test','subscript',1,'p_subcript2','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2402),
  ('subscript -> COLON','subscript',1,'p_subscript3','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2407),
  ('subscript -> DOUBLECOLON','subscript',1,'p_subscript4','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2412),
  ('subscript -> test COLON','subscript',2,'p_subscript5','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2418),
  ('subscript -> test DOUBLECOLON','subscript',2,'p_subscrip6','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2423),
  ('subscript -> COLON test','subscript',2,'p_subscript7','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2429),
  ('subscript -> COLON test COLON','subscript',3,'p_subscript8','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2434),
  ('subscript -> DOUBLECOLON test','subscript',2,'p_subscript9','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2440),
  ('subscript -> test COLON test','subscript',3,'p_subscript10','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2445),
  ('subscript -> test COLON test COLON','subscript',4,'p_subscript11','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2450),
  ('subscript -> COLON test COLON test','subscript',4,'p_subscript12','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2456),
  ('subscript -> test COLON test COLON test','subscript',5,'p_subscript13','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2461),
  ('subscript -> test DOUBLECOLON test','subscript',3,'p_subscript14','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2466),
  ('exprlist -> expr','exprlist',1,'p_exprlist1','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2471),
  ('exprlist -> expr COMMA','exprlist',2,'p_exprlist2','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2476),
  ('exprlist -> expr exprlist_list','exprlist',2,'p_exprlist3','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2483),
  ('exprlist -> expr exprlist_list COMMA','exprlist',3,'p_exprlist4','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2490),
  ('exprlist_list -> COMMA expr','exprlist_list',2,'p_exprlist_list1','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2497),
  ('exprlist_list -> exprlist_list COMMA expr','exprlist_list',3,'p_exprlist_list2','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2502),
  ('dictorsetmaker -> test COLON test comp_for','dictorsetmaker',4,'p_dictorsetmaker1','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2507),
  ('dictorsetmaker -> test COLON test','dictorsetmaker',3,'p_dictorsetmaker2','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2512),
  ('dictorsetmaker -> test COLON test COMMA','dictorsetmaker',4,'p_dictorsetmaker3','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2518),
  ('dictorsetmaker -> test COLON test dosm_colon_list','dictorsetmaker',4,'p_dictorsetmaker4','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2524),
  ('dictorsetmaker -> test COLON test dosm_colon_list COMMA','dictorsetmaker',5,'p_dictorsetmaker5','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2530),
  ('dictorsetmaker -> test comp_for','dictorsetmaker',2,'p_dictorsetmaker6','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2536),
  ('dictorsetmaker -> test COMMA','dictorsetmaker',2,'p_dictorsetmaker7','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2541),
  ('dictorsetmaker -> test dosm_comma_list','dictorsetmaker',2,'p_dictorsetmaker8','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2547),
  ('dictorsetmaker -> test dosm_comma_list COMMA','dictorsetmaker',3,'p_dictorsetmaker9','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2553),
  ('dosm_colon_list -> COMMA test COLON test','dosm_colon_list',4,'p_dosm_colon_list1','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2559),
  ('dosm_colon_list -> dosm_colon_list COMMA test COLON test','dosm_colon_list',5,'p_dosm_colon_list2','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2564),
  ('dosm_comma_list -> COMMA test','dosm_comma_list',2,'p_dosm_comma_list1','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2569),
  ('dosm_comma_list -> dosm_comma_list COMMA test','dosm_comma_list',3,'p_dosm_comma_list2','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2574),
  ('arglist -> argument','arglist',1,'p_arglist1','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2579),
  ('arglist -> argument COMMA','arglist',2,'p_arglist2','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2587),
  ('arglist -> STAR test','arglist',2,'p_arglist3','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2595),
  ('arglist -> STAR test COMMA DOUBLESTAR test','arglist',5,'p_arglist4','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2600),
  ('arglist -> DOUBLESTAR test','arglist',2,'p_arglist5','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2605),
  ('arglist -> arglist_list argument','arglist',2,'p_arglist6','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2610),
  ('arglist -> arglist_list argument COMMA','arglist',3,'p_arglist7','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2622),
  ('arglist -> arglist_list STAR test','arglist',3,'p_arglist8','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2634),
  ('arglist -> arglist_list STAR test COMMA DOUBLESTAR test','arglist',6,'p_arglist9','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2646),
  ('arglist -> arglist_list DOUBLESTAR test','arglist',3,'p_arglist10','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2658),
  ('arglist -> STAR test COMMA argument','arglist',4,'p_arglist11','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2670),
  ('arglist -> STAR test COMMA argument COMMA DOUBLESTAR test','arglist',7,'p_arglist12','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2681),
  ('arglist -> STAR test COMMA arglist_list argument','arglist',5,'p_arglist13','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2692),
  ('arglist -> STAR test COMMA arglist_list argument COMMA DOUBLESTAR test','arglist',8,'p_arglist14','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2703),
  ('arglist_list -> argument COMMA','arglist_list',2,'p_arglist_list1','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2714),
  ('arglist_list -> arglist_list argument COMMA','arglist_list',3,'p_arglist_list2','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2719),
  ('argument -> test','argument',1,'p_argument1','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2724),
  ('argument -> test comp_for','argument',2,'p_argument2','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2729),
  ('argument -> test EQUAL test','argument',3,'p_argument3','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2736),
  ('list_for -> FOR exprlist IN testlist_safe','list_for',4,'p_list_for1','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2744),
  ('list_for -> FOR exprlist IN testlist_safe list_iter','list_for',5,'p_list_for2','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2751),
  ('list_iter -> list_for','list_iter',1,'p_list_iter1','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2765),
  ('list_iter -> list_if','list_iter',1,'p_list_iter2','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2770),
  ('list_if -> IF old_test','list_if',2,'p_list_if1','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2775),
  ('list_if -> IF old_test list_iter','list_if',3,'p_list_if2','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2780),
  ('comp_for -> FOR exprlist IN or_test','comp_for',4,'p_comp_for1','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2785),
  ('comp_for -> FOR exprlist IN or_test comp_iter','comp_for',5,'p_comp_for2','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2792),
  ('comp_iter -> comp_for','comp_iter',1,'p_comp_iter1','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2806),
  ('comp_iter -> comp_if','comp_iter',1,'p_comp_iter2','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2811),
  ('comp_if -> IF old_test','comp_if',2,'p_comp_if1','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2816),
  ('comp_if -> IF old_test comp_iter','comp_if',3,'p_comp_if2','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2821),
  ('testlist_safe -> old_test','testlist_safe',1,'p_testlist_safe1','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2826),
  ('testlist_safe -> old_test testlist_safe_list','testlist_safe',2,'p_testlist_safe2','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2831),
  ('testlist_safe -> old_test testlist_safe_list COMMA','testlist_safe',3,'p_testlist_safe3','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2837),
  ('testlist_safe_list -> COMMA old_test','testlist_safe_list',2,'p_testlist_safe_list1','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2843),
  ('testlist_safe_list -> testlist_safe_list COMMA old_test','testlist_safe_list',3,'p_testlist_safe_list2','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2848),
  ('old_test -> or_test','old_test',1,'p_old_test1','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2853),
  ('old_test -> old_lambdef','old_test',1,'p_old_test2','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2858),
  ('old_lambdef -> LAMBDA COLON old_test','old_lambdef',3,'p_old_lambdef1','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2863),
  ('old_lambdef -> LAMBDA varargslist COLON old_test','old_lambdef',4,'p_old_lambdef2','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2870),
  ('lambdef -> LAMBDA COLON test','lambdef',3,'p_lambdef1','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2877),
  ('lambdef -> LAMBDA varargslist COLON test','lambdef',4,'p_lambdef2','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2884),
  ('varargslist -> fpdef COMMA STAR NAME','varargslist',4,'p_varargslist1','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2891),
  ('varargslist -> fpdef COMMA STAR NAME COMMA DOUBLESTAR NAME','varargslist',7,'p_varargslist2','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2898),
  ('varargslist -> fpdef COMMA DOUBLESTAR NAME','varargslist',4,'p_varargslist3','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2905),
  ('varargslist -> fpdef','varargslist',1,'p_varargslist4','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2912),
  ('varargslist -> fpdef COMMA','varargslist',2,'p_varargslist5','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2919),
  ('varargslist -> fpdef varargslist_list COMMA STAR NAME','varargslist',5,'p_varargslist6','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2926),
  ('varargslist -> fpdef varargslist_list COMMA STAR NAME COMMA DOUBLESTAR NAME','varargslist',8,'p_varargslist7','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2935),
  ('varargslist -> fpdef varargslist_list COMMA DOUBLESTAR NAME','varargslist',5,'p_varargslist8','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2944),
  ('varargslist -> fpdef varargslist_list','varargslist',2,'p_varargslist9','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2953),
  ('varargslist -> fpdef varargslist_list COMMA','varargslist',3,'p_varargslist10','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2962),
  ('varargslist -> fpdef EQUAL test COMMA STAR NAME','varargslist',6,'p_varargslist11','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2971),
  ('varargslist -> fpdef EQUAL test COMMA STAR NAME COMMA DOUBLESTAR NAME','varargslist',9,'p_varargslist12','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2978),
  ('varargslist -> fpdef EQUAL test COMMA DOUBLESTAR NAME','varargslist',6,'p_varargslist13','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2985),
  ('varargslist -> fpdef EQUAL test','varargslist',3,'p_varargslist14','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2992),
  ('varargslist -> fpdef EQUAL test COMMA','varargslist',4,'p_varargslist15','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',2999),
  ('varargslist -> fpdef EQUAL test varargslist_list COMMA STAR NAME','varargslist',7,'p_varargslist16','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',3006),
  ('varargslist -> fpdef EQUAL test varargslist_list COMMA STAR NAME COMMA DOUBLESTAR NAME','varargslist',10,'p_varargslist17','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',3019),
  ('varargslist -> fpdef EQUAL test varargslist_list COMMA DOUBLESTAR NAME','varargslist',7,'p_varargslist18','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',3032),
  ('varargslist -> fpdef EQUAL test varargslist_list','varargslist',4,'p_varargslist19','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',3045),
  ('varargslist -> fpdef EQUAL test varargslist_list COMMA','varargslist',5,'p_varargslist20','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',3058),
  ('varargslist -> STAR NAME','varargslist',2,'p_varargslist21','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',3071),
  ('varargslist -> STAR NAME COMMA DOUBLESTAR NAME','varargslist',5,'p_varargslist22','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',3077),
  ('varargslist -> DOUBLESTAR NAME','varargslist',2,'p_varargslist23','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',3083),
  ('varargslist_list -> COMMA fpdef','varargslist_list',2,'p_varargslist_list1','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',3090),
  ('varargslist_list -> COMMA fpdef EQUAL test','varargslist_list',4,'p_varargslist_list2','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',3095),
  ('varargslist_list -> varargslist_list COMMA fpdef','varargslist_list',3,'p_varargslist_list3','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',3100),
  ('varargslist_list -> varargslist_list COMMA fpdef EQUAL test','varargslist_list',5,'p_varargslist_list4','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',3111),
  ('fpdef -> NAME','fpdef',1,'p_fpdef1','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',3119),
  ('fpdef -> LPAR fplist RPAR','fpdef',3,'p_fpdef2','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',3124),
  ('fplist -> fpdef','fplist',1,'p_fplist1','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',3131),
  ('fplist -> fpdef COMMA','fplist',2,'p_fplist2','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',3136),
  ('fplist -> fpdef fplist_list','fplist',2,'p_fplist3','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',3144),
  ('fplist -> fpdef fplist_list COMMA','fplist',3,'p_fplist4','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',3153),
  ('fplist_list -> COMMA fpdef','fplist_list',2,'p_fplist_list1','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',3162),
  ('fplist_list -> fplist_list COMMA fpdef','fplist_list',3,'p_fplist_list2','c:\\Users\\i341972\\Desktop\\git_repos\\enaml\\enaml\\core\\parser.py',3167),
]

########NEW FILE########
__FILENAME__ = signaling
#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
import warnings


warnings.warn(
    'Importing from enaml.core.signaling is deprectated. '
    'Use enaml.signaling instead.', DeprecationWarning
)

# Backwards compatibility imports
from enaml.signaling import Signal, BoundSignal as InstanceSignal


########NEW FILE########
__FILENAME__ = templated
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from traits.api import List

from .declarative import Declarative, setup_bindings


class Templated(Declarative):
    """ A declarative which serves as a base class for templated types.

    The `Templated` class serves as a base class for classes such as
    `Looper` and `Conditional` which never create their children, but
    the descriptions of their children as templates for generating new
    objects at runtime.

    """
    #: Private storage for the templates used to create items.
    _templates = List

    #--------------------------------------------------------------------------
    # Lifetime API
    #--------------------------------------------------------------------------
    def post_destroy(self):
        """ A post destroy handler.

        The templated item will release all of its templates after it
        has been destroyed.

        """
        super(Templated, self).post_destroy()
        self._templates = []

    #--------------------------------------------------------------------------
    # Declarative API
    #--------------------------------------------------------------------------
    def populate(self, description, identifiers, f_globals):
        """ An overridden parent class populator.

        A `Templated` object never actually constructs its children.
        Instead, the child descriptions are used as templates by the
        various subclasses to generate objects at runtime. This method
        simply creates the object, initializes the bindings, and stores
        the children information in the templates list.

        """
        ident = description['identifier']
        if ident:
            identifiers[ident] = self
        bindings = description['bindings']
        if len(bindings) > 0:
            setup_bindings(self, bindings, identifiers, f_globals)
        children = description['children']
        if len(children) > 0:
            template = (identifiers, f_globals, children)
            self._templates.append(template)


########NEW FILE########
__FILENAME__ = trait_types
#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from traits.api import TraitType, TraitError, BaseInstance
from traits.traits import CTrait


#------------------------------------------------------------------------------
# Enaml Instance
#------------------------------------------------------------------------------
class EnamlInstance(TraitType):
    """ A custom TraitType which serves as a simple isinstance(...)
    validator. This class serves as the base class for other custom
    trait types such as EnamlEvent.

    """
    @staticmethod
    def is_valid_type(obj):
        """ A static method which returns whether or not the given object
        can be used as the type in an isinstance(..., type) expression.

        Paramters
        ---------
        obj : object
            The object which should behave like a type for the purpose
            of an isinstance check. This means the object is type
            or defines an '__instancecheck__' method.

        Returns
        -------
        result : bool
            True if the object is a type or defines a method named
            '__instancecheck__', False otherwise.

        """
        return isinstance(obj, type) or hasattr(obj, '__instancecheck__')

    def __init__(self, base_type=object):
        """ Initialize an EnamlInstance.

        Parameters
        ----------
        base_type : type-like object, optional
            An object that behaves like a type for the purposes of a
            call to isinstance. The staticmethod 'is_valid_attr_type'
            defined on this class can be used to test a type before
            creating an instance of this class. It is assumed that the
            given type passes that test. The default is object.

        """
        if not EnamlInstance.is_valid_type(base_type):
            msg = '%s is not a valid type object'
            raise TypeError(msg % base_type)
        super(EnamlInstance, self).__init__()
        self.base_type = base_type

    def validate(self, obj, name, value):
        """ The validation handler for an EnamlInstace. It performs a
        simple isinstance(...) check using the attribute type provided
        to the constructor.

        """
        if not isinstance(value, self.base_type):
            self.error(obj, name, value)
        return value

    def full_info(self, obj, name, value):
        """ Overridden parent class method to compute an appropriate info
        string for use in error messages.

        """
        return 'an instance of %s' % self.base_type


#------------------------------------------------------------------------------
# Enaml Event
#------------------------------------------------------------------------------
class EnamlEventDispatcher(object):
    """ A thin object which is used to dispatch a notification for an
    EnamlEvent. Instances of this class are callable with at most one
    argument, which will be the payload of the event. Instances of this
    dispatcher should not be held onto, since they maintain a strong
    reference to the underlying object.

    """
    def __init__(self, trait, obj, name):
        """ Initialize an event dispatcher.

        Parameters
        ----------
        trait : Instance(TraitType)
            The trait type instance on which validate will be called
            with the event payload.

        obj : Instance(HasTraits)
            The HasTraits object on which the event is being emitted.

        name : string
            The name of the event being emitted.

        """
        self._trait = trait
        self._obj = obj
        self._name = name

    def __call__(self, payload=None):
        """ Dispatches the event with the given payload.

        Paramters
        ---------
        payload : object, optional
            The payload argument of the event. This object will be
            validated against the type declared for the event.
            The default payload is None.

        """
        obj = self._obj
        name = self._name
        self._trait.validate(obj, name, payload)
        obj.trait_property_changed(name, None, payload)


class EnamlEvent(EnamlInstance):
    """ A custom EnamlInstance that is used to implement the event
    type in Enaml. An EnamlEvent is read-only, and returns a dispatcher
    which can be called to emit the event.

    """
    def get(self, obj, name):
        """ The trait getter method. Returns an EnamlEventDispatcher
        instance which can be called to emit the event.

        """
        return EnamlEventDispatcher(self, obj, name)

    def set(self, obj, name, value):
        """ The trait setter method. Fires off a EnamlEventDispatcher
        as if the event were called with the payload.

        """
        EnamlEventDispatcher(self, obj, name)(value)

    def full_info(self, obj, name, value):
        """ Overridden parent class method to compute an appropriate info
        string for use in error messages.

        """
        return 'emitted with an object of %s' % self.base_type


#------------------------------------------------------------------------------
# Bounded
#------------------------------------------------------------------------------
class Bounded(TraitType):
    """ Generic Bounded Trait class.

    The class defines a generic Trait where the value is validated
    on assigment to fall between low and high (static or dynamic) bounds.

    """
    info_text = "Bounded value"

    def __init__(self, value=None, low=None, high=None, **metadata):
        """
        Arguments
        ---------
        value :
            The default value. It can be a python object or a Trait.

        low :
            The lower bound of the Trait.

        high :
            The upper bound of the Trait.

        """
        if isinstance(value, CTrait):
            self.validate = self.validate_with_trait
            default_value = value.default
        else:
            self.validate = self.validate_bounds
            if value is None:
                if low is not None:
                    value = default_value = low
                else:
                    value = default_value = high
            else:
                default_value = value

        super(Bounded, self).__init__(default_value, **metadata)

        self._high = high
        self._low = low
        self._value = value

        if isinstance(value, basestring):
            self.default_value_type = 8
            self.default_value = self._get_default_value

    def _get_default_value(self, obj):
        """ Handles computing the default value for the Bounded trait.

        """
        return reduce(getattr, self._value.split('.'), obj)

    def validate_with_trait(self, obj, name, value):
        """ Validate the trait value.

        Validation takes place in two steps:
        #. The input value is validated based on the expected Trait type.
        #. The value it is between the static (or dynamic) bounds.

        """
        value_trait = self._value
        value = value_trait.validate(obj, name, value)
        return self.validate_bounds(obj, name, value)

    def validate_bounds(self, obj, name, value):
        """ Validate that the value is in range.

        .. note:: Any exceptions that may take place are converted to
            TraitErrors.

        """
        low, high = self.get_bounds(obj)
        if low is None:
            low = value
        if high is None:
            high = value

        is_inside_bounds = False
        try:
            is_inside_bounds = (low <= value <= high)
        except Exception as raised_exception:
            if isinstance(raised_exception, TraitError):
                raise raised_exception
            else:
                msg = ('Bound checking of {0} caused a the following Python '
                       'Exception: {1}'.format(value, raised_exception))
                raise TraitError(msg)

        if not is_inside_bounds:
            msg = ('The assigned value must be bounded between {0} '
                   ' and {1}. Got {2} instead.'.format(low, high, value))
            raise TraitError(msg)

        return value

    def get_bounds(self, obj):
        """ Get the lower and upper bounds of the Trait.

        """
        low = self._low
        if isinstance(low, basestring):
            low = reduce(getattr, low.split('.'), obj)

        high = self._high
        if isinstance(high, basestring):
            high = reduce(getattr, high.split('.'), obj)

        return (low, high)


#------------------------------------------------------------------------------
# Coercing Instance
#------------------------------------------------------------------------------
class CoercingInstance(BaseInstance):
    """ A BaseInstance subclass which attempts to coerce a value by
    calling the class constructor and passing the new value into the
    original validate method.

    """
    def validate(self, obj, name, value):
        """ Attempts to coerce the given value to an appropriate type
        by calling the underlying class constructor. The coerced value
        is then sent to the superclass' validate method.

        """
        if isinstance(self.klass, basestring):
            self.resolve_klass(obj, name, value)
        try:
            value = self.klass(value)
        except:
            pass
        return super(CoercingInstance, self).validate(obj, name, value)


########NEW FILE########
__FILENAME__ = fonts
#------------------------------------------------------------------------------
#  Copyright (c) 2013, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
""" A utility module for dealing with CSS3 font strings.

"""
from collections import namedtuple


#: CSS3 keywords for font style.
_styles = set(['normal', 'italic', 'oblique'])

#: CSS3 keywords for font variants.
_variants = set(['normal', 'small-caps'])

#: CSS3 keywords for font weight.
_weights = set([
    'normal', 'bold', 'bolder', 'lighter', '100', '200', '300', '400',
    '500', '600', '700', '800', '900'
])

#: CSS3 keywords for font sizes.
_sizes = set([
    'xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large',
    'larger', 'smaller',
])

#: CSS3 font size unit suffixes.
_units = set(['in', 'cm', 'mm', 'pt', 'pc', 'px'])


#: A namedtuple for storing parsed font information.
Font = namedtuple('Font', 'style variant weight size family')


def parse_font(font):
    """ Parse a CSS shorthand font string into a Font namedtuple.

    Returns
    -------
    result : Font or None
        A namedtuple of font information for the given string, or None
        if the given string is not a valid CSS shorthand font.

    """
    token = []
    tokens = []
    quotechar = None
    for char in font:
        if quotechar is not None:
            if char == quotechar:
                tokens.append(''.join(token))
                token = []
                quotechar = None
            else:
                token.append(char)
        elif char == '"' or char == "'":
            quotechar = char
        elif char in ' \t':
            if token:
                tokens.append(''.join(token))
                token = []
        else:
            token.append(char)

    # Failed to close quoted string.
    if quotechar is not None:
        return

    if token:
        tokens.append(''.join(token))

    sizes = []
    families = []
    optionals = []
    for token in tokens:
        if token in _styles or token in _variants or token in _weights:
            if len(sizes) > 0 or len(families) > 0:
                return None
            optionals.append(token)
        elif token in _sizes or token[-1] == '%' or token[-2:] in _units:
            if len(families) > 0:
                return None
            sizes.append(token)
        else:
            families.append(token)

    if len(optionals) > 3:
        return None
    if len(sizes) != 1:
        return None
    if len(families) != 1:
        return None

    style = None
    variant = None
    weight = None
    size = sizes[0]
    family = families[0]

    for opt in optionals:
        if opt == 'normal':
            continue
        elif opt in _styles:
            if style is not None:
                return None
            style = opt
        elif opt in _variants:
            if variant is not None:
                return None
            variant = opt
        elif opt in _weights:
            if weight is not None:
                return None
            weight = opt
        else:
            return None

    style = style or 'normal'
    variant = variant or 'normal'
    weight = weight or 'normal'

    if size[-1] == '%':
        try:
            float(size[:-1])
        except ValueError:
            return None
    else:
        try:
            float(size[:-2])
        except ValueError:
            return None

    return Font(style, variant, weight, size, family)


########NEW FILE########
__FILENAME__ = icon_provider
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from abc import ABCMeta, abstractmethod

from traits.api import HasTraits, Enum, Instance, List

from .image_provider import Image
from .resource import Resource


class IconImage(HasTraits):
    """ An object representing an image in an icon.

    Instances of this class are used to populate the `images` list of
    an `Icon` instance. Instances of this class should be treated as
    read-only once they are created.

    """
    #: The widget mode for which this icon should apply.
    mode = Enum('normal', 'active', 'disabled', 'selected')

    #: The widget state for which this icon should apply.
    state = Enum('off', 'on')

    #: The image to use for this icon.
    image = Instance(Image)

    def snapshot(self):
        """ Get a snapshot dictionary for this icon image.

        """
        snap = {}
        snap['mode'] = self.mode
        snap['state'] = self.state
        snap['image'] = self.image.snapshot() if self.image else None
        return snap


class Icon(Resource):
    """ A resource object representing an icon.

    Instances of this class are created by an `IconProvider` when it
    handles a request for an icon. Instances of this class should be
    treated as read-only once they are created.

    """
    #: The list of icon images which compose this icon.
    images = List(IconImage)

    def snapshot(self):
        """ Get a snapshot dictionary for this icon.

        """
        snap = super(Icon, self).snapshot()
        snap['images'] = [image.snapshot() for image in self.images]
        return snap


class IconProvider(object):
    """ An abstract API definition for an icon provider object.

    """
    __metaclass__ = ABCMeta

    @abstractmethod
    def request_icon(self, path, callback):
        """ Request an icon from this provider.

        Parameters
        ----------
        path : str
            The requested path of the icon, with the provider prefix
            removed. For example, if the full icon source path was:
            `icon://myprovider/icons/foo` then the path passed to this
            method will be `icons/foo`.

        callback : callable
            A callable which should be invoked when the icon is loaded.
            It accepts a single argument, which is the loaded `Icon`
            object. It is safe to invoke this callable from a thread.

        """
        raise NotImplementedError


########NEW FILE########
__FILENAME__ = image_provider
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from abc import ABCMeta, abstractmethod

from traits.api import Enum, Str, Tuple, Int

from .resource import Resource


class Image(Resource):
    """ A resource object representing an image.

    Instances of this class are created by an `ImageProvider` when it
    handles a request for an image. Instances of this class should be
    treated as read-only once they are created.

    """
    #: The format of the image. By default, the consumer of the image
    #: will probe the header to automatically infer a type.
    format = Enum(
        'auto',     # Automatically determine the image format
        'png',      # Portable Network Graphics
        'jpg',      # Joint Photographic Experts Group
        'gif',      # Graphics Interchange Format
        'bmp',      # Windows Bitmap
        'xpm',      # X11 Pixmap
        'xbm',      # X11 Bitmap
        'pbm',      # Portable Bitmap
        'pgm',      # Portable Graymap
        'ppm',      # Portable Pixmap
        'tiff',     # Tagged Image File Format
        # 'array',    # A numpy array with an appropriate image dtype.
    )

    #: The (width, height) size of the image. An invalid size indicates
    #: that the size of the image should be automatically inferred.
    size = Tuple(Int(-1), Int(-1))

    # XXX this needs to be augmented to support arrays.
    #: The bytestring holding the data for the image.
    data = Str

    def snapshot(self):
        """ Get a snapshot dictionary for this image.

        """
        snap = super(Image, self).snapshot()
        snap['format'] = self.format
        snap['size'] = self.size
        snap['data'] = self.data
        return snap


class ImageProvider(object):
    """ An abstract API definition for an image provider object.

    """
    __metaclass__ = ABCMeta

    @abstractmethod
    def request_image(self, path, size, callback):
        """ Request an image from this provider.

        Parameters
        ----------
        path : str
            The requested path of the image, with the provider prefix
            removed. For example, if the full image source path was:
            `image://myprovider/icons/foo` then the path passed to
            this method will be `icons/foo`.

        size : tuple
            A tuple of (width, height) which is the requested size of
            the image. If this value is (-1, -1), then the image should
            be loaded in its original size. Otherwise, the image should
            be loaded in the requested size if possible.

        callback : callable
            A callable which should be invoked when the image is loaded.
            It accepts a single argument, which is the loaded `Image`
            object. It is safe to invoke this callable from a thread.

        """
        raise NotImplementedError


########NEW FILE########
__FILENAME__ = ab_constrainable
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from abc import ABCMeta


class ABConstrainable(object):
    """ An abstract base class for objects that can be laid out using
    layout helpers.

    Minimally, instances need to have `top`, `bottom`, `left`, `right`,
    `width`, `height`, `v_center` and `h_center` attributes which are
    `LinearSymbolic` instances.

    """
    __metaclass__ = ABCMeta


########NEW FILE########
__FILENAME__ = api
#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from .layout_helpers import (
    align, hbox, vbox, horizontal, vertical, grid, spacer,
)
from .geometry import Box, BoxF, Pos, PosF, Rect, RectF, Size, SizeF


########NEW FILE########
__FILENAME__ = box_model
#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from .constraint_variable import ConstraintVariable


class BoxModel(object):
    """ A class which provides a simple constraints box model.

    Primitive Variables:
        left, top, width, height

    Derived Variables:
        right, bottom, v_center, h_center

    """
    __slots__ = (
        'left', 'top', 'width', 'height', 'right', 'bottom', 'v_center',
        'h_center'
    )

    def __init__(self, owner):
        """ Initialize a BoxModel.

        Parameters
        ----------
        owner : str
            A string which uniquely identifies the owner of this box
            model.

        """
        self.left = ConstraintVariable('left', owner)
        self.top = ConstraintVariable('top', owner)
        self.width = ConstraintVariable('width', owner)
        self.height = ConstraintVariable('height', owner)
        self.right = self.left + self.width
        self.bottom = self.top + self.height
        self.v_center = self.top + self.height / 2.0
        self.h_center = self.left + self.width / 2.0


class ContentsBoxModel(BoxModel):
    """ A BoxModel subclass which adds an inner contents box.

    Primitive Variables:
        contents_[left|right|top|bottom]

    Derived Variables:
        contents_[width|height|v_center|h_center]

    """
    __slots__ = (
        'contents_left', 'contents_right', 'contents_top', 'contents_bottom',
        'contents_width', 'contents_height', 'contents_v_center',
        'contents_h_center'
    )

    def __init__(self, owner):
        """ Initialize a ContainerBoxModel.

        Parameters
        ----------
        owner : string
            A string which uniquely identifies the owner of this box
            model.

        """
        super(ContentsBoxModel, self).__init__(owner)
        self.contents_left = ConstraintVariable('contents_left', owner)
        self.contents_right = ConstraintVariable('contents_right', owner)
        self.contents_top = ConstraintVariable('contents_top', owner)
        self.contents_bottom = ConstraintVariable('contents_bottom', owner)
        self.contents_width = self.contents_right - self.contents_left
        self.contents_height = self.contents_bottom - self.contents_top
        self.contents_v_center = self.contents_top + self.contents_height / 2.0
        self.contents_h_center = self.contents_left + self.contents_width / 2.0


########NEW FILE########
__FILENAME__ = constraint_variable
#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from collections import defaultdict
import operator


STRENGTHS = set(['required', 'strong', 'medium', 'weak'])


def almost_equal(a, b, eps=1e-8):
    return abs(a - b) < eps


class LinearSymbolic(object):

    __slots__ = ()

    def nonlinear(self, msg):
        raise TypeError('Non-linear expression: %s' % msg)

    def nonlinear_op(self, op):
        raise TypeError('Non-linear operator: `%s`' % op)

    def as_dict(self):
        raise NotImplementedError

    def __repr__(self):
        raise NotImplementedError

    def __add__(self, other):
        raise NotImplementedError

    def __mul__(self, other):
        raise NotImplementedError

    def __div__(self, other):
        raise NotImplementedError

    def __str__(self):
        return self.__repr__()

    def __radd__(self, other):
        return self.__add__(other)

    def __sub__(self, other):
        return self + (-1.0 * other)

    def __rsub__(self, other):
        return other + (-1.0 * self)

    def __rmul__(self, other):
        return self.__mul__(other)

    def __rdiv__(self, other):
        self.nonlinear_op('/')

    def __floordiv__(self, other):
        self.nonlinear_op('//')

    def __rfloordiv__(self, other):
        self.nonlinear_op('//')

    def __mod__(self, other):
        self.nonlinear_op('%')

    def __divmod__(self, other):
        self.nonlinear_op('divmod')

    def __rdivmod__(self, other):
        self.nonlinear_op('divmod')

    def __pow__(self, other, mod):
        self.nonlinear_op('**')

    def __rpow__(self, other, mod):
        self.nonlinear_op('**')

    def __lshift__(self, other):
        self.nonlinear_op('<<')

    def __rlshift__(self, other):
        self.nonlinear_op('<<')

    def __rshift__(self, other):
        self.nonlinear_op('>>')

    def __rrshift__(self, other):
        self.nonlinear_op('>>')

    def __and__(self, other):
        self.nonlinear_op('&')

    def __rand__(self, other):
        self.nonlinear_op('&')

    def __or__(self, other):
        self.nonlinear_op('|')

    def __ror__(self, other):
        self.nonlinear_op('|')

    def __xor__(self, other):
        self.nonlinear_op('^')

    def __rxor__(self, other):
        self.nonlinear_op('^')

    def __eq__(self, other):
        if isinstance(other, (float, int, long)):
            rhs = LinearExpression([], float(other))
        elif isinstance(other, LinearSymbolic):
            rhs = other
        else:
            msg = 'Invalid type for constraint operation %s' % type(other)
            raise TypeError(msg)
        return EQConstraint(self, rhs)

    def __le__(self, other):
        if isinstance(other, (float, int, long)):
            rhs = LinearExpression([], float(other))
        elif isinstance(other, LinearSymbolic):
            rhs = other
        else:
            msg = 'Invalid type for constraint operation %s' % type(other)
            raise TypeError(msg)
        return LEConstraint(self, rhs)

    def __ge__(self, other):
        if isinstance(other, (float, int, long)):
            rhs = LinearExpression([], float(other))
        elif isinstance(other, LinearSymbolic):
            rhs = other
        else:
            msg = 'Invalid type for constraint operation %s' % type(other)
            raise TypeError(msg)
        return GEConstraint(self, rhs)

    def __ne__(self, other):
        raise ValueError('Invalid constraint operation.')

    def __lt__(self, other):
        raise ValueError('Invalid constraint operation.')

    def __gt__(self, other):
        raise ValueError('Invalid constraint operation.')


class ConstraintVariable(LinearSymbolic):

    __slots__ = ('name', 'owner')

    def __init__(self, name, owner):
        self.name = name
        self.owner = owner

    def as_dict(self):
        dct = {
            'type': 'linear_symbolic',
            'name': self.name,
            'owner': self.owner,
        }
        return dct

    def __repr__(self):
        template = 'ConstraintVariable({0!r}, {1!r})'
        return template.format(self.name, self.owner)

    def __str__(self):
        template = '{0}:{1}'
        return template.format(self.name, self.owner)

    def __add__(self, other):
        if not isinstance(self, LinearSymbolic):
            self, other = other, self
        if isinstance(other, (float, int, long)):
            terms = [Term(self)]
            const = float(other)
            expr = LinearExpression(terms, const)
        elif isinstance(other, Term):
            terms = [Term(self), other]
            expr = LinearExpression(terms)
        elif isinstance(other, ConstraintVariable):
            terms = [Term(self), Term(other)]
            expr = LinearExpression(terms)
        elif isinstance(other, LinearExpression):
            expr = other + self
        else:
            return NotImplemented
        return expr

    def __mul__(self, other):
        if not isinstance(self, LinearSymbolic):
            self, other = other, self
        if isinstance(other, (float, int, long)):
            res = Term(self, float(other))
        elif isinstance(other, (Term, ConstraintVariable, LinearExpression)):
            self.nonlinear('[ %s ] * [ %s ]' % (self, other))
        else:
            return NotImplemented
        return res

    def __div__(self, other):
        if not isinstance(self, LinearSymbolic):
            other.nonlinear('[ %s ] / [ %s ]' % (self, other))
        if isinstance(other, (float, int)):
            res = (1.0 / float(other)) * self
        elif isinstance(other, (Term, ConstraintVariable, LinearExpression)):
            self.nonlinear('[ %s ] / [ %s ]' % (self, other))
        else:
            return NotImplemented
        return res


class Term(LinearSymbolic):

    __slots__ = ('var', 'coeff')

    def __init__(self, var, coeff=1.0):
        self.var = var
        self.coeff = coeff

    def as_dict(self):
        dct = {
            'type': 'term',
            'var': self.var.as_dict(),
            'coeff': self.coeff,
        }
        return dct

    def __repr__(self):
        template = 'Term({0!r}, {1!r})'
        return template.format(self.var, self.coeff)

    def __str__(self):
        if self.coeff == 1.0:
            template = '{name}'
        elif self.coeff == -1.0:
            template = '-{name}'
        else:
            template = '{coeff} * {name}'
        kwargs = {
            'coeff': self.coeff,
            'name': self.var.name,
        }
        return template.format(**kwargs)

    def __add__(self, other):
        if not isinstance(self, LinearSymbolic):
            self, other = other, self
        if isinstance(other, (float, int, long)):
            terms = [self]
            const = float(other)
            expr = LinearExpression(terms, const)
        elif isinstance(other, Term):
            terms = [self, other]
            expr = LinearExpression(terms)
        elif isinstance(other, ConstraintVariable):
            terms = [self, Term(other)]
            expr = LinearExpression(terms)
        elif isinstance(other, LinearExpression):
            expr = other + self
        else:
            return NotImplemented
        return expr

    def __mul__(self, other):
        if not isinstance(self, LinearSymbolic):
            self, other = other, self
        if isinstance(other, (float, int, long)):
            res = Term(self.var, float(other) * self.coeff)
        elif isinstance(other, (Term, ConstraintVariable, LinearExpression)):
            self.nonlinear('[ %s ] * [ %s ]' % (self, other))
        else:
            return NotImplemented
        return res

    def __div__(self, other):
        if not isinstance(self, LinearSymbolic):
            other.nonlinear('[ %s ] / [ %s ]' % (self, other))
        if isinstance(other, (float, int, long)):
            res = (1.0 / float(other)) * self
        elif isinstance(other, (Term, ConstraintVariable, LinearExpression)):
            self.nonlinear('[ %s ] / [ %s ]' % (self, other))
        else:
            return NotImplemented
        return res


class LinearExpression(LinearSymbolic):

    __slots__ = ('terms', 'constant')

    @staticmethod
    def reduce_terms(terms):
        mapping = defaultdict(float)
        for term in terms:
            mapping[term.var] += term.coeff
        terms = tuple(
            Term(var, coeff) for (var, coeff) in mapping.iteritems()
            if not almost_equal(coeff, 0.0)
        )
        return terms

    def __init__(self, terms, constant=0.0):
        self.terms = self.reduce_terms(terms)
        self.constant = constant

    def as_dict(self):
        dct = {
            'type': 'linear_expression',
            'terms': [term.as_dict() for term in self.terms],
            'constant': self.constant,
        }
        return dct

    def __repr__(self):
        if len(self.terms) > 0:
            s = sorted(self.terms, key=operator.attrgetter('var.name'))
            terms = ' + '.join(str(term) for term in s)
            if self.constant > 0.0:
                terms += ' + %s' % self.constant
            elif self.constant < 0.0:
                terms += ' - %s' % -self.constant
        else:
            terms = str(self.constant)
        return terms

    def __add__(self, other):
        if not isinstance(self, LinearSymbolic):
            self, other = other, self
        if isinstance(other, (float, int, long)):
            expr = LinearExpression(self.terms, self.constant + float(other))
        elif isinstance(other, Term):
            terms = list(self.terms) + [other]
            expr = LinearExpression(terms, self.constant)
        elif isinstance(other, ConstraintVariable):
            terms = list(self.terms) + [Term(other)]
            expr = LinearExpression(terms, self.constant)
        elif isinstance(other, LinearExpression):
            terms = list(self.terms) + list(other.terms)
            const = self.constant + other.constant
            expr = LinearExpression(terms, const)
        else:
            return NotImplemented
        return expr

    def __mul__(self, other):
        if not isinstance(self, LinearSymbolic):
            self, other = other, self
        if isinstance(other, (float, int, long)):
            terms = [other * term for term in self.terms]
            const = self.constant * other
            res = LinearExpression(terms, const)
        elif isinstance(other, (Term, ConstraintVariable, LinearExpression)):
            self.nonlinear('[ %s ] * [ %s ]' % (self, other))
        else:
            return NotImplemented
        return res

    def __div__(self, other):
        if not isinstance(self, LinearSymbolic):
            self, other = other, self
        if isinstance(other, (float, int, long)):
            res = (1.0 / float(other)) * self
        elif isinstance(other, (Term, ConstraintVariable, LinearExpression)):
            self.nonlinear('[ %s ] / [ %s ]' % (self, other))
        else:
            return NotImplemented
        return res


class LinearConstraint(object):

    __slots__ = ('lhs', 'rhs', 'strength', 'weight', 'op')

    def __init__(self, lhs, rhs, strength='required', weight=1.0):
        self.lhs = lhs
        self.rhs = rhs
        self.strength = strength
        self.weight = weight
        self.op = None

    def as_dict(self):
        dct = {
            'type': 'linear_constraint',
            'lhs': self.lhs.as_dict(),
            'op': self.op,
            'rhs': self.rhs.as_dict(),
            'strength': self.strength,
            'weight': self.weight,
        }
        return dct

    def __repr__(self):
        template = '<{name}: ({lhs} {op} {rhs}) | {strength} | {weight}>'
        kwargs = {
            'name': type(self).__name__,
            'lhs': self.lhs,
            'rhs': self.rhs,
            'op': self.op,
            'strength': self.strength,
            'weight': self.weight,
        }
        return template.format(**kwargs)

    def __str__(self):
        template = '{lhs} {op} {rhs}'
        kwargs = {
            'lhs': self.lhs,
            'rhs': self.rhs,
            'op': self.op,
        }
        return template.format(**kwargs)

    def __or__(self, other):
        strength = self.strength
        weight = self.weight
        if isinstance(other, (float, int, long)):
            weight = other
        elif isinstance(other, basestring):
            if other not in STRENGTHS:
                msg = 'Expected a known strength string. '
                msg +=  'Got {!r} instead.'
                raise ValueError(msg.format(other))
            else:
                strength = other
        else:
            msg = 'Expected a known strength string or a float weight. '
            msg += 'Got {!r} instead.'
            raise ValueError(msg.format(other))
        return type(self)(self.lhs, self.rhs, strength, weight)

    def __ror__(self, other):
        return self.__or__(other)

    def __hash__(self):
        return object.__hash__(self)


class LEConstraint(LinearConstraint):

    __slots__ = ()

    def __init__(self, lhs, rhs, strength='required', weight=1.0):
        super(LEConstraint, self).__init__(lhs, rhs, strength, weight)
        self.op = '<='


class GEConstraint(LinearConstraint):

    __slots__ = ()

    def __init__(self, lhs, rhs, strength='required', weight=1.0):
        super(GEConstraint, self).__init__(lhs, rhs, strength, weight)
        self.op = b'>='


class EQConstraint(LinearConstraint):

    __slots__ = ()

    def __init__(self, lhs, rhs, strength='required', weight=1.0):
        super(EQConstraint, self).__init__(lhs, rhs, strength, weight)
        self.op = b'=='


########NEW FILE########
__FILENAME__ = geometry
#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Rect
#------------------------------------------------------------------------------
class BaseRect(tuple):
    """ A tuple subclass representing an (x, y, width, height) 
    bounding box. Subclasses should override the __new__ method 
    to enforce any necessary typing.

    """
    __slots__ = ()

    def __new__(cls, x, y, width, height):
        return super(BaseRect, cls).__new__(cls, (x, y, width, height))

    def __getnewargs__(self):
        return tuple(self)

    def __repr__(self):
        template = '%s(x=%s, y=%s, width=%s, height=%s)'
        values = (self.__class__.__name__,) + self
        return template % values

    @property
    def x(self):
        """ The 'x' position component of the rect.

        """
        return self[0]
    
    @property
    def y(self):
        """ The 'y' position component of the rect.

        """
        return self[1]
    
    @property
    def width(self):
        """ The 'width' size component of the rect.

        """
        return self[2]
    
    @property
    def height(self):
        """ The 'height' size component of the rect.

        """
        return self[3]


class Rect(BaseRect):
    """ A BaseRect implementation for integer values.

    """
    __slots__ = ()

    def __new__(cls, x, y, width, height):
        i = int
        return super(Rect, cls).__new__(cls, i(x), i(y), i(width), i(height))
        
    @property
    def box(self):
        """ The equivalent Box for this rect.

        """
        x, y, width, height = self
        return Box(y, x + width, y + height, x)

    @property
    def pos(self):
        """ The position of the rect as a Pos object.

        """
        return Pos(self.x, self.y)
    
    @property
    def size(self):
        """ The size of the rect as a Size object.

        """
        return Size(self.width, self.height)
    

class RectF(BaseRect):
    """ A BaseRect implementation for floating point values.

    """
    __slots__ = ()

    def __new__(cls, x, y, width, height):
        f = float
        return super(RectF, cls).__new__(cls, f(x), f(y), f(width), f(height))
    
    @property
    def box(self):
        """ The equivalent Box for this rect.

        """
        x, y, width, height = self
        return BoxF(y, x + width, y + height, x)

    @property
    def pos(self):
        """ The position of the rect as a Pos object.

        """
        return PosF(self.x, self.y)
    
    @property
    def size(self):
        """ The size of the rect as a Size object.

        """
        return SizeF(self.width, self.height)


#------------------------------------------------------------------------------
# Box
#------------------------------------------------------------------------------
class BaseBox(tuple):
    """ A tuple subclass representing a (top, right, bottom, left) box.
    Subclasses should override the __new__ method to enforce any typing.

    """
    __slots__ = ()

    @staticmethod
    def coerce_type(item):
        return item

    def __new__(cls, top=None, right=None, bottom=None, left=None):
        if isinstance(top, (tuple, BaseBox)):
            return cls(*top)
        c = cls.coerce_type
        top = c(top)
        if right is None:
            right = top
        else:
            right = c(right)
        if bottom is None:
            bottom = top
        else:
            bottom = c(bottom)
        if left is None:
            left = right
        else:
            left = c(left)
        return super(BaseBox, cls).__new__(cls, (top, right, bottom, left))
    
    def __getnewargs__(self):
        return tuple(self)

    def __repr__(self):
        template = '%s(top=%s, right=%s, bottom=%s, left=%s)'
        values = (self.__class__.__name__,) + self
        return template % values

    @property
    def top(self):
        """ The 'top' component of the box.

        """
        return self[0]
    
    @property
    def right(self):
        """ The 'right' component of the box.

        """
        return self[1]
    
    @property
    def bottom(self):
        """ The 'bottom' component of the box.

        """
        return self[2]
    
    @property
    def left(self):
        """ The 'left' component of the box.

        """
        return self[3]
    

class Box(BaseBox):
    """ A BaseBox implementation for integer values.

    """
    __slots__ = ()

    @staticmethod
    def coerce_type(item):
        return 0 if item is None else int(item)
    
    @property
    def rect(self):
        """ The equivalent Rect for this box.

        """
        top, right, bottom, left = self
        return Rect(left, top, right - left, bottom - top)
    
    @property
    def size(self):
        """ The Size of this box.

        """
        top, right, bottom, left = self
        return Size(right - left, bottom - top)

    @property
    def pos(self):
        """ The Pos of this box.

        """
        return Pos(self.left, self.top)


class BoxF(BaseBox):
    """ A BaseBox implementation for floating point values.

    """
    __slots__ = ()

    @staticmethod
    def coerce_type(item):
        return 0.0 if item is None else float(item)
    
    @property
    def rect(self):
        """ The equivalent Rect for this box.

        """
        top, right, bottom, left = self
        return RectF(left, top, right - left, bottom - top)
    
    @property
    def size(self):
        """ The Size of this box.

        """
        top, right, bottom, left = self
        return SizeF(right - left, bottom - top)

    @property
    def pos(self):
        """ The Pos of this box.

        """
        return PosF(self.left, self.top)


#------------------------------------------------------------------------------
# Pos
#------------------------------------------------------------------------------
class BasePos(tuple):
    """ A tuple subclass representing a (x, y) positions. Subclasses 
    should override the __new__ method to enforce any necessary typing.

    """
    __slots__ = ()

    def __new__(cls, x, y):
        return super(BasePos, cls).__new__(cls, (x, y))
    
    def __getnewargs__(self):
        return tuple(self)

    def __repr__(self):
        template = '%s(x=%s, y=%s)'
        values = (self.__class__.__name__,) + self
        return template % values

    @property
    def x(self):
        """ The 'x' component of the size.

        """
        return self[0]
    
    @property
    def y(self):
        """ The 'y' component of the size.

        """
        return self[1]


class Pos(BasePos):
    """ An implementation of BasePos for integer values.

    """
    __slots__ = ()

    def __new__(cls, x, y):
        i = int
        return super(Pos, cls).__new__(cls, i(x), i(y))


class PosF(BasePos):
    """ An implementation of BasePos of floating point values.

    """
    __slots__ = ()

    def __new__(cls, x, y):
        f = float
        return super(PosF, cls).__new__(cls, f(x), f(y))


#------------------------------------------------------------------------------
# Size
#------------------------------------------------------------------------------
class BaseSize(tuple):
    """ A tuple subclass representing a (width, height) size. Subclasses 
    should override the __new__ method to enforce any necessary typing.

    """
    __slots__ = ()

    @staticmethod
    def coerce_type(item):
        return item

    def __new__(cls, width=None, height=None):
        if isinstance(width, (tuple, BaseSize)):
            return cls(*width)
        c = cls.coerce_type
        width = c(width)
        if height is None:
            height = width
        else:
            height = c(height)
        return super(BaseSize, cls).__new__(cls, (width, height))

    def __getnewargs__(self):
        return tuple(self)

    def __repr__(self):
        template = '%s(width=%s, height=%s)'
        values = (self.__class__.__name__,) + self
        return template % values

    @property
    def width(self):
        """ The 'width' component of the size.

        """
        return self[0]
    
    @property
    def height(self):
        """ The 'height' component of the size.

        """
        return self[1]
    

class Size(BaseSize):
    """ A BaseSize implementation for integer values.

    """
    __slots__ = ()
    
    @staticmethod
    def coerce_type(item):
        return 0 if item is None else int(item)


class SizeF(BaseSize):
    """ A BaseSize implementation for floating point values.

    """
    __slots__ = ()

    @staticmethod
    def coerce_type(item):
        return 0.0 if item is None else float(item)


########NEW FILE########
__FILENAME__ = layout_helpers
#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from abc import ABCMeta, abstractmethod
from collections import defaultdict
from uuid import uuid4

from traits.api import HasTraits, Range

from enaml.core.trait_types import CoercingInstance

from .ab_constrainable import ABConstrainable
from .box_model import BoxModel
from .constraint_variable import ConstraintVariable, LinearSymbolic, STRENGTHS
from .geometry import Box


#------------------------------------------------------------------------------
# Default Spacing
#------------------------------------------------------------------------------
class DefaultSpacing(HasTraits):
    """ A class which encapsulates the default spacing parameters for
    the various layout helper objects.

    """
    #: The space between abutted components
    ABUTMENT = Range(low=0, value=10)

    #: The space between aligned anchors
    ALIGNMENT = Range(low=0, value=0)

    #: The margins for box helpers
    BOX_MARGINS = CoercingInstance(Box, default=Box(0, 0, 0, 0))


# We only require a singleton of DefaultSpacing
DefaultSpacing = DefaultSpacing()


#------------------------------------------------------------------------------
# Helper Functions
#------------------------------------------------------------------------------
def expand_constraints(component, constraints):
    """ A function which expands any DeferredConstraints in the provided
    list. This is a generator function which yields the flattened stream
    of constraints.

    Paramters
    ---------
    component : Constrainable
        The constrainable component with which the constraints are
        associated. This will be passed to the .get_constraints()
        method of any DeferredConstraint instance.

    constraints : list
        The list of constraints.

    Yields
    ------
    constraints
        The stream of expanded constraints.

    """
    for cn in constraints:
        if isinstance(cn, DeferredConstraints):
            for item in cn.get_constraints(component):
                if item is not None:
                    yield item
        else:
            if cn is not None:
                yield cn


def is_spacer(item):
    """ Returns True if the given item can be considered a spacer, False
    other otherwise.

    """
    return isinstance(item, (Spacer, int))


#------------------------------------------------------------------------------
# Deferred Constraints
#------------------------------------------------------------------------------
class DeferredConstraints(object):
    """ Abstract base class for objects that will yield lists of
    constraints upon request.

    """
    __metaclass__ = ABCMeta

    def __init__(self):
        """ Initialize a DeferredConstraints instance.

        """
        # __or__() will set these default strength and weight. If
        # provided, they will be combined with the constraints created
        # by this instance.
        self.default_strength = None
        self.default_weight = None

    def __or__(self, other):
        """ Set the strength of all of the constraints to a common
        strength.

        """
        if isinstance(other, (float, int, long)):
            self.default_weight = float(other)
        elif isinstance(other, basestring):
            if other not in STRENGTHS:
                raise ValueError('Invalid strength %r' % other)
            self.default_strength = other
        else:
            msg = 'Strength must be a string. Got %s instead.'
            raise TypeError(msg % type(other))
        return self

    def when(self, switch):
        """ A simple method that can be used to switch off the generated
        constraints depending on a boolean value.

        """
        if switch:
            return self

    def get_constraints(self, component):
        """ Returns a list of weighted LinearConstraints.

        Parameters
        ----------
        component : Component or None
            The component that owns this DeferredConstraints. It can
            be None for contexts in which there is not a containing
            component, such as in certain nested DeferredConstraints.

        Returns
        -------
        result : list of LinearConstraints
            The list of LinearConstraint objects which have been
            weighted by any provided strengths and weights.

        """
        cn_list = self._get_constraints(component)
        strength = self.default_strength
        if strength is not None:
            cn_list = [cn | strength for cn in cn_list]
        weight = self.default_weight
        if weight is not None:
            cn_list = [cn | weight for cn in cn_list]
        return cn_list

    @abstractmethod
    def _get_constraints(self, component):
        """ Returns a list of LinearConstraint objects.

        Subclasses must implement this method to actually yield their
        constraints. Users of instances should instead call the
        `get_constraints()` method which will combine these
        constraints with the `default_strength` and/or the
        `default_weight` if one or both are provided.

        Parameters
        ----------
        component : Component or None
            The component that owns this DeferredConstraints. It can
            be None for contexts in which there is not a containing
            component, such as in certain nested DeferredConstraints.

        Returns
        -------
        result : list of LinearConstraints
            The list of LinearConstraint objects for this deferred
            instance.

        """
        raise NotImplementedError


#------------------------------------------------------------------------------
# Deferred Constraints Implementations
#------------------------------------------------------------------------------
class DeferredConstraintsFunction(DeferredConstraints):
    """ A concrete implementation of DeferredConstraints which will
    call a function to get the constraint list upon request.

    """
    def __init__(self, func, *args, **kwds):
        """ Initialize a DeferredConstraintsFunction.

        Parameters
        ----------
        func : callable
            A callable object which will return the list of constraints.

        *args
            The arguments to pass to 'func'.

        **kwds
            The keyword arguments to pass to 'func'.

        """
        super(DeferredConstraintsFunction, self).__init__()
        self.func = func
        self.args = args
        self.kwds = kwds

    def _get_constraints(self, component):
        """ Abstract method implementation which calls the underlying
        function to generate the list of constraints.

        """
        return self.func(*self.args, **self.kwds)


class AbutmentHelper(DeferredConstraints):
    """ A concrete implementation of DeferredConstraints which will
    lay out its components by abutting them in a given orientation.

    """
    def __init__(self, orientation, *items, **config):
        """ Initialize an AbutmentHelper.

        Parameters
        ----------
        orientation
            A string which is either 'horizontal' or 'vertical' which
            indicates the abutment orientation.

        *items
            The components to abut in the given orientation.

        **config
            Configuration options for how this helper should behave.
            The following options are currently supported:

            spacing
                An integer >= 0 which indicates how many pixels of
                inter-element spacing to use during abutment. The
                default is the value of DefaultSpacing.ABUTMENT.

        """
        super(AbutmentHelper, self).__init__()
        self.orientation = orientation
        self.items = items
        self.spacing = config.get('spacing', DefaultSpacing.ABUTMENT)

    def __repr__(self):
        """ A pretty string representation of the helper.

        """
        items = ', '.join(map(repr, self.items))
        return '{0}({1})'.format(self.orientation, items)

    def _get_constraints(self, component):
        """ Abstract method implementation which applies the constraints
        to the given items, after filtering them for None values.

        """
        items = [item for item in self.items if item is not None]
        factories = AbutmentConstraintFactory.from_items(
            items, self.orientation, self.spacing,
        )
        cn_lists = (f.constraints() for f in factories)
        return list(cn for cns in cn_lists for cn in cns)


class AlignmentHelper(DeferredConstraints):
    """ A deferred constraints helper class that lays out with a given
    anchor to align.

    """
    def __init__(self, anchor, *items, **config):
        """ Initialize an AlignmentHelper.

        Parameters
        ----------
        anchor
            A string which is either 'left', 'right', 'top', 'bottom',
            'v_center', or 'h_center'.

        *items
            The components to align on the given anchor.

        **config
            Configuration options for how this helper should behave.
            The following options are currently supported:

            spacing
                An integer >= 0 which indicates how many pixels of
                inter-element spacing to use during alignement. The
                default is the value of DefaultSpacing.ALIGNMENT.

        """
        super(AlignmentHelper, self).__init__()
        self.anchor = anchor
        self.items = items
        self.spacing = config.get('spacing', DefaultSpacing.ALIGNMENT)

    def __repr__(self):
        """ A pretty string representation of the layout helper.

        """
        items = ', '.join(map(repr, self.items))
        return 'align({0!r}, {1})'.format(self.anchor, items)

    def _get_constraints(self, component):
        """ Abstract method implementation which applies the constraints
        to the given items, after filtering them for None values.

        """
        items = [item for item in self.items if item is not None]
        # If there are less than two items, no alignment needs to
        # happen, so return no constraints.
        if len(items) < 2:
            return []
        factories = AlignmentConstraintFactory.from_items(
            items, self.anchor, self.spacing,
        )
        cn_lists = (f.constraints() for f in factories)
        return list(cn for cns in cn_lists for cn in cns)


class BoxHelper(DeferredConstraints):
    """ A DeferredConstraints helper class which adds a box model to
    the helper.

    The addition of the box model allows the helper to be registered
    as ABConstrainable which has the effect of allowing box helper
    instances to be nested.

    """
    def __init__(self, name):
        """ Initialize a BoxHelper.

        Parameters
        ----------
        name : str
            A string name to prepend to a unique owner id generated
            for this box helper, to aid in debugging.

        """
        super(BoxHelper, self).__init__()
        self.constraints_id = name + '|' + uuid4().hex
        self._box_model = BoxModel(self.constraints_id)

    left = property(lambda self: self._box_model.left)
    top = property(lambda self: self._box_model.top)
    right = property(lambda self: self._box_model.right)
    bottom = property(lambda self: self._box_model.bottom)
    width = property(lambda self: self._box_model.width)
    height = property(lambda self: self._box_model.height)
    v_center = property(lambda self: self._box_model.v_center)
    h_center = property(lambda self: self._box_model.h_center)


ABConstrainable.register(BoxHelper)


class LinearBoxHelper(BoxHelper):
    """ A layout helper which arranges items in a linear box.

    """
    #: A mapping orientation to the anchor names needed to make the
    #: constraints on the containing component.
    orientation_map = {
        'horizontal': ('left', 'right'),
        'vertical': ('top', 'bottom'),
    }

    #: A mapping of ortho orientations
    ortho_map = {
        'horizontal': 'vertical',
        'vertical': 'horizontal',
    }

    def __init__(self, orientation, *items, **config):
        """ Initialize a LinearBoxHelper.

        Parameters
        ----------
        orientation : str
            The layout orientation of the box. This must be either
            'horizontal' or 'vertical'.

        *items
            The components to align on the given anchor.

        **config
            Configuration options for how this helper should behave.
            The following options are currently supported:

            spacing
                An integer >= 0 which indicates how many pixels of
                inter-element spacing to use during abutment. The
                default is the value of DefaultSpacing.ABUTMENT.

            margins
                A int, tuple of ints, or Box of ints >= 0 which
                indicate how many pixels of margin to add around
                the bounds of the box. The default is the value of
                DefaultSpacing.BOX_MARGIN.

        """
        super(LinearBoxHelper, self).__init__(orientation[0] + 'box')
        self.items = items
        self.orientation = orientation
        self.ortho_orientation = self.ortho_map[orientation]
        self.spacing = config.get('spacing', DefaultSpacing.ABUTMENT)
        self.margins = Box(config.get('margins', DefaultSpacing.BOX_MARGINS))

    def __repr__(self):
        """ A pretty string representation of the layout helper.

        """
        items = ', '.join(map(repr, self.items))
        return '{0}box({1})'.format(self.orientation[0], items)

    def _get_constraints(self, component):
        """ Generate the linear box constraints.

        This is an abstractmethod implementation which will use the
        space available on the provided component to layout the items.

        """
        items = [item for item in self.items if item is not None]
        if len(items) == 0:
            return items

        first, last = self.orientation_map[self.orientation]
        first_boundary = getattr(self, first)
        last_boundary = getattr(self, last)
        first_ortho, last_ortho = self.orientation_map[self.ortho_orientation]
        first_ortho_boundary = getattr(self, first_ortho)
        last_ortho_boundary = getattr(self, last_ortho)

        # Setup the initial outer constraints of the box
        if component is not None:
            # This box helper is inside a real component, not just nested
            # inside of another box helper. Check if the component is a
            # PaddingConstraints object and use it's contents anchors.
            attrs = ['top', 'bottom', 'left', 'right']
            # XXX hack!
            if hasattr(component, 'contents_top'):
                other_attrs = ['contents_' + attr for attr in attrs]
            else:
                other_attrs = attrs[:]
            constraints = [
                getattr(self, attr) == getattr(component, other)
                for (attr, other) in zip(attrs, other_attrs)
            ]
        else:
            constraints = []

        # Create the margin spacers that will be used.
        margins = self.margins
        if self.orientation == 'vertical':
            first_spacer = EqSpacer(margins.top)
            last_spacer = EqSpacer(margins.bottom)
            first_ortho_spacer = FlexSpacer(margins.left)
            last_ortho_spacer = FlexSpacer(margins.right)
        else:
            first_spacer = EqSpacer(margins.left)
            last_spacer = EqSpacer(margins.right)
            first_ortho_spacer = FlexSpacer(margins.top)
            last_ortho_spacer = FlexSpacer(margins.bottom)

        # Add a pre and post padding spacer if the user hasn't specified
        # their own spacer as the first/last element of the box items.
        if not is_spacer(items[0]):
            pre_along_args = [first_boundary, first_spacer]
        else:
            pre_along_args = [first_boundary]
        if not is_spacer(items[-1]):
            post_along_args = [last_spacer, last_boundary]
        else:
            post_along_args = [last_boundary]

        # Accummulate the constraints in the direction of the layout
        along_args = pre_along_args + items + post_along_args
        kwds = dict(spacing=self.spacing)
        helpers = [AbutmentHelper(self.orientation, *along_args, **kwds)]
        ortho = self.ortho_orientation
        for item in items:
            # Add the helpers for the ortho constraints
            if isinstance(item, ABConstrainable):
                abutment_items = (
                    first_ortho_boundary, first_ortho_spacer,
                    item, last_ortho_spacer, last_ortho_boundary,
                )
                helpers.append(AbutmentHelper(ortho, *abutment_items, **kwds))
            # Pull out nested helpers so that their constraints get
            # generated during the pass over the helpers list.
            if isinstance(item, DeferredConstraints):
                helpers.append(item)

        # Pass over the list of child helpers and generate the
        # flattened list of constraints.
        for helper in helpers:
            constraints.extend(helper.get_constraints(None))

        return constraints


class _GridCell(object):
    """ A private class used by a GridHelper to track item cells.

    """
    def __init__(self, item, row, col):
        """ Initialize a _GridCell.

        Parameters
        ----------
        item : object
            The item contained in the cell.

        row : int
            The row index of the cell.

        col : int
            The column index of the cell.

        """
        self.item = item
        self.start_row = row
        self.start_col = col
        self.end_row = row
        self.end_col = col

    def expand_to(self, row, col):
        """ Expand the cell to enclose the given row and column.

        """
        self.start_row = min(row, self.start_row)
        self.end_row = max(row, self.end_row)
        self.start_col = min(col, self.start_col)
        self.end_col = max(col, self.end_col)


class GridHelper(BoxHelper):
    """ A layout helper which arranges items in a grid.

    """
    def __init__(self, *rows, **config):
        """ Initialize a GridHelper.

        Parameters
        ----------
        *rows: iterable of lists
            The rows to layout in the grid. A row must be composed of
            constrainable objects and None. An item will be expanded
            to span all of the cells in which it appears.

        **config
            Configuration options for how this helper should behave.
            The following options are currently supported:

            row_align
                A string which is the name of a constraint variable on
                a item. If given, it is used to add constraints on the
                alignment of items in a row. The constraints will only
                be applied to items that do not span rows.

            row_spacing
                An integer >= 0 which indicates how many pixels of
                space should be placed between rows in the grid. The
                default is the value of DefaultSpacing.ABUTMENT.

            column_align
                A string which is the name of a constraint variable on
                a item. If given, it is used to add constraints on the
                alignment of items in a column. The constraints will
                only be applied to items that do not span columns.

            column_spacing
                An integer >= 0 which indicates how many pixels of
                space should be placed between columns in the grid.
                The default is the value of DefaultSpacing.ABUTMENT.

            margins
                A int, tuple of ints, or Box of ints >= 0 which
                indicate how many pixels of margin to add around
                the bounds of the grid. The default is the value of
                DefaultSpacing.BOX_MARGIN.

        """
        super(GridHelper, self).__init__('grid')
        self.grid_rows = rows
        self.row_align = config.get('row_align', '')
        self.col_align = config.get('col_align', '')
        self.row_spacing = config.get('row_spacing', DefaultSpacing.ABUTMENT)
        self.col_spacing = config.get('column_spacing', DefaultSpacing.ABUTMENT)
        self.margins = Box(config.get('margins', DefaultSpacing.BOX_MARGINS))

    def __repr__(self):
        """ A pretty string representation of the layout helper.

        """
        items = ', '.join(map(repr, self.grid_rows))
        return 'grid({0})'.format(items)

    def _get_constraints(self, component):
        """ Generate the grid constraints.

        This is an abstractmethod implementation which will use the
        space available on the provided component to layout the items.

        """
        grid_rows = self.grid_rows
        if not grid_rows:
            return []

        # Validate and compute the cell span for the items in the grid.
        cells = []
        cell_map = {}
        num_cols = 0
        num_rows = len(grid_rows)
        for row_idx, row in enumerate(grid_rows):
            for col_idx, item in enumerate(row):
                if item is None:
                    continue
                elif isinstance(item, ABConstrainable):
                    if item in cell_map:
                        cell_map[item].expand_to(row_idx, col_idx)
                    else:
                        cell = _GridCell(item, row_idx, col_idx)
                        cell_map[item] = cell
                        cells.append(cell)
                else:
                    m = ('Grid cells must be constrainable objects or None. '
                         'Got object of type `%s` instead.')
                    raise TypeError(m % type(item).__name__)
            num_cols = max(num_cols, col_idx + 1)

        # Setup the initial outer constraints of the grid
        if component is not None:
            # This box helper is inside a real component, not just nested
            # inside of another box helper. Check if the component is a
            # PaddingConstraints object and use it's contents anchors.
            attrs = ['top', 'bottom', 'left', 'right']
            # XXX hack!
            if hasattr(component, 'contents_top'):
                other_attrs = ['contents_' + attr for attr in attrs]
            else:
                other_attrs = attrs[:]
            constraints = [
                getattr(self, attr) == getattr(component, other)
                for (attr, other) in zip(attrs, other_attrs)
            ]
        else:
            constraints = []

        # Create the row and column constraint variables along with
        # some default limits
        row_vars = []
        col_vars = []
        cn_id = self.constraints_id
        for idx in xrange(num_rows + 1):
            name = 'row' + str(idx)
            var = ConstraintVariable(name, cn_id)
            row_vars.append(var)
            constraints.append(var >= 0)
        for idx in xrange(num_cols + 1):
            name = 'col' + str(idx)
            var = ConstraintVariable(name, cn_id)
            col_vars.append(var)
            constraints.append(var >= 0)

        # Add some neighbor relations to the row and column vars.
        for r1, r2 in zip(row_vars[:-1], row_vars[1:]):
            constraints.append(r1 <= r2)
        for c1, c2 in zip(col_vars[:-1], col_vars[1:]):
            constraints.append(c1 <= c2)

        # Setup the initial interior bounding box for the grid.
        margins = self.margins
        top_items = (self.top, EqSpacer(margins.top), row_vars[0])
        bottom_items = (row_vars[-1], EqSpacer(margins.bottom), self.bottom)
        left_items = (self.left, EqSpacer(margins.left), col_vars[0])
        right_items = (col_vars[-1], EqSpacer(margins.right), self.right)
        helpers = [
            AbutmentHelper('vertical', *top_items),
            AbutmentHelper('vertical', *bottom_items),
            AbutmentHelper('horizontal', *left_items),
            AbutmentHelper('horizontal', *right_items),
        ]

        # Setup the spacer list for constraining the cell items
        row_spacer = FlexSpacer(self.row_spacing / 2.)
        col_spacer = FlexSpacer(self.col_spacing / 2.)
        rspace = [row_spacer] * len(row_vars)
        rspace[0] = 0
        rspace[-1] = 0
        cspace = [col_spacer] * len(col_vars)
        cspace[0] = 0
        cspace[-1] = 0

        # Setup the constraints for each constrainable grid cell.
        for cell in cells:
            sr = cell.start_row
            er = cell.end_row + 1
            sc = cell.start_col
            ec = cell.end_col + 1
            item = cell.item
            row_item = (
                row_vars[sr], rspace[sr], item, rspace[er], row_vars[er]
            )
            col_item = (
                col_vars[sc], cspace[sc], item, cspace[ec], col_vars[ec]
            )
            helpers.append(AbutmentHelper('vertical', *row_item))
            helpers.append(AbutmentHelper('horizontal', *col_item))
            if isinstance(item, DeferredConstraints):
                helpers.append(item)

        # Add the row alignment constraints if given. This will only
        # apply the alignment constraint to items which do not span
        # multiple rows.
        if self.row_align:
            row_map = defaultdict(list)
            for cell in cells:
                if cell.start_row == cell.end_row:
                    row_map[cell.start_row].append(cell.item)
            for items in row_map.itervalues():
                if len(items) > 1:
                    helpers.append(AlignmentHelper(self.row_align, *items))

        # Add the column alignment constraints if given. This will only
        # apply the alignment constraint to items which do not span
        # multiple columns.
        if self.col_align:
            col_map = defaultdict(list)
            for cell in cells:
                if cell.start_col == cell.end_col:
                    col_map[cell.start_col].append(cell.item)
            for items in row_map.itervalues():
                if len(items) > 1:
                    helpers.append(AlignmentHelper(self.col_align, *items))

        # Add the child helpers constraints to the constraints list.
        for helper in helpers:
            constraints.extend(helper.get_constraints(None))

        return constraints


#------------------------------------------------------------------------------
# Abstract Constraint Factory
#------------------------------------------------------------------------------
class AbstractConstraintFactory(object):
    """ An abstract constraint factory class. Subclasses must implement
    the 'constraints' method implement which returns a LinearConstraint
    instance.

    """
    __metaclass__ = ABCMeta

    @staticmethod
    def validate(items):
        """ A validator staticmethod that insures a sequence of items is
        appropriate for generating a sequence of linear constraints. The
        following conditions are verified of the sequence of given items:

            * The number of items in the sequence is 0 or >= 2.

            * The first and last items are instances of either
              LinearSymbolic or Constrainable.

            * All of the items in the sequence are instances of
              LinearSymbolic, Constrainable, Spacer, or int.

        If any of the above conditions do not hold, an exception is
        raised with a (hopefully) useful error message.

        """
        if len(items) == 0:
            return

        if len(items) < 2:
            msg = 'Two or more items required to setup abutment constraints.'
            raise ValueError(msg)

        extrema_types = (LinearSymbolic, ABConstrainable)
        def extrema_test(item):
            return isinstance(item, extrema_types)

        item_types = (LinearSymbolic, ABConstrainable, Spacer, int)
        def item_test(item):
            return isinstance(item, item_types)

        if not all(extrema_test(item) for item in (items[0], items[-1])):
            msg = ('The first and last items of a constraint sequence '
                   'must be anchors or Components. Got %s instead.')
            args = [type(items[0]), type(items[1])]
            raise TypeError(msg % args)

        if not all(map(item_test, items)):
            msg = ('The allowed items for a constraint sequence are'
                   'anchors, Components, Spacers, and ints. '
                   'Got %s instead.')
            args = [type(item) for item in items]
            raise TypeError(msg % args)

    @abstractmethod
    def constraints(self):
        """ An abstract method which must be implemented by subclasses.
        It should return a list of LinearConstraint instances.

        """
        raise NotImplementedError


#------------------------------------------------------------------------------
# Abstract Constraint Factory Implementations
#------------------------------------------------------------------------------
class BaseConstraintFactory(AbstractConstraintFactory):
    """ A base constraint factory class that implements basic common
    logic. It is not meant to be used directly but should rather be
    subclassed to be useful.

    """
    def __init__(self, first_anchor, spacer, second_anchor):
        """ Create an base constraint instance.

        Parameters
        ----------
        first_anchor : LinearSymbolic
            A symbolic object that can be used in a constraint expression.

        spacer : Spacer
            A spacer instance to put space between the items.

        second_anchor : LinearSymbolic
            The second anchor for the constraint expression.

        """
        self.first_anchor = first_anchor
        self.spacer = spacer
        self.second_anchor = second_anchor

    def constraints(self):
        """ Returns LinearConstraint instance which is formed through
        an appropriate linear expression for the given space between
        the anchors.

        """
        first = self.first_anchor
        second = self.second_anchor
        spacer = self.spacer
        return spacer.constrain(first, second)


class SequenceConstraintFactory(BaseConstraintFactory):
    """ A BaseConstraintFactory subclass that represents a constraint
    between two anchors of different components separated by some amount
    of space. It has a '_make_cns' classmethod which will create a list
    of constraint factory instances from a sequence of items, the two
    anchor names, and a default spacing.

    """
    @classmethod
    def _make_cns(cls, items, first_anchor_name, second_anchor_name, spacing):
        """ A classmethod that generates a list of constraints factories
        given a sequence of items, two anchor names, and default spacing.

        Parameters
        ----------
        items : sequence
            A valid sequence of constrainable objects. These inclue
            instances of Constrainable, LinearSymbolic, Spacer,
            and int.

        first_anchor_name : string
            The name of the anchor on the first item in a constraint
            pair.

        second_anchor_name : string
            The name of the anchor on the second item in a constraint
            pair.

        spacing : int
            The spacing to use between items if no spacing is explicitly
            provided by in the sequence of items.

        Returns
        -------
        result : list
            A list of constraint factory instance.

        """
        # Make sure the items we'll be dealing with are valid for the
        # algorithm. This is a basic validation. Further error handling
        # is performed as needed.
        cls.validate(items)

        # The list of constraints we'll be creating for the given
        # sequence of items.
        cns = []

        # The list of items is treated as a stack. So we want to first
        # reverse it so the first items are at the top of the stack.
        items = list(reversed(items))

        while items:

            # Grab the item that will provide the first anchor
            first_item = items.pop()

            # first_item will be a Constrainable or a LinearSymbolic.
            # For the first iteration, this is enforced by 'validate'.
            # For subsequent iterations, this condition is enforced by
            # the fact that this loop only pushes those types back onto
            # the stack.
            if isinstance(first_item, ABConstrainable):
                first_anchor = getattr(first_item, first_anchor_name)
            elif isinstance(first_item, LinearSymbolic):
                first_anchor = first_item
            else:
                raise TypeError('This should never happen')

            # Grab the next item off the stack. It will be an instance
            # of Constrainable, LinearSymbolic, Spacer, or int. If it
            # can't provide an anchor, we grab the item after it which
            # *should* be able to provide one. If no space is given, we
            # use the provided default space.
            next_item = items.pop()
            if isinstance(next_item, Spacer):
                spacer = next_item
                second_item = items.pop()
            elif isinstance(next_item, int):
                spacer = EqSpacer(next_item)
                second_item = items.pop()
            elif isinstance(next_item, (ABConstrainable, LinearSymbolic)):
                spacer = EqSpacer(spacing)
                second_item = next_item
            else:
                raise ValueError('This should never happen')

            # If the second_item can't provide an anchor, such as two
            # spacers next to each other, then this is an error and we
            # raise an appropriate exception.
            if isinstance(second_item, ABConstrainable):
                second_anchor = getattr(second_item, second_anchor_name)
            elif isinstance(second_item, LinearSymbolic):
                second_anchor = second_item
            else:
                msg = 'Expected anchor or Constrainable. Got %r instead.'
                raise TypeError(msg % second_item)

            # Create the class instance for this constraint
            factory = cls(first_anchor, spacer, second_anchor)

            # If there are still items on the stack, then the second_item
            # will be used as the first_item in the next iteration.
            # Otherwise, we have exhausted all constraints and can exit.
            if items:
                items.append(second_item)

            # Finally, store away the created factory for returning.
            cns.append(factory)

        return cns


class AbutmentConstraintFactory(SequenceConstraintFactory):
    """ A SequenceConstraintFactory subclass that represents an abutment
    constraint, which is a constraint between two anchors of different
    components separated by some amount of space. It has a 'from_items'
    classmethod which will create a sequence of abutment constraints
    from a sequence of items, a direction, and default spacing.

    """
    #: A mapping from orientation to the order of anchor names to
    #: lookup for a pair of items in order to make the constraint.
    orientation_map = {
        'horizontal': ('right', 'left'),
        'vertical': ('bottom', 'top'),
    }

    @classmethod
    def from_items(cls, items, orientation, spacing):
        """ A classmethod that generates a list of abutment constraints
        given a sequence of items, an orientation, and default spacing.

        Parameters
        ----------
        items : sequence
            A valid sequence of constrainable objects. These inclue
            instances of Constrainable, LinearSymbolic, Spacer,
            and int.

        orientation : string
            Either 'vertical' or 'horizontal', which represents the
            orientation in which to abut the items.

        spacing : int
            The spacing to use between items if no spacing is explicitly
            provided by in the sequence of items.

        Returns
        -------
        result : list
            A list of AbutmentConstraint instances.

        Notes
        ------
        The order of abutment is left-to-right for horizontal direction
        and top-to-bottom for vertical direction.

        """
        # Grab the tuple of anchor names to lookup for each pair of
        # items in order to make the connection.
        orient = cls.orientation_map.get(orientation)
        if orient is None:
            msg = ("Valid orientations for abutment are 'vertical' or "
                   "'horizontal'. Got %r instead.")
            raise ValueError(msg % orientation)
        first_name, second_name = orient
        return cls._make_cns(items, first_name, second_name, spacing)


class AlignmentConstraintFactory(SequenceConstraintFactory):
    """ A SequenceConstraintFactory subclass which represents an
    alignmnent constraint, which is a constraint between two anchors of
    different components which are aligned but may be separated by some
    amount of space. It provides a 'from_items' classmethod which will
    create a  list of alignment constraints from a sequence of items an
    anchor name, and a default spacing.

    """
    @classmethod
    def from_items(cls, items, anchor_name, spacing):
        """ A classmethod that will create a seqence of alignment
        constraints given a sequence of items, an anchor name, and
        a default spacing.

        Parameters
        ----------
        items : sequence
            A valid sequence of constrainable objects. These inclue
            instances of Constrainable, LinearSymbolic, Spacer,
            and int.

        anchor_name : string
            The name of the anchor on the components which should be
            aligned. Either 'left', 'right', 'top', 'bottom', 'v_center',
            or 'h_center'.

        spacing : int
            The spacing to use between items if no spacing is explicitly
            provided by in the sequence of items.

        Returns
        -------
        result : list
            A list of AbutmentConstraint instances.

        Notes
        -----
        For every item in the sequence, if the item is a component, then
        anchor for the given anchor_name on that component will be used.
        If a LinearSymbolic is given, then that symbolic will be used and
        the anchor_name will be ignored. Specifying space between items
        via integers or spacers is allowed.

        """
        return cls._make_cns(items, anchor_name, anchor_name, spacing)


#------------------------------------------------------------------------------
# Spacers
#------------------------------------------------------------------------------
class Spacer(object):
    """ An abstract base class for spacers. Subclasses must implement
    the 'constrain' method.

    """
    __metaclass__ = ABCMeta

    def __init__(self, amt, strength=None, weight=None):
        self.amt = max(0, amt)
        self.strength = strength
        self.weight = weight

    def when(self, switch):
        """ A simple method that can be used to switch off the generated
        space depending on a boolean value.

        """
        if switch:
            return self

    def constrain(self, first_anchor, second_anchor):
        """ Returns the list of generated constraints appropriately
        weighted by the default strength and weight, if provided.

        """
        constraints = self._constrain(first_anchor, second_anchor)
        strength = self.strength
        if strength is not None:
            constraints = [cn | strength for cn in constraints]
        weight = self.weight
        if weight is not None:
            constraints = [cn | weight for cn in constraints]
        return constraints

    @abstractmethod
    def _constrain(self, first_anchor, second_anchor):
        """ An abstract method. Subclasses should implement this method
        to return a list of LinearConstraint instances which separate
        the two anchors according to the amount of space represented
        by the spacer.

        """
        raise NotImplementedError


class EqSpacer(Spacer):
    """ A spacer which represents a fixed amount of space.

    """
    def _constrain(self, first_anchor, second_anchor):
        """ A constraint of the form (anchor_1 + space == anchor_2)

        """
        return [(first_anchor + self.amt) == second_anchor]


class LeSpacer(Spacer):
    """ A spacer which represents a flexible space with a maximum value.

    """
    def _constrain(self, first_anchor, second_anchor):
        """ A constraint of the form (anchor_1 + space >= anchor_2)
        That is, the visible space must be less than or equal to the
        given amount. An additional constraint is applied which
        constrains (anchor_1 <= anchor_2) to prevent negative space.

        """
        return [(first_anchor + self.amt) >= second_anchor,
                first_anchor <= second_anchor]


class GeSpacer(Spacer):
    """ A spacer which represents a flexible space with a minimum value.

    """
    def _constrain(self, first_anchor, second_anchor):
        """ A constraint of the form (anchor_1 + space <= anchor_2)
        That is, the visible space must be greater than or equal to
        the given amount.

        """
        return [(first_anchor + self.amt) <= second_anchor]


class FlexSpacer(Spacer):
    """ A spacer which represents a space with a hard minimum, but also
    a weaker preference for being that minimum.

    """
    def __init__(self, amt, min_strength='required', min_weight=1.0, eq_strength='medium', eq_weight=1.25):
        self.amt = max(0, amt)
        self.min_strength = min_strength
        self.min_weight = min_weight
        self.eq_strength = eq_strength
        self.eq_weight = eq_weight

    def constrain(self, first_anchor, second_anchor):
        """ Return list of LinearConstraint objects that are appropriate to
        separate the two anchors according to the amount of space represented by
        the spacer.

        """
        return self._constrain(first_anchor, second_anchor)

    def _constrain(self, first_anchor, second_anchor):
        """ Constraints of the form (anchor_1 + space <= anchor_2) and
        (anchor_1 + space == anchor_2)

        """
        return [
            ((first_anchor + self.amt) <= second_anchor) | self.min_strength | self.min_weight,
            ((first_anchor + self.amt) == second_anchor) | self.eq_strength | self.eq_weight,
        ]


class LayoutSpacer(Spacer):
    """ A Spacer instance which supplies convenience symbolic and normal
    methods to facilitate specifying spacers in layouts.

    """
    def __call__(self, *args, **kwargs):
        return self.__class__(*args, **kwargs)

    def __eq__(self, other):
        if not isinstance(other, int):
            raise TypeError('space can only be created from ints')
        return EqSpacer(other, self.strength, self.weight)

    def __le__(self, other):
        if not isinstance(other, int):
            raise TypeError('space can only be created from ints')
        return LeSpacer(other, self.strength, self.weight)

    def __ge__(self, other):
        if not isinstance(other, int):
            raise TypeError('space can only be created from ints')
        return GeSpacer(other, self.strength, self.weight)

    def _constrain(self, first_anchor, second_anchor):
        """ Returns a greater than or equal to spacing constraint.

        """
        spacer = GeSpacer(self.amt, self.strength, self.weight)
        return spacer._constrain(first_anchor, second_anchor)

    def flex(self, **kwargs):
        """ Returns a flex spacer for the current amount.

        """
        return FlexSpacer(self.amt, **kwargs)


#------------------------------------------------------------------------------
# Layout Helper Functions and Objects
#------------------------------------------------------------------------------
def horizontal(*items, **config):
    """ Create a DeferredConstraints object composed of horizontal
    abutments for the given sequence of items.

    """
    return AbutmentHelper('horizontal', *items, **config)


def vertical(*items, **config):
    """ Create a DeferredConstraints object composed of vertical
    abutments for the given sequence of items.

    """
    return AbutmentHelper('vertical', *items, **config)


def hbox(*items, **config):
    """ Create a DeferredConstraints object composed of horizontal
    abutments for a given sequence of items.

    """
    return LinearBoxHelper('horizontal', *items, **config)


def vbox(*items, **config):
    """ Create a DeferredConstraints object composed of vertical abutments
    for a given sequence of items.

    """
    return LinearBoxHelper('vertical', *items, **config)


def align(anchor, *items, **config):
    """ Align the given anchors of the given components. Inter-component
    spacing is allowed.

    """
    return AlignmentHelper(anchor, *items, **config)


def grid(*rows, **config):
    """ Create a DeferredConstraints object which lays out items in a
    grid.

    """
    return GridHelper(*rows, **config)


spacer = LayoutSpacer(DefaultSpacing.ABUTMENT)


########NEW FILE########
__FILENAME__ = layout_manager
#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from casuarius import Solver, medium


class LayoutManager(object):
    """ A class which uses a casuarius solver to manage a system
    of constraints.

    """
    def __init__(self):
        self._solver = Solver(autosolve=False)
        self._initialized = False
        self._running = False

    def initialize(self, constraints):
        """ Initialize the solver with the given constraints.

        Parameters
        ----------
        constraints : Iterable
            An iterable that yields the constraints to add to the
            solvers.

        """
        if self._initialized:
            raise RuntimeError('Solver already initialized')
        solver = self._solver
        solver.autosolve = False
        for cn in constraints:
            solver.add_constraint(cn)
        solver.autosolve = True
        self._initialized = True

    def replace_constraints(self, old_cns, new_cns):
        """ Replace constraints in the solver.

        Parameters
        ----------
        old_cns : list
            The list of casuarius constraints to remove from the
            solver.

        new_cns : list
            The list of casuarius constraints to add to the solver.

        """
        if not self._initialized:
            raise RuntimeError('Solver not yet initialized')
        solver = self._solver
        solver.autosolve = False
        for cn in old_cns:
            solver.remove_constraint(cn)
        for cn in new_cns:
            solver.add_constraint(cn)
        solver.autosolve = True

    def layout(self, cb, width, height, size, strength=medium, weight=1.0):
        """ Perform an iteration of the solver for the new width and
        height constraint variables.

        Parameters
        ----------
        cb : callable
            A callback which will be called when new values from the
            solver are available. This will be called from within a
            solver context while the solved values are valid. Thus
            the new values should be consumed before the callback
            returns.

        width : Constraint Variable
            The constraint variable representing the width of the
            main layout container.

        height : Constraint Variable
            The constraint variable representing the height of the
            main layout container.

        size : (int, int)
            The (width, height) size tuple which is the current size
            of the main layout container.

        strength : casuarius strength, optional
            The strength with which to perform the layout using the
            current size of the container. i.e. the strength of the
            resize. The default is casuarius.medium.

        weight : float, optional
            The weight to apply to the strength. The default is 1.0

        """
        if not self._initialized:
            raise RuntimeError('Layout with uninitialized solver')
        if self._running:
            return
        try:
            self._running = True
            w, h = size
            values = [(width, w), (height, h)]
            with self._solver.suggest_values(values, strength, weight):
                cb()
        finally:
            self._running = False

    def get_min_size(self, width, height, strength=medium, weight=0.1):
        """ Run an iteration of the solver with the suggested size of the
        component set to (0, 0). This will cause the solver to effectively
        compute the minimum size that the window can be to solve the
        system.

        Parameters
        ----------
        width : Constraint Variable
            The constraint variable representing the width of the
            main layout container.

        height : Constraint Variable
            The constraint variable representing the height of the
            main layout container.

        strength : casuarius strength, optional
            The strength with which to perform the layout using the
            current size of the container. i.e. the strength of the
            resize. The default is casuarius.medium.

        weight : float, optional
            The weight to apply to the strength. The default is 0.1
            so that constraints of medium strength but default weight
            have a higher precedence than the minimum size.

        Returns
        -------
        result : (float, float)
            The floating point (min_width, min_height) size of the
            container which would best satisfy the set of constraints.

        """
        if not self._initialized:
            raise RuntimeError('Get min size on uninitialized solver')
        values = [(width, 0.0), (height, 0.0)]
        with self._solver.suggest_values(values, strength, weight):
            min_width = width.value
            min_height = height.value
        return (min_width, min_height)

    def get_max_size(self, width, height, strength=medium, weight=0.1):
        """ Run an iteration of the solver with the suggested size of
        the component set to a very large value. This will cause the
        solver to effectively compute the maximum size that the window
        can be to solve the system. The return value is a tuple numbers.
        If one of the numbers is -1, it indicates there is no maximum in
        that direction.

        Parameters
        ----------
        width : Constraint Variable
            The constraint variable representing the width of the
            main layout container.

        height : Constraint Variable
            The constraint variable representing the height of the
            main layout container.

        strength : casuarius strength, optional
            The strength with which to perform the layout using the
            current size of the container. i.e. the strength of the
            resize. The default is casuarius.medium.

        weight : float, optional
            The weight to apply to the strength. The default is 0.1
            so that constraints of medium strength but default weight
            have a higher precedence than the minimum size.

        Returns
        -------
        result : (float or -1, float or -1)
            The floating point (max_width, max_height) size of the
            container which would best satisfy the set of constraints.

        """
        if not self._initialized:
            raise RuntimeError('Get max size on uninitialized solver')
        max_val = 2**24 - 1 # Arbitrary, but the max allowed by Qt.
        values = [(width, max_val), (height, max_val)]
        with self._solver.suggest_values(values, strength, weight):
            max_width = width.value
            max_height = height.value
        width_diff = abs(max_val - int(round(max_width)))
        height_diff = abs(max_val - int(round(max_height)))
        if width_diff <= 1:
            max_width = -1
        if height_diff <= 1:
            max_height = -1
        return (max_width, max_height)


########NEW FILE########
__FILENAME__ = editor_commands
"""
Editor commands so far:
  set-text
  set-mode
  set-theme

"""
#------------------------------------------------------------------------------
# Enaml -> Qt -> JS
#------------------------------------------------------------------------------

# Enaml sends a message like this to the client
enaml_msg = {
    'action' : 'set-text',
    'payload' : {
	'text' : 'hello world'
    }
}

# Qt client receives this message
def on_message_set_text(self, payload):
    self.set_text(payload['text'])

# Qt client's set_? method changes its values, then
# emits a signal which tells the JS editor to update
def set_text(self, text):
    self._text = text
    self.text_changed.emit(text)

# The JS client responds to the signal and updates the editor
"""
JavaScript code:

// Bind signal to JS handler. py_ace_editor is the Python object that was
// injected into the JS. ace_editor is the JS text editor object.
py_ace_editor.text_changed.connect(ace_editor.getSession().doc, "setValue")

"""

#------------------------------------------------------------------------------
# JS -> Qt
#------------------------------------------------------------------------------

# The JS client binds its events to handlers on the injected Python object
"""
JavaScript code:

// Bind a JS editor event to a Python handler. py_ace_editor is the Python
// object that was injected into the JS. ace_editor is the JS text editor
// object.
py_set_text = function() {
    py_ace_editor.set_text_from_js(ace_editor.getSession().getDocument().getValue())
}

ace_editor.getSession().on("change", py_set_text)

"""

# Python handler
def set_text_from_js(self, text):
    self._text = text

# NOTE: We cannot use set_text here, because if the signal were emitted the text
# would be set twice, so we have to have a method that sets the text but doesn't
# emit the signal.
# XXX: better way to do this so that we avoid having two methods for essentially
# the same operation?

########NEW FILE########
__FILENAME__ = generate_browser_safe
import sys
import os
import re

try:
    filename = sys.argv[1]
    if os.path.exists(filename):
        html = open(filename, 'r').read()
        html = re.sub(r'\$\{.*\}/?', '', html)
        open(filename.split('.')[0] + '_safe.html', 'w').write(html)
    else:
        print "File does not exist."
except:
    print "Please specify a file."

########NEW FILE########
__FILENAME__ = qt_ace_editor
from PySide.QtCore import QObject, Signal, Slot
from string import Template
import os

EVENT_TEMPLATE = Template("""
    py_${func} = function() {
        py_ace_editor.${func}(${args});
    }
    editor.${target}.on("${event_name}", py_${func});
""")

BINDING_TEMPLATE = Template("""
    py_ace_editor.${signal}.connect(${target}, "${func}")
""")


class QtAceEditor(QObject):
    text_changed = Signal(unicode)
    mode_changed = Signal(unicode)
    theme_changed = Signal(unicode)
    auto_pair_changed = Signal(bool)
    font_size_changed = Signal(int)
    margin_line_changed = Signal(bool)
    margin_line_column_changed = Signal(int)

    def __init__(self, parent=None):
        """ Initialize the editor

        """
        super(QtAceEditor, self).__init__(parent)
        self._events = []
        self._bindings = []

    def set_text(self, text):
        """ Set the text of the editor

        """
        self._text = text
        self.text_changed.emit(text)

    @Slot(unicode)
    def set_text_from_js(self, text):
        """ Set the text from the javascript editor. This method is required
        because set_text emits the signal to update the text again.

        """
        self._text = text

    def text(self):
        """ Return the text of the editor

        """
        return self._text

    def set_mode(self, mode):
        """ Set the mode of the editor

        """
        if mode.startswith('ace/mode/'):
            self._mode = mode
        else:
            self._mode = 'ace/mode/' + mode
        self.mode_changed.emit(self._mode)

    def mode(self):
        """ Return the mode of the editor

        """
        return self._mode

    def set_theme(self, theme):
        """ Set the theme of the editor

        """
        if theme.startswith('ace/theme/'):
            self._theme = theme
        else:
            self._theme = "ace/theme/" + theme
        self.theme_changed.emit(self._theme)

    def theme(self):
        """ Return the theme of the editor

        """
        return self._theme

    def set_auto_pair(self, auto_pair):
        """ Set the auto_pair behavior of the editor

        """
        self._auto_pair = auto_pair
        self.auto_pair_changed.emit(auto_pair)

    def set_font_size(self, font_size):
        """ Set the font size of the editor

        """
        self._font_size = font_size
        self.font_size_changed.emit(font_size)

    def show_margin_line(self, margin_line):
        """ Set the margin line of the editor

        """
        self._margin_line = margin_line
        self.margin_line_changed.emit(margin_line)

    def set_margin_line_column(self, margin_line_col):
        """ Set the margin line column of the editor

        """
        self._margin_line_column = margin_line_col
        self.margin_line_column_changed.emit(margin_line_col)

    def generate_ace_event(self, _func, _target, _args, _event_name):
        """ Generate a Javascript ace editor event handler.

        Parameters
        -----------
        _func : string
            The python method to be called on the python AceEditor object

        _args : string
            The javascript expression to pass to the method

        _target : string
            The Ace Editor target to tie the event to

        _event_name : string
            The name of the AceEditor event

        """
        event = EVENT_TEMPLATE.substitute(func=_func, args=_args,
                                          target=_target,
                                          event_name=_event_name)
        self._events.append(event)

    def generate_binding(self, _signal, _target, _func):
        """ Generate a connection between a Qt signal and a javascript function.
        Any parameters given to the signal will be passed to the javascript
        function.

        Parameters
        ----------
        _signal : string
             The name of the Qt signal

        _target : string
            The name of the target Javascript object

        _func : string
            The name of the function to call on the target object

        """
        binding = BINDING_TEMPLATE.substitute(signal=_signal, target=_target,
                                              func=_func)
        self._bindings.append(binding)

    def generate_html(self):
        """ Generate the html code for the ace editor

        """
        # XXX better way to access files here?
        p = os.path
        template_path = p.join(p.dirname(p.abspath(__file__)),
            'tab_ace_test.html')
        template = Template(open(template_path, 'r').read())
        _r_path = "file://" + p.join(p.dirname(p.abspath(__file__)))
        _events = '\n'.join(self._events)
        _bindings = '\n'.join(self._bindings)
        return template.substitute(events=_events, resource_path=_r_path,
                                   bindings=_bindings)

########NEW FILE########
__FILENAME__ = qt_ace_editor_view
from ..qt.QtWebKit import QWebView, QWebSettings
from qt_ace_editor import QtAceEditor


class QtAceEditorView(QWebView):
    def __init__(self, parent=None):
        """ Initialize the editor window

        """
        super(QtAceEditorView, self).__init__(parent)
        self.ace_editor = QtAceEditor()

        # XXX this is used for debugging, it should be taken out eventually
        self.settings().setAttribute(QWebSettings.DeveloperExtrasEnabled, True)

        self.main_frame = self.page().mainFrame()
        self.main_frame.addToJavaScriptWindowObject('py_ace_editor',
                                                    self.ace_editor)

        self.ace_editor.generate_ace_event('set_text_from_js', 'getSession()',
            'editor.getSession().getDocument().getValue()', 'change')

        self.ace_editor.generate_binding('theme_changed', 'editor',
             'setTheme')
        self.ace_editor.generate_binding('mode_changed',
             'editor.getSession()', 'setMode')
        self.ace_editor.generate_binding('text_changed',
             'editor.getSession().doc', 'setValue')
        self.ace_editor.generate_binding('auto_pair_changed', 'editor',
                                         'setBehavioursEnabled')
        self.ace_editor.generate_binding('font_size_changed', 'editor',
                                         'setFontSize')
        self.ace_editor.generate_binding('margin_line_changed', 'editor',
                                         'setShowPrintMargin')
        self.ace_editor.generate_binding('margin_line_column_changed',
                                         'editor', 'setPrintMarginColumn')

        html = self.ace_editor.generate_html()
        self.setHtml(html)

    def editor(self):
        """ Return the ace editor

        """
        return self.ace_editor

########NEW FILE########
__FILENAME__ = QtCore
#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from . import qt_api

if qt_api == 'pyqt':
    from PyQt4.QtCore import *
    from PyQt4.QtCore import pyqtProperty as Property
    from PyQt4.QtCore import pyqtSignal as Signal
    from PyQt4.QtCore import pyqtSlot as Slot
    from PyQt4.Qt import QCoreApplication
    from PyQt4.Qt import Qt
    __version__ = QT_VERSION_STR
    __version_info__ = tuple(map(int, QT_VERSION_STR.split('.')))
    # Remove the input hook or pdb.set_trace() will infinitely recurse
    pyqtRemoveInputHook()
else:
    from PySide import __version__, __version_info__
    from PySide.QtCore import *

########NEW FILE########
__FILENAME__ = QtGui
#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from . import qt_api

if qt_api == 'pyqt':
    from PyQt4.Qt import QKeySequence, QTextCursor
    from PyQt4.QtGui import *
    
else:
    from PySide.QtGui import *

########NEW FILE########
__FILENAME__ = QtNetwork
#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from . import qt_api

if qt_api == 'pyqt':
    from PyQt4.QtNetwork import *
    
else:
    from PySide.QtNetwork import *

########NEW FILE########
__FILENAME__ = QtOpenGL
#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from . import qt_api

if qt_api == 'pyqt':
    from PyQt4.QtOpenGL import *
    
else:
    from PySide.QtOpenGL import *

########NEW FILE########
__FILENAME__ = QtScript
#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from . import qt_api

if qt_api == 'pyqt':
    from PyQt4.QtScript import *
    
else:
    from PySide.QtScript import *

########NEW FILE########
__FILENAME__ = QtSvg
#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from . import qt_api

if qt_api == 'pyqt':
    from PyQt4.QtSvg import *
    
else:
    from PySide.QtSvg import *

########NEW FILE########
__FILENAME__ = QtTest
#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from . import qt_api

if qt_api == 'pyqt':
    from PyQt4.QtTest import *
    
else:
    from PySide.QtTest import *

########NEW FILE########
__FILENAME__ = QtWebKit
#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from . import qt_api

if qt_api == 'pyqt':
    from PyQt4.QtWebKit import *
    
else:
    from PySide.QtWebKit import *

########NEW FILE########
__FILENAME__ = qt_abstract_button
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
import logging

from .qt.QtCore import QSize
from .qt.QtGui import QIcon, QImage, QPixmap
from .qt_constraints_widget import size_hint_guard
from .qt_control import QtControl


logger = logging.getLogger(__name__)


class QtAbstractButton(QtControl):
    """ A Qt implementation of the Enaml AbstractButton class.

    This class can serve as a base class for widgets that implement
    button behavior such as CheckBox, RadioButton and PushButtons.
    It is not meant to be used directly.

    """
    #: Temporary internal storage for the icon source url.
    _icon_source = ''

    #--------------------------------------------------------------------------
    # Setup Methods
    #--------------------------------------------------------------------------
    def create_widget(self, parent, tree):
        """ This method must be implemented by subclasses to create
        the proper button widget.

        """
        raise NotImplementedError

    def create(self, tree):
        """ Create and initialize the abstract button widget.

        """
        super(QtAbstractButton, self).create(tree)
        self.set_checkable(tree['checkable'])
        self.set_checked(tree['checked'])
        self.set_text(tree['text'])
        self._icon_source = tree['icon_source']
        self.set_icon_size(tree['icon_size'])
        widget = self.widget()
        widget.clicked.connect(self.on_clicked)
        widget.toggled.connect(self.on_toggled)

    def activate(self):
        """ Activate the button widget.

        """
        self.set_icon_source(self._icon_source)
        super(QtAbstractButton, self).activate()

    #--------------------------------------------------------------------------
    # Signal Handlers
    #--------------------------------------------------------------------------
    def on_clicked(self):
        """ The signal handler for the 'clicked' signal.

        """
        content = {'checked': self.widget().isChecked()}
        self.send_action('clicked', content)

    def on_toggled(self):
        """ The signal handler for the 'toggled' signal.

        """
        content = {'checked': self.widget().isChecked()}
        self.send_action('toggled', content)

    #--------------------------------------------------------------------------
    # Message Handlers
    #--------------------------------------------------------------------------
    def on_action_set_checked(self, content):
        """ Handle the 'set_checked' action from the Enaml widget.

        """
        self.set_checked(content['checked'])

    def on_action_set_text(self, content):
        """ Handle the 'set_text' action from the Enaml widget.

        """
        with size_hint_guard(self):
            self.set_text(content['text'])

    def on_action_set_icon_source(self, content):
        """ Handle the 'set_icon_source' action from the Enaml widget.

        """
        self.set_icon_source(content['icon_source'])

    def on_action_set_icon_size(self, content):
        """ Handle the 'set_icon_size' action from the Enaml widget.

        """
        with size_hint_guard(self):
            self.set_icon_size(content['icon_size'])

    #--------------------------------------------------------------------------
    # Widget update methods
    #--------------------------------------------------------------------------
    def set_checkable(self, checkable):
        """ Sets whether or not the widget is checkable.

        """
        self.widget().setCheckable(checkable)

    def set_checked(self, checked):
        """ Sets the widget's checked state with the provided value.

        """
        widget = self.widget()
        # This handles the case where, by default, Qt will not allow
        # all of the radio buttons in a group to be disabled. By
        # temporarily turning off auto-exclusivity, we are able to
        # handle that case.
        if not checked and widget.isChecked() and widget.autoExclusive():
            widget.setAutoExclusive(False)
            widget.setChecked(checked)
            widget.setAutoExclusive(True)
        else:
            widget.setChecked(checked)

    def set_text(self, text):
        """ Sets the widget's text with the provided value.

        """
        self.widget().setText(text)

    def set_icon_source(self, icon_source):
        """ Sets the widget's icon to the provided image.

        """
        if icon_source:
            loader = self._session.load_resource(icon_source)
            loader.on_load(self._on_icon_load)
        else:
            self._on_icon_load(QIcon())

    def set_icon_size(self, icon_size):
        """ Sets the widget's icon size to the provided size.

        """
        self.widget().setIconSize(QSize(*icon_size))

    #--------------------------------------------------------------------------
    # Private API
    #--------------------------------------------------------------------------
    def _on_icon_load(self, icon):
        """ A private resource loader callback.

        This method is invoked when the requested icon is successfully
        loaded. It will update the icon on the button widget and issue
        a size hint updated event to the layout system if needed.

        Parameters
        ----------
        icon : QIcon or QImage
            The icon or image that was loaded by the request.

        """
        if isinstance(icon, QImage):
            icon = QIcon(QPixmap.fromImage(icon))
        elif not isinstance(icon, QIcon):
            msg = 'got incorrect type for icon: `%s`'
            logger.error(msg % type(icon).__name__)
            icon = QIcon()
        with size_hint_guard(self):
            self.widget().setIcon(icon)


########NEW FILE########
__FILENAME__ = qt_action
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
import logging

from .qt.QtGui import QAction, QKeySequence, QIcon, QImage, QPixmap
from .qt_object import QtObject


logger = logging.getLogger(__name__)


class QtAction(QtObject):
    """ A Qt implementation of an Enaml Action.

    """
    #: Temporary internal storage for the icon source url.
    _icon_source = ''

    # FIXME Currently, the checked state of the action is lost when
    # switching from checkable to non-checkable and back again.
    #--------------------------------------------------------------------------
    # Setup Methods
    #--------------------------------------------------------------------------
    def create_widget(self, parent, tree):
        """ Create the underlying QAction object.

        """
        return QAction(parent)

    def create(self, tree):
        """ Create and initialize the underlying control.

        """
        super(QtAction, self).create(tree)
        self.set_text(tree['text'])
        self.set_tool_tip(tree['tool_tip'])
        self.set_status_tip(tree['status_tip'])
        self._icon_source = tree['icon_source']
        self.set_checkable(tree['checkable'])
        self.set_checked(tree['checked'])
        self.set_enabled(tree['enabled'])
        self.set_visible(tree['visible'])
        self.set_separator(tree['separator'])
        widget = self.widget()
        widget.triggered.connect(self.on_triggered)
        widget.toggled.connect(self.on_toggled)

    def activate(self):
        """ Activate the action.

        """
        self.set_icon_source(self._icon_source)
        super(QtAction, self).activate()

    #--------------------------------------------------------------------------
    # Signal Handlers
    #--------------------------------------------------------------------------
    def on_triggered(self):
        """ The signal handler for the 'triggered' signal.

        """
        content = {'checked': self.widget().isChecked()}
        self.send_action('triggered', content)

    def on_toggled(self):
        """ The signal handler for the 'toggled' signal.

        """
        if 'checked' not in self.loopback_guard:
            content = {'checked': self.widget().isChecked()}
            self.send_action('toggled', content)

    #--------------------------------------------------------------------------
    # Message Handling
    #--------------------------------------------------------------------------
    def on_action_set_text(self, content):
        """ Handle the 'set_text' action from the Enaml widget.

        """
        self.set_text(content['text'])

    def on_action_set_tool_tip(self, content):
        """ Handle the 'set_tool_tip' action from the Enaml widget.

        """
        self.set_tool_tip(content['tool_tip'])

    def on_action_set_status_tip(self, content):
        """ Handle the 'set_status_tip' action from the Enaml widget.

        """
        self.set_status_tip(content['status_tip'])

    def on_action_set_icon_source(self, content):
        """ Handle the 'set_icon_source' action from the Enaml widget.

        """
        self.set_icon_source(content['icon_source'])

    def on_action_set_checkable(self, content):
        """ Handle the 'set_checkable' action from the Enaml widget.

        """
        self.set_checkable(content['checkable'])

    def on_action_set_checked(self, content):
        """ Handle the 'set_checked' action from the Enaml widget.

        """
        self.set_checked(content['checked'])

    def on_action_set_enabled(self, content):
        """ Handle the 'set_enabled' action from the Enaml widget.

        """
        self.set_enabled(content['enabled'])

    def on_action_set_visible(self, content):
        """ Handle the 'set_visible' action from the Enaml widget.

        """
        self.set_visible(content['visible'])

    def on_action_set_separator(self, content):
        """ Handle the 'set_separator' action from the Enaml widget.

        """
        self.set_separator(content['separator'])

    #--------------------------------------------------------------------------
    # Widget Update Methods
    #--------------------------------------------------------------------------
    def set_text(self, text):
        """ Set the text on the underlying control.

        """
        widget = self.widget()
        widget.setText(text)
        parts = text.split('\t')
        if len(parts) > 1:
            shortcut = QKeySequence(parts[-1])
            widget.setShortcut(shortcut)

    def set_tool_tip(self, tool_tip):
        """ Set the tool tip on the underlying control.

        """
        self.widget().setToolTip(tool_tip)

    def set_status_tip(self, status_tip):
        """ Set the status tip on the underyling control.

        """
        self.widget().setStatusTip(status_tip)

    def set_icon_source(self, icon_source):
        """ Set the icon source for the action.

        """
        if icon_source:
            loader = self._session.load_resource(icon_source)
            loader.on_load(self._on_icon_load)
        else:
            self._on_icon_load(QIcon())

    def set_checkable(self, checkable):
        """ Set the checkable state on the underlying control.

        """
        self.widget().setCheckable(checkable)

    def set_checked(self, checked):
        """ Set the checked state on the underlying control.

        """
        with self.loopback_guard('checked'):
            self.widget().setChecked(checked)

    def set_enabled(self, enabled):
        """ Set the enabled state on the underlying control.

        """
        self.widget().setEnabled(enabled)

    def set_visible(self, visible):
        """ Set the visible state on the underlying control.

        """
        self.widget().setVisible(visible)

    def set_separator(self, separator):
        """ Set the separator state on the underlying control.

        """
        self.widget().setSeparator(separator)

    #--------------------------------------------------------------------------
    # Private API
    #--------------------------------------------------------------------------
    def _on_icon_load(self, icon):
        """ A private resource loader callback.

        This method is invoked when the requested icon is successfully
        loaded. It will update the icon on the action.

        Parameters
        ----------
        icon : QIcon or QImage
            The icon or image that was loaded by the request.

        """
        if isinstance(icon, QImage):
            icon = QIcon(QPixmap.fromImage(icon))
        elif not isinstance(icon, QIcon):
            msg = 'got incorrect type for icon: `%s`'
            logger.error(msg % type(icon).__name__)
            icon = QIcon()
        self.widget().setIcon(icon)


########NEW FILE########
__FILENAME__ = qt_action_group
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from .qt.QtGui import QActionGroup
from .qt_action import QtAction
from .qt_object import QtObject


class QCustomActionGroup(QActionGroup):
    """ A QActionGroup subclass which fixes some toggling issues.

    When a QActionGroup is set from non-exlusive to exclusive, it
    doesn't uncheck the non-current actions. It also does not keep
    track of the most recently checked widget when in non-exclusive
    mode, so that state is lost. This subclass corrects these issues.

    """
    def __init__(self, *args, **kwargs):
        """ Initialize a QCustomActionGroup.

        Parameters
        ----------
        *args, **kwargs
            The positional and keyword arguments needed to initialize
            a QActionGroup.

        """
        super(QCustomActionGroup, self).__init__(*args, **kwargs)
        self.triggered.connect(self.onTriggered)
        self._last_checked = None

    def onTriggered(self, action):
        """ The signal handler for the 'triggered' signal.

        """
        if action.isCheckable() and action.isChecked():
            if self.isExclusive():
                last = self._last_checked
                if last is not None and last is not action:
                    last.setChecked(False)
            self._last_checked = action

    def setExclusive(self, exclusive):
        """ Set the exclusive state of the action group.

        Parameters
        ----------
        exclusive : bool
            Whether or not the action group is exclusive.

        """
        super(QCustomActionGroup, self).setExclusive(exclusive)
        if exclusive:
            last = self._last_checked
            if last is not None:
                last.setChecked(True)
                for action in self.actions():
                    if action is not last:
                        action.setChecked(False)


class QtActionGroup(QtObject):
    """ A Qt implementation of an Enaml ActionGroup.

    """
    #--------------------------------------------------------------------------
    # Setup Methods
    #--------------------------------------------------------------------------
    def create_widget(self, parent, tree):
        """ Create the underlying action group widget.

        """
        return QCustomActionGroup(parent)

    def create(self, tree):
        """ Create and initialize the underlying control.

        """
        super(QtActionGroup, self).create(tree)
        self.set_exclusive(tree['exclusive'])
        self.set_enabled(tree['enabled'])
        self.set_visible(tree['visible'])

    def init_layout(self):
        """ Initialize the layout for the underlying control.

        """
        super(QtActionGroup, self).init_layout()
        widget = self.widget()
        for child in self.children():
            if isinstance(child, QtAction):
                widget.addAction(child.widget())

    #--------------------------------------------------------------------------
    # Child Events
    #--------------------------------------------------------------------------
    def child_removed(self, child):
        """ Handle the child removed event for a QtActionGroup.

        """
        if isinstance(child, QtAction):
            action = child.widget()
            self.widget().removeAction(action)
            parent = self.parent()
            if parent is not None:
                parent.widget().removeAction(action)

    def child_added(self, child):
        """ Handle the child added event for a QtActionGroup.

        """
        # The easiest way to handle the insert is to tell the parent to
        # insert all the current actions. It will work out the proper
        # ordering automatically.
        if isinstance(child, QtAction):
            self.widget().addAction(child.widget())
            parent = self.parent()
            if parent is not None:
                before = parent.find_next_action(self)
                parent.widget().insertActions(before, self.actions())

    #--------------------------------------------------------------------------
    # Utility Methods
    #--------------------------------------------------------------------------
    def actions(self):
        """ Get the QAction children for this action group.

        Returns
        -------
        result : list
            The list of QAction instances which are children of this
            action group. Unlike the list returned by the `actions`
            method of the QActionGroup, the children in this list will
            have the correct order.

        """
        isinst = isinstance
        return [c.widget() for c in self.children() if isinst(c, QtAction)]

    #--------------------------------------------------------------------------
    # Message Handling
    #--------------------------------------------------------------------------
    def on_action_set_exclusive(self, content):
        """ Handle the 'set_exclusive' action from the Enaml widget.

        """
        self.set_exclusive(content['exclusive'])

    def on_action_set_enabled(self, content):
        """ Handle the 'set_enabled' action from the Enaml widget.

        """
        self.set_enabled(content['enabled'])

    def on_action_set_visible(self, content):
        """ Handle the 'set_visible' action from the Enaml widget.

        """
        self.set_visible(content['visible'])

    #--------------------------------------------------------------------------
    # Widget Update Methods
    #--------------------------------------------------------------------------
    def set_exclusive(self, exclusive):
        """ Set the exclusive state of the underlying control.

        """
        self.widget().setExclusive(exclusive)

    def set_enabled(self, enabled):
        """ Set the enabled state of the underlying control.

        """
        self.widget().setEnabled(enabled)

    def set_visible(self, visible):
        """ Set the visible state of the underlying control.

        """
        self.widget().setVisible(visible)


########NEW FILE########
__FILENAME__ = qt_application
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
import logging
import uuid

from enaml.application import Application

from .qt.QtCore import Qt, QThread
from .qt.QtGui import QApplication
from .q_action_socket import QActionSocket
from .q_deferred_caller import deferredCall, timedCall
from .qt_session import QtSession
from .qt_factories import register_default


logger = logging.getLogger(__name__)


# This registers the default Qt factories with the QtWidgetRegistry and
# allows an application access to the default widget implementations.
register_default()


class QtApplication(Application):
    """ A Qt implementation of an Enaml application.

    A QtApplication uses the Qt toolkit to implement an Enaml UI that
    runs in the local process.

    """
    def __init__(self, factories):
        """ Initialize a QtApplication.

        Parameters
        ----------
        factories : iterable
            An iterable of SessionFactory instances to pass to the
            superclass constructor.

        """
        super(QtApplication, self).__init__(factories)
        self._qapp = QApplication.instance() or QApplication([])
        self._qt_sessions = {}
        self._sessions = {}

    #--------------------------------------------------------------------------
    # Abstract API Implementation
    #--------------------------------------------------------------------------
    def start_session(self, name):
        """ Start a new session of the given name.

        This method will create a new session object for the requested
        session type and return the new session_id. If the session name
        is invalid, an exception will be raised.

        Parameters
        ----------
        name : str
            The name of the session to start.

        Returns
        -------
        result : str
            The unique identifier for the created session.

        """
        if name not in self._named_factories:
            raise ValueError('Invalid session name')

        # Create and open a new server-side session.
        factory = self._named_factories[name]
        session = factory()
        session_id = uuid.uuid4().hex
        session.open(session_id)
        self._sessions[session_id] = session

        # Create and open a new client-side session.
        groups = session.widget_groups[:]
        qt_session = QtSession(session_id, groups)
        self._qt_sessions[session_id] = qt_session
        qt_session.open(session.snapshot())

        # Setup the sockets for the session pair
        server_socket = QActionSocket()
        client_socket = QActionSocket()
        conn = Qt.QueuedConnection
        server_socket.messagePosted.connect(client_socket.receive, conn)
        client_socket.messagePosted.connect(server_socket.receive, conn)

        # Activate the server and client sessions. The server session
        # is activated first so that it is ready to receive messages
        # sent by the client during activation. These messages will
        # typically be requests for resources.
        session.activate(server_socket)
        qt_session.activate(client_socket)

        return session_id

    def end_session(self, session_id):
        """ End the session with the given session id.

        This method will close down the existing session. If the session
        id is not valid, an exception will be raised.

        Parameters
        ----------
        session_id : str
            The unique identifier for the session to close.

        """
        if session_id not in self._sessions:
            raise ValueError('Invalid session id')
        self._sessions.pop(session_id).close()
        del self._qt_sessions[session_id]

    def session(self, session_id):
        """ Get the session for the given session id.

        Parameters
        ----------
        session_id : str
            The unique identifier for the session to retrieve.

        Returns
        -------
        result : Session or None
            The session object with the given id, or None if the id
            does not correspond to an active session.

        """
        return self._sessions.get(session_id)

    def sessions(self):
        """ Get the currently active sessions for the application.

        Returns
        -------
        result : list
            The list of currently active sessions for the application.

        """
        return self._sessions.values()

    def start(self):
        """ Start the application's main event loop.

        """
        app = self._qapp
        if not getattr(app, '_in_event_loop', False):
            app._in_event_loop = True
            app.exec_()
            app._in_event_loop = False

    def stop(self):
        """ Stop the application's main event loop.

        """
        app = self._qapp
        app.exit()
        app._in_event_loop = False

    def deferred_call(self, callback, *args, **kwargs):
        """ Invoke a callable on the next cycle of the main event loop
        thread.

        Parameters
        ----------
        callback : callable
            The callable object to execute at some point in the future.

        *args, **kwargs
            Any additional positional and keyword arguments to pass to
            the callback.

        """
        deferredCall(callback, *args, **kwargs)

    def timed_call(self, ms, callback, *args, **kwargs):
        """ Invoke a callable on the main event loop thread at a
        specified time in the future.

        Parameters
        ----------
        ms : int
            The time to delay, in milliseconds, before executing the
            callable.

        callback : callable
            The callable object to execute at some point in the future.

        *args, **kwargs
            Any additional positional and keyword arguments to pass to
            the callback.

        """
        timedCall(ms, callback, *args, **kwargs)

    def is_main_thread(self):
        """ Indicates whether the caller is on the main gui thread.

        Returns
        -------
        result : bool
            True if called from the main gui thread. False otherwise.

        """
        return QThread.currentThread() == self._qapp.thread()


########NEW FILE########
__FILENAME__ = qt_bounded_date
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from .qt.QtCore import Qt, QDate
from .qt_control import QtControl


def as_qdate(iso_date):
    """ Convert an iso date string to a QDate

    """
    return QDate.fromString(iso_date, Qt.ISODate)


def as_iso_date(qdate):
    """ Convert a QDate object into and iso date string.

    """
    return qdate.toString(Qt.ISODate)


class QtBoundedDate(QtControl):
    """ A base class for implementing Qt-Enaml date widgets.

    """
    #--------------------------------------------------------------------------
    # Setup Methods
    #--------------------------------------------------------------------------
    def create(self, tree):
        """ Create and initialize the underyling date widget.

        """
        super(QtBoundedDate, self).create(tree)
        self.set_min_date(as_qdate(tree['minimum']))
        self.set_max_date(as_qdate(tree['maximum']))
        self.set_date(as_qdate(tree['date']))

    #--------------------------------------------------------------------------
    # Message Handlers
    #--------------------------------------------------------------------------
    def on_action_set_date(self, content):
        """ Handle the 'set_date' action from the Enaml widget.

        """
        self.set_date(as_qdate(content['date']))

    def on_action_set_minimum(self, content):
        """ Handle the 'set_minimum' action from the Enaml widget.

        """
        self.set_min_date(as_qdate(content['minimum']))

    def on_action_set_maximum(self, content):
        """ Handle the 'set_maximum' action from the Enaml widget.

        """
        self.set_max_date(as_qdate(content['maximum']))

    #--------------------------------------------------------------------------
    # Signal Handlers
    #--------------------------------------------------------------------------
    def on_date_changed(self):
        """ A signal handler to connect to the date changed signal of
        the underlying widget.

        This will convert the QDate to iso format and send the Enaml
        widget the 'date_changed' action.

        """
        if 'date' not in self.loopback_guard:
            qdate = self.get_date()
            content = {'date': as_iso_date(qdate)}
            self.send_action('date_changed', content)

    #--------------------------------------------------------------------------
    # Abstract Methods
    #--------------------------------------------------------------------------
    def get_date(self):
        """ Return the current date in the control.

        Returns
        -------
        result : QDate
            The current control date as a QDate object.

        """
        raise NotImplementedError

    def set_date(self, date):
        """ Set the widget's current date.

        Implementations should enter the loopback guard using the key
        'date' before setting the date.

        Parameters
        ----------
        date : QDate
            The QDate object to use for setting the date.

        """
        raise NotImplementedError

    def set_max_date(self, date):
        """ Set the widget's maximum date.

        Parameters
        ----------
        date : QDate
            The QDate object to use for setting the maximum date.

        """
        raise NotImplementedError

    def set_min_date(self, date):
        """ Set the widget's minimum date.

        Parameters
        ----------
        date : QDate
            The QDate object to use for setting the minimum date.

        """
        raise NotImplementedError


########NEW FILE########
__FILENAME__ = qt_bounded_datetime
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from .qt.QtCore import Qt, QDateTime
from .qt_control import QtControl


def as_qdatetime(iso_datetime):
    """ Convert an iso datetime string to a QDateTime.

    """
    return QDateTime.fromString(iso_datetime, Qt.ISODate)


def as_iso_datetime(qdatetime):
    """ Convert a QDateTime object into an iso datetime string.

    """
    return qdatetime.toString(Qt.ISODate)


class QtBoundedDatetime(QtControl):
    """ A base class for implementing Qt-Enaml datetime widgets.

    """
    #--------------------------------------------------------------------------
    # Setup Methods
    #--------------------------------------------------------------------------
    def create(self, create):
        """ Create and initialize the underlying datetime widget.

        """
        super(QtBoundedDatetime, self).create(create)
        self.set_min_datetime(as_qdatetime(create['minimum']))
        self.set_max_datetime(as_qdatetime(create['maximum']))
        self.set_datetime(as_qdatetime(create['datetime']))

    #--------------------------------------------------------------------------
    # Message Handlers
    #--------------------------------------------------------------------------
    def on_action_set_datetime(self, content):
        """ Handle the 'set_datetime' action from the Enaml widget.

        """
        self.set_datetime(as_qdatetime(content['datetime']))

    def on_action_set_minimum(self, content):
        """ Handle the 'set_minimum' action from the Enaml widget.

        """
        self.set_min_datetime(as_qdatetime(content['minimum']))

    def on_action_set_maximum(self, content):
        """ Handle the 'set_maximum' action from the Enaml widget.

        """
        self.set_max_datetime(as_qdatetime(content['maximum']))

    #--------------------------------------------------------------------------
    # Signal Handlers
    #--------------------------------------------------------------------------
    def on_datetime_changed(self):
        """ A signal handler to connect to the datetime changed signal
        of the underlying widget.

        This will convert the QDateTime to iso format and send the Enaml
        widget the 'event-changed' action.

        """
        if 'datetime' not in self.loopback_guard:
            qdatetime = self.get_datetime()
            content = {'datetime': as_iso_datetime(qdatetime)}
            self.send_action('datetime_changed', content)

    #--------------------------------------------------------------------------
    # Widget Update Methods
    #--------------------------------------------------------------------------
    def get_datetime(self):
        """ Return the current datetime in the control.

        Returns
        -------
        result : QDateTime
            The current control datetime as a QDateTime object.

        """
        raise NotImplementedError

    def set_datetime(self, datetime):
        """ Set the widget's current datetime.

        Implementations should enter the loopback guard using the key
        'datetime' before setting the datetime.

        Parameters
        ----------
        datetime : QDateTime
            The QDateTime object to use for setting the datetime.

        """
        raise NotImplementedError

    def set_max_datetime(self, datetime):
        """ Set the widget's maximum datetime.

        Parameters
        ----------
        datetime : QDateTime
            The QDateTime object to use for setting the maximum datetime.

        """
        raise NotImplementedError

    def set_min_datetime(self, datetime):
        """ Set the widget's minimum datetime.

        Parameters
        ----------
        datetime : QDateTime
            The QDateTime object to use for setting the minimum datetime.

        """
        raise NotImplementedError


########NEW FILE########
__FILENAME__ = qt_bounded_time
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from .qt.QtCore import Qt, QTime
from .qt_control import QtControl


def as_qtime(iso_time):
    """ Convert an iso time string to a QTime.

    """
    return QTime.fromString(iso_time, Qt.ISODate)


def as_iso_time(qtime):
    """ Convert a QTime object into and iso time string.

    """
    return qtime.toString(Qt.ISODate)


class QtBoundedTime(QtControl):
    """ A base class for implementing Qt-Enaml time widgets.

    """
    #--------------------------------------------------------------------------
    # Setup Methods
    #--------------------------------------------------------------------------
    def create(self, tree):
        """ Create and initialize the underyling time widget.

        """
        super(QtBoundedTime, self).create(tree)
        self.set_min_time(as_qtime(tree['minimum']))
        self.set_max_time(as_qtime(tree['maximum']))
        self.set_time(as_qtime(tree['time']))

    #--------------------------------------------------------------------------
    # Message Handlers
    #--------------------------------------------------------------------------
    def on_action_set_time(self, content):
        """ Handle the 'set_time' action from the Enaml widget.

        """
        self.set_time(as_qtime(content['time']))

    def on_action_set_minimum(self, content):
        """ Handle the 'set_minimum' action from the Enaml widget.

        """
        self.set_min_time(as_qtime(content['minimum']))

    def on_action_set_maximum(self, content):
        """ Handle the 'set_maximum' action from the Enaml widget.

        """
        self.set_max_time(as_qtime(content['maximum']))

    #--------------------------------------------------------------------------
    # Signal Handlers
    #--------------------------------------------------------------------------
    def on_time_changed(self):
        """ A signal handler to connect to the time changed signal of
        the underlying widget.

        This will convert the QTime to iso format and send the Enaml
        widget the 'time_changed' action.

        """
        if 'time' not in self.loopback_guard:
            qtime = self.get_time()
            content = {'time': as_iso_time(qtime)}
            self.send_action('time_changed', content)

    #--------------------------------------------------------------------------
    # Abstract Methods
    #--------------------------------------------------------------------------
    def get_time(self):
        """ Return the current time in the control.

        Returns
        -------
        result : QTime
            The current control time as a QTime object.

        """
        raise NotImplementedError

    def set_time(self, time):
        """ Set the widget's current time.

        Implementations should enter the loopback guard using the key
        'time' before setting the time.

        Parameters
        ----------
        time : QTime
            The QTime object to use for setting the time.

        """
        raise NotImplementedError

    def set_max_time(self, time):
        """ Set the widget's maximum time.

        Parameters
        ----------
        time : QTime
            The QTime object to use for setting the maximum time.

        """
        raise NotImplementedError

    def set_min_time(self, time):
        """ Set the widget's minimum time.

        Parameters
        ----------
        time : QTime
            The QTime object to use for setting the minimum time.

        """
        raise NotImplementedError


########NEW FILE########
__FILENAME__ = qt_calendar
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from .qt.QtGui import QCalendarWidget
from .qt_bounded_date import QtBoundedDate


class QtCalendar(QtBoundedDate):
    """ A Qt implementation of an Enaml Calendar.

    """
    #--------------------------------------------------------------------------
    # Setup Methods
    #--------------------------------------------------------------------------
    def create_widget(self, parent, tree):
        """ Create the underlying calender widget.

        """
        return QCalendarWidget(parent)

    def create(self, tree):
        """ Create and initialize the underlying widget.

        """
        super(QtCalendar, self).create(tree)
        self.widget().activated.connect(self.on_date_changed)

    #--------------------------------------------------------------------------
    # Abstract Method Implementations
    #--------------------------------------------------------------------------
    def get_date(self):
        """ Return the current date in the control.

        Returns
        -------
        result : QDate
            The current control date as a QDate object.

        """
        return self.widget().selectedDate()

    def set_date(self, date):
        """ Set the widget's current date.

        Parameters
        ----------
        date : QDate
            The QDate object to use for setting the date.

        """
        with self.loopback_guard('date'):
            self.widget().setSelectedDate(date)

    def set_max_date(self, date):
        """ Set the widget's maximum date.

        Parameters
        ----------
        date : QDate
            The QDate object to use for setting the maximum date.

        """
        self.widget().setMaximumDate(date)

    def set_min_date(self, date):
        """ Set the widget's minimum date.

        Parameters
        ----------
        date : QDate
            The QDate object to use for setting the minimum date.

        """
        self.widget().setMinimumDate(date)


########NEW FILE########
__FILENAME__ = qt_check_box
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from .qt.QtGui import QCheckBox
from .qt_abstract_button import QtAbstractButton


class QtCheckBox(QtAbstractButton):
    """ A Qt implementation of an Enaml CheckBox.

    """
    def create_widget(self, parent, tree):
        """ Create the underlying check box widget.

        """
        return QCheckBox(parent)


########NEW FILE########
__FILENAME__ = qt_combo_box
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from .qt.QtGui import QComboBox
from .qt_control import QtControl


class QtComboBox(QtControl):
    """ A Qt implementation of an Enaml ComboBox.

    """
    #--------------------------------------------------------------------------
    # Setup Methods
    #--------------------------------------------------------------------------
    def create_widget(self, parent, tree):
        """ Create the underlying combo box widget.

        """
        box = QComboBox(parent)
        box.setInsertPolicy(QComboBox.NoInsert)
        return box

    def create(self, tree):
        """ Create and initialize the underlying widget.

        """
        super(QtComboBox, self).create(tree)
        self.set_items(tree['items'])
        self.set_index(tree['index'])
        self.set_editable(tree['editable'])
        self.widget().currentIndexChanged.connect(self.on_index_changed)

    #--------------------------------------------------------------------------
    # Message Handlers
    #--------------------------------------------------------------------------
    def on_action_set_index(self, content):
        """ Handle the 'set_index' action from the Enaml widget.

        """
        self.set_index(content['index'])

    def on_action_set_items(self, content):
        """ Handle the 'set_items' action from the Enaml widget.

        """
        self.set_items(content['items'])

    def on_action_set_editable(self, content):
        """ Handle the 'set_editable' action from the Enaml widget.

        """
        self.set_editable(content['editable'])
        # The update is needed to avoid artificats (at least on Windows)
        self.widget().update()

    #--------------------------------------------------------------------------
    # Signal Handlers
    #--------------------------------------------------------------------------
    def on_index_changed(self):
        """ The signal handler for the index changed signal.

        """
        if 'index' not in self.loopback_guard:
            content = {'index': self.widget().currentIndex()}
            self.send_action('index_changed', content)

    #--------------------------------------------------------------------------
    # Widget Update Methods
    #--------------------------------------------------------------------------
    def set_items(self, items):
        """ Set the items of the ComboBox.

        """
        widget = self.widget()
        count = widget.count()
        nitems = len(items)
        for idx, item in enumerate(items[:count]):
            widget.setItemText(idx, item)
        if nitems > count:
            for item in items[count:]:
                widget.addItem(item)
        elif nitems < count:
            for idx in reversed(range(nitems, count)):
                widget.removeItem(idx)

    def set_index(self, index):
        """ Set the current index of the ComboBox.

        """
        with self.loopback_guard('index'):
            self.widget().setCurrentIndex(index)

    def set_editable(self, editable):
        """ Set whether the combo box is editable.

        """
        self.widget().setEditable(editable)


########NEW FILE########
__FILENAME__ = qt_constraints_widget
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from contextlib import contextmanager

from casuarius import ConstraintVariable

from .qt.QtCore import QRect
from .qt_widget import QtWidget


@contextmanager
def size_hint_guard(obj):
    """ A contenxt manager which will call `size_hint_updated` if the
    size hint changes during context execution.

    Parameters
    ----------
    obj : QtConstraintsWidget
        The constraints widget withe size hint of interest.

    """
    old_hint = obj.widget_item().sizeHint()
    yield
    new_hint = obj.widget_item().sizeHint()
    if old_hint != new_hint:
        obj.size_hint_updated()


class LayoutBox(object):
    """ A class which encapsulates a layout box using casuarius
    constraint variables.

    The constraint variables are created on an as-needed basis, this
    allows Enaml widgets to define new constraints and build layouts
    with them, without having to specifically update this client code.

    """
    def __init__(self, name, owner):
        """ Initialize a LayoutBox.

        Parameters
        ----------
        name : str
            A name to use in the label for the constraint variables in
            this layout box.

        owner : str
            The owner id to use in the label for the constraint variables
            in this layout box.

        """
        self._name = name
        self._owner = owner
        self._primitives = {}

    def primitive(self, name):
        """ Returns a primitive casuarius constraint variable for the
        given name.

        Parameters
        ----------
        name : str
            The name of the constraint variable to return.

        """
        primitives = self._primitives
        if name in primitives:
            res = primitives[name]
        else:
            label = '{0}|{1}|{2}'.format(self._name, self._owner, name)
            res = primitives[name] = ConstraintVariable(label)
        return res


class QtConstraintsWidget(QtWidget):
    """ A Qt implementation of an Enaml ConstraintsWidget.

    """
    #: The hug strengths for the widget's size hint.
    _hug = ('strong', 'strong')

    #: The resist strengths for the widget's size hint.
    _resist = ('strong', 'strong')

    #: The list of hard constraints which must be applied to the widget.
    #: These constraints are computed lazily and only once since they
    #: are assumed to never change.
    _hard_cns = []

    #: The list of size hint constraints to apply to the widget. These
    #: constraints are computed once and then cached. If the size hint
    #: of a widget changes at run time, then `size_hint_updated` should
    #: be called to trigger an appropriate relayout of the widget.
    _size_hint_cns = []

    #: The list of constraint dictionaries defined by the user on
    #: the server side Enaml widget.
    _user_cns = []

    #--------------------------------------------------------------------------
    # Setup Methods
    #--------------------------------------------------------------------------
    def create(self, tree):
        """ Create and initialize the underlyling widget.

        """
        super(QtConstraintsWidget, self).create(tree)
        layout = tree['layout']
        self.layout_box = LayoutBox(type(self).__name__, self.object_id())
        self._hug = layout['hug']
        self._resist = layout['resist']
        self._user_cns = layout['constraints']

    #--------------------------------------------------------------------------
    # Message Handlers
    #--------------------------------------------------------------------------
    def on_action_relayout(self, content):
        """ Handle the 'relayout' action from the Enaml widget.

        """
        # XXX The QtContainer needs to get in on the action to grab the
        # share_layout flag.
        self._hug = content['hug']
        self._resist = content['resist']
        self._user_cns = content['constraints']
        self.clear_size_hint_constraints()
        self.relayout()

    #--------------------------------------------------------------------------
    # Layout Handling
    #--------------------------------------------------------------------------
    def relayout(self):
        """ Peform a relayout for this constraints widget.

        The default behavior of this method is to proxy the call up the
        tree of ancestors until it is either handled by a subclass which
        has reimplemented this method (see QtContainer), or the ancestor
        is not an instance of QtConstraintsWidget, at which point the
        layout request is dropped.

        """
        parent = self.parent()
        if isinstance(parent, QtConstraintsWidget):
            parent.relayout()

    def replace_constraints(self, old_cns, new_cns):
        """ Replace constraints in the current layout system.

        The default behavior of this method is to proxy the call up the
        tree of ancestors until it is either handled by a subclass which
        has reimplemented this method (see QtContainer), or the ancestor
        is not an instance of QtConstraintsWidget, at which point the
        request is dropped.

        Parameters
        ----------
        old_cns : list
            The list of casuarius constraints to remove from the
            current layout system.

        new_cns : list
            The list of casuarius constraints to add to the
            current layout system.

        """
        parent = self.parent()
        if isinstance(parent, QtConstraintsWidget):
            parent.replace_constraints(old_cns, new_cns)

    def clear_constraints(self, cns):
        """ Clear the given constraints from the current layout system.

        The default behavior of this method is to proxy the call up the
        tree of ancestors until it is either handled by a subclass which
        has reimplemented this method (see QtContainer), or the ancestor
        is not an instance of QtConstraintsWidget, at which point the
        request is dropped. This method will *not* trigger a relayout.

        Parameters
        ----------
        cns : list
            The list of casuarius constraints to remove from the
            current layout system.

        """
        parent = self.parent()
        if isinstance(parent, QtConstraintsWidget):
            parent.clear_constraints(cns)

    def size_hint_constraints(self):
        """ Creates the list of size hint constraints for this widget.

        This method uses the provided size hint of the widget and the
        policies for 'hug' and 'resist' to generate constraints which
        respect the size hinting of the widget.

        If the size hint of the underlying widget is not valid, then
        no constraints will be generated.

        Returns
        -------
        result : list
            A list of casuarius LinearConstraint instances.

        """
        cns = self._size_hint_cns
        if not cns:
            cns = self._size_hint_cns = []
            push = cns.append
            hint = self.widget_item().sizeHint()
            if hint.isValid():
                width_hint = hint.width()
                height_hint = hint.height()
                primitive = self.layout_box.primitive
                width = primitive('width')
                height = primitive('height')
                hug_width, hug_height = self._hug
                resist_width, resist_height = self._resist
                if width_hint >= 0:
                    if hug_width != 'ignore':
                        cn = (width == width_hint) | hug_width
                        push(cn)
                    if resist_width != 'ignore':
                        cn = (width >= width_hint) | resist_width
                        push(cn)
                if height_hint >= 0:
                    if hug_height != 'ignore':
                        cn = (height == height_hint) | hug_height
                        push(cn)
                    if resist_height != 'ignore':
                        cn = (height >= height_hint) | resist_height
                        push(cn)
        return cns

    def size_hint_updated(self):
        """ Notify the layout system that the size hint of this widget
        has been updated.

        """
        # Only the ancestors of a widget care about its size hint,
        # so this method attempts to replace the size hint constraints
        # for the widget starting with its parent.
        parent = self.parent()
        if isinstance(parent, QtConstraintsWidget):
            old_cns = self._size_hint_cns
            self._size_hint_cns = []
            new_cns = self.size_hint_constraints()
            parent.replace_constraints(old_cns, new_cns)

    def clear_size_hint_constraints(self):
        """ Clear the size hint constraints from the layout system.

        """
        # Only the ancestors of a widget care about its size hint,
        # so this method attempts to replace the size hint constraints
        # for the widget starting with its parent.
        parent = self.parent()
        if isinstance(parent, QtConstraintsWidget):
            cns = self._size_hint_cns
            self._size_hint_cns = []
            parent.clear_constraints(cns)

    def hard_constraints(self):
        """ Generate the constraints which must always be applied.

        These constraints are generated once the first time this method
        is called. The results are then cached and returned immediately
        on future calls.

        Returns
        -------
        result : list
            A list of casuarius LinearConstraint instance.

        """
        cns = self._hard_cns
        if not cns:
            primitive = self.layout_box.primitive
            left = primitive('left')
            top = primitive('top')
            width = primitive('width')
            height = primitive('height')
            cns = [left >= 0, top >= 0, width >= 0, height >= 0]
            self._hard_cns = cns
        return cns

    def user_constraints(self):
        """ Get the list of user constraints defined for this widget.

        The default implementation returns the list of constraint
        information sent by the server.

        Returns
        -------
        result : list
            The list of dictionaries which represent the user defined
            linear constraints.

        """
        return self._user_cns

    def geometry_updater(self):
        """ A method which can be called to create a function which
        will update the layout geometry of the underlying widget.

        The parameter and return values below describe the function
        that is returned by calling this method.

        Parameters
        ----------
        dx : float
            The offset of the parent widget from the computed origin
            of the layout. This amount is subtracted from the computed
            layout 'x' amount, which is expressed in the coordinates
            of the owner widget.

        dy : float
            The offset of the parent widget from the computed origin
            of the layout. This amount is subtracted from the computed
            layout 'y' amount, which is expressed in the coordinates
            of the layout owner widget.

        Returns
        -------
        result : (x, y)
            The computed layout 'x' and 'y' amount, expressed in the
            coordinates of the layout owner widget.

        """
        # The return function is a hyper optimized (for Python) closure
        # that will be called on every resize to update the geometry of
        # the widget. According to cProfile, executing the body of this
        # closure is 2x faster than the call to QWidgetItem.setGeometry.
        # The previous version of this method, `update_layout_geometry`,
        # was 5x slower. This is explicitly not idiomatic Python code.
        # It exists purely for the sake of efficiency, justified with
        # profiling.
        primitive = self.layout_box.primitive
        x = primitive('left')
        y = primitive('top')
        width = primitive('width')
        height = primitive('height')
        setgeo = self.widget_item().setGeometry
        rect = QRect
        def update_geometry(dx, dy):
            nx = x.value
            ny = y.value
            setgeo(rect(nx - dx, ny - dy, width.value, height.value))
            return nx, ny
        # Store a reference to self on the updater, so that the layout
        # container can know the object on which the updater operates.
        update_geometry.item = self
        return update_geometry


########NEW FILE########
__FILENAME__ = qt_container
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from collections import deque

from casuarius import weak
from enaml.layout.layout_manager import LayoutManager

from .qt.QtCore import QSize, Signal
from .qt.QtGui import QFrame
from .qt_constraints_widget import (
    QtConstraintsWidget, LayoutBox, size_hint_guard,
)


def _convert_cn_info(info, owners):
    """ Converts the lhs or rhs of a linear constraint info dict into
    its corresponding casuarius object.

    """
    cn_type = info['type']
    if cn_type == 'linear_expression':
        const = info['constant']
        terms = info['terms']
        convert = _convert_cn_info
        res = sum(convert(t, owners) for t in terms) + const
    elif cn_type == 'term':
        coeff = info['coeff']
        var = info['var']
        res = coeff * _convert_cn_info(var, owners)
    elif cn_type == 'linear_symbolic':
        sym_name = info['name']
        owner_id = info['owner']
        owner = owners.get(owner_id, None)
        if owner is None:
            owner = owners[owner_id] = LayoutBox('_virtual', owner_id)
        res = owner.primitive(sym_name)
    else:
        msg = 'Unhandled constraint info type `%s`' % cn_type
        raise ValueError(msg)
    return res


def as_linear_constraint(info, owners):
    """ Converts a constraint info dict into a casuarius linear
    constraint.

    For constraints specified in the info dict which do not have a
    corresponding owner (e.g. those created by box helpers) a
    constraint variable will be synthesized.

    Parameters
    ----------
    info : dict
        A dictionary sent from an Enaml widget which specifies the
        information for a linear constraint.

    owners : dict
        A mapping from constraint id to an owner object which holds
        the actual casuarius constraint variables as attributes.

    Returns
    -------
    result : LinearConstraint
        A casuarius linear constraint for the given dict.

    """
    if info['type'] != 'linear_constraint':
        msg = 'The info dict does not specify a linear constraint.'
        raise ValueError(msg)
    convert = _convert_cn_info
    lhs = convert(info['lhs'], owners)
    rhs = convert(info['rhs'], owners)
    op = info['op']
    if op == '==':
        cn = lhs == rhs
    elif op == '<=':
        cn = lhs <= rhs
    elif op == '>=':
        cn = lhs >= rhs
    else:
        msg = 'Unhandled constraint operator `%s`' % op
        raise ValueError(msg)
    return cn | info['strength'] | info['weight']


class QContainer(QFrame):
    """ A subclass of QFrame which behaves as a container.

    """
    #: A signal which is emitted on a resize event.
    resized = Signal()

    #: The internally cached size hint.
    _size_hint = QSize()

    def resizeEvent(self, event):
        """ Converts a resize event into a signal.

        """
        super(QContainer, self).resizeEvent(event)
        self.resized.emit()

    def sizeHint(self):
        """ Returns the previously set size hint. If that size hint is
        invalid, the superclass' sizeHint will be used.

        """
        hint = self._size_hint
        if not hint.isValid():
            hint = super(QContainer, self).sizeHint()
        return QSize(hint)

    def setSizeHint(self, hint):
        """ Sets the size hint to use for this widget.

        """
        self._size_hint = QSize(hint)

    def minimumSizeHint(self):
        """ Returns the minimum size hint for the widget.

        For a QContainer, the minimum size hint is equivalent to the
        minimum size as computed by the layout manager.

        """
        return self.minimumSize()


class QtContainer(QtConstraintsWidget):
    """ A Qt implementation of an Enaml Container.

    """
    #: Whether or not this container should share its layout with a
    #: parent container.
    _share_layout = False

    #: The padding to use when constraining the layout.
    _padding = (10, 10, 10, 10)

    #: Whether or not this container owns its layout. A container which
    #: does not own its layout is not responsible for laying out its
    #: children on a resize event, and will proxy the call to its owner.
    _owns_layout = True

    #: The object which has taken ownership of the layout for this
    #: container, if any.
    _layout_owner = None

    #: The LayoutManager instance to use for solving the layout system
    #: for this container.
    _layout_manager = None

    #: The function to use for refreshing the layout on a resize event.
    _refresh = lambda *args, **kwargs: None

    #: The table of offsets to use during a layout pass.
    _offset_table = []

    #: The table of (index, updater) pairs to use during a layout pass.
    _layout_table = []

    #: A dict mapping constraint owner id to associated LayoutBox
    _cn_owners = {}

    #: A list of the current contents constraints for the widget.
    _contents_cns = []

    #: A list of the current size hint constraints for the widget.
    _size_hint_cns = []

    #--------------------------------------------------------------------------
    # Setup Methods
    #--------------------------------------------------------------------------
    def create_widget(self, parent, tree):
        """ Creates the underlying QContainer widget.

        """
        return QContainer(parent)

    def create(self, tree):
        """ Create and initialize the underlying widget.

        """
        super(QtContainer, self).create(tree)
        layout = tree['layout']
        self._share_layout = layout['share_layout']
        self._padding = layout['padding']
        # The resized signal is connected directly to the refresh
        # method to save the overhead of the extra function call.
        self.widget().resized.connect(self.refresh)

    def init_layout(self):
        """ Initializes the layout for the container.

        """
        super(QtContainer, self).init_layout()
        # Layout ownership can only be transferred *after* this init
        # layout method is called, since layout occurs bottom up. So,
        # we only initialize a layout manager if we are not going to
        # transfer ownership at some point.
        if not self.will_transfer():
            offset_table, layout_table = self._build_layout_table()
            cns = self._generate_constraints(layout_table)
            # Initializing the layout manager can fail if the objective
            # function is unbounded. We let that failure occur so it can
            # be logged. Nothing is stored until it succeeds.
            manager = LayoutManager()
            manager.initialize(cns)
            self._offset_table = offset_table
            self._layout_table = layout_table
            self._layout_manager = manager
            self._refresh = self._build_refresher(manager)
            self.refresh_sizes()

    #--------------------------------------------------------------------------
    # Public Layout Handling
    #--------------------------------------------------------------------------
    def relayout(self):
        """ Rebuilds the constraints layout for this widget if it owns
        the responsibility for laying out its descendents.

        """
        if self._owns_layout:
            item = self.widget_item()
            old_hint = item.sizeHint()
            self.init_layout()
            self.refresh()
            new_hint = item.sizeHint()
            # If the size hint constraints are empty, it indicates that
            # they were previously cleared. In this case, the layout
            # system must be notified to rebuild its constraints, even
            # if the numeric size hint hasn't changed.
            if old_hint != new_hint or not self._size_hint_cns:
                self.size_hint_updated()
        else:
            self._layout_owner.relayout()

    def refresh(self):
        """ Makes a layout pass over the descendents if this widget owns
        the responsibility for their layout.

        """
        # The _refresh function is generated on every relayout and has
        # already taken into account whether or not the container owns
        # the layout.
        self._refresh()

    def refresh_sizes(self):
        """ Refresh the min/max/best sizes for the underlying widget.

        This method is normally called automatically at the proper
        times. It should not normally need to be called by user code.

        """
        widget = self.widget()
        widget.setSizeHint(self.compute_best_size())
        widget.setMinimumSize(self.compute_min_size())
        widget.setMaximumSize(self.compute_max_size())

    def replace_constraints(self, old_cns, new_cns):
        """ Replace constraints in the given layout.

        This method can be used to selectively add/remove/replace
        constraints in the layout system, when it is more efficient
        than performing a full relayout.

        Parameters
        ----------
        old_cns : list
            The list of casuarius constraints to remove from the
            the current layout system.

        new_cns : list
            The list of casuarius constraints to add to the
            current layout system.

        """
        if self._owns_layout:
            manager = self._layout_manager
            if manager is not None:
                with size_hint_guard(self):
                    manager.replace_constraints(old_cns, new_cns)
                    self.refresh_sizes()
                    self.refresh()
        else:
            self._layout_owner.replace_constraints(old_cns, new_cns)

    def clear_constraints(self, cns):
        """ Clear the given constraints from the current layout.

        Parameters
        ----------
        cns : list
            The list of casuarius constraints to remove from the
            current layout system.

        """
        if self._owns_layout:
            manager = self._layout_manager
            if manager is not None:
                manager.replace_constraints(cns, [])
        else:
            self._layout_owner.clear_constraints(cns)

    def layout(self):
        """ The callback invoked by the layout manager when there are
        new layout values available.

        This iterates over the layout table and calls the geometry
        updater functions.

        """
        # We explicitly don't use enumerate() to generate the running
        # index because this method is on the code path of the resize
        # event and hence called *often*. The entire code path for a
        # resize event is micro optimized and justified with profiling.
        offset_table = self._offset_table
        layout_table = self._layout_table
        running_index = 1
        for offset_index, updater in layout_table:
            dx, dy = offset_table[offset_index]
            new_offset = updater(dx, dy)
            offset_table[running_index] = new_offset
            running_index += 1

    def contents_margins(self):
        """ Get the contents margins for the container.

        The contents margins are added to the user provided padding
        to determine the final offset from a layout box boundary to
        the corresponding content line. The default content margins
        are zero. This method can be reimplemented by subclasses to
        supply different margins.

        Returns
        -------
        result : tuple
            A tuple of 'top', 'right', 'bottom', 'left' contents
            margins to use for computing the contents constraints.

        """
        return (0, 0, 0, 0)

    def contents_margins_updated(self):
        """ Notify the layout system that the contents margins of this
        widget have been updated.

        """
        old_cns = self._contents_cns
        self._contents_cns = []
        new_cns = self.contents_constraints()
        self.replace_constraints(old_cns, new_cns)

    def contents_constraints(self):
        """ Create the contents constraints for the container.

        The contents contraints are generated by combining the user
        padding with the margins returned by 'contents_margins' method.

        Returns
        -------
        result : list
            The list of casuarius constraints for the content.

        """
        cns = self._contents_cns
        if not cns:
            padding = self._padding
            margins = self.contents_margins()
            tval, rval, bval, lval = map(sum, zip(padding, margins))
            primitive = self.layout_box.primitive
            top = primitive('top')
            left = primitive('left')
            width = primitive('width')
            height = primitive('height')
            contents_top = primitive('contents_top')
            contents_left = primitive('contents_left')
            contents_right = primitive('contents_right')
            contents_bottom = primitive('contents_bottom')
            cns = [
                contents_top == (top + tval),
                contents_left == (left + lval),
                contents_right == (left + width - rval),
                contents_bottom == (top + height - bval),
            ]
            self._contents_cns = cns
        return cns

    #--------------------------------------------------------------------------
    # Private Layout Handling
    #--------------------------------------------------------------------------
    def _build_refresher(self, manager):
        """ A private method which will build a function which, when
        called, will refresh the layout for the container.

        Parameters
        ----------
        manager : LayoutManager
            The layout manager to use when refreshing the layout.

        """
        # The return function is a hyper optimized (for Python) closure
        # in order minimize the amount of work which is performed on the
        # code path of the resize event. This is explicitly not idiomatic
        # Python code. It exists purely for the sake of efficiency,
        # justified with profiling.
        mgr_layout = manager.layout
        layout = self.layout
        primitive = self.layout_box.primitive
        width_var = primitive('width')
        height_var = primitive('height')
        widget = self._widget
        width = widget.width
        height = widget.height
        def refresher():
            mgr_layout(layout, width_var, height_var, (width(), height()))
        return refresher

    def _build_layout_table(self):
        """ A private method which will build the layout table for
        this container.

        A layout table is a pair of flat lists which hold the required
        objects for laying out the child widgets of this container.
        The flat table is built in advance (and rebuilt if and when
        the tree structure changes) so that it's not necessary to
        perform an expensive tree traversal to layout the children
        on every resize event.

        Returns
        -------
        result : (list, list)
            The offset table and layout table to use during a resize
            event.

        """
        # The offset table is a list of (dx, dy) tuples which are the
        # x, y offsets of children expressed in the coordinates of the
        # layout owner container. This owner container may be different
        # from the parent of the widget, and so the delta offset must
        # be subtracted from the computed geometry values during layout.
        # The offset table is updated during a layout pass in breadth
        # first order.
        #
        # The layout table is a flat list of (idx, updater) tuples. The
        # idx is an index into the offset table where the given child
        # can find the offset to use for its layout. The updater is a
        # callable provided by the widget which accepts the dx, dy
        # offset and will update the layout geometry of the widget.
        zero_offset = (0, 0)
        offset_table = [zero_offset]
        layout_table = []
        queue = deque((0, child) for child in self.children())

        # Micro-optimization: pre-fetch bound methods and store globals
        # as locals. This method is not on the code path of a resize
        # event, but it is on the code path of a relayout. If there
        # are many children, the queue could potentially grow large.
        push_offset = offset_table.append
        push_item = layout_table.append
        push = queue.append
        pop = queue.popleft
        QtConstraintsWidget_ = QtConstraintsWidget
        QtContainer_ = QtContainer
        isinst = isinstance

        # The queue yields the items in the tree in breadth-first order
        # starting with the immediate children of this container. If a
        # given child is a container that will share its layout, then
        # the children of that container are added to the queue to be
        # added to the layout table.
        running_index = 0
        while queue:
            offset_index, item = pop()
            if isinst(item, QtConstraintsWidget_):
                push_item((offset_index, item.geometry_updater()))
                push_offset(zero_offset)
                running_index += 1
                if isinst(item, QtContainer_):
                    if item.transfer_layout_ownership(self):
                        for child in item.children():
                            push((running_index, child))

        return offset_table, layout_table

    def _generate_constraints(self, layout_table):
        """ Creates the list of casuarius LinearConstraint objects for
        the widgets for which this container owns the layout.

        This method walks over the items in the given layout table and
        aggregates their constraints into a single list of casuarius
        LinearConstraint objects which can be given to the layout
        manager.

        Parameters
        ----------
        layout_table : list
            The layout table created by a call to _build_layout_table.

        Returns
        -------
        result : list
            The list of casuarius LinearConstraints instances to pass to
            the layout manager.

        """
        # The mapping of constraint owners and the list of constraint
        # info dictionaries provided by the Enaml widgets.
        box = self.layout_box
        cn_owners = {self.object_id(): box}
        cn_dicts = list(self.user_constraints())
        cn_dicts_extend = cn_dicts.extend

        # The list of raw casuarius constraints which will be returned
        # from this method to be added to the casuarius solver.
        raw_cns = self.hard_constraints() + self.contents_constraints()
        raw_cns_extend = raw_cns.extend

        # The first element in a layout table item is its offset index
        # which is not relevant to constraints generation.
        isinst = isinstance
        QtContainer_ = QtContainer
        for _, updater in layout_table:
            child = updater.item
            cn_owners[child.object_id()] = child.layout_box
            raw_cns_extend(child.hard_constraints())
            if isinst(child, QtContainer_):
                if child.transfer_layout_ownership(self):
                    cn_dicts_extend(child.user_constraints())
                    raw_cns_extend(child.contents_constraints())
                else:
                    raw_cns_extend(child.size_hint_constraints())
            else:
                raw_cns_extend(child.size_hint_constraints())
                cn_dicts_extend(child.user_constraints())

        # Convert the list of Enaml constraints info dicts to actual
        # casuarius LinearConstraint objects for the solver.
        add_cn = raw_cns.append
        as_cn = as_linear_constraint
        for info in cn_dicts:
            add_cn(as_cn(info, cn_owners))

        # We keep a strong reference to the constraint owners dict,
        # since it may include instances of LayoutBox which were
        # created on-the-fly and hold constraint variables which
        # should not be deleted.
        self._cn_owners = cn_owners

        return raw_cns

    #--------------------------------------------------------------------------
    # Auxiliary Methods
    #--------------------------------------------------------------------------
    def transfer_layout_ownership(self, owner):
        """ A method which can be called by other components in the
        hierarchy to gain ownership responsibility for the layout
        of the children of this container. By default, the transfer
        is allowed and is the mechanism which allows constraints to
        cross widget boundaries. Subclasses should reimplement this
        method if different behavior is desired.

        Parameters
        ----------
        owner : Declarative
            The component which has taken ownership responsibility
            for laying out the children of this component. All
            relayout and refresh requests will be forwarded to this
            component.

        Returns
        -------
        results : bool
            True if the transfer was allowed, False otherwise.

        """
        if not self._share_layout:
            return False
        self._owns_layout = False
        self._layout_owner = owner
        self._layout_manager = None
        self._refresh = owner.refresh
        self._offset_table = []
        self._layout_table = []
        self._cn_owners = {}
        return True

    def will_transfer(self):
        """ Whether or not the container expects to transfer its layout
        ownership to its parent.

        This method is predictive in nature and exists so that layout
        managers are not senslessly created during the bottom-up layout
        initialization pass. It is declared public so that subclasses
        can override the behavior if necessary.

        """
        if self._share_layout:
            if isinstance(self.parent(), QtContainer):
                return True
        return False

    def compute_min_size(self):
        """ Calculates the minimum size of the container which would
        allow all constraints to be satisfied.

        If the container's resist properties have a strength less than
        'medium', the returned size will be zero. If the container does
        not own its layout, the returned size will be invalid.

        Returns
        -------
        result : QSize
            A (potentially invalid) QSize which is the minimum size
            required to satisfy all constraints.

        """
        resist_width, resist_height = self._resist
        shrink = ('ignore', 'weak')
        if resist_width in shrink and resist_height in shrink:
            return QSize(0, 0)
        if self._owns_layout and self._layout_manager is not None:
            primitive = self.layout_box.primitive
            width = primitive('width')
            height = primitive('height')
            w, h = self._layout_manager.get_min_size(width, height)
            if resist_width in shrink:
                w = 0
            if resist_height in shrink:
                h = 0
            return QSize(w, h)
        return QSize()

    def compute_best_size(self):
        """ Calculates the best size of the container.

        The best size of the container is obtained by computing the min
        size of the layout using a strength which is much weaker than a
        normal resize. This takes into account the size of any widgets
        which have their resist clip property set to 'weak' while still
        allowing the window to be resized smaller by the user. If the
        container does not own its layout, the returned size will be
        invalid.

        Returns
        -------
        result : QSize
            A (potentially invalid) QSize which is the best size that
            will satisfy all constraints.

        """
        if self._owns_layout and self._layout_manager is not None:
            primitive = self.layout_box.primitive
            width = primitive('width')
            height = primitive('height')
            w, h = self._layout_manager.get_min_size(width, height, weak)
            return QSize(w, h)
        return QSize()

    def compute_max_size(self):
        """ Calculates the maximum size of the container which would
        allow all constraints to be satisfied.

        If the container's hug properties have a strength less than
        'medium', or if the container does not own its layout, the
        returned size will be the Qt maximum.

        Returns
        -------
        result : QSize
            A (potentially invalid) QSize which is the maximum size
            allowable while still satisfying all constraints.

        """
        hug_width, hug_height = self._hug
        expanding = ('ignore', 'weak')
        if hug_width in expanding and hug_height in expanding:
            return QSize(16777215, 16777215)
        if self._owns_layout and self._layout_manager is not None:
            primitive = self.layout_box.primitive
            width = primitive('width')
            height = primitive('height')
            w, h = self._layout_manager.get_max_size(width, height)
            if w < 0 or hug_width in expanding:
                w = 16777215
            if h < 0 or hug_height in expanding:
                h = 16777215
            return QSize(w, h)
        return QSize(16777215, 16777215)


########NEW FILE########
__FILENAME__ = qt_control
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from .qt_constraints_widget import QtConstraintsWidget


class QtControl(QtConstraintsWidget):
    """ A Qt implementation of an Enaml Control.

    """
    # Currently, the QtConstraintsWidget superclass is a sufficient
    # implementation.
    pass


########NEW FILE########
__FILENAME__ = qt_datetime_selector
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from .qt.QtGui import QDateTimeEdit
from .qt_bounded_datetime import QtBoundedDatetime


class QtDatetimeSelector(QtBoundedDatetime):
    """ A Qt implementation of an Enaml DatetimeSelector.

    """
    #--------------------------------------------------------------------------
    # Setup Methods
    #--------------------------------------------------------------------------
    def create_widget(self, parent, tree):
        """ Create the underlying datetime widget.

        """
        return QDateTimeEdit(parent)

    def create(self, tree):
        """ Create and initialize the underlying widget.

        """
        super(QtDatetimeSelector, self).create(tree)
        self.set_datetime_format(tree['datetime_format'])
        self.set_calendar_popup(tree['calendar_popup'])
        self.widget().dateTimeChanged.connect(self.on_datetime_changed)

    #--------------------------------------------------------------------------
    # Message Handling
    #--------------------------------------------------------------------------
    def on_action_set_datetime_format(self, content):
        """ Handle the 'set_datetime_format' action from the Enaml
        widget.

        """
        self.set_datetime_format(content['datetime_format'])

    def on_action_set_calendar_popup(self, content):
        """ Handle the 'set_calendar_popup' action from the Enaml widget.

        """
        self.set_calendar_popup(content['calendar_popup'])

    #--------------------------------------------------------------------------
    # Widget Update Methods
    #--------------------------------------------------------------------------
    def get_datetime(self):
        """ Return the current datetime in the control.

        Returns
        -------
        result : QDateTime
            The current control datetime as a QDateTime object.

        """
        return self.widget().dateTime()

    def set_datetime(self, datetime):
        """ Set the widget's current datetime.

        Parameters
        ----------
        datetime : QDateTime
            The QDateTime object to use for setting the datetime.

        """
        with self.loopback_guard('datetime'):
            self.widget().setDateTime(datetime)

    def set_max_datetime(self, datetime):
        """ Set the widget's maximum datetime.

        Parameters
        ----------
        datetime : QDateTime
            The QDateTime object to use for setting the maximum datetime.

        """
        self.widget().setMaximumDateTime(datetime)

    def set_min_datetime(self, datetime):
        """ Set the widget's minimum datetime.

        Parameters
        ----------
        datetime : QDateTime
            The QDateTime object to use for setting the minimum datetime.

        """
        self.widget().setMinimumDateTime(datetime)

    def set_datetime_format(self, datetime_format):
        """ Set the widget's datetime format.

        Parameters
        ----------
        datetime_format : str
            A Python time formatting string.

        """
        # XXX make sure Python's and Qt's format strings are the
        # same, or convert between the two.
        self.widget().setDisplayFormat(datetime_format)

    def set_calendar_popup(self, popup):
        """ Set whether a calendar popup is available on the widget.

        Parameters
        ----------
        popup : bool
            Whether the calendar popup is enabled.

        """
        self.widget().setCalendarPopup(popup)


########NEW FILE########
__FILENAME__ = qt_date_selector
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from .qt.QtGui import QDateEdit
from .qt_bounded_date import QtBoundedDate


class QtDateSelector(QtBoundedDate):
    """ A Qt implementation of an Enaml DateSelector.

    """
    #--------------------------------------------------------------------------
    # Setup Methods
    #--------------------------------------------------------------------------
    def create_widget(self, parent, tree):
        """ Create the underlying QDateEdit widget.

        """
        return QDateEdit(parent)

    def create(self, tree):
        """ Create and initialize the underlying widget.

        """
        super(QtDateSelector, self).create(tree)
        self.set_date_format(tree['date_format'])
        self.set_calendar_popup(tree['calendar_popup'])
        self.widget().dateChanged.connect(self.on_date_changed)

    #--------------------------------------------------------------------------
    # Message Handling
    #--------------------------------------------------------------------------
    def on_action_set_date_format(self, content):
        """ Handle the 'set_date_format' action from the Enaml widget.

        """
        self.set_date_format(content['date_format'])

    def on_action_set_calendar_popup(self, content):
        """ Handle the 'set_calendar_popup' action from the Enaml widget.

        """
        self.set_calendar_popup(content['calendar_popup'])

    #--------------------------------------------------------------------------
    # Widget Update Methods
    #--------------------------------------------------------------------------
    def get_date(self):
        """ Return the current date in the control.

        Returns
        -------
        result : QDate
            The current control date as a QDate object.

        """
        return self.widget().date()

    def set_date(self, date):
        """ Set the widget's current date.

        Parameters
        ----------
        date : QDate
            The QDate object to use for setting the date.

        """
        with self.loopback_guard('date'):
            self.widget().setDate(date)

    def set_max_date(self, date):
        """ Set the widget's maximum date.

        Parameters
        ----------
        date : QDate
            The QDate object to use for setting the maximum date.

        """
        self.widget().setMaximumDate(date)

    def set_min_date(self, date):
        """ Set the widget's minimum date.

        Parameters
        ----------
        date : QDate
            The QDate object to use for setting the minimum date.

        """
        self.widget().setMinimumDate(date)

    def set_date_format(self, date_format):
        """ Set the widget's date format.

        Parameters
        ----------
        date_format : str
            A Python time formatting string.

        """
        # XXX make sure Python's and Qt's format strings are the
        # same, or convert between the two.
        self.widget().setDisplayFormat(date_format)

    def set_calendar_popup(self, popup):
        """ Set whether a calendar popup is available on the widget.

        Parameters
        ----------
        popup : bool
            Whether the calendar popup is enabled.

        """
        self.widget().setCalendarPopup(popup)


########NEW FILE########
__FILENAME__ = qt_dock_pane
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from .qt.QtCore import Qt, Signal
from .qt.QtGui import QDockWidget, QWidget
from .qt_container import QtContainer
from .qt_widget import QtWidget


#: A mapping from Enaml dock areas to Qt dock areas.
_DOCK_AREA_MAP = {
    'top': Qt.TopDockWidgetArea,
    'right': Qt.RightDockWidgetArea,
    'bottom': Qt.BottomDockWidgetArea,
    'left': Qt.LeftDockWidgetArea,
    'all': Qt.AllDockWidgetAreas,
}


#: A mapping from Qt dock areas to Enaml dock areas.
_DOCK_AREA_INV_MAP = {
    Qt.TopDockWidgetArea: 'top',
    Qt.RightDockWidgetArea: 'right',
    Qt.BottomDockWidgetArea: 'bottom',
    Qt.LeftDockWidgetArea: 'left',
    Qt.AllDockWidgetAreas: 'all',
}


class QCustomDockWidget(QDockWidget):
    """ A custom QDockWidget which adds some Enaml specific features.

    """
    #: A signal emitted when the dock widget is closed by the user.
    closed = Signal()

    #: A signal emitted when the dock widget is floated.
    floated = Signal()

    #: A signal emitted when the dock widget is docked. The payload
    #: will be the new dock area.
    docked = Signal(object)

    def __init__(self, *args, **kwargs):
        """ Initialize a QCustomDockWidget.

        Parameters
        ----------
        *args, **kwargs
            The positional and keyword arguments needed to initialize
            a QDockWidget.

        """
        super(QCustomDockWidget, self).__init__(*args, **kwargs)
        self._title_bar_visible = True
        self._dock_area = Qt.LeftDockWidgetArea
        self.topLevelChanged.connect(self._onTopLevelChanged)

    #--------------------------------------------------------------------------
    # Private API
    #--------------------------------------------------------------------------
    def _onTopLevelChanged(self, top_level):
        """ The signal handler for the the 'topLevelChanged' signal.

        """
        # Hiding the title bar on a floating dock widget causes the
        # frame to be hidden. We need to make sure its shown when
        # floating, and hidden again upon docking if needed.
        if top_level:
            self._showTitleBar()
            self.floated.emit()
        else:
            if not self._title_bar_visible:
                self._hideTitleBar()
            parent = self.parent()
            if parent is not None:
                self._dock_area = parent.dockWidgetArea(self)
            self.docked.emit(self._dock_area)

    def _showTitleBar(self):
        """ Shows the title bar for the widget.

        """
        if self.titleBarWidget() is not None:
            self.setTitleBarWidget(None)

    def _hideTitleBar(self):
        """ Hides the title bar for the widget.

        """
        if self.titleBarWidget() is None:
            self.setTitleBarWidget(QWidget())

    def closeEvent(self, event):
        """ A close event handler which emits the 'closed' signal.

        """
        super(QCustomDockWidget, self).closeEvent(event)
        self.closed.emit()

    #--------------------------------------------------------------------------
    # Public API
    #--------------------------------------------------------------------------
    def dockArea(self):
        """ Get the current dock area for the dock widget.

        Returns
        -------
        result : QDockWidgetArea
            The dock widget area where this dock widget resides.

        """
        return self._dock_area

    def setDockArea(self, area):
        """ Set the current dock area for the dock widget.

        Parameters
        ----------
        area : QDockWidgetArea
            The dock widget area where this dock widget should reside.

        """
        self._dock_area = area
        parent = self.parent()
        if parent is not None:
            parent.setDockWidgetArea(area, self)

    def titleBarVisible(self):
        """ Get whether or not the title bar is visible.

        Returns
        -------
        result : bool
            Whether or not the title bar is visible.

        """
        return self._title_bar_visible

    def setTitleBarVisible(self, visible):
        """ Set whether or not the title bar is visible.

        Parameters
        ----------
        visible : bool
            Whether or not the title bar is visible.

        """
        self._title_bar_visible = visible
        if visible:
            self._showTitleBar()
        else:
            if not self.isFloating():
                self._hideTitleBar()


class QtDockPane(QtWidget):
    """ A Qt implementation of an Enaml DockPane.

    """
    #--------------------------------------------------------------------------
    # Setup Methods
    #--------------------------------------------------------------------------
    def create_widget(self, parent, tree):
        """ Create the underlying dock pane widget.

        """
        return QCustomDockWidget(parent)

    def create(self, tree):
        """ Create and initialize the dock pane control.

        """
        super(QtDockPane, self).create(tree)
        self.set_title(tree['title'])
        self.set_title_bar_visible(tree['title_bar_visible'])
        self.set_title_bar_orientation(tree['title_bar_orientation'])
        self.set_closable(tree['closable'])
        self.set_movable(tree['movable'])
        self.set_floatable(tree['floatable'])
        self.set_floating(tree['floating'])
        self.set_dock_area(tree['dock_area'])
        self.set_allowed_dock_areas(tree['allowed_dock_areas'])
        widget = self.widget()
        widget.closed.connect(self.on_closed)
        widget.floated.connect(self.on_floated)
        widget.docked.connect(self.on_docked)

    def init_layout(self):
        """ Handle the layout initialization for the dock pane.

        """
        super(QtDockPane, self).init_layout()
        self.widget().setWidget(self.dock_widget())

    #--------------------------------------------------------------------------
    # Utility Methods
    #--------------------------------------------------------------------------
    def dock_widget(self):
        """ Find and return the dock widget child for this widget.

        Returns
        -------
        result : QWidget or None
            The dock widget defined for this widget, or None if one is
            not defined.

        """
        widget = None
        for child in self.children():
            if isinstance(child, QtContainer):
                widget = child.widget()
        return widget

    #--------------------------------------------------------------------------
    # Child Events
    #--------------------------------------------------------------------------
    def child_removed(self, child):
        """ Handle the child removed event for a QtDockPane.

        """
        if isinstance(child, QtContainer):
            self.widget().setWidget(self.dock_widget())

    def child_added(self, child):
        """ Handle the child added event for a QtDockPane.

        """
        if isinstance(child, QtContainer):
            self.widget().setWidget(self.dock_widget())

    #--------------------------------------------------------------------------
    # Signal Handlers
    #--------------------------------------------------------------------------
    def on_closed(self):
        """ The signal handler for the 'closed' signal.

        """
        # The closed signal is only emitted when the widget is closed
        # by the user, so there is no need for a loopback guard.
        self.send_action('closed', {})

    def on_floated(self):
        """ The signal handler for the 'floated' signal.

        """
        if 'floating' not in self.loopback_guard:
            self.send_action('floated', {})

    def on_docked(self, area):
        """ The signal handler for the 'docked' signal.

        """
        if 'floating' not in self.loopback_guard:
            content = {'dock_area': _DOCK_AREA_INV_MAP[area]}
            self.send_action('docked', content)

    #--------------------------------------------------------------------------
    # Message Handling
    #--------------------------------------------------------------------------
    def on_action_set_title(self, content):
        """ Handle the 'set_title' action from the Enaml widget.

        """
        self.set_title(content['title'])

    def on_action_set_title_bar_visible(self, content):
        """ Handle the 'set_title_bar_visible' action from the Enaml
        widget.

        """
        self.set_title_bar_visible(content['title_bar_visible'])

    def on_action_set_title_bar_orientation(self, content):
        """ Handle the 'set_title_bar_orientation' action from the
        Enaml widget.

        """
        self.set_title_bar_orientation(content['title_bar_orientation'])

    def on_action_set_closable(self, content):
        """ Handle the 'set_closable' action from the Enaml widget.

        """
        self.set_closable(content['closable'])

    def on_action_set_movable(self, content):
        """ Handle the 'set_movable' action from the Enaml widget.

        """
        self.set_movable(content['movable'])

    def on_action_set_floatable(self, content):
        """ Handle the 'set_floatable' action from the Enaml widget.

        """
        self.set_floatable(content['floatable'])

    def on_action_set_floating(self, content):
        """ Handle the 'set_floating' action from the Enaml widget.

        """
        self.set_floating(content['floating'])

    def on_action_set_dock_area(self, content):
        """ Handle the 'set_dock_area' action from the Enaml widget.

        """
        self.set_dock_area(content['dock_area'])

    def on_action_set_allowed_dock_areas(self, content):
        """ Handle the 'set_allowed_dock_areas' action from the Enaml
        widget.

        """
        self.set_allowed_dock_areas(content['allowed_dock_areas'])

    def on_action_open(self, content):
        """ Handle the 'open' action from the Enaml widget.

        """
        self.widget().setVisible(True)

    def on_action_close(self, content):
        """ Handle the 'close' action from the Enaml widget.

        """
        # Don't call widget.close() since that will fire a closeEvent.
        self.widget().setVisible(False)

    #--------------------------------------------------------------------------
    # Widget Update Methods
    #--------------------------------------------------------------------------
    def set_title(self, title):
        """ Set the title on the underlying widget.

        """
        self.widget().setWindowTitle(title)

    def set_title_bar_visible(self, visible):
        """ Set the title bar visibility of the underlying widget.

        """
        self.widget().setTitleBarVisible(visible)

    def set_title_bar_orientation(self, orientation):
        """ Set the title bar orientation of the underyling widget.

        """
        widget = self.widget()
        features = widget.features()
        if orientation == 'vertical':
            features |= QDockWidget.DockWidgetVerticalTitleBar
        else:
            features &= ~QDockWidget.DockWidgetVerticalTitleBar
        widget.setFeatures(features)

    def set_closable(self, closable):
        """ Set the closable state on the underlying widget.

        """
        widget = self.widget()
        features = widget.features()
        if closable:
            features |= QDockWidget.DockWidgetClosable
        else:
            features &= ~QDockWidget.DockWidgetClosable
        widget.setFeatures(features)

    def set_movable(self, movable):
        """ Set the movable state on the underlying widget.

        """
        widget = self.widget()
        features = widget.features()
        if movable:
            features |= QDockWidget.DockWidgetMovable
        else:
            features &= ~QDockWidget.DockWidgetMovable
        widget.setFeatures(features)

    def set_floatable(self, floatable):
        """ Set the floatable state on the underlying widget.

        """
        widget = self.widget()
        features = widget.features()
        if floatable:
            features |= QDockWidget.DockWidgetFloatable
        else:
            features &= ~QDockWidget.DockWidgetFloatable
        widget.setFeatures(features)

    def set_floating(self, floating):
        """ Set the floating staet on the underlying widget.

        """
        with self.loopback_guard('floating'):
            self.widget().setFloating(floating)

    def set_dock_area(self, dock_area):
        """ Set the dock area on the underlying widget.

        """
        self.widget().setDockArea(_DOCK_AREA_MAP[dock_area])

    def set_allowed_dock_areas(self, dock_areas):
        """ Set the allowed dock areas on the underlying widget.

        """
        qt_areas = Qt.NoDockWidgetArea
        for area in dock_areas:
            qt_areas |= _DOCK_AREA_MAP[area]
        self.widget().setAllowedAreas(qt_areas)


########NEW FILE########
__FILENAME__ = qt_enable_canvas
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from .qt.QtGui import QFrame
from .q_single_widget_layout import QSingleWidgetLayout
from .qt_constraints_widget import size_hint_guard
from .qt_control import QtControl

from enable.api import Window as EnableWindow


class QtEnableCanvas(QtControl):
    """ A Qt implementation of an Enaml EnableCanvas.

    """
    #: Internal storage for the enable component.
    _component = None

    #: Internal storage for the enable window.
    _window = None

    #--------------------------------------------------------------------------
    # Setup Methods
    #--------------------------------------------------------------------------
    def create_widget(self, parent, tree):
        """ Create the underlying widget.

        """
        widget = QFrame(parent)
        layout = QSingleWidgetLayout()
        widget.setLayout(layout)
        return widget

    def create(self, tree):
        """ Create and initialize the underlying widget.

        """
        super(QtEnableCanvas, self).create(tree)
        self._component = tree['component']

    def init_layout(self):
        """ Initialize the layout of the underlying widget.

        """
        super(QtEnableCanvas, self).init_layout()
        self.refresh_enable_widget()

    #--------------------------------------------------------------------------
    # Message Handlers
    #--------------------------------------------------------------------------
    def on_action_set_component(self, content):
        """ Handle the 'set_component' action from the Enaml widget.

        """
        self._component = content['component']
        with size_hint_guard(self):
            self.refresh_enable_widget()

    #--------------------------------------------------------------------------
    # Widget Update Methods
    #--------------------------------------------------------------------------
    def refresh_enable_widget(self):
        """ Create the enable widget and update the underlying control.

        """
        widget = self.widget()
        component = self._component
        if component is not None:
            self._window = EnableWindow(widget, component=component)
            enable_widget = self._window.control
        else:
            self._window = None
            enable_widget = None
        widget.layout().setWidget(enable_widget)


########NEW FILE########
__FILENAME__ = qt_factories
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
def action_factory():
    from .qt_action import QtAction
    return QtAction


def action_group_factory():
    from .qt_action_group import QtActionGroup
    return QtActionGroup


def calendar_factory():
    from .qt_calendar import QtCalendar
    return QtCalendar


def check_box_factory():
    from .qt_check_box import QtCheckBox
    return QtCheckBox


def combo_box_factory():
    from .qt_combo_box import QtComboBox
    return QtComboBox


def container_factory():
    from .qt_container import QtContainer
    return QtContainer


def date_selector_factory():
    from .qt_date_selector import QtDateSelector
    return QtDateSelector


def datetime_selector_factory():
    from .qt_datetime_selector import QtDatetimeSelector
    return QtDatetimeSelector


def dock_pane_factory():
    from .qt_dock_pane import QtDockPane
    return QtDockPane


def enable_canvas_factory():
    from .qt_enable_canvas import QtEnableCanvas
    return QtEnableCanvas


def field_factory():
    from .qt_field import QtField
    return QtField


def file_dialog_factory():
    from .qt_file_dialog import QtFileDialog
    return QtFileDialog


def flow_area_factory():
    from .qt_flow_area import QtFlowArea
    return QtFlowArea


def flow_item_factory():
    from .qt_flow_item import QtFlowItem
    return QtFlowItem


def form_factory():
    from .qt_form import QtForm
    return QtForm


def group_box_factory():
    from .qt_group_box import QtGroupBox
    return QtGroupBox


def html_factory():
    from .qt_html import QtHtml
    return QtHtml


def image_factory():
    from .qt_image import QtImage
    return QtImage


def image_view_factory():
    from .qt_image_view import QtImageView
    return QtImageView


def label_factory():
    from .qt_label import QtLabel
    return QtLabel


def list_control_factory():
    from .qt_list_control import QtListControl
    return QtListControl


def list_item_factory():
    from .qt_list_item import QtListItem
    return QtListItem


def main_window_factory():
    from .qt_main_window import QtMainWindow
    return QtMainWindow


def mdi_area_factory():
    from .qt_mdi_area import QtMdiArea
    return QtMdiArea


def mdi_window_factory():
    from .qt_mdi_window import QtMdiWindow
    return QtMdiWindow


def menu_factory():
    from .qt_menu import QtMenu
    return QtMenu


def menu_bar_factory():
    from .qt_menu_bar import QtMenuBar
    return QtMenuBar


def mpl_canvas_factory():
    from .qt_mpl_canvas import QtMPLCanvas
    return QtMPLCanvas


def multiline_field_factory():
    from .qt_multiline_field import QtMultilineField
    return QtMultilineField


def notebook_factory():
    from .qt_notebook import QtNotebook
    return QtNotebook


def page_factory():
    from .qt_page import QtPage
    return QtPage


def push_button_factory():
    from .qt_push_button import QtPushButton
    return QtPushButton


def progress_bar_factory():
    from .qt_progress_bar import QtProgressBar
    return QtProgressBar


def radio_button_factory():
    from .qt_radio_button import QtRadioButton
    return QtRadioButton


def scroll_area_factory():
    from .qt_scroll_area import QtScrollArea
    return QtScrollArea


def separator_factory():
    from .qt_separator import QtSeparator
    return QtSeparator


def slider_factory():
    from .qt_slider import QtSlider
    return QtSlider


def spin_box_factory():
    from .qt_spin_box import QtSpinBox
    return QtSpinBox


def split_item_factory():
    from .qt_split_item import QtSplitItem
    return QtSplitItem


def splitter_factory():
    from .qt_splitter import QtSplitter
    return QtSplitter


def stack_factory():
    from .qt_stack import QtStack
    return QtStack


def stack_item_factory():
    from .qt_stack_item import QtStackItem
    return QtStackItem


#def text_editor_factory():
#    from .qt_text_editor import QtTextEditor
#    return QtTextEditor


def time_selector_factory():
    from .qt_time_selector import QtTimeSelector
    return QtTimeSelector


def tool_bar_factory():
    from .qt_tool_bar import QtToolBar
    return QtToolBar


def traits_item_factory():
    from .qt_traits_item import QtTraitsItem
    return QtTraitsItem


def web_view_factory():
    from .qt_web_view import QtWebView
    return QtWebView


def window_factory():
    from .qt_window import QtWindow
    return QtWindow


def register_default():
    from .qt_widget_registry import QtWidgetRegistry
    reg = QtWidgetRegistry.register
    register = lambda name, factory: reg(name, factory, 'default')
    register('Action', action_factory)
    register('ActionGroup', action_group_factory)
    register('Calendar', calendar_factory)
    register('CheckBox', check_box_factory)
    register('ComboBox', combo_box_factory)
    register('Container', container_factory)
    register('DateSelector', date_selector_factory)
    register('DatetimeSelector', datetime_selector_factory)
    register('DockPane', dock_pane_factory)
    register('EnableCanvas', enable_canvas_factory)
    register('Field', field_factory)
    register('FileDialog', file_dialog_factory)
    register('FlowArea', flow_area_factory)
    register('FlowItem', flow_item_factory)
    register('Form', form_factory)
    register('GroupBox', group_box_factory)
    register('Html', html_factory)
    register('Image', image_factory)
    register('ImageView', image_view_factory)
    register('Label', label_factory)
    register('ListControl', list_control_factory)
    register('ListItem', list_item_factory)
    register('MainWindow', main_window_factory)
    register('MdiArea', mdi_area_factory)
    register('MdiWindow', mdi_window_factory)
    register('Menu', menu_factory)
    register('MenuBar', menu_bar_factory)
    register('MPLCanvas', mpl_canvas_factory)
    register('MultilineField', multiline_field_factory)
    register('Notebook', notebook_factory)
    register('Page', page_factory)
    register('PushButton', push_button_factory)
    register('ProgressBar', progress_bar_factory)
    register('RadioButton', radio_button_factory)
    register('ScrollArea', scroll_area_factory)
    register('Separator', separator_factory)
    register('Slider', slider_factory)
    register('SpinBox', spin_box_factory)
    register('SplitItem', split_item_factory)
    register('Splitter', splitter_factory)
    register('Stack', stack_factory)
    register('StackItem', stack_item_factory)
    register('TimeSelector', time_selector_factory)
    register('ToolBar', tool_bar_factory)
    register('TraitsItem', traits_item_factory)
    register('WebView', web_view_factory)
    register('Window', window_factory)


########NEW FILE########
__FILENAME__ = qt_field
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from enaml.validation.client_validators import null_validator, make_validator

from .qt.QtGui import QLineEdit
from .qt.QtCore import Signal
from .qt_control import QtControl


ECHO_MODES = {
    'normal': QLineEdit.Normal,
    'password' : QLineEdit.Password,
    'silent' : QLineEdit.NoEcho
}


class QtFocusLineEdit(QLineEdit):
    """ A QLineEdit subclass which converts a lost focus event into
    a lost focus signal.

    """
    lostFocus = Signal()

    def focusOutEvent(self, event):
        self.lostFocus.emit()
        return super(QtFocusLineEdit, self).focusOutEvent(event)


class QtField(QtControl):
    """ A Qt4 implementation of an Enaml Field.

    """
    #: The client side validator function for the field.
    _validator = null_validator

    #: The validator message for the validator.
    _validator_message = ''

    #: The list of submit triggers for when to submit a text change.
    _submit_triggers = []

    #: The last text value submitted to or sent from the server.
    _last_value = None

    #: A flag indicating whether the current field is invalid.
    _is_error_state = False

    #--------------------------------------------------------------------------
    # Setup Methods
    #--------------------------------------------------------------------------
    def create_widget(self, parent, tree):
        """ Creates the underlying QLineEdit widget.

        """
        return QtFocusLineEdit(parent)

    def create(self, tree):
        """ Create and initialize the underlying widget.

        """
        super(QtField, self).create(tree)
        self.set_text(tree['text'])
        self.set_validator(tree['validator'])
        self.set_submit_triggers(tree['submit_triggers'])
        self.set_placeholder(tree['placeholder'])
        self.set_echo_mode(tree['echo_mode'])
        self.set_max_length(tree['max_length'])
        self.set_read_only(tree['read_only'])
        widget = self.widget()
        widget.lostFocus.connect(self.on_lost_focus)
        widget.returnPressed.connect(self.on_return_pressed)
        widget.textEdited.connect(self.on_text_edited)

    #--------------------------------------------------------------------------
    # Private API
    #--------------------------------------------------------------------------
    def _submit_text(self, text):
        """ Submit the given text as an update to the server widget.

        Parameters
        ----------
        text : unicode
            The unicode text to send to the server widget.

        """
        content = {'text': text}
        self.send_action('submit_text', content)

    def _validate_and_submit(self):
        """ Validate the current text in the control, and submit it to
        the server widget if it's valid.

        """
        text = self.widget().text()
        if text != self._last_value:
            if self._validator(text):
                self._clear_error_style()
                self._submit_text(text)
                self._last_value = text
            else:
                self._set_error_style()

    def _set_error_style(self):
        # A temporary hack until styles are implemented
        s = 'QLineEdit { border: 2px solid red; background: rgb(255, 220, 220); }'
        self.widget().setStyleSheet(s)
        self._is_error_state = True

    def _clear_error_style(self):
        # A temporary hack until styles are implemented
        self.widget().setStyleSheet('')
        self._is_error_state = False

    #--------------------------------------------------------------------------
    # Signal Handlers
    #--------------------------------------------------------------------------
    def on_lost_focus(self):
        """ The signal handler for 'lostFocus' signal.

        """
        if 'lost_focus' in self._submit_triggers:
            self._validate_and_submit()

    def on_return_pressed(self):
        """ The signal handler for 'returnPressed' signal.

        """
        if 'return_pressed' in self._submit_triggers:
            self._validate_and_submit()

    def on_text_edited(self):
        """ The signal handler for 'textEdited' signal.
        """
        if 'text_edited' in self._submit_triggers:
            self._validate_and_submit()

    #--------------------------------------------------------------------------
    # Message Handlers
    #--------------------------------------------------------------------------
    def on_action_set_text(self, content):
        """ Handle the 'set_text' action from the Enaml widget.

        """
        self.set_text(content['text'])

    def on_action_set_validator(self, content):
        """ Handle the 'set_validator' action from the Enaml widget.

        """
        self.set_validator(content['validator'])

    def on_action_set_submit_triggers(self, content):
        """ Handle the 'set_submit_triggers' action from the Enaml
        widget.

        """
        self.set_submit_triggers(content['submit_triggers'])

    def on_action_set_placeholder(self, content):
        """ Hanlde the 'set_placeholder' action from the Enaml widget.

        """
        self.set_placeholder(content['placeholder'])

    def on_action_set_echo_mode(self, content):
        """ Handle the 'set_echo_mode' action from the Enaml widget.

        """
        self.set_echo_mode(content['echo_mode'])

    def on_action_set_max_length(self, content):
        """ Handle the 'set_max_length' action from the Enaml widget.

        """
        self.set_max_length(content['max_length'])

    def on_action_set_read_only(self, content):
        """ Handle the 'set_read_only' action from the Enaml widget.

        """
        self.set_read_only(content['read_only'])

    def on_action_invalid_text(self, content):
        """ Handle the 'invalid_text' action from the Enaml widget.

        """
        if self.widget().text() == content['text']:
            self._set_error_style()

    #--------------------------------------------------------------------------
    # Widget Update Methods
    #--------------------------------------------------------------------------
    def set_text(self, text):
        """ Set the text in the underlying widget.

        """
        self.widget().setText(text)
        self._last_value = text
        self._clear_error_style()

    def set_validator(self, validator):
        """ Set the validator for the underlying widget.

        """
        if validator is None:
            self._validator = null_validator
            self._validator_message = ''
        else:
            self._validator = make_validator(validator)
            self._validator_message = validator.get('message', '')

    def set_submit_triggers(self, triggers):
        """ Set the submit triggers for the underlying widget.

        """
        self._submit_triggers = triggers

    def set_placeholder(self, text):
        """ Set the placeholder text of the underlying widget.

        """
        self.widget().setPlaceholderText(text)

    def set_echo_mode(self, mode):
        """ Set the echo mode of the underlying widget.

        """
        self.widget().setEchoMode(ECHO_MODES[mode])

    def set_max_length(self, length):
        """ Set the maximum text length in the underlying widget.

        """
        if length <= 0 or length > 32767:
            length = 32767
        self.widget().setMaxLength(length)

    def set_read_only(self, read_only):
        """ Set whether or not the widget is read only.

        """
        self.widget().setReadOnly(read_only)


########NEW FILE########
__FILENAME__ = qt_file_dialog
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from .qt import qt_api
from .qt.QtGui import QFileDialog
from .qt_object import QtObject


# A mapping from the Enaml dialog modes to the name of the static method
# on QFileDialog which will launch the appropriate native dialog.
if qt_api == 'pyqt':
    _NATIVE_METHOD_NAMES = {
        'open_file': 'getOpenFileNameAndFilter',
        'open_files': 'getOpenFileNamesAndFilter',
        'save_file': 'getSaveFileNameAndFilter',
        'directory': 'getExistingDirectory',
    }
else:
    _NATIVE_METHOD_NAMES = {
        'open_file': 'getOpenFileName',
        'open_files': 'getOpenFileNames',
        'save_file': 'getSaveFileName',
        'directory': 'getExistingDirectory',
    }


class QtFileDialog(QtObject):
    """ A Qt implementation of an Enaml FileDialog.

    """
    #--------------------------------------------------------------------------
    # Setup Methods
    #--------------------------------------------------------------------------
    def create_widget(self, parent, tree):
        """ Create the underlying widget.

        The file dialog widget is created on-demand when the open action
        is received. There is no persistent widget created for the file
        dialog.

        """
        return None

    #--------------------------------------------------------------------------
    # Message Handlers
    #--------------------------------------------------------------------------
    def on_action_open(self, content):
        """ Handle the 'open' action from the Enaml widget.

        """
        if content['native_dialog']:
            result = self._open_native(content)
        else:
            result = self._open_non_native(content)
        self.send_action('closed', result)

    #--------------------------------------------------------------------------
    # Private API
    #--------------------------------------------------------------------------
    def _open_native(self, content):
        """ Open a native dialog for the given configuration.

        Parameters
        ----------
        content : dict
            The content dict sent by the Enaml widget for the `open`
            action.

        Returns
        -------
        result : dict
            The content dict for the `closed` action to be sent back
            to the Enaml widget.

        """
        mode = content['mode']
        assert mode in ('open_file', 'open_files', 'save_file', 'directory')

        def unpack_content():
            parent = self.parent_widget()
            caption = content['title']
            path = content['path']
            filters = u';;'.join(content['filters'])
            selected_filter = content['selected_filter']
            if mode == 'directory':
                args = (parent, caption, path)
            else:
                args = (parent, caption, path, filters, selected_filter)
            return args

        def pack_result(result):
            if mode == 'directory':
                paths = [result] if result else []
                selected_filter = u''
            elif mode == 'open_files':
                paths, selected_filter = result
            else:
                p, selected_filter = result
                paths = [p] if p else []
            content = {}
            if paths:
                content['result'] = 'accepted'
                content['paths'] = paths
                content['selected_filter'] = selected_filter
            else:
                content['result'] = 'rejected'
            return content

        method = getattr(QFileDialog, _NATIVE_METHOD_NAMES[mode])
        return pack_result(method(*unpack_content()))

    def _open_non_native(self, content):
        """ Open a non-native dialog for the given configuration.

        Parameters
        ----------
        content : dict
            The content dict sent by the Enaml widget for the `open`
            action.

        Returns
        -------
        result : dict
            The content dict for the `closed` action to be sent back
            to the Enaml widget.

        """
        mode = content['mode']
        assert mode in ('open_file', 'open_files', 'save_file', 'directory')

        dlg = QFileDialog(self.parent_widget())
        if mode == 'open_file':
            dlg.setAcceptMode(QFileDialog.AcceptOpen)
            dlg.setFileMode(QFileDialog.ExistingFile)
        elif mode == 'open_files':
            dlg.setAcceptMode(QFileDialog.AcceptOpen)
            dlg.setFileMode(QFileDialog.ExistingFiles)
        elif mode == 'save_file':
            dlg.setAcceptMode(QFileDialog.AcceptSave)
            dlg.setFileMode(QFileDialog.AnyFile)
        else:
            dlg.setAcceptMode(QFileDialog.AcceptOpen)
            dlg.setFileMode(QFileDialog.Directory)
            dlg.setOption(QFileDialog.ShowDirsOnly, True)

        caption = content['title']
        path = content['path']
        filters = content['filters']
        selected_filter = content['selected_filter']

        if caption:
            dlg.setWindowTitle(caption)
        dlg.setDirectory(path)
        dlg.setNameFilters(filters)
        dlg.selectNameFilter(selected_filter)

        result = {}
        if dlg.exec_():
            result['result'] = 'accepted'
            result['paths'] = dlg.selectedFiles()
            result['selected_filter'] = dlg.selectedNameFilter()
        else:
            result['result'] = 'rejected'

        return result


########NEW FILE########
__FILENAME__ = qt_flow_area
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from .qt.QtGui import QScrollArea, QFrame
from .qt_constraints_widget import QtConstraintsWidget
from .qt_flow_item import QtFlowItem
from .q_flow_layout import QFlowLayout


_DIRECTION_MAP = {
    'left_to_right': QFlowLayout.LeftToRight,
    'right_to_left': QFlowLayout.RightToLeft,
    'top_to_bottom': QFlowLayout.TopToBottom,
    'bottom_to_top': QFlowLayout.BottomToTop,
}


_ALIGN_MAP = {
    'leading': QFlowLayout.AlignLeading,
    'trailing': QFlowLayout.AlignTrailing,
    'center': QFlowLayout.AlignCenter,
    'justify': QFlowLayout.AlignJustify,
}


class QFlowArea(QScrollArea):
    """ A custom QScrollArea which implements a flowing layout.

    """
    def __init__(self, parent=None):
        """ Initialize a QFlowArea.

        Parameters
        ----------
        parent : QWidget, optional
            The parent widget of this widget.

        """
        super(QFlowArea, self).__init__(parent)
        self._widget = QFrame(self)
        self._layout = QFlowLayout()
        self._widget.setLayout(self._layout)
        self.setWidgetResizable(True)
        self.setWidget(self._widget)

    def layout(self):
        """ Get the layout for this flow area.

        The majority of interaction for a QFlowArea takes place through
        its layout, rather than through the widget itself.

        Returns
        -------
        result : QFlowLayout
            The flow layout for this flow area.

        """
        return self._layout

    def setLayout(self, layout):
        """ A reimplemented method. Setting the layout on a QFlowArea
        is not supported.

        """
        raise TypeError("Cannot set layout on a QFlowArea.")


class QtFlowArea(QtConstraintsWidget):
    """ A Qt implementation of an Enaml FlowArea.

    """
    #--------------------------------------------------------------------------
    # Setup Methods
    #--------------------------------------------------------------------------
    def create_widget(self, parent, tree):
        """ Create the underlying widget.

        """
        return QFlowArea(parent)

    def create(self, tree):
        """ Create and initialize the underlying control.

        """
        super(QtFlowArea, self).create(tree)
        self.set_direction(tree['direction'])
        self.set_align(tree['align'])
        self.set_horizontal_spacing(tree['horizontal_spacing'])
        self.set_vertical_spacing(tree['vertical_spacing'])
        self.set_margins(tree['margins'])

    def init_layout(self):
        """ Initialize the layout for the underlying control.

        """
        super(QtFlowArea, self).init_layout()
        layout = self.widget().layout()
        for child in self.children():
            if isinstance(child, QtFlowItem):
                layout.addWidget(child.widget())

    #--------------------------------------------------------------------------
    # Child Events
    #--------------------------------------------------------------------------
    def child_removed(self, child):
        """ Handle the child removed event for a QtMdiArea.

        """
        if isinstance(child, QtFlowItem):
            self.widget().layout().removeWidget(child.widget())

    def child_added(self, child):
        """ Handle the child added event for a QtMdiArea.

        """
        if isinstance(child, QtFlowItem):
            index = self.index_of(child)
            self.widget().layout().insertWidget(index, child.widget())

    #--------------------------------------------------------------------------
    # Message Handling
    #--------------------------------------------------------------------------
    def on_action_set_direction(self, content):
        """ Handle the 'set_direction' action from the Enaml widget.

        """
        self.set_direction(content['direction'])

    def on_action_set_align(self, content):
        """ Handle the 'set_align' action from the Enaml widget.

        """
        self.set_align(content['align'])

    def on_action_set_horizontal_spacing(self, content):
        """ Handle the 'set_horizontal_spacing' action from the Enaml
        widget.

        """
        self.set_horizontal_spacing(content['horizontal_spacing'])

    def on_action_set_vertical_spacing(self, content):
        """ Handle the 'set_vertical_spacing' action from the Enaml
        widget.

        """
        self.set_vertical_spacing(content['vertical_spacing'])

    def on_action_set_margins(self, content):
        """ Handle the 'set_margins' action from the Enaml widget.

        """
        self.set_margins(content['margins'])

    #--------------------------------------------------------------------------
    # Widget Update Methods
    #--------------------------------------------------------------------------
    def set_direction(self, direction):
        """ Set the direction for the underlying control.

        """
        self.widget().layout().setDirection(_DIRECTION_MAP[direction])

    def set_align(self, align):
        """ Set the alignment for the underlying control.

        """
        self.widget().layout().setAlignment(_ALIGN_MAP[align])

    def set_horizontal_spacing(self, spacing):
        """ Set the horizontal spacing of the underyling control.

        """
        self.widget().layout().setHorizontalSpacing(spacing)

    def set_vertical_spacing(self, spacing):
        """ Set the vertical spacing of the underlying control.

        """
        self.widget().layout().setVerticalSpacing(spacing)

    def set_margins(self, margins):
        """ Set the margins of the underlying control.

        """
        top, right, bottom, left = margins
        self.widget().layout().setContentsMargins(left, top, right, bottom)

    #--------------------------------------------------------------------------
    # Overrides
    #--------------------------------------------------------------------------
    def replace_constraints(self, old_cns, new_cns):
        """ A reimplemented QtConstraintsWidget layout method.

        Constraints layout may not cross the boundary of a FlowArea,
        so this method is no-op which stops the layout propagation.

        """
        pass

    def clear_constraints(self, cns):
        """ A reimplemented QtConstraintsWidget layout method.

        Constraints layout may not cross the boundary of a FlowArea,
        so this method is no-op which stops the layout propagation.

        """
        pass


########NEW FILE########
__FILENAME__ = qt_flow_item
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from .qt.QtCore import QSize, QEvent
from .qt.QtGui import QFrame, QLayout
from .q_flow_layout import QFlowLayout, AbstractFlowWidget, FlowLayoutData
from .q_single_widget_layout import QSingleWidgetLayout
from .qt_container import QtContainer
from .qt_widget import QtWidget


_ALIGN_MAP = {
    'leading': QFlowLayout.AlignLeading,
    'trailing': QFlowLayout.AlignTrailing,
    'center': QFlowLayout.AlignCenter,
}


class QFlowItem(QFrame):
    """ A QFrame subclass which acts as an item in a QFlowArea.

    """
    def __init__(self, parent=None):
        """ Initialize a QFlowItem.

        Parameters
        ----------
        parent : QWidget, optional
            The parent of the flow item.

        """
        super(QFlowItem, self).__init__(parent)
        self._flow_widget = None
        self._layout_data = FlowLayoutData()
        self.setLayout(QSingleWidgetLayout())
        self.layout().setSizeConstraint(QLayout.SetMinAndMaxSize)

    def layoutData(self):
        """ Get the layout data associate with this flow item.

        This method implements the AbstractFlowWidget interface.

        Returns
        -------
        result : FlowLayoutData
            The layout data for this flow item.

        """
        return self._layout_data

    def preferredSize(self):
        """ Get the preferred size for this widget.

        Returns
        -------
        result : QSize
            The preferred size of this flow item.

        """
        return self._layout_data.preferred_size

    def setPreferredSize(self, size):
        """ Set the preferred size for this flow item.

        This will trigger an invalidation of the layout data.

        Parameters
        ----------
        size : QSize
            The preferred size for the flow item.

        """
        d = self._layout_data
        d.preferred_size = size
        d.dirty = True
        self.updateGeometry()

    def alignment(self):
        """ Get the alignment for the flow item.

        Returns
        -------
        result : QFlowLayout alignment
            The alignment for the flow item in the layout.

        """
        return self._layout_data.alignment

    def setAlignment(self, alignment):
        """ Set the alignment for the flot item.

        This will trigger an invalidation of the layout data.

        Parameters
        ----------
        alignment : QFlowLayout alignment
            The alignment for the flow item in the layout.

        """
        d = self._layout_data
        d.alignment = alignment
        d.dirty = True
        self.updateGeometry()

    def stretch(self):
        """ Get the stretch factor for the flow item.

        Returns
        -------
        result : int
            The stretch factor for the flow item in the direction of
            the layout flow.

        """
        return self._layout_data.stretch

    def setStretch(self, stretch):
        """ Set the stretch factor for the flow item.

        This will trigger an invalidation of the layout data.

        Parameters
        ----------
        stretch : int
            The stretch factor for the flow item in the direction of
            the layout flow.

        """
        d = self._layout_data
        d.stretch = stretch
        d.dirty = True
        self.updateGeometry()

    def orthoStretch(self):
        """ Get the ortho stretch factor for the flow item.

        Returns
        -------
        result : int
            The stretch factor for the flow item in the direction
            orthogonal to the layout flow.

        """
        return self._layout_data.stretch

    def setOrthoStretch(self, stretch):
        """ Set the ortho stretch factor for the flow item.

        This will trigger an invalidation of the layout data.

        Parameters
        ----------
        stretch : int
            The stretch factor for the flow item in the direction
            orthogonal to the layout flow.

        """
        d = self._layout_data
        d.ortho_stretch = stretch
        d.dirty = True
        self.updateGeometry()

    def flowWidget(self):
        """ Get the flow widget for this flow item.

        Returns
        -------
        result : QWidget or None
            The flow widget being managed by this item.

        """
        return self._flow_widget

    def setFlowWidget(self, widget):
        """ Set the flow widget for this flow item.

        Parameters
        ----------
        widget : QWidget
            The QWidget to use as the flow widget in this item.

        """
        self._flow_widget = widget
        self.layout().setWidget(widget)

    def event(self, event):
        """ A custom event handler which handles LayoutRequest events.

        When a LayoutRequest event is posted to this widget, it will
        emit the `layoutRequested` signal. This allows an external
        consumer of this widget to update their external layout.

        """
        if event.type() == QEvent.LayoutRequest:
            self._layout_data.dirty = True
        return super(QFlowItem, self).event(event)


AbstractFlowWidget.register(QFlowItem)


class QtFlowItem(QtWidget):
    """ A Qt implementation of an Enaml FlowItem.

    """
    #--------------------------------------------------------------------------
    # Setup Methods
    #--------------------------------------------------------------------------
    def create_widget(self, parent, tree):
        """ Create the underlying QFlowItem widget.

        """
        return QFlowItem(parent)

    def create(self, tree):
        """ Create and initialize the underlying control.

        """
        super(QtFlowItem, self).create(tree)
        self.set_preferred_size(tree['preferred_size'])
        self.set_align(tree['align'])
        self.set_stretch(tree['stretch'])
        self.set_ortho_stretch(tree['ortho_stretch'])

    def init_layout(self):
        """ Initialize the layout for the underyling widget.

        """
        super(QtFlowItem, self).init_layout()
        self.widget().setFlowWidget(self.flow_widget())

    #--------------------------------------------------------------------------
    # Utility Methods
    #--------------------------------------------------------------------------
    def flow_widget(self):
        """ Find and return the flow widget child for this widget.

        Returns
        -------
        result : QWidget or None
            The flow widget defined for this widget, or None if one is
            not defined.

        """
        widget = None
        for child in self.children():
            if isinstance(child, QtContainer):
                widget = child.widget()
        return widget

    #--------------------------------------------------------------------------
    # Child Events
    #--------------------------------------------------------------------------
    def child_removed(self, child):
        """ Handle the child added event for a QtFlowItem.

        """
        if isinstance(child, QtContainer):
            self.widget().setFlowWidget(self.flow_widget())

    def child_added(self, child):
        """ Handle the child added event for a QtFlowItem.

        """
        if isinstance(child, QtContainer):
            self.widget().setFlowWidget(self.flow_widget())

    #--------------------------------------------------------------------------
    # Message Handling
    #--------------------------------------------------------------------------
    def on_action_set_preferred_size(self, content):
        """ Handle the 'set_preferred_size' action from the Enaml
        widget.

        """
        self.set_preferred_size(content['preferred_size'])

    def on_action_set_align(self, content):
        """ Handle the 'set_align' action from the Enaml widget.

        """
        self.set_align(content['align'])

    def on_action_set_stretch(self, content):
        """ Handle the 'set_stretch' action from the Enaml widget.

        """
        self.set_stretch(content['stretch'])

    def on_action_set_ortho_stretch(self, content):
        """ Handle the 'set_ortho_stretch' action from the Enaml widget.

        """
        self.set_ortho_stretch(content['ortho_stretch'])

    #--------------------------------------------------------------------------
    # Widget Update Methods
    #--------------------------------------------------------------------------
    def set_preferred_size(self, size):
        """ Set the preferred size of the underlying widget.

        """
        self.widget().setPreferredSize(QSize(*size))

    def set_align(self, align):
        """ Set the alignment of the underlying widget.

        """
        self.widget().setAlignment(_ALIGN_MAP[align])

    def set_stretch(self, stretch):
        """ Set the stretch factor of the underlying widget.

        """
        self.widget().setStretch(stretch)

    def set_ortho_stretch(self, stretch):
        """ Set the ortho stretch factor of the underling widget.

        """
        self.widget().setOrthoStretch(stretch)


########NEW FILE########
__FILENAME__ = qt_font_utils
#------------------------------------------------------------------------------
#  Copyright (c) 2013, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from enaml.fonts import parse_font

from .qt.QtGui import QFont, QApplication


STYLE = {
    'normal': QFont.StyleNormal,
    'italic': QFont.StyleItalic,
    'oblique': QFont.StyleOblique,
}


VARIANT = {
    'normal': QFont.MixedCase,
    'small-caps': QFont.SmallCaps,
}


WEIGHT = {
    'normal': QFont.Normal,
    'bold': QFont.Bold,
    '100': 12,
    '200': 25,
    '300': 37,
    '400': 50,
    '500': 62,
    '600': 75,
    '700': 87,
    '800': 99,
    '900': 99,
}


RELATIVE_WEIGHT = {
    'bolder': {
        100: 50,
        200: 50,
        300: 50,
        400: 75,
        500: 75,
        600: 87,
        700: 99,
        800: 99,
        900: 99,
    },
    'lighter': {
        100: 12,
        200: 12,
        300: 25,
        400: 25,
        500: 50,
        600: 50,
        700: 75,
        800: 87,
        900: 87,
    }
}


SIZES = {
    'xx-small': 0,
    'x-small': 1,
    'small': 2,
    'medium': 3,
    'large': 4,
    'x-large': 5,
    'xx-large': 6,
}


RELATIVE_SIZES = {
    'larger': 4,
    'smaller': 2,
}


SCALE_FACTORS = [0.6, 0.7, 0.8, 1.0, 1.2, 1.5, 2.0]


# Convert CSS units into points.
UNIT_CONVERTERS = {
    'in': lambda size: size * 72.0,
    'cm': lambda size: size * 72.0 / 2.54,
    'mm': lambda size: size * 72.0 / 254.0,
    'pt': lambda size: size,
    'pc': lambda size: size * 12.0,
    'px': lambda size: size * 0.75,
}


class QtFontCache(object):

    def __init__(self, default=None):
        """ Initialize a QFontCache.

        Parameters
        ----------
        default: QFont, optional
            The font to use to fill the default parameters of fonts.

        """
        self._default = default
        self._cache = {}  # XXX need an lru cache here.

    def __getitem__(self, font):
        cache = self._cache
        if font in cache:
            return cache[font]
        if isinstance(font, basestring):
            font_ = parse_font(font)
            if font_ is None:
                return self._default or QFont()
            qfont = self._make_qfont(font_)
            cache[font] = cache[font_] = qfont
        else:
            qfont = self._make_qfont(font)
            cache[font] = qfont
        return qfont

    def _make_qfont(self, font):
        """ Create a QFont from an Enaml Font object.

        Parameters
        ----------
        font : Font
            The Enaml Font object.

        Returns
        -------
        result : QFont
            An equivalent QFont for the given Enaml Font.

        """
        app = QApplication.instance()
        if app is not None:
            app_default = app.font()
        else:
            app_default = QFont()

        default = self._default
        if default is None:
            default = app_default

        qfont = QFont()
        qfont.setStyle(STYLE[font.style])
        qfont.setCapitalization(VARIANT[font.variant])
        if font.family:
            qfont.setFamily(font.family)

        fweight = font.weight
        if fweight in WEIGHT:
            qfont.setWeight(WEIGHT[fweight])
        elif fweight in RELATIVE_WEIGHT:
            mapping = RELATIVE_WEIGHT[fweight]
            sweight = int(round(default.weight() * 8 / 100.0) * 100)
            qfont.setWeight(mapping[sweight])

        fsize = font.size
        if fsize in SIZES:
            scale_idx = SIZES[fsize]
            size = app_default.pointSizeF() * SCALE_FACTORS[scale_idx]
            qfont.setPointSizeF(size)
        elif fsize in RELATIVE_SIZES:
            scale = SCALE_FACTORS[RELATIVE_SIZES[fsize]]
            if default.pointSize() < 0:
                size = default.pixelSize() * scale
                qfont.setPixelSize(int(size))
            else:
                size = default.pointSizeF() * scale
                qfont.setPointSizeF(size)
        elif fsize[-1] == '%':
            scale = float(fsize[:-1]) / 100.0
            if default.pointSize() < 0:
                size = default.pixelSize() * scale
                qfont.setPixelSize(int(size))
            else:
                size = default.pointSizeF() * scale
                qfont.setPointSizeF(size)
        else:
            size = float(fsize[:-2])
            converter = UNIT_CONVERTERS[fsize[-2:]]
            qfont.setPointSizeF(converter(size))

        return qfont.resolve(default)


QtGlobalFontCache = QtFontCache()


########NEW FILE########
__FILENAME__ = qt_form
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from .qt_container import QtContainer


class QtForm(QtContainer):
    """ A Qt implementation of an Enaml Form.

    """
    # Currently, the QtContainer superclass is a sufficient implementation.
    pass


########NEW FILE########
__FILENAME__ = qt_group_box
#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
import sys

from .qt.QtCore import Qt, QSize, Signal
from .qt.QtGui import QGroupBox
from .qt_container import QtContainer


QT_ALIGNMENTS = {
    'left': Qt.AlignLeft,
    'right': Qt.AlignRight,
    'center': Qt.AlignHCenter,
}


class QResizingGroupBox(QGroupBox):
    """ A subclass of QGroupBox which behaves like a container.

    """
    #: A signal which is emitted on a resize event.
    resized = Signal()

    #: The internally cached size hint.
    _size_hint = QSize()

    def resizeEvent(self, event):
        """ Converts a resize event into a signal.

        """
        super(QResizingGroupBox, self).resizeEvent(event)
        self.resized.emit()

    def sizeHint(self):
        """ Returns the previously set size hint. If that size hint is
        invalid, the superclass' sizeHint will be used.

        """
        hint = self._size_hint
        if not hint.isValid():
            return super(QResizingGroupBox, self).sizeHint()
        return QSize(hint)

    def setSizeHint(self, hint):
        """ Sets the size hint to use for this widget.

        """
        self._size_hint = QSize(hint)

    def minimumSizeHint(self):
        """ Returns the minimum size hint of the widget.

        The minimum size hint for a QResizingGroupBox is conceptually
        the same as its size hint, so we just return that value.

        """
        return self.sizeHint()


class QtGroupBox(QtContainer):
    """ A Qt implementation of an Enaml GroupBox.

    """
    #--------------------------------------------------------------------------
    # Setup methods
    #--------------------------------------------------------------------------
    def create_widget(self, parent, tree):
        """ Creates the underlying QGroupBox control.

        """
        widget = QResizingGroupBox(parent)
        if sys.platform == 'darwin':
            # On OSX, the widget item layout rect is too small.
            # Setting this attribute forces the widget item to
            # use the widget rect for layout.
            widget.setAttribute(Qt.WA_LayoutUsesWidgetRect, True)
        return widget

    def create(self, tree):
        """ Create and initialize the underlying widget.

        """
        super(QtGroupBox, self).create(tree)
        self.set_title(tree['title'])
        self.set_flat(tree['flat'])
        self.set_title_align(tree['title_align'])

    #--------------------------------------------------------------------------
    # Layout Handling
    #--------------------------------------------------------------------------
    def contents_margins(self):
        """ Get the current contents margins for the group box.

        """
        m = self.widget().contentsMargins()
        return (m.top(), m.right(), m.bottom(), m.left())

    #--------------------------------------------------------------------------
    # Message Handlers
    #--------------------------------------------------------------------------
    def on_action_set_title(self, content):
        """ Handle the 'set_title' action from the Enaml widget.

        """
        widget = self.widget()
        old_margins = widget.contentsMargins()
        self.set_title(content['title'])
        new_margins = widget.contentsMargins()
        if old_margins != new_margins:
            self.contents_margins_updated()

    def on_action_set_title_align(self, content):
        """ Handle the 'set_title_align' action from the Enaml widget.

        """
        self.set_title_align(content['title_align'])

    def on_action_set_flat(self, content):
        """ Handle the 'set_flat' action from the Enaml widget.

        """
        self.set_flat(content['flat'])

    #--------------------------------------------------------------------------
    # Widget Update methods
    #--------------------------------------------------------------------------
    def set_title(self, title):
        """ Updates the title of group box.

        """
        self.widget().setTitle(title)

    def set_flat(self, flat):
        """ Updates the flattened appearance of the group box.

        """
        self.widget().setFlat(flat)

    def set_title_align(self, align):
        """ Updates the alignment of the title of the group box.

        """
        qt_align = QT_ALIGNMENTS[align]
        self.widget().setAlignment(qt_align)


########NEW FILE########
__FILENAME__ = qt_html
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from .qt.QtGui import QTextEdit
from .qt_control import QtControl


class QtHtml(QtControl):
    """ A Qt implementation of an Enaml HTML widget.

    """
    #--------------------------------------------------------------------------
    # Setup Methods
    #--------------------------------------------------------------------------
    def create_widget(self, parent, tree):
        """ Create the underlying html widget.

        """
        widget = QTextEdit(parent)
        widget.setReadOnly(True)
        return widget

    def create(self, tree):
        """ Create and initialize the underlying widget.

        """
        super(QtHtml, self).create(tree)
        self.set_source(tree['source'])

    #--------------------------------------------------------------------------
    # Message Handlers
    #--------------------------------------------------------------------------
    def on_action_set_source(self, content):
        """ Handle the 'set_source' action from the Enaml widget.

        """
        self.set_source(content['source'])

    #--------------------------------------------------------------------------
    # Widget Update Methods
    #--------------------------------------------------------------------------
    def set_source(self, source):
        """ Set the source of the html widget

        """
        self.widget().setHtml(source)


########NEW FILE########
__FILENAME__ = qt_image_view
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
import logging

from .qt.QtGui import QFrame, QPainter, QImage, QPixmap
from .qt_constraints_widget import size_hint_guard
from .qt_control import QtControl


logger = logging.getLogger(__name__)


class QImageView(QFrame):
    """ A custom QFrame that will paint a QPixmap as an image. The
    api is similar to QLabel, but with a few more options to control
    how the image scales.

    """
    def __init__(self, parent=None):
        """ Initialize a QImageView.

        Parameters
        ----------
        parent : QWidget or None, optional
            The parent widget of this image viewer.

        """
        super(QImageView, self).__init__(parent)
        self._pixmap = None
        self._scaled_contents = False
        self._allow_upscaling = False
        self._preserve_aspect_ratio = False

    #--------------------------------------------------------------------------
    # Private API
    #--------------------------------------------------------------------------
    def paintEvent(self, event):
        """ A custom paint event handler which draws the image according
        to the current size constraints.

        """
        pixmap = self._pixmap
        if pixmap is None:
            return

        pm_size = pixmap.size()
        pm_width = pm_size.width()
        pm_height = pm_size.height()
        if pm_width == 0 or pm_height == 0:
            return

        # Use the widget rect instead of the event rect so the image
        # paints properly in a scroll area where it may be clipped.
        evt_rect = self.rect()
        evt_x = evt_rect.x()
        evt_y = evt_rect.y()
        evt_width = evt_rect.width()
        evt_height = evt_rect.height()

        if not self._scaled_contents:
            # If the image isn't scaled, it is centered if possible.
            # Otherwise, it's painted at the origin and clipped.
            paint_x = max(0, int((evt_width / 2. - pm_width / 2.) + evt_x))
            paint_y = max(0, int((evt_height / 2. - pm_height / 2.) + evt_y))
            paint_width = pm_width
            paint_height = pm_height
        else:
            # If the image *is* scaled, it's scaled size depends on the
            # size of the paint area as well as the other scaling flags.
            if self._preserve_aspect_ratio:
                pm_ratio = float(pm_width) / pm_height
                evt_ratio = float(evt_width) / evt_height
                if evt_ratio >= pm_ratio:
                    if self._allow_upscaling:
                        paint_height = evt_height
                    else:
                        paint_height = min(pm_height, evt_height)
                    paint_width = int(paint_height * pm_ratio)
                else:
                    if self._allow_upscaling:
                        paint_width = evt_width
                    else:
                        paint_width = min(pm_width, evt_width)
                    paint_height = int(paint_width / pm_ratio)
            else:
                if self._allow_upscaling:
                    paint_height = evt_height
                    paint_width = evt_width
                else:
                    paint_height = min(pm_height, evt_height)
                    paint_width = min(pm_width, evt_width)
            # In all cases of scaling, we know that the scaled image is
            # no larger than the paint area, and can thus be centered.
            paint_x = int((evt_width / 2. - paint_width / 2.) + evt_x)
            paint_y = int((evt_height / 2. - paint_height / 2.) + evt_y)

        # Finally, draw the pixmap into the calculated rect.
        painter = QPainter(self)
        painter.setRenderHint(QPainter.SmoothPixmapTransform)
        painter.drawPixmap(paint_x, paint_y, paint_width, paint_height, pixmap)

    #--------------------------------------------------------------------------
    # Public API
    #--------------------------------------------------------------------------
    def sizeHint(self):
        """ Returns a appropriate size hint for the image based on the
        underlying QPixmap.

        """
        pixmap = self._pixmap
        if pixmap is not None:
            return pixmap.size()
        return super(QImageView, self).sizeHint()

    def pixmap(self):
        """ Returns the underlying pixmap for the image view.

        """
        return self._pixmap

    def setPixmap(self, pixmap):
        """ Set the pixmap to use as the image in the widget.

        Parameters
        ----------
        pixamp : QPixmap
            The QPixmap to use as the image in the widget.

        """
        self._pixmap  = pixmap
        self.update()

    def scaledContents(self):
        """ Returns whether or not the contents scale with the widget
        size.

        """
        return self._scaled_contents

    def setScaledContents(self, scaled):
        """ Set whether the contents scale with the widget size.

        Parameters
        ----------
        scaled : bool
            If True, the image will be scaled to fit the widget size,
            subject to the other sizing constraints in place. If False,
            the image will not scale and will be clipped as required.

        """
        self._scaled_contents = scaled
        self.update()

    def allowUpscaling(self):
        """ Returns whether or not the image can be scaled greater than
        its natural size.

        """
        return self._allow_upscaling

    def setAllowUpscaling(self, allow):
        """ Set whether or not to allow the image to be scaled beyond
        its natural size.

        Parameters
        ----------
        allow : bool
            If True, then the image may be scaled larger than its
            natural if it is scaled to fit. If False, the image will
            never be scaled larger than its natural size. In either
            case, the image may be scaled smaller.

        """
        self._allow_upscaling = allow
        self.update()

    def preserveAspectRatio(self):
        """ Returns whether or not the aspect ratio of the image is
        maintained during a resize.

        """
        return self._preserve_aspect_ratio

    def setPreserveAspectRatio(self, preserve):
        """ Set whether or not to preserve the image aspect ratio.

        Parameters
        ----------
        preserve : bool
            If True then the aspect ratio of the image will be preserved
            if it is scaled to fit. Otherwise, the aspect ratio will be
            ignored.

        """
        self._preserve_aspect_ratio = preserve
        self.update()


class QtImageView(QtControl):
    """ A Qt implementation of an Enaml ImageView widget.

    """
    #: Temporary internal storage for the image source url.
    _image_source = ''

    #--------------------------------------------------------------------------
    # Setup methods
    #--------------------------------------------------------------------------
    def create_widget(self, parent, tree):
        """ Create the underlying QImageView control.

        """
        return QImageView(parent)

    def create(self, tree):
        """ Create and initialize the underlying control.

        """
        super(QtImageView, self).create(tree)
        self._image_source = tree['source']
        self.set_scale_to_fit(tree['scale_to_fit'])
        self.set_allow_upscaling(tree['allow_upscaling'])
        self.set_preserve_aspect_ratio(tree['preserve_aspect_ratio'])

    def activate(self):
        """ Activate the image view.

        This method will request the initial image source for the
        widget.

        """
        self.set_source(self._image_source)
        super(QtImageView, self).activate()

    #--------------------------------------------------------------------------
    # Message Handlers
    #--------------------------------------------------------------------------
    def on_action_set_source(self, content):
        """ Handle the 'set_source' action from the Enaml widget.

        """
        self.set_source(content['source'])

    def on_action_set_scale_to_fit(self, content):
        """ Handle the 'set_scale_to_fit' action from the Enaml widget.

        """
        self.set_scale_to_fit(content['scale_to_fit'])

    def on_action_set_allow_upscaling(self, content):
        """ Handle the 'set_allow_upscaling' action from the Enaml
        widget.

        """
        self.set_allow_upscaling(content['allow_upscaling'])

    def on_action_set_preserve_aspect_ratio(self, content):
        """ Handle the 'set_preserve_aspect_ratio' action from the
        Enaml widget

        """
        self.set_preserve_aspect_ratio(content['preserve_aspect_ratio'])

    #--------------------------------------------------------------------------
    # Widget Update Methods
    #--------------------------------------------------------------------------
    def set_scale_to_fit(self, scale_to_fit):
        """ Sets whether or not the image scales with the underlying
        control.

        """
        self.widget().setScaledContents(scale_to_fit)

    def set_allow_upscaling(self, allow):
        """ Sets whether or not the image will scale beyond its natural
        size.

        """
        self.widget().setAllowUpscaling(allow)

    def set_preserve_aspect_ratio(self, preserve):
        """ Sets whether or not to preserve the aspect ratio of the
        image when scaling.

        """
        self.widget().setPreserveAspectRatio(preserve)

    def set_source(self, source):
        """ Set the image source for the underlying widget.

        This will trigger a deferred load of the image pointed to by
        the given source url.

        """
        if source:
            loader = self._session.load_resource(source)
            loader.on_load(self._on_image_load)
        else:
            self._on_image_load(QImage())

    #--------------------------------------------------------------------------
    # Private API
    #--------------------------------------------------------------------------
    def _on_image_load(self, image):
        """ A private resource loader callback.

        This method is invoked when the requested image is successfully
        loaded. It will update the image in the image view widget and
        issue a size hint updated event to the layout system if needed.

        Parameters
        ----------
        image : QImage
            The QImage that was loaded by the resource request.

        """
        if not isinstance(image, QImage):
            msg = 'got incorrect type for image: `%s`'
            logger.error(msg % type(image).__name__)
            image = QImage()
        with size_hint_guard(self):
            self.widget().setPixmap(QPixmap.fromImage(image))


########NEW FILE########
__FILENAME__ = qt_label
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from .qt.QtCore import Qt
from .qt.QtGui import QLabel
from .qt_constraints_widget import size_hint_guard
from .qt_control import QtControl


ALIGN_MAP = {
    'left': Qt.AlignLeft,
    'right': Qt.AlignRight,
    'center': Qt.AlignHCenter,
    'justify': Qt.AlignJustify,
}


VERTICAL_ALIGN_MAP = {
    'top': Qt.AlignTop,
    'bottom': Qt.AlignBottom,
    'center': Qt.AlignVCenter,
}


class QtLabel(QtControl):
    """ A Qt implementation of an Enaml Label.

    """
    #--------------------------------------------------------------------------
    # Setup Methods
    #--------------------------------------------------------------------------
    def create_widget(self, parent, tree):
        """ Create the underlying label widget.

        """
        return QLabel(parent)

    def create(self, tree):
        """ Create and initialize the underlying widget.

        """
        super(QtLabel, self).create(tree)
        self.set_text(tree['text'])
        self.set_align(tree['align'])
        self.set_vertical_align(tree['vertical_align'])

    #--------------------------------------------------------------------------
    # Message Handlers
    #--------------------------------------------------------------------------
    def on_action_set_text(self, content):
        """ Handle the 'set_text' action from the Enaml widget.

        """
        with size_hint_guard(self):
            self.set_text(content['text'])

    def on_action_set_align(self, content):
        """ Handle the 'set_align' action from the Enaml widget.

        """
        self.set_align(content['align'])

    def on_action_set_vertical_align(self, content):
        """ Handle the 'set_vertical_align' action from the Enaml widget.

        """
        self.set_vertical_align(content['vertical_align'])

    #--------------------------------------------------------------------------
    # Widget Update Methods
    #--------------------------------------------------------------------------
    def set_text(self, text):
        """ Set the text in the underlying widget.

        """
        self.widget().setText(text)

    def set_align(self, align):
        """ Set the alignment of the text in the underlying widget.

        """
        widget = self.widget()
        alignment = widget.alignment()
        alignment &= ~Qt.AlignHorizontal_Mask
        alignment |= ALIGN_MAP[align]
        widget.setAlignment(alignment)

    def set_vertical_align(self, align):
        """ Set the vertical alignment of the text in the underlying
        widget.

        """
        widget = self.widget()
        alignment = widget.alignment()
        alignment &= ~Qt.AlignVertical_Mask
        alignment |= VERTICAL_ALIGN_MAP[align]
        widget.setAlignment(alignment)


########NEW FILE########
__FILENAME__ = qt_list_control
#------------------------------------------------------------------------------
#  Copyright (c) 2013, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from .qt.QtCore import QSize
from .qt.QtGui import QListWidget
from .qt_control import QtControl
from .qt_list_item import QtListItem


VIEW_MODES = {
    'list': QListWidget.ListMode,
    'icon': QListWidget.IconMode,
}


RESIZE_MODES = {
    'adjust': QListWidget.Adjust,
    'fixed': QListWidget.Fixed,
}


FLOW_MODES = {
    'left_to_right': QListWidget.LeftToRight,
    'top_to_bottom': QListWidget.TopToBottom,
}


LAYOUT_MODES = {
    'single_pass': QListWidget.SinglePass,
    'batched': QListWidget.Batched,
}


class QtListControl(QtControl):
    """ A Qt implementation of an Enaml ListControl.

    """
    def create_widget(self, parent, tree):
        """ Create the underlying widget.

        """
        # XXX we may want to consider using a QListView with a custom
        # QAbstractListModel, rather than QListWidget. This way maps
        # nicely to the tree structure, but may use more memory than
        # is needed.
        return QListWidget(parent)

    def create(self, tree):
        """ Create and initialize the underlying control.

        """
        super(QtListControl, self).create(tree)
        self.set_view_mode(tree['view_mode'])
        self.set_resize_mode(tree['resize_mode'])
        self.set_flow_mode(tree['flow_mode'])
        self.set_item_wrap(tree['item_wrap'])
        self.set_word_wrap(tree['word_wrap'])
        self.set_item_spacing(tree['item_spacing'])
        self.set_icon_size(tree['icon_size'])
        self.set_uniform_item_sizes(tree['uniform_item_sizes'])
        self.set_layout_mode(tree['layout_mode'])
        self.set_batch_size(tree['batch_size'])

    def init_layout(self):
        """ Initialize the layout of the underlying control.

        """
        super(QtListControl, self).init_layout()
        widget = self.widget()
        for child in self.children():
            if isinstance(child, QtListItem):
                widget.addItem(child.create_item())
                child.initialize_item()

        # Late-bind the signal handlers to avoid doing any unnecessary
        # work while the child items are being intialized.
        widget.itemChanged.connect(self.on_item_changed)
        widget.itemClicked.connect(self.on_item_clicked)
        widget.itemDoubleClicked.connect(self.on_item_double_clicked)

    #--------------------------------------------------------------------------
    # Child Events
    #--------------------------------------------------------------------------
    def child_removed(self, child):
        """ Handle the child removed event for a QtListControl.

        """
        if not self._destroying and isinstance(child, QtListItem):
            widget = self.widget()
            item = child.item()
            if item is not None:
                row = widget.row(item)
                widget.takeItem(row)

    def child_added(self, child):
        """ Handle the child added event for a QtListControl.

        """
        if isinstance(child, QtListItem):
            row = self.index_of(child)
            item = child.create_item()
            self.widget().insertItem(row, item)
            child.initialize_item()

    #--------------------------------------------------------------------------
    # Signal Handlers
    #--------------------------------------------------------------------------
    def on_item_changed(self, item):
        """ The signal handler for the `itemChanged` signal.

        This handler forwards the call to the item that was changed.

        """
        owner = getattr(item, 'item_owner', None)
        if owner is not None:
            owner.on_changed()

    def on_item_clicked(self, item):
        """ The signal handler for the `itemClicked` signal.

        This handler forwards the call to the item that was clicked.

        """
        owner = getattr(item, 'item_owner', None)
        if owner is not None:
            owner.on_clicked()

    def on_item_double_clicked(self, item):
        """ The signal handler for the `itemDoubleClicked` signal.

        This handler forwards the call to the item that was clicked.

        """
        owner = getattr(item, 'item_owner', None)
        if owner is not None:
            owner.on_double_clicked()

    #--------------------------------------------------------------------------
    # Message Handlers
    #--------------------------------------------------------------------------
    def on_action_refresh_items_layout(self, content):
        """ Handle the 'refresh_items_layout' action from the Enaml
        widget.

        """
        self.widget().scheduleDelayedItemsLayout()

    def on_action_set_view_mode(self, content):
        """ Handle the 'set_view_mode' action from the Enaml widget.

        """
        self.set_view_mode(content['view_mode'])

    def on_action_set_resize_mode(self, content):
        """ Handle the 'set_resize_mode' action from the Enaml widget.

        """
        self.set_resize_mode(content['resize_mode'])

    def on_action_set_flow_mode(self, content):
        """ Handle the 'set_flow_mode' action from the Enaml widget.

        """
        self.set_flow_mode(content['flow_mode'])

    def on_action_set_item_wrap(self, content):
        """ Handle the 'set_item_wrap' action from the Enaml widget.

        """
        self.set_item_wrap(content['item_wrap'])

    def on_action_set_word_wrap(self, content):
        """ Handle the 'set_word_wrap' action from the Enaml widget.

        """
        self.set_word_wrap(content['word_wrap'])

    def on_action_set_item_spacing(self, content):
        """ Handle the 'set_item_spacing' action from the Enaml widget.

        """
        self.set_item_spacing(content['item_spacing'])

    def on_action_set_icon_size(self, content):
        """ Handle the 'set_icon_size' action from the Enaml widget.

        """
        self.set_icon_size(content['icon_size'])

    def on_action_set_uniform_item_sizes(self, content):
        """ Handle the 'set_uniform_item_sizes' action from the Enaml
        widget.

        """
        self.set_uniform_item_sizes(content['uniform_item_sizes'])

    def on_action_set_layout_mode(self, content):
        """ Handle the 'set_layout_mode' action from the Enaml widget.

        """
        self.set_layout_mode(content['layout_mode'])

    def on_action_set_batch_size(self, content):
        """ Handle the 'set_batch_size' action from the Enaml widget.

        """
        self.set_batch_size(content['batch_size'])

    #--------------------------------------------------------------------------
    # Widget Update Methods
    #--------------------------------------------------------------------------
    def set_view_mode(self, mode):
        """ Set the view mode of the underlying control.

        """
        # Always set static movement for now. This can be revisited in
        # the future if the need arises to support movable items.
        widget = self.widget()
        widget.setViewMode(VIEW_MODES[mode])
        widget.setMovement(QListWidget.Static)

    def set_resize_mode(self, mode):
        """ Set the resize mode of the underlying control.

        """
        self.widget().setResizeMode(RESIZE_MODES[mode])

    def set_flow_mode(self, mode):
        """ Set the flow mode of the underlying control.

        """
        widget = self.widget()
        if mode == 'default':
            if widget.viewMode() == QListWidget.ListMode:
                qflow = QListWidget.TopToBottom
            else:
                qflow = QListWidget.LeftToRight
        else:
            qflow = FLOW_MODES[mode]
        widget.setFlow(qflow)

    def set_item_wrap(self, wrap):
        """ Set the item wrapping on the underlying control.

        """
        widget = self.widget()
        if wrap is None:
            wrap = widget.viewMode() == QListWidget.IconMode
        widget.setWrapping(wrap)

    def set_word_wrap(self, wrap):
        """ Set the word wrap on the underlying control.

        """
        self.widget().setWordWrap(wrap)

    def set_item_spacing(self, spacing):
        """ Set the item spacing on the underlying control.

        """
        self.widget().setSpacing(spacing)

    def set_icon_size(self, size):
        """ Set the icon size on the underlying control.

        """
        self.widget().setIconSize(QSize(*size))

    def set_uniform_item_sizes(self, uniform):
        """ Set the uniform item sizes flag on the underlying control.

        """
        self.widget().setUniformItemSizes(uniform)

    def set_layout_mode(self, mode):
        """ Set the layout mode on the underlying control.

        """
        self.widget().setLayoutMode(LAYOUT_MODES[mode])

    def set_batch_size(self, size):
        """ Set the batch size on the underlying control.

        """
        self.widget().setBatchSize(size)


########NEW FILE########
__FILENAME__ = qt_list_item
#------------------------------------------------------------------------------
#  Copyright (c) 2013, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
import logging

from enaml.colors import parse_color

from .qt.QtCore import Qt, QSize
from .qt.QtGui import QListWidgetItem, QColor, QIcon, QPixmap, QImage
from .qt_font_utils import QtFontCache
from .qt_object import QtObject


logger = logging.getLogger(__name__)


HORIZONTAL_ALIGN = {
    'left': Qt.AlignLeft,
    'right': Qt.AlignRight,
    'center': Qt.AlignHCenter,
    'justify': Qt.AlignJustify,
}


VERTICAL_ALIGN = {
    'top': Qt.AlignTop,
    'bottom': Qt.AlignBottom,
    'center': Qt.AlignVCenter,
}


CHECKED_STATE = {
    None: None,
    True: Qt.Checked,
    False: Qt.Unchecked,
    Qt.Checked: True,
    Qt.Unchecked: False,
}


class QtListItem(QtObject):
    """ A Qt implementation of an Enaml ListItem.

    """
    # Temporary internal storage for the icon source.
    _icon_source = None

    #--------------------------------------------------------------------------
    # Setup Methods
    #--------------------------------------------------------------------------
    def create_widget(self, parent, tree):
        """ Create the underlying widget.

        """
        # QListWidgetItem is not a QObject and is therefore not used as
        # a widget for this item. The creation of the item is performed
        # explicitly during the parent layout pass.
        self._tree = tree
        self._item = None
        return None

    def create_item(self):
        """ A method called by the parent QtListControl.

        This method is called during the parent layout pass to allow
        the QListWidgetItem to be created. The returned item will be
        uninitialized.

        Returns
        -------
        return : QListWidgetItem
            The uninitialized QListWidgetItem owned by this object.

        """
        # The `item_owner` ref is used by the parent QtListControl
        # to route signals generated by an item back to the QtListItem
        # which owns the underlying widget item.
        self._item = QListWidgetItem()
        self._item.item_owner = self
        return self._item

    def initialize_item(self):
        """ A method called by the parent QtListControl.

        This method is called during the parent layout pass to allow
        the QListWidgetItem to be initialized.

        """
        tree = self._tree
        self._tree = None
        self.set_text(tree['text'])
        self.set_tool_tip(tree['tool_tip'])
        self.set_status_tip(tree['status_tip'])
        self.set_background(tree['background'])
        self.set_foreground(tree['foreground'])
        self.set_font(tree['font'])
        self.set_checkable(tree['checkable'])
        self.set_selectable(tree['selectable'])
        self.set_checked(tree['checked'])
        self.set_selected(tree['selected'])
        self.set_editable(tree['editable'])
        self.set_enabled(tree['enabled'])
        self.set_visible(tree['visible'])
        self.set_text_align(tree['text_align'])
        self.set_vertical_text_align(tree['vertical_text_align'])
        self.set_preferred_size(tree['preferred_size'])
        icon = tree['icon_source']
        if icon:
            # Only create the instance attribute if it's not null.
            # This helps save memory when the number of items is large.
            self._icon_source = icon

    def activate(self):
        """ Activate the underlying item.

        """
        super(QtListItem, self).activate()
        self.set_icon_source(self._icon_source)

    #--------------------------------------------------------------------------
    # Public API
    #--------------------------------------------------------------------------
    def item(self):
        """ Get the widget item associated with this object.

        Returns
        -------
        result : QListWidgetItem or None
            The widget item for this object, or None if the object
            has no widget.

        """
        return self._item

    def destroy(self):
        """ A reimplemented destructor method.

        This method clears the item reference and removes the circular
        reference to the owner item.

        """
        super(QtListItem, self).destroy()
        item = self._item
        if item is not None:
            item.item_owner = None
            self._item = None

    #--------------------------------------------------------------------------
    # Signal Handlers
    #--------------------------------------------------------------------------
    def on_changed(self):
        """ A handler called by the parent list widget from within the
        `itemChanged` signal handler.

        """
        if 'changed' not in self.loopback_guard:
            text = self._item.data(Qt.DisplayRole)
            state = self._item.data(Qt.CheckStateRole)
            content = {'text': text, 'checked': CHECKED_STATE[state]}
            self.send_action('changed', content)

    def on_clicked(self):
        """ A handler called by the parent list widget from within the
        `itemClicked` signal handler.

        """
        self.send_action('clicked', {})

    def on_double_clicked(self):
        """ A handler called by the parent list widget from within the
        `itemDoubleClicked` signal handler.

        """
        self.send_action('double_clicked', {})

    #--------------------------------------------------------------------------
    # Message Handling
    #--------------------------------------------------------------------------
    def on_action_set_text(self, content):
        """ Handle the 'set_text' action from the Enaml item.

        """
        self.set_text(content['text'])

    def on_action_set_tool_tip(self, content):
        """ Handle the 'set_tool_tip' action from the Enaml item.

        """
        self.set_tool_tip(content['tool_tip'])

    def on_action_set_status_tip(self, content):
        """ Handle the 'set_status_tip' action from the Enaml item.

        """
        self.set_status_tip(content['status_tip'])

    def on_action_set_background(self, content):
        """ Handle the 'set_background' action from the Enaml item.

        """
        self.set_background(content['background'])

    def on_action_set_foreground(self, content):
        """ Handle the 'set_foreground' action from the Enaml item.

        """
        self.set_foreground(content['foreground'])

    def on_action_set_font(self, content):
        """ Handle the 'set_font' action from the Enaml item.

        """
        self.set_font(content['font'])

    def on_action_set_icon_source(self, content):
        """ Handle the 'set_icon_source' action from the Enaml item.

        """
        self.set_icon_source(content['icon_source'])

    def on_action_set_checkable(self, content):
        """ Handle the 'set_checkable' action from the Enaml item.

        """
        self.set_checkable(content['checkable'])

    def on_action_set_selectable(self, content):
        """ Handle the 'set_selectable' action from the Enaml item.

        """
        self.set_selectable(content['selectable'])

    def on_action_set_checked(self, content):
        """ Handle the 'set_checked' action from the Enaml item.

        """
        self.set_checked(content['checked'])

    def on_action_set_selected(self, content):
        """ Handle the 'set_selected' action from the Enaml item.

        """
        self.set_selected(content['selected'])

    def on_action_set_editable(self, content):
        """ Handle the 'set_editable' action from the Enaml item.

        """
        self.set_editable(content['editable'])

    def on_action_set_enabled(self, content):
        """ Handle the 'set_enabled' action from the Enaml item.

        """
        self.set_enabled(content['enabled'])

    def on_action_set_visible(self, content):
        """ Handle the 'set_visible' action from the Enaml item.

        """
        self.set_visible(content['visible'])

    def on_action_set_text_align(self, content):
        """ Handle the 'set_text_align' action from the Enaml item.

        """
        self.set_text_align(content['text_align'])

    def on_action_set_vertical_text_align(self, content):
        """ Handle the 'set_vertical_text_align' action from the Enaml
        item.

        """
        self.set_vertical_text_align(content['vertical_text_align'])

    def on_action_set_preferred_size(self, content):
        """ Handle the 'set_preferred_size' action from the Enaml item.

        """
        self.set_preferred_size(content['preferred_size'])

    #--------------------------------------------------------------------------
    # Widget Update Methods
    #--------------------------------------------------------------------------
    # Note: Qt's abstract item views handle invalid QVariants differently
    # than they handle an invalid value of a particular type. The code in
    # these setters therefore sets the data using roles instead of the
    # more convenient setter methods. Every data change is guarded to
    # prevent loopback for a change that was not initiated by the user.

    def set_text(self, text):
        """ Set the text for the list item.

        """
        with self.loopback_guard('changed'):
            self._item.setData(Qt.DisplayRole, text or None)

    def set_tool_tip(self, tool_tip):
        """ Set the tool tip for the list item.

        """
        with self.loopback_guard('changed'):
            self._item.setData(Qt.ToolTipRole, tool_tip or None)

    def set_status_tip(self, status_tip):
        """ Set the status tip for the list item.

        """
        with self.loopback_guard('changed'):
            self._item.setData(Qt.StatusTipRole, status_tip or None)

    def set_background(self, background):
        """ Set the background color for the list item.

        """
        qcolor = None
        if background:
            color = parse_color(background)
            if color is not None:
                qcolor = QColor.fromRgbF(*color)
        with self.loopback_guard('changed'):
            self._item.setData(Qt.BackgroundRole, qcolor)

    def set_foreground(self, foreground):
        """ Set the foreground color for the list item.

        """
        qcolor = None
        if foreground:
            color = parse_color(foreground)
            if color is not None:
                qcolor = QColor.fromRgbF(*color)
        with self.loopback_guard('changed'):
            self._item.setData(Qt.ForegroundRole, qcolor)

    def set_font(self, font):
        """ Set the font for the list item.

        """
        item = self._item
        if not font:
            if item.data(Qt.FontRole) is not None:
                item.setData(Qt.FontRole, None)
        else:
            # XXX this may warrant more work
            parent = self.parent()
            cache = getattr(parent, '_items_font_cache', None)
            if cache is None:
                pfont = parent.widget().font()
                cache = parent._items_font_cache = QtFontCache(pfont)
            item.setData(Qt.FontRole, cache[font])

    def set_icon_source(self, icon_source):
        """ Set the icon source for the list item.

        """
        if icon_source:
            loader = self._session.load_resource(icon_source)
            loader.on_load(self._on_icon_load)
        else:
            with self.loopback_guard('changed'):
                self._item.setData(Qt.DecorationRole, None)

    def set_checkable(self, checkable):
        """ Set the checkable state for the list item.

        """
        self._set_item_flag(Qt.ItemIsUserCheckable, checkable)

    def set_selectable(self, selectable):
        """ Set the selectable state for the list item.

        """
        self._set_item_flag(Qt.ItemIsSelectable, selectable)

    def set_checked(self, checked):
        """ Set the checked state for the list item.

        """
        with self.loopback_guard('changed'):
            self._item.setData(Qt.CheckStateRole, CHECKED_STATE[checked])

    def set_selected(self, selected):
        """ Set the selected state for the list item.

        """
        # Note that the item must be parented for this to have effect.
        self._item.setSelected(selected)

    def set_editable(self, editable):
        """ Set the editable state for the list item.

        """
        self._set_item_flag(Qt.ItemIsEditable, editable)

    def set_enabled(self, enabled):
        """ Set the enabled state for the list item.

        """
        self._set_item_flag(Qt.ItemIsEnabled, enabled)

    def set_visible(self, visible):
        """ Set the visible state for the list item.

        """
        # Note that the item must be parented for this to have effect.
        self._item.setHidden(not visible)

    def set_text_align(self, align):
        """ Set the horizontal text alignment for the list item.

        """
        # Use the convenience getter and setters instead of the `data`
        # method, since the latter is broken on PySide; likely to do
        # with its conversion of the align flag into a QVariant.
        item = self._item
        flags = item.textAlignment()
        flags &= ~Qt.AlignHorizontal_Mask
        flags |= HORIZONTAL_ALIGN[align]
        with self.loopback_guard('changed'):
            item.setTextAlignment(flags)

    def set_vertical_text_align(self, align):
        """ Set the vertical text alignment for the list item.

        """
        # Use the convenience getter and setters instead of the `data`
        # method, since the latter is broken on PySide; likely to do
        # with its conversion of the align flag into a QVariant.
        item = self._item
        flags = item.textAlignment()
        flags &= ~Qt.AlignVertical_Mask
        flags |= VERTICAL_ALIGN[align]
        with self.loopback_guard('changed'):
            item.setTextAlignment(flags)

    def set_preferred_size(self, preferred_size):
        """ Set the preferred size for the list item.

        """
        size = QSize(*preferred_size)
        if not size.isValid():
            size = None
        with self.loopback_guard('changed'):
            self._item.setData(Qt.SizeHintRole, size)

    #--------------------------------------------------------------------------
    # Private API
    #--------------------------------------------------------------------------
    def _set_item_flag(self, flag, enabled):
        """ Set or unset the given item flag for the item.

        """
        item = self._item
        flags = item.flags()
        if enabled:
            flags |= flag
        else:
            flags &= ~flag
        with self.loopback_guard('changed'):
            item.setFlags(flags)

    def _on_icon_load(self, icon):
        """ A private resource loader callback.

        This method is invoked when the requested icon is successfully
        loaded. It will update the icon on the item.

        Parameters
        ----------
        icon : QIcon or QImage
            The icon or image that was loaded by the request.

        """
        if isinstance(icon, QImage):
            icon = QIcon(QPixmap.fromImage(icon))
        elif not isinstance(icon, QIcon):
            msg = 'got incorrect type for icon: `%s`'
            logger.error(msg % type(icon).__name__)
            icon = None
        with self.loopback_guard('changed'):
            self._item.setData(Qt.DecorationRole, icon)


########NEW FILE########
__FILENAME__ = qt_main_window
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
import sys

from .qt.QtCore import Qt, Signal
from .qt.QtGui import QMainWindow
from .q_deferred_caller import deferredCall
from .qt_container import QtContainer
from .qt_dock_pane import QtDockPane
from .qt_menu_bar import QtMenuBar
from .qt_tool_bar import QtToolBar
from .qt_window import QtWindow


class QCustomMainWindow(QMainWindow):
    """ A custom QMainWindow which adds some Enaml specific features.

    """
    #: A signal emitted when the window is closed by the user
    closed = Signal()

    #--------------------------------------------------------------------------
    # Private API
    #--------------------------------------------------------------------------
    def closeEvent(self, event):
        """ A close event handler which emits the 'closed' signal.

        """
        super(QCustomMainWindow, self).closeEvent(event)
        self.closed.emit()

    #--------------------------------------------------------------------------
    # Public API
    #--------------------------------------------------------------------------
    def setDockWidgetArea(self, area, dock_widget):
        """ Set the dock area for the given dock widget.

        If the dock widget has not been added to the main window, this
        method is a no-op.

        Parameters
        ----------
        area : QDockWidgetArea
            The dock area to use for the widget.

        dock_widget : QDockWidget
            The dock widget to move to the given area.

        """
        curr = self.dockWidgetArea(dock_widget)
        if curr != Qt.NoDockWidgetArea:
            if curr != area:
                visible = dock_widget.isVisible()
                self.removeDockWidget(dock_widget)
                self.addDockWidget(area, dock_widget)
                dock_widget.setVisible(visible)

    def setToolBarArea(self, area, tool_bar):
        """ Set the tool bar area for the given tool bar.

        If the tool bar has not been added to the main window, this
        method is a no-op.

        Parameters
        ----------
        area : QToolBarArea
            The tool bar area to use for the widget.

        tool_bar : QToolBar
            The tool bar to move to the given area.

        """
        curr = self.toolBarArea(tool_bar)
        if curr != Qt.NoToolBarArea:
            if curr != area:
                visible = tool_bar.isVisible()
                floating = tool_bar.isFloating()
                tool_bar.setVisible(False)
                self.removeToolBar(tool_bar)
                self.addToolBar(area, tool_bar)
                tool_bar.resize(tool_bar.sizeHint())
                tool_bar.setFloating(floating)
                tool_bar.setVisible(visible)


class QtMainWindow(QtWindow):
    """ A Qt implementation of an Enaml MainWindow.

    """
    #: A private flag used to track the visible state changes sent from
    #: the Enaml widget. This is needed on OSX when dynamically adding
    #: a tool bar in order to work around a visibility bug in Qt.
    _visible_hint = False

    #--------------------------------------------------------------------------
    # Setup Methods
    #--------------------------------------------------------------------------
    def create_widget(self, parent, tree):
        """ Create the underlying widget QMainWindow widget.

        """
        widget = QCustomMainWindow(parent)
        widget.setDocumentMode(True)
        widget.setDockNestingEnabled(True)
        return widget

    def init_layout(self):
        """ Initialize the layout for the underlying widget.

        """
        # The superclass' init_layout() method is explicitly not called
        # since the layout initialization for Window is not appropriate
        # for MainWindow.
        main_window = self.widget()
        components = self.components()
        main_window.setMenuBar(components['menu_bar'])
        main_window.setCentralWidget(components['central_widget'])
        for dpane in components['dock_panes']:
            main_window.addDockWidget(dpane.dockArea(), dpane)
        for tbar in components['tool_bars']:
            # XXX slight hack. When adding the toolbar to the main
            # window, it is forcibly unfloated. In order for the
            # initial floating state to be maintained, it must be
            # re-floating after being added. We do the refloating
            # in the future, so that the main window shows up first.
            floating = tbar.isFloating()
            main_window.addToolBar(tbar.toolBarArea(), tbar)
            if floating:
                deferredCall(tbar.setFloating, True)

    #--------------------------------------------------------------------------
    # Utility Methods
    #--------------------------------------------------------------------------
    def components(self):
        """ Get a dictionary of the main window components.

        Returns
        -------
        result : dict
            A dicionary of main window components categorized by their
            function.

        """
        d = {
            'central_widget': None, 'menu_bar': None,
            'tool_bars': [], 'dock_panes': [],
        }
        for child in self.children():
            if isinstance(child, QtDockPane):
                d['dock_panes'].append(child.widget())
            elif isinstance(child, QtToolBar):
                d['tool_bars'].append(child.widget())
            elif isinstance(child, QtMenuBar):
                d['menu_bar'] = child.widget()
            elif isinstance(child, QtContainer):
                d['central_widget'] = child.widget()
        return d

    #--------------------------------------------------------------------------
    # Child Events
    #--------------------------------------------------------------------------
    def child_removed(self, child):
        """ Handle the child removed event for a QtMainWindow.

        """
        main_window = self.widget()
        if isinstance(child, QtDockPane):
            main_window.removeDockWidget(child.widget())
        elif isinstance(child, QtToolBar):
            main_window.removeToolBar(child.widget())
        elif isinstance(child, QtContainer):
            components = self.components()
            main_window.setCentralWidget(components['central_widget'])
        elif isinstance(child, QtMenuBar):
            components = self.components()
            main_window.setMenuBar(components['menu_bar'])

    def child_added(self, child):
        """ Handle the child added event for a QtMainWindow.

        """
        main_window = self.widget()
        if isinstance(child, QtMenuBar):
            components = self.components()
            main_window.setMenuBar(components['menu_bar'])
        elif isinstance(child, QtContainer):
            components = self.components()
            main_window.setCentralWidget(components['central_widget'])
        elif isinstance(child, QtDockPane):
            dock_widget = child.widget()
            main_window.addDockWidget(dock_widget.dockArea(), dock_widget)
        elif isinstance(child, QtToolBar):
            # There are two hacks involved in adding a tool bar. The
            # first is the same hack that is perfomed in the layout
            # method for a floating tool bar. The second is specific
            # to OSX. On that platform, adding a tool bar to main
            # window which is already visible but does not have any
            # current tool bars will cause the main window to be hidden.
            # This will only occur the *first* time a tool bar is added
            # to the window. The hack below is workaround which should
            # be sufficient for most use cases. A bug should really be
            # filed against Qt for this one, since it's reproducible
            # outside of Enaml.
            bar_widget = child.widget()
            reshow = False
            if sys.platform == 'darwin':
                reshow = self._visible_hint and not main_window.isVisible()
            floating = bar_widget.isFloating()
            main_window.addToolBar(bar_widget.toolBarArea(), bar_widget)
            if floating:
                deferredCall(bar_widget.setFloating, True)
            if reshow:
                main_window.setVisible(True)

    #--------------------------------------------------------------------------
    # Widget Update Methods
    #--------------------------------------------------------------------------
    def set_visible(self, visible):
        """ Set the visibility of the underlying control.

        This is an overridden parent class method which keeps track of
        the visible flag set by the Enaml widget.

        """
        self._visible_hint = visible
        super(QtMainWindow, self).set_visible(visible)


########NEW FILE########
__FILENAME__ = qt_mdi_area
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from .qt.QtGui import QMdiArea
from .qt_constraints_widget import QtConstraintsWidget
from .qt_mdi_window import QtMdiWindow


class QtMdiArea(QtConstraintsWidget):
    """ A Qt implementation of an Enaml MdiArea.

    """
    #--------------------------------------------------------------------------
    # Setup Methods
    #--------------------------------------------------------------------------
    def create_widget(self, parent, tree):
        """ Create the underlying QMdiArea widget.

        """
        return QMdiArea(parent)

    def init_layout(self):
        """ Initialize the layout for the underlying control.

        """
        super(QtMdiArea, self).init_layout()
        widget = self.widget()
        for child in self.children():
            if isinstance(child, QtMdiWindow):
                widget.addSubWindow(child.widget())

    #--------------------------------------------------------------------------
    # Child Events
    #--------------------------------------------------------------------------
    def child_removed(self, child):
        """ Handle the child removed event for a QtMdiArea.

        """
        if isinstance(child, QtMdiWindow):
            self.widget().removeSubWindow(child.widget())

    def child_added(self, child):
        """ Handle the child added event for a QtMdiArea.

        """
        # The size hint of a QMdiArea is typically quite large and the
        # size hint constraints are usually ignored. There is no need
        # to notify of a change in size hint here.
        if isinstance(child, QtMdiWindow):
            self.widget().addSubWindow(child.widget())


########NEW FILE########
__FILENAME__ = qt_mdi_window
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from .qt.QtGui import QMdiSubWindow, QLayout
from .qt_widget import QtWidget


class QtMdiWindow(QtWidget):
    """ A Qt implementation of an Enaml MdiWindow.

    """
    #--------------------------------------------------------------------------
    # Setup Methods
    #--------------------------------------------------------------------------
    def create_widget(self, parent, tree):
        """ Create the underlying QMdiSubWindow widget.

        """
        # We don't parent the subwindow immediately. It will be added
        # explicitly by the parent QMdiArea during its layout pass.
        # If we set the parent here, Qt will spit out warnings when
        # it's set added to the area later on. We *could* parent it
        # here, and simply not add it explicitly to the mdi area, but
        # this way is more explicit and consistent with the rest of
        # the framework.
        widget = QMdiSubWindow()
        widget.layout().setSizeConstraint(QLayout.SetMinAndMaxSize)
        return widget

    def init_layout(self):
        """ Initialize the layout for the underlying control.

        """
        super(QtMdiWindow, self).init_layout()
        self._set_window_widget(self.mdi_widget())

    #--------------------------------------------------------------------------
    # Utility Methods
    #--------------------------------------------------------------------------
    def mdi_widget(self):
        """ Find and return the mdi widget child for this widget.

        Returns
        -------
        result : QWidget or None
            The mdi widget defined for this widget, or None if one is
            not defined.

        """
        widget = None
        for child in self.children():
            if isinstance(child, QtWidget):
                widget = child.widget()
        return widget

    #--------------------------------------------------------------------------
    # Child Events
    #--------------------------------------------------------------------------
    def child_removed(self, child):
        """ Handle the child removed event for a QtMdiWindow.

        """
        if isinstance(child, QtWidget):
            self._set_window_widget(self.mdi_widget())

    def child_added(self, child):
        """ Handle the child added event for a QtMdiWindow.

        """
        if isinstance(child, QtWidget):
            self._set_window_widget(self.mdi_widget())

    #--------------------------------------------------------------------------
    # Private API
    #--------------------------------------------------------------------------
    def _set_window_widget(self, mdi_widget):
        """ A private method which set the child widget on the window.

        Parameters
        ----------
        mdi_widget : QWidget
            The child widget to use in the mdi window.

        """
        # We need to first set the window widget to None, or Qt will
        # complain if a widget is already set on the window.
        widget = self.widget()
        widget.setWidget(None)
        if mdi_widget is None:
            return
        # We need to unparent the underlying widget before adding
        # it to the subwindow. Otherwise, children like QMainWindow
        # will persist as top-level non-mdi widgets.
        mdi_widget.setParent(None)
        widget.setWidget(mdi_widget)
        # On OSX, the resize gripper will be obscured unless we
        # lower the widget in the window's stacking order.
        mdi_widget.lower()


########NEW FILE########
__FILENAME__ = qt_menu
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from .qt.QtCore import Qt
from .qt.QtGui import QMenu
from .qt_action import QtAction
from .qt_action_group import QtActionGroup
from .qt_widget import QtWidget


class QCustomMenu(QMenu):
    """ A custom subclass of QMenu which adds some convenience apis.

    """
    def __init__(self, *args, **kwargs):
        """ Initialize a QCustomMenu.

        Parameters
        ----------
        *args, **kwargs
            The positional and keyword arguments needed to initialize
            a QMenu.

        """
        super(QCustomMenu, self).__init__(*args, **kwargs)
        self._is_context_menu = False

    #--------------------------------------------------------------------------
    # Private API
    #--------------------------------------------------------------------------
    def _onShowContextMenu(self, pos):
        """ A private signal handler for displaying the context menu.

        This handler is connected to the context menu requested signal
        on the parent widget when this menu is marked as a context
        menu.

        """
        parent = self.parentWidget()
        if parent is not None:
            global_pos = parent.mapToGlobal(pos)
            self.exec_(global_pos)

    #--------------------------------------------------------------------------
    # Public API
    #--------------------------------------------------------------------------
    def isContextMenu(self):
        """ Whether this menu acts as a context menu for its parent.

        Returns
        -------
        result : bool
            True if this menu acts as a context menu, False otherwise.

        """
        return self._is_context_menu

    def setContextMenu(self, context):
        """ Set whether this menu acts as a context menu for its parent.

        Parameters
        ----------
        context : bool
            True if this menu should act as a context menu, False
            otherwise.

        """
        old_context = self._is_context_menu
        self._is_context_menu = context
        if old_context != context:
            parent = self.parentWidget()
            if parent is not None:
                handler = self._onShowContextMenu
                if context:
                    parent.setContextMenuPolicy(Qt.CustomContextMenu)
                    parent.customContextMenuRequested.connect(handler)
                else:
                    parent.setContextMenuPolicy(Qt.DefaultContextMenu)
                    parent.customContextMenuRequested.disconnect(handler)

    def removeActions(self, actions):
        """ Remove the given actions from the menu.

        Parameters
        ----------
        actions : iterable
            An iterable of QActions to remove from the menu.

        """
        remove = self.removeAction
        for action in actions:
            remove(action)


class QtMenu(QtWidget):
    """ A Qt implementation of an Enaml Menu.

    """
    #--------------------------------------------------------------------------
    # Setup Methods
    #--------------------------------------------------------------------------
    def create_widget(self, parent, tree):
        """ Create the underlying menu widget.

        """
        return QCustomMenu(parent)

    def create(self, tree):
        """ Create and initialize the underlying widget.

        """
        super(QtMenu, self).create(tree)
        self.set_title(tree['title'])
        self.set_context_menu(tree['context_menu'])

    def init_layout(self):
        """ Initialize the layout for the underlying widget.

        """
        super(QtMenu, self).init_layout()
        widget = self.widget()
        for child in self.children():
            if isinstance(child, QtMenu):
                widget.addMenu(child.widget())
            elif isinstance(child, QtAction):
                widget.addAction(child.widget())
            elif isinstance(child, QtActionGroup):
                widget.addActions(child.actions())

    #--------------------------------------------------------------------------
    # Child Events
    #--------------------------------------------------------------------------
    def child_removed(self, child):
        """  Handle the child removed event for a QtMenu.

        """
        if isinstance(child, QtMenu):
            self.widget().removeAction(child.widget().menuAction())
        elif isinstance(child, QtAction):
            self.widget().removeAction(child.widget())
        elif isinstance(child, QtActionGroup):
            self.widget().removeActions(child.actions())

    def child_added(self, child):
        """ Handle the child added event for a QtMenu.

        """
        before = self.find_next_action(child)
        if isinstance(child, QtMenu):
            self.widget().insertMenu(before, child.widget())
        elif isinstance(child, QtAction):
            self.widget().insertAction(before, child.widget())
        elif isinstance(child, QtActionGroup):
            self.widget().insertActions(before, child.actions())

    #--------------------------------------------------------------------------
    # Utility Methods
    #--------------------------------------------------------------------------
    def find_next_action(self, child):
        """ Get the QAction instance which comes immediately after the
        actions of the given child.

        Parameters
        ----------
        child : QtMenu, QtActionGroup, or QtAction
            The child of interest.

        Returns
        -------
        result : QAction or None
            The QAction which comes immediately after the actions of the
            given child, or None if no actions follow the child.

        """
        # The target action must be tested for membership against the
        # current actions on the menu itself, since this method may be
        # called after a child is added, but before the actions for the
        # child have actually been added to the menu.
        index = self.index_of(child)
        if index != -1:
            actions = set(self.widget().actions())
            for child in self.children()[index + 1:]:
                target = None
                if isinstance(child, QtMenu):
                    target = child.widget().menuAction()
                elif isinstance(child, QtAction):
                    target = child.widget()
                elif isinstance(child, QtActionGroup):
                    acts = child.actions()
                    target = acts[0] if acts else None
                if target in actions:
                    return target

    #--------------------------------------------------------------------------
    # Message Handling
    #--------------------------------------------------------------------------
    def on_action_set_title(self, content):
        """ Handle the 'set_title' action from the Enaml widget.

        """
        self.set_title(content['title'])

    def on_action_set_context_menu(self, content):
        """ Handle the 'set_context_menu' action from the Enaml widget.

        """
        self.set_context_menu(content['context_menu'])

    #--------------------------------------------------------------------------
    # Widget Update Methods
    #--------------------------------------------------------------------------
    def set_visible(self, visible):
        """ Set the visibility on the underlying widget.

        This is an overridden method which sets the visibility on the
        underlying QAction for the menu instead of on the menu itself.

        """
        self.widget().menuAction().setVisible(visible)

    def set_title(self, title):
        """ Set the title of the underlying widget.

        """
        self.widget().setTitle(title)

    def set_context_menu(self, context):
        """ Set whether or not the menu is a context menu.

        """
        self.widget().setContextMenu(context)


########NEW FILE########
__FILENAME__ = qt_menu_bar
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
import sys

from .qt.QtGui import QMainWindow, QMenuBar
from .qt_menu import QtMenu
from .qt_widget import QtWidget


class QtMenuBar(QtWidget):
    """ A Qt implementation of an Enaml MenuBar.

    """
    #--------------------------------------------------------------------------
    # Setup Methods
    #--------------------------------------------------------------------------
    def create_widget(self, parent, tree):
        """ Create the underlying menu bar widget.

        """
        # On OSX, there is a weird issue where creating a QMenuBar with
        # a parent will cause the menu bar to not show up when its added
        # to the main window. On that platform we work around the issue
        # by having the QMainWindow create the menu bar for us, or by
        # creating it without a parent. This issue is even more weird,
        # because in the C++ code for QMainWindow::menuBar() the newly
        # created menu bar is given the QMainWindow as its parent...
        if sys.platform == 'darwin':
            if isinstance(parent, QMainWindow):
                menu_bar = parent.menuBar()
            else:
                menu_bar = QMenuBar()
        else:
            menu_bar = QMenuBar(parent)
        return menu_bar

    def init_layout(self):
        """ Initialize the layout for the underlying control.

        """
        super(QtMenuBar, self).init_layout()
        widget = self.widget()
        for child in self.children():
            if isinstance(child, QtMenu):
                widget.addMenu(child.widget())

    #--------------------------------------------------------------------------
    # Child Events
    #--------------------------------------------------------------------------
    def child_removed(self, child):
        """ Handle the child removed event for a QtMenuBar.

        """
        if isinstance(child, QtMenu):
            self.widget().removeAction(child.widget().menuAction())

    def child_added(self, child):
        """ Handle the child added event for a QtMenuBar.

        """
        if isinstance(child, QtMenu):
            before = self.find_next_action(child)
            self.widget().insertMenu(before, child.widget())

    #--------------------------------------------------------------------------
    # Utility Methods
    #--------------------------------------------------------------------------
    def find_next_action(self, child):
        """ Get the QAction instance which comes immediately after the
        actions of the given child.

        Parameters
        ----------
        child : QtMenu
            The child menu of interest.

        Returns
        -------
        result : QAction or None
            The QAction which comes immediately after the actions of the
            given child, or None if no actions follow the child.

        """
        # The target action must be tested for membership against the
        # current actions on the menu bar itself, since this method may
        # be called after a child is added, but before the actions for
        # the child have actually added to the menu.
        index = self.index_of(child)
        if index != -1:
            actions = set(self.widget().actions())
            for child in self.children()[index + 1:]:
                if isinstance(child, QtMenu):
                    target = child.widget().menuAction()
                    if target in actions:
                        return target


########NEW FILE########
__FILENAME__ = qt_mpl_canvas
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#
# Special thanks to Steven Silvester for contributing this module!
#------------------------------------------------------------------------------
from .qt.QtCore import Qt
from .qt.QtGui import QFrame, QVBoxLayout
from .qt_constraints_widget import size_hint_guard
from .qt_control import QtControl

from matplotlib.backends.backend_qt4agg import FigureCanvasQTAgg
from matplotlib.backends.backend_qt4agg import NavigationToolbar2QTAgg


class QtMPLCanvas(QtControl):
    """ A Qt implementation of an Enaml MPLCanvas.

    """
    #: Internal storage for the matplotlib figure.
    _figure = None

    #: Internal storage for whether or not to show the toolbar.
    _toolbar_visible = False

    #--------------------------------------------------------------------------
    # Setup Methods
    #--------------------------------------------------------------------------
    def create_widget(self, parent, tree):
        """ Create the underlying widget.

        """
        widget = QFrame(parent)
        layout = QVBoxLayout()
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(0)
        widget.setLayout(layout)
        return widget

    def create(self, tree):
        """ Create and initialize the underlying widget.

        """
        super(QtMPLCanvas, self).create(tree)
        self._figure = tree['figure']
        self._toolbar_visible = tree['toolbar_visible']

    def init_layout(self):
        """ Initialize the layout of the underlying widget.

        """
        super(QtMPLCanvas, self).init_layout()
        self.refresh_mpl_widget()

    #--------------------------------------------------------------------------
    # Message Handlers
    #--------------------------------------------------------------------------
    def on_action_set_figure(self, content):
        """ Handle the 'set_figure' action from the Enaml widget.

        """
        self._figure = content['figure']
        with size_hint_guard(self):
            self.refresh_mpl_widget()

    def on_action_set_toolbar_visible(self, content):
        """ Handle the 'set_toolbar_visible' action from the Enaml
        widget.

        """
        visible = content['toolbar_visible']
        self._toolbar_visible = visible
        layout = self.widget().layout()
        if layout.count() == 2:
            with size_hint_guard(self):
                toolbar = layout.itemAt(0).widget()
                toolbar.setVisible(visible)

    #--------------------------------------------------------------------------
    # Widget Update Methods
    #--------------------------------------------------------------------------
    def refresh_mpl_widget(self):
        """ Create the mpl widget and update the underlying control.

        """
        # Delete the old widgets in the layout, it's just shenanigans
        # to try to reuse the old widgets when the figure changes.
        widget = self.widget()
        layout = widget.layout()
        while layout.count():
            layout_item = layout.takeAt(0)
            layout_item.widget().deleteLater()

        # Create the new figure and toolbar widgets. It seems that key
        # events will not be processed without an mpl figure manager.
        # However, a figure manager will create a new toplevel window,
        # which is certainly not desired in this case. This appears to
        # be a limitation of matplotlib. The canvas is manually set to
        # visible, or QVBoxLayout will ignore it for size hinting.
        figure = self._figure
        if figure is not None:
            canvas = FigureCanvasQTAgg(figure)
            canvas.setParent(widget)
            canvas.setFocusPolicy(Qt.ClickFocus)
            canvas.setVisible(True)
            toolbar = NavigationToolbar2QTAgg(canvas, widget)
            toolbar.setVisible(self._toolbar_visible)
            layout.addWidget(toolbar)
            layout.addWidget(canvas)


########NEW FILE########
__FILENAME__ = qt_multiline_field
#------------------------------------------------------------------------------
#  Copyright (c) 2013, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from .qt.QtGui import QTextEdit
from .qt.QtCore import Signal, QTimer
from .qt_control import QtControl


class QMultilineEdit(QTextEdit):
    """ A QTextEdit which notifies on a collapsing timer.

    """
    delayedTextChanged = Signal()

    def __init__(self, parent=None):
        super(QMultilineEdit, self).__init__(parent)
        self._changed_timer = timer = QTimer()
        timer.setInterval(200)
        timer.setSingleShot(True)
        timer.timeout.connect(self.delayedTextChanged)
        self.textChanged.connect(timer.start)


class QtMultilineField(QtControl):
    """ A Qt4 implementation of an Enaml Field.

    """
    #: Whether or not to auto synchronize the text on change.
    _auto_sync_text = True

    #--------------------------------------------------------------------------
    # Setup Methods
    #--------------------------------------------------------------------------
    def create_widget(self, parent, tree):
        """ Creates the underlying QFocusMultiLineEdit widget.

        """
        return QMultilineEdit(parent)

    def create(self, tree):
        """ Create and initialize the underlying widget.

        """
        super(QtMultilineField, self).create(tree)
        self._auto_sync_text = tree['auto_sync_text']
        self.set_text(tree['text'])
        self.set_read_only(tree['read_only'])
        widget = self.widget()
        widget.delayedTextChanged.connect(self.on_text_changed)

    #--------------------------------------------------------------------------
    # Private API
    #--------------------------------------------------------------------------
    def _send_text_changed(self):
        """ Send the current text as an update to the server widget.

        """
        text = self.widget().toPlainText()
        self.send_action('text_changed', {'text': text})

    #--------------------------------------------------------------------------
    # Signal Handlers
    #--------------------------------------------------------------------------
    def on_text_changed(self):
        """ The signal handler for 'delayedTextChanged' signal.

        """
        if self._auto_sync_text and 'text' not in self.loopback_guard:
            self._send_text_changed()

    #--------------------------------------------------------------------------
    # Message Handlers
    #--------------------------------------------------------------------------
    def on_action_set_text(self, content):
        """ Handle the 'set_text' action from the Enaml widget.

        """
        self.set_text(content['text'])

    def on_action_set_auto_sync_text(self, content):
        """ Handle the 'set_auto_sync_text' action from the Enaml widget.

        """
        self._auto_sync_text = content['auto_sync_text']

    def on_action_set_read_only(self, content):
        """ Handle the 'set_read_only' action from the Enaml widget.

        """
        self.set_read_only(content['read_only'])

    def on_action_sync_text(self, content):
        """ Handle the 'sync_text' action from the Enaml widget.

        """
        self._send_text_changed()

    #--------------------------------------------------------------------------
    # Widget Update Methods
    #--------------------------------------------------------------------------
    def set_text(self, text):
        """ Set the text in the underlying widget.

        """
        with self.loopback_guard('text'):
            self.widget().setText(text)

    def set_read_only(self, read_only):
        """ Set whether or not the widget is read only.

        """
        self.widget().setEnabled(not read_only)


########NEW FILE########
__FILENAME__ = qt_notebook
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
import sys
from weakref import WeakKeyDictionary

from .qt.QtCore import Qt, QEvent, Signal
from .qt.QtGui import QTabWidget, QTabBar, QResizeEvent, QApplication
from .qt_constraints_widget import QtConstraintsWidget
from .qt_page import QtPage


TAB_POSITIONS = {
    'top': QTabWidget.North,
    'bottom': QTabWidget.South,
    'left': QTabWidget.West,
    'right': QTabWidget.East,
}


DOCUMENT_MODES = {
    'document': True,
    'preferences': False,
}


class QNotebook(QTabWidget):
    """ A custom QTabWidget which handles children of type QPage.

    """
    #: A signal emitted when a LayoutRequest event is posted to the
    #: notebook widget. This will typically occur when the size hint
    #: of the notebook is no longer valid.
    layoutRequested = Signal()

    def __init__(self, *args, **kwargs):
        """ Initialize a QNotebook.

        Parameters
        ----------
        *args, **kwargs
            The positional and keyword arguments needed to create
            a QTabWidget.

        """
        super(QNotebook, self).__init__(*args, **kwargs)
        self.tabCloseRequested.connect(self.onTabCloseRequested)
        self._hidden_pages = WeakKeyDictionary()

    #--------------------------------------------------------------------------
    # Private API
    #--------------------------------------------------------------------------
    def _refreshTabBar(self):
        """ Trigger an immediate relayout and refresh of the tab bar.

        """
        # The public QTabBar api does not provide a way to trigger the
        # 'layoutTabs' method of QTabBarPrivate and there are certain
        # operations (such as modifying a tab close button) which need
        # to have that happen. This method provides a workaround by
        # sending a dummy resize event to the tab bar, followed by one
        # to the tab widget.
        app = QApplication.instance()
        if app is not None:
            bar = self.tabBar()
            size = bar.size()
            event = QResizeEvent(size, size)
            app.sendEvent(bar, event)
            size = self.size()
            event = QResizeEvent(size, size)
            app.sendEvent(self, event)

    #--------------------------------------------------------------------------
    # Signal Handlers
    #--------------------------------------------------------------------------
    def onTabCloseRequested(self, index):
        """ The handler for the 'tabCloseRequested' signal.

        """
        self.widget(index).requestClose()

    #--------------------------------------------------------------------------
    # Public API
    #--------------------------------------------------------------------------
    def event(self, event):
        """ A custom event handler which handles LayoutRequest events.

        When a LayoutRequest event is posted to this widget, it will
        emit the `layoutRequested` signal. This allows an external
        consumer of this widget to update their external layout.

        """
        res = super(QNotebook, self).event(event)
        if event.type() == QEvent.LayoutRequest:
            self.layoutRequested.emit()
        return res

    def showPage(self, page):
        """ Show a hidden QPage instance in the notebook.

        If the page is not owned by the notebook, this is a no-op.

        Parameters
        ----------
        page : QPage
            The hidden QPage instance to show in the notebook.

        """
        index = self.indexOf(page)
        if index == -1:
            index = self._hidden_pages.pop(page, -1)
            if index != -1:
                self.insertPage(index, page)

    def hidePage(self, page):
        """ Hide the given QPage instance in the notebook.

        If the page is not owned by the notebook, this is a no-op.

        Parameters
        ----------
        page : QPage
            The QPage instance to hide in the notebook.

        """
        index = self.indexOf(page)
        if index != -1:
            self.removeTab(index)
            page.hide()
            self._hidden_pages[page] = index

    def addPage(self, page):
        """ Add a QPage instance to the notebook.

        This method should be used in favor of the 'addTab' method.

        Parameters
        ----------
        page : QPage
            The QPage instance to add to the notebook.

        """
        self.insertPage(self.count(), page)

    def insertPage(self, index, page):
        """ Insert a QPage instance into the notebook.

        This should be used in favor of the 'insertTab' method.

        Parameters
        ----------
        index : int
            The index at which to insert the page.

        page : QPage
            The QPage instance to add to the notebook.

        """
        if page.isOpen():
            index = min(index, self.count())
            self.insertTab(index, page, page.title())
            self.setTabIcon(index, page.icon())
            self.setTabToolTip(index, page.toolTip())
            self.setTabEnabled(index, page.isTabEnabled())
            self.setTabCloseButtonVisible(index, page.isClosable())
        else:
            page.hide()
            self._hidden_pages[page] = index

    def removePage(self, page):
        """ Remove a QPage instance from the notebook.

        If the page does not exist in the notebook, this is a no-op.

        Parameters
        ----------
        page : QPage
            The QPage instance to remove from the notebook.

        """
        index = self.indexOf(page)
        if index != -1:
            self.removeTab(index)
            page.hide()

    def setTabCloseButtonVisible(self, index, visible, refresh=True):
        """ Set whether the close button for the given tab is visible.

        The 'tabsClosable' property must be set to True for this to
        have effect.

        Parameters
        ----------
        index : int
            The index of the target page.

        visible : bool
            Whether or not the close button for the tab should be
            visible.

        refresh : bool, optional
            Whether or not to refresh the tab bar at the end of the
            operation. The default is True.

        """
        # When changing the visibility of a button, we also change its
        # size so that the tab can layout properly.
        if index >= 0 and index < self.count():
            tabBar = self.tabBar()
            btn1 = tabBar.tabButton(index, QTabBar.LeftSide)
            btn2 = tabBar.tabButton(index, QTabBar.RightSide)
            if btn1 is not None:
                btn1.setVisible(visible)
                if not visible:
                    btn1.resize(0, 0)
                else:
                    btn1.resize(btn1.sizeHint())
            if btn2 is not None:
                btn2.setVisible(visible)
                if not visible:
                    btn2.resize(0, 0)
                else:
                    btn2.resize(btn2.sizeHint())
            if refresh:
                self._refreshTabBar()

    def setTabsClosable(self, closable):
        """ Set the tab closable state for the widget.

        This is an overridden parent class method which extends the
        logic to account for the closable state on the individual
        pages.

        Parameters
        ----------
        closable : bool
            Whether or not the tabs should be closable.

        """
        super(QNotebook, self).setTabsClosable(closable)
        # When setting tabs closable to False, the default logic of
        # QTabBar is to delete the close button on the tab. When the
        # closable flag is set to True a new close button is created
        # for every tab, unless one has already been provided. This
        # means we need to make an extra pass over each tab to sync
        # the state of the buttons when the flag is set to True.
        if closable:
            setVisible = self.setTabCloseButtonVisible
            for index in xrange(self.count()):
                page = self.widget(index)
                setVisible(index, page.isClosable(), refresh=False)
        self._refreshTabBar()


class QtNotebook(QtConstraintsWidget):
    """ A Qt implementation of an Enaml Notebook.

    """
    #--------------------------------------------------------------------------
    # Setup methods
    #--------------------------------------------------------------------------
    def create_widget(self, parent, tree):
        """ Create the underlying notebook widget.

        """
        widget = QNotebook(parent)
        if sys.platform == 'darwin':
            # On OSX, the widget item layout rect is too small.
            # Setting this attribute forces the widget item to
            # use the widget rect for layout.
            widget.setAttribute(Qt.WA_LayoutUsesWidgetRect, True)
        return widget

    def create(self, tree):
        """ Create and initialize the underyling widget.

        """
        super(QtNotebook, self).create(tree)
        self.set_tab_style(tree['tab_style'])
        self.set_tab_position(tree['tab_position'])
        self.set_tabs_closable(tree['tabs_closable'])
        self.set_tabs_movable(tree['tabs_movable'])

    def init_layout(self):
        """ Handle the layout initialization for the notebook.

        """
        super(QtNotebook, self).init_layout()
        widget = self.widget()
        for child in self.children():
            if isinstance(child, QtPage):
                widget.addPage(child.widget())
        widget.layoutRequested.connect(self.on_layout_requested)

    #--------------------------------------------------------------------------
    # Child Events
    #--------------------------------------------------------------------------
    def child_removed(self, child):
        """ Handle the child removed event for a QtNotebook.

        """
        if isinstance(child, QtPage):
            self.widget().removePage(child.widget())

    def child_added(self, child):
        """ Handle the child added event for a QtNotebook.

        """
        if isinstance(child, QtPage):
            index = self.index_of(child)
            if index != -1:
                self.widget().insertPage(index, child.widget())

    #--------------------------------------------------------------------------
    # Signal Handlers
    #--------------------------------------------------------------------------
    def on_layout_requested(self):
        """ Handle the `layoutRequested` signal from the QNotebook.

        """
        self.size_hint_updated()

    #--------------------------------------------------------------------------
    # Message Handlers
    #--------------------------------------------------------------------------
    def on_action_set_tab_style(self, content):
        """ Handle the 'set_tab_style' action from the Enaml widget.

        """
        self.set_tab_style(content['tab_style'])

    def on_action_set_tab_position(self, content):
        """ Handle the 'set_tab_position' action from the Enaml widget.

        """
        self.set_tab_position(content['tab_position'])

    def on_action_set_tabs_closable(self, content):
        """ Handle the 'set_tabs_closable' action from the Enaml widget.

        """
        self.set_tabs_closable(content['tabs_closable'])

    def on_action_set_tabs_movable(self, content):
        """ Handle the 'set_tabs_movable' action from the Enaml widget.

        """
        self.set_tabs_movable(content['tabs_movable'])

    #--------------------------------------------------------------------------
    # Widget Update Methods
    #--------------------------------------------------------------------------
    def set_tab_style(self, style):
        """ Set the tab style for the tab bar in the widget.

        """
        self.widget().setDocumentMode(DOCUMENT_MODES[style])

    def set_tab_position(self, position):
        """ Set the position of the tab bar in the widget.

        """
        self.widget().setTabPosition(TAB_POSITIONS[position])

    def set_tabs_closable(self, closable):
        """ Set whether or not the tabs are closable.

        """
        self.widget().setTabsClosable(closable)

    def set_tabs_movable(self, movable):
        """ Set whether or not the tabs are movable.

        """
        self.widget().setMovable(movable)


########NEW FILE########
__FILENAME__ = qt_object
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
import functools
import logging

from enaml.utils import LoopbackGuard, make_dispatcher

from .qt.QtCore import QObject
from .q_deferred_caller import deferredCall


logger = logging.getLogger(__name__)


#: The dispatch function for action dispatching.
dispatch_action = make_dispatcher('on_action_', logger)


def deferred_updates(func):
    """ A method decorator which will defer widget updates.

    When used as a decorator for a QtObject, this will disable updates
    on the underlying widget, and re-enable them on the next cycle of
    the event loop after the method returns.

    Parameters
    ----------
    func : function
        A function object defined as a method on a QtObject.

    """
    @functools.wraps(func)
    def closure(self, *args, **kwargs):
        widget = self.widget()
        if widget is not None and widget.isWidgetType():
            widget.setUpdatesEnabled(False)
            try:
                res = func(self, *args, **kwargs)
            finally:
                deferredCall(widget.setUpdatesEnabled, True)
        else:
            res = func(self, *args, **kwargs)
        return res
    return closure


class QtObject(object):
    """ The most base class of all client objects for the Enaml Qt
    implementation.

    """
    @classmethod
    def construct(cls, tree, parent, session):
        """ Construct the QtObject instance for the given parameters.

        This classmethod is called by the QtSession object which owns
        the object being built. When called, it creates a new instance
        of the class by extracting the object id from the snapshot and
        calling the class' constructor. It then invokes the `create`
        method on the new instance. This classmethod exists for cases
        where it is necessary to define custom construction behavior.
        A subclass may reimplement this method as required.

        Parameters
        ----------
        tree : dict
            An Enaml snapshot dict representing an object tree from this
            object downward.

        parent : QtObject or None
            The parent QtObject to use for this object, or None if this
            object is top-level.

        session : QtSession
            The QtSession object which owns this object. The session is
            used for sending messages to the server side widgets.

        Returns
        -------
        result : QtObject
            The QtObject instance for these parameters.

        Notes
        -----
        This method does *not* construct the children for this object.
        That responsibility lies with the QtSession object which calls
        this constructor.

        """
        object_id = tree['object_id']
        self = cls(object_id, parent, session)
        self.create(tree)
        session.register(self)
        return self

    def __init__(self, object_id, parent, session):
        """ Initialize a QtObject.

        Parameters
        ----------
        object_id : str
            The unique identifier to use with this object.

        parent : QtObject or None
            The parent object of this object, or None if this object
            has no parent.

        session : QtSession
            The QtSession object which owns this object. The session is
            used for sending messages to the server side widgets.

        """
        self._object_id = object_id
        self._session = session
        self._parent = None
        self._children = []
        self._widget = None
        self._initialized = False
        self._destroying = False
        self.set_parent(parent)

    #--------------------------------------------------------------------------
    # Properties
    #--------------------------------------------------------------------------
    @property
    def loopback_guard(self):
        """ Lazily creates and returns a LoopbackGuard for convenient
        use by subclasses.

        """
        try:
            guard = self._loopback_guard
        except AttributeError:
            guard = self._loopback_guard = LoopbackGuard()
        return guard

    #--------------------------------------------------------------------------
    # Object Methods
    #--------------------------------------------------------------------------
    def object_id(self):
        """ Get the object id for the object.

        Returns
        -------
        result : str
            The unique identifier for this object.

        """
        return self._object_id

    def widget(self):
        """ Get the toolkit-specific object for this object.

        Returns
        -------
        result : QObject or None
            The toolkit object for this object, or None if it does not
            have a toolkit object.

        """
        return self._widget

    def parent_widget(self):
        """ Get the toolkit-specific parent widget for this object.

        Returns
        -------
        result : QObject or None
            The toolkit object for this object, or None if it does
            not exist.

        """
        parent = self._parent
        if parent is not None:
            parent = parent.widget()
        return parent

    def create_widget(self, parent, tree):
        """ A method which should be reimplemented by subclasses.

        This method is called by the create(...) method. It should
        create and return the underlying Qt widget. Implementations
        of this method should *not* call the superclass version.

        Parameters
        ----------
        parent : QObject or None
            The parent Qt toolkit object for this control, or None if
            the control does not have a parent.

        tree : dict
            The dictionary representation of the tree for this object.
            This is provided in the even that the component needs to
            create a different type of widget based on the information
            in the tree.

        """
        return QObject()

    def create(self, tree):
        """ A method called by the application when creating the UI.

        The default implementation of this method calls 'create_widget'
        and assigns the results to the 'widget' attribute, so subclasses
        must be sure to call the superclass method as the first order of
        business.

        This method is called by the application in a top-down fashion.

        Parameters
        ----------
        tree : dict
            The dictionary representation of the tree for this object.

        """
        parent = self._parent
        parent_widget = parent.widget() if parent else None
        self._widget = self.create_widget(parent_widget, tree)

    def initialized(self):
        """ Get whether or not this object is initialized.

        Returns
        -------
        result : bool
            True if this object has been initialized, False otherwise.

        """
        return self._initialized

    def initialize(self):
        """ A method called by the application to initialize the UI.

        This method is called by the application to allow the object
        tree perform any post-create initialization required. This
        method should only be called once. Multiple calls to this
        method are ignored.

        """
        if not self._initialized:
            for child in self.children():
                child.initialize()
            self.init_layout()
            self._initialized = True

    def init_layout(self):
        """ A method that allows widgets to do layout initialization.

        This method is called after all widgets in a tree have had
        their 'create' method called. It is useful for doing any
        initialization related to layout.

        The default implementation of this method is a no-op in order
        to be super() friendly.

        This method is called by the application in a bottom-up order.

        """
        pass

    def activate(self):
        """ A method called by the session to activate the UI.

        This method is called by the session after the server side
        session has indicated it is ready to accept messages. This
        provides the object tree to make initial request for data
        from the server side objects.

        """
        for child in self.children():
            child.activate()

    def destroy(self):
        """ Destroy this object.

        After an object is destroyed, it is no longer usable and should
        be discarded. All internal references to the object will be
        removed.

        """
        # Set the destroying flag to True so objects can optimize
        # their destruction behavior.
        self._destroying = True

        # Destroy the children before destroying the underlying widget
        # this gives the children the opportunity to perform cleanup
        # with an intact parent before being destroyed. Destroying a
        # child will cause it to be removed from the parent, so the
        # list is copied to ensure proper iteration.
        for child in self._children[:]:
            child.destroy()
        self._children = []

        # Only after the children are destroyed is the intialized flag
        # set to False. This allows a child which is being destroyed
        # to fire off the child_removed event on the parent so that
        # the parent can do cleanup before the child is destroyed.
        self._initialized = False

        # Fire the child_removed event immediately, so a child can be
        # removed from any auxiliary container they parent may have
        # placed it in, before the underlying widget is destroyed.
        parent = self._parent
        if parent is not None:
            if self in parent._children:
                parent._children.remove(self)
                if parent._initialized:
                    parent.child_removed(self)
            self._parent = None

        # Finally, unparent the underlying toolkit widget. Since there
        # should no longer be any public references to it, it will be
        # garbage collected and destroyed. This appears to be a safer
        # approach than calling widget.deleteLater().
        widget = self._widget
        if widget is not None:
            widget.setParent(None)
            self._widget = None

        # Remove what should be the last remaining strong references to
        # `self` which will allow this object to be garbage collected.
        self._session.unregister(self)
        self._session = None

    #--------------------------------------------------------------------------
    # Parenting Methods
    #--------------------------------------------------------------------------
    def parent(self):
        """ Get the parent of this QtObject.

        Returns
        -------
        result : QtObject or None
            The parent object of this object, or None if it has no
            parent.

        """
        return self._parent

    def children(self):
        """ Get the children of this object.

        Returns
        -------
        result : list
            The list of children of this object. This list should not
            be modified in place by user code.

        """
        return self._children

    def set_parent(self, parent):
        """ Set the parent for this object.

        If the parent is already initialized, then the `child_removed`
        and `child_added` events will be emitted on the parent. Updates
        on the widget are disabled until after the child events on the
        parent have been processed.

        Parameters
        ----------
        parent : QtObject or None
            The parent of this object, or None if it has no parent.

        """
        # Note: If this object is not yet fully intialized, then the
        # added/removed events must be executed on the next cycle of
        # the event loop. It's possible that this method is being called
        # from the `construct` class method and the toolkit widget will
        # not yet exist. This means that child event handlers that rely
        # on the child toolkit widget existing will fail.
        curr = self._parent
        if curr is parent or parent is self:
            return

        self._parent = parent
        if curr is not None:
            if self in curr._children:
                curr._children.remove(self)
                if curr._initialized:
                    if self._initialized:
                        curr.child_removed(self)
                    else:
                        deferredCall(curr.child_removed, self)

        if parent is not None:
            parent._children.append(self)
            if parent._initialized:
                if self._initialized:
                    parent.child_added(self)
                else:
                    deferredCall(parent.child_added, self)

    def child_removed(self, child):
        """ Called when a child is removed from this object.

        The default implementation of this method unparents the toolkit
        widget if the parent of the child is None. Subclasses which need
        more control may reimplement this method.

        Parameters
        ----------
        child : QtObject
            The child object removed from this object.

        """
        if child._parent is None:
            widget = child._widget
            if widget is not None:
                widget.setParent(None)

    def child_added(self, child):
        """ A method called when a child is added to this object.

        The default implementation ensures that the toolkit widget is
        properly parented. Subclasses which need more control may
        reimplement this method.

        Parameters
        ----------
        child : QtObject
            The child object added to this object.

        """
        widget = child._widget
        if widget is not None:
            widget.setParent(self._widget)

    def index_of(self, child):
        """ Return the index of the given child.

        Parameters
        ----------
        child : QtObject
            The child of interest.

        Returns
        -------
        result : int
            The index of the given child, or -1 if it is not found.

        """
        children = self._children
        if child in children:
            return children.index(child)
        return -1

    #--------------------------------------------------------------------------
    # Messaging API
    #--------------------------------------------------------------------------
    def send_action(self, action, content):
        """ Send an action to the server side object.

        The action will only be sent if the object is fully initialized.

        Parameters
        ----------
        action : str
            The name of the action performed.

        content : dict
            The content data for the action.

        """
        if self._initialized:
            self._session.send(self._object_id, action, content)

    def receive_action(self, action, content):
        """ Receive an action from the server side object.

        The default implementation will dynamically dispatch the action
        to specially named handlers if the current state of the object
        is 'active'. Subclasses may reimplement this method if more
        control is needed.

        Parameters
        ----------
        action : str
            The name of the action to perform.

        content : dict
            The content data for the action.

        """
        if self._initialized:
            dispatch_action(self, action, content)

    #--------------------------------------------------------------------------
    # Action Handlers
    #--------------------------------------------------------------------------
    @deferred_updates
    def on_action_children_changed(self, content):
        """ Handle the 'children_changed' action from the Enaml object.

        This method will unparent the removed children and add the new
        children to this object. If a given new child does not exist, it
        will be built. Subclasses that need more control may reimplement
        this method. The default implementation disables updates on the
        widget while adding children and reenables them on the next cyle
        of the event loop.

        """
        # Unparent the children being removed. Destroying a widget is
        # handled through a separate message.
        lookup = self._session.lookup
        for object_id in content['removed']:
            child = lookup(object_id)
            if child is not None and child._parent is self:
                child.set_parent(None)

        # Build or reparent the children being added.
        for tree in content['added']:
            object_id = tree['object_id']
            child = lookup(object_id)
            if child is not None:
                child.set_parent(self)
            else:
                child = self._session.build(tree, self)
                child.initialize()

        # Update the ordering of the children based on the order given
        # in the message. If the given order does not include all of
        # the current children, then the ones not included will be
        # appended to the end of the new list in an undefined order.
        ordered = []
        curr_set = set(self._children)
        for object_id in content['order']:
            child = lookup(object_id)
            if child is not None and child._parent is self:
                ordered.append(child)
                curr_set.discard(child)
        ordered.extend(curr_set)
        self._children = ordered

    def on_action_destroy(self, content):
        """ Handle the 'destroy' action from the Enaml object.

        This method will call the `destroy` method on the object.

        """
        if self._initialized:
            self.destroy()
        else:
            deferredCall(self.destroy)


########NEW FILE########
__FILENAME__ = qt_page
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
import logging

from .qt.QtCore import Signal
from .qt.QtGui import QFrame, QIcon, QImage, QPixmap
from .q_single_widget_layout import QSingleWidgetLayout
from .qt_container import QtContainer
from .qt_widget import QtWidget


logger = logging.getLogger(__name__)


class QPage(QFrame):
    """ A QFrame subclass which acts as a page in a QNotebook.

    """
    #: A signal emitted when the page has been closed by the user.
    pageClosed = Signal()

    def __init__(self, *args, **kwargs):
        """ Initialize a QPage.

        Parameters
        ----------
        *args, **kwargs
            The position and keyword arguments required to initialize
            a QWidget.

        """
        super(QPage, self).__init__(*args, **kwargs)
        self._title = u''
        self._tool_tip = u''
        self._icon = QIcon()
        self._closable = True
        self._is_enabled = True
        self._is_open = True
        self._page_widget = None
        self.setLayout(QSingleWidgetLayout())

    #--------------------------------------------------------------------------
    # Private API
    #--------------------------------------------------------------------------
    def _findNotebook(self):
        """ Get the parent QNotebook for this page.

        Returns
        -------
        result : QNotebook or None
            The parent QNotebook for this page, or None if one cannot
            be found.

        """
        # Avoid a circular import with the qt_notebook module
        from .qt_notebook import QNotebook
        # Depending on where we are during initialization, the notebook
        # will be either our parent or grandparent because of how the
        # QTabWidget reparents things internally.
        parent = self.parent()
        if isinstance(parent, QNotebook):
            return parent
        if parent is not None:
            parent = parent.parent()
            if isinstance(parent, QNotebook):
                return parent

    def _pageIndexOperation(self, closure):
        """ A private method which will run the given closure if there
        is a valid index for this page.

        """
        notebook = self._findNotebook()
        if notebook is not None:
            index = notebook.indexOf(self)
            if index != -1:
                closure(notebook, index)

    #--------------------------------------------------------------------------
    # Public API
    #--------------------------------------------------------------------------
    def requestClose(self):
        """ A method called by the parent notebook when the user has
        requested that this page be closed.

        If the page is marked as closable, then it will be closed and
        the 'pageClosed' signal will be emitted.

        """
        if self.isClosable():
            self.close()
            self.pageClosed.emit()

    def pageWidget(self):
        """ Get the page widget for this page.

        Returns
        -------
        result : QWidget or None
            The page widget being managed by this page.

        """
        return self._page_widget

    def setPageWidget(self, widget):
        """ Set the page widget for this page.

        Parameters
        ----------
        widget : QWudget
            The Qt widget to use as the page widget in this page.

        """
        self._page_widget = widget
        self.layout().setWidget(widget)

    def isOpen(self):
        """ Get whether or not the page is open.

        Returns
        -------
        result : bool
            True if the page is open, False otherwise.

        """
        return self._is_open

    def open(self):
        """ Open the page in the notebook.

        """
        self._is_open = True
        notebook = self._findNotebook()
        if notebook is not None:
            notebook.showPage(self)

    def close(self):
        """ Close the page in the notebook.

        """
        self._is_open = False
        notebook = self._findNotebook()
        if notebook is not None:
            notebook.hidePage(self)

    def isTabEnabled(self):
        """ Return whether or not the tab for this page is enabled.

        This method should be used in favor of isEnabled.

        Returns
        -------
        result : bool
            True if the tab for this page is enabled, False otherwise.

        """
        return self._is_enabled

    def setTabEnabled(self, enabled):
        """ Set whether the tab for this page is enabled.

        This method should be used in favor of isEnabled.

        Parameters
        ----------
        enabled : bool
            True if the tab should be enabled, False otherwise.

        """
        self._is_enabled = enabled
        def closure(nb, index):
            nb.setTabEnabled(index, enabled)
        self._pageIndexOperation(closure)

    def title(self):
        """ Returns the tab title for this page.

        Returns
        -------
        result : unicode
            The title string for the page's tab.

        """
        return self._title

    def setTitle(self, title):
        """ Set the title for the tab for this page.

        Parameters
        ----------
        title : unicode
            The string to use for this page's tab title.

        """
        self._title = title
        def closure(nb, index):
            nb.setTabText(index, title)
        self._pageIndexOperation(closure)

    def isClosable(self):
        """ Returns whether or not the tab for this page is closable.

        Returns
        -------
        result : bool
            True if this page's tab is closable, False otherwise.

        """
        return self._closable

    def setClosable(self, closable):
        """ Set whether the tab for this page is closable.

        Parameters
        ----------
        closable : bool
            True if the tab should be closable, False otherwise.

        """
        self._closable = closable
        def closure(nb, index):
            nb.setTabCloseButtonVisible(index, closable)
        self._pageIndexOperation(closure)

    def toolTip(self):
        """ Returns the tool tip for the tab for this page.

        Returns
        -------
        result : unicode
            The tool tip string for the page's tab.

        """
        return self._tool_tip

    def setToolTip(self, tool_tip):
        """ Set the tool tip for the tab for this page.

        This overrides the default implementation to set the tool tip
        on the notebook tab.

        Parameters
        ----------
        title : unicode
            The string to use for this page's tab tool tip.

        """
        self._tool_tip = tool_tip
        def closure(nb, index):
            nb.setTabToolTip(index, tool_tip)
        self._pageIndexOperation(closure)

    def icon(self):
        """ Get the icon for the page.

        Returns
        -------
        result : QIcon
            The icon for the page.

        """
        return self._icon

    def setIcon(self, icon):
        """ Set the icon for the page.

        Parameters
        ----------
        icon : QIcon
            The icon for the page.

        """
        self._icon = icon
        def closure(nb, index):
            nb.setTabIcon(index, icon)
        self._pageIndexOperation(closure)


class QtPage(QtWidget):
    """ A Qt implementation of an Enaml notebook Page.

    """
    #: Temporary internal storage for the icon source url.
    _icon_source = ''

    #--------------------------------------------------------------------------
    # Setup Methods
    #--------------------------------------------------------------------------
    def create_widget(self, parent, tree):
        """ Create the underlying page widget.

        """
        return QPage(parent)

    def create(self, tree):
        """ Create and initialize the underlying widget.

        """
        super(QtPage, self).create(tree)
        self.set_title(tree['title'])
        self.set_closable(tree['closable'])
        self._icon_source = tree['icon_source']
        self.widget().pageClosed.connect(self.on_page_closed)

    def init_layout(self):
        """ Initialize the layout for the underyling widget.

        """
        super(QtPage, self).init_layout()
        self.widget().setPageWidget(self.page_widget())

    def activate(self):
        """ Activate the page widget.

        """
        self.set_icon_source(self._icon_source)
        super(QtPage, self).activate()

    #--------------------------------------------------------------------------
    # Utility Methods
    #--------------------------------------------------------------------------
    def page_widget(self):
        """ Find and return the page widget child for this widget.

        Returns
        -------
        result : QWidget or None
            The page widget defined for this widget, or None if one is
            not defined.

        """
        widget = None
        for child in self.children():
            if isinstance(child, QtContainer):
                widget = child.widget()
        return widget

    #--------------------------------------------------------------------------
    # Child Events
    #--------------------------------------------------------------------------
    def child_removed(self, child):
        """ Handle the child removed event for a QtPage.

        """
        if isinstance(child, QtContainer):
            self.widget().setPageWidget(self.page_widget())

    def child_added(self, child):
        """ Handle the child added event for a QtPage.

        """
        if isinstance(child, QtContainer):
            self.widget().setPageWidget(self.page_widget())

    #--------------------------------------------------------------------------
    # Signal Handlers
    #--------------------------------------------------------------------------
    def on_page_closed(self):
        """ The signal handler for the 'pageClosed' signal.

        """
        self.send_action('closed', {})

    #--------------------------------------------------------------------------
    # Message Handling
    #--------------------------------------------------------------------------
    def on_action_set_title(self, content):
        """ Handle the 'set_title' action from the Enaml widget.

        """
        self.set_title(content['title'])

    def on_action_set_closable(self, content):
        """ Handle the 'set_closable' action from the Enaml widget.

        """
        self.set_closable(content['closable'])

    def on_action_set_icon_source(self, content):
        """ Handle the 'set_icon_source' action from the Enaml widget.

        """
        self.set_icon_source(content['icon_source'])

    def on_action_open(self, content):
        """ Handle the 'open' action from the Enaml widget.

        """
        self.widget().open()

    def on_action_close(self, content):
        """ Handle the 'close' action from the Enaml widget.

        """
        self.widget().close()

    #--------------------------------------------------------------------------
    # Widget Update Methods
    #--------------------------------------------------------------------------
    def set_visible(self, visible):
        """ An overridden visibility setter which to opens|closes the
        notebook page.

        """
        widget = self.widget()
        if visible:
            widget.open()
        else:
            widget.close()

    def set_enabled(self, enabled):
        """ An overridden enabled setter which sets the tab enabled
        state.

        """
        self.widget().setTabEnabled(enabled)

    def set_title(self, title):
        """ Set the title of the tab for this page.

        """
        self.widget().setTitle(title)

    def set_closable(self, closable):
        """ Set whether or not this page is closable.

        """
        self.widget().setClosable(closable)

    def set_icon_source(self, icon_source):
        """ Sets the widget's icon to the provided image.

        """
        if icon_source:
            loader = self._session.load_resource(icon_source)
            loader.on_load(self._on_icon_load)
        else:
            self._on_icon_load(QIcon())

    #--------------------------------------------------------------------------
    # Private API
    #--------------------------------------------------------------------------
    def _on_icon_load(self, icon):
        """ A private resource loader callback.

        This method is invoked when the requested icon is successfully
        loaded. It will update the icon on the page widget.

        Parameters
        ----------
        icon : QIcon or QImage
            The icon or image that was loaded by the request.

        """
        if isinstance(icon, QImage):
            icon = QIcon(QPixmap.fromImage(icon))
        elif not isinstance(icon, QIcon):
            msg = 'got incorrect type for icon: `%s`'
            logger.error(msg % type(icon).__name__)
            icon = QIcon()
        self.widget().setIcon(icon)


########NEW FILE########
__FILENAME__ = qt_progress_bar
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from .qt.QtGui import QProgressBar
from .qt_control import QtControl


class QtProgressBar(QtControl):
    """ A Qt implementation of an Enaml ProgressBar.

    """
    #--------------------------------------------------------------------------
    # Setup Methods
    #--------------------------------------------------------------------------
    def create_widget(self, parent, tree):
        """ Create the underlying progress bar widget.

        """
        widget = QProgressBar(parent)
        widget.setTextVisible(False)
        return widget

    def create(self, tree):
        """ Create and initialize the underlying widget.

        """
        super(QtProgressBar, self).create(tree)
        self.set_minimum(tree['minimum'])
        self.set_maximum(tree['maximum'])
        self.set_value(tree['value'])

    #--------------------------------------------------------------------------
    # Message Handlers
    #--------------------------------------------------------------------------
    def on_action_set_minimum(self, content):
        """ Handle the 'set_minimum' action from the Enaml widget.

        """
        self.set_minimum(content['minimum'])

    def on_action_set_maximum(self, content):
        """ Handle the 'set_maximum' action from the Enaml widget.

        """
        self.set_maximum(content['maximum'])

    def on_action_set_value(self, content):
        """ Handle the 'set_value' action from the Enaml widget.

        """
        self.set_value(content['value'])

    #--------------------------------------------------------------------------
    # Widget Update Methods
    #--------------------------------------------------------------------------
    def set_minimum(self, value):
        """ Set the minimum value of the progress bar

        """
        self.widget().setMinimum(value)

    def set_maximum(self, value):
        """ Set the maximum value of the progress bar

        """
        self.widget().setMaximum(value)

    def set_value(self, value):
        """ Set the value of the progress bar

        """
        self.widget().setValue(value)


########NEW FILE########
__FILENAME__ = qt_push_button
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from .qt.QtGui import QPushButton
from .qt_abstract_button import QtAbstractButton
from .qt_menu import QtMenu


class QtPushButton(QtAbstractButton):
    """ A Qt implementation of an Enaml PushButton.

    """
    def create_widget(self, parent, tree):
        """ Create the underlying QPushButton widget.

        """
        return QPushButton(parent)

    def init_layout(self):
        """ Handle layout initialization for the push button.

        """
        super(QtPushButton, self).init_layout()
        self.widget().setMenu(self.menu())

    #--------------------------------------------------------------------------
    # Utility Methods
    #--------------------------------------------------------------------------
    def menu(self):
        """ Find and return the menu child for this widget.

        Returns
        -------
        result : QMenu or None
            The menu defined for this widget, or None if not defined.

        """
        widget = None
        for child in self.children():
            if isinstance(child, QtMenu):
                widget = child.widget()
        return widget

    #--------------------------------------------------------------------------
    # Child Events
    #--------------------------------------------------------------------------
    def child_removed(self, child):
        """ Handle the child removed event for a QtPushButton.

        """
        if isinstance(child, QtMenu):
            self.widget().setMenu(self.menu())

    def child_added(self, child):
        """ Handle the child added event for a QtPushButton.

        """
        if isinstance(child, QtMenu):
            self.widget().setMenu(self.menu())


########NEW FILE########
__FILENAME__ = qt_radio_button
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from .qt.QtGui import QRadioButton
from .qt_abstract_button import QtAbstractButton


class QtRadioButton(QtAbstractButton):
    """ A Qt implementation of an Enaml RadioButton.

    """
    def create_widget(self, parent, tree):
        """ Create the underlying radio button widget.

        """
        return QRadioButton(parent)


########NEW FILE########
__FILENAME__ = qt_resource
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
import logging

from .qt.QtGui import QImage, QIcon, QPixmap


logger = logging.getLogger(__name__)


_ICON_MODE_MAP = {
    'normal': QIcon.Normal,
    'disabled': QIcon.Disabled,
    'active': QIcon.Active,
    'selected': QIcon.Selected,
}


_ICON_STATE_MAP = {
    'off': QIcon.Off,
    'on': QIcon.On,
}


def convert_from_Image(image):
    """ Convert the given resource dict into a QImage.

    Parameters
    ----------
    image : dict
        A dictionary representation of an Enaml Image.

    Returns
    -------
    result : QImage
        The QImage instance for the given Enaml image dict.

    """
    format = image['format']
    if format == 'auto':
        format = ''
    return QImage.fromData(image['data'], format)


def convert_from_Icon(icon):
    """ Convert the given resource dict into a QIcon.

    Parameters
    ----------
    image : dict
        A dictionary representation of an Enaml Icon.

    Returns
    -------
    result : QIcon
        The QIcon instance for the given Enaml icon dict.

    """
    qicon = QIcon()
    for img in icon['images']:
        mode = _ICON_MODE_MAP[img['mode']]
        state = _ICON_STATE_MAP[img['state']]
        image = convert_resource(img['image'])
        qicon.addPixmap(QPixmap.fromImage(image), mode, state)
    return qicon


def convert_resource(resource):
    """ Convert a resource dict into a Qt resource handle.

    Parameters
    ----------
    resource : dict
        A dictionary representation of the Qt resource to create.

    Returns
    -------
    result : QObject or None
        An appropriate Qt object for the resource, or None if the
        resource could not be converted.

    """
    items = globals()
    name = resource['class']
    handler = items.get('convert_from_' + name)
    if handler is None:
        for name in resource['bases']:
            handler = items.get('load_' + name)
            if handler is not None:
                break
        if handler is None:
            msg = 'failed to create resource `%s:%s`'
            logger.error(msg % (resource['class'], resource['bases']))
            return
    return handler(resource)


########NEW FILE########
__FILENAME__ = qt_resource_manager
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
import logging
from urlparse import urlparse

from enaml.utils import id_generator

from .q_deferred_caller import deferredCall
from .qt_resource import convert_resource


logger = logging.getLogger(__name__)


#: An id generator for making requests to the server.
req_id_generator = id_generator('r_')


class DeferredResource(object):
    """ An deferred resource object returned by a `QtURLRequestManager`.

    Instances of this class are provided to widgets when they request a
    resource url. Since the url may need to be retrieved from a server,
    Loading occurs asynchronously. This object allows a widget to supply
    a callback to be invoked when the resource is loaded.

    """
    __slots__ = ('_callback')

    def __init__(self):
        """ Initialize a DeferredResource.

        """
        self._callback = None

    #--------------------------------------------------------------------------
    # Private API
    #--------------------------------------------------------------------------
    def _notify(self, resource):
        """ Notify the consumer that the resource is available.

        This method is invoked directly by a `QtResourceManager`. It
        should not be called by user code.

        Parameters
        ----------
        resource : object
            An object of the appropriate type for the requested resource.

        """
        callback = self._callback
        self._callback = None
        if callback is not None:
            callback(resource)

    #--------------------------------------------------------------------------
    # Public API
    #--------------------------------------------------------------------------
    def on_load(self, callback):
        """ Register a callback to be invoked on resource load.

        Parameters
        ----------
        callback : callable
            A callable which accepts a single argument, which is the
            resource object loaded for the requested resource.

        """
        self._callback = callback


class QtResourceManager(object):
    """ An object which manages requesting urls from the server session.

    """
    def __init__(self):
        """ Initialize a QtResourceManager.

        """
        self._handles = {}
        self._pending = {}

    def load(self, url, metadata, request):
        """ Load the resource handle for the given url.

        This method will asynchronously load the resource for the given
        url, requesting it from the server side session if needed.

        Parameters
        ----------
        url : str
            The url pointing to the resource to load.

        metadata : dict
            Additional metadata required by the session to load the
            requested resource. See the individual load handlers for
            the supported metadata.

        request : URLRequest
            An URLRequest instance to use for making requests from the
            server side session, if such requests are required.

        Returns
        -------
        result : DeferredResource
            A deferred resource object which will invoke a callback on
            resource load.

        """
        loader = DeferredResource()
        scheme = urlparse(url).scheme
        key_handler = getattr(self, '_make_%s_key' % scheme, None)
        if key_handler is None:
            msg = 'unhandled request scheme for url: `%s`'
            logger.error(msg % url)
            return loader
        keyval = key_handler(metadata)
        key = (url, keyval)
        handles = self._handles
        if key in handles:
            deferredCall(loader._notify, handles[key])
            return loader
        pending = self._pending
        if key in pending:
            pending[key].append(loader)
            return loader
        req_id = req_id_generator.next()
        pending[req_id] = key
        pending[key] = [loader]
        request(req_id, url, metadata)
        return loader

    def on_load(self, req_id, url, resource):
        """ Handle the loading of a requested resource.

        This method is called by the QtSession object when it receives
        a reply for a previously requested resource.

        Parameters
        ----------
        req_id : str
            The unique identifier for the request.

        url : str
            The resource url which was requested.

        resource : dict
            The dictionary representation of the loaded resource.

        """
        pending = self._pending
        if req_id in pending:
            key = pending.pop(req_id)
            if key in pending:
                loaders = pending.pop(key)
            else:
                loaders = ()
            qt_resource = convert_resource(resource)
            if qt_resource is not None:
                self._handles[key] = qt_resource
                for loader in loaders:
                    loader._notify(qt_resource)

    def on_fail(self, req_id, url):
        """ Handle the failed loading of a requested resource.

        This method is called by the QtSession object when it receives
        a reply for a previously requested resource which failed to
        properly load.

        Parameters
        ----------
        req_id : str
            The unique identifier for the request.

        url : str
            The resource url which was requested.

        resource : dict
            The dictionary representation of the resrouce

        """
        # TODO use something like a failed-to-load image here?
        pending = self._pending
        if req_id in pending:
            key = pending.pop(req_id)
            if key in pending:
                del pending[key]

    #--------------------------------------------------------------------------
    # Private API
    #--------------------------------------------------------------------------
    def _make_image_key(self, metadata):
        """ Make a key value for the image metadata.

        Parameters
        ----------
        metadata : dict
            The image accepts optional 'size' metadata which is the
            desired size with which to load the image. The default is
            (-1, -1) which indicates the natural size should be used.

        Returns
        -------
        result : tuple
            The size with which to load the image.

        """
        return metadata.get('size', (-1, -1))

    def _make_icon_key(self, metatdata):
        """ Make a key value for the icon metadata.

        Parameters
        ----------
        metadata : dict
            The icon accepts no metadata. Any data in this dict will be
            ignored.

        Returns
        -------
        result : None
            This method always returns None.

        """
        return None


########NEW FILE########
__FILENAME__ = qt_scroll_area
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from .qt.QtCore import Qt, QEvent, QSize, Signal
from .qt.QtGui import QScrollArea
from .qt_constraints_widget import QtConstraintsWidget
from .qt_container import QtContainer


SCROLLBAR_MAP = {
    'as_needed' : Qt.ScrollBarAsNeeded,
    'always_off' : Qt.ScrollBarAlwaysOff,
    'always_on' : Qt.ScrollBarAlwaysOn
}


class QCustomScrollArea(QScrollArea):
    """ A custom QScrollArea for use with the QtScrollArea.

    This subclass fixes some bugs related to size hints.

    """
    #: A signal emitted when a LayoutRequest event is posted to the
    #: scroll area. This will typically occur when the size hint of
    #: the scroll area is no longer valid.
    layoutRequested = Signal()

    #: A private internally cached size hint.
    _size_hint = QSize()

    def event(self, event):
        """ A custom event handler which handles LayoutRequest events.

        When a LayoutRequest event is posted to this widget, it will
        emit the `layoutRequested` signal. This allows an external
        consumer of this widget to update their external layout.

        """
        res = super(QCustomScrollArea, self).event(event)
        if event.type() == QEvent.LayoutRequest:
            self._size_hint = QSize()
            self.layoutRequested.emit()
        return res

    def setWidget(self, widget):
        """ Set the widget for this scroll area.

        This is a reimplemented parent class method which invalidates
        the cached size hint before setting the widget.

        """
        self._size_hint = QSize()
        self.takeWidget() # Let Python keep ownership of the old widget
        super(QCustomScrollArea, self).setWidget(widget)

    def sizeHint(self):
        """ Get the size hint for the scroll area.

        This reimplemented method fixes a Qt bug where the size hint
        is not updated after the scroll widget is first shown. The
        bug is documented on the Qt bug tracker:
        https://bugreports.qt-project.org/browse/QTBUG-10545

        """
        # This code is ported directly from QScrollArea.cpp but instead
        # of caching the size hint of the scroll widget, it caches the
        # size hint for the entire scroll area, and invalidates it when
        # the widget is changed or it receives a LayoutRequest event.
        hint = self._size_hint
        if hint.isValid():
            return QSize(hint)
        fw = 2 * self.frameWidth()
        hint = QSize(fw, fw)
        font_height = self.fontMetrics().height()
        widget = self.widget()
        if widget is not None:
            if self.widgetResizable():
                hint += widget.sizeHint()
            else:
                hint += widget.size()
        else:
            hint += QSize(12 * font_height, 8 * font_height)
        if self.verticalScrollBarPolicy() == Qt.ScrollBarAlwaysOn:
            vbar = self.verticalScrollBar()
            hint.setWidth(hint.width() + vbar.sizeHint().width())
        if self.horizontalScrollBarPolicy() == Qt.ScrollBarAlwaysOn:
            hbar = self.horizontalScrollBar()
            hint.setHeight(hint.height() + hbar.sizeHint().height())
        hint = hint.boundedTo(QSize(36 * font_height, 24 * font_height))
        self._size_hint = hint
        return QSize(hint)


class QtScrollArea(QtConstraintsWidget):
    """ A Qt implementation of an Enaml ScrollArea.

    """
    #: A private cache of the old size hint for the scroll area.
    _old_hint = None

    #--------------------------------------------------------------------------
    # Setup Methods
    #--------------------------------------------------------------------------
    def create_widget(self, parent, tree):
        """ Create the underlying QScrollArea widget.

        """
        return QCustomScrollArea(parent)

    def create(self, tree):
        """ Create and initialize the underlying widget.

        """
        super(QtScrollArea, self).create(tree)
        self.set_horizontal_policy(tree['horizontal_policy'])
        self.set_vertical_policy(tree['vertical_policy'])
        self.set_widget_resizable(tree['widget_resizable'])

    def init_layout(self):
        """ Initialize the layout of the underlying widget.

        """
        super(QtScrollArea, self).init_layout()
        widget = self.widget()
        widget.setWidget(self.scroll_widget())
        widget.layoutRequested.connect(self.on_layout_requested)

    #--------------------------------------------------------------------------
    # Utility Methods
    #--------------------------------------------------------------------------
    def scroll_widget(self):
        """ Find and return the scroll widget child for this widget.

        Returns
        -------
        result : QWidget or None
            The scroll widget defined for this widget, or None if one is
            not defined.

        """
        widget = None
        for child in self.children():
            if isinstance(child, QtContainer):
                widget = child.widget()
        return widget

    #--------------------------------------------------------------------------
    # Child Events
    #--------------------------------------------------------------------------
    def child_removed(self, child):
        """ Handle the child removed event for a QtScrollArea.

        """
        if isinstance(child, QtContainer):
            self.widget().setWidget(self.scroll_widget())

    def child_added(self, child):
        """ Handle the child added event for a QtScrollArea.

        """
        if isinstance(child, QtContainer):
            self.widget().setWidget(self.scroll_widget())

    #--------------------------------------------------------------------------
    # Signal Handlers
    #--------------------------------------------------------------------------
    def on_layout_requested(self):
        """ Handle the `layoutRequested` signal from the QScrollArea.

        """
        new_hint = self.widget().sizeHint()
        if new_hint != self._old_hint:
            self._old_hint = new_hint
            self.size_hint_updated()

    #--------------------------------------------------------------------------
    # Overrides
    #--------------------------------------------------------------------------
    def replace_constraints(self, old_cns, new_cns):
        """ A reimplemented QtConstraintsWidget layout method.

        Constraints layout may not cross the boundary of a ScrollArea,
        so this method is no-op which stops the layout propagation.

        """
        pass

    def clear_constraints(self, cns):
        """ A reimplemented QtConstraintsWidget layout method.

        Constraints layout may not cross the boundary of a ScrollArea,
        so this method is no-op which stops the layout propagation.

        """
        pass

    #--------------------------------------------------------------------------
    # Message Handlers
    #--------------------------------------------------------------------------
    def on_action_set_horizontal_policy(self, content):
        """ Handle the 'set_horizontal_policy' action from the Enaml
        widget.

        """
        self.set_horizontal_policy(content['horizontal_policy'])

    def on_action_set_vertical_policy(self, content):
        """ Handle the 'set_vertical_policy' action from the Enaml
        widget.

        """
        self.set_vertical_policy(content['vertical_policy'])

    def on_action_set_widget_resizable(self, content):
        """ Handle the 'set_widget_resizable' action from the Enaml
        widget.

        """
        self.set_widget_resizable(content['widget_resizable'])

    #--------------------------------------------------------------------------
    # Widget Update Methods
    #--------------------------------------------------------------------------
    def set_horizontal_policy(self, policy):
        """ Set the horizontal scrollbar policy of the widget.

        """
        self.widget().setHorizontalScrollBarPolicy(SCROLLBAR_MAP[policy])

    def set_vertical_policy(self, policy):
        """ Set the vertical scrollbar policy of the widget.

        """
        self.widget().setVerticalScrollBarPolicy(SCROLLBAR_MAP[policy])

    def set_widget_resizable(self, resizable):
        """ Set whether or not the scroll widget is resizable.

        """
        self.widget().setWidgetResizable(resizable)


########NEW FILE########
__FILENAME__ = qt_separator
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from .qt.QtCore import QSize
from .qt.QtGui import QFrame
from .qt_control import QtControl


# A mapping from Enaml orientation to frame shape enum.
_SHAPE_MAP = {
    'horizontal': QFrame.HLine,
    'vertical': QFrame.VLine,
}


# A mapping from Enaml line style to frame shadow enum.
_SHADOW_MAP = {
    'sunken': QFrame.Sunken,
    'raised': QFrame.Raised,
    'plain': QFrame.Plain
}


class QSeparator(QFrame):
    """ A QFrame subclass which acts as a separator.

    This subclass reimplements the sizeHint method to compute a hint
    which is appropriate for a frame being used as a vertical or
    horizontal separator line.

    """
    def sizeHint(self):
        # The default sizeHint method returns (-1, 3) or (3, -1) when
        # the frame is used as a separator, regardless of the computed
        # frame width. This override corrects that behavior.
        hint = super(QSeparator, self).sizeHint()
        if self.frameShadow() in (QFrame.Raised, QFrame.Sunken):
            shape = self.frameShape()
            if shape == QFrame.HLine:
                hint = QSize(hint.width(), max(3, self.frameWidth() * 2))
            elif shape == QFrame.VLine:
                hint = QSize(max(3, self.frameWidth() * 2), hint.height())
        return hint


class QtSeparator(QtControl):
    """ A Qt implementation of an Enaml Separator.

    """
    def create_widget(self, parent, tree):
        """ Create underlying QSeparator control.

        """
        return QSeparator(parent)

    def create(self, tree):
        """ Create and initialize the underlying widget.

        """
        super(QtSeparator, self).create(tree)
        self.set_orientation(tree['orientation'])
        self.set_line_style(tree['line_style'])
        self.set_line_width(tree['line_width'])
        self.set_midline_width(tree['midline_width'])

    #--------------------------------------------------------------------------
    # Message Handling
    #--------------------------------------------------------------------------
    def on_action_set_orientation(self, content):
        """ Handle the 'set_orientation' action from the Enaml widget.

        """
        self.set_orientation(content['orientation'])
        self.size_hint_updated()

    def on_action_set_line_style(self, content):
        """ Handle the 'set_line_style' action from the Enaml widget.

        """
        self.set_line_style(content['line_style'])
        self.size_hint_updated()

    def on_action_set_line_width(self, content):
        """ Handle the 'set_line_width' action from the Enaml widget.

        """
        self.set_line_width(content['line_width'])
        self.size_hint_updated()
        self.widget().update()

    def on_action_set_midline_width(self, content):
        """ Handle the 'set_midline_width' action from the Enaml widget.

        """
        self.set_midline_width(content['midline_width'])
        self.size_hint_updated()
        self.widget().update()

    #--------------------------------------------------------------------------
    # Widget Update Methods
    #--------------------------------------------------------------------------
    def set_orientation(self, orientation):
        """ Set the orientation of the underlying widget.

        """
        self.widget().setFrameShape(_SHAPE_MAP[orientation])

    def set_line_style(self, style):
        """ Set the line style of the underlying widget.

        """
        self.widget().setFrameShadow(_SHADOW_MAP[style])

    def set_line_width(self, width):
        """ Set the line width of the underlying widget.

        """
        self.widget().setLineWidth(width)

    def set_midline_width(self, width):
        """ Set the midline width of the underlying widget.

        """
        self.widget().setMidLineWidth(width)


########NEW FILE########
__FILENAME__ = qt_session
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from collections import defaultdict
import logging

from enaml.utils import make_dispatcher

from .qt_resource_manager import QtResourceManager
from .qt_widget_registry import QtWidgetRegistry


logger = logging.getLogger(__name__)


#: The dispatch function for action dispatching.
dispatch_action = make_dispatcher('on_action_', logger)


class URLRequest(object):
    """ A simple object for making url requests.

    """
    def __init__(self, session):
        """ Initialize a URLRequest.

        Parameters
        ----------
        session : Session
            The session object for which the url is being requested.

        """
        self._session = session

    def __call__(self, req_id, url, metadata):
        """ Make a request for the given url resource.

        Parameters
        ----------
        req_id : str
            A unique identifier for this request.

        url : str
            The resource url which should be requested.

        metadata : dict
            Additional metadata to pass along with the request.

        Returns
        -------
        result : bool

        """
        content = {}
        content['id'] = req_id
        content['url'] = url
        content['metadata'] = metadata
        session = self._session
        session.send(session._session_id, 'url_request', content)


class QtSession(object):
    """ An object which manages a session of Qt client objects.

    """
    def __init__(self, session_id, widget_groups):
        """ Initialize a QtSession.

        Parameters
        ----------
        session_id : str
            The string identifier for this session.

        widget_groups : list of str
            The list of string widget groups for this session.

        """
        self._session_id = session_id
        self._widget_groups = widget_groups
        self._resource_manager = QtResourceManager()
        self._registered_objects = {}
        self._windows = []
        self._socket = None

    #--------------------------------------------------------------------------
    # Public API
    #--------------------------------------------------------------------------
    def open(self, snapshot):
        """ Open the session using the given snapshot.

        Parameters
        ----------
        snapshot : list of dicts
            The list of tree snapshots to build for this session.

        """
        windows = self._windows
        for tree in snapshot:
            window = self.build(tree, None)
            if window is not None:
                windows.append(window)
                window.initialize()

    def activate(self, socket):
        """ Active the session and its windows.

        Parameters
        ----------
        socket : ActionSocketInterface
            The socket interface to use for messaging with the server
            side Enaml objects.

        """
        # Setup the socket before activation so that widgets may
        # request resources from the server for startup purposes.
        self._socket = socket
        socket.on_message(self.on_message)
        for window in self._windows:
            window.activate()

    def build(self, tree, parent):
        """ Build and return a new widget using the given tree dict.

        Parameters
        ----------
        tree : dict
            The dictionary snapshot representation of the tree of
            items to build.

        parent : QtObject or None
            The parent for the tree, or None if the tree is top-level.

        Returns
        -------
        result : QtObject or None
            The object representation of the root of the tree, or None
            if it could not be built. If the object cannot be built,
            the building errors will be sent to the error logger.

        """
        groups = self._widget_groups
        factory = QtWidgetRegistry.lookup(tree['class'], groups)
        if factory is None:
            for class_name in tree['bases']:
                factory = QtWidgetRegistry.lookup(class_name, groups)
                if factory is not None:
                    break
        if factory is None:
            msg =  'Unhandled object type: %s:%s'
            item_class = tree['class']
            item_bases = tree['bases']
            logger.error(msg % (item_class, item_bases))
            return
        obj = factory().construct(tree, parent, self)
        for child in tree['children']:
            self.build(child, obj)
        return obj

    def register(self, obj):
        """ Register an object with the session.

        QtObjects are registered automatically during construction.

        Parameters
        ----------
        obj : QtObject
            The QtObject to register with the session.

        """
        self._registered_objects[obj.object_id()] = obj

    def unregister(self, obj):
        """ Unregister an object from the session.

        QtObjects are unregistered automatically during destruction.

        Parameters
        ----------
        obj : QtObject
            The QtObject to unregister from the session.

        """
        self._registered_objects.pop(obj.object_id(), None)

    def lookup(self, object_id):
        """ Lookup a registered object with the given object id.

        Parameters
        ----------
        object_id : str
            The object id for the object to lookup.

        Returns
        -------
        result : QtObject or None
            The registered QtObject with the given identifier, or None
            if no registered object is found.

        """
        return self._registered_objects.get(object_id)

    def load_resource(self, url, metadata=None):
        """ Asynchronously Load the resource pointed to by the given url.

        Parameters
        ----------
        url : str
            The url pointed to the resource that should be loaded.

        metadata : dict, optional
            Additional metadata required by the session to load the
            requested resource.

        Returns
        -------
        result : DeferredResource
            A deferred object which will invoke a callback when the
            resource for the url is loaded.

        """
        if metadata is None:
            metadata = {}
        request = URLRequest(self)
        return self._resource_manager.load(url, metadata, request)

    #--------------------------------------------------------------------------
    # Messaging API
    #--------------------------------------------------------------------------
    def send(self, object_id, action, content):
        """ Send a message to a server object.

        This method is called by the `QtObject` instances owned by this
        session to send messages to their server implementations.

        Parameters
        ----------
        object_id : str
            The object id of the server object.

        action : str
            The action that should be performed by the object.

        content : dict
            The content dictionary for the action.

        """
        socket = self._socket
        if socket is not None:
            socket.send(object_id, action, content)

    def on_message(self, object_id, action, content):
        """ Receive a message sent to an object owned by this session.

        This is a handler method registered as the callback for the
        action socket. The message will be routed to the appropriate
        `QtObject` instance.

        Parameters
        ----------
        object_id : str
            The object id of the target object.

        action : str
            The action that should be performed by the object.

        content : dict
            The content dictionary for the action.

        """
        if object_id == self._session_id:
            dispatch_action(self, action, content)
        else:
            try:
                obj = self._registered_objects[object_id]
            except KeyError:
                msg = "Invalid object id sent to QtSession: %s:%s"
                logger.warn(msg % (object_id, action))
                return
            else:
                obj.receive_action(action, content)

    #--------------------------------------------------------------------------
    # Action Handlers
    #--------------------------------------------------------------------------
    def on_action_add_window(self, content):
        """ Handle the 'add_window' action from the Enaml session.

        """
        window = self.build(content['window'], None)
        if window is not None:
            self._windows.append(window)
            window.initialize()
            window.activate()

    def on_action_url_reply(self, content):
        """ Handle the 'url_reply' action from the Enaml session.

        """
        url = content['url']
        req_id = content['id']
        status = content['status']
        manager = self._resource_manager
        if status == 'ok':
            resource = content['resource']
            manager.on_load(req_id, url, resource)
        else:
            manager.on_fail(req_id, url)

    def on_action_message_batch(self, content):
        """ Handle the 'message_batch' action sent by the Enaml session.

        Actions sent to the message batch are processed in the following
        order 'children_changed' -> 'destroy' -> 'relayout' -> other...

        """
        actions = defaultdict(list)
        for item in content['batch']:
            action = item[1]
            actions[action].append(item)
        ordered = []
        batch_order = ('children_changed', 'destroy', 'relayout')
        for key in batch_order:
            ordered.extend(actions.pop(key, ()))
        for value in actions.itervalues():
            ordered.extend(value)
        objects = self._registered_objects
        for object_id, action, msg_content in ordered:
            try:
                obj = objects[object_id]
            except KeyError:
                msg = "Invalid object id sent to QtSession %s:%s"
                logger.warn(msg % (object_id, action))
            else:
                dispatch_action(obj, action, msg_content)

    def on_action_close(self, content):
        """ Handle the 'close' action sent by the Enaml session.

        """
        for window in self._windows:
            window.destroy()
        self._windows = []
        self._registered_objects = {}
        self._resource_manager = None
        self._socket.on_message(None)
        self._socket = None


########NEW FILE########
__FILENAME__ = qt_slider
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from .qt.QtCore import Qt
from .qt.QtGui import QSlider
from .qt_control import QtControl


#: A map from Enaml constants to QSlider TickPosition values.
_TICK_POSITION_MAP = {
    'no_ticks': QSlider.NoTicks,
    'left': QSlider.TicksLeft,
    'right': QSlider.TicksRight,
    'top': QSlider.TicksAbove,
    'bottom': QSlider.TicksBelow,
    'both':QSlider.TicksBothSides
}


#: A map from Enaml enums to Qt constants for horizontal or vertical
#: orientation.
_ORIENTATION_MAP = {
    'horizontal': Qt.Horizontal,
    'vertical': Qt.Vertical
}


class QtSlider(QtControl):
    """ A Qt implementation of an Enaml Slider.

    """
    #--------------------------------------------------------------------------
    # Setup Methods
    #--------------------------------------------------------------------------
    def create_widget(self, parent, tree):
        """ Create the underlying QSlider widget.

        """
        return QSlider(parent)

    def create(self, tree):
        """ Create and initialize the underlying widget.

        """
        super(QtSlider, self).create(tree)
        # Initialize the value after the minimum and maximum to avoid
        # the potential for premature internal clipping of the value.
        self.set_minimum(tree['minimum'])
        self.set_maximum(tree['maximum'])
        self.set_value(tree['value'])
        self.set_orientation(tree['orientation'])
        self.set_page_step(tree['page_step'])
        self.set_single_step(tree['single_step'])
        self.set_tick_interval(tree['tick_interval'])
        self.set_tick_position(tree['tick_position'])
        self.set_tracking(tree['tracking'])
        self.widget().valueChanged.connect(self.on_value_changed)

    #--------------------------------------------------------------------------
    # Message Handlers
    #--------------------------------------------------------------------------
    def on_action_set_value(self, content):
        """ Handle the 'set_value' action from the Enaml widget.

        """
        self.set_value(content['value'])

    def on_action_set_maximum(self, content):
        """ Handle the 'set_maximum' action from the Enaml widget.

        """
        self.set_maximum(content['maximum'])

    def on_action_set_minimum(self, content):
        """ Handle the 'set_minimum' action from the Enaml widget.

        """
        self.set_minimum(content['minimum'])

    def on_action_set_orientation(self, content):
        """ Handle the 'set_orientation' action from the Enaml widget.

        """
        self.set_orientation(content['orientation'])

    def on_action_set_page_step(self, content):
        """ Handle the 'set_page_step' action from the Enaml widget.

        """
        self.set_page_step(content['page_step'])

    def on_action_set_single_step(self, content):
        """ Handle the 'set_single_step' action from the Enaml widget.

        """
        self.set_single_step(content['single_step'])

    def on_action_set_tick_interval(self, content):
        """ Handle the 'set_tick_interval' action from the Enaml widget.

        """
        self.set_tick_interval(content['tick_interval'])

    def on_action_set_tick_position(self, content):
        """ Handle the 'set_tick_position' action from the Enaml widget.

        """
        self.set_tick_position(content['tick_position'])

    def on_action_set_tracking(self, content):
        """ Handle the 'set_tracking' action from the Enaml widget.

        """
        self.set_tracking(content['tracking'])

    #--------------------------------------------------------------------------
    # Signal Handlers
    #--------------------------------------------------------------------------
    def on_value_changed(self):
        """ Send the 'value_changed' action to the Enaml widget when the
        slider value has changed.

        """
        if 'value' not in self.loopback_guard:
            content = {'value': self.widget().value()}
            self.send_action('value_changed', content)

    #--------------------------------------------------------------------------
    # Widget Update Methods
    #--------------------------------------------------------------------------
    def set_value(self, value):
        """ Set the value of the underlying widget.

        """
        with self.loopback_guard('value'):
            self.widget().setValue(value)

    def set_maximum(self, maximum):
        """ Set the maximum value of the underlying widget.

        """
        self.widget().setMaximum(maximum)

    def set_minimum(self, minimum):
        """ Set the minimum value of the underlying widget.

        """
        self.widget().setMinimum(minimum)

    def set_orientation(self, orientation):
        """ Set the orientation of the underlying widget.

        """
        self.widget().setOrientation(_ORIENTATION_MAP[orientation])

    def set_page_step(self, page_step):
        """ Set the page step of the underlying widget.

        """
        self.widget().setPageStep(page_step)

    def set_single_step(self, single_step):
        """ Set the single step of the underlying widget.

        """
        self.widget().setSingleStep(single_step)

    def set_tick_interval(self, interval):
        """ Set the tick interval of the underlying widget.

        """
        self.widget().setTickInterval(interval)

    def set_tick_position(self, tick_position):
        """ Set the tick position of the underlying widget.

        """
        self.widget().setTickPosition(_TICK_POSITION_MAP[tick_position])

    def set_tracking(self, tracking):
        """ Set the tracking of the underlying widget.

        """
        self.widget().setTracking(tracking)


########NEW FILE########
__FILENAME__ = qt_spin_box
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from .qt.QtGui import QSpinBox
from .qt_control import QtControl


class QtSpinBox(QtControl):
    """ A Qt implementation of an Enaml SpinBox.

    """
    #--------------------------------------------------------------------------
    # Setup Methods
    #--------------------------------------------------------------------------
    def create_widget(self, parent, tree):
        """ Create the underlying QSpinBox widget.

        """
        widget = QSpinBox(parent)
        widget.setKeyboardTracking(False)
        return widget

    def create(self, tree):
        """ Create and initialize the underlying widget.

        """
        super(QtSpinBox, self).create(tree)
        self.set_maximum(tree['maximum'])
        self.set_minimum(tree['minimum'])
        self.set_value(tree['value'])
        self.set_prefix(tree['prefix'])
        self.set_suffix(tree['suffix'])
        self.set_special_value_text(tree['special_value_text'])
        self.set_single_step(tree['single_step'])
        self.set_read_only(tree['read_only'])
        self.set_wrapping(tree['wrapping'])
        self.widget().valueChanged.connect(self.on_value_changed)

    #--------------------------------------------------------------------------
    # Signal Handler
    #--------------------------------------------------------------------------
    def on_value_changed(self):
        """ The signal handler for the 'valueChanged' signal.

        """
        # Guard against loopback recursion since Qt will emit the
        # valueChanged signal when programatically setting the value.
        if 'value' not in self.loopback_guard:
            content = {'value': self.widget().value()}
            self.send_action('value_changed', content)

    #--------------------------------------------------------------------------
    # Message Handlers
    #--------------------------------------------------------------------------
    def on_action_set_maximum(self, content):
        """ Handler for the 'set_maximum' action from the Enaml widget.

        """
        self.set_maximum(content['maximum'])

    def on_action_set_minimum(self, content):
        """ Handler for the 'set_minimum' action from the Enaml widget.

        """
        self.set_minimum(content['minimum'])

    def on_action_set_value(self, content):
        """ Handler for the 'set_value' action from the Enaml widget.

        """
        self.set_value(content['value'])

    def on_action_set_prefix(self, content):
        """ Handler for the 'set_prefix' action from the Enaml widget.

        """
        self.set_prefix(content['prefix'])

    def on_action_set_suffix(self, content):
        """ Handler for the 'set_suffix' action from the Enaml widget.

        """
        self.set_suffix(content['suffix'])

    def on_action_set_special_value_text(self, content):
        """ Handler for the 'set_special_value_text' action from the
        Enaml widget.

        """
        self.set_special_value_text(content['special_value_text'])

    def on_action_set_single_step(self, content):
        """ Handler for the 'set_single_step' action from the Enaml
        widget.

        """
        self.set_single_step(content['single_step'])

    def on_action_set_read_only(self, content):
        """ Handler for the 'set_read_only' action from the Enaml
        widget.

        """
        self.set_read_only(content['read_only'])

    def on_action_set_wrapping(self, content):
        """ Handler for the 'set_wrapping' action from the Enaml
        widget.

        """
        self.set_wrapping(content['wrapping'])

    #--------------------------------------------------------------------------
    # Widget Update Methods
    #--------------------------------------------------------------------------
    def set_maximum(self, maximum):
        """ Set the widget's maximum value.

        """
        self.widget().setMaximum(maximum)

    def set_minimum(self, minimum):
        """ Set the widget's minimum value.

        """
        self.widget().setMinimum(minimum)

    def set_value(self, value):
        """ Set the spin box's value.

        """
        # The setValue will emit a changed signal. Since this will only
        # be called as a result of an Enaml action, we guard against
        # the loopback
        with self.loopback_guard('value'):
            self.widget().setValue(value)

    def set_prefix(self, prefix):
        """ Set the prefix for the spin box.

        """
        self.widget().setPrefix(prefix)

    def set_suffix(self, suffix):
        """ Set the suffix for the spin box.

        """
        self.widget().setSuffix(suffix)

    def set_special_value_text(self, text):
        """ Set the special value text for the spin box.

        """
        self.widget().setSpecialValueText(text)

    def set_single_step(self, step):
        """ Set the widget's single step value.

        """
        self.widget().setSingleStep(step)

    def set_read_only(self, read_only):
        """ Set the widget's read only flag.

        """
        self.widget().setReadOnly(read_only)

    def set_wrapping(self, wrapping):
        """ Set the widget's wrapping flag.

        """
        self.widget().setWrapping(wrapping)


########NEW FILE########
__FILENAME__ = qt_splitter
#------------------------------------------------------------------------------
# Copyright (c) 2011, Enthought, Inc.
# All rights reserved.
#------------------------------------------------------------------------------
import sys

from .qt.QtCore import Qt, QEvent, Signal
from .qt.QtGui import (
    QSplitter, QSplitterHandle, QVBoxLayout, QFrame, QApplication
)
from .qt_constraints_widget import QtConstraintsWidget
from .qt_split_item import QtSplitItem


_ORIENTATION_MAP = {
    'horizontal': Qt.Horizontal,
    'vertical': Qt.Vertical,
}


class QWinSplitterHandle(QSplitterHandle):
    """ A custom QSplitterHandle which is used on win32 platforms.

    The native Windows style draws the splitter handle the same color as
    the widget background, which makes it invisible for most cases. This
    subclass overlays a raised line on the splitter to provide a little
    bit of visual feedback.

    """
    def __init__(self, orientation, parent=None):
        super(QWinSplitterHandle, self).__init__(orientation, parent)
        self._frame = frame = QFrame(self)
        l = QVBoxLayout()
        l.addWidget(frame)
        l.setSpacing(0)
        l.setContentsMargins(0, 0, 0, 0)
        self.setLayout(l)
        self.updateFrame()

    def updateFrame(self):
        """ Update the internal frame style for the current orientation.

        """
        orientation = self.orientation()
        s = QFrame.VLine if orientation == Qt.Horizontal else QFrame.HLine
        self._frame.setFrameStyle(s | QFrame.Raised)


class QCustomSplitter(QSplitter):
    """ A custom QSplitter which handles children of type QSplitItem.

    """
    #: A signal emitted when a LayoutRequest event is posted to the
    #: splitter widget. This will typically occur when the size hint
    #: of the splitter is no longer valid.
    layoutRequested = Signal()

    def createHandle(self):
        """ A reimplemented virtual method to create splitter handles.

        On win32 platforms, this will return a custom QSplitterHandle
        which works around an issue with handle not drawing nicely. On
        all other platforms, a normal QSplitterHandler widget.

        """
        if sys.platform == 'win32':
            return QWinSplitterHandle(self.orientation(), self)
        return QSplitterHandle(self.orientation(), self)

    def setOrientation(self, orientation):
        """ Set the orientation of the splitter.

        This overriden method will call the `updateFrame` method of the
        splitter handles when running on win32 platforms. On any other
        platform, this method simply calls the superclass method.

        """
        old = self.orientation()
        if old != orientation:
            super(QCustomSplitter, self).setOrientation(orientation)
            if sys.platform == 'win32':
                for idx in xrange(self.count()):
                    handle = self.handle(idx)
                    handle.updateFrame()

    def event(self, event):
        """ A custom event handler which handles LayoutRequest events.

        When a LayoutRequest event is posted to this widget, it will
        emit the `layoutRequested` signal. This allows an external
        consumer of this widget to update their external layout.

        """
        res = super(QCustomSplitter, self).event(event)
        if event.type() == QEvent.LayoutRequest:
            self.layoutRequested.emit()
        return res


class QtSplitter(QtConstraintsWidget):
    """ A Qt implementation of an Enaml Splitter.

    """
    #--------------------------------------------------------------------------
    # Setup methods
    #--------------------------------------------------------------------------
    def create_widget(self, parent, tree):
        """ Creates the underlying QSplitter control.

        """
        return QCustomSplitter(parent)

    def create(self, tree):
        """ Create and initialize the underlying control.

        """
        super(QtSplitter, self).create(tree)
        self.set_orientation(tree['orientation'])
        self.set_live_drag(tree['live_drag'])

    def init_layout(self):
        """ Handle the layout initialization for the splitter.

        """
        super(QtSplitter, self).init_layout()
        widget = self.widget()
        for child in self.children():
            if isinstance(child, QtSplitItem):
                widget.addWidget(child.widget())
        widget.layoutRequested.connect(self.on_layout_requested)

        # On Windows, messages are consumed from three different queues,
        # each with a different priority. The lowest priority is the
        # queue which holds WM_PAINT messages. Dragging the splitter bar
        # generates WM_MOUSEMOVE messages which have a higher priority.
        # These messages (dragging the bar) generate size events in Qt
        # which are delivered immediately. This means that if handling
        # the resize event from the drag takes too long (> ~800us) then
        # another size event will arrive before the paint event, since
        # the new WM_MOUSEMOVE will be processed before the WM_PAINT.
        # So on Windows, the `splitterMoved` signal, which is emitted
        # on every drag, is connected to a handler which will force a
        # repaint if opaque resize is turned on. Since paint event are
        # collapsed, the effect of this is to restore the order of event
        # processing.
        if sys.platform == 'win32':
            widget.splitterMoved.connect(self.on_win32_splitter_moved)

    #--------------------------------------------------------------------------
    # Child Events
    #--------------------------------------------------------------------------

    # QSplitter automatically removes a widget when it's reparented. The
    # base child_removed event will set the parent to None, and that is
    # all that is needed.

    def child_added(self, child):
        """ Handle the child added event for a QtSplitter.

        """
        if isinstance(child, QtSplitItem):
            index = self.index_of(child)
            if index != -1:
                self.widget().insertWidget(index, child.widget())

    #--------------------------------------------------------------------------
    # Signal Handlers
    #--------------------------------------------------------------------------
    def on_layout_requested(self):
        """ Handle the `layoutRequested` signal from the QSplitter.

        """
        self.size_hint_updated()

    def on_win32_splitter_moved(self):
        """ Handle the 'splitterMoved' signal from the QSplitter.

        This handler is only connected when running on Windows and it
        serves to make sure paint events get processed during heavy
        resize events when opaque resizing is turned on.

        """
        if self.widget().opaqueResize():
            QApplication.sendPostedEvents()

    #--------------------------------------------------------------------------
    # Message Handler Methods
    #--------------------------------------------------------------------------
    def on_action_set_orientation(self, content):
        """ Handle the 'set_orientation' action from the Enaml widget.

        """
        self.set_orientation(content['orientation'])
        self.size_hint_updated()

    def on_action_set_live_drag(self, content):
        """ Handle the 'set_live_drag' action from the Enaml widget.

        """
        self.set_live_drag(content['live_drag'])

    #--------------------------------------------------------------------------
    # Widget Update Methods
    #--------------------------------------------------------------------------
    def set_orientation(self, orientation):
        """ Update the orientation of the QSplitter.

        """
        q_orientation = _ORIENTATION_MAP[orientation]
        self.widget().setOrientation(q_orientation)

    def set_live_drag(self, live_drag):
        """ Update the dragging mode of the QSplitter.

        """
        self.widget().setOpaqueResize(live_drag)


########NEW FILE########
__FILENAME__ = qt_split_item
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from .qt.QtGui import QFrame, QSplitter, QLayout
from .q_single_widget_layout import QSingleWidgetLayout
from .qt_container import QtContainer
from .qt_widget import QtWidget


class QSplitItem(QFrame):
    """ A QFrame subclass which acts as an item in a QSplitter.

    """
    def __init__(self, parent=None):
        """ Initialize a QSplitItem.

        Parameters
        ----------
        parent : QWidget, optional
            The parent widget of the split item, or None if it has no
            parent.

        """
        super(QSplitItem, self).__init__(parent)
        self._split_widget = None
        self.setLayout(QSingleWidgetLayout())
        self.layout().setSizeConstraint(QLayout.SetMinAndMaxSize)

    def splitWidget(self):
        """ Get the split widget for this split item.

        Returns
        -------
        result : QWidget or None
            The split widget being managed by this item.

        """
        return self._split_widget

    def setSplitWidget(self, widget):
        """ Set the split widget for this split item.

        Parameters
        ----------
        widget : QWidget
            The QWidget to use as the split widget in this item.

        """
        self._split_widget = widget
        self.layout().setWidget(widget)

    def stretch(self):
        """ Get the stretch factor for this split item.

        Returns
        -------
        result : int
            The stretch factor for this split item.

        """
        # horizontal and vertical stretch are set to be the same,
        # so which one is returned here is irrelevant.
        return self.sizePolicy().horizontalStretch()

    def setStretch(self, stretch):
        """ Set the stretch factor for this split item.

        Parameters
        ----------
        stretch : int
            The stretch factor to use for this split item.

        """
        stretch = max(0, stretch)
        policy = self.sizePolicy()
        policy.setHorizontalStretch(stretch)
        policy.setVerticalStretch(stretch)
        self.setSizePolicy(policy)

    def collapsible(self):
        """ Get whether or not this widget is collapsible.

        Returns
        -------
        result : bool
            Whether or not this item can be collapsed to zero size.

        """
        parent = self.parentWidget()
        if isinstance(parent, QSplitter):
            return parent.isCollapsible(parent.indexOf(self))
        return False

    def setCollapsible(self, collapsible):
        """ Set whether or not this widget is collapsible.

        Parameters
        ----------
        collapsible : bool
            Whether or not this item can be collapsed to zero size.
            This holds regardless of the minimum size of the item.

        """
        parent = self.parentWidget()
        if isinstance(parent, QSplitter):
            return parent.setCollapsible(parent.indexOf(self), collapsible)


class QtSplitItem(QtWidget):
    """ A Qt implementation of an Enaml SplitItem.

    """
    #--------------------------------------------------------------------------
    # Setup Methods
    #--------------------------------------------------------------------------
    def create_widget(self, parent, tree):
        """ Create the underlying QStackItem widget.

        """
        return QSplitItem(parent)

    def create(self, tree):
        """ Create and initialize the underyling widget.

        """
        super(QtSplitItem, self).create(tree)
        self.set_stretch(tree['stretch'])
        self.set_collapsible(tree['collapsible'])

    def init_layout(self):
        """ Initialize the layout for the underyling widget.

        """
        super(QtSplitItem, self).init_layout()
        self.widget().setSplitWidget(self.split_widget())

    #--------------------------------------------------------------------------
    # Utility Methods
    #--------------------------------------------------------------------------
    def split_widget(self):
        """ Find and return the split widget child for this widget.

        Returns
        -------
        result : QWidget or None
            The split widget defined for this widget, or None if one is
            not defined.

        """
        widget = None
        for child in self.children():
            if isinstance(child, QtContainer):
                widget = child.widget()
        return widget

    #--------------------------------------------------------------------------
    # Child Events
    #--------------------------------------------------------------------------
    def child_removed(self, child):
        """ Handle the child removed event for a QtSplitItem.

        """
        if isinstance(child, QtContainer):
            self.widget().setSplitWidget(self.split_widget())

    def child_added(self, child):
        """ Handle the child added event for a QtSplitItem.

        """
        if isinstance(child, QtContainer):
            self.widget().setSplitWidget(self.split_widget())

    #--------------------------------------------------------------------------
    # Message Handlers
    #--------------------------------------------------------------------------
    def on_action_set_stretch(self, content):
        """ Handle the 'set_stretch' action from the Enaml widget.

        """
        self.set_stretch(content['stretch'])

    def on_action_set_collapsible(self, content):
        """ Handle the 'set_collapsible' action from the Enaml widget.

        """
        self.set_collapsible(content['collapsible'])

    #--------------------------------------------------------------------------
    # Widget Update Methods
    #--------------------------------------------------------------------------
    def set_stretch(self, stretch):
        """ Set the stretch factor for the underlying widget.

        """
        self.widget().setStretch(stretch)

    def set_collapsible(self, collapsible):
        """ Set the collapsible flag for the underlying widget.

        """
        self.widget().setCollapsible(collapsible)


########NEW FILE########
__FILENAME__ = qt_stack
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from .qt.QtCore import QTimer, QEvent, Signal
from .qt.QtGui import QStackedWidget, QPixmap
from .qt_constraints_widget import QtConstraintsWidget
from .qt_stack_item import QtStackItem
from .q_pixmap_painter import QPixmapPainter
from .q_pixmap_transition import (
    QDirectedTransition, QSlideTransition, QWipeTransition, QIrisTransition,
    QFadeTransition, QCrossFadeTransition
)


_TRANSITION_TYPES = {
    'slide': QSlideTransition,
    'wipe': QWipeTransition,
    'iris': QIrisTransition,
    'fade': QFadeTransition,
    'crossfade': QCrossFadeTransition,
}


_TRANSITION_DIRECTIONS = {
    'left_to_right': QDirectedTransition.LeftToRight,
    'right_to_left': QDirectedTransition.RightToLeft,
    'top_to_bottom': QDirectedTransition.TopToBottom,
    'bottom_to_top': QDirectedTransition.BottomToTop,
}


def make_transition(info):
    """ Make a QPixmapTransition from a description dictionary.

    Parameters
    ----------
    info : dict
        A dictionary sent by an Enaml widget which represents a
        transition.

    Returns
    -------
    result : QPixmapTransition or None
        A QPixmapTransition to use as the transition, or None if one
        could not be created for the given dict.

    """
    type_ = info.get('type')
    if type_ in _TRANSITION_TYPES:
        transition = _TRANSITION_TYPES[type_]()
        duration = info.get('duration')
        if duration is not None:
            transition.setDuration(duration)
        if isinstance(transition, QDirectedTransition):
            direction = info.get('direction')
            if direction in _TRANSITION_DIRECTIONS:
                transition.setDirection(_TRANSITION_DIRECTIONS[direction])
        return transition


class QStack(QStackedWidget):
    """ A QStackedWidget subclass which adds support for transitions.

    """
    #: A signal emitted when a LayoutRequest event is posted to the
    #: stack widget. This will typically occur when the size hint of
    #: the stack is no longer valid.
    layoutRequested = Signal()

    def __init__(self, *args, **kwargs):
        """ Initialize a QStack.

        Parameters
        ----------
        *args, **kwargs
            The positional and keyword arguments needed to initalize
            a QStackedWidget.

        """
        super(QStack, self).__init__(*args, **kwargs)
        self._painter = None
        self._transition = None
        self._transition_index = 0

    #--------------------------------------------------------------------------
    # Private API
    #--------------------------------------------------------------------------
    def _onTransitionFinished(self):
        """ A signal handler for the `finished` signal of the transition.

        This method resets the internal painter and triggers the normal
        index change for the stacked widget.

        """
        painter = self._painter
        if painter is not None:
            painter.setTargetWidget(None)
        self._painter = None
        self.setCurrentIndex(self._transition_index)
        # This final show() makes sure the underlyling widget is visible.
        # If transitions are being fired rapidly, it's possible that the
        # current index and the transition index will be the same when
        # the call above is invoked. In such cases, Qt short circuits the
        # evaluation and the current widget is not shown.
        self.currentWidget().show()

    def _runTransition(self):
        """ A private method which runs the transition effect.

        The `_transition_index` attribute should be set before calling
        this method. If no transition object exists for this widget,
        then it is equivalent to calling `setCurrentIndex`. If the new
        index is not different from the current index the transition
        will not be performed.

        """
        from_index = self.currentIndex()
        to_index = self._transition_index

        # If the index hasn't changed, there is nothing to update.
        if from_index == to_index:
            return

        # If there is no transition applied, just change the index.
        transition = self._transition
        if transition is None:
            self.setCurrentIndex(to_index)
            return

        # Otherwise, grab the pixmaps for the start and ending states
        # and set them on the transtion. The widgets are resized to the
        # current size so that the pixmaps are grabbed in a good state.
        src_widget = self.widget(from_index)
        dst_widget = self.widget(to_index)
        size = self.size()
        src_widget.resize(size)
        dst_widget.resize(size)
        src_pixmap = QPixmap.grabWidget(src_widget)
        dst_pixmap = QPixmap.grabWidget(dst_widget)
        out_pixmap = QPixmap(size)
        transition.setPixmaps(src_pixmap, dst_pixmap, out_pixmap)

        # Hide both of the constituent widgets so that the painter has
        # a clean widget on which to draw.
        src_widget.setVisible(False)
        dst_widget.setVisible(False)

        # Hookup the pixmap painter and start the transition.
        painter = self._painter = QPixmapPainter()
        painter.setTargetWidget(self)
        transition.pixmapUpdated.connect(painter.drawPixmap)
        transition.start()

    #--------------------------------------------------------------------------
    # Public API
    #--------------------------------------------------------------------------
    def event(self, event):
        """ A custom event handler which handles LayoutRequest events.

        When a LayoutRequest event is posted to this widget, it will
        emit the `layoutRequested` signal. This allows an external
        consumer of this widget to update their external layout.

        """
        res = super(QStack, self).event(event)
        if event.type() == QEvent.LayoutRequest:
            self.layoutRequested.emit()
        return res

    def transition(self):
        """ Get the transition installed on this widget.

        Returns
        -------
        result : QPixmapTransition or None
            The pixmap transition installed on this widget, or None if
            no transition is being used.

        """
        return self._transition

    def setTransition(self, transition):
        """ Set the transition to be used by this widget.

        Parameters
        ----------
        transition : QPixmapTransition or None
            The transition to use when changing between widgets on this
            stack or None if no transition should be used.

        """
        old = self._transition
        if old is not None:
            old.finished.disconnect(self._onTransitionFinished)
        self._transition = transition
        if transition is not None:
            transition.finished.connect(self._onTransitionFinished)

    def transitionTo(self, index):
        """ Transition the stack widget to the given index.

        If there is no transition object is installed on the widget
        this is equivalent to calling `setCurrentIndex`. Otherwise,
        the change will be animated using the installed transition.

        Parameters
        ----------
        index : int
            The index of the target transition widget.

        """
        self._transition_index = index
        if self.transition() is not None:
            QTimer.singleShot(0, self._runTransition)
        else:
            self.setCurrentIndex(index)


class QtStack(QtConstraintsWidget):
    """ A Qt implementation of an Enaml Stack.

    """
    #: The initial selected index in the stack.
    _initial_index = 0

    def create_widget(self, parent, tree):
        """ Create the underlying QStack widget.

        """
        return QStack(parent)

    def create(self, tree):
        """ Create and initialize the underlying control.

        """
        super(QtStack, self).create(tree)
        self.set_transition(tree['transition'])
        self._initial_index = tree['index']

    def init_layout(self):
        """ Initialize the layout of the underlying control.

        """
        super(QtStack, self).init_layout()
        widget = self.widget()
        for child in self.children():
            if isinstance(child, QtStackItem):
                widget.addWidget(child.widget())
        # Bypass the transition effect during initialization.
        widget.setCurrentIndex(self._initial_index)
        widget.layoutRequested.connect(self.on_layout_requested)
        widget.currentChanged.connect(self.on_current_changed)

    #--------------------------------------------------------------------------
    # Child Events
    #--------------------------------------------------------------------------
    def child_removed(self, child):
        """ Handle the child removed event for a QtStack.

        """
        if isinstance(child, QtStackItem):
            self.widget().removeWidget(child.widget())

    def child_added(self, child):
        """ Handle the child added event for a QtStack.

        """
        if isinstance(child, QtStackItem):
            index = self.index_of(child)
            if index != -1:
                self.widget().insertWidget(index, child.widget())

    #--------------------------------------------------------------------------
    # Signal Handlers
    #--------------------------------------------------------------------------
    def on_layout_requested(self):
        """ Handle the `layoutRequested` signal from the QStack.

        """
        self.size_hint_updated()

    def on_current_changed(self):
        """ Handle the `currentChanged` signal from the QStack.

        """
        if 'index' not in self.loopback_guard:
            index = self.widget().currentIndex()
            self.send_action('index_changed', {'index': index})

    #--------------------------------------------------------------------------
    # Message Handlers
    #--------------------------------------------------------------------------
    def on_action_set_index(self, content):
        """ Handle the 'set_index' action from the Enaml widget.

        """
        with self.loopback_guard('index'):
            self.set_index(content['index'])

    def on_action_set_transition(self, content):
        """ Handle the 'set_transition' action from the Enaml widget.

        """
        self.set_transition(content['transition'])

    #--------------------------------------------------------------------------
    # Widget Update Methods
    #--------------------------------------------------------------------------
    def set_index(self, index):
        """ Set the current index of the underlying widget.

        """
        self.widget().transitionTo(index)

    def set_transition(self, transition):
        """ Set the transition on the underlying widget.

        """
        self.widget().setTransition(make_transition(transition))


########NEW FILE########
__FILENAME__ = qt_stack_item
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from .qt.QtGui import QFrame
from .q_single_widget_layout import QSingleWidgetLayout
from .qt_container import QtContainer
from .qt_widget import QtWidget


class QStackItem(QFrame):
    """ A QFrame subclass which acts as an item QStack.

    """
    def __init__(self, *args, **kwargs):
        """ Initialize a QStackItem.

        Parameters
        ----------
        *args, **kwargs
            The position and keyword arguments required to initialize
            a QWidget.

        """
        super(QStackItem, self).__init__(*args, **kwargs)
        self._stack_widget = None
        self.setLayout(QSingleWidgetLayout())

    def stackWidget(self):
        """ Get the stack widget for this stack item.

        Returns
        -------
        result : QWidget or None
            The stack widget being managed by this item.

        """
        return self._stack_widget

    def setStackWidget(self, widget):
        """ Set the stack widget for this stack item.

        Parameters
        ----------
        widget : QWidget
            The QWidget to use as the stack widget in this item.

        """
        self._stack_widget = widget
        self.layout().setWidget(widget)


class QtStackItem(QtWidget):
    """ A Qt implementation of an Enaml StackItem.

    """
    #--------------------------------------------------------------------------
    # Setup Methods
    #--------------------------------------------------------------------------
    def create_widget(self, parent, tree):
        """ Create the underlying QStackItem widget.

        """
        return QStackItem(parent)

    def init_layout(self):
        """ Initialize the layout for the underyling widget.

        """
        super(QtStackItem, self).init_layout()
        self.widget().setStackWidget(self.stack_widget())

    #--------------------------------------------------------------------------
    # Utility Methods
    #--------------------------------------------------------------------------
    def stack_widget(self):
        """ Find and return the stack widget child for this widget.

        Returns
        -------
        result : QWidget or None
            The stack widget defined for this widget, or None if one is
            not defined.

        """
        widget = None
        for child in self.children():
            if isinstance(child, QtContainer):
                widget = child.widget()
        return widget

    #--------------------------------------------------------------------------
    # Child Events
    #--------------------------------------------------------------------------
    def child_removed(self, child):
        """ Handle the child added event for a QtStackItem.

        """
        if isinstance(child, QtContainer):
            self.widget().setStackWidget(self.stack_widget())

    def child_added(self, child):
        """ Handle the child added event for a QtStackItem.

        """
        if isinstance(child, QtContainer):
            self.widget().setStackWidget(self.stack_widget())

    #--------------------------------------------------------------------------
    # Widget Update Methods
    #--------------------------------------------------------------------------
    def set_visible(self, visible):
        """ An overridden visibility setter.

        This setter disables changing visibility on the widget since
        the visibility is controlled entirely by the parent stack.

        """
        pass


########NEW FILE########
__FILENAME__ = qt_text_editor
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from .editor.qt_ace_editor_view import QtAceEditorView
from .qt_control import QtControl


class QtTextEditor(QtControl):
    """ A Qt4 implementation of an Enaml TextEditor.

    """
    def create(self):
        """ Create the underlying widget.

        """
        self.widget = QtAceEditorView(self.parent_widget)

    def initialize(self, attrs):
        """ Initialize the widget's attributes.

        """
        super(QtTextEditor, self).initialize(attrs)
        self.attrs = attrs
        self.widget.loadFinished.connect(self.on_load)

    def on_load(self):
        """ The attributes have to be set after the webview
        has finished loading, so this function is delayed

        """
        self.set_text(self.attrs['text'])
        self.set_theme(self.attrs['theme'])
        self.set_mode(self.attrs['mode'])
        self.set_auto_pair(self.attrs['auto_pair'])
        self.set_font_size(self.attrs['font_size'])
        self.show_margin_line(self.attrs['margin_line'])
        self.set_margin_line_column(self.attrs['margin_line_column'])

    #--------------------------------------------------------------------------
    # Message Handlers
    #--------------------------------------------------------------------------
    def on_message_set_text(self, payload):
        """ Handle the 'set-text' action from the Enaml widget.

        """
        self.set_text(payload['text'])

    def on_message_set_theme(self, payload):
        """ Handle the 'set-theme' action from the Enaml widget.

        """
        self.set_theme(payload['theme'])

    def on_message_set_mode(self, payload):
        """ Handle the 'set-mode' action from the Enaml widget.

        """
        self.set_mode(payload['mode'])

    def on_message_set_auto_pair(self, payload):
        """ Handle the 'set-auto_pair' action from the Enaml widget.

        """
        self.set_auto_pair(payload['auto_pair'])

    def on_message_set_font_size(self, payload):
        """ Handle the 'set-font_size' action from the Enaml widget.

        """
        self.set_font_size(payload['font_size'])

    def on_message_show_margin_line(self, payload):
        """ Handle the 'show-margin_line' action from the Enaml widget.

        """
        self.show_margin_line(payload['margin_line'])

    def on_message_set_margin_line_column(self, payload):
        """ Handle the 'set-margin_line_column' action from the Enaml widget.

        """
        self.set_margin_line_column(payload['margin_line_column'])

    #--------------------------------------------------------------------------
    # Widget Update Methods
    #--------------------------------------------------------------------------
    def set_text(self, text):
        """ Set the text in the underlying widget.

        """
        self.widget.editor().set_text(text)

    def set_theme(self, theme):
        """ Set the theme of the underlying editor.

        """
        self.widget.editor().set_theme(theme)

    def set_mode(self, mode):
        """ Set the mode of the underlying editor.

        """
        self.widget.editor().set_mode(mode)

    def set_auto_pair(self, auto_pair):
        """ Set whether or not to pair parentheses, braces, etc in the editor

        """
        self.widget.editor().set_auto_pair(auto_pair)

    def set_font_size(self, font_size):
        """ Set the font size of the editor

        """
        self.widget.editor().set_font_size(font_size)

    def show_margin_line(self, margin_line):
        """ Set whether or not to display the margin line in the editor

        """
        self.widget.editor().show_margin_line(margin_line)

    def set_margin_line_column(self, margin_line_col):
        """ Set the column number for the margin line

        """
        self.widget.editor().set_margin_line_column(margin_line_col)

########NEW FILE########
__FILENAME__ = qt_time_selector
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from .qt.QtGui import QTimeEdit
from .qt_bounded_time import QtBoundedTime


class QtTimeSelector(QtBoundedTime):
    """ A Qt implementation of an Enaml TimeSelector.

    """
    #--------------------------------------------------------------------------
    # Setup Methods
    #--------------------------------------------------------------------------
    def create_widget(self, parent, tree):
        """ Create the underlying QTimeEdit widget.

        """
        return QTimeEdit(parent)

    def create(self, tree):
        """ Create and initialize the underlying widget.

        """
        super(QtTimeSelector, self).create(tree)
        self.set_time_format(tree['time_format'])
        self.widget().timeChanged.connect(self.on_time_changed)

    #--------------------------------------------------------------------------
    # Message Handling
    #--------------------------------------------------------------------------
    def on_action_set_time_format(self, content):
        """ Handle the 'set_time_format' action from the Enaml widget.

        """
        self.set_time_format(content['time_format'])

    #--------------------------------------------------------------------------
    # Widget Update Methods
    #--------------------------------------------------------------------------
    def get_time(self):
        """ Return the current time in the control.

        Returns
        -------
        result : QTime
            The current control time as a QTime object.

        """
        return self.widget().time()

    def set_time(self, time):
        """ Set the widget's current time.

        Parameters
        ----------
        time : QTime
            The QTime object to use for setting the time.

        """
        with self.loopback_guard('time'):
            self.widget().setTime(time)

    def set_max_time(self, time):
        """ Set the widget's maximum time.

        Parameters
        ----------
        time : QTime
            The QTime object to use for setting the maximum time.

        """
        self.widget().setMaximumTime(time)

    def set_min_time(self, time):
        """ Set the widget's minimum time.

        Parameters
        ----------
        time : QTime
            The QTime object to use for setting the minimum time.

        """
        self.widget().setMinimumTime(time)

    def set_time_format(self, time_format):
        """ Set the widget's time format.

        Parameters
        ----------
        time_format : str
            A Python time formatting string.

        """
        # XXX make sure Python's and Qt's format strings are the
        # same, or convert between the two.
        self.widget().setDisplayFormat(time_format)


########NEW FILE########
__FILENAME__ = qt_tool_bar
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
import sys

from .qt.QtCore import Qt, Signal
from .qt.QtGui import QToolBar, QMainWindow
from .qt_action import QtAction
from .qt_action_group import QtActionGroup
from .qt_constraints_widget import QtConstraintsWidget


#: A mapping from Enaml dock area to Qt tool bar areas
_DOCK_AREA_MAP = {
    'top': Qt.TopToolBarArea,
    'right': Qt.RightToolBarArea,
    'bottom': Qt.BottomToolBarArea,
    'left': Qt.LeftToolBarArea,
    'all': Qt.AllToolBarAreas,
}


#: A mapping from Qt tool bar areas to Enaml dock areas
_DOCK_AREA_INV_MAP = {
    Qt.TopToolBarArea: 'top',
    Qt.RightToolBarArea: 'right',
    Qt.BottomToolBarArea: 'bottom',
    Qt.LeftToolBarArea: 'left',
    Qt.AllToolBarAreas: 'all',
}


#: A mapping from Enaml orientation to Qt Orientation
_ORIENTATION_MAP = {
    'horizontal': Qt.Horizontal,
    'vertical': Qt.Vertical,
}


class QCustomToolBar(QToolBar):
    """ A custom QToolBar which adds some Enaml specific features.

    """
    #: A signal emitted when the dock widget is floated.
    floated = Signal()

    #: A signal emitted when the dock widget is docked. The payload
    #: will be the new dock area.
    docked = Signal(object)

    def __init__(self, *args, **kwargs):
        """ Initialize a QCustomToolBar.

        Parameters
        ----------
        *args, **kwargs
            The positional and keyword arguments needed to initialize
            a QToolBar.

        """
        super(QCustomToolBar, self).__init__(*args, **kwargs)
        self._tool_bar_area = Qt.TopToolBarArea
        self.topLevelChanged.connect(self._onTopLevelChanged)

    #--------------------------------------------------------------------------
    # Private API
    #--------------------------------------------------------------------------
    def _onTopLevelChanged(self, top_level):
        """ The signal handler for the the 'topLevelChanged' signal.

        """
        if top_level:
            self.floated.emit()
        else:
            parent = self.parent()
            if parent is not None and isinstance(parent, QMainWindow):
                self._tool_bar_area = parent.toolBarArea(self)
            self.docked.emit(self._tool_bar_area)

    #--------------------------------------------------------------------------
    # Public API
    #--------------------------------------------------------------------------
    def removeActions(self, actions):
        """ Remove the given actions from the tool bar.

        Parameters
        ----------
        actions : iterable
            An iterable of QActions to remove from the tool bar.

        """
        remove = self.removeAction
        for action in actions:
            remove(action)

    def toolBarArea(self):
        """ Get the current tool bar area for the tool bar.

        Returns
        -------
        result : QToolBarArea
            The tool bar area where this tool bar resides.

        """
        return self._tool_bar_area

    def setToolBarArea(self, area):
        """ Set the current tool bar area for the tool bar.

        Parameters
        ----------
        area : QToolBarArea
            The tool bar area where this tool bar should reside.

        """
        self._tool_bar_area = area
        parent = self.parent()
        if isinstance(parent, QMainWindow):
            parent.setToolBarArea(area, self)

    def setFloating(self, floating):
        """ Set the floating state of the tool bar.

        Parameters
        ----------
        floating : bool
            Whether or not the tool bar should floating.

        """
        # QToolBar doesn't provide a setFloating() method. This code
        # is taken mostly from QToolBarPrivate::updateWindowFlags.
        parent = self.parent()
        if isinstance(parent, QMainWindow):
            visible = self.isVisibleTo(parent)
            flags = Qt.Tool if floating else Qt.Widget
            flags |= Qt.FramelessWindowHint
            if sys.platform == 'darwin':
                flags |= Qt.WindowStaysOnTopHint
            self.setWindowFlags(flags)
            if visible:
                self.resize(self.sizeHint())
                self.setVisible(True)


class QtToolBar(QtConstraintsWidget):
    """ A Qt implementation of an Enaml ToolBar.

    """
    #--------------------------------------------------------------------------
    # Setup Methods
    #--------------------------------------------------------------------------
    def create_widget(self, parent, tree):
        """ Create the underlying tool bar widget.

        """
        return QCustomToolBar(parent)

    def create(self, tree):
        """ Create and initialize the underlying tool bar control.

        """
        super(QtToolBar, self).create(tree)
        self.set_movable(tree['movable'])
        self.set_floatable(tree['floatable'])
        self.set_floating(tree['floating'])
        self.set_dock_area(tree['dock_area'])
        self.set_allowed_dock_areas(tree['allowed_dock_areas'])
        self.set_orientation(tree['orientation'])
        widget = self.widget()
        widget.floated.connect(self.on_floated)
        widget.docked.connect(self.on_docked)

    def init_layout(self):
        """ Initialize the layout for the toolbar.

        """
        super(QtToolBar, self).init_layout()
        widget = self.widget()
        for child in self.children():
            if isinstance(child, QtAction):
                widget.addAction(child.widget())
            elif isinstance(child, QtActionGroup):
                widget.addActions(child.actions())

    #--------------------------------------------------------------------------
    # Child Events
    #--------------------------------------------------------------------------
    def child_removed(self, child):
        """  Handle the child removed event for a QtToolBar.

        """
        if isinstance(child, QtAction):
            self.widget().removeAction(child.widget())
        elif isinstance(child, QtActionGroup):
            self.widget().removeActions(child.actions())

    def child_added(self, child):
        """ Handle the child added event for a QtToolBar.

        """
        before = self.find_next_action(child)
        if isinstance(child, QtAction):
            self.widget().insertAction(before, child.widget())
        elif isinstance(child, QtActionGroup):
            self.widget().insertActions(before, child.actions())

    #--------------------------------------------------------------------------
    # Utility Methods
    #--------------------------------------------------------------------------
    def find_next_action(self, child):
        """ Get the QAction instance which comes immediately after the
        actions of the given child.

        Parameters
        ----------
        child : QtActionGroup, or QtAction
            The child of interest.

        Returns
        -------
        result : QAction or None
            The QAction which comes immediately after the actions of the
            given child, or None if no actions follow the child.

        """
        # The target action must be tested for membership against the
        # current actions on the tool bar itself, since this method may
        # be called after a child is added, but before the actions for
        # the child have actually been added to the tool bar.
        index = self.index_of(child)
        if index != -1:
            actions = set(self.widget().actions())
            for child in self.children()[index + 1:]:
                target = None
                if isinstance(child, QtAction):
                    target = child.widget()
                elif isinstance(child, QtActionGroup):
                    acts = child.actions()
                    target = acts[0] if acts else None
                if target in actions:
                    return target

    #--------------------------------------------------------------------------
    # Signal Handlers
    #--------------------------------------------------------------------------
    def on_floated(self):
        """ The signal handler for the 'floated' signal.

        """
        if 'floating' not in self.loopback_guard:
            self.send_action('floated', {})

    def on_docked(self, area):
        """ The signal handler for the 'docked' signal.

        """
        if 'floating' not in self.loopback_guard:
            content = {'dock_area': _DOCK_AREA_INV_MAP[area]}
            self.send_action('docked', content)

    #--------------------------------------------------------------------------
    # Message Handling
    #--------------------------------------------------------------------------
    def on_action_set_movable(self, content):
        """ Handle the 'set_movable' action from the Enaml widget.

        """
        self.set_movable(content['movable'])

    def on_action_set_floatable(self, content):
        """ Handle the 'set_floatable' action from the Enaml widget.

        """
        self.set_floatable(content['floatable'])

    def on_action_set_floating(self, content):
        """ Handle the 'set_floating' action from the Enaml widget.

        """
        self.set_floating(content['floating'])

    def on_action_set_dock_area(self, content):
        """ Handle the 'set_dock_area' action from the Enaml widget.

        """
        self.set_dock_area(content['dock_area'])

    def on_action_set_allowed_dock_areas(self, content):
        """ Handle the 'set_allowed_dock_areas' action from the Enaml
        widget.

        """
        self.set_allowed_dock_areas(content['allowed_dock_areas'])

    def on_action_set_orientation(self, content):
        """ Handle the 'set_orientation' action from the Enaml widget.

        """
        self.set_orientation(content['orientation'])

    #--------------------------------------------------------------------------
    # Widget Update Methods
    #--------------------------------------------------------------------------
    def set_movable(self, movable):
        """ Set the movable state on the underlying widget.

        """
        self.widget().setMovable(movable)

    def set_floatable(self, floatable):
        """ Set the floatable state on the underlying widget.

        """
        self.widget().setFloatable(floatable)

    def set_floating(self, floating):
        """ Set the floating staet on the underlying widget.

        """
        with self.loopback_guard('floating'):
            self.widget().setFloating(floating)

    def set_dock_area(self, dock_area):
        """ Set the dock area on the underyling widget.

        """
        self.widget().setToolBarArea(_DOCK_AREA_MAP[dock_area])

    def set_allowed_dock_areas(self, dock_areas):
        """ Set the allowed dock areas on the underlying widget.

        """
        qt_areas = Qt.NoToolBarArea
        for area in dock_areas:
            qt_areas |= _DOCK_AREA_MAP[area]
        self.widget().setAllowedAreas(qt_areas)

    def set_orientation(self, orientation):
        """ Set the orientation of the underlying widget.

        """
        # If the tool bar is a child of a QMainWindow, then that window
        # will take control of setting its orientation and changes to
        # the orientation by the user must be ignored.
        widget = self.widget()
        parent = widget.parent()
        if not isinstance(parent, QMainWindow):
            widget.setOrientation(_ORIENTATION_MAP[orientation])


########NEW FILE########
__FILENAME__ = qt_traits_item
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#
# Special thanks to Steven Silvester for contributing this module!
#------------------------------------------------------------------------------
from .qt.QtGui import QFrame
from .q_single_widget_layout import QSingleWidgetLayout
from .qt_constraints_widget import size_hint_guard
from .qt_control import QtControl


class QtTraitsItem(QtControl):
    """ A Qt implementation of an Enaml TraitsItem.

    """
    #: Internal storage for the traits model
    _model = None

    #: Internal storage for the traits view
    _view = None

    #: Internal storage for the traits handler
    _handler = None

    #: Internal storage for the generated traits UI object.
    _ui = None

    #--------------------------------------------------------------------------
    # Setup Methods
    #--------------------------------------------------------------------------
    def create_widget(self, parent, tree):
        """ Create the underlying widget.

        """
        widget = QFrame(parent)
        layout = QSingleWidgetLayout()
        widget.setLayout(layout)
        return widget

    def create(self, tree):
        """ Create and initialize the underlying widget.

        """
        super(QtTraitsItem, self).create(tree)
        self._model = tree['model']
        self._view = tree['view']
        self._handler = tree['handler']

    def init_layout(self):
        """ Initialize the layout for the widget.

        """
        super(QtTraitsItem, self).init_layout()
        self.refresh_traits_widget()

    #--------------------------------------------------------------------------
    # Message Handlers
    #--------------------------------------------------------------------------
    def on_action_set_model(self, content):
        """ Handle the 'set_model' action from the Enaml widget.

        """
        self._model = content['model']
        with size_hint_guard(self):
            self.refresh_traits_widget()

    def on_action_set_view(self, content):
        """ Handle the 'set_view' action from the Enaml widget.

        """
        self._view = content['view']
        with size_hint_guard(self):
            self.refresh_traits_widget()

    def on_action_set_handler(self, content):
        """ Handle the 'set_handler' action from the Enaml widget.

        """
        self._handler = content['handler']
        with size_hint_guard(self):
            self.refresh_traits_widget()

    #--------------------------------------------------------------------------
    # Widget Update Methods
    #--------------------------------------------------------------------------
    def refresh_traits_widget(self):
        """ Create the traits widget and update the underlying control.

        """
        widget = self.widget()
        model = self._model
        if model is None:
            control = None
        else:
            view = self._view
            handler = self._handler
            self._ui = ui = model.edit_traits(
                parent=widget, view=view, handler=handler, kind='subpanel',
            )
            control = ui.control
        widget.layout().setWidget(control)


########NEW FILE########
__FILENAME__ = qt_web_view
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from .qt.QtCore import QUrl
from .qt.QtWebKit import QWebView
from .qt_control import QtControl


class QtWebView(QtControl):
    """ A Qt implementation of an Enaml WebView.

    """
    def create_widget(self, parent, tree):
        """ Create the underlying QWebView control.

        """
        return QWebView(parent)

    def create(self, tree):
        """ Create and initialize the underlying control.

        """
        super(QtWebView, self).create(tree)
        html = tree['html']
        if html:
            self.set_html(html)
        else:
            self.set_url(tree['url'])

    #--------------------------------------------------------------------------
    # Message Handling
    #--------------------------------------------------------------------------
    def on_action_set_url(self, content):
        """ Handle the 'set_url' action from the Enaml widget.

        """
        self.set_url(content['url'])

    def on_action_set_html(self, content):
        """ Handle the 'set_html' action from the Enaml widget.

        """
        self.set_html(content['html'])

    #--------------------------------------------------------------------------
    # Widget Update Methods
    #--------------------------------------------------------------------------
    def set_url(self, url):
        """ Set the url for the underlying control.

        """
        self.widget().setUrl(QUrl(url))

    def set_html(self, html):
        """ Set the html source for the underlying control.

        """
        self.widget().setHtml(html, 'c:/')


########NEW FILE########
__FILENAME__ = qt_widget
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
import sys

from enaml.colors import parse_color

from .qt.QtGui import QWidget, QWidgetItem, QColor, QApplication
from .qt.QtCore import Qt, QSize
from .qt_object import QtObject


def q_parse_color(color):
    """ Convert a color string into a QColor.

    Parameters
    ----------
    color : string
        A CSS3 color string to convert to a QColor.

    Returns
    -------
    result : QColor
        The QColor for the given color string

    """
    rgba = parse_color(color)
    if rgba is None:
        qcolor = QColor()
    else:
        r, g, b, a = rgba
        qcolor = QColor.fromRgbF(r, g, b, a)
    return qcolor


class QtWidget(QtObject):
    """ A Qt4 implementation of an Enaml Widget.

    """
    #: An attribute which will hold the default focus rect state if
    #: it is ever changed by the user.
    _default_focus_attr = None

    #: An attribute which will hold the widget item for the widget.
    _widget_item = None

    #: An attribute which indicates whether or not the background
    #: color of the widget has been changed.
    _bgcolor_changed = False

    #: An attribute which indicates whether or not the foreground
    #: color of the widget has been changed.
    _fgcolor_changed = False

    def create_widget(self, parent, tree):
        """ Creates the underlying QWidget object.

        """
        return QWidget(parent)

    def create(self, tree):
        """ Create and initialize the underlying widget.

        """
        super(QtWidget, self).create(tree)
        self.set_minimum_size(tree['minimum_size'])
        self.set_maximum_size(tree['maximum_size'])
        self.set_bgcolor(tree['bgcolor'])
        self.set_fgcolor(tree['fgcolor'])
        self.set_font(tree['font'])
        self.set_enabled(tree['enabled'])
        self.set_visible(tree['visible'])
        self.set_show_focus_rect(tree['show_focus_rect'])
        self.set_tool_tip(tree['tool_tip'])
        self.set_status_tip(tree['status_tip'])

    #--------------------------------------------------------------------------
    # Public Api
    #--------------------------------------------------------------------------
    def widget_item(self):
        """ Get the QWidgetItem for the underlying widget.

        Returns
        -------
        result : QWidgetItem
            The QWidgetItem to use for the underlying widget.

        """
        res = self._widget_item
        if res is None:
            res = self._widget_item = QWidgetItem(self.widget())
        return res

    #--------------------------------------------------------------------------
    # Message Handlers
    #--------------------------------------------------------------------------
    def on_action_set_enabled(self, content):
        """ Handle the 'set_enabled' action from the Enaml widget.

        """
        self.set_enabled(content['enabled'])

    def on_action_set_visible(self, content):
        """ Handle the 'set_visible' action from the Enaml widget.

        """
        self.set_visible(content['visible'])

    def on_action_set_bgcolor(self, content):
        """ Handle the 'set_bgcolor' action from the Enaml widget.

        """
        self.set_bgcolor(content['bgcolor'])

    def on_action_set_fgcolor(self, content):
        """ Handle the 'set_fgcolor' action from the Enaml widget.

        """
        self.set_fgcolor(content['fgcolor'])

    def on_action_set_font(self, content):
        """ Handle the 'set_font' action from the Enaml widget.

        """
        self.set_font(content['font'])

    def on_action_set_minimum_size(self, content):
        """ Handle the 'set_minimum_size' action from the Enaml widget.

        """
        self.set_minimum_size(content['minimum_size'])

    def on_action_set_maximum_size(self, content):
        """ Handle the 'set_maximum_size' action from the Enaml widget.

        """
        self.set_maximum_size(content['maximum_size'])

    def on_action_set_show_focus_rect(self, content):
        """ Handle the 'set_show_focus_rect' action from the Enaml
        widget.

        """
        self.set_show_focus_rect(content['show_focus_rect'])

    def on_action_set_tool_tip(self, content):
        """ Handle the 'set_tool_tip' action from the Enaml widget.

        """
        self.set_tool_tip(content['tool_tip'])

    def on_action_set_status_tip(self, content):
        """ Handle the 'set_status_tip' action from the Enaml widget.

        """
        self.set_status_tip(content['status_tip'])

    #--------------------------------------------------------------------------
    # Widget Update Methods
    #--------------------------------------------------------------------------
    def set_minimum_size(self, min_size):
        """ Sets the minimum size on the underlying widget.

        Parameters
        ----------
        min_size : (int, int)
            The minimum size allowable for the widget. A value of
            (-1, -1) indicates the default min size.

        """
        # QWidget uses (0, 0) as the minimum size.
        if -1 in min_size:
            min_size = (0, 0)
        self.widget().setMinimumSize(QSize(*min_size))

    def set_maximum_size(self, max_size):
        """ Sets the maximum size on the underlying widget.

        Parameters
        ----------
        max_size : (int, int)
            The minimum size allowable for the widget. A value of
            (-1, -1) indicates the default max size.

        """
        # QWidget uses 16777215 as the max size
        if -1 in max_size:
            max_size = (16777215, 16777215)
        self.widget().setMaximumSize(QSize(*max_size))

    def set_enabled(self, enabled):
        """ Set the enabled state on the underlying widget.

        Parameters
        ----------
        enabled : bool
            Whether or not the widget is enabled.

        """
        self.widget().setEnabled(enabled)

    def set_visible(self, visible):
        """ Set the visibility state on the underlying widget.

        Parameters
        ----------
        visible : bool
            Whether or not the widget is visible.

        """
        self.widget().setVisible(visible)

    def set_bgcolor(self, bgcolor):
        """ Set the background color on the underlying widget.

        Parameters
        ----------
        bgcolor : str
            The background color of the widget as a CSS color string.

        """
        if bgcolor or self._bgcolor_changed:
            widget = self.widget()
            role = widget.backgroundRole()
            qcolor = q_parse_color(bgcolor)
            if not qcolor.isValid():
                app_palette = QApplication.instance().palette(widget)
                qcolor = app_palette.color(role)
                widget.setAutoFillBackground(False)
            else:
                widget.setAutoFillBackground(True)
            palette = widget.palette()
            palette.setColor(role, qcolor)
            widget.setPalette(palette)
            self._bgcolor_changed = True

    def set_fgcolor(self, fgcolor):
        """ Set the foreground color on the underlying widget.

        Parameters
        ----------
        fgcolor : str
            The foreground color of the widget as a CSS color string.

        """
        if fgcolor or self._fgcolor_changed:
            widget = self.widget()
            role = widget.foregroundRole()
            qcolor = q_parse_color(fgcolor)
            if not qcolor.isValid():
                app_palette = QApplication.instance().palette(widget)
                qcolor = app_palette.color(role)
            palette = widget.palette()
            palette.setColor(role, qcolor)
            widget.setPalette(palette)
            self._fgcolor_changed = True

    def set_font(self, font):
        """ Set the font on the underlying widget.

        Parameters
        ----------
        font : str
            The font for the widget as a CSS font string.

        """
        pass

    def set_show_focus_rect(self, show):
        """ Sets whether or not to show the focus rectangle around
        the widget. This is currently only supported on OSX.

        """
        if sys.platform == 'darwin':
            widget = self.widget()
            attr = Qt.WA_MacShowFocusRect
            if show is None:
                if self._default_focus_attr is not None:
                    widget.setAttribute(attr, self._default_focus_attr)
            else:
                if self._default_focus_attr is None:
                    self._default_focus_attr = widget.testAttribute(attr)
                widget.setAttribute(attr, show)

    def set_tool_tip(self, tool_tip):
        """ Set the tool tip for this widget.

        """
        self.widget().setToolTip(tool_tip)

    def set_status_tip(self, status_tip):
        """ Set the status tip for this widget.

        """
        self.widget().setStatusTip(status_tip)


########NEW FILE########
__FILENAME__ = qt_widget_registry
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from collections import defaultdict


class QtWidgetRegistry(object):
    """ A class for registering Qt widget factories.

    This is a process-widget registry class. Interaction is done through
    the two classmethods `register` and `lookup`.

    """
    #: Private storage for the widget factories.
    _groups = defaultdict(dict)

    @classmethod
    def register(cls, name, factory, group, strict=False):
        """ Registery a widget factory.

        Parameters
        ----------
        name : str
            The name of the Enaml widget class which is implemented
            by the class returned by the given factory.

        factory : callable
            A callable which takes no arguments and returns the class
            which implements the widget.

        group : str
            The widget group with which this factory is associated.

        strict : bool, optional
            If True, attempting to register a factory for a widget
            which is already registered will raise a ValueError.
            The default is False.

        """
        thisgroup = cls._groups[group]
        if strict and name in thisgroup:
            msg = ('Factory already registered for the `%s` widget in the '
                   '`%s` widget group.')
            raise ValueError(msg % (name, group))
        thisgroup[name] = factory

    @classmethod
    def lookup(cls, name, groups):
        """ Lookup a widget factory.

        Parameters
        ----------
        name : str
            The name of the Enaml widget for which to lookup a factory.

        groups : list of str
            The list of groups to check for a matching factory. The
            groups are checked in order with the first match being
            returned. If no match is found, None will be returned.

        """
        thesegroups = cls._groups
        for group in groups:
            if group in thesegroups:
                thisgroup = thesegroups[group]
                if name in thisgroup:
                    return thisgroup[name]


########NEW FILE########
__FILENAME__ = qt_window
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
import logging

from .qt.QtCore import Qt, QSize, Signal
from .qt.QtGui import QFrame, QLayout, QIcon, QImage, QPixmap
from .q_deferred_caller import deferredCall
from .q_single_widget_layout import QSingleWidgetLayout
from .qt_container import QtContainer
from .qt_widget import QtWidget


logger = logging.getLogger(__name__)


MODALITY = {
    'non_modal': Qt.NonModal,
    'application_modal': Qt.ApplicationModal,
    'window_modal': Qt.WindowModal,
}


class QWindowLayout(QSingleWidgetLayout):
    """ A QSingleWidgetLayout subclass which adds support for windows
    which explicitly set their minimum and maximum sizes.

    """
    def minimumSize(self):
        """ The minimum size for the layout area.

        This is a reimplemented method which will return the explicit
        minimum size of the window, if provided.

        """
        parent = self.parentWidget()
        if parent is not None:
            size = parent.explicitMinimumSize()
            if size.isValid():
                return size
        return super(QWindowLayout, self).minimumSize()

    def maximumSize(self):
        """ The maximum size for the layout area.

        This is a reimplemented method which will return the explicit
        maximum size of the window, if provided.

        """
        parent = self.parentWidget()
        if parent is not None:
            size = parent.explicitMaximumSize()
            if size.isValid():
                return size
        return super(QWindowLayout, self).maximumSize()


class QWindow(QFrame):
    """ A custom QFrame which uses a QWindowLayout to manage its
    central widget.

    The window layout computes the min/max size of the window based
    on its central widget, unless the user explicitly changes them.

    """
    #: A signal emitted when the window is closed.
    closed = Signal()

    def __init__(self, parent=None):
        """ Initialize a QWindow.

        Parameters
        ----------
        *args, **kwargs
            The positional and keyword arguments needed to initialize
            a QFrame.

        """
        super(QWindow, self).__init__(parent, Qt.Window)
        self._central_widget = None
        self._expl_min_size = QSize()
        self._expl_max_size = QSize()
        layout = QWindowLayout()
        layout.setSizeConstraint(QLayout.SetMinAndMaxSize)
        self.setLayout(layout)

    def closeEvent(self, event):
        """ Handle the QCloseEvent from the window system.

        By default, this handler calls the superclass' method to close
        the window and then emits the 'closed' signal.

        """
        super(QWindow, self).closeEvent(event)
        self.closed.emit()

    def centralWidget(self):
        """ Returns the central widget for the window.

        Returns
        -------
        result : QWidget or None
            The central widget of the window, or None if no widget
            was provided.

        """
        return self._central_widget

    def setCentralWidget(self, widget):
        """ Set the central widget for this window.

        Parameters
        ----------
        widget : QWidget
            The widget to use as the content of the window.

        """
        self._central_widget = widget
        self.layout().setWidget(widget)

    def explicitMinimumSize(self):
        """ Return the explicit minimum size for this widget.

        Returns
        -------
        result : QSize
            If the user has explitly set the minimum size of the
            widget, that size will be returned. Otherwise, an
            invalid QSize will be returned.

        """
        return self._expl_min_size

    def explicitMaximumSize(self):
        """ Return the explicit maximum size for this widget.

        Returns
        -------
        result : QSize
            If the user has explitly set the maximum size of the
            widget, that size will be returned. Otherwise, an
            invalid QSize will be returned.

        """
        return self._expl_max_size

    def setMinimumSize(self, size):
        """ Set the minimum size for the QWindow.

        This is an overridden parent class method which stores the
        provided size as the explictly set QSize. The explicit
        size can be reset by passing a QSize of (0, 0).

        Parameters
        ----------
        size : QSize
            The minimum size for the QWindow.

        """
        super(QWindow, self).setMinimumSize(size)
        if size == QSize(0, 0):
            self._expl_min_size = QSize()
        else:
            self._expl_min_size = size
        self.layout().update()

    def setMaximumSize(self, size):
        """ Set the maximum size for the QWindow.

        This is an overridden parent class method which stores the
        provided size as the explictly set QSize. The explicit
        size can be reset by passing a QSize equal to the maximum
        widget size of QSize(16777215, 16777215).

        Parameters
        ----------
        size : QSize
            The maximum size for the QWindow.

        """
        super(QWindow, self).setMaximumSize(size)
        if size == QSize(16777215, 16777215):
            self._expl_max_size = QSize()
        else:
            self._expl_max_size = size
        self.layout().update()


class QtWindow(QtWidget):
    """ A Qt implementation of an Enaml Window.

    """
    #: Temporary internal storage for the icon source url.
    _icon_source = ''

    #--------------------------------------------------------------------------
    # Setup Methods
    #--------------------------------------------------------------------------
    def create_widget(self, parent, tree):
        """ Create the underlying QWindow object.

        """
        return QWindow(parent)

    def create(self, tree):
        """ Create and initialize the underlying widget.

        """
        super(QtWindow, self).create(tree)
        self.set_title(tree['title'])
        self.set_initial_size(tree['initial_size'])
        self.set_modality(tree['modality'])
        self.set_always_on_top(tree['always_on_top'])
        self._icon_source = tree['icon_source']
        self.widget().closed.connect(self.on_closed)

    def init_layout(self):
        """ Perform layout initialization for the control.

        """
        super(QtWindow, self).init_layout()
        self.widget().setCentralWidget(self.central_widget())

    def activate(self):
        """ Activate the window.

        """
        self.set_icon_source(self._icon_source)
        super(QtWindow, self).activate()

    #--------------------------------------------------------------------------
    # Utility Methods
    #--------------------------------------------------------------------------
    def central_widget(self):
        """ Find and return the central widget child for this widget.

        Returns
        -------
        result : QWidget or None
            The central widget defined for this widget, or None if one
            is not defined.

        """
        widget = None
        for child in self.children():
            if isinstance(child, QtContainer):
                widget = child.widget()
        return widget

    #--------------------------------------------------------------------------
    # Child Events
    #--------------------------------------------------------------------------
    def child_removed(self, child):
        """ Handle the child removed event for a QtWindow.

        """
        if isinstance(child, QtContainer):
            self.widget().setCentralWidget(self.central_widget())

    def child_added(self, child):
        """ Handle the child added event for a QtWindow.

        """
        if isinstance(child, QtContainer):
            self.widget().setCentralWidget(self.central_widget())

    #--------------------------------------------------------------------------
    # Signal Handlers
    #--------------------------------------------------------------------------
    def on_closed(self):
        """ The signal handler for the 'closed' signal.

        """
        self.send_action('closed', {})

    #--------------------------------------------------------------------------
    # Message Handlers
    #--------------------------------------------------------------------------
    def on_action_close(self, content):
        """ Handle the 'close' action from the Enaml widget.

        """
        self.close()

    def on_action_maximize(self, content):
        """ Handle the 'maximize' action from the Enaml widget.

        """
        self.maximize()

    def on_action_minimize(self, content):
        """ Handle the 'minimize' action from the Enaml widget.

        """
        self.minimize()

    def on_action_restore(self, content):
        """ Handle the 'restore' action from the Enaml widget.

        """
        self.restore()

    def on_action_send_to_front(self, content):
        """ Handle the 'send_to_front' action from the Enaml widget.

        """
        self.send_to_front()

    def on_action_send_to_back(self, content):
        """ Handle the 'send_to_back' action from the Enaml widget.

        """
        self.send_to_back()

    def on_action_set_icon_source(self, content):
        """ Handle the 'set_icon_source' action from the Enaml widget.

        """
        self.set_icon_source(content['icon_source'])

    def on_action_set_title(self, content):
        """ Handle the 'set_title' action from the Enaml widget.

        """
        self.set_title(content['title'])

    def on_action_set_modality(self, content):
        """ Handle the 'set_modality' action from the Enaml widget.

        """
        self.set_modality(content['modality'])

    def on_action_set_always_on_top(self, content):
        """ Handle the 'set_always_on_top' action from the Enaml widget.

        """
        self.set_always_on_top(content['always_on_top'])

    #--------------------------------------------------------------------------
    # Widget Update Methods
    #--------------------------------------------------------------------------
    def close(self):
        """ Close the window

        """
        self.widget().close()

    def maximize(self):
        """ Maximize the window.

        """
        self.widget().showMaximized()

    def minimize(self):
        """ Minimize the window.

        """
        self.widget().showMinimized()

    def restore(self):
        """ Restore the window after a minimize or maximize.

        """
        self.widget().showNormal()

    def send_to_front(self):
        """ Move the window to the front of all other windows.

        """
        self.widget().raise_()

    def send_to_back(self):
        """ Move the window to the back of all other windows.

        """
        self.widget().lower()

    def set_icon_source(self, icon_source):
        """ Set the window icon source.

        """
        if icon_source:
            loader = self._session.load_resource(icon_source)
            loader.on_load(self._on_icon_load)
        else:
            self._on_icon_load(QIcon())

    def set_title(self, title):
        """ Set the title of the window.

        """
        self.widget().setWindowTitle(title)

    def set_initial_size(self, size):
        """ Set the initial size of the window.

        """
        if -1 in size:
            return
        self.widget().resize(QSize(*size))

    def set_modality(self, modality):
        """ Set the modality of the window.

        """
        self.widget().setWindowModality(MODALITY[modality])

    def set_always_on_top(self, always_on_top):
        """ Set the 'always_on_top' flag on the window

        """
        widget = self.widget()
        flags = widget.windowFlags()
        if always_on_top:
            flags |= Qt.WindowStaysOnTopHint
        else:
            flags &= ~Qt.WindowStaysOnTopHint
        if flags != widget.windowFlags():
            visible = widget.isVisible()
            widget.setWindowFlags(flags)
            if visible:  # http://qt-project.org/doc/qt-4.8/qwidget.html#windowFlags-prop
                widget.show()

    def set_visible(self, visible):
        """ Set the visibility on the window.

        This is an overridden parent class method to set the visibility
        at a later time, so that layout can be initialized before the
        window is displayed.

        """
        # XXX this could be done better.
        deferredCall(super(QtWindow, self).set_visible, visible)

    #--------------------------------------------------------------------------
    # Private API
    #--------------------------------------------------------------------------
    def _on_icon_load(self, icon):
        """ A private resource loader callback.

        This method is invoked when the requested icon is successfully
        loaded. It will update the icon on the action and issue a size
        hint updated event to the layout system if needed.

        Parameters
        ----------
        icon : QIcon or QImage
            The icon or image that was loaded by the request.

        """
        if isinstance(icon, QImage):
            icon = QIcon(QPixmap.fromImage(icon))
        elif not isinstance(icon, QIcon):
            msg = 'got incorrect type for icon: `%s`'
            logger.error(msg % type(icon).__name__)
            icon = QIcon()
        self.widget().setWindowIcon(icon)


########NEW FILE########
__FILENAME__ = q_action_socket
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
import types

from enaml.socket_interface import ActionSocketInterface
from enaml.weakmethod import WeakMethod

from .qt.QtCore import QObject, Signal


class QActionSocket(QObject):
    """ A concrete implementation of ActionSocketInterface.

    This is a QObject subclass which converts a `send` on the socket
    into a `messagePosted` signal which can be connected to another
    part of the application. Incoming socket messages can be delivered
    to the `receive` method of the socket.

    """
    #: A signal emitted when a message has been sent on the socket.
    messagePosted = Signal(object, object, object)

    def __init__(self):
        """ Initialize a QActionSocket.

        """
        super(QActionSocket, self).__init__()
        self._callback = None

    def on_message(self, callback):
        """ Register a callback for receiving messages sent by a client
        object.

        Parameters
        ----------
        callback : callable
            A callable with an argument signature that is equivalent to
            the `send` method. If the callback is a bound method, then
            the lifetime of the callback will be bound to lifetime of
            the method owner object.

        """
        if isinstance(callback, types.MethodType):
            callback = WeakMethod(callback)
        self._callback = callback

    def send(self, object_id, action, content):
        """ Send the action to any attached listeners.

        Parameters
        ----------
        object_id : str
            The object id of the target object.

        action : str
            The action that should be performed by the object.

        content : dict
            The content dictionary for the action.

        """
        self.messagePosted.emit(object_id, action, content)

    def receive(self, object_id, action, content):
        """ Receive a message sent to the socket.

        The message will be routed to the registered callback, if one
        exists.

        Parameters
        ----------
        object_id : str
            The object id of the target object.

        action : str
            The action that should be performed by the object.

        content : dict
            The content dictionary for the action.

        """
        callback = self._callback
        if callback is not None:
            callback(object_id, action, content)


ActionSocketInterface.register(QActionSocket)


########NEW FILE########
__FILENAME__ = q_deferred_caller
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from .qt.QtCore import QObject, QTimer, Qt, Signal
from .qt.QtGui import QApplication


class QDeferredCaller(QObject):
    """ A QObject subclass which facilitates executing callbacks on the
    main application thread.

    """
    _posted = Signal(object)

    def __init__(self):
        """ Initialize a QDeferredCaller.

        """
        super(QDeferredCaller, self).__init__()
        app = QApplication.instance()
        if app is not None:
            self.moveToThread(app.thread())
        self._posted.connect(self._onPosted, Qt.QueuedConnection)

    #--------------------------------------------------------------------------
    # Private API
    #--------------------------------------------------------------------------
    def _onPosted(self, callback):
        """ A private signal handler for the '_callbackPosted' signal.

        This handler simply executes the callback.

        """
        callback()

    #--------------------------------------------------------------------------
    # Public API
    #--------------------------------------------------------------------------
    def deferredCall(self, callback, *args, **kwargs):
        """ Execute the callback on the main gui thread.

        Parameters
        ----------
        callback : callable
            The callable object to execute on the main thread.

        *args, **kwargs
            Any additional positional and keyword arguments to pass to
            the callback.

        """
        f = lambda: callback(*args, **kwargs)
        self._posted.emit(f)

    def timedCall(self, ms, callback, *args, **kwargs):
        """ Execute a callback on a timer in the main gui thread.

        Parameters
        ----------
        ms : int
            The time to delay, in milliseconds, before executing the
            callable.

        callback : callable
            The callable object to execute at on the timer.

        *args, **kwargs
            Any additional positional and keyword arguments to pass to
            the callback.

        """
        f = lambda: callback(*args, **kwargs)
        f2 = lambda: QTimer.singleShot(ms, f)
        self._posted.emit(f2)


#: A globally available caller instance. This will be created on demand
#: by the globally available caller functions.
_caller = None


def deferredCall(callback, *args, **kwargs):
    """ Execute the callback on the main gui thread.

    This is a convenience wrapper around QDeferredCaller.deferredCall.
    This should only be called after the QApplication is created.

    """
    global _caller
    c = _caller
    if c is None:
        c = _caller = QDeferredCaller()
    c.deferredCall(callback, *args, **kwargs)


def timedCall(ms, callback, *args, **kwargs):
    """ Execute a callback on a timer in the main gui thread.

    This is a convenience wrapper around QDeferredCaller.timedCall.
    This should only be called after the QApplication is created.

    """
    global _caller
    c = _caller
    if c is None:
        c = _caller = QDeferredCaller()
    c.timedCall(ms, callback, *args, **kwargs)


########NEW FILE########
__FILENAME__ = q_flow_layout
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from abc import ABCMeta, abstractmethod

from .qt.QtCore import Qt, QSize, QRect
from .qt.QtGui import QLayout, QWidgetItem


class AbstractFlowWidget(object):
    """ An abstract base class which defines the interface for widgets
    which can be used in a QFlowLayout.

    Users of QFlowLayout must register their custom QWidget classes with
    this class in order to use the QFlowLayout.

    """
    __metaclass__ = ABCMeta

    @abstractmethod
    def layoutData(self):
        """ An abstractmethod which must be implemented by subclasses.

        Returns
        -------
        result : FlowLayoutData
            The FlowLayoutData instance to use for this widget. The
            same data layout data instance should be returned for
            each call to this method.

        """
        raise NotImplementedError


class FlowLayoutData(object):
    """ The layout data object to use with AbstractFlowWidget instances.

    For performance reasons, there are no runtime checks on the limits
    of the values assigned to this class. Users should ensure that the
    values assigned conform to the documented limits. Users must set
    the `dirty` flag to True before calling `updateGeometry` in order
    for changes to have effect.

    """
    #: Whether or not the computed info for the layout item is dirty.
    #: This must be set to True before calling `updateGeometry` on
    #: the owner widget.
    dirty = True

    #: The flow stretch factor of the layout item. This value controls
    #: the amount of space that is taken up by an expandable item in the
    #: direction of the layout flow, relative to the other items in the
    #: line. The minimum is 0 which means the item should not expand.
    #: There is no maximum. The default is 0.
    stretch = 0

    #: The ortho stretch factor of the layout item. This value controls
    #: the amount of space that is taken up by an expandable item in the
    #: direction orthogonal to the layout flow, relative to other items
    #: in the line. The minimum is 0 which means the item should not
    #: expand. There is no maximum. The default is 0.
    ortho_stretch = 0

    #: The alignment of the layout item in the direction orthogonal to
    #: the layout flow. This must be one of the enums Qt.AlignLeading,
    #: Qt.AlignTrailing, or Qt.AlignCenter.
    alignment = Qt.AlignLeading

    #: The preferred size for the layout item. This size will be used
    #: as the size of the layout item to the extent possible. If this
    #: size is invalid in a particular dimension, the sizeHint of the
    #: item in that direction will be used.
    preferred_size = QSize()

    def __init__(self):
        """ Initialize a FlowLayoutData.

        """
        self.preferred_size = QSize()


class QFlowWidgetItem(QWidgetItem):
    """ A custom QWidgetItem for use with the QFlowLayout.

    """
    #: The FlowLayoutData associated with this widget item. It is a
    #: publically accesible attribute for performance reasons.
    data = None

    def __init__(self, widget, data):
        """ Initialize a QFlowWidgetItem.

        Parameters
        ----------
        widget : QWidget
            The widget to manage with this item.

        data : FlowLayoutData
            The layout data struct associated with this item.

        """
        super(QFlowWidgetItem, self).__init__(widget)
        self.data = data
        self._cached_hint = QSize()
        self._cached_max = QSize()
        self._cached_min = QSize()

    def maximumSize(self):
        """ Reimplemented maximum size computation.

        The max size for a flow widget item is cached and recomputed
        only when the widget item is invalidated.

        """
        if not self._cached_max.isValid():
            self._cached_max = super(QFlowWidgetItem, self).maximumSize()
        return self._cached_max

    def minimumSize(self):
        """ Reimplemented minimum size computation.

        The min size for a flow widget item is cached and recomputed
        only when the widget item is invalidated.

        """
        if not self._cached_min.isValid():
            self._cached_min = super(QFlowWidgetItem, self).minimumSize()
        return self._cached_min

    def sizeHint(self):
        """ Reimplemented size hint computation.

        The size hint for a flow widget item is cached and recomputed
        only when the widget item is invalidated. The size hint is the
        valid union of the preferred size, as indicated by the layout
        data, and the size hint of the widget.

        """
        if not self._cached_hint.isValid():
            hint = super(QFlowWidgetItem, self).sizeHint()
            pref = self.data.preferred_size
            smin = self.minimumSize()
            smax = self.maximumSize()
            if pref.width() != -1:
                pw = max(smin.width(), min(pref.width(), smax.width()))
                hint.setWidth(pw)
            if pref.height() != -1:
                ph = max(smin.height(), min(pref.height(), smax.height()))
                hint.setHeight(ph)
            self._cached_hint = hint
        return self._cached_hint

    def setGeometry(self, rect):
        """ Set the rectangle covered by this layout item.

        This reimplemented method ensures that layout always occurs at
        the origin of the given rect. The default QWidgetItem behavior
        is to center the item in the given space.

        Parameters
        ----------
        rect : QRect
            The rectangle that this layout item should cover.

        """
        if self.isEmpty():
            return
        s = rect.size().boundedTo(self.maximumSize())
        self.widget().setGeometry(rect.x(), rect.y(), s.width(), s.height())

    def invalidate(self):
        """ Invalidate the internal cached data for this widget item.

        The invalidation will only have an effect if the layout data
        associate with this item is marked as dirty.

        """
        if self.data.dirty:
            self._cached_hint = QSize()
            self._cached_min = QSize()
            self.data.dirty = False


class _LayoutRow(object):
    """ A private class used by QFlowLayout.

    This class accumulates information about a row of items as the items
    are added to the row. Instances of the this class are created by the
    QFlowLayout during a layout pass. For performance reasons, there are
    several publically accesible attributes. See their documentation for
    restrictions on their use.

    """
    #: The height to use for laying out the row. This attribute is
    #: modified directly by the layout as it distributes the vertical
    #: space amongst the rows.
    layout_height = 0

    #: The minimum height required for the row. This is automatically
    #: updated as items are added to the row. It should be considered
    #: read-only to external users.
    min_height = 0

    #: The minimum width required for the row. This is automatically
    #: updated as items are added to the row. It should be considered
    #: read-only to external users.
    min_width = 0

    #: The desired height for the row. This is automatically updated as
    #: items are added to the row. It should be considered read-only to
    #: external users.
    hint_height = 0

    #: The desired width for the row. This is automatically updated as
    #: items are added to the row. It should be considered read-only to
    #: external users.
    hint_width = 0

    #: The vertical stretch factor for the row. This is automatically
    #: updated as items are added to the row. It should be considered
    #: read-only by external users.
    stretch = 0

    def __init__(self, width, options):
        """ Initialize a layout row.

        Parameters
        ----------
        width : int
            The width of the layout area.

        options : _LayoutOptions
            The options in effect for the layout.

        """
        self._width = width
        self._options = options
        self._items_stretch = 0
        self._items = []

    @property
    def diff_height(self):
        """ A read-only property which computes the difference between
        the desired height and the minimum height.

        """
        return self.hint_height - self.min_height

    def add_item(self, item):
        """ Add an item to the layout row.

        Parameters
        ----------
        item : QFlowWidgetItem
            The flow widget item to add to the layout row.

        Returns
        -------
        result : bool
            True if the items was added. False if the item was not
            added. An item will not be added if the row already
            contains an item and adding another item would cause
            it to overflow.

        """
        min_size = item.minimumSize()
        hint_size = item.sizeHint()
        n = len(self._items)
        s = self._options.h_spacing
        if n > 0 and (self.hint_width + s + hint_size.width()) > self._width:
            return False
        self.min_height = max(self.min_height, min_size.height())
        self.hint_height = max(self.hint_height, hint_size.height())
        self.stretch = max(self.stretch, item.data.ortho_stretch)
        self.min_width += min_size.width()
        self.hint_width += hint_size.width()
        self._items_stretch += item.data.stretch
        if n > 0:
            self.min_width += s
            self.hint_width += s
        self._items.append(item)
        return True

    def layout(self, x, y):
        """ Layout the row using the given starting coordinates.

        Parameters
        ----------
        x : int
            The x coordinate of the row origin.

        y : int
            The y coordinate of the row origin.

        """
        opts = self._options
        layout_width = self._width
        layout_height = self.layout_height
        delta = self._width - self.hint_width
        items = self._items

        # Short circuit the case where there is negative extra space.
        # This means that there must be only a single item in the row,
        # in which case the width may shrink to the minimum if needed.
        if delta < 0:
            assert len(items) == 1
            item = items[0]
            w = max(layout_width, item.minimumSize().width())
            if item.data.ortho_stretch > 0:
                h = min(layout_height, item.maximumSize().height())
            else:
                h = min(layout_height, item.sizeHint().height())
            delta_h = layout_height - h
            if delta_h > 0:
                align = item.data.alignment
                if align == QFlowLayout.AlignTrailing:
                    y += delta_h
                elif align == QFlowLayout.AlignCenter:
                    y += delta_h / 2
            item.setGeometry(QRect(x, y, w, h))
            return

        # Reversing the items reverses the layout direction. All of the
        # computation up to this point has be independent of direction.
        if opts.direction == QFlowLayout.RightToLeft:
            items.reverse()

        # Precompute a map of starting widths for the items. These will
        # be progressively modified as the delta space is distributed.
        widths = {}
        for item in items:
            widths[item] = item.sizeHint().width()

        # If the flow stretch for the row is greater than zero. Then
        # there exists an item or items which have flow stretch. It's
        # not sufficient to simply distribute the delta space according
        # to relative stretch factors, because an item may have a max
        # width which is less than the adjusted width. This causes the
        # rest of the adjustments to be invalid, yielding a potential
        # O(n^2) solution. Instead, the items which can stretch are
        # sorted according to the differences between their desired
        # width and max width. When distributing the delta space in this
        # order, any unused space from an item is added back to the pool
        # and its stretch factor removed from further computation. This
        # gives an O(n log n) solution to the problem. This algorithm
        # iteratively removes space from the delta, so that the alignment
        # pass below operates on the adjusted free space amount.
        items_stretch = self._items_stretch
        if items_stretch > 0:
            diffs = []
            for item in items:
                if item.data.stretch > 0:
                    h = item.sizeHint().width()
                    m = item.maximumSize().width()
                    diffs.append((m - h, item))
            diffs.sort()
            for ignored, item in diffs:
                item_stretch = item.data.stretch
                max_width = item.maximumSize().width()
                d = item_stretch * delta / items_stretch
                items_stretch -= item_stretch
                item_width = widths[item]
                if item_width + d > max_width:
                    widths[item] = max_width
                    delta -= max_width - item_width
                else:
                    widths[item] = item_width + d
                    delta -= d

        # The widths of all items are now computed. Any leftover delta
        # space is used for alignment purposes. This is accomplished by
        # shifting the starting location and, in the case of justify,
        # adding to the horizontal space value.
        start_x = x
        space = opts.h_spacing
        if opts.alignment == QFlowLayout.AlignLeading:
            if opts.direction == QFlowLayout.RightToLeft:
                start_x += delta
        elif opts.alignment == QFlowLayout.AlignTrailing:
            if opts.direction == QFlowLayout.LeftToRight:
                start_x += delta
        elif opts.alignment == QFlowLayout.AlignCenter:
            start_x += delta / 2
        else:
            d = delta / (len(items) + 1)
            space += d
            start_x += d

        # Make a final pass over the items and perform the layout. This
        # pass handles the orthogonal alignment of the item if there is
        # any leftover vertical space for the item.
        curr_x = start_x
        for item in items:
            w = widths[item]
            if item.data.ortho_stretch > 0:
                h = min(layout_height, item.maximumSize().height())
            else:
                h = min(layout_height, item.sizeHint().height())
            delta = layout_height - h
            this_y = y
            if delta > 0:
                align = item.data.alignment
                if align == QFlowLayout.AlignTrailing:
                    this_y = y + delta
                elif align == QFlowLayout.AlignCenter:
                    this_y = y + delta / 2
            item.setGeometry(QRect(curr_x, this_y, w, h))
            curr_x += (w + space)


class _LayoutColumn(object):
    """ A private class used by QFlowLayout.

    This class accumulates information about a column of items as the
    items are added to the column. Instances of the this class are
    created by the QFlowLayout during a layout pass. For performance
    reasons, there are several publically accesible attributes. See
    their documentation for restrictions on their use.

    """
    #: The width to use for laying out the column. This attribute is
    #: modified directly by the layout as it distributes the horizontal
    #: space amongst the columns.
    layout_width = 0

    #: The minimum height required for the column. This is automatically
    #: updated as items are added to the column. It should be considered
    #: read-only to external users.
    min_height = 0

    #: The minimum width required for the column. This is automatically
    #: updated as items are added to the column. It should be considered
    #: read-only to external users.
    min_width = 0

    #: The desired height for the column. This is automatically updated
    #: as items are added to the column. It should be considered
    #: read-only to external users.
    hint_height = 0

    #: The desired width for the column. This is automatically updated
    #: as items are added to the column. It should be considered
    #: read-only to external users.
    hint_width = 0

    #: The vertical stretch factor for the column. This is automatically
    #: updated as items are added to the column. It should be considered
    #: read-only by external users.
    stretch = 0

    def __init__(self, height, options):
        """ Initialize a layout column.

        Parameters
        ----------
        height : int
            The height of the layout area.

        options : _LayoutOptions
            The options in effect for the layout.

        """
        self._height = height
        self._options = options
        self._items_stretch = 0
        self._items = []

    @property
    def diff_width(self):
        """ A read-only property which computes the difference between
        the desired width and the minimum width.

        """
        return self.hint_width - self.min_width

    def add_item(self, item):
        """ Add an item to the layout column.

        Parameters
        ----------
        item : QFlowWidgetItem
            The flow widget item to add to the layout column.

        Returns
        -------
        result : bool
            True if the items was added. False if the item was not
            added. An item will not be added if the column already
            contains an item and adding another item would cause
            it to overflow.

        """
        min_size = item.minimumSize()
        hint_size = item.sizeHint()
        n = len(self._items)
        s = self._options.v_spacing
        if n > 0 and self.hint_height + s + hint_size.height() > self._height:
            return False
        self.min_width = max(self.min_width, min_size.width())
        self.hint_width = max(self.hint_width, hint_size.width())
        self.stretch = max(self.stretch, item.data.ortho_stretch)
        self.min_height += min_size.height()
        self.hint_height += hint_size.height()
        self._items_stretch += item.data.stretch
        if n > 0:
            self.min_height += s
            self.hint_height += s
        self._items.append(item)
        return True

    def layout(self, x, y):
        """ Layout the row using the given starting coordinates.

        Parameters
        ----------
        x : int
            The x coordinate of the column origin.

        y : int
            The y coordinate of the column origin.

        """
        opts = self._options
        layout_height = self._height
        layout_width = self.layout_width
        delta = self._height - self.hint_height
        items = self._items

        # Short circuit the case where there is negative extra space.
        # This means that there must be only a single item in the column,
        # in which case the height may shrink to the minimum if needed.
        if delta < 0:
            assert len(items) == 1
            item = items[0]
            h = max(layout_height, item.minimumSize().height())
            if item.data.ortho_stretch > 0:
                w = min(layout_width, item.maximumSize().width())
            else:
                w = min(layout_width, item.sizeHint().width())
            delta_w = layout_width - w
            if delta_w > 0:
                align = item.data.alignment
                if align == QFlowLayout.AlignTrailing:
                    x += delta_w
                elif align == QFlowLayout.AlignCenter:
                    x += delta_w / 2
            item.setGeometry(QRect(x, y, w, h))
            return

        # Reversing the items reverses the layout direction. All of the
        # computation up to this point has be independent of direction.
        if opts.direction == QFlowLayout.BottomToTop:
            items.reverse()

        # Precompute a map of starting heights for the items. These will
        # be progressively modified as the delta space is distributed.
        heights = {}
        for item in items:
            heights[item] = item.sizeHint().height()

        # See the long comment in _LayoutRow for the explanation about
        # this section of code. This section is simply the transpose.
        items_stretch = self._items_stretch
        if items_stretch > 0:
            diffs = []
            for item in items:
                if item.data.stretch > 0:
                    h = item.sizeHint().height()
                    m = item.maximumSize().height()
                    diffs.append((m - h, item))
            diffs.sort()
            for ignored, item in diffs:
                item_stretch = item.data.stretch
                max_height = item.maximumSize().height()
                d = item_stretch * delta / items_stretch
                items_stretch -= item_stretch
                item_height = heights[item]
                if item_height + d > max_height:
                    heights[item] = max_height
                    delta -= max_height - item_height
                else:
                    heights[item] = item_height + d
                    delta -= d

        # The heights of all items are now computed. Any leftover delta
        # space is used for alignment purposes. This is accomplished by
        # shifting the starting location and, in the case of justify,
        # adding to the vertical space value.
        start_y = y
        space = opts.v_spacing
        if opts.alignment == QFlowLayout.AlignLeading:
            if opts.direction == QFlowLayout.BottomToTop:
                start_y += delta
        elif opts.alignment == QFlowLayout.AlignTrailing:
            if opts.direction == QFlowLayout.TopToBottom:
                start_y += delta
        elif opts.alignment == QFlowLayout.AlignCenter:
            start_y += delta / 2
        else:
            d = delta / (len(items) + 1)
            space += d
            start_y += d

        # Make a final pass over the items and perform the layout. This
        # pass handles the orthogonal alignment of the item if there is
        # any leftover horizontal space for the item.
        curr_y = start_y
        for item in items:
            h = heights[item]
            if item.data.ortho_stretch > 0:
                w = min(layout_width, item.maximumSize().width())
            else:
                w = min(layout_width, item.sizeHint().width())
            delta = layout_width - w
            this_x = x
            if delta > 0:
                align = item.data.alignment
                if align == QFlowLayout.AlignTrailing:
                    this_x = x + delta
                elif align == QFlowLayout.AlignCenter:
                    this_x = x + delta / 2
            item.setGeometry(QRect(this_x, curr_y, w, h))
            curr_y += (h + space)


class QFlowLayout(QLayout):
    """ A custom QLayout which implements a flowing wraparound layout.

    """
    #: Lines are filled from left to right and stacked top to bottom.
    LeftToRight = 0

    #: Lines are filled from right to left and stacked top to bottom.
    RightToLeft = 1

    #: Lines are filled from top to bottom and stacked left to right.
    TopToBottom = 2

    #: Lines are filled from bottom to top and stacked left to right.
    BottomToTop = 3

    #: Lines are aligned to their leading edge.
    AlignLeading = 4

    #: Lines are aligned to their trailing edge.
    AlignTrailing = 5

    #: Lines are aligned centered within any extra space.
    AlignCenter = 6

    #: Lines are aligned justified within any extra space.
    AlignJustify = 7

    def __init__(self):
        """ Initialize a QFlowLayout.

        """
        super(QFlowLayout, self).__init__()
        self._items = []
        self._options = _LayoutOptions()
        self._cached_w = -1
        self._cached_hfw = -1
        self._cached_min = None
        self._cached_hint = None
        self._wfh_size = None

    def addWidget(self, widget):
        """ Add a widget to the end of the flow layout.

        Parameters
        ----------
        widget : AbstractFlowWidget
            The flow widget to add to the layout.

        """
        self.insertWidget(self.count(), widget)

    def insertWidget(self, index, widget):
        """ Insert a widget into the flow layout.

        Parameters
        ----------
        index : int
            The index at which to insert the widget.

        widget : AbstractFlowWidget
            The flow widget to insert into the layout.

        """
        assert isinstance(widget, AbstractFlowWidget), 'invalid widget type'
        self.addChildWidget(widget)
        item = QFlowWidgetItem(widget, widget.layoutData())
        self._items.insert(index, item)
        widget.show()
        self.invalidate()

    def direction(self):
        """ Get the direction of the flow layout.

        Returns
        -------
        result : QFlowLayout direction enum
            The direction of the layout. The default is LeftToRight.

        """
        return self._options.direction

    def setDirection(self, direction):
        """ Set the direction of the flow layout.

        Parameters
        ----------
        direction : QFlowLayout direction enum
            The desired flow direction of the layout.

        """
        self._options.direction = direction
        self.invalidate()

    def alignment(self):
        """ Get the alignment for the lines in the layout.

        Returns
        -------
        result : QFlowLayout alignment enum
            The alignment of the lines in the layout. The default is
            AlignLeading.

        """
        return self._options.alignment

    def setAlignment(self, alignment):
        """ Set the alignment for the lines in the layout.

        Parameters
        ----------
        alignment : QFlowLayout alignment enum
            The desired alignment of the lines in the layout.

        """
        self._options.alignment = alignment
        self.invalidate()

    def horizontalSpacing(self):
        """ Get the horizontal spacing for the layout.

        Returns
        -------
        result : int
            The number of pixels of horizontal space between items in
            the layout. The default is 10px.

        """
        return self._options.h_spacing

    def setHorizontalSpacing(self, spacing):
        """ Set the horizontal spacing for the layout.

        Parameters
        ----------
        spacing : int
            The number of pixels of horizontal space to place between
            items in the layout.

        """
        self._options.h_spacing = spacing
        self.invalidate()

    def verticalSpacing(self):
        """ Get the vertical spacing for the layout.

        Returns
        -------
        result : int
            The number of pixels of vertical space between items in the
            layout. The default is 10px.

        """
        return self._options.v_spacing

    def setVerticalSpacing(self, spacing):
        """ Set the vertical spacing for the layout.

        Parameters
        ----------
        spacing : int
            The number of pixels of vertical space to place between
            items in the layout.

        """
        self._options.v_spacing = spacing
        self.invalidate()

    def hasHeightForWidth(self):
        """ Whether the height of the layout depends on its width.

        Returns
        -------
        result : bool
            True if the flow direction is horizontal, False otherwise.

        """
        return self._options.direction in (self.LeftToRight, self.RightToLeft)

    def heightForWidth(self, width):
        """ Get the height of the layout for the given width.

        This value only applies if `hasHeightForWidth` returns True.

        Parameters
        ----------
        width : int
            The width for which to determine a height.

        """
        if self._cached_w != width:
            left, top, right, bottom = self.getContentsMargins()
            adj_width = width - (left + right)
            height = self._doLayout(QRect(0, 0, adj_width, 0), True)
            self._cached_hfw = height + top + bottom
            self._cached_w = adj_width
        return self._cached_hfw

    def addItem(self, item):
        """ A required virtual method implementation.

        This method should not be used. The methods `addWidget` and
        `insertWidget` should be used instead.

        """
        msg = 'Use `addWidget` and `insertWidget` instead.'
        raise NotImplementedError(msg)

    def invalidate(self):
        """ Invalidate the cached values of the layout.

        """
        self._cached_w = -1
        self._cached_hfw = -1
        self._cached_wfh = -1
        self._cached_min = None
        self._cached_hint = None
        for item in self._items:
            item.invalidate()
        super(QFlowLayout, self).invalidate()

    def count(self):
        """ A virtual method implementation which returns the number of
        items in the layout.

        """
        return len(self._items)

    def itemAt(self, idx):
        """ A virtual method implementation which returns the layout item
        for the given index or None if one does not exist.

        """
        items = self._items
        if idx < len(items):
            return items[idx]

    def takeAt(self, idx):
        """ A virtual method implementation which removes and returns the
        item at the given index or None if one does not exist.

        """
        items = self._items
        if idx < len(items):
            item = items[idx]
            del items[idx]
            item.widget().hide()
            # The creation path of the layout items bypasses the virtual
            # wrapper methods, this means that the ownership of the cpp
            # pointer is never transfered to Qt. If the item is returned
            # here it will be delete by Qt, which doesn't own the pointer.
            # A double free occurs once the Python item falls out of scope.
            # To avoid this, this method always returns None and the item
            # cleanup is performed by Python, which owns the cpp pointer.

    def setGeometry(self, rect):
        """ Sets the geometry of all the items in the layout.

        """
        super(QFlowLayout, self).setGeometry(rect)
        self._doLayout(self.contentsRect())

    def sizeHint(self):
        """ A virtual method implementation which returns the size hint
        for the layout.

        """
        if self._cached_hint is None:
            size = QSize(0, 0)
            for item in self._items:
                size = size.expandedTo(item.sizeHint())
            left, top, right, bottom = self.getContentsMargins()
            size.setWidth(size.width() + left + right)
            size.setHeight(size.height() + top + bottom)
            self._cached_hint = size
        return self._cached_hint

    def minimumSize(self):
        """ A reimplemented method which returns the minimum size hint
        of the layout item widget as the minimum size of the window.

        """
        if self._cached_min is None:
            size = QSize(0, 0)
            for item in self._items:
                size = size.expandedTo(item.minimumSize())
            left, top, right, bottom = self.getContentsMargins()
            size.setWidth(size.width() + left + right)
            size.setHeight(size.height() + top + bottom)
            self._cached_min = size
        # XXX hack! We really need hasWidthForHeight! This doesn't quite
        # work because a QScrollArea internally caches the min size.
        d = self._options.direction
        if d == self.TopToBottom or d == self.BottomToTop:
            m = QSize(self._cached_min)
            if m.width() < self._cached_wfh:
                m.setWidth(self._cached_wfh)
            return m
        return self._cached_min

    #--------------------------------------------------------------------------
    # Private API
    #--------------------------------------------------------------------------
    def _doLayout(self, rect, test=False):
        """ Perform the layout for the given rect.

        Parameters
        ----------
        rect : QRect
            The area to use for performing the layout.

        test : bool, optional
            If True, perform a trial run of the layout without actually
            updating any of the item geometries.

        Returns
        -------
        result : int
            The layout space (width or height) required in the direction
            orthogonal to the layout flow.

        """
        d = self._options.direction
        if d == self.LeftToRight or d == self.RightToLeft:
            res = self._doHorizontalLayout(rect, test)
        else:
            res = self._doVerticalLayout(rect, test)
            # XXX hack! we need hasWidthForHeight
            self._cached_wfh = res + rect.x()
        return res

    def _doHorizontalLayout(self, rect, test):
        """ Perform the layout for a horizontal flow direction.

        The method signature is identical to the `_doLayout` method.

        """
        # Walk over the items and create the layout rows.
        rows = []
        width = rect.width()
        opts = self._options
        for item in self._items:
            if len(rows) == 0:
                row = _LayoutRow(width, opts)
                row.add_item(item)
                rows.append(row)
            else:
                row = rows[-1]
                if not row.add_item(item):
                    row = _LayoutRow(width, opts)
                    row.add_item(item)
                    rows.append(row)

        # After collecting rows all of the rows, compute the metrics. If
        # this is a test run, only the minimum height is required.
        space = opts.v_spacing * (len(rows) - 1)
        if test:
            return sum(row.min_height for row in rows) + space

        min_height = space
        hint_height = space
        total_diff = 0
        stretch = 0
        for row in rows:
            min_height += row.min_height
            hint_height += row.hint_height
            total_diff += row.diff_height
            stretch += row.stretch

        # Make an initial pass to distribute extra space to rows which
        # lie between their minimum height and desired height.
        height = rect.height()
        play_space = max(0, height - min_height)
        diff_space = max(total_diff, 1) # Guard against divide by zero
        layout_height = 0
        for row in rows:
            d = play_space * row.diff_height / diff_space
            row.layout_height = min(row.min_height + d, row.hint_height)
            layout_height += row.layout_height
        layout_height += space

        # Make a second pass to distribute remaining space to rows
        # which with a stretch factor greater than zero.
        remaining = height - layout_height
        if remaining > 0 and stretch > 0:
            for row in rows:
                if row.stretch > 0:
                    row.layout_height += remaining * row.stretch / stretch

        # Make a final pass to layout the rows, computing the overall
        # final layout height along the way.
        final_height = 0
        x = rect.x()
        curr_y = rect.y()
        v_space = opts.v_spacing
        for row in rows:
            row.layout(x, curr_y)
            d = row.layout_height + v_space
            final_height += d
            curr_y += d

        return final_height

    def _doVerticalLayout(self, rect, test):
        """ Perform the layout for a vertical flow direction.

        The method signature is identical to the `_doLayout` method.

        """
        # Walk over the items and create the layout columns.
        cols = []
        height = rect.height()
        opts = self._options
        for item in self._items:
            if len(cols) == 0:
                col = _LayoutColumn(height, opts)
                col.add_item(item)
                cols.append(col)
            else:
                col = cols[-1]
                if not col.add_item(item):
                    col = _LayoutColumn(height, opts)
                    col.add_item(item)
                    cols.append(col)

        # After collecting rows all of the columns, compute the metrics.
        # If this is a test run, only the minimum width is required.
        space = opts.h_spacing * (len(cols) - 1)
        if test:
            return sum(col.min_width for col in cols) + space

        min_width = space
        hint_width = space
        total_diff = 0
        stretch = 0
        for col in cols:
            min_width += col.min_width
            hint_width += col.hint_width
            total_diff += col.diff_width
            stretch += col.stretch

        # Make an initial pass to distribute extra space to columns
        # which lie between their minimum width and desired width.
        width = rect.width()
        play_space = max(0, width - min_width)
        diff_space = max(total_diff, 1) # Guard against divide by zero
        layout_width = 0
        for col in cols:
            d = play_space * col.diff_width / diff_space
            col.layout_width = min(col.min_width + d, col.hint_width)
            layout_width += col.layout_width
        layout_width += space

        # Make a second pass to distribute remaining space to columns
        # which with a stretch factor greater than zero.
        remaining = width - layout_width
        if remaining > 0 and stretch > 0:
            for col in cols:
                if col.stretch > 0:
                    col.layout_width += remaining * col.stretch / stretch

        # Make a final pass to layout the columns, computing the overall
        # final layout width along the way.
        final_width = 0
        y = rect.y()
        curr_x = rect.x()
        h_space = opts.h_spacing
        for col in cols:
            col.layout(curr_x, y)
            d = col.layout_width + h_space
            final_width += d
            curr_x += d

        return final_width


class _LayoutOptions(object):
    """ A private class used by QFlowLayout to store layout options.

    """
    #: The flow direction of the layout.
    direction = QFlowLayout.LeftToRight

    #: The alignment of a line in the layout.
    alignment = QFlowLayout.AlignLeading

    #: The horizontal spacing between items or lines in the layout.
    h_spacing = 10

    #: The vertical spacing between items or lines in the layout.
    v_spacing = 10


########NEW FILE########
__FILENAME__ = q_pixmap_painter
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from .qt.QtCore import QObject, QEvent, Slot
from .qt.QtGui import QPainter, QPixmap


class QPixmapPainter(QObject):
    """ A QObject class which will paint a pixmap onto a QWidget.

    """
    def __init__(self):
        """ Initialize a QPixmapPainter.

        """
        super(QPixmapPainter, self).__init__()
        self._target = None
        self._pixmap = None

    #--------------------------------------------------------------------------
    # Slots
    #--------------------------------------------------------------------------
    @Slot(QPixmap)
    def drawPixmap(self, pixmap):
        """ Draw the given pixmap onto the parent widget.

        This method is also a Slot which can be connected to signal that
        emits a QPixmap payload.

        Parameters
        ----------
        pixmap : QPixmap
            The pixmap to draw in on the parent.

        """
        self._pixmap = pixmap
        target = self._target
        if target is not None:
            target.update()

    #--------------------------------------------------------------------------
    # Public API
    #--------------------------------------------------------------------------
    def targetWidget(self):
        """ Get the target widget of this painter.

        Returns
        -------
        result : QWidget or None
            The target widget onto which this painter will paint, or
            None if a widget has not yet been provided.

        """
        return self._target

    def setTargetWidget(self, widget):
        """ Set the target widget for this painter.

        Parameters
        ----------
        widget : QWidget
            The widget onto which this painter will paint incoming
            pixmaps.

        """
        old = self._target
        if old is not None:
            old.removeEventFilter(self)
        if widget is not None:
            widget.installEventFilter(self)
        self._target = widget

    def eventFilter(self, obj, event):
        """ Filter the events for the given object.

        This method will only filter paint events for the target of this
        object. If there is a pixmap available for drawing, then that
        will be drawn onto the target.

        """
        if event.type() == QEvent.Paint:
            if obj is self._target:
                pm = self._pixmap
                if pm is not None:
                    painter = QPainter(obj)
                    painter.drawPixmap(0, 0, pm)
                    return True
        return False


########NEW FILE########
__FILENAME__ = q_pixmap_transition
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from .qt.QtCore import QPoint, QRect, QVariantAnimation, Signal
from .qt.QtGui import QPainter, QPixmap, QPainterPath 


class QPixmapTransition(QVariantAnimation):
    """ A QVariantAnimation subclass for building transitions between
    two QPixmaps.

    This is an abstract base class which provides common functionality
    for creating concrete transitions.

    """
    #: A signal emmitted when the output pixmap has been updated with
    #: a new frame in the transition animation. The paylod will be the
    #: output pixmap of the transition.
    pixmapUpdated = Signal(QPixmap)

    def __init__(self):
        """ Initialize a QPixmapTransition.

        """
        super(QPixmapTransition, self).__init__()
        self._start_pixmap = None
        self._end_pixmap = None
        self._out_pixmap = None

    #--------------------------------------------------------------------------
    # Public API
    #--------------------------------------------------------------------------
    def startPixmap(self):
        """ Get the starting pixmap for the transition.

        Returns
        -------
        result : QPixmap or None
            The starting pixmap for the transition or None if it has
            not yet been provided.

        """
        return self._start_pixmap

    def endPixmap(self):
        """ Get the ending pixmap for the transition.

        Returns
        -------
        result : QPixmap or None
            The ending pixmap for the transition or None if it has
            not yet been provided.

        """
        return self._end_pixmap

    def outPixmap(self):
        """ Get the output pixmap for the transition.

        Returns
        -------
        result : QPixmap or None
            The output pixmap for the transition or None if it has
            not yet been provided.

        """
        return self._out_pixmap

    def setPixmaps(self, start, end, out):
        """ Set the pixmaps to use during the transition.

        Parameters
        ----------
        start : QPixmap
            The pixmap for the first frame of the transition.

        end : QPixmap
            The pixmap for the last frame of the transition.

        out : QPixmap
            The pixmap into which the intermediate transition frames
            will be drawn.

        """
        self._start_pixmap = start
        self._end_pixmap = end
        self._out_pixmap = out

    def start(self):
        """ Start the pixmap transition.

        This is an overridden parent class method which provides a 
        hook for subclasses to prepare their working pixmaps before
        the animation is started.

        """
        start, end = self.preparePixmap()
        self.setStartValue(start)
        self.setEndValue(end)
        super(QPixmapTransition, self).start()

    def updateCurrentValue(self, value):
        """ Updates the current transition value.
            
        This method will dispatch to the `updatePixmap` method provided
        that the current animation state is `Running` and then emit
        the `pixmapUpdated` signal. 

        Parameters
        ----------
        value : object
            The variant interpolated object value for the current step
            in the animation.

        """
        if self.state() == self.State.Running:
            self.updatePixmap(value)
            self.pixmapUpdated.emit(self.outPixmap())

    #--------------------------------------------------------------------------
    # Abstract API
    #--------------------------------------------------------------------------
    def preparePixmap(self):
        """ Prepare the underlying pixmap(s) for the transition.

        This method is abstract and must be implemented by subclasses. 
        It is called directly before the transition is started. The
        subclass should do any required transition initialization in
        this method.

        Returns
        -------
        result : (start, end)
            The start and end values to use when interpolating the
            transition. The interpolated values will be passed to
            the `updatePixmap` method.

        """
        raise NotImplementedError

    def updatePixmap(self, value):
        """ Update the underlying output pixmap for the transition.

        This method is abstract and must be implemented by subclasses. 
        It is called during the transition with an interpolated value
        appopriate for the current transition step.

        Parameters
        ----------
        value : object
            The interpolated value between the values of `start` and
            `end` returned by the `preparePixmap` method.

        """
        raise NotImplementedError


class QDirectedTransition(QPixmapTransition):
    """ A QPixmapTransition which adds a transition direction.

    This is a base class used by several concrete transition classes.
    It is not meant to be used directly.

    """
    #: Transition proceeds from left to right.
    LeftToRight = 0

    #: Transition proceeds from right to left.
    RightToLeft = 1

    #: Transition proceeds from top to bottom.
    TopToBottom = 2

    #: Transition proceeds from bottom to top.
    BottomToTop = 3

    def __init__(self):
        """ Initialize a QDirectedTransition.

        """
        super(QDirectedTransition, self).__init__()
        self._direction = self.RightToLeft

    def direction(self):
        """ Get the direction of the transition.

        Returns
        -------
        result : int
            The direction enum value for the transition.

        """
        return self._direction

    def setDirection(self, direction):
        """ Set the direction of the transition.

        Parameters
        ----------
        direction : int
            The direction enum value for the transition. Must be one
            of `LeftToRight`, `RightToLeft`, `TopToBottom`, or 
            `BottomToTop`.

        """
        dirs = (
            self.LeftToRight, self.RightToLeft, 
            self.TopToBottom, self.BottomToTop,
        )
        if direction not in dirs:
            raise ValueError('Invalid direction: %s' % direction)
        self._direction = direction


class QSlideTransition(QDirectedTransition):
    """ A QDirectedTransition which animates using a sliding effect.

    """
    def __init__(self):
        """ Initialize a QSlideTransition.

        """
        super(QSlideTransition, self).__init__()
        self._slide_pixmap = None

    def preparePixmap(self):
        """ Prepare the pixmap(s) for the transition.

        This method builds a temporary pixmap containing both the start
        and end pixmaps adjoined. The transition then draws a subrect
        of this pixmap into the output pixmap.

        """
        start = self.startPixmap()
        end = self.endPixmap()
        size = start.size().expandedTo(end.size())
        width = size.width()
        height = size.height()
        direction = self.direction()
        if direction == self.LeftToRight:
            pm = QPixmap(width * 2, height)
            painter = QPainter(pm)
            painter.drawPixmap(0, 0, end)
            painter.drawPixmap(width, 0, start)
            start_rect = QRect(width, 0, width * 2, height)
            end_rect = QRect(0, 0, width, height)
        elif direction == self.RightToLeft:
            pm = QPixmap(width * 2, height)
            painter = QPainter(pm)
            painter.drawPixmap(0, 0, start)
            painter.drawPixmap(width, 0, end)
            start_rect = QRect(0, 0, width, height)
            end_rect = QRect(width, 0, width * 2, height)
        elif direction == self.TopToBottom:
            pm = QPixmap(width, height * 2)
            painter = QPainter(pm)
            painter.drawPixmap(0, 0, end)
            painter.drawPixmap(0, height, start)
            start_rect = QRect(0, height, width, height * 2)
            end_rect = QRect(0, 0, width, height)
        elif direction == self.BottomToTop:
            pm = QPixmap(width, height * 2)
            painter = QPainter(pm)
            painter.drawPixmap(0, 0, start)
            painter.drawPixmap(0, height, end)
            start_rect = QRect(0, 0, width, height)
            end_rect = QRect(0, height, width, height * 2)
        else:
            raise ValueError('Invalid direction: %s' % direction)
        self._slide_pixmap = pm
        return start_rect, end_rect

    def updatePixmap(self, rect):
        """ Update the pixmap for the current transition.

        This method paints the current rect from the internal slide
        pixmap into the output pixmap.

        """
        painter = QPainter(self.outPixmap())
        painter.drawPixmap(QPoint(0, 0), self._slide_pixmap, rect)


class QWipeTransition(QDirectedTransition):
    """ A QDirectedTransition which animates using a wipe effect.

    """
    def preparePixmap(self):
        """ Prepare the pixmap(s) for the transition.

        This method draws the starting pixmap into the output pixmap.
        The transition update then draws over the output with the
        proper portion of the ending pixmap.

        """
        start = self.startPixmap()
        end = self.endPixmap()
        size = start.size().expandedTo(end.size())
        width = size.width()
        height = size.height()
        painter = QPainter(self.outPixmap())
        painter.drawPixmap(0, 0, start)
        direction = self.direction()
        if direction == self.LeftToRight:
            start_rect = QRect(0, 0, 0, height)
        elif direction == self.RightToLeft:
            start_rect = QRect(width, 0, 0, height)
        elif direction == self.TopToBottom:
            start_rect = QRect(0, 0, width, 0)
        elif direction == self.BottomToTop:
            start_rect = QRect(0, height, width, 0)
        else:
            raise ValueError('Invalid direction: %s' % direction)
        end_rect = QRect(0, 0, width, height)
        return start_rect, end_rect

    def updatePixmap(self, rect):
        """ Update the pixmap for the current transition.

        This method paints the current rect from the ending pixmap into
        the proper rect of the output pixmap.

        """
        painter = QPainter(self.outPixmap())
        painter.drawPixmap(rect, self.endPixmap(), rect)


class QIrisTransition(QPixmapTransition):
    """ A QPixmap transition which animates using an iris effect.

    """
    def preparePixmap(self):
        """ Prepare the pixmap(s) for the transition.

        This method draws the starting pixmap into the output pixmap.
        The transition update then sets a circular clipping region on
        the ouput and draws in the ending pixmap.

        """
        start = self.startPixmap()
        end = self.endPixmap()
        painter = QPainter(self.outPixmap())
        painter.drawPixmap(0, 0, start)
        size = start.size().expandedTo(end.size())
        width = size.width()
        height = size.height()
        radius = int((width**2 + height**2) ** 0.5) / 2
        start_rect = QRect(width / 2, height / 2, 0, 0)
        end_rect = QRect(width / 2, height / 2, radius, radius)
        return start_rect, end_rect

    def updatePixmap(self, rect):
        """ Update the pixmap for the current transition.

        This method sets a radial clipping region on the output pixmap
        and draws in the relevant portion of the ending pixamp.

        """
        x = rect.x()
        y = rect.y()
        rx = rect.width()
        ry = rect.height()
        path = QPainterPath()
        path.addEllipse(QPoint(x, y), rx, ry)
        painter = QPainter(self.outPixmap())
        painter.setClipPath(path)
        painter.drawPixmap(QPoint(0, 0), self.endPixmap())


class QFadeTransition(QPixmapTransition):
    """ A QPixmapTransition which animates using a fade effect.

    """
    def preparePixmap(self):
        """ Prepare the pixmap(s) for the transition.

        This method draws the starting pixmap into the output pixmap.
        The transition updates then draw the relevant pixmaps into 
        the output using an appropriate alpha.

        """
        painter = QPainter(self.outPixmap())
        painter.drawPixmap(QPoint(0, 0), self.startPixmap())
        return -1.0, 1.0

    def updatePixmap(self, alpha):
        """ Update the pixmap for the current transition.

        This method first clears the output pixmap. It then draws a
        pixmap using the given alpha value. An alpha value less than
        zero indicates that the starting pixmap should be drawn. A 
        value greater than or equal to zero indicates the ending 
        pixmap should be drawn.

        """
        out = self.outPixmap()
        painter = QPainter(out)
        painter.eraseRect(0, 0, out.width(), out.height())
        if alpha < 0.0:
            alpha = -1.0 * alpha
            source = self.startPixmap()
        else:
            source = self.endPixmap()
        painter.setOpacity(alpha)
        painter.drawPixmap(QPoint(0, 0), source)


class QCrossFadeTransition(QPixmapTransition):
    """ A QPixmapTransition which animates using a cross fade effect.

    """
    def preparePixmap(self):
        """ Prepare the pixmap(s) for the transition.

        This method draws the starting pixmap into the output pixmap.
        The transition updates then draw the two pixmaps with an 
        appropriate alpha blending value.

        """
        painter = QPainter(self.outPixmap())
        painter.drawPixmap(QPoint(0, 0), self.startPixmap())
        return 0.0, 1.0

    def updatePixmap(self, alpha):
        """ Update the pixmap for the current transition.

        This method first clears the output pixmap. It then draws the 
        starting pixmap followed by the ending pixmap. Each pixmap is
        drawn with complementary alpha values.

        """
        out = self.outPixmap()
        painter = QPainter(out)
        painter.eraseRect(0, 0, out.width(), out.height())
        painter.setOpacity(1.0 - alpha)
        painter.drawPixmap(QPoint(0, 0), self.startPixmap())
        painter.setOpacity(alpha)
        painter.drawPixmap(QPoint(0, 0), self.endPixmap())


########NEW FILE########
__FILENAME__ = q_single_widget_layout
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from .qt.QtCore import QSize
from .qt.QtGui import QLayout, QWidgetItem


class QSingleWidgetItem(QWidgetItem):
    """ A QWidgetItem subclass for use with the QSingleWidgetLayout.

    The semantics of this widget item are slightly different from that
    of the standard QWidgetItem; it always aligns its widget with the
    top left of the layout rect. This class is expressly meant for use
    by the QSingleWidgetLayout.

    """
    def setGeometry(self, rect):
        """ Set the rectangle covered by this layout item.

        Parameters
        ----------
        rect : QRect
            The rectangle that this layout item should cover.

        """
        if self.isEmpty():
            return
        s = rect.size().boundedTo(self.maximumSize())
        self.widget().setGeometry(rect.x(), rect.y(), s.width(), s.height())


class QSingleWidgetLayout(QLayout):
    """ A QLayout subclass which can have at most one layout item.

    The layout item is expanded to fit the allowable space; similar to
    how a central widget behaves in a QMainWindow. Unlike QMainWindow,
    this layout respects the maximum size of the widget. The default
    contents margins of this layout is 0px in all directions.

    """
    def __init__(self, *args, **kwargs):
        """ Initialize a QSingleWidgetLayout.

        Parameters
        ----------
        *args, **kwargs
            The positional and keyword arguments needed to initialize
            a QLayout.

        """
        super(QSingleWidgetLayout, self).__init__(*args, **kwargs)
        self.setContentsMargins(0, 0, 0, 0)
        self._item = None

    # Note: do not name this method `widget` since that is a virtual
    # method on QLayoutItem which is a parent class of QLayout.
    def getWidget(self):
        """ Get the widget being managed by this layout.

        Returns
        -------
        result : QWidget or None
            The widget being managed by this layout or None if it does
            not exist.

        """
        item = self._item
        if item is not None:
            return item.widget()

    def setWidget(self, widget):
        """ Set the widget for this layout.

        Parameters
        ----------
        widget : QWidget
            The widget to manage with this layout.

        """
        if self.getWidget() is not widget:
            self.takeAt(0)
            if widget is not None:
                self.addChildWidget(widget)
                self._item = QSingleWidgetItem(widget)
                widget.show()
                self.invalidate()

    def addWidget(self, widget):
        """ Overridden parent class method. This method redirects to the
        `setWidget` method. User code should call `setWidget` instead.

        """
        import warnings
        msg = ('`QSingleWidgetLayout.addWidget`: use the '
               '`QSingleWidgetLayout.setWidget` method instead.')
        warnings.warn(msg)
        self.setWidget(widget)

    def addItem(self, item):
        """ A virtual method implementation which sets the layout item
        in the layout. The old item will be overridden.

        This method should not be used. The method `setWidget` should be
        used instead.

        """
        msg = 'Use `setWidget` instead.'
        raise NotImplementedError(msg)

    def count(self):
        """ A virtual method implementation which returns 0 if no layout
        item is supplied, or 1 if there is a current layout item.

        """
        return 0 if self._item is None else 1

    def itemAt(self, idx):
        """ A virtual method implementation which returns the layout item
        for the given index or None if one does not exist.

        """
        if idx == 0:
            return self._item

    def takeAt(self, idx):
        """ A virtual method implementation which removes and returns the
        item at the given index or None if one does not exist.

        """
        if idx == 0:
            item = self._item
            self._item = None
            if item is not None:
                item.widget().hide()
            # The creation path of the layout item bypasses the virtual
            # wrapper methods, this means that the ownership of the cpp
            # pointer is never transfered to Qt. If the item is returned
            # here it will be delete by Qt, which doesn't own the pointer.
            # A double free occurs once the Python item falls out of scope.
            # To avoid this, this method always returns None and the item
            # cleanup is performed by Python, which owns the cpp pointer.

    def sizeHint(self):
        """ A virtual method implementation which returns the size hint
        for the layout.

        """
        item = self._item
        if item is not None:
            hint = item.sizeHint()
            left, top, right, bottom = self.getContentsMargins()
            hint.setHeight(hint.height() + top + bottom)
            hint.setWidth(hint.width() + left + right)
            return hint
        return QSize()

    def setGeometry(self, rect):
        """ A reimplemented method which sets the geometry of the managed
        widget to fill the given rect.

        """
        super(QSingleWidgetLayout, self).setGeometry(rect)
        item = self._item
        if item is not None:
            item.setGeometry(self.contentsRect())

    def minimumSize(self):
        """ A reimplemented method which returns the minimum size hint
        of the layout item widget as the minimum size of the window.

        """
        item = self._item
        if item is not None:
            s = item.minimumSize()
            left, top, right, bottom = self.getContentsMargins()
            s.setHeight(s.height() + top + bottom)
            s.setWidth(s.width() + left + right)
            return s
        return super(QSingleWidgetLayout, self).minimumSize()

    def maximumSize(self):
        """ A reimplemented method which returns the maximum size hint
        of the layout item widget as the maximum size of the window.

        """
        item = self._item
        if item is not None:
            s = item.maximumSize()
            left, top, right, bottom = self.getContentsMargins()
            s.setHeight(s.height() + top + bottom)
            s.setWidth(s.width() + left + right)
            return s
        return super(QSingleWidgetLayout, self).maximumSize()


########NEW FILE########
__FILENAME__ = resource
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from traits.api import HasTraits


class Resource(HasTraits):
    """ A base class to use for creating resource objects.

    """
    def class_name(self):
        """ Get the class name of this resource.

        """
        return type(self).__name__

    def base_names(self):
        """ Get the base class names of this resource.

        """
        names = []
        for base in type(self).mro()[1:]:
            if base is Resource:
                names.append(base.__name__)
                break
            names.append(base.__name__)
        return names

    def snapshot(self):
        """ Get a snapshot dictionary for this resource.

        Subclass should reimplement this method to add more metadata
        to the snapshot dictionary.

        """
        return {'class': self.class_name(), 'bases': self.base_names()}


########NEW FILE########
__FILENAME__ = resource_manager
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
import logging
from urlparse import urlparse

from traits.api import HasTraits, Dict, Str

from .icon_provider import IconProvider
from .image_provider import ImageProvider


logger = logging.getLogger(__name__)


class ResourceManager(HasTraits):
    """ A class which manages resource loading for a `Session`.

    A `ResourceManager` is used by a `Session` object to load resources
    when a url resource request is made by a client session. Users work
    with the manager by assigning provider objects associated with a
    host name. For example, a user can provide an image for the url
    `image://filesystem/c:/foo/bar.png` by assigning an `ImageProvider`
    instace to the `image_providers` dict with the key `filesystem`.

    """
    #: A dict mapping provider location to image provider object. When
    #: a resource `image://foo/bar/baz` is requested, the image provider
    #: provider `foo` is use to request path `/bar/baz`.
    image_providers = Dict(Str, ImageProvider)

    #: A dict of icon providers for the `icon://...` scheme.
    icon_providers = Dict(Str, IconProvider)

    def load(self, url, metadata, reply):
        """ Load a resource from the manager.

        Parameters
        ----------
        url : str
            The url pointing to the resource to load.

        metadata : dict
            Additional metadata required to load the resource of the
            given type. See the individual loading handlers for the
            supported metadata.

        reply : URLReply
            A url reply which will be invoked with the loaded resource
            object, or None if the loading fails. It must be safe to
            invoke this reply from a thread.

        """
        scheme = urlparse(url).scheme
        handler = getattr(self, '_load_' + scheme, None)
        if handler is None:
            msg = 'unhandled url resource scheme: `%s`'
            logger.error(msg % url)
            reply(None)
            return
        handler(url, metadata, reply)

    #--------------------------------------------------------------------------
    # Private API
    #--------------------------------------------------------------------------
    def _load_image(self, url, metadata, reply):
        """ Load an image resource.

        This is a private handler method called by the `load` method.
        It should not be called directly by user code.

        Parameters
        ----------
        url : str
            The url pointing to the image to load.

        metadata : dict
            The image loader accepts optional 'size' metadata which
            is the desired size with which to load the image. The
            default is (-1, -1) which indicates the images natural
            size should be used.

        reply : URLReply
            A url reply which will be invoked with the loaded image
            object, or None if the loading fails. It must be safe to
            invoke this reply from a thread.

        """
        spec = urlparse(url)
        provider = self.image_providers.get(spec.netloc)
        if provider is None:
            msg = 'no image provider registered for url: `%s`'
            logger.error(msg % url)
            reply(None)
            return
        size = metadata.get('size', (-1, -1))
        provider.request_image(spec.path, size, reply)

    def _load_icon(self, url, metadata, reply):
        """ Load an icon resource.

        This is a private handler method called by the `load` method.
        It should not be called directly by user code.

        Parameters
        ----------
        url : str
            The url pointing to the icon to load.

        metadata : dict
            The icon loader does not accept any metadata. Any data
            in this dict will be ignored.

        reply : URLReply
            A url reply which will be invoked with the loaded icon
            object, or None if the loading fails. It must be safe to
            invoke this reply from a thread.

        """
        spec = urlparse(url)
        provider = self.icon_providers.get(spec.netloc)
        if provider is None:
            msg = 'no icon provider registered for url: `%s`'
            logger.error(msg % url)
            reply(None)
            return
        provider.request_icon(spec.path, reply)


########NEW FILE########
__FILENAME__ = runner
#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
""" Command-line tool to run .enaml files.

"""
import optparse
import os
import sys
import types
import warnings

from enaml import imports
from enaml.stdlib.sessions import show_simple_view
from enaml.core.parser import parse
from enaml.core.enaml_compiler import EnamlCompiler


def prepare_toolkit(toolkit_option):
    """ Prepare the toolkit to be used by Enaml.

    This function determines the Enaml toolkit based on the values of
    the toolkit option and the ETS_TOOLKIT environment variable. ETS
    gui components default to Wx when ETS_TOOLKIT is not defined, but
    Enaml defaults to Qt. Under this condition, ETS_TOOLKIT is updated
    to be consistent with Enaml. If ETS_TOOLKIT is already set and it
    is incompatibile with the -t option, a warning is raised.

    Parameters
    ----------
    toolkit_option : str
        The toolkit option provided to the enaml-run script.

    Returns
    -------
    result : str
       The toolkit to be used by enaml.

    """
    if 'ETS_TOOLKIT' in os.environ:
        ets_toolkit = os.environ['ETS_TOOLKIT'].lower().split('.')[0][:2]
        if toolkit_option == 'default' and ets_toolkit in ('wx', 'qt'):
            enaml_toolkit = ets_toolkit
        else:
            enaml_toolkit = 'wx' if toolkit_option == 'wx' else 'qt'
            if ets_toolkit != enaml_toolkit:
                msg = (
                    'The --toolkit option is different from the ETS_TOOLKIT '
                    'environment variable, which can cause incompatibility '
                    'issues when using enable or chaco components.'
                )
                warnings.warn(msg)
    else:
        if toolkit_option == 'wx':
            enaml_toolkit = 'wx'
            os.environ['ETS_TOOLKIT'] = 'wx'
        else:
            enaml_toolkit = 'qt'
            os.environ['ETS_TOOLKIT'] = 'qt4'
    return enaml_toolkit


def main():
    usage = 'usage: %prog [options] enaml_file [script arguments]'
    parser = optparse.OptionParser(usage=usage, description=__doc__)
    parser.allow_interspersed_args = False
    parser.add_option(
        '-c', '--component', default='Main', help='The component to view'
    )
    parser.add_option(
        '-t', '--toolkit', default='default',
        help='The GUI toolkit to use [default: qt or ETS_TOOLKIT].'
    )

    options, args = parser.parse_args()
    toolkit = prepare_toolkit(options.toolkit)

    if len(args) == 0:
        print 'No .enaml file specified'
        sys.exit()
    else:
        enaml_file = args[0]
        script_argv = args[1:]

    with open(enaml_file, 'rU') as f:
        enaml_code = f.read()

    # Parse and compile the Enaml source into a code object
    ast = parse(enaml_code, filename=enaml_file)
    code = EnamlCompiler.compile(ast, enaml_file)

    # Create a proper module in which to execute the compiled code so
    # that exceptions get reported with better meaning
    module = types.ModuleType('__main__')
    module.__file__ = enaml_file
    ns = module.__dict__

    # Put the directory of the Enaml file first in the path so relative
    # imports can work.
    sys.path.insert(0, os.path.abspath(os.path.dirname(enaml_file)))
    # Bung in the command line arguments.
    sys.argv = [enaml_file] + script_argv
    with imports():
        exec code in ns

    requested = options.component
    if requested in ns:
        component = ns[requested]
        descr = 'Enaml-run "%s" view' % requested
        show_simple_view(component(), toolkit, descr)
    elif 'main' in ns:
        ns['main']()
    else:
        msg = "Could not find component '%s'" % options.component
        print msg


if __name__ == '__main__':
    main()

########NEW FILE########
__FILENAME__ = session
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
import logging

from traits.api import (
    HasTraits, Instance, List, Str, ReadOnly, Enum, Property, on_trait_change
)

from enaml.widgets.window import Window

from .application import deferred_call
from .resource_manager import ResourceManager
from .signaling import Signal
from .socket_interface import ActionSocketInterface
from .utils import make_dispatcher


logger = logging.getLogger(__name__)


#: The dispatch function for action dispatching on the session.
dispatch_action = make_dispatcher('on_action_', logger)


class DeferredBatch(object):
    """ A class which aggregates batch items.

    Each time an item is added to this object, its tick count is
    incremented and a tick down event is posted to the event queue.
    When the object receives the tick down event, it decrements its
    tick count, and if it's zero, fires the `triggered` signal.

    This allows a consumer of the batch to continually add items and
    have the `triggered` signal fired only when the event queue is
    fully drained of relevant messages.

    """
    #: A signal emitted when the tick count of the batch reaches zero
    #: and the owner of the batch should consume the messages.
    triggered = Signal()

    def __init__(self):
        """ Initialize a DeferredBatch.

        """
        self._items = []
        self._tick = 0

    #--------------------------------------------------------------------------
    # Private API
    #--------------------------------------------------------------------------
    def _tick_down(self):
        """ A private handler method which ticks down the batch.

        The tick down events are called in a deferred fashion to allow
        for the aggregation of batch events. When the tick reaches
        zero, the `triggered` signal will be emitted.

        """
        self._tick -= 1
        if self._tick == 0:
            self.triggered.emit()
        else:
            deferred_call(self._tick_down)

    #--------------------------------------------------------------------------
    # Public API
    #--------------------------------------------------------------------------
    def release(self):
        """ Release the items that were added to the batch.

        Returns
        -------
        result : list
            The list of items added to the batch.

        """
        items = self._items
        self._items = []
        return items

    def append(self, item):
        """ Append an item to the batch.

        This will cause the batch to tick up and then start the tick
        down process if necessary.

        Parameters
        ----------
        item : object
            The item to add to the batch.

        """
        self._items.append(item)
        if self._tick == 0:
            deferred_call(self._tick_down)
        self._tick += 1


class URLReply(object):
    """ A reply object for sending a loaded resource to a client session.

    """
    def __init__(self, session, req_id, url):
        """ Initialize a URLReply.

        Parameters
        ----------
        session : Session
            The session object for which the image is being loaded.

        req_id : str
            The identifier that was sent with the originating request.
            This identifier will be included in the response.

        url : str
            The url that was sent with the originating request. This
            url will be included in the response.

        """
        self._session = session
        self._req_id = req_id
        self._url = url

    def __call__(self, resource):
        """ Send the reply to the client session.

        Parameters
        ----------
        resource : Resource
            The loaded resource object, or None if the resource failed
            to load.

        """
        reply = {'id': self._req_id, 'url': self._url}
        if resource is None:
            reply['status'] = 'fail'
        else:
            reply['status'] = 'ok'
            reply['resource'] = resource.snapshot()
        session = self._session
        session.send(session.session_id, 'url_reply', reply)


class Session(HasTraits):
    """ An object representing the session between a client and its
    Enaml objects.

    The session object is what ensures that each client has their own
    individual instances of objects, so that the only state that is
    shared between simultaneously existing clients is that which is
    explicitly provided by the developer.

    """
    #: The string identifier for this session. This is provided by
    #: the application when the session is opened. The value should
    #: not be manipulated by user code.
    session_id = ReadOnly

    #: The top level windows which are managed by this session. This
    #: should be populated by user code during the `on_open` method.
    windows = List(Window)

    #: The widget implementation groups which should be used by the
    #: widgets in this session. Widget groups are an advanced feature
    #: which allow the developer to selectively expose toolkit specific
    #: implementations of Enaml widgets. All standard Enaml widgets are
    #: available in the 'default' group. This value will rarely need to
    #: be changed by the user.
    widget_groups = List(Str, ['default'])

    #: A resource manager used for loading resources for the session.
    resource_manager = Instance(ResourceManager, ())

    #: The socket used by this session for communication. This is
    #: provided by the Application when the session is activated.
    #: The value should not normally be manipulated by user code.
    socket = Instance(ActionSocketInterface)

    #: The current state of the session. This value is changed by the
    #: by the application as it drives the session through its lifetime.
    #: This should not be manipulated directly by user code.
    state = Enum(
        'inactive', 'opening', 'opened', 'activating', 'active', 'closing',
        'closed',
    )

    #: A read-only property which is True if the session is inactive.
    is_inactive = Property(fget=lambda self: self.state == 'inactive')

    #: A read-only property which is True if the session is opening.
    is_opening = Property(fget=lambda self: self.state == 'opening')

    #: A read-only property which is True if the session is opened.
    is_opened = Property(fget=lambda self: self.state == 'opened')

    #: A read-only property which is True if the session is activating.
    is_activating = Property(fget=lambda self: self.state == 'activating')

    #: A read-only property which is True if the session is active.
    is_active = Property(fget=lambda self: self.state == 'active')

    #: A read-only property which is True if the session is closing.
    is_closing = Property(fget=lambda self: self.state == 'closing')

    #: A read-only property which is True if the session is closed.
    is_closed = Property(fget=lambda self: self.state == 'closed')

    #: A private dictionary of objects registered with this session.
    #: This value should not be manipulated by user code.
    _registered_objects = Instance(dict, ())

    #: The private deferred message batch used for collapsing layout
    #: related messages into a single batch to send to the client
    #: session for more efficient handling.
    _batch = Instance(DeferredBatch)
    def __batch_default(self):
        batch = DeferredBatch()
        batch.triggered.connect(self._on_batch_triggered)
        return batch

    #--------------------------------------------------------------------------
    # Class API
    #--------------------------------------------------------------------------
    @classmethod
    def factory(cls, name='', description='', *args, **kwargs):
        """ Get a SessionFactory instance for this Session class.

        Parameters
        ----------
        name : str, optional
            The name to use for the session instances. The default uses
            the class name.

        description : str, optional
            A human friendly description of the session. The default uses
            the class docstring.

        *args, **kwargs
            Any positional and keyword arguments to pass to the session
            when it is instantiated.

        """
        from enaml.session_factory import SessionFactory
        if not name:
            name = cls.__name__
        if not description:
            description = cls.__doc__
        return SessionFactory(name, description, cls, *args, **kwargs)

    #--------------------------------------------------------------------------
    # Private API
    #--------------------------------------------------------------------------
    def _on_batch_triggered(self):
        """ A signal handler for the `triggered` signal on the deferred
        message batch.

        """
        batch = [task() for task in self._batch.release()]
        content = {'batch': batch}
        self.send(self.session_id, 'message_batch', content)

    @on_trait_change('windows:destroyed')
    def _on_window_destroyed(self, obj, name, old, new):
        """ A trait handler for the `destroyed` event on the windows.

        This handler will remove a destroyed window from the list of
        the session's windows.

        """
        self.windows.remove(obj)

    #--------------------------------------------------------------------------
    # Abstract API
    #--------------------------------------------------------------------------
    def on_open(self):
        """ Called by the application when the session is opened.

        This method must be implemented in a subclass and is called to
        create the Enaml objects for the session. This method will only
        be called once during the session lifetime. User code should
        create their windows and assign them to the list of `windows`
        before the method returns.

        """
        raise NotImplementedError

    def on_close(self):
        """ Called by the application when the session is closed.

        This method may be optionally implemented by subclasses so that
        they can perform custom cleaup. After this method returns, the
        session should be considered invalid. This method is only called
        once during the session lifetime.

        """
        pass

    #--------------------------------------------------------------------------
    # Public API
    #--------------------------------------------------------------------------
    def open(self, session_id):
        """ Called by the application to open the session.

        This method will call the `on_open` abstract method which must
        be implemented by subclasses. The method should never be called
        by user code.

        Parameters
        ----------
        session_id : str
            The unique identifier to use for this session.

        """
        self.session_id = session_id
        self.state = 'opening'
        self.on_open()
        for window in self.windows:
            window.initialize()
        self.state = 'opened'

    def activate(self, socket):
        """ Called by the application to activate the session and its
        windows.

        This method will be called by the Application once during the
        session lifetime. Once this method returns, the session and
        its objects will be ready to send and receive messages. This
        should never be called by user code.

        Parameters
        ----------
        socket : ActionSocketInterface
            A concrete implementation of ActionSocketInterface to use
            for messaging by this session.

        """
        self.state = 'activating'
        for window in self.windows:
            window.activate(self)
        self.socket = socket
        socket.on_message(self.on_message)
        self.state = 'active'

    def close(self):
        """ Called by the application when the session is closed.

        This method will call the `on_close` method which can optionally
        be implemented by subclasses. The method should never be called
        by user code.

        """
        self.send(self.session_id, 'close', {})
        self.state = 'closing'
        self.on_close()
        # The list is copied to avoid issues with the list changing size
        # while iterating. Windows are removed from the `windows` list
        # when they fire their `destroyed` event during destruction.
        for window in self.windows[:]:
            window.destroy()
        self.windows = []
        self._registered_objects = {}
        self.socket.on_message(None)
        self.socket = None
        self.state = 'closed'

    def add_window(self, window):
        """ Add a window to the session's window list.

        This will add the window to the session and create the client
        side window if necessary. If the window
        already exists in the session, this is a no-op.

        Parameters
        ----------
        window : Window
            A new window instance to add to the session. It will not
            normally have a parent, though this is not enforced.

        """
        if window not in self.windows:
            self.windows.append(window)
            if self.is_active:
                window.initialize()
                # If the window has no parent, the client session must
                # be told to create it. Otherwise, the window's parent
                # will create it during the children changed event.
                if window.parent is None:
                    content = {'window': window.snapshot()}
                    self.send(self.session_id, 'add_window', content)
                window.activate(self)

    def snapshot(self):
        """ Get a snapshot of the windows of this session.

        Returns
        -------
        result : list
            A list of snapshots representing the current windows for
            this session.

        """
        return [window.snapshot() for window in self.windows]

    def register(self, obj):
        """ Register an object with the session.

        This method is called by an Object when it is activated by a
        Session. It should never be called by user code.

        Parameters
        ----------
        obj : Object
            The object to register with the session.

        """
        self._registered_objects[obj.object_id] = obj

    def unregister(self, obj):
        """ Unregister an object from the session.

        This method is called by an Object when it is being destroyed.
        It should never be called by user code.

        Parameters
        ----------
        obj : Object
            The object to unregister from the session.

        """
        self._registered_objects.pop(obj.object_id, None)

    #--------------------------------------------------------------------------
    # Messaging API
    #--------------------------------------------------------------------------
    def send(self, object_id, action, content):
        """ Send a message to a client object.

        This method is called by the `Object` instances owned by this
        session to send messages to their client implementations.

        Parameters
        ----------
        object_id : str
            The object id of the client object.

        action : str
            The action that should be performed by the object.

        content : dict
            The content dictionary for the action.

        """
        if self.is_active:
            self.socket.send(object_id, action, content)

    def batch(self, object_id, action, content):
        """ Batch a message to be sent by the session.

        This method can be called to add a message to an internal batch
        to be sent to the client at a later time. This is useful for
        queueing messages which are related and are emitted in rapid
        succession, such as `destroy` and `children_changed`. This can
        allow the client-side to batch update the ui, avoiding flicker
        and rendering artifacts. This method should be used with care.

        Parameters
        ----------
        object_id : str
            The object id of the client object.

        action : str
            The action that should be performed by the object.

        content : dict
            The content dictionary for the action.

        """
        task = lambda: (object_id, action, content)
        self._batch.append(task)

    def batch_task(self, object_id, action, task):
        """ Similar to `batch` but takes a callable task.

        Parameters
        ----------
        object_id : str
            The object id of the client object.

        action : str
            The action that should be performed by the object.

        task : callable
            A callable which will be invoked at a later time to get
            the content of the message. The callable must return the
            content dictionary for the action.

        """
        ctask = lambda: (object_id, action, task())
        self._batch.append(ctask)

    def on_message(self, object_id, action, content):
        """ Receive a message sent to an object owned by this session.

        This is a handler method registered as the callback for the
        action socket. The message will be routed to the appropriate
        `Object` instance.

        Parameters
        ----------
        object_id : str
            The object id of the target object.

        action : str
            The action that should be performed by the object.

        content : dict
            The content dictionary for the action.

        """
        if self.is_active:
            if object_id == self.session_id:
                dispatch_action(self, action, content)
            else:
                try:
                    obj = self._registered_objects[object_id]
                except KeyError:
                    msg = "Invalid object id sent to Session: %s:%s"
                    logger.warn(msg % (object_id, action))
                    return
                else:
                    obj.receive_action(action, content)

    #--------------------------------------------------------------------------
    # Action Handlers
    #--------------------------------------------------------------------------
    def on_action_url_request(self, content):
        """ Handle the 'url_request' action from the client session.

        """
        url = content['url']
        metadata = content['metadata']
        reply = URLReply(self, content['id'], url)
        self.resource_manager.load(url, metadata, reply)


########NEW FILE########
__FILENAME__ = session_factory
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
class SessionFactory(object):
    """ A class whose instances are used by an Enaml Application to
    create Session instances.

    """
    def __init__(self, name, description, session_class, *args, **kwargs):
        """ Initialize a SessionFactory.

        Parameters
        ----------
        name : str
            A unique, human-friendly name for the Session that will be
            created.

        description : str
            A brief description of the Session that will be created.

        session_class : Session subclass
            A concrete subclass of Session that will be created by this
            factory.

        *args, **kwargs
            Optional positional and keyword arguments to pass to the
            __init__() method of the Session that gets created.

        """
        self.name = name
        self.description = description
        self.session_class = session_class
        self.args = args
        self.kwargs = kwargs

    def __call__(self):
        """ Called by the Enaml Application to create an instance of
        the Session.

        Returns
        -------
        result : Session
            A new instance of the Session type provided to the factory.

        """
        return self.session_class(*self.args, **self.kwargs)


########NEW FILE########
__FILENAME__ = signaling
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from types import MethodType
from weakref import ref

from .callableref import CallableRef
from .weakmethod import WeakMethod


#: The key used to store the signals in an object's __dict__
_SIGNALS_KEY = '_[signals]'


class Signal(object):
    """ A descriptor which provides notification functionality similar
    to Qt signals and slots.

    A Signal is used by creating an instance in the body of a class
    definition. Slots (callables) are connected to the signal through
    the `connect` and `disconnect` methods. A signal can be emitted by
    calling the `emit` method passing arbitrary positional and keyword
    arguments.

    If a bound method is connected to a signal, then that slot will be
    automatically disconnected when the underlying object instance is
    garbage collected.

    """
    __slots__ = ()

    @staticmethod
    def disconnect_all(obj):
        """ Disconnect all slots connected to all signals on an object.

        Parameters
        ----------
        obj : object
            An object which has signals. Any slots connected to signals
            on this object will be disconnected.

        """
        dct = obj.__dict__
        key = _SIGNALS_KEY
        if key in dct:
            del dct[key]

    def __get__(self, obj, cls):
        """ The data descriptor getter.

        Returns
        -------
        result : Signal or BoundSignal
            If the descriptor is accessed through the class, then this
            Signal will be returned. Otherwise, a BoundSignal for the
            object will be returned.

        """
        if obj is None:
            return self
        return BoundSignal(self, ref(obj))

    def __set__(self, obj, val):
        """ The data descriptor setter.

        Attempting to assign to a Signal will raise an AttributeError.

        """
        raise AttributeError("can't set read only Signal")

    def __delete__(self, obj):
        """ The data descriptor deleter.

        This will disconnect all slots connected to this signal owned
        by the given object.

        """
        dct = obj.__dict__
        key = _SIGNALS_KEY
        if key not in dct:
            return
        signals = dct[key]
        if self not in signals:
            return
        del signals[self]
        if len(signals) == 0:
            del dct[key]


class _Disconnector(object):
    """ An object which disconnects a slot from a signal when the slot
    is garbage collected.

    This class is a private implementation detail of signaling and is
    not meant for public consumption.

    """
    __slots__ = ('_signal', '_objref')

    def __init__(self, signal, objref):
        """ Initialize a _Disconnector.

        Parameters
        ----------
        signal : Signal
            The Signal instance associated with this disconnector.

        objref : weakref
            A weak reference to the object which owns the signal.

        """
        self._signal = signal
        self._objref = objref

    def __call__(self, slot):
        """ Disconnect the slot from the signal.

        Parameters
        ----------
        slot : callable
            The slot to be disconnected from the signal.

        """
        obj = self._objref()
        if obj is None:
            return
        key = _SIGNALS_KEY
        dct = obj.__dict__
        if key not in dct:
            return
        signals = dct[key]
        signal = self._signal
        if signal not in signals:
            return
        slots = signals[signal]
        try:
            slots.remove(slot)
        except ValueError:
            pass
        else:
            # A _Disconnector is the first item in the list and is
            # created on demand. The list is deleted when that is the
            # only item remaining.
            if len(slots) == 1:
                del signals[signal]
                if len(signals) == 0:
                    del dct[key]


class BoundSignal(object):
    """ A bound Signal object.

    Instances of this class are created on the fly by a Signal. This
    class performs the actual work for connecting, disconnecting, and
    emitting signals.

    """
    __slots__ = ('_signal', '_objref')

    def __init__(self, signal, objref):
        """ Initialize a BoundSignal.

        Parameters
        ----------
        signal : Signal
            The Signal instance which created this BoundSignal.

        objref : weakref
            A weak reference to the object which owns the signal. The
            weakref should not have been created with a callback, as
            the internal implementation depends on the semantics of
            weakrefs created without callbacks.

        """
        self._signal = signal
        self._objref = objref

    def __eq__(self, other):
        """ Custom equality checking for a BoundSignal.

        A BoundSignal will compare equal to another BoundSignal if the
        unerlying Signal and object reference are equal. This equality
        is part of the mechanism which allows a signal to be connected
        to another signal.

        """
        if isinstance(other, BoundSignal):
            signal = self._signal
            objref = self._objref
            return signal is other._signal and objref is other._objref
        return False

    def __call__(self, *args, **kwargs):
        """ Custom call support for a BoundSignal.

        Calling a signal is indentical invoking the `emit` method. By
        making a signal callable, it is possible to directly connect
        a signal to another signal.

        Parameters
        ----------
        *args, **kwargs
            The positional and keyword arguments to pass to the slots
            connected to the signal.

        """
        self.emit(*args, **kwargs)

    #--------------------------------------------------------------------------
    # Public API
    #--------------------------------------------------------------------------
    def emit(self, *args, **kwargs):
        """ Emit the signal with the given arguments and keywords.

        If a connected slot raises an exceptions, no further slots will
        be invoked and the exception will be bubbled up.

        Parameters
        ----------
        *args, **kwargs
            The positional and keyword arguments to pass to the slots
            connected to the signal.

        """
        obj = self._objref()
        if obj is None:
            return
        dct = obj.__dict__
        key = _SIGNALS_KEY
        if key not in dct:
            return
        signals = dct[key]
        signal = self._signal
        if signal not in signals:
            return
        # Make a copy of the list of slots since calling a slot has the
        # potential to modify the slots list. The first item in the list
        # is skipped since it is the disconnector for the signal. Putting
        # the disconnector in the list saves time and space.
        slots = signals[signal][1:]
        for slot in slots:
            slot(*args, **kwargs)

    def connect(self, slot):
        """ Connect the given slot to the signal.

        The slot will be called when the signal is emitted. It will be
        passed any positional and keyword arguments that were emitted
        with the signal. Multiple slots connected to a signal will be
        invoked in the order in which they were connected. Slots which
        are instance methods will be automatically disconnected when
        their underlying instance is garbage collected.

        Parameters
        ----------
        slot : callable
            The callable slot to invoke when the signal is emitted.

        """
        obj = self._objref()
        if obj is None:
            return
        dct = obj.__dict__
        key = _SIGNALS_KEY
        if key in dct:
            signals = dct[key]
        else:
            signals = dct[key] = {}
        signal = self._signal
        if signal in signals:
            slots = signals[signal]
            d = slots[0]
        else:
            d = _Disconnector(signal, self._objref)
            slots = signals[signal] = [d]
        if isinstance(slot, MethodType) and slot.im_self is not None:
            slot = CallableRef(WeakMethod(slot), d)
        slots.append(slot)

    def disconnect(self, slot):
        """ Disconnect the slot from the signal.

        If the slot was not previously connected, this is a no-op.

        Parameters
        ----------
        slot : callable
            The callable slot to disconnect from the signal.

        """
        if isinstance(slot, MethodType) and slot.im_self is not None:
            slot = CallableRef(WeakMethod(slot))
        _Disconnector(self._signal, self._objref)(slot)


# Use the faster version of signaling if it's available.
try:
    from enaml.extensions.signaling import Signal, BoundSignal, _Disconnector
except ImportError:
    pass


########NEW FILE########
__FILENAME__ = socket_interface
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from abc import ABCMeta, abstractmethod


class ActionSocketInterface(object):
    """ An abstract base class defining an action socket interface.

    Concrete implementations of this interface can be used by Session
    instances to send and recieve messages to and from their client
    objects.

    """
    __metaclass__ = ABCMeta

    @abstractmethod
    def on_message(self, callback):
        """ Register a callback for receiving messages sent by a
        client object.

        Parameters
        ----------
        callback : callable
            A callable with an argument signature that is equivalent to
            the `send` method. If the callback is a bound method, then
            the lifetime of the callback will be bound to lifetime of
            the method owner object.

        """
        raise NotImplementedError

    @abstractmethod
    def send(self, object_id, action, content):
        """ Send an action to the client of an object.

        Parameters
        ----------
        object_id : str
            The object id for the Object sending the message.

        action : str
            The action that should be take by the client object.

        content : dict
            The dictionary of content needed to perform the action.

        """
        raise NotImplementedError


########NEW FILE########
__FILENAME__ = flat_file_system_model
#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from collections import namedtuple
from functools import wraps
from os import listdir
from os.path import abspath, isabs, normpath, join, isdir, pardir
import re

from enaml.core.item_model import AbstractListModel, ModelIndex, ALIGN_LEFT, ALIGN_VCENTER


# A named tuple which holds the relative path of an item in the 
# current working directory of the model, and whether or not that 
# item is a directory.
_FlatRecord = namedtuple('_FlatRecord', 'is_dir rel_path')


def _reset_model(func):
    """ A method decorator which will reset an abstract item model.

    """
    @wraps(func)
    def closure(self, *args, **kwargs):
        self.begin_reset_model()
        res = func(self, *args, **kwargs)
        self.end_reset_model()
        return res
    return closure


def _refresh_data(func):
    """ A method decorator which will trigger a refresh of all data in 
    a list model. This assumes that the data in the list model is in 
    the zero column.

    """
    @wraps(func)
    def closure(self, *args, **kwargs):
        parent = None
        top_left = self.index(0, 0, parent)
        bottom_right = self.index(self.row_count(parent) - 1, 0, parent)
        res = func(self, *args, **kwargs)
        self.notify_data_changed(top_left, bottom_right)
        return res
    return closure


class FlatFileSystemModel(AbstractListModel):
    """ A concrete list model implementation which navigates a mounted
    filesystem one directory at a time.

    """
    def __init__(
        self, directory='.', show_hidden=False, file_pattern=r'.*', 
        dir_icon=None, file_icon=None):
        """ Initialize a FlatFilesystemModel.

        Parameters
        ----------
        directory : string, optional
            The path to the working directory. Defaults to the current
            working directory.

        show_hidden : bool, optional
            Whether or not to show hidden files. Defaults to False.

        file_pattern : string, optional
            A regex pattern which will be compiled and matched against 
            the file names in a directory. Only files which match the 
            pattern will be accepted. Matching is performed in a case 
            insensitive fashion. The default pattern matches everything. 
            More controlled filtering may be obtained by overriding the 
            filter_dir and filter_file methods.

        dir_icon : Icon, optional
            An optional icon to display next to directory names.

        file_icon : Icon, optional
            An optional icon to display next to file name.

        """
        self._cwd = abspath(normpath(directory))
        self._show_hidden = show_hidden
        self._file_pattern = file_pattern
        self._file_pattern_rgx = re.compile(file_pattern, re.IGNORECASE)
        self._dir_icon = dir_icon
        self._file_icon = file_icon
        self._contents = []
        self._loadcwd()

    #--------------------------------------------------------------------------
    # AbstractListModel Implementation Methods
    #--------------------------------------------------------------------------
    def row_count(self, parent):
        """ Returns the number of rows in the model, which is equal to 
        the number of items in the current directory.

        """
        if parent is not None:
            return 0
        return len(self._contents)

    def data(self, index):
        """ Returns the display data for the given row, which is the 
        relative path for that item in the current directory.

        """
        return self._contents[index.row].rel_path

    def alignment(self, index):
        """ Returns the alignment for the given row. By default, items
        align to the left and vertically centered.

        """
        return ALIGN_LEFT | ALIGN_VCENTER
    
    def decoration(self, index):
        """ Returns the appropriate file or directory icon for the 
        given index.

        """
        if self.isdir(index):
            return self._dir_icon
        return self._file_icon

    #--------------------------------------------------------------------------
    # Private Methods
    #--------------------------------------------------------------------------
    def _loadcwd(self):
        """ Loads the contents of the current working directory.

        Parameters
        ----------
        directory : string
            The directory for which to retrieve items.

        Returns
        -------
        result : list of 2-tuples
            A list of 2-tuples of the form (bool, string) where the 
            boolean indicates whether the item is a directory and 
            the string is the relative path to the item.

        """
        contents = self._contents = []
        push = contents.append
        cwd = self._cwd
        filter_dir = self.filter_dir
        filter_file = self.filter_file
        rcd = _FlatRecord

        # The first item in a directory is always the relative path to
        # the parent directory. This allows for simple navigation 
        # through the filesystem. But we may want to update it in the
        # future to use something like a breadcrumbs widget.
        push(rcd(True, pardir))
        for item in listdir(cwd):
            if isdir(join(cwd, item)):
                if filter_dir(item):
                    push(rcd(True, item))
            else:
                if filter_file(item):
                    push(rcd(False, item))

    #--------------------------------------------------------------------------
    # Public Properties
    #--------------------------------------------------------------------------
    def _get_show_hidden(self):
        """ Returns whether or not hidden directories and files are
        shown.

        """
        return self._show_hidden

    @_reset_model
    def _set_show_hidden(self, show):
        """ Set whether or not hidden directories and files are shown.

        """
        self._show_hidden = show
        self._loadcwd()

    show_hidden = property(_get_show_hidden, _set_show_hidden)

    def _get_file_pattern(self):
        """ Return the current file pattern in use by the model.

        """
        return self._file_pattern

    @_reset_model
    def _set_file_pattern(self, file_pattern):
        """ Set the pattern to be used by the model.

        """
        self._file_pattern = file_pattern
        self._file_pattern_rgx = re.compile(file_pattern, re.IGNORECASE)
        self._loadcwd()

    file_pattern = property(_get_file_pattern, _set_file_pattern)

    def _get_dir_icon(self):
        """ Return the directory icon in use by the model.

        """
        return self._dir_icon

    @_refresh_data
    def _set_dir_icon(self, icon):
        """ Set the directory icon in use by the model.

        """
        self._dir_icon = icon

    dir_icon = property(_get_dir_icon, _set_dir_icon)

    def _get_file_icon(self):
        """ Return the file icon in use by the model.

        """
        return self._file_icon

    @_refresh_data
    def _set_file_icon(self, icon):
        """ Set the file icon in use by the model.

        """
        self._file_icon = icon

    file_icon = property(_get_file_icon, _set_file_icon)

    #--------------------------------------------------------------------------
    # Public Methods
    #--------------------------------------------------------------------------
    def getcwd(self):
        """ Returns the current working directory.

        """
        return self._cwd

    @_reset_model
    def chdir(self, directory):
        """ Sets the current working directory and refresh the model.

        Parameters
        ----------
        directory : string or ModelIndex
            A relative or absolute path to a directory, or a model index
            pointing to a directory in the current working directory.

        """
        if isinstance(directory, ModelIndex):
            directory = self._contents[directory.row].rel_path
        if not isabs(directory):
            directory = join(self._cwd, directory)
        self._cwd = abspath(normpath(directory))
        self._loadcwd()

    def isdir(self, index):
        """ Returns whether or not the item at the given index is a 
        directory.

        Calling os.path.isdir is an expensive system call, which is
        therefore only done once when loading a new directory. Using
        this method when needing to query for directory status will
        save time.

        Parameters
        ----------
        index : ModelIndex
            The model index for the associated item.

        Returns
        -------
        result : bool
            True if the model index points to a directory. False 
            otherwise.

        """
        return self._contents[index.row].is_dir

    def abspath(self, index):
        """ Return the absolute path to the item at the given index.

        Parameters
        ----------
        index : ModelIndex
            The model index for the associated item.

        Returns
        -------
        result : string
            The absolute path to the item pointed to by the index.

        """
        return join(self._cwd, self._contents[index.row].rel_path)

    def filter_dir(self, directory):
        """ Returns whether or not to include the given directory in the 
        results for the current directory.

        The default implementation filters based on whether or not the
        directory is hidden (according the model flag).

        Parameters
        ----------
        directory : string
            The directory which should be tested for inclusion.

        Returns
        -------
        result : bool
            True if the directory should be included, False otherwise.

        """
        if not self._show_hidden and directory.startswith('.'):
            return False
        return True

    def filter_file(self, item):
        """ Returns whether or not to include the given item in the 
        results for the current directory.

        The default implementation filters based on whether or not the
        item is hidden (according the model flag) and whether or not it 
        matches the provided pattern.

        Parameters
        ----------
        items : string
            The items which should be tested for inclusion.

        Returns
        -------
        result : bool
            True if the item should be included, False otherwise.

        """
        if not self._show_hidden and item.startswith('.'):
            return False
        return bool(self._file_pattern_rgx.match(item))


########NEW FILE########
__FILENAME__ = item_model
#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from abc import ABCMeta, abstractmethod

from .signaling import Signal


#------------------------------------------------------------------------------
# The various AbstractItemModel flags
#------------------------------------------------------------------------------
# Item flags (these are the same values as Qt's flags so we don't
# have to do a map lookup for Qt).
NO_ITEM_FLAGS = 0x0         # The item has no state flags
ITEM_IS_SELECTABLE = 0x1    # The item can be selected in a view.
ITEM_IS_EDITABLE = 0x2      # The item can be edited in a view.
ITEM_IS_DRAG_ENABLED = 0x4  # The item can be dragged.
ITEM_IS_DROP_ENABLED = 0x8  # Another item can be dropped onto this one.
ITEM_IS_CHECKABLE = 0x10    # The item's "checked" state can be changed from a view.
ITEM_IS_ENABLED = 0x20      # This item permits user interaction in a view.
ITEM_IS_TRISTATE = 0x40     # The item is checkable, and it has three distinct states.


# Alignment flags (these are the same values as Qt's flags so we don't
# have to do a map lookup for Qt).
ALIGN_LEFT = 0x1
ALIGN_RIGHT = 0x2
ALIGN_HCENTER = 0x4
ALIGN_JUSTIFY = 0x8
ALIGN_TOP = 0x20
ALIGN_BOTTOM = 0x40
ALIGN_VCENTER = 0x80
ALIGN_CENTER = ALIGN_HCENTER | ALIGN_VCENTER


#------------------------------------------------------------------------------
# AbstractItemModel
#------------------------------------------------------------------------------
class AbstractItemModel(object):
    """ An abstract model for supplying information to heierarchical
    widgets.

    """
    __metaclass__ = ABCMeta

    #: Fired by the begin_insert_columns method
    columns_about_to_be_inserted = Signal()

    #: Fired by the begin_move_columns method
    columns_about_to_be_moved = Signal()

    #: Fired by the begin_remove_columns method
    columns_about_to_be_removed = Signal()

    #: Fired by the end_insert_columns method
    columns_inserted = Signal()

    #: Fired by the end_move_columns method
    columns_moved = Signal()

    #: Fired by the end_remove_rows method
    columns_removed = Signal()

    #: Fired by the begin_insert_rows method
    rows_about_to_be_inserted = Signal()

    #: Fired by the begin_move_rows method
    rows_about_to_be_moved = Signal()

    #: Fired by the begin_remove_columns method
    rows_about_to_be_removed = Signal()

    #: Fired by the end_insert_rows method
    rows_inserted = Signal()

    #: Fired by the end_move_rows method
    rows_moved = Signal()

    #: Fired by the end_remove_rows method
    rows_removed = Signal()

    #: Fired by the begin_change_layout method
    layout_about_to_be_changed = Signal()

    #: Fired by the end_change_layout method
    layout_changed = Signal()

    #: Fired by the begin_reset_model method
    model_about_to_be_reset = Signal()

    #: Fired by the end_reset_model method
    model_reset = Signal()

    #: Fired by the notify_data_changed method
    data_changed = Signal()
    
    #: Fired by the notify_horizontal_header_data_changed method
    horizontal_header_data_changed = Signal()

    #: Fired by the notify_vertical_header_data_changed method
    vertical_header_data_changed = Signal()
    
    #--------------------------------------------------------------------------
    # Model change notification trigger methods 
    #--------------------------------------------------------------------------
    def begin_insert_columns(self, parent, first, last):
        """ Begins inserting a column.

        This method must be called before inserting data into
        the model.

        Arguments
        ---------
        parent : ModelIndex
            The parent into which the new columns will be inserted.

        first : int
            The column position at which insertion will begin.

        last : int
            The column position at which insertion will end.

        """
        evt_arg = (parent, first, last)
        self.columns_about_to_be_inserted(evt_arg)

    def begin_move_columns(self, src_parent, src_first, src_last, dst_parent, dst_child):
        """ Begins to move a column.

        Arguments
        ---------
        src_parent : ModelIndex
            The item from which columns will be moved.

        src_first : int
            The number of the first column to be moved.

        src_last : int
            The number of the last column to be moved.

        dst_parent : ModelIndex
            The item into which the columns will be moved.

        dst_child : int
            The column number to which the columns will be moved.

        """
        evt_arg = (src_parent, src_first, src_last, dst_parent, dst_child)
        self.columns_about_to_be_moved(evt_arg)

    def begin_remove_columns(self, parent, first, last):
        """ Begins to remove columns.

        This method must be called before removing data from the
        model.

        Arguments
        ---------
        parent : ModelIndex
            The item from which the columns will be removed.

        first : int
            The number of the first column to remove.

        last : int
            The number of the last column to remove.

        """
        evt_arg = (parent, first, last)
        self.columns_about_to_be_removed(evt_arg)

    def end_insert_columns(self, parent, first, last):
        """ Finish inserting columns.

        This method must be called after inserting data into
        the model.

        Arguments
        ---------
        parent : ModelIndex
            The parent into which the new columns will be inserted.

        first : int
            The column position at which insertion will begin.

        last : int
            The column position at which insertion will end.

        """
        evt_arg = (parent, first, last)
        self.columns_inserted(evt_arg)

    def end_move_columns(self, src_parent, src_first, src_last, dst_parent, dst_child):
        """ Finish moving columns.

        This method must be called after moving data in a model.

        Arguments
        ---------
        src_parent : ModelIndex
            The item from which columns will be moved.

        src_first : int
            The number of the first column to be moved.

        src_last : int
            The number of the last column to be moved.

        dst_parent : ModelIndex
            The item into which the columns will be moved.

        dst_child : int
            The column number to which the columns will be moved.

        """
        evt_arg = (src_parent, src_first, src_last, dst_parent, dst_child)
        self.columns_moved(evt_arg)

    def end_remove_columns(self, parent, first, last):
        """ Finish removing columns.

        This method must be called after removing data from a model.

        Arguments
        ---------
        parent : ModelIndex
            The item from which the columns will be removed.

        first : int
            The number of the first column to remove.

        last : int
            The number of the last column to remove.

        """
        evt_arg = (parent, first, last)
        self.columns_removed(evt_arg)

    def begin_insert_rows(self, parent, first, last):
        """ Begins a row insertion.

        This method must be called before inserting data into
        the model.

        Arguments
        ---------
        parent : ModelIndex
            The item into which the new rows will be inserted.

        first : int
            The row position at which insertion will begin.

        last : int
            The row position at which insertion will end.

        """
        evt_arg = (parent, first, last)
        self.rows_about_to_be_inserted(evt_arg)

    def begin_move_rows(self, src_parent, src_first, src_last,
                        dst_parent, dst_child):
        """ Begins to move a row.

        Arguments
        ---------
        src_parent : ModelIndex
            The item from which rows will be moved.

        src_first : int
            The number of the first row to be moved.

        src_last : int
            The number of the last row to be moved.

        dst_parent : ModelIndex
            The item into which the rows will be moved.

        dst_child : int
            The row number to which the rows will be moved.

        """
        evt_arg = (src_parent, src_first, src_last, dst_parent, dst_child)
        self.rows_about_to_be_moved(evt_arg)

    def begin_remove_rows(self, parent, first, last):
        """ Begins to remove rows.

        This method must be called before removing data from the
        model.

        Arguments
        ---------
        parent : ModelIndex
            The item from which the rows will be removed.

        first : int
            The number of the first row to remove.

        last : int
            The number of the last row to remove.

        """
        evt_arg = (parent, first, last)
        self.rows_about_to_be_removed(evt_arg)

    def end_insert_rows(self, parent, first, last):
        """ Finish inserting rows.

        This method must be called after inserting data into
        the model.

        Arguments
        ---------
        parent : ModelIndex
            The item into which the new rows will be inserted.

        first : int
            The row position at which insertion will begin.

        last : int
            The row position at which insertion will end.

        """
        evt_arg = (parent, first, last)
        self.rows_inserted(evt_arg)

    def end_move_rows(self, src_parent, src_first, src_last, dst_parent, dst_child):
        """ Finish moving rows

        This method must be called after moving data in a model.

        Arguments
        ---------
        src_parent : ModelIndex
            The item from which rows will be moved.

        src_first : int
            The number of the first row to be moved.

        src_last : int
            The number of the last row to be moved.

        dst_parent : ModelIndex
            The item into which the rows will be moved.

        dst_child : int
            The row number to which the rows will be moved.

        """
        evt_arg = (src_parent, src_first, src_last, dst_parent, dst_child)
        self.rows_moved(evt_arg)

    def end_remove_rows(self, parent, first, last):
        """ Finish removing rows.

        This method must be called after moving data in a model.

        Arguments
        ---------
        parent : ModelIndex
            The item from which the rows will be removed.

        first : int
            The number of the first row to remove.

        last : int
            The number of the last row to remove.

        """
        evt_arg = (parent, first, last)
        self.rows_removed(evt_arg)

    def begin_change_layout(self):
        """ Begin a change to the layout of the model -- e.g., sort it.

        This method must be called before rearranging data in a model.

        """
        self.layout_about_to_be_changed()

    def end_change_layout(self):
        """ Finish a change to the layout of the model.

        This method must be called after rearranging data in a model.

        """
        self.layout_changed()

    def begin_reset_model(self):
        """ Begin to reset a model.

        Model indices must be recomputed, and any associated views will 
        also be reset.

        This method must be called before a model is reset.

        """
        self.model_about_to_be_reset()

    def end_reset_model(self):
        """ Finish resetting a model.

        This method must be called after a model is reset.

        """
        self.model_reset()

    def notify_data_changed(self, top_left, bottom_right):
        """ Create a notification event for the model data has changed.

        Arguments
        ---------
        top_left : ModelIndex
            The upper-left boundary of the changed items.

        bottom_right : ModelIndex
            The bottom-right boundary of the changed items.

        """
        self.data_changed((top_left, bottom_right))

    def notify_horizontal_header_data_changed(self, first, last):
        """ Create a notification that model horizontal header data 
        has changed.

        Arguments
        ---------
        first : int
            The first horizontal/column header that has been modified.

        last : int
            The last horizontal/column header that has been modified.

        """
        self.horizontal_header_data_changed((first, last))

    def notify_vertical_header_data_changed(self, first, last):
        """ Create a notification that model vertical header data 
        has changed.

        Arguments
        ---------
        first : int
            The first vertical/row header that has been modified.

        last : int
            The last vertical/row header that has been modified.

        """
        self.vertical_header_data_changed((first, last))

    #--------------------------------------------------------------------------
    # Misc methods 
    #--------------------------------------------------------------------------
    def sibling(self, row, column, index):
        """ Obtain an item with the same parent as `index`.

        Arguments
        ---------
        row : int
            The row of the new item.

        column : int
            The column of the new item.

        index : ModelIndex
            An item for which to find a "sibling".

        Returns
        -------
        index : ModelIndex
            An element with the same parent as the specified item.

        """
        return self.index(row, column, self.parent(index))

    def buddy(self, index):
        """ Refers the caller to an item in the model to edit.

        Each item is its own buddy by default, but this is not required.

        Arguments
        ---------
        index : ModelIndex
            The model index for which the buddy index should be 
            returned for editing.

        Returns
        -------
        buddy : ModelIndex
            The item that should be edited.

        """
        return index

    def can_fetch_more(self, parent=None):
        """ Returns `True` if items of `parent` can provide more data.

        Arguments
        ---------
        parent : ModelIndex or None
            A model index, possibly with more data that can be fetched.

        Returns
        -------
        has_more : bool
            True if more data is available, False otherwise.

        """
        return False

    def fetch_more(self, parent=None):
        """ Obtain data from model items, if more is available.

        This method is useful when incrementally adding data to a model.

        Arguments
        ---------
        parent : ModelIndex or None
            An index to query.

        Returns
        -------
        data : AbstractItemModel
            Data that has yet to be received.

        """
        pass

    def has_index(self, row, column, parent=None):
        """ Determine whether this model can provide a valid index with
        certain specifications.

        Arguments
        ---------
        row : int
            A row to be used in the index.

        column : int
            A column to be used in the index.

        parent : ModelIndex or None
            A parent on which to base the new model index.

        Returns
        -------
        result : bool
            True if the inputs produce a valid index, False otherwise.

        """
        if row < 0 or column < 0:
            return False
        return row < self.row_count(parent) and column < self.column_count(parent)

    def has_children(self, parent=None):
        """ Determines if an index has any child items.

        Arguments
        ---------
        parent : ModelIndex or None
            A model index to check for children.

        Returns
        -------
        result : bool
            True if the index has children, False otherwise.

        """
        return self.row_count(parent) > 0 and self.column_count(parent) > 0

    def create_index(self, row, column, context):
        """ Create a new index into this model.

        Arguments
        ---------
        row : int
            A row to specify the index

        column : int
            A column to specify the index.

        context : object
            A value that can be useful when working with a model.

        Returns
        -------
        index : ModelIndex
            A new index into this model.

        """
        return ModelIndex(row, column, context, self)

    def flags(self, index):
        """ Obtain the flags that specify user interaction with items.

        Arguments
        ---------
        index : ModelIndex
            Items to query.

        Returns
        -------
        item_flags : tuple of strings
            The ways in which a view can interact with the items.

        """
        return ITEM_IS_SELECTABLE | ITEM_IS_ENABLED

    #--------------------------------------------------------------------------
    # Abstract Methods
    #--------------------------------------------------------------------------
    @abstractmethod
    def column_count(self, parent=None):
        """ Count the number of columns in the children of an item.

        Arguments
        ---------
        parent : ModelIndex or None
            A model item with children.

        Returns
        -------
        count : int
            The number of columns in the model.

        """
        raise NotImplementedError

    @abstractmethod
    def row_count(self, parent=None):
        """ Count the number of rows in the children of an item.

        Arguments
        ---------
        parent : ModelIndex or None
            A model item with children.

        Returns
        -------
        count : int
            The number of rows in the model.

        """
        raise NotImplementedError

    @abstractmethod
    def index(self, row, column, parent=None):
        """ Obtain an index coresponding to an item in the model.

        Arguments
        ---------
        row : int
            The sought-after item's row.

        column : int
            The sought-after item's column.

        parent : ModelIndex or None
            The parent item that is the base of this index.

        Returns
        -------
        item : ModelIndex or None
            An index for the specified item.

        """
        raise NotImplementedError

    @abstractmethod
    def parent(self, index):
        """ Obtain the parent of a model item.

        Arguments
        ---------
        index : ModelIndex
            A model item, possibly with a valid parent.

        Returns
        -------
        index : ModelIndex
            An index for the parent item.

        """
        raise NotImplementedError


    @abstractmethod
    def data(self, index):
        """ Get the data for a model index as a string for display.

        Arguments
        ---------
        index : ModelIndex
            The model index for which to return the data.

        Returns
        -------
        value : string
            The data as a string for display.

        """
        raise NotImplementedError

    #--------------------------------------------------------------------------
    # Auxiliary Data Methods
    #--------------------------------------------------------------------------
    def decoration(self, index):
        """ Return an icon for the index

        The default implementation returns None.

        Arguments
        ---------
        index : ModelIndex
            The model index for which to return the icon.

        Returns
        -------
        value : icon??
            The icon to display for the cell.

        """
        # XXX Handle Icons !!!
        return None
    
    def edit_data(self, index):
        """ Get the data for a model index as a string for editing.

        The default implementation returns 'data(index)'.

        Arguments
        ---------
        index : ModelIndex
            The model index for which to return the data.

        Returns
        -------
        value : string
            The data as a string for editing.

        """
        return self.data(index)
    
    def tool_tip(self, index):
        """ Get the tool tip string for a given model index.

        The default implementation returns None.

        Arguments
        ---------
        index : ModelIndex
            The model index for which to return the tool tip.

        Returns
        -------
        value : string
            The tool tip string.

        """
        return None
    
    def status_tip(self, index):
        """ Get the status tip string for a given model index.

         The default implementation returns None.

        Arguments
        ---------
        index : ModelIndex
            The model index for which to return the status tip.

        Returns
        -------
        value : string
            The status tip string.

        """
        return None

    def whats_this(self, index):
        """ Get the what's this? string for a given model index.

         The default implementation returns None.

        Arguments
        ---------
        index : ModelIndex
            The model index for which to return the what's this? string.

        Returns
        -------
        value : string
            The what's this? string.

        """
        return None
    
    def font(self, index):
        """ Get the font for a given model index.

        The default implementation returns None.

        Arguments
        ---------
        index : ModelIndex
            The model index for which to return the font.

        Returns
        -------
        value : Font
            The font to use for this model index.

        """
        return None
    
    def alignment(self, index):
        """ Get the alignment of the text for a given model index.

        The default implementation returns ALIGN_VCENTER | ALIGN_RIGHT

        Arguments
        ---------
        index : ModelIndex
            The model index for which to return the alignment.

        Returns
        -------
        value : int
            The OR'd alignment flags to use for the given model index.

        """
        return ALIGN_VCENTER | ALIGN_RIGHT
    
    def background(self, index):
        """ The background brush to use for the given index.

        The default implementation returns None.

        Arguments
        ---------
        index : ModelIndex
            The model index for which to return the brush.

        Returns
        -------
        value : Brush
            The brush to use for the given model index.

        """
        return None
    
    def foreground(self, index):
        """ The foreground brush to use for the given index.

        The default implementation returns None.

        Arguments
        ---------
        index : ModelIndex
            The model index for which to return the brush.

        Returns
        -------
        value : Brush
            The brush to use for the given model index.

        """
        return None
    
    def check_state(self, index):
        """ Get the check state for the given index.

        The default implementation returns None.

        Arguments
        ---------
        index : ModelIndex
            The model index for which to return the check state.

        Returns
        -------
        value : string
            The check state to use for the given model index.

        """
        return None
    
    def size_hint(self, index):
        """ Get the (width, height) size hint for the given index.

        The default implementation returns None.

        Arguments
        ---------
        index : ModelIndex
            The model index for which to return the size hint.

        Returns
        -------
        value : (width, height)
            The size hint to use for the given model index.

        """
        return None

    #--------------------------------------------------------------------------
    # Data Setter Methods
    #--------------------------------------------------------------------------
    def set_data(self, index, value):
        """ Update a model item's data. The default implementation does
        nothing and returns False.

        Implementations that allow editing must set the 'editable' flag
        to True, and call notify_data_changed(...) explicity in order
        for the table to update.

        Arguments
        ---------
        index : ModelIndex
            The model index for the item to update.

        value : object
            The user supplied value to set in the model.

        Returns
        -------
        success : bool
            True if the data was successfully set, False otherwise.

        """
        return False
    
    def set_check_state(self, index, value):
        """ Update a model item's check state. The default implementation 
        does nothing and returns False.

        Implementations that allow editing must set the 'editable' flag
        to True, and call notify_data_changed(...) explicity in order
        for the table to update.

        Arguments
        ---------
        index : ModelIndex
            The model index for the item to update.

        value : object
            The check state to set in the model.

        Returns
        -------
        success : bool
            True if the data was successfully set, False otherwise.

        """
        return False
    
    #--------------------------------------------------------------------------
    # Header Data Methods 
    #--------------------------------------------------------------------------
    def horizontal_header_data(self, section):
        """ Get the horizontal label for a particular header section.

        The default implementation returns the column number of the given 
        header. Subclasses should override this method to return 
        appropriate data for their model.

        Arguments
        ---------
        section : int
            The column number of the header.

        Returns
        -------
        data : string
            The requested header label

        """
        return unicode(section + 1)
    
    def vertical_header_data(self, section):
        """ Get the vertical label for a particular header section.

        The default implementation returns the row number of the given 
        header. Subclasses should override this method to return 
        appropriate data for their model.

        Arguments
        ---------
        section : int
            The row number of the header.

        Returns
        -------
        data : string
            The requested header label

        """
        return unicode(section + 1)

    #--------------------------------------------------------------------------
    # Header Data auxiliary methods
    #--------------------------------------------------------------------------
    def horizontal_header_decoration(self, section):
        """ Get the horizontal icon for a particular header section.

        The default implementation returns None.

        Arguments
        ---------
        section : int
            The column number of the header.

        Returns
        -------
        data : icon??
            The requested icon for the header

        """
        # XXX implement icons
        return None
    
    def vertical_header_decoration(self, section):
        """ Get the vertical icon for a particular header section.

        The default implementation returns None.

        Arguments
        ---------
        section : int
            The row number of the header.

        Returns
        -------
        data : icon??
            The requested icon for the header

        """
        # XXX implement icons
        return None

    def horizontal_header_tool_tip(self, section):
        """ Get the horizontal tool tip for a particular header section.

        The default implementation returns None.

        Arguments
        ---------
        section : int
            The column number of the header.

        Returns
        -------
        data : string
            The requested tool tip for the header

        """
        return None
    
    def vertical_header_tool_tip(self, section):
        """ Get the vertical tool tip for a particular header section.

        The default implementation returns None.

        Arguments
        ---------
        section : int
            The row number of the header.

        Returns
        -------
        data : string
            The requested tool tip for the header

        """
        return None   
    
    def horizontal_header_status_tip(self, section):
        """ Get the horizontal status tip for a particular header section.

        The default implementation returns None.

        Arguments
        ---------
        section : int
            The column number of the header.

        Returns
        -------
        data : string
            The requested status tip for the header

        """
        return None
    
    def vertical_header_status_tip(self, section):
        """ Get the vertical status tip for a particular header section.

        The default implementation returns None.

        Arguments
        ---------
        section : int
            The row number of the header.

        Returns
        -------
        data : string
            The requested status tip for the header

        """
        return None 
        
    def horizontal_header_whats_this(self, section):
        """ Get the horizontal whats this for a particular header section.

        The default implementation returns None.

        Arguments
        ---------
        section : int
            The column number of the header.

        Returns
        -------
        data : string
            The requested what's this? for the header

        """
        return None
    
    def vertical_header_whats_this(self, section):
        """ Get the vertical whats this for a particular header section.

        The default implementation returns None.

        Arguments
        ---------
        section : int
            The row number of the header.

        Returns
        -------
        data : string
            The requested what's this? for the header

        """
        return None 
    
    def horizontal_header_font(self, section):
        """ Get the horizontal font for a particular header section.

        The default implementation returns None.

        Arguments
        ---------
        section : int
            The column number of the header.

        Returns
        -------
        data : Font()
            The requested font for the header

        """
        return None
    
    def vertical_header_font(self, section):
        """ Get the vertical font for a particular header section.

        The default implementation returns None.

        Arguments
        ---------
        section : int
            The row number of the header.

        Returns
        -------
        data : Font()
            The requested font for the header

        """
        return None 

    def horizontal_header_alignment(self, section):
        """ Get the horizontal whats this for a particular header section.

        The default implementation returns ALIGN_CENTER.

        Arguments
        ---------
        section : int
            The column number of the header.

        Returns
        -------
        data : int
            The OR'd alignment flags for the header

        """
        return ALIGN_CENTER
    
    def vertical_header_alignment(self, section):
        """ Get the vertical whats this for a particular header section.

        The default implementation returns ALIGN_CENTER

        Arguments
        ---------
        section : int
            The row number of the header.

        Returns
        -------
        data : int
            The OR'd alignment flags for the header

        """
        return ALIGN_CENTER
    
    def horizontal_header_background(self, section):
        """ Get the horizontal background brush for a particular 
        header section.

        The default implementation returns None.

        Arguments
        ---------
        section : int
            The column number of the header.

        Returns
        -------
        data : Brush()
            The requested brush for the header

        """
        return None
    
    def vertical_header_background(self, section):
        """ Get the vertical background brush for a particular
        header section.

        The default implementation returns None.

        Arguments
        ---------
        section : int
            The row number of the header.

        Returns
        -------
        data : Brush()
            The requested brush for the header

        """
        return None 

    def horizontal_header_foreground(self, section):
        """ Get the horizontal foreground brush for a particular 
        header section.

        The default implementation returns None.

        Arguments
        ---------
        section : int
            The column number of the header.

        Returns
        -------
        data : Brush()
            The requested brush for the header

        """
        return None
    
    def vertical_header_foreground(self, section):
        """ Get the vertical foreground brush for a particular
        header section.

        The default implementation returns None.

        Arguments
        ---------
        section : int
            The row number of the header.

        Returns
        -------
        data : Brush()
            The requested brush for the header

        """
        return None

    def horizontal_header_size_hint(self, section):
        """ Get the size hint for a particular horizontal header section.

        The default implementation returns None.

        Arguments
        ---------
        section : int
            The column number of the header.

        Returns
        -------
        value : (width, height)
            The size hint to use for the given column number.

        """
        return None
    
    def vertical_header_size_hint(self, section):
        """ Get the size hint for a particular vertical header section.

        The default implementation returns None.

        Arguments
        ---------
        section : int
            The row number of the header.

        Returns
        -------
        value : (width, height)
            The size hint to use for the given row number.

        """
        return None

    #--------------------------------------------------------------------------
    # Header Data Setters
    #--------------------------------------------------------------------------
    
    # At the moment we dont have a compelling use case where we
    # need to be able to set the header data from the ui. But in 
    # the future, that functionality will be added here.


#------------------------------------------------------------------------------
# AbstractTableModel
#------------------------------------------------------------------------------
class AbstractTableModel(AbstractItemModel):
    """ An AbstractItemModel subclass that implements the methods 
    necessary to restrict the model to a 2-dimensional table of data.

    """
    def index(self, row, column, parent=None):
        """ Abstract method implementation that will create a valid
        model index for the given row and column if they are valid.
        Otherwise, returns an invalid index.

        """
        if self.has_index(row, column, parent):
            return self.create_index(row, column, None)

    def parent(self, index):
        """ Abstract method implementation that always returns None, 
        forcing the model to be flat.

        """
        return None

    def has_children(self, parent):
        """ Overridden parent class method which restrics the model to
        2-dimensions.

        """
        if parent is None or parent.model is self:
            return self.row_count(parent) > 0 and self.column_count(parent) > 0
        return False


#------------------------------------------------------------------------------
# AbstractListModel
#------------------------------------------------------------------------------
class AbstractListModel(AbstractItemModel):
    """ An AbstractItemModel subclass that implements the methods 
    necessary to restrict the model to a 1-dimensional list of data.

    """
    def index(self, row, column, parent=None):
        """ Abstract method implementation that will create a valid
        model index for the given row and column if they are valid.
        Otherwise, returns an invalid index.

        """
        if self.has_index(row, column, parent):
            return self.create_index(row, column, None)

    def parent(self, index):
        """ Abstract method implementation that always returns an
        invalid index, forcing the model to be flat.

        """
        return None

    def column_count(self, parent=None):
        """ Overridden parent class method which restricts the model
        to a single column.

        """
        if parent is not None:
            return 0
        return 1

    def has_children(self, parent=None):
        """ Overridden parent class method which restrics the model
        to 1-dimension.

        """
        if parent is not None:
            return False
        return self.row_count() > 0


#------------------------------------------------------------------------------
# Model Index
#------------------------------------------------------------------------------
class ModelIndex(tuple):
    """ ModelIndexes are used to navigate an AbstractItemModel.

    A ModelIndex is a lightweight object and should be created on the
    fly, rather than attempting some form of caching. The user will
    not normally need to create indexes manually. Instead, use the
    create_index method on an AbstractItemModel.

    """
    __slots__ = ()
    
    def __new__(cls, row, column, context, model):
        """ Construct a model index.

        Arguments
        ---------
        row : int
            The row index represented by this index.

        column : int
            The column index represented by this index

        context : object
            A user supplied object that aids in navigating the user's
            model.

        model : AbstractItemModel
            The model in which this index is active. This is typically
            supplied by the create_index method of the AbstractItemModel.

        """
        return tuple.__new__(cls, (row, column, context, model))

    def __repr__(self):
        return 'ModelIndex(row=%s, col=%s, context=%s, model=%s)' % self
    
    def __str__(self):
        return self.__repr__()

    @property
    def row(self):
        return self[0]
    
    @property
    def column(self):
        return self[1]
    
    @property
    def context(self):
        return self[2]

    @property
    def model(self):
        return self[3]
        
    def parent(self):
        """ Returns the parent ModelIndex of this index.

        """
        return self.model.parent(self)

    def sibling(self, row, column):
        """ Returns the sibling ModelIndex of this index for the given
        row and column indexes.

        """
        model = self.model
        if self.row == row and self.column == column:
            return self
        return model.index(row, column, model.parent(self))

    def child(self, row, column):
        """ Returns the child ModelIndex of this index for the given
        row and column indexes.

        """
        return self.model.index(row, column, self)

    def flags(self):
        """ Returns the flags for this index.

        """
        return self.model.flags(self)


# Use the faster Cython implemented ModelIndex if available
try:
    from ..speedups.model_index import ModelIndex
except ImportError:
    pass


########NEW FILE########
__FILENAME__ = list_model
#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from enaml.core.item_model import (
    AbstractListModel, ITEM_IS_SELECTABLE, ITEM_IS_ENABLED, ITEM_IS_EDITABLE,
)


class ListModel(AbstractListModel):
    """ A concrete implementation of AbstractListModel which is intended
    to be easy to use for data models which behave more-or-less like
    one dimensional sequences.

    The data object can be updated dynamically after instantiation by 
    using the 'data_source' property.

    """
    base_flags = ITEM_IS_ENABLED | ITEM_IS_SELECTABLE

    def __init__(self, data, editable=False, display_data_converter=unicode,
                 edit_data_converter=None, background_brush_func=None, 
                 foreground_brush_func=None, font_func=None, 
                 vertical_headers=None, horizontal_headers=None):
        """ Initialize a ListModel.

        Parameters
        ----------
        data : 1D sequence-like object
            A sequence-like object that provides the data for the model.
            At a minimum it must support __getitem__ and __len__, and
            if editable, __setitem__.
        
        editable : bool, optional
            A bool which indicates whether or not the model is editable.
            If True, editing a cell will be done with an editor that is
            appropriate for the type of data given in the model. The
            default is False.
            
        display_data_converter : callable, optional
            An optional callable which should take a single argument: the
            value for the cell, and return a unicode value to use as the
            display value in the cell. The default value is the builtin
            unicode object.
        
        edit_data_converter : callable or None, optional
            An optional callable which should take a single argument: the
            unicode value typed by the user, and return a value to set
            in the model. This converter is only used when the model is
            declared as editable. If this converter is not supplied and
            the model is editable, then the type of the converted value
            will be determined automatically based on the input type. If
            a converter is supplied, and it cannot convert the value, it
            should raise a ValueError and the change will be ignored. The
            default value is None.
        
        background_brush_func : callable or None, optional
            If provided, it should be a callable which accepts two 
            arguments: the data value and the row index, and returns
            a brush for the background of the cell. The default is
            None.
        
        foreground_brush_func : callable or None, optional
            If provided, it should be a callable which accepts two 
            arguments: the data value and the row index, and returns
            a brush for the foreground of the cell. The default is
            None.
        
        font_func : callable or None, optional
            If provided, it should be a callable which accepts two 
            arguments: the data value and the row index, and returns
            a font for the cell. The default is None.
        
        vertical_headers : sequence-like object or None
            If provided, is should be a sequence like object which
            will be indexed with an integer index to retrieve a
            unicode string for the given row header. 
        
        horizontal_headers : sequence-like object or None
            If provided, is should be a sequence like object which
            will be indexed with an integer index to retrieve a
            unicode string for the given column header.

        """
        self._data_source = data
        self._editable = editable
        self._display_data_converter = display_data_converter
        self._edit_data_converter = edit_data_converter
        self._background_brush_func = background_brush_func
        self._foreground_brush_func = foreground_brush_func
        self._font_func = font_func
        self._vertical_headers = vertical_headers
        self._horizontal_headers = horizontal_headers

    def _get_data_source(self):
        """ The property getter for the 'data_source' property.
        
        """
        return self._data_source
    
    def _set_data_source(self, data):
        """ The property setter for the 'data_source' property.    
        
        """
        self.begin_reset_model()
        self._data_source = data
        self.end_reset_model()
    
    data_source = property(_get_data_source, _set_data_source)

    def flags(self, index):
        """ Returns the flags for the items in the model.

        """
        flags = self.base_flags
        if self._editable:
            flags |= ITEM_IS_EDITABLE
        return flags

    def data(self, index):
        """ Returns the data point from the data source converted to a 
        unicode for display.

        """
        return self._display_data_converter(self._data_source[index.row])
    
    def edit_data(self, index):
        """ Returns the data value for editing. If an edit converter is
        provided, then the unicode form of the data is returned, 
        otherwise, the raw datapoint is returned.

        """
        if self._edit_data_converter is None:
            return self._data_source[index.row]
        return self.data(index)
    
    def set_data(self, index, value):
        """ Sets the data source with the converted value, emits the 
        proper changed notification and returns True. 

        """
        converter = self._edit_data_converter
        if converter is not None:
            try:
                value = converter(value)
            except ValueError:
                return False
        self._data_source[index.row] = value
        self.notify_data_changed(index, index)
        return True

    def row_count(self, parent=None):
        """ Returns the number of rows in the data source.

        """
        if parent is not None:
            return 0
        return len(self._data_source)

    def background(self, index):
        """ Returns the brush for the background of the given index,
        or None.

        """
        brush_func = self._background_brush_func
        if brush_func is not None:
            row = index.row
            return brush_func(self._data_source[row], row)
    
    def foreground(self, index):
        """ Returns the brush for the foreground of the given index,
        or None.

        """
        brush_func = self._foreground_brush_func
        if brush_func is not None:
            row = index.row
            return brush_func(self._data_source[row], row)

    def font(self, index):
        """ Returns the font for the foreground of the given index,
        or None.

        """
        font_func = self._font_func
        if font_func is not None:
            row = index.row
            return font_func(self._data_source[row], row)

    def vertical_header_data(self, section):
        """ Returns the vertical header data for the given section.

        """
        headers = self._vertical_headers
        if headers is not None:
            res = headers[section]
        else:
            sup = super(ListModel, self)
            res = sup.vertical_header_data(section)
        return res
    
    def horizontal_header_data(self, section):
        """ Returns the horiztonal header data for the given section.

        """
        headers = self._horizontal_headers
        if headers is not None:
            res = headers[section]
        else:
            sup = super(ListModel, self)
            res = sup.horizontal_header_data(section)
        return res


########NEW FILE########
__FILENAME__ = object_model
#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from enaml.core.item_model import (
    AbstractTableModel, ITEM_IS_SELECTABLE, ITEM_IS_ENABLED, ITEM_IS_EDITABLE,
)


class ObjectModel(AbstractTableModel):
    """ A concrete implementation of AbstractTableModel which is intended
    to be easy to use for data models which display list of objects 
    where each object corresponds to a row in the table.

    The data object can be updated dynamically after instantiation by 
    using the 'data_source' property.

    """
    base_flags = ITEM_IS_ENABLED | ITEM_IS_SELECTABLE

    @staticmethod
    def format_header(header):
        """ A simple formatter class which converts an attribute name
        in a form more-or-less suitable for a column header.

        """
        return ' '.join(s.capitalize() for s in header.split('_'))

    def __init__(self, data, transpose=False, editable=False, 
                 display_data_converter=unicode, edit_data_converter=None, 
                 background_brush_func=None, foreground_brush_func=None, 
                 font_func=None, vertical_headers=None, 
                 horizontal_headers=None):
        """ Initialize an ObjectModel.

        Parameters
        ----------
        data : a 2-tuple of (object, column_attributes)
            A tuple whose first element is a sequence-like object that
            provides the row objects for the model, and whose second
            element is a sequence-like object that provides the string 
            names of the attributes of the objects which provide the
            data for the columns. At a minimum both elements must support
            __getitem__ and __len__.

        transpose : bool, optional
            A boolean which indicates that the model should be transposed
            such that the objects represent columns and the attributes
            represent rows. The default is False.

        editable : bool, optional
            A bool which indicates whether or not the model is editable.
            If True, editing a cell will be done with an editor that is
            appropriate for the type of data given in the model. The
            default is False.
            
        display_converter : callable, optional
            An optional callable which should take a single argument: the
            value for the cell, and return a unicode value to use as the
            display value in the cell. The default value is the builtin
            unicode object.
        
        edit_converter : callable or None, optional
            An optional callable which should take a single argument: the
            unicode value typed by the user, and return a value to set
            in the model. This converter is only used when the model is
            declared as editable. If this converter is not supplied and
            the model is editable, then the type of the converted value
            will be determined automatically based on the input type. If
            a converter is supplied, and it cannot convert the value, it
            should raise a ValueError and the change will be ignored. The
            default value is None.
        
        background_brush_func : callable or None, optional
            If provided, it should be a callable which accepts three
            arguments: the data value, the row index and column index, 
            and returns a brush for the background of the cell. The 
            default is None.
        
        foreground_brush_func : callable or None, optional
            If provided, it should be a callable which accepts three
            arguments: the data value, the row index and column index, 
            and returns a brush for the foreground of the cell. The 
            default is None.
        
        font_func : callable or None, optional
            If provided, it should be a callable which accepts three
            arguments: the data value, the row index and column index, 
            and returns a font for the cell. The default is None.

        vertical_headers : sequence-like object or None
            If provided, is should be a sequence like object which
            will be indexed with an integer index to retrieve a
            unicode string for the given row header. 
        
        horizontal_headers : sequence-like object or None
            If provided, is should be a sequence like object which
            will be indexed with an integer index to retrieve a
            unicode string for the given column header.

        """
        self._data_source = data
        self._transpose = transpose
        self._editable = editable
        self._display_data_converter = display_data_converter
        self._edit_data_converter = edit_data_converter
        self._background_brush_func = background_brush_func
        self._foreground_brush_func = foreground_brush_func
        self._font_func = font_func
        self._vertical_headers = vertical_headers
        self._horizontal_headers = horizontal_headers
    
    def _get_data_source(self):
        """ The property getter for the 'data_source' property.
        
        """
        return self._data_source
    
    def _set_data_source(self, data):
        """ The property setter for the 'data_source' property.    
        
        """
        self.begin_reset_model()
        self._data_source = data
        self.end_reset_model()
    
    data_source = property(_get_data_source, _set_data_source)

    def _get_transpose(self):
        """ The property getter for the 'transpose' property.

        """
        return self._transpose
    
    def _set_transpose(self, value):
        """ The property setter for the 'transposed' property.

        """
        self.begin_reset_model()
        self._transpose = value
        self.end_reset_model()
    
    transpose = property(_get_transpose, _set_transpose)
    
    def flags(self, index):
        """ Returns the flags for the items in the model.

        """
        flags = self.base_flags
        if self._editable:
            flags |= ITEM_IS_EDITABLE
        return flags

    def data(self, index): 
        """ Returns the data point from the data source converted to a 
        unicode for display.

        """
        row = index.row
        col = index.column
        if self._transpose:
            row, col = col, row
        objs, attrs = self._data_source
        value = getattr(objs[row], attrs[col])
        return self._display_data_converter(value)
    
    def edit_data(self, index):
        """ Returns the data value for editing. If an edit converter is
        provided, then the unicode form of the data is returned, 
        otherwise, the raw datapoint is returned.

        """
        if self._edit_data_converter is None:
            row = index.row
            col = index.column
            if self._transpose:
                row, col = col, row
            objs, attrs = self._data_source
            return getattr(objs[row], attrs[col])
        return self.data(index)
    
    def set_data(self, index, value):
        """ Sets the data source with the converted value, emits the 
        proper changed notification and returns True. 

        """
        converter = self._edit_data_converter
        if converter is not None:
            try:
                value = converter(value)
            except ValueError:
                return False
        row = index.row
        col = index.column
        if self._transpose:
            row, col = col, row
        objs, attrs = self._data_source
        setattr(objs[row], attrs[col], value)
        self.notify_data_changed(index, index)
        return True
        
    def row_count(self, parent=None):
        """ Returns the number of rows in the data source.

        """
        if parent is not None:
            return 0
        idx = 0
        if self._transpose:
            idx = 1
        return len(self._data_source[idx])
    
    def column_count(self, parent=None):
        """ Returns the number of columns in the data source.

        """
        if parent is not None:
            return 0
        idx = 1
        if self._transpose:
            idx = 0
        return len(self._data_source[idx])

    def background(self, index):
        """ Returns the brush for the background of the given index,
        or None.

        """
        brush_func = self._background_brush_func
        if brush_func is not None:
            row = index.row
            col = index.column
            if self._transpose:
                row, col = col, row
            objs, attrs = self._data_source
            value = getattr(objs[row], attrs[col])
            return brush_func(value, row, col)
    
    def foreground(self, index):
        """ Returns the brush for the foreground of the given index,
        or None.

        """
        brush_func = self._foreground_brush_func
        if brush_func is not None:
            row = index.row
            col = index.column
            if self._transpose:
                row, col = col, row
            objs, attrs = self._data_source
            value = getattr(objs[row], attrs[col])
            return brush_func(value, row, col)

    def font(self, index):
        """ Returns the font for the foreground of the given index,
        or None.

        """
        font_func = self._font_func
        if font_func is not None:
            row = index.row
            col = index.column
            if self._transpose:
                row, col = col, row
            objs, attrs = self._data_source
            value = getattr(objs[row], attrs[col])
            return font_func(value, row, col)

    def vertical_header_data(self, section):
        """ Returns the vertical header data for the given section.

        """
        headers = self._vertical_headers
        if headers is not None:
            res = headers[section]
        else:
            if self._transpose:
                res = self.format_header(self._data_source[1][section])
            else:
                sup = super(ObjectModel, self)
                res = sup.vertical_header_data(section)
        return res
    
    def horizontal_header_data(self, section):
        """ Returns the horiztonal header data for the given section.

        """
        headers = self._horizontal_headers
        if headers is not None:
            res = headers[section]
        else:
            if not self._transpose:
                res = self.format_header(self._data_source[1][section])
            else:
                sup = super(ObjectModel, self)
                res = sup.horizontal_header_data(section)
        return res


########NEW FILE########
__FILENAME__ = table_model
#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from enaml.core.item_model import (
    AbstractTableModel, ITEM_IS_SELECTABLE, ITEM_IS_ENABLED, ITEM_IS_EDITABLE,
)


class TableModel(AbstractTableModel):
    """ A concrete implementation of AbstractTableModel which is intended
    to be easy to use for data models which behave like two dimensional
    arrays.

    The data object can be updated dynamically after instantiation by 
    using the 'data_source' property.

    """
    base_flags = ITEM_IS_ENABLED | ITEM_IS_SELECTABLE

    def __init__(self, data, editable=False, display_data_converter=unicode,
                 edit_data_converter=None, background_brush_func=None, 
                 foreground_brush_func=None, font_func=None,
                 vertical_headers=None, horizontal_headers=None):
        """ Initialize a TableModel.

        Parameters
        ----------
        data : 2D array-like object
            An array-like object that provides the data for the model.
            At a minimum it must support __getitem__ which can be
            indexed with a (row, col) tuple, and have a 'shape' attribute
            which gives an (nrows, ncols) tuple. If the model is also
            editable, it should support __setitem__

        editable : bool, optional
            A bool which indicates whether or not the model is editable.
            If True, editing a cell will be done with an editor that is
            appropriate for the type of data given in the model. The
            default is False.
            
        display_converter : callable, optional
            An optional callable which should take a single argument: the
            value for the cell, and return a unicode value to use as the
            display value in the cell. The default value is the builtin
            unicode object.
        
        edit_converter : callable or None, optional
            An optional callable which should take a single argument: the
            unicode value typed by the user, and return a value to set
            in the model. This converter is only used when the model is
            declared as editable. If this converter is not supplied and
            the model is editable, then the type of the converted value
            will be determined automatically based on the input type. If
            a converter is supplied, and it cannot convert the value, it
            should raise a ValueError and the change will be ignored. The
            default value is None.
        
        background_brush_func : callable or None, optional
            If provided, it should be a callable which accepts three
            arguments: the data value, the row index and column index, 
            and returns a brush for the background of the cell. The 
            default is None.
        
        foreground_brush_func : callable or None, optional
            If provided, it should be a callable which accepts three
            arguments: the data value, the row index and column index, 
            and returns a brush for the foreground of the cell. The 
            default is None.
        
        font_func : callable or None, optional
            If provided, it should be a callable which accepts three
            arguments: the data value, the row index and column index, 
            and returns a font for the cell. The default is None.

        vertical_headers : sequence-like object or None
            If provided, is should be a sequence like object which
            will be indexed with an integer index to retrieve a
            unicode string for the given row header. 
        
        horizontal_headers : sequence-like object or None
            If provided, is should be a sequence like object which
            will be indexed with an integer index to retrieve a
            unicode string for the given column header.

        """
        self._data_source = data
        self._editable = editable
        self._display_data_converter = display_data_converter
        self._edit_data_converter = edit_data_converter
        self._background_brush_func = background_brush_func
        self._foreground_brush_func = foreground_brush_func
        self._font_func = font_func
        self._vertical_headers = vertical_headers
        self._horizontal_headers = horizontal_headers
    
    def _get_data_source(self):
        """ The property getter for the 'data_source' property.
        
        """
        return self._data_source
    
    def _set_data_source(self, data):
        """ The property setter for the 'data_source' property.    
        
        """
        self.begin_reset_model()
        self._data_source = data
        self.end_reset_model()
    
    data_source = property(_get_data_source, _set_data_source)

    def flags(self, index):
        """ Returns the flags for the items in the model.

        """
        flags = self.base_flags
        if self._editable:
            flags |= ITEM_IS_EDITABLE
        return flags

    def data(self, index): 
        """ Returns the data point from the data source converted to a 
        unicode for display.

        """
        row = index.row
        col = index.column
        return self._display_data_converter(self._data_source[row, col])
    
    def edit_data(self, index):
        """ Returns the data value for editing. If an edit converter is
        provided, then the unicode form of the data is returned, 
        otherwise, the raw datapoint is returned.

        """
        if self._edit_data_converter is None:
            row = index.row
            col = index.column
            return self._data_source[row, col]
        return self.data(index)
    
    def set_data(self, index, value):
        """ Sets the data source with the converted value, emits the 
        proper changed notification and returns True. 

        """
        converter = self._edit_data_converter
        if converter is not None:
            try:
                value = converter(value)
            except ValueError:
                return False
        row = index.row
        col = index.column
        self._data_source[row, col] = value
        self.notify_data_changed(index, index)
        return True
        
    def row_count(self, parent=None):
        """ Returns the number of rows in the data source.

        """
        if parent is not None:
            return 0
        return self._data_source.shape[0]
    
    def column_count(self, parent=None):
        """ Returns the number of columns in the data source.

        """
        if parent is not None:
            return 0
        return self._data_source.shape[1]

    def background(self, index):
        """ Returns the brush for the background of the given index,
        or None.

        """
        brush_func = self._background_brush_func
        if brush_func is not None:
            row = index.row
            col = index.column
            return brush_func(self._data_source[row, col], row, col)
    
    def foreground(self, index):
        """ Returns the brush for the foreground of the given index,
        or None.

        """
        brush_func = self._foreground_brush_func
        if brush_func is not None:
            row = index.row
            col = index.column
            return brush_func(self._data_source[row, col], row, col)

    def font(self, index):
        """ Returns the font for the foreground of the given index,
        or None.

        """
        font_func = self._font_func
        if font_func is not None:
            row = index.row
            col = index.column
            return font_func(self._data_source[row, col], row, col)

    def vertical_header_data(self, section):
        """ Returns the vertical header data for the given section.

        """
        headers = self._vertical_headers
        if headers is not None:
            res = headers[section]
        else:
            sup = super(TableModel, self)
            res = sup.vertical_header_data(section)
        return res
    
    def horizontal_header_data(self, section):
        """ Returns the horiztonal header data for the given section.

        """
        headers = self._horizontal_headers
        if headers is not None:
            res = headers[section]
        else:
            sup = super(TableModel, self)
            res = sup.horizontal_header_data(section)
        return res


########NEW FILE########
__FILENAME__ = thumbnail_model
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from collections import namedtuple
from functools import wraps

from enaml.core.toolkit import Toolkit
from enaml.core.item_model import AbstractListModel, ALIGN_HCENTER, ALIGN_VCENTER


# A named tuple representing a thumbnail. It contains the 'name' to show
# below the thumbnail in a view. The 'image' object from which to create
# the thumbnail, and any 'metadata' to associate with the thumbnail for
# use in other parts of an application.
Thumbnail = namedtuple('Thumbnail', 'name image metadata')


def _refresh_data(func):
    """ A method decorator which will trigger a refresh of all data in 
    a list model. This assumes that the data in the list model is in 
    the zero column.

    """
    @wraps(func)
    def closure(self, *args, **kwargs):
        parent = None
        top_left = self.index(0, 0, parent)
        bottom_right = self.index(self.row_count(parent) - 1, 0, parent)
        res = func(self, *args, **kwargs)
        self.notify_data_changed(top_left, bottom_right)
        return res
    return closure


class ThumbnailModel(AbstractListModel):
    """ A concrete list model implementation which displays a list of
    thumbnails.

    """
    def __init__(self, thumbs=None):
        """ Initialize a ThumbnailModel

        Parameters
        ----------
        thumbs : list, optional
            An initial list of Thumbnail objects to be used by the model.

        """
        self._thumbs = thumbs[:] if thumbs is not None else []
        self._toolkit = Toolkit.active_toolkit()
        self._icon_cls = self._toolkit['Icon']

    #--------------------------------------------------------------------------
    # Abstract List Model Implementation
    #--------------------------------------------------------------------------
    def row_count(self, index):
        """ Returns the number of thumbnails in the current thumbnail
        list.

        """
        if index is None:
            return len(self._thumbs)
        return 0

    def data(self, index):
        """ Returns the name for the thumbnail at the given index.

        """
        return self._thumbs[index.row].name

    def alignment(self, index):
        """ Returns the alignment for the given row. Thumbnail text
        is centered in the item.

        """
        return ALIGN_HCENTER | ALIGN_VCENTER
    
    def decoration(self, index):
        """ Returns the icon for the given row. The icons are created
        on the fly from the images contained in the thumbnails.

        """
        image = self._thumbs[index.row].image
        return self._icon_cls.from_image(image)

    #--------------------------------------------------------------------------
    # Private API
    #--------------------------------------------------------------------------
    def _insert(self, idx, thumb):
        """ Inserts the given thumbnail or list of thumbnails at the 
        given index and triggers the appropriate data refresh.

        """
        if isinstance(thumb, Thumbnail):
            self.begin_insert_rows(None, idx, idx)
            self._thumbs.insert(idx, thumb)
            self.end_insert_rows(None, idx, idx)
        else:
            last = idx + len(thumb) - 1
            self.begin_insert_rows(None, idx, last)
            old = self._thumbs
            new = old[:idx] + thumb + old[idx:]
            self._thumbs = new
            self.end_insert_rows(None, idx, last)

    def _append(self, thumb):
        """ Appends the given thumbnail to the model and triggers the
        appropriate data refresh.

        """
        idx = len(self._thumbs)
        self.begin_insert_rows(None, idx, idx)
        self._thumbs.append(thumb)
        self.end_insert_rows(None, idx, idx)

    def _extend(self, thumbs):
        """ Extends the model with the given thumbnails and triggers
        the appropriate data refresh.

        """
        idx = len(self._thumbs)
        last = idx + len(thumbs) - 1
        self.begin_insert_rows(None, idx, last)
        self._thumbs.extend(thumbs)
        self.end_insert_rows(None, idx, last)

    def _remove(self, idx, count):
        """ Removes the given number of thumbnails starting at the
        given index.

        """
        last = idx + count - 1
        self.begin_remove_rows(None, idx, last)
        del self._thumbs[idx:last+1]
        self.end_remove_rows(None, idx, last)

    def _set_thumbnails(self, thumbs):
        """ Resets the model using the given thumbnails.

        """
        self.begin_reset_model()
        self._thumbs = thumbs[:]
        self.end_reset_model()

    def _clear(self):
        """ Clears the internal list of thumbnails and resets the model.

        """
        self.begin_reset_model()
        self._thumbs = []
        self.end_reset_model()
        
    #--------------------------------------------------------------------------
    # Public Methods
    #--------------------------------------------------------------------------
    def insert(self, idx, thumb):
        """ Insert the given thumbnail(s) at the specified index and
        trigger the appropriate refresh.

        Parameters
        ----------
        idx : int
            The index where to insert the thumbnail(s).

        thumb : Thumbnail or list of Thumbnails
            The thumbnail(s) to insert into the model. If a list is
            given, the thumbnails will be inserted in order.

        Notes
        -----
        This method is thread safe. The actual update will occur on the
        main gui thread. It is thus safe to use a thread to perform the 
        thumbnail creation and then request the update.

        """
        self._toolkit.app.call_on_main(self._insert, idx, thumb)

    def append(self, thumb):
        """ Append the given thumbnail to the model and trigger the
        appropriate refresh. 
        
        Parameters
        ----------
        thumb : Thumbnail
            The thumbnail to append to the model.

        Notes
        -----
        This method is thread safe. The actual update will occur on the
        main gui thread. It is thus safe to use a thread to perform the 
        thumbnail creation and then request the update.

        """
        self._toolkit.app.call_on_main(self._append, thumb)

    def extend(self, thumbs):
        """ Extend the model with the given thumbnails and trigger the
        appropriate refresh.
        
        Parameters
        ----------
        thumbs : list of Thumbnails
            The thumbnails to add to the end of the model.

        Notes
        -----
        This method is thread safe. The actual update will occur on the
        main gui thread. It is thus safe to use a thread to perform the 
        thumbnail creation and then request the update.

        """
        self._toolkit.app.call_on_main(self._extend, thumbs)

    def remove(self, idx, count):
        """ Remove the specified thumbnails from the model.

        Parameters
        ----------
        idx : int
            The starting index of the chunk of thumbnails to remove.

        count : int
            The number of thumbnails to remove from the model.

        Notes
        -----
        This method is thread safe. The actual update will occur on the
        main gui thread. It is thus safe to use a thread to perform the 
        thumbnail creation and then request the update.

        """
        self._toolkit.app.call_on_main(self._remove, idx, count)

    def thumbnail(self, index):
        """ Returns the thumbnail for the given model index.

        """
        return self._thumbs[index.row]
        
    def thumbnails(self):
        """ Returns the thumbnails in the model.

        Returns
        -------
        result : list of Thumbnails
            The thumbnails in use by the model.

        Notes
        -----
        The returned list is a copy of internal list of thumbnails.
        It is safe to modify the returned list in-place as it will 
        have no effect on the model.

        """
        return self._thumbs[:]

    def set_thumbnails(self, thumbs):
        """ Reset the model with the provided thumbnails.

        Parameters
        ----------
        thumbs : list of Thumbnails
            The thumbnails to use in the model. Old thumbnails will
            be discarded.

        Notes
        -----
        This method is thread safe. The actual update will occur on the
        main gui thread. It is thus safe to use a thread to perform the 
        thumbnail creation and then request the update.

        """
        self._toolkit.app.call_on_main(self._set_thumbnails, thumbs)

    def clear(self):
        """ Clear the model of all thumbnails and trigger the 
        appropriate refresh.

        """
        self._toolkit.app.call_on_main(self._clear)


########NEW FILE########
__FILENAME__ = sessions
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
""" Enaml Standard Library - Sessions

This module contains some Session subclasses and associated utilities that
handle common Session use cases.

"""
from collections import Iterable
from functools import wraps

from enaml.session import Session
from enaml.session_factory import SessionFactory


class SimpleSession(Session):
    """ A concrete Session class that receives a callable, positional,
    and keyword arguments and creates the associated view(s).

    """
    def __init__(self, sess_callable, *args, **kwargs):
        """ Initialize the session with the callable and arguments.

        """
        super(SimpleSession, self).__init__()
        self.sess_callable = sess_callable
        self.args = args
        self.kwargs = kwargs

    def on_open(self):
        """ Create the view from the callable

        """
        w = self.sess_callable(*self.args, **self.kwargs)
        if isinstance(w, Iterable):
            self.windows.extend(w)
        else:
            self.windows.append(w)


def simple_session(sess_name, sess_descr, sess_callable, *args, **kwargs):
    """ Creates a SessionFactory instance for a callable.

    This creates a SessionFactory instance which will create instances
    of SimpleSession when prompted by the application.

    Parameters
    ----------
    sess_name : str
        A unique, human-friendly name for the session.

    sess_descr : str
        A brief description of the session.

    sess_callable : callable
        A callable which will return an Enaml view or iterable of views.

    *args, **kwargs
        Optional positional and keyword arguments to pass to the callable
        when the session is created.

    """
    fact = SessionFactory(
        sess_name, sess_descr, SimpleSession, sess_callable, *args, **kwargs
    )
    return fact


def view_factory(sess_name=None, sess_descr=None):
    """ A decorator that creates a session factory from a callable.

    This can be used in the following ways:

        @view_factory
        def view(...):
            ...
            return View(...)

        @view_factory('my-views', 'This is several views')
        def views(...):
            ...
            return [View1(...), View2(...)]

        simple = view_factory(Main)

    """
    def wrapper(func, _name, _descr):
        if _name is None:
            _name = func.__name__
        if _descr is None:
            _descr = func.__doc__ or 'no description'
        @wraps(func)
        def closure(*args, **kwargs):
            return simple_session(_name, _descr, func, *args, **kwargs)
        return closure
    if sess_name is not None and callable(sess_name):
        return wrapper(sess_name, None, sess_descr)
    def _wrapper(func):
        return wrapper(func, sess_name, sess_descr)
    return _wrapper


def show_simple_view(view, toolkit='qt', description=''):
    """ Display a simple view to the screen in the local process.

    Parameters
    ----------
    view : Object
        The top level Object to use as the view.

    toolkit : string, optional
        The toolkit backend to use to display the view. Currently
        supported values are 'qt' and 'wx'. The default is 'qt'.
        Note that not all functionality is available on Wx.

    description : string, optional
        An optional description to give to the session.

    """
    f = lambda: view
    if toolkit == 'qt':
        from enaml.qt.qt_application import QtApplication
        app = QtApplication([simple_session('main', description, f)])
    elif toolkit == 'wx':
        from enaml.wx.wx_application import WxApplication
        app = WxApplication([simple_session('main', description, f)])
    else:
        raise ValueError('Unknown toolkit `%s`' % toolkit)
    app.start_session('main')
    app.start()
    return app


########NEW FILE########
__FILENAME__ = slider_transforms
#------------------------------------------------------------------------------
#  Copyright (c) 2013, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
""" Enaml Standard Library - Slider Transforms

This module contains declarative classes which can be used as children
of a `Slider` to transform the integer range of the slider into an
alternative data space.

"""
from traits.api import Any, Bool, Float, Range, on_trait_change

from enaml.core.declarative import Declarative


class SliderTransform(Declarative):
    """ A base class for creating declarative slider transforms.

    A SliderTransform must be subclassed to be useful. The abstract api
    defined below must be implemented by the subclass.

    When using a transform with a slider, the transform takes complete
    ownership of the slider range. That is, no effort is made to listen
    for outside changes to the slider range, so all changes should be
    made on the transform.

    """
    #: The data-space minimum for the transform. This may be redefined
    #: by a subclass to enforce stronger typing.
    minimum = Any

    #: The data-space maximum for the transform. This may be redefined
    #: by a subclass to enforce stronger typing.
    maximum = Any

    #: The data-space value for the transform. This may be redefined
    #: by a subclass to enforce stronger typing.
    value = Any

    #: A boolean flag used to prevent loopback cycles.
    _guard = Bool(False)

    #--------------------------------------------------------------------------
    # Private API
    #--------------------------------------------------------------------------
    def pre_initialize(self):
        """ A pre-initialization handler.

        The parent slider values are initialized during the transform
        initialization pass.

        """
        self._apply_transform()

    def _apply_transform(self, minimum=True, maximum=True, value=True):
        """ Apply the current transform to the parent slider.

        Parameters
        ----------
        minimum : bool, optional
            Whether or not to update the slider minimum. The default
            is False.

        maximum : bool, optional
            Whether or not to update the slider maximum. The default
            is False.

        value : bool, optional
            Whether or not to update the slider value. The default
            is False.

        """
        parent = self.parent
        if parent is not None:
            if minimum:
                parent.minimum = self.get_minimum()
            if maximum:
                parent.maximum = self.get_maximum()
            if value:
                parent.value = self.get_value()

    @on_trait_change('parent:value')
    def _update_value(self, val):
        """ Update the transformed value when slider changes.

        """
        if self.is_active:
            self._guard = True
            try:
                self.set_value(val)
            finally:
                self._guard = False

    def _minimum_changed(self):
        """ Update the slider minimum on transform minimum change.

        """
        if self.is_active:
            self._apply_transform(maximum=False, value=False)

    def _maximum_changed(self):
        """ Update the slider maximum on transform maximum change.

        """
        if self.is_active:
            self._apply_transform(minimum=False, value=False)

    def _value_changed(self):
        """ Update the slider value on transform value change.

        """
        if self.is_active and not self._guard:
            self._apply_transform(minimum=False, maximum=False)

    #--------------------------------------------------------------------------
    # Abstract API
    #--------------------------------------------------------------------------
    def get_minimum(self):
        """ Get the minimum value of the transform as an int.

        Returns
        -------
        result : int
            The minimum value of the transform converted to an int.

        """
        raise NotImplementedError

    def get_maximum(self):
        """ Get the maximum value of the transform as an int.

        Returns
        -------
        result : int
            The maximum value of the transform converted to an int.

        """
        raise NotImplementedError

    def get_value(self):
        """ Get the value of the transform as an int.

        Returns
        -------
        result : int
            The value of the transform converted to an int.

        """
        raise NotImplementedError

    def set_value(self, value):
        """ Set the value of the transform from an int.

        Parameters
        ----------
        value : int
            The integer value of the slider.

        """
        raise NotImplementedError


class FloatTransform(SliderTransform):
    """ A concreted SliderTransform for floating point values.

    """
    #: A redeclared parent class trait which enforces float values.
    minimum = Float(0.0)

    #: A redeclared parent class trait which enforces float values.
    maximum = Float(1.0)

    #: A redeclared parent class trait which enforces float values.
    value = Float(0.0)

    #: The number of stops to use between the minimum and maximum.
    precision = Range(low=1, value=100)

    #--------------------------------------------------------------------------
    # Abstract API Implementation
    #--------------------------------------------------------------------------
    def get_minimum(self):
        """ Get the minimum value of the transform as an int.

        Returns
        -------
        result : int
            The minimum value of the transform converted to an int.

        """
        return 0

    def get_maximum(self):
        """ Get the maximum value of the transform as an int.

        Returns
        -------
        result : int
            The maximum value of the transform converted to an int.

        """
        return self.precision

    def get_value(self):
        """ Get the value of the transform as an int.

        Returns
        -------
        result : int
            The value of the transform converted to an int.

        """
        offset = self.value - self.minimum
        delta = self.maximum - self.minimum
        return int(offset * self.precision / delta)

    def set_value(self, val):
        """ Set the value of the transform from an int.

        Parameters
        ----------
        value : int
            The integer value of the slider.

        """
        delta = self.maximum - self.minimum
        self.value = (val * delta / self.precision) + self.minimum


########NEW FILE########
__FILENAME__ = calendar
#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from datetime import date

from traits.api import TraitError

from .enaml_test_case import EnamlTestCase, required_method


class TestCalendar(EnamlTestCase):
    """ Logic for testing calendars.

    Toolkit testcases need to provide the following functions

    Abstract Methods
    ----------------
    get_date(self, widget)
        Get a calendar's active date.

    get_min_date(self, widget)
        Get a calendar's minimum date attribute.

    get_max_date(self, widget)
        Get a calendar's maximum date attribute.

    activate_date(self, widget, date)
        Fire an event to indicate that a date was activated.

    select_date(self, widget, date)
        Fire an event to indicate that a date was selected.

    """

    def setUp(self):
        """ Set up before the calendar tests

        """

        source = """
enamldef MainView(MainWindow):
    attr events
    Calendar:
        name = 'cal'
        selected :: events.append(('selected', event.new))
        activated :: events.append(('activated', event.new))
"""

        self.events = []
        self.view = self.parse_and_create(source, events=self.events)
        self.component = self.component_by_name(self.view, 'cal')
        self.widget = self.component.toolkit_widget

    def test_initial_value(self):
        """ Test the initial attributes of the calendar.

        """
        component = self.component

        self.assertEnamlInSync(component, 'date', date.today())
        self.assertEnamlInSync(component, 'min_date', date(1752, 9, 14))
        self.assertEnamlInSync(component, 'max_date', date(7999, 12, 31))
        self.assertEqual(self.events, [])

    def test_change_min_date(self):
        """ Test changing the minimum date.

        """
        component = self.component
        new_minimum = date(2000,1,1)
        component.min_date = new_minimum
        self.assertEnamlInSync(component, 'min_date', new_minimum)

    def test_change_max_date(self):
        """ Test changing the maximum date.

        """
        component = self.component
        new_maximum = date(2005,1,1)
        component.max_date = new_maximum
        self.assertEnamlInSync(component, 'max_date', new_maximum)

    def test_change_date_in_enaml(self):
        """ Test changing the current date through the component.

        """
        component = self.component
        new_date = date(2007,10,9)
        component.date = new_date
        self.assertEnamlInSync(component, 'date', new_date)
        self.assertEqual(self.events, [])

    def test_invalid_min_date(self):
        """ Test changing to an invalid date below the min range.

        """
        component = self.component
        min_date = date(2000,2,3)
        component.min_date = min_date
        with self.assertRaises(TraitError):
            component.date = date(2000,1,1)
        self.assertEnamlInSync(component, 'date', date.today())
        self.assertEqual(self.events, [])

    def test_invalid_max_date(self):
        """ Test changing to an invalid date above the max range.

        """
        component = self.component
        component.date = date(2011,10,9)
        self.assertEqual(self.events, [])
        max_date = date(2014,2,3)
        component.max_date = max_date
        with self.assertRaises(TraitError):
            component.date = date(2016,10,9)
        self.assertEnamlInSync(component, 'date', date(2011,10,9))
        self.assertEqual(self.events, [])

    def test_select_date_in_ui(self):
        """ Test changing the current date thought the ui

        """
        component = self.component
        widget = self.widget
        new_date = date(2007,10,9)
        self.select_date(widget, new_date)
        self.assertEqual(self.get_date(widget), new_date)
        # make sure that the component is not updated when selected is fired
        self.assertEqual(component.date, date.today())
        self.assertEqual(self.events, [('selected', new_date)])

    def test_activate_date_in_ui(self):
        """ Test activating the current date thought the ui

        """
        component = self.component
        widget = self.widget
        new_date = date(2007,10,9)
        self.select_date(widget, new_date)
        self.activate_date(self.widget, new_date)
        self.assertEnamlInSync(component, 'date', new_date)
        self.assertEqual(self.events, [('selected', new_date),
                                       ('activated', new_date)])

    def test_change_maximum_and_date(self):
        """ Test setting maximum while the date is out of range.

        """
        component = self.component
        component.date = date(2007,10,9)
        component.max_date = date(2006,5,9)
        self.assertEnamlInSync(component, 'date', date(2006,5,9))
        self.assertEqual(self.events, [])

    def test_change_minimum_and_date(self):
        """ Test setting minimum while the date is out of range.

        """
        component = self.component
        component.date = date(2007,10,9)
        component.min_date = date(2010,5,9)
        self.assertEnamlInSync(component, 'date', date(2010,5,9))
        self.assertEqual(self.events, [])

    def test_change_range_invalid(self):
        """ Test setting minimum > maximum.

        """
        component = self.component
        component.min_date = date(2010,5,9)
        with self.assertRaises(TraitError):
            component.max_date = date(2006,5,9)

        component.max_date = date(2034,12,10)
        with self.assertRaises(TraitError):
            component.min_date = date(2034,12,14)

    #--------------------------------------------------------------------------
    # Special initialization tests
    #--------------------------------------------------------------------------
    def test_initial_too_early(self):
        """ Check initialization with an invalid early date is corrected.

        .. todo:: avoid using the enaml source

        """
        enaml_source = """
import datetime
enamldef MainView(MainWindow):
    attr events
    Calendar:
        name = 'cal'
        date = datetime.date(1980, 1, 1)
        min_date = datetime.date(1990, 1, 1)
        max_date = datetime.date(2000, 1, 1)
        selected :: events.append(('selected', event.new))
        activated :: events.append(('activated', event.new))

"""
        events = []
        with self.assertRaises(TraitError):
            self.parse_and_create(enaml_source, events=events)

    def test_initial_too_late(self):
        """ Check initialization with an invalid late date is corrected.

        .. todo:: avoid using the enaml source

        """
        enaml = """
import datetime
enamldef MainView(MainWindow):
    attr events
    Calendar:
        name = 'cal'
        date = datetime.date(2010, 1, 1)
        min_date = datetime.date(1990, 1, 1)
        max_date = datetime.date(2000, 1, 1)
        selected :: events.append(('selected', event.new))
        activated :: events.append(('activated', event.new))
"""
        events = []
        with self.assertRaises(TraitError):
            self.parse_and_create(enaml, events=events)

    #--------------------------------------------------------------------------
    # Abstract methods
    #--------------------------------------------------------------------------
    @required_method
    def get_date(self, widget):
        """ Get a calendar's active date.

        """
        pass

    @required_method
    def get_min_date(self, widget):
        """ Get a calendar's minimum date attribute.

        """
        pass

    @required_method
    def get_max_date(self, widget):
        """ Get a calendar's maximum date attribute.

        """
        pass

    @required_method
    def activate_date(self, widget):
        """ Fire an event to indicate that a date was activated.

        """
        pass

    @required_method
    def select_date(self, widget, date):
        """ Fire an event to indicate that a date was selected.

        """
        pass


########NEW FILE########
__FILENAME__ = check_box
#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from .enaml_test_case import EnamlTestCase, required_method


class TestCheckBox(EnamlTestCase):
    """ Logic for testing push buttons.

    Tooklit testcases need to provide the following functions

    Abstract Methods
    ----------------
    get_text(widget)
        Returns the text from the tookit widget.

    checked_status(widget)
        Returns the checked status of the toolkit widget.

    Checkbox_pressed(self)
        Press the checkbox programmatically.

    Checkbox_released(self)
        Release the checkbox programmatically.

    Checkbox_toggled(self)
        Toggle the button programmatically.

    """
    def setUp(self):
        """ Setup enaml component for testing

        """
        self.check_box_label = 'checkbox label'

        enaml_source = """
enamldef MainView(MainWindow):
    attr events
    CheckBox:
        name = 'checkb1'
        text = 'checkbox label'
        checked = True
        toggled :: events.append('toggled')
        pressed :: events.append('pressed')
        released :: events.append('released')
""".format(self.check_box_label)

        self.events = []
        self.view = self.parse_and_create(enaml_source, events=self.events)
        self.component = self.component_by_name(self.view, 'checkb1')
        self.widget = self.component.toolkit_widget

    def test_box_initialization(self):
        """ Test the initialization of the widget

        """
        component = self.component
        # checked
        self.assertEnamlInSync(component, 'checked', True)
        self.assertEnamlInSync(component, 'text', self.check_box_label)

    def testLabelChange(self):
        """ Test changing the label of a check box

        """
        component = self.component
        new_label = 'new_label'
        component.text = new_label
        self.assertEnamlInSync(component, 'text', new_label)

    def testSettingChecked(self):
        """ Test selecting a WXCheckBox

        """
        component = self.component
        # un-check
        self.component.checked = False
        self.assertEnamlInSync(component, 'checked', False)
        # check
        self.component.checked = True
        self.assertEnamlInSync(component, 'checked', True)

    def test_checkbox_pressed(self):
        """ React to a checkbox press event.

        """
        events = self.events
        self.checkbox_pressed(self.widget)
        self.assertTrue(self.component.down)
        self.assertEqual(events, ['pressed'])

    def test_checkbox_toggled(self):
        """ Test a checkbox toggled event.

        """
        events = self.events
        self.checkbox_toggle(self.widget)
        self.assertFalse(self.component.down)
        self.assertEqual(events, ['toggled'])

    def test_checkbox_released(self):
        """ Test a checkbox release event.

        """
        events = self.events
        # Release events are ignored if the button was not already down
        self.checkbox_released(self.widget)
        self.assertEqual(events, [])

    def test_press_release_sequence(self):
        """ Verify the even firing when the press-release (nornal) 
        sequence is applied.

        """
        component = self.component
        widget = self.widget
        events = self.events
        self.checkbox_pressed(widget)
        self.assertTrue(component.down)
        self.checkbox_released(widget)
        self.assertFalse(component.down)
        self.assertEqual(events, ['pressed', 'released'])

    def test_checkbox_all_events(self):
        """ Test press, release, and click events.

        """
        self.checkbox_pressed(self.widget)
        self.checkbox_released(self.widget)
        self.checkbox_toggle(self.widget)

        events = self.events
        self.assertEqual(events, ['pressed', 'released', 'toggled'])

    #--------------------------------------------------------------------------
    # Abstract methods
    #--------------------------------------------------------------------------
    @required_method
    def get_text(self, widget):
        """ Returns the text from the tookit widget.

        """
        pass

    @required_method
    def get_checked(self, widget):
        """ Returns the checked status of the toolkit widget.

        """
        pass

    @required_method
    def checkbox_pressed(self, widget):
        """ Press the checkbox programmatically.

        """
        pass

    @required_method
    def checkbox_released(self, widget):
        """ Release the button programmatically.

        """
        pass

    @required_method
    def checkbox_toggle(self, widget):
        """ Toggle the button programmatically.

        """
        pass


########NEW FILE########
__FILENAME__ = combo_box
#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from .enaml_test_case import EnamlTestCase, required_method


class TestComboBox(EnamlTestCase):
    """ Logic for testing combo boxes.

    Tooklit testcases need to provide the following methods

    Abstract Methods
    ----------------
    get_selected_text(self, widget)
        Get the current selected text of a combo box.

    get_item_text(self, widget, index)
        Get the text of a combo box item at a particular index.

    select_item(self, widget, index)
        Fire an event to simulate the selection of an item.

    """

    def setUp(self):
        """ Setup before the combo box tests.

        """

        enaml = """
enamldef MainView(MainWindow):
    attr events
    ComboBox:
        name = 'cmb'
        items = [int, float, oct]
        value = float
        to_string = lambda x: str(x) + '!' if x is not None else ''
        selected :: events.append(('selected', event.new))
"""

        self.events = []
        self.view = self.parse_and_create(enaml, events=self.events)
        self.component = self.component_by_name(self.view, 'cmb')
        self.widget = self.component.toolkit_widget

    def test_initialization(self):
        """ Test the initial state.

        """
        component = self.component
        str_value = component.selected_text
        self.assertEqual(self.get_selected_text(self.widget), str_value)
        self.assertEqual(component.value, component.items[1])
        self.assertEqual(self.events, [])

    def test_items(self):
        """ Check that the Enaml combo box items match the toolkit widget.

        """
        component = self.component
        for i, item in enumerate(component.items):
            widget_text = self.get_item_text(self.widget, i)
            self.assertEqual(widget_text, component.to_string(item))

    def test_to_string(self):
        """ Update the ComboBox.to_string callable.

        """
        component = self.component
        component.to_string = lambda x: str(x) + '?'
        self.test_items()

    def test_selected_event(self):
        """ Fire an event for item selection.

        """
        self.select_item(self.widget, 2)
        self.assertEqual(self.events, [('selected', oct)])

    def test_change_selected_item(self):
        """ Update the visible item when a new one is selected internally.

        """
        component = self.component
        self.assertEqual(component.value, float)
        index = 2
        self.select_item(self.widget, index)
        self.assertEqual(component.value, oct)
        self.assertEqual(self.events, [('selected', oct)])

    def test_append_item(self):
        """ Add an item on the Enaml side; see if the toolkit widget 
        updates.

        """
        component = self.component
        component.items.append('hello')
        self.test_items()

    def test_remove_item(self):
        """ Remove an item on the Enaml side; see if the toolkit widget 
        updates.

        """
        component = self.component
        component.items.pop(0)
        self.test_items()

    def test_deselect(self):
        """ Assert that an invalid value sets the index to -1.

        """
        component = self.component
        component.value = hex
        self.assertTrue(component.value is hex)
        self.assertEqual(component.index, -1)

    def test_value_when_items_change(self):
        """ Assert that the selection moves correctly when the items 
        change.

        """
        component = self.component
        component.value = int
        self.assertEqual(component.value, int)
        self.assertEqual(component.index, 0)
        component.items.insert(0, hex)
        self.assertEqual(component.index, 1)
        self.assertEqual(self.events, [])

    def test_index_when_items_change(self):
        """ Assert that the index is -1 when the value is removed from 
        the items list.

        """
        component = self.component
        component.value = int
        component.items.pop(0)
        self.assertEqual(component.index, -1)
        self.assertEqual(self.events, [])

    #--------------------------------------------------------------------------
    # Abstract methods
    #--------------------------------------------------------------------------
    @required_method
    def get_selected_text(self, widget):
        """ Get the current selected text of a combo box.

        """
        pass

    @required_method
    def get_item_text(self, widget, index):
        """ Get the text of a combo box item at a particular index.

        """
        pass

    @required_method
    def select_item(self, widget, index):
        """ Fire an event to simulate the selection of an item.

        """
        pass


########NEW FILE########
__FILENAME__ = datetime_edit
#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from datetime import datetime as python_datetime

from traits.api import TraitError

from .enaml_test_case import EnamlTestCase, required_method


class TestDatetimeEdit(EnamlTestCase):
    """ Logic for testing the date time edit components.

    Tooklit testcases need to provide the following functions

    Abstract Methods
    ----------------
    get_datetime(self, widget)
        Get the toolkits widget's active datetime.

    get_min_datetime(self, widget)
        Get the toolkits widget's maximum datetime attribute.

    get_max_datetime(self, widget)
        Get the toolkits widget's minimum datetime attribute.

    change_datetime(self, widget, date)
        Simulate a change datetime action at the toolkit widget.

    get_datetime_as_string(self, widget)
        Get the toolkits widget's active datetime as a string.

    """

    def setUp(self):
        """ Set up for the TimeEdit testcases

        """

        enaml_source = """
from datetime import datetime as python_datetime
enamldef MainView(MainWindow):
    attr events
    DatetimeEdit:
        name = 'test'
        datetime = python_datetime(2001, 4, 3, 8, 45, 32, 23000)
        datetime_changed :: events.append(('datetime_changed', event.new))
"""

        self.default_datetime = python_datetime(2001, 4, 3, 8, 45, 32, 23000)
        self.events = []
        self.view = self.parse_and_create(enaml_source, events=self.events)
        self.component = self.component_by_name(self.view, 'test')
        self.widget = self.component.toolkit_widget

    def test_initialization_values(self):
        """ Test the initial attributes of the date edit component.

        """
        component = self.component

        self.assertEnamlInSync(component, 'datetime',
                               python_datetime(2001, 4, 3, 8, 45, 32, 23000))
        self.assertEnamlInSync(component, 'min_datetime',
                               python_datetime(1752,9,14,0,0,0,0))
        self.assertEnamlInSync(component, 'max_datetime',
                               python_datetime(7999, 12, 31, 23, 59, 59, 999000))
        self.assertEqual(self.events, [])

    def test_change_max_datetime(self):
        """ Test changing the maximum datetime.

        """
        component = self.component
        new_maximum = python_datetime(2005,1,1)
        component.max_datetime = new_maximum
        self.assertEnamlInSync(component, 'max_datetime', new_maximum)
        self.assertEqual(self.events, [])

    def test_change_min_datetime(self):
        """ Test changing the minimum datetime.

        """
        component = self.component
        new_minimum = python_datetime(2000,1,1)
        component.min_datetime = new_minimum
        self.assertEnamlInSync(component, 'min_datetime', new_minimum)
        self.assertEqual(self.events, [])

    def test_change_maximum_and_datetime(self):
        """ Test setting maximum while the datetime is out of range.

        """
        component = self.component
        component.datetime = python_datetime(2007,10,9)
        component.max_datetime = python_datetime(2006,5,9)
        self.assertEnamlInSync(component, 'datetime', python_datetime(2006,5,9))
        self.assertEqual(self.events, [])

    def test_change_minimum_and_datetime(self):
        """ Test setting minimum while the datetime is out of range.

        """
        component = self.component
        component.datetime = python_datetime(2007,10,9)
        component.min_datetime = python_datetime(2010,5,9)
        self.assertEnamlInSync(component, 'datetime', python_datetime(2010,5,9))
        self.assertEqual(self.events, [])

    def test_change_datetime_in_enaml(self):
        """ Test changing the current datetime through the component.

        """
        component = self.component
        new_datetime = python_datetime(2007,10,9)
        component.datetime = new_datetime
        self.assertEnamlInSync(component, 'datetime', new_datetime)
        self.assertEqual(self.events, [])

    def test_change_datetime_in_ui(self):
        """ Test changing the current datetime thought the ui

        """
        component = self.component
        widget = self.widget
        new_datetime = python_datetime(2007,10,9)
        self.change_datetime(widget, new_datetime)
        self.assertEnamlInSync(component, 'datetime', new_datetime)
        self.assertEqual(self.events, [('datetime_changed', new_datetime)])

    def test_invalid_min_datetime(self):
        """ Test changing to an invalid datetime below the min range.

        """
        component = self.component
        min_datetime = python_datetime(2000,2,3)
        component.min_datetime = min_datetime
        with self.assertRaises(TraitError):
            component.datetime = python_datetime(2000,1,1)
        self.assertEnamlInSync(component, 'datetime', self.default_datetime)

    def test_invalid_max_datetime(self):
        """ Test changing to an invalid datetime above the max range.

        """
        component = self.component
        init_datetime = python_datetime(2011,10,9)
        component.datetime = init_datetime
        self.assertEqual(self.events, [])
        max_datetime = python_datetime(2014,2,3)
        component.max_datetime = max_datetime
        with self.assertRaises(TraitError):
            component.datetime = python_datetime(2016,10,9)
        self.assertEnamlInSync(component, 'datetime', init_datetime)
        self.assertEqual(self.events, [])

    def test_set_format(self):
        """ Test setting the output format

        """
        component = self.component
        widget = self.widget
        component.datetime_format = 'MMM dd yyyy hh:mm'
        test_datetime = python_datetime(2007,10,9, 2, 34, 12,2000)
        component.datetime = test_datetime
        widget_string = self.get_datetime_as_string(widget)
        formated_date = unicode(test_datetime.strftime('%b %d %Y %H:%M'), encoding='utf-8')
        self.assertEqual(widget_string, formated_date)
        self.assertEqual(self.events, [])

    def test_change_range_invalid(self):
        """ Test setting minimum > maximum.

        """
        component = self.component
        component.min_datetime = python_datetime(2010,5,9)
        with self.assertRaises(TraitError):
            component.max_datetime = python_datetime(2006,5,9)

        component.max_datetime = python_datetime(2034,12,10)
        with self.assertRaises(TraitError):
            component.min_date = python_datetime(2034,12,14)

    #--------------------------------------------------------------------------
    # Special initialization tests
    #--------------------------------------------------------------------------
    def test_initial_too_early(self):
        """ Check initialization with an invalid early datetime is corrected.

        .. todo:: avoid using the enaml source

        """
        enaml_source = """
from datetime import datetime as python_datetime
enamldef MainView(MainWindow):
    attr events
    DatetimeEdit:
        name = 'test'
        datetime = python_datetime(1980, 1, 1, 23, 10, 34)
        min_datetime = python_datetime(1990, 1, 1)
        max_datetime = python_datetime(2000, 1, 1)
        datetime_changed :: events.append(('datetime_changed', event.new))
"""
        events = []
        with self.assertRaises(TraitError):
            self.parse_and_create(enaml_source, events=events)

    def test_initial_too_late(self):
        """ Check initialization with an invalid late datetime is corrected.

        .. todo:: avoid using the enaml source

        """
        enaml_source = """
from datetime import datetime as python_datetime
enamldef MainView(MainWindow):
    attr events
    DatetimeEdit:
        name = 'test'
        datetime = python_datetime(2010, 1, 1, 9, 12, 34, 14234)
        min_datetime = python_datetime(1990, 1, 1)
        max_datetime = python_datetime(2000, 1, 1)
        datetime_changed :: events.append(('datetime_changed', event.new))
"""
        events = []
        with self.assertRaises(TraitError):
            self.parse_and_create(enaml_source, events=events)

    #--------------------------------------------------------------------------
    # Abstract methods
    #--------------------------------------------------------------------------
    @required_method
    def get_datetime(self, widget):
        """  Get the toolkits widget's active datetime.

        """
        pass

    @required_method
    def get_min_datetime(self, widget):
        """  Get the toolkits widget's maximum datetime attribute.

        """
        pass

    @required_method
    def get_max_datetime(self, widget):
        """ Get the toolkits widget's minimum datetime attribute.

        """
        pass

    @required_method
    def change_datetime(self, widget, date):
        """ Simulate a change datetime action at the toolkit widget.

        """
        pass

    @required_method
    def get_datetime_as_string(self, widget):
        """  Get the toolkits widget's active datetime as a string.

        """
        pass


########NEW FILE########
__FILENAME__ = date_edit
#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from datetime import date

from traits.api import TraitError

from .enaml_test_case import EnamlTestCase, required_method


class TestDateEdit(EnamlTestCase):
    """ Logic for testing the date edit components.

    Tooklit testcases need to provide the following functions

    Abstract Methods
    ----------------
    get_date(self, widget)
        Get the toolkits widget's active date.

    get_min_date(self, widget)
        Get the toolkits widget's minimum date attribute.

    get_max_date(self, widget)
        Get the toolkits widget's maximum date attribute.

    change_date(self, widget, date)
        Simulate a change date action at the toolkit widget.

    get_date_as_string(self, widget)
        Get the toolkits widget's active date as a string.

    """

    def setUp(self):
        """ Set up before the date_edit tests

        """
        enaml_source = """
enamldef MainView(MainWindow):
    attr events
    DateEdit:
        name = 'test'
        date_changed :: events.append(('date_changed', event.new))
"""
        self.events = []
        self.view = self.parse_and_create(enaml_source, events=self.events)
        self.component = self.component_by_name(self.view, 'test')
        self.widget = self.component.toolkit_widget

    def test_initialization_values(self):
        """ Test the initial attributes of the date edit component.

        """
        component = self.component
        self.assertEnamlInSync(component, 'date', date.today())
        self.assertEnamlInSync(component, 'min_date', date(1752, 9, 14))
        self.assertEnamlInSync(component, 'max_date', date(7999, 12, 31))
        self.assertEqual(self.events, [])

    def test_change_min_date(self):
        """ Test changing the minimum date.

        """
        component = self.component
        new_minimum = date(2000,1,1)
        component.min_date = new_minimum
        self.assertEnamlInSync(component, 'min_date', new_minimum)

    def test_change_max_date(self):
        """ Test changing the maximum date.

        """
        component = self.component
        new_maximum = date(2005,1,1)
        component.max_date = new_maximum
        self.assertEnamlInSync(component, 'max_date', new_maximum)

    def test_change_date_in_enaml(self):
        """ Test changing the current date through the component.

        """
        component = self.component
        new_date = date(2007,10,9)
        component.date = new_date
        self.assertEnamlInSync(component, 'date', new_date)
        self.assertEqual(self.events, [])

    def test_change_date_in_ui(self):
        """ Test changing the current date through the ui.

        """
        component = self.component
        widget = self.widget
        new_date = date(2007,10,9)
        self.change_date(widget, new_date)
        self.assertEnamlInSync(component, 'date', new_date)
        self.assertEqual(self.events, [('date_changed', new_date)])

    def test_invalid_min_date(self):
        """ Test changing to an invalid date below the min range.

        """
        component = self.component
        min_date = date(2000,2,3)
        component.min_date = min_date
        with self.assertRaises(TraitError):
            component.date = date(2000,1,1)
        self.assertEnamlInSync(component, 'date', date.today())
        self.assertEqual(self.events, [])

    def test_invalid_max_date(self):
        """ Test changing to an invalid date above the max range.

        """
        component = self.component
        component.date = date(2011,10,9)
        self.assertEqual(self.events, [])
        max_date = date(2014,2,3)
        component.max_date = max_date
        with self.assertRaises(TraitError):
            component.date = date(2016,10,9)
        self.assertEnamlInSync(component, 'date', date(2011,10,9))
        self.assertEqual(self.events, [])

    def test_change_maximum_and_date(self):
        """ Test setting maximum while the date is out of range.

        """
        component = self.component
        component.date = date(2007,10,9)
        component.max_date = date(2006,5,9)
        self.assertEnamlInSync(component, 'date', date(2006,5,9))
        self.assertEqual(self.events, [])

    def test_change_minimum_and_date(self):
        """ Test setting minimum while the date is out of range.

        """
        component = self.component
        component.date = date(2007,10,9)
        component.min_date = date(2010,5,9)
        self.assertEnamlInSync(component, 'date', date(2010,5,9))
        self.assertEqual(self.events, [])

    def test_change_range_invalid(self):
        """ Test setting minimum > maximum.

        """
        component = self.component
        component.min_date = date(2010,5,9)
        with self.assertRaises(TraitError):
            component.max_date = date(2006,5,9)

        component.max_date = date(2034,12,10)
        with self.assertRaises(TraitError):
            component.min_date = date(2034,12,14)

    def test_set_format(self):
        """ Test setting the output format

        """
        component = self.component
        widget = self.widget
        test_date = date(2007,10,9)
        component.date_format = 'MMM dd yyyy'
        component.date = date(2007,10,9)
        widget_string = self.get_date_as_string(widget)
        formated_date = unicode(test_date.strftime('%b %d %Y'), encoding='utf-8')
        self.assertEqual(widget_string, formated_date)

    #--------------------------------------------------------------------------
    # Special initialization tests
    #--------------------------------------------------------------------------
    def test_initial_too_late(self):
        """ Check initialization with an invalid late date.

        """
        enaml_source = """
import datetime
enamldef MainView(MainWindow):
    attr events
    DateEdit:
        name = 'test'
        date = datetime.date(2010, 1, 1)
        min_date = datetime.date(1990, 1, 1)
        max_date = datetime.date(2000, 1, 1)
        date_changed :: events.append('date_changed')
"""
        events = []
        # FIXME: need make a more refined check, this is not the best way
        with self.assertRaises(TraitError):
            self.parse_and_create(enaml_source, events=events)

    def test_initial_too_early(self):
        """ Check initialization with an invalid early date.

        """
        enaml_source = """
import datetime
enamldef MainView(MainWindow):
    attr events
    DateEdit:
        name = 'test'
        min_date = datetime.date(1990, 1, 1)
        max_date = datetime.date(2000, 1, 1)
        date = datetime.date(1980, 1, 1)
        date_changed :: events.append('date_changed')
"""
        events = []
        # FIXME: need make a more refined check, this is not the best way
        with self.assertRaises(TraitError):
            self.parse_and_create(enaml_source, events=events)

    #--------------------------------------------------------------------------
    # Abstract methods
    #--------------------------------------------------------------------------
    @required_method
    def get_date(self, widget):
        """  Get the toolkits widget's active date.

        """
        pass

    @required_method
    def get_min_date(self, widget):
        """  Get the toolkits widget's maximum date attribute.

        """
        pass

    @required_method
    def get_max_date(self, widget):
        """ Get the toolkits widget's minimum date attribute.

        """
        pass

    @required_method
    def change_date(self, widget, date):
        """ Simulate a change date action at the toolkit widget.

        """
        pass

    @required_method
    def get_date_as_string(self, widget):
        """  Get the toolkits widget's active date as a string.

        """
        pass


########NEW FILE########
__FILENAME__ = dialog
#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from .enaml_test_case import required_method
from .window import TestWindow


def skip_test(func):
    def closure(self, *args, **kwargs):
        self.skipTest('Skipped')
    return closure


class TestDialog(TestWindow):
    """ Logic for testing Dialogs.

    """

    def setUp(self):
        """ Set up Dialog tests.

        """

        enaml_source = """
enamldef MainView(Dialog):
    name = 'dialog'
    title = 'foo'
"""

        self.view = self.parse_and_create(enaml_source)
        self.component = self.component_by_name(self.view, 'dialog')
        self.widget = self.component.toolkit_widget
        # Don't actually show the dialog.
        self.disable_showing(self.widget)
        # (trait_name, value) log of all trait change events on the Dialog.
        self.event_log = []
        self.component.on_trait_change(self._append_event_handler, 'anytrait')

    def test_initial_active(self):
        """ Test the initial value of the active flag on the Dialog.

        """
        self.assertEquals(self.component.active, False)
    
    def test_result_value(self):
        """ Test the modification of the result value.

        """
        self.assertEquals(self.component.result, 'rejected')
        self.component.accept()
        self.assertEquals(self.component.result, 'accepted')
        self.component.reject()
        self.assertEquals(self.component.result, 'rejected')

    def test_show_close(self):
        """ Test the behavior when showing and closing the dialog.

        """
        self.component.abstract_obj.set_visible(True)
        # Compare sets because the order is unimportant.
        self.assertEquals(set(self.event_log), set([
            ('active', True),
            ('_active', True),
            ('opened', None),
        ]))
        self.event_log = []
        self.component.accept()
        self.assertEquals(set(self.event_log), set([
            ('active', False),
            ('_active', False),
            ('result', 'accepted'),
            ('_result', 'accepted'),
            ('closed', 'accepted'),
        ]))
        self.event_log = []
        self.component.abstract_obj.set_visible(True)
        self.assertEquals(set(self.event_log), set([
            ('active', True),
            ('_active', True),
            ('opened', None),
        ]))
        self.event_log = []
        self.component.reject()
        self.assertEquals(set(self.event_log), set([
            ('active', False),
            ('_active', False),
            ('result', 'rejected'),
            ('_result', 'rejected'),
            ('closed', 'rejected')
        ]))

    @required_method
    def disable_showing(self, widget):
        """ Disable the actual display of the dialog window.

        """
        pass

    def _append_event_handler(self, object, name, old, new):
        """ Append the trait change notification to the event log.

        """
        # XXX this test is fragile since it's collected all trait 
        # change events. Hence we need to filter out certain things
        # we don't care about. FIX THIS TEST!!!!!
        if name == '_relayout_pending':
            return
        self.event_log.append((name, new))


########NEW FILE########
__FILENAME__ = enaml_test_case
#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
import unittest
import inspect
import types

from enaml import default_toolkit
from enaml.core.parser import parse
from enaml.core.enaml_compiler import EnamlCompiler


def required_method(function_object):
    """ Decorator for required methods.

    The decorator wraps an *empty* method to raise an NotImplementedError
    with an appropriate error message.

    """
    def proxy_function(self, *args, **kwargs):
        function_name = function_object.__name__
        msg = ("Method '{0}' needs to be implemented for the '{1}' test case".\
                format(function_name, self))
        raise NotImplementedError(msg)
    return proxy_function


class EnamlTestCase(unittest.TestCase):
    """ Base class for testing Enaml object widgets.

    This class provide utility methods and assertion functions to help
    the testing of enaml components

    """
    # default toolkit to use for the enaml source parsing
    toolkit = default_toolkit()

    def component_by_name(self, component, name):
        """ Find an item in the view with a given name. The component
        should have the name set its 'name' attribute.

        Arguments
        ---------
        component : BaseComponent
            The enaml based BaseComponent object.

        name : str
            The name of the enaml component to find in the tree.

        Returns
        -------
            The corresponding component or None.

        """
        return component.find_by_name(name)

    def parse_and_create(self, source, **kwargs):
        """ Parses and compiles the source. The source should have a
        component defined with the name 'MainView'. 

        Arguments
        ---------
        source : str
            The enaml source file

        kwargs : dict
            The default attribute values to pass to the component.

        """
        enaml_ast = parse(source)
        enaml_module = types.ModuleType('__tests__')
        ns = enaml_module.__dict__
        code = EnamlCompiler.compile(enaml_ast, '__enaml_tests__')

        toolkit = self.toolkit

        with toolkit:
            exec code in ns
            view = ns['MainView']
            cmpnt = view(**kwargs)

        toolkit.app.initialize()
        self.app = toolkit.app.app_object()
        cmpnt.setup()
        return cmpnt

    def assertEnamlInSync(self, component, attribute_name, value):
        """ Verify that the requested attribute is properly set

        The method compares the attribute value in the Enaml object and
        check if it is synchronized with the toolkit widget. The component
        attribute is retrieved directly while the widget value is retrieved
        through a call to a method function in the test case.

        Arguments
        ---------
        component : enaml.widgets.component.Component
            The Enaml component to check.

        attribute_name : str
            The string name of the Enaml attribute to check.

        value :
            The expected value.

        .. note:: It is expected that the user has defined an appropriate
            method get_<attribute_name>(widget) or the extentded version
            get_<attribute_name>(component, widget) in the current test
            case. The extended signature is commonly used because additional
            information on the component's attributes is required to return
            a sensible result (e.g. the component uses Converters to set
            and retrieve the value of the attribute). The assert method
            The get methods can raise assertion errors when it is not
            possible to retrieve a sensible value for the attribute.

        """
        widget = component.toolkit_widget
        enaml_value = getattr(component, attribute_name)
        widget_method = getattr(self, 'get_' + attribute_name)

        try:
            inspect.getcallargs(widget_method, widget)
        except TypeError:
            widget_value = widget_method(component, widget)
        else:
            widget_value = widget_method(widget)

        self.assertEqual(value, enaml_value)
        self.assertEqual(value, widget_value)


########NEW FILE########
__FILENAME__ = field
#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from traits.api import push_exception_handler, pop_exception_handler

from enaml.validation import IntValidator

from .enaml_test_case import EnamlTestCase, required_method


class TestField(EnamlTestCase):
    """ Logic for testing fields.

    Tooklit testcases need to provide the following methods:

    Abstract Methods
    ----------------

    """

    def setUp(self):
        """ Set up tests for Enaml's Field widget.

        """

        enaml_source = """
enamldef MainView(MainWindow):
    attr events
    Field:
        name = 'field'
        max_length = 8
        cursor_position = 1
        placeholder_text = 'hold'
        value = 'abc'
        text_edited :: events.append('text_edited')
        return_pressed :: events.append('return_pressed')
"""

        self.events = []
        self.view = self.parse_and_create(enaml_source, events=self.events)
        self.component = self.component_by_name(self.view, 'field')
        self.gain_focus_if_needed(self.widget)

    @property
    def widget(self):
        """ Get the widget of the main component.

        The property getter is necessary because the internal widget of
        the component might change (see WXField).

        """
        return self.component.toolkit_widget

    def test_value(self):
        """ Test the toolkit widget's initial state.

        """
        self.assertEqual(self.component.value, self.get_value(self.widget))
        self.assertEnamlInSync(self.component, 'value', u'abc')

    def test_edit_text(self):
        """ Simulate typing into a field.

        """
        self.set_cursor_position(self.widget, 1)
        self.edit_text(self.widget, u'!?')
        self.component.submit()
        self.assertEnamlInSync(self.component, 'value', u'a!?bc')

    def test_send_twice(self):
        """ Type text, then type more text.

        """
        self.set_cursor_position(self.widget, 1)
        self.edit_text(self.widget, u'!?')
        self.edit_text(self.widget, u'zz')
        self.component.submit()
        self.assertEnamlInSync(self.component, 'value', u'a!?zzbc')

    def test_position_cursor(self):
        """ Position the cursor before typing.

        """
        self.set_cursor_position(self.widget, 0)
        self.edit_text(self.widget, u'xyz')
        self.component.submit()
        self.assertEqual(self.get_value(self.widget), u'xyzabc')

    def test_enaml_text_changed(self):
        """ Check that the widget reflects changes to the Enaml component.

        """
        self.component.value = u'test'
        self.assertEqual(self.get_value(self.widget), u'test')

    def test_password_mode_silent(self):
        """ Test the password_mode status.

        """
        component = self.component
        component.password_mode = 'silent'
        self.assertEnamlInSync(component, 'password_mode', 'silent')

    def test_password_mode_password(self):
        """ Test the password_mode status.

        """
        component = self.component
        component.password_mode = 'password'
        self.assertEnamlInSync(component, 'password_mode', 'password')

    def test_password_mode_normal(self):
        """ Test the password_mode status.

        """
        component = self.component
        self.assertEnamlInSync(component, 'password_mode', 'normal')
        component.password_mode = 'password' # switch to something else
        component.password_mode = 'normal'
        self.assertEnamlInSync(component, 'password_mode', 'normal')

    def test_max_length(self):
        """ Check that the field enforces its maximum length.

        """
        max_len = self.component.max_length
        self.edit_text(self.widget, u'a' * (max_len + 1))
        self.component.submit()
        self.assertEqual(len(self.component.value), max_len)

    def test_component_set_selection(self):
        """ Check the Enaml component's text selection feature.

        """
        self.component.value = u'text'
        self.component.set_selection(1, 3)
        self.assertEqual(self.component.selected_text, u'ex')

    def test_format(self):
        """ Test the validators formatting.

        """
        self.component.value = 64
        self.component.validator = IntValidator()
        self.assertEqual(self.get_value(self.widget), u'64')

    def test_convert(self):
        """ Test the validators conversion.

        """
        self.component.value = 0
        self.component.validator = IntValidator()
        self.component.clear()
        self.edit_text(self.widget, u'123')
        self.component.submit()
        self.assertEqual(self.component.value, 123)

    def test_validator_change(self):
        """ Check that changing a validator works properly.

        """
        output = [False]
        def handler(obj, name, old, new):
            output[0] = True
        push_exception_handler(handler)
        old = self.component.validator
        self.component.validator = IntValidator()
        self.component.validator = old
        pop_exception_handler()
        self.assertTrue(output[0])

    def test_acceptable(self):
        """ Check that validation properly sets the 'acceptable' attribute.

        """
        self.assertTrue(self.component.acceptable)
        self.component.value = 0
        self.component.validator = IntValidator(low=10, high=150)
        self.assertFalse(self.component.acceptable)
        self.component.clear()
        self.edit_text(self.widget, '100')
        self.assertTrue(self.component.acceptable)
        self.component.clear()
        self.edit_text(self.widget, '5')
        self.assertFalse(self.component.acceptable)

    def test_change_text(self):
        """ Change text programmatically, as opposed to editing it.

        """
        self.change_text(self.widget, 'text')
        self.assertEqual(self.events, [])

    def test_press_return(self):
        """ Simulate a press of the 'Return' key.

        """
        self.press_return(self.widget)
        self.assertEqual(self.events, ['return_pressed'])

    #--------------------------------------------------------------------------
    # Test toolkit implementation class's methods
    #--------------------------------------------------------------------------
    def test_select_all(self):
        """ Select all text in a field.

        """
        self.component.select_all()
        self.assertEnamlInSync(self.component, 'selected_text', u'abc')

    def test_deselect(self):
        """ De-select text in a field.

        """
        self.component.select_all()
        self.component.deselect()
        self.assertEnamlInSync(self.component, 'selected_text', u'')

    def test_clear(self):
        """ Clear all text from the field.

        """
        self.component.clear()
        self.assertEqual(self.get_value(self.widget), u'')

    def test_backspace(self):
        """ Test the field's "backspace" method.

        """
        self.set_cursor_position(self.widget, 2)
        self.component.backspace()
        self.assertEqual(self.get_value(self.widget), u'ac')
        self.assertEnamlInSync(self.component, 'cursor_position', 1)

    def test_delete(self):
        """ Test the field's "delete" method.

        """
        self.set_cursor_position(self.widget, 2)
        self.component.delete()
        self.assertEqual(self.get_value(self.widget), u'ab')
        self.assertEnamlInSync(self.component, 'cursor_position', 2)

    def test_end(self, mark=False):
        """ Move the cursor to the end of the field.

        """
        # For some reason, the Qt cursor is getting internally 
        # reset to the end without emitting a signal. I gave up
        # debugging it after 1.5 hours. For now, just trigger 
        # an explicit change. It will probably never show up 
        # as a problem in practice since as soon as you click
        # in the field, the cursor will change. - SCC
        self.component.home()
        self.component.end()
        self.assertEnamlInSync(self.component, 'cursor_position', 3)

    def test_home(self, mark=False):
        """ Move the cursor to the beginning of the field.

        """
        self.component.home()
        self.assertEnamlInSync(self.component, 'cursor_position', 0)

    def test_cut(self):
        """ Remove selected text and add it to the clipboard.

        """
        self.component.set_selection(1, 3)
        self.component.cut()
        self.assertEqual(self.get_value(self.widget), u'a')

    def test_copy_paste(self):
        """ Copy text, then paste it at the beginning of the field.

        """
        self.component.set_selection(1, 2)
        self.component.copy()
        self.set_cursor_position(self.widget, 0)
        self.component.paste()
        self.assertEqual(self.get_value(self.widget), u'babc')

    def test_cut_paste(self):
        """ Cut text, then paste it at the beginning of the field.

        """
        self.component.set_selection(1, 2)
        self.component.cut()
        self.set_cursor_position(self.widget, 0)
        self.component.paste()
        self.assertEqual(self.get_value(self.widget), u'bac')

    def test_insert(self):
        """ Insert text into the field.

        """
        self.set_cursor_position(self.widget, 2)
        self.component.insert('foo')
        self.assertEqual(self.get_value(self.widget), u'abfooc')

    def test_undo_delete(self):
        """ Undo a deletion.

        """
        self.set_cursor_position(self.widget, 1)
        self.component.delete()
        self.assertEqual(self.get_value(self.widget), u'ac')
        self.component.undo()
        self.assertEqual(self.get_value(self.widget), u'abc')

    def test_undo_insert(self):
        """ Undo text insertion.

        """
        self.set_cursor_position(self.widget, 1)
        self.component.insert('bar')
        self.assertEqual(self.get_value(self.widget), u'abarbc')
        self.component.undo()
        self.assertEqual(self.get_value(self.widget), u'abc')

    def test_redo_delete(self):
        """ Redo, after undoing a deletion.

        """
        self.test_undo_delete()
        self.component.redo()
        self.assertEqual(self.get_value(self.widget), u'ac')

    def test_redo_insertion(self):
        """ Redo, after undoing an insertion.

        """
        self.test_undo_insert()
        self.component.redo()
        self.assertEqual(self.get_value(self.widget), u'abarbc')

    #--------------------------------------------------------------------------
    # Abstract methods
    #--------------------------------------------------------------------------
    @required_method
    def get_value(self, widget):
        """ Get the visible text of a field.

        """
        pass

    @required_method
    def get_password_mode(self, widget):
        """ Get the password_mode status.

        """
        pass

    @required_method
    def edit_text(self, widget, text):
        """ Simulate typing in a field.

        """
        pass

    @required_method
    def change_text(self, widget, text):
        """ Change text programmatically, rather than "editing" it.

        """
        pass

    @required_method
    def set_cursor_position(self, widget, index):
        """ Set the cursor at a specific position.

        """
        pass

    @required_method
    def get_cursor_position(self, widget):
        """ Get the cursor position.

        """
        pass

    @required_method
    def get_selected_text(self, widget):
        """ Get the currently-selected text from a field.

        """
        pass

    @required_method
    def press_return(self, widget):
        """ Simulate a press of the 'Return' key.

        """
        pass

    @required_method
    def gain_focus_if_needed(self, widget):
        """ Have the widget gain focus if required for the tests.

        """
        pass


########NEW FILE########
__FILENAME__ = group_box
#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from traits.api import TraitError

from .enaml_test_case import EnamlTestCase, required_method


class TestGroupBox(EnamlTestCase):
    """ Logic for testing labels.

    Tooklit testcases need to provide the following methods:

    Abstract Methods
    ----------------
    get_title
        Returns the group title from the tookit widget

    get_flat
        Returns the flat border style from the tookit widget

    get_title_align
        Returns the title align style from the tookit widget

    Notes
    -----
    All the provided methods need to support the extented signature
    <method>(component, widget).

    """
    def setUp(self):
        """ Set up label tests.

        """
        enaml_source = """
enamldef MainView(MainWindow):
    name = 'win'
    Container:
        constraints = [horizontal(left, gb, right), vertical(top, gb, bottom),
                       vertical(label1, label2), align('left', label1, label2)]
        GroupBox:
            id: gb
            name = 'gb'
            title = 'MyGroup'
            flat = True
            title_align = 'center'
            Label:
                id: label1
                text = 'foofoofoofoofoofoofoofoofoofoofoofoo'
            Label:
                id: label2
                text = 'barbarbarbarbarbarbarbarbarbar'
"""
        self.view = self.parse_and_create(enaml_source)
        self.component = self.component_by_name(self.view, 'gb')
        self.widget = self.component.toolkit_widget

    def test_initialization(self):
        """ Test initialization

        Test that the atrributes of the GroupBox have the
        correct values and these values are insync with the information
        in the toolkit widget.

        """
        component = self.component
        self.assertEnamlInSync(component, 'title', 'MyGroup')
        self.assertEnamlInSync(component, 'flat', True)
        self.assertEnamlInSync(component, 'title_align', 'center')

    # This is an expected failure on Qt since the call later event
    # do not get process without the event loop running.
    def test_title_changed(self):
        """ Change the title text of the GroupBox.

        """
        component = self.component
        component.title = "New title"
        self.assertEnamlInSync(component, 'title', 'New title')

    # This is an expected failure on Qt since the call later event
    # do not get process without the event loop running.
    def test_flat_style_changed(self):
        """ Change the flat style border of the GroupBox.

        """
        component = self.component
        component.flat = False
        self.assertEnamlInSync(component, 'flat', False)

    def test_title_align_changed(self):
        """ Change the title alignment.

        """
        component = self.component
        component.title_align = 'right'
        self.assertEnamlInSync(component, 'title_align', 'right')
        component.title_align = 'left'
        self.assertEnamlInSync(component, 'title_align', 'left')
        component.title_align = 'center'
        self.assertEnamlInSync(component, 'title_align', 'center')

    def test_invalid_alignment(self):
        """ Change the title alignment to an invalid value.

        """
        component = self.component
        with self.assertRaises(TraitError):
            component.title_align = 'almost center'
        self.assertEnamlInSync(component, 'title_align', 'center')

    #--------------------------------------------------------------------------
    # Abstract methods
    #--------------------------------------------------------------------------
    @required_method
    def get_title(self, widget):
        """ Returns the title text from the tookit widget

        """
        pass

    @required_method
    def get_flat(self, widget):
        """ Returns the flat style status from the tookit widget

        """
        pass

    @required_method
    def get_title_align(self, widget):
        """ Returns the title aligment in the tookit widget

        """
        pass


########NEW FILE########
__FILENAME__ = html
#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from .enaml_test_case import EnamlTestCase, required_method


class TestHtml(EnamlTestCase):
    """ Logic for testing Html widgets.

    The toolkits return HTML as plain text, so we do not compare formatting.
    Tooklit testcases need to provide the following methods

    Abstract Methods
    ----------------
    get_source(self, widget)
        Get the source of an Html widget.

    """
    text = 'That is a bold claim.'

    def setUp(self):
        """ Set up before the Html tests.

        """
        enaml_source = """
enamldef MainView(MainWindow):
    Html:
        name = 'html'
        source = '<b>{0}</b>'
""".format(self.text)

        self.view = self.parse_and_create(enaml_source)
        self.component = self.component_by_name(self.view, 'html')
        self.widget = self.component.toolkit_widget

    def test_initial_source(self):
        """ Test the initial source of an Html widget.

        """
        widget_source = self.get_source(self.widget)
        self.assertEqual(widget_source, self.text)

    def test_source_changed(self):
        """ Change the source of an Html widget.

        """
        new_text = 'Underlined'
        new_source = '<u>{0}</u>'.format(new_text)
        self.component.source = new_source
        widget_source = self.get_source(self.widget)
        self.assertEqual(widget_source, new_text)

    #--------------------------------------------------------------------------
    # Abstract methods
    #--------------------------------------------------------------------------
    @required_method
    def get_source(self, widget):
        """ Get the source of an Html widget.

        """
        pass


########NEW FILE########
__FILENAME__ = label
#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from .enaml_test_case import EnamlTestCase, required_method


class TestLabel(EnamlTestCase):
    """ Logic for testing labels.

    Tooklit testcases need to provide the following methods

    Abstract Methods
    ----------------
    get_text()
        Returns the label text from the tookit widget

    """

    def setUp(self):
        """ Set up label tests.

        """

        enaml_source = """
enamldef MainView(MainWindow):
    Label:
        name = 'label'
        text = 'foo'
"""

        self.view = self.parse_and_create(enaml_source)
        self.component = self.component_by_name(self.view, 'label')
        self.widget = self.component.toolkit_widget

    def test_initial_text(self):
        """ Test the initial text of a label.

        """
        self.assertEnamlInSync(self.component, 'text', 'foo')

    def test_text_changed(self):
        """ Change the text of the label.

        """

        self.component.text = 'bar'
        self.assertEnamlInSync(self.component, 'text', 'bar')

    #--------------------------------------------------------------------------
    # Abstract methods
    #--------------------------------------------------------------------------
    @required_method
    def get_text(self, widget):
        """ Returns the label text from the tookit widget

        """
        pass


########NEW FILE########
__FILENAME__ = operators
#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from .enaml_test_case import EnamlTestCase, required_method


class TestLessLess(EnamlTestCase):
    """ Generic testcases for enaml the LessLess operator.

    These testcases test the basic functionality of widgets interacting
    with each other.

    To run these tests for a specific back-end it is required to have
    a functional implementation of the following wigdets:
        - Window
        - CheckBox
        - Label

    Abstract Methods
    ----------------
    get_text(widget)
        Returns the text from the tookit widget of a Label.

    get_checked(widget)
        Return the checked status of a CheckBox.

    """
    def setUp(self):
        enaml_source = """
enamldef MainView(MainWindow):
    Container:
        Label:
            name = 'lb'
            text << 'CheckBox is {0}'.format(cb.checked)
        CheckBox:
            id: cb
            name = 'cb'
            text = 'Should be checked'
            checked = True
"""
        self.view = self.parse_and_create(enaml_source)
        self.label = self.component_by_name(self.view, 'lb')
        self.check_box = self.component_by_name(self.view, 'cb')
        self.label_widget = self.label.toolkit_widget
        self.check_box_widget = self.check_box.toolkit_widget

    def test_lessless_init(self):
        """ Test the value after initialization

        """
        label = self.label
        check_box = self.check_box
        self.assertEnamlInSync(check_box, 'checked', True)
        self.assertEnamlInSync(label, 'text', 'CheckBox is True')

    def test_lessless_update(self):
        """ Test the value after initialization

        """
        label = self.label
        check_box = self.check_box
        check_box.checked = False
        self.assertEnamlInSync(label, 'text', 'CheckBox is False')
        self.assertEnamlInSync(check_box, 'checked', False)

    #--------------------------------------------------------------------------
    # Abstract methods
    #--------------------------------------------------------------------------
    @required_method
    def get_text(self, widget):
        """ Returns the label text from the tookit widget of Label.

        """
        pass

    @required_method
    def get_checked(self, widget):
        """ Returns the label text from the tookit widget of CheckBox.

        """
        pass


########NEW FILE########
__FILENAME__ = progress_bar
#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from traits.api import TraitError

from .enaml_test_case import EnamlTestCase, required_method


class TestProgressBar(EnamlTestCase):
    """ Logic for testing the ProgressBar.

    Tooklit testcases need to provide the following functions

    Abstract Methods
    ----------------
    get_value(self, widget)
        Get the toolkits widget's active value.

    get_minimum(self, widget)
        Get the toolkits widget's minimum value.

    get_maximum(self, widget)
        Get the toolkits widget's maximum value.

    """

    def setUp(self):
        """ Set up before the ProgressBar tests.

        """

        enaml = """
enamldef MainView(MainWindow):
    ProgressBar:
        name = 'test'
"""

        self.view = self.parse_and_create(enaml)
        self.component = self.component_by_name(self.view, 'test')
        self.widget = self.component.toolkit_widget

    def test_initialization_values(self):
        """ Test the initial attributes of the ProgressBar component.

        """
        component = self.component

        self.assertEnamlInSync(component, 'value', 0)
        self.assertEnamlInSync(component, 'minimum', 0)
        self.assertEnamlInSync(component, 'maximum', 100)

    def test_change_minimum(self):
        """ Test changing the minimum value.

        """
        component = self.component
        new_minimum = 10
        component.minimum = new_minimum
        self.assertEnamlInSync(component, 'minimum', new_minimum)

    def test_change_maximum(self):
        """ Test changing the maximum value.

        """
        component = self.component
        new_maximum = 90
        component.maximum = new_maximum
        self.assertEnamlInSync(component, 'maximum', new_maximum)

    def test_change_value_in_enaml(self):
        """ Test changing the current value through the component.

        """
        component = self.component
        new_value = 10
        component.value = new_value
        self.assertEnamlInSync(component, 'value', new_value)

    def test_invalid_minimum(self):
        """ Test changing to an invalid value below the minimum.

        """
        component = self.component
        with self.assertRaises(TraitError):
            component.value = -10
        self.assertEnamlInSync(component, 'value', 0)

    def test_invalid_maximum(self):
        """ Test changing to an invalid value above the maximum.

        """
        component = self.component
        with self.assertRaises(TraitError):
            component.value = 110
        self.assertEnamlInSync(component, 'value', 0)

    def test_change_maximum_and_value(self):
        """ Test setting maximum while the value is out of range.

        """
        component = self.component
        component.value = 90
        component.maximum = 80
        self.assertEnamlInSync(component, 'value', 80)

    def test_change_minimum_and_value(self):
        """ Test setting minimum while the value is out of range.

        """
        component = self.component
        component.minimum = 10
        self.assertEnamlInSync(component, 'value', 10)

    def test_change_range_invalid(self):
        """ Test setting minimum > maximum.

        """
        component = self.component
        with self.assertRaises(TraitError):
            component.maximum = -10

        with self.assertRaises(TraitError):
            component.minimum = 110

    #--------------------------------------------------------------------------
    # Special initialization tests
    #--------------------------------------------------------------------------
    def test_initial_too_large(self):
        """ Check initialization with a value too large for the specified
        maximum.

        """
        enaml = """
enamldef MainView(MainWindow):
    ProgressBar:
        name = 'test'
        value = 95
        minimum = 10
        maximum = 90
"""
        # FIXME: need make a more refined check, this is not the best way
        with self.assertRaises(TraitError):
            self.parse_and_create(enaml)

    def test_initial_too_small(self):
        """ Check initialization with a value too small for the specified
        minimum.

        """

        enaml = """
enamldef MainView(MainWindow):
    ProgressBar:
        name = 'test'
        value = 5
        minimum = 10
        maximum = 90
"""

        # FIXME: need make a more refined check, this is not the best way
        with self.assertRaises(TraitError):
            self.parse_and_create(enaml)

    def test_percentage(self):
        """ Test that the percentage is computed accurately.

        """
        self.component.maximum = 1000
        self.component.value = 999
        # Note the rounding down to 99%.
        self.assertEquals(self.component.percentage, 99)
        self.component.value = 1000
        self.assertEquals(self.component.percentage, 100)
        self.component.value = 899
        # Note the rounding to the nearest integer.
        self.assertEquals(self.component.percentage, 90)
        self.component.value = 0
        self.component.maximum = 0
        self.assertEquals(self.component.percentage, 0)
        self.component.minimum = -1000
        self.assertEquals(self.component.percentage, 100)
        self.component.value = -1
        self.assertEquals(self.component.percentage, 99)

    #--------------------------------------------------------------------------
    # Abstract methods
    #--------------------------------------------------------------------------
    @required_method
    def get_value(self, widget):
        """  Get the toolkits widget's active value.

        """
        pass

    @required_method
    def get_minimum(self, widget):
        """  Get the toolkits widget's maximum value attribute.

        """
        pass

    @required_method
    def get_maximum(self, widget):
        """ Get the toolkits widget's minimum value attribute.

        """
        pass


########NEW FILE########
__FILENAME__ = push_button
#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from .enaml_test_case import EnamlTestCase, required_method


class TestPushButton(EnamlTestCase):
    """ Logic for testing push buttons.

    Tooklit testcases need to provide the following methods

    Abstract Methods
    ----------------
    button_pressed(self)
        Press the button programmatically.

    button_released(self)
        Release the button programmatically.

    button_clicked(self)
        Click the button programmatically.

    """

    def setUp(self):
        """ Set up before push button tests.

        """

        enaml_source = """
enamldef MainView(MainWindow):
    attr events
    PushButton:
        name = 'pb1'
        text = 'foo'
        clicked :: events.append('clicked')
        pressed :: events.append('pressed')
        released :: events.append('released')
"""

        self.events = []
        self.view = self.parse_and_create(enaml_source, events=self.events)
        self.component = self.component_by_name(self.view, 'pb1')
        self.widget = self.component.toolkit_widget

    def test_button_pressed(self):
        """ React to a push button press event.

        """
        self.button_pressed()

        events = self.events
        self.assertTrue(self.component.down)
        self.assertIn('pressed', events)
        self.assertNotIn('released', events)
        self.assertNotIn('clicked', events)

    def test_button_clicked(self):
        """ Test a push button click event.

        """
        self.button_clicked()

        events = self.events
        self.assertIn('clicked', events)
        self.assertNotIn('pressed', events)
        self.assertNotIn('released', events)

    def test_button_released(self):
        """ Test a push button release event.

        """
        events = self.events
        # Release events are ignored if the button weas not already down
        self.button_released()
        self.assertEqual(events, [])

    def test_press_release_sequence(self):
        """ Verify the even firing when the press-release (nornal) sequence
        is applied.

        """
        events = self.events

        self.button_pressed()
        self.assertTrue(self.component.down)
        self.button_released()
        self.assertFalse(self.component.down)
        self.assertEqual(events.count('pressed'), 1)
        self.assertEqual(events.count('released'), 1)
        self.assertNotIn('clicked', events)

    def test_button_all_events(self):
        """ Test press, release, and click events.

        """
        self.button_pressed()
        self.button_released()
        self.button_clicked()

        events = self.events
        self.assertEqual(events.count('clicked'), 1)
        self.assertEqual(events.count('pressed'), 1)
        self.assertEqual(events.count('released'), 1)

    def test_button_down(self):
        """ Test the button's `down` attribute.

        """
        component = self.component

        self.assertFalse(component.down)
        self.button_pressed()
        self.assertTrue(component.down)
        self.button_released()
        self.assertFalse(component.down)

    #--------------------------------------------------------------------------
    # Abstract methods
    #--------------------------------------------------------------------------
    @required_method
    def button_pressed(self):
        """ Press the button programmatically.

        """
        pass

    @required_method
    def button_released(self):
        """ Release the button programmatically.

        """
        pass

    @required_method
    def button_clicked(self):
        """ Click the button programmatically.

        """
        pass


########NEW FILE########
__FILENAME__ = qt_test_assistant
#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from enaml import qt_toolkit


class QtTestAssistant(object):
    """ Assistant class for testing wx based components.

    This class is to be used as a mixing with the base enaml test case
    class for the components tests of the qt backend. It sets the correct
    toolkit attribute and (in the future) provide some useful methods for
    testin Qt based components.

    """

    toolkit = qt_toolkit()


########NEW FILE########
__FILENAME__ = test_qt_application
import contextlib
import cStringIO
import sys
import threading
import time
import unittest

import enaml


@contextlib.contextmanager
def redirect_stderr(new_stderr=None):
    """
    Context manager to temporarily redirect stderr output
    to another source.  If given, 'new_stderr' should be a file-like object.

    """
    if new_stderr is None:
        new_stderr = cStringIO.StringIO()
    old_stderr = sys.stderr
    sys.stderr = new_stderr
    try:
        yield new_stderr
    finally:
        sys.stderr = old_stderr


class TestQtApplication(unittest.TestCase):
    def test_exceptions_in_scheduled_tasks(self):

        success = threading.Event()

        def on_success(app):
            success.set()
            app._qt_app.exit()

        def on_failure(app):
            app._qt_app.exit()

        def main(app):
            time.sleep(0.5)
            for _ in xrange(10):
                app.schedule(lambda: 1/0)
            time.sleep(0.5)
            app.schedule(on_success, (app,))

        app = enaml.default_toolkit().app
        app.initialize()

        # Ensure we eventually exit the UI mainloop even if the test fails.
        app.timer(10000, on_failure, app)
        t = threading.Thread(target=main, args=(app,))
        app.schedule(t.start)

        with redirect_stderr():
            app.start_event_loop()

        self.assertTrue(
            success.is_set(),
            "scheduled task not executed",
        )


if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_qt_calendar
#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from .qt_test_assistant import QtTestAssistant
from .. import calendar

from enaml.backends.qt.qt_date_edit import qdate_to_python


class TestQtCalendar(QtTestAssistant, calendar.TestCalendar):
    """ QtCalendar tests. 

    """
    def get_date(self, widget):
        """  Get the toolkits widget's active date.

        """
        date = widget.selectedDate()
        return qdate_to_python(date)

    def get_min_date(self, widget):
        """  Get the toolkits widget's maximum date attribute.

        """
        date = widget.minimumDate()
        return qdate_to_python(date)

    def get_max_date(self, widget):
        """ Get the toolkits widget's minimum date attribute.

        """
        date = widget.maximumDate()
        return qdate_to_python(date)

    def activate_date(self, widget, date):
        """ Fire an event to indicate that a date was activated.

        """
        widget.activated.emit(date)

    def select_date(self, widget, date):
        """ Fire an event to indicate that a date was selected.

        """
        # The setDate method in Qt will also signal the dateSelected 
        # signal.
        widget.setSelectedDate(date)


########NEW FILE########
__FILENAME__ = test_qt_check_box
#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from .qt_test_assistant import QtTestAssistant
from .. import check_box

class TestQtCheckBox(QtTestAssistant, check_box.TestCheckBox):
    """ QtCheckbox tests. """

    def get_text(self, widget):
        """ Returns the text from the tookit widget.

        """
        return widget.text()

    def get_checked(self, widget):
        """ Returns the checked status from the tookit widget.

        """
        return widget.isChecked()

    def checkbox_pressed(self, widget):
        """ Press the checkbox programmatically.

        """
        self.widget.pressed.emit()

    def checkbox_released(self, widget):
        """ Release the button programmatically.

        """
        self.widget.released.emit()

    def checkbox_toggle(self, widget):
        """ Toggle the button programmatically.

        """
        self.widget.toggled.emit(True)

########NEW FILE########
__FILENAME__ = test_qt_combo_box
#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from .qt_test_assistant import QtTestAssistant
from .. import combo_box


class TestQtComboBox(QtTestAssistant, combo_box.TestComboBox):
    """ QtComboBox tests. """

    def get_selected_text(self, widget):
        """ Get the current selected text of a combo box.

        """
        return widget.currentText()

    def get_item_text(self, widget, index):
        """ Get the text of a combo box item at a particular index.

        """
        return widget.itemText(index)

    def select_item(self, widget, index):
        """ Fire an event to simulate the selection of an item.

        """
        widget.setCurrentIndex(index)


########NEW FILE########
__FILENAME__ = test_qt_datetime_edit
#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from .qt_test_assistant import QtTestAssistant

from .. import datetime_edit

from enaml.backends.qt.qt_datetime_edit import qdatetime_to_python


class TestQtDatetimeEdit(QtTestAssistant, datetime_edit.TestDatetimeEdit):
    """ QtDateEdit tests. 

    """
    def get_datetime(self, widget):
        """  Get the toolkits widget's active datetime.

        """
        datetime = widget.dateTime()
        return qdatetime_to_python(datetime)

    def get_min_datetime(self, widget):
        """  Get the toolkits widget's maximum datetime attribute.

        """
        datetime = widget.minimumDateTime()
        return qdatetime_to_python(datetime)

    def get_max_datetime(self, widget):
        """ Get the toolkits widget's minimum datetime attribute.

        """
        datetime = widget.maximumDateTime()
        return qdatetime_to_python(datetime)

    def change_datetime(self, widget, datetime):
        """ Simulate a change datetime action at the toolkit widget.

        """
        # The setDateTime method in Qt will also emit the
        # dateTimeChanged signal.
        self.widget.setDateTime(datetime)

    def get_datetime_as_string(self, widget):
        """  Get the toolkits widget's active datetime as a string.

        """
        return self.widget.text()


########NEW FILE########
__FILENAME__ = test_qt_date_edit
#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from .qt_test_assistant import QtTestAssistant
from .. import date_edit

from enaml.backends.qt.qt_date_edit import qdate_to_python

class TestQtDateEdit(QtTestAssistant, date_edit.TestDateEdit):
    """ QtDateEdit tests. """

    def get_date(self, widget):
        """  Get the toolkits widget's active date.

        """
        date = widget.date()
        return qdate_to_python(date)

    def get_min_date(self, widget):
        """  Get the toolkits widget's maximum date attribute.

        """
        date = widget.minimumDate()
        return qdate_to_python(date)

    def get_max_date(self, widget):
        """ Get the toolkits widget's minimum date attribute.

        """
        date = widget.maximumDate()
        return qdate_to_python(date)

    def change_date(self, widget, date):
        """ Simulate a change date action at the toolkit widget.

        .. note:: The setDate method in Qt will also signal the dateChanged
            signal.
        """
        self.widget.setDate(date)

    def get_date_as_string(self, widget):
        """  Get the toolkits widget's active date as a string.

        """
        return self.widget.text()


########NEW FILE########
__FILENAME__ = test_qt_dialog
#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from . import test_qt_window
from .. import dialog

class TestQtDialog(test_qt_window.TestQtWindow, dialog.TestDialog):
    """ QtDialog tests. """

    def disable_showing(self, widget):
        """ Disable the actual display of the dialog window.

        """
        widget.exec_ = lambda:None
        widget.show = lambda:None
        widget.setWindowModality = lambda x:None


########NEW FILE########
__FILENAME__ = test_qt_field
#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from enaml.backends.qt.qt import QtGui

from .qt_test_assistant import QtTestAssistant

from .. import field


QT_2_ENAML_PASSWORD_MODES = {
    QtGui.QLineEdit.Normal: 'normal',
    QtGui.QLineEdit.Password: 'password',
    QtGui.QLineEdit.NoEcho: 'silent',
}


class TestQtField(QtTestAssistant, field.TestField):
    """ QtField tests. 

    """
    def get_value(self, widget):
        """ Get the visible text of a field.

        """
        return widget.text()

    def edit_text(self, widget, text):
        """ Simulate typing in a field.

        """
        widget.insert(text)
        
    def change_text(self, widget, text):
        """ Change text programmatically, rather than "edit" it.

        """
        widget.setText(text)

    def set_cursor_position(self, widget, index):
        """ Set the cursor at a specific position.

        """
        widget.setCursorPosition(index)

    def get_cursor_position(self, widget):
        """ Get the cursor position.

        """
        return widget.cursorPosition()

    def set_selected_text(self, widget, start, stop):
        """ Select text in a field.

        """
        widget.setSelection(start, stop - start)

    def get_selected_text(self, widget):
        """ Get the currently-selected text from a field.

        """
        return widget.selectedText()

    def get_password_mode(self, widget):
        """ Get the password mode status of the widget

        """
        mode = widget.echoMode()
        return QT_2_ENAML_PASSWORD_MODES[mode]

    def press_return(self, widget):
        """ Simulate a press of the 'Return' key.

        """
        widget.returnPressed.emit()

    def gain_focus_if_needed(self, widget):
        """ Have the widget gain focus if required for the tests.

        """
        # qt does the right thing, so we don't need to gain focus.
        pass


########NEW FILE########
__FILENAME__ = test_qt_group_box
#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from unittest import expectedFailure

from enaml.backends.qt.qt import QtCore
from .qt_test_assistant import QtTestAssistant
from .. import group_box

# The alignment object we get back from widget.alignment() is not
# hashable. So we convert the flags to ints.
QT_2_ENAML_ALIGNMENTS = {int(QtCore.Qt.AlignLeft): 'left',
                         int(QtCore.Qt.AlignRight): 'right',
                         int(QtCore.Qt.AlignHCenter): 'center'}


class TestQtGroupBox(QtTestAssistant, group_box.TestGroupBox):

    # This test is an expected failure since calling process
    # events on qt still doesn't seem to empty the relayout
    # queue which has call-later events waiting. Without
    # those being processed, the title update never happens.
    @expectedFailure
    def test_title_changed(self):
        super(TestGroupBox, self).test_title_changed(self)

    def get_title(self, component, widget):
        """ Returns the title text from the tookit widget

        """
        # The title is set on a deferred call, so we need to pump
        # the event loop a bit to get the title to change.
        # XXX this doesn't work, see above comment.
        self.toolkit.app.process_events()
        return widget.title()

    # This test is an expected failure since calling process
    # events on qt still doesn't seem to empty the relayout
    # queue which has call-later events waiting. Without
    # those being processed, the flat update never happens.
    @expectedFailure
    def test_flat_style_changed(self):
        super(TestGroupBox, self).test_flat_style_changed(self)

    def get_flat(self, component, widget):
        """ Returns the flat style status from the tookit widget

        """
        # The flat is set on a deferred call, so we need to pump
        # the event loop a bit to get the title to change.
        # XXX this doesn't work, see above comment.
        self.toolkit.app.process_events()
        return widget.isFlat()

    def get_title_align(self, component, widget):
        """ Returns the title aligment in the tookit widget

        """
        alignment = int(widget.alignment())
        return QT_2_ENAML_ALIGNMENTS[alignment]
########NEW FILE########
__FILENAME__ = test_qt_html
#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from .qt_test_assistant import QtTestAssistant
from .. import html

class TestQtHtml(QtTestAssistant, html.TestHtml):
    """ QtHtml tests. """

    def get_source(self, widget):
        """ Get the source of an Html widget.

        """
        return widget.toPlainText()

########NEW FILE########
__FILENAME__ = test_qt_label
#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from .qt_test_assistant import QtTestAssistant
from .. import label

class TestQtLabel(QtTestAssistant, label.TestLabel):
    """ QtLabel tests. """

    def get_text(self, widget):
        """ Get a label's text.

        """
        return widget.text()

########NEW FILE########
__FILENAME__ = test_qt_operators
#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from .qt_test_assistant import QtTestAssistant
from .. import operators

class TestQtLessLess(QtTestAssistant, operators.TestLessLess):
    """ TestSuite for the LessLess operator in Qt.

    """
    def get_text(self, widget):
        """ Returns the label text from the tookit widget of Label.

        """
        return widget.text()

    def get_checked(self, widget):
        """ Returns the label text from the tookit widget of CheckBox.

        """
        return widget.isChecked()

########NEW FILE########
__FILENAME__ = test_qt_progress_bar
#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from .qt_test_assistant import QtTestAssistant
from .. import progress_bar


class TestQtProgressBar(QtTestAssistant, progress_bar.TestProgressBar):
    """ QtProgressBar tests.
    
    """

    def get_value(self, widget):
        """  Get the toolkits widget's active value.

        """
        return widget.value()

    def get_minimum(self, widget):
        """  Get the toolkits widget's maximum value attribute.

        """
        return widget.minimum()

    def get_maximum(self, widget):
        """ Get the toolkits widget's minimum value attribute.

        """
        return widget.maximum()

########NEW FILE########
__FILENAME__ = test_qt_push_button
#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from .qt_test_assistant import QtTestAssistant
from .. import push_button


class TestQtPushButton(QtTestAssistant, push_button.TestPushButton):
    """ QtPushButton tests. """

    def button_pressed(self):
        """ Press the button programmatically.

        """
        self.widget.pressed.emit()

    def button_released(self):
        """ Release the button programmatically.

        """
        self.widget.released.emit()

    def button_clicked(self):
        """ Click the button programmatically.

        PySide expects 0 arguments for this signal, but PyQt expects 1.

        """
        try:
            self.widget.clicked.emit(False)
        except TypeError:
            self.widget.clicked.emit()

########NEW FILE########
__FILENAME__ = test_qt_radio_button
#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from .qt_test_assistant import QtTestAssistant
from .. import radio_button


class TestQtRadioButton(QtTestAssistant, radio_button.TestRadioButton):
    """ QtRadioButton tests. """

    def get_value(self, button):
        """ Get the checked state of a radio button.

        """
        return button.isChecked()

    def get_text(self, button):
        """ Get the label of a button.

        """
        return button.text()


########NEW FILE########
__FILENAME__ = test_qt_selection_models
#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------

from .qt_test_assistant import QtTestAssistant

from .. import selection_models


class QtSelectionTestHelper(object):
    def get_tk_selection(self, widget):
        """ Return the widget's selection as a list of (topleft, botright)
        ranges with (row, col) indexes.

        """
        pysel = []
        for srange in widget.selection():
            topleft = srange.topLeft()
            botright = srange.bottomRight()
            pysel.append(((topleft.row(), topleft.column()), (botright.row(), botright.column())))
        return pysel


class TestQtBaseSelectionModel(QtTestAssistant, QtSelectionTestHelper, selection_models.TestBaseSelectionModel):
    """ QtBaseSelectionModel tests. 

    """

class TestQtRowSelectionModel(QtTestAssistant, QtSelectionTestHelper, selection_models.TestRowSelectionModel):
    """ Qt RowSelectionModel tests. 

    """


########NEW FILE########
__FILENAME__ = test_qt_slider
#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from enaml.backends.qt.qt import QtGui, QtCore

from enaml.backends.qt.qt_slider import (HOR_TICK_POS_MAP,
                                         VERT_TICK_POS_MAP)

from .qt_test_assistant import QtTestAssistant
from .. import slider

# A map from Qt constants for horizontal or vertical orientation to Enaml enums.
ORIENTATION_MAP = {QtCore.Qt.Horizontal: 'horizontal',
                   QtCore.Qt.Vertical: 'vertical'}


# Map test event actions to the Qt Slider event signals
EVENT_MAP = {slider.TestEvents.PRESSED: 'sliderPressed',
             slider.TestEvents.RELEASED: 'sliderReleased'}

# Map test event actions to the Qt Slider actions
ACTION_MAP ={slider.TestEvents.HOME: QtGui.QAbstractSlider.SliderToMinimum,
             slider.TestEvents.END: QtGui.QAbstractSlider.SliderToMaximum,
             slider.TestEvents.STEP_UP: QtGui.QAbstractSlider.SliderSingleStepAdd,
             slider.TestEvents.STEP_DOWN: QtGui.QAbstractSlider.SliderSingleStepSub,
             slider.TestEvents.PAGE_UP: QtGui.QAbstractSlider.SliderPageStepAdd,
             slider.TestEvents.PAGE_DOWN: QtGui.QAbstractSlider.SliderPageStepSub}

class TestQtSlider(QtTestAssistant, slider.TestSlider):
    """ QtLabel tests. """

    def get_value(self, widget):
        """ Get a slider's position.

        """
        return widget.value()

    def get_minimum(self, widget):
        """ Get the Slider's minimum value.

        """
        return widget.minimum()

    def get_maximum(self, widget):
        """ Get the Slider's maximum value.

        """
        return widget.maximum()

    def get_tick_interval(self, widget):
        """ Get the Slider's tick_interval value.

        """
        return widget.tickInterval()

    def get_tick_position(self, widget):
        """ Get the Slider's tick position style.

        """
        value = widget.tickPosition()
        orientation = self.get_orientation(widget)
        if orientation == 'vertical':
            result = VERT_TICK_POS_MAP[value]
        else:
            result = HOR_TICK_POS_MAP[value]
        return result

    def get_orientation(self, widget):
        """ Get the Slider's orientation.

        """
        value = widget.orientation()
        return ORIENTATION_MAP[value]

    def get_single_step(self, widget):
        """ Get the Slider's single step value.

        """
        return widget.singleStep()

    def get_page_step(self, widget):
        """ Get the Slider's page step value.

        """
        return widget.pageStep()

    def get_tracking(self, widget):
        """ Get the Slider's tracking status.

        """
        return widget.hasTracking()

    def send_event(self, widget, event):
        """ Send an event to the Slider programmatically.

        Arguments
        ---------
        widget :
            The widget to send the event to.

        event :
            The desired event to be proccessed.

        """
        if event in ACTION_MAP:
            widget.triggerAction(ACTION_MAP[event])
        elif event in EVENT_MAP:
            getattr(widget, EVENT_MAP[event]).emit()
        else:
            raise NotImplementedError('Test event is not Implemented')


########NEW FILE########
__FILENAME__ = test_qt_spin_box
#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from .qt_test_assistant import QtTestAssistant
from .. import spin_box


class TestQtSpinBox(QtTestAssistant, spin_box.TestSpinBox):
    """ QtSpinBox tests. """

    def get_value(self, widget):
        """ Get a spin box's value.

        """
        return widget.value()

    def get_low(self, widget):
        """ Get a spin box's minimum value.

        """
        return widget.minimum()

    def get_high(self, widget):
        """ Get a spin box's maximum value.

        """
        return widget.maximum()

    def get_step(self, widget):
        """ Get a spin box's step size.

        """
        return widget.singleStep()

    def get_wrap(self, widget):
        """ Check if a spin box wraps around at the edge values.

        """
        return widget.wrapping()

    def get_text(self, widget):
        """ Get the text displayed in a spin box.

        """
        return widget.text()

    def spin_up_event(self, widget):
        """ Simulate a click on the 'up' spin button.

        """
        widget.stepUp()

    def spin_down_event(self, widget):
        """ Simulate a click on the 'down' spin button.

        """
        widget.stepDown()

########NEW FILE########
__FILENAME__ = test_qt_toggle_button
#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from .qt_test_assistant import QtTestAssistant

from .. import toggle_button


class TestQtToggleButton(QtTestAssistant, toggle_button.TestToggleButton):
    """ QtToggleButton tests. 
    
    """
    def get_text(self, widget):
        """ Returns the text from the tookit widget.

        """
        return widget.text()

    def get_checked(self, widget):
        """ Returns the checked status from the tookit widget.

        """
        return widget.isChecked()

    def toggle_button_pressed(self, widget):
        """ Press the toggle button programmatically.

        """
        self.widget.pressed.emit()

    def toggle_button_released(self, widget):
        """ Release the button programmatically.

        """
        self.widget.released.emit()

    def toggle_button_toggle(self, widget):
        """ Toggle the button programmatically.

        """
        self.widget.toggled.emit(True)


########NEW FILE########
__FILENAME__ = test_qt_window
#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from .qt_test_assistant import QtTestAssistant
from .. import window

class TestQtWindow(QtTestAssistant, window.TestWindow):
    """ QtWindow tests. """

    def get_title(self, widget):
        """ Get a window's title.

        """
        return widget.windowTitle()


########NEW FILE########
__FILENAME__ = radio_button
#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from .enaml_test_case import EnamlTestCase, required_method


class TestRadioButton(EnamlTestCase):
    """ Logic for testing radio buttons.

    Tooklit testcases need to provide the following methods

    Abstract Methods
    ----------------
    get_value(self, button)
        Get the checked state of a radio button.

    get_text(self, button)
        Get the label of a button.

    """
    def setUp(self):
        """ Finalise set up before the Radio button tests

        """

        label_1 = 'Label 1'
        label_2 = 'Label 2'

        enaml_source = """
enamldef MainView(MainWindow):
    Container:
        RadioButton:
            name = 'radio1'
            text = '{0}'
            checked = True
        RadioButton:
            name = 'radio2'
            text = '{1}'
""".format(label_1, label_2)

        self.events = []
        self.view = self.parse_and_create(enaml_source)
        self.radio1 = self.component_by_name(self.view, 'radio1')
        self.widget1 = self.radio1.toolkit_widget
        self.radio2 = self.component_by_name(self.view, 'radio2')
        self.widget2 = self.radio2.toolkit_widget

    def test_initial_value(self):
        """ Test the initial checked state of the radio buttons.

        """
        widget1_value = self.get_value(self.widget1)
        self.assertTrue(widget1_value)
        self.assertEqual(self.radio1.checked, widget1_value)

        widget2_value = self.get_value(self.widget2)
        self.assertFalse(widget2_value)
        self.assertEqual(self.radio2.checked, widget2_value)

    def test_initial_labels(self):
        """ Test that the toolkit widget's label reflects the Enaml text.

        """
        widget1_label = self.get_text(self.widget1)
        self.assertEqual(widget1_label, 'Label 1')
        self.assertEqual(self.radio1.text, widget1_label)

        widget2_label = self.get_text(self.widget2)
        self.assertEqual(widget2_label, 'Label 2')
        self.assertEqual(self.radio2.text, widget2_label)

    def test_change_label(self):
        """ Change the label of a RadioButton at the Enaml level.

        """
        new_label = 'new_label'
        self.radio2.text = new_label

        widget2_text = self.get_text(self.widget2)
        self.assertEqual(new_label, widget2_text)
        self.assertEqual(self.radio2.text, widget2_text)

    def test_set_checked(self):
        """ Test setting the value of a radio button in a group.

        """
        # Select the second button.
        self.radio2.checked = True

        widget2_value = self.get_value(self.widget2)
        self.assertTrue(widget2_value)
        self.assertEqual(self.radio2.checked, widget2_value)

        # Select the first button to deselect second.
        self.radio1.checked = True

        widget2_value = self.get_value(self.widget2)
        self.assertFalse(widget2_value)
        self.assertEqual(self.radio2.checked, widget2_value)

    def test_multiple_radio_buttons(self):
        """Test selecting one of a set radiobuttons. """

        # select second
        self.radio2.checked = True

        widget1_value = self.get_value(self.widget1)
        widget2_value = self.get_value(self.widget2)

        # The selected radio button is ofcourse aware (we did this)
        self.assertEqual(self.radio2.checked, widget2_value)

        # Both the wxwidgets know of the change!
        self.assertTrue(widget2_value)
        self.assertFalse(widget1_value)

        self.assertEqual(self.radio1.checked, widget1_value)

    #--------------------------------------------------------------------------
    # absrtact methods
    #--------------------------------------------------------------------------
    @required_method
    def get_value(self, button):
        """ Get the checked state of a radio button.

        """
        pass

    @required_method
    def get_text(self, button):
        """ Get the label of a button.

        """
        pass


########NEW FILE########
__FILENAME__ = selection_models
#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from .enaml_test_case import EnamlTestCase, required_method


class SelectionTestHelper(object):
    """ Helper mixin for selection model test cases.

    """
    @property
    def widget(self):
        """ Get the current toolkit "widget", as it may change.

        """
        return self.component.abstract_obj.selection_model

    def index(self, row, column):
        """ Create an appropriate ModelIndex.

        """
        return self.item_model.create_index(row, column, self.item_model)

    def to_enaml_selection(self, pysel):
        """ Convert a selection list given with (row, col) tuples to a 
        selection list with ModexIndexes.

        """
        esel = []
        for topleft, botright in pysel:
            esel.append((self.index(*topleft), self.index(*botright)))
        return esel

    def from_enaml_selection(self, esel):
        """ Convert an Enaml selection list with ModelIndexes to one 
        given with (row, col) tuples for comparison purposes.

        """
        pysel = []
        for topleft, botright in esel:
            pysel.append(((topleft.row, topleft.column), 
                          (botright.row, botright.column)))
        return pysel

    def set_py_selection(self, pysel, command):
        """ Set the selection using (int, int) indices.

        """
        esel = self.to_enaml_selection(pysel)
        self.component.set_selection(esel, command)

    def get_py_selection(self):
        """ Get the selection using (int, int) indices.

        """
        return self.from_enaml_selection(self.component.get_selection())

    #--------------------------------------------------------------------------
    # Abstract methods
    #--------------------------------------------------------------------------
    @required_method
    def get_tk_selection(self, widget):
        """ Return the widget's selection as a list of (topleft, botright)
        ranges with (row, col) indexes.

        """
        pass


class TestBaseSelectionModel(EnamlTestCase, SelectionTestHelper):
    """ Logic for testing selection models.

    """
    def setUp(self):
        """ Set up tests for Enaml's BaseSelectionModel.

        """
        enaml_source = """
from enaml.stdlib.table_model import TableModel
import numpy as np

nrows = 20
ncols = 10

table = np.arange(nrows * ncols).reshape((nrows, ncols))
the_item_model = TableModel(table)

enamldef MainView(MainWindow):
    attr events
    TableView:
        name = 'table_view'
        item_model = the_item_model
        BaseSelectionModel:
            name = 'selection_model'
"""

        self.events = []
        self.view = self.parse_and_create(enaml_source, events=self.events)
        self.table_view = self.component_by_name(self.view, 'table_view')
        self.component = self.table_view.selection_model
        self.item_model = self.table_view.item_model

    def test_empty_initial_selection(self):
        """ No selection.

        """
        self.assertEqual(self.get_tk_selection(self.widget), [])
        self.assertEqual(self.get_py_selection(), [])

    def test_set_selection_clear_select(self):
        """ Test the 'clear_select' command.

        """
        pysel = [((1, 2), (3, 4))]
        self.set_py_selection(pysel, 'clear_select')
        self.assertEqual(self.get_tk_selection(self.widget), pysel)
        self.assertEqual(self.get_py_selection(), pysel)

        pysel = [((0, 1), (6,7))]
        self.set_py_selection(pysel, 'clear_select')
        self.assertEqual(self.get_tk_selection(self.widget), pysel)
        self.assertEqual(self.get_py_selection(), pysel)

        self.component.clear()
        self.assertEqual(self.get_tk_selection(self.widget), [])
        self.assertEqual(self.get_py_selection(), [])

    def test_set_selection_clear_select_rows(self):
        """ Test the ('clear_select', 'rows') command.

        """
        pysel = [((1, 2), (3, 4))]
        test_sel = [((1, 0), (3, 9))]
        self.set_py_selection(pysel, ('clear_select', 'rows'))
        self.assertEqual(self.get_tk_selection(self.widget), test_sel)
        self.assertEqual(self.get_py_selection(), test_sel)

    def test_set_selection_no_update(self):
        """ Test the 'no_update' command.

        """
        pysel = [((1, 2), (3, 4))]
        self.set_py_selection(pysel, 'no_update')
        self.assertEqual(self.get_tk_selection(self.widget), [])
        self.assertEqual(self.get_py_selection(), [])

        new = [((0, 1), (6, 7))]
        self.set_py_selection(new, 'clear_select')
        self.assertEqual(self.get_tk_selection(self.widget), new)
        self.assertEqual(self.get_py_selection(), new)

        self.set_py_selection(pysel, 'no_update')
        self.assertEqual(self.get_tk_selection(self.widget), new)
        self.assertEqual(self.get_py_selection(), new)

    def test_set_selection_select(self):
        """ Test the 'select' command.

        """
        pysel = [((1, 2), (3, 4))]
        self.set_py_selection(pysel, 'select')
        self.assertEqual(self.get_tk_selection(self.widget), pysel)
        self.assertEqual(self.get_py_selection(), pysel)

        new = [((5, 1), (7, 5))]
        self.set_py_selection(new, 'select')
        self.assertEqual(self.get_tk_selection(self.widget), pysel+new)
        self.assertEqual(self.get_py_selection(), pysel+new)

    def test_set_selection_deselect(self):
        """ Test the 'deselect' command.

        """
        pysel = [((1, 2), (3, 4))]
        self.set_py_selection(pysel, 'clear_select')
        self.assertEqual(self.get_tk_selection(self.widget), pysel)
        self.assertEqual(self.get_py_selection(), pysel)

        new = [((2, 2), (4, 4))]
        remainder = [((1,2), (1,4))]
        self.set_py_selection(new, 'deselect')
        self.assertEqual(self.get_tk_selection(self.widget), remainder)
        self.assertEqual(self.get_py_selection(), remainder)

    def test_set_selection_toggle(self):
        """ Test the 'toggle' command.

        """
        pysel = [((1, 2), (3, 4))]
        self.set_py_selection(pysel, 'clear_select')
        self.assertEqual(self.get_tk_selection(self.widget), pysel)
        self.assertEqual(self.get_py_selection(), pysel)

        new = [((2, 2), (4, 4))]
        remainder = [((1, 2), (1, 4)), ((4, 2), (4, 4))]
        self.set_py_selection(new, 'toggle')
        self.assertEqual(self.get_tk_selection(self.widget), remainder)
        self.assertEqual(self.get_py_selection(), remainder)


class TestRowSelectionModel(EnamlTestCase, SelectionTestHelper):
    """ Logic for testing RowSelectionModel

    """
    def setUp(self):
        """ Set up tests for Enaml's RowSelectionModel

        """
        enaml_source = """
from enaml.stdlib.table_model import TableModel
import numpy as np

nrows = 20
ncols = 10

table = np.arange(nrows * ncols).reshape((nrows, ncols))
the_item_model = TableModel(table)


enamldef MainView(MainWindow):
    attr events
    TableView:
        name = 'table_view'
        item_model = the_item_model
        RowSelectionModel:
            name = 'selection_model'
"""

        self.events = []
        self.view = self.parse_and_create(enaml_source, events=self.events)
        self.table_view = self.component_by_name(self.view, 'table_view')
        self.component = self.table_view.selection_model
        self.item_model = self.table_view.item_model

    def test_set_selected_rows(self):
        """ Test the selection of rows through the selected_rows trait.

        """
        self.assertEqual(self.component.selected_rows, [])
        self.component.selected_rows = [2, 3, 5, 6]
        pysel = [((2, 0), (2, 9)), ((3, 0), (3, 9)), ((5, 0), (5, 9)), ((6, 0), (6, 9))]
        self.assertEqual(self.get_tk_selection(self.widget), pysel)
        self.assertEqual(self.get_py_selection(), pysel)

        self.component.selected_rows.append(7)
        new = pysel + [((7, 0), (7, 9))]
        self.assertEqual(self.get_tk_selection(self.widget), new)
        self.assertEqual(self.get_py_selection(), new)

        del self.component.selected_rows[1]
        del new[1]
        self.assertEqual(self.get_tk_selection(self.widget), new)
        self.assertEqual(self.get_py_selection(), new)

    def test_get_selected_rows(self):
        """ Test that the selected_rows trait gets updated correctly when the
        selection is set elsewhere.

        """
        pysel = [((2, 0), (2, 9)), ((3, 0), (3, 9)), ((5, 0), (5, 9)), ((6, 0), (6, 9))]
        self.set_py_selection(pysel, ('clear_select', 'rows'))
        self.assertEqual(self.component.selected_rows, [2, 3, 5, 6])


########NEW FILE########
__FILENAME__ = slider
#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from traits.api import TraitError

from .enaml_test_case import EnamlTestCase, required_method


class TestEvents(object):
    """ Events required by the testcase.

    """
    #: The left button is pressed
    PRESSED = 0x0

    #: The left button is released
    RELEASED = 0x1

    #: The thumb is moved one step up
    STEP_UP = 0x2

    #: The thumb is moved one step down
    STEP_DOWN = 0x3

    #: The thumb is moved one page up
    PAGE_UP = 0x4

    #: The thumb is moved one page down
    PAGE_DOWN = 0x5

    #: The thumb is moved to home
    HOME = 0x6

    #: The thumb is moved to the end
    END = 0x7


class TestSlider(EnamlTestCase):
    """ Logic for testing sliders.


    Tooklit testcases need to provide the following methods

    Abstract Methods
    ----------------
    get_value(self, widget)
        Get the Slider's value.

    get_tick_interval(self, widget)
        Get the Slider's tick_interval value.

    get_tick_position(self, widget)
        Get the Slider's tick position style.

    get_orientation(self, widget)
        Get the Slider's orientation.

    get_single_step(self, widget)
        Get the Slider's single step value.

    get_page_step(self, widget)
        Get the Slider's page step value.

    get_tracking(self, widget)
        Get the Slider's tracking status.

    send_event(self, widget, event)
        Send an event to the Slider programmatically.

    """

    def setUp(self):
        """ Set up before the spin box tests.

        """

        enaml_source = """
enamldef MainView(MainWindow):
    attr events
    Slider:
        name = 'slider'
        moved :: events.append(('moved', event.new))
        pressed :: events.append('pressed')
        released :: events.append('released')
"""

        self.events = []
        self.view = self.parse_and_create(enaml_source, events=self.events)
        self.component = self.component_by_name(self.view, 'slider')
        self.widget = self.component.toolkit_widget

    def test_initial_attributes(self):
        """ Compare the Enaml Slider's attributes with its toolkit widget.

        """
        component = self.component

        self.assertFalse(component.error)
        self.assertIsNone(component.exception)

        self.assertEnamlInSync(component, 'value', 0)
        self.assertEnamlInSync(component, 'minimum', 0)
        self.assertEnamlInSync(component, 'maximum', 100)
        self.assertEnamlInSync(component, 'tick_interval', 10)
        self.assertEnamlInSync(component, 'tick_position', 'bottom')
        self.assertEnamlInSync(component, 'orientation', 'horizontal')
        self.assertEnamlInSync(component, 'single_step', 1)
        self.assertEnamlInSync(component, 'page_step', 10)
        self.assertEqual(self.events, [])


    def test_tracking_attribute(self):
        """ Test accesing tracking attribute.

        """
        component = self.component

        self.assertEnamlInSync(component, 'tracking', True)

        component.tracking = False
        self.assertEnamlInSync(component, 'tracking', False)
        self.assertEqual(self.events, [])


    def test_change_maximum(self):
        """ Test changing the maximum range of the slider.

        """
        component = self.component
        component.maximum = 200
        self.assertEnamlInSync(component, 'maximum', 200)

    def test_change_minimum(self):
        """ Test changing the minimum range of the slider.

        """
        component = self.component
        component.value = 70
        component.minimum = 50
        self.assertEnamlInSync(component, 'minimum', 50)
        self.assertEqual(self.events, [])

    def test_change_maximum_invalid(self):
        """ Test attempting to set an invalid value to the maximum range
        of the slider.

        """
        component = self.component
        with self.assertRaises(TraitError):
            component.maximum = -23
        component.minimum = 50
        with self.assertRaises(TraitError):
            component.maximum = 23
        self.assertEqual(self.events, [])

    def test_change_minimum_invalid(self):
        """ Test attempting to set an invalid value to the minimum range
        of the slider.

        """
        component = self.component
        with self.assertRaises(TraitError):
            component.minimum = -13
        with self.assertRaises(TraitError):
            component.minimum = 135
        self.assertEqual(self.events, [])

    def test_change_maximum_and_value(self):
        """ Test setting maximum while the value is out of range.

        """
        component = self.component
        component.value = 70
        self.assertEnamlInSync(component, 'value', 70)
        component.maximum = 50
        self.assertEnamlInSync(component, 'value', 50)
        self.assertEqual(self.events, [])

    def test_change_minimum_and_value(self):
        """ Test setting minimum while the value is out of range.

        """
        component = self.component
        component.value = 30
        component.minimum = 50
        self.assertEnamlInSync(component, 'value', 50)
        self.assertEqual(self.events, [])

    def test_value_change(self):
        """ Test changing the value programmaticaly.

        """
        component = self.component
        component.value = 1
        self.assertEnamlInSync(component, 'value', 1)
        component.value = 34
        self.assertEnamlInSync(component, 'value', 34)
        self.assertEqual(self.events, [])

    def test_invalid_value_change(self):
        """ Test changing the position with the an invalid value

        when invalid, check that it has not changed the values and the
        errors are updated.

        """
        component = self.component

        with self.assertRaises(TraitError):
            component.value = -2
        with self.assertRaises(TraitError):
            component.value = 120

    def test_orientation_setting(self):
        """ Test changing the widget orientation

        """
        component = self.component

        self.component.orientation = 'vertical'
        self.assertEnamlInSync(component, 'orientation', 'vertical')

        self.component.orientation = 'horizontal'
        self.assertEnamlInSync(component, 'orientation', 'horizontal')

    def test_tick_position_setting(self):
        """ Test changing the widget tickposition

        """
        component = self.component

        component.tick_position = 'bottom'
        self.assertEnamlInSync(component, 'tick_position', 'bottom')

        component.tick_position = 'top'
        self.assertEnamlInSync(component, 'tick_position', 'top')

        component.tick_position = 'both'
        self.assertEnamlInSync(component, 'tick_position', 'both')

        self.component.orientation = 'vertical'

        component.tick_position = 'left'
        self.assertEnamlInSync(component, 'tick_position', 'left')

        component.tick_position = 'right'
        self.assertEnamlInSync(component, 'tick_position', 'right')

        component.tick_position = 'both'
        self.assertEnamlInSync(component, 'tick_position', 'both')

        component.tick_position = 'no_ticks'
        self.assertEnamlInSync(component, 'tick_position', 'no_ticks')

    def test_incompatible_tick_position(self):
        """ Test that changing tick position is addapted if the orientation
        is not compatible.

        This is in sync with how the QSlider behaves.

        """
        component = self.component

        component.tick_position = 'left'
        self.assertEnamlInSync(component, 'tick_position', 'top')

        component.tick_position = 'right'
        self.assertEnamlInSync(component, 'tick_position', 'bottom')

        self.component.orientation = 'vertical'

        component.tick_position = 'bottom'
        self.assertEnamlInSync(component, 'tick_position', 'right')

        component.tick_position = 'top'
        self.assertEnamlInSync(component, 'tick_position', 'left')

    def test_changing_orientaion_tick_policy(self):
        """ Test that the ticks follow the orientation changes

        """
        component = self.component

        component.tick_position = 'bottom'
        self.component.orientation = 'vertical'
        self.assertEnamlInSync(component, 'tick_position', 'right')
        component.tick_position = 'left'
        self.component.orientation = 'horizontal'
        self.assertEnamlInSync(component, 'tick_position', 'top')

    def test_pressing_the_thumb(self):
        """ Test firing events when the thumb is pressed down.

        """
        events = self.events
        component = self.component
        component.value = 50
        self.send_event(self.widget, TestEvents.PRESSED)
        self.assertEqual(['pressed'], events)

    # This fails on windows under wx because the underlying size of the
    # of the widget is not reliable. So the precomputed mouse
    # position for the mouse event which is sent can be wrong.
    def test_releasing_the_thumb(self):
        """ Test firing events when the thumb is released.

        """
        events = self.events
        component = self.component
        component.value = 50

        self.send_event(self.widget, TestEvents.RELEASED)
        self.assertEqual([], events)

        self.send_event(self.widget, TestEvents.PRESSED)
        self.send_event(self.widget, TestEvents.RELEASED)
        self.assertEqual(['pressed', 'released'], events)

    def test_moving_the_thumb_programmaticaly(self):
        """ Test firing events when the thumb is moved (programmatically).

        """
        component = self.component
        events = self.events
        component.value = 30
        self.assertEqual(events, [])
        self.assertEnamlInSync(component, 'value', 30)

    def test_move_to_home(self):
        """ Test firing events and value when the thumb is moved to home.

        """
        component = self.component
        events = self.events
        component.value = 50
        self.send_event(self.widget, TestEvents.HOME)
        self.assertEnamlInSync(component, 'value', 0)
        self.assertEqual(events, [])

    def test_move_to_end(self):
        """ Test firing events and value when the thumb is moved to end.

        """
        component = self.component
        events = self.events
        self.send_event(self.widget, TestEvents.END)
        self.assertEnamlInSync(component, 'value', 100)
        self.assertEqual(events, [])

    def test_move_down_by_one_step(self):
        """ Test firing events and value when the thumb is moved by one
        step down.

        """
        component = self.component
        events = self.events
        component.value = 50
        self.send_event(self.widget, TestEvents.STEP_DOWN)
        self.assertEnamlInSync(component, 'value', 49)
        self.assertEqual(events, [])

    def test_move_up_by_one_step(self):
        """ Test firing events and value when the thumb is moved by one
        step up.

        """
        component = self.component
        events = self.events
        component.value = 50
        self.send_event(self.widget, TestEvents.STEP_UP)
        self.assertEnamlInSync(component, 'value', 51)
        self.assertEqual(events, [])

    def test_move_down_by_one_page(self):
        """ Test firing events and value when the thumb is moved by one
        page down.

        """
        component = self.component
        events = self.events
        component.value = 50
        self.send_event(self.widget, TestEvents.PAGE_DOWN)
        self.assertEnamlInSync(component, 'value', 40)
        self.assertEqual(events, [])

    def test_move_up_by_one_page(self):
        """ Test firing events and value when the thumb is moved by one
        page up.

        """
        component = self.component
        events = self.events
        component.value = 50
        self.send_event(self.widget, TestEvents.PAGE_UP)
        self.assertEnamlInSync(component, 'value', 60)
        self.assertEqual(events, [])

    #--------------------------------------------------------------------------
    # Abstract methods
    #--------------------------------------------------------------------------
    @required_method
    def get_value(self, widget):
        """ Get the Slider's value.

        """
        pass

    @required_method
    def get_minimum(self, widget):
        """ Get the Slider's minimum value.

        """
        pass

    @required_method
    def get_maximum(self, widget):
        """ Get the Slider's maximum value.

        """
        pass

    @required_method
    def get_tick_interval(self, widget):
        """ Get the Slider's tick_interval value.

        """
        pass

    @required_method
    def get_tick_position(self, widget):
        """ Get the Slider's tick position style.

        """
        pass

    @required_method
    def get_orientation(self, widget):
        """ Get the Slider's orientation.

        """
        pass

    @required_method
    def get_single_step(self, widget):
        """ Get the Slider's single step value.

        """
        pass

    @required_method
    def get_page_step(self, widget):
        """ Get the Slider's page step value.

        """
        pass

    @required_method
    def get_tracking(self, widget):
        """ Get the Slider's tracking status.

        """
        pass

    @required_method
    def send_event(self, widget, event):
        """ Send an event to the Slider programmatically.

        Arguments
        ---------
        widget :
            The widget to send the event to.

        event :
            The desired event to be proccessed.

        """
        pass


########NEW FILE########
__FILENAME__ = spin_box
#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from .enaml_test_case import EnamlTestCase, required_method


class TestSpinBox(EnamlTestCase):
    """ Logic for testing spin boxes.

    Tooklit testcases need to provide the following methods

    Abstract Methods
    ----------------
    def get_value(self, widget)
        Get a spin box's value.

    def get_low(self, widget)
        Get a spin box's minimum value.

    get_high(self, widget)
        Get a spin box's maximum value.

    get_step(self, widget)
        Get a spin box's step size.

    get_wrap(self, widget)
        Check if a spin box wraps around at the edge values.

    get_text(self, widget)
        Get the text displayed in a spin box.

    spin_up_event(self, widget)
        Simulate a click on the 'up' spin button.

    spin_down_event(self, widget)
        Simulate a click on the 'down' spin button.

    """
    def setUp(self):
        """ Set up before the spin box tests.

        """

        enaml_source = """
enamldef MainView(MainWindow):
    attr events
    SpinBox:
        name = 'spinbox'
        low = -10
        high = 21
        step = 2
        value = -4
        wrap = True
"""

        self.events = []
        self.view = self.parse_and_create(enaml_source, events=self.events)
        self.component = self.component_by_name(self.view, 'spinbox')
        self.widget = self.component.toolkit_widget

    def test_initial_attributes(self):
        """ Compare the Enaml SpinBox's attributes with its toolkit widget.

        """
        component = self.component
        widget = self.widget
        self.assertEqual(self.get_value(widget), component.value)
        self.assertEqual(self.get_low(widget), component.low)
        self.assertEqual(self.get_high(widget), component.high)
        self.assertEqual(self.get_step(widget), component.step)
        self.assertEqual(self.get_wrap(widget), component.wrap)

    def test_change_low(self):
        """ Update the spin box's minimum value.

        """
        component = self.component
        new_low = component.low - 1
        component.low = new_low
        component_low = component.low
        widget_low = self.get_low(self.widget)
        self.assertEqual(component_low, new_low)
        self.assertEqual(widget_low, component_low)

    def test_change_high(self):
        """ Update the spin box's maximum value.

        """
        component = self.component
        new_high = component.high + 1
        component.high = new_high
        component_high = component.high
        widget_high = self.get_high(self.widget)
        self.assertEqual(component_high, new_high)
        self.assertEqual(widget_high, component_high)

    def test_step_up(self):
        """ Simulate a press of the spin box's 'up' button.

        """
        component = self.component
        widget = self.widget
        old_widget_value = self.get_value(widget)
        widget_step = self.get_step(widget)
        self.spin_up_event(widget)
        new_widget_value = self.get_value(widget)
        self.assertEqual(new_widget_value, old_widget_value + widget_step)
        self.assertEqual(component.value, new_widget_value)

    def test_step_down(self):
        """ Simulate a press of the spin box's 'down' button.

        """
        component = self.component
        widget = self.widget
        old_widget_value = self.get_value(widget)
        widget_step = self.get_step(widget)
        self.spin_down_event(widget)
        new_widget_value = self.get_value(widget)
        self.assertEqual(new_widget_value, old_widget_value - widget_step)
        self.assertEqual(component.value, new_widget_value)

    def test_wrap_top(self):
        """ Check that a spin box wraps appropriately, from top to bottom.

        """
        widget = self.widget
        component = self.component
        component.value = component.high
        self.spin_up_event(self.widget)
        self.assertEqual(component.value, component.low)
        self.assertEqual(component.value, self.get_value(widget))

    def test_wrap_bottom(self):
        """ Check that a spin box wraps appropriately, from bottom to top.

        """
        widget = self.widget
        component = self.component
        component.value = component.low
        self.spin_down_event(widget)
        self.assertEqual(component.value, component.high)
        self.assertEqual(component.value, self.get_value(widget))

    def test_no_wrap_top(self):
        """ Check that a spin box doesn't wrap from top to bottom.

        """
        widget = self.widget
        component = self.component
        high = component.high
        component.wrap = False
        component.value = high
        self.spin_up_event(widget)
        self.assertEqual(component.value, high)
        self.assertEqual(component.value, self.get_value(widget))

    def test_no_wrap_bottom(self):
        """ Check that a spin box doesn't wrap from bottom to top.

        """
        widget = self.widget
        component = self.component
        low = component.low
        component.wrap = False
        component.value = low
        self.spin_down_event(widget)
        self.assertEqual(component.value, low)
        self.assertEqual(component.value, self.get_value(widget))

    def test_text_display(self):
        """ Check the displayed text.

        """
        self.assertEqual(self.get_text(self.widget), '-4')

    #--------------------------------------------------------------------------
    # Abstract methods
    #--------------------------------------------------------------------------
    @required_method
    def get_value(self, widget):
        """ Get a spin box's value.

        """
        pass

    @required_method
    def get_low(self, widget):
        """ Get a spin box's minimum value.

        """
        pass

    @required_method
    def get_high(self, widget):
        """ Get a spin box's maximum value.

        """
        pass

    @required_method
    def get_step(self, widget):
        """ Get a spin box's step size.

        """
        pass

    @required_method
    def get_wrap(self, widget):
        """ Check if a spin box wraps around at the edge values.

        """
        pass

    @required_method
    def get_text(self, widget):
        """ Get the text displayed in a spin box.

        """
        pass

    @required_method
    def spin_up_event(self, widget):
        """ Simulate a click on the 'up' spin button.

        """
        pass

    @required_method
    def spin_down_event(self, widget):
        """ Simulate a click on the 'down' spin button.

        """
        pass


########NEW FILE########
__FILENAME__ = toggle_button
#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from .enaml_test_case import EnamlTestCase, required_method


class TestToggleButton(EnamlTestCase):
    """ Logic for testing toggle buttons.

    Tooklit testcases need to provide the following functions

    Abstract Methods
    ----------------
    get_text(widget)
        Returns the text from the tookit widget.

    checked_status(widget)
        Returns the checked status of the toolkit widget.

    Checkbox_pressed(self)
        Press the toggle button programmatically.

    Checkbox_released(self)
        Release the toggle button programmatically.

    Checkbox_toggled(self)
        Toggle the toggle button programmatically.

    """
    def setUp(self):
        """ Setup enaml component for testing

        """
        self.toggle_button_label = 'toggle button label'

        enaml_source = """
enamldef MainView(MainWindow):
    attr events
    ToggleButton:
        name = 'togglebtn1'
        text = 'toggle button label'
        checked = True
        toggled :: events.append('toggled')
        pressed :: events.append('pressed')
        released :: events.append('released')
""".format(self.toggle_button_label)

        self.events = []
        self.view = self.parse_and_create(enaml_source, events=self.events)
        self.component = self.component_by_name(self.view, 'togglebtn1')
        self.widget = self.component.toolkit_widget

    def test_box_initialization(self):
        """ Test the initialization of the widget

        """
        component = self.component
        # checked
        self.assertEnamlInSync(component, 'checked', True)
        self.assertEnamlInSync(component, 'text', self.toggle_button_label)

    def testLabelChange(self):
        """ Test changing the label of a check box

        """
        component = self.component
        new_label = 'new_label'
        component.text = new_label
        self.assertEnamlInSync(component, 'text', new_label)

    def testSettingChecked(self):
        """ Test selecting a ToggleButton

        """
        component = self.component
        # un-check
        self.component.checked = False
        self.assertEnamlInSync(component, 'checked', False)
        # check
        self.component.checked = True
        self.assertEnamlInSync(component, 'checked', True)

    def test_toggle_button_pressed(self):
        """ React to a toggle button press event.

        """
        events = self.events
        self.toggle_button_pressed(self.widget)
        self.assertTrue(self.component.down)
        self.assertEqual(events, ['pressed'])

    def test_toggle_button_toggled(self):
        """ Test a toggle button toggled event.

        """
        events = self.events
        self.toggle_button_toggle(self.widget)
        self.assertFalse(self.component.down)
        self.assertEqual(events, ['toggled'])

    def test_toggle_button_released(self):
        """ Test a toggle button release event.

        """
        events = self.events
        # Release events are ignored if the button was not already down
        self.toggle_button_released(self.widget)
        self.assertEqual(events, [])

    def test_press_release_sequence(self):
        """ Verify the even firing when the press-release (nornal) 
        sequence is applied.

        """
        component = self.component
        widget = self.widget
        events = self.events
        self.toggle_button_pressed(widget)
        self.assertTrue(component.down)
        self.toggle_button_released(widget)
        self.assertFalse(component.down)
        self.assertEqual(events, ['pressed', 'released'])

    def test_toggle_button_all_events(self):
        """ Test press, release, and click events.

        """
        self.toggle_button_pressed(self.widget)
        self.toggle_button_released(self.widget)
        self.toggle_button_toggle(self.widget)

        events = self.events
        self.assertEqual(events, ['pressed', 'released', 'toggled'])

    #--------------------------------------------------------------------------
    # Abstract methods
    #--------------------------------------------------------------------------
    @required_method
    def get_text(self, widget):
        """ Returns the text from the tookit widget.

        """
        pass

    @required_method
    def get_checked(self, widget):
        """ Returns the checked status of the toolkit widget.

        """
        pass

    @required_method
    def toggle_button_pressed(self, widget):
        """ Press the toggle button programmatically.

        """
        pass

    @required_method
    def toggle_button_released(self, widget):
        """ Release the button programmatically.

        """
        pass

    @required_method
    def toggle_button_toggle(self, widget):
        """ Toggle the button programmatically.

        """
        pass


########NEW FILE########
__FILENAME__ = window
#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from .enaml_test_case import EnamlTestCase, required_method


class TestWindow(EnamlTestCase):
    """ Logic for testing Windows.

    """
    def setUp(self):
        """ Set up Window tests.

        """

        enaml_source = """
enamldef MainView(MainWindow):
    name = 'window'
    title = 'foo'
"""

        self.view = self.parse_and_create(enaml_source)
        self.component = self.component_by_name(self.view, 'window')
        self.widget = self.component.toolkit_widget

    def test_initial_title(self):
        """ Test the initial title of a Window.

        """
        self.assertEnamlInSync(self.component, 'title', 'foo')

    def test_title_changed(self):
        """ Change the title of the Window.

        """
        self.component.title = 'bar'
        self.assertEnamlInSync(self.component, 'title', 'bar')

    #--------------------------------------------------------------------------
    # Abstract methods
    #--------------------------------------------------------------------------
    @required_method
    def get_title(self, widget):
        """ Returns the title from the toolkit widget.

        """
        pass


########NEW FILE########
__FILENAME__ = test_wx_calendar
#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
import wx.calendar

from .wx_test_assistant import WXTestAssistant, skip_nonwindows
from ...components import calendar


@skip_nonwindows
class TestWXCalendar(WXTestAssistant, calendar.TestCalendar):
    """ WXCalendar tests.

    """
    def get_date(self, widget):
        """ Get a calendar's active date.

        """
        return widget.PyGetDate()

    def get_min_date(self, widget):
        """ Get a calendar's minimum date attribute.

        """
        return widget.PyGetLowerDateLimit()

    def get_max_date(self, widget):
        """ Get a calendar's maximum date attribute.

        """
        return widget.PyGetUpperDateLimit()

    def activate_date(self, widget, date):
        """ Fire an event to indicate that a date was activated.

        """
        cal_event = wx.calendar.EVT_CALENDAR
        event = wx.calendar.CalendarEvent(widget, cal_event.typeId)
        event.PySetDate(date)
        widget.GetEventHandler().ProcessEvent(event)
        self.process_wx_events(self.app)

    def select_date(self, widget, date):
        """ Fire an event to indicate that a date was selected.

        """
        cal_select_event = wx.calendar.EVT_CALENDAR_SEL_CHANGED
        event = wx.calendar.CalendarEvent(widget, cal_select_event.typeId)
        widget.PySetDate(date)
        event.PySetDate(date)
        widget.GetEventHandler().ProcessEvent(event)
        self.process_wx_events(self.app)


########NEW FILE########
__FILENAME__ = test_wx_check_box
#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
import wx

from .wx_test_assistant import WXTestAssistant, skip_nonwindows
from .. import check_box

@skip_nonwindows
class TestWXCheckBox(WXTestAssistant, check_box.TestCheckBox):
    """ WXCheckbox tests. """

    def get_text(self, widget):
        """ Returns the text from the tookit widget.

        """
        return widget.GetLabel()

    def get_checked(self, widget):
        """ Returns the checked status from the tookit widget.

        """
        return widget.GetValue()

    def checkbox_pressed(self, widget):
        """ Press the checkbox programmatically.

        """
        self.send_wx_event(widget, wx.EVT_LEFT_DOWN)

    def checkbox_released(self, widget):
        """ Release the button programmatically.

        """
        self.send_wx_event(widget, wx.EVT_LEFT_UP)
        self.send_wx_event(widget, wx.EVT_LEAVE_WINDOW)

    def checkbox_toggle(self, widget):
        """ Toggle the button programmatically.

        """
        self.send_wx_event(widget, wx.EVT_CHECKBOX)

########NEW FILE########
__FILENAME__ = test_wx_combo_box
#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
import wx

from .wx_test_assistant import WXTestAssistant, skip_nonwindows

from .. import combo_box


@skip_nonwindows
class TestWXComboBox(WXTestAssistant, combo_box.TestComboBox):
    """ WXComboBox tests. 

    """
    def get_selected_text(self, widget):
        """ Get the current selected text of a combo box.

        """
        return widget.GetStringSelection()

    def get_item_text(self, widget, index):
        """ Get the text of a combo box item at a particular index.

        """
        return widget.GetString(index)

    def select_item(self, widget, index):
        """ Fire an event to simulate the selection of an item.

        """
        widget.SetSelection(index)
        self.send_wx_event(widget, wx.EVT_COMBOBOX)


########NEW FILE########
__FILENAME__ = test_wx_date_edit
#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
import wx

from enaml.backends.wx.wx_date_edit import to_wx_date, from_wx_date

from .wx_test_assistant import WXTestAssistant, skip_nonwindows
from .. import date_edit


@skip_nonwindows
class TestWXDateEdit(WXTestAssistant, date_edit.TestDateEdit):
    """ WXDateEdit tests. """

    def test_set_format(self):
        """ Test setting the output format

        """
        self.skipTest('Seetting the display format is not supported in'
                      ' native wxWidgets')

    def get_date(self, widget):
        """  Get the toolkits widget's active date.

        """
        date = widget.GetValue()
        return from_wx_date(date)

    def get_min_date(self, widget):
        """  Get the toolkits widget's maximum date attribute.

        """
        date = widget.GetLowerLimit()
        return from_wx_date(date)

    def get_max_date(self, widget):
        """ Get the toolkits widget's minimum date attribute.

        """
        date = widget.GetUpperLimit()
        return from_wx_date(date)

    def change_date(self, widget, date):
        """ Simulate a change date action at the toolkit widget.

        """
        wx_date = to_wx_date(date)
        widget.SetValue(wx_date)
        event_type = wx.EVT_DATE_CHANGED
        event = wx.DateEvent(widget, wx_date, event_type.typeId)
        widget.GetEventHandler().ProcessEvent(event)
        self.process_wx_events(self.app)

    def get_date_as_string(self, widget):
        """  Get the toolkits widget's active date as a string.

        """
        self.skipTest("The retrival of the date as string is not"
                      "implemented yet for the wx_toolkit")


########NEW FILE########
__FILENAME__ = test_wx_dialog
#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
import unittest
from . import test_wx_window
from .. import dialog


@unittest.skip('Wx Dialog must be run in an event loop to work')
class TestWXDialog(test_wx_window.TestWXWindow, dialog.TestDialog):
    """ WXDialog tests. """

    def get_title(self, widget):
        """ Get a window's title.

        """
        return widget.GetTitle()

    def disable_showing(self, widget):
        """ Disable the actual display of the dialog window.

        """
        widget.ShowModal = lambda:None



########NEW FILE########
__FILENAME__ = test_wx_field
#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from unittest import expectedFailure
import warnings

import wx

from .wx_test_assistant import WXTestAssistant, skip_nonwindows

from .. import field


warnings.simplefilter('ignore')


@skip_nonwindows
class TestWxField(WXTestAssistant, field.TestField):
    """ WXField tests. 

    """
    def get_value(self, widget):
        """ Get the visible text of a field.

        """
        self.process_wx_events(self.app)
        return widget.GetValue()

    def edit_text(self, widget, text):
        """ Simulate typing in a field.

        """
        widget.WriteText(text)
        self.send_wx_event(widget, wx.EVT_TEXT)
        self.process_wx_events(self.app)

    def change_text(self, widget, text):
        """ Change text programmatically, rather than "edit" it.

        """
        widget.ChangeValue(text)
        self.process_wx_events(self.app)

    def set_cursor_position(self, widget, index):
        """ Set the cursor at a specific position.

        """
        widget.SetInsertionPoint(index)
        self.process_wx_events(self.app)

    def get_cursor_position(self, widget):
        """ Get the cursor position.

        """
        self.process_wx_events(self.app)
        return widget.GetInsertionPoint()

    def get_password_mode(self, widget):
        """ Get the password mode status of the widget.

        Currently WXField only supports `password` and normal`.

        """
        # FIXME: specifically checking if we are using WX and the component
        # is set to 'silent' so that we can set the test to expected failure
        # we use this ugly hack.
        @expectedFailure
        def silent_password_mode(self):
            self.fail('Currently WXField only supports `password` and normal`.')

        component = self.component
        if component.password_mode == 'silent':
            silent_password_mode()

        self.process_wx_events(self.app)
        if widget.HasFlag(wx.TE_PASSWORD):
            return 'password'
        else:
            return 'normal'

    def get_selected_text(self, widget):
        """ Get the currently-selected text from a field.

        """
        self.process_wx_events(self.app)
        return widget.GetStringSelection()

    def press_return(self, widget):
        """ Simulate a press of the 'Return' key.

        """
        self.send_wx_event(widget, wx.EVT_TEXT_ENTER)
        self.process_wx_events(self.app)

    def gain_focus_if_needed(self, widget):
        """ Have the widget gain focus if required for the tests.

        """
        # wx doesn't seem to handle anything on the widget properly 
        # if the widget's not visible or doesn't have focus. So, in order 
        # for these tests to run, we need to gain focus on the widget. This
        # is not required in normal circumstances. Further, we can't get
        # widget to SetFocus before the value has been set, so we need
        # to "re-initialize" the widget it. This is really terrible and
        # it would be good to know which part of wx is broken so this
        # can be fixed.
        widget.SetFocus()
        val = self.component.value
        self.component.value = ''
        self.component.value = val


########NEW FILE########
__FILENAME__ = test_wx_group_box
#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
import wx

from .wx_test_assistant import WXTestAssistant, skip_nonwindows

from .. import group_box


@skip_nonwindows
class TestGroupBox(WXTestAssistant, group_box.TestGroupBox):

    def setUp(self):
        """ Setup for GroupBox testcases.

        1. Run the parent setup.
        2. Resize the widget and process events to allow for the private
           widgets to resize.

        """
        super(TestGroupBox, self).setUp()
        window = self.component_by_name(self.view, 'win')
        abstract = window.abstract_obj
        abstract.resize((200, 200))
        self.process_wx_events(self.app)

    def get_title(self, component, widget):
        """ Returns the title text from the tookit widget

        """
        self.process_wx_events(self.app)
        abstract = component.abstract_obj
        return abstract.widget.GetTitle()

    def get_flat(self, component, widget):
        """ Returns the flat style status from the tookit widget

        """
        self.process_wx_events(self.app)
        abstract = component.abstract_obj
        return abstract.widget.GetFlat()

    def get_title_align(self, component, widget):
        """ Returns the title aligment in the tookit widget

        """
        self.process_wx_events(self.app)
        # FIXME: this check depends on the size of the current window and
        # is not very reliable.
        abstract = component.abstract_obj
        align = abstract.widget.GetAlignment()
        if align == wx.ALIGN_LEFT:
            res = 'left'
        elif align == wx.ALIGN_CENTER:
            res = 'center'
        elif align == wx.ALIGN_RIGHT:
            res = 'right'
        else:
            res = 'undefined'
        return res


########NEW FILE########
__FILENAME__ = test_wx_html
#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from .wx_test_assistant import WXTestAssistant, skip_nonwindows
from .. import html


@skip_nonwindows
class TestWxHtml(WXTestAssistant, html.TestHtml):
    """ WXHtml tests. """

    def get_source(self, widget):
        """ Get the source of an Html widget.

        """
        return widget.ToText()


########NEW FILE########
__FILENAME__ = test_wx_label
#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from .wx_test_assistant import WXTestAssistant, skip_nonwindows
from .. import label


@skip_nonwindows
class TestWxLabel(WXTestAssistant, label.TestLabel):
    """ WXLabel tests. """

    def get_text(self, widget):
        """ Get a label's text.

        """
        return widget.GetLabel()

########NEW FILE########
__FILENAME__ = test_wx_operators
#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from .wx_test_assistant import WXTestAssistant, skip_nonwindows
from .. import operators

@skip_nonwindows
class TestWXLessLess(WXTestAssistant, operators.TestLessLess):
    """ TestSuite for the LessLess operator in WX.

    """
    def get_text(self, widget):
        """ Returns the label text from the tookit widget of Label.

        """
        return widget.GetLabel()

    def get_checked(self, widget):
        """ Returns the label text from the tookit widget of CheckBox.

        """
        return widget.GetValue()

########NEW FILE########
__FILENAME__ = test_wx_progress_bar
#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from .wx_test_assistant import WXTestAssistant, skip_nonwindows
from .. import progress_bar


@skip_nonwindows
class TestWXProgressBar(WXTestAssistant, progress_bar.TestProgressBar):
    """ WXProgressBar tests.

    .. note:: The wx test uses the extended signature because the range and
        value of the progress bar is related to the minimum attribute.

    """

    def get_value(self, component, widget):
        """  Get the toolkits widget's active value.

        """
        return widget.GetValue() + component.minimum

    def get_minimum(self, component, widget):
        """  Get the toolkits widget's maximum value attribute.

        .. note:: The minimum value is maintained only in the component

        """
        return component.minimum

    def get_maximum(self, component, widget):
        """ Get the toolkits widget's minimum value attribute.

        """
        return widget.GetRange() - component.minimum

########NEW FILE########
__FILENAME__ = test_wx_push_button
#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
import wx

from .wx_test_assistant import WXTestAssistant, skip_nonwindows
from .. import push_button


@skip_nonwindows
class TestWxPushButton(WXTestAssistant, push_button.TestPushButton):
    """ WXPushButton tests. """

    def button_pressed(self):
        """ Press the button programmatically.

        """
        self.send_wx_event(self.widget, wx.EVT_LEFT_DOWN)

    def button_released(self):
        """ Release the button programmatically.

        """
        widget = self.widget
        self.send_wx_event(widget, wx.EVT_LEFT_UP)
        self.send_wx_event(widget, wx.EVT_LEAVE_WINDOW)

    def button_clicked(self):
        """ Click the button programmatically.

        """
        self.send_wx_event(self.widget, wx.EVT_BUTTON)


########NEW FILE########
__FILENAME__ = test_wx_radio_button
#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from .wx_test_assistant import WXTestAssistant, skip_nonwindows
from .. import radio_button


@skip_nonwindows
class TestWxRadioButton(WXTestAssistant, radio_button.TestRadioButton):
    """ WXRadioButton tests. """

    def get_value(self, button):
        """ Get the checked state of a radio button.

        """
        self.process_wx_events(self.app)
        return button.GetValue()

    def get_text(self, button):
        """ Get the label of a button.

        """
        return button.GetLabel()

########NEW FILE########
__FILENAME__ = test_wx_slider
#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from unittest import expectedFailure
import wx

from .wx_test_assistant import WXTestAssistant, skip_nonwindows

from .. import slider


# A map from wxSlider constants to Enaml TickPosition values.
TICK_POS_MAP = {wx.SL_BOTTOM: 'bottom',
                wx.SL_LEFT: 'left' ,
                wx.SL_RIGHT: 'right',
                wx.SL_TOP: 'top',
                wx.SL_BOTTOM: 'bottom',
                wx.SL_BOTH: 'both',
                wx.SL_TICKS: 'Ticks'}

# A map from Wx constants to Enaml enums for horizontal or vertical orientation.
ORIENTATION_MAP = {wx.SL_HORIZONTAL: 'horizontal',
                   wx.SL_VERTICAL: 'vertical'}

# Map event actions to WX constants
EVENT_MAP = {slider.TestEvents.PRESSED: wx.EVT_LEFT_DOWN,
             slider.TestEvents.RELEASED: wx.EVT_LEFT_UP,
             slider.TestEvents.HOME: wx.EVT_SCROLL_BOTTOM,
             slider.TestEvents.END: wx.EVT_SCROLL_TOP,
             slider.TestEvents.STEP_UP: wx.EVT_SCROLL_LINEUP,
             slider.TestEvents.STEP_DOWN: wx.EVT_SCROLL_LINEDOWN,
             slider.TestEvents.PAGE_UP: wx.EVT_SCROLL_PAGEUP,
             slider.TestEvents.PAGE_DOWN: wx.EVT_SCROLL_PAGEDOWN}


@skip_nonwindows
class TestWXSlider(WXTestAssistant, slider.TestSlider):
    """ QtLabel tests. """

    def setUp(self):
        """ Setup the slider testing based on the wx backend.

        Special care is needed because we need to have a specific size
        of the wx slider in order to properly check the firing of the
        pressed thumb event.

        """
        super(TestWXSlider, self).setUp()
        self.widget.SetSize(wx.Size(200,20))

    # This test fails on windows under wx because the underlying size of the
    # of the widget is not reliable. So the precomputed mouse position for
    # the mouse event which is sent can be wrong.
    @expectedFailure
    def test_releasing_the_thumb(self):
        super(TestWXSlider, self).test_relleasing_the_thumb(self)

    def get_value(self, widget):
        """ Get a slider's position.

        """
        return widget.GetValue()

    def get_minimum(self, widget):
        """ Get the Slider's minimum value.

        """
        return widget.GetMin()

    def get_maximum(self, widget):
        """ Get the Slider's maximum value.

        """
        return widget.GetMax()

    def get_tick_interval(self, widget):
        """ Get the Slider's tick_interval value.

        """
        return widget.GetTickFreq()

    def get_tick_position(self, widget):
        """ Get the Slider's tick position style.

        Assertion errors are raised when it is not posible to estimate the
        tick positiosn.

        """
        style = widget.GetWindowStyle()
        flags = []
        for flag in TICK_POS_MAP.keys():
            if flag & style:
                flags.append(TICK_POS_MAP[flag])

        number_of_flags = len(flags)
        if number_of_flags == 0:
            return 'no_ticks'
        elif number_of_flags == 1:
            self.fail('The tick position style is expected to have at least'
                      ' two style bits set when the ticks are visible')
        elif number_of_flags == 2:
            self.assertIn('Ticks', flags, 'When the ticks are visible'
                      ' the position style is expected to have the wx.SL_TICKS'
                      ' bit set')
            flags.pop(flags.index('Ticks'))
        else:
            self.fail('More than two tick position style flags are set')

        return flags[0]

    def get_orientation(self, widget):
        """ Get the Slider's orientation.

        """
        style = widget.GetWindowStyle()
        flags = []
        for flag in ORIENTATION_MAP.keys():
            if flag & style:
                flags.append(ORIENTATION_MAP[flag])

        number_of_flags = len(flags)

        if number_of_flags == 0:
            self.fail('Orientation should be always set in the widget')
        elif number_of_flags > 1:
            self.fail('More than one orientation style flags are set')

        return flags[0]

    def get_single_step(self, widget):
        """ Get the Slider's single step value.

        """
        return widget.GetLineSize()

    def get_page_step(self, widget):
        """ Get the Slider's page step value.

        """
        return widget.GetPageSize()

    def get_tracking(self, widget):
        """ Get the Slider's tracking status.

        """
        return self.component.tracking

    def send_event(self, widget, event):
        """ Send an event to the Slider programmatically.

        Arguments
        ---------
        widget :
            The widget to sent the event to.

        event :
            The desired event to be proccessed.

        """
        event_type = EVENT_MAP[event]
        if  event_type in (wx.EVT_LEFT_DOWN, wx.EVT_LEFT_UP):
            position = wx.Point(100,10)
            self.send_wx_mouse_event(widget, event_type, position=position)
        else:
            value = widget.GetValue()
            if event_type == wx.EVT_SCROLL_BOTTOM:
                value = widget.GetMin()
            elif event_type == wx.EVT_SCROLL_TOP:
                value = widget.GetMax()
            elif event_type == wx.EVT_SCROLL_LINEUP:
                value += widget.GetLineSize()
            elif event_type == wx.EVT_SCROLL_LINEDOWN:
                value -= widget.GetLineSize()
            elif event_type == wx.EVT_SCROLL_PAGEUP:
                value += widget.GetPageSize()
            elif event_type == wx.EVT_SCROLL_PAGEDOWN:
                value -= widget.GetPageSize()

            widget.SetValue(value)
            event = wx.ScrollEvent(event_type.typeId, widget.GetId())
            widget.GetEventHandler().ProcessEvent(event)
        self.process_wx_events(self.app)

########NEW FILE########
__FILENAME__ = test_wx_spin_box
#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
import wx

from .wx_test_assistant import WXTestAssistant, skip_nonwindows

from .. import spin_box


@skip_nonwindows
class TestWxSpinBox(WXTestAssistant, spin_box.TestSpinBox):
    """ WXSpinBox tests. """

    def get_value(self, widget):
        """ Get a spin box's value.

        """
        return widget.GetValue()

    def get_low(self, widget):
        """ Get a spin box's minimum value.

        """
        return widget.GetLow()

    def get_high(self, widget):
        """ Get a spin box's maximum value.

        """
        return widget.GetHigh()

    def get_step(self, widget):
        """ Get a spin box's step size.

        """
        return widget.GetStep()

    def get_wrap(self, widget):
        """ Check if a spin box wraps around at the edge values.

        """
        return widget.GetWrap()

    def get_text(self, widget):
        """ Get the text displayed in a spin box.

        """
        return widget._value_string

    def spin_up_event(self, widget):
        """ Simulate a click on the 'up' spin button.

        """
        event = wx.SpinEvent(wx.EVT_SPIN_UP.typeId)
        widget.OnSpinUp(event)
        self.process_wx_events(wx.GetApp())

    def spin_down_event(self, widget):
        """ Simulate a click on the 'down' spin button.

        """
        event = wx.SpinEvent(wx.EVT_SPIN_DOWN.typeId)
        widget.OnSpinDown(event)
        self.process_wx_events(wx.GetApp())


########NEW FILE########
__FILENAME__ = test_wx_toggle_button
#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
import wx

from .wx_test_assistant import WXTestAssistant, skip_nonwindows

from .. import toggle_button

@skip_nonwindows
class TestWXToggleButton(WXTestAssistant, toggle_button.TestToggleButton):
    """ WXToggleButton tests. 
    
    """
    def get_text(self, widget):
        """ Returns the text from the tookit widget.

        """
        return widget.GetLabel()

    def get_checked(self, widget):
        """ Returns the checked status from the tookit widget.

        """
        return widget.GetValue()

    def toggle_button_pressed(self, widget):
        """ Press the toggle button programmatically.

        """
        self.send_wx_event(widget, wx.EVT_LEFT_DOWN)

    def toggle_button_released(self, widget):
        """ Release the button programmatically.

        """
        self.send_wx_event(widget, wx.EVT_LEFT_UP)
        self.send_wx_event(widget, wx.EVT_LEAVE_WINDOW)

    def toggle_button_toggle(self, widget):
        """ Toggle the button programmatically.

        """
        self.send_wx_event(widget, wx.EVT_TOGGLEBUTTON)


########NEW FILE########
__FILENAME__ = test_wx_window
#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from .wx_test_assistant import WXTestAssistant, skip_nonwindows
from .. import window

@skip_nonwindows
class TestWXWindow(WXTestAssistant, window.TestWindow):
    """ WXWindow tests. """

    def get_title(self, widget):
        """ Get a window's title.

        """
        return widget.GetTitle()


########NEW FILE########
__FILENAME__ = wx_test_assistant
#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------

import sys
from unittest import skipUnless

import wx

from enaml import wx_toolkit


skip_nonwindows = skipUnless(sys.platform.startswith('win'),
    "The wx backend is only supported on Windows.")


class WXTestAssistant(object):
    """ Assistant class for testing wx based components.

    This class is to be used as a mixing aling with the base enaml test case
    class for the components tests of the wx backend. It sets the correct
    toolkit attribute and provides some useful methods to mock events in
    wx.

    """

    toolkit = wx_toolkit()

    def process_wx_events(self, app):
        """ Process posted wxPython events.

        Tests that require resize, move and show/hide or generic event
        response take place need to call this method.

        """
        app.ProcessPendingEvents()

    def send_wx_event(self, widget, event_type):
        """ Send a wxPython widget an event (e.g., EVT_BUTTON).

        """
        event = wx.PyCommandEvent(event_type.typeId, widget.GetId())
        widget.GetEventHandler().ProcessEvent(event)
        self.process_wx_events(self.app)

    def send_wx_mouse_event(self, widget, event_type, position=None):
        """ Send a wxPython widget an mouse event (e.g., EVT_BUTTON).

        """
        event = wx.MouseEvent(event_type.typeId)
        if position is None:
            event.m_x = 0
            event.m_y = 0
        else:
            event.m_x = position.x
            event.m_y = position.y
        widget.GetEventHandler().ProcessEvent(event)
        self.process_wx_events(self.app)

########NEW FILE########
__FILENAME__ = test_constraints_widget
#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from unittest import TestCase

from traits.api import TraitError

from ..widgets.constraints_widget import ConstraintsWidget


class TestLayoutComponent(TestCase):
    """ Test basic operations on LayoutComponents.

    """
    def test_hug_property(self):
        """ Test that the hug property works correctly.

        """
        good_values = ['ignore', 'weak', 'medium', 'strong', 'required']
        bad_values = ['Ignore', None, 'srong']

        comp = ConstraintsWidget()

        for good_val in good_values:
            comp.hug_width = good_val
            comp.hug_height = good_val
            self.assertEqual(comp.hug_width, good_val)
            self.assertEqual(comp.hug_height, good_val)

        for bad_val in bad_values:
            self.assertRaises(TraitError, comp.trait_set, hug_width=bad_val)
            self.assertRaises(TraitError, comp.trait_set, hug_height=bad_val)

    def test_resist_clip_property(self):
        """ Test that the resist_clip property works correctly.

        """
        good_values = ['ignore', 'weak', 'medium', 'strong', 'required']
        bad_values = ['Ignore', None, 'srong']

        comp = ConstraintsWidget()

        for good_val in good_values:
            comp.resist_width = good_val
            comp.resist_height = good_val
            self.assertEqual(comp.resist_width, good_val)
            self.assertEqual(comp.resist_height, good_val)

        for bad_val in bad_values:
            self.assertRaises(TraitError, comp.trait_set, resist_width=bad_val)
            self.assertRaises(TraitError, comp.trait_set, resist_height=bad_val)


########NEW FILE########
__FILENAME__ = test_geometry
#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from __future__ import absolute_import

import unittest
import cPickle

from enaml.layout import geometry


class TestPickleGeometry(unittest.TestCase):
    def check_pickling(self, cls, nargs):
        args = (0,) * nargs
        obj = cls(*args)
        pickled = cPickle.dumps(obj, protocol=cPickle.HIGHEST_PROTOCOL)
        unpickled = cPickle.loads(pickled)
        self.assertEqual(obj, unpickled)

    def test_base_rect(self):
        self.check_pickling(geometry.BaseRect, 4)

    def test_rect(self):
        self.check_pickling(geometry.Rect, 4)

    def test_rect_f(self):
        self.check_pickling(geometry.RectF, 4)

    def test_base_box(self):
        self.check_pickling(geometry.BaseBox, 4)

    def test_box(self):
        self.check_pickling(geometry.Box, 4)

    def test_box_f(self):
        self.check_pickling(geometry.BoxF, 4)

    def test_base_pos(self):
        self.check_pickling(geometry.BasePos, 2)

    def test_pos(self):
        self.check_pickling(geometry.Pos, 2)

    def test_pos_f(self):
        self.check_pickling(geometry.PosF, 2)

    def test_base_size(self):
        self.check_pickling(geometry.BaseSize, 2)

    def test_size(self):
        self.check_pickling(geometry.Size, 2)

    def test_size_f(self):
        self.check_pickling(geometry.SizeF, 2)


########NEW FILE########
__FILENAME__ = test_import_hooks
#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
import sys
import unittest

from enaml.core import import_hooks


class FakeSys(object):
    def __init__(self):
        self.meta_path = []


class TestImportHooks(unittest.TestCase):

    def setUp(self):
        # Monkey-patch "sys" in the import_hooks module.
        import_hooks.sys = FakeSys()

    def tearDown(self):
        import_hooks.sys = sys

    def test_install_count(self):
        """ Test that EnamlImporter can be installed in a nested manner.

        """
        importer = import_hooks.EnamlImporter
        counts = importer._install_count
        meta_path = import_hooks.sys.meta_path

        self.assertEquals(counts[importer], 0)
        self.assertEquals(len(meta_path), 0)

        importer.install()
        self.assertEquals(counts[importer], 1)
        self.assertEquals(len(meta_path), 1)

        importer.install()
        self.assertEquals(counts[importer], 2)
        self.assertEquals(len(meta_path), 1)

        importer.uninstall()
        self.assertEquals(counts[importer], 1)
        self.assertEquals(len(meta_path), 1)

        importer.uninstall()
        self.assertEquals(counts[importer], 0)
        self.assertEquals(len(meta_path), 0)


########NEW FILE########
__FILENAME__ = test_bounded
#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
import unittest
from datetime import date

from traits.api import (HasStrictTraits, TraitError, Float, Instance, Date)

from enaml.core.trait_types import Bounded

class Test_Bounded_Static(unittest.TestCase):
    """ Test the use of the Bounded trait with static bounds.

    """
    @classmethod
    def setUpClass(self):

        class my_class(HasStrictTraits):

            value = Bounded(0.2, 0, 4)

        self.traits_class = my_class

    def setUp(self):
        self.traits_instance = self.traits_class()

    def test_init(self):
        """ Test basic static initialization """
        value = self.traits_instance.value
        self.assertAlmostEqual(value, 0.2)

    def test_assigment(self):
        """ Test static assigment """
        instance = self.traits_instance
        instance.value = 0.7
        self.assertAlmostEqual(instance.value, 0.7)

    def test_invalid(self):
        """ Test static assigment """
        instance = self.traits_instance
        with self.assertRaises(TraitError):
            instance.value = -2

class Test_Bounded_Dynamic(unittest.TestCase):
    """ Test the use of the Bounded trait with dynamic bounds.

    """
    @classmethod
    def setUpClass(self):

        class my_class(HasStrictTraits):

            low = Float(0)
            high = Float(4)
            value = Bounded(0.2, low='low', high='high')

        self.traits_class = my_class

    def setUp(self):
        self.traits_instance = self.traits_class()

    def test_init(self):
        """ Test dynamic initialization. """
        value = self.traits_instance.value
        self.assertAlmostEqual(value, 0.2)

    def test_assigment(self):
        """ Test assigment. """
        instance = self.traits_instance
        instance.value = 0.7
        self.assertAlmostEqual(instance.value, 0.7)

    def test_invalid(self):
        """ Test invalid assigment. """
        instance = self.traits_instance
        with self.assertRaises(TraitError):
            instance.value = -2

    def test_change_lower(self):
        """ Test changing the lower bound. """
        instance = self.traits_instance
        instance.low = -4.0
        instance.value = -2
        self.assertAlmostEqual(instance.value, -2)

    def test_change_upper(self):
        """ Test changing the upper bound. """
        instance = self.traits_instance
        instance.high =  6.0
        instance.value =  5.7
        self.assertAlmostEqual(instance.value, 5.7)

class Test_Bounded_Special(unittest.TestCase):
    """ Test special use cases for the Bounded trait.

    """
    def test_inner_bound_class(self):
        """ Test dynamic initialization with inner class.

        """
        class small_class(HasStrictTraits):
            low = Float(0)
            high = Float(2)

        class main_class(HasStrictTraits):
            bounds = Instance(small_class, ())
            value = Bounded(0.2, 'bounds.low', 'bounds.high')

        instance = main_class()
        instance.value = 0.2
        self.assertAlmostEqual(instance.value, 0.2)

        with self.assertRaises(TraitError):
            instance.value = -1

    def test_bounded_traits(self):
        """ Test initialization with Trait Class

        """
        class main_class(HasStrictTraits):
            value = Bounded(Date(date(2007,12, 18)),
                            date(2003,12, 18),
                            date(2010,12, 18))

        instance = main_class()
        self.assertEqual(instance.value, date(2007,12, 18))

        with self.assertRaises(TraitError):
            instance.value = 0.2

        instance.value = date(2008,12, 18)
        self.assertEqual(instance.value, date(2008,12, 18))

    def test_bounded_python(self):
        """ Test initialization wiht complex python object.

        """
        class main_class(HasStrictTraits):
            value = Bounded(date(2007,12, 18),
                            date(2003,12, 18),
                            date(2010,12, 18))

        instance = main_class()
        self.assertEqual(instance.value, date(2007,12, 18))
        with self.assertRaises(TraitError):
            instance.value = 0.2

        instance.value = date(2008,12, 18)
        self.assertEqual(instance.value, date(2008,12, 18))
########NEW FILE########
__FILENAME__ = test_number_validators
#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
import unittest

from enaml.validation.api import (
    IntValidator, FloatValidator, RegexValidator
)


class ValidatorTestCase(unittest.TestCase):
    """ Simple class exposing assertValid and asertInvalid methods to test
    validators. """

    def assertValid(self, validator, value):
        self.assertTrue(validator.validate(value, None)[1])

    def assertInvalid(self, validator, value):
        self.assertFalse(validator.validate(value, None)[1])


class TestIntValidator(ValidatorTestCase):

    def test_int_validator(self):
        v = IntValidator()
        self.assertInvalid(v, u'k')
        self.assertValid(v, u'12')
        self.assertValid(v, u'-12')
        self.assertInvalid(v, u'1e7')

    def test_number_out_of_range(self):
        v = IntValidator(minimum=10, maximum=89)
        self.assertValid(v, u'12')
        self.assertInvalid(v, u'-12')
        self.assertInvalid(v, u'9')
        self.assertInvalid(v, u'60k')


class TestFloatValidator(ValidatorTestCase):

    def test_int_validator(self):
        v = FloatValidator()
        self.assertInvalid(v, u'k')
        self.assertValid(v, u'12')
        self.assertValid(v, u'-12')
        self.assertValid(v, u'1e7')

    def test_number_out_of_range(self):
        v = FloatValidator(minimum=10, maximum=89)
        self.assertValid(v, u'12')
        self.assertInvalid(v, u'-12')
        self.assertInvalid(v, u'9')
        self.assertInvalid(v, u'60k')

    def test_validator_no_exponent(self):
        v = FloatValidator(allow_exponent=False, minimum=10)
        self.assertValid(v, u'12')
        self.assertInvalid(v, u'9')
        self.assertInvalid(v, u'60k')

########NEW FILE########
__FILENAME__ = enaml_test_case
#------------------------------------------------------------------------------
#  Copyright (c) 2011-2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from contextlib import contextmanager
import itertools
import types
import unittest

from enaml.core.parser import parse
from enaml.core.enaml_compiler import EnamlCompiler
from enaml.stdlib.sessions import simple_session

from enaml.qt.qt_application import QtApplication

class TestingQtApplication(QtApplication):
    """ Custom application used only by the testing framework for QT.

    It prevent the application from starting the event loop and exposes a
    function as a context manager to execute a set of actions before forcing the
    events to be processed.

    """
    def start(self):
        """ Start the application's main event loop.

        """
        pass

    @contextmanager
    def process_events(self):
        """ Process all the pending events on the QT event loop.

        This method is for testing only. It runs the event loop and process all
        the events.

        """
        yield

        # From QT Documentation
        # Immediately dispatches all events which have been previously queued
        # with QCoreApplication::postEvent().
        # Events from the window system are not dispatched by this function,
        # but by processEvents().
        self._qapp.sendPostedEvents()

        # Processes all pending events for the calling thread
        self._qapp.processEvents()


_session_counter = itertools.count()
def get_unique_session_identifier():
    """ Returns a 'unique' name for a session. """
    return 'session_%d' % _session_counter.next()


class EnamlTestCase(unittest.TestCase):
    """ Base class for testing Enaml object widgets.

    This class provide utility methods functions to help the testing of
    enaml components.

    """
    def find_client_widget(self, root, type_name):
        """ A simple function that recursively walks a widget tree until it
        finds a widget of a particular type.

        """

        if type_name in [ cls.__name__ for cls in type(root).__mro__]:
            return root.widget()

        for child in root.children():
            found = self.find_client_widget(child, type_name)
            if found is not None:
                return found

        return None

    def find_server_widget(self, root, type_name):
        """ A simple function that recursively walks a widget tree until it
        finds a widget of a particular type.

        """
        if type_name in [cls.__name__ for cls in type(root).__mro__]:
            return root

        for child in root.children:
            found = self.find_server_widget(child, type_name)
            if found is not None:
                return found

        return None

    def parse_and_create(self, source, **kwargs):
        """ Parses and compiles the source. The source should have a
        component defined with the name 'MainView'.

        Arguments
        ---------
        source : str
            The enaml source file

        kwargs : dict
            The default attribute values to pass to the component.

        Returns
        -------
            The component tree for the 'MainView' component.

        """
        enaml_ast = parse(source)
        enaml_module = types.ModuleType('__tests__')
        ns = enaml_module.__dict__
        code = EnamlCompiler.compile(enaml_ast, '__enaml_tests__')

        exec code in ns
        View = ns['MainView']

        # Start the app instance first.
        session_name =  get_unique_session_identifier()
        view_factory = simple_session(session_name, 'test', View)

        self.app = TestingQtApplication.instance()

        if self.app is None:
            self.app = TestingQtApplication([])

        self.app.add_factories([view_factory])

        session_id = self.app.start_session(session_name)

        self.app.start()

        session = self.app._sessions[session_id]

        # retrieve the enaml server side root widget
        self.view = session.windows[0]

        # retrieve the enaml client side root widget
        self.client_view = self.app._qt_sessions[session_id]._windows[0]

    def tearDown(self):

        self.app.stop()


########NEW FILE########
__FILENAME__ = test_combo_box
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from .enaml_test_case import EnamlTestCase


class TestComboBox(EnamlTestCase):
    """ Unit tests for the ComboBox widget.

    """

    def setUp(self):
        enaml_source = """
from enaml.widgets.api import ComboBox, Window

enamldef MainView(Window):
    ComboBox:
        items = ["foo", "bar", "baz"]
"""
        self.parse_and_create(enaml_source)
        self.server_widget = self.find_server_widget(self.view, "ComboBox")
        self.client_widget = self.find_client_widget(
            self.client_view, "QtComboBox"
        )

    def test_set_items(self):
        """ Test the setting of a ComboBox's items attribute. """

        expected_result =  ["foo", "bar", "baz", "qux"]

        index_before_setting_value = self.server_widget.index

        with self.app.process_events():
            self.server_widget.items = expected_result

        result = [
            self.client_widget.itemText(i) for i in xrange(self.client_widget.count())
        ]

        self.assertEquals(expected_result, result)
        self.assertEquals(index_before_setting_value, self.server_widget.index)


    def test_set_value(self):
        """ Test the setting of a ComboBox's value attribute. """

        self.assertEquals(-1, self.server_widget.index)

        with self.app.process_events():
            self.server_widget.items = ["foo", "bar", "baz"]
            self.server_widget.index = 1

        self.assertEquals(self.server_widget.index, 1)

        self.assertEquals(self.server_widget.index, self.client_widget.currentIndex())

        with self.app.process_events():
            self.server_widget.index = 2

        self.assertEquals(self.server_widget.index, self.client_widget.currentIndex())

        with self.app.process_events():
            self.client_widget.setCurrentIndex(0)

        self.assertEquals(self.server_widget.index, self.client_widget.currentIndex())

    def test_set_value_and_index(self):
        """ Test the setting of a ComboBox's items and  value attribute. """

        self.assertEquals(-1, self.server_widget.index)

        with self.app.process_events():
            self.server_widget.items.append("bb")
            self.server_widget.index = 1

        self.assertEquals(1, self.server_widget.index)

        self.assertEquals(self.server_widget.index, self.client_widget.currentIndex())

class TestComboBoxLoopbackIssue(EnamlTestCase):
    """ A different set of unit tests for the ComboBox widget that are failing
    if the index is not protected on the client side with a loopback_guard

    """

    def setUp(self):
        enaml_source = """
from enaml.widgets.api import ComboBox, Window, PushButton

enamldef MainView(Window):
    ComboBox:
        id: cb
        items = []

    PushButton:
        clicked::
            print 'Clicked'
            cb.items = ['1', '2', '3']
            cb.index = 1
"""
        self.parse_and_create(enaml_source)
        self.server_widget = self.find_server_widget(self.view, "ComboBox")
        self.client_widget = self.find_client_widget(
            self.client_view, "QtComboBox"
        )

    def test_set_value(self):
        """ Test the setting of a ComboBox's value attribute with an empty list. 

        Changing the empty list triggers an on_index_changed call on the client
        side that seem to bypass the server set_index call. The problem does not
        happen when the list is not empty.
        """

        with self.app.process_events():
            self.server_widget.items = ["foo", "bar", "baz"]
        with self.app.process_events():
            self.server_widget.index = 1

        self.assertEquals(self.server_widget.index, 1)
        self.assertEquals(self.server_widget.index, self.client_widget.currentIndex())


    def test_set_value_from_button(self):
        """ Test the setting of a ComboBox's value attribute with an empty list. 

        Same test as test_set_value but using a PushButton (closer to reality)
        """

        button = self.find_client_widget(self.client_view, 'QtPushButton')

        with self.app.process_events():
            button.click()

        self.assertEquals(self.client_widget.currentIndex(), 1)
        self.assertEquals(self.server_widget.index, 1)
        self.assertEquals(
            self.server_widget.index, self.client_widget.currentIndex()
        )



if __name__ == '__main__':
    import unittest
    unittest.main()


########NEW FILE########
__FILENAME__ = test_constraints_widget
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from .enaml_test_case import EnamlTestCase


class TestConstraintsWidget(EnamlTestCase):
    """ Unit tests for the ConstraintsWidget widget. The QtConstraintsWidget
    cannot be instantiated directly. To test the behaviour, we check that
    a Field stored within a Container will be properly updated if we change
    the ConstraintsWidget attribute on the server side.

    """

    def setUp(self):
        enaml_source = """
from enaml.widgets.api import Window, Field, Container

enamldef MainView(Window):
    initial_size = (500, 100)
    Container:
        Field:
            pass
"""
        self.parse_and_create(enaml_source)
        self.server_widget = self.find_server_widget(self.view, "ConstraintsWidget")
        self.client_widget = self.find_client_widget(self.client_view, "QtConstraintsWidget")

    def test_set_hug(self):
        """ Test the setting of a ConstraintsWidget's hug attribute
        """

        initial_size = self.client_widget.size()

        with self.app.process_events():
            self.server_widget.hug_width = 'ignore'
            self.server_widget.hug_height = 'weak'

        self.assertNotEqual(initial_size, self.client_widget.size())

    def test_set_resist_clip(self):
        """ Test the setting of a ConstraintsWidget's resist_clip attribute
        """


        initial_size = self.client_widget.size()

        with self.app.process_events():
            self.server_widget.resist_width = 'required'
            self.server_widget.resist_height = 'medium'

        self.assertNotEqual(initial_size, self.client_widget.size())


    # XXX Add more tests

if __name__ == '__main__':
    import logging
    import unittest
    logging.basicConfig(level=logging.DEBUG)
    unittest.main()

########NEW FILE########
__FILENAME__ = test_container
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from .enaml_test_case import EnamlTestCase


class TestContainer(EnamlTestCase):
    """ Unit tests for the Container widget.

    """

    def setUp(self):
        enaml_source = """
from enaml.widgets.api import Container, Window, Field

enamldef MainView(Window):
    Container:
        hug_width = 'strong'
        hug_height = 'strong'
"""
        self.parse_and_create(enaml_source)
        self.server_widget = self.find_server_widget(self.view, "Container")
        self.client_widget = self.find_client_widget(self.client_view, "QtContainer")

    def test_set_padding(self):
        """ Test the setting of a Container's padding attribute
        """

        initial_size = self.client_widget.size().toTuple()

        with self.app.process_events():
            self.server_widget.padding = (0,0,0,0)

        # ensure changing the padding has an impact on the client size. 
        # Removing the padding should make the container larger
        no_padding_size = self.client_widget.size().toTuple()

        self.assertTrue(initial_size[0] < no_padding_size[0])
        self.assertTrue(initial_size[1] < no_padding_size[1])

if __name__ == '__main__':
    import unittest
    unittest.main()

########NEW FILE########
__FILENAME__ = test_datetime_selector
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
import datetime

from .enaml_test_case import EnamlTestCase

ONE_SECOND_DELTA = datetime.timedelta(seconds=1)

class TestDatetimeEdit(EnamlTestCase):
    """ Unit tests for the DatetimeEdit widget.

    """

    def setUp(self):
        enaml_source = """
from enaml.widgets.api import DatetimeSelector, Window

enamldef MainView(Window):
    DatetimeSelector:
        pass
"""
        self.parse_and_create(enaml_source)
        self.server_widget = self.find_server_widget(self.view, "DatetimeSelector")
        self.client_widget = self.find_client_widget(self.client_view, "QtDatetimeSelector")

    def test_set_date_format(self):
        """ Test the setting of a DateTimeSelector's date_format attribute.
        """

        with self.app.process_events():
            self.server_widget.datetime_format = "%m/%d/%Y"

        self.assertEquals(self.client_widget.displayFormat(), self.server_widget.datetime_format)


    ### Testing the BoundedDate interface

    def test_set_minimum_and_maximum(self):
        """ Test the setting of a BoundedDate's miminum and maximum attribute.
        """

        now = datetime.datetime.now()

        with self.app.process_events():
            self.server_widget.minimum = now
            self.server_widget.maximum = now + datetime.timedelta(days=7)



        self.assertTrue(
            self.client_widget.minimumDateTime().toPython() -  now < ONE_SECOND_DELTA)
        self.assertTrue(
            self.client_widget.minimumDateTime().toPython() - self.server_widget.minimum <  ONE_SECOND_DELTA
        )
        self.assertTrue(
            self.client_widget.maximumDateTime().toPython() - self.server_widget.maximum < ONE_SECOND_DELTA
        )

    def test_set_maximum_with_date_update(self):
        """ Test the setting of a BoundedDate's maximum attribute having an impact on the
        current date selected.
        """

        maximum_date =  datetime.datetime.now() - datetime.timedelta(days=7)

        with self.app.process_events():
            self.server_widget.maximum = maximum_date

        self.assertTrue(
            self.client_widget.dateTime().toPython() - maximum_date < ONE_SECOND_DELTA
        )

    # XXX: Need to test the receive_date_changed() method

if __name__ == '__main__':
    import unittest
    unittest.main()

########NEW FILE########
__FILENAME__ = test_date_selector
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
import datetime

from .enaml_test_case import EnamlTestCase


class TestDateSelector(EnamlTestCase):
    """ Unit tests for the DateSelector widget.

    """

    def setUp(self):
        enaml_source = """
from enaml.widgets.api import DateSelector, Window

enamldef MainView(Window):
    DateSelector:
        pass
"""
        self.parse_and_create(enaml_source)
        self.server_widget = self.find_server_widget(self.view, "DateSelector")
        self.client_widget = self.find_client_widget(self.client_view, "QtDateSelector")

    def test_set_date_format(self):
        """ Test the setting of a DateSelector's date_format attribute.
        """

        with self.app.process_events():
            self.server_widget.date_format = "%m/%d/%Y"

        self.assertEquals(self.client_widget.displayFormat(), self.server_widget.date_format)


    ### Testing the BoundedDate interface

    def test_set_minimum_and_maximum(self):
        """ Test the setting of a BoundedDate's miminum and maximum attribute.
        """

        with self.app.process_events():
            self.server_widget.minimum = datetime.date.today()
            self.server_widget.maximum = datetime.date.today() + datetime.timedelta(days=7)

        self.assertEquals(
            self.client_widget.minimumDateTime().toPython().date(), datetime.date.today()
        )
        self.assertEquals(
            self.client_widget.minimumDateTime().toPython().date(), self.server_widget.minimum
        )
        self.assertEquals(
            self.client_widget.maximumDateTime().toPython().date(), self.server_widget.maximum
        )

    def test_set_maximum_with_date_update(self):
        """ Test the setting of a BoundedDate's maximum attribute having an impact on the
        current date selected.
        """

        maximum_date =  datetime.date.today() - datetime.timedelta(days=7)

        with self.app.process_events():
            self.server_widget.maximum = maximum_date

        self.assertEquals(self.client_widget.date().toPython(), maximum_date)

    # XXX: Need to test the receive_date_changed() method

if __name__ == '__main__':
    import unittest
    unittest.main()

########NEW FILE########
__FILENAME__ = test_field
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from enaml.validation.api import IntValidator

from .enaml_test_case import EnamlTestCase

from enaml.qt.qt_field import ECHO_MODES


class TestField(EnamlTestCase):
    """ Unit tests for the Field widget.

    """

    def setUp(self):
        enaml_source = """
from enaml.widgets.api import Field, Window

enamldef MainView(Window):
    Field:
        pass
"""
        self.parse_and_create(enaml_source)
        self.server_widget = self.find_server_widget(self.view, "Field")
        self.client_widget = self.find_client_widget(self.client_view, "QtField")

    def test_set_max_length(self):
        """ Test the setting of a Field's max_length attribute
        """
        with self.app.process_events():
            self.server_widget.max_length = 100

        self.assertEquals(self.client_widget.maxLength(), self.server_widget.max_length)

    def test_set_password_mode(self):
        """ Test the setting of a Field's password_mode attribute
        """
        with self.app.process_events():
            self.server_widget.echo_mode = 'silent'

        self.assertEquals(
            self.client_widget.echoMode(),
            ECHO_MODES[self.server_widget.echo_mode]
        )

    def test_set_placeholder_text(self):
        """ Test the setting of a Field's placeholder_text attribute
        """
        with self.app.process_events():
            self.server_widget.placeholder = "Placeholder"

        self.assertEquals(self.client_widget.placeholderText(), self.server_widget.placeholder)

    def test_set_read_only(self):
        """ Test the setting of a Field's read_only attribute
        """
        with self.app.process_events():
            self.server_widget.read_only = True

        self.assertEquals(self.client_widget.isReadOnly(), self.server_widget.read_only)

    def test_set_submit_mode(self):
        """ Test the setting of a Field's submit_triggers attribute
        """
        with self.app.process_events():
            self.server_widget.submit_triggers = ['lost_focus', 'return_pressed']

        ## Find a way to test that.

    def test_set_validator(self):
        """ Test the setting of a Field's validator attribute
        """
        with self.app.process_events():
            self.server_widget.text = '1'
            self.server_widget.validator = IntValidator()


        bad_text_input = 'hello world!'

        # Try to set the text with a string from the client side
        with self.app.process_events():
            self.client_widget.setText(bad_text_input)
            self.client_widget.returnPressed.emit()

        expected_value = '1'

        self.assertEquals(expected_value, self.server_widget.text)
        # on the client side, the text is the wrong one BUT the stylsheet shows
        # that the input is invalid
        self.assertEquals(bad_text_input, self.client_widget.text())
        self.assertNotEquals('', self.client_widget.styleSheet())

    def test_set_text(self):
        """ Test the setting of a Field's text attribute
        """
        with self.app.process_events():
            self.server_widget.text = "Whatever"

        self.assertEquals(self.client_widget.text(), self.server_widget.text)

if __name__ == '__main__':
    import unittest
    unittest.main()

########NEW FILE########
__FILENAME__ = test_html
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from .enaml_test_case import EnamlTestCase


class TestHtml(EnamlTestCase):
    """ Unit tests for the Html widget.

    """

    def setUp(self):
        enaml_source = """
from enaml.widgets.api import Html, Window

enamldef MainView(Window):
    Html:
        source = "<html/>"
"""
        self.parse_and_create(enaml_source)
        self.server_label = self.find_server_widget(self.view, "Html")
        self.client_label = self.find_client_widget(self.client_view, "QtHtml")

    def test_set_source(self):
        """ Test the setting of a Html's source attribute.
        """
        with self.app.process_events():
            self.server_label.source = "<br />Blah<br />"

        self.assertIn(self.server_label.source, self.client_label.toHtml())


########NEW FILE########
__FILENAME__ = test_image_view
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from .enaml_test_case import EnamlTestCase


class TestImageView(EnamlTestCase):
    """ Unit tests for the ImageView widget.

    """

    def setUp(self):
        enaml_source = """
from enaml.widgets.api import ImageView, Window

enamldef MainView(Window):
    ImageView:
        pass
"""
        self.parse_and_create(enaml_source)
        self.server_widget = self.find_server_widget(self.view, "ImageView")
        self.client_widget = self.find_client_widget(self.client_view, "QtImageView")

    def test_set_image(self):
        """ Test the setting of a ImageView's image attribute
        """
        # XXX: This needs fleshing out.
        pass

    def test_set_scale_to_fit(self):
        """ Test the setting of a ImageView's scale_to_fit attribute
        """
        with self.app.process_events():
            self.server_widget.scale_to_fit = False
        assert self.client_widget.scaledContents() == self.server_widget.scale_to_fit

    def test_set_preserve_aspect_ratio(self):
        """ Test the setting of a ImageView's preserve_aspect_ratio attribute
        """
        with self.app.process_events():
            self.server_widget.preserve_aspect_ratio = False
        assert self.client_widget.preserveAspectRatio() == self.server_widget.preserve_aspect_ratio

    def test_set_allow_upscaling(self):
        """ Test the setting of a ImageView's  attribute
        """
        with self.app.process_events():
            self.server_widget.allow_upscaling = False
        assert self.client_widget.allowUpscaling() == self.server_widget.allow_upscaling


########NEW FILE########
__FILENAME__ = test_label
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from .enaml_test_case import EnamlTestCase


class TestLabel(EnamlTestCase):
    """ Unit tests for the Label widget.

    """

    def setUp(self):
        enaml_source = """
from enaml.widgets.api import Label, Window

enamldef MainView(Window):
    Label:
        text = "text"
"""
        self.parse_and_create(enaml_source)
        self.server_label = self.find_server_widget(self.view, "Label")
        self.client_label = self.find_client_widget(self.client_view, "QtLabel")

    def test_set_text(self):
        """ Test the setting of a Label's text attribute.
        """
        with self.app.process_events():
            self.server_label.text = "something else"

        self.assertEquals(self.client_label.text(), self.server_label.text)

    ## Need to add tests for align and vertical_align

########NEW FILE########
__FILENAME__ = test_progress_bar
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from .enaml_test_case import EnamlTestCase


class TestProgressBar(EnamlTestCase):
    """ Unit tests for the ProgressBar widget.

    """

    def setUp(self):
        enaml_source = """
from enaml.widgets.api import ProgressBar, Window

enamldef MainView(Window):
    ProgressBar:
        pass
"""
        self.parse_and_create(enaml_source)
        self.server_widget = self.find_server_widget(self.view, "ProgressBar")
        self.client_widget = self.find_client_widget(self.client_view, "QtProgressBar")

    def test_set_maximum(self):
        """ Test the setting of a ProgressBar's maximum attribute
        """
        with self.app.process_events():
            self.server_widget.maximum = 1000

        self.assertEquals(self.client_widget.maximum(), self.server_widget.maximum)

    def test_set_minimum(self):
        """ Test the setting of a ProgressBar's minimum attribute
        """
        with self.app.process_events():
            self.server_widget.minimum = 10

        self.assertEquals(self.client_widget.minimum(), self.server_widget.minimum)

    def test_set_value(self):
        """ Test the setting of a ProgressBar's value attribute
        """
        with self.app.process_events():
            self.server_widget.value = 50

        self.assertEquals(self.client_widget.value(), self.server_widget.value)


########NEW FILE########
__FILENAME__ = test_push_button
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from .enaml_test_case import EnamlTestCase


class TestPushButton(EnamlTestCase):
    """ Unit tests for the PushButton widget.

    """

    def setUp(self):
        enaml_source = """
from enaml.widgets.api import PushButton, Window

enamldef Button(PushButton):
    attr click_count = 0


enamldef MainView(Window):
    Button:
        id: pb1
        clicked::
            pb1.click_count += 1
"""
        self.parse_and_create(enaml_source)
        self.server_widget = self.find_server_widget(self.view, "Button")
        self.client_widget = self.find_client_widget(self.client_view, "QtPushButton")

    def test_set_text(self):
        """ Test the setting of a PushButton's text attribute
        """

        with self.app.process_events():
            self.server_widget.text = "Push Me!"

        self.assertEquals(self.client_widget.text(), self.server_widget.text)

    def test_client_clicked(self):
        """ Test a click on the client side that must increase the click count on the
        server side.
        """

        initial_click_count = self.server_widget.click_count

        with self.app.process_events():
            self.client_widget.click()

        self.assertEquals(1 + initial_click_count, self.server_widget.click_count)

    def test_server_clicked(self):
        """ Test a click on the client side that must increase the click count on the
        server side.
        """

        initial_click_count = self.server_widget.click_count

        with self.app.process_events():
            self.server_widget.clicked()

        self.assertEquals(1 + initial_click_count, self.server_widget.click_count)



class TestTogglePushButtonControl(EnamlTestCase):
    """ Unit tests for the ToggleControl widget.

    """

    def setUp(self):
        enaml_source = """
from enaml.widgets.api import Window, PushButton

enamldef MainView(Window):
    PushButton:
        checkable = True
        checked = False
"""
        self.parse_and_create(enaml_source)
        self.server_widget = self.find_server_widget(self.view, "PushButton")
        self.client_widget = self.find_client_widget(self.client_view, "QtPushButton")

    def test_set_checked(self):
        """ Test the setting of a ToggleControl's checked attribute
        """
        with self.app.process_events():
            self.server_widget.checked = not self.server_widget.checked

        self.assertEquals(self.client_widget.isChecked(), self.server_widget.checked)

    def test_client_toggle(self):
        """ Test toggling the state on the client side .
        """

        initial_state = self.server_widget.checked

        with self.app.process_events():
            self.client_widget.toggle()

        self.assertEquals(initial_state, not self.server_widget.checked)

    def test_server_clicked(self):
        """ Test toggling the state on the server side .
        """

        initial_state = self.client_widget.isChecked()

        with self.app.process_events():
            self.server_widget.checked = not initial_state

        self.assertEquals(initial_state, not self.client_widget.isChecked())


if __name__ == '__main__':
    import unittest
    unittest.main()

########NEW FILE########
__FILENAME__ = test_slider
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from .enaml_test_case import EnamlTestCase

from enaml.qt.qt_slider import _ORIENTATION_MAP, _TICK_POSITION_MAP


class TestSlider(EnamlTestCase):
    """ Unit tests for the Slider widget.

    """

    def setUp(self):
        enaml_source = """
from enaml.widgets.api import Slider, Window

enamldef MainView(Window):
    Slider:
        pass
"""
        self.parse_and_create(enaml_source)
        self.server_widget = self.find_server_widget(self.view, "Slider")
        self.client_widget = self.find_client_widget(self.client_view, "QtSlider")

    def test_set_maximum(self):
        """ Test the setting of a Slider's maximum attribute
        """
        with self.app.process_events():
            self.server_widget.maximum = 1000

        self.assertEquals(self.client_widget.maximum(), self.server_widget.maximum)

    def test_set_minimum(self):
        """ Test the setting of a Slider's minimum attribute
        """
        with self.app.process_events():
            self.server_widget.minimum = 10

        self.assertEquals(self.client_widget.minimum(), self.server_widget.minimum)

    def test_set_orientation(self):
        """ Test the setting of a Slider's orientation attribute
        """
        with self.app.process_events():
            self.server_widget.orientation = 'vertical'

        self.assertEquals(
            self.client_widget.orientation(),
             _ORIENTATION_MAP[self.server_widget.orientation]
        )

    def test_set_page_step(self):
        """ Test the setting of a Slider's page_step attribute
        """
        with self.app.process_events():
            self.server_widget.page_step = 25

        self.assertEquals(self.client_widget.pageStep(), self.server_widget.page_step)

    def test_set_single_step(self):
        """ Test the setting of a Slider's single_step attribute
        """
        with self.app.process_events():
            self.server_widget.single_step = 50

        self.assertEquals(self.client_widget.singleStep(), self.server_widget.single_step)

    def test_set_tick_interval(self):
        """ Test the setting of a Slider's tick_interval attribute
        """
        with self.app.process_events():
            self.server_widget.tick_interval = 13

        assert self.client_widget.tickInterval() == self.server_widget.tick_interval

    def test_set_tick_position(self):
        """ Test the setting of a Slider's tick_position attribute
        """
        with self.app.process_events():
            self.server_widget.tick_position = 'top'

        self.assertEquals(
            self.client_widget.tickPosition(),
            _TICK_POSITION_MAP[self.server_widget.tick_position]
        )

    def test_set_tracking(self):
        """ Test the setting of a Slider's tracking attribute
        """
        with self.app.process_events():
            self.server_widget.tracking = False

        self.assertEquals(self.client_widget.hasTracking(), self.server_widget.tracking)

    def test_set_value(self):
        """ Test the setting of a Slider's value attribute
        """
        with self.app.process_events():
            self.server_widget.value = 75

        self.assertEquals(self.client_widget.value(), self.server_widget.value)

if __name__ == '__main__':
    import unittest
    unittest.main()


########NEW FILE########
__FILENAME__ = test_spin_box
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from enaml.validation.api import IntValidator

from .enaml_test_case import EnamlTestCase


class TestSpinBox(EnamlTestCase):
    """ Unit tests for the SpinBox widget.

    """

    def setUp(self):
        enaml_source = """
from enaml.widgets.api import SpinBox, Window

enamldef MainView(Window):
    SpinBox:
        pass
"""
        self.parse_and_create(enaml_source)
        self.server_widget = self.find_server_widget(self.view, "SpinBox")
        self.client_widget = self.find_client_widget(self.client_view, "QtSpinBox")

    def test_set_maximum(self):
        """ Test the setting of a SpinBox's maximum attribute
        """
        with self.app.process_events():
            self.server_widget.maximum = 1000

        self.assertEquals(self.client_widget.maximum(), self.server_widget.maximum)

    def test_set_minimum(self):
        """ Test the setting of a SpinBox's minimum attribute
        """
        with self.app.process_events():
            self.server_widget.minimum = 10

        self.assertEquals(self.client_widget.minimum(), self.server_widget.minimum)

    def test_set_single_step(self):
        """ Test the setting of a SpinBox's single_step attribute
        """
        with self.app.process_events():
            self.server_widget.single_step = 25

        self.assertEquals(self.client_widget.singleStep(), self.server_widget.single_step)

    def test_set_value(self):
        """ Test the setting of a SpinBox's value attribute
        """
        with self.app.process_events():
            self.server_widget.value = 50

        self.assertEquals(self.client_widget.value(), self.server_widget.value)

    def test_set_wrap(self):
        """ Test the setting of a SpinBox's wrap attribute
        """
        with self.app.process_events():
            self.server_widget.wrapping = True

        self.assertEquals(self.client_widget.wrapping(), self.server_widget.wrapping)

    ### Need to add tests for special_value_text, prefix, suffix and read_only

if __name__ == '__main__':
    import unittest
    unittest.main()

########NEW FILE########
__FILENAME__ = test_widget_component
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
import sys
import unittest


from enaml.colors import parse_color
from enaml.qt.qt.QtCore import Qt
from .enaml_test_case import EnamlTestCase

def get_rbga_from_qt_color(color):
    """ Returns an RGBA tuple with color values between 0 and 1 from a QColor.
    """
    return (color.redF(), color.greenF(), color.blueF(), color.alphaF())



class Test(EnamlTestCase):
    """ Unit tests for the WidgetComponent widget.

    There is not factory for the WidgetComponent in enaml.qt.qt_factories.
    The test is done on a PushButton (that inherits from the WidgetComponent).

    """

    def setUp(self):
        enaml_source = """
from enaml.widgets.api import Window, PushButton

enamldef MainView(Window):
    PushButton:
        pass
"""
        self.parse_and_create(enaml_source)
        self.server_widget = self.find_server_widget(self.view, "PushButton")
        self.client_widget = self.find_client_widget(
            self.client_view, "QtPushButton"
        )

    def test_set_enabled(self):
        """ Test the setting of a WidgetComponent's enabled attribute
        """
        with self.app.process_events():
            self.server_widget.enabled = False
        self.assertEquals(
            self.client_widget.isEnabled(), self.server_widget.enabled
        )

    def test_set_visible(self):
        """ Test the setting of a WidgetComponent's visible attribute
        """
        with self.app.process_events():
            self.server_widget.visible = False

        self.assertEquals(
            self.client_widget.isVisible(), self.server_widget.visible
        )

    def test_set_minimum_size(self):
        """ Test the setting of a WidgetComponent's minimum_size attribute
        """
        with self.app.process_events():
            self.server_widget.minimum_size = (100, 100)

        self.assertEquals(
            self.client_widget.minimumSize().toTuple(),
            self.server_widget.minimum_size
        )

    def test_set_maximum_size(self):
        """ Test the setting of a WidgetComponent's maximum_size attribute
        """
        with self.app.process_events():
            self.server_widget.maximum_size = (250, 250)

        self.assertEquals(
            self.client_widget.maximumSize().toTuple(),
            self.server_widget.maximum_size
        )

    @unittest.skipIf(sys.platform != 'darwin', 'Supported only on MacOSX')
    def test_set_show_focus_rect(self):
        """ Test the setting of a WidgetComponent's show_focus_rect attribute
        """
        with self.app.process_events():
            self.server_widget.show_focus_rect = True

        self.assertEquals(
            self.client_widget.testAttribute(Qt.WA_MacShowFocusRect),
            self.server_widget.show_focus_rect
        )

    def test_set_bgcolor(self):
        """ Test the setting of a WidgetComponent's bgcolor attribute
        """
        background_color = "#FFFFFF"
        with self.app.process_events():
            self.server_widget.bgcolor = background_color
        rgba = parse_color(background_color)

        role = self.client_widget.backgroundRole()
        color = self.client_widget.palette().color(role)
        client_color = get_rbga_from_qt_color(color)

        self.assertEquals(rgba, client_color)

    def test_set_fgcolor(self):
        """ Test the setting of a WidgetComponent's fgcolor attribute
        """
        foreground_color = "#000000"

        with self.app.process_events():
            self.server_widget.fgcolor = foreground_color

        rgba = parse_color(foreground_color)


        role = self.client_widget.foregroundRole()
        color = self.client_widget.palette().color(role)
        client_color = get_rbga_from_qt_color(color)

        self.assertEquals(rgba, client_color)

    @unittest.expectedFailure
    def test_set_font(self):
        """ Test the setting of a WidgetComponent's font attribute
        """
        with self.app.process_events():
            self.server_widget.font = "Helvetica-Regular"

        self.assertEquals(self.client_widget.font(), self.server_widget.font)



if __name__ == '__main__':
    unittest.main()


########NEW FILE########
__FILENAME__ = test_window
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from .enaml_test_case import EnamlTestCase


class TestWindow(EnamlTestCase):
    """ Unit tests for the Window widget.

    """

    def setUp(self):
        enaml_source = """
from enaml.widgets.api import Window

enamldef MainView(Window):
    title = ""
"""
        self.parse_and_create(enaml_source)
        self.server_window = self.find_server_widget(self.view, "MainView")
        self.client_window = self.find_client_widget(self.client_view, "QtWindow")

    def test_set_title(self):
        """ Test the setting of a Window's title attribute.
        """
        self.assertEquals(self.client_window.windowTitle(), '')

        with self.app.process_events():
            self.server_window.title = "something else"

        self.assertEquals(self.client_window.windowTitle(), self.server_window.title)

    def test_set_maximize(self):
        """ Test the Window's maximize() method.
        """
        self.assertFalse(self.client_window.isMaximized())

        with self.app.process_events():
            self.server_window.maximize()

        self.assertTrue(self.client_window.isMaximized())

    def test_set_minimize(self):
        """ Test the Window's minimize() method.
        """
        self.assertFalse(self.client_window.isMinimized())

        with self.app.process_events():
            self.server_window.minimize()

        self.assertTrue(self.client_window.isMinimized())

    def test_set_restore(self):
        """ Test the Window's restore() method.
        """
        self.assertFalse(self.client_window.isMinimized())
        with self.app.process_events():
            self.server_window.minimize()
            self.server_window.restore()
        self.assertFalse(self.client_window.isMinimized())


if __name__ == '__main__':
    import unittest
    import logging
    logging.basicConfig(level=logging.DEBUG)
    unittest.main()

########NEW FILE########
__FILENAME__ = utils
#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
""" An amalgamation of utilities used throughout the Enaml framework.

"""
from collections import defaultdict
from functools import wraps
import logging
from random import shuffle
from string import letters, digits


def id_generator(stem):
    """ A unique identifier generator.

    For a given stem, the returned generator is guaranteed to yield
    consecutively increasing identifiers using a randomly ordered
    base 62 charset. The identifiers are only guaranteed unique for a
    given instance of the generator. The randomness is employed to
    improve the hashing characteristics of the returned identifiers.

    Parameters
    ----------
    stem : str
        A string stem to prepend to a incrementing integer value.

    """
    charset = list(digits + letters)
    shuffle(charset)
    charset = ''.join(charset)
    charsetlen = len(charset)
    places = [0]
    push = places.append
    enumerate_ = enumerate
    join = ''.join
    while True:
        yield stem + join(charset[digit] for digit in places)
        for idx, digit in enumerate_(places):
            digit += 1
            if digit == charsetlen:
                places[idx] = 0
            else:
                places[idx] = digit
                break
        if places[-1] == 0:
            push(1)


class abstractclassmethod(classmethod):
    """ A backport of the Python 3's abc.abstractclassmethod.

    """
    __isabstractmethod__ = True

    def __init__(self, func):
        func.__isabstractmethod__ = True
        super(abstractclassmethod, self).__init__(func)


class LoopbackContext(object):
    """ A context manager generated by LoopbackGuard.

    Instances of this class manage acquiring and releasing the lock
    items for instances of LoopbackGuard.

    """
    __slots__ = ('_guard', '_items')

    def __init__(self, guard, items):
        """ Initialize a LoopbackContext

        Parameters
        ----------
        guard : LoopbackGuard
            The loopback guard instance for which we will acquire the
            lock for the items.

        items : iterable
            An iterable items which will be passed to the 'acquire'
            method on the loopback guard.

        """
        self._guard = guard
        self._items = tuple(items)

    def __enter__(self):
        """ Acquire the guard lock on the lock items.

        """
        self._guard.acquire(self._items)

    def __exit__(self, exc_type, exc_value, traceback):
        """ Release the guard lock on the lock items.

        """
        self._guard.release(self._items)


class LoopbackGuard(object):
    """ A guard object to protect against feedback loops.

    Instances of this class are used by objects to protect against
    loopback conditions while updating attributes. Instances of this
    class are callable and return a guarding context manager for the
    provided lock items. The guard can be tested for a locked item
    using the `in` keyword.

    """
    __slots__ = ('locked_items',)

    def __init__(self):
        """ Initialize a loopback guard.

        """
        self.locked_items = None

    def __call__(self, *items):
        """ Return a context manager which will guard the given items.

        Parameters
        ----------
        items
            The items for which to acquire the guard from within the
            returned context manager. These items must be hashable.

        Returns
        -------
        result : LoopbackContext
            A context manager which will acquire the guard for the
            provided items.

        """
        return LoopbackContext(self, items)

    def __contains__(self, item):
        """ Returns whether or not the given item is currently guarded.

        Parameters
        ----------
        item : object
            The item to check for guarded state.

        Returns
        -------
        result : bool
            True if the item is currently guarded, False otherwise.

        """
        locked_items = self.locked_items
        if locked_items is not None:
            return item in locked_items
        return False

    def acquire(self, items):
        """ Acquire the guard for the given items.

        This method is normally called by the LoopbackContext returned
        by calling this instance. User code should not typically call
        this method directly. It is safe to call this method multiple
        times for and item, provided it is paired with the same number
        of calls to release(...). The guard will be released when the
        acquired count on the item reaches zeros.

        Parameters
        ----------
        items : iterable
            An iterable of objects for which to acquire the guard. The
            items must be hashable.

        """
        locked_items = self.locked_items
        if locked_items is None:
            locked_items = self.locked_items = defaultdict(int)
        for item in items:
            locked_items[item] += 1

    def release(self, items):
        """ Release the guard for the given lock items.

        This method is normally called by the LoopbackContext returned
        by calling this instance. User code should not normally call
        this method directly. It is safe to call this method multiple
        times for and item, provided it is paired with the same number
        of calls to acquire(...). The guard will be released when the
        acquired count on the item reaches zeros.

        Parameters
        ----------
        items : iterable
            An iterable of objects for which to release the guard. The
            items must be hashable.

        """
        locked_items = self.locked_items
        if locked_items is not None:
            for item in items:
                locked_items[item] -= 1
                if locked_items[item] <= 0:
                    del locked_items[item]
            if not locked_items:
                self.locked_items = None


class ObjectDict(dict):
    """ A dict subclass which exposes its keys as attributes.

    """
    def __getattr__(self, name):
        try:
            return self[name]
        except KeyError:
            raise AttributeError(name)

    def __setattr__(self, name, value):
        self[name] = value


def log_exceptions(func):
    """ A decorator which will catch errors raised by a function and
    convert them into log error messages.

    When a decorated function raises an Exception, the return value
    will be None.

    """
    @wraps(func)
    def closure(*args, **kwargs):
        try:
            res = func(*args, **kwargs)
        except Exception:
            # Get the logger for the wrapped function.
            logger = logging.getLogger(func.__module__)
            message = 'Exception occured in `%s`:' % func.__name__
            logger.exception(message)
            res = None
        return res
    return closure



def make_dispatcher(prefix, logger=None):
    """ Create a function which will dispatch arguments to specially
    named handler methods on an object.

    Parameters
    ----------
    prefix : str
        The string to prefix to all dispatch names to construct the
        name of the handler method.

    logger : logging.Logger, optional
        A logger to use for logging handler lookup misses.

    Returns
    -------
    result : types.FunctionType
        A function with the signature func(obj, name, *args). Calling
        it is equivalent to `getattr(obj, prefix + name)(*args)`

    """
    def dispatcher(obj, name, *args):
        handler = getattr(obj, prefix + name, None)
        if handler is not None:
            handler(*args)
        elif logger is not None:
            msg = "no dispatch handler found for '%s' on `%s` object"
            logger.warn(msg % (name, obj))
    dispatcher.__name__ = prefix + '_dispatcher'
    return dispatcher


# Backwards comatibility import. WeakMethod was moved to its own module.
from .weakmethod import WeakMethod


########NEW FILE########
__FILENAME__ = api
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from .validator import Validator
from .int_validator import IntValidator
from .float_validator import FloatValidator
from .regex_validator import RegexValidator


########NEW FILE########
__FILENAME__ = client_validators
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
""" Python implementations of basic client-side validators.

This module provides basic implementations of client-side validators for
Enaml clients implemented in Python. Enaml client-side implementations in
other languages (eg. javascript) or in tookits which provide their own 
validation system should whichever is more appropriate.

"""
import re


def null_validator(text):
    """ A validator function which will return True for all text input.

    Parameters
    ----------
    text : string
        The text to validate.

    """
    return True


def regex_validator(regex):
    """ Creates a callable which will validate text input against the
    provided regex string.

    Parameters
    ----------
    regex : unicode
        A regular expression string to use for matching.

    Returns
    -------
    results : callable
        A callable which takes a single unicode argument and returns
        True if the text matches the regex, False otherwise.

    """
    rgx = re.compile(regex, re.UNICODE)
    def validator(text):
        return bool(rgx.match(text))
    return validator


def int_validator(base=10, minimum=None, maximum=None):
    """ Creates a callable which will validate text input against the
    provided integer range.

    Parameters
    ----------
    base : 2, 8, 10, or 16
        The number base to use with the range. Supported bases are 
        2, 8, 10, and 16.

    minimum : None or int
        The base 10 lower bound of allowable values, inlcusive. None 
        indicates no lower bound.

    maximum : None or int
        The base 10 upper bound of allowable values, inlcusive. None 
        indicates no upper bound.

    Returns
    -------
    results : callable
        A callable which takes a single unicode argument and returns 
        True if the text matches the range, False otherwise.

    """
    def validator(text):
        try:
            value = int(text, base)
        except ValueError:
            return False
        if minimum is not None and value < minimum:
            return False
        if maximum is not None and value > maximum:
            return False
        return True
    return validator


def float_validator(minimum=None, maximum=None, allow_exponent=False):
    """ Creates a callable which will validate text input against the
    provided float range.

    Parameters
    ----------
    minimum : None or float
        The lower bound of allowable values, inlcusive. None indicates
        no lower bound.

    maximum : None or float
        The upper bound of allowable values, inlcusive. None indicates 
        no upper bound.

    allow_exponent : bool
        Whether or not to allow exponents like '1e6' in the input.

    Returns
    -------
    results : callable
        A callable which takes a single unicode argument and returns 
        True if the text matches the range, False otherwise.

    """
    def validator(text):
        try:
            value = float(text)
        except ValueError:
            return False
        if minimum is not None and value < minimum:
            return False
        if maximum is not None and value > maximum:
            return False
        if not allow_exponent and 'e' in text.lower():
            return False
        return True
    return validator


_VALIDATOR_TYPES = {
    'regex': regex_validator,
    'int': int_validator,
    'float': float_validator,
}


def make_validator(info):
    """ Make a validator function for the given dict represenation.

    Parameters
    ----------
    info : dict
        The dictionary representation of a client side validator sent
        by the Enaml server widget.

    Returns
    -------
    result : callable
        A callable which takes a single unicode argument and returns
        True if the text is valid. False otherwise. If the validator 
        type is not supported, a null validator which accepts all text 
        will be returned.
    
    """
    vtype = info['type']
    if vtype in _VALIDATOR_TYPES:
        return _VALIDATOR_TYPES[vtype](**info['arguments'])
    else:
        return null_validator


########NEW FILE########
__FILENAME__ = float_validator
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from traits.api import Either, Float, Bool

from .validator import Validator


class FloatValidator(Validator):
    """ A concrete Validator which handles floating point input.

    This validator ensures that the text represents a floating point
    number within a specified range.

    """
    #: The minimum value allowed for the float, inclusive, or None if 
    #: there is no lower bound.
    minimum = Either(None, Float)

    #: The maximum value allowed for the float, inclusive, or None if 
    #: there is no upper bound.
    maximum = Either(None, Float)

    #: Whether or not to allow exponents like '1e6' in the input.
    allow_exponent = Bool(True)
    
    def convert(self, text):
        """ Converts the text to a floating point value.

        Parameters
        ----------
        text : unicode
            The unicode text to convert to an integer.

        Returns
        -------
        result : float
            The floating point value for the converted text. 

        Raises
        ------
        ValueError
            A ValueError will be raised if the conversion fails.

        """
        return float(text)

    def validate(self, text, component):
        """ Validates the given text matches the float range.

        Parameters
        ----------
        text : unicode
            The unicode text edited by the client widget.

        component : Declarative
            The declarative component currently making use of the
            validator.

        Returns
        -------
        result : (unicode, bool)
            A 2-tuple of (optionally modified) unicode text, and whether
            or not that text should be considered valid.

        """
        try:
            value = self.convert(text)
        except ValueError:
            return (text, False)
        minimum = self.minimum
        if minimum is not None and value < minimum:
            return (text, False)
        maximum = self.maximum
        if maximum is not None and value > maximum:
            return (text, False)
        if not self.allow_exponent and 'e' in text.lower():
            return (text, False)
        return (text, True)

    def client_validator(self):
        """ The client side float validator.

        Returns
        -------
        result : dict
            The dict representation of the client side float validator.
            
        """
        res = {}
        res['type'] = 'float'
        res['message'] = self.message
        res['arguments'] = {
            'minimum': self.minimum,
            'maximum': self.maximum,
            'allow_exponent': self.allow_exponent
        }
        return res


########NEW FILE########
__FILENAME__ = int_validator
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from traits.api import Either, Int, Enum

from .validator import Validator


class IntValidator(Validator):
    """ A concrete Validator which handles integer input.

    This validator ensures that the text represents an integer within a
    specified range in a specified base.

    """
    #: The minimum value allowed for the int, inclusive, or None if 
    #: there is no lower bound.
    minimum = Either(None, Int)

    #: The maximum value allowed for the int, inclusive, or None if 
    #: there is no upper bound.
    maximum = Either(None, Int)

    #: The base in which the int is represented.
    base = Enum(10, 2, 8, 16)
    
    def convert(self, text):
        """ Converts the text to an int in the given base.

        Parameters
        ----------
        text : unicode
            The unicode text to convert to an integer.

        Returns
        -------
        result : int
            The integer value for the converted text. 

        Raises
        ------
        ValueError
            A ValueError will be raised if the conversion fails.

        """
        return int(text, self.base)

    def validate(self, text, component):
        """ Validates the given text matches the integer range.

        Parameters
        ----------
        text : unicode
            The unicode text edited by the client widget.

        component : Declarative
            The declarative component currently making use of the
            validator.

        Returns
        -------
        result : (unicode, bool)
            A 2-tuple of (optionally modified) unicode text, and whether
            or not that text should be considered valid.

        """
        try:
            value = self.convert(text)
        except ValueError:
            return (text, False)
        minimum = self.minimum
        if minimum is not None and value < minimum:
            return (text, False)
        maximum = self.maximum
        if maximum is not None and value > maximum:
            return (text, False)
        return (text, True)

    def client_validator(self):
        """ The client side int validator.

        Returns
        -------
        result : dict
            The dict representation of the client side int validator.
            
        """
        res = {}
        res['type'] = 'int'
        res['message'] = self.message
        res['arguments'] = {
            'minimum': self.minimum,
            'maximum': self.maximum,
            'base': self.base
        }
        return res


########NEW FILE########
__FILENAME__ = regex_validator
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
import re

from traits.api import Str, Property, cached_property

from .validator import Validator


class RegexValidator(Validator):
    """ A concrete Validator which handles text input.

    This validator ensures that the text matches a provided regular
    expression string.

    """
    #: The regular expression string to use for validation. The default
    #: regex matches everything.
    regex = Str(r'.*')

    #: A read only cached property which holds the compiled regular
    #: expression object.
    _regex = Property(depends_on='regex')

    @cached_property
    def _get__regex(self):
        """ The getter for the '_regex' property. 

        Returns
        -------
        result : sre object
            A compiled regular expression object for the current regex
            string.

        """
        return re.compile(self.regex, re.UNICODE)

    def validate(self, text, component):
        """ Validates the given text matches the regular expression.

        Parameters
        ----------
        text : unicode
            The unicode text edited by the client widget.

        component : Declarative
            The declarative component currently making use of the
            validator.

        Returns
        -------
        result : (unicode, bool)
            A 2-tuple of (optionally modified) unicode text, and whether
            or not that text should be considered valid.

        """
        return (text, bool(self._regex.match(text)))

    def client_validator(self):
        """ The client side regex validator.

        Returns
        -------
        result : dict
            The dict representation of the client side regex validator.
            
        """
        res = {}
        res['type'] = 'regex'
        res['message'] = self.message
        res['arguments'] = {'regex': self.regex}
        return res


########NEW FILE########
__FILENAME__ = validator
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from traits.api import HasTraits, Unicode


class Validator(HasTraits):
    """ The base class for creating widget text validators.

    This class is abstract. It's abstract api must be implemented by a
    subclass in order to be usable.

    """
    #: An optional message to associate with the validator. This message
    #: will be sent to the client widget if server side validation fails
    message = Unicode

    def validate(self, text, component):
        """ Validates the given text.

        This is an abstract method which must be implemented by 
        sublasses.

        Parameters
        ----------
        text : unicode
            The unicode text edited by the client widget.

        component : Declarative
            The declarative component currently making use of the
            validator.

        Returns
        -------
        result : (unicode, bool)
            A 2-tuple of (optionally modified) unicode text, and whether
            or not that text should be considered valid.

        """
        raise NotImplementedError

    def client_validator(self):
        """ A serializable representation of a client side validator.

        Returns
        -------
        result : dict or None
            A dict in the format specified by 'validator_format.js'
            or None if no client validator is specified. The default
            implementation of this method returns None.

        """
        return None


########NEW FILE########
__FILENAME__ = version
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
""" The version information for this release of Enaml.

"""
from collections import namedtuple

# The major release number. Differences in the major number indicate
# possibly large differences in API.
MAJOR = 0

# The minor release number. Differences in the minor number indicate
# possibly small differences in the API, but these changes will come
# backwards compatibility support when possible. Minor releases are
# typically used for large feature additions.
MINOR = 6

# The micro release number. The micro release number is incremented
# for bug fix releases and small feature additions.
MICRO = 8

# The version info for the current release.
version_info = namedtuple('version_info', 'major minor micro')
version_info = version_info(MAJOR, MINOR, MICRO)

# Remove everything but the 'version_info' from this module.
del namedtuple, MAJOR, MINOR, MICRO


########NEW FILE########
__FILENAME__ = weakmethod
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from types import MethodType
from weakref import ref


class WeakMethod(object):
    """ An object which weakly binds a method with a lifetime bound
    to the lifetime of the underlying object.

    Instances of WeakMethod are also weakref-able with a lifetime which
    is also bound to lifetime of the method owner.

    If multiple WeakMethods are requested for the same equivalent method
    object, the same WeakMethod will be returned. This behavior is the
    same as the standard weakref semantics.

    """
    __slots__ = ('_im_func', '_im_selfref', '_im_class', '__weakref__')

    #: An internal dict which maintains a strong reference to the
    #: the underlying weak method wrappers until the owner of the
    #: method is destroyed.
    _instances = {}

    @staticmethod
    def _remove(wr_item):
        """ A private weakref callback which will release the internal
        strong references to the WeakMethod instances for the object.

        """
        del WeakMethod._instances[wr_item]

    def __new__(cls, method):
        """ Create a new WeakMethod instance or return an equivalent
        which already exists.

        Parameters
        ----------
        method : A bound method object
            The bound method which should be wrapped weakly.

        """
        # The logic to setup the weakref is as follows:
        #
        # The keys of the instances dict should be weakrefs for a given
        # object and have a callback that will pop the item from the dict
        # when the underlying object is destroyed. When using weakrefs as
        # keys in a dictionary, two weakrefs will hash to the same value
        # and compare equally if their underlying object is the same. This
        # is true even if the two weakrefs have different callbacks. When
        # creating weakrefs without callbacks, Python will only create a
        # single instance for a given object, and return that same weakref
        # instance for multiple calls. i.e:
        #
        #     >>> f = Foo()
        #     >>> r = weakref.ref(f)
        #     >>> r is weakref.ref(f)
        #     True
        #
        # However, Python will create a new weakref instance for each
        # weakref with a callback, even if the callback is the same:
        #
        #     >>> def bar(): pass
        #     >>> f = Foo()
        #     >>> r = weakref.ref(f, bar)
        #     >>> r is weakref.ref(f, bar)
        #     False
        #
        # A WeakMethod instance does not rely on a callback. Therefore, a
        # good amount of space can be saved if all WeakMethod instances for
        # a given object share the same no-callback weakref for that object,
        # and the only weakref with callback kept around is the one used as
        # the key in the dict.
        #
        # The logic below first creates a no-callback weakref, which is always
        # necessary and will only be created by Python once and then reused.
        # That weakref is used to lookup the item in the dict. If that lookup
        # succeeds, the weakref with callback already exists and no more work
        # is required. Otherwise, the weakref with callback is created and
        # used as the key in the dict.
        im_selfref = ref(method.im_self)
        items = WeakMethod._instances.get(im_selfref)
        if items is None:
            items = []
            cbref = ref(method.im_self, WeakMethod._remove)
            WeakMethod._instances[cbref] = items
        im_func = method.im_func
        im_class = method.im_class
        for wm in items:
            if wm._im_func is im_func and wm._im_class is im_class:
                return wm
        self = super(WeakMethod, cls).__new__(cls)
        self._im_func = im_func
        self._im_selfref = im_selfref
        self._im_class = im_class
        items.append(self)
        return self

    def __call__(self, *args, **kwargs):
        """ Invoke the wrapped method by reconstructing the bound
        method from its components.

        If the underlying instance object has been destroyed, this
        method will return None.

        Parameters
        ----------
        *args, **kwargs
            The positional and keyword arguments to pass to the method.

        """
        im_self = self._im_selfref()
        if im_self is None:
            return
        method = MethodType(self._im_func, im_self, self._im_class)
        return method(*args, **kwargs)


# Use the faster version of WeakMethod if it's available.
try:
    from enaml.extensions.weakmethod import WeakMethod
except ImportError:
    pass


########NEW FILE########
__FILENAME__ = abstract_button
#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from traits.api import Bool, Unicode, Str

from enaml.core.trait_types import CoercingInstance, EnamlEvent
from enaml.layout.geometry import Size

from .control import Control


class AbstractButton(Control):
    """ A base class which provides functionality common for several
    button-like widgets.

    """
    #: The text to use as the button's label.
    text = Unicode

    #: The source url for the icon to use for the button.
    icon_source = Str

    #: The size to use for the icon. The default is an invalid size
    #: and indicates that an appropriate default should be used.
    icon_size = CoercingInstance(Size, (-1, -1))

    #: Whether or not the button is checkable. The default is False.
    checkable = Bool(False)

    #: Whether a checkable button is currently checked.
    checked = Bool(False)

    #: Fired when the button is pressed then released. The payload will
    #: be the current checked state.
    clicked = EnamlEvent

    #: Fired when a checkable button is toggled. The payload will be
    #: the current checked state.
    toggled = EnamlEvent

    #: How strongly a component hugs it's contents' width. Buttons hug
    #: their contents' width weakly by default.
    hug_width = 'weak'

    #--------------------------------------------------------------------------
    # Initialization
    #--------------------------------------------------------------------------
    def snapshot(self):
        """ Returns the snapshot for an abstract button.

        """
        snap = super(AbstractButton, self).snapshot()
        snap['text'] = self.text
        snap['checkable'] = self.checkable
        snap['checked'] = self.checked
        snap['icon_size'] = tuple(self.icon_size)
        snap['icon_source'] = self.icon_source
        return snap

    def bind(self):
        """ Bind the change handlers for an abstract button.

        """
        super(AbstractButton, self).bind()
        attrs = ('text', 'checkable', 'checked', 'icon_size', 'icon_source')
        self.publish_attributes(*attrs)

    #--------------------------------------------------------------------------
    # Message Handling
    #--------------------------------------------------------------------------
    def on_action_clicked(self, content):
        """ Handle the 'clicked' action from the UI widget.

        The content will contain the current checked state.

        """
        checked = content['checked']
        self.set_guarded(checked=checked)
        self.clicked(checked)

    def on_action_toggled(self, content):
        """ Handle the 'toggled' action from the UI widget.

        The payload will contain the current checked state.

        """
        checked = content['checked']
        self.set_guarded(checked=checked)
        self.toggled(checked)


########NEW FILE########
__FILENAME__ = action
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from traits.api import Unicode, Bool, Str

from enaml.core.messenger import Messenger
from enaml.core.trait_types import EnamlEvent


class Action(Messenger):
    """ A non visible widget used in a ToolBar or Menu.

    An Action represents an actionable item in a ToolBar or a Menu.
    Though an Action itself is a non-visible component, it will be
    rendered in an appropriate fashion for the location where it is
    used.

    """
    #: The text label associate with the action.
    text = Unicode

    #: The tool tip text to use for this action. Typically displayed
    #: as a small label when the user hovers over the action.
    tool_tip = Unicode

    #: The text that is displayed in the status bar when the user
    #: hovers over the action.
    status_tip = Unicode

    #: The source url for the icon to use for the Action.
    icon_source = Str

    #: Whether or not the action can be checked.
    checkable = Bool(False)

    #: Whether or not the action is checked. This value only has meaning
    #: if 'checkable' is set to True.
    checked = Bool(False)

    #: Whether or not the item representing the action is enabled.
    enabled = Bool(True)

    #: Whether or not the item representing the action is visible.
    visible = Bool(True)

    #: Whether or not the action should be treated as a separator. If
    #: this value is True, none of the other values have meaning.
    separator = Bool(False)

    #: An event fired when the action is triggered by user interaction.
    #: They payload will be the current checked state.
    triggered = EnamlEvent

    #: An event fired when a checkable action changes its checked state.
    #: The payload will be the current checked state.
    toggled = EnamlEvent

    #--------------------------------------------------------------------------
    # Initialization
    #--------------------------------------------------------------------------
    def snapshot(self):
        """ Returns the snapshot dict for the Action.

        """
        snap = super(Action, self).snapshot()
        snap['text'] = self.text
        snap['tool_tip'] = self.tool_tip
        snap['status_tip'] = self.status_tip
        snap['icon_source'] = self.icon_source
        snap['checkable'] = self.checkable
        snap['checked'] = self.checked
        snap['enabled'] = self.enabled
        snap['visible'] = self.visible
        snap['separator'] = self.separator
        return snap

    def bind(self):
        """ Binds the change handlers for the Action.

        """
        super(Action, self).bind()
        attrs = (
            'text', 'tool_tip', 'status_tip', 'icon_source', 'checkable',
            'checked', 'enabled', 'visible', 'separator'
        )
        self.publish_attributes(*attrs)

    #--------------------------------------------------------------------------
    # Message Handling
    #--------------------------------------------------------------------------
    def on_action_triggered(self, content):
        """ Handle the 'triggered' action from the client widget.

        """
        checked = content['checked']
        self.set_guarded(checked=checked)
        self.triggered(checked)

    def on_action_toggled(self, content):
        """ Handle the 'toggled' action from the client widget.

        """
        checked = content['checked']
        self.set_guarded(checked=checked)
        self.toggled(checked)


########NEW FILE########
__FILENAME__ = action_group
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from traits.api import Bool, Property, cached_property

from enaml.core.messenger import Messenger

from .action import Action


class ActionGroup(Messenger):
    """ A non visible widget used to group actions.

    An action group can be used in a MenuBar or a ToolBar to group a
    related set of Actions and apply common operations to the set. The
    primary use of an action group is to make any checkable actions in
    the group mutually exclusive.

    """
    #: Whether or not the actions in this group are exclusive.
    exclusive = Bool(True)

    #: Whether or not the actions in this group are enabled.
    enabled = Bool(True)

    #: Whether or not the actions in this group are visible.
    visible = Bool(True)

    #: A read only property which returns the actions for this group.
    actions = Property(depends_on='children')

    #--------------------------------------------------------------------------
    # Initialization
    #--------------------------------------------------------------------------
    def snapshot(self):
        """ Returns the snapshot dict for the ActionGroup.

        """
        snap = super(ActionGroup, self).snapshot()
        snap['exclusive'] = self.exclusive
        snap['enabled'] = self.enabled
        snap['visible'] = self.visible
        return snap

    def bind(self):
        """ Binds the change handlers for the ActionGroup.

        """
        super(ActionGroup, self).bind()
        self.publish_attributes('exclusive', 'enabled', 'visible')

    #--------------------------------------------------------------------------
    # Private API
    #--------------------------------------------------------------------------
    @cached_property
    def _get_actions(self):
        """ The getter for the 'actions' property.

        Returns
        -------
        result : tuple
            The tuple of Actions defined as children of this ActionGroup.

        """
        isinst = isinstance
        items = (child for child in self.children if isinst(child, Action))
        return tuple(items)


########NEW FILE########
__FILENAME__ = api
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
# Backward compatibility imports
from enaml.core.include import Include

# Widget imports
from .action import Action
from .action_group import ActionGroup
from .bounded_date import BoundedDate
from .bounded_datetime import BoundedDatetime
from .calendar import Calendar
from .check_box import CheckBox
from .combo_box import ComboBox
from .container import Container
from .date_selector import DateSelector
from .datetime_selector import DatetimeSelector
from .dock_pane import DockPane
from .enable_canvas import EnableCanvas
from .field import Field
from .file_dialog import FileDialog
from .flow_area import FlowArea
from .flow_item import FlowItem
from .form import Form
from .group_box import GroupBox
from .html import Html
from .image_view import ImageView
from .label import Label
from .list_control import ListControl
from .list_item import ListItem
from .main_window import MainWindow
from .mdi_area import MdiArea
from .mdi_window import MdiWindow
from .menu import Menu
from .menu_bar import MenuBar
from .mpl_canvas import MPLCanvas
from .multiline_field import MultilineField
from .notebook import Notebook
from .page import Page
from .progress_bar import ProgressBar
from .push_button import PushButton
from .radio_button import RadioButton
from .scroll_area import ScrollArea
from .slider import Slider
from .separator import Separator
from .spin_box import SpinBox
from .split_item import SplitItem
from .splitter import Splitter
from .stack import Stack
from .stack_item import StackItem
#from .text_editor import TextEditor
from .time_selector import TimeSelector
from .tool_bar import ToolBar
from .traits_item import TraitsItem
from .web_view import WebView
from .window import Window


########NEW FILE########
__FILENAME__ = bounded_date
#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from datetime import date as py_date

from dateutil.parser import parse as parse_iso_dt
from traits.api import Date, Property, on_trait_change

from enaml.core.trait_types import Bounded

from .control import Control


class BoundedDate(Control):
    """ A base class for components which edit a Python datetime.date
    object bounded between minimum and maximum values.

    This class is not meant to be used directly.

    """
    #: The minimum date available in the date edit. If not defined then
    #: the default value is September 14, 1752.
    minimum = Property(Date, depends_on ='_minimum')

    #: The internal minimum date storage
    _minimum = Date(py_date(1752, 9, 14))

    #: The maximum date available in the date edit. If not defined then
    #: the default value is December 31, 7999.
    maximum = Property(Date, depends_on ='_maximum')

    #: The internal maximum date storage
    _maximum = Date(py_date(7999, 12, 31))

    #: The currently selected date. Default is the current date. The
    #: value is bounded between :attr:`minimum` and :attr:`maximum`.
    date = Bounded(Date(py_date.today()), low='minimum', high='maximum')

    #--------------------------------------------------------------------------
    # Initialization
    #--------------------------------------------------------------------------
    def snapshot(self):
        """ Return a dictionary which contains all the state necessary to
        initialize a client widget.

        """
        snap = super(BoundedDate, self).snapshot()
        snap['minimum'] = self.minimum.isoformat()
        snap['maximum'] = self.maximum.isoformat()
        snap['date'] = self.date.isoformat()
        return snap

    def bind(self):
        """ A method called after initialization which allows the widget
        to bind any event handlers necessary.

        """
        super(BoundedDate, self).bind()
        otc = self.on_trait_change
        otc(self._send_minimum, 'minimum')
        otc(self._send_maximum, 'maximum')
        otc(self._send_date, 'date')

    #--------------------------------------------------------------------------
    # Message Handling
    #--------------------------------------------------------------------------
    def on_action_date_changed(self, content):
        """ Handle the 'date_changed' action from the UI control.

        """
        date = parse_iso_dt(content['date']).date()
        self.set_guarded(date=date)

    def _send_minimum(self):
        """ Send the minimum date to the client widget.

        """
        content = {'minimum': self.minimum.isoformat()}
        self.send_action('set_minimum', content)

    def _send_maximum(self):
        """ Send the maximum date to the client widget.

        """
        content = {'maximum': self.maximum.isoformat()}
        self.send_action('set_maximum', content)

    def _send_date(self):
        """ Send the current date to the client widget.

        """
        if 'date' not in self.loopback_guard:
            content = {'date': self.date.isoformat()}
            self.send_action('set_date', content)

    #--------------------------------------------------------------------------
    # Property methods
    #--------------------------------------------------------------------------
    def _get_minimum(self):
        """ The property getter for the minimum date.

        """
        return self._minimum

    def _set_minimum(self, date):
        """ The property setter for the minimum date.

        If the new minimum is greater than the current maximum, then the
        maximum will be adjusted up.

        """
        if date > self._maximum:
            self._maximum = date
        self._minimum = date

    def _get_maximum(self):
        """ The property getter for the maximum date.

        """
        return self._maximum

    def _set_maximum(self, date):
        """ The property setter for the maximum date.

        If the new maximum is less than the current minimum, then the
        minimum will be ajusted down.

        """
        if date < self._minimum:
            self._minimum = date
        self._maximum = date

    #--------------------------------------------------------------------------
    # Private API
    #--------------------------------------------------------------------------
    @on_trait_change('minimum, maximum')
    def _adapt_date(self):
        """ Actively adapt the date to lie within the boundaries.

        """
        self.date = min(max(self.date, self.minimum), self.maximum)


########NEW FILE########
__FILENAME__ = bounded_datetime
#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from datetime import datetime as py_datetime

from dateutil.parser import parse as parse_iso_dt
from traits.api import Property, BaseInstance, on_trait_change

from enaml.core.trait_types import Bounded

from .control import Control


#: A custom trait which validates Python datetime instances.
Datetime = BaseInstance(py_datetime)


class BoundedDatetime(Control):
    """ A base class for use with widgets that edit a Python
    datetime.datetime object bounded between minimum and maximum
    values. This class is not meant to be used directly.

    """
    #: The minimum datetime available in the datetime edit. If not
    #: defined then the default value is midnight September 14, 1752.
    minimum = Property(Datetime, depends_on ='_minimum')

    #: The internal minimum datetime storage
    _minimum = Datetime(py_datetime(1752, 9, 14, 0, 0, 0, 0))

    #: The maximum datetime available in the datetime edit. If not
    #: defined then the default value is the second before midnight
    #: December 31, 7999.
    maximum = Property(Datetime, depends_on ='_maximum')

    #: The internal maximum datetime storage
    _maximum = Datetime(py_datetime(7999, 12, 31, 23, 59, 59, 999000))

    #: The currently selected date. Default is datetime.now(). The
    #: value is bounded between :attr:`minimum` and :attr:`maximum`.
    datetime = Bounded(Datetime(py_datetime.now()), low='minimum', high='maximum')

    #--------------------------------------------------------------------------
    # Initialization
    #--------------------------------------------------------------------------
    def snapshot(self):
        """ Return a dictionary which contains all the state necessary to
        initialize a client widget.

        """
        snap = super(BoundedDatetime, self).snapshot()
        snap['minimum'] = self.minimum.isoformat()
        snap['maximum'] = self.maximum.isoformat()
        snap['datetime'] = self.datetime.isoformat()
        return snap

    def bind(self):
        """ A method called after initialization which allows the widget
        to bind any event handlers necessary.

        """
        super(BoundedDatetime, self).bind()
        otc = self.on_trait_change
        otc(self._send_minimum, 'minimum')
        otc(self._send_maximum, 'maximum')
        otc(self._send_datetime, 'datetime')

    #--------------------------------------------------------------------------
    # Message Handling
    #--------------------------------------------------------------------------
    def on_action_datetime_changed(self, content):
        """ The handler for the 'datetime_changed' action sent from the
        client widget.

        """
        datetime = parse_iso_dt(content['datetime'])
        self.set_guarded(datetime=datetime)

    def _send_minimum(self):
        """ Send the minimum datetime to the client widget.

        """
        content = {'minimum': self.minimum.isoformat()}
        self.send_action('set_minimum', content)

    def _send_maximum(self):
        """ Send the maximum datetime to the client widget.

        """
        content = {'maximum': self.maximum.isoformat()}
        self.send_action('set_maximum', content)

    def _send_datetime(self):
        """ Send the current datetime to the client widget.

        """
        if 'datetime' not in self.loopback_guard:
            content = {'datetime': self.datetime.isoformat()}
            self.send_action('set_datetime', content)

    #--------------------------------------------------------------------------
    # Properties
    #--------------------------------------------------------------------------
    def _get_minimum(self):
        """ The property getter for the minimum datetime.

        """
        return self._minimum

    def _set_minimum(self, datetime):
        """ The property setter for the minimum datetime.

        If the new minimum is greater than the current maximum, then the
        maximum will be adjusted up.

        """
        if datetime > self._maximum:
            self._maximum = datetime
        self._minimum = datetime

    def _get_maximum(self):
        """ The property getter for the maximum datetime.

        """
        return self._maximum

    def _set_maximum(self, datetime):
        """ The property setter for the maximum datetime.

        If the new maximum is less than the current minimum, then the
        minimum will be ajusted down.

        """
        if datetime < self._minimum:
            self._minimum = datetime
        self._maximum = datetime

    #--------------------------------------------------------------------------
    # Private API
    #--------------------------------------------------------------------------
    @on_trait_change('minimum, maximum')
    def _adapt_datetime(self):
        """ Actively adapt the datetime to lie within the boundaries.

        """
        self.datetime = min(max(self.datetime, self.minimum), self.maximum)


########NEW FILE########
__FILENAME__ = bounded_time
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from datetime import datetime, time

from dateutil.parser import parse as parse_iso_dt
from traits.api import Property, Time, on_trait_change

from enaml.core.trait_types import Bounded

from .control import Control


class BoundedTime(Control):
    """ A base class for use with widgets that edit a Python
    datetime.time object bounded between minimum and maximum
    values. This class is not meant to be used directly.

    """
    #: The minimum time available in the control. If not defined then
    #: the default value is midnight.
    minimum = Property(Time, depends_on ='_minimum')

    #: The internal minimum time storage.
    _minimum = Time(time(0, 0, 0, 0))

    #: The maximum time available in the control. If not defined then
    #: the default value is the second before midnight.
    maximum = Property(Time, depends_on ='_maximum')

    #: The internal maximum time storage.
    _maximum = Time(time(23, 59, 59, 999000))

    #: The currently selected time. Default is datetime.now().time(). The
    #: value is bounded between :attr:`minimum` and :attr:`maximum`.
    time = Bounded(Time(datetime.now().time()), low='minimum', high='maximum')

    #--------------------------------------------------------------------------
    # Initialization
    #--------------------------------------------------------------------------
    def snapshot(self):
        """ Return a dictionary which contains all the state necessary to
        initialize a client widget.

        """
        snap = super(BoundedTime, self).snapshot()
        snap['minimum'] = self.minimum.isoformat()
        snap['maximum'] = self.maximum.isoformat()
        snap['time'] = self.time.isoformat()
        return snap

    def bind(self):
        """ A method called after initialization which allows the widget
        to bind any event handlers necessary.

        """
        super(BoundedTime, self).bind()
        otc = self.on_trait_change
        otc(self._send_minimum, 'minimum')
        otc(self._send_maximum, 'maximum')
        otc(self._send_time, 'time')

    #--------------------------------------------------------------------------
    # Message Handling
    #--------------------------------------------------------------------------
    def on_action_time_changed(self, content):
        """ The handler for the 'time_changed' action sent from the
        client widget.

        """
        time = parse_iso_dt(content['time']).time()
        self.set_guarded(time=time)

    def _send_minimum(self):
        """ Send the minimum time to the client widget.

        """
        content = {'minimum': self.minimum.isoformat()}
        self.send_action('set_minimum', content)

    def _send_maximum(self):
        """ Send the maximum time to the client widget.

        """
        content = {'maximum': self.maximum.isoformat()}
        self.send_action('set_maximum', content)

    def _send_time(self):
        """ Send the current time to the client widget.

        """
        if 'time' not in self.loopback_guard:
            content = {'time': self.time.isoformat()}
            self.send_action('set_time', content)

    #--------------------------------------------------------------------------
    # Properties
    #--------------------------------------------------------------------------
    def _get_minimum(self):
        """ The property getter for the minimum time.

        """
        return self._minimum

    def _set_minimum(self, time):
        """ The property setter for the minimum time.

        If the new minimum is greater than the current maximum, then the
        maximum will be adjusted up.

        """
        if time > self._maximum:
            self._maximum = time
        self._minimum = time

    def _get_maximum(self):
        """ The property getter for the maximum time.

        """
        return self._maximum

    def _set_maximum(self, time):
        """ The property setter for the maximum time.

        If the new maximum is less than the current minimum, then the
        minimum will be ajusted down.

        """
        if time < self._minimum:
            self._minimum = time
        self._maximum = time

    #--------------------------------------------------------------------------
    # Private API
    #--------------------------------------------------------------------------
    @on_trait_change('minimum, maximum')
    def _adapt_time(self):
        """ Actively adapt the time to lie within the boundaries.

        """
        self.time = min(max(self.time, self.minimum), self.maximum)


########NEW FILE########
__FILENAME__ = calendar
#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from .bounded_date import BoundedDate


class Calendar(BoundedDate):
    """ A bounded date control which edits a Python datetime.date using 
    a widget which resembles a calendar.

    """
    # The BoundedDate interface is sufficient for a Calendar
    pass


########NEW FILE########
__FILENAME__ = check_box
#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from .abstract_button import AbstractButton


class CheckBox(AbstractButton):
    """ An checkable button represented by a standard check box widget.

    Use a check box when it's necessary to toggle a boolean value
    independent of any other widgets in a group. 

    When its necessary to allow the toggling of only one value in a 
    group of values, use a group of RadioButtons or the RadioGroup
    control from the Enaml standard library.

    The interface for AbstractButton fully defines the interface for
    a CheckBox.

    """
    #: Check boxes are checkable by default.
    checkable = True


########NEW FILE########
__FILENAME__ = combo_box
#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from traits.api import Bool, List, Int, Property, Unicode, cached_property

from .control import Control


class ComboBox(Control):
    """ A drop-down list from which one item can be selected at a time.

    Use a combo box to select a single item from a collection of items.

    """
    #: The unicode strings to display in the combo box.
    items = List(Unicode)

    #: The integer index of the currently selected item. If the given
    #: index falls outside of the range of items, the item will be
    #: deselected.
    index = Int(-1)

    #: Whether the text in the combo box can be edited by the user.
    editable = Bool(False)

    #: A readonly property that will return the currently selected
    #: item. If the index falls out of range, the selected item will
    #: be the empty string.
    selected_item = Property(Unicode, depends_on=['index', 'items[]'])

    #: How strongly a component hugs it's contents' width. ComboBoxes
    #: hug width weakly, by default.
    hug_width = 'weak'

    #--------------------------------------------------------------------------
    # Initialization
    #--------------------------------------------------------------------------
    def snapshot(self):
        """ Returns the dict of creation attributes for the combo box.

        """
        snap = super(ComboBox, self).snapshot()
        snap['items'] = self.items
        snap['index'] = self.index
        snap['editable'] = self.editable
        return snap

    def bind(self):
        """ A method called after initialization which allows the widget
        to bind any event handlers necessary.

        """
        super(ComboBox, self).bind()
        self.publish_attributes('index', 'editable')
        self.on_trait_change(self._send_items, 'items, items_items')

    def _send_items(self):
        """ Send the 'set_items' action to the client widget.

        """
        content = {'items': self.items}
        self.send_action('set_items', content)

    #--------------------------------------------------------------------------
    # Message Handling
    #--------------------------------------------------------------------------
    def on_action_index_changed(self, content):
        """ The message handler for the 'index_changed' action from the
        client widget. The content will contain the selected 'index'.

        """
        index = content['index']
        self.set_guarded(index=index)

    #--------------------------------------------------------------------------
    # Property Handlers
    #--------------------------------------------------------------------------
    @cached_property
    def _get_selected_item(self):
        """ The getter for the `selected_item` property.

        """
        items = self.items
        idx = self.index
        if idx < 0 or idx >= len(items):
            return u''
        return items[idx]


########NEW FILE########
__FILENAME__ = constraints_widget
#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from traits.api import Property, Enum, Instance, List

from enaml.application import Application, ScheduledTask
from enaml.layout.ab_constrainable import ABConstrainable
from enaml.layout.box_model import BoxModel
from enaml.layout.layout_helpers import expand_constraints

from .widget import Widget


#: A traits enum which defines the allowable constraints strengths.
PolicyEnum = Enum('ignore', 'weak', 'medium', 'strong', 'required')


def get_from_box_model(self, name):
    """ Property getter for all attributes that come from the box model.

    """
    return getattr(self._box_model, name)


class ConstraintsWidget(Widget):
    """ A Widget subclass which adds constraint information.

    A ConstraintsWidget is augmented with symbolic constraint variables
    which define a box model on the widget. This box model is used to
    declare constraints between this widget and other components which
    participate in constraints-based layout.

    Constraints are added to a widget by assigning a list to the
    'constraints' attribute. This list may contain raw LinearConstraint
    objects (which are created by manipulating the symbolic constraint
    variables) or DeferredConstraints objects which generated these
    LinearConstraint objects on-the-fly.

    A ConstraintsWidget also has a 'constraints_id' which is a uuid
    given to the object and to each of its constraint variables in
    order to track ownership of the constraint variables. This id
    is automatically generated, and should not be modified by the
    user.

    """
    #: The list of user-specified constraints or constraint-generating
    #: objects for this component.
    constraints = List

    #: A read-only symbolic object that represents the left boundary of
    #: the component
    left = Property(fget=get_from_box_model)

    #: A read-only symbolic object that represents the top boundary of
    #: the component
    top = Property(fget=get_from_box_model)

    #: A read-only symbolic object that represents the width of the
    #: component
    width = Property(fget=get_from_box_model)

    #: A read-only symbolic object that represents the height of the
    #: component
    height = Property(fget=get_from_box_model)

    #: A read-only symbolic object that represents the right boundary
    #: of the component
    right = Property(fget=get_from_box_model)

    #: A read-only symbolic object that represents the bottom boundary
    #: of the component
    bottom = Property(fget=get_from_box_model)

    #: A read-only symbolic object that represents the vertical center
    #: of the component
    v_center = Property(fget=get_from_box_model)

    #: A read-only symbolic object that represents the horizontal
    #: center of the component
    h_center = Property(fget=get_from_box_model)

    #: How strongly a component hugs it's width hint. Valid strengths
    #: are 'weak', 'medium', 'strong', 'required' and 'ignore'. Default
    #: is 'strong'. This trait should be overridden on a per-control
    #: basis to specify a logical default for the given control.
    hug_width = PolicyEnum('strong')

    #: How strongly a component hugs it's height hint. Valid strengths
    #: are 'weak', 'medium', 'strong', 'required' and 'ignore'. Default
    #: is 'strong'. This trait should be overridden on a per-control
    #: basis to specify a logical default for the given control.
    hug_height = PolicyEnum('strong')

    #: How strongly a component resists clipping its contents. Valid
    #: strengths are 'weak', 'medium', 'strong', 'required' and 'ignore'.
    #: The default is 'strong' for width.
    resist_width = PolicyEnum('strong')

    #: How strongly a component resists clipping its contents. Valid
    #: strengths are 'weak', 'medium', 'strong', 'required' and 'ignore'.
    #: The default is 'strong' for height.
    resist_height = PolicyEnum('strong')

    #: The private application task used to collapse layout messages.
    _layout_task = Instance(ScheduledTask)

    #: The private storage the box model instance for this component.
    _box_model = Instance(BoxModel)
    def __box_model_default(self):
        return BoxModel(self.object_id)

    #--------------------------------------------------------------------------
    # Initialization
    #--------------------------------------------------------------------------
    def snapshot(self):
        """ Populates the initial attributes dict for the component.

        A ConstraintsWidget adds the 'layout' key to the creation
        attributes dict. The value is a dict with the following keys.

        'constraints'
            A list of dictionaries representing linear constraints.

        'resist_clip'
            A tuple containing width and height clip policies.

        'hug'
            A tuple containing width and height hug policies.

        """
        snap = super(ConstraintsWidget, self).snapshot()
        snap['layout'] = self._layout_info()
        return snap

    def bind(self):
        """ Binds the change handlers for the component.

        """
        super(ConstraintsWidget, self).bind()
        d = 'constraints, hug_width, hug_height, resist_width, resist_height'
        self.on_trait_change(self._send_relayout, d)

    #--------------------------------------------------------------------------
    # Public API
    #--------------------------------------------------------------------------
    def when(self, switch):
        """ A method which returns `self` or None based on the truthness
        of the argument.

        This can be useful to easily turn off the effects of an object
        in constraints-based layout.

        Parameters
        ----------
        switch : bool
            A boolean which indicates whether this instance or None
            should be returned.

        Returns
        -------
        result : self or None
            If 'switch' is boolean True, self is returned. Otherwise,
            None is returned.

        """
        if switch:
            return self

    #--------------------------------------------------------------------------
    # Message Handling
    #--------------------------------------------------------------------------
    def _send_relayout(self):
        """ Send the 'relayout' action to the client widget.

        If an Enaml Application instance exists, then multiple `relayout`
        actions will be collapsed into a single action that will be sent
        on the next cycle of the event loop. If no application exists,
        then the action is sent immediately.

        """
        # The relayout action is deferred until the next cycle of the
        # event loop for two reasons: 1) So that multiple relayout
        # requests can be collapsed into a single action. 2) So that
        # all child events (which are fired synchronously) can finish
        # processing and send their actions to the client before the
        # relayout request is sent. The action itself is batched so
        # that it can be sent along with any object tree changes.
        app = Application.instance()
        if app is not None:
            task = self._layout_task
            if task is None:
                def notifier(ignored):
                    self._layout_task = None
                def layout_task():
                    self.batch_action('relayout', self._layout_info())
                task = app.schedule(layout_task)
                task.notify(notifier)
                self._layout_task = task

    #--------------------------------------------------------------------------
    # Constraints Generation
    #--------------------------------------------------------------------------
    def _layout_info(self):
        """ Creates a dictionary from the current layout information.

        This method uses the current layout state of the component,
        comprised of constraints, clip, and hug policies, and creates
        a dictionary which can be serialized and sent to clients.

        Returns
        -------
        result : dict
            A dictionary of the current layout state for the component.

        """
        info = {
            'constraints': self._generate_constraints(),
            'resist': (self.resist_width, self.resist_height),
            'hug': (self.hug_width, self.hug_height),
        }
        return info

    def _generate_constraints(self):
        """ Creates a list of constraint info dictionaries.

        This method converts the list of symbolic constraints returned
        by the call to '_collect_constraints' into a list of constraint
        info dictionaries which can be serialized and sent to clients.

        Returns
        -------
        result : list of dicts
            A list of dictionaries which are serializable versions of
            the symbolic constraints defined for the widget.

        """
        cns = self._collect_constraints()
        cns = [cn.as_dict() for cn in expand_constraints(self, cns)]
        return cns

    def _collect_constraints(self):
        """ Creates a list of symbolic constraints for the component.

        By default, this method combines the constraints defined by
        the 'constraints' this, and those returned by a call to the
        '_hard_constraints' method. Subclasses which need more control
        should override this method.

        Returns
        -------
        result : list
            A list of symbolic constraints and deferred constraints
            for this component.

        """
        cns = self.constraints
        if not cns:
            cns = self._default_constraints()
        return cns + self._component_constraints() + self._hard_constraints()

    def _hard_constraints(self):
        """ Creates the list of required symbolic constraints.

        These are constraints that must apply to the internal layout
        computations of a component as well as that of containers which
        may parent this component. By default, all components will have
        their 'left', 'right', 'width', and 'height' symbols constrained
        to >= 0. These constraints are applied client-side, in order to
        save bandwidth. Subclasses which need to add more constraints
        should reimplement this method.

        Returns
        -------
        result : list
            A list of symbolic constraints which must always be applied
            to a component.

        """
        return []

    def _component_constraints(self):
        """ Returns a list of constraints which should be applied on
        top of any additional user-supplied constraints and hard
        constraints.

        The default implementation returns an empty list.

        """
        return []

    def _default_constraints(self):
        """ Returns a list of constraints to include if the user has
        not specified their own in the 'constraints' list.

        The default implementation returns an empty list.

        """
        return []


ABConstrainable.register(ConstraintsWidget)


########NEW FILE########
__FILENAME__ = container
#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from traits.api import Property, Instance, Bool, cached_property

from enaml.core.trait_types import CoercingInstance
from enaml.layout.box_model import ContentsBoxModel
from enaml.layout.geometry import Box
from enaml.layout.layout_helpers import vbox

from .constraints_widget import ConstraintsWidget, get_from_box_model


class Container(ConstraintsWidget):
    """ A ConstraintsWidget subclass that provides functionality for
    laying out constrainable children according to their system of
    constraints.

    The Container is the canonical component used to arrange child
    widgets using constraints-based layout. Given a heierarchy of
    components, the top-most Container will be charged with the actual
    layout of the decendents. This allows constraints to cross the
    boundaries of Containers, enabling powerful and flexible layouts.

    There are widgets whose boundaries constraints may not cross. Some
    examples of these would be a ScrollArea or a TabGroup. See the
    documentation of a given container component as to whether or not
    constraints may cross its boundaries.

    """
    #: A boolean which indicates whether or not to allow the layout
    #: ownership of this container to be transferred to an ancestor.
    #: This is False by default, which means that every container
    #: get its own layout solver. This improves speed and reduces
    #: memory use (by keeping a solver's internal tableaux small)
    #: but at the cost of not being able to share constraints
    #: across Container boundaries. This flag must be explicitly
    #: marked as True to enable sharing.
    share_layout = Bool(False)

    #: A read-only symbolic object that represents the internal left
    #: boundary of the content area of the container.
    contents_left = Property(fget=get_from_box_model)

    #: A read-only symbolic object that represents the internal right
    #: boundary of the content area of the container.
    contents_right = Property(fget=get_from_box_model)

    #: A read-only symbolic object that represents the internal top
    #: boundary of the content area of the container.
    contents_top = Property(fget=get_from_box_model)

    #: A read-only symbolic object that represents the internal bottom
    #: boundary of the content area of the container.
    contents_bottom = Property(fget=get_from_box_model)

    #: A read-only symbolic object that represents the internal width of
    #: the content area of the container.
    contents_width = Property(fget=get_from_box_model)

    #: A read-only symbolic object that represents the internal height of
    #: the content area of the container.
    contents_height = Property(fget=get_from_box_model)

    #: A read-only symbolic object that represents the internal center
    #: along the vertical direction the content area of the container.
    contents_v_center = Property(fget=get_from_box_model)

    #: A read-only symbolic object that represents the internal center
    #: along the horizontal direction of the content area of the container.
    contents_h_center = Property(fget=get_from_box_model)

    #: A box object which holds the padding for this component. The
    #: padding is the amount of space between the outer boundary box
    #: and the content box. The default padding is (10, 10, 10, 10).
    #: Certain subclasses, such as GroupBox, may provide additional
    #: margin than what is specified by the padding.
    padding = CoercingInstance(Box, (10, 10, 10, 10))

    #: A read only property which returns this container's widgets.
    widgets = Property(depends_on='children')

    #: Containers freely exapnd in width and height. The size hint
    #: constraints for a Container are used when the container is
    #: not sharing its layout. In these cases, expansion of the
    #: container is typically desired.
    hug_width = 'ignore'
    hug_height = 'ignore'

    #: The private storage the box model instance for this component.
    _box_model = Instance(ContentsBoxModel)
    def __box_model_default(self):
        return ContentsBoxModel(self.object_id)

    #--------------------------------------------------------------------------
    # Initialization
    #--------------------------------------------------------------------------
    def bind(self):
        """ Bind the necessary change handlers for the control.

        """
        super(Container, self).bind()
        self.on_trait_change(self._send_relayout, 'share_layout, padding')

    #--------------------------------------------------------------------------
    # Children Events
    #--------------------------------------------------------------------------
    def children_event(self, event):
        """ Handle a `ChildrenEvent` on a container.

        This event handler will send a relayout event if the `Container`
        is active and the user has not defined their own constraints.

        """
        super(Container, self).children_event(event)
        if self.is_active and not self.constraints:
            self._send_relayout()

    #--------------------------------------------------------------------------
    # Constraints Generation
    #--------------------------------------------------------------------------
    def _layout_info(self):
        """ An overridden parent class method which adds the 'share'
        layout key to the dict of layout information sent to the client.

        """
        layout = super(Container, self)._layout_info()
        layout['share_layout'] = self.share_layout
        layout['padding'] = self.padding
        return layout

    def _default_constraints(self):
        """ Supplies a default vbox constraint to the constraints
        children of the container if other constraints are not given.

        """
        cns = super(Container, self)._default_constraints()
        cns.append(vbox(*self.widgets))
        return cns

    #--------------------------------------------------------------------------
    # Property Getters
    #--------------------------------------------------------------------------
    @cached_property
    def _get_widgets(self):
        """ The getter for the 'widgets' property

        Returns
        -------
        result : tuple
            The tuple of ContraintsWidgets defined as children of this
            Container.

        """
        isinst = isinstance
        widgets = (c for c in self.children if isinst(c, ConstraintsWidget))
        return tuple(widgets)


########NEW FILE########
__FILENAME__ = control
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from .constraints_widget import ConstraintsWidget


class Control(ConstraintsWidget):
    """ A widget which represents a leaf node in the hierarchy.

    A Control is conceptually the same as a ConstraintsWidget, except
    that it does not have widget children. This base class serves as
    a placeholder for potential future functionality.

    """
    pass


########NEW FILE########
__FILENAME__ = datetime_selector
#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from traits.api import Bool, Str

from .bounded_datetime import BoundedDatetime


class DatetimeSelector(BoundedDatetime):
    """ A datetime widget that displays a Python datetime.datetime
    object using an appropriate toolkit specific control.

    """
    #: A python date format string to format the datetime. If None is
    #: supplied (or is invalid) the system locale setting is used.
    #: This may not be supported by all backends.
    datetime_format = Str

    #: Whether to use a calendar popup for selecting the date.
    calendar_popup = Bool(False)

    #: How strongly to hugs the content width. A DatetimeSelector ignores
    #: the width hug by default, so it expands freely in width.
    hug_width = 'ignore'

    #--------------------------------------------------------------------------
    # Initialization
    #--------------------------------------------------------------------------
    def snapshot(self):
        """ Return a dictionary which contains all the state necessary to
        initialize a client widget.

        """
        snap = super(DatetimeSelector, self).snapshot()
        snap['datetime_format'] = self.datetime_format
        snap['calendar_popup'] = self.calendar_popup
        return snap

    def bind(self):
        """ A method called after initialization which allows the widget
        to bind any event handlers necessary.

        """
        super(DatetimeSelector, self).bind()
        self.publish_attributes('datetime_format', 'calendar_popup')


########NEW FILE########
__FILENAME__ = date_selector
#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from traits.api import Bool, Str

from .bounded_date import BoundedDate


class DateSelector(BoundedDate):
    """ A widget to edit a Python datetime.date object.

    A DateSelector displays a Python datetime.date using an appropriate
    toolkit specific control. This is a geometrically smaller control
    than what is provided by Calendar.

    """
    #: A python date format string to format the date for display. If
    #: If none is supplied (or is invalid) the system locale setting
    #: is used. This may not be supported by all backends.
    date_format = Str

    #: Whether to use a calendar popup for selecting the date.
    calendar_popup = Bool(False)

    #: How strongly to hugs the content width. A DateSelector ignores
    #: the width hug by default, so it expands freely in width.
    hug_width = 'ignore'

    #--------------------------------------------------------------------------
    # Initialization
    #--------------------------------------------------------------------------
    def snapshot(self):
        """ Return a dictionary which contains all the state necessary to
        initialize a client widget.

        """
        snap = super(DateSelector, self).snapshot()
        snap['date_format'] = self.date_format
        snap['calendar_popup'] = self.calendar_popup
        return snap

    def bind(self):
        """ A method called after initialization which allows the widget
        to bind any event handlers necessary.

        """
        super(DateSelector, self).bind()
        self.publish_attributes('date_format', 'calendar_popup')


########NEW FILE########
__FILENAME__ = dock_pane
#------------------------------------------------------------------------------
# Copyright (c) 2012, Enthought, Inc.
# All rights reserved.
#------------------------------------------------------------------------------
from traits.api import List, Enum, Unicode, Bool,  Property, cached_property

from enaml.core.trait_types import EnamlEvent

from .container import Container
from .widget import Widget


class DockPane(Widget):
    """ A widget which can be docked in a MainWindow.

    A DockPane is a widget which can be docked in designated dock areas
    in a MainWindow. It can have at most a single child widget which is
    an instance of Container.

    """
    #: The title to use in the title bar.
    title = Unicode

    #: Whether or not the title bar is visible.
    title_bar_visible = Bool(True)

    #: The orientation of the title bar.
    title_bar_orientation = Enum('horizontal', 'vertical')

    #: Whether or not the dock pane is closable via a close button.
    closable = Bool(True)

    #: Whether or not the dock pane is movable by the user.
    movable = Bool(True)

    #: Whether or not the dock can be floated as a separate window.
    floatable = Bool(True)

    #: A boolean indicating whether or not the dock pane is floating.
    floating = Bool(False)

    #: The dock area in the MainWindow where the pane is docked.
    dock_area = Enum('left', 'right', 'top', 'bottom')

    #: The dock areas in the MainWindow where the pane can be docked
    #: by the user. Note that this does not preclude the pane from
    #: being docked programmatically via the 'dock_area' attribute.
    allowed_dock_areas = List(
        Enum('left', 'right', 'top', 'bottom', 'all'), value=['all'],
    )

    #: A read only property which returns the pane's dock widget.
    dock_widget = Property(depends_on='children')

    #: An event fired when the user closes the pane by clicking on the
    #: dock pane's close button.
    closed = EnamlEvent

    #--------------------------------------------------------------------------
    # Initialization
    #--------------------------------------------------------------------------
    def snapshot(self):
        """ Returns the snapshot dict for the DockPane.

        """
        snap = super(DockPane, self).snapshot()
        snap['title'] = self.title
        snap['title_bar_visible'] = self.title_bar_visible
        snap['title_bar_orientation'] = self.title_bar_orientation
        snap['closable'] = self.closable
        snap['movable'] = self.movable
        snap['floatable'] = self.floatable
        snap['floating'] = self.floating
        snap['dock_area'] = self.dock_area
        snap['allowed_dock_areas'] = self.allowed_dock_areas
        return snap

    def bind(self):
        super(DockPane, self).bind()
        attrs = (
            'title', 'title_bar_visible', 'title_bar_orientation', 'closable',
            'movable', 'floatable', 'floating', 'dock_area',
            'allowed_dock_areas'
        )
        self.publish_attributes(*attrs)

    #--------------------------------------------------------------------------
    # Private API
    #--------------------------------------------------------------------------
    @cached_property
    def _get_dock_widget(self):
        """ The getter for the 'dock_widget' property.

        Returns
        -------
        result : Container or None
            The dock widget for the DockPane, or None if not provided.

        """
        widget = None
        for child in self.children:
            if isinstance(child, Container):
                widget = child
        return widget

    #--------------------------------------------------------------------------
    # Message Handling
    #--------------------------------------------------------------------------
    def on_action_closed(self, content):
        """ Handle the 'closed' action from the client widget.

        """
        self.set_guarded(visible=False)
        self.closed()

    def on_action_floated(self, content):
        """ Handle the 'floated' action from the client widget.

        """
        self.set_guarded(floating=True)

    def on_action_docked(self, content):
        """ Handle the 'docked' action from the client widget.

        """
        self.set_guarded(floating=False)
        self.set_guarded(dock_area=content['dock_area'])

    #--------------------------------------------------------------------------
    # Public API
    #--------------------------------------------------------------------------
    def open(self):
        """ Open the dock pane in the MainWindow.

        Calling this method will also set the pane visibility to True.

        """
        self.set_guarded(visible=True)
        self.send_action('open', {})

    def close(self):
        """ Close the dock pane in the MainWindow.

        Calling this method will set the pane visibility to False.

        """
        self.set_guarded(visible=False)
        self.send_action('close', {})


########NEW FILE########
__FILENAME__ = enable_canvas
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
# NOTE: There shall be no imports from enable in this module. Doing so
# will create an import dependency on enable for the rest of Enaml!
from traits.api import Instance

from .control import Control


class EnableCanvas(Control):
    """ A control which can be used to embded an Enable component.

    """
    #: The enable.component.Component instance to draw.
    component = Instance('enable.component.Component')

    #: An EnableCanvas expands freely in width and height by default.
    hug_width = 'ignore'
    hug_height = 'ignore'

    #--------------------------------------------------------------------------
    # Initialization
    #--------------------------------------------------------------------------
    def snapshot(self):
        """ Get the snapshot dict for the canvas.

        """
        snap = super(EnableCanvas, self).snapshot()
        snap['component'] = self.component
        return snap

    def bind(self):
        """ Bind the change handlers for the control.

        """
        super(EnableCanvas, self).bind()
        self.publish_attributes('component')


########NEW FILE########
__FILENAME__ = field
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from traits.api import Bool, Int, Unicode, Enum, List, Instance

from enaml.validation.validator import Validator

from .control import Control


class Field(Control):
    """ A single line editable text widget.

    """
    #: The unicode text to display in the field.
    text = Unicode

    #: The mask to use for text input.
    #: TODO - describe and implement this mask
    mask = Unicode

    #: The validator to use for this field. If the validator provides
    #: a client side validator, then text will only be submitted if it
    #: passes that validator.
    validator = Instance(Validator)

    #: The list of actions which should cause the client to submit its
    #: text to the server for validation and update. The currently
    #: supported values are 'lost_focus', 'return_pressed' and 
    #: 'text_edited' .
    submit_triggers = List(
        Enum('lost_focus', 'return_pressed', 'text_edited'), 
            ['lost_focus', 'return_pressed']
    )

    #: The grayed-out text to display if the field is empty and the
    #: widget doesn't have focus. Defaults to the empty string.
    placeholder = Unicode

    #: How to display the text in the field. Valid values are 'normal'
    #: which displays the text as normal, 'password' which displays the
    #: text with an obscured character, and 'silent' which displays no
    #: text at all but still allows input.
    echo_mode = Enum('normal', 'password', 'silent')

    #: The maximum length of the field in characters. The default value
    #: is Zero and indicates there is no maximum length.
    max_length = Int(0)

    #: Whether or not the field is read only. Defaults to False.
    read_only = Bool(False)

    #: How strongly a component hugs it's contents' width. Fields ignore
    #: the width hug by default, so they expand freely in width.
    hug_width = 'ignore'

    #--------------------------------------------------------------------------
    # Initialization
    #--------------------------------------------------------------------------
    def snapshot(self):
        """ Returns the snapshot dict for the field.

        """
        snap = super(Field, self).snapshot()
        snap['text'] = self.text
        snap['validator'] = self._client_validator()
        snap['submit_triggers'] = self.submit_triggers
        snap['placeholder'] = self.placeholder
        snap['echo_mode'] = self.echo_mode
        snap['max_length'] = self.max_length
        snap['read_only'] = self.read_only
        return snap

    def bind(self):
        """ A method called after initialization which allows the widget
        to bind any event handlers necessary.

        """
        super(Field, self).bind()
        attrs = (
            'text', 'placeholder', 'echo_mode', 'max_length', 'read_only',
        )
        self.publish_attributes(*attrs)
        self.on_trait_change(self._send_validator, 'validator')
        self.on_trait_change(self._send_submit_triggers, 'submit_triggers[]')

    #--------------------------------------------------------------------------
    # Private API
    #--------------------------------------------------------------------------
    def _client_validator(self):
        """ A private method which returns the current client validator.

        """
        v = self.validator
        return v.client_validator() if v is not None else None

    def _send_validator(self):
        """ Send the new validator to the client widget.

        """
        content = {'validator': self._client_validator()}
        self.send_action('set_validator', content)

    def _send_submit_triggers(self):
        """ Send the new submit triggers to the client widget.

        """
        content = {'submit_triggers': self.submit_triggers}
        self.send_action('set_submit_triggers', content)

    #--------------------------------------------------------------------------
    # Message Handling
    #--------------------------------------------------------------------------
    def on_action_submit_text(self, content):
        """ Handle the 'submit_text' action from the client widget.

        """
        edit_text = content['text']
        validator = self.validator
        if validator is not None:
            text, valid = validator.validate(edit_text, self)
        else:
            text, valid = edit_text, True
        if valid:
            # If the new text differs from the original edit text,
            # we push an update to the client.
            if text != edit_text:
                content = {'text': text}
                self.send_action('set_text', content)
            self.set_guarded(text=text)
        else:
            # notify the client that server validation failed.
            content = {'text': text}
            self.send_action('invalid_text', content)


########NEW FILE########
__FILENAME__ = file_dialog
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from traits.api import Enum, Bool, Callable, List, Unicode

from enaml.application import deferred_call
from enaml.core.messenger import Messenger
from enaml.core.trait_types import EnamlEvent


class FileDialog(Messenger):
    """ A dialog widget that allows the user to open and save files and
    directories.

    """
    #: The title to use for the dialog.
    title = Unicode

    #: The mode of the dialog.
    mode = Enum('open_file', 'open_files', 'save_file', 'directory')

    #: The selected path in the dialog. This value will be used to set
    #: the initial working directory and file, as appropriate, when the
    #: dialog is opened. It will aslo be updated when the dialog is
    #: closed and accepted.
    path = Unicode

    #: The list of selected paths in the dialog. It will be updated
    #: when the dialog is closed and accepted. It is output only and
    #: is only applicable for the `open_files` mode.
    paths = List(Unicode)

    #: The string filters used to restrict the user's selections.
    filters = List(Unicode)

    #: The selected filter from the list of filters. This value will be
    #: used as the initial working filter when the dialog is opened. It
    #: will also be updated when the dialog is closed and accepted.
    selected_filter = Unicode

    #: Whether to use a platform native dialog, when available.
    native_dialog = Bool(True)

    #: An enum indicating if the dialog was accepted or rejected by
    #: the user. It will be updated when the dialog is closed. This
    #: value is output only.
    result = Enum('rejected', 'accepted')

    #: An optional callback which will be invoked when the dialog is
    #: closed. This is a convenience to make it easier to handle the
    #: non-blocking behavior of the dialog. The callback must accept
    #: a single argument, which will be the dialog instance.
    callback = Callable

    #: An event fired when the dialog is closed. The dialog state will
    #: be updated before this event is fired.
    closed = EnamlEvent

    #: Whether to destroy the dialog widget on close. The default is
    #: True since dialogs are typically used in a transitory fashion.
    #: If this value is set to True, the dialog will be destroyed on
    #: the completion of the `closed` event.
    destroy_on_close = Bool(True)

    #--------------------------------------------------------------------------
    # Utility Methods
    #--------------------------------------------------------------------------
    def open(self):
        """ Open the dialog for user interaction.

        """
        if self.parent is None:
            raise ValueError('FileDialog cannot be opened without a parent.')
        content = {}
        content['title'] = self.title
        content['mode'] = self.mode
        content['path'] = self.path
        content['filters'] = self.filters
        content['selected_filter'] = self.selected_filter
        content['native_dialog'] = self.native_dialog
        # A common dialog idiom is as follows:
        #
        #    dlg = FileDialog(foo, ...)
        #    dlg.open()
        #
        # With this scenario, the dialog will not have been initialized
        # by the time the `open` method is called, since the child event
        # of the dialog parent is batched by the Messenger class. The
        # 'open' action must therefore be deferred in order to allow the
        # dialog be fully initialized and capable of sending messages.
        # Otherwise, the 'open' message will be dropped.
        if self.is_active:
            self.send_action('open', content)
        else:
            deferred_call(self.send_action, 'open', content)

    #--------------------------------------------------------------------------
    # Message Handling
    #--------------------------------------------------------------------------
    def on_action_closed(self, content):
        """ Handle the 'closed' action from the client widget.

        """
        self.result = content['result']
        if self.result == 'accepted':
            paths = content['paths']
            self.paths = paths
            self.path = paths[0] if paths else u''
            self.selected_filter = content['selected_filter']
        if self.callback:
            self.callback(self)
        self.closed()
        if self.destroy_on_close:
            self.destroy()


########NEW FILE########
__FILENAME__ = flow_area
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from traits.api import Enum, Range, Property, cached_property

from enaml.core.trait_types import CoercingInstance
from enaml.layout.geometry import Box

from .constraints_widget import ConstraintsWidget
from .flow_item import FlowItem


class FlowArea(ConstraintsWidget):
    """ A widget which lays out its children in flowing manner, wrapping
    around at the end of the available space.

    """
    #: The flow direction of the layout.
    direction = Enum(
        'left_to_right', 'right_to_left', 'top_to_bottom', 'bottom_to_top'
    )

    #: The alignment of a line of items within the layout.
    align = Enum('leading', 'trailing', 'center', 'justify')

    #: The amount of horizontal space to place between items.
    horizontal_spacing = Range(low=0, value=10)

    #: The amount of vertical space to place between items.
    vertical_spacing = Range(low=0, value=10)

    #: The margins to use around the outside of the flow area.
    margins = CoercingInstance(Box, (10, 10, 10, 10))

    #: A read only property which returns the area's flow items.
    flow_items = Property(depends_on='children')

    #: A FlowArea expands freely in width and height by default.
    hug_width = 'ignore'
    hug_height = 'ignore'

    #--------------------------------------------------------------------------
    # Initialization
    #--------------------------------------------------------------------------
    def snapshot(self):
        """ Returns the snapshot dict for the FlowArea.

        """
        snap = super(FlowArea, self).snapshot()
        snap['direction'] = self.direction
        snap['align'] = self.align
        snap['horizontal_spacing'] = self.horizontal_spacing
        snap['vertical_spacing'] = self.vertical_spacing
        snap['margins'] = self.margins
        return snap

    def bind(self):
        """ Bind the change handler for the FlowItem.

        """
        super(FlowArea, self).bind()
        attrs = (
            'direction', 'align', 'horizontal_spacing','vertical_spacing',
            'margins',
        )
        self.publish_attributes(*attrs)

    #--------------------------------------------------------------------------
    # Private API
    #--------------------------------------------------------------------------
    @cached_property
    def _get_flow_items(self):
        """ The getter for the 'flow_items' property.

        Returns
        -------
        result : tuple
            The tuple of FlowItem children defined for this area.

        """
        isinst = isinstance
        items = (c for c in self.children if isinst(c, FlowItem))
        return tuple(items)


########NEW FILE########
__FILENAME__ = flow_item
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from traits.api import Enum, Range, Property, cached_property

from enaml.core.trait_types import CoercingInstance
from enaml.layout.geometry import Size

from .container import Container
from .widget import Widget


class FlowItem(Widget):
    """ A widget which can be used as an item in a FlowArea.

    A FlowItem is a widget which can be used as a child of a FlowArea
    widget. It can have at most a single child widget which is an
    instance of Container.

    """
    #: The preferred size of this flow item. This size will be used as
    #: the size of the item in the layout, bounded to the computed min
    #: and max size. A size of (-1, -1) indicates to use the widget's
    #: size hint as the preferred size.
    preferred_size = CoercingInstance(Size, (-1, -1))

    #: The alignment of this item in the direction orthogonal to the
    #: layout flow.
    align = Enum('leading', 'trailing', 'center')

    #: The stretch factor for this item in the flow direction, relative
    #: to other items in the same line. The default is zero which means
    #: that the item will not expand in the direction orthogonal to the
    #: layout flow.
    stretch = Range(low=0, value=0)

    #: The stretch factor for this item in the orthogonal direction
    #: relative to other items in the layout. The default is zero
    #: which means that the item will not expand in the direction
    #: orthogonal to the layout flow.
    ortho_stretch = Range(low=0, value=0)

    #: A read only property which returns the items's flow widget.
    flow_widget = Property(depends_on='children')

    #--------------------------------------------------------------------------
    # Initialization
    #--------------------------------------------------------------------------
    def snapshot(self):
        """ Returns the snapshot dict for the FlowItem.

        """
        snap = super(FlowItem, self).snapshot()
        snap['preferred_size'] = self.preferred_size
        snap['align'] = self.align
        snap['stretch'] = self.stretch
        snap['ortho_stretch'] = self.ortho_stretch
        return snap

    def bind(self):
        """ Bind the change handler for the FlowItem.

        """
        super(FlowItem, self).bind()
        attrs = ('preferred_size', 'align', 'stretch', 'ortho_stretch')
        self.publish_attributes(*attrs)

    #--------------------------------------------------------------------------
    # Private API
    #--------------------------------------------------------------------------
    @cached_property
    def _get_flow_widget(self):
        """ The getter for the 'flow_widget' property.

        Returns
        -------
        result : Container or None
            The flow widget for the FlowItem, or None if not provided.

        """
        widget = None
        for child in self.children:
            if isinstance(child, Container):
                widget = child
        return widget


########NEW FILE########
__FILENAME__ = form
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from traits.api import Instance, Str

from enaml.layout.constraint_variable import ConstraintVariable
from enaml.layout.layout_helpers import align, hbox, vbox

from .container import  Container


class Form(Container):
    """ A Container subclass that arranges its children in two columns.

    The left column is typically Labels (but this is not a requirement).
    The right are the actual widgets for data entry. The children should
    be in alternating label/widget order. If there are an odd number
    of children, the last child will span both columns.

    The Form provides an extra constraint variable, 'midline', which
    is used as the alignment anchor for the columns.

    """
    #: The ConstraintVariable giving the midline along which the labels
    #: and widgets are aligned.
    midline = Instance(ConstraintVariable)
    def _midline_default(self):
        return ConstraintVariable('midline', self.object_id)

    #: The strength for the form layout constraints.
    # FIXME: Use an Enum.
    layout_strength = Str('strong')

    #: A form hugs its height strongly by default. Forms are typcially
    #: used to display vertical arrangements of widgets, with forms
    #: often being stacked on top of each other. For this case, hugging
    #: the height is desired.
    hug_height = 'strong'

    def _component_constraints(self):
        """ Supplies the constraints which layout the children in a
        two column form.

        """
        # FIXME: do something sensible when children are not visible.
        children = list(self.widgets)
        labels = children[::2]
        widgets = children[1::2]

        n_labels = len(labels)
        n_widgets = len(widgets)

        if n_labels != n_widgets:
            if n_labels > n_widgets:
                odd_child = labels.pop()
            else:
                odd_child = widgets.pop()
        else:
            odd_child = None

        layout_strength = self.layout_strength
        constraints = []

        # Align the left side of each widget with the midline constraint
        # variable of the form.
        midline = self.midline
        for widget in widgets:
            cn = (widget.left == midline) | layout_strength
            constraints.append(cn)

        # Arrange each label/widget pair horizontally in the form
        # XXX this is a highly inefficient way to generate these
        # constraints. It starts to be noticeably slow when the
        # form has around 20 rows. This can be done better.
        labels_widgets = zip(labels, widgets)
        vbox_args = [hbox(label, widget) for label, widget in labels_widgets]
        if odd_child is not None:
            vbox_args.append(odd_child)
        constraints.append(vbox(*vbox_args))

        for label, widget in labels_widgets:
            # FIXME: baselines would be much better.
            constraints.append(align('v_center', label, widget) | layout_strength)

        return constraints

    def _default_constraints(self):
        """ Overridden parent class method which returns an empty list.

        This disables the vbox constraints supplied by the superclass
        Container. All Form constraints are generated by the
        '_component_constraints' method.

        """
        return []


########NEW FILE########
__FILENAME__ = group_box
#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from traits.api import Bool, Unicode, Enum

from .container import Container


class GroupBox(Container):
    """ The GroupBox container, which introduces a group of widgets with 
    a title and usually has a border.

    """
    #: The title displayed at the top of the box.
    title = Unicode

    #: The flat parameter determines if the GroupBox is displayed with 
    #: just the title and a header line (True) or with a full border 
    #: (False, the default).
    flat = Bool(False)

    #: The alignment of the title text.
    title_align = Enum('left', 'right', 'center')

    def snapshot(self):
        """ Populates the initial attributes dict for the component.

        """
        snap = super(GroupBox, self).snapshot()
        snap['title'] = self.title
        snap['flat'] = self.flat
        snap['title_align'] = self.title_align
        return snap

    def bind(self):
        """ A method called after initialization which allows the widget
        to bind any event handlers necessary.

        """
        super(GroupBox, self).bind()
        self.publish_attributes('title', 'title_align', 'flat')


########NEW FILE########
__FILENAME__ = html
#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from traits.api import Str

from .control import Control


class Html(Control):
    """ An extremely simple widget for displaying HTML.

    """
    #: The Html source code to be rendered.
    source = Str

    #: How strongly a component hugs it's contents' width. Html widgets
    #: ignore the width hug by default, so they expand freely in width.
    hug_width = 'ignore'

    #: How strongly a component hugs it's contents' height. Html widgets
    #: ignore the height hug by default, so they expand freely in height.
    hug_height = 'ignore'

    #--------------------------------------------------------------------------
    # Initialization
    #--------------------------------------------------------------------------
    def snapshot(self):
        """ Return the dictionary of creation attributes for the control.

        """
        snap = super(Html, self).snapshot()
        snap['source'] = self.source
        return snap

    def bind(self):
        """ A method called after initialization which allows the widget
        to bind any event handlers necessary.

        """
        super(Html, self).bind()
        self.publish_attributes('source')


########NEW FILE########
__FILENAME__ = image_view
#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from traits.api import Bool, Str

from .control import Control


class ImageView(Control):
    """ A widget which can display an Image with optional scaling.

    """
    #: The source url of the image to load.
    source = Str

    #: Whether or not to scale the image with the size of the component.
    scale_to_fit = Bool(False)

    #: Whether to allow upscaling of an image if scale_to_fit is True.
    allow_upscaling = Bool(True)

    #: Whether or not to preserve the aspect ratio if scaling the image.
    preserve_aspect_ratio = Bool(True)

    #: An image view hugs its width weakly by default.
    hug_width = 'weak'

    #: An image view hugs its height weakly by default.
    hug_height = 'weak'

    #--------------------------------------------------------------------------
    # Initialization
    #--------------------------------------------------------------------------
    def snapshot(self):
        """ Returns the dict of creation attribute for the control.

        """
        snap = super(ImageView, self).snapshot()
        snap['source'] = self.source
        snap['scale_to_fit'] = self.scale_to_fit
        snap['allow_upscaling'] = self.allow_upscaling
        snap['preserve_aspect_ratio'] = self.preserve_aspect_ratio
        return snap

    def bind(self):
        """ A method called after initialization which allows the widget
        to bind any event handlers necessary.

        """
        super(ImageView, self).bind()
        attrs = (
            'source', 'scale_to_fit', 'allow_upscaling',
            'preserve_aspect_ratio',
        )
        self.publish_attributes(*attrs)


########NEW FILE########
__FILENAME__ = include
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
# Backwards compatibility import
from enaml.core.include import Include


########NEW FILE########
__FILENAME__ = label
#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from traits.api import Unicode, Enum

from .control import Control


class Label(Control):
    """ A simple control for displaying read-only text.

    """
    #: The text for the label.
    text = Unicode

    #: The horizontal alignment of the text in the widget area.
    align = Enum('left', 'right', 'center', 'justify')

    #: The vertical alignment of the text in the widget area.
    vertical_align = Enum('center', 'top', 'bottom')

    #: How strongly a component hugs it's content. Labels hug their
    #: contents' width weakly by default.
    hug_width = 'weak'

    #--------------------------------------------------------------------------
    # Initialization
    #--------------------------------------------------------------------------
    def snapshot(self):
        """ Returns the dict of creation attributes for the control.

        """
        snap = super(Label, self).snapshot()
        snap['text'] = self.text
        snap['align'] = self.align
        snap['vertical_align'] = self.vertical_align
        return snap

    def bind(self):
        """ A method called after initialization which allows the widget
        to bind any event handlers necessary.

        """
        super(Label, self).bind()
        self.publish_attributes('text', 'align', 'vertical_align')


########NEW FILE########
__FILENAME__ = list_control
#------------------------------------------------------------------------------
#  Copyright (c) 2013, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from traits.api import Bool, Enum, Range, Property, cached_property

from enaml.core.trait_types import CoercingInstance
from enaml.layout.geometry import Size

from .control import Control
from .list_item import ListItem


class ListControl(Control):
    """ A `ListControl` displays a collection `ListItem` children.

    `ListItem` objects are flexible and convenient, but they are also
    fairly heavy weight. `ListControl` is well suited for use when the
    number of `ListItem` children is under ~1000.

    """
    #: The viewing mode of the list control. The 'list' mode arranges
    #: all items in a vertical list with small icons. The 'icon' mode
    #: uses large icons and a grid layout.
    view_mode = Enum('list', 'icon')

    #: Whether the items are fixed in place or adjusted during a resize.
    #: A relayout can be manually triggered at any time by calling the
    #: `refresh_item_layout()` method.
    resize_mode = Enum('adjust', 'fixed')

    #: The flow direction for the layout. A value of 'default' will
    #: allow the toolkit to choose an appropriate value based on the
    #: chosen view mode.
    flow_mode = Enum('default', 'top_to_bottom', 'left_to_right')

    #: Whether or not the layout items should wrap around at the widget
    #: boundaries. A value of None indicates the toolkit should choose
    #: proper value based on the view mode.
    item_wrap = Enum(None, True, False)

    #: Whether or not the text in the items should wrap at word
    #: boundaries when there is not enough horizontal space.
    word_wrap = Bool(False)

    #: The spacing to place between the items in the widget.
    item_spacing = Range(low=0, value=0)

    #: The size to render the icons in the list control. The default
    #: indicates that the toolkit is free to choose a proper size.
    icon_size = CoercingInstance(Size, (-1, -1))

    #: Whether or not the items in the model have uniform sizes. If
    #: all the items have uniform size, then the layout algorithm
    #: can be much more efficient on large models. If this is set
    #: to True, but the items do not have uniform sizes, then the
    #: behavior of the layout is undefined.
    uniform_item_sizes = Bool(False)

    #: The behavior used when laying out the items. In 'single_pass'
    #: mode, all items are laid out at once. In 'batch' mode, the
    #: items are laid out in batches of 'batch_size'. Batching can
    #: help make large models appear more interactive, but is not
    #: usually required for moderately sized models.
    layout_mode = Enum('single_pass', 'batched')

    #: The size of the layout batch when in 'batched' layout mode.
    batch_size = Range(low=0, value=100)

    #: A read only property which returns the control's list items.
    list_items = Property(depends_on='children')

    #: A list control expands freely in height and width by default.
    hug_width = 'weak'
    hug_height = 'weak'

    #--------------------------------------------------------------------------
    # Initialization
    #--------------------------------------------------------------------------
    def snapshot(self):
        """ Returns the snapshot dictionary for the list control.

        """
        snap = super(ListControl, self).snapshot()
        snap['view_mode'] = self.view_mode
        snap['resize_mode'] = self.resize_mode
        snap['flow_mode'] = self.flow_mode
        snap['item_wrap'] = self.item_wrap
        snap['word_wrap'] = self.word_wrap
        snap['item_spacing'] = self.item_spacing
        snap['icon_size'] = self.icon_size
        snap['uniform_item_sizes'] = self.uniform_item_sizes
        snap['layout_mode'] = self.layout_mode
        snap['batch_size'] = self.batch_size
        return snap

    def bind(self):
        """ A method called after initialization which allows the widget
        to bind any event handlers necessary.

        """
        super(ListControl, self).bind()
        attrs = (
            'view_mode', 'resize_mode', 'flow_mode', 'item_wrap', 'word_wrap',
            'item_spacing', 'icon_size', 'uniform_item_sizes', 'layout_mode',
            'batch_size',
        )
        self.publish_attributes(*attrs)

    #--------------------------------------------------------------------------
    # Public API
    #--------------------------------------------------------------------------
    def refresh_items_layout(self):
        """ Request an items layout refresh from the client widget.

        """
        self.send_action('refresh_items_layout', {})

    #--------------------------------------------------------------------------
    # Private API
    #--------------------------------------------------------------------------
    @cached_property
    def _get_list_items(self):
        """ The getter for the 'list_items' property.

        Returns
        -------
        result : tuple
            The tuple of ListItem children defined for this area.

        """
        isinst = isinstance
        items = (c for c in self.children if isinst(c, ListItem))
        return tuple(items)


########NEW FILE########
__FILENAME__ = list_item
#------------------------------------------------------------------------------
#  Copyright (c) 2013, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from traits.api import Bool, Enum, Str, Unicode

from enaml.core.messenger import Messenger
from enaml.core.trait_types import CoercingInstance, EnamlEvent
from enaml.layout.geometry import Size


class ListItem(Messenger):
    """ A non-widget used as an item in a `ListControl`

    A `ListItem` represents an item in a `ListControl`. It contains all
    of the information needed for data and styling.

    """
    #: The text to display in the item.
    text = Unicode

    #: The tool tip to use for the item.
    tool_tip = Unicode

    #: The status tip to use for the item.
    status_tip = Unicode

    #: The background color of the item. Supports CSS3 color strings.
    background = Str

    #: The foreground color of the item. Supports CSS3 color strings.
    foreground = Str

    #: The font used for the widget. Supports CSS3 shorthand font strings.
    font = Str

    #: The source url for the icon to use for the item.
    icon_source = Str

    #: Whether or not the item can be checked by the user. This has no
    #: bearing on whether or not a checkbox is visible for the item.
    #: For controlling the visibility of the checkbox, see `checked`.
    checkable = Bool(False)

    #: Whether or not the item is checked. A value of None indicates
    #: that no check box should be visible for the item.
    checked = Enum(None, False, True)

    #: Whether or not the item can be selected.
    selectable = Bool(True)

    #: Whether or not the item is selected. This value only has meaning
    #: if 'selectable' is set to True.
    selected = Bool(False)

    #: Whether or not the item is editable.
    editable = Bool(False)

    #: Whether or not the item is enabled.
    enabled = Bool(True)

    #: Whether or not the item is visible.
    visible = Bool(True)

    #: The horizontal alignment of the text in the item area.
    text_align = Enum('left', 'right', 'center', 'justify')

    #: The vertical alignment of the text in the item area.
    vertical_text_align = Enum('center', 'top', 'bottom')

    #: The preferred size of the item.
    preferred_size = CoercingInstance(Size, (-1, -1))

    #: An event fired when the user clicks on the item. The payload
    #: will be the current checked state of the item.
    clicked = EnamlEvent

    #: An event fired when the user double clicks on the item. The
    #: payload will be the current checked state of the item.
    double_clicked = EnamlEvent

    #: An event fired when the user toggles a checkable item. The
    #: payload will be the current checked state of the item.
    toggled = EnamlEvent

    #--------------------------------------------------------------------------
    # Initialization
    #--------------------------------------------------------------------------
    def snapshot(self):
        """ Returns the snapshot dictionary for the list item.

        """
        snap = super(ListItem, self).snapshot()
        snap['text'] = self.text
        snap['tool_tip'] = self.tool_tip
        snap['status_tip'] = self.status_tip
        snap['background'] = self.background
        snap['foreground'] = self.foreground
        snap['font'] = self.font
        snap['icon_source'] = self.icon_source
        snap['checkable'] = self.checkable
        snap['checked'] = self.checked
        snap['selectable'] = self.selectable
        snap['selected'] = self.selected
        snap['editable'] = self.editable
        snap['enabled'] = self.enabled
        snap['visible'] = self.visible
        snap['text_align'] = self.text_align
        snap['vertical_text_align'] = self.vertical_text_align
        snap['preferred_size'] = self.preferred_size
        return snap

    def bind(self):
        """ Bind the change handlers for the list item.

        """
        super(ListItem, self).bind()
        attrs = (
            'text', 'tool_tip', 'status_tip', 'background', 'foreground',
            'font', 'icon_source', 'checkable', 'checked', 'selectable',
            'selected', 'editable', 'enabled', 'visible', 'preferred_size',
            'text_align', 'vertical_text_align',
        )
        self.publish_attributes(*attrs)

    #--------------------------------------------------------------------------
    # Message Handling
    #--------------------------------------------------------------------------
    def on_action_clicked(self, content):
        """ Handle the 'clicked' action from the client widget.

        """
        self.clicked(self.checked)

    def on_action_double_clicked(self, content):
        """ Handle the 'double_clicked' action from the client widget.

        """
        self.double_clicked(self.checked)

    def on_action_changed(self, content):
        """ Handle the 'changed' action from the client widget.

        """
        old_checked = self.checked
        new_checked = content['checked']
        was_toggled = old_checked != new_checked
        if was_toggled:
            self.set_guarded(checked=new_checked)
        self.set_guarded(text=content['text'])
        if was_toggled:
            self.toggled(new_checked)


########NEW FILE########
__FILENAME__ = main_window
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from traits.api import Property, cached_property

from .dock_pane import DockPane
from .menu_bar import MenuBar
from .tool_bar import ToolBar
from .window import Window


class MainWindow(Window):
    """ A top level main window widget.

    MainWindow widgets are top level widgets which provide additional
    functionality beyond frame decoration. A MainWindow may optionally
    contain a MenuBar, any number of ToolBars, a StatusBar, and any
    number of DockPanes. Like Window, a MainWindow can have at most one
    central Container widget, which will be expanded to fit into the
    available space.

    """
    #: A read only property which returns the window's MenuBar.
    menu_bar = Property(depends_on='children')

    #: A read only property which returns the window's ToolBars.
    tool_bars = Property(depends_on='children')

    #: A read only property which returns the window's DockPanes.
    dock_panes = Property(depends_on='children')

    #: A read only property which returns the window's StatusBar.
    # status_bar = Property(depends_on='children')

    #--------------------------------------------------------------------------
    # Private API
    #--------------------------------------------------------------------------
    @cached_property
    def _get_menu_bar(self):
        """ The getter for the 'menu_bar' property.

        Returns
        -------
        result : MenuBar or None
            The menu bar for this main window, or None if one is not
            defined.

        """
        menu = None
        for child in self.children:
            if isinstance(child, MenuBar):
                menu = child
        return menu

    @cached_property
    def _get_tool_bars(self):
        """ The getter for the 'tool_bars' property.

        Returns
        -------
        result : tuple
            The tuple of ToolBar instances defined as children of this
            MainWindow.

        """
        isinst = isinstance
        panes = (child for child in self.children if isinst(child, ToolBar))
        return tuple(panes)

    @cached_property
    def _get_dock_panes(self):
        """ The getter for the 'dock_panes' property.

        Returns
        -------
        result : tuple
            The tuple of DockPane instances defined as children of this
            MainWindow.

        """
        isinst = isinstance
        panes = (child for child in self.children if isinst(child, DockPane))
        return tuple(panes)


########NEW FILE########
__FILENAME__ = mdi_area
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from traits.api import Property, cached_property

from .constraints_widget import ConstraintsWidget
from .mdi_window import MdiWindow


class MdiArea(ConstraintsWidget):
    """ A widget which acts as a virtual window manager for other
    top level widget.

    An MdiArea can be used to provide an area within an application
    that can display other widgets in their own independent windows.
    Children of an MdiArea should be defined as instances of MdiWindow.

    """
    #: A read only property which returns the area's MdiWindows.
    mdi_windows = Property(depends_on='children')

    #: An MdiArea expands freely in width and height by default.
    hug_width = 'ignore'
    hug_height = 'ignore'
    
    #: An MdiArea resists clipping only weakly by default.
    resist_width = 'weak'
    resist_height = 'weak'

    #--------------------------------------------------------------------------
    # Private API
    #--------------------------------------------------------------------------
    @cached_property
    def _get_mdi_windows(self):
        """ The getter for the 'mdi_windows' property.

        Returns
        -------
        result : tuple
            The tuple of MdiWindow instances defined as children of this
            MdiArea.

        """
        isinst = isinstance
        windows = (c for c in self.children if isinst(c, MdiWindow))
        return tuple(windows)


########NEW FILE########
__FILENAME__ = mdi_window
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from traits.api import Property, cached_property

from .widget import Widget


class MdiWindow(Widget):
    """ A widget which can be used as a window in an MdiArea.

    An MdiWindow is a widget which can be used as an independent window
    in an MdiArea. It can have at most a single child widget which is
    an instance of Widget.

    """
    #: A read only property which returns the pane's dock widget.
    mdi_widget = Property(depends_on='children')

    #--------------------------------------------------------------------------
    # Private API
    #--------------------------------------------------------------------------
    @cached_property
    def _get_mdi_widget(self):
        """ The getter for the 'mdi_widget' property.

        Returns
        -------
        result : Widget or None
            The mdi widget for the MdiWindow, or None if not provided.

        """
        widget = None
        for child in self.children:
            if isinstance(child, Widget):
                widget = child
        return widget


########NEW FILE########
__FILENAME__ = menu
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from traits.api import Bool, Unicode, Property, cached_property

from .action import Action
from .action_group import ActionGroup
from .widget import Widget


class Menu(Widget):
    """ A widget used as a menu in a MenuBar.

    """
    #: The title to use for the menu.
    title = Unicode

    #: Whether this menu should behave as a context menu for its parent.
    context_menu = Bool(False)

    #: The items in the menu: Menu | Action | ActionGroup
    items = Property(depends_on='children')

    #--------------------------------------------------------------------------
    # Initialization
    #--------------------------------------------------------------------------
    def snapshot(self):
        """ Returns the snapshot dict for the Menu.

        """
        snap = super(Menu, self).snapshot()
        snap['title'] = self.title
        snap['context_menu'] = self.context_menu
        return snap

    def bind(self):
        """ Bind the change handlers for the menu.

        """
        super(Menu, self).bind()
        self.publish_attributes('title', 'context_menu')

    #--------------------------------------------------------------------------
    # Private API
    #--------------------------------------------------------------------------
    @cached_property
    def _get_items(self):
        """ The getter for the 'items' property.

        Returns
        -------
        result : tuple
            The tuple of menu items for this menu.

        """
        isinst = isinstance
        allowed = (Action, ActionGroup, Menu)
        items = (child for child in self.children if isinst(child, allowed))
        return tuple(items)


########NEW FILE########
__FILENAME__ = menu_bar
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from traits.api import Property, cached_property

from .menu import Menu
from .widget import Widget


class MenuBar(Widget):
    """ A widget used as a menu bar in a MainWindow.

    """
    #: A read only property which returns the menu bar's menus.
    menus = Property(depends_on='children')

    #--------------------------------------------------------------------------
    # Private API
    #--------------------------------------------------------------------------
    @cached_property
    def _get_menus(self):
        """ The getter for the 'menus' property.

        Returns
        -------
        result : tuple
            The tuple of Menus defined as children of this MenuBar.

        """
        isinst = isinstance
        menus = (child for child in self.children if isinst(child, Menu))
        return tuple(menus)


########NEW FILE########
__FILENAME__ = mpl_canvas
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#
# Special thanks to Steven Silvester for contributing this module!
#------------------------------------------------------------------------------
# NOTE: There shall be no imports from matplotlib in this module. Doing so
# will create an import dependency on matplotlib for the rest of Enaml!
from traits.api import Instance, Bool

from .control import Control


class MPLCanvas(Control):
    """ A control which can be used to embded a matplotlib figure.

    """
    #: The matplotlib figure to display in the widget.
    figure = Instance('matplotlib.figure.Figure')

    #: Whether or not the matplotlib figure toolbar is visible.
    toolbar_visible = Bool(False)

    #: Matplotlib figures expand freely in height and width by default.
    hug_width = 'ignore'
    hug_height = 'ignore'

    #--------------------------------------------------------------------------
    # Initialization
    #--------------------------------------------------------------------------
    def snapshot(self):
        """ Get the snapshot dict for the MPLCanvas.

        """
        snap = super(MPLCanvas, self).snapshot()
        snap['figure'] = self.figure
        snap['toolbar_visible'] = self.toolbar_visible
        return snap

    def bind(self):
        """ Bind the change handlers for the MPLCanvas.

        """
        super(MPLCanvas, self).bind()
        self.publish_attributes('figure', 'toolbar_visible')


########NEW FILE########
__FILENAME__ = multiline_field
#------------------------------------------------------------------------------
#  Copyright (c) 2013, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from traits.api import Bool, Unicode

from .control import Control


class MultilineField(Control):
    """ A simple multiline editable text widget.

    """
    #: The unicode text to display in the field.
    text = Unicode

    #: Whether or not the field is read only.
    read_only = Bool(False)

    #: Whether the text in the control should be auto-synchronized with
    #: the text attribute on the field. If this is True, the text will
    #: be updated every time the user edits the control. In order to be
    #: efficient, the toolkit will batch updates on a collapsing timer.
    auto_sync_text = Bool(True)

    #: Multiline fields expand freely in width and height by default.
    hug_width = 'ignore'
    hug_height = 'ignore'

    #--------------------------------------------------------------------------
    # Initialization
    #--------------------------------------------------------------------------
    def snapshot(self):
        """ Get the snapshot dict for the control.

        """
        snap = super(MultilineField, self).snapshot()
        snap['text'] = self.text
        snap['read_only'] = self.read_only
        snap['auto_sync_text'] = self.auto_sync_text
        return snap

    def bind(self):
        """ Bind the change handlers for the control.

        """
        super(MultilineField, self).bind()
        self.publish_attributes('text', 'read_only', 'auto_sync_text')

    #--------------------------------------------------------------------------
    # Message Handling
    #--------------------------------------------------------------------------
    def on_action_text_changed(self, content):
        """ Handle the 'text_changed' action from the client widget.

        """
        text = content['text']
        self.set_guarded(text=text)

    #--------------------------------------------------------------------------
    # Public API
    #--------------------------------------------------------------------------
    def sync_text(self):
        """ Send a message to the toolkit to synchronize the text.

        """
        self.send_action('sync_text', {})


########NEW FILE########
__FILENAME__ = notebook
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from traits.api import Enum, Bool, Property, cached_property

from .constraints_widget import ConstraintsWidget
from .page import Page


class Notebook(ConstraintsWidget):
    """ A component which displays its children as tabbed pages.
    
    """
    #: The style of tabs to use in the notebook. Preferences style
    #: tabs are appropriate for configuration dialogs and the like.
    #: Document style tabs are appropriate for multi-page editing
    #: in code editors and the like.
    tab_style = Enum('document', 'preferences')

    #: The position of tabs in the notebook.
    tab_position = Enum('top', 'bottom', 'left', 'right')

    #: Whether or not the tabs in the notebook should be closable.
    tabs_closable = Bool(True)

    #: Whether or not the tabs in the notebook should be movable.
    tabs_movable = Bool(True)

    #: A read only property which returns the notebook's Pages.
    pages = Property(depends_on='children')

    #: How strongly a component hugs it's contents' width. A Notebook
    #: ignores its width hug by default, so it expands freely in width.
    hug_width = 'ignore'

    #: How strongly a component hugs it's contents' height. A Notebook
    #: ignores its height hug by default, so it expands freely in height.
    hug_height = 'ignore'

    #--------------------------------------------------------------------------
    # Initialization
    #--------------------------------------------------------------------------
    def snapshot(self):
        """ Returns the snapshot for the control.

        """
        snap = super(Notebook, self).snapshot()
        snap['tab_style'] = self.tab_style
        snap['tab_position'] = self.tab_position
        snap['tabs_closable'] = self.tabs_closable
        snap['tabs_movable'] = self.tabs_movable
        return snap

    def bind(self):
        """ Bind the change handlers for the control.

        """
        super(Notebook, self).bind()
        attrs = (
            'tab_style', 'tab_position', 'tabs_closable', 'tabs_movable',
        )
        self.publish_attributes(*attrs)

    #--------------------------------------------------------------------------
    # Private API
    #--------------------------------------------------------------------------
    @cached_property
    def _get_pages(self):
        """ The getter for the 'pages' property.

        Returns
        -------
        result : tuple
            The tuple of Page instances defined as children of this
            Notebook.

        """
        isinst = isinstance
        pages = (child for child in self.children if isinst(child, Page))
        return tuple(pages)


########NEW FILE########
__FILENAME__ = page
#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from traits.api import Unicode, Bool, Str, Property, cached_property

from enaml.core.trait_types import EnamlEvent

from .container import Container
from .widget import Widget


class Page(Widget):
    """ A widget which can be used as a page in a Notebook control.

    A Page is a widget which can be used as a child of a Notebook
    control. It can have at most a single child widget which is an
    instance of Container.

    """
    #: The title to use for the page in the notebook.
    title = Unicode

    #: The source url for the icon to use for the page.
    icon_source = Str

    #: Whether or not this individual page is closable. Note that the
    #: 'tabs_closable' flag on the parent Notebook must be set to True
    #: for this to have any effect.
    closable = Bool(True)

    #: A read only property which returns the page's page widget.
    page_widget = Property(depends_on='children')

    #: An event fired when the user closes the page by clicking on
    #: the tab's close button. This event is fired by the parent
    #: Notebook when the tab is closed. This event has no payload.
    closed = EnamlEvent

    #--------------------------------------------------------------------------
    # Initialization
    #--------------------------------------------------------------------------
    def snapshot(self):
        """ Return the snapshot for the control.

        """
        snap = super(Page, self).snapshot()
        snap['title'] = self.title
        snap['closable'] = self.closable
        snap['icon_source'] = self.icon_source
        return snap

    def bind(self):
        """ Bind the change handlers for the control.

        """
        super(Page, self).bind()
        self.publish_attributes('title', 'closable', 'icon_source')

    #--------------------------------------------------------------------------
    # Private API
    #--------------------------------------------------------------------------
    @cached_property
    def _get_page_widget(self):
        """ The getter for the 'page_widget' property.

        Returns
        -------
        result : Container or None
            The page widget for the Page, or None if not provided.

        """
        widget = None
        for child in self.children:
            if isinstance(child, Container):
                widget = child
        return widget

    #--------------------------------------------------------------------------
    # Message Handling
    #--------------------------------------------------------------------------
    def on_action_closed(self, content):
        """ Handle the 'closed' action from the client widget.

        """
        self.set_guarded(visible=False)
        self.closed()

    #--------------------------------------------------------------------------
    # Public API
    #--------------------------------------------------------------------------
    def open(self):
        """ Open the page in the Notebook.

        Calling this method will also set the page visibility to True.

        """
        self.set_guarded(visible=True)
        self.send_action('open', {})

    def close(self):
        """ Close the page in the Notebook.

        Calling this method will set the page visibility to False.

        """
        self.set_guarded(visible=False)
        self.send_action('close', {})


########NEW FILE########
__FILENAME__ = progress_bar
#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from traits.api import Int, Property, TraitError, on_trait_change

from enaml.core.trait_types import Bounded

from .control import Control


class ProgressBar(Control):
    """ A control which displays a value as a ticking progress bar.

    """
    #: The minimum value that the progress bar can take. Extra checks
    #: take place to make sure that the user does not programmatically
    #: set :attr:`minimum` > :attr:`maximum`.
    minimum = Property(Int, depends_on='_minimum')

    #: The internal minimum storage.
    _minimum = Int(0)

    #: The maximum value that the progress bar can take. Extra checks
    #: take place to make sure that the user does not programmatically
    #: set :attr:`minimum` > :attr:`maximum`.
    maximum = Property(Int, depends_on='_maximum')

    #: The internal maximum storage.
    _maximum = Int(100)

    #: The current value. Default is the minimum value. The value is
    #: bounded between :attr:`minimum` and :attr:`maximum`. Changing
    #: the boundary attributes might result in an update of :attr:`value`
    #: to fit in the new range. Attempts to assign a value outside of
    #: these bounds will result in a TraitError.
    value = Bounded(0, low='minimum', high='maximum')

    #: The percentage completed, rounded to an integer. This is a
    #: readonly property for convenient use by other Components.
    percentage = Property(Int, depends_on=['_minimum', '_maximum', 'value'])

    #: How strongly a component hugs it's content. ProgressBars expand
    #: to fill the available horizontal space by default.
    hug_width = 'ignore'

    #--------------------------------------------------------------------------
    # Initialization
    #--------------------------------------------------------------------------
    def snapshot(self):
        """ Returns the dict of creation attributes for the control.

        """
        snap = super(ProgressBar, self).snapshot()
        snap['maximum'] = self.maximum
        snap['minimum'] = self.minimum
        snap['value'] = self.value
        return snap

    def bind(self):
        """ A method called after initialization which allows the widget
        to bind any event handlers necessary.

        """
        super(ProgressBar, self).bind()
        self.publish_attributes('maximum', 'minimum', 'value')

    #--------------------------------------------------------------------------
    # Property Methods
    #--------------------------------------------------------------------------
    def _get_minimum(self):
        """ The property getter for the ProgressBar minimum.

        """
        return self._minimum

    def _set_minimum(self, value):
        """ The property setter for :attr:`minimum`. Addtional checks are
        applied to make sure that :attr:`minimum` < :attr:`maximum`

        """
        if value > self.maximum:
            msg = ('The minimum value of ProgressBar should be smaller than '
                   'the current maximum value({0}), but a value of {1} was '
                   'given')
            msg = msg.format(self.maximum, value)
            raise TraitError(msg)
        self._minimum = value

    def _get_maximum(self):
        """ The property getter for the ProgressBar maximum.

        """
        return self._maximum

    def _set_maximum(self, value):
        """ The property setter for :attr:`maximum`. Addtional checks are
        applied to make sure that :attr:`minimum` < :attr:`maximum`

        """
        if value < self.minimum:
            msg = ('The maximum value of ProgressBar should be larger than '
                   'the current minimum value({0}), but a value of {1} was '
                   'given')
            msg = msg.format(self.minimum, value)
            raise TraitError(msg)
        self._maximum = value

    def _get_percentage(self):
        """ The property getter for the ProgressBar percentage.

        """
        minimum = self.minimum
        maximum = self.maximum
        value = self.value
        dy = maximum - minimum
        if dy == 0:
            res = 0
        elif value == maximum:
            res = 100
        else:
            dx = float(value - minimum)
            res = int(round(100.0 * dx / dy))
            # We already excluded the case where the value was exactly
            # the maximum, so we can't really be at 100%, so round this
            # down to 99% if necessary.
            res = min(res, 99)
        return res

    #--------------------------------------------------------------------------
    # Private API
    #--------------------------------------------------------------------------
    @on_trait_change('minimum, maximum')
    def _adapt_value(self):
        """ Adapt the value to the boundaries

        """
        if self.initialized:
            self.value = min(max(self.value, self.minimum), self.maximum)


########NEW FILE########
__FILENAME__ = push_button
#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from traits.api import Property, cached_property

from .abstract_button import AbstractButton
from .menu import Menu


class PushButton(AbstractButton):
    """ A button control represented by a standard push button widget.

    """
    #: A read only property which returns the button's menu.
    menu = Property(depends_on='children')

    #--------------------------------------------------------------------------
    # Private API
    #--------------------------------------------------------------------------
    @cached_property
    def _get_menu(self):
        """ The getter for the 'menu' property.

        Returns
        -------
        result : Menu or None
            The menu for the PushButton, or None if not provided.

        """
        menu = None
        for child in self.children:
            if isinstance(child, Menu):
                menu = child
        return menu


########NEW FILE########
__FILENAME__ = radio_button
#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from .abstract_button import AbstractButton


class RadioButton(AbstractButton):
    """ An exclusive checkable button represented by a standard radio
    button widget. 

    Use a radio button to toggle the value of a boolean field. For a 
    group of radio buttons with the same widget parent, only one radio 
    button may be selected at a time. This makes groups of radio buttons 
    useful for selecting amongst a discrete set of values. For multiple 
    groups of independent radio buttons, place each group of buttons
    in their own Container.

    The interface for AbstractButton fully defines the interface for
    a RadioButton.

    """
    #: Radio buttons are checkable by default.
    checkable = True


########NEW FILE########
__FILENAME__ = scroll_area
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from traits.api import Enum, Property, Bool, cached_property

from .constraints_widget import ConstraintsWidget
from .container import Container


#: Enum trait describing the scrollbar policies that can be assigned to
#: the horizontal and vertical scrollbars.
ScrollbarPolicy = Enum('as_needed', 'always_on', 'always_off')


class ScrollArea(ConstraintsWidget):
    """ A widget which displays a single child in a scrollable area.

    A ScrollArea has at most a single child Container widget.

    """
    #: The horizontal scrollbar policy.
    horizontal_policy = ScrollbarPolicy

    #: The vertical scrollbar policy.
    vertical_policy = ScrollbarPolicy

    #: Whether to resize the scroll widget when possible to avoid the
    #: need for scrollbars or to make use of extra space.
    widget_resizable = Bool(True)

    #: A read only property which returns the scrolled widget.
    scroll_widget = Property(depends_on='children')

    #: How strongly a component hugs it's contents' width. Scroll
    #: areas do not hug their width and are free to expand.
    hug_width = 'ignore'

    #: How strongly a component hugs it's contents' height. Scroll
    #: areas do not hug their height and are free to expand.
    hug_height = 'ignore'

    #--------------------------------------------------------------------------
    # Initialization
    #--------------------------------------------------------------------------
    def snapshot(self):
        """ Return a dictionary which contains all the state necessary to
        initialize a client widget.

        """
        snap = super(ScrollArea, self).snapshot()
        snap['horizontal_policy'] = self.horizontal_policy
        snap['vertical_policy'] = self.vertical_policy
        snap['widget_resizable'] = self.widget_resizable
        return snap

    def bind(self):
        """ Bind the change handlers for this widget.

        """
        super(ScrollArea, self).bind()
        attrs = ('horizontal_policy', 'vertical_policy', 'widget_resizable')
        self.publish_attributes(*attrs)

    #--------------------------------------------------------------------------
    # Private API
    #--------------------------------------------------------------------------
    @cached_property
    def _get_scroll_widget(self):
        """ The getter for the 'scroll_widget' property.

        Returns
        -------
        result : Container or None
            The scroll widget for the ScrollArea, or None if not
            provided.

        """
        widget = None
        for child in self.children:
            if isinstance(child, Container):
                widget = child
        return widget


########NEW FILE########
__FILENAME__ = separator
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from traits.api import Range, Enum, Either, Property

from .constraints_widget import PolicyEnum
from .control import Control


class Separator(Control):
    """ A widget which draws a horizontal or vertical separator line.

    """
    #: The orientation of the separator line.
    orientation = Enum('horizontal', 'vertical')

    #: The line style for the separator.
    line_style = Enum('sunken', 'raised', 'plain')

    #: The thickness of the outer separator line.
    line_width = Range(low=0, high=3, value=1)

    #: The thickness of the inner separator line. This only has an
    #: effect for the 'sunken' and 'raised' line styles.
    midline_width = Range(low=0, high=3, value=0)

    #: Hug width is redefined as a property to be computed based on the
    #: orientation of the separator unless overridden by the user.
    hug_width = Property(PolicyEnum, depends_on=['_hug_width', 'orientation'])

    #: Hug height is redefined as a property to be computed based on the
    #: orientation of the separator unless overridden by the user.
    hug_height = Property(PolicyEnum, depends_on=['_hug_height', 'orientation'])

    #: An internal override trait for hug_width
    _hug_width = Either(None, PolicyEnum, default=None)

    #: An internal override trait for hug_height
    _hug_height = Either(None, PolicyEnum, default=None)

    #--------------------------------------------------------------------------
    # Initialization
    #--------------------------------------------------------------------------
    def snapshot(self):
        """ Returns the snapshot dictionary for the Separator.

        """
        snap = super(Separator, self).snapshot()
        snap['orientation'] = self.orientation
        snap['line_style'] = self.line_style
        snap['line_width'] = self.line_width
        snap['midline_width'] = self.midline_width
        return snap

    def bind(self):
        """ Binds the change handlers for the Separator.

        """
        super(Separator, self).bind()
        attrs = ('orientation', 'line_style', 'line_width', 'midline_width')
        self.publish_attributes(*attrs)

    #--------------------------------------------------------------------------
    # Property Methods
    #--------------------------------------------------------------------------
    def _get_hug_width(self):
        """ The property getter for 'hug_width'.

        Returns a computed hug value unless overridden by the user.

        """
        res = self._hug_width
        if res is None:
            if self.orientation == 'horizontal':
                res = 'ignore'
            else:
                res = 'strong'
        return res

    def _get_hug_height(self):
        """ The proper getter for 'hug_height'.

        Returns a computed hug value unless overridden by the user.

        """
        res = self._hug_height
        if res is None:
            if self.orientation == 'vertical':
                res = 'ignore'
            else:
                res = 'strong'
        return res

    def _set_hug_width(self, value):
        """ The property setter for 'hug_width'.

        Overrides the computed value.

        """
        self._hug_width = value

    def _set_hug_height(self, value):
        """ The property setter for 'hug_height'.

        Overrides the computed value.

        """
        self._hug_height = value


########NEW FILE########
__FILENAME__ = slider
#------------------------------------------------------------------------------
#  Copyright (c) 2013, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from traits.api import Bool, Enum, Property, Int, Either, Range

from .constraints_widget import PolicyEnum
from .control import Control


class Slider(Control):
    """ A simple slider widget that can be used to select from a range
    of integral values.

    A `SliderTransform` can be used to transform the integer range
    of the slider into another data space. For more details, see
    `enaml.stdlib.slider_transform`.

    """
    #: The minimum slider value. If the minimum value is changed such
    #: that it becomes greater than the current value or the maximum
    #: value, then those values will be adjusted. The default is 0.
    minimum = Property(Int)

    #: The internal minimum value storage.
    _minimum = Int(0)

    #: The maximum slider value. If the maximum value is changed such
    #: that it becomes smaller than the current value or the minimum
    #: value, then those values will be adjusted. The default is 100.
    maximum = Property(Int)

    #: The internal maximum storage.
    _maximum = Int(100)

    #: The position value of the Slider. The value will be clipped to
    #: always fall between the minimum and maximum.
    value = Property(Int)

    #: The internal value storage.
    _value = Int(0)

    #: Defines the number of steps that the slider will move when the
    #: user presses the arrow keys. The default is 1. An upper limit
    #: may be imposed according the limits of the client widget.
    single_step = Range(low=1)

    #: Defines the number of steps that the slider will move when the
    #: user presses the page_up/page_down keys. The Default is 10. An
    #: upper limit may be imposed on this value according to the limits
    #: of the client widget.
    page_step = Range(low=1, value=10)

    #: A TickPosition enum value indicating how to display the tick
    #: marks. Note that the orientation takes precedence over the tick
    #: mark position and an incompatible tick position will be adapted
    #: according to the current orientation. The default tick position
    #: is 'bottom'.
    tick_position = Enum(
        'bottom', ('no_ticks', 'left', 'right', 'top', 'bottom', 'both'),
    )

    #: The interval to place between slider tick marks in units of
    #: value (as opposed to pixels). The minimum value is 0, which
    #: indicates that the choice is left up to the client.
    tick_interval = Range(low=0)

    #: The orientation of the slider. The default orientation is
    #: horizontal. When the orientation is flipped the tick positions
    #: (if set) also adapt to reflect the changes  (e.g. the LEFT
    #: becomes TOP when the orientation becomes horizontal).
    orientation = Enum('horizontal', 'vertical')

    #: If True, the value is updated while sliding. Otherwise, it is
    #: only updated when the slider is released. Defaults to True.
    tracking = Bool(True)

    #: Hug width is redefined as a property to be computed based on the
    #: orientation of the slider unless overridden by the user.
    hug_width = Property(PolicyEnum, depends_on=['_hug_width', 'orientation'])

    #: Hug height is redefined as a property to be computed based on the
    #: orientation of the slider unless overridden by the user.
    hug_height = Property(PolicyEnum, depends_on=['_hug_height', 'orientation'])

    #: An internal override trait for hug_width
    _hug_width = Either(None, PolicyEnum, default=None)

    #: An internal override trait for hug_height
    _hug_height = Either(None, PolicyEnum, default=None)

    #--------------------------------------------------------------------------
    # Initialization
    #--------------------------------------------------------------------------
    def snapshot(self):
        """ Return a dictionary which contains all the state necessary to
        initialize a client widget.

        """
        snap = super(Slider, self).snapshot()
        snap['minimum'] = self.minimum
        snap['maximum'] = self.maximum
        snap['value'] = self.value
        snap['single_step'] = self.single_step
        snap['page_step'] = self.page_step
        snap['tick_position'] = self.tick_position
        snap['tick_interval'] = self.tick_interval
        snap['orientation'] = self.orientation
        snap['tracking'] = self.tracking
        return snap

    def bind(self):
        """ A method called after initialization which allows the widget
        to bind any event handlers necessary.

        """
        super(Slider, self).bind()
        attrs = (
            'minimum', 'maximum', 'value', 'single_step', 'page_step',
            'tick_position', 'tick_interval', 'orientation', 'tracking',
        )
        self.publish_attributes(*attrs)

    #--------------------------------------------------------------------------
    # Message Handling
    #--------------------------------------------------------------------------
    def on_action_value_changed(self, content):
        """ Handle the 'value_changed' action from the client widget.

        The content will contain the 'value' of the slider.

        """
        self.set_guarded(value=content['value'])

    #--------------------------------------------------------------------------
    # Property Methods
    #--------------------------------------------------------------------------
    def _get_hug_width(self):
        """ The property getter for 'hug_width'.

        Returns a computed hug value unless overridden by the user.

        """
        res = self._hug_width
        if res is None:
            if self.orientation == 'horizontal':
                res = 'ignore'
            else:
                res = 'strong'
        return res

    def _get_hug_height(self):
        """ The proper getter for 'hug_height'.

        Returns a computed hug value unless overridden by the user.

        """
        res = self._hug_height
        if res is None:
            if self.orientation == 'vertical':
                res = 'ignore'
            else:
                res = 'strong'
        return res

    def _set_hug_width(self, value):
        """ The property setter for 'hug_width'.

        Overrides the computed value.

        """
        self._hug_width = value

    def _set_hug_height(self, value):
        """ The property setter for 'hug_height'.

        Overrides the computed value.

        """
        self._hug_height = value

    def _get_minimum(self):
        """ The property getter for the slider 'minimum'.

        """
        return self._minimum

    def _set_minimum(self, minimum):
        """ The property setter for the 'minimum' attribute.

        """
        # Manually fire the trait change notifications to avoid the
        # need for property depends_on; this saves memory overhead.
        # All data is accessed using the private attributes to avoid
        # inadvertantly triggering the evaluation of a bound Enaml
        # attribute, which could fool with the state by setting the
        # value too soon.
        old_max = self._maximum
        if minimum > old_max:
            self._maximum = minimum
            self.trait_property_changed('maximum', old_max, minimum)
        old_val = self._value
        if minimum > old_val:
            self._value = minimum
            self.trait_property_changed('value', old_val, minimum)
        old_min = self._minimum
        if minimum != old_min:
            self._minimum = minimum
            self.trait_property_changed('minimum', old_min, minimum)

    def _get_maximum(self):
        """ The property getter for the slider 'maximum'.

        """
        return self._maximum

    def _set_maximum(self, maximum):
        """ The property setter for the 'maximum' attribute.

        """
        # Manually fire the trait change notifications to avoid the
        # need for property depends_on; this saves memory overhead.
        # All data is accessed using the private attributes to avoid
        # inadvertantly triggering the evaluation of a bound Enaml
        # attribute, which could fool with the state by setting the
        # value too soon.
        old_min = self._minimum
        if maximum < old_min:
            self._minimum = maximum
            self.trait_property_changed('minimum', old_min, maximum)
        old_val = self._value
        if maximum < old_val:
            self._value = maximum
            self.trait_property_changed('value', old_val, maximum)
        old_max = self._maximum
        if maximum != old_max:
            self._maximum = maximum
            self.trait_property_changed('maximum', old_max, maximum)

    def _get_value(self):
        """ The property getter for the slider 'value'.

        """
        return self._value

    def _set_value(self, value):
        """ The property setter for the 'value' attribute.

        """
        # Manually fire the trait change notifications to avoid the
        # need for property depends_on; this saves memory overhead.
        # The minimum and maximum values are explicity accessed through
        # their property so that any bound Enaml attributes can provide
        # the proper default value. This ensures that the min and max
        # are alway up-to-date before potentially clipping the value.
        old_val = self._value
        new_val = max(self.minimum, min(self.maximum, value))
        if old_val != new_val:
            self._value = new_val
            self.trait_property_changed('value', old_val, new_val)


########NEW FILE########
__FILENAME__ = spin_box
#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from traits.api import Int, Bool, Range, Unicode

from .control import Control


class SpinBox(Control):
    """ A spin box widget which manipulates integer values.

    """
    #: The minimum value for the spin box. Defaults to 0.
    minimum = Int(0)

    #: The maximum value for the spin box. Defaults to 100.
    maximum = Int(100)

    #: The current integer value for the spin box, constrained to
    #: minimum <= value <= maximum.
    value = Range('minimum', 'maximum')

    #: An optional prefix to include in the displayed text.
    prefix = Unicode

    #: An optional suffix to include in the displayed text.
    suffix = Unicode

    #: Optional text to display when the spin box is at its minimum.
    #: This allows the developer to indicate to the user a special
    #: significance to the minimum value e.g. "Auto"
    special_value_text = Unicode

    #: The step size for the spin box. Defaults to 1.
    single_step = Range(low=1)

    #: Whether or not the spin box is read-only. If True, the user
    #: will not be able to edit the values in the spin box, but they
    #: will still be able to copy the text to the clipboard.
    read_only = Bool(False)

    #: Whether or not the spin box will wrap around at its extremes.
    #: Defaults to False.
    wrapping = Bool(False)

    #: How strongly a component hugs it's contents' width. SpinBoxes
    #: ignore the width hug by default, so they expand freely in width.
    hug_width = 'ignore'

    #--------------------------------------------------------------------------
    # Initialization
    #--------------------------------------------------------------------------
    def snapshot(self):
        """ Return the dict of creation attributes for the control.

        """
        snap = super(SpinBox, self).snapshot()
        attrs = {
            'maximum' : self.maximum,
            'minimum' : self.minimum,
            'value' : self.value,
            'prefix': self.prefix,
            'suffix': self.suffix,
            'special_value_text': self.special_value_text,
            'single_step' : self.single_step,
            'read_only': self.read_only,
            'wrapping' : self.wrapping,
        }
        snap.update(attrs)
        return snap

    def bind(self):
        """ A method called after initialization which allows the widget
        to bind any event handlers necessary.

        """
        super(SpinBox, self).bind()
        attrs = (
            'maximum', 'minimum', 'value', 'prefix', 'suffix',
            'special_value_text', 'single_step', 'read_only', 'wrapping',
        )
        self.publish_attributes(*attrs)

    #--------------------------------------------------------------------------
    # Message Handling
    #--------------------------------------------------------------------------
    def on_action_value_changed(self, content):
        """ Handle the 'value_changed' action from the client widget.

        """
        self.set_guarded(value=content['value'])


########NEW FILE########
__FILENAME__ = splitter
#------------------------------------------------------------------------------
# Copyright (c) 2011, Enthought, Inc.
# All rights reserved.
#------------------------------------------------------------------------------
from traits.api import Bool, Enum, Property, cached_property

from .constraints_widget import ConstraintsWidget
from .split_item import SplitItem


class Splitter(ConstraintsWidget):
    """ A widget which displays its children in separate resizable 
    compartements that are connected with a resizing bar.
     
    A Splitter can have an arbitrary number of Container children.

    """
    #: The orientation of the Splitter. 'horizontal' means the children 
    #: are laid out left to right, 'vertical' means top to bottom.
    orientation = Enum('horizontal', 'vertical')

    #: Whether the child widgets resize as a splitter is being dragged
    #: (True), or if a simple indicator is drawn until the drag handle
    #: is released (False). The default is True.
    live_drag = Bool(True)
    
    #: A read only property which returns the split items being managed
    #: by the splitter.
    split_items = Property(depends_on='children')

    #: How strongly a component hugs it's contents' width. A Splitter
    #: container ignores its width hug by default, so it expands freely
    #: in width.
    hug_width = 'ignore'

    #: How strongly a component hugs it's contents' height. A Splitter
    #: container ignores its height hug by default, so it expands freely
    #: in height.
    hug_height = 'ignore'

    #--------------------------------------------------------------------------
    # Initialization
    #--------------------------------------------------------------------------
    def snapshot(self):
        """ Return the dict of creation attributes for the control.

        """
        snap = super(Splitter, self).snapshot()
        snap['orientation'] = self.orientation
        snap['live_drag'] = self.live_drag
        return snap

    def bind(self):
        """ Bind the change handlers for the widget.

        """
        super(Splitter, self).bind()
        self.publish_attributes('orientation', 'live_drag')

    #--------------------------------------------------------------------------
    # Private API
    #--------------------------------------------------------------------------
    @cached_property
    def _get_split_items(self):
        """ The getter for the 'split_items' property.

        Returns
        -------
        result : tuple
            The tuple of SplitItem instances defined as children of
            this Splitter.

        """
        isinst = isinstance
        items = (child for child in self.children if isinst(child, SplitItem))
        return tuple(items)


########NEW FILE########
__FILENAME__ = split_item
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from traits.api import Any, Bool, Range, Property, cached_property

from .container import Container
from .widget import Widget


class SplitItem(Widget):
    """ A widget which can be used as an item in a Splitter.

    A SplitItem is a widget which can be used as a child of a Splitter
    widget. It can have at most a single child widget which is an
    instance of Container.

    """
    #: The stretch factor for this item. The stretch factor determines
    #: how much an item is resized relative to its neighbors when the
    #: splitter space is allocated.
    stretch = Range(low=0, value=1)

    #: Whether or not the item can be collapsed to zero width by the
    #: user. This holds regardless of the minimum size of the item.
    collapsible = Bool(True)

    #: A read only property which returns the split widget.
    split_widget = Property(depends_on='children')

    #: This is a deprecated attribute. It should no longer be used.
    preferred_size = Any

    #--------------------------------------------------------------------------
    # Initialization
    #--------------------------------------------------------------------------
    def snapshot(self):
        """ Return the dict of creation attributes for the control.

        """
        snap = super(SplitItem, self).snapshot()
        snap['stretch'] = self.stretch
        snap['collapsible'] = self.collapsible
        return snap

    def bind(self):
        """ Bind the change handlers for the widget.

        """
        super(SplitItem, self).bind()
        self.publish_attributes('stretch', 'collapsible')

    #--------------------------------------------------------------------------
    # Private API
    #--------------------------------------------------------------------------
    @cached_property
    def _get_split_widget(self):
        """ The getter for the 'split_widget' property.

        Returns
        -------
        result : Container or None
            The split widget for the SplitItem, or None if not provided.

        """
        widget = None
        for child in self.children:
            if isinstance(child, Container):
                widget = child
        return widget


########NEW FILE########
__FILENAME__ = stack
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from traits.api import Dict, Int, Property, cached_property

from .constraints_widget import ConstraintsWidget
from .stack_item import StackItem


class Stack(ConstraintsWidget):
    """ A component which displays its children as a stack of widgets,
    only one of which is visible at a time.

    """
    #: The index of the visible widget in the stack. The widget itself
    #: does not provide a means to changing this index. That control
    #: must be supplied externally. If the given index falls outside of
    #: the range of stack items, no widget will be visible.
    index = Int(0)

    #: The transition to use when change between stack items.
    #: XXX Document the supported transitions.
    transition = Dict

    #: A read only property which returns the stack's StackItems
    stack_items = Property(depends_on='children')

    #--------------------------------------------------------------------------
    # Initialization
    #--------------------------------------------------------------------------
    def snapshot(self):
        """ Returns the snapshot for the control.

        """
        snap = super(Stack, self).snapshot()
        snap['index'] = self.index
        snap['transition'] = self.transition
        return snap

    def bind(self):
        """ Bind the change handlers for the control.

        """
        super(Stack, self).bind()
        self.publish_attributes('index', 'transition')

    #--------------------------------------------------------------------------
    # Message Handling
    #--------------------------------------------------------------------------
    def on_action_index_changed(self, content):
        """ Handle the `index_changed` action from the client widget.

        """
        with self.loopback_guard('index'):
            self.index = content['index']

    #--------------------------------------------------------------------------
    # Private API
    #--------------------------------------------------------------------------
    @cached_property
    def _get_stack_items(self):
        """ The getter for the 'stack_items' property.

        Returns
        -------
        result : tuple
            The tuple of StackItem instances defined as children of
            this Stack.

        """
        isinst = isinstance
        items = (child for child in self.children if isinst(child, StackItem))
        return tuple(items)


########NEW FILE########
__FILENAME__ = stack_item
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from traits.api import Property, cached_property

from .container import Container
from .widget import Widget


class StackItem(Widget):
    """ A widget which can be used as an item in a Stack.

    A StackItem is a widget which can be used as a child of a Stack
    widget. It can have at most a single child widget which is an
    instance of Container.

    """
    #: A read only property which returns the items's stack widget.
    stack_widget = Property(depends_on='children')

    #--------------------------------------------------------------------------
    # Private API
    #--------------------------------------------------------------------------
    @cached_property
    def _get_stack_widget(self):
        """ The getter for the 'stack_widget' property.

        Returns
        -------
        result : Container or None
            The stack widget for the StackItem, or None if not provided.

        """
        widget = None
        for child in self.children:
            if isinstance(child, Container):
                widget = child
        return widget


########NEW FILE########
__FILENAME__ = text_editor
#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from traits.api import Unicode, Bool, Int

from .control import Control


class TextEditor(Control):
    """ A simple control for displaying read-only text.

    """
    #: The text for the text editor
    text = Unicode("")

    #: The editing mode for the editor
    mode = Unicode("ace/mode/text")

    #: The theme for the editor
    theme = Unicode("ace/theme/textmate")

    #: Auto pairs parentheses, braces, etc
    auto_pair = Bool(True)

    #: The editor's font size
    font_size = Int(12)

    #: Display the margin line
    margin_line = Bool(True)

    #: The column number for the margin line
    margin_line_column = Int(80)

    #--------------------------------------------------------------------------
    # Initialization
    #--------------------------------------------------------------------------
    def snapshot(self):
        """ Returns the dict of creation attributes for the control.

        """
        snap = super(TextEditor, self).snapshot()
        snap['text'] = self.text
        snap['mode'] = self.mode
        snap['theme'] = self.theme
        snap['auto_pair'] = self.auto_pair
        snap['font_size'] = self.font_size
        snap['margin_line'] = self.margin_line
        snap['margin_line_column'] = self.margin_line_column
        return snap

    def bind(self):
        """ A method called after initialization which allows the widget
        to bind any event handlers necessary.

        """
        super(TextEditor, self).bind()
        self.publish_attributes('text', 'mode', 'theme', 'auto_pair',
            'font_size', 'margin_line', 'margin_line_column')


########NEW FILE########
__FILENAME__ = time_selector
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from traits.api import Str

from .bounded_time import BoundedTime


class TimeSelector(BoundedTime):
    """ A time widget that displays a Python datetime.time object using
    an appropriate toolkit specific control.

    """
    #: A python time format string to format the time. If None is
    #: supplied (or is invalid) the system locale setting is used.
    #: This may not be supported by all backends.
    time_format = Str

    #: How strongly to hugs the content width. A TimeSelector ignores
    #: the width hug by default, so it expands freely in width.
    hug_width = 'ignore'

    #--------------------------------------------------------------------------
    # Initialization
    #--------------------------------------------------------------------------
    def snapshot(self):
        """ Return a dictionary which contains all the state necessary to
        initialize a client widget.

        """
        snap = super(TimeSelector, self).snapshot()
        snap['time_format'] = self.time_format
        return snap

    def bind(self):
        """ A method called after initialization which allows the widget
        to bind any event handlers necessary.

        """
        super(TimeSelector, self).bind()
        self.publish_attributes('time_format')


########NEW FILE########
__FILENAME__ = tool_bar
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from traits.api import Bool, Enum, List, Property, Either, cached_property

from .action import Action
from .action_group import ActionGroup
from .constraints_widget import ConstraintsWidget, PolicyEnum


class ToolBar(ConstraintsWidget):
    """ A widget which displays a row of tool buttons.

    A ToolBar is typically used as a child of a MainWindow where it can
    be dragged and docked in various locations in the same fashion as a
    DockPane. However, a ToolBar can also be used as the child of a
    Container and layed out with constraints, though in this case it will
    lose its ability to be docked.

    """
    #: Whether or not the tool bar is movable by the user. This value
    #: only has meaning if the tool bar is the child of a MainWindow.
    movable = Bool(True)

    #: Whether or not the tool bar can be floated as a separate window.
    #: This value only has meaning if the tool bar is the child of a
    #: MainWindow.
    floatable = Bool(True)

    #: A boolean indicating whether or not the tool bar is floating.
    #: This value only has meaning if the tool bar is the child of a
    #: MainWindow.
    floating = Bool(False)

    #: The dock area in the MainWindow where the tool bar is docked.
    #: This value only has meaning if the tool bar is the child of a
    #: MainWindow.
    dock_area = Enum('top', ('left', 'right', 'top', 'bottom'))

    #: The areas in the MainWindow where the tool bar can be docked
    #: by the user. This value only has meaning if the tool bar is the
    #: child of a MainWindow.
    allowed_dock_areas = List(
        Enum('left', 'right', 'top', 'bottom', 'all'), value=['all'],
    )

    #: The orientation of the toolbar. This only has meaning when the
    #: toolbar is not a child of a MainWindow and is used as part of
    #: a constraints based layout.
    orientation = Enum('horizontal', 'vertical')

    #: A read only property which returns the tool bar's items:
    #: ActionGroup | Action
    items = Property(depends_on='children')

    #: Hug width is redefined as a property to be computed based on the
    #: orientation of the tool bar unless overridden by the user.
    hug_width = Property(PolicyEnum, depends_on=['_hug_width', 'orientation'])

    #: Hug height is redefined as a property to be computed based on the
    #: orientation of the slider unless overridden by the user.
    hug_height = Property(PolicyEnum, depends_on=['_hug_height', 'orientation'])

    #: An internal override trait for hug_width
    _hug_width = Either(None, PolicyEnum, default=None)

    #: An internal override trait for hug_height
    _hug_height = Either(None, PolicyEnum, default=None)

    #--------------------------------------------------------------------------
    # Initialization
    #--------------------------------------------------------------------------
    def snapshot(self):
        """ Returns the snapshot dict for the DockPane.

        """
        snap = super(ToolBar, self).snapshot()
        snap['movable'] = self.movable
        snap['floatable'] = self.floatable
        snap['floating'] = self.floating
        snap['dock_area'] = self.dock_area
        snap['allowed_dock_areas'] = self.allowed_dock_areas
        snap['orientation'] = self.orientation
        return snap

    def bind(self):
        """ Bind the change handlers for the ToolBar.

        """
        super(ToolBar, self).bind()
        attrs = (
            'movable', 'floatable', 'floating', 'dock_area',
            'allowed_dock_areas', 'orientation',
        )
        self.publish_attributes(*attrs)

    #--------------------------------------------------------------------------
    # Private API
    #--------------------------------------------------------------------------
    @cached_property
    def _get_items(self):
        """ The getter for the 'items' property.

        Returns
        -------
        result : tuple
            The tuple of items for the ToolBar.

        """
        isinst = isinstance
        types = (Action, ActionGroup)
        items = (child for child in self.children if isinst(child, types))
        return tuple(items)

    #--------------------------------------------------------------------------
    # Property Methods
    #--------------------------------------------------------------------------
    def _get_hug_width(self):
        """ The property getter for 'hug_width'.

        Returns a computed hug value unless overridden by the user.

        """
        res = self._hug_width
        if res is None:
            if self.orientation == 'horizontal':
                res = 'ignore'
            else:
                res = 'strong'
        return res

    def _get_hug_height(self):
        """ The proper getter for 'hug_height'.

        Returns a computed hug value unless overridden by the user.

        """
        res = self._hug_height
        if res is None:
            if self.orientation == 'vertical':
                res = 'ignore'
            else:
                res = 'strong'
        return res

    def _set_hug_width(self, value):
        """ The property setter for 'hug_width'.

        Overrides the computed value.

        """
        self._hug_width = value

    def _set_hug_height(self, value):
        """ The property setter for 'hug_height'.

        Overrides the computed value.

        """
        self._hug_height = value

    #--------------------------------------------------------------------------
    # Message Handling
    #--------------------------------------------------------------------------
    def on_action_floated(self, content):
        """ Handle the 'floated' action from the client widget.

        """
        self.set_guarded(floating=True)

    def on_action_docked(self, content):
        """ Handle the 'docked' action from the client widget.

        """
        self.set_guarded(floating=False)
        self.set_guarded(dock_area=content['dock_area'])


########NEW FILE########
__FILENAME__ = traits_item
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#
# Special thanks to Steven Silvester for contributing this module!
#------------------------------------------------------------------------------
# NOTE: There shall be no imports from traitsui in this module. Doing so
# will create an import dependency on traitsui for the rest of Enaml!
from traits.api import HasTraits, Instance

from .control import Control


class TraitsItem(Control):
    """ A control which can be used to embded a traits ui view.

    """
    #: The traits model being displayed. If no other view is given, the
    #: view will be retrieved by calling `model.edit_traits()`.
    model = Instance(HasTraits)

    #: An optional traits ui View definition to use in lieu of the
    #: default view generated by the model.
    view = Instance('traitsui.api.View')

    #: An optional traits ui Handler definition to use in lieu of the
    #: default handler generated by the model.
    handler = Instance('traitsui.api.Handler')

    #: TraitsItem widgets expand freely in height and width by default.
    hug_width = 'ignore'
    hug_height = 'ignore'

    #--------------------------------------------------------------------------
    # Initialization
    #--------------------------------------------------------------------------
    def snapshot(self):
        """ Get the snapshot dictionary for the TraitsItem widget.

        """
        snap = super(TraitsItem, self).snapshot()
        snap['model'] = self.model
        snap['view'] = self.view
        snap['handler'] = self.handler
        return snap

    def bind(self):
        """ Bind the change handlers for the control.

        """
        super(TraitsItem, self).bind()
        self.publish_attributes('model', 'view', 'handler')


########NEW FILE########
__FILENAME__ = web_view
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from traits.api import Unicode

from .control import Control


class WebView(Control):
    """ A widget which displays a web page.

    Unlike the simpler `Html` widget, this widget supports the features
    of a full web browser.

    """
    #: The URL to load in the web view. This can be a path to a remote
    #: resource or a path to a file on the local filesystem. This value
    #: is mutually exclusive of `html`.
    url = Unicode

    #: The html to load into the web view. This value is mutually
    #: exclusive of `url`.
    html = Unicode

    #: A web view expands freely in height and width by default.
    hug_width = 'ignore'
    hug_height = 'ignore'

    #--------------------------------------------------------------------------
    # Initialization
    #--------------------------------------------------------------------------
    def snapshot(self):
        """ Create the snapshot for the widget.

        """
        snap = super(WebView, self).snapshot()
        snap['url'] = self.url
        snap['html'] = self.html
        return snap

    def bind(self):
        """ Bind the change handlers for the widget.

        """
        super(WebView, self).bind()
        self.publish_attributes('url', 'html')


########NEW FILE########
__FILENAME__ = widget
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from traits.api import Bool, Str, Tuple, Range, Enum, Unicode

from enaml.core.messenger import Messenger


#: A predefined trait which defines a size tuple. A size value of
#: (-1, -1) represents a default size.
SizeTuple = Tuple(Range(low=-1, value=-1), Range(low=-1, value=-1))


class Widget(Messenger):
    """ The base class of all visible widgets in Enaml.

    """
    #: Whether or not the widget is enabled.
    enabled = Bool(True)

    #: Whether or not the widget is visible.
    visible = Bool(True)

    #: A flag indicating whether or not to show the focus rectangle for
    #: the given widget. This is not necessarily support by all widgets
    #: on all clients. A value of None indicates to use the default as
    #: supplied by the client.
    show_focus_rect = Enum(None, True, False)

    #: The background color of the widget. Supports CSS3 color strings.
    bgcolor = Str

    #: The foreground color of the widget. Supports CSS3 color strings.
    fgcolor = Str

    #: The font used for the widget. Supports CSS font formats.
    font = Str

    #: The minimum size for the widget. The default means that the
    #: client should determine an intelligent minimum size.
    minimum_size = SizeTuple

    #: The maximum size for the widget. The default means that the
    #: client should determine and inteliigent maximum size.
    maximum_size = SizeTuple

    #: The tool tip to show when the user hovers over the widget.
    tool_tip = Unicode

    #: The status tip to show when the user hovers over the widget.
    status_tip = Unicode

    #--------------------------------------------------------------------------
    # Initialization
    #--------------------------------------------------------------------------
    def snapshot(self):
        snap = super(Widget, self).snapshot()
        snap['enabled'] = self.enabled
        snap['visible'] = self.visible
        snap['bgcolor'] = self.bgcolor
        snap['fgcolor'] = self.fgcolor
        snap['font'] = self.font
        snap['minimum_size'] = self.minimum_size
        snap['maximum_size'] = self.maximum_size
        snap['show_focus_rect'] = self.show_focus_rect
        snap['tool_tip'] = self.tool_tip
        snap['status_tip'] = self.status_tip
        return snap

    def bind(self):
        """ Bind the change handlers for a widget component.

        """
        super(Widget, self).bind()
        attrs = (
            'enabled', 'visible', 'bgcolor', 'fgcolor', 'font',
            'minimum_size', 'maximum_size', 'show_focus_rect',
            'tool_tip', 'status_tip',
        )
        self.publish_attributes(*attrs)


########NEW FILE########
__FILENAME__ = window
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from traits.api import Unicode, Enum, Property, Str, Bool, cached_property

from enaml.core.trait_types import EnamlEvent

from .container import Container
from .widget import Widget, SizeTuple


class Window(Widget):
    """ A top-level Window component.

    A Window component is represents of a top-level visible component
    with a frame decoration. It may have at most one child widget which
    is dubbed the 'central widget'. The central widget is an instance
    of Container and is expanded to fit the size of the window.

    A Window does not support features like MenuBars or DockPanes, for
    such functionality, use a MainWindow widget.

    """
    #: The titlebar text.
    title = Unicode

    #: The initial size of the window. A value of (-1, -1) indicates
    #: to let the client choose the initial size
    initial_size = SizeTuple

    #: An enum which indicates the modality of the window. The default
    #: value is 'non_modal'.
    modality = Enum('non_modal', 'application_modal', 'window_modal')

    #: Whether or not the window remains on top of all others.
    always_on_top = Bool(False)

    #: If this value is set to True, the window will be destroyed on
    #: the completion of the `closed` event.
    destroy_on_close = Bool(True)

    #: An event fired when the window is closed.
    closed = EnamlEvent

    #: Returns the central widget in use for the Window
    central_widget = Property(depends_on='children')

    #: The source url for the titlebar icon.
    icon_source = Str

    #--------------------------------------------------------------------------
    # Initialization
    #--------------------------------------------------------------------------
    def snapshot(self):
        """ Return the snapshot for a Window.

        """
        snap = super(Window, self).snapshot()
        snap['title'] = self.title
        snap['initial_size'] = self.initial_size
        snap['modality'] = self.modality
        snap['always_on_top'] = self.always_on_top
        snap['icon_source'] = self.icon_source
        return snap

    def bind(self):
        """ A method called after initialization which allows the widget
        to bind any event handlers necessary.

        """
        super(Window, self).bind()
        attrs = ('title', 'modality', 'always_on_top', 'icon_source')
        self.publish_attributes(*attrs)

    #--------------------------------------------------------------------------
    # Private API
    #--------------------------------------------------------------------------
    @cached_property
    def _get_central_widget(self):
        """ The getter for the 'central_widget' property.

        Returns
        -------
        result : Container or None
            The central widget for the Window, or None if not provieded.

        """
        widget = None
        for child in self.children:
            if isinstance(child, Container):
                widget = child
        return widget

    #--------------------------------------------------------------------------
    # Message Handling
    #--------------------------------------------------------------------------
    def on_action_closed(self, content):
        """ Handle the 'closed' action from the client widget.

        """
        self.set_guarded(visible=False)
        self.closed()
        if self.destroy_on_close:
            self.destroy()

    #--------------------------------------------------------------------------
    # Public API
    #--------------------------------------------------------------------------
    def close(self):
        """ Send the 'close' action to the client widget.

        """
        self.send_action('close', {})

    def maximize(self):
        """ Send the 'maximize' action to the client widget.

        """
        self.send_action('maximize', {})

    def minimize(self):
        """ Send the 'minimize' action to the client widget.

        """
        self.send_action('minimize', {})

    def restore(self):
        """ Send the 'restore' action to the client widget.

        """
        self.send_action('restore', {})

    def send_to_front(self):
        """ Send the 'send_to_front' action to the client widget.

        This moves the window to the front of all the toplevel windows.

        """
        self.send_action('send_to_front', {})

    def send_to_back(self):
        """ Send the 'send_to_back' action to the client widget.

        This moves the window to the back of all the toplevel windows.

        """
        self.send_action('send_to_back', {})


########NEW FILE########
__FILENAME__ = wx_abstract_button
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from .wx_control import WxControl


class WxAbstractButton(WxControl):
    """ A Wx implementation of the Enaml AbstractButton class.

    This class can serve as a base class for widgets that implement
    button behavior such as CheckBox, RadioButton and PushButtons.
    It is not meant to be used directly.

    """
    #--------------------------------------------------------------------------
    # Setup Methods
    #--------------------------------------------------------------------------
    def create_widget(self, parent, tree):
        """ This method must be implemented by subclasses to create
        the proper button widget.

        """
        raise NotImplementedError

    def create(self, tree):
        """ Create and initialize the abstract button widget.

        Subclasses should reimplement this method and bind appropriate
        event handlers to the 'on_clicked' and 'on_toggled' event
        handlers.

        """
        super(WxAbstractButton, self).create(tree)
        self.set_checkable(tree['checkable'])
        self.set_checked(tree['checked'])
        self.set_text(tree['text'])

    #--------------------------------------------------------------------------
    # Message Handlers
    #--------------------------------------------------------------------------
    def on_action_set_checked(self, content):
        """ Handle the 'set_checked' action from the Enaml widget.

        """
        self.set_checked(content['checked'])

    def on_action_set_text(self, content):
        """ Handle the 'set_text' action from the Enaml widget.

        """
        self.set_text(content['text'])
        # Trigger a relayout since the size hint likely changed

    def on_action_set_icon_size(self, content):
        """ Handle the 'set_icon_size' action from the Enaml widget.

        """
        self.set_icon_size(content['icon_size'])

    #--------------------------------------------------------------------------
    # Event Handlers
    #--------------------------------------------------------------------------
    def on_clicked(self, event):
        """ The event handler for the clicked event.

        Parameters
        ----------
        event : wxEvent
            The wx event object. This is ignored by the handler.

        """
        content = {'checked': self.get_checked()}
        self.send_action('clicked', content)

    def on_toggled(self, event):
        """ The event handler for the toggled event.

        Parameters
        ----------
        event : wxEvent
            The wx event object. This is ignored by the handler.

        """
        content = {'checked': self.get_checked()}
        self.send_action('toggled', content)

    #--------------------------------------------------------------------------
    # Abstract API
    #--------------------------------------------------------------------------
    def set_checkable(self, checkable):
        """ Sets whether or not the widget is checkable.

        """
        raise NotImplementedError

    def get_checked(self):
        """ Returns the checked state of the widget.

        """
        raise NotImplementedError

    def set_checked(self, checked):
        """ Sets the widget's checked state with the provided value.

        """
        raise NotImplementedError

    def set_text(self, text):
        """ Sets the widget's text with the provided value.

        """
        self.widget().SetLabel(text)

    def set_icon(self, icon):
        """ Sets the widget's icon to the provided image

        """
        pass

    def set_icon_size(self, icon_size):
        """ Sets the widget's icon size to the provided tuple

        """
        pass


########NEW FILE########
__FILENAME__ = wx_action
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from weakref import WeakValueDictionary

import wx
import wx.lib.newevent

from .wx_object import WxObject


#: An event emitted when a wxAction has been triggered by the user. The
#: payload of the event will have an 'IsChecked' attribute.
wxActionTriggeredEvent, EVT_ACTION_TRIGGERED = wx.lib.newevent.NewEvent()

#: An event emitted by a wxAction when it has been toggled by the user.
#: The payload of the event will have an 'IsChecked' attribute.
wxActionToggledEvent, EVT_ACTION_TOGGLED = wx.lib.newevent.NewEvent()

#: An event emitted by a wxAction when its state has been changed.
wxActionChangedEvent, EVT_ACTION_CHANGED = wx.lib.newevent.NewEvent()


class wxAction(wx.EvtHandler):
    """ A wx.EvtHandler which behaves similar to a QAction.

    """
    #: Class storage which maps action id -> action instance.
    _action_map = WeakValueDictionary()

    @classmethod
    def FindById(cls, action_id):
        """ Find a wxAction instance using the given action id.

        Parameters
        ----------
        action_id : int
            The id for the action.

        Returns
        -------
        result : wxAction or None
            The wxAction instance for the given id, or None if not
            action exists for that id.

        """
        return cls._action_map.get(action_id)

    def __init__(self, parent=None):
        """ Initialize a wxAction.

        Parameters
        ----------
        parent : object or None
            The parent for this wxAction. The parent is not directly
            used by the action, but is provided as a convenience for
            other parts of the framework.

        """
        super(wxAction, self).__init__()
        self._parent = parent
        self._text = u''
        self._tool_tip = u''
        self._status_tip = u''
        self._checkable = False
        self._checked = False
        self._enabled = True
        self._visible = True
        self._group_enabled = True
        self._group_visible = True
        self._separator = False
        self._batch = False
        self._id = wx.NewId()
        self._action_map[self._id] = self

    #--------------------------------------------------------------------------
    # Private API
    #--------------------------------------------------------------------------
    def _EmitChanged(self):
        """ Emits the EVT_ACTION_CHANGED event if not in batch mode.

        """
        if not self._batch:
            event = wxActionChangedEvent()
            event.SetEventObject(self)
            wx.PostEvent(self, event)

    def _SetGroupEnabled(self, enabled):
        """ A private method called by an owner action group.

        Parameters
        ----------
        enabled : bool
            Whether or not the owner group is enabled.

        """
        if self._group_enabled != enabled:
            old = self.IsEnabled()
            self._group_enabled = enabled
            new = self.IsEnabled()
            if old != new:
                self._EmitChanged()

    def _SetGroupVisible(self, visible):
        """ A private method called by an owner action group.

        Parameters
        ----------
        visible : bool
            Whether or not the owner group is visble.

        """
        if self._group_visible != visible:
            old = self.IsVisible()
            self._group_visible = visible
            new = self.IsVisible()
            if old != new:
                self._EmitChanged()

    #--------------------------------------------------------------------------
    # Public API
    #--------------------------------------------------------------------------
    def GetParent(self):
        """ Get the parent of the action.

        Returns
        -------
        result : object or None
            The parent of this action or None.

        """
        return self._parent

    def SetParent(self, parent):
        """ Set the parent of the action.

        Parameters
        ----------
        parent : object or None
            The object to use as the parent of this action.

        """
        self._parent = parent

    def Trigger(self):
        """ A method called by the action owner when the user triggers
        the action.

        This handler will emit the custom EVT_ACTION_TRIGGERED event.
        User code should not typically call this method directly.

        """
        # This event is dispatched immediately in order to preserve
        # the order of event firing for trigger/toggle.
        event = wxActionTriggeredEvent(IsChecked=self._checked)
        event.SetEventObject(self)
        wx.PostEvent(self, event)

    def BeginBatch(self):
        """ Enter batch update mode for the action.

        """
        self._batch = True

    def EndBatch(self, emit=True):
        """ Exit batch update mode for the action.

        Parameters
        ----------
        emit : bool, optional
            If True, emit a changed event after leaving batch mode. The
            default is True.

        """
        self._batch = False
        if emit:
            self._EmitChanged()

    def GetId(self):
        """ Get the unique wx id for this action.

        Returns
        -------
        result : int
            The wx id number for this action.

        """
        return self._id

    def GetText(self):
        """ Get the text for the action.

        Returns
        -------
        result : unicode
            The unicode text for the action.

        """
        return self._text

    def SetText(self, text):
        """ Set the text for the action.

        Parameters
        ----------
        text : unicode
            The unicode text for the action.

        """
        if self._text != text:
            self._text = text
            self._EmitChanged()

    def GetToolTip(self):
        """ Get the tool tip for the action.

        Returns
        -------
        result : unicode
            The unicode tool tip for the action.

        """
        return self._tool_tip

    def SetToolTip(self, tool_tip):
        """ Set the tool tip for the action.

        Parameters
        ----------
        tool_tip : unicode
            The unicode tool tip for the action.

        """
        if self._tool_tip != tool_tip:
            self._tool_tip = tool_tip
            self._EmitChanged()

    def GetStatusTip(self):
        """ Get the status tip for the action.

        Returns
        -------
        result : unicode
            The unicode status tip for the action.

        """
        return self._status_tip

    def SetStatusTip(self, status_tip):
        """ Set the status tip for the action.

        Parameters
        ----------
        status_tip : unicode
            The unicode status tip for the action.

        """
        if self._status_tip != status_tip:
            self._status_tip = status_tip
            self._EmitChanged()

    def IsCheckable(self):
        """ Get whether or not the action is checkable.

        Returns
        -------
        result : bool
            Whether or not the action is checkable.

        """
        return self._checkable

    def SetCheckable(self, checkable):
        """ Set whether or not the action is checkable.

        Parameters
        ----------
        checkable : bool
            Whether or not the action is checkable.

        """
        if self._checkable != checkable:
            self._checkable = checkable
            self._EmitChanged()

    def IsChecked(self):
        """ Get whether or not the action is checked.

        Returns
        -------
        result : bool
            Whether or not the action is checked.

        """
        return self._checked

    def SetChecked(self, checked):
        """ Set whether or not the action is checked.

        Parameters
        ----------
        checked : bool
            Whether or not the action is checked.

        """
        if self._checked != checked:
            self._checked = checked
            self._EmitChanged()
            event = wxActionToggledEvent(IsChecked=checked)
            event.SetEventObject(self)
            wx.PostEvent(self, event)

    def IsEnabled(self):
        """ Get whether or not the action is enabled.

        Returns
        -------
        result : bool
            Whether or not the action is enabled.

        """
        if self._group_enabled:
            return self._enabled
        return False

    def SetEnabled(self, enabled):
        """ Set whether or not the action is enabled.

        Parameters
        ----------
        enabled : bool
            Whether or not the action is enabled.

        """
        if self._enabled != enabled:
            self._enabled = enabled
            if self._group_enabled:
                self._EmitChanged()

    def IsVisible(self):
        """ Get whether or not the action is visible.

        Returns
        -------
        result : bool
            Whether or not the action is visible.

        """
        if self._group_visible:
            return self._visible
        return False

    def SetVisible(self, visible):
        """ Set whether or not the action is visible.

        Parameters
        ----------
        visible : bool
            Whether or not the action is visible.

        """
        if self._visible != visible:
            self._visible = visible
            if self._group_visible:
                self._EmitChanged()

    def IsSeparator(self):
        """ Get whether or not the action is a separator.

        Returns
        -------
        result : bool
            Whether or not the action is a separator.

        """
        return self._separator

    def SetSeparator(self, separator):
        """ Set whether or not the action is a separator.

        Parameters
        ----------
        separator : bool
            Whether or not the action is a separator.

        """
        if self._separator != separator:
            self._separator = separator
            self._EmitChanged()


class WxAction(WxObject):
    """ A Wx implementation of an Enaml Action.

    """
    #--------------------------------------------------------------------------
    # Setup Methods
    #--------------------------------------------------------------------------
    def create_widget(self, parent, tree):
        """ Create the underlying wxAction object.

        """
        return wxAction(parent)

    def create(self, tree):
        """ Create and initialize the underlying control.

        """
        super(WxAction, self).create(tree)
        widget = self.widget()
        widget.BeginBatch()
        self.set_text(tree['text'])
        self.set_tool_tip(tree['tool_tip'])
        self.set_status_tip(tree['status_tip'])
        self.set_checkable(tree['checkable'])
        self.set_checked(tree['checked'])
        self.set_enabled(tree['enabled'])
        self.set_visible(tree['visible'])
        self.set_separator(tree['separator'])
        widget.EndBatch(emit=False)
        widget.Bind(EVT_ACTION_TRIGGERED, self.on_triggered)
        widget.Bind(EVT_ACTION_TOGGLED, self.on_toggled)

    #--------------------------------------------------------------------------
    # Event Handlers
    #--------------------------------------------------------------------------
    def on_triggered(self, event):
        """ The event handler for the EVT_ACTION_TRIGGERED event.

        """
        content = {'checked': event.IsChecked}
        self.send_action('triggered', content)

    def on_toggled(self, event):
        """ The event handler for the EVT_ACTION_TOGGLED event.

        """
        content = {'checked': event.IsChecked}
        self.send_action('toggled', content)

    #--------------------------------------------------------------------------
    # Message Handling
    #--------------------------------------------------------------------------
    def on_action_set_text(self, content):
        """ Handle the 'set_text' action from the Enaml widget.

        """
        self.set_text(content['text'])

    def on_action_set_tool_tip(self, content):
        """ Handle the 'set_tool_tip' action from the Enaml widget.

        """
        self.set_tool_tip(content['tool_tip'])

    def on_action_set_status_tip(self, content):
        """ Handle the 'set_status_tip' action from the Enaml widget.

        """
        self.set_status_tip(content['status_tip'])

    def on_action_set_checkable(self, content):
        """ Handle the 'set_checkable' action from the Enaml widget.

        """
        self.set_checkable(content['checkable'])

    def on_action_set_checked(self, content):
        """ Handle the 'set_checked' action from the Enaml widget.

        """
        self.set_checked(content['checked'])

    def on_action_set_enabled(self, content):
        """ Handle the 'set_enabled' action from the Enaml widget.

        """
        self.set_enabled(content['enabled'])

    def on_action_set_visible(self, content):
        """ Handle the 'set_visible' action from the Enaml widget.

        """
        self.set_visible(content['visible'])

    def on_action_set_separator(self, content):
        """ Handle the 'set_separator' action from the Enaml widget.

        """
        self.set_separator(content['separator'])

    #--------------------------------------------------------------------------
    # Widget Update Methods
    #--------------------------------------------------------------------------
    def set_text(self, text):
        """ Set the text on the underlying control.

        """
        self.widget().SetText(text)

    def set_tool_tip(self, tool_tip):
        """ Set the tool tip on the underlying control.

        """
        self.widget().SetToolTip(tool_tip)

    def set_status_tip(self, status_tip):
        """ Set the status tip on the underyling control.

        """
        self.widget().SetStatusTip(status_tip)

    def set_checkable(self, checkable):
        """ Set the checkable state on the underlying control.

        """
        self.widget().SetCheckable(checkable)

    def set_checked(self, checked):
        """ Set the checked state on the underlying control.

        """
        self.widget().SetChecked(checked)

    def set_enabled(self, enabled):
        """ Set the enabled state on the underlying control.

        """
        self.widget().SetEnabled(enabled)

    def set_visible(self, visible):
        """ Set the visible state on the underlying control.

        """
        self.widget().SetVisible(visible)

    def set_separator(self, separator):
        """ Set the separator state on the underlying control.

        """
        self.widget().SetSeparator(separator)


########NEW FILE########
__FILENAME__ = wx_action_group
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
import wx

from .wx_action import WxAction, EVT_ACTION_CHANGED
from .wx_object import WxObject


class wxActionGroup(wx.EvtHandler):
    """ A simple object which keeps track of a group of actions.

    """
    def __init__(self, parent=None):
        """ Initialize a wxActionGroup.

        Parameters
        ----------
        parent : object or None
            The parent for this wxActionGroup. The parent is not used
            directly by the action, but is provided as a convenience
            for other parts of the framework.

        """
        super(wxActionGroup, self).__init__()
        self._parent = parent
        self._exclusive = True
        self._enabled = True
        self._visible = True
        self._actions = []
        self._checked_action = None

    #--------------------------------------------------------------------------
    # Private API
    #--------------------------------------------------------------------------
    def OnActionChanged(self, event):
        """ The event handler for the EVT_ACTION_CHANGED event.

        This handler will update the current checked action and toggle
        any other old action if the group is exclusive.

        """
        event.Skip()
        action = event.GetEventObject()
        if action.IsChecked():
            old_action = self._checked_action
            self._checked_action = action
            if self.IsExclusive():
                if action is not old_action:
                    if old_action is not None:
                        old_action.SetChecked(False)

    #--------------------------------------------------------------------------
    # Public API
    #--------------------------------------------------------------------------
    def GetParent(self):
        """ Get the parent of the action group.

        Returns
        -------
        result : object or None
            The parent of this action group or None.

        """
        return self._parent

    def SetParent(self, parent):
        """ Set the parent of the action group.

        Parameters
        ----------
        parent : object or None
            The object to use as the parent of this action group.

        """
        self._parent = parent

    def AddAction(self, action):
        """ Add an action to the action group.

        If the action already exists in the group, this is a no-op.

        Parameters
        ----------
        action : wxAction
            The wxAction to add to the group.

        """
        actions = self._actions
        if action not in actions:
            actions.append(action)
            action.Bind(EVT_ACTION_CHANGED, self.OnActionChanged)
            parent = action.GetParent()
            if isinstance(parent, wxActionGroup) and parent is not self:
                parent.RemoveAction(action)
                action.SetParent(self)

        if action.IsChecked():
            old_action = self._checked_action
            self._checked_action = action
            if self.IsExclusive():
                if action is not old_action:
                    if old_action is not None:
                        old_action.SetChecked(False)

        action._SetGroupEnabled(self._enabled)
        action._SetGroupVisible(self._visible)

    def RemoveAction(self, action):
        """ Remove the action from the action group.

        If the action does not exist in the group, this is a no-op.

        Parameters
        ----------
        action : wxAction
            The wxAction to remove from the group.

        """
        actions = self._actions
        if action in actions:
            actions.remove(action)
            action.Unbind(EVT_ACTION_CHANGED, handler=self.OnActionChanged)
            if action is self._checked_action:
                self._checked_action = None

    def GetActions(self):
        """ Get the list of actions for this group.

        Returns
        -------
        result : list
            The list of wxAction instances for this action group. This
            list should not be modified in-place.

        """
        return self._actions

    def GetCheckedAction(self):
        """ Get the currently checked action in the group.

        Returns
        -------
        result : wxAction or None
            The currently checked action in the group, or None if
            no action is checked.

        """
        return self._checked_action

    def IsExclusive(self):
        """ Get whether or not the action group is exclusive.

        Returns
        -------
        result : bool
            Whether or not the action group is exclusive.

        """
        return self._exclusive

    def SetExclusive(self, exclusive):
        """ Set whether or not the action group is exclusive.

        Parameters
        ----------
        exclusive : bool
            Whether or not the action is exclusive.

        """
        if self._exclusive != exclusive:
            self._exclusive = exclusive
            if exclusive:
                curr = self._checked_action
                for action in self._actions:
                    if action is not curr:
                        action.SetChecked(False)

    def IsEnabled(self):
        """ Get whether or not the action group is enabled.

        Returns
        -------
        result : bool
            Whether or not the action group is enabled.

        """
        return self._enabled

    def SetEnabled(self, enabled):
        """ Set whether or not the action group is enabled.

        Parameters
        ----------
        enabled : bool
            Whether or not the action group is enabled.

        """
        if self._enabled != enabled:
            self._enabled = enabled
            for action in self._actions:
                action._SetGroupEnabled(enabled)

    def IsVisible(self):
        """ Get whether or not the action group is visible.

        Returns
        -------
        result : bool
            Whether or not the action group is visible.

        """
        return self._visible

    def SetVisible(self, visible):
        """ Set whether or not the action group is visible.

        Parameters
        ----------
        enabled : bool
            Whether or not the action is visible.

        """
        if self._visible != visible:
            self._visible = visible
            for action in self._actions:
                action._SetGroupVisible(visible)


class WxActionGroup(WxObject):
    """ A Wx implementation of an Enaml ActionGroup.

    """
    #--------------------------------------------------------------------------
    # Setup Methods
    #--------------------------------------------------------------------------
    def create_widget(self, parent, tree):
        """ Create the underlying action group widget.

        """
        return wxActionGroup(parent)

    def create(self, tree):
        """ Create and initialize the underlying control.

        """
        super(WxActionGroup, self).create(tree)
        self.set_exclusive(tree['exclusive'])
        self.set_enabled(tree['enabled'])
        self.set_visible(tree['visible'])

    def init_layout(self):
        """ Initialize the layout for the underlying control.

        """
        super(WxActionGroup, self).init_layout()
        widget = self.widget()
        for child in self.children():
            if isinstance(child, WxAction):
                widget.AddAction(child.widget())

    #--------------------------------------------------------------------------
    # Child Events
    #--------------------------------------------------------------------------
    def child_removed(self, child):
        """ Handle the child removed event for a WxActionGroup.

        """
        if isinstance(child, WxAction):
            action = child.widget()
            self.widget().RemoveAction(action)
            parent = self.parent()
            if parent is not None:
                parent.widget().RemoveAction(action)

    def child_added(self, child):
        """ Handle the child added event for a WxActionGroup.

        """
        # The easiest way to handle the insert is to tell the parent to
        # insert all the current actions. It will work out the proper
        # ordering automatically.
        if isinstance(child, WxAction):
            self.widget().AddAction(child.widget())
            parent = self.parent()
            if parent is not None:
                before = parent.find_next_action(self)
                parent.widget().InsertActions(before, self.actions())

    #--------------------------------------------------------------------------
    # Utility Methods
    #--------------------------------------------------------------------------
    def actions(self):
        """ Get the WxAction children for this action group.

        Returns
        -------
        result : list
            The list of wxAction instances which are children of this
            action group. Unlike the list returned by the `GetActions`
            method of the wxActionGroup, the children in this list will
            have the correct order.

        """
        isinst = isinstance
        return [c.widget() for c in self.children() if isinst(c, WxAction)]

    #--------------------------------------------------------------------------
    # Message Handling
    #--------------------------------------------------------------------------
    def on_action_set_exclusive(self, content):
        """ Handle the 'set_exclusive' action from the Enaml widget.

        """
        self.set_exclusive(content['exclusive'])

    def on_action_set_enabled(self, content):
        """ Handle the 'set_enabled' action from the Enaml widget.

        """
        self.set_enabled(content['enabled'])

    def on_action_set_visible(self, content):
        """ Handle the 'set_visible' action from the Enaml widget.

        """
        self.set_visible(content['visible'])

    #--------------------------------------------------------------------------
    # Widget Update Methods
    #--------------------------------------------------------------------------
    def set_exclusive(self, exclusive):
        """ Set the exclusive state of the underlying control.

        """
        self.widget().SetExclusive(exclusive)

    def set_enabled(self, enabled):
        """ Set the enabled state of the underlying control.

        """
        self.widget().SetEnabled(enabled)

    def set_visible(self, visible):
        """ Set the visible state of the underlying control.

        """
        self.widget().SetVisible(visible)


########NEW FILE########
__FILENAME__ = wx_action_socket
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
import types

import wx
import wx.lib.newevent

from enaml.socket_interface import ActionSocketInterface
from enaml.weakmethod import WeakMethod


#: A custom event type for posting messages on the socket.
wxActionSocketEvent, EVT_ACTION_SOCKET = wx.lib.newevent.NewEvent()


class wxActionSocket(wx.EvtHandler):
    """ A concrete implementation of ActionSocketInterface.

    This is a wxEvtHandler subclass which converts a `send` on the
    socket into an `EVT_ACTION_SOCKET` event which can be bound to
    another part of the application. Incoming socket events can be
    delivered to the `receive` method of the socket.

    """
    def __init__(self):
        """ Initialize a wxActionSocket.

        """
        super(wxActionSocket, self).__init__()
        self._callback = None

    def on_message(self, callback):
        """ Register a callback for receiving messages sent by a client
        object.

        Parameters
        ----------
        callback : callable
            A callable with an argument signature that is equivalent to
            the `send` method. If the callback is a bound method, then
            the lifetime of the callback will be bound to lifetime of
            the method owner object.

        """
        if isinstance(callback, types.MethodType):
            callback = WeakMethod(callback)
        self._callback = callback

    def send(self, object_id, action, content):
        """ Send the action to any attached listeners.

        Parameters
        ----------
        object_id : str
            The object id of the target object.

        action : str
            The action that should be performed by the object.

        content : dict
            The content dictionary for the action.

        """
        event = wxActionSocketEvent(
            object_id=object_id, action=action, content=content,
        )
        wx.PostEvent(self, event)

    def receive(self, event):
        """ Receive a message sent to the socket.

        The message will be routed to the registered callback, if one
        exists.

        Parameters
        ----------
        object_id : str
            The object id of the target object.

        action : str
            The action that should be performed by the object.

        content : dict
            The content dictionary for the action.

        """
        callback = self._callback
        if callback is not None:
            callback(event.object_id, event.action, event.content)


ActionSocketInterface.register(wxActionSocket)


########NEW FILE########
__FILENAME__ = wx_application
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
import logging
import uuid

import wx

from enaml.application import Application

from .wx_action_socket import wxActionSocket, EVT_ACTION_SOCKET
from .wx_deferred_caller import DeferredCall, TimedCall
from .wx_session import WxSession
from .wx_factories import register_default


logger = logging.getLogger(__name__)


# This registers the default Wx factories with the WxWidgetRegistry and
# allows an application access to the default widget implementations.
register_default()


class WxApplication(Application):
    """ A concrete implementation of an Enaml application.

    A WxApplication uses the Wx toolkit to implement an Enaml UI that
    runs in the local process.

    """
    def __init__(self, factories):
        """ Initialize a WxApplication.

        Parameters
        ----------
        factories : iterable
            An iterable of SessionFactory instances to pass to the
            superclass constructor.

        """
        super(WxApplication, self).__init__(factories)
        self._wxapp = wx.GetApp() or wx.PySimpleApp()
        self._wx_sessions = {}
        self._sessions = {}

    #--------------------------------------------------------------------------
    # Abstract API Implementation
    #--------------------------------------------------------------------------
    def start_session(self, name):
        """ Start a new session of the given name.

        This method will create a new session object for the requested
        session type and return the new session_id. If the session name
        is invalid, an exception will be raised.

        Parameters
        ----------
        name : str
            The name of the session to start.

        Returns
        -------
        result : str
            The unique identifier for the created session.

        """
        if name not in self._named_factories:
            raise ValueError('Invalid session name')

        # Create and open a new server-side session.
        factory = self._named_factories[name]
        session = factory()
        session_id = uuid.uuid4().hex
        session.open(session_id)
        self._sessions[session_id] = session

        # Create and open a new client-side session.
        groups = session.widget_groups[:]
        wx_session = WxSession(session_id, groups)
        self._wx_sessions[session_id] = wx_session
        wx_session.open(session.snapshot())

        # Setup the sockets for the session pair
        server_socket = wxActionSocket()
        client_socket = wxActionSocket()
        server_socket.Bind(EVT_ACTION_SOCKET, client_socket.receive)
        client_socket.Bind(EVT_ACTION_SOCKET, server_socket.receive)

        # Activate the server and client sessions. The server session
        # is activated first so that it is ready to receive messages
        # sent by the client during activation. These messages will
        # typically be requests for resources.
        session.activate(server_socket)
        wx_session.activate(client_socket)

        return session_id

    def end_session(self, session_id):
        """ End the session with the given session id.

        This method will close down the existing session. If the session
        id is not valid, an exception will be raised.

        Parameters
        ----------
        session_id : str
            The unique identifier for the session to close.

        """
        if session_id not in self._sessions:
            raise ValueError('Invalid session id')
        self._sessions.pop(session_id).close()
        del self._wx_sessions[session_id]

    def session(self, session_id):
        """ Get the session for the given session id.

        Parameters
        ----------
        session_id : str
            The unique identifier for the session to retrieve.

        Returns
        -------
        result : Session or None
            The session object with the given id, or None if the id
            does not correspond to an active session.

        """
        return self._sessions.get(session_id)

    def sessions(self):
        """ Get the currently active sessions for the application.

        Returns
        -------
        result : list
            The list of currently active sessions for the application.

        """
        return self._sessions.values()

    def start(self):
        """ Start the application's main event loop.

        """
        app = self._wxapp
        if not app.IsMainLoopRunning():
            app.MainLoop()

    def stop(self):
        """ Stop the application's main event loop.

        """
        app = self._wxapp
        if app.IsMainLoopRunning():
            app.Exit()

    def deferred_call(self, callback, *args, **kwargs):
        """ Invoke a callable on the next cycle of the main event loop
        thread.

        Parameters
        ----------
        callback : callable
            The callable object to execute at some point in the future.

        *args, **kwargs
            Any additional positional and keyword arguments to pass to
            the callback.

        """
        DeferredCall(callback, *args, **kwargs)

    def timed_call(self, ms, callback, *args, **kwargs):
        """ Invoke a callable on the main event loop thread at a
        specified time in the future.

        Parameters
        ----------
        ms : int
            The time to delay, in milliseconds, before executing the
            callable.

        callback : callable
            The callable object to execute at some point in the future.

        *args, **kwargs
            Any additional positional and keyword arguments to pass to
            the callback.

        """
        TimedCall(ms, callback, *args, **kwargs)

    def is_main_thread(self):
        """ Indicates whether the caller is on the main gui thread.

        Returns
        -------
        result : bool
            True if called from the main gui thread. False otherwise.

        """
        return wx.Thread_IsMain()


########NEW FILE########
__FILENAME__ = wx_bounded_date
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
import datetime

from dateutil import parser as isoparser
import wx

from .wx_control import WxControl


def as_wx_date(iso_date):
    """ Convert an iso date string to a wxDateTime.

    """
    # wx doesn't have iso date parsing until version 2.9
    py_date = isoparser.parse(iso_date)
    day = py_date.day
    month = py_date.month - 1  # wx peculiarity!
    year = py_date.year
    return wx.DateTimeFromDMY(day, month, year)


def as_iso_date(wx_date):
    """ Convert a QDate object into and iso date string.

    """
    day = wx_date.GetDay()
    month = wx_date.GetMonth() + 1  # wx peculiarity!
    year = wx_date.GetYear()
    return datetime.date(year, month, day).isoformat()


class WxBoundedDate(WxControl):
    """ A base class for use with Wx widgets implementing behavior
    for subclasses of BoundedDate.

    """
     #--------------------------------------------------------------------------
    # Setup Methods
    #--------------------------------------------------------------------------
    def create(self, tree):
        """ Create and initialize the bounded date widget.

        """
        super(WxBoundedDate, self).create(tree)
        self.set_min_date(as_wx_date(tree['minimum']))
        self.set_max_date(as_wx_date(tree['maximum']))
        self.set_date(as_wx_date(tree['date']))

    #--------------------------------------------------------------------------
    # Message Handlers
    #--------------------------------------------------------------------------
    def on_action_set_date(self, content):
        """ Handle the 'set_date' action from the Enaml widget.

        """
        self.set_date(as_wx_date(content['date']))

    def on_action_set_minimum(self, content):
        """ Hanlde the 'set_minimum' action from the Enaml widget.

        """
        self.set_min_date(as_wx_date(content['minimum']))

    def on_action_set_maximum(self, content):
        """ Handle the 'set_maximum' action from the Enaml widget.

        """
        self.set_max_date(as_wx_date(content['maximum']))

    #--------------------------------------------------------------------------
    # Event Handlers
    #--------------------------------------------------------------------------
    def on_date_changed(self, event):
        """ An event handler to connect to the date changed signal of
        the underlying widget.

        This will convert the wxDateTime to iso format and send the Enaml
        widget the 'date_changed' action.

        """
        wx_date = self.get_date()
        content = {'date': as_iso_date(wx_date)}
        self.send_action('date_changed', content)

    #--------------------------------------------------------------------------
    # Abstract Methods
    #--------------------------------------------------------------------------
    def get_date(self):
        """ Return the current date in the control.

        Returns
        -------
        result : wxDateTime
            The current control date as a wxDateTime object.

        """
        raise NotImplementedError

    def set_date(self, date):
        """ Set the widget's current date.

        Parameters
        ----------
        date : wxDateTime
            The wxDateTime object to use for setting the date.

        """
        raise NotImplementedError

    def set_max_date(self, date):
        """ Set the widget's maximum date.

        Parameters
        ----------
        date : wxDateTime
            The wxDateTime object to use for setting the maximum date.

        """
        raise NotImplementedError

    def set_min_date(self, date):
        """ Set the widget's minimum date.

        Parameters
        ----------
        date : wxDateTime
            The wxDateTime object to use for setting the minimum date.

        """
        raise NotImplementedError


########NEW FILE########
__FILENAME__ = wx_calendar
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from wx.calendar import CalendarCtrl, EVT_CALENDAR

from .wx_bounded_date import WxBoundedDate


class WxCalendar(WxBoundedDate):
    """ A Wx implementation of an Enaml Calendar.

    """
    #--------------------------------------------------------------------------
    # Setup methods
    #--------------------------------------------------------------------------
    def create_widget(self, parent, tree):
        """ Creates the wx.calendar.CalendarCtrl widget.

        """
        return CalendarCtrl(parent)

    def create(self, tree):
        """ Create and initialize the the calendar widget.

        """
        super(WxCalendar, self).create(tree)
        self.widget().Bind(EVT_CALENDAR, self.on_date_changed)

    #--------------------------------------------------------------------------
    # Abstract Method Implementations
    #--------------------------------------------------------------------------
    def get_date(self):
        """ Return the current date in the control.

        Returns
        -------
        result : wxDateTime
            The current control date as a wxDateTime object.

        """
        return self.widget().GetDate()

    def set_date(self, date):
        """ Set the widget's current date.

        Parameters
        ----------
        date : wxDateTime
            The wxDateTime object to use for setting the date.

        """
        self.widget().SetDate(date)

    def set_max_date(self, date):
        """ Set the widget's maximum date.

        Parameters
        ----------
        date : wxDateTime
            The wxDateTime object to use for setting the maximum date.

        """
        self.widget().SetUpperDateLimit(date)

    def set_min_date(self, date):
        """ Set the widget's minimum date.

        Parameters
        ----------
        date : wxDateTime
            The wxDateTime object to use for setting the minimum date.

        """
        self.widget().SetLowerDateLimit(date)


########NEW FILE########
__FILENAME__ = wx_check_box
#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
import wx
import wx.lib.newevent

from .wx_abstract_button import WxAbstractButton


#: A check box event emitted when the button is clicked.
wxCheckBoxClicked, EVT_CHECKBOX_CLICKED = wx.lib.newevent.NewEvent()

#: A check event emitted when the button value is changed.
wxCheckBoxToggled, EVT_CHECKBOX_TOGGLED = wx.lib.newevent.NewEvent()


class wxProperCheckBox(wx.CheckBox):
    """ A custom subclass of wx.CheckBox.

    This checkbox emits an EVT_CHECKBOX_CLICKED event whenever the
    button is clicked. It also emits an EVT_CHECKBOX_TOGGLED whenever
    the checkbox changes state.

    """
    def __init__(self, *args, **kwargs):
        """ Initialize a wxProperCheckBox.

        *args, **kwargs
            The positional and keyword arguments required to initialize
            a wx.RadioButton.

        """
        super(wxProperCheckBox, self).__init__(*args, **kwargs)
        self._in_click = False
        self.Bind(wx.EVT_LEFT_DOWN, self.OnLeftDown)
        self.Bind(wx.EVT_LEFT_UP, self.OnLeftUp)
        self.Bind(wx.EVT_CHECKBOX, self.OnToggled)

    def OnLeftDown(self, event):
        """ Handles the left down mouse event for the check box.

        This is first part of generating a click event.

        """
        event.Skip()
        self._in_click = True

    def OnLeftUp(self, event):
        """ Handles the left up mouse event for the check box.

        This is the second part of generating a click event.

        """
        event.Skip()
        if self._in_click:
            self._in_click = False
            event = wxCheckBoxClicked()
            wx.PostEvent(self, event)

    def OnToggled(self, event):
        """ Handles the standard toggle event and emits the custom 
        toggle event for the check box. 

        """
        event = wxCheckBoxToggled()
        wx.PostEvent(self, event)

    def SetValue(self, val):
        """ Overrides the default SetValue method to emit proper events.

        """
        old = self.GetValue()
        if old != val:
            super(wxProperCheckBox, self).SetValue(val)
            self._last = val
            event = wxCheckBoxToggled()
            wx.PostEvent(self, event)


class WxCheckBox(WxAbstractButton):
    """ A Wx implementation of an Enaml CheckBox.

    """
    #--------------------------------------------------------------------------
    # Setup methods
    #--------------------------------------------------------------------------
    def create_widget(self, parent, tree):
        """ Creates the underlying wxProperCheckBox.

        """
        return wxProperCheckBox(parent)

    def create(self, tree):
        """ Create and initialize the check box control.

        """
        super(WxCheckBox, self).create(tree)
        widget = self.widget()
        widget.Bind(EVT_CHECKBOX_CLICKED, self.on_clicked)
        widget.Bind(EVT_CHECKBOX_TOGGLED, self.on_toggled)

    #--------------------------------------------------------------------------
    # Abstract API Implementation
    #--------------------------------------------------------------------------
    def set_checkable(self, checkable):
        """ Sets whether or not the widget is checkable.

        """
        # wx doesn't support changing the checkability of a check box
        pass

    def get_checked(self):
        """ Returns the checked state of the widget.

        """
        return self.widget().GetValue()

    def set_checked(self, checked):
        """ Sets the widget's checked state with the provided value.

        """
        self.widget().SetValue(checked)


########NEW FILE########
__FILENAME__ = wx_combo_box
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
import wx

from .wx_control import WxControl


class WxComboBox(WxControl):
    """ A Wx implementation of an Enaml ComboBox.

    """
    #--------------------------------------------------------------------------
    # Setup Methods
    #--------------------------------------------------------------------------
    def create_widget(self, parent, tree):
        """ Create the underlying wx.ComboBox widget.

        """
        return wx.ComboBox(parent, style=wx.CB_READONLY)

    def create(self, tree):
        """ Create and initialize the combo box control.

        """
        super(WxComboBox, self).create(tree)
        self.set_items(tree['items'])
        self.set_index(tree['index'])
        self.widget().Bind(wx.EVT_COMBOBOX, self.on_index_changed)

    #--------------------------------------------------------------------------
    # Message Handlers
    #--------------------------------------------------------------------------
    def on_action_set_index(self, content):
        """ Handle the 'set_index' action from the Enaml widget.

        """
        self.set_index(content['index'])

    def on_action_set_items(self, content):
        """ Handle the 'set_items' action from the Enaml widget.

        """
        self.set_items(content['items'])

    #--------------------------------------------------------------------------
    # Event Handlers
    #--------------------------------------------------------------------------
    def on_index_changed(self, event):
        """ The signal handler for the index changed signal.

        """
        content = {'index': self.widget().GetCurrentSelection()}
        self.send_action('index_changed', content)

    #--------------------------------------------------------------------------
    # Widget Update Methods
    #--------------------------------------------------------------------------
    def set_items(self, items):
        """ Set the items of the ComboBox.

        """
        widget = self.widget()
        sel = widget.GetCurrentSelection()
        widget.SetItems(items)
        widget.SetSelection(sel)

    def set_index(self, index):
        """ Set the current index of the ComboBox

        """
        self.widget().SetSelection(index)


########NEW FILE########
__FILENAME__ = wx_constraints_widget
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from casuarius import ConstraintVariable

from .wx_widget import WxWidget


class LayoutBox(object):
    """ A class which encapsulates a layout box using casuarius
    constraint variables.

    The constraint variables are created on an as-needed basis, this
    allows Enaml widgets to define new constraints and build layouts
    with them, without having to specifically update this client
    code.

    """
    def __init__(self, name, owner):
        """ Initialize a LayoutBox.

        Parameters
        ----------
        name : str
            A name to use in the label for the constraint variables in
            this layout box.

        owner : str
            The owner id to use in the label for the constraint variables
            in this layout box.

        """
        self._name = name
        self._owner = owner
        self._primitives = {}

    def primitive(self, name):
        """ Returns a primitive casuarius constraint variable for the
        given name.

        Parameters
        ----------
        name : str
            The name of the constraint variable to return.

        """
        primitives = self._primitives
        if name in primitives:
            res = primitives[name]
        else:
            label = '{0}|{1}|{2}'.format(self._name, self._owner, name)
            res = primitives[name] = ConstraintVariable(label)
        return res


class WxConstraintsWidget(WxWidget):
    """ A Wx implementation of an Enaml ConstraintsWidget.

    """
    #: The hug strengths for the widget's size hint.
    _hug = ('strong', 'strong')

    #: The resist strengths for the widget's size hint.
    _resist = ('strong', 'strong')

    #: The list of hard constraints which must be applied to the widget.
    #: These constraints are computed lazily and only once since they
    #: are assumed to never change.
    _hard_cns = []

    #: The list of size hint constraints to apply to the widget. These
    #: constraints are computed once and then cached. If the size hint
    #: of a widget changes at run time, then `size_hint_updated` should
    #: be called to trigger an appropriate relayout of the widget.
    _size_hint_cns = []

    #: The list of constraint dictionaries defined by the user on
    #: the server side Enaml widget.
    _user_cns = []

    #--------------------------------------------------------------------------
    # Setup Methods
    #--------------------------------------------------------------------------
    def create(self, tree):
        """ Create and initialize the control.

        """
        super(WxConstraintsWidget, self).create(tree)
        layout = tree['layout']
        self.layout_box = LayoutBox(type(self).__name__, self.object_id())
        self._hug = layout['hug']
        self._resist = layout['resist']
        self._user_cns = layout['constraints']

    #--------------------------------------------------------------------------
    # Message Handlers
    #--------------------------------------------------------------------------
    def on_action_relayout(self, content):
        """ Handle the 'relayout' action from the Enaml widget.

        """
        # XXX The WxContainer needs to get in on the action to grab the
        # share_layout flag.
        self._hug = content['hug']
        self._resist_clip = content['resist']
        self._user_cns = content['constraints']
        self.clear_size_hint_constraints()
        self.relayout()

    #--------------------------------------------------------------------------
    # Layout Handling
    #--------------------------------------------------------------------------
    def relayout(self):
        """ Peform a relayout for this constraints widget.

        The default behavior of this method is to proxy the call up the
        tree of ancestors until it is either handled by a subclass which
        has reimplemented this method (see WxContainer), or the ancestor
        is not an instance of WxConstraintsWidget, at which point the
        layout request is dropped.

        """
        parent = self.parent()
        if isinstance(parent, WxConstraintsWidget):
            parent.relayout()

    def replace_constraints(self, old_cns, new_cns):
        """ Replace constraints in the current layout system.

        The default behavior of this method is to proxy the call up the
        tree of ancestors until it is either handled by a subclass which
        has reimplemented this method (see WxContainer), or the ancestor
        is not an instance of WxConstraintsWidget, at which point the
        request is dropped.

        Parameters
        ----------
        old_cns : list
            The list of casuarius constraints to remove from the
            current layout system.

        new_cns : list
            The list of casuarius constraints to add to the
            current layout system.

        """
        parent = self.parent()
        if isinstance(parent, WxConstraintsWidget):
            parent.replace_constraints(old_cns, new_cns)

    def clear_constraints(self, cns):
        """ Clear the given constraints from the current layout system.

        The default behavior of this method is to proxy the call up the
        tree of ancestors until it is either handled by a subclass which
        has reimplemented this method (see WxContainer), or the ancestor
        is not an instance of WxConstraintsWidget, at which point the
        request is dropped. This method will *not* trigger a relayout.

        Parameters
        ----------
        cns : list
            The list of casuarius constraints to remove from the
            current layout system.

        """
        parent = self.parent()
        if isinstance(parent, WxConstraintsWidget):
            parent.clear_constraints(cns)

    def size_hint_constraints(self):
        """ Creates the list of size hint constraints for this widget.

        This method uses the provided size hint of the widget and the
        policies for 'hug' and 'resist_clip' to generate casuarius
        LinearConstraint objects which respect the size hinting of the
        widget.

        If the size hint of the underlying widget is not valid, then
        no constraints will be generated.

        Returns
        -------
        result : list
            A list of casuarius LinearConstraint instances.

        """
        cns = self._size_hint_cns
        if not cns:
            cns = self._size_hint_cns = []
            push = cns.append
            hint = self.widget().GetBestSize()
            if hint.IsFullySpecified():
                width_hint = hint.width
                height_hint = hint.height
                primitive = self.layout_box.primitive
                width = primitive('width')
                height = primitive('height')
                hug_width, hug_height = self._hug
                resist_width, resist_height = self._resist
                if width_hint >= 0:
                    if hug_width != 'ignore':
                        cn = (width == width_hint) | hug_width
                        push(cn)
                    if resist_width != 'ignore':
                        cn = (width >= width_hint) | resist_width
                        push(cn)
                if height_hint >= 0:
                    if hug_height != 'ignore':
                        cn = (height == height_hint) | hug_height
                        push(cn)
                    if resist_height != 'ignore':
                        cn = (height >= height_hint) | resist_height
                        push(cn)
        return cns

    def size_hint_updated(self):
        """ Notify the layout system that the size hint of this widget
        has been updated.

        """
        # Only the ancestors of a widget care about its size hint,
        # so this method attempts to replace the size hint constraints
        # for the widget starting with its parent.
        parent = self.parent()
        if isinstance(parent, WxConstraintsWidget):
            old_cns = self._size_hint_cns
            self._size_hint_cns = []
            new_cns = self.size_hint_constraints()
            parent.replace_constraints(old_cns, new_cns)
        self.update_geometry()

    def clear_size_hint_constraints(self):
        """ Clear the size hint constraints from the layout system.

        """
        # Only the ancestors of a widget care about its size hint,
        # so this method attempts to replace the size hint constraints
        # for the widget starting with its parent.
        parent = self.parent()
        if isinstance(parent, WxConstraintsWidget):
            cns = self._size_hint_cns
            self._size_hint_cns = []
            parent.clear_constraints(cns)

    def hard_constraints(self):
        """ Generate the constraints which must always be applied.

        These constraints are generated once the first time this method
        is called. The results are then cached and returned immediately
        on future calls.

        Returns
        -------
        result : list
            A list of casuarius LinearConstraint instance.

        """
        cns = self._hard_cns
        if not cns:
            primitive = self.layout_box.primitive
            left = primitive('left')
            top = primitive('top')
            width = primitive('width')
            height = primitive('height')
            cns = [left >= 0, top >= 0, width >= 0, height >= 0]
            self._hard_cns = cns
        return cns

    def user_constraints(self):
        """ Get the list of user constraints defined for this widget.

        The default implementation returns the list of constraint
        information sent by the server.

        Returns
        -------
        result : list
            The list of dictionaries which represent the user defined
            linear constraints.

        """
        return self._user_cns

    def geometry_updater(self):
        """ A method which can be called to create a function which
        will update the layout geometry of the underlying widget.

        The parameter and return values below describe the function
        that is returned by calling this method.

        Parameters
        ----------
        dx : float
            The offset of the parent widget from the computed origin
            of the layout. This amount is subtracted from the computed
            layout 'x' amount, which is expressed in the coordinates
            of the owner widget.

        dy : float
            The offset of the parent widget from the computed origin
            of the layout. This amount is subtracted from the computed
            layout 'y' amount, which is expressed in the coordinates
            of the layout owner widget.

        Returns
        -------
        result : (x, y)
            The computed layout 'x' and 'y' amount, expressed in the
            coordinates of the layout owner widget.

        """
        # The return function is a hyper optimized (for Python) closure
        # that will is called on every resize to update the geometry of
        # the widget. This is explicitly not idiomatic Python code. It
        # exists purely for the sake of efficiency and was justified
        # with profiling.
        primitive = self.layout_box.primitive
        x = primitive('left')
        y = primitive('top')
        width = primitive('width')
        height = primitive('height')
        setdims = self.widget().SetDimensions
        def update_geometry(dx, dy):
            nx = x.value
            ny = y.value
            setdims(nx - dx, ny - dy, width.value, height.value)
            return nx, ny
        # Store a reference to self on the updater, so that the layout
        # container can know the object on which the updater operates.
        update_geometry.item = self
        return update_geometry


########NEW FILE########
__FILENAME__ = wx_container
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from collections import deque

from casuarius import weak
from enaml.layout.layout_manager import LayoutManager

import wx

from .wx_constraints_widget import WxConstraintsWidget, LayoutBox


def _convert_cn_info(info, owners):
    """ Converts the lhs or rhs of a linear constraint info dict into
    its corresponding casuarius object.

    """
    cn_type = info['type']
    if cn_type == 'linear_expression':
        const = info['constant']
        terms = info['terms']
        convert = _convert_cn_info
        res = sum(convert(t, owners) for t in terms) + const
    elif cn_type == 'term':
        coeff = info['coeff']
        var = info['var']
        res = coeff * _convert_cn_info(var, owners)
    elif cn_type == 'linear_symbolic':
        sym_name = info['name']
        owner_id = info['owner']
        owner = owners.get(owner_id, None)
        if owner is None:
            owner = owners[owner_id] = LayoutBox('_virtual', owner_id)
        res = owner.primitive(sym_name)
    else:
        msg = 'Unhandled constraint info type `%s`' % cn_type
        raise ValueError(msg)
    return res


def as_linear_constraint(info, owners):
    """ Converts a constraint info dict into a casuarius linear
    constraint.

    For constraints specified in the info dict which do not have a
    corresponding owner (e.g. those created by box helpers) a
    constraint variable will be synthesized.

    Parameters
    ----------
    info : dict
        A dictionary sent from an Enaml widget which specifies the
        information for a linear constraint.

    owners : dict
        A mapping from constraint id to an owner object which holds
        the actual casuarius constraint variables as attributes.

    Returns
    -------
    result : LinearConstraint
        A casuarius linear constraint for the given dict.

    """
    if info['type'] != 'linear_constraint':
        msg = 'The info dict does not specify a linear constraint.'
        raise ValueError(msg)
    convert = _convert_cn_info
    lhs = convert(info['lhs'], owners)
    rhs = convert(info['rhs'], owners)
    op = info['op']
    if op == '==':
        cn = lhs == rhs
    elif op == '<=':
        cn = lhs <= rhs
    elif op == '>=':
        cn = lhs >= rhs
    else:
        msg = 'Unhandled constraint operator `%s`' % op
        raise ValueError(msg)
    return cn | info['strength'] | info['weight']


class wxContainer(wx.PyPanel):
    """ A subclass of wx.PyPanel which allows the default best size to
    be overriden by calling SetBestSize.

    This functionality is used by the WxContainer to override the
    size hint with a value computed from the constraints layout
    manager.

    """
    #: An invalid wx.Size used as the default value for class instances.
    _best_size = wx.Size(-1, -1)

    def DoGetBestSize(self):
        """ Reimplemented parent class method.

        This will return the best size as set by a call to SetBestSize.
        If that is invalid, then the superclass' version will be used.

        """
        size = self._best_size
        if not size.IsFullySpecified():
            size = super(wxContainer, self).DoGetBestSize()
        return size

    def SetBestSize(self, size):
        """ Sets the best size to use for this container.

        """
        self._best_size = size


class WxContainer(WxConstraintsWidget):
    """ A Wx implementation of an Enaml Container.

    """
    #: Whether or not this container should share its layout with a
    #: parent container.
    _share_layout = False

    #: The padding to use when constraining the layout.
    _padding = (10, 10, 10, 10)

    #: Whether or not this container owns its layout. A container which
    #: does not own its layout is not responsible for laying out its
    #: children on a resize event, and will proxy the call to its owner.
    _owns_layout = True

    #: The object which has taken ownership of the layout for this
    #: container, if any.
    _layout_owner = None

    #: The LayoutManager instance to use for solving the layout system
    #: for this container.
    _layout_manager = None

    #: The function to use for refreshing the layout on a resize event.
    _refresh = lambda *args, **kwargs: None

    #: The table of offsets to use during a layout pass.
    _offset_table = []

    #: The table of (index, updater) pairs to use during a layout pass.
    _layout_table = []

    #: A dict mapping constraint owner id to associated LayoutBox
    _cn_owners = {}

    #: A list of the current contents constraints for the widget.
    _contents_cns = []

    #: Whether or not the current container is shown. This is toggled
    #: by the EVT_SHOW handler.
    _is_shown = True

    #--------------------------------------------------------------------------
    # Setup Methods
    #--------------------------------------------------------------------------
    def create_widget(self, parent, tree):
        """ Creates the underlying wxContainer widget.

        """
        return wxContainer(parent)

    def create(self, tree):
        """ Create and initialize the container.

        """
        super(WxContainer, self).create(tree)
        layout = tree['layout']
        self._share_layout = layout['share_layout']
        self._padding = layout['padding']
        widget = self.widget()
        widget.Bind(wx.EVT_SIZE, self.on_resize)
        widget.Bind(wx.EVT_SHOW, self.on_show)

    def init_layout(self):
        """ Initializes the layout for the container.

        """
        super(WxContainer, self).init_layout()
        # Layout ownership can only be transferred *after* this init
        # layout method is called, since layout occurs bottom up. So,
        # we only initialize a layout manager if we are not going to
        # transfer ownership at some point.
        if not self.will_transfer():
            offset_table, layout_table = self._build_layout_table()
            cns = self._generate_constraints(layout_table)
            # Initializing the layout manager can fail if the objective
            # function is unbounded. We let that failure occur so it can
            # be logged. Nothing is stored until it succeeds.
            manager = LayoutManager()
            manager.initialize(cns)
            self._offset_table = offset_table
            self._layout_table = layout_table
            self._layout_manager = manager
            self._refresh = self._build_refresher(manager)
            self.refresh_sizes()

    #--------------------------------------------------------------------------
    # Event Handlers
    #--------------------------------------------------------------------------
    def on_resize(self, event):
        """ The event handler for the EVT_SIZE event.

        This handler triggers a layout pass when the container widget
        is resized.

        """
        self.refresh()

    def on_show(self, event):
        """ The event handler for the EVT_SHOW event.

        This handler toggles the value of the _is_shown flag.

        """
        # The EVT_SHOW event is not reliable. For example, it is not
        # emitted on the children of widgets that were hidden. So, if
        # this container is the child of, say, a notebook page, then
        # the switching of tabs does not emit a show event. So, the
        # notebook page must cooperatively emit a show event on this
        # container. Therefore, we can't treat this event as a 'real'
        # toolkit event, we just use it as a hint.
        self._is_shown = shown = event.GetShow()
        if shown:
            self.refresh()

    #------------------------- -------------------------------------------------
    # Layout Handling
    #--------------------------------------------------------------------------
    def relayout(self):
        """ Rebuilds the constraints layout for this widget if it owns
        the responsibility for laying out its descendents.

        """
        if self._owns_layout:
            widget = self.widget()
            old_hint = widget.GetBestSize()
            self.init_layout()
            self.refresh()
            new_hint = widget.GetBestSize()
            # If the size hint constraints are empty, it indicates that
            # they were previously cleared. In this case, the layout
            # system must be notified to rebuild its constraints, even
            # if the numeric size hint hasn't changed.
            if old_hint != new_hint or not self._size_hint_cns:
                self.size_hint_updated()
        else:
            self._layout_owner.relayout()

    def refresh(self):
        """ Makes a layout pass over the descendents if this widget owns
        the responsibility for their layout.

        If the widget is not visible on the screen, the refresh will be
        skipped.

        """
        # The _refresh function is generated on every relayout and has
        # already taken into account whether or not the container owns
        # the layout.
        if self._is_shown:
            self._refresh()

    def refresh_sizes(self):
        """ Refresh the min/max/best sizes for the underlying widget.

        This method is normally called automatically at the proper
        times. It should not normally need to be called by user code.

        """
        widget = self.widget()
        widget.SetBestSize(self.compute_best_size())
        widget.SetMinSize(self.compute_min_size())
        widget.SetMaxSize(self.compute_max_size())

    def replace_constraints(self, old_cns, new_cns):
        """ Replace constraints in the given layout.

        This method can be used to selectively add/remove/replace
        constraints in the layout system, when it is more efficient
        than performing a full relayout.

        Parameters
        ----------
        old_cns : list
            The list of casuarius constraints to remove from the
            the current layout system.

        new_cns : list
            The list of casuarius constraints to add to the
            current layout system.

        """
        if self._owns_layout:
            manager = self._layout_manager
            if manager is not None:
                widget = self.widget()
                old_hint = widget.GetBestSize()
                manager.replace_constraints(old_cns, new_cns)
                self.refresh_sizes()
                self.refresh()
                new_hint = widget.GetBestSize()
                if old_hint != new_hint:
                    self.size_hint_updated()
        else:
            self._layout_owner.replace_constraints(old_cns, new_cns)

    def clear_constraints(self, cns):
        """ Clear the given constraints from the current layout.

        Parameters
        ----------
        cns : list
            The list of casuarius constraints to remove from the
            current layout system.

        """
        if self._owns_layout:
            manager = self._layout_manager
            if manager is not None:
                manager.replace_constraints(cns, [])
        else:
            self._layout_owner.clear_constraints(cns)

    def layout(self):
        """ The callback invoked by the layout manager when there are
        new layout values available.

        This iterates over the layout table and calls the geometry
        updater functions.

        """
        # We explicitly don't use enumerate() to generate the running
        # index because this method is on the code path of the resize
        # event and hence called *often*. The entire code path for a
        # resize event is micro optimized and justified with profiling.
        offset_table = self._offset_table
        layout_table = self._layout_table
        running_index = 1
        for offset_index, updater in layout_table:
            dx, dy = offset_table[offset_index]
            new_offset = updater(dx, dy)
            offset_table[running_index] = new_offset
            running_index += 1

    def contents_margins(self):
        """ Get the contents margins for the container.

        The contents margins are added to the user provided padding
        to determine the final offset from a layout box boundary to
        the corresponding content line. The default content margins
        are zero. This method can be reimplemented by subclasses to
        supply different margins.

        Returns
        -------
        result : tuple
            A tuple of 'top', 'right', 'bottom', 'left' contents
            margins to use for computing the contents constraints.

        """
        return (0, 0, 0, 0)

    def contents_margins_updated(self):
        """ Notify the layout system that the contents margins of this
        widget have been updated.

        """
        old_cns = self._contents_cns
        self._contents_cns = []
        new_cns = self.contents_constraints()
        self.replace_constraints(old_cns, new_cns)

    def contents_constraints(self):
        """ Create the contents constraints for the container.

        The contents contraints are generated by combining the user
        padding with the margins returned by 'contents_margins' method.

        Returns
        -------
        result : list
            The list of casuarius constraints for the content.

        """
        cns = self._contents_cns
        if not cns:
            padding = self._padding
            margins = self.contents_margins()
            tval, rval, bval, lval = map(sum, zip(padding, margins))
            primitive = self.layout_box.primitive
            top = primitive('top')
            left = primitive('left')
            width = primitive('width')
            height = primitive('height')
            contents_top = primitive('contents_top')
            contents_left = primitive('contents_left')
            contents_right = primitive('contents_right')
            contents_bottom = primitive('contents_bottom')
            cns = [
                contents_top == (top + tval),
                contents_left == (left + lval),
                contents_right == (left + width - rval),
                contents_bottom == (top + height - bval),
            ]
            self._contents_cns = cns
        return cns

    #--------------------------------------------------------------------------
    # Constraints Computation
    #--------------------------------------------------------------------------
    def _build_refresher(self, manager):
        """ A private method which will build a function which, when
        called, will refresh the layout for the container.

        Parameters
        ----------
        manager : LayoutManager
            The layout manager to use when refreshing the layout.

        """
        # The return function is a hyper optimized (for Python) closure
        # in order minimize the amount of work which is performed on the
        # code path of the resize event. This is explicitly not idiomatic
        # Python code. It exists purely for the sake of efficiency,
        # justified with profiling.
        mgr_layout = manager.layout
        layout = self.layout
        primitive = self.layout_box.primitive
        width_var = primitive('width')
        height_var = primitive('height')
        size = self._widget.GetSizeTuple
        def refresher():
            mgr_layout(layout, width_var, height_var, size())
        return refresher

    def _build_layout_table(self):
        """ A private method which will build the layout table for
        this container.

        A layout table is a pair of flat lists which hold the required
        objects for laying out the child widgets of this container.
        The flat table is built in advance (and rebuilt if and when
        the tree structure changes) so that it's not necessary to
        perform an expensive tree traversal to layout the children
        on every resize event.

        Returns
        -------
        result : (list, list)
            The offset table and layout table to use during a resize
            event.

        """
        # The offset table is a list of (dx, dy) tuples which are the
        # x, y offsets of children expressed in the coordinates of the
        # layout owner container. This owner container may be different
        # from the parent of the widget, and so the delta offset must
        # be subtracted from the computed geometry values during layout.
        # The offset table is updated during a layout pass in breadth
        # first order.
        #
        # The layout table is a flat list of (idx, updater) tuples. The
        # idx is an index into the offset table where the given child
        # can find the offset to use for its layout. The updater is a
        # callable provided by the widget which accepts the dx, dy
        # offset and will update the layout geometry of the widget.
        zero_offset = (0, 0)
        offset_table = [zero_offset]
        layout_table = []
        queue = deque((0, child) for child in self.children())

        # Micro-optimization: pre-fetch bound methods and store globals
        # as locals. This method is not on the code path of a resize
        # event, but it is on the code path of a relayout. If there
        # are many children, the queue could potentially grow large.
        push_offset = offset_table.append
        push_item = layout_table.append
        push = queue.append
        pop = queue.popleft
        WxConstraintsWidget_ = WxConstraintsWidget
        WxContainer_ = WxContainer
        isinst = isinstance

        # The queue yields the items in the tree in breadth-first order
        # starting with the immediate children of this container. If a
        # given child is a container that will share its layout, then
        # the children of that container are added to the queue to be
        # added to the layout table.
        running_index = 0
        while queue:
            offset_index, item = pop()
            if isinst(item, WxConstraintsWidget_):
                push_item((offset_index, item.geometry_updater()))
                push_offset(zero_offset)
                running_index += 1
                if isinst(item, WxContainer_):
                    if item.transfer_layout_ownership(self):
                        for child in item.children():
                            push((running_index, child))

        return offset_table, layout_table

    def _generate_constraints(self, layout_table):
        """ Creates the list of casuarius LinearConstraint objects for
        the widgets for which this container owns the layout.

        This method walks over the items in the given layout table and
        aggregates their constraints into a single list of casuarius
        LinearConstraint objects which can be given to the layout
        manager.

        Parameters
        ----------
        layout_table : list
            The layout table created by a call to _build_layout_table.

        Returns
        -------
        result : list
            The list of casuarius LinearConstraints instances to pass to
            the layout manager.

        """
        # The mapping of constraint owners and the list of constraint
        # info dictionaries provided by the Enaml widgets.
        box = self.layout_box
        cn_owners = {self.object_id(): box}
        cn_dicts = list(self.user_constraints())
        cn_dicts_extend = cn_dicts.extend

        # The list of raw casuarius constraints which will be returned
        # from this method to be added to the casuarius solver.
        raw_cns = self.hard_constraints() + self.contents_constraints()
        raw_cns_extend = raw_cns.extend

        # The first element in a layout table item is its offset index
        # which is not relevant to constraints generation.
        isinst = isinstance
        WxContainer_ = WxContainer
        for _, updater in layout_table:
            child = updater.item
            cn_owners[child.object_id()] = child.layout_box
            raw_cns_extend(child.hard_constraints())
            if isinst(child, WxContainer_):
                if child.transfer_layout_ownership(self):
                    cn_dicts_extend(child.user_constraints())
                    raw_cns_extend(child.contents_constraints())
                else:
                    raw_cns_extend(child.size_hint_constraints())
            else:
                raw_cns_extend(child.size_hint_constraints())
                cn_dicts_extend(child.user_constraints())

        # Convert the list of Enaml constraints info dicts to actual
        # casuarius LinearConstraint objects for the solver.
        add_cn = raw_cns.append
        as_cn = as_linear_constraint
        for info in cn_dicts:
            add_cn(as_cn(info, cn_owners))

        # We keep a strong reference to the constraint owners dict,
        # since it may include instances of LayoutBox which were
        # created on-the-fly and hold constraint variables which
        # should not be deleted.
        self._cn_owners = cn_owners

        return raw_cns

    #--------------------------------------------------------------------------
    # Auxiliary Methods
    #--------------------------------------------------------------------------
    def transfer_layout_ownership(self, owner):
        """ A method which can be called by other components in the
        hierarchy to gain ownership responsibility for the layout
        of the children of this container. By default, the transfer
        is allowed and is the mechanism which allows constraints to
        cross widget boundaries. Subclasses should reimplement this
        method if different behavior is desired.

        Parameters
        ----------
        owner : Declarative
            The component which has taken ownership responsibility
            for laying out the children of this component. All
            relayout and refresh requests will be forwarded to this
            component.

        Returns
        -------
        results : bool
            True if the transfer was allowed, False otherwise.

        """
        if not self._share_layout:
            return False
        self._owns_layout = False
        self._layout_owner = owner
        self._layout_manager = None
        self._refresh = owner.refresh
        self._offset_table = []
        self._layout_table = []
        self._cn_owners = {}
        return True

    def will_transfer(self):
        """ Whether or not the container expects to transfer its layout
        ownership to its parent.

        This method is predictive in nature and exists so that layout
        managers are not senslessly created during the bottom-up layout
        initialization pass. It is declared public so that subclasses
        can override the behavior if necessary.

        """
        if self._share_layout:
            if isinstance(self.parent(), WxContainer):
                return True
        return False

    def compute_min_size(self):
        """ Calculates the minimum size of the container which would
        allow all constraints to be satisfied.

        If this container does not own its layout then it will return
        an invalid wxSize.

        Returns
        -------
        result : wxSize
            A (potentially) invalid wxSize which is the minimum size
            required to satisfy all constraints.

        """
        if self._owns_layout and self._layout_manager is not None:
            primitive = self.layout_box.primitive
            width = primitive('width')
            height = primitive('height')
            w, h = self._layout_manager.get_min_size(width, height)
            res = wx.Size(w, h)
        else:
            res = wx.Size(-1, -1)
        return res

    def compute_best_size(self):
        """ Calculates the best size of the container.

        The best size of the container is obtained by computing the min
        size of the layout using a strength which is much weaker than a
        normal resize. This takes into account the size of any widgets
        which have their resist clip property set to 'weak' while still
        allowing the window to be resized smaller by the user. If this
        container does not own its layout then it will return an
        invalid QSize.

        Returns
        -------
        result : wxSize
            A (potentially) invalid wxSize which is the minimum size
            required to satisfy all constraints.

        """
        if self._owns_layout and self._layout_manager is not None:
            primitive = self.layout_box.primitive
            width = primitive('width')
            height = primitive('height')
            w, h = self._layout_manager.get_min_size(width, height, weak)
            res = wx.Size(w, h)
        else:
            res = wx.Size(-1, -1)
        return res

    def compute_max_size(self):
        """ Calculates the maximum size of the container which would
        allow all constraints to be satisfied.

        If this container does not own its layout then it will return
        an invalid wxSize.

        Returns
        -------
        result : wxSize
            A (potentially) invalid wxSize which is the maximum size
            allowable while still satisfying all constraints.

        """
        if self._owns_layout and self._layout_manager is not None:
            primitive = self.layout_box.primitive
            width = primitive('width')
            height = primitive('height')
            w, h = self._layout_manager.get_max_size(width, height)
            res = wx.Size(w, h)
        else:
            res = wx.Size(-1, -1)
        return res


########NEW FILE########
__FILENAME__ = wx_control
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from .wx_constraints_widget import WxConstraintsWidget


class WxControl(WxConstraintsWidget):
    """ A Wx implementation of an Enaml Control.

    """
    # Currently, the WxConstraintsWidget superclass is a sufficient
    # implementation.
    pass


########NEW FILE########
__FILENAME__ = wx_date_selector
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
import wx

from .wx_bounded_date import WxBoundedDate


class WxDateSelector(WxBoundedDate):
    """ A Wx implementation of an Enaml DateSelector.

    """
    #--------------------------------------------------------------------------
    # Setup methods
    #--------------------------------------------------------------------------
    def create_widget(self, parent, tree):
        """ Creates the underlying wx.DatePickerCtrl.

        """
        return wx.DatePickerCtrl(parent)

    def create(self, tree):
        """ Create and initialize the date selector control.

        """
        super(WxDateSelector, self).create(tree)
        self.set_date_format(tree['date_format'])
        self.widget().Bind(wx.EVT_DATE_CHANGED, self.on_date_changed)

    #--------------------------------------------------------------------------
    # Message Handling
    #--------------------------------------------------------------------------
    def on_action_set_date_format(self, content):
        """ Handle the 'set_date_format' action from the Enaml widget.

        """
        self.set_date_format(content['date_format'])

    #--------------------------------------------------------------------------
    # Widget Update Methods
    #--------------------------------------------------------------------------
    def get_date(self):
        """ Return the current date in the control.

        Returns
        -------
        result : wxDateTime
            The current control date as a wxDateTime object.

        """
        return self.widget().GetValue()

    def set_date(self, date):
        """ Set the widget's current date.

        Parameters
        ----------
        date : wxDateTime
            The wxDateTime object to use for setting the date.

        """
        self.widget().SetValue(date)

    def set_max_date(self, date):
        """ Set the widget's maximum date.

        Parameters
        ----------
        date : wxDateTime
            The wxDateTime object to use for setting the maximum date.

        """
        widget = self.widget()
        widget.SetRange(widget.GetLowerLimit(), date)

    def set_min_date(self, date):
        """ Set the widget's minimum date.

        Parameters
        ----------
        date : wxDateTime
            The wxDateTime object to use for setting the minimum date.

        """
        widget = self.widget()
        widget.SetRange(date, widget.GetUpperLimit())

    def set_date_format(self, date_format):
        """ Set the widget's date format.

        Parameters
        ----------
        date_format : str
            A Python time formatting string.
            
        .. note:: Changing the format on wx is not supported.
                  See http://trac.wxwidgets.org/ticket/10988

        """
        pass


########NEW FILE########
__FILENAME__ = wx_deferred_caller
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
import wx


class wxDeferredCaller(object):
    """ A simple object which facilitates running callbacks on the main
    application thread.

    """
    #--------------------------------------------------------------------------
    # Public API
    #--------------------------------------------------------------------------
    def DeferredCall(self, callback, *args, **kwargs):
        """ Execute the callback on the main gui thread.

        Parameters
        ----------
        callback : callable
            The callable object to execute on the main thread.

        *args, **kwargs
            Any additional positional and keyword arguments to pass to
            the callback.

        """
        wx.CallAfter(callback, *args, **kwargs)

    def TimedCall(self, ms, callback, *args, **kwargs):
        """ Execute a callback on timer in the main gui thread.

        Parameters
        ----------
        ms : int
            The time to delay, in milliseconds, before executing the
            callable.

        callback : callable
            The callable object to execute at on the timer.

        *args, **kwargs
            Any additional positional and keyword arguments to pass to
            the callback.

        """
        f = lambda: wx.CallLater(ms, callback, *args, **kwargs)
        wx.CallAfter(f)


#: A globally available caller instance. This will be created on demand
#: by the globally available caller functions.
_caller = None


def DeferredCall(callback, *args, **kwargs):
    """ Execute the callback on the main gui thread.

    This is a convenience wrapper around QDeferredCaller.deferredCall.
    This should only be called after the QApplication is created.

    """
    global _caller
    c = _caller
    if c is None:
        c = _caller = wxDeferredCaller()
    c.DeferredCall(callback, *args, **kwargs)


def TimedCall(ms, callback, *args, **kwargs):
    """ Execute a callback on a timer in the main gui thread.

    This is a convenience wrapper around QDeferredCaller.timedCall.
    This should only be called after the QApplication is created.

    """
    global _caller
    c = _caller
    if c is None:
        c = _caller = wxDeferredCaller()
    c.TimedCall(ms, callback, *args, **kwargs)


########NEW FILE########
__FILENAME__ = wx_dock_pane
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
import wx
import wx.lib.newevent

from .wx_container import WxContainer
from .wx_single_widget_sizer import wxSingleWidgetSizer
from .wx_upstream import aui
from .wx_widget import WxWidget


#: A mapping from Enaml dock areas to wx aui dock area enums
_DOCK_AREA_MAP = {
    'top': aui.AUI_DOCK_TOP,
    'right': aui.AUI_DOCK_RIGHT,
    'bottom': aui.AUI_DOCK_BOTTOM,
    'left': aui.AUI_DOCK_LEFT,
}

#: A mapping from wx aui dock area enums to Enaml dock areas.
_DOCK_AREA_INV_MAP = {
    aui.AUI_DOCK_TOP: 'top',
    aui.AUI_DOCK_RIGHT: 'right',
    aui.AUI_DOCK_BOTTOM: 'bottom',
    aui.AUI_DOCK_LEFT: 'left',
}

#: A mapping from Enaml allowed dock areas to wx direction enums.
_ALLOWED_AREAS_MAP = {
    'top': wx.TOP,
    'right': wx.RIGHT,
    'bottom': wx.BOTTOM,
    'left': wx.LEFT,
    'all': wx.ALL,
}

#: A mappint from Enaml orientations to wx orientations.
_ORIENTATION_MAP = {
    'horizontal': wx.HORIZONTAL,
    'vertical': wx.VERTICAL,
}


#: An event emitted when the dock pane is floated.
wxDockPaneFloatedEvent, EVT_DOCK_PANE_FLOATED = wx.lib.newevent.NewEvent()

#: An event emitted when the dock is docked.
wxDockPaneDockedEvent, EVT_DOCK_PANE_DOCKED = wx.lib.newevent.NewEvent()

#: An event emitted when the dock pane is closed.
wxDockPaneClosedEvent, EVT_DOCK_PANE_CLOSED = wx.lib.newevent.NewEvent()


class wxDockPane(wx.Panel):
    """ A wxPanel subclass which adds DockPane features.

    """
    def __init__(self, parent, *args, **kwargs):
        """ Initialize a wxDockPane.

        Parameters
        ----------
        *args, **kwargs
            The positional and keyword arguments needed to initialize
            a wxPanel.

        """
        super(wxDockPane, self).__init__(parent, *args, **kwargs)
        self._is_open = True
        self._title = u''
        self._title_bar_visible = True
        self._title_bar_orientation = wx.HORIZONTAL
        self._closable = True
        self._movable = True
        self._floatable = True
        self._floating = False
        self._dock_area = aui.AUI_DOCK_LEFT
        self._allowed_dock_areas = wx.ALL
        self._dock_widget = None
        self.SetSizer(wxSingleWidgetSizer())

    #--------------------------------------------------------------------------
    # Private API
    #--------------------------------------------------------------------------
    def _FindPaneManager(self):
        """ Find the pane manager for this dock pane.

        Returns
        -------
        result : AuiManager or None
            The AuiManager for this dock pane, or None if not found.

        """
        event = aui.AuiManagerEvent(aui.wxEVT_AUI_FIND_MANAGER)
        self.ProcessEvent(event)
        return event.GetManager()

    def _PaneInfoOperation(self, closure):
        """ A private method which will run the given closure if there
        is a valid pane info object for this dock pane.

        """
        manager = self._FindPaneManager()
        if manager is not None:
            pane = manager.GetPane(self)
            if pane.IsOk():
                closure(pane)
                manager.Update()

    #--------------------------------------------------------------------------
    # Event Handlers
    #--------------------------------------------------------------------------
    def OnClose(self, event):
        """ Handles the parent EVT_AUI_PANE_CLOSE event.

        This event handler is called directly by the parent wxMainWindow
        from its pane close event handler. This handler simply emits the
        EVT_DOCK_PANE_CLOSED event.

        """
        self._is_open = False
        wx.PostEvent(self, wxDockPaneClosedEvent())

    def OnFloated(self, event):
        """ Handles the parent EVT_AUI_PANE_FLOATED event.

        This event handler is called directly by the parent wxMainWindow
        from its pane floated event handler. This handler simply emits
        the EVT_DOCK_PANE_FLOATED event.

        """
        self._floating = True
        wx.PostEvent(self, wxDockPaneFloatedEvent())

    def OnDocked(self, event):
        """ Handles the parent EVT_AUI_PANE_DOCKED event.

        This event handler is called directly by the parent wxMainWindow
        from its pane docked event handler. This handler simply emits
        the EVT_DOCK_PANE_DOCKED event.

        """
        self._floating = False
        self._dock_area = event.GetPane().dock_direction
        wx.PostEvent(self, wxDockPaneDockedEvent())

    #--------------------------------------------------------------------------
    # Public API
    #--------------------------------------------------------------------------
    def MakePaneInfo(self):
        """ Create a new AuiPaneInfo object for this dock pane.

        This is called by the wxMainWindow when it adds this dock pane
        to its internal layout for the first time.

        Returns
        -------
        result : AuiPaneInfo
            An initialized AuiPaneInfo object for this pane.

        """
        info = aui.AuiPaneInfo()

        # Don't allow docking panes as a notebook since that causes
        # issues with finding the proper parent manager on updates
        # and it makes resizing of dock panes abysmally slow.
        info.NotebookDockable(False)

        info.BestSize(self.GetBestSize())
        info.MinSize(self.GetEffectiveMinSize())
        info.Show(self.IsOpen())
        info.Caption(self.GetTitle())
        info.CloseButton(self.GetClosable())
        info.Movable(self.GetMovable())
        info.Floatable(self.GetFloatable())
        info.Direction(self.GetDockArea())

        left = self.GetTitleBarOrientation() == wx.VERTICAL
        info.CaptionVisible(self.GetTitleBarVisible(), left)

        areas = self.GetAllowedDockAreas()
        info.TopDockable(bool(areas & wx.TOP))
        info.RightDockable(bool(areas & wx.RIGHT))
        info.LeftDockable(bool(areas & wx.LEFT))
        info.BottomDockable(bool(areas & wx.BOTTOM))

        if self.GetFloating():
            info.Float()
        else:
            info.Dock()

        return info

    def GetDockWidget(self):
        """ Get the dock widget being managed by this pane.

        Returns
        -------
        result : wxWindow or None
            The wx widget being managed by this dock pane, or None
            if no widget is being managed.

        """
        return self._dock_widget

    def SetDockWidget(self, widget):
        """ Set the dock widget to be managed by the pane.

        Any old dock widget will be removed, but not destroyed.

        Parameters
        ----------
        widget : wxWindow
            The wx widget to use as the dock widget for this pane.

        """
        old_widget = self._dock_widget
        if old_widget:
            old_widget.Hide()
        self._dock_widget = widget
        self.GetSizer().Add(widget)
        self.UpdateSizing()

    def UpdateSizing(self):
        """ Trigger a sizing update of the pane manager.

        """
        def closure(pane):
            pane.MinSize(self.GetBestSize())
        self._PaneInfoOperation(closure)

    def IsOpen(self):
        """ Get whether or not the dock pane is open.

        Returns
        -------
        result : bool
            True if the pane is open, False otherwise.

        """
        return self._is_open

    def Open(self):
        """ Open the dock pane in the main window.

        If the pane is already open, this method is a no-op.

        """
        self._is_open = True
        def closure(pane):
            if not pane.IsShown():
                pane.Show(True)
        self._PaneInfoOperation(closure)

    def Close(self):
        """ Close the dock pane in the main window.

        If the pane is already closed, this method is no-op.

        """
        self._is_open = False
        def closure(pane):
            if pane.IsShown():
                pane.Show(False)
        self._PaneInfoOperation(closure)

    def GetTitle(self):
        """ Get the title for the dock pane.

        Returns
        -------
        result : unicode
            The title of the dock pane.

        """
        return self._title

    def SetTitle(self, title):
        """ Set the title for the dock pane.

        Parameters
        ----------
        title : unicode
            The title to use for the dock pane.

        """
        if self._title != title:
            self._title = title
            def closure(pane):
                pane.Caption(title)
            self._PaneInfoOperation(closure)

    def GetTitleBarVisible(self):
        """ Get the title bar visibility state for the dock pane.

        Returns
        -------
        result : bool
            Whether or not the title bar is visible.

        """
        return self._title_bar_visible

    def SetTitleBarVisible(self, visible):
        """ Set the title bar visibility state for the dock pane.

        Parameters
        ----------
        visible : bool
            Whether or not the title bar should be visible.

        """
        if self._title_bar_visible != visible:
            self._title_bar_visible = visible
            def closure(pane):
                left = self._title_bar_orientation == wx.VERTICAL
                pane.CaptionVisible(visible, left)
            self._PaneInfoOperation(closure)

    def GetTitleBarOrientation(self):
        """ Get the title bar orientation for the dock pane.

        Returns
        -------
        result : int
            The orientation of the title bar. Either wx.HORIZONTAL
            or wx.VERTICAL

        """
        return self._title_bar_orientation

    def SetTitleBarOrientation(self, orientation):
        """ Set the title bar orientation for the dock pane.

        Parameters
        ----------
        result : int
            The orientation of the title bar. Either wx.HORIZONTAL
            or wx.VERTICAL

        """
        if self._title_bar_orientation != orientation:
            self._title_bar_orientation = orientation
            def closure(pane):
                visible = self._title_bar_visible
                left = orientation == wx.VERTICAL
                pane.CaptionVisible(visible, left)
            self._PaneInfoOperation(closure)

    def GetClosable(self):
        """ Get the closable state of the pane.

        Returns
        -------
        result : bool
            Whether or not the pane is closable.

        """
        return self._closable

    def SetClosable(self, closable):
        """ Set the closable state of the pane.

        Parameters
        ----------
        closable : bool
            Whether or not the pane is closable.

        """
        if self._closable != closable:
            self._closable = closable
            def closure(pane):
                pane.CloseButton(closable)
            self._PaneInfoOperation(closure)

    def GetMovable(self):
        """ Get the movable state of the pane.

        Returns
        -------
        result : bool
            Whether or not the pane is movable.

        """
        return self._movable

    def SetMovable(self, movable):
        """ Set the movable state of the pane.

        Parameters
        ----------
        movable : bool
            Whether or not the pane is movable.

        """
        if self._movable != movable:
            self._movable = movable
            def closure(pane):
                pane.Movable(movable)
            self._PaneInfoOperation(closure)

    def GetFloatable(self):
        """ Get the floatable state of the pane.

        Returns
        -------
        result : bool
            Whether or not the pane is floatable.

        """
        return self._floatable

    def SetFloatable(self, floatable):
        """ Set the floatable state of the pane.

        Parameters
        ----------
        floatable : bool
            Whether or not the pane is floatable.

        """
        if self._floatable != floatable:
            self._floatable = floatable
            def closure(pane):
                pane.Floatable(floatable)
            self._PaneInfoOperation(closure)

    def GetFloating(self):
        """ Get the floating state of the pane.

        Returns
        -------
        result : bool
            Whether or not the pane is floating.

        """
        return self._floating

    def SetFloating(self, floating):
        """ Set the floating state of the pane.

        Parameters
        ----------
        floating : bool
            Whether or not the pane should be floating.

        """
        if self._floating != floating:
            self._floating = floating
            def closure(pane):
                if floating:
                    pane.Float()
                else:
                    pane.Dock()
            self._PaneInfoOperation(closure)

    def GetDockArea(self):
        """ Get the current dock area of the pane.

        Returns
        -------
        result : int
            The current dock area of the pane. One of the wx enums
            LEFT, RIGHT, TOP, or BOTTOM.

        """
        return self._dock_area

    def SetDockArea(self, dock_area):
        """ Set the dock area for the pane.

        Parameters
        ----------
        dock_area : int
            The dock area for the pane. One of the wx enums LEFT,
            RIGHT, TOP, or BOTTOM.

        """
        if self._dock_area != dock_area:
            self._dock_area = dock_area
            def closure(pane):
                pane.Direction(dock_area)
            self._PaneInfoOperation(closure)

    def GetAllowedDockAreas(self):
        """ Get the allowed dock areas for the pane.

        Returns
        -------
        result : int
            The allowed dock areas for the pane. One of the wx enums
            LEFT, RIGHT, TOP, BOTTOM, or ALL.

        """
        return self._allowed_dock_areas

    def SetAllowedDockAreas(self, dock_areas):
        """ Set the allowed dock areas for the pane.

        Parameters
        ----------
        dock_areas : int
            The allowed dock areas for the pane. One of the wx enums
            LEFT, RIGHT, TOP, BOTTOM, or ALL.

        """
        if self._allowed_dock_areas != dock_areas:
            self._allowed_dock_areas = dock_areas
            def closure(pane):
                pane.TopDockable(bool(dock_areas & wx.TOP))
                pane.RightDockable(bool(dock_areas & wx.RIGHT))
                pane.LeftDockable(bool(dock_areas & wx.LEFT))
                pane.BottomDockable(bool(dock_areas & wx.BOTTOM))
            self._PaneInfoOperation(closure)


class WxDockPane(WxWidget):
    """ A Wx implementation of an Enaml DockPane.

    """
    #--------------------------------------------------------------------------
    # Setup Methods
    #--------------------------------------------------------------------------
    def create_widget(self, parent, tree):
        """ Create the underlying wxDockPane widget.

        """
        return wxDockPane(parent)

    def create(self, tree):
        """ Create and initialize the dock pane control.

        """
        super(WxDockPane, self).create(tree)
        self.set_title(tree['title'])
        self.set_title_bar_visible(tree['title_bar_visible'])
        self.set_title_bar_orientation(tree['title_bar_orientation'])
        self.set_closable(tree['closable'])
        self.set_movable(tree['movable'])
        self.set_floatable(tree['floatable'])
        self.set_floating(tree['floating'])
        self.set_dock_area(tree['dock_area'])
        self.set_allowed_dock_areas(tree['allowed_dock_areas'])
        widget = self.widget()
        widget.Bind(EVT_DOCK_PANE_FLOATED, self.on_dock_pane_floated)
        widget.Bind(EVT_DOCK_PANE_DOCKED, self.on_dock_pane_docked)
        widget.Bind(EVT_DOCK_PANE_CLOSED, self.on_dock_pane_closed)

    def init_layout(self):
        """ Handle the layout initialization for the dock pane.

        """
        super(WxDockPane, self).init_layout()
        self.widget().SetDockWidget(self.dock_widget())

    #--------------------------------------------------------------------------
    # Utility Methods
    #--------------------------------------------------------------------------
    def dock_widget(self):
        """ Find and return the dock widget child for this widget.

        Returns
        -------
        result : wxWindow or None
            The dock widget defined for this widget, or None if one is
            not defined.

        """
        widget = None
        for child in self.children():
            if isinstance(child, WxContainer):
                widget = child.widget()
        return widget

    #--------------------------------------------------------------------------
    # Child Events
    #--------------------------------------------------------------------------
    def child_removed(self, child):
        """ Handle the child removed event for a WxDockPane.

        """
        if isinstance(child, WxContainer):
            self.widget().SetDockWidget(self.dock_widget())

    def child_added(self, child):
        """ Handle the child added event for a WxDockPane.

        """
        if isinstance(child, WxContainer):
            self.widget().SetDockWidget(self.dock_widget())

    #--------------------------------------------------------------------------
    # Event Handlers
    #--------------------------------------------------------------------------
    def on_dock_pane_closed(self, event):
        """ The event handler for the EVT_DOCK_PANE_CLOSED event.

        """
        self.send_action('closed', {})

    def on_dock_pane_floated(self, event):
        """ The event handler for the EVT_DOCK_PANE_FLOATED event.

        """
        self.send_action('floated', {})

    def on_dock_pane_docked(self, event):
        """ The event handler for the EVT_DOCK_PANE_AREA event.

        """
        area = self.widget().GetDockArea()
        content = {'dock_area': _DOCK_AREA_INV_MAP[area]}
        self.send_action('docked', content)

    #--------------------------------------------------------------------------
    # Message Handling
    #--------------------------------------------------------------------------
    def on_action_set_title(self, content):
        """ Handle the 'set_title' action from the Enaml widget.

        """
        self.set_title(content['title'])

    def on_action_set_title_bar_visible(self, content):
        """ Handle the 'set_title_bar_visible' action from the Enaml
        widget.

        """
        self.set_title_bar_visible(content['title_bar_visible'])

    def on_action_set_title_bar_orientation(self, content):
        """ Handle the 'set_title_bar_orientation' action from the
        Enaml widget.

        """
        self.set_title_bar_orientation(content['title_bar_orientation'])

    def on_action_set_closable(self, content):
        """ Handle the 'set_closable' action from the Enaml widget.

        """
        self.set_closable(content['closable'])

    def on_action_set_movable(self, content):
        """ Handle the 'set_movable' action from the Enaml widget.

        """
        self.set_movable(content['movable'])

    def on_action_set_floatable(self, content):
        """ Handle the 'set_floatable' action from the Enaml widget.

        """
        self.set_floatable(content['floatable'])

    def on_action_set_floating(self, content):
        """ Handle the 'set_floating' action from the Enaml widget.

        """
        self.set_floating(content['floating'])

    def on_action_set_dock_area(self, content):
        """ Handle the 'set_dock_area' action from the Enaml widget.

        """
        self.set_dock_area(content['dock_area'])

    def on_action_set_allowed_dock_areas(self, content):
        """ Handle the 'set_allowed_dock_areas' action from the Enaml
        widget.

        """
        self.set_allowed_dock_areas(content['allowed_dock_areas'])

    def on_action_open(self, content):
        """ Handle the 'open' action from the Enaml widget.

        """
        self.widget().Open()

    def on_action_close(self, content):
        """ Handle the 'close' action from the Enaml widget.

        """
        self.widget().Close()

    #--------------------------------------------------------------------------
    # Widget Update Methods
    #--------------------------------------------------------------------------
    def set_visible(self, visible):
        """ An overridden visibility setter which to opens|closes the
        dock pane.

        """
        widget = self.widget()
        if visible:
            widget.Open()
        else:
            widget.Close()

    def set_title(self, title):
        """ Set the title on the underlying widget.

        """
        self.widget().SetTitle(title)

    def set_title_bar_visible(self, visible):
        """ Set the title bar visibility of the underlying widget.

        """
        self.widget().SetTitleBarVisible(visible)

    def set_title_bar_orientation(self, orientation):
        """ Set the title bar orientation of the underyling widget.

        """
        self.widget().SetTitleBarOrientation(_ORIENTATION_MAP[orientation])

    def set_closable(self, closable):
        """ Set the closable state on the underlying widget.

        """
        self.widget().SetClosable(closable)

    def set_movable(self, movable):
        """ Set the movable state on the underlying widget.

        """
        self.widget().SetMovable(movable)

    def set_floatable(self, floatable):
        """ Set the floatable state on the underlying widget.

        """
        self.widget().SetFloatable(floatable)

    def set_floating(self, floating):
        """ Set the floating staet on the underlying widget.

        """
        self.widget().SetFloating(floating)

    def set_dock_area(self, dock_area):
        """ Set the dock area on the underyling widget.

        """
        self.widget().SetDockArea(_DOCK_AREA_MAP[dock_area])

    def set_allowed_dock_areas(self, dock_areas):
        """ Set the allowed dock areas on the underlying widget.

        """
        wx_areas = 0
        for area in dock_areas:
            wx_areas |= _ALLOWED_AREAS_MAP[area]
        self.widget().SetAllowedDockAreas(wx_areas)


########NEW FILE########
__FILENAME__ = wx_enable_canvas
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
import wx

from .wx_control import WxControl
from .wx_single_widget_sizer import wxSingleWidgetSizer

from enable.api import Window as EnableWindow


class WxEnableCanvas(WxControl):
    """ A Wx implementation of an Enaml EnableCanvas.

    """
    #: Internal storage for the enable component.
    _component = None

    #: Internal storage for the enable window.
    _window = None

    #--------------------------------------------------------------------------
    # Setup Methods
    #--------------------------------------------------------------------------
    def create_widget(self, parent, tree):
        """ Create the underlying widget.

        """
        widget = wx.Panel(parent)
        sizer = wxSingleWidgetSizer()
        widget.SetSizer(sizer)
        return widget

    def create(self, tree):
        """ Create and initialize the underlying widget.

        """
        super(WxEnableCanvas, self).create(tree)
        self._component = tree['component']

    def init_layout(self):
        """ Initialize the layout of the underlying widget.

        """
        super(WxEnableCanvas, self).init_layout()
        self.refresh_enable_widget()

    #--------------------------------------------------------------------------
    # Message Handlers
    #--------------------------------------------------------------------------
    def on_action_set_component(self, content):
        """ Handle the 'set_component' action from the Enaml widget.

        """
        self._component = content['component']
        self.refresh_enable_widget()

    #--------------------------------------------------------------------------
    # Widget Update Methods
    #--------------------------------------------------------------------------
    def refresh_enable_widget(self):
        """ Create the enable widget and update the underlying control.

        """
        widget = self.widget()
        widget.Freeze()
        component = self._component
        if component is not None:
            self._window = EnableWindow(widget, component=component)
            enable_widget = self._window.control
        else:
            self._window = None
            enable_widget = None
        widget.GetSizer().Add(enable_widget)
        widget.Thaw()


########NEW FILE########
__FILENAME__ = wx_factories
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------\
def action_factory():
    from .wx_action import WxAction
    return WxAction


def action_group_factory():
    from .wx_action_group import WxActionGroup
    return WxActionGroup


def calendar_factory():
    from .wx_calendar import WxCalendar
    return WxCalendar


def check_box_factory():
    from .wx_check_box import WxCheckBox
    return WxCheckBox


def combo_box_factory():
    from .wx_combo_box import WxComboBox
    return WxComboBox


def container_factory():
    from .wx_container import WxContainer
    return WxContainer


def date_selector_factory():
    from .wx_date_selector import WxDateSelector
    return WxDateSelector


# def datetime_selector_factory():
#     from .wx_datetime_selector import WxDatetimeSelector
#     return WxDatetimeSelector


def dock_pane_factory():
    from .wx_dock_pane import WxDockPane
    return WxDockPane


def enable_canvas_factory():
    from .wx_enable_canvas import WxEnableCanvas
    return WxEnableCanvas


def field_factory():
    from .wx_field import WxField
    return WxField


def form_factory():
    from .wx_form import WxForm
    return WxForm


def group_box_factory():
    from .wx_group_box import WxGroupBox
    return WxGroupBox


def html_factory():
    from .wx_html import WxHtml
    return WxHtml


# def image_view_factory():
#     from .wx_image_view import WxImageView
#     return WxImageView


def label_factory():
    from .wx_label import WxLabel
    return WxLabel


def main_window_factory():
    from .wx_main_window import WxMainWindow
    return WxMainWindow


def menu_factory():
    from .wx_menu import WxMenu
    return WxMenu


def menu_bar_factory():
    from .wx_menu_bar import WxMenuBar
    return WxMenuBar


def mpl_canvas_factory():
    from .wx_mpl_canvas import WxMPLCanvas
    return WxMPLCanvas


def multiline_field_factory():
    from wx_multiline_field import WxMultilineField
    return WxMultilineField


def notebook_factory():
    from .wx_notebook import WxNotebook
    return WxNotebook


def page_factory():
    from .wx_page import WxPage
    return WxPage


def push_button_factory():
    from .wx_push_button import WxPushButton
    return WxPushButton


def progress_bar_factory():
    from .wx_progress_bar import WxProgressBar
    return WxProgressBar


def radio_button_factory():
    from .wx_radio_button import WxRadioButton
    return WxRadioButton


def scroll_area_factory():
    from .wx_scroll_area import WxScrollArea
    return WxScrollArea


def slider_factory():
    from .wx_slider import WxSlider
    return WxSlider


def spin_box_factory():
    from .wx_spin_box import WxSpinBox
    return WxSpinBox


def split_item_factory():
    from .wx_split_item import WxSplitItem
    return WxSplitItem


def splitter_factory():
    from .wx_splitter import WxSplitter
    return WxSplitter


# def text_editor_factory():
#     from .wx_text_editor import WxTextEditor
#     return WxTextEditor


def tool_bar_factory():
    from .wx_tool_bar import WxToolBar
    return WxToolBar


def traits_item_factory():
    from .wx_traits_item import WxTraitsItem
    return WxTraitsItem


def window_factory():
    from .wx_window import WxWindow
    return WxWindow


def register_default():
    from .wx_widget_registry import WxWidgetRegistry
    reg = WxWidgetRegistry.register
    register = lambda name, factory: reg(name, factory, 'default')
    register('Action', action_factory)
    register('ActionGroup', action_group_factory)
    register('Calendar', calendar_factory)
    register('CheckBox', check_box_factory)
    register('ComboBox', combo_box_factory)
    register('Container', container_factory)
    register('DateSelector', date_selector_factory)
    register('DockPane', dock_pane_factory)
    register('EnableCanvas', enable_canvas_factory)
    register('Field', field_factory)
    register('Form', form_factory)
    register('GroupBox', group_box_factory)
    register('Html', html_factory)
    register('Label', label_factory)
    register('MainWindow', main_window_factory)
    register('Menu', menu_factory)
    register('MenuBar', menu_bar_factory)
    register('MPLCanvas', mpl_canvas_factory)
    register('MultilineField', multiline_field_factory)
    register('Notebook', notebook_factory)
    register('Page', page_factory)
    register('PushButton', push_button_factory)
    register('ProgressBar', progress_bar_factory)
    register('RadioButton', radio_button_factory)
    register('ScrollArea', scroll_area_factory)
    register('Slider', slider_factory)
    register('SpinBox', spin_box_factory)
    register('SplitItem', split_item_factory)
    register('Splitter', splitter_factory)
    register('ToolBar', tool_bar_factory)
    register('TraitsItem', traits_item_factory)
    register('Window', window_factory)


########NEW FILE########
__FILENAME__ = wx_field
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
import wx

from enaml.validation.client_validators import null_validator, make_validator

from .wx_control import WxControl


class wxLineEdit(wx.TextCtrl):
    """ A wx.TextCtrl subclass which is similar to a QLineEdit in terms
    of features and behavior.

    """
    def __init__(self, *args, **kwargs):
        """ Initialize a wxLineEdit.

        Parameters
        ----------
        *args, **kwargs
            The positional and keyword arguments to initialize a
            wx.TextCtrl.

        """
        super(wxLineEdit, self).__init__(*args, **kwargs)
        self._placeholder_text = ''
        self._placeholder_active = False
        self._user_fgcolor = None
        self.Bind(wx.EVT_KILL_FOCUS, self.OnKillFocus)
        self.Bind(wx.EVT_SET_FOCUS, self.OnSetFocus)

    #--------------------------------------------------------------------------
    # Private API
    #--------------------------------------------------------------------------
    def _UpdatePlaceholderDisplay(self):
        """ Updates the display with the placeholder text if no text
        is currently set for the control.

        """
        if not self.GetValue() and self._placeholder_text:
            self.ChangeValue(self._placeholder_text)
            color = wx.Color(95, 95, 95)
            super(wxLineEdit, self).SetForegroundColour(color)
            self._placeholder_active = True

    def _RemovePlaceholderDisplay(self):
        """ Removes the placeholder text if it is currently active.

        """
        if self._placeholder_active:
            self.ChangeValue('')
            color = self._user_fgcolor or wx.Color(0, 0, 0)
            super(wxLineEdit, self).SetForegroundColour(color)
            self._placeholder_active = False

    #--------------------------------------------------------------------------
    # Event Handlers
    #--------------------------------------------------------------------------
    def OnKillFocus(self, event):
        """ Refreshes the placeholder display when the control loses
        focus.

        """
        self._UpdatePlaceholderDisplay()
        event.Skip()

    def OnSetFocus(self, event):
        """ Removes the placeholder display when the control receives
        focus.

        """
        self._RemovePlaceholderDisplay()
        event.Skip()

    #--------------------------------------------------------------------------
    # Public API
    #--------------------------------------------------------------------------
    def GetBestSize(self):
        """ Overridden best size method to add 44 pixels in width to the
        field. This makes Wx consistent with Qt.

        """
        size = super(wxLineEdit, self).GetBestSize()
        return wx.Size(size.GetWidth() + 44, size.GetHeight())

    def SetPlaceHolderText(self, placeholder_text):
        """ Sets the placeholder text to the given value. Pass an empty
        string to turn off the placeholder text functionality.

        """
        self._placeholder_text = placeholder_text
        self._UpdatePlaceholderDisplay()

    def GetPlaceHolderText(self):
        """ Returns the placeholder text for this control.

        """
        return self._placeholder_text

    def ChangeValue(self, text):
        """ Overridden method which moves the insertion point to the end
        of the field when changing the text value. This causes the field
        to behave like Qt.

        """
        super(wxLineEdit, self).ChangeValue(text)
        self.SetInsertionPoint(len(text))

    def GetValue(self):
        """ Returns string value in the control, or an empty string if
        the placeholder text is active.

        """
        if self._placeholder_active:
            return ''
        return super(wxLineEdit, self).GetValue()

    def SetForegroundColour(self, wxColor, force=False):
        """ Sets the foreground color of the field. If the placeholder
        text is being shown, `force` must be True in order to override
        the placeholder text color.

        """
        self._user_fgcolor = wxColor
        if self._placeholder_active and not force:
            return
        super(wxLineEdit, self).SetForegroundColour(wxColor)


class WxField(WxControl):
    """ A Wx implementation of an Enaml Field.

    """
    #: The client side validator function for the field.
    _validator = null_validator

    #: The validator message for the validator.
    _validator_message = ''

    #: The list of submit triggers for when to submit a text change.
    _submit_triggers = []

    #: The last text value submitted to or sent from the server.
    _last_value = None

    #: A flag indicating whether the current field is invalid.
    _is_error_state = False

    #--------------------------------------------------------------------------
    # Setup Methods
    #--------------------------------------------------------------------------
    def create_widget(self, parent, tree):
        """ Creates the underlying wxLineEdit.

        """
        # We have to do a bit of initialization in the create method
        # since wx requires the style of certain things to be set at
        # the point of instantiation
        style = wx.TE_PROCESS_ENTER
        if tree['read_only']:
            style |= wx.TE_READONLY
        else:
            style &= ~wx.TE_READONLY
        echo_mode = tree['echo_mode']
        if echo_mode == 'normal':
            style &= ~wx.TE_PASSWORD
        else:
            style |= wx.TE_PASSWORD
        read_only = tree['read_only']
        if read_only:
            style |= wx.TE_READONLY
        else:
            style &= ~wx.TE_READONLY
        return wxLineEdit(parent, style=style)

    def create(self, tree):
        """ Create and initialize the wx field control.

        """
        super(WxField, self).create(tree)
        self.set_text(tree['text'])
        self.set_validator(tree['validator'])
        self.set_submit_triggers(tree['submit_triggers'])
        self.set_placeholder(tree['placeholder'])
        self.set_max_length(tree['max_length'])
        widget = self.widget()
        widget.Bind(wx.EVT_KILL_FOCUS, self.on_lost_focus)
        widget.Bind(wx.EVT_TEXT_ENTER, self.on_return_pressed)
        widget.Bind(wx.EVT_TEXT, self.on_text_edited)

    #--------------------------------------------------------------------------
    # Private API
    #--------------------------------------------------------------------------
    def _submit_text(self, text):
        """ Submit the given text as an update to the server widget.

        Parameters
        ----------
        text : unicode
            The unicode text to send to the server widget.

        """
        content = {'text': text}
        self.send_action('submit_text', content)

    def _validate_and_submit(self):
        """ Validate the current text in the control, and submit it to
        the server widget if it's valid.

        """
        text = self.widget().GetValue()
        if text != self._last_value:
            if self._validator(text):
                self._clear_error_style()
                self._submit_text(text)
                self._last_value = text
            else:
                self._set_error_style()

    def _set_error_style(self):
        # A temporary hack until styles are implemented
        self._is_error_state = True
        # XXX attempting to change the field style here is futile

    def _clear_error_style(self):
        # A temporary hack until styles are implemented
        self._is_error_state = False
        # XXX attempting to change the field style here is futile

    #--------------------------------------------------------------------------
    # Event Handling
    #--------------------------------------------------------------------------
    def on_lost_focus(self, event):
        """ The event handler for EVT_KILL_FOCUS event.

        """
        event.Skip()
        if 'lost_focus' in self._submit_triggers:
            self._validate_and_submit()

    def on_return_pressed(self, event):
        """ The event handler for EVT_TEXT_ENTER event.

        """
        # don't skip or Wx triggers the system beep, grrrrrrr.....
        #event.Skip()
        if 'return_pressed' in self._submit_triggers:
            self._validate_and_submit()

    def on_text_edited(self, event):
        """ The event handler for EVT_TEXT event.

        """
        event.Skip()
        if 'text_edited' in self._submit_triggers:
            self._validate_and_submit()

    #--------------------------------------------------------------------------
    # Message Handling
    #--------------------------------------------------------------------------
    def on_action_set_text(self, content):
        """ Handle the 'set_text' action from the Enaml widget.

        """
        self.set_text(content['text'])

    def on_action_set_validator(self, content):
        """ Handle the 'set_validator' action from the Enaml widget.

        """
        self.set_validator(content['validator'])

    def on_action_set_submit_triggers(self, content):
        """ Handle the 'set_submit_triggers' action from the Enaml
        widget.

        """
        self.set_submit_triggers(content['sumbit_triggers'])

    def on_action_set_placeholder(self, content):
        """ Hanlde the 'set_placeholder' action from the Enaml widget.

        """
        self.set_placeholder(content['placeholder'])

    def on_action_set_echo_mode(self, content):
        """ Handle the 'set_echo_mode' action from the Enaml widget.

        """
        self.set_echo_mode(content['echo_mode'])

    def on_action_set_max_length(self, content):
        """ Handle the 'set_max_length' action from the Enaml widget.

        """
        self.set_max_length(content['max_length'])

    def on_action_set_read_only(self, content):
        """ Handle the 'set_read_only' action from the Enaml widget.

        """
        self.set_read_only(content['read_only'])

    def on_action_invalid_text(self, content):
        """ Handle the 'invalid_text' action from the Enaml widget.

        """
        if self.widget().GetValue() == content['text']:
            self._set_error_style()

    #--------------------------------------------------------------------------
    # Widget Update Methods
    #--------------------------------------------------------------------------
    def set_text(self, text):
        """ Updates the text control with the given unicode text.

        """
        self.widget().ChangeValue(text)
        self._last_value = text
        self._clear_error_style()

    def set_validator(self, validator):
        """ Sets the validator for the control.

        """
        if validator is None:
            self._validator = null_validator
            self._validator_message = ''
        else:
            self._validator = make_validator(validator)
            self._validator_message = validator.get('message', '')

    def set_submit_triggers(self, triggers):
        """ Set the submit triggers for the underlying widget.

        """
        self._submit_triggers = triggers

    def set_placeholder(self, placeholder):
        """ Sets the placeholder text in the widget.

        """
        self.widget().SetPlaceHolderText(placeholder)

    def set_echo_mode(self, echo_mode):
        """ Sets the echo mode of the wiget.
        """
        # Wx cannot change the echo mode dynamically. It requires
        # creating a brand-new control, so we just ignore the change.
        pass

    def set_max_length(self, max_length):
        """ Set the max length of the control to max_length. If the max
        length is <= 0 or > 32767 then the control will be set to hold
        32kb of text.

        """
        if (max_length <= 0) or (max_length > 32767):
            max_length = 32767
        self.widget().SetMaxLength(max_length)

    def set_read_only(self, read_only):
        """ Sets the read only state of the widget.

        """
        # Wx cannot change the read only state dynamically. It requires
        # creating a brand-new control, so we just ignore the change.
        pass


########NEW FILE########
__FILENAME__ = wx_form
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from .wx_container import WxContainer


class WxForm(WxContainer):
    """ A Wx implementation of an Enaml Form.

    """
    # Currently, the WxContainer superclass is a sufficient implementation.
    pass


########NEW FILE########
__FILENAME__ = wx_group_box
#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
import wx

from .wx_container import WxContainer, wxContainer


WX_ALIGNMENTS = {
    'left': wx.ALIGN_LEFT,
    'center': wx.ALIGN_CENTER,
    'right': wx.ALIGN_RIGHT,
}


class wxGroupBox(wxContainer):
    """ A wxContainer sublcass that implements GroupBox functionality.

    """
    def __init__(self, *args, **kwargs):
        """ Initialize a wxGroupBox.

        Parameters
        ----------
        *args, **kwargs
            The positional and keyword arguments to initialize a
            wxContainer.

        """
        super(wxGroupBox, self).__init__(*args, **kwargs)
        self._title = ''
        self._border = wx.StaticBox(self)
        self._line = wx.StaticLine(self)
        self._label = wx.StaticText(self)
        self._label.Raise()
        self._label_size = self._label.GetBestSize()
        self._title_alignment = wx.ALIGN_LEFT
        self._flat = False
        # Set the panel to double buffered or suffer terrible
        # rendering artifacts
        self.SetDoubleBuffered(True)

    #--------------------------------------------------------------------------
    # Public API
    #--------------------------------------------------------------------------
    def GetAlignment(self):
        """ Return the wx alignment flag for the current alignment
        of the group box title.

        """
        return self._title_alignment

    def SetAlignment(self, alignment):
        """ Set the alignment of the title of the group box. Should
        be one of wx.ALIGN_LEFT, wx.ALIGN_RIGHT, wx.ALIGN_CENTER.

        """
        self._title_alignment = alignment
        self._update_layout()

    def GetFlat(self):
        """ Returns a boolean indicating whether the group box is using
        a flat style.

        """
        return self._flat

    def SetFlat(self, flat):
        """ Set whether or not the group box should be displayed using
        a flat style.

        """
        self._flat = flat
        if flat:
            self._border.Show(False)
            self._line.Show(True)
        else:
            self._border.Show(True)
            self._line.Show(False)
        self._update_layout()

    def GetTitle(self):
        """ Return the current title text in the group box.

        """
        # Undo the hack applied in SetTitle(...)
        title = self._title
        if title:
            title = title[1:-1]
        return title

    def SetTitle(self, title):
        """ Set the current title text in the group box.

        """
        # A bit of a hack to give us a little padding around the label
        if title:
            title = ' %s ' % title
        self._title = title
        self._label.SetLabel(title)
        self._label_size = self._label.GetBestSize()
        if not title:
            self._label.Show(False)
        else:
            self._label.Show(True)
        self._update_layout()

    def SetDimensions(self, x, y, width, height):
        """ Overridden parent class method to synchronize the group
        box decorations.

        """
        super(wxGroupBox, self).SetDimensions(x, y, width, height)
        self._update_layout()

    def SetSize(self, size):
        """ Overridden parent class method to synchronize the group
        box decorations.

        """
        super(wxGroupBox, self).SetSize(size)
        self._update_layout()

    def GetContentsMargins(self):
        """ Get the contents margins for the group box.

        These margins are computed empirically so that they look similar
        to the margins provided by Qt on Windows.

        Returns
        -------
        result : tuple
            The top, right, bottom, and left margin values.

        """
        label = self._label
        height = label.GetCharHeight()
        if not label.IsShown():
            height /= 2
        return (height, 1, 1, 1)

    #--------------------------------------------------------------------------
    # Private API
    #--------------------------------------------------------------------------
    def _update_layout(self):
        """ Synchronizes the drawing of the group box decorations with
        the panel.

        """
        if self._flat:
            self._update_line_geometry()
        else:
            self._update_border_geometry()
        self._update_title_geometry()
        self.Refresh()

    def _update_border_geometry(self):
        """ Updates the geometry of the border.

        """
        width, height = self.GetSizeTuple()
        self._border.SetSizeWH(width, height)

    def _update_line_geometry(self):
        """ Updates the geometry of the line.

        """
        y = self._label_size.GetHeight() / 2
        width, _ = self.GetSizeTuple()
        self._line.SetDimensions(0, y, width, 2)

    def _update_title_geometry(self):
        """ Updates the geometry of the title.

        """
        label = self._label
        flat = self._flat
        align = self._title_alignment
        text_width, _ = self._label_size
        width, _ = self.GetSizeTuple()
        # These offsets are determined empirically to look similar
        # in form to Qt on Windows
        if align == wx.ALIGN_LEFT:
            x = 0 if flat else 8
            label.Move((x, 0))
        elif align == wx.ALIGN_RIGHT:
            right = width
            right -= 0 if flat else 8
            x = right - text_width
            label.Move((x, 0))
        elif align == wx.ALIGN_CENTER:
            label.CenterOnParent(dir=wx.HORIZONTAL)
        else:
            raise ValueError('Invalid title alignment %s' % align)


class WxGroupBox(WxContainer):
    """ A Wx implementation of an Enaml GroupBox.

    """
    #--------------------------------------------------------------------------
    # Setup methods
    #--------------------------------------------------------------------------
    def create_widget(self, parent, tree):
        """ Creates the underlying custom wxGroupBox control.

        """
        return wxGroupBox(parent)

    def create(self, tree):
        """ Create and initialize the group box control.

        """
        super(WxGroupBox, self).create(tree)
        self.set_title(tree['title'])
        self.set_flat(tree['flat'])
        self.set_title_align(tree['title_align'])

    #--------------------------------------------------------------------------
    # Layout Handling
    #--------------------------------------------------------------------------
    def contents_margins(self):
        """ Get the current contents margins for the group box.

        """
        return self.widget().GetContentsMargins()

    #--------------------------------------------------------------------------
    # Message Handlers
    #--------------------------------------------------------------------------
    def on_action_set_title(self, content):
        """ Handle the 'set_title' action from the Enaml widget.

        """
        widget = self.widget()
        old_margins = widget.GetContentsMargins()
        self.set_title(content['title'])
        new_margins = widget.GetContentsMargins()
        if old_margins != new_margins:
            self.contents_margins_updated()

    def on_action_set_title_align(self, content):
        """ Handle the 'set_title_align' action from the Enaml widget.

        """
        self.set_title_align(content['title_align'])

    def on_action_set_flat(self, content):
        """ Handle the 'set_flat' action from the Enaml widget.

        """
        self.set_flat(content['flat'])

    #--------------------------------------------------------------------------
    # Widget Update methods
    #--------------------------------------------------------------------------
    def set_title(self, title):
        """ Update the title of the group box.

        """
        self.widget().SetTitle(title)

    def set_flat(self, flat):
        """ Updates the flattened appearance of the group box.

        """
        self.widget().SetFlat(flat)

    def set_title_align(self, align):
        """ Updates the alignment of the title of the group box.

        """
        wx_align = WX_ALIGNMENTS[align]
        self.widget().SetAlignment(wx_align)


########NEW FILE########
__FILENAME__ = wx_html
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
import wx.html

from .wx_control import WxControl


class wxProperHtmlWindow(wx.html.HtmlWindow):
    """ A custom wx Html window that returns a non-braindead best size.

    """
    _best_size = wx.Size(256, 192)

    def GetBestSize(self):
        """ Returns the best size for the html window.

        """
        return self._best_size


class WxHtml(WxControl):
    """ A Wx implementation of the Enaml Html widget.

    """
    #--------------------------------------------------------------------------
    # Setup Methods
    #--------------------------------------------------------------------------
    def create_widget(self, parent, tree):
        """ Create the underlying html widget.

        """
        return wxProperHtmlWindow(parent)

    def create(self, tree):
        """ Create and initialize the html control.

        """
        super(WxHtml, self).create(tree)
        self.set_source(tree['source'])

    #--------------------------------------------------------------------------
    # Message Handlers
    #--------------------------------------------------------------------------
    def on_action_set_source(self, content):
        """ Handle the 'set_source' action from the Enaml widget.

        """
        self.set_source(content['source'])

    #--------------------------------------------------------------------------
    # Widget Update Methods
    #--------------------------------------------------------------------------
    def set_source(self, source):
        """ Set the source of the html widget

        """
        self.widget().SetPage(source)


########NEW FILE########
__FILENAME__ = wx_label
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
import wx

from .wx_control import WxControl


ALIGN_MAP = {
    'left': wx.ALIGN_LEFT,
    'right': wx.ALIGN_RIGHT,
    'center': wx.ALIGN_CENTER,
    'justify': wx.ALIGN_LEFT, # wx doesn't support justification
}


ALIGN_MASK = wx.ALIGN_LEFT | wx.ALIGN_RIGHT | wx.ALIGN_CENTER


class WxLabel(WxControl):
    """ A Wx implementation of an Enaml Label.

    """
    #--------------------------------------------------------------------------
    # Setup Methods
    #--------------------------------------------------------------------------
    def create_widget(self, parent, tree):
        """ Create the underlying wx.StaticText widget.

        """
        return wx.StaticText(parent)

    def create(self, tree):
        """ Create and initialize the label control.

        """
        super(WxLabel, self).create(tree)
        self.set_text(tree['text'])
        self.set_align(tree['align'])
        self.set_vertical_align(tree['vertical_align'])

    #--------------------------------------------------------------------------
    # Message Handlers
    #--------------------------------------------------------------------------
    def on_action_set_text(self, content):
        """ Handle the 'set_text' action from the Enaml widget.

        """
        widget = self.widget()
        old_hint = widget.GetBestSize()
        self.set_text(content['text'])
        new_hint = widget.GetBestSize()
        if old_hint != new_hint:
            self.size_hint_updated()

    def on_action_set_align(self, content):
        """ Handle the 'set_align' action from the Enaml widget.

        """
        self.set_align(content['align'])
        self.widget().Refresh()

    def on_action_set_vertical_align(self, content):
        """ Handle the 'set_vertical_align' action from the Enaml widget.

        """
        self.set_vertical_align(content['vertical_align'])

    #--------------------------------------------------------------------------
    # Widget Update Methods
    #--------------------------------------------------------------------------
    def set_text(self, text):
        """ Set the text in the underlying widget.

        """
        self.widget().SetLabel(text)

    def set_align(self, align):
        """ Set the alignment of the text in the underlying widget.

        """
        widget = self.widget()
        style = widget.GetWindowStyle()
        style &= ~ALIGN_MASK
        style |= ALIGN_MAP[align]
        widget.SetWindowStyle(style)

    def set_vertical_align(self, align):
        """ Set the vertical alignment of the text in the underlying
        widget.

        """
        # Wx does not support vertical alignment.
        pass


########NEW FILE########
__FILENAME__ = wx_layout_request
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from wx.lib.newevent import NewCommandEvent


#: A custom command event that can be posted to request a layout
#: when a widget's geometry has changed. On Qt, this type of event
#: is posted and handled automatically. This fills that gap.
wxEvtLayoutRequested, EVT_COMMAND_LAYOUT_REQUESTED = NewCommandEvent()


########NEW FILE########
__FILENAME__ = wx_main_window
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
import wx

from .wx_action import wxAction
from .wx_container import WxContainer
from .wx_dock_pane import WxDockPane
from .wx_menu_bar import WxMenuBar
from .wx_tool_bar import WxToolBar
from .wx_upstream import aui
from .wx_window import WxWindow


class wxToolBarContainer(wx.Panel):
    """ A simple wx.Panel that arranges the tool bars for a main window.

    """
    # The Wx AuiToolBar is terrible and the aui code which lays out
    # the tool bars is equally as bad. Unless we want to rewrite the
    # entire aui libary to do docking properly, we have to accept that
    # docking toolbars on wx are a no-go. That said, if the user defined
    # multiple tool bars for their main window, it would be bad to only
    # show one of them, which is what we would get if we had the wx.Frame
    # manage the tool bars directly (since it only supports a single tool
    # bar). Instead, we put all of the tool bars in a vertical sizer and
    # stick the entire thing at the top of the main window layout and
    # forbid it from being moved around. If better docking support is
    # desired, the user would be better off with Qt.
    def __init__(self, *args, **kwargs):
        """ Initialize a wxToolBarContainer.

        Parameters
        ----------
        *args, **kwargs
            The positional and keyword arguments to initialize a
            wx.Panel.

        """
        super(wxToolBarContainer, self).__init__(*args, **kwargs)
        self._tool_bars = []
        self.SetSizer(wx.BoxSizer(wx.VERTICAL))
        self.SetDoubleBuffered(True)

    def AddToolBar(self, tool_bar):
        """ Add a tool bar to the container.

        If the tool bar already exists in this container, this will be
        a no-op. The tool bar will be reparented to this container.

        Parameters
        ----------
        tool_bar : wxToolBar
            The wxToolBar instance to add to this container.

        """
        tool_bars = self._tool_bars
        if tool_bar not in tool_bars:
            tool_bars.append(tool_bar)
            tool_bar.Reparent(self)
            self.GetSizer().Add(tool_bar, 0, wx.EXPAND)

    def RemoveToolBar(self, tool_bar):
        """ Remove a tool bar from the container.

        If the tool bar already exists in this container, this will be
        a no-op.

        Parameters
        ----------
        tool_bar : wxToolBar
            The wxToolBar instance to remove from the container.

        """
        tool_bars = self._tool_bars
        if tool_bar in tool_bars:
            tool_bars.remove(tool_bar)
            self.GetSizer().Detach(tool_bar)


class wxMainWindow(wx.Frame):
    """ A wx.Frame subclass which adds MainWindow functionality.

    """
    def __init__(self, *args, **kwargs):
        """ Initialize a wxMainWindow.

        Parameters
        ----------
        *args, **kwargs
            The positional and keyword arguments necessary to initialize
            a wx.Frame.

        """
        super(wxMainWindow, self).__init__(*args, **kwargs)
        flags = (
            aui.AUI_MGR_DEFAULT | aui.AUI_MGR_LIVE_RESIZE |
            aui.AUI_MGR_USE_NATIVE_MINIFRAMES
        )
        self._manager = aui.AuiManager(self, agwFlags=flags)
        self._central_widget = None
        self._tool_bars = None
        self._batch = False
        self.Bind(wx.EVT_MENU, self.OnMenu)
        self.Bind(wx.EVT_CLOSE, self.OnClose)
        self.Bind(aui.EVT_AUI_PANE_CLOSE, self.OnPaneClose)
        self.Bind(aui.EVT_AUI_PANE_FLOATED, self.OnPaneFloated)
        self.Bind(aui.EVT_AUI_PANE_DOCKED, self.OnPaneDocked)

        # Add a hidden dummy widget to the pane manager. This is a
        # workaround for a Wx bug where the laying out of the central
        # pane will have jitter on window resize (the computed layout
        # origin of the central pane oscillates between (0, 0) and
        # (1, 1)) if there are no other panes in the layout. If we
        # add a hidden pane with zero size, it prevents the jitter.
        self._hidden_widget = wx.Window(self)
        pane = aui.AuiPaneInfo()
        pane.BestSize(wx.Size(0, 0))
        pane.MinSize(wx.Size(0, 0))
        pane.Show(False)
        self._manager.AddPane(self._hidden_widget, pane)

    #--------------------------------------------------------------------------
    # Event Handlers
    #--------------------------------------------------------------------------
    def OnPaneClose(self, event):
        """ Handle the EVT_AUI_PANE_CLOSE event.

        This event gets passed on to the wxDockPane for handling.

        """
        event.GetPane().window.OnClose(event)

    def OnPaneFloated(self, event):
        """ Handle the EVT_AUI_PANE_FLOATED event.

        This event gets passed on to the wxDockPane for handling.

        """
        event.GetPane().window.OnFloated(event)

    def OnPaneDocked(self, event):
        """ Handle the EVT_AUI_PANE_DOCKED event.

        This event gets passed on to the wxDockPane for handling.

        """
        event.GetPane().window.OnDocked(event)

    def OnMenu(self, event):
        """ The event handler for the EVT_MENU event.

        This event handler will be called when an action is triggered
        in a Menu or a ToolBar.

        """
        action = wxAction.FindById(event.GetId())
        if action is not None:
            if action.IsCheckable():
                action.SetChecked(event.Checked())
            action.Trigger()

    def OnClose(self, event):
        """ The event handler for the EVT_CLOSE event.

        This event handler prevents the frame from being destroyed on
        close. Instead it just sets the visibility to False.

        """
        self.Hide()

    #--------------------------------------------------------------------------
    # Public API
    #--------------------------------------------------------------------------
    def BeginBatch(self):
        """ Enter batch update mode for main window updates.

        Main window updates that are performed after calling this method
        will not be committed until EndBatch is called. This can be used
        to reduce flicker when making updates to the MainWindow.

        """
        self._batch = True

    def EndBatch(self):
        """ Exit batch update mode and process any pending updates.

        After calling this method, any pending main window updates will
        be processed.

        """
        self._batch = False
        self._manager.Update()

    def GetCentralWidget(self):
        """ Get the central widget for the main window.

        Returns
        -------
        result : wxWindow or None
            The central widget for the window, or None if no central
            widget is defined.

        """
        return self._central_widget

    def SetCentralWidget(self, widget):
        """ Set the central widget for the main window.

        Parameters
        ----------
        widget : wxWindow
            The wxWindow instance to use as the central widget in the
            main window.

        """
        manager = self._manager
        old_widget = self._central_widget
        if old_widget:
            old_widget.Hide()
            pane = manager.GetPane(old_widget)
            if pane.IsOk():
                pane.Show(False)
                manager.DetachPane(old_widget)
        self._central_widget = widget
        pane = aui.AuiPaneInfo().CenterPane()
        manager.AddPane(widget, pane)
        if not self._batch:
            manager.Update()

    def SetMenuBar(self, menu_bar):
        """ Set the menu bar for the main window.

        Parameters
        ----------
        menu_bar : wxMenuBar
            The wxMenuBar instance to add to the main window.

        """
        old_bar = self.GetMenuBar()
        if old_bar is not menu_bar:
            super(wxMainWindow, self).SetMenuBar(menu_bar)
            # The menu bar must be refreshed after attachment
            if menu_bar:
                menu_bar.Update()

    def AddToolBar(self, tool_bar):
        """ Add a tool bar to the main window.

        If the tool bar already exists in the main window, calling this
        method is effectively a no-op.

        Parameters
        ----------
        tool_bar : wxToolBar
            The wxToolBar instance to add to the main window.

        """
        bars = self._tool_bars
        manager = self._manager
        if bars is None:
            bars = self._tool_bars = wxToolBarContainer(self)
            pane = aui.AuiPaneInfo().ToolbarPane().Top().Gripper(False)
            manager.AddPane(bars, pane)
        pane = manager.GetPane(bars)
        bars.AddToolBar(tool_bar)
        pane.MinSize(bars.GetBestSize())
        if not self._batch:
            manager.Update()

    def RemoveToolBar(self, tool_bar):
        """ Remove a tool bar from the main window.

        If the tool bar already exists in the main window, calling this
        method is effectively a no-op.

        Parameters
        ----------
        tool_bar : wxToolBar
            The wxToolBar instance to remove from the main window.

        """
        bars = self._tool_bars
        if bars is not None:
            bars.RemoveToolBar(tool_bar)
            tool_bar.Hide()
            manager = self._manager
            pane = manager.GetPane(bars)
            pane.MinSize(bars.GetBestSize())
            if not self._batch:
                manager.Update()
                manager.Update() # 2 calls required, because Wx...

    def AddDockPane(self, dock_pane):
        """ Add a dock pane to the main window.

        If the pane already exists in the main window, calling this
        method is a no-op.

        Parameters
        ----------
        dock_pane : wxDockPane
            The wxDockPane instance to add to the main window.

        """
        manager = self._manager
        pane = manager.GetPane(dock_pane)
        if not pane.IsOk():
            manager.AddPane(dock_pane, dock_pane.MakePaneInfo())
            if not self._batch:
                manager.Update()

    def RemoveDockPane(self, dock_pane):
        """ Remove a dock pane from the main window.

        If the pane does not exist in the window, calling this method
        is a no-op.

        Parameters
        ----------
        dock_pane : wxDockPane
            The wxDockPane instance to remove from the window.

        """
        manager = self._manager
        pane = manager.GetPane(dock_pane)
        if pane.IsOk():
            pane.Show(False)
            manager.DetachPane(dock_pane)
            if not self._batch:
                manager.Update()


class WxMainWindow(WxWindow):
    """ A Wx implementation of an Enaml MainWindow.

    """
    #--------------------------------------------------------------------------
    # Setup Methods
    #--------------------------------------------------------------------------
    def create_widget(self, parent, tree):
        """ Create the underlying wx.Frame widget and dock manager.

        """
        return wxMainWindow(parent)

    def init_layout(self):
        """ Perform the layout initialization for the main window.

        """
        # The superclass' init_layout() method is explicitly not called
        # since the layout initialization for Window is not appropriate
        # for MainWindow
        main_window = self.widget()
        components = self.components()
        main_window.BeginBatch()
        main_window.SetMenuBar(components['menu_bar'])
        main_window.SetCentralWidget(components['central_widget'])
        for dpane in components['dock_panes']:
            main_window.AddDockPane(dpane)
        for tbar in components['tool_bars']:
            main_window.AddToolBar(tbar)
        main_window.EndBatch()

    #--------------------------------------------------------------------------
    # Utility Methods
    #--------------------------------------------------------------------------
    def components(self):
        """ Get a dictionary of the main window components.

        Returns
        -------
        result : dict
            A dicionary of main window components categorized by their
            function.

        """
        d = {
            'central_widget': None, 'menu_bar': None,
            'tool_bars': [], 'dock_panes': [],
        }
        for child in self.children():
            if isinstance(child, WxDockPane):
                d['dock_panes'].append(child.widget())
            elif isinstance(child, WxToolBar):
                d['tool_bars'].append(child.widget())
            elif isinstance(child, WxMenuBar):
                d['menu_bar'] = child.widget()
            elif isinstance(child, WxContainer):
                d['central_widget'] = child.widget()
        return d

    #--------------------------------------------------------------------------
    # Child Events
    #--------------------------------------------------------------------------
    def child_removed(self, child):
        """ Handle the child removed event for a WxMainWindow.

        """
        main_window = self.widget()
        if isinstance(child, WxDockPane):
            main_window.RemoveDockPane(child.widget())
        elif isinstance(child, WxToolBar):
            main_window.RemoveToolBar(child.widget())
        elif isinstance(child, WxContainer):
            components = self.components()
            main_window.SetCentralWidget(components['central_widget'])
        elif isinstance(child, WxMenuBar):
            components = self.components()
            main_window.SetMenuBar(components['menu_bar'])

    def child_added(self, child):
        """ Handle the child added event for a WxMainWindow.

        """
        main_window = self.widget()
        if isinstance(child, WxMenuBar):
            components = self.components()
            main_window.SetMenuBar(components['menu_bar'])
        elif isinstance(child, WxContainer):
            components = self.components()
            main_window.SetCentralWidget(components['central_widget'])
        elif isinstance(child, WxDockPane):
            main_window.AddDockPane(child.widget())
        elif isinstance(child, WxToolBar):
            main_window.AddToolBar(child.widget())


########NEW FILE########
__FILENAME__ = wx_menu
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
import wx
import wx.lib.newevent

from .wx_action import WxAction, EVT_ACTION_CHANGED
from .wx_action_group import WxActionGroup
from .wx_widget import WxWidget


#: An event emitted when the menu state changes.
wxMenuChangedEvent, EVT_MENU_CHANGED = wx.lib.newevent.NewEvent()


class wxMenu(wx.Menu):
    """ A wx.Menu subclass which provides a more convenient api for
    working with wxMenu and wxAction children.

    """
    def __init__(self, parent, *args, **kwargs):
        """ Initialize a wxMenu.

        Parameters
        ----------
        *args, **kwargs
            The positional and keyword arguments needed to initialize
            a wx.Menu.

        """
        super(wxMenu, self).__init__(*args, **kwargs)
        self._parent = parent
        self._title = u''
        self._all_items = []
        self._menus_map = {}
        self._actions_map = {}
        self._enabled = True
        self._bar_enabled = True
        self._visible = True
        self._batch = False
        self._is_context_menu = False
        self._id = wx.NewId()

    #--------------------------------------------------------------------------
    # Private API
    #--------------------------------------------------------------------------
    def _EmitChanged(self):
        """ Emits the menu changed event if not in batch mode.

        """
        if not self._batch:
            event = wxMenuChangedEvent()
            event.SetEventObject(self)
            wx.PostEvent(self, event)

    def _SetBarEnabled(self, enabled):
        """ A private method called by an owner menu bar.

        Parameters
        ----------
        enabled : bool
            Whether or not the owner menu bar is enabled.

        """
        if self._bar_enabled != enabled:
            old = self.IsEnabled()
            self._bar_enabled = enabled
            new = self.IsEnabled()
            if old != new:
                self._EmitChanged()

    def _InsertMenuItem(self, index, menu):
        """ Insert a new item into the menu for the given menu.

        Parameters
        ----------
        menu : wxMenu
            The wxMenu instance to use as the submenu.

        Returns
        -------
        result : wx.MenuItem
            The menu item to use for the given menu.

        """
        text = menu.GetTitle()
        menu_id = menu.GetId()
        text = text or 'menu_%d' % menu_id # null text == exception
        res = wx.MenuItem(self, menu_id, text, '', subMenu=menu)
        res.Enable(menu.IsEnabled())
        self.InsertItem(index, res)
        return res

    def _InsertActionItem(self, index, action):
        """ Insert a new item into the menu for the given action.

        Parameters
        ----------
        action : wxAction
            The wx action for which to create a wx.MenuItem.

        Returns
        -------
        result : wx.MenuItem
            The menu item for the given action.

        """
        text = action.GetText()
        help = action.GetStatusTip()
        if action.IsSeparator():
            res = wx.MenuItem(self, wx.ID_SEPARATOR, text, help)
            self.InsertItem(index, res)
        else:
            action_id = action.GetId()
            text = text or 'action_%d' % action_id # null text == exception
            if action.IsCheckable():
                # The wx.ITEM_RADIO kind doesn't behave nicely, so we
                # just use the check kind and rely on the action group
                # to handle the exclusive radio behavior. Changing the
                # bitmap to something that looks like a radio button
                # breaks the Windows theme.
                kind = wx.ITEM_CHECK
                res = wx.MenuItem(self, action_id, text, help, kind)
                # Must instert the item before checking it, or c++
                # assertion errors are thrown
                self.InsertItem(index, res)
                res.Check(action.IsChecked())
            else:
                kind = wx.ITEM_NORMAL
                res = wx.MenuItem(self, action_id, text, help, kind)
                self.InsertItem(index, res)
            res.Enable(action.IsEnabled())
        return res

    def OnActionChanged(self, event):
        """ The event handler for the EVT_ACTION_CHANGED event.

        This handler will be called when a child action changes. It
        ensures that the new state of the child action is in sync with
        the associated menu item.

        """
        event.Skip()
        action = event.GetEventObject()
        item = self._actions_map.get(action)

        # Fist, check for a visibility change. This requires adding or
        # removing the menu item from the menu and the actions map.
        visible = action.IsVisible()
        if visible != bool(item):
            if visible:
                index = self._all_items.index(action)
                n_visible = len(self._actions_map) + len(self._menus_map)
                index = min(index, n_visible)
                new_item = self._InsertActionItem(index, action)
                self._actions_map[action] = new_item
            else:
                self.DestroyItem(item)
                del self._actions_map[action]
            return

        # If the item is invisible, there is nothing to update.
        if not item:
            return

        # If the item is a separator, and the separator state has
        # changed, we need to build an entirely new menu item, and
        # replace the existing item with the new one.
        item_sep = item.IsSeparator()
        action_sep = action.IsSeparator()
        if item_sep or action_sep:
            if item_sep != action_sep:
                self.DestroyItem(item)
                index = self._all_items.index(action)
                n_visible = len(self._actions_map) + len(self._menus_map)
                index = min(index, n_visible)
                new_item = self._InsertActionItem(index, action)
                self._actions_map[action] = new_item
            return

        # For all other state, the menu item can be updated in-place.
        item.SetItemLabel(action.GetText())
        item.SetHelp(action.GetStatusTip())
        if action.IsCheckable():
            item.SetKind(wx.ITEM_CHECK)
            item.Check(action.IsChecked())
        else:
            if item.IsCheckable():
                item.Check(False)
            item.SetKind(wx.ITEM_NORMAL)
        item.Enable(action.IsEnabled())

    def OnMenuChanged(self, event):
        """ The event hanlder for the EVT_MENU_CHANGED event.

        This handler will be called when a child menu changes. It
        ensure that the new state of the child menu is in sync with
        the associated menu item.

        """
        event.Skip()
        menu = event.GetEventObject()
        item = self._menus_map.get(menu)

        # Fist, check for a visibility change. This requires adding or
        # removing the menu item from the menu and the menus map.
        visible = menu.IsVisible()
        if visible != bool(item):
            if visible:
                index = self._all_items.index(menu)
                n_visible = len(self._actions_map) + len(self._menus_map)
                index = min(index, n_visible)
                new_item = self._InsertMenuItem(index, menu)
                self._menus_map[menu] = new_item
            else:
                # Need to first remove the submenu or wx will destroy it.
                item.SetSubMenu(None)
                self.DestroyItem(item)
                del self._menus_map[menu]
            return

        # If the item is invisible, there is nothing to update.
        if not item:
            return

        # For all other state, the menu item can be updated in-place.
        item.SetItemLabel(menu.GetTitle())
        item.Enable(menu.IsEnabled())

    def OnShowContextMenu(self, event):
        """ A private event handler for displaying the context menu.

        This handler is connected to the context menu event on the
        parent widget when this menu is marked as a context menu.

        """
        parent = self._parent
        if parent and isinstance(parent, wx.Window):
            parent.PopupMenu(self)

    #--------------------------------------------------------------------------
    # Public API
    #--------------------------------------------------------------------------
    def BeginBatch(self):
        """ Enter batch update mode for the menu.

        """
        self._batch = True

    def EndBatch(self, emit=True):
        """ Exit batch update mode for the menu.

        Parameters
        ----------
        emit : bool, optional
            If True, emit a changed event after leaving batch mode. The
            default is True.

        """
        self._batch = False
        if emit:
            self._EmitChanged()

    def GetId(self):
        """ Get the unique wx id for this menu.

        Returns
        -------
        result : int
            The wx id number for this menu.

        """
        return self._id

    def GetTitle(self):
        """ Get the title for the menu.

        Returns
        -------
        result : unicode
            The unicode title for the menu.

        """
        return self._title

    def SetTitle(self, title):
        """ Set the title for the menu.

        Parameters
        ----------
        title : unicode
            The unicode string to use as the menu title.

        """
        if self._title != title:
            self._title = title
            self._EmitChanged()

    def IsEnabled(self):
        """ Get whether or not the menu is enabled.

        Returns
        -------
        result : bool
            Whether or not the menu is enabled.

        """
        if self._bar_enabled:
            return self._enabled
        return False

    def SetEnabled(self, enabled):
        """ Set whether or not the menu is enabled.

        Parameters
        ----------
        enabled : bool
            Whether or not the menu is enabled.

        """
        if self._enabled != enabled:
            self._enabled = enabled
            if self._bar_enabled:
                self._EmitChanged()

    def IsVisible(self):
        """ Get whether or not the menu is visible.

        Returns
        -------
        result : bool
            Whether or not the menu is visible.

        """
        return self._visible

    def SetVisible(self, visible):
        """ Set whether or not the menu is visible.

        Parameters
        ----------
        visible : bool
            Whether or not the menu is visible.

        """
        if self._visible != visible:
            self._visible = visible
            self._EmitChanged()

    def IsContextMenu(self):
        """ Whether this menu acts as a context menu for its parent.

        Returns
        -------
        result : bool
            True if this menu acts as a context menu, False otherwise.

        """
        return self._is_context_menu

    def SetContextMenu(self, context):
        """ Set whether this menu acts as a context menu for its parent.

        Parameters
        ----------
        context : bool
            True if this menu should act as a context menu, False
            otherwise.

        """
        old_context = self._is_context_menu
        self._is_context_menu = context
        if old_context != context:
            parent = self._parent
            if parent:
                handler = self.OnShowContextMenu
                if context:
                    parent.Bind(wx.EVT_CONTEXT_MENU, handler)
                else:
                    parent.Unbind(wx.EVT_CONTEXT_MENU, handler=handler)

    def AddMenu(self, menu):
        """ Add a wx menu to the Menu.

        If the menu already exists in this menu, it will be moved to
        the end.

        Parameters
        ----------
        menu : wxMenu
            The wxMenu instance to add to this menu.

        """
        self.InsertMenu(None, menu)

    def InsertMenu(self, before, menu):
        """ Insert a wx menu into the Menu.

        If the menu already exists in this menu, if will be moved to
        the proper location.

        Parameters
        ----------
        before : wxAction, wxMenu, or None
            The item in the menu which should come directly after the
            new sub-menu.

        menu : wxMenu
            The wxMenu instance to insert into this menu.

        """
        all_items = self._all_items
        if menu not in all_items:
            if before in all_items:
                index = all_items.index(before)
            else:
                index = len(all_items)
            all_items.insert(index, menu)
            if menu.IsVisible():
                max_index = len(self._actions_map) + len(self._menus_map)
                index = min(index, max_index)
                menu_item = self._InsertMenuItem(index, menu)
                self._menus_map[menu] = menu_item
            menu.Bind(EVT_MENU_CHANGED, self.OnMenuChanged)
        else:
            # XXX this is a potentially slow way to do things if the
            # number of menus being moved around is large. But, the
            # Wx apis don't appear to offer a better way, so this is
            # what we get (as usual...).
            self.RemoveMenu(menu)
            self.InsertMenu(before, menu)

    def RemoveMenu(self, menu):
        """ Remove a wx menu from the Menu.

        If the menu does not exist in the menu, this is a no-op.

        Parameters
        ----------
        menu : wxMenu
            The wxMenu instance to remove from this menu.

        """
        all_items = self._all_items
        if menu in all_items:
            all_items.remove(menu)
            menu.Unbind(EVT_MENU_CHANGED, handler=self.OnMenuChanged)
            menu_item = self._menus_map.pop(menu, None)
            if menu_item is not None:
                self.RemoveItem(menu_item)
                # Set the SubMenu to None or wx will destroy it.
                menu_item.SetSubMenu(None)

    def AddAction(self, action):
        """ Add a wx action to the Menu.

        If the action already exists in the menu, it will be moved to
        the end.

        Parameters
        ----------
        action : wxAction
            The wxAction instance to add to this menu.

        """
        self.InsertAction(None, action)

    def AddActions(self, actions):
        """ Add multiple wx actions to the Menu.

        If an action already exists in the menu, it will be moved to
        the end.

        Parameters
        ----------
        actions : iterable
            An iterable of wxAction instances to add to the menu.

        """
        insert = self.InsertAction
        for action in actions:
            insert(None, action)

    def InsertAction(self, before, action):
        """ Insert a wx action into the Menu.

        If the action already exists in the menu, it will be moved to
        the proper location.

        Parameters
        ----------
        before : wxAction, wxMenu, or None
            The item in the menu which should come directly after the
            new action.

        action : wxAction
            The wxAction instance to insert into this menu.

        """
        all_items = self._all_items
        if action not in all_items:
            if before in all_items:
                index = all_items.index(before)
            else:
                index = len(all_items)
            all_items.insert(index, action)
            if action.IsVisible():
                max_index = len(self._actions_map) + len(self._menus_map)
                index = min(index, max_index)
                menu_item = self._InsertActionItem(index, action)
                self._actions_map[action] = menu_item
            action.Bind(EVT_ACTION_CHANGED, self.OnActionChanged)
        else:
            # XXX this is a potentially slow way to do things if the
            # number of actions being moved around is large. But, the
            # Wx apis don't appear to offer a better way, so this is
            # what we get (as usual...).
            self.RemoveAction(action)
            self.InsertAction(before, action)

    def InsertActions(self, before, actions):
        """ Insert multiple wx actions into the Menu.

        If an action already exists in this menu, it will be moved to
        the proper location.

        Parameters
        ----------
        before : wxAction, wxMenu, or None
            The item in the menu which should come directly after the
            new actions.

        actions : iterable
            An iterable of wxAction instances to add to the menu.

        """
        insert = self.InsertAction
        for action in actions:
            insert(before, action)

    def RemoveAction(self, action):
        """ Remove a wx action from the Menu.

        If the action does not exist in the menu, this is a no-op.

        Parameters
        ----------
        action : wxAction
            The wxAction instance to remove from this menu.

        """
        all_items = self._all_items
        if action in all_items:
            all_items.remove(action)
            action.Unbind(EVT_ACTION_CHANGED, handler=self.OnActionChanged)
            menu_item = self._actions_map.pop(action, None)
            if menu_item is not None:
                self.RemoveItem(menu_item)

    def RemoveActions(self, actions):
        """ Remove multiple actions from the Menu.

        If an action does not exist in the menu, it will be ignored.

        Parameters
        ----------
        actions : iterable
            An iterable of wxAction instances to remove from the menu.

        """
        remove = self.RemoveAction
        for action in actions:
            remove(action)


class WxMenu(WxWidget):
    """ A Wx implementation of an Enaml Menu.

    """
    #--------------------------------------------------------------------------
    # Setup Methods
    #--------------------------------------------------------------------------
    def create_widget(self, parent, tree):
        """ Create the underlying wx menu widget.

        """
        widget = wxMenu(parent)
        widget.BeginBatch()
        return widget

    def create(self, tree):
        """ Create and initialize the underlying control.

        """
        super(WxMenu, self).create(tree)
        self.set_title(tree['title'])
        self.set_context_menu(tree['context_menu'])
        self.widget().EndBatch(emit=False)

    def init_layout(self):
        """ Initialize the layout for the underlying control.

        """
        super(WxMenu, self).init_layout()
        widget = self.widget()
        for child in self.children():
            if isinstance(child, WxMenu):
                widget.AddMenu(child.widget())
            elif isinstance(child, WxAction):
                widget.AddAction(child.widget())
            elif isinstance(child, WxActionGroup):
                widget.AddActions(child.actions())

    #--------------------------------------------------------------------------
    # Child Events
    #--------------------------------------------------------------------------
    def child_removed(self, child):
        """  Handle the child removed event for a WxMenu.

        """
        if isinstance(child, WxMenu):
            self.widget().RemoveMenu(child.widget())
        elif isinstance(child, WxAction):
            self.widget().RemoveAction(child.widget())
        elif isinstance(child, WxActionGroup):
            self.widget().RemoveActions(child.actions())

    def child_added(self, child):
        """ Handle the child added event for a WxMenu.

        """
        before = self.find_next_action(child)
        if isinstance(child, WxMenu):
            self.widget().InsertMenu(before, child.widget())
        elif isinstance(child, WxAction):
            self.widget().InsertAction(before, child.widget())
        elif isinstance(child, WxActionGroup):
            self.widget().InsertActions(before, child.actions())

    #--------------------------------------------------------------------------
    # Utility Methods
    #--------------------------------------------------------------------------
    def find_next_action(self, child):
        """ Get the wxAction or wxMenu instance which comes immediately
        after the actions of the given child.

        Parameters
        ----------
        child : WxMenu, WxActionGroup, or WxAction
            The child of interest.

        Returns
        -------
        result : wxAction, wxMenu, or None
            The wxAction or wxMenu which comes immediately after the
            actions of the given child, or None if no actions follow
            the child.

        """
        index = self.index_of(child)
        if index != -1:
            for child in self.children()[index + 1:]:
                target = None
                if isinstance(child, (WxMenu, WxAction)):
                    target = child.widget()
                elif isinstance(child, WxActionGroup):
                    acts = child.actions()
                    target = acts[0] if acts else None
                if target is not None:
                    return target

    #--------------------------------------------------------------------------
    # Message Handling
    #--------------------------------------------------------------------------
    def on_action_set_title(self, content):
        """ Handle the 'set_title' action from the Enaml widget.

        """
        self.set_title(content['title'])

    def on_action_set_context_menu(self, content):
        """ Handle the 'set_context_menu' action from the Enaml widget.

        """
        self.set_context_menu(content['context_menu'])

    #--------------------------------------------------------------------------
    # Widget Update Methods
    #--------------------------------------------------------------------------
    def set_title(self, title):
        """ Set the title of the underlyling control.

        """
        self.widget().SetTitle(title)

    def set_enabled(self, enabled):
        """ Overridden parent class method.

        This properly sets the enabled state on a menu using the custom
        wxMenu api.

        """
        self.widget().SetEnabled(enabled)

    def set_visible(self, visible):
        """ Overrdden parent class method.

        This properly sets the visible state on a menu using the custom
        wxMenu api.

        """
        self.widget().SetVisible(visible)

    def set_context_menu(self, context):
        """ Set whether or not the menu is a context menu.

        """
        self.widget().SetContextMenu(context)

    def set_minimum_size(self, min_size):
        """ Overridden parent class method.

        Menus do not have a minimum size, so this method is a no-op.

        """
        pass

    def set_maximum_size(self, max_size):
        """ Overridden parent class method.

        Menus do not have a maximum size, so this method is a no-op.

        """
        pass

    def set_tool_tip(self, tool_tip):
        """ Overridden parent class method.

        Menus do not have a tool tip, so this method is a no-op.

        """
        pass


########NEW FILE########
__FILENAME__ = wx_menu_bar
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
import wx

from .wx_menu import WxMenu, EVT_MENU_CHANGED
from .wx_widget import WxWidget


class wxMenuBar(wx.MenuBar):
    """ A wx.MenuBar subclass which exposes a more convenient api for
    working with wxMenu children.

    """
    def __init__(self, *args, **kwargs):
        """ Initialize a wxMenuBar.

        Parameters
        ----------
        *args, **kwargs
            The positional and keyword arguments needed to initialize
            a wx.MenuBar.

        """
        super(wxMenuBar, self).__init__(*args, **kwargs)
        self._menus = []
        self._visible_menus = []
        self._enabled = True

    #--------------------------------------------------------------------------
    # Private API
    #--------------------------------------------------------------------------
    def OnMenuChanged(self, event):
        """ The event handler for the EVT_MENU_CHANGED event.

        This event handler will synchronize the menu changes with
        the menu bar.

        """
        event.Skip()
        if self.IsAttached():
            menu = event.GetEventObject()

            # First, check for a visibility change. This requires adding
            # or removing the menu from the menu bar.
            visible = menu.IsVisible()
            was_visible = menu in self._visible_menus
            if visible != was_visible:
                if visible:
                    index = self._menus.index(menu)
                    index = min(index, len(self._visible_menus))
                    self._visible_menus.insert(index, menu)
                    self.Insert(index, menu, menu.GetTitle())
                    self.EnableTop(index, menu.IsEnabled())
                else:
                    index = self._visible_menus.index(menu)
                    self._visible_menus.pop(index)
                    self.Remove(index)
                return

            # If the menu isn't visible, there's nothing to do.
            if not visible:
                return

            # For all other state, the menu can be updated in-place.
            index = self._visible_menus.index(menu)
            self.SetMenuLabel(index, menu.GetTitle())
            self.EnableTop(index, menu.IsEnabled())

    #--------------------------------------------------------------------------
    # Public API
    #--------------------------------------------------------------------------
    def IsEnabled(self):
        """ Get whether or not the menu bar is enabled.

        Returns
        -------
        result : bool
            Whether or not the menu bar is enabled.

        """
        return self._enabled

    def SetEnabled(self, enabled):
        """ Set whether or not the menu bar is enabled.

        Parameters
        ----------
        enabled : bool
            Whether or not the menu bar is enabled.

        """
        # Wx does not provide a means for disabling the entire menu
        # bar, so we must do it manually by disabling each menu.
        if self._enabled != enabled:
            self._enabled = enabled
            for menu in self._menus:
                menu._SetBarEnabled(enabled)

    def AddMenu(self, menu):
        """ Add a wxMenu to the menu bar.

        If the menu already exists in the menu bar, this is a no-op.

        Parameters
        ----------
        menu : wxMenu
            The wxMenu instance to add to the menu bar.

        """
        self.InsertMenu(None, menu)

    def InsertMenu(self, before, menu):
        """ Insert a wxMenu into the menu bar.

        If the menu already exists in the menu bar, this is a no-op.

        Parameters
        ----------
        before : wxMenu
            The menu before which to insert the given menu.

        menu : wxMenu
            The menu to insert into the menu bar.

        """
        menus = self._menus
        if menu not in menus:
            if before in menus:
                index = menus.index(before)
            else:
                index = len(menus)
            menus.insert(index, menu)
            if menu.IsVisible():
                max_index = len(self._visible_menus)
                index = min(index, max_index)
                self._visible_menus.insert(index, menu)
                self.Insert(index, menu, menu.GetTitle())
            menu.Bind(EVT_MENU_CHANGED, self.OnMenuChanged)
            menu._SetBarEnabled(self._enabled)

    def RemoveMenu(self, menu):
        """ Remove a wxMenu from the menu bar.

        If the menu does not exist in the menu bar, this is a no-op.

        Parameters
        ----------
        menu : wxMenu
            The menu to remove from the menu bar.

        """
        menus = self._menus
        if menu in menus:
            menus.remove(menu)
            menu.Unbind(EVT_MENU_CHANGED, handler=self.OnMenuChanged)
            visible_menus = self._visible_menus
            if menu in visible_menus:
                index = visible_menus.index(menu)
                visible_menus.remove(menu)
                self.Remove(index)

    def Update(self):
        """ A method which can be called to update the menu bar.

        Calling this method will manually refresh the state of the
        items in the menu bar. This is useful to call just after
        attaching the menu bar to a frame, since the menu bar state
        cannot be updated prior to being attached.

        """
        if self.IsAttached():
            for index, menu in enumerate(self._visible_menus):
                self.SetMenuLabel(index, menu.GetTitle())
                if not menu.IsEnabled():
                    self.EnableTop(index, False)


class WxMenuBar(WxWidget):
    """ A Wx implementation of an Enaml MenuBar.

    """
    #--------------------------------------------------------------------------
    # Setup Methods
    #--------------------------------------------------------------------------
    def create_widget(self, parent, tree):
        """ Create the underlying menu bar widget.

        """
        return wxMenuBar()

    def init_layout(self):
        """ Initialize the layout for the underlying control.

        """
        super(WxMenuBar, self).init_layout()
        widget = self.widget()
        for child in self.children():
            if isinstance(child, WxMenu):
                widget.AddMenu(child.widget())

    #--------------------------------------------------------------------------
    # Child Events
    #--------------------------------------------------------------------------
    def child_removed(self, child):
        """ Handle the child removed event for a WxMenuBar.

        """
        if isinstance(child, WxMenu):
            self.widget().RemoveMenu(child.widget())

    def child_added(self, child):
        """ Handle the child added event for a WxMenuBar.

        """
        if isinstance(child, WxMenu):
            before = self.find_next_menu(child)
            self.widget().InsertMenu(before, child.widget())

    #--------------------------------------------------------------------------
    # Utility Methods
    #--------------------------------------------------------------------------
    def find_next_menu(self, child):
        """ Get the wxMenu instance which comes immediately after the
        menu of the given child.

        Parameters
        ----------
        child : WxMenu
            The child menu of interest.

        Returns
        -------
        result : wxMenu or None
            The wxMenu which comes immediately after the menu of the
            given child, or None if no menu follows the child.

        """
        index = self.index_of(child)
        if index != -1:
            for child in self.children()[index + 1:]:
                if isinstance(child, WxMenu):
                    return child.widget()

    #--------------------------------------------------------------------------
    # Widget Update Methods
    #--------------------------------------------------------------------------
    def set_enabled(self, enabled):
        """ Overridden parent class method.

        This properly sets the enabled state on a menu bar.

        """
        self.widget().SetEnabled(enabled)

    def set_visible(self, visible):
        """ Overrdden parent class method.

        This method is a no-op, since a MenuBar cannot change it's
        visibility under Wx.

        """
        pass


########NEW FILE########
__FILENAME__ = wx_mpl_canvas
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#
# Special thanks to Steven Silvester for contributing this module!
#------------------------------------------------------------------------------
import wx

from .wx_control import WxControl

from matplotlib.backends.backend_wxagg import FigureCanvasWxAgg
from matplotlib.backends.backend_wx import NavigationToolbar2Wx


class WxMPLCanvas(WxControl):
    """ A Wx implementation of an Enaml MPLCanvas.

    """
    #: Internal storage for the matplotlib figure.
    _figure = None

    #: Internal storage for whether or not to show the toolbar.
    _toolbar_visible = False

    #--------------------------------------------------------------------------
    # Setup Methods
    #--------------------------------------------------------------------------
    def create_widget(self, parent, tree):
        """ Create the underlying widget.

        """
        widget = wx.Panel(parent)
        sizer = wx.BoxSizer(wx.VERTICAL)
        widget.SetSizer(sizer)
        return widget

    def create(self, tree):
        """ Create and initialize the underlying widget.

        """
        super(WxMPLCanvas, self).create(tree)
        self._figure = tree['figure']
        self._toolbar_visible = tree['toolbar_visible']

    def init_layout(self):
        """ Initialize the layout of the underlying widget.

        """
        super(WxMPLCanvas, self).init_layout()
        self.refresh_mpl_widget(notify=False)

    #--------------------------------------------------------------------------
    # Message Handlers
    #--------------------------------------------------------------------------
    def on_action_set_figure(self, content):
        """ Handle the 'set_figure' action from the Enaml widget.

        """
        self._figure = content['figure']
        self.refresh_mpl_widget()

    def on_action_set_toolbar_visible(self, content):
        """ Handle the 'set_toolbar_visible' action from the Enaml
        widget.

        """
        visible = content['toolbar_visible']
        self._toolbar_visible = visible
        widget = self.widget()
        sizer = widget.GetSizer()
        children = sizer.GetChildren()
        if len(children) == 2:
            widget.Freeze()
            old_hint = widget.GetBestSize()
            toolbar = children[0]
            toolbar.Show(visible)
            new_hint = widget.GetBestSize()
            if old_hint != new_hint:
                self.size_hint_updated()
            sizer.Layout()
            widget.Thaw()

    #--------------------------------------------------------------------------
    # Widget Update Methods
    #--------------------------------------------------------------------------
    def refresh_mpl_widget(self, notify=True):
        """ Create the mpl widget and update the underlying control.

        Parameters
        ----------
        notify : bool, optional
            Whether to notify the layout system if the size hint of the
            widget has changed. The default is True.

        """
        # Delete the old widgets in the layout, it's just shenanigans
        # to try to reuse the old widgets when the figure changes.
        widget = self.widget()
        widget.Freeze()
        if notify:
            old_hint = widget.GetBestSize()
        sizer = widget.GetSizer()
        sizer.Clear(True)

        # Create the new figure and toolbar widgets. It seems that key
        # events will not be processed without an mpl figure manager.
        # However, a figure manager will create a new toplevel window,
        # which is certainly not desired in this case. This appears to
        # be a limitation of matplotlib.
        figure = self._figure
        if figure is not None:
            canvas = FigureCanvasWxAgg(widget, -1, figure)
            toolbar = NavigationToolbar2Wx(canvas)
            toolbar.Show(self._toolbar_visible)
            sizer.Add(toolbar, 0, wx.EXPAND)
            sizer.Add(canvas, 1, wx.EXPAND)

        if notify:
            new_hint = widget.GetBestSize()
            if old_hint != new_hint:
                self.size_hint_updated()

        sizer.Layout()
        widget.Thaw()


########NEW FILE########
__FILENAME__ = wx_multiline_field
#------------------------------------------------------------------------------
#  Copyright (c) 2013, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
import wx
import wx.lib.newevent

from .wx_control import WxControl


#: The event used to signal a delayed text change.
wxTextChangedEvent, EVT_TEXT_CHANGED = wx.lib.newevent.NewEvent()


class wxMultilineField(wx.TextCtrl):
    """ A text control which notifies on a collpasing timer.

    """
    def __init__(self, *args, **kwargs):
        """ Initialize a wxMultilineField.

        Parameters
        ----------
        *args, **kwargs
            The positional and keyword arguments to initialize a
            wx.TextCtrl.

        """
        super(wxMultilineField, self).__init__(*args, **kwargs)
        self._timer = wx.Timer(self)
        self.Bind(wx.EVT_TIMER, self.OnTimerFired, self._timer)
        self.Bind(wx.EVT_TEXT, self.OnTextEdited)

    #--------------------------------------------------------------------------
    # Event Handlers
    #--------------------------------------------------------------------------
    def OnTextEdited(self, event):
        """ Restart the collapsing timer when the text is edited.

        """
        self._timer.Start(200, oneShot=True)
        event.Skip()

    def OnTimerFired(self, event):
        """ Handles the wx.EVT_TIMER event for delayed text change.

        """
        event = wxTextChangedEvent()
        event.SetEventObject(self)
        self.GetEventHandler().ProcessEvent(event)

    #--------------------------------------------------------------------------
    # Public API
    #--------------------------------------------------------------------------
    def GetBestSize(self):
        """ A reimplemented best size method.

        This adds 246 pixels in width and 176 pixels to the height to
        make Wx consistent with Qt.

        """
        size = super(wxMultilineField, self).GetBestSize()
        return wx.Size(size.GetWidth() + 246, size.GetHeight() + 176)

    def ChangeValue(self, text):
        """ An overridden parent class method.

        This moves the insertion point to the end of the field when the
        text value changes. This makes the field to behave like Qt.

        """
        super(wxMultilineField, self).ChangeValue(text)
        self.SetInsertionPointEnd()


class WxMultilineField(WxControl):
    """ A Wx implementation of an Enaml Field.

    """
    #: Whether or not to auto synchronize the text on change.
    _auto_sync_text = True

    #--------------------------------------------------------------------------
    # Setup Methods
    #--------------------------------------------------------------------------
    def create_widget(self, parent, tree):
        """ Creates the underlying wxMultiLineField.

        """
        style = wx.TE_MULTILINE | wx.TE_RICH
        return wxMultilineField(parent, style=style)

    def create(self, tree):
        """ Create and initialize the wx field control.

        """
        super(WxMultilineField, self).create(tree)
        self._auto_sync_text = tree['auto_sync_text']
        self.set_text(tree['text'])
        self.set_read_only(tree['read_only'])
        widget = self.widget()
        widget.Bind(EVT_TEXT_CHANGED, self.on_text_changed)

    #--------------------------------------------------------------------------
    # Private API
    #--------------------------------------------------------------------------
    def _send_text_changed(self):
        """ Send the current text as an update to the server widget.

        """
        text = self.widget().GetValue()
        self.send_action('text_changed', {'text': text})

    #--------------------------------------------------------------------------
    # Event Handling
    #--------------------------------------------------------------------------
    def on_text_changed(self, event):
        """ The event handler for EVT_TEXT_CHANGED event.

        """
        if self._auto_sync_text and 'text' not in self.loopback_guard:
            self._send_text_changed()

    #--------------------------------------------------------------------------
    # Message Handling
    #--------------------------------------------------------------------------
    def on_action_set_text(self, content):
        """ Handle the 'set_text' action from the Enaml widget.

        """
        self.set_text(content['text'])

    def on_action_set_auto_sync_text(self, content):
        """ Handle the 'set_auto_sync_text' action from the Enaml widget.

        """
        self._auto_sync_text = content['auto_sync_text']

    def on_action_set_read_only(self, content):
        """ Handle the 'set_read_only' action from the Enaml widget.

        """
        self.set_read_only(content['read_only'])

    def on_action_sync_text(self, content):
        """ Handle the 'sync_text' action from the Enaml widget.

        """
        self._send_text_changed()

    #--------------------------------------------------------------------------
    # Widget Update Methods
    #--------------------------------------------------------------------------
    def set_text(self, text):
        """ Updates the text control with the given unicode text.

        """
        with self.loopback_guard('text'):
            self.widget().ChangeValue(text)

    def set_read_only(self, read_only):
        """ Sets the read only state of the widget.

        """
        self.widget().SetEditable(not read_only)


########NEW FILE########
__FILENAME__ = wx_notebook
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
import weakref
import wx

from .wx_constraints_widget import WxConstraintsWidget
from .wx_layout_request import EVT_COMMAND_LAYOUT_REQUESTED
from .wx_page import WxPage
from .wx_upstream import aui


#: A mapping of notebook tab positions for the document style tabs.
#: Wx currently only supports top and bottom tab positions.
_TAB_POSITION_MAP = {
    'top': aui.AUI_NB_TOP,
    'left': aui.AUI_NB_TOP,
    'bottom': aui.AUI_NB_BOTTOM,
    'right': aui.AUI_NB_BOTTOM,
}


#: A mask of notebook tab positions for the document style tabs.
_TAB_POSITION_MASK = aui.AUI_NB_TOP | aui.AUI_NB_BOTTOM


class wxDocumentNotebook(aui.AuiNotebook):
    """ A custom AuiNotebook which handles children of type wxPage.

    This notebook is used to implement 'document' style tabs for an
    Enaml Notebook control.

    """
    def __init__(self, *args, **kwargs):
        """ Initialize a wxDocumentNotebook.

        Parameters
        ----------
        *args, **kwargs
            The positional and keyword arguments to pass to the super
            class.

        """
        super(wxDocumentNotebook, self).__init__(*args, **kwargs)
        self.Bind(aui.EVT_AUINOTEBOOK_PAGE_CLOSE, self.OnPageClose)
        self._hidden_pages = weakref.WeakKeyDictionary()

    #--------------------------------------------------------------------------
    # Event Handlers
    #--------------------------------------------------------------------------
    def OnPageClose(self, event):
        """ The handler for the EVT_AUINOTEBOOK_PAGE_CLOSE event.

        This handler forwards the event to the wxPage instance.

        """
        self.GetPage(event.GetSelection()).OnClose(event)

    #--------------------------------------------------------------------------
    # Public API
    #--------------------------------------------------------------------------
    def GetBestSize(self):
        """ Overridden GetBestSize method which will return the best
        size for the notebook.

        """
        size = wx.Size(256, 192)
        for idx in xrange(self.GetPageCount()):
            page = self.GetPage(idx)
            psize = page.GetBestSize()
            size.SetWidth(max(size.GetWidth(), psize.GetWidth()))
            size.SetHeight(max(size.GetHeight(), psize.GetHeight()))
        # On windows, there's an off by 2 error in the width.
        height = self.GetHeightForPageHeight(size.GetHeight())
        return wx.Size(size.GetWidth() + 2, height)

    def ShowWxPage(self, page):
        """ Show a hidden wxPage instance in the notebook.

        If the page is not owned by the notebook, this is a no-op.

        Parameters
        ----------
        page : wxPage
            The hidden wxPage instance to show in the notebook.

        """
        index = self.GetPageIndex(page)
        if index == -1:
            index = self._hidden_pages.pop(page, -1)
            if index != -1:
                self.InsertWxPage(index, page)

    def HideWxPage(self, page):
        """ Hide the given wxPage instance in the notebook.

        If the page is not owned by the notebook, this is a no-op.

        Parameters
        ----------
        page : wxPage
            The wxPage instance to hide in the notebook.

        """
        index = self.GetPageIndex(page)
        if index != -1:
            self.RemovePage(index)
            page.Show(False)
            self._hidden_pages[page] = index

    def AddWxPage(self, page):
        """ Add a wxPage instance to the notebook.

        This should be used in favor of AddPage for adding a wxPage
        instance to the notebook, as it takes into account the current
        page state.

        Parameters
        ----------
        page : wxPage
            The wxPage instance to add to the notebook.

        """
        if page.IsOpen():
            self.AddPage(page, page.GetTitle())
            index = self.GetPageIndex(page)
            if not page.GetEnabled():
                self.EnableTab(index, False)
            if not page.GetClosable():
                self.SetCloseButton(index, False)
        else:
            page.Show(False)
            self._hidden_pages[page] = self.GetPageCount()

    def InsertWxPage(self, index, page):
        """ Insert a wxPage instance into the notebook.

        This should be used in favor of InsertPage for inserting a
        wxPage instance into the notebook, as it takes into account the
        current page state.

        Parameters
        ----------
        index : int
            The index at which to insert the page.

        page : wxPage
            The wxPage instance to add to the notebook.

        """
        if page.IsOpen():
            index = min(index, self.GetPageCount())
            self.InsertPage(index, page, page.GetTitle())
            if not page.GetEnabled():
                self.EnableTab(index, False)
            if not page.GetClosable():
                self.SetCloseButton(index, False)
        else:
            page.Show(False)
            self._hidden_pages[page] = index

    def RemoveWxPage(self, page):
        """ Remove a wxPage instance from the notebook.

        If the page does not exist in the notebook, this is a no-op.

        Parameters
        ----------
        page : wxPage
            The wxPage instance to remove from the notebook.

        """
        index = self.GetPageIndex(page)
        if index != -1:
            self.RemovePage(index)
            page.Show(False)


class wxPreferencesNotebook(wx.Notebook):
    """ A custom wx.Notebook which handles children of type wxPage.

    This notebook is used to implement 'document' style tabs for an
    Enaml Notebook control.

    """
    def __init__(self, *args, **kwargs):
        """ Initialize a wxPreferencesNotebook.

        Parameters
        ----------
        *args, **kwargs
            The positional and keyword arguments to pass to the super
            class.

        """
        super(wxPreferencesNotebook, self).__init__(*args, **kwargs)
        self._hidden_pages = weakref.WeakKeyDictionary()

    #--------------------------------------------------------------------------
    # Public API
    #--------------------------------------------------------------------------
    def GetBestSize(self):
        """ Overridden GetBestSize method which will return the best
        size for the notebook.

        """
        size = wx.Size(256, 192)
        for idx in xrange(self.GetPageCount()):
            page = self.GetPage(idx)
            psize = page.GetBestSize()
            size.SetWidth(max(size.GetWidth(), psize.GetWidth()))
            size.SetHeight(max(size.GetHeight(), psize.GetHeight()))
        # On windows, the wx.Notebook renders each page with 2 pixels
        # of padding on the top, and bottom, and 4 pixels of padding
        # on the left and right (at least under the Windows 7 theme).
        # We need to compensate for this padding along with the space
        # taken up by the tab bar. The tab bar height was manually
        # measured to be 21 pixels. I've found no way to have wx measure
        # it for me (there's nothing in RendererNative for it), so its
        # just hard-coded for now.
        return wx.Size(size.GetWidth() + 8, size.GetHeight() + 25)

    def ShowWxPage(self, page):
        """ Show a hidden wxPage instance in the notebook.

        If the page is not owned by the notebook, this is a no-op.

        Parameters
        ----------
        page : wxPage
            The hidden wxPage instance to show in the notebook.

        """
        index = self.GetPageIndex(page)
        if index == -1:
            index = self._hidden_pages.pop(page, -1)
            if index != -1:
                self.InsertWxPage(index, page)

    def HideWxPage(self, page):
        """ Hide the given wxPage instance in the notebook.

        If the page is not owned by the notebook, this is a no-op.

        Parameters
        ----------
        page : wxPage
            The wxPage instance to hide in the notebook.

        """
        index = self.GetPageIndex(page)
        if index != -1:
            self.RemovePage(index)
            page.Show(False)
            self._hidden_pages[page] = index

    def AddWxPage(self, page):
        """ Add a wxPage instance to the notebook.

        This should be used in favor of AddPage for adding a wxPage
        instance to the notebook, as it takes into account the current
        page state.

        Parameters
        ----------
        page : wxPage
            The wxPage instance to add to the notebook.

        """
        if page.IsOpen():
            self.AddPage(page, page.GetTitle())
        else:
            page.Show(False)
            self._hidden_pages[page] = self.GetPageCount()

    def InsertWxPage(self, index, page):
        """ Insert a wxPage instance into the notebook.

        This should be used in favor of InsertPage for inserting a
        wxPage instance into the notebook, as it takes into account the
        current page state.

        Parameters
        ----------
        index : int
            The index at which to insert the page.

        page : wxPage
            The wxPage instance to add to the notebook.

        """
        if page.IsOpen():
            index = min(index, self.GetPageCount())
            self.InsertPage(index, page, page.GetTitle())
        else:
            page.Show(False)
            self._hidden_pages[page] = index

    def RemoveWxPage(self, page):
        """ Remove a wxPage instance from the notebook.

        If the page does not exist in the notebook, this is a no-op.

        Parameters
        ----------
        page : wxPage
            The wxPage instance to remove from the notebook.

        """
        index = self.GetPageIndex(page)
        if index != -1:
            self.RemovePage(index)
            page.Show(False)

    def GetPageIndex(self, page):
        """ Returns the index of the page in the control.

        Parameters
        ----------
        page : wxPage
            The wxPage instance in the control.

        Returns
        -------
        result : int
            The index of the page in the control, or -1 if the page
            is not found.

        """
        # Wx has no way of querying for the index of a page, so we must
        # linear search ourselves. Hooray for brain-dead toolkits!
        for idx in xrange(self.GetPageCount()):
            if self.GetPage(idx) == page:
                return idx
        return -1

    def EnableTab(self, index, enabled):
        """ Change the enabled state of the tab at the given index.

        Parameters
        ----------
        index : int
            The index of the target tab.

        enabled : bool
            Whether or not the tab should be enabled.

        """
        if index >= 0 and index < self.GetPageCount():
            page = self.GetPage(index)
            page.Enable(enabled)

    def SetCloseButton(self, index, closable):
        """ A dummy method which makes the wxPreferencesNotebook api
        compatible with the wxDocumentNotebook.

        Close buttons cannot be set on a preferences notebook. This
        method exists soley so that child wxPages do not need to
        special case their implementation based on their parent.

        """
        pass


class WxNotebook(WxConstraintsWidget):
    """ A Wx implementation of an Enaml Notebook.

    """
    #--------------------------------------------------------------------------
    # Setup methods
    #--------------------------------------------------------------------------
    def create_widget(self, parent, tree):
        """ Create the underlying wx notebook widget.

        """
        if tree['tab_style'] == 'preferences':
            res = wxPreferencesNotebook(parent)
        else:
            style = aui.AUI_NB_SCROLL_BUTTONS
            res =  wxDocumentNotebook(parent, agwStyle=style)
        return res

    def create(self, tree):
        """ Create and initialize the notebook control

        """
        super(WxNotebook, self).create(tree)
        self.set_tab_style(tree['tab_style'])
        self.set_tab_position(tree['tab_position'])
        self.set_tabs_closable(tree['tabs_closable'])
        self.set_tabs_movable(tree['tabs_movable'])

    def init_layout(self):
        """ Handle the layout initialization for the notebook.

        """
        super(WxNotebook, self).init_layout()
        widget = self.widget()
        for child in self.children():
            if isinstance(child, WxPage):
                widget.AddWxPage(child.widget())
        widget.Bind(EVT_COMMAND_LAYOUT_REQUESTED, self.on_layout_requested)

    #--------------------------------------------------------------------------
    # Child Events
    #--------------------------------------------------------------------------
    def child_removed(self, child):
        """ Handle the child removed event for a WxNotebook.

        """
        if isinstance(child, WxPage):
            self.widget().RemoveWxPage(child.widget())
            self.size_hint_updated()

    def child_added(self, child):
        """ Handle the child added event for a WxNotebook.

        """
        if isinstance(child, WxPage):
            index = self.index_of(child)
            if index != -1:
                self.widget().InsertWxPage(index, child.widget())
                self.size_hint_updated()

    #--------------------------------------------------------------------------
    # Event Handlers
    #--------------------------------------------------------------------------
    def on_layout_requested(self, event):
        """ Handle the layout request event from a child page.

        """
        self.size_hint_updated()

    #--------------------------------------------------------------------------
    # Message Handlers
    #--------------------------------------------------------------------------
    def on_action_set_tab_style(self, content):
        """ Handle the 'set_tab_style' action from the Enaml widget.

        """
        self.set_tab_style(content['tab_style'])

    def on_action_set_tab_position(self, content):
        """ Handle the 'set_tab_position' action from the Enaml widget.

        """
        self.set_tab_position(content['tab_position'])

    def on_action_set_tabs_closable(self, content):
        """ Handle the 'set_tabs_closable' action from the Enaml widget.

        """
        self.set_tabs_closable(content['tabs_closable'])

    def on_action_set_tabs_movable(self, content):
        """ Handle the 'set_tabs_movable' action from the Enaml widget.

        """
        self.set_tabs_movable(content['tabs_movable'])

    #--------------------------------------------------------------------------
    # Widget Update Methods
    #--------------------------------------------------------------------------
    def set_tab_style(self, style):
        """ Set the tab style for the underlying widget.

        """
        # Changing the tab style on wx is not supported
        pass

    def set_tab_position(self, position):
        """ Set the position of the tab bar in the widget.

        """
        # Tab position changes only supported on the document notebook.
        widget = self.widget()
        if isinstance(widget, wxDocumentNotebook):
            flags = widget.GetAGWWindowStyleFlag()
            flags &= ~_TAB_POSITION_MASK
            flags |= _TAB_POSITION_MAP[position]
            widget.SetAGWWindowStyleFlag(flags)
            widget.Refresh() # Avoids rendering artifacts

    def set_tabs_closable(self, closable):
        """ Set whether or not the tabs are closable.

        """
        # Closable tabs are only supported on the document notebook.
        widget = self.widget()
        if isinstance(widget, wxDocumentNotebook):
            flags = widget.GetAGWWindowStyleFlag()
            if closable:
                flags |= aui.AUI_NB_CLOSE_ON_ALL_TABS
            else:
                flags &= ~aui.AUI_NB_CLOSE_ON_ALL_TABS
            widget.SetAGWWindowStyleFlag(flags)

    def set_tabs_movable(self, movable):
        """ Set whether or not the tabs are movable.

        """
        # Movable tabs are only supported on the document notebook.
        widget = self.widget()
        if isinstance(widget, wxDocumentNotebook):
            flags = widget.GetAGWWindowStyleFlag()
            if movable:
               flags |= aui.AUI_NB_TAB_MOVE
            else:
               flags &= ~aui.AUI_NB_TAB_MOVE
            widget.SetAGWWindowStyleFlag(flags)


########NEW FILE########
__FILENAME__ = wx_object
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
import functools

import wx

from enaml.utils import LoopbackGuard

from .wx_deferred_caller import DeferredCall


def deferred_updates(func):
    """ A method decorator which will defer widget updates.

    When used as a decorator for a WxObject, this will disable updates
    on the underlying widget, and re-enable them on the next cycle of
    the event loop after the method returns.

    Parameters
    ----------
    func : function
        A function object defined as a method on a WxObject.

    """
    @functools.wraps(func)
    def closure(self, *args, **kwargs):
        widget = self.widget()
        if widget and isinstance(widget, wx.Window):
            widget.Freeze()
            try:
                res = func(self, *args, **kwargs)
            finally:
                DeferredCall(widget.Thaw)
        else:
            res = func(self, *args, **kwargs)
        return res
    return closure


class WxObject(object):
    """ The most base class of all client objects for the Enaml Wx
    implementation.

    """
    @classmethod
    def construct(cls, tree, parent, session):
        """ Construct the WxObject instance for the given parameters.

        This classmethod is called by the WxSession object which owns
        the object being built. When called, it creates a new instance
        of the class by extracting the object id from the snapshot and
        calling the class' constructor. It then invokes the `create`
        method on the new instance. This classmethod exists for cases
        where it is necessary to define custom construction behavior.
        A subclass may reimplement this method as required.

        Parameters
        ----------
        tree : dict
            An Enaml snapshot dict representing an object tree from this
            object downward.

        parent : WxObject or None
            The parent WxObject to use for this object, or None if this
            object is top-level.

        session : WxSession
            The WxSession object which owns this object. The session is
            used for sending messages to the server side widgets.

        Returns
        -------
        result : WxObject
            The WxObject instance for these parameters.

        Notes
        -----
        This method does *not* construct the children for this object.
        That responsibility lies with the WxSession object which calls
        this constructor.

        """
        object_id = tree['object_id']
        self = cls(object_id, parent, session)
        self.create(tree)
        session.register(self)
        return self

    def __init__(self, object_id, parent, session):
        """ Initialize a WxObject.

        Parameters
        ----------
        object_id : str
            The unique identifier to use with this object.

        parent : WxObject or None
            The parent object of this object, or None if this object
            has no parent.

        pipe : wxActionPipe or None
            The action pipe to use for sending actions to Enaml objects.

        builder : WxBuilder
            The WxBuilder instance that built this object.

        """
        self._object_id = object_id
        self._session = session
        self._parent = None
        self._children = []
        self._widget = None
        self._initialized = False
        self.set_parent(parent)

    #--------------------------------------------------------------------------
    # Properties
    #--------------------------------------------------------------------------
    @property
    def loopback_guard(self):
        """ Lazily creates and returns a LoopbackGuard for convenient
        use by subclasses.

        """
        try:
            guard = self._loopback_guard
        except AttributeError:
            guard = self._loopback_guard = LoopbackGuard()
        return guard

    #--------------------------------------------------------------------------
    # Object Methods
    #--------------------------------------------------------------------------
    def object_id(self):
        """ Get the object id for the object.

        Returns
        -------
        result : str
            The unique identifier for this object.

        """
        return self._object_id

    def widget(self):
        """ Get the toolkit-specific object for this object.

        Returns
        -------
        result : wxEvtHandler
            The toolkit object for this object, or None if it does not
            have a toolkit object.

        """
        return self._widget

    def create_widget(self, parent, tree):
        """ A method which should be reimplemented by subclasses.

        This method is called by the create(...) method. It should
        create and return the underlying Wx widget. Implementations
        of this method should *not* call the superclass version.

        Parameters
        ----------
        parent : wxEvtHandler or None
            The parent Wx toolkit object for this control, or None if
            the control does not have a parent.

        tree : dict
            The dictionary representation of the tree for this object.
            This is provided in the even that the component needs to
            create a different type of widget based on the information
            in the tree.

        """
        return wx.EvtHandler()

    def create(self, tree):
        """ A method called by the application when creating the UI.

        The default implementation of this method calls 'create_widget'
        and assigns the results to the 'widget' attribute, so subclasses
        must be sure to call the superclass method as the first order of
        business.

        This method is called by the application in a top-down fashion.

        Parameters
        ----------
        tree : dict
            The dictionary representation of the tree for this object.

        """
        parent = self._parent
        parent_widget = parent.widget() if parent else None
        self._widget = self.create_widget(parent_widget, tree)

    def initialized(self):
        """ Get whether or not this object is initialized.

        Returns
        -------
        result : bool
            True if this object has been initialized, False otherwise.

        """
        return self._initialized

    def initialize(self):
        """ A method called by the application to initialize the UI.

        This method is called by the application to allow the object
        tree perform any post-create initialization required. This
        method should only be called once. Multiple calls to this
        method are ignored.

        """
        if not self._initialized:
            for child in self.children():
                child.initialize()
            self.init_layout()
            self._initialized = True

    def init_layout(self):
        """ A method that allows widgets to do layout initialization.

        This method is called after all widgets in a tree have had
        their 'create' method called. It is useful for doing any
        initialization related to layout.

        The default implementation of this method is a no-op in order
        to be super() friendly.

        This method is called by the application in a bottom-up order.

        """
        pass

    def activate(self):
        """ A method called by the session to activate the UI.

        This method is called by the session after the server side
        session has indicated it is ready to accept messages. This
        provides the object tree to make initial request for data
        from the server side objects.

        """
        for child in self.children():
            child.activate()

    def destroy(self):
        """ Destroy this object.

        After an object is destroyed, it is no longer usable and should
        be discarded. All internal references to the object will be
        removed.

        """
        # Destroy the children before destroying the underlying widget
        # this gives the children the opportunity to perform cleanup
        # with an intact parent before being destroyed. Destroying a
        # child will cause it to be removed from the parent, so the
        # list is copied to ensure proper iteration.
        for child in self._children[:]:
            child.destroy()
        self._children = []

        # Only after the children are destroyed is the intialized flag
        # set to False. This allows a child which is being destroyed
        # to fire off the child_removed event on the parent so that
        # the parent can do cleanup before the child is destroyed.
        self._initialized = False

        # Fire the child_removed event immediately, so a child can be
        # removed from any auxiliary container they parent may have
        # placed it in, before the underlying widget is destroyed.
        parent = self._parent
        if parent is not None:
            if self in parent._children:
                parent._children.remove(self)
                if parent._initialized:
                    # Wx has a tendency to destroy the world out from
                    # under the developer, particularly when a wxFrame
                    # is closed. This guards against bad shutdowns by
                    # not sending the child event to the parent if the
                    # widget is already destroyed.
                    if self._widget:
                        parent.child_removed(self)
            self._parent = None

        # Finally, destroy the underlying toolkit widget, since there
        # should no longer be any public references to it.
        widget = self._widget
        if widget:
            widget.Destroy()
            self._widget = None

        # Remove what should be the last remaining strong references to
        # `self` which will allow this object to be garbage collected.
        self._session.unregister(self)
        self._session = None

    #--------------------------------------------------------------------------
    # Parenting Methods
    #--------------------------------------------------------------------------
    def parent(self):
        """ Get the parent of this WxObject.

        Returns
        -------
        result : WxObject or None
            The parent object of this object, or None if it has no
            parent.

        """
        return self._parent

    def children(self):
        """ Get the children of this object.

        Returns
        -------
        result : list
            The list of children of this object. This list should not
            be modified in place by user code.

        """
        return self._children

    def set_parent(self, parent):
        """ Set the parent for this object.

        If the parent is already initialized, then the `child_removed`
        and `child_added` events will be emitted on the parent. Updates
        on the widget are disabled until after the child events on the
        parent have been processed.

        Parameters
        ----------
        parent : WxObject or None
            The parent of this object, or None if it has no parent.

        """
        # Note: The added/removed events must be executed on the next
        # cycle of the event loop. It's possible that this method is
        # being called from the `construct` class method and the child
        # of the widget will not yet exist. This means that child event
        # handlers that rely on the child widget existing will fail.
        curr = self._parent
        if curr is parent or parent is self:
            return

        self._parent = parent
        if curr is not None:
            if self in curr._children:
                curr._children.remove(self)
                if curr._initialized:
                    if self._initialized:
                        curr.child_removed(self)
                    else:
                        DeferredCall(curr.child_removed, self)

        if parent is not None:
            parent._children.append(self)
            if parent._initialized:
                if self._initialized:
                    curr.child_added(self)
                else:
                    DeferredCall(parent.child_added, self)

    def child_removed(self, child):
        """ Called when a child is removed from this object.

        The default implementation of this method hides the toolkit
        widget if the parent of the child is None (since wx cannot
        fully unparent a widget). Subclasses which need more control
        may reimplement this method.

        Parameters
        ----------
        child : WxObject
            The child object removed from this object.

        """
        if child._parent is None:
            widget = child._widget
            if widget and isinstance(widget, wx.Window):
                widget.Hide()

    def child_added(self, child):
        """ A method called when a child is added to this object.

        The default implementation ensures that the toolkit widget is
        properly parented. Subclasses which need more control may
        reimplement this method.

        Parameters
        ----------
        child : WxObject
            The child object added to this object.

        """
        widget = child._widget
        if widget and isinstance(widget, wx.Window):
            parent = self._widget
            if isinstance(parent, wx.Window):
                widget.Reparent(parent)

    def index_of(self, child):
        """ Return the index of the given child.

        Parameters
        ----------
        child : WxObject
            The child of interest.

        Returns
        -------
        result : int
            The index of the given child, or -1 if it is not found.

        """
        children = self._children
        if child in children:
            return children.index(child)
        return -1

    #--------------------------------------------------------------------------
    # Messaging API
    #--------------------------------------------------------------------------
    def send_action(self, action, content):
        """ Send an action on the action pipe for this object.

        The action will only be sent if the object is fully initialized.

        Parameters
        ----------
        action : str
            The name of the action performed.

        content : dict
            The content data for the action.

        """
        if self._initialized:
            self._session.send(self._object_id, action, content)

    #--------------------------------------------------------------------------
    # Action Handlers
    #--------------------------------------------------------------------------
    @deferred_updates
    def on_action_children_changed(self, content):
        """ Handle the 'children_changed' action from the Enaml object.

        This method will unparent the removed children and add the new
        children to this object. If a given new child does not exist, it
        will be built. Subclasses that need more control may reimplement
        this method. The default implementation disables updates on the
        widget while adding children and reenables them on the next cyle
        of the event loop.

        """
        # Unparent the children being removed. Destroying a widget is
        # handled through a separate message.
        lookup = self._session.lookup
        for object_id in content['removed']:
            child = lookup(object_id)
            if child is not None and child._parent is self:
                child.set_parent(None)

        # Build or reparent the children being added.
        for tree in content['added']:
            object_id = tree['object_id']
            child = lookup(object_id)
            if child is not None:
                child.set_parent(self)
            else:
                child = self._session.build(tree, self)
                child.initialize()

        # Update the ordering of the children based on the order given
        # in the message. If the given order does not include all of
        # the current children, then the ones not included will be
        # appended to the end of the new list in an undefined order.
        ordered = []
        curr_set = set(self._children)
        for object_id in content['order']:
            child = lookup(object_id)
            if child is not None and child._parent is self:
                ordered.append(child)
                curr_set.discard(child)
        ordered.extend(curr_set)
        self._children = ordered

    def on_action_destroy(self, content):
        """ Handle the 'destroy' action from the Enaml object.

        This method will call the `destroy` method on the object.

        """
        if self._initialized:
            self.destroy()
        else:
            DeferredCall(self.destroy)


########NEW FILE########
__FILENAME__ = wx_page
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
import wx
import wx.lib.newevent

from .wx_container import WxContainer
from .wx_widget import WxWidget
from .wx_single_widget_sizer import wxSingleWidgetSizer


#: An event emitted when the notebook page is closed.
wxPageClosedEvent, EVT_PAGE_CLOSED = wx.lib.newevent.NewEvent()


class wxPage(wx.Panel):
    """ A wxPanel subclass which acts as a page in a wx notebook.

    """
    def __init__(self, *args, **kwargs):
        """ Initialize a wxPage.

        Parameters
        ----------
        *args, **kwargs
            The position and keyword arguments required to initialize
            a wxContainer.

        """
        super(wxPage, self).__init__(*args, **kwargs)
        self._title = u''
        self._closable = True
        self._is_enabled = True
        self._is_open = True
        self._page_widget = None
        self.SetSizer(wxSingleWidgetSizer())
        self.Bind(wx.EVT_SHOW, self.OnShow)

    #--------------------------------------------------------------------------
    # Event Handlers
    #--------------------------------------------------------------------------
    def OnClose(self, event):
        """ Handle the page close event.

        This event handler is called by the parent notebook. The parent
        event is always be vetoed or else Wx will destroy the page. If
        the page is closable, we close the page and emit the custom
        close event.

        """
        event.Veto()
        if self.GetClosable():
            self.Close()
            evt = wxPageClosedEvent()
            wx.PostEvent(self, evt)

    def OnShow(self, event):
        """ Handle the show event.

        Wx will not emit an EVT_SHOW on the child of this page. So, this
        event handler passes the show event along to the contained page
        widget, so that it can disable its layout when not visible.

        """
        page = self._page_widget
        if page:
            wx.PostEvent(page, event)

    #--------------------------------------------------------------------------
    # Private API
    #--------------------------------------------------------------------------
    def _PageIndexOperation(self, closure):
        """ A private method which will run the given closure if there
        is a valid index for this page.

        """
        parent = self.GetParent()
        if parent:
            index = parent.GetPageIndex(self)
            if index != -1:
                closure(parent, index)

    #--------------------------------------------------------------------------
    # Public API
    #--------------------------------------------------------------------------
    def GetPageWidget(self):
        """ Get the page widget for this page.

        Returns
        -------
        result : wxWindow or None
            The page widget being managed by this page.

        """
        return self._page_widget

    def SetPageWidget(self, widget):
        """ Set the page widget for this page.

        Parameters
        ----------
        widget : wxWindow
            The wx widget to use as the page widget in this page.

        """
        self._page_widget = widget
        self.GetSizer().Add(widget)

    def IsOpen(self):
        """ Get whether or not the page is open.

        Returns
        -------
        result : bool
            True if the page is open, False otherwise.

        """
        return self._is_open

    def Open(self):
        """ Open the page in the notebook.

        """
        self._is_open = True
        parent = self.GetParent()
        if parent:
            parent.ShowWxPage(self)

    def Close(self):
        """ Close the page in the notebook.

        """
        self._is_open = False
        parent = self.GetParent()
        if parent:
            parent.HideWxPage(self)

    def GetEnabled(self):
        """ Get the enabled state of the page.

        This method should be used in favor of IsEnabled.

        Returns
        -------
        result : bool
            True the page is enabled, False otherwise.

        """
        return self._is_enabled

    def SetEnabled(self, enabled):
        """ Set the enabled state of the page.

        This method should be used in favor of Enable.

        Parameters
        ---------
        enabled : bool
            Whether or not the page should be enabled.

        """
        self._is_enabled = enabled
        def closure(nb, index):
            nb.EnableTab(index, enabled)
        self._PageIndexOperation(closure)

    def GetTitle(self):
        """ Returns tab title for this page.

        Returns
        -------
        result : unicode
            The title string for the page's tab.

        """
        return self._title

    def SetTitle(self, title):
        """ Set the title for this page.

        Parameters
        ----------
        title : unicode
            The string to use for this page's tab title.

        """
        self._title = title
        def closure(nb, index):
            nb.SetPageText(index, title)
        self._PageIndexOperation(closure)

    def GetClosable(self):
        """ Returns whether or not this page is closable.

        Returns
        -------
        result : bool
            True if this page is closable, False otherwise.

        """
        return self._closable

    def SetClosable(self, closable):
        """ Set whether this page is closable.

        Parameters
        ----------
        closable : bool
            True if this page should be closable, False otherwise.

        """
        self._closable = closable
        def closure(nb, index):
            nb.SetCloseButton(index, closable)
        self._PageIndexOperation(closure)


class WxPage(WxWidget):
    """ A Wx implementation of an Enaml notebook Page.

    """
    #--------------------------------------------------------------------------
    # Setup Methods
    #--------------------------------------------------------------------------
    def create_widget(self, parent, tree):
        """ Create the underlying wxPage widget.

        """
        return wxPage(parent)

    def create(self, tree):
        """ Create and initialize the page control.

        """
        super(WxPage, self).create(tree)
        self.set_title(tree['title'])
        self.set_closable(tree['closable'])
        self.widget().Bind(EVT_PAGE_CLOSED, self.on_page_closed)

    def init_layout(self):
        """ Initialize the layout of the notebook page.

        """
        super(WxPage, self).init_layout()
        self.widget().SetPageWidget(self.page_widget())

    #--------------------------------------------------------------------------
    # Utility Methods
    #--------------------------------------------------------------------------
    def page_widget(self):
        """ Find and return the page widget child for this widget.

        Returns
        -------
        result : wxWindow or None
            The page widget defined for this widget, or None if one is
            not defined.

        """
        widget = None
        for child in self.children():
            if isinstance(child, WxContainer):
                widget = child.widget()
        return widget

    #--------------------------------------------------------------------------
    # Child Events
    #--------------------------------------------------------------------------
    def child_removed(self, child):
        """ Handle the child removed event for a WxPage.

        """
        if isinstance(child, WxContainer):
            self.widget().SetPageWidget(self.page_widget())

    def child_added(self, child):
        """ Handle the child added event for a WxPage.

        """
        if isinstance(child, WxContainer):
            self.widget().SetPageWidget(self.page_widget())

    #--------------------------------------------------------------------------
    # Event Handlers
    #--------------------------------------------------------------------------
    def on_page_closed(self, event):
        """ The event handler for the EVT_PAGE_CLOSED event.

        """
        self.send_action('closed', {})

    #--------------------------------------------------------------------------
    # Message Handling
    #--------------------------------------------------------------------------
    def on_action_set_title(self, content):
        """ Handle the 'set_title' action from the Enaml widget.

        """
        self.set_title(content['title'])

    def on_action_set_closable(self, content):
        """ Handle the 'set_closable' action from the Enaml widget.

        """
        self.set_closable(content['closable'])

    def on_action_open(self, content):
        """ Handle the 'open' action from the Enaml widget.

        """
        self.widget().Open()

    def on_action_close(self, content):
        """ Handle the 'close' action from the Enaml widget.

        """
        self.widget().Close()

    #--------------------------------------------------------------------------
    # Widget Update Methods
    #--------------------------------------------------------------------------
    def set_visible(self, visible):
        """ An overridden visibility setter which to opens|closes the
        notebook page.

        """
        widget = self.widget()
        if visible:
            widget.Open()
        else:
            widget.Close()

    def set_enabled(self, enabled):
        """ An overridden enabled setter which sets the tab enabled
        state.

        """
        self.widget().SetEnabled(enabled)

    def set_title(self, title):
        """ Set the title of the tab for this page.

        """
        self.widget().SetTitle(title)

    def set_closable(self, closable):
        """ Set whether or not this page is closable.

        """
        self.widget().SetClosable(closable)


########NEW FILE########
__FILENAME__ = wx_progress_bar
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
import wx

from .wx_control import WxControl


class WxProgressBar(WxControl):
    """ A Wx implementation of an Enaml ProgressBar.

    """
    #: The minimum value of the progress bar
    _minimum = 0

    #: The maximum value of the progress bar
    _maximum = 100

    #--------------------------------------------------------------------------
    # Setup Methods
    #--------------------------------------------------------------------------
    def create_widget(self, parent, tree):
        """ Create the underlying wx.Gauge widget.

        """
        return wx.Gauge(parent)

    def create(self, tree):
        """ Create and initialize the progress bar control.

        """
        super(WxProgressBar, self).create(tree)
        self.set_minimum(tree['minimum'])
        self.set_maximum(tree['maximum'])
        self.set_value(tree['value'])

    #--------------------------------------------------------------------------
    # Message Handlers
    #--------------------------------------------------------------------------
    def on_action_set_minimum(self, content):
        """ Handle the 'set_minimum' action from the Enaml widget.

        """
        self.set_minimum(content['minimum'])

    def on_action_set_maximum(self, content):
        """ Handle the 'set_maximum' action from the Enaml widget.

        """
        self.set_maximum(content['maximum'])

    def on_action_set_value(self, content):
        """ Handle the 'set_value' action from the Enaml widget.

        """
        self.set_value(content['value'])

    #--------------------------------------------------------------------------
    # Widget Update Methods
    #--------------------------------------------------------------------------
    def set_minimum(self, value):
        """ Set the minimum value of the progress bar

        """
        self._minimum = value
        self.widget().SetRange(self._maximum - value)

    def set_maximum(self, value):
        """ Set the maximum value of the progress bar

        """
        self._maximum = value
        self.widget().SetRange(value - self._minimum)

    def set_value(self, value):
        """ Set the value of the progress bar

        """
        self.widget().SetValue(value - self._minimum)


########NEW FILE########
__FILENAME__ = wx_push_button
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
import wx

from .wx_abstract_button import WxAbstractButton


class WxPushButton(WxAbstractButton):
    """ A Wx implementation of the Enaml PushButton.

    """
    #--------------------------------------------------------------------------
    # Setup methods
    #--------------------------------------------------------------------------
    def create_widget(self, parent, tree):
        """ Creates the underlying wx.Button control.

        """
        return wx.Button(parent)

    def create(self, tree):
        """ Create and initialize the PushButton control.
        
        """
        super(WxPushButton, self).create(tree)
        self.widget().Bind(wx.EVT_BUTTON, self.on_clicked)

    #--------------------------------------------------------------------------
    # Abstract API Implementation 
    #--------------------------------------------------------------------------
    def set_checkable(self, checkable):
        """ Sets whether or not the widget is checkable.

        """
        # XXX ignore this for now, wx has a completely separate control
        # wx.ToggleButton for handling this, that we'll need to swap
        # out dynamically.
        pass

    def get_checked(self):
        """ Returns the checked state of the widget.

        """
        return False

    def set_checked(self, checked):
        """ Sets the widget's checked state with the provided value.

        """
        pass


########NEW FILE########
__FILENAME__ = wx_radio_button
#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from weakref import WeakKeyDictionary

import wx
import wx.lib.newevent

from .wx_abstract_button import WxAbstractButton


#: A radio button event that is emited when the button is clicked.
wxRadioClicked, EVT_RADIO_CLICKED = wx.lib.newevent.NewEvent()

#: A radio button event emitted when the button value is changed.
wxRadioToggled, EVT_RADIO_TOGGLED = wx.lib.newevent.NewEvent()


class wxProperRadioButton(wx.RadioButton):
    """ A custom stubclass of wx.RadioButton.

    The wx.RadioButton doesn't emit toggled events when it unchecks the
    other radio buttons in the same group. So, the only time an
    EVT_RADIOBUTTON is emitted is when the button changes from off to
    on. This custom subclass does some orchestration and will emit an
    EVT_RADIO_TOGGLED whenever the control changes its value. It also
    emits an EVT_RADIO_CLICKED event when the control is clicked, even
    if the click doesn't change the value in the control.

    """
    #: The WeakKeyDictionary which stores the sibling radio buttons 
    #: for a given parent widget. When any radio button is toggled,
    #: the list of siblings is iterated and each child is given the 
    #: the chance to see it's been toggled off. If it has, then it
    #: will emit a toggled event.
    _parents = WeakKeyDictionary()

    def __init__(self, *args, **kwargs):
        """ Initialize a wxProperRadioButton.

        *args, **kwargs
            The positional and keyword arguments required to initialize
            a wx.RadioButton.

        """
        super(wxProperRadioButton, self).__init__(*args, **kwargs)
        parent = self.GetParent()
        if parent:
            children = self._parents.setdefault(parent, [])
            children.append(self)
        self._last = self.GetValue()
        self._in_click = False
        self.Bind(wx.EVT_LEFT_DOWN, self.OnLeftDown)
        self.Bind(wx.EVT_LEFT_UP, self.OnLeftUp)
        self.Bind(wx.EVT_RADIOBUTTON, self.OnToggled)
        
    def OnLeftDown(self, event):
        """ Handles the left down mouse event for the radio button.

        This is first part of generating a click event.

        """
        event.Skip()
        self._in_click = True

    def OnLeftUp(self, event):
        """ Handles the left up mouse event for the radio button.

        This is the second part of generating a click event.

        """
        event.Skip()
        if self._in_click:
            self._in_click = False
            event = wxRadioClicked()
            wx.PostEvent(self, event)

    def OnToggled(self, event):
        """ Handles the standard toggle event and emits a toggle on
        event. After emitting that event, it will cycle through the 
        list of its siblings and give them a change to emit a toggle
        off event.

        """
        self._last = self.GetValue()
        event = wxRadioToggled()
        wx.PostEvent(self, event)
        self.CheckSiblings()

    def CheckToggledOff(self):
        """ Checks the state of the radio button to see if it has been
        toggled from on to off. If it has, it will emit a toggle off
        event.

        """
        last = self._last
        curr = self.GetValue()
        if not curr and last:
            self._last = curr
            event = wxRadioToggled()
            wx.PostEvent(self, event)

    def CheckSiblings(self):
        """ Iterates over the siblings of this radio button, giving 
        each a chance to respond to a possible toggle off.

        """
        parent = self.GetParent()
        if parent:
            parents = self._parents
            if parent in parents:
                for child in parents[parent]:
                    child.CheckToggledOff()

    def SetValue(self, val):
        """ Overrides the default SetValue method to emit proper events.

        """
        old = self.GetValue()
        if old != val:
            super(wxProperRadioButton, self).SetValue(val)
            self._last = val
            event = wxRadioToggled()
            wx.PostEvent(self, event)
            self.CheckSiblings()
        
    def Destroy(self):
        """ Overridden destroy method to remove the radio button from
        the list of siblings before it's destroyed.

        """
        parent = self.GetParent()
        if parent:
            parents = self._parents
            if parent in parents:
                children = parents[parent]
                try:
                    children.remove(self)
                except ValueError:
                    pass
        super(wxProperRadioButton, self).Destroy()


class WxRadioButton(WxAbstractButton):
    """ A Wx implementation of an Enaml RadioButton.

    WxRadioButton uses a custom wx.RadioButton control. Radio buttons
    with the same parent will be mutually exclusive. For independent
    groups, place them in their own parent component.

    """
    #--------------------------------------------------------------------------
    # Setup Methods
    #--------------------------------------------------------------------------
    def create_widget(self, parent, tree):
        """ Creates the underlying custom wx.RadioButton control.

        """
        return wxProperRadioButton(parent)

    def create(self, tree):
        """ Create and initialize the radio button control.
        
        """
        super(WxRadioButton, self).create(tree)
        widget = self.widget()
        widget.Bind(EVT_RADIO_CLICKED, self.on_clicked)
        widget.Bind(EVT_RADIO_TOGGLED, self.on_toggled)

    #--------------------------------------------------------------------------
    # Abstract API Implementation
    #--------------------------------------------------------------------------
    def set_checkable(self, checkable):
        """ Sets whether or not the widget is checkable.

        """
        # wx doesn't support changing the checkability of a radio button
        pass

    def get_checked(self):
        """ Returns the checked state of the widget.

        """
        return self.widget().GetValue()

    def set_checked(self, checked):
        """ Sets the widget's checked state with the provided value.

        """
        self.widget().SetValue(checked)


########NEW FILE########
__FILENAME__ = wx_scroll_area
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
import wx

from .wx_constraints_widget import WxConstraintsWidget
from .wx_container import WxContainer
from .wx_single_widget_sizer import wxSingleWidgetSizer


# The 'always_on' scroll policy is not supported on wx, because it
# requires setting a window style flag which does not dynamically
# toggle in a reliable fashion. Since we only support 'off' or 'auto'
# it's easiest to use this mapping to convert straight from policy
# values into a respective scroll rate. A rate of Zero causes wx not
# to show the scroll bar. A positive rate indicates to scroll that many
# pixels per event. We set the rate to 1 to have smooth scrolling. Wx
# doesn't make a distinction between scroll events caused by the mouse
# or scrollbar and those caused by clicking the scroll buttons (ala qt),
# and thus this rate applies the same to all of those events. Since we
# expect that clicking on a scroll button happens much more infrequently
# than scrolling by dragging the scroll bar, we opt for a lower rate
# in order to get smooth drag scrolling and sacrifice some usability
# on the scroll buttons.
SCROLLBAR_MAP = {
    'as_needed': 1,
    'always_off': 0,
    'always_on': 1,
}


class wxScrollAreaSizer(wxSingleWidgetSizer):
    """ A wxSingleWidgetSizer subclass which makes adjusts the min
    size to account for a 2 pixel error in Wx.

    """
    def CalcMin(self):
        """ Returns the minimum size for the area owned by the sizer.

        Returns
        -------
        result : wxSize
            The wx size representing the minimum area required by the
            sizer.

        """
        # The effective min size computation is correct, but the wx
        # scrolled window interprets it with an error of 2px. That
        # is we need to make wx think that the min size is 2px smaller
        # than it actually is so that scroll bars should and hide at
        # the appropriate sizes.
        res = super(wxScrollAreaSizer, self).CalcMin()
        if res.IsFullySpecified():
            res.width -= 2
            res.height -= 2
        return res


class wxScrollArea(wx.ScrolledWindow):
    """ A custom wx.ScrolledWindow which is suits Enaml's use case.

    """
    #: The internal best size. The same as QAbstractScrollArea.
    _best_size = wx.Size(256, 192)

    def __init__(self, *args, **kwargs):
        """ Initialize a wxScrollArea.

        Parameters
        ----------
        *args, **kwargs
            The positional and keyword arguments needed to initialize
            a wxScrolledWindow.

        """
        super(wxScrollArea, self).__init__(*args, **kwargs)
        self._scroll_widget = None
        self.SetSizer(wxScrollAreaSizer())

    def GetBestSize(self):
        """ An overridden parent class method which returns a sensible
        best size.

        The default wx implementation returns a best size of (16, 16)
        on Windows; far too small to be useful. So, we just adopt the
        size hint of (256, 192) used in Qt's QAbstractScrollArea.

        """
        return self._best_size

    def GetScrollWidget(self):
        """ Get the scroll widget for this scroll area.

        Returns
        -------
        results : wxWindow
            The wxWindow being scrolled by this scroll area.

        """
        return self._scroll_widget

    def SetScrollWidget(self, widget):
        """ Set the scroll widget for this scroll area.

        Parameters
        ----------
        widget : wxWindow
            The wxWindow which should be scrolled by this area.

        """
        self._scroll_widget = widget
        self.GetSizer().Add(widget)


class WxScrollArea(WxConstraintsWidget):
    """ A Wx implementation of an Enaml ScrollArea.

    """
    #: Storage for the horizontal scroll policy
    _h_scroll = 'as_needed'

    #: Storage for the vertical scroll policy
    _v_scroll = 'as_needed'

    def create_widget(self, parent, tree):
        """ Create the underlying wxScrolledWindow widget.

        """
        style = wx.HSCROLL | wx.VSCROLL | wx.BORDER_SIMPLE
        return wxScrollArea(parent, style=style)

    def create(self, tree):
        """ Create and initialize the scroll area widget.

        """
        super(WxScrollArea, self).create(tree)
        self.set_horizontal_policy(tree['horizontal_policy'])
        self.set_vertical_policy(tree['vertical_policy'])
        self.set_widget_resizable(tree['widget_resizable'])

    def init_layout(self):
        """ Handle the layout initialization for the scroll area.

        """
        super(WxScrollArea, self).init_layout()
        self.widget().SetScrollWidget(self.scroll_widget())

    #--------------------------------------------------------------------------
    # Utility Methods
    #--------------------------------------------------------------------------
    def scroll_widget(self):
        """ Find and return the scroll widget child for this widget.

        Returns
        -------
        result : wxWindow or None
            The scroll widget defined for this widget, or None if one is
            not defined.

        """
        widget = None
        for child in self.children():
            if isinstance(child, WxContainer):
                widget = child.widget()
        return widget

    #--------------------------------------------------------------------------
    # Child Events
    #--------------------------------------------------------------------------
    def child_removed(self, child):
        """ Handle the child removed event for a WxScrollArea.

        """
        if isinstance(child, WxContainer):
            self.widget().SetScrollWidget(self.scroll_widget())

    def child_added(self, child):
        """ Handle the child added event for a WxScrollArea.

        """
        if isinstance(child, WxContainer):
            self.widget().SetScrollWidget(self.scroll_widget())

    #--------------------------------------------------------------------------
    # Overrides
    #--------------------------------------------------------------------------
    def replace_constraints(self, old_cns, new_cns):
        """ A reimplemented WxConstraintsWidget layout method.

        Constraints layout may not cross the boundary of a ScrollArea,
        so this method is no-op which stops the layout propagation.

        """
        pass

    def clear_constraints(self, cns):
        """ A reimplemented WxConstraintsWidget layout method.

        Constraints layout may not cross the boundary of a ScrollArea,
        so this method is no-op which stops the layout propagation.

        """
        pass

    #--------------------------------------------------------------------------
    # Message Handlers
    #--------------------------------------------------------------------------
    def on_action_set_horizontal_policy(self, content):
        """ Handle the 'set_horizontal_policy' action from the Enaml
        widget.

        """
        self.set_horizontal_policy(content['horizontal_policy'])

    def on_action_set_vertical_policy(self, content):
        """ Handle the 'set_vertical_policy' action from the Enaml
        widget.

        """
        self.set_vertical_policy(content['vertical_policy'])

    def on_action_set_widget_resizable(self, content):
        """ Handle the 'set_widget_resizable' action from the Enaml
        widget.

        """
        self.set_widget_resizable(content['widget_resizable'])

    #--------------------------------------------------------------------------
    # Widget Update Methods
    #--------------------------------------------------------------------------
    def set_horizontal_policy(self, policy):
        """ Set the horizontal scrollbar policy of the widget.

        """
        self._h_scroll = policy
        horiz = SCROLLBAR_MAP[policy]
        vert = SCROLLBAR_MAP[self._v_scroll]
        self.widget().SetScrollRate(horiz, vert)

    def set_vertical_policy(self, policy):
        """ Set the vertical scrollbar policy of the widget.

        """
        self._v_scroll = policy
        horiz = SCROLLBAR_MAP[self._h_scroll]
        vert = SCROLLBAR_MAP[policy]
        self.widget().SetScrollRate(horiz, vert)

    def set_widget_resizable(self, resizable):
        """ Set whether or not the scroll widget is resizable.

        """
        # Not currently implemented on Wx
        pass


########NEW FILE########
__FILENAME__ = wx_session
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from collections import defaultdict
import logging

from enaml.utils import make_dispatcher

from .wx_widget_registry import WxWidgetRegistry


logger = logging.getLogger(__name__)


#: The dispatch function for action dispatching.
dispatch_action = make_dispatcher('on_action_', logger)


class WxSession(object):
    """ An object which manages a session of Wx client objects.

    """
    def __init__(self, session_id, widget_groups):
        """ Initialize a WxSession.

        Parameters
        ----------
        session_id : str
            The string identifier for this session.

        widget_groups : list of str
            The list of string widget groups for this session.

        """
        self._session_id = session_id
        self._widget_groups = widget_groups
        self._registered_objects = {}
        self._windows = []
        self._socket = None

    #--------------------------------------------------------------------------
    # Public API
    #--------------------------------------------------------------------------
    def open(self, snapshot):
        """ Open the session using the given snapshot.

        Parameters
        ----------
        snapshot : list of dicts
            The list of tree snapshots to build for this session.

        """
        windows = self._windows
        for tree in snapshot:
            window = self.build(tree, None)
            if window is not None:
                windows.append(window)
                window.initialize()

    def activate(self, socket):
        """ Active the session and its windows.

        Parameters
        ----------
        socket : ActionSocketInterface
            The socket interface to use for messaging with the server
            side Enaml objects.

        """
        # Setup the socket before activation so that widgets may
        # request resources from the server for startup purposes.
        self._socket = socket
        socket.on_message(self.on_message)
        for window in self._windows:
            window.activate()

    def build(self, tree, parent):
        """ Build and return a new widget using the given tree dict.

        Parameters
        ----------
        tree : dict
            The dictionary snapshot representation of the tree of
            items to build.

        parent : WxObject or None
            The parent for the tree, or None if the tree is top-level.

        Returns
        -------
        result : WxObject or None
            The object representation of the root of the tree, or None
            if it could not be built. If the object cannot be built,
            the building errors will be sent to the error logger.

        """
        groups = self._widget_groups
        factory = WxWidgetRegistry.lookup(tree['class'], groups)
        if factory is None:
            for class_name in tree['bases']:
                factory = WxWidgetRegistry.lookup(class_name, groups)
                if factory is not None:
                    break
        if factory is None:
            msg =  'Unhandled object type: %s:%s'
            item_class = tree['class']
            item_bases = tree['bases']
            logger.error(msg % (item_class, item_bases))
            return
        obj = factory().construct(tree, parent, self)
        for child in tree['children']:
            self.build(child, obj)
        return obj

    def register(self, obj):
        """ Register an object with the session.

        WxObjects are registered automatically during construction.

        Parameters
        ----------
        obj : WxObject
            The WxObject to register with the session.

        """
        self._registered_objects[obj.object_id()] = obj

    def unregister(self, obj):
        """ Unregister an object from the session.

        WxObjects are unregistered automatically during destruction.

        Parameters
        ----------
        obj : WxObject
            The WxObject to unregister from the session.

        """
        self._registered_objects.pop(obj.object_id(), None)

    def lookup(self, object_id):
        """ Lookup a registered object with the given object id.

        Parameters
        ----------
        object_id : str
            The object id for the object to lookup.

        Returns
        -------
        result : WxObject or None
            The registered WxObject with the given identifier, or None
            if no registered object is found.

        """
        return self._registered_objects.get(object_id)

    #--------------------------------------------------------------------------
    # Messaging API
    #--------------------------------------------------------------------------
    def send(self, object_id, action, content):
        """ Send a message to a server object.

        This method is called by the `WxObject` instances owned by this
        session to send messages to their server implementations.

        Parameters
        ----------
        object_id : str
            The object id of the server object.

        action : str
            The action that should be performed by the object.

        content : dict
            The content dictionary for the action.

        """
        socket = self._socket
        if socket is not None:
            socket.send(object_id, action, content)

    def on_message(self, object_id, action, content):
        """ Receive a message sent to an object owned by this session.

        This is a handler method registered as the callback for the
        action socket. The message will be routed to the appropriate
        `WxObject` instance.

        Parameters
        ----------
        object_id : str
            The object id of the target object.

        action : str
            The action that should be performed by the object.

        content : dict
            The content dictionary for the action.

        """
        if object_id == self._session_id:
            obj = self
        else:
            try:
                obj = self._registered_objects[object_id]
            except KeyError:
                msg = "Invalid object id sent to WxSession: %s:%s"
                logger.warn(msg % (object_id, action))
                return
        dispatch_action(obj, action, content)

    #--------------------------------------------------------------------------
    # Action Handlers
    #--------------------------------------------------------------------------
    def on_action_add_window(self, content):
        """ Handle the 'add_window' action from the Enaml session.

        """
        window = self.build(content['window'], None)
        if window is not None:
            self._windows.append(window)
            window.initialize()
            window.activate()

    def on_action_message_batch(self, content):
        """ Handle the 'message_batch' action sent by the Enaml session.

        Actions sent to the message batch are processed in the following
        order 'children_changed' -> 'destroy' -> 'relayout' -> other...

        """
        actions = defaultdict(list)
        for item in content['batch']:
            action = item[1]
            actions[action].append(item)
        ordered = []
        batch_order = ('children_changed', 'destroy', 'relayout')
        for key in batch_order:
            ordered.extend(actions.pop(key, ()))
        for value in actions.itervalues():
            ordered.extend(value)
        objects = self._registered_objects
        for object_id, action, msg_content in ordered:
            try:
                obj = objects[object_id]
            except KeyError:
                msg = "Invalid object id sent to WxSession %s:%s"
                logger.warn(msg % (object_id, action))
            else:
                dispatch_action(obj, action, msg_content)

    def on_action_close(self, content):
        """ Handle the 'close' action sent by the Enaml session.

        """
        for window in self._windows:
            window.destroy()
        self._windows = []
        self._registered_objects = {}
        self._socket.on_message(None)
        self._socket = None


########NEW FILE########
__FILENAME__ = wx_single_widget_sizer
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
import wx


class wxSingleWidgetSizer(wx.PySizer):
    """ A custom wx Sizer for sizing a single child widget.

    There can only be one widget in this sizer at a time and it should
    be added via the .Add(...) method. Old items will be removed
    automatically (but not destroyed).

    """
    _default_size = wx.Size(-1, -1)

    _widget = None

    def CalcMax(self):
        """ A method to compute the maximum size allowed by the sizer.

        This is not a native wx sizer method, but is included for
        convenience.

        """
        widget = self._widget
        if not widget:
            return self._default_size
        return widget.GetMaxSize()

    def Add(self, widget):
        """ Adds the given widget to the sizer, removing the old widget
        if present. The old widget is not destroyed.

        """
        if self._widget is not widget:
            self.Clear(deleteWindows=False)
            old = self._widget
            if old:
                old.Hide()
            self._widget = widget
            if widget:
                widget.Show()
                res = super(wxSingleWidgetSizer, self).Add(widget)
                self.Layout()
                return res

    def CalcMin(self):
        """ Returns the minimum size for the children this sizer is
        managing.

        """
        widget = self._widget
        if not widget:
            return self._default_size
        return widget.GetEffectiveMinSize()

    def RecalcSizes(self):
        """ Resizes the child to fit the available space of the window.

        """
        widget = self._widget
        if widget:
            widget.SetSize(self.GetSize())


########NEW FILE########
__FILENAME__ = wx_slider
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
import wx
import wx.lib.newevent

from .wx_control import WxControl


#: Horizontal tick mapping
_TICK_POSITION_MAP = {
    'top': wx.SL_TOP | wx.SL_AUTOTICKS,
    'bottom': wx.SL_BOTTOM | wx.SL_AUTOTICKS,
    'left': wx.SL_LEFT | wx.SL_AUTOTICKS,
    'right': wx.SL_RIGHT | wx.SL_AUTOTICKS,
    'both': wx.SL_BOTH | wx.SL_AUTOTICKS,
}


#: An OR'd combination of all the tick flags.
_TICK_MASK = (
    wx.SL_TOP | wx.SL_BOTTOM | wx.SL_LEFT | wx.SL_RIGHT | wx.SL_BOTH |
    wx.SL_AUTOTICKS
)


#: A map adapting orientation to tick positions
_TICK_ADAPT_MAP = {
    'vertical': {
        'left': 'left',
        'right': 'right',
        'both': 'both',
        'top': 'left',
        'bottom': 'right',
    },
    'horizontal': {
        'left': 'top',
        'right': 'bottom',
        'both': 'both',
        'top': 'top',
        'bottom': 'bottom',
    },
}


#: A map from string orientation to wx slider orientation
_ORIENTATION_MAP = {
    'horizontal': wx.SL_HORIZONTAL,
    'vertical': wx.SL_VERTICAL,
}


#: An OR'd combination of all the orientation flags
_ORIENTATION_MASK = wx.SL_HORIZONTAL | wx.SL_VERTICAL


#: A new event emitted by the custom slider control
wxSliderEvent, EVT_SLIDER = wx.lib.newevent.NewEvent()


class wxProperSlider(wx.Slider):
    """ A wx.Slider subclass which supports tracking.

    """
    #: The event types for the frequent thumb track event
    _tracking_evt = wx.EVT_SCROLL_THUMBTRACK.evtType[0]

    #: The event type for the thumb release event.
    _release_evt = wx.EVT_SCROLL_THUMBRELEASE.evtType[0]

    #: The event type for the scroll end event.
    _end_evt = wx.EVT_SCROLL_CHANGED.evtType[0]

    def __init__(self, *args, **kwargs):
        """ Initialize a wxProperSlider.

        Parameters
        ----------
        *args, **kwargs
            The positional and keyword arguments for initializing a
            wx.Slider.

        """
        super(wxProperSlider, self).__init__(*args, **kwargs)
        self._tracking = True
        self.Bind(wx.EVT_SCROLL, self.OnScroll)

    def OnScroll(self, event):
        """ An event handler which handles all scroll events.

        This handler determines whether or not a slider event sould be
        emitted for the scroll changed, based on whether tracking is
        enabled for the slider.

        """
        evt_type = event.EventType

        # We never emit on the _end_event since that is windows-only
        if evt_type == self._end_evt:
            return

        if self._tracking:
            if evt_type != self._release_evt:
                emit = True
            else:
                emit = False
        else:
            emit = evt_type != self._tracking_evt

        if emit:
            evt = wxSliderEvent()
            wx.PostEvent(self, evt)

    def GetTracking(self):
        """ Whether or not tracking is enabled for the slider.

        Returns
        -------
        result : bool
            True if tracking is enabled for the slider, False otherwise.

        """
        return self._tracking

    def SetTracking(self, tracking):
        """ Set whether tracking is enabled for the slider.

        Parameters
        ----------
        tracking : bool
            True if tracking should be enabled, False otherwise.

        """
        self._tracking = tracking


class WxSlider(WxControl):
    """ A Wx implementation of an Enaml Slider.

    """
    #--------------------------------------------------------------------------
    # Setup Methods
    #--------------------------------------------------------------------------
    def create_widget(self, parent, tree):
        """ Create the underlying wxProperSlider widget.

        """
        return wxProperSlider(parent)

    def create(self, tree):
        """ Create and initialize the slider control.

        """
        # NOTE: The tick interval must be set *after* the tick position
        # or Wx will ignore the tick interval. grrr...
        super(WxSlider, self).create(tree)
        # Initialize the value after the minimum and maximum to avoid
        # the potential for premature internal clipping of the value.
        self.set_minimum(tree['minimum'])
        self.set_maximum(tree['maximum'])
        self.set_value(tree['value'])
        self.set_orientation(tree['orientation'])
        self.set_page_step(tree['page_step'])
        self.set_single_step(tree['single_step'])
        self.set_tick_position(tree['tick_position'])
        self.set_tick_interval(tree['tick_interval'])
        self.set_tracking(tree['tracking'])
        self.widget().Bind(EVT_SLIDER, self.on_value_changed)

    #--------------------------------------------------------------------------
    # Message Handlers
    #--------------------------------------------------------------------------
    def on_action_set_value(self, content):
        """ Handle the 'set_value' action from the Enaml widget.

        """
        self.set_value(content['value'])

    def on_action_set_maximum(self, content):
        """ Handle the 'set_maximum' action from the Enaml widget.

        """
        self.set_maximum(content['maximum'])

    def on_action_set_minimum(self, content):
        """ Handle the 'set_minimum' action from the Enaml widget.

        """
        self.set_minimum(content['minimum'])

    def on_action_set_orientation(self, content):
        """ Handle the 'set_orientation' action from the Enaml widget.

        """
        self.set_orientation(content['orientation'])

    def on_action_set_page_step(self, content):
        """ Handle the 'set_page_step' action from the Enaml widget.

        """
        self.set_page_step(content['page_step'])

    def on_action_set_single_step(self, content):
        """ Handle the 'set_single_step' action from the Enaml widget.

        """
        self.set_single_step(content['single_step'])

    def on_action_set_tick_interval(self, content):
        """ Handle the 'set_tick_interval' action from the Enaml widget.

        """
        self.set_tick_interval(content['tick_interval'])

    def on_action_set_tick_position(self, content):
        """ Handle the 'set_tick_position' action from the Enaml widget.

        """
        self.set_tick_position(content['tick_position'])

    def on_action_set_tracking(self, content):
        """ Handle the 'set_tracking' action from the Enaml widget.

        """
        self.set_tracking(content['tracking'])

    #--------------------------------------------------------------------------
    # Event Handlers
    #--------------------------------------------------------------------------
    def on_value_changed(self, event):
        """ Send the 'value_changed' action to the Enaml widget when the
        slider value has changed.

        """
        content = {'value': self.widget().GetValue()}
        self.send_action('value_changed', content)

    #--------------------------------------------------------------------------
    # Widget Update Methods
    #--------------------------------------------------------------------------
    def set_value(self, value):
        """ Set the value of the underlying widget.

        """
        self.widget().SetValue(value)

    def set_maximum(self, maximum):
        """ Set the maximum value of the underlying widget.

        """
        widget = self.widget()
        minimum, _ = widget.GetRange()
        widget.SetRange(minimum, maximum)

    def set_minimum(self, minimum):
        """ Set the minimum value of the underlying widget.

        """
        widget = self.widget()
        _, maximum = widget.GetRange()
        widget.SetRange(minimum, maximum)

    def set_orientation(self, orientation):
        """ Set the orientation of the underlying widget.

        """
        widget = self.widget()
        style = widget.GetWindowStyle()
        style &= ~_ORIENTATION_MASK
        style |= _ORIENTATION_MAP[orientation]
        widget.SetWindowStyle(style)

    def set_page_step(self, page_step):
        """ Set the page step of the underlying widget.

        """
        self.widget().SetPageSize(page_step)

    def set_single_step(self, single_step):
        """ Set the single step of the underlying widget.

        """
        self.widget().SetLineSize(single_step)

    def set_tick_interval(self, interval):
        """ Set the tick interval of the underlying widget.

        """
        self.widget().SetTickFreq(interval)

    def set_tick_position(self, tick_position):
        """ Set the tick position of the underlying widget.

        """
        widget = self.widget()
        style = widget.GetWindowStyle()
        style &= ~_TICK_MASK
        if tick_position != 'no_ticks':
            if style & wx.SL_VERTICAL:
                tick_position = _TICK_ADAPT_MAP['vertical'][tick_position]
            else:
                tick_position = _TICK_ADAPT_MAP['horizontal'][tick_position]
            style |= _TICK_POSITION_MAP[tick_position]
        widget.SetWindowStyle(style)

    def set_tracking(self, tracking):
        """ Set the tracking of the underlying widget.

        """
        self.widget().SetTracking(tracking)


########NEW FILE########
__FILENAME__ = wx_spin_box
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
import wx
import wx.lib.newevent

from .wx_control import WxControl


#: The changed event for the custom spin box
wxSpinBoxEvent, EVT_SPIN_BOX = wx.lib.newevent.NewEvent()


class wxProperSpinBox(wx.SpinCtrl):
    """ A custom wx spin control that acts more like QSpinBox.

    The standard wx.SpinCtrl doesn't support too many features, and
    the ones it does support are (like wrapping) are limited. So,
    this custom control hard codes the internal range to the maximum
    range of the wx.SpinCtrl and implements wrapping manually.

    For changed events, users should bind to EVT_SPIN_BOX rather than
    EVT_SPINCTRL.

    See the method docstrings for supported functionality.

    This control is really a god awful hack and needs to be rewritten
    using a combination wx.SpinButton and wx.TextCtrl.

    """
    def __init__(self, *args, **kwargs):
        """ CustomSpinCtrl constructor.

        Parameters
        ----------
        *args, **kwargs
            The positional and keyword arguments for initializing a
            wx.SpinCtrl.

        """
        # The max range of the wx.SpinCtrl is the range of a signed
        # 32bit integer. We don't care about wx's internal value of
        # the control, since we maintain our own internal counter.
        # and because the internal value of the widget gets reset to
        # the minimum of the range whenever SetValueString is called.
        self._hard_min = -(1 << 31)
        self._hard_max = (1 << 31) - 1
        self._internal_value = 0
        self._low = 0
        self._high = 100
        self._step = 1
        self._prefix = u''
        self._suffix = u''
        self._special_value_text = u''
        self._value_string = unicode(self._low)
        self._wrap = False
        self._read_only = False

        # Stores whether spin-up or spin-down was pressed.
        self._spin_state = None

        super(wxProperSpinBox, self).__init__(*args, **kwargs)
        super(wxProperSpinBox, self).SetRange(self._hard_min, self._hard_max)

        # Setting the spin control to process the enter key removes
        # its processing of the Tab key. This is desired for two reasons:
        # 1) It is consistent with the Qt version of the control.
        # 2) The default tab processing is kinda wacky in that when
        #    tab is pressed, it emits a text event with the string
        #    representation of the integer value of the control,
        #    regardless of the value of the user supplied string.
        #    This is definitely not correct and so processing on
        #    Enter allows us to avoid the issue entirely.
        self.WindowStyle |= wx.TE_PROCESS_ENTER

        self.Bind(wx.EVT_SPIN_UP, self.OnSpinUp)
        self.Bind(wx.EVT_SPIN_DOWN, self.OnSpinDown)
        self.Bind(wx.EVT_SPINCTRL, self.OnSpinCtrl)
        self.Bind(wx.EVT_TEXT, self.OnText)
        self.Bind(wx.EVT_KILL_FOCUS, self.OnKillFocus)
        self.Bind(wx.EVT_TEXT_ENTER, self.OnEnterPressed)

    #--------------------------------------------------------------------------
    # Event Handlers
    #--------------------------------------------------------------------------
    def OnEnterPressed(self, event):
        """ The event handler for an enter key press. It forces an
        interpretation of the current text control value.

        """
        self.InterpretText()

    def OnKillFocus(self, event):
        """ Handles evaluating the text in the control when the control
        loses focus.

        """
        # The spin control doesn't emit a spin event when losing focus
        # to process typed input change unless it results in a different
        # value, so we have to handle it manually and update the control
        # again after the event. It must be invoked on a CallAfter or it
        # doesn't work properly. The lambda avoids a DeadObjectError if
        # the app is exited before the callback executes.
        wx.CallAfter(lambda: self.InterpretText() if self else None)

    def OnText(self, event):
        """ Handles the text event of the spin control to store away the
        user typed text for later conversion.

        """
        if self._read_only:
            return
        # Do not be tempted to try to implement the 'tracking' feature
        # by adding logic to this method. Wx emits this event at weird
        # times such as ctrl-a select all as well as when SetValueString
        # is called. Granted, this can be avoided with a recursion guard,
        # however, there is no way to get/set the caret position on the
        # control and every call to SetValueString resets the caret
        # position to Zero. So, there is really no possible way to
        # implement 'tracking' without creating an entirely new custom
        # control. So for now, the wx backend just lacks that feature.
        self._value_string = event.GetString()

    def OnSpinUp(self, event):
        """ The event handler for the spin up event. We veto the spin
        event to prevent the control from changing it's internal value.
        Instead, we maintain complete control of the value.

        """
        event.Veto()
        if self._read_only:
            return
        self._spin_state = 'up'
        self.OnSpinCtrl(event)
        self._spin_state = None

    def OnSpinDown(self, event):
        """ The event handler for the spin down event. We veto the spin
        event to prevent the control from changing it's internal value.
        Instead, we maintain complete control of the value.

        """
        event.Veto()
        if self._read_only:
            return
        self._spin_state = 'down'
        self.OnSpinCtrl(event)
        self._spin_state = None

    def OnSpinCtrl(self, event):
        """ Handles the spin control being changed by user interaction.
        All of the manual stepping and wrapping logic is computed by
        this method.

        """
        if self._read_only:
            return
        last = self._internal_value
        low = self._low
        high = self._high
        step = self._step
        wrap = self._wrap
        spin_state = self._spin_state
        if spin_state == 'down':
            if last == low:
                if wrap:
                    computed = high
                else:
                    computed = low
            else:
                computed = last - step
                if computed < low:
                    computed = low
            self.SetValue(computed)
        elif spin_state == 'up':
            if last == high:
                if wrap:
                    computed = low
                else:
                    computed = high
            else:
                computed = last + step
                if computed > high:
                    computed = high
            self.SetValue(computed)
        else:
            # A suprious spin event generated by wx when the widget loses
            # focus. We can safetly ignore it.
            pass

    #--------------------------------------------------------------------------
    # Getters/Setters
    #--------------------------------------------------------------------------
    def GetLow(self):
        """ Returns the minimum value of the control.

        """
        return self._low

    def GetMin(self):
        """ Equivalent to GetLow().

        """
        return self._low

    def SetLow(self, low):
        """ Sets the minimum value of the control and changes the
        value to the min if the current value would be out of range.

        """
        if low < self._hard_min:
            raise ValueError('%s is too low for wxProperSpinBox.' % low)
        self._low = low
        if self.GetValue() < low:
            self.SetValue(low)

    def GetHigh(self):
        """ Returns the maximum value of the control.

        """
        return self._high

    def GetMax(self):
        """ Equivalent to GetHigh().

        """
        return self._high

    def SetHigh(self, high):
        """ Sets the maximum value of the control and changes the
        value to the max if the current value would be out of range.

        """
        if high > self._hard_max:
            raise ValueError('%s is too high for wxProperSpinBox.' % high)
        self._high = high
        if self.GetValue() > high:
            self.SetValue(high)

    def SetRange(self, low, high):
        """ Sets the low and high values of the control.

        """
        self.SetLow(low)
        self.SetHigh(high)

    def GetStep(self):
        """ Returns the step size of the control.

        """
        return self._step

    def SetStep(self, step):
        """ Sets the step size of the control.

        """
        self._step = step

    def GetWrap(self):
        """ Gets the wrap flag of the control.

        """
        return self._wrap

    def SetWrap(self, wrap):
        """ Sets the wrap flag of the control.

        """
        self._wrap = wrap

    def GetPrefix(self):
        """ Get the prefix text for the control.

        Returns
        -------
        result : unicode
            The unicode prefix text.

        """
        return self._prefix

    def SetPrefix(self, prefix):
        """ Set the prefix text for the control.

        Parameters
        ----------
        prefix : unicode
            The unicode prefix text for the control.

        """
        self._prefix = prefix

    def GetSuffix(self):
        """ Get the suffix text for the control.

        Returns
        -------
        result : unicode
            The unicode suffix text.

        """
        return self._suffix

    def SetSuffix(self, suffix):
        """ Set the suffix text for the control.

        Parameters
        ----------
        suffix : unicode
            The unicode suffix text for the control.

        """
        self._suffix = suffix

    def GetSpecialValueText(self):
        """ Returns the special value text for the spin box.

        Returns
        -------
        result : unicode
            The unicode special value text.

        """
        return self._special_value_text

    def SetSpecialValueText(self, text):
        """ Set the special value text for the control.

        Parameters
        ----------
        text : unicode
            The unicode special value text for the control.

        """
        self._special_value_text = text

    def GetReadOnly(self):
        """ Get the read only flag for the control.

        Returns
        -------
        result : bool
            True if the control is read only, False otherwise.

        """
        return self._suffix

    def SetReadOnly(self, read_only):
        """ Set the read only flag for the control

        Parameters
        ----------
        read_only : bool
            True if the control should be read only, False otherwise.

        """
        self._read_only = read_only

    def GetValue(self):
        """ Returns the internal integer value of the control.

        """
        return self._internal_value

    def SetValue(self, value):
        """ Sets the value of the control to the given value, provided
        that the value is within the range of the control. If the
        given value is within range, and is different from the current
        value of the control, an EVT_SPIN_BOX will be emitted.

        """
        different = False
        if self._low <= value <= self._high:
            different = (self._internal_value != value)
            self._internal_value = value

        # Always set the value string, just to be overly
        # safe that we don't fall out of sync.
        self._value_string = self.TextFromValue(self._internal_value)
        self.SetValueString(self._value_string)

        if different:
            evt = wxSpinBoxEvent()
            wx.PostEvent(self, evt)

    #--------------------------------------------------------------------------
    # Support Methods
    #--------------------------------------------------------------------------
    def InterpretText(self):
        """ Interprets the user supplied text and updates the control.

        """
        prefix = self._prefix
        suffix = self._suffix
        svt = self._special_value_text
        text = self._value_string
        if svt and text == svt:
            self.SetValue(self._low)
            return
        if prefix and text.startswith(prefix):
            text = text[len(prefix):]
        if suffix and text.endswith(suffix):
            text = text[:-len(suffix)]
        try:
            value = int(text)
        except ValueError:
            value = self._internal_value
        self.SetValue(value)

    def TextFromValue(self, value):
        """ Converts the given integer to a string for display.

        """
        prefix = self._prefix
        suffix = self._suffix
        svt = self._special_value_text
        if value == self._low and svt:
            return svt
        text = unicode(value)
        if prefix:
            text = '%s%s' % (prefix, text)
        if suffix:
            text = '%s%s' % (text, suffix)
        return text


class WxSpinBox(WxControl):
    """ A Wx implementation of an Enaml SpinBox.

    """
    #--------------------------------------------------------------------------
    # Setup Methods
    #--------------------------------------------------------------------------
    def create_widget(self, parent, tree):
        """ Create the underlying wxProperSpinBox widget.

        """
        return wxProperSpinBox(parent)

    def create(self, tree):
        """ Create and initialize the slider control.

        """
        super(WxSpinBox, self).create(tree)
        self.set_maximum(tree['maximum'])
        self.set_minimum(tree['minimum'])
        self.set_value(tree['value'])
        self.set_prefix(tree['prefix'])
        self.set_suffix(tree['suffix'])
        self.set_special_value_text(tree['special_value_text'])
        self.set_single_step(tree['single_step'])
        self.set_read_only(tree['read_only'])
        self.set_wrapping(tree['wrapping'])
        self.widget().Bind(EVT_SPIN_BOX, self.on_value_changed)

    #--------------------------------------------------------------------------
    # Event Handlers
    #--------------------------------------------------------------------------
    def on_value_changed(self, event):
        """ The event handler for the 'EVT_SPIN_BOX' event.

        """
        content = {'value': self.widget().GetValue()}
        self.send_action('value_changed', content)

    #--------------------------------------------------------------------------
    # Message Handlers
    #--------------------------------------------------------------------------
    def on_action_set_maximum(self, content):
        """ Handler for the 'set_maximum' action from the Enaml widget.

        """
        self.set_maximum(content['maximum'])

    def on_action_set_minimum(self, content):
        """ Handler for the 'set_minimum' action from the Enaml widget.

        """
        self.set_minimum(content['minimum'])

    def on_action_set_value(self, content):
        """ Handler for the 'set_value' action from the Enaml widget.

        """
        self.set_value(content['value'])

    def on_action_set_prefix(self, content):
        """ Handler for the 'set_prefix' action from the Enaml widget.

        """
        self.set_prefix(content['prefix'])

    def on_action_set_suffix(self, content):
        """ Handler for the 'set_suffix' action from the Enaml widget.

        """
        self.set_suffix(content['suffix'])

    def on_action_set_special_value_text(self, content):
        """ Handler for the 'set_special_value_text' action from the
        Enaml widget.

        """
        self.set_special_value_text(content['special_value_text'])

    def on_action_set_single_step(self, content):
        """ Handler for the 'set_single_step' action from the Enaml
        widget.

        """
        self.set_single_step(content['single_step'])

    def on_action_set_read_only(self, content):
        """ Handler for the 'set_read_only' action from the Enaml
        widget.

        """
        self.set_read_only(content['read_only'])

    def on_action_set_wrapping(self, content):
        """ Handler for the 'set_wrapping' action from the Enaml
        widget.

        """
        self.set_wrapping(content['wrapping'])

    #--------------------------------------------------------------------------
    # Widget Update Methods
    #--------------------------------------------------------------------------
    def set_maximum(self, maximum):
        """ Set the widget's maximum value.

        """
        self.widget().SetHigh(maximum)

    def set_minimum(self, minimum):
        """ Set the widget's minimum value.

        """
        self.widget().SetLow(minimum)

    def set_value(self, value):
        """ Set the spin box's value.

        """
        self.widget().SetValue(value)

    def set_prefix(self, prefix):
        """ Set the prefix for the spin box.

        """
        self.widget().SetPrefix(prefix)

    def set_suffix(self, suffix):
        """ Set the suffix for the spin box.

        """
        self.widget().SetSuffix(suffix)

    def set_special_value_text(self, text):
        """ Set the special value text for the spin box.

        """
        self.widget().SetSpecialValueText(text)

    def set_single_step(self, step):
        """ Set the widget's single step value.

        """
        self.widget().SetStep(step)

    def set_read_only(self, read_only):
        """ Set the widget's read only flag.

        """
        self.widget().SetReadOnly(read_only)

    def set_wrapping(self, wrapping):
        """ Set the widget's wrapping flag.

        """
        self.widget().SetWrap(wrapping)


########NEW FILE########
__FILENAME__ = wx_splitter
#------------------------------------------------------------------------------
# Copyright (c) 2012, Enthought, Inc.
# All rights reserved.
#------------------------------------------------------------------------------
import wx
from wx.lib.splitter import MultiSplitterWindow

from .wx_constraints_widget import WxConstraintsWidget
from .wx_split_item import WxSplitItem


_ORIENTATION_MAP = {
    'horizontal': wx.HORIZONTAL,
    'vertical': wx.VERTICAL,
}


class wxSplitter(MultiSplitterWindow):
    """ A wx.lib.splitter.MultiSplitterWindow subclass that changes
    the behavior of resizing neighbors to be consistent with Qt.

    """
    def _OnMouse(self, event):
        """ Overriden parent class mouse event handler which fakes the
        state of the keyboard so that resize behavior is consistent
        between wx and Qt.

        """
        # We modify the mouse event to "fake" like the shift key is
        # always down. This causes the splitter to not adjust its
        # neighbor when dragging the sash. This behavior is consistent
        # with Qt's behavior. This is not *the best* way to handle this,
        # but it's the easiest and quickest at the moment. The proper
        # way would be to reimplement this method in its entirety and
        # allow the adjustNeighbor computation to be based on keyboard
        # state as well as attribute flags.
        #
        # TODO implement this properly (or just rewrite this entire
        # control, because like everything else in Wx, it's crap).
        event.m_shiftDown = True
        return super(wxSplitter, self)._OnMouse(event)

    def _GetWindowMin(self, window):
        """ Overriden parent class method which properly computes the
        window min size.

        """
        size = window.GetEffectiveMinSize()
        if self._orient == wx.HORIZONTAL:
            res = size.GetWidth()
        else:
            res = size.GetHeight()
        return res

    def _GetSashSize(self):
        """ Overridden parent class method to return a proper sash size
        for the custom sash painting.

        """
        return 4

    def _DrawSash(self, dc):
        """ Overridden parent class method which draws a custom sash.

        On Windows, the default themed sash drawing causes the sash to
        not be visible; this method corrects that problem and draws a
        sash which is visibly similar to Enaml's Qt Windows version.

        """
        sash_size = self._GetSashSize()
        width, height = self.GetClientSize()
        light_pen = wx.WHITE_PEN
        dark_pen = wx.GREY_PEN
        brush = wx.Brush(self.GetBackgroundColour())
        if self._orient == wx.HORIZONTAL:
            pos = 0
            for sash in self._sashes[:-1]:
                pos += sash
                dc.SetPen(wx.TRANSPARENT_PEN)
                dc.SetBrush(brush)
                dc.DrawRectangle(pos, 0, sash_size, height)
                dc.SetPen(light_pen)
                dc.DrawLine(pos + 1, 0, pos + 1, height)
                dc.SetPen(dark_pen)
                dc.DrawLine(pos + 2, 0, pos + 2, height)
                pos += sash_size
        else:
            pos = 0
            for sash in self._sashes[:-1]:
                pos += sash
                dc.SetPen(wx.TRANSPARENT_PEN)
                dc.SetBrush(brush)
                dc.DrawRectangle(0, pos, width, sash_size)
                dc.SetPen(light_pen)
                dc.DrawLine(0, pos + 1, width, pos + 1)
                dc.SetPen(dark_pen)
                dc.DrawLine(0, pos + 2, width, pos + 2)
                pos += sash_size

    def _OnSize(self, event):
        """ Overridden parent class method which resizes the sashes.

        The default Wx behavior allocates all extra space to the last
        split item, and it will clip the items when the window size is
        reduced. This override uses a weighted algorithm to allocate
        the free space among the items and will not allow the items
        to be clipped by a window resize.

        """
        # Pre-fetch some commonly used objects
        get_min = self._GetWindowMin
        windows = self._windows
        sashes = self._sashes

        # Compute the total space available for the sashes
        sash_widths = self._GetSashSize() * (len(windows) - 1)
        offset = sash_widths + 2 * self._GetBorderSize()
        if self._orient == wx.HORIZONTAL:
            free_space = self.GetClientSize().GetWidth() - offset
        else:
            free_space = self.GetClientSize().GetHeight() - offset

        # Compute the effective stretch factors for each window. The
        # effective stretch factor is the greater of the current or
        # minimum width of the window, multiplied by the window's
        # stretch factor.
        parts = []
        total_stretch = 0
        for idx, (sash, window) in enumerate(zip(sashes, windows)):
            minw = get_min(window)
            if sash < minw:
                sash = sashes[idx] = minw
            stretch = window.GetStretch() * sash
            parts.append((stretch, idx, minw, window))
            total_stretch += stretch

        # Add (or remove) the extra space by fairly allocating it to
        # each window based on their effective stretch factor.
        diff_space = free_space - sum(sashes)
        for stretch, idx, minw, window in parts:
            if stretch > 0:
                d = diff_space * stretch / total_stretch
                new = max(sashes[idx] + d, minw)
                sashes[idx] = new

        # Since the windows are clipped to their minimum width, it's
        # possible that the current space occupied by the windows will
        # be too large. In that case, the overage is distributed to the
        # windows fairly, based on their relative capacity for shrink.
        curr_space = sum(sashes)
        if curr_space > free_space:
            diffs = []
            total_diff = 0
            for stretch, idx, minw, window in parts:
                diff = sashes[idx] - minw
                if diff > 0:
                    diffs.append((diff, window, idx, minw))
                    total_diff += diff
            remaining = curr_space - free_space
            diffs.sort()
            for diff, window, idx, minw in reversed(diffs):
                delta = remaining * diff / total_diff
                old = sashes[idx]
                new = max(old - delta, minw)
                actual_diff = old - new
                remaining -= actual_diff
                total_diff -= actual_diff
                sashes[idx] = new

        # The superclass handler which will actually perform the layout.
        super(wxSplitter, self)._OnSize(event)


class WxSplitter(WxConstraintsWidget):
    """ A Wx implementation of an Enaml Splitter.

    """
    #--------------------------------------------------------------------------
    # Setup methods
    #--------------------------------------------------------------------------
    def create_widget(self, parent, tree):
        """ Creates the underlying wxSplitter widget.

        """
        return wxSplitter(parent)

    def create(self, tree):
        """ Create and initialize the splitter control.
        """
        super(WxSplitter, self).create(tree)
        self.set_orientation(tree['orientation'])
        self.set_live_drag(tree['live_drag'])

    def init_layout(self):
        """ Handle the layout initialization for the splitter.

        """
        super(WxSplitter, self).init_layout()
        widget = self.widget()
        for child in self.children():
            if isinstance(child, WxSplitItem):
                widget.AppendWindow(child.widget())

    #--------------------------------------------------------------------------
    # Child Events
    #--------------------------------------------------------------------------
    def child_removed(self, child):
        """ Handle the child removed event for a WxSplitter.

        """
        if isinstance(child, WxSplitItem):
            widget = child.widget()
            self.widget().DetachWindow(widget)
            widget.Hide()
            self.size_hint_updated()

    def child_added(self, child):
        """ Handle the child added event for a WxSplitter.

        """
        if isinstance(child, WxSplitItem):
            index = self.index_of(child)
            if index != -1:
                self.widget().InsertWindow(index, child.widget())
                self.size_hint_updated()

    #--------------------------------------------------------------------------
    # Message Handler Methods
    #--------------------------------------------------------------------------
    def on_action_set_orientation(self, content):
        """ Handle the 'set_orientation' action from the Enaml widget.

        """
        self.set_orientation(content['orientation'])
        self.size_hint_updated()

    def on_action_set_live_drag(self, content):
        """ Handle the 'set_live_drag' action from the Enaml widget.

        """
        self.set_live_drag(content['live_drag'])

    #--------------------------------------------------------------------------
    # Widget Update Methods
    #--------------------------------------------------------------------------
    def set_orientation(self, orientation):
        """ Update the orientation of the splitter.

        """
        wx_orientation = _ORIENTATION_MAP[orientation]
        widget = self.widget()
        widget.SetOrientation(wx_orientation)
        widget.SizeWindows()

    def set_live_drag(self, live_drag):
        """ Updates the drag state of the splitter.

        """
        widget = self.widget()
        if live_drag:
            widget.WindowStyle |= wx.SP_LIVE_UPDATE
        else:
            widget.WindowStyle &= ~wx.SP_LIVE_UPDATE


########NEW FILE########
__FILENAME__ = wx_split_item
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
import wx

from .wx_single_widget_sizer import wxSingleWidgetSizer
from .wx_container import WxContainer
from .wx_widget import WxWidget


class wxSplitItem(wx.Panel):
    """ A wxPanel subclass which acts as an item in a wxSplitter.

    """
    def __init__(self, parent):
        """ Initialize a wxSplitItem.

        Parameters
        ----------
        parent : wx.Window
            The parent widget of the split item.

        """
        super(wxSplitItem, self).__init__(parent)
        self._split_widget = None
        self._stretch = 0
        self.SetSizer(wxSingleWidgetSizer())

    def GetSplitWidget(self):
        """ Get the split widget for this split item.

        Returns
        -------
        result : wxWindow or None
            The split widget being managed by this item.

        """
        return self._split_widget

    def SetSplitWidget(self, widget):
        """ Set the split widget for this split item.

        Parameters
        ----------
        widget : wxWindow
            The wxWindow to use as the split widget in this item.

        """
        self._split_widget = widget
        self.GetSizer().Add(widget)

    def GetStretch(self):
        """ Get the stretch factor for the widget.

        Returns
        -------
        result : int
            The stretch factor for the widget.

        """
        return self._stretch

    def SetStretch(self, stretch):
        """ Set the stretch factor for the widget.

        Parameters
        ----------
        stretch : int
            The stretch factor for the widget.

        """
        self._stretch = stretch


class WxSplitItem(WxWidget):
    """ A Wx implementation of an Enaml SplitItem.

    """
    #--------------------------------------------------------------------------
    # Setup Methods
    #--------------------------------------------------------------------------
    def create_widget(self, parent, tree):
        """ Create the underlying QStackItem widget.

        """
        return wxSplitItem(parent)

    def create(self, tree):
        """ Create and initialize the underyling widget.

        """
        super(WxSplitItem, self).create(tree)
        self.set_stretch(tree['stretch'])
        self.set_collapsible(tree['collapsible'])

    def init_layout(self):
        """ Initialize the layout for the underyling widget.

        """
        super(WxSplitItem, self).init_layout()
        self.widget().SetSplitWidget(self.split_widget())

    #--------------------------------------------------------------------------
    # Utility Methods
    #--------------------------------------------------------------------------
    def split_widget(self):
        """ Find and return the split widget child for this widget.

        Returns
        -------
        result : wxWindow or None
            The split widget defined for this widget, or None if one is
            not defined.

        """
        widget = None
        for child in self.children():
            if isinstance(child, WxContainer):
                widget = child.widget()
        return widget

    #--------------------------------------------------------------------------
    # Child Events
    #--------------------------------------------------------------------------
    def child_removed(self, child):
        """ Handle the child removed event for a WxSplitItem.

        """
        if isinstance(child, WxContainer):
            self.widget().SetSplitWidget(self.split_widget())

    def child_added(self, child):
        """ Handle the child added event for a QtSplitItem.

        """
        if isinstance(child, WxContainer):
            self.widget().SetSplitWidget(self.split_widget())

    #--------------------------------------------------------------------------
    # Message Handlers
    #--------------------------------------------------------------------------
    def on_action_set_stretch(self, content):
        """ Handle the 'set_stretch' action from the Enaml widget.

        """
        self.set_stretch(content['stretch'])

    def on_action_set_collapsible(self, content):
        """ Handle the 'set_collapsible' action from the Enaml widget.

        """
        self.set_collapsible(content['collapsible'])

    #--------------------------------------------------------------------------
    # Widget Update Methods
    #--------------------------------------------------------------------------
    def set_stretch(self, stretch):
        """ Set the stretch factor for the underlying widget.

        """
        self.widget().SetStretch(stretch)

    def set_collapsible(self, collapsible):
        """ Set the collapsible flag for the underlying widget.

        """
        # Not supported on Wx
        pass


########NEW FILE########
__FILENAME__ = wx_tool_bar
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
import wx

from .wx_action import WxAction, EVT_ACTION_CHANGED
from .wx_action_group import WxActionGroup
from .wx_constraints_widget import WxConstraintsWidget


#: A mapping from Enaml orientation to wx Orientation
_ORIENTATION_MAP = {
    'horizontal': wx.HORIZONTAL,
    'vertical': wx.VERTICAL,
}


class wxToolBar(wx.ToolBar):
    """ A wx.ToolBar subclass which handles wxAction instances.

    """
    def __init__(self, *args, **kwargs):
        """ Initialize a wxToolBar.

        Parameters
        ----------
        *args, **kwargs
            The position and keyword arguments needed to initialize
            an AuiToolBar.

        """
        super(wxToolBar, self).__init__(*args, **kwargs)
        self._all_items = []
        self._actions_map = {}

    #--------------------------------------------------------------------------
    # Private API
    #--------------------------------------------------------------------------
    def _InsertAction(self, index, action):
        """ Insert a new tool into the tool bar for the given action.

        Parameters
        ----------
        action : wxAction
            The wxAction instance to add to the tool bar.

        Returns
        -------
        result : wxToolBarToolBase
            The tool base item created when adding the control to the
            tool bar.

        """
        if action.IsSeparator():
            item = self.InsertSeparator(index)
        else:
            text = action.GetText()
            short_help = action.GetToolTip()
            long_help = action.GetStatusTip()
            action_id = action.GetId()
            bmp = wx.EmptyBitmap(0, 0)
            if action.IsCheckable():
                item = self.InsertLabelTool(
                    index, action_id, text, bmp, kind=wx.ITEM_CHECK,
                    shortHelp=short_help, longHelp=long_help,
                )
                if action.IsChecked() != item.IsToggled():
                    item.Toggle()
            else:
                item = self.InsertLabelTool(
                    index, action_id, text, bmp, kind=wx.ITEM_NORMAL,
                    shortHelp=short_help, longHelp=long_help,
                )
            item.Enable(action.IsEnabled())
        return item

    def OnActionChanged(self, event):
        """ The event handler for the EVT_ACTION_CHANGED event.

        This handler will be called when a child action changes. It
        ensures that the new state of the child action is in sync with
        the associated tool bar item.

        """
        event.Skip()
        action = event.GetEventObject()
        item = self._actions_map.get(action)

        # Handle a visibility change. The tool must be added/removed.
        visible = action.IsVisible()
        if visible != bool(item):
            if visible:
                index = self._all_items.index(action)
                index = min(index, len(self._actions_map))
                new_item = self._InsertAction(index, action)
                self._actions_map[action] = new_item
                self.Realize()
            else:
                self.DeleteTool(item.GetId())
                del self._actions_map[action]
            return

        # If the item is invisible, there is nothing to update.
        if not item:
            return

        # Handle a separator change. The existing tool must be replaced.
        if action.IsSeparator() != item.IsSeparator():
            self.DeleteTool(item.GetId())
            del self._actions_map[action]
            index = self._all_items.index(action)
            index = min(index, len(self._actions_map))
            new_item = self._InsertAction(index, action)
            self._actions_map[action] = new_item
            self.Realize()
            return

        # Handle a checkable change. The existing too must be replaced.
        if action.IsCheckable() != item.CanBeToggled():
            self.DeleteTool(item.GetId())
            del self._actions_map[action]
            index = self._all_items.index(action)
            index = min(index, len(self._actions_map))
            new_item = self._InsertAction(index, action)
            self._actions_map[action] = new_item
            self.Realize()
            return

        # All other state can be updated in-place.
        item.SetLabel(action.GetText())
        item.SetShortHelp(action.GetToolTip())
        item.SetLongHelp(action.GetStatusTip())
        if action.IsCheckable():
            if action.IsChecked() != item.IsToggled():
                item.Toggle()
        item.Enable(action.IsEnabled())
        self.Realize()

    #--------------------------------------------------------------------------
    # Public API
    #--------------------------------------------------------------------------
    def AddAction(self, action, realize=True):
        """ Add an action to the tool bar.

        If the action already exists in the toolbar, it will be moved
        to the end.

        Parameters
        ----------
        action : wxAction
            The wxAction instance to add to the tool bar.

        realize : bool, optional
            Whether the toolbar should realize the change immediately.
            If False, Realize() will need to be called manually once
            all desired changes have been made. The default is True.

        """
        self.InsertAction(None, action, realize)

    def AddActions(self, actions, realize=True):
        """ Add multiple wx actions to the tool bar.

        If an action already exists in the tool bar, it will be moved
        to the end.

        Parameters
        ----------
        actions : iterable
            An iterable of wxAction instances to add to the tool bar.

        realize : bool, optional
            Whether the toolbar should realize the change immediately.
            If False, Realize() will need to be called manually once
            all desired changes have been made. The default is True.

        """
        insert = self.InsertAction
        for action in actions:
            insert(None, action, False)
        if realize:
            self.Realize()

    def InsertAction(self, before, action, realize=True):
        """ Insert a wx action into the tool bar.

        If the action already exists in the tool bar, it will be moved
        to the proper location.

        Parameters
        ----------
        before : wxAction or None
            The action in the tool bar which should come directly after
            the new action.

        action : wxAction
            The wxAction instance to insert into this tool bar.

        realize : bool, optional
            Whether the toolbar should realize the change immediately.
            If False, Realize() will need to be called manually once
            all desired changes have been made. The default is True.

        """
        all_items = self._all_items
        if action not in all_items:
            if before in all_items:
                index = all_items.index(before)
            else:
                index = len(all_items)
            all_items.insert(index, action)
            if action.IsVisible():
                max_index = len(self._actions_map)
                index = min(index, max_index)
                item = self._InsertAction(index, action)
                self._actions_map[action] = item
            action.Bind(EVT_ACTION_CHANGED, self.OnActionChanged)
            if realize:
                self.Realize()
        else:
            # XXX this is a potentially slow way to do things if the
            # number of actions being moved around is large. But, the
            # Wx apis don't appear to offer a better way, so this is
            # what we get (as usual...).
            self.RemoveAction(action)
            self.InsertAction(before, action, realize)

    def InsertActions(self, before, actions, realize=True):
        """ Insert multiple wx actions into the Menu.

        If an action already exists in this menu, it will be moved to
        the proper location.

        Parameters
        ----------
        before : wxAction, wxMenu, or None
            The item in the menu which should come directly after the
            new actions.

        actions : iterable
            An iterable of wxAction instances to add to the tool bar.

        realize : bool, optional
            Whether the toolbar should realize the change immediately.
            If False, Realize() will need to be called manually once
            all desired changes have been made. The default is True.

        """
        insert = self.InsertAction
        for action in actions:
            insert(before, action, False)
        if realize:
            self.Realize()

    def RemoveAction(self, action):
        """ Remove a wx action from the tool bar.

        If the action does not exist in the tool bar, this is a no-op.

        Parameters
        ----------
        action : wxAction
            The wxAction instance to remove from this tool bar.

        """
        all_items = self._all_items
        if action in all_items:
            all_items.remove(action)
            action.Unbind(EVT_ACTION_CHANGED, handler=self.OnActionChanged)
            item = self._actions_map.pop(action, None)
            if item is not None:
                self.DeleteTool(item.GetId())

    def RemoveActions(self, actions):
        """ Remove multiple actions from the tool bar.

        If an action does not exist in the tool bar, it will be ignored.

        Parameters
        ----------
        actions : iterable
            An iterable of wxActions to remove from the tool bar.

        """
        remove = self.RemoveAction
        for action in actions:
            remove(action)


class WxToolBar(WxConstraintsWidget):
    """ A Wx implementation of an Enaml ToolBar.

    """
    #--------------------------------------------------------------------------
    # Setup Methods
    #--------------------------------------------------------------------------
    def create_widget(self, parent, tree):
        """ Create the underlying tool bar widget.

        """
        # The orientation of a tool bar can only be set at creation time.
        # Wx does not support changing it dynamically. It is only set if
        # the tool bar is a child of something other than a wx.Frame.
        # The style must include TB_FLAT or separators won't be drawn.
        style =  wx.TB_FLAT | wx.TB_TEXT | wx.NO_BORDER
        if not isinstance(parent, wx.Frame):
            style |= _ORIENTATION_MAP[tree['orientation']]
        else:
            style |= wx.HORIZONTAL

        tbar = wxToolBar(parent, style=style)

        # Setting the tool bar to double buffered avoids a ton of
        # flickering on Windows during resize events.
        tbar.SetDoubleBuffered(True)

        # For now, we set the bitmap size to 0 since we don't yet
        # support icons or images.
        tbar.SetToolBitmapSize(wx.Size(0, 0))

        return tbar

    def create(self, tree):
        """ Create and initialize the underlying tool bar control.

        """
        super(WxToolBar, self).create(tree)
        self.set_orientation(tree['orientation'])
        self.set_movable(tree['movable'])
        self.set_floatable(tree['floatable'])
        self.set_floating(tree['floating'])
        self.set_dock_area(tree['dock_area'])
        self.set_allowed_dock_areas(tree['allowed_dock_areas'])

    def init_layout(self):
        """ Initialize the layout for the toolbar.

        """
        super(WxToolBar, self).init_layout()
        widget = self.widget()
        for child in self.children():
            if isinstance(child, WxAction):
                widget.AddAction(child.widget(), False)
            elif isinstance(child, WxActionGroup):
                widget.AddActions(child.actions(), False)
        widget.Realize()

    #--------------------------------------------------------------------------
    # Child Events
    #--------------------------------------------------------------------------
    def child_removed(self, child):
        """  Handle the child removed event for a WxToolBar.

        """
        if isinstance(child, WxAction):
            self.widget().RemoveAction(child.widget())
        elif isinstance(child, WxActionGroup):
            self.widget().RemoveActions(child.actions())

    def child_added(self, child):
        """ Handle the child added event for a WxToolBar.

        """
        before = self.find_next_action(child)
        if isinstance(child, WxAction):
            self.widget().InsertAction(before, child.widget())
        elif isinstance(child, WxActionGroup):
            self.widget().InsertActions(before, child.actions())

    #--------------------------------------------------------------------------
    # Utility Methods
    #--------------------------------------------------------------------------
    def find_next_action(self, child):
        """ Get the wxAction instance which comes immediately after the
        actions of the given child.

        Parameters
        ----------
        child : WxActionGroup, or WxAction
            The child of interest.

        Returns
        -------
        result : wxAction or None
            The wxAction which comes immediately after the actions of the
            given child, or None if no actions follow the child.

        """
        index = self.index_of(child)
        if index != -1:
            for child in self.children()[index + 1:]:
                target = None
                if isinstance(child, WxAction):
                    target = child.widget()
                elif isinstance(child, WxActionGroup):
                    acts = child.actions()
                    target = acts[0] if acts else None
                if target is not None:
                    return target

    #--------------------------------------------------------------------------
    # Message Handling
    #--------------------------------------------------------------------------
    def on_action_set_movable(self, content):
        """ Handle the 'set_movable' action from the Enaml widget.

        """
        self.set_movable(content['movable'])

    def on_action_set_floatable(self, content):
        """ Handle the 'set_floatable' action from the Enaml widget.

        """
        self.set_floatable(content['floatable'])

    def on_action_set_floating(self, content):
        """ Handle the 'set_floating' action from the Enaml widget.

        """
        self.set_floating(content['floating'])

    def on_action_set_dock_area(self, content):
        """ Handle the 'set_dock_area' action from the Enaml widget.

        """
        self.set_dock_area(content['dock_area'])

    def on_action_set_allowed_dock_areas(self, content):
        """ Handle the 'set_allowed_dock_areas' action from the Enaml
        widget.

        """
        self.set_allowed_dock_areas(content['allowed_dock_areas'])

    #--------------------------------------------------------------------------
    # Widget Update Methods
    #--------------------------------------------------------------------------\
    def set_visible(self, visible):
        """ Overridden parent class visibility setter which properly
        handles the visibility of the tool bar.

        """
        # XXX implement me!
        pass

    def set_orientation(self, orientation):
        """ Set the orientation of the underlying widget.

        """
        # Wx does not support dynamically changing the orientation.
        pass

    def set_movable(self, movable):
        """ Set the movable state on the underlying widget.

        """
        # The standard wx toolbar doesn't support docking. The Aui
        # toolbar sucks, don't use it.
        pass

    def set_floatable(self, floatable):
        """ Set the floatable state on the underlying widget.

        """
        # The standard wx toolbar doesn't support docking. The Aui
        # toolbar sucks, don't use it.
        pass

    def set_floating(self, floating):
        """ Set the floating staet on the underlying widget.

        """
        # The standard wx toolbar doesn't support docking. The Aui
        # toolbar sucks, don't use it.
        pass

    def set_dock_area(self, dock_area):
        """ Set the dock area on the underyling widget.

        """
        # The standard wx toolbar doesn't support docking. The Aui
        # toolbar sucks, don't use it.
        pass

    def set_allowed_dock_areas(self, dock_areas):
        """ Set the allowed dock areas on the underlying widget.

        """
        # The standard wx toolbar doesn't support docking. The Aui
        # toolbar sucks, don't use it.
        pass


########NEW FILE########
__FILENAME__ = wx_traits_item
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#
# Special thanks to Steven Silvester for contributing this module!
#------------------------------------------------------------------------------
import wx

from .wx_control import WxControl
from .wx_single_widget_sizer import wxSingleWidgetSizer


class WxTraitsItem(WxControl):
    """ A Wx implementation of an Enaml TraitsItem.

    """
    #: Internal storage for the traits model
    _model = None

    #: Internal storage for the traits view
    _view = None

    #: Internal storage for the traits handler
    _handler = None

    #: Internal storage for the generated traits UI object.
    _ui = None

    #--------------------------------------------------------------------------
    # Setup Methods
    #--------------------------------------------------------------------------
    def create_widget(self, parent, tree):
        """ Create the underlying widget.

        """
        widget = wx.Panel(parent)
        sizer = wxSingleWidgetSizer()
        widget.SetSizer(sizer)
        return widget

    def create(self, tree):
        """ Create and initialize the underlying widget.

        """
        super(WxTraitsItem, self).create(tree)
        self._model = tree['model']
        self._view = tree['view']
        self._handler = tree['handler']

    def init_layout(self):
        """ Initialize the layout for the widget.

        """
        super(WxTraitsItem, self).init_layout()
        self.refresh_traits_widget(notify=False)

    #--------------------------------------------------------------------------
    # Message Handlers
    #--------------------------------------------------------------------------
    def on_action_set_model(self, content):
        """ Handle the 'set_model' action from the Enaml widget.

        """
        self._model = content['model']
        self.refresh_traits_widget()

    def on_action_set_view(self, content):
        """ Handle the 'set_view' action from the Enaml widget.

        """
        self._view = content['view']
        self.refresh_traits_widget()

    def on_action_set_handler(self, content):
        """ Handle the 'set_handler' action from the Enaml widget.

        """
        self._handler = content['handler']
        self.refresh_traits_widget()

    #--------------------------------------------------------------------------
    # Widget Update Methods
    #--------------------------------------------------------------------------
    def refresh_traits_widget(self, notify=True):
        """ Create the traits widget and update the underlying control.

        Parameters
        ----------
        notify : bool, optional
            Whether to notify the layout system if the size hint of the
            widget has changed. The default is True.

        """
        widget = self.widget()
        model = self._model
        if model is None:
            control = None
        else:
            view = self._view
            handler = self._handler
            self._ui = ui = model.edit_traits(
                parent=widget, view=view, handler=handler, kind='subpanel',
            )
            control = ui.control
        if notify:
            old_hint = widget.GetBestSize()
            widget.GetSizer().Add(control)
            new_hint = widget.GetBestSize()
            if old_hint != new_hint:
               self.size_hint_updated()
        else:
            widget.GetSizer().Add(control)


########NEW FILE########
__FILENAME__ = auibar
"""
`auibar.py` contains an implementation of :class:`AuiToolBar`, which is a completely owner-drawn
toolbar perfectly integrated with the AUI layout system. This allows drag and drop of
toolbars, docking/floating behaviour and the possibility to define "overflow" items
in the toolbar itself.

The default theme that is used is :class:`AuiToolBar`, which provides a modern,
glossy look and feel. The theme can be changed by calling :meth:`AuiToolBar.SetArtProvider`.
"""

__author__ = "Andrea Gavana <andrea.gavana@gmail.com>"
__date__ = "31 March 2009"


import wx
import types

from aui_utilities import BitmapFromBits, StepColour, GetLabelSize
from aui_utilities import GetBaseColour, MakeDisabledBitmap

import framemanager
from aui_constants import *

# wxPython version string
_VERSION_STRING = wx.VERSION_STRING

# AuiToolBar events
wxEVT_COMMAND_AUITOOLBAR_TOOL_DROPDOWN = wx.NewEventType()
wxEVT_COMMAND_AUITOOLBAR_OVERFLOW_CLICK = wx.NewEventType()
wxEVT_COMMAND_AUITOOLBAR_RIGHT_CLICK = wx.NewEventType()
wxEVT_COMMAND_AUITOOLBAR_MIDDLE_CLICK = wx.NewEventType()
wxEVT_COMMAND_AUITOOLBAR_BEGIN_DRAG = wx.NewEventType()

EVT_AUITOOLBAR_TOOL_DROPDOWN = wx.PyEventBinder(wxEVT_COMMAND_AUITOOLBAR_TOOL_DROPDOWN, 1)
""" A dropdown `AuiToolBarItem` is being shown. """
EVT_AUITOOLBAR_OVERFLOW_CLICK = wx.PyEventBinder(wxEVT_COMMAND_AUITOOLBAR_OVERFLOW_CLICK, 1)
""" The user left-clicked on the overflow button in `AuiToolBar`. """
EVT_AUITOOLBAR_RIGHT_CLICK = wx.PyEventBinder(wxEVT_COMMAND_AUITOOLBAR_RIGHT_CLICK, 1)
""" Fires an event when the user right-clicks on a `AuiToolBarItem`. """
EVT_AUITOOLBAR_MIDDLE_CLICK = wx.PyEventBinder(wxEVT_COMMAND_AUITOOLBAR_MIDDLE_CLICK, 1)
""" Fires an event when the user middle-clicks on a `AuiToolBarItem`. """
EVT_AUITOOLBAR_BEGIN_DRAG = wx.PyEventBinder(wxEVT_COMMAND_AUITOOLBAR_BEGIN_DRAG, 1)
""" A drag operation involving a toolbar item has started. """

# ----------------------------------------------------------------------

class CommandToolBarEvent(wx.PyCommandEvent):
    """ A specialized command event class for events sent by :class:`AuiToolBar`. """
    
    def __init__(self, command_type, win_id):
        """
        Default class constructor.

        :param `command_type`: the event kind or an instance of :class:`PyCommandEvent`.
        :param integer `win_id`: the window identification number.
        """
        
        if type(command_type) == types.IntType:    
            wx.PyCommandEvent.__init__(self, command_type, win_id)
        else:
            wx.PyCommandEvent.__init__(self, command_type.GetEventType(), command_type.GetId())
            
        self.is_dropdown_clicked = False
        self.click_pt = wx.Point(-1, -1)
        self.rect = wx.Rect(-1, -1, 0, 0)
        self.tool_id = -1


    def IsDropDownClicked(self):
        """ Returns whether the drop down menu has been clicked. """

        return self.is_dropdown_clicked
    

    def SetDropDownClicked(self, c):
        """
        Sets whether the drop down menu has been clicked.

        :param bool `c`: ``True`` to set the drop down as clicked, ``False`` otherwise.
        """

        self.is_dropdown_clicked = c    


    def GetClickPoint(self):
        """ Returns the point where the user clicked with the mouse. """

        return self.click_pt

    
    def SetClickPoint(self, p):
        """
        Sets the clicking point.

        :param Point `p`: the location of the mouse click.
        """
        
        self.click_pt = p    


    def GetItemRect(self):
        """ Returns the :class:`AuiToolBarItem` rectangle. """

        return self.rect

    
    def SetItemRect(self, r):
        """
        Sets the :class:`AuiToolBarItem` rectangle.

        :param Rect `r`: the toolbar item rectangle.
        """

        self.rect = r    


    def GetToolId(self):
        """ Returns the :class:`AuiToolBarItem` identifier. """

        return self.tool_id

    
    def SetToolId(self, id):
        """
        Sets the :class:`AuiToolBarItem` identifier.

        :param integer `id`: the toolbar item identifier.
        """

        self.tool_id = id   


# ----------------------------------------------------------------------

class AuiToolBarEvent(CommandToolBarEvent):
    """ A specialized command event class for events sent by :class:`AuiToolBar`. """
    
    def __init__(self, command_type=None, win_id=0):
        """
        Default class constructor.

        :param `command_type`: the event kind or an instance of :class:`PyCommandEvent`.
        :param integer `win_id`: the window identification number.
        """

        CommandToolBarEvent.__init__(self, command_type, win_id)

        if type(command_type) == types.IntType:
            self.notify = wx.NotifyEvent(command_type, win_id)
        else:
            self.notify = wx.NotifyEvent(command_type.GetEventType(), command_type.GetId())

        
    def GetNotifyEvent(self):
        """ Returns the actual :class:`NotifyEvent`. """
        
        return self.notify


    def IsAllowed(self):
        """ Returns whether the event is allowed or not. """

        return self.notify.IsAllowed()


    def Veto(self):
        """
        Prevents the change announced by this event from happening.

        It is in general a good idea to notify the user about the reasons for
        vetoing the change because otherwise the applications behaviour (which
        just refuses to do what the user wants) might be quite surprising.
        """

        self.notify.Veto()


    def Allow(self):
        """
        This is the opposite of :meth:`Veto`: it explicitly allows the event to be
        processed. For most events it is not necessary to call this method as the
        events are allowed anyhow but some are forbidden by default (this will
        be mentioned in the corresponding event description).
        """

        self.notify.Allow()


# ----------------------------------------------------------------------

class ToolbarCommandCapture(wx.PyEvtHandler):
    """ A class to handle the dropdown window menu. """
    
    def __init__(self):
        """ Default class constructor. """
        
        wx.PyEvtHandler.__init__(self)
        self._last_id = 0


    def GetCommandId(self):
        """ Returns the event command identifier. """
        
        return self._last_id 


    def ProcessEvent(self, event):
        """
        Processes an event, searching event tables and calling zero or more suitable
        event handler function(s).

        :param `event`: the event to process.

        :note: Normally, your application would not call this function: it is called
         in the wxPython implementation to dispatch incoming user interface events
         to the framework (and application).
         However, you might need to call it if implementing new functionality (such as
         a new control) where you define new event types, as opposed to allowing the
         user to override functions.

         An instance where you might actually override the :meth:`ProcessEvent` function is where
         you want to direct event processing to event handlers not normally noticed by
         wxPython. For example, in the document/view architecture, documents and views
         are potential event handlers. When an event reaches a frame, :meth:`ProcessEvent` will
         need to be called on the associated document and view in case event handler
         functions are associated with these objects. 

         The normal order of event table searching is as follows:

         1. If the object is disabled (via a call to :meth:`~EvtHandler.SetEvtHandlerEnabled`) the function
            skips to step (6).
         2. If the object is a :class:`Window`, :meth:`ProcessEvent` is recursively called on the window's 
            :class:`Validator`. If this returns ``True``, the function exits.
         3. wxWidgets `SearchEventTable` is called for this event handler. If this fails, the
            base class table is tried, and so on until no more tables exist or an appropriate
            function was found, in which case the function exits.
         4. The search is applied down the entire chain of event handlers (usually the chain
            has a length of one). If this succeeds, the function exits.
         5. If the object is a :class:`Window` and the event is a :class:`CommandEvent`, :meth:`ProcessEvent` is
            recursively applied to the parent window's event handler. If this returns ``True``,
            the function exits.
         6. Finally, :meth:`ProcessEvent` is called on the :class:`App` object.
        """
        
        if event.GetEventType() == wx.wxEVT_COMMAND_MENU_SELECTED:
            self._last_id = event.GetId()
            return True
        
        if self.GetNextHandler():
            return self.GetNextHandler().ProcessEvent(event)

        return False


# ----------------------------------------------------------------------

class AuiToolBarItem(object):
    """
    AuiToolBarItem is a toolbar element.
    
    It has a unique id (except for the separators which always have id = -1), the
    style (telling whether it is a normal button, separator or a control), the
    state (toggled or not, enabled or not) and short and long help strings. The
    default implementations use the short help string for the tooltip text which
    is popped up when the mouse pointer enters the tool and the long help string
    for the applications status bar.
    """

    def __init__(self, item=None):
        """
        Default class constructor.

        :param `item`: another instance of :class:`AuiToolBarItem`.
        """

        if item:
            self.Assign(item)
            return
        
        self.window = None
        self.clockwisebmp = wx.NullBitmap
        self.counterclockwisebmp = wx.NullBitmap
        self.clockwisedisbmp = wx.NullBitmap
        self.counterclockwisedisbmp = wx.NullBitmap
        self.sizer_item = None
        self.spacer_pixels = 0
        self.id = 0
        self.kind = ITEM_NORMAL
        self.state = 0   # normal, enabled
        self.proportion = 0
        self.active = True
        self.dropdown = True
        self.sticky = True
        self.user_data = 0

        self.label = ""
        self.bitmap = wx.NullBitmap
        self.disabled_bitmap = wx.NullBitmap
        self.hover_bitmap = wx.NullBitmap
        self.short_help = ""
        self.long_help = ""
        self.target = None
        self.min_size = wx.Size(-1, -1)
        self.alignment = wx.ALIGN_CENTER
        self.orientation = AUI_TBTOOL_HORIZONTAL
        

    def Assign(self, c):
        """
        Assigns the properties of the :class:`AuiToolBarItem` `c` to `self`.

        :param `c`: another instance of :class:`AuiToolBarItem`.
        """

        self.window = c.window
        self.label = c.label
        self.bitmap = c.bitmap
        self.disabled_bitmap = c.disabled_bitmap
        self.hover_bitmap = c.hover_bitmap
        self.short_help = c.short_help
        self.long_help = c.long_help
        self.sizer_item = c.sizer_item
        self.min_size = c.min_size
        self.spacer_pixels = c.spacer_pixels
        self.id = c.id
        self.kind = c.kind
        self.state = c.state
        self.proportion = c.proportion
        self.active = c.active
        self.dropdown = c.dropdown
        self.sticky = c.sticky
        self.user_data = c.user_data
        self.alignment = c.alignment
        self.orientation = c.orientation
        self.target = c.target


    def SetWindow(self, w):
        """
        Assigns a window to the toolbar item.

        :param Window `w`: associate this window `w` to the :class:`AuiToolBarItem`.
        """

        self.window = w

        
    def GetWindow(self):
        """ Returns window associated to the toolbar item. """

        return self.window        


    def SetId(self, new_id):
        """
        Sets the toolbar item identifier.

        :param integer `new_id`: the new tool id.
        """

        self.id = new_id

        
    def GetId(self):
        """ Returns the toolbar item identifier. """

        return self.id 


    def SetKind(self, new_kind):
        """
        Sets the :class:`AuiToolBarItem` kind.

        :param integer `new_kind`: can be one of the following items:

         ========================  =============================
         Item Kind                 Description
         ========================  =============================
         ``ITEM_CONTROL``          The item in the :class:`AuiToolBar` is a control
         ``ITEM_LABEL``            The item in the :class:`AuiToolBar` is a text label
         ``ITEM_SPACER``           The item in the :class:`AuiToolBar` is a spacer
         ``ITEM_SEPARATOR``        The item in the :class:`AuiToolBar` is a separator
         ``ITEM_CHECK``            The item in the :class:`AuiToolBar` is a toolbar check item
         ``ITEM_NORMAL``           The item in the :class:`AuiToolBar` is a standard toolbar item
         ``ITEM_RADIO``            The item in the :class:`AuiToolBar` is a toolbar radio item
         ========================  =============================
        """

        self.kind = new_kind


    def GetKind(self):
        """
        Returns the toolbar item kind.

        See :meth:`SetKind` for more details.
        """

        return self.kind
        

    def SetState(self, new_state):
        """
        Sets the toolbar item state.

        :param `new_state`: can be one of the following states:

         ============================================  ======================================
         Button State Constant                         Description     
         ============================================  ======================================
         ``AUI_BUTTON_STATE_NORMAL``                   Normal button state
         ``AUI_BUTTON_STATE_HOVER``                    Hovered button state
         ``AUI_BUTTON_STATE_PRESSED``                  Pressed button state
         ``AUI_BUTTON_STATE_DISABLED``                 Disabled button state
         ``AUI_BUTTON_STATE_HIDDEN``                   Hidden button state
         ``AUI_BUTTON_STATE_CHECKED``                  Checked button state
         ============================================  ======================================
    
        """

        self.state = new_state

        
    def GetState(self):
        """
        Returns the toolbar item state.

        :see: :meth:`SetState` for more details.
        """
        
        return self.state 


    def SetSizerItem(self, s):
        """
        Associates a sizer item to this toolbar item.

        :param `s`: an instance of :class:`SizerItem`.
        """

        self.sizer_item = s

        
    def GetSizerItem(self):
        """ Returns the associated sizer item. """

        return self.sizer_item 


    def SetLabel(self, s):
        """
        Sets the toolbar item label.

        :param string `s`: the toolbar item label.
        """

        self.label = s

        
    def GetLabel(self):
        """ Returns the toolbar item label. """

        return self.label 


    def SetBitmap(self, bmp):
        """
        Sets the toolbar item bitmap.

        :param Bitmap `bmp`: the image associated with this :class:`AuiToolBarItem`.
        """
        
        self.bitmap = bmp

        
    def GetBitmap(self):
        """ Returns the toolbar item bitmap. """

        return self.GetRotatedBitmap(False)


    def SetDisabledBitmap(self, bmp):
        """
        Sets the toolbar item disabled bitmap.

        :param Bitmap `bmp`: the disabled image associated with this :class:`AuiToolBarItem`.
        """
        
        self.disabled_bitmap = bmp

        
    def GetDisabledBitmap(self):
        """ Returns the toolbar item disabled bitmap. """
        
        return self.GetRotatedBitmap(True)


    def SetHoverBitmap(self, bmp):
        """
        Sets the toolbar item hover bitmap.

        :param Bitmap `bmp`: the hover image associated with this :class:`AuiToolBarItem`.
        """
        
        self.hover_bitmap = bmp


    def SetOrientation(self, a):
        """
        Sets the toolbar tool orientation.

        :param integer `a`: one of ``AUI_TBTOOL_HORIZONTAL``, ``AUI_TBTOOL_VERT_CLOCKWISE`` or
         ``AUI_TBTOOL_VERT_COUNTERCLOCKWISE``.
        """

        self.orientation = a


    def GetOrientation(self):
        """ Returns the toolbar tool orientation. """

        return self.orientation
    
        
    def GetHoverBitmap(self):
        """ Returns the toolbar item hover bitmap. """
        
        return self.hover_bitmap 


    def GetRotatedBitmap(self, disabled):
        """
        Returns the correct bitmap depending on the tool orientation.

        :param bool `disabled`: whether to return the disabled bitmap or not.
        """
        
        bitmap_to_rotate = (disabled and [self.disabled_bitmap] or [self.bitmap])[0]
        if not bitmap_to_rotate.IsOk() or self.orientation == AUI_TBTOOL_HORIZONTAL:
            return bitmap_to_rotate

        rotated_bitmap = wx.NullBitmap
        clockwise = True
        if self.orientation == AUI_TBTOOL_VERT_CLOCKWISE:
            rotated_bitmap = (disabled and [self.clockwisedisbmp] or [self.clockwisebmp])[0]

        elif self.orientation == AUI_TBTOOL_VERT_COUNTERCLOCKWISE:
            rotated_bitmap = (disabled and [self.counterclockwisedisbmp] or [self.counterclockwisebmp])[0]
            clockwise = False

        if not rotated_bitmap.IsOk():
            rotated_bitmap = wx.BitmapFromImage(bitmap_to_rotate.ConvertToImage().Rotate90(clockwise))

        return rotated_bitmap


    def SetShortHelp(self, s):
        """
        Sets the short help string for the :class:`AuiToolBarItem`, to be displayed in a
        :class:`ToolTip` when the mouse hover over the toolbar item.

        :param string `s`: the tool short help string.
        """

        self.short_help = s

        
    def GetShortHelp(self):
        """ Returns the short help string for the :class:`AuiToolBarItem`. """

        return self.short_help 


    def SetLongHelp(self, s):
        """
        Sets the long help string for the toolbar item. This string is shown in the
        statusbar (if any) of the parent frame when the mouse pointer is inside the
        tool.

        :param string `s`: the tool long help string.
        """

        self.long_help = s

        
    def GetLongHelp(self):
        """ Returns the long help string for the :class:`AuiToolBarItem`. """

        return self.long_help 


    def SetMinSize(self, s):
        """
        Sets the toolbar item minimum size.

        :param Size `s`: the toolbar item minimum size.
        """

        self.min_size = wx.Size(*s)

        
    def GetMinSize(self):
        """ Returns the toolbar item minimum size. """

        return self.min_size 


    def SetSpacerPixels(self, s):
        """
        Sets the number of pixels for a toolbar item with kind = ``ITEM_SEPARATOR``.

        :param integer `s`: number of pixels.
        """

        self.spacer_pixels = s

        
    def GetSpacerPixels(self):
        """ Returns the number of pixels for a toolbar item with kind = ``ITEM_SEPARATOR``. """

        return self.spacer_pixels 


    def SetProportion(self, p):
        """
        Sets the :class:`AuiToolBarItem` proportion in the toolbar.

        :param integer `p`: the item proportion.
        """

        self.proportion = p

        
    def GetProportion(self):
        """ Returns the :class:`AuiToolBarItem` proportion in the toolbar. """

        return self.proportion 


    def SetActive(self, b):
        """
        Activates/deactivates the toolbar item.

        :param bool `b`: ``True`` to activate the item, ``False`` to deactivate it.
        """

        self.active = b

        
    def IsActive(self):
        """ Returns whether the toolbar item is active or not. """

        return self.active
    

    def SetHasDropDown(self, b):
        """
        Sets whether the toolbar item has an associated dropdown menu.

        :param bool `b`: ``True`` to set a dropdown menu, ``False`` otherwise.
        """

        self.dropdown = b

        
    def HasDropDown(self):
        """ Returns whether the toolbar item has an associated dropdown menu or not. """

        return self.dropdown 


    def SetSticky(self, b):
        """
        Sets whether the toolbar item is sticky (permanent highlight after mouse enter)
        or not.

        :param bool `b`: ``True`` to set the item as sticky, ``False`` otherwise.
        """

        self.sticky = b

        
    def IsSticky(self):
        """ Returns whether the toolbar item has a sticky behaviour or not. """

        return self.sticky 


    def SetUserData(self, data):
        """
        Associates some kind of user data to the toolbar item.
        
        :param PyObject `data`: a Python object.

        :note: The user data can be any Python object.
        """

        self.user_data = data

        
    def GetUserData(self):
        """ Returns the associated user data. """

        return self.user_data
    

    def SetAlignment(self, align):
        """
        Sets the toolbar item alignment.

        :param integer `align`: the item alignment, which can be one of the available :class:`Sizer`
         alignments.
        """

        self.alignment = align

        
    def GetAlignment(self):
        """ Returns the toolbar item alignment. """

        return self.alignment        


# ----------------------------------------------------------------------

class AuiDefaultToolBarArt(object):
    """
    Toolbar art provider code - a tab provider provides all drawing functionality to the :class:`AuiToolBar`.
    This allows the :class:`AuiToolBar` to have a plugable look-and-feel.

    By default, a :class:`AuiToolBar` uses an instance of this class called :class:`AuiDefaultToolBarArt`
    which provides bitmap art and a colour scheme that is adapted to the major platforms'
    look. You can either derive from that class to alter its behaviour or write a
    completely new tab art class. Call :meth:`AuiToolBar.SetArtProvider` to make use this new tab art.
    """

    def __init__(self):
        """ Default class constructor. """

        self.SetDefaultColours()

        self._agwFlags = 0
        self._text_orientation = AUI_TBTOOL_TEXT_BOTTOM
        self._highlight_colour = wx.SystemSettings.GetColour(wx.SYS_COLOUR_HIGHLIGHT)

        self._separator_size = 7
        self._orientation = AUI_TBTOOL_HORIZONTAL
        self._gripper_size = 7
        self._overflow_size = 16

        button_dropdown_bits = "\xe0\xf1\xfb"
        overflow_bits = "\x80\xff\x80\xc1\xe3\xf7"

        self._button_dropdown_bmp = BitmapFromBits(button_dropdown_bits, 5, 3, wx.BLACK)
        self._disabled_button_dropdown_bmp = BitmapFromBits(button_dropdown_bits, 5, 3,
                                                            wx.Colour(128, 128, 128))
        self._overflow_bmp = BitmapFromBits(overflow_bits, 7, 6, wx.BLACK)
        self._disabled_overflow_bmp = BitmapFromBits(overflow_bits, 7, 6, wx.Colour(128, 128, 128))

        self._font = wx.SystemSettings.GetFont(wx.SYS_DEFAULT_GUI_FONT)


    def SetDefaultColours(self, base_colour=None):
        """
        Sets the default colours, which are calculated from the given base colour.

        :param `base_colour`: an instance of :class:`Colour`. If defaulted to ``None``, a colour
         is generated accordingly to the platform and theme.
        """

        if base_colour is None:
            self._base_colour = GetBaseColour()
        else:
            self._base_colour = base_colour

        darker3_colour = StepColour(self._base_colour, 60)
        darker5_colour = StepColour(self._base_colour, 40)

        self._gripper_pen1 = wx.Pen(darker5_colour)
        self._gripper_pen2 = wx.Pen(darker3_colour)
        self._gripper_pen3 = wx.WHITE_PEN
        

    def Clone(self):
        """ Clones the :class:`AuiDefaultToolBarArt` art. """

        return AuiDefaultToolBarArt()


    def SetAGWFlags(self, agwFlags):
        """
        Sets the toolbar art flags.

        :param integer `agwFlags`: a combination of the following values:

         ==================================== ==================================
         Flag name                            Description
         ==================================== ==================================
         ``AUI_TB_TEXT``                      Shows the text in the toolbar buttons; by default only icons are shown
         ``AUI_TB_NO_TOOLTIPS``               Don't show tooltips on :class:`AuiToolBar` items
         ``AUI_TB_NO_AUTORESIZE``             Do not auto-resize the :class:`AuiToolBar`
         ``AUI_TB_GRIPPER``                   Shows a gripper on the :class:`AuiToolBar`
         ``AUI_TB_OVERFLOW``                  The :class:`AuiToolBar` can contain overflow items
         ``AUI_TB_VERTICAL``                  The :class:`AuiToolBar` is vertical
         ``AUI_TB_HORZ_LAYOUT``               Shows the text and the icons alongside, not vertically stacked. This style
                                              must be used with ``AUI_TB_TEXT``
         ``AUI_TB_PLAIN_BACKGROUND``          Don't draw a gradient background on the toolbar
         ``AUI_TB_HORZ_TEXT``                 Combination of ``AUI_TB_HORZ_LAYOUT`` and ``AUI_TB_TEXT``
         ==================================== ==================================
        
        """
        
        self._agwFlags = agwFlags


    def GetAGWFlags(self):
        """
        Returns the :class:`AuiDefaultToolBarArt` flags.

        :see: :meth:`~AuiDefaultToolBarArt.SetAGWFlags` for more details.
        """

        return self._agwFlags


    def SetFont(self, font):
        """
        Sets the :class:`AuiDefaultToolBarArt` font.

        :param Font `font`: the font used for displaying toolbar item labels.
        """

        self._font = font


    def SetTextOrientation(self, orientation):
        """
        Sets the text orientation.

        :param integer `orientation`: can be one of the following constants:

         ==================================== ==================================
         Orientation Switches                 Description
         ==================================== ==================================
         ``AUI_TBTOOL_TEXT_LEFT``             Text in :class:`AuiToolBar` items is aligned left
         ``AUI_TBTOOL_TEXT_RIGHT``            Text in :class:`AuiToolBar` items is aligned right
         ``AUI_TBTOOL_TEXT_TOP``              Text in :class:`AuiToolBar` items is aligned top
         ``AUI_TBTOOL_TEXT_BOTTOM``           Text in :class:`AuiToolBar` items is aligned bottom
         ==================================== ==================================
        
        """

        self._text_orientation = orientation


    def GetFont(self):
        """ Returns the :class:`AuiDefaultToolBarArt` font. """

        return self._font


    def GetTextOrientation(self):
        """
        Returns the :class:`AuiDefaultToolBarArt` text orientation. 

        :see: :meth:`~AuiDefaultToolBarArt.SetTextOrientation` for more details.
        """

        return self._text_orientation


    def SetOrientation(self, orientation):
        """
        Sets the toolbar tool orientation.

        :param integer `orientation`: one of ``AUI_TBTOOL_HORIZONTAL``, ``AUI_TBTOOL_VERT_CLOCKWISE`` or
         ``AUI_TBTOOL_VERT_COUNTERCLOCKWISE``.
        """

        self._orientation = orientation


    def GetOrientation(self):
        """ Returns the toolbar orientation. """

        return self._orientation        


    def DrawBackground(self, dc, wnd, _rect, horizontal=True):
        """
        Draws a toolbar background with a gradient shading.

        :param `dc`: a :class:`DC` device context;
        :param `wnd`: a :class:`Window` derived window;
        :param Rect `_rect`: the :class:`AuiToolBarItem` rectangle;
        :param bool `horizontal`: ``True`` if the toolbar is horizontal, ``False`` if it is vertical.
        """

        rect = wx.Rect(*_rect)

        start_colour = StepColour(self._base_colour, 180)
        end_colour = StepColour(self._base_colour, 85)
        reflex_colour = StepColour(self._base_colour, 95)
        
        dc.GradientFillLinear(rect, start_colour, end_colour,
                              (horizontal and [wx.SOUTH] or [wx.EAST])[0])

        left = rect.GetLeft()
        right = rect.GetRight()
        top = rect.GetTop()
        bottom = rect.GetBottom()

        dc.SetPen(wx.Pen(reflex_colour))
        if horizontal:
            dc.DrawLine(left, bottom, right+1, bottom)
        else:
            dc.DrawLine(right, top, right, bottom+1)
            

    def DrawPlainBackground(self, dc, wnd, _rect):
        """
        Draws a toolbar background with a plain colour.

        This method contrasts with the default behaviour of the :class:`AuiToolBar` that
        draws a background gradient and this break the window design when putting
        it within a control that has margin between the borders and the toolbar
        (example: put :class:`AuiToolBar` within a :class:`StaticBoxSizer` that has a plain background).
      
        :param `dc`: a :class:`DC` device context;
        :param `wnd`: a :class:`Window` derived window;
        :param Rect `_rect`: the :class:`AuiToolBarItem` rectangle.
        """
        
        rect = wx.Rect(*_rect)
        rect.height += 1

        dc.SetBrush(wx.Brush(wx.SystemSettings.GetColour(wx.SYS_COLOUR_3DFACE)))
        dc.DrawRectangle(rect.x - 1, rect.y - 1, rect.width + 2, rect.height + 1)


    def DrawLabel(self, dc, wnd, item, rect):
        """
        Draws a toolbar item label.
        
        :param `dc`: a :class:`DC` device context;
        :param `wnd`: a :class:`Window` derived window;
        :param `item`: an instance of :class:`AuiToolBarItem`;
        :param Rect `rect`: the :class:`AuiToolBarItem` rectangle.
        """
        
        dc.SetFont(self._font)

        if item.state & AUI_BUTTON_STATE_DISABLED:
            dc.SetTextForeground(wx.SystemSettings.GetColour(wx.SYS_COLOUR_GRAYTEXT))
        else:
            dc.SetTextForeground(wx.SystemSettings.GetColour(wx.SYS_COLOUR_BTNTEXT))
            
        orient = item.GetOrientation()

        horizontal = orient == AUI_TBTOOL_HORIZONTAL
        # we only care about the text height here since the text
        # will get cropped based on the width of the item
        label_size = GetLabelSize(dc, item.GetLabel(), not horizontal)
        text_width = label_size.GetWidth()
        text_height = label_size.GetHeight()

        if orient == AUI_TBTOOL_HORIZONTAL:
            text_x = rect.x + (rect.width - text_width) / 2
            text_y = rect.y + (rect.height - text_height) / 2
            dc.DrawText(item.GetLabel(), text_x, text_y)

        elif orient == AUI_TBTOOL_VERT_CLOCKWISE:
            text_x = rect.x + (rect.width + text_width) / 2
            text_y = rect.y
            dc.DrawRotatedText(item.GetLabel(), text_x, text_y, 270)

        elif AUI_TBTOOL_VERT_COUNTERCLOCKWISE:
            text_x = rect.x + (rect.width - text_width) / 2
            text_y = rect.y + text_height
            dc.DrawRotatedText(item.GetLabel(), text_x, text_y, 90)


    def DrawButton(self, dc, wnd, item, rect):
        """
        Draws a toolbar item button.
        
        :param `dc`: a :class:`DC` device context;
        :param `wnd`: a :class:`Window` derived window;
        :param `item`: an instance of :class:`AuiToolBarItem`;
        :param Rect `rect`: the :class:`AuiToolBarItem` rectangle.
        """

        bmp_rect, text_rect = self.GetToolsPosition(dc, item, rect)

        if not item.GetState() & AUI_BUTTON_STATE_DISABLED:
        
            if item.GetState() & AUI_BUTTON_STATE_PRESSED:
            
                dc.SetPen(wx.Pen(self._highlight_colour))
                dc.SetBrush(wx.Brush(StepColour(self._highlight_colour, 150)))
                dc.DrawRectangleRect(rect)
            
            elif item.GetState() & AUI_BUTTON_STATE_HOVER or item.IsSticky():
            
                dc.SetPen(wx.Pen(self._highlight_colour))
                dc.SetBrush(wx.Brush(StepColour(self._highlight_colour, 170)))

                # draw an even lighter background for checked item hovers (since
                # the hover background is the same colour as the check background)
                if item.GetState() & AUI_BUTTON_STATE_CHECKED:
                    dc.SetBrush(wx.Brush(StepColour(self._highlight_colour, 180)))

                dc.DrawRectangleRect(rect)
            
            elif item.GetState() & AUI_BUTTON_STATE_CHECKED:
            
                # it's important to put this code in an else statment after the
                # hover, otherwise hovers won't draw properly for checked items
                dc.SetPen(wx.Pen(self._highlight_colour))
                dc.SetBrush(wx.Brush(StepColour(self._highlight_colour, 170)))
                dc.DrawRectangleRect(rect)
            
        if item.GetState() & AUI_BUTTON_STATE_DISABLED:
            bmp = item.GetDisabledBitmap()
        else:
            bmp = item.GetBitmap()

        if bmp.IsOk():
            dc.DrawBitmap(bmp, bmp_rect.x, bmp_rect.y, True)
        else:
            # If there is no bitmap to draw, the text can use the whole
            # item rect.
            text_rect = rect

        # set the item's text colour based on if it is disabled
        dc.SetTextForeground(wx.BLACK)
        if item.GetState() & AUI_BUTTON_STATE_DISABLED:
            dc.SetTextForeground(DISABLED_TEXT_COLOUR)

        if self._agwFlags & AUI_TB_TEXT and item.GetLabel() != "":
            self.DrawLabel(dc, wnd, item, text_rect)
        

    def DrawDropDownButton(self, dc, wnd, item, rect):
        """
        Draws a toolbar dropdown button.
        
        :param `dc`: a :class:`DC` device context;
        :param `wnd`: a :class:`Window` derived window;
        :param `item`: an instance of :class:`AuiToolBarItem`;
        :param Rect `rect`: the :class:`AuiToolBarItem` rectangle.
        """
        
        dropbmp_x = dropbmp_y = 0

        button_rect = wx.Rect(rect.x, rect.y, rect.width-BUTTON_DROPDOWN_WIDTH, rect.height)
        dropdown_rect = wx.Rect(rect.x+rect.width-BUTTON_DROPDOWN_WIDTH-1, rect.y, BUTTON_DROPDOWN_WIDTH+1, rect.height)

        horizontal = item.GetOrientation() == AUI_TBTOOL_HORIZONTAL
        
        if horizontal:
            button_rect = wx.Rect(rect.x, rect.y, rect.width-BUTTON_DROPDOWN_WIDTH, rect.height)
            dropdown_rect = wx.Rect(rect.x+rect.width-BUTTON_DROPDOWN_WIDTH-1, rect.y, BUTTON_DROPDOWN_WIDTH+1, rect.height)
        else:
            button_rect = wx.Rect(rect.x, rect.y, rect.width, rect.height-BUTTON_DROPDOWN_WIDTH)
            dropdown_rect = wx.Rect(rect.x, rect.y+rect.height-BUTTON_DROPDOWN_WIDTH-1, rect.width, BUTTON_DROPDOWN_WIDTH+1)

        dropbmp_width = self._button_dropdown_bmp.GetWidth()
        dropbmp_height = self._button_dropdown_bmp.GetHeight()
        if not horizontal:
            tmp = dropbmp_width
            dropbmp_width = dropbmp_height
            dropbmp_height = tmp

        dropbmp_x = dropdown_rect.x + (dropdown_rect.width/2) - dropbmp_width/2
        dropbmp_y = dropdown_rect.y + (dropdown_rect.height/2) - dropbmp_height/2

        bmp_rect, text_rect = self.GetToolsPosition(dc, item, button_rect)
        
        if item.GetState() & AUI_BUTTON_STATE_PRESSED:
        
            dc.SetPen(wx.Pen(self._highlight_colour))
            dc.SetBrush(wx.Brush(StepColour(self._highlight_colour, 140)))
            dc.DrawRectangleRect(button_rect)
            dc.DrawRectangleRect(dropdown_rect)
        
        elif item.GetState() & AUI_BUTTON_STATE_HOVER or item.IsSticky():
        
            dc.SetPen(wx.Pen(self._highlight_colour))
            dc.SetBrush(wx.Brush(StepColour(self._highlight_colour, 170)))
            dc.DrawRectangleRect(button_rect)
            dc.DrawRectangleRect(dropdown_rect)

        elif item.GetState() & AUI_BUTTON_STATE_CHECKED:
            # it's important to put this code in an else statment after the 
            # hover, otherwise hovers won't draw properly for checked items 
            dc.SetPen(wx.Pen(self._highlight_colour))
            dc.SetBrush(wx.Brush(StepColour(self._highlight_colour, 170)))
            dc.DrawRectangle(button_rect)
            dc.DrawRectangle(dropdown_rect)
            
        if item.GetState() & AUI_BUTTON_STATE_DISABLED:
        
            bmp = item.GetDisabledBitmap()
            dropbmp = self._disabled_button_dropdown_bmp
        
        else:
        
            bmp = item.GetBitmap()
            dropbmp = self._button_dropdown_bmp
        
        if not bmp.IsOk():
            return

        dc.DrawBitmap(bmp, bmp_rect.x, bmp_rect.y, True)
        if horizontal:
            dc.DrawBitmap(dropbmp, dropbmp_x, dropbmp_y, True)
        else:
            dc.DrawBitmap(wx.BitmapFromImage(dropbmp.ConvertToImage().Rotate90(item.GetOrientation() == AUI_TBTOOL_VERT_CLOCKWISE)),
                          dropbmp_x, dropbmp_y, True)
            
        # set the item's text colour based on if it is disabled
        dc.SetTextForeground(wx.BLACK)
        if item.GetState() & AUI_BUTTON_STATE_DISABLED:
            dc.SetTextForeground(DISABLED_TEXT_COLOUR)

        if self._agwFlags & AUI_TB_TEXT and item.GetLabel() != "":  
            self.DrawLabel(dc, wnd, item, text_rect)
        

    def DrawControlLabel(self, dc, wnd, item, rect):
        """
        Draws a label for a toolbar control.
        
        :param `dc`: a :class:`DC` device context;
        :param `wnd`: a :class:`Window` derived window;
        :param `item`: an instance of :class:`AuiToolBarItem`;
        :param Rect `rect`: the :class:`AuiToolBarItem` rectangle.
        """

        label_size = GetLabelSize(dc, item.GetLabel(), item.GetOrientation() != AUI_TBTOOL_HORIZONTAL)
        text_height = label_size.GetHeight()
        text_width = label_size.GetWidth()

        dc.SetFont(self._font)

        if self._agwFlags & AUI_TB_TEXT:
        
            tx, text_height = dc.GetTextExtent("ABCDHgj")        

        text_width, ty = dc.GetTextExtent(item.GetLabel())

        # don't draw the label if it is wider than the item width
        if text_width > rect.width:
            return

        # set the label's text colour
        dc.SetTextForeground(wx.BLACK)

        text_x = rect.x + (rect.width/2) - (text_width/2) + 1
        text_y = rect.y + rect.height - text_height - 1

        if self._agwFlags & AUI_TB_TEXT and item.GetLabel() != "": 
            dc.DrawText(item.GetLabel(), text_x, text_y)
    

    def GetLabelSize(self, dc, wnd, item):
        """
        Returns the label size for a toolbar item.
        
        :param `dc`: a :class:`DC` device context;
        :param `wnd`: a :class:`Window` derived window;
        :param `item`: an instance of :class:`AuiToolBarItem`.
        """

        dc.SetFont(self._font)
        label_size = GetLabelSize(dc, item.GetLabel(), self._orientation != AUI_TBTOOL_HORIZONTAL)

        return wx.Size(item.GetMinSize().GetWidth(), label_size.GetHeight())


    def GetToolSize(self, dc, wnd, item):
        """
        Returns the toolbar item size.
        
        :param `dc`: a :class:`DC` device context;
        :param `wnd`: a :class:`Window` derived window;
        :param `item`: an instance of :class:`AuiToolBarItem`.
        """
        
        if not item.GetBitmap().IsOk() and not self._agwFlags & AUI_TB_TEXT:
            return wx.Size(16, 16)

        width = item.GetBitmap().GetWidth()
        height = item.GetBitmap().GetHeight()

        if self._agwFlags & AUI_TB_TEXT:
        
            dc.SetFont(self._font)
            label_size = GetLabelSize(dc, item.GetLabel(), self.GetOrientation() != AUI_TBTOOL_HORIZONTAL)
            padding = 6
            
            if self._text_orientation == AUI_TBTOOL_TEXT_BOTTOM:
            
                if self.GetOrientation() != AUI_TBTOOL_HORIZONTAL:
                    height += 3   # space between top border and bitmap
                    height += 3   # space between bitmap and text
                    padding = 0

                height += label_size.GetHeight()
            
                if item.GetLabel() != "":
                    width = max(width, label_size.GetWidth()+padding)
                
            elif self._text_orientation == AUI_TBTOOL_TEXT_RIGHT and item.GetLabel() != "":
            
                if self.GetOrientation() == AUI_TBTOOL_HORIZONTAL:
                    
                    width += 3  # space between left border and bitmap
                    width += 3  # space between bitmap and text
                    padding = 0

                width += label_size.GetWidth()
                height = max(height, label_size.GetHeight()+padding)
                
        # if the tool has a dropdown button, add it to the width
        if item.HasDropDown():
            if item.GetOrientation() == AUI_TBTOOL_HORIZONTAL:
                width += BUTTON_DROPDOWN_WIDTH+4
            else:
                height += BUTTON_DROPDOWN_WIDTH+4

        return wx.Size(width, height)


    def DrawSeparator(self, dc, wnd, _rect):
        """
        Draws a toolbar separator.
        
        :param `dc`: a :class:`DC` device context;
        :param `wnd`: a :class:`Window` derived window;
        :param Rect `_rect`: the :class:`AuiToolBarItem` rectangle.
        """
        
        horizontal = True
        if self._agwFlags & AUI_TB_VERTICAL:
            horizontal = False

        rect = wx.Rect(*_rect)

        if horizontal:
        
            rect.x += (rect.width/2)
            rect.width = 1
            new_height = (rect.height*3)/4
            rect.y += (rect.height/2) - (new_height/2)
            rect.height = new_height
        
        else:
        
            rect.y += (rect.height/2)
            rect.height = 1
            new_width = (rect.width*3)/4
            rect.x += (rect.width/2) - (new_width/2)
            rect.width = new_width
        
        start_colour = StepColour(self._base_colour, 80)
        end_colour = StepColour(self._base_colour, 80)
        dc.GradientFillLinear(rect, start_colour, end_colour, (horizontal and [wx.SOUTH] or [wx.EAST])[0])


    def DrawGripper(self, dc, wnd, rect):
        """
        Draws the toolbar gripper.
        
        :param `dc`: a :class:`DC` device context;
        :param `wnd`: a :class:`Window` derived window;
        :param Rect `rect`: the :class:`AuiToolBarItem` rectangle.
        """
        
        i = 0
        while 1:
        
            if self._agwFlags & AUI_TB_VERTICAL:
            
                x = rect.x + (i*4) + 4
                y = rect.y + 3
                if x > rect.GetWidth() - 4:
                    break
            
            else:
            
                x = rect.x + 3
                y = rect.y + (i*4) + 4
                if y > rect.GetHeight() - 4:
                    break
            
            dc.SetPen(self._gripper_pen1)
            dc.DrawPoint(x, y)
            dc.SetPen(self._gripper_pen2)
            dc.DrawPoint(x, y+1)
            dc.DrawPoint(x+1, y)
            dc.SetPen(self._gripper_pen3)
            dc.DrawPoint(x+2, y+1)
            dc.DrawPoint(x+2, y+2)
            dc.DrawPoint(x+1, y+2)

            i += 1


    def DrawOverflowButton(self, dc, wnd, rect, state):
        """
        Draws the overflow button for the :class:`AuiToolBar`.
        
        :param `dc`: a :class:`DC` device context;
        :param `wnd`: a :class:`Window` derived window;
        :param Rect `rect`: the :class:`AuiToolBarItem` rectangle;
        :param integer `state`: the overflow button state.
        """
        
        if state & AUI_BUTTON_STATE_HOVER or  state & AUI_BUTTON_STATE_PRESSED:
        
            cli_rect = wnd.GetClientRect()
            light_gray_bg = StepColour(self._highlight_colour, 170)

            if self._agwFlags & AUI_TB_VERTICAL:
            
                dc.SetPen(wx.Pen(self._highlight_colour))
                dc.DrawLine(rect.x, rect.y, rect.x+rect.width, rect.y)
                dc.SetPen(wx.Pen(light_gray_bg))
                dc.SetBrush(wx.Brush(light_gray_bg))
                dc.DrawRectangle(rect.x, rect.y+1, rect.width, rect.height)
            
            else:
            
                dc.SetPen(wx.Pen(self._highlight_colour))
                dc.DrawLine(rect.x, rect.y, rect.x, rect.y+rect.height)
                dc.SetPen(wx.Pen(light_gray_bg))
                dc.SetBrush(wx.Brush(light_gray_bg))
                dc.DrawRectangle(rect.x+1, rect.y, rect.width, rect.height)
            
        x = rect.x + 1 + (rect.width-self._overflow_bmp.GetWidth())/2
        y = rect.y + 1 + (rect.height-self._overflow_bmp.GetHeight())/2
        dc.DrawBitmap(self._overflow_bmp, x, y, True)


    def GetElementSize(self, element_id):
        """
        Returns the size of a UI element in the :class:`AuiToolBar`.

        :param integer `element_id`: can be one of the following:

         ==================================== ==================================
         Element Identifier                   Description
         ==================================== ==================================
         ``AUI_TBART_SEPARATOR_SIZE``         Separator size in :class:`AuiToolBar`
         ``AUI_TBART_GRIPPER_SIZE``           Gripper size in :class:`AuiToolBar`
         ``AUI_TBART_OVERFLOW_SIZE``          Overflow button size in :class:`AuiToolBar`
         ==================================== ==================================        
        """
        
        if element_id == AUI_TBART_SEPARATOR_SIZE:
            return self._separator_size
        elif element_id == AUI_TBART_GRIPPER_SIZE:
            return self._gripper_size
        elif element_id == AUI_TBART_OVERFLOW_SIZE:
            return self._overflow_size

        return 0


    def SetElementSize(self, element_id, size):
        """
        Sets the size of a UI element in the :class:`AuiToolBar`.

        :param integer `element_id`: can be one of the following:

         ==================================== ==================================
         Element Identifier                   Description
         ==================================== ==================================
         ``AUI_TBART_SEPARATOR_SIZE``         Separator size in :class:`AuiToolBar`
         ``AUI_TBART_GRIPPER_SIZE``           Gripper size in :class:`AuiToolBar`
         ``AUI_TBART_OVERFLOW_SIZE``          Overflow button size in :class:`AuiToolBar`
         ==================================== ==================================        

        :param integer `size`: the new size of the UI element.        
        """
        
        if element_id == AUI_TBART_SEPARATOR_SIZE:
            self._separator_size = size
        elif element_id == AUI_TBART_GRIPPER_SIZE:
            self._gripper_size = size
        elif element_id == AUI_TBART_OVERFLOW_SIZE:
            self._overflow_size = size


    def ShowDropDown(self, wnd, items):
        """
        Shows the drop down window menu for overflow items.

        :param `wnd`: an instance of :class:`Window`;
        :param list `items`: a list of the overflow toolbar items.
        """

        menuPopup = wx.Menu()
        items_added = 0

        for item in items:

            if item.GetKind() not in [ITEM_SEPARATOR, ITEM_SPACER, ITEM_CONTROL]:
            
                text = item.GetShortHelp()
                if text == "":
                    text = item.GetLabel()
                if text == "":
                    text = " "

                kind = item.GetKind()
                m = wx.MenuItem(menuPopup, item.GetId(), text, item.GetShortHelp(), kind)
                orientation = item.GetOrientation()
                item.SetOrientation(AUI_TBTOOL_HORIZONTAL)
                
                if kind not in [ITEM_CHECK, ITEM_RADIO]:
                    m.SetBitmap(item.GetBitmap())

                item.SetOrientation(orientation)                    
                    
                menuPopup.AppendItem(m)
                if kind in [ITEM_CHECK, ITEM_RADIO]:            
                    state = (item.state & AUI_BUTTON_STATE_CHECKED and [True] or [False])[0]
                    m.Check(state)

                items_added += 1
            
            else:
            
                if items_added > 0 and item.GetKind() == ITEM_SEPARATOR:
                    menuPopup.AppendSeparator()
            
        # find out where to put the popup menu of window items
        pt = wx.GetMousePosition()
        pt = wnd.ScreenToClient(pt)

        # find out the screen coordinate at the bottom of the tab ctrl
        cli_rect = wnd.GetClientRect()
        pt.y = cli_rect.y + cli_rect.height

        cc = ToolbarCommandCapture()
        wnd.PushEventHandler(cc)

        # Adjustments to get slightly better menu placement
        if wx.Platform == "__WXMAC__":
            pt.y += 5
            pt.x -= 5

        wnd.PopupMenu(menuPopup, pt)
        command = cc.GetCommandId()
        wnd.PopEventHandler(True)

        return command


    def GetToolsPosition(self, dc, item, rect):
        """
        Returns the bitmap and text rectangles for a toolbar item.
        
        :param `dc`: a :class:`DC` device context;
        :param `item`: an instance of :class:`AuiToolBarItem`;
        :param Rect `rect`: the tool rectangle.
        """
        
        text_width = text_height = 0
        horizontal = self._orientation == AUI_TBTOOL_HORIZONTAL
        text_bottom = self._text_orientation == AUI_TBTOOL_TEXT_BOTTOM
        text_right = self._text_orientation == AUI_TBTOOL_TEXT_RIGHT
        bmp_width = item.GetBitmap().GetWidth()
        bmp_height = item.GetBitmap().GetHeight()
     
        if self._agwFlags & AUI_TB_TEXT:        
            dc.SetFont(self._font)
            label_size = GetLabelSize(dc, item.GetLabel(), not horizontal)
            text_height = label_size.GetHeight()
            text_width = label_size.GetWidth()
        
        bmp_x = bmp_y = text_x = text_y = 0

        if horizontal and text_bottom:
            bmp_x = rect.x + (rect.width/2) - (bmp_width/2)
            bmp_y = rect.y + 3
            text_x = rect.x + (rect.width/2) - (text_width/2)
            text_y = rect.y + ((bmp_y - rect.y) * 2) + bmp_height
        
        elif horizontal and text_right:
            bmp_x = rect.x + 3
            bmp_y = rect.y + (rect.height/2) - (bmp_height / 2)
            text_x = rect.x + ((bmp_x - rect.x) * 2) + bmp_width
            text_y = rect.y + (rect.height/2) - (text_height/2)
        
        elif not horizontal and text_bottom:
            bmp_x = rect.x + (rect.width / 2) - (bmp_width / 2)
            bmp_y = rect.y + 3
            text_x = rect.x + (rect.width / 2) - (text_width / 2)
            text_y = rect.y + ((bmp_y - rect.y) * 2) + bmp_height
        
        bmp_rect = wx.Rect(bmp_x, bmp_y, bmp_width, bmp_height)
        text_rect = wx.Rect(text_x, text_y, text_width, text_height)

        return bmp_rect, text_rect

    
class AuiToolBar(wx.PyControl):
    """
    AuiToolBar is a completely owner-drawn toolbar perfectly integrated with the AUI layout system.
    This allows drag and drop of toolbars, docking/floating behaviour and the possibility to define
    "overflow" items in the toolbar itself.

    The default theme that is used is :class:`AuiDefaultToolBarArt`, which provides a modern,
    glossy look and feel. The theme can be changed by calling :meth:`AuiToolBar.SetArtProvider`.
    """

    def __init__(self, parent, id=wx.ID_ANY, pos=wx.DefaultPosition,
                 size=wx.DefaultSize, style=0, agwStyle=AUI_TB_DEFAULT_STYLE):
        """
        Default class constructor.

        :param Window `parent`: the :class:`AuiToolBar` parent;
        :param integer `id`: an identifier for the control: a value of -1 is taken to mean a default;
        :param Point `pos`: the control position. A value of (-1, -1) indicates a default position,
         chosen by either the windowing system or wxPython, depending on platform;
        :param Size `size`: the control size. A value of (-1, -1) indicates a default size,
         chosen by either the windowing system or wxPython, depending on platform;
        :param integer `style`: the control window style;
        :param integer `agwStyle`: the AGW-specific window style. This can be a combination of the
         following bits:
        
         ==================================== ==================================
         Flag name                            Description
         ==================================== ==================================
         ``AUI_TB_TEXT``                      Shows the text in the toolbar buttons; by default only icons are shown
         ``AUI_TB_NO_TOOLTIPS``               Don't show tooltips on :class:`AuiToolBar` items
         ``AUI_TB_NO_AUTORESIZE``             Do not auto-resize the :class:`AuiToolBar`
         ``AUI_TB_GRIPPER``                   Shows a gripper on the :class:`AuiToolBar`
         ``AUI_TB_OVERFLOW``                  The :class:`AuiToolBar` can contain overflow items
         ``AUI_TB_VERTICAL``                  The :class:`AuiToolBar` is vertical
         ``AUI_TB_HORZ_LAYOUT``               Shows the text and the icons alongside, not vertically stacked.
                                              This style must be used with ``AUI_TB_TEXT``
         ``AUI_TB_PLAIN_BACKGROUND``          Don't draw a gradient background on the toolbar
         ``AUI_TB_HORZ_TEXT``                 Combination of ``AUI_TB_HORZ_LAYOUT`` and ``AUI_TB_TEXT``
         ==================================== ==================================

         The default value for `agwStyle` is: ``AUI_TB_DEFAULT_STYLE`` = 0

        """
        
        wx.PyControl.__init__(self, parent, id, pos, size, style|wx.BORDER_NONE)

        self._sizer = wx.BoxSizer(wx.HORIZONTAL)
        self.SetSizer(self._sizer)
        self._button_width = -1
        self._button_height = -1
        self._sizer_element_count = 0
        self._action_pos = wx.Point(-1, -1)
        self._action_item = None
        self._tip_item = None
        self._art = AuiDefaultToolBarArt()
        self._tool_packing = 2
        self._tool_border_padding = 3
        self._tool_text_orientation = AUI_TBTOOL_TEXT_BOTTOM
        self._tool_orientation = AUI_TBTOOL_HORIZONTAL
        self._tool_alignment = wx.EXPAND
        self._gripper_sizer_item = None
        self._overflow_sizer_item = None
        self._dragging = False

        self._agwStyle = self._originalStyle = agwStyle

        self._gripper_visible = (self._agwStyle & AUI_TB_GRIPPER and [True] or [False])[0]
        self._overflow_visible = (self._agwStyle & AUI_TB_OVERFLOW and [True] or [False])[0]
        self._overflow_state = 0
        self._custom_overflow_prepend = []
        self._custom_overflow_append = []

        self._items = []
        
        self.SetMargins(5, 5, 2, 2)
        self.SetFont(wx.NORMAL_FONT)
        self._art.SetAGWFlags(self._agwStyle)
        self.SetExtraStyle(wx.WS_EX_PROCESS_IDLE)
        
        if agwStyle & AUI_TB_HORZ_LAYOUT:
            self.SetToolTextOrientation(AUI_TBTOOL_TEXT_RIGHT)
        elif agwStyle & AUI_TB_VERTICAL:
            if agwStyle & AUI_TB_CLOCKWISE:
                self.SetToolOrientation(AUI_TBTOOL_VERT_CLOCKWISE)
            elif agwStyle & AUI_TB_COUNTERCLOCKWISE:
                self.SetToolOrientation(AUI_TBTOOL_VERT_COUNTERCLOCKWISE)
 
        self.SetBackgroundStyle(wx.BG_STYLE_CUSTOM)
        
        self.Bind(wx.EVT_SIZE, self.OnSize)
        self.Bind(wx.EVT_IDLE, self.OnIdle)
        self.Bind(wx.EVT_ERASE_BACKGROUND, self.OnEraseBackground)
        self.Bind(wx.EVT_PAINT, self.OnPaint)
        self.Bind(wx.EVT_LEFT_DOWN, self.OnLeftDown)
        self.Bind(wx.EVT_LEFT_DCLICK, self.OnLeftDown)
        self.Bind(wx.EVT_LEFT_UP, self.OnLeftUp)
        self.Bind(wx.EVT_RIGHT_DOWN, self.OnRightDown)
        self.Bind(wx.EVT_RIGHT_DCLICK, self.OnRightDown)
        self.Bind(wx.EVT_RIGHT_UP, self.OnRightUp)
        self.Bind(wx.EVT_MIDDLE_DOWN, self.OnMiddleDown)
        self.Bind(wx.EVT_MIDDLE_DCLICK, self.OnMiddleDown)
        self.Bind(wx.EVT_MIDDLE_UP, self.OnMiddleUp)
        self.Bind(wx.EVT_MOTION, self.OnMotion)
        self.Bind(wx.EVT_LEAVE_WINDOW, self.OnLeaveWindow)
        self.Bind(wx.EVT_SET_CURSOR, self.OnSetCursor)


    def SetWindowStyleFlag(self, style):
        """
        Sets the style of the window.
        
        :param integer `style`: the new window style. 

        :note: Please note that some styles cannot be changed after the window
         creation and that `Refresh` might need to be be called after changing the
         others for the change to take place immediately.

        :note: Overridden from :class:`PyControl`.
        """

        wx.PyControl.SetWindowStyleFlag(self, style|wx.BORDER_NONE)
        

    def SetAGWWindowStyleFlag(self, agwStyle):
        """
        Sets the AGW-specific style of the window.
        
        :param integer `agwStyle`: the new window style. This can be a combination of the
         following bits:
        
         ==================================== ==================================
         Flag name                            Description
         ==================================== ==================================
         ``AUI_TB_TEXT``                      Shows the text in the toolbar buttons; by default only icons are shown
         ``AUI_TB_NO_TOOLTIPS``               Don't show tooltips on :class:`AuiToolBar` items
         ``AUI_TB_NO_AUTORESIZE``             Do not auto-resize the :class:`AuiToolBar`
         ``AUI_TB_GRIPPER``                   Shows a gripper on the :class:`AuiToolBar`
         ``AUI_TB_OVERFLOW``                  The :class:`AuiToolBar` can contain overflow items
         ``AUI_TB_VERTICAL``                  The :class:`AuiToolBar` is vertical
         ``AUI_TB_HORZ_LAYOUT``               Shows the text and the icons alongside, not vertically stacked.
                                              This style must be used with ``AUI_TB_TEXT``
         ``AUI_TB_PLAIN_BACKGROUND``          Don't draw a gradient background on the toolbar
         ``AUI_TB_HORZ_TEXT``                 Combination of ``AUI_TB_HORZ_LAYOUT`` and ``AUI_TB_TEXT``
         ==================================== ==================================

        :note: Please note that some styles cannot be changed after the window
         creation and that `Refresh` might need to be be called after changing the
         others for the change to take place immediately.
        """
        self._agwStyle = self._originalStyle = agwStyle

        if self._art:
            self._art.SetAGWFlags(self._agwStyle)
        
        if agwStyle & AUI_TB_GRIPPER:
            self._gripper_visible = True
        else:
            self._gripper_visible = False

        if agwStyle & AUI_TB_OVERFLOW:
            self._overflow_visible = True
        else:
            self._overflow_visible = False

        if agwStyle & AUI_TB_HORZ_LAYOUT:
            self.SetToolTextOrientation(AUI_TBTOOL_TEXT_RIGHT)
        else:
            self.SetToolTextOrientation(AUI_TBTOOL_TEXT_BOTTOM)

        if agwStyle & AUI_TB_VERTICAL:
            if agwStyle & AUI_TB_CLOCKWISE:
                self.SetToolOrientation(AUI_TBTOOL_VERT_CLOCKWISE)
            elif agwStyle & AUI_TB_COUNTERCLOCKWISE:
                self.SetToolOrientation(AUI_TBTOOL_VERT_COUNTERCLOCKWISE)

                
    def GetAGWWindowStyleFlag(self):
        """
        Returns the AGW-specific window style flag.

        :see: :meth:`SetAGWWindowStyleFlag` for an explanation of various AGW-specific style.
        """
        return self._agwStyle
    

    def SetArtProvider(self, art):
        """
        Instructs :class:`AuiToolBar` to use art provider specified by parameter `art`
        for all drawing calls. This allows plugable look-and-feel features. 

        :param `art`: an art provider.

        :note: The previous art provider object, if any, will be deleted by :class:`AuiToolBar`.
        """
        
        del self._art
        self._art = art

        if self._art:
            self._art.SetAGWFlags(self._agwStyle)
            self._art.SetTextOrientation(self._tool_text_orientation)
            self._art.SetOrientation(self._tool_orientation)
        

    def GetArtProvider(self):
        """ Returns the current art provider being used. """

        return self._art

    def AddSimpleTool(self, tool_id, label, bitmap, short_help_string="", kind=ITEM_NORMAL, target=None):
        """
        Adds a tool to the toolbar. This is the simplest method you can use to
        ass an item to the :class:`AuiToolBar`.

        :param integer `tool_id`: an integer by which the tool may be identified in subsequent operations;
        :param string `label`: the toolbar tool label;
        :param Bitmap `bitmap`: the primary tool bitmap;
        :param string `short_help_string`: this string is used for the tools tooltip;
        :param integer `kind`: the item kind. Can be one of the following:

         ========================  =============================
         Item Kind                 Description
         ========================  =============================
         ``ITEM_CONTROL``          The item in the :class:`AuiToolBar` is a control
         ``ITEM_LABEL``            The item in the :class:`AuiToolBar` is a text label
         ``ITEM_SPACER``           The item in the :class:`AuiToolBar` is a spacer
         ``ITEM_SEPARATOR``        The item in the :class:`AuiToolBar` is a separator
         ``ITEM_CHECK``            The item in the :class:`AuiToolBar` is a toolbar check item
         ``ITEM_NORMAL``           The item in the :class:`AuiToolBar` is a standard toolbar item
         ``ITEM_RADIO``            The item in the :class:`AuiToolBar` is a toolbar radio item
         ========================  =============================

        :param `target`: a custom string indicating that an instance of :class:`~lib.agw.aui.framemanager.AuiPaneInfo`
         has been minimized into this toolbar.
        """
        
        return self.AddTool(tool_id, label, bitmap, wx.NullBitmap, kind, short_help_string, "", None, target)


    def AddToggleTool(self, tool_id, bitmap, disabled_bitmap, toggle=False, client_data=None, short_help_string="", long_help_string=""):
        """
        Adds a toggle tool to the toolbar. 

        :param integer `tool_id`: an integer by which the tool may be identified in subsequent operations;
        :param Bitmap `bitmap`: the primary tool bitmap;
        :param Bitmap `disabled_bitmap`: the bitmap to use when the tool is disabled. If it is equal to
         :class:`NullBitmap`, the disabled bitmap is automatically generated by greing the normal one;
        :param PyObject `client_data`: whatever Python object to associate with the toolbar item;
        :param string `short_help_string`: this string is used for the tools tooltip;
        :param string `long_help_string`: this string is shown in the statusbar (if any) of the parent
         frame when the mouse pointer is inside the tool.
        """

        kind = (toggle and [ITEM_CHECK] or [ITEM_NORMAL])[0]
        return self.AddTool(tool_id, "", bitmap, disabled_bitmap, kind, short_help_string, long_help_string, client_data)


    def AddTool(self, tool_id, label, bitmap, disabled_bitmap, kind, short_help_string='', long_help_string='', client_data=None, target=None):
        """
        Adds a tool to the toolbar. This is the full feature version of :meth:`AddTool`.

        :param integer `tool_id`: an integer by which the tool may be identified in subsequent operations;
        :param string `label`: the toolbar tool label;
        :param Bitmap `bitmap`: the primary tool bitmap;
        :param Bitmap `disabled_bitmap`: the bitmap to use when the tool is disabled. If it is equal to
         :class:`NullBitmap`, the disabled bitmap is automatically generated by greing the normal one;
        :param integer `kind`: the item kind. Can be one of the following:

         ========================  =============================
         Item Kind                 Description
         ========================  =============================
         ``ITEM_CONTROL``          The item in the :class:`AuiToolBar` is a control
         ``ITEM_LABEL``            The item in the :class:`AuiToolBar` is a text label
         ``ITEM_SPACER``           The item in the :class:`AuiToolBar` is a spacer
         ``ITEM_SEPARATOR``        The item in the :class:`AuiToolBar` is a separator
         ``ITEM_CHECK``            The item in the :class:`AuiToolBar` is a toolbar check item
         ``ITEM_NORMAL``           The item in the :class:`AuiToolBar` is a standard toolbar item
         ``ITEM_RADIO``            The item in the :class:`AuiToolBar` is a toolbar radio item
         ========================  =============================

        :param string `short_help_string`: this string is used for the tools tooltip;
        :param string `long_help_string`: this string is shown in the statusbar (if any) of the parent
         frame when the mouse pointer is inside the tool.
        :param PyObject `client_data`: whatever Python object to associate with the toolbar item.
        :param `target`: a custom string indicating that an instance of :class:`~lib.agw.aui.framemanager.AuiPaneInfo`
         has been minimized into this toolbar.
        """
        
        item = AuiToolBarItem()
        item.window = None
        item.label = label
        item.bitmap = bitmap
        item.disabled_bitmap = disabled_bitmap
        item.short_help = short_help_string
        item.long_help = long_help_string
        item.target = target
        item.active = True
        item.dropdown = False
        item.spacer_pixels = 0

        if tool_id == wx.ID_ANY:
            tool_id = wx.NewId()
            
        item.id = tool_id
        item.state = 0
        item.proportion = 0
        item.kind = kind
        item.sizer_item = None
        item.min_size = wx.Size(-1, -1)
        item.user_data = 0
        item.sticky = False
        item.orientation = self._tool_orientation

        if not item.disabled_bitmap.IsOk():
            # no disabled bitmap specified, we need to make one
            if item.bitmap.IsOk():
                item.disabled_bitmap = MakeDisabledBitmap(item.bitmap)
        
        self._items.append(item)
        return self._items[-1]


    def AddCheckTool(self, tool_id, label, bitmap, disabled_bitmap, short_help_string="", long_help_string="", client_data=None):
        """
        Adds a new check (or toggle) tool to the :class:`AuiToolBar`.
        
        :see: :meth:`AddTool` for an explanation of the input parameters.
        """

        return self.AddTool(tool_id, label, bitmap, disabled_bitmap, ITEM_CHECK, short_help_string, long_help_string, client_data) 


    def AddRadioTool(self, tool_id, label, bitmap, disabled_bitmap, short_help_string="", long_help_string="", client_data=None):
        """
        Adds a new radio tool to the toolbar.

        Consecutive radio tools form a radio group such that exactly one button
        in the group is pressed at any moment, in other words whenever a button
        in the group is pressed the previously pressed button is automatically
        released. You should avoid having the radio groups of only one element
        as it would be impossible for the user to use such button.

        :note: By default, the first button in the radio group is initially pressed,
         the others are not.

        :see: :meth:`AddTool` for an explanation of the input parameters.
        """

        return self.AddTool(tool_id, label, bitmap, disabled_bitmap, ITEM_RADIO, short_help_string, long_help_string, client_data)

    
    def AddControl(self, control, label=""):
        """
        Adds any control to the toolbar, typically e.g. a :class:`ComboBox`.

        :param Window `control`: the control to be added;
        :param string `label`: the label which appears if the control goes into the
         overflow items in the toolbar.
        """

        item = AuiToolBarItem()
        item.window = control
        item.label = label
        item.bitmap = wx.NullBitmap
        item.disabled_bitmap = wx.NullBitmap
        item.active = True
        item.dropdown = False
        item.spacer_pixels = 0
        item.id = control.GetId()
        item.state = 0
        item.proportion = 0
        item.kind = ITEM_CONTROL
        item.sizer_item = None
        item.min_size = control.GetEffectiveMinSize()
        item.user_data = 0
        item.sticky = False
        item.orientation = self._tool_orientation

        self._items.append(item)
        return self._items[-1]


    def AddLabel(self, tool_id, label="", width=0):
        """
        Adds a label tool to the :class:`AuiToolBar`.

        :param integer `tool_id`: an integer by which the tool may be identified in subsequent operations;
        :param string `label`: the toolbar tool label;
        :param integer `width`: the tool width.
        """

        min_size = wx.Size(-1, -1)
        
        if width != -1:
            min_size.x = width

        item = AuiToolBarItem()
        item.window = None
        item.label = label
        item.bitmap = wx.NullBitmap
        item.disabled_bitmap = wx.NullBitmap
        item.active = True
        item.dropdown = False
        item.spacer_pixels = 0

        if tool_id == wx.ID_ANY:
            tool_id = wx.NewId()
        
        item.id = tool_id
        item.state = 0
        item.proportion = 0
        item.kind = ITEM_LABEL
        item.sizer_item = None
        item.min_size = min_size
        item.user_data = 0
        item.sticky = False
        item.orientation = self._tool_orientation

        self._items.append(item)
        return self._items[-1]


    def AddSeparator(self):
        """ Adds a separator for spacing groups of tools. """
        
        item = AuiToolBarItem()
        item.window = None
        item.label = ""
        item.bitmap = wx.NullBitmap
        item.disabled_bitmap = wx.NullBitmap
        item.active = True
        item.dropdown = False
        item.id = -1
        item.state = 0
        item.proportion = 0
        item.kind = ITEM_SEPARATOR
        item.sizer_item = None
        item.min_size = wx.Size(-1, -1)
        item.user_data = 0
        item.sticky = False
        item.orientation = self._tool_orientation

        self._items.append(item)
        return self._items[-1]


    def AddSpacer(self, pixels):
        """
        Adds a spacer for spacing groups of tools.

        :param integer `pixels`: the width of the spacer.
        """

        item = AuiToolBarItem()
        item.window = None
        item.label = ""
        item.bitmap = wx.NullBitmap
        item.disabled_bitmap = wx.NullBitmap
        item.active = True
        item.dropdown = False
        item.spacer_pixels = pixels
        item.id = -1
        item.state = 0
        item.proportion = 0
        item.kind = ITEM_SPACER
        item.sizer_item = None
        item.min_size = wx.Size(-1, -1)
        item.user_data = 0
        item.sticky = False
        item.orientation = self._tool_orientation

        self._items.append(item)
        return self._items[-1]


    def AddStretchSpacer(self, proportion=1):
        """
        Adds a stretchable spacer for spacing groups of tools.

        :param integer `proportion`: the stretchable spacer proportion.
        """
        
        item = AuiToolBarItem()
        item.window = None
        item.label = ""
        item.bitmap = wx.NullBitmap
        item.disabled_bitmap = wx.NullBitmap
        item.active = True
        item.dropdown = False
        item.spacer_pixels = 0
        item.id = -1
        item.state = 0
        item.proportion = proportion
        item.kind = ITEM_SPACER
        item.sizer_item = None
        item.min_size = wx.Size(-1, -1)
        item.user_data = 0
        item.sticky = False
        item.orientation = self._tool_orientation

        self._items.append(item)
        return self._items[-1]


    def Clear(self):
        """ Deletes all the tools in the :class:`AuiToolBar`. """

        self._items = []
        self._sizer_element_count = 0


    def ClearTools(self):
        """ Deletes all the tools in the :class:`AuiToolBar`. """

        self.Clear()
        

    def DeleteTool(self, tool_id):
        """
        Removes the specified tool from the toolbar and deletes it.

        :param integer `tool_id`: the :class:`AuiToolBarItem` identifier.

        :returns: ``True`` if the tool was deleted, ``False`` otherwise.
        
        :note: Note that it is unnecessary to call :meth:`Realize` for the change to
         take place, it will happen immediately.
        """

        idx = self.GetToolIndex(tool_id)
        
        if idx >= 0 and idx < len(self._items):
            self._items.pop(idx)
            self.Realize()
            return True
        
        return False


    def DeleteToolByPos(self, pos):
        """
        This function behaves like :meth:`DeleteTool` but it deletes the tool at the specified position and not the one with the given id.

        :param integer `pos`: the tool position.

        :see: :meth:`~AuiToolBar.DeleteTool`        
        """
        
        if pos >= 0 and pos < len(self._items):
            
            self._items.pop(pos)
            self.Realize()
            return True

        return False


    def FindControl(self, id):
        """
        Returns a pointer to the control identified by `id` or ``None`` if no corresponding control is found.

        :param integer `id`: the control identifier.        
        """
        
        wnd = self.FindWindow(id)
        return wnd


    def FindTool(self, tool_id):
        """
        Finds a tool for the given tool id.

        :param integer `tool_id`: the :class:`AuiToolBarItem` identifier.
        """
        
        for item in self._items:
            if item.id == tool_id:
                return item
    
        return None


    def FindToolByLabel(self, label):
        """
        Finds a tool for the given label.

        :param string `label`: the :class:`AuiToolBarItem` label.
        """
        
        for item in self._items:
            if item.label == label:
                return item
    
        return None


    def FindToolForPosition(self, x, y):
        """
        Finds a tool for the given mouse position.

        :param integer `x`: mouse `x` position;
        :param integer `y`: mouse `y` position.

        :returns: a pointer to a :class:`AuiToolBarItem` if a tool is found, or ``None`` otherwise.
        """

        for i, item in enumerate(self._items):
            if not item.sizer_item:
                continue

            rect = item.sizer_item.GetRect()
            if rect.Contains((x,y)):
            
                # if the item doesn't fit on the toolbar, return None
                if not self.GetToolFitsByIndex(i):
                    return None

                return item
            
        return None


    def HitTest(self, x, y):
        """
        Finds a tool for the given mouse position.

        :param integer `x`: mouse `x` screen position;
        :param integer `y`: mouse `y` screen position.

        :returns: a pointer to a :class:`AuiToolBarItem` if a tool is found, or ``None`` otherwise.

        :note: This method is similar to :meth:`FindToolForPosition` but it works with absolute coordinates.
        """
        
        return self.FindToolForPosition(*self.ScreenToClient((x,y)))


    def FindToolForPositionWithPacking(self, x, y):
        """
        Finds a tool for the given mouse position, taking into account also the tool packing.

        :param integer `x`: mouse `x` position;
        :param integer `y`: mouse `y` position.

        :returns: a pointer to a :class:`AuiToolBarItem` if a tool is found, or ``None`` otherwise.
        """
        
        count = len(self._items)
        
        for i, item in enumerate(self._items):
            if not item.sizer_item:
                continue

            rect = item.sizer_item.GetRect()

            # apply tool packing
            if i+1 < count:
                rect.width += self._tool_packing

            if rect.Contains((x,y)):
            
                # if the item doesn't fit on the toolbar, return None
                if not self.GetToolFitsByIndex(i):
                    return None

                return item

        return None


    def FindToolByIndex(self, pos):
        """
        Finds a tool for the given tool position in the :class:`AuiToolBar`.

        :param integer `pos`: the tool position in the toolbar.

        :returns: a pointer to a :class:`AuiToolBarItem` if a tool is found, or ``None`` otherwise.        
        """
        
        if pos < 0 or pos >= len(self._items):
            return None

        return self._items[pos]


    def SetToolBitmapSize(self, size):
        """
        Sets the default size of each tool bitmap. The default bitmap size is 16 by 15 pixels.

        :param Size `size`: the size of the bitmaps in the toolbar.

        :note: This should be called to tell the toolbar what the tool bitmap
         size is. Call it before you add tools.

        :note: Note that this is the size of the bitmap you pass to :meth:`AddTool`,
         and not the eventual size of the tool button.

        .. todo::

           Add :class:`ToolBar` compatibility, actually implementing this method.
           
        """

        # TODO: wx.ToolBar compatibility
        pass


    def GetToolBitmapSize(self):
        """
        Returns the size of bitmap that the toolbar expects to have. The default bitmap size is 16 by 15 pixels.

        :note: Note that this is the size of the bitmap you pass to :meth:`AddTool`,
         and not the eventual size of the tool button.

        .. todo::

           Add :class:`ToolBar` compatibility, actually implementing this method.
           
        """
        
        # TODO: wx.ToolBar compatibility
        return wx.Size(16, 15)


    def SetToolProportion(self, tool_id, proportion):
        """
        Sets the tool proportion in the toolbar.

        :param integer `tool_id`: the :class:`AuiToolBarItem` identifier;
        :param integer `proportion`: the tool proportion in the toolbar.
        """

        item = self.FindTool(tool_id)
        if not item:
            return

        item.proportion = proportion


    def GetToolProportion(self, tool_id):
        """
        Returns the tool proportion in the toolbar.

        :param integer `tool_id`: the :class:`AuiToolBarItem` identifier.
        """

        item = self.FindTool(tool_id)
        if not item:
            return

        return item.proportion


    def SetToolSeparation(self, separation):
        """
        Sets the separator size for the toolbar.

        :param integer `separation`: the separator size in pixels.
        """

        if self._art:
            self._art.SetElementSize(AUI_TBART_SEPARATOR_SIZE, separation)


    def GetToolSeparation(self):
        """ Returns the separator size for the toolbar, in pixels. """
        
        if self._art:
            return self._art.GetElementSize(AUI_TBART_SEPARATOR_SIZE)

        return 5


    def SetToolDropDown(self, tool_id, dropdown):
        """
        Assigns a drop down window menu to the toolbar item.

        :param integer `tool_id`: the :class:`AuiToolBarItem` identifier;
        :param bool `dropdown`: whether to assign a drop down menu or not.
        """

        item = self.FindTool(tool_id)
        if not item:
            return

        item.dropdown = dropdown


    def GetToolDropDown(self, tool_id):
        """
        Returns whether the toolbar item identified by `tool_id` has an associated drop down window menu or not.

        :param integer `tool_id`: the :class:`AuiToolBarItem` identifier.
        """

        item = self.FindTool(tool_id)
        if not item:
            return

        return item.dropdown


    def SetToolSticky(self, tool_id, sticky):
        """
        Sets the toolbar item as sticky or non-sticky.

        :param integer `tool_id`: the :class:`AuiToolBarItem` identifier;
        :param bool `sticky`: whether the tool should be sticky or not.
        """

        # ignore separators
        if tool_id == -1:
            return

        item = self.FindTool(tool_id)
        if not item:
            return

        if item.sticky == sticky:
            return

        item.sticky = sticky

        self.Refresh(False)
        self.Update()


    def GetToolSticky(self, tool_id):
        """
        Returns whether the toolbar item identified by `tool_id` has a sticky behaviour or not.

        :param integer `tool_id`: the :class:`AuiToolBarItem` identifier.
        """

        item = self.FindTool(tool_id)
        if not item:
            return

        return item.sticky


    def SetToolBorderPadding(self, padding):
        """
        Sets the padding between the tool border and the label.

        :param integer `padding`: the padding in pixels.
        """

        self._tool_border_padding = padding


    def GetToolBorderPadding(self):
        """ Returns the padding between the tool border and the label, in pixels. """

        return self._tool_border_padding


    def SetToolTextOrientation(self, orientation):
        """
        Sets the label orientation for the toolbar items.

        :param integer `orientation`: the :class:`AuiToolBarItem` label orientation.
        """

        self._tool_text_orientation = orientation

        if self._art:
            self._art.SetTextOrientation(orientation)
    

    def GetToolTextOrientation(self):
        """ Returns the label orientation for the toolbar items. """

        return self._tool_text_orientation


    def SetToolOrientation(self, orientation):
        """
        Sets the tool orientation for the toolbar items.

        :param integer `orientation`: the :class:`AuiToolBarItem` orientation.
        """

        self._tool_orientation = orientation
        if self._art:
            self._art.SetOrientation(orientation)


    def GetToolOrientation(self):
        """ Returns the orientation for the toolbar items. """

        return self._tool_orientation        


    def SetToolPacking(self, packing):
        """
        Sets the value used for spacing tools. The default value is 1 pixel.

        :param integer `packing`: the value for packing.
        """

        self._tool_packing = packing


    def GetToolPacking(self):
        """ Returns the value used for spacing tools. The default value is 1 pixel. """

        return self._tool_packing


    def SetOrientation(self, orientation):
        """
        Sets the toolbar orientation.

        :param integer `orientation`: either ``wx.VERTICAL`` or ``wx.HORIZONTAL``.

        :note: This can be temporarily overridden by :class:`~lib.agw.aui.framemanager.AuiManager` when floating and
         docking a :class:`AuiToolBar`.
        """

        pass
    

    def SetMargins(self, left=-1, right=-1, top=-1, bottom=-1):
        """
        Set the values to be used as margins for the toolbar.

        :param integer `left`: the left toolbar margin;
        :param integer `right`: the right toolbar margin;
        :param integer `top`: the top toolbar margin;
        :param integer `bottom`: the bottom toolbar margin.
        """

        if left != -1:
            self._left_padding = left
        if right != -1:
            self._right_padding = right
        if top != -1:
            self._top_padding = top
        if bottom != -1:
            self._bottom_padding = bottom


    def SetMarginsSize(self, size):
        """
        Set the values to be used as margins for the toolbar.

        :param Size `size`: the margin size (an instance of :class:`Size`).
        """
        
        self.SetMargins(size.x, size.x, size.y, size.y)


    def SetMarginsXY(self, x, y):
        """
        Set the values to be used as margins for the toolbar.
        
        :param integer `x`: left margin, right margin and inter-tool separation value;
        :param integer `y`: top margin, bottom margin and inter-tool separation value.
        """
        
        self.SetMargins(x, x, y, y)        

            
    def GetGripperVisible(self):
        """ Returns whether the toolbar gripper is visible or not. """

        return self._gripper_visible


    def SetGripperVisible(self, visible):
        """
        Sets whether the toolbar gripper is visible or not.

        :param bool `visible`: ``True`` for a visible gripper, ``False`` otherwise.
        """

        self._gripper_visible = visible
        if visible:
            self._agwStyle |= AUI_TB_GRIPPER
        else:
            self._agwStyle &= ~AUI_TB_GRIPPER
            
        self.Realize()
        self.Refresh(False)


    def GetOverflowVisible(self):
        """ Returns whether the overflow button is visible or not. """

        return self._overflow_visible


    def SetOverflowVisible(self, visible):
        """
        Sets whether the overflow button is visible or not.

        :param bool `visible`: ``True`` for a visible overflow button, ``False`` otherwise.
        """

        self._overflow_visible = visible
        if visible:
            self._agwStyle |= AUI_TB_OVERFLOW
        else:
            self._agwStyle &= ~AUI_TB_OVERFLOW

        self.Refresh(False)


    def SetFont(self, font):
        """
        Sets the :class:`AuiToolBar` font.

        :param Font `font`: the new toolbar font.

        :note: Overridden from :class:`PyControl`.
        """        

        res = wx.PyControl.SetFont(self, font)

        if self._art:
            self._art.SetFont(font)
    
        return res


    def SetHoverItem(self, pitem):
        """
        Sets a toolbar item to be currently hovered by the mouse.

        :param `pitem`: an instance of :class:`AuiToolBarItem`.
        """

        former_hover = None

        for item in self._items:
        
            if item.state & AUI_BUTTON_STATE_HOVER:
                former_hover = item
                
            item.state &= ~AUI_BUTTON_STATE_HOVER

        if pitem:
            pitem.state |= AUI_BUTTON_STATE_HOVER
        
        if former_hover != pitem:
            self.Refresh(False)
            self.Update()
        

    def SetPressedItem(self, pitem):
        """
        Sets a toolbar item to be currently in a "pressed" state.

        :param `pitem`: an instance of :class:`AuiToolBarItem`.
        """

        former_item = None

        for item in self._items:
        
            if item.state & AUI_BUTTON_STATE_PRESSED:
                former_item = item
                
            item.state &= ~AUI_BUTTON_STATE_PRESSED
        
        if pitem:
            pitem.state &= ~AUI_BUTTON_STATE_HOVER
            pitem.state |= AUI_BUTTON_STATE_PRESSED
        
        if former_item != pitem:
            self.Refresh(False)
            self.Update()
    

    def RefreshOverflowState(self):
        """ Refreshes the overflow button. """

        if not self._overflow_sizer_item:
            self._overflow_state = 0
            return
        
        overflow_state = 0
        overflow_rect = self.GetOverflowRect()

        # find out the mouse's current position
        pt = wx.GetMousePosition()
        pt = self.ScreenToClient(pt)

        # find out if the mouse cursor is inside the dropdown rectangle
        if overflow_rect.Contains((pt.x, pt.y)):

            if _VERSION_STRING < "2.9":
                leftDown = wx.GetMouseState().LeftDown()
            else:
                leftDown = wx.GetMouseState().LeftIsDown()
        
            if leftDown:
                overflow_state = AUI_BUTTON_STATE_PRESSED
            else:
                overflow_state = AUI_BUTTON_STATE_HOVER
        
        if overflow_state != self._overflow_state:
            self._overflow_state = overflow_state
            self.Refresh(False)
            self.Update()
        
        self._overflow_state = overflow_state


    def ToggleTool(self, tool_id, state):
        """
        Toggles a tool on or off. This does not cause any event to get emitted.

        :param integer `tool_id`: tool in question.
        :param bool `state`: if ``True``, toggles the tool on, otherwise toggles it off.

        :note: This only applies to a tool that has been specified as a toggle tool.
        """
        tool = self.FindTool(tool_id)
        if tool:
            if tool.kind == ITEM_RADIO:
                if state and not (tool.state & AUI_BUTTON_STATE_CHECKED):
                    tool.state |= AUI_BUTTON_STATE_CHECKED
                    items = self._items
                    index = items.index(tool)
                    for item in items[index + 1:]:
                        if item.kind != ITEM_RADIO:
                            break
                        item.state &= ~AUI_BUTTON_STATE_CHECKED
                    for item in reversed(items[:index]):
                        if item.kind != ITEM_RADIO:
                            break
                        item.state &= ~AUI_BUTTON_STATE_CHECKED
            elif tool.kind == ITEM_CHECK:
                if state:
                    tool.state |= AUI_BUTTON_STATE_CHECKED
                else:
                    tool.state &= ~AUI_BUTTON_STATE_CHECKED 

    def GetToolToggled(self, tool_id):
        """
        Returns whether a tool is toggled or not.

        :param integer `tool_id`: the toolbar item identifier.

        :note: This only applies to a tool that has been specified as a toggle tool.
        """        

        tool = self.FindTool(tool_id)

        if tool:
            if tool.kind not in [ITEM_CHECK, ITEM_RADIO]:
                return False

            return (tool.state & AUI_BUTTON_STATE_CHECKED and [True] or [False])[0]
        
        return False


    def EnableTool(self, tool_id, state):
        """
        Enables or disables the tool.

        :param integer `tool_id`: identifier for the tool to enable or disable.
        :param bool `state`: if ``True``, enables the tool, otherwise disables it.
        """

        tool = self.FindTool(tool_id)

        if tool:
        
            if state:
                tool.state &= ~AUI_BUTTON_STATE_DISABLED
            else:
                tool.state |= AUI_BUTTON_STATE_DISABLED
        

    def GetToolEnabled(self, tool_id):
        """
        Returns whether the tool identified by `tool_id` is enabled or not.

        :param integer `tool_id`: the tool identifier.
        """

        tool = self.FindTool(tool_id)

        if tool:
            return (tool.state & AUI_BUTTON_STATE_DISABLED and [False] or [True])[0]

        return False


    def GetToolLabel(self, tool_id):
        """
        Returns the tool label for the tool identified by `tool_id`.

        :param integer `tool_id`: the tool identifier.
        """

        tool = self.FindTool(tool_id)
        if not tool:
            return ""
        
        return tool.label


    def SetToolLabel(self, tool_id, label):
        """
        Sets the tool label for the tool identified by `tool_id`.

        :param integer `tool_id`: the tool identifier;
        :param string `label`: the new toolbar item label.
        """
        
        tool = self.FindTool(tool_id)
        if tool:    
            tool.label = label
    

    def GetToolBitmap(self, tool_id):
        """
        Returns the tool bitmap for the tool identified by `tool_id`.

        :param integer `tool_id`: the tool identifier.
        """
        
        tool = self.FindTool(tool_id)
        if not tool:
            return wx.NullBitmap

        return tool.bitmap


    def SetToolBitmap(self, tool_id, bitmap):
        """
        Sets the tool bitmap for the tool identified by `tool_id`.

        :param integer `tool_id`: the tool identifier;
        :param Bitmap `bitmap`: the new bitmap for the toolbar item.
        """
        
        tool = self.FindTool(tool_id)
        if tool:
            tool.bitmap = bitmap


    def SetToolNormalBitmap(self, tool_id, bitmap):
        """
        Sets the tool bitmap for the tool identified by `tool_id`.

        :param integer `tool_id`: the tool identifier;
        :param Bitmap `bitmap`: the new bitmap for the toolbar item.
        """
        
        self.SetToolBitmap(tool_id, bitmap)


    def SetToolDisabledBitmap(self, tool_id, bitmap):
        """
        Sets the tool disabled bitmap for the tool identified by `tool_id`.

        :param integer `tool_id`: the tool identifier;
        :param Bitmap `bitmap`: the new disabled bitmap for the toolbar item.
        """
        
        tool = self.FindTool(tool_id)
        if tool:
            tool.disabled_bitmap = bitmap


    def GetToolShortHelp(self, tool_id):
        """
        Returns the short help for the given tool.

        :param integer `tool_id`: the tool identifier.
        """

        tool = self.FindTool(tool_id)
        if not tool:
            return ""

        return tool.short_help


    def SetToolShortHelp(self, tool_id, help_string):
        """
        Sets the short help for the given tool.

        :param integer `tool_id`: the tool identifier;
        :param string `help_string`: the string for the short help.
        """
        
        tool = self.FindTool(tool_id)
        if tool:
            tool.short_help = help_string


    def GetToolLongHelp(self, tool_id):
        """
        Returns the long help for the given tool.

        :param integer `tool_id`: the tool identifier.
        """

        tool = self.FindTool(tool_id)
        if not tool:
            return ""

        return tool.long_help


    def SetToolAlignment(self, alignment=wx.EXPAND):
        """
        This sets the alignment for all of the tools within the toolbar
        (only has an effect when the toolbar is expanded).

        :param integer `alignment`: :class:`Sizer` alignment value
         (``wx.ALIGN_CENTER_HORIZONTAL`` or ``wx.ALIGN_CENTER_VERTICAL``).
        """

        self._tool_alignment = alignment



    def SetToolLongHelp(self, tool_id, help_string):
        """
        Sets the long help for the given tool.

        :param integer `tool_id`: the tool identifier;
        :param string `help_string`: the string for the long help.
        """
        
        tool = self.FindTool(tool_id)
        if tool:
            tool.long_help = help_string
    

    def SetCustomOverflowItems(self, prepend, append):
        """
        Sets the two lists `prepend` and `append` as custom overflow items.

        :param list `prepend`: a list of :class:`AuiToolBarItem` to be prepended;
        :param list `append`: a list of :class:`AuiToolBarItem` to be appended.
        """

        self._custom_overflow_prepend = prepend
        self._custom_overflow_append = append


    def GetToolCount(self):
        """ Returns the number of tools in the :class:`AuiToolBar`. """

        return len(self._items)


    def GetToolIndex(self, tool_id):
        """
        Returns the position of the tool in the toolbar given its identifier.

        :param integer `tool_id`: the toolbar item identifier.
        """

        # this will prevent us from returning the index of the
        # first separator in the toolbar since its id is equal to -1
        if tool_id == -1:
            return wx.NOT_FOUND

        for i, item in enumerate(self._items):
            if item.id == tool_id:
                return i
        
        return wx.NOT_FOUND


    def GetToolPos(self, tool_id):
        """
        Returns the position of the tool in the toolbar given its identifier.

        :param integer `tool_id`: the toolbar item identifier.
        """
        
        return self.GetToolIndex(tool_id)
                                

    def GetToolFitsByIndex(self, tool_id):
        """
        Returns whether the tool identified by `tool_id` fits into the toolbar or not.

        :param integer `tool_id`: the toolbar item identifier.
        """
        
        if tool_id < 0 or tool_id >= len(self._items):
            return False

        if not self._items[tool_id].sizer_item:
            return False

        cli_w, cli_h = self.GetClientSize()
        rect = self._items[tool_id].sizer_item.GetRect()

        if self._agwStyle & AUI_TB_VERTICAL:
            # take the dropdown size into account
            if self._overflow_visible:
                cli_h -= self._overflow_sizer_item.GetSize().y

            if rect.y+rect.height < cli_h:
                return True
        
        else:
        
            # take the dropdown size into account
            if self._overflow_visible:
                cli_w -= self._overflow_sizer_item.GetSize().x

            if rect.x+rect.width < cli_w:
                return True
        
        return False


    def GetToolFits(self, tool_id):
        """
        Returns whether the tool identified by `tool_id` fits into the toolbar or not.

        :param integer `tool_id`: the toolbar item identifier.
        """
        
        return self.GetToolFitsByIndex(self.GetToolIndex(tool_id))


    def GetToolRect(self, tool_id):
        """
        Returns the toolbar item rectangle

        :param integer `tool_id`: the toolbar item identifier.
        """

        tool = self.FindTool(tool_id)
        if tool and tool.sizer_item:
            return tool.sizer_item.GetRect()

        return wx.Rect()


    def GetToolBarFits(self):
        """ Returns whether the :class:`AuiToolBar` size fits in a specified size. """

        if len(self._items) == 0:
            # empty toolbar always 'fits'
            return True
        
        # entire toolbar content fits if the last tool fits
        return self.GetToolFitsByIndex(len(self._items) - 1)


    def Realize(self):
        """ Realizes the toolbar. This function should be called after you have added tools. """

        dc = wx.ClientDC(self)
        
        if not dc.IsOk():
            return False

        horizontal = True
        if self._agwStyle & AUI_TB_VERTICAL:
            horizontal = False

        # create the new sizer to add toolbar elements to
        sizer = wx.BoxSizer((horizontal and [wx.HORIZONTAL] or [wx.VERTICAL])[0])

        # add gripper area
        separator_size = self._art.GetElementSize(AUI_TBART_SEPARATOR_SIZE)
        gripper_size = self._art.GetElementSize(AUI_TBART_GRIPPER_SIZE)
        
        if gripper_size > 0 and self._gripper_visible:        
            if horizontal:
                self._gripper_sizer_item = sizer.Add((gripper_size, 1), 0, wx.EXPAND)
            else:
                self._gripper_sizer_item = sizer.Add((1, gripper_size), 0, wx.EXPAND)
        else:
            self._gripper_sizer_item = None
        
        # add "left" padding
        if self._left_padding > 0:
            if horizontal:
                sizer.Add((self._left_padding, 1))
            else:
                sizer.Add((1, self._left_padding))
        
        count = len(self._items)
        for i, item in enumerate(self._items):
        
            sizer_item = None
            kind = item.kind

            if kind == ITEM_LABEL:
                
                size = self._art.GetLabelSize(dc, self, item)
                sizer_item = sizer.Add((size.x + (self._tool_border_padding*2),
                                        size.y + (self._tool_border_padding*2)),
                                       item.proportion,
                                       item.alignment)
                if i+1 < count:
                    sizer.AddSpacer(self._tool_packing)
                

            elif kind in [ITEM_CHECK, ITEM_NORMAL, ITEM_RADIO]:
                
                size = self._art.GetToolSize(dc, self, item)
                sizer_item = sizer.Add((size.x + (self._tool_border_padding*2),
                                        size.y + (self._tool_border_padding*2)),
                                       0,
                                       item.alignment)
                # add tool packing
                if i+1 < count:
                    sizer.AddSpacer(self._tool_packing)

            elif kind == ITEM_SEPARATOR:
                
                if horizontal:
                    sizer_item = sizer.Add((separator_size, 1), 0, wx.EXPAND)
                else:
                    sizer_item = sizer.Add((1, separator_size), 0, wx.EXPAND)

                # add tool packing
                if i+1 < count:
                    sizer.AddSpacer(self._tool_packing)

            elif kind == ITEM_SPACER:
                
                if item.proportion > 0:
                    sizer_item = sizer.AddStretchSpacer(item.proportion)
                else:
                    sizer_item = sizer.Add((item.spacer_pixels, 1))
                    
            elif kind == ITEM_CONTROL:
                
                vert_sizer = wx.BoxSizer(wx.VERTICAL)
                vert_sizer.AddStretchSpacer(1)
                ctrl_sizer_item = vert_sizer.Add(item.window, 0, wx.EXPAND)
                vert_sizer.AddStretchSpacer(1)
                
                if self._agwStyle & AUI_TB_TEXT and \
                    self._tool_text_orientation == AUI_TBTOOL_TEXT_BOTTOM and \
                    item.GetLabel() != "":
                
                    s = self.GetLabelSize(item.GetLabel())
                    vert_sizer.Add((1, s.y))

                sizer_item = sizer.Add(vert_sizer, item.proportion, wx.EXPAND)
                min_size = item.min_size

                # proportional items will disappear from the toolbar if
                # their min width is not set to something really small
                if item.proportion != 0:
                    min_size.x = 1
                
                if min_size.IsFullySpecified():
                    sizer.SetItemMinSize(vert_sizer, min_size)
                    vert_sizer.SetItemMinSize(item.window, min_size)
                
                # add tool packing
                if i+1 < count:
                    sizer.AddSpacer(self._tool_packing)
                
            item.sizer_item = sizer_item
        

        # add "right" padding
        if self._right_padding > 0:
            if horizontal:
                sizer.Add((self._right_padding, 1))
            else:
                sizer.Add((1, self._right_padding))
        
        # add drop down area
        self._overflow_sizer_item = None
        if self._agwStyle & AUI_TB_OVERFLOW:
            overflow_size = self._art.GetElementSize(AUI_TBART_OVERFLOW_SIZE)
            if overflow_size > 0 and self._overflow_visible:
                if horizontal:
                    self._overflow_sizer_item = sizer.Add((overflow_size, 1), 0, wx.EXPAND)
                else:
                    self._overflow_sizer_item = sizer.Add((1, overflow_size), 0, wx.EXPAND)
            else:
                self._overflow_sizer_item = None

        # the outside sizer helps us apply the "top" and "bottom" padding
        outside_sizer = wx.BoxSizer((horizontal and [wx.VERTICAL] or [wx.HORIZONTAL])[0])

        # add "top" padding
        if self._top_padding > 0:
        
            if horizontal:
                outside_sizer.Add((1, self._top_padding))
            else:
                outside_sizer.Add((self._top_padding, 1))
        
        # add the sizer that contains all of the toolbar elements
        outside_sizer.Add(sizer, 1, self._tool_alignment)

        # add "bottom" padding
        if self._bottom_padding > 0:
        
            if horizontal:
                outside_sizer.Add((1, self._bottom_padding))
            else:
                outside_sizer.Add((self._bottom_padding, 1))

        del self._sizer # remove old sizer
        self._sizer = outside_sizer
        self.SetSizer(outside_sizer)

        # calculate the rock-bottom minimum size
        for item in self._items:
        
            if item.sizer_item and item.proportion > 0 and item.min_size.IsFullySpecified():
                item.sizer_item.SetMinSize((0, 0))
        
        self._absolute_min_size = self._sizer.GetMinSize()

        # reset the min sizes to what they were
        for item in self._items:
        
            if item.sizer_item and item.proportion > 0 and item.min_size.IsFullySpecified():
                item.sizer_item.SetMinSize(item.min_size)
        
        # set control size
        size = self._sizer.GetMinSize()
        self.SetMinSize(size)
        self._minWidth = size.x
        self._minHeight = size.y

        if self._agwStyle & AUI_TB_NO_AUTORESIZE == 0:
        
            cur_size = self.GetClientSize()
            new_size = self.GetMinSize()

            if new_size != cur_size:
            
                self.SetClientSize(new_size)
            
            else:
            
                self._sizer.SetDimension(0, 0, cur_size.x, cur_size.y)
            
        else:
        
            cur_size = self.GetClientSize()
            self._sizer.SetDimension(0, 0, cur_size.x, cur_size.y)
                    
        self.Refresh(False)
        return True

    def GetOverflowState(self):
        """ Returns the state of the overflow button. """

        return self._overflow_state

    def GetOverflowRect(self):
        """ Returns the rectangle of the overflow button. """

        cli_rect = wx.RectPS(wx.Point(0, 0), self.GetClientSize())
        overflow_rect = wx.Rect(*self._overflow_sizer_item.GetRect())
        overflow_size = self._art.GetElementSize(AUI_TBART_OVERFLOW_SIZE)

        if self._agwStyle & AUI_TB_VERTICAL:
        
            overflow_rect.y = cli_rect.height - overflow_size
            overflow_rect.x = 0
            overflow_rect.width = cli_rect.width
            overflow_rect.height = overflow_size
        
        else:
        
            overflow_rect.x = cli_rect.width - overflow_size
            overflow_rect.y = 0
            overflow_rect.width = overflow_size
            overflow_rect.height = cli_rect.height
        
        return overflow_rect


    def GetLabelSize(self, label):
        """
        Returns the standard size of a toolbar item.

        :param string `label`: a test label.
        """

        dc = wx.ClientDC(self)
        dc.SetFont(self._font)

        return GetLabelSize(dc, label, self._tool_orientation != AUI_TBTOOL_HORIZONTAL)


    def GetAuiManager(self):
        """ Returns the :class:`~lib.agw.aui.framemanager.AuiManager` which manages the toolbar. """

        return getattr(self, '_auiManager', None)


    def SetAuiManager(self, auiManager):
        """ Sets the :class:`~lib.agw.aui.framemanager.AuiManager` which manages the toolbar. """
        
        self._auiManager = auiManager        

        
    def DoIdleUpdate(self):
        """ Updates the toolbar during idle times. """

        handler = self.GetEventHandler()
        if not handler:
            return
        
        need_refresh = False

        for item in self._items:
                
            if item.id == -1:
                continue

            evt = wx.UpdateUIEvent(item.id)
            evt.SetEventObject(self)

            if handler.ProcessEvent(evt):
            
                if evt.GetSetEnabled():
                
                    if item.window:
                        is_enabled = item.window.IsEnabled()
                    else:
                        is_enabled = (item.state & AUI_BUTTON_STATE_DISABLED and [False] or [True])[0]

                    new_enabled = evt.GetEnabled()
                    if new_enabled != is_enabled:
                    
                        if item.window:
                            item.window.Enable(new_enabled)
                        else:
                            if new_enabled:
                                item.state &= ~AUI_BUTTON_STATE_DISABLED
                            else:
                                item.state |= AUI_BUTTON_STATE_DISABLED
                        
                        need_refresh = True
                    
                if evt.GetSetChecked():
                
                    # make sure we aren't checking an item that can't be
                    if item.kind != ITEM_CHECK and item.kind != ITEM_RADIO:
                        continue

                    is_checked = (item.state & AUI_BUTTON_STATE_CHECKED and [True] or [False])[0]
                    new_checked = evt.GetChecked()

                    if new_checked != is_checked:
                    
                        if new_checked:
                            item.state |= AUI_BUTTON_STATE_CHECKED
                        else:
                            item.state &= ~AUI_BUTTON_STATE_CHECKED

                        need_refresh = True
                    
        if need_refresh:
            self.Refresh(False)

        
    def OnSize(self, event):
        """
        Handles the ``wx.EVT_SIZE`` event for :class:`AuiToolBar`.

        :param `event`: a :class:`SizeEvent` event to be processed.        
        """
        x, y = self.GetClientSize()
        realize = False

        if (x >= y and self._absolute_min_size.x > x) or (y > x and self._absolute_min_size.y > y):
            # hide all flexible items
            for item in self._items:
                if item.sizer_item and item.proportion > 0 and item.sizer_item.IsShown():
                    item.sizer_item.Show(False)
                    item.sizer_item.SetProportion(0)

            if self._originalStyle & AUI_TB_OVERFLOW:
                if not self.GetOverflowVisible():
                    self.SetOverflowVisible(True)
                    realize = True
                       
        else:
            if self._originalStyle & AUI_TB_OVERFLOW and not self._custom_overflow_append and \
               not self._custom_overflow_prepend:
                if self.GetOverflowVisible():
                    self.SetOverflowVisible(False)
                    realize = True

            # show all flexible items
            for item in self._items:
                if item.sizer_item and item.proportion > 0 and not item.sizer_item.IsShown():
                    item.sizer_item.Show(True)
                    item.sizer_item.SetProportion(item.proportion)
                
        self._sizer.SetDimension(0, 0, x, y)

        if realize:
            self.Realize()
        else:
            self.Refresh(False)
            
        self.Update()

        
    def DoSetSize(self, x, y, width, height, sizeFlags=wx.SIZE_AUTO):
        """        
        Sets the position and size of the window in pixels. The `sizeFlags`
        parameter indicates the interpretation of the other params if they are
        equal to -1.

        :param integer `x`: the window `x` position;
        :param integer `y`: the window `y` position;
        :param integer `width`: the window width;
        :param integer `height`: the window height;
        :param integer `sizeFlags`: may have one of this bit set:
   
         ===================================  ======================================
         Size Flags                           Description
         ===================================  ======================================
         ``wx.SIZE_AUTO``                     A -1 indicates that a class-specific default should be used.
         ``wx.SIZE_AUTO_WIDTH``               A -1 indicates that a class-specific default should be used for the width.
         ``wx.SIZE_AUTO_HEIGHT``              A -1 indicates that a class-specific default should be used for the height.
         ``wx.SIZE_USE_EXISTING``             Existing dimensions should be used if -1 values are supplied.
         ``wx.SIZE_ALLOW_MINUS_ONE``          Allow dimensions of -1 and less to be interpreted as real dimensions, not default values.
         ``wx.SIZE_FORCE``                    Normally, if the position and the size of the window are already the same as the
                                              parameters of this function, nothing is done. but with this flag a window resize may
                                              be forced even in this case (supported in wx 2.6.2 and later and only implemented
                                              for MSW and ignored elsewhere currently) 
         ===================================  ======================================

        :note: Overridden from :class:`PyControl`.
        """
        
        parent_size = self.GetParent().GetClientSize()
        if x + width > parent_size.x:
            width = max(0, parent_size.x - x)
        if y + height > parent_size.y:
            height = max(0, parent_size.y - y)

        wx.PyControl.DoSetSize(self, x, y, width, height, sizeFlags)


    def OnIdle(self, event):
        """
        Handles the ``wx.EVT_IDLE`` event for :class:`AuiToolBar`.

        :param `event`: a :class:`IdleEvent` event to be processed.        
        """
        
        self.DoIdleUpdate()
        event.Skip()


    def DoGetBestSize(self):
        """
        Gets the size which best suits the window: for a control, it would be the
        minimal size which doesn't truncate the control, for a panel - the same
        size as it would have after a call to `Fit()`.
        
        :note: Overridden from :class:`PyControl`.
        """
        return self._absolute_min_size
    

    def OnPaint(self, event):
        """
        Handles the ``wx.EVT_PAINT`` event for :class:`AuiToolBar`.

        :param `event`: a :class:`PaintEvent` event to be processed.        
        """
        dc = wx.AutoBufferedPaintDC(self)
        cli_rect = wx.RectPS(wx.Point(0, 0), self.GetClientSize())

        horizontal = True
        if self._agwStyle & AUI_TB_VERTICAL:
            horizontal = False

        if self._agwStyle & AUI_TB_PLAIN_BACKGROUND:
            self._art.DrawPlainBackground(dc, self, cli_rect)
        else:
            self._art.DrawBackground(dc, self, cli_rect, horizontal)

        gripper_size = self._art.GetElementSize(AUI_TBART_GRIPPER_SIZE)
        dropdown_size = self._art.GetElementSize(AUI_TBART_OVERFLOW_SIZE)

        # paint the gripper
        if self._agwStyle & AUI_TB_GRIPPER and gripper_size > 0 and self._gripper_sizer_item:
            gripper_rect = wx.Rect(*self._gripper_sizer_item.GetRect())
            if horizontal:
                gripper_rect.width = gripper_size
            else:
                gripper_rect.height = gripper_size
                
            self._art.DrawGripper(dc, self, gripper_rect)
        
        # calculated how far we can draw items
        if horizontal:
            last_extent = cli_rect.width
        else:
            last_extent = cli_rect.height
            
        if self._overflow_visible:
            last_extent -= dropdown_size

        # paint each individual tool
        for item in self._items:

            if not item.sizer_item:
                continue

            item_rect = wx.Rect(*item.sizer_item.GetRect())

            if (horizontal and item_rect.x + item_rect.width >= last_extent) or \
               (not horizontal and item_rect.y + item_rect.height >= last_extent):

                break
            
            if item.kind == ITEM_SEPARATOR:
                # draw a separator
                self._art.DrawSeparator(dc, self, item_rect)
            
            elif item.kind == ITEM_LABEL:
                # draw a text label only
                self._art.DrawLabel(dc, self, item, item_rect)
            
            elif item.kind == ITEM_NORMAL:
                # draw a regular button or dropdown button
                if not item.dropdown:
                    self._art.DrawButton(dc, self, item, item_rect)
                else:
                    self._art.DrawDropDownButton(dc, self, item, item_rect)
            
            elif item.kind == ITEM_CHECK:
                # draw a regular toggle button or a dropdown one
                if not item.dropdown:
                    self._art.DrawButton(dc, self, item, item_rect)
                else:
                    self._art.DrawDropDownButton(dc, self, item, item_rect)

            elif item.kind == ITEM_RADIO:
                # draw a toggle button
                self._art.DrawButton(dc, self, item, item_rect)
            
            elif item.kind == ITEM_CONTROL:
                # draw the control's label
                self._art.DrawControlLabel(dc, self, item, item_rect)
            
            # fire a signal to see if the item wants to be custom-rendered
            self.OnCustomRender(dc, item, item_rect)
        
        # paint the overflow button
        if dropdown_size > 0 and self._overflow_sizer_item:
            dropdown_rect = self.GetOverflowRect()
            self._art.DrawOverflowButton(dc, self, dropdown_rect, self._overflow_state)

        
    def OnEraseBackground(self, event):
        """
        Handles the ``wx.EVT_ERASE_BACKGROUND`` event for :class:`AuiToolBar`.

        :param `event`: a :class:`EraseEvent` event to be processed.

        :note: This is intentionally empty, to reduce flicker.
        """

        pass
    

    def OnLeftDown(self, event):
        """
        Handles the ``wx.EVT_LEFT_DOWN`` event for :class:`AuiToolBar`.

        :param `event`: a :class:`MouseEvent` event to be processed.        
        """
        
        cli_rect = wx.RectPS(wx.Point(0, 0), self.GetClientSize())
        self.StopPreviewTimer()

        if self._gripper_sizer_item:
        
            gripper_rect = wx.Rect(*self._gripper_sizer_item.GetRect())
            if gripper_rect.Contains(event.GetPosition()):
            
                # find aui manager
                manager = self.GetAuiManager()
                if not manager:
                    return

                x_drag_offset = event.GetX() - gripper_rect.GetX()
                y_drag_offset = event.GetY() - gripper_rect.GetY()

                clientPt = wx.Point(*event.GetPosition())
                screenPt = self.ClientToScreen(clientPt)
                managedWindow = manager.GetManagedWindow()
                managerClientPt = managedWindow.ScreenToClient(screenPt)

                # gripper was clicked
                manager.OnGripperClicked(self, managerClientPt, wx.Point(x_drag_offset, y_drag_offset))            
                return

        if self._overflow_sizer_item:
            overflow_rect = self.GetOverflowRect()

            if self._art and self._overflow_visible and overflow_rect.Contains(event.GetPosition()):
            
                e = AuiToolBarEvent(wxEVT_COMMAND_AUITOOLBAR_OVERFLOW_CLICK, -1)
                e.SetEventObject(self)
                e.SetToolId(-1)
                e.SetClickPoint(event.GetPosition())
                processed = self.ProcessEvent(e)

                if processed:
                    self.DoIdleUpdate()
                else:                
                    overflow_items = []

                    # add custom overflow prepend items, if any
                    count = len(self._custom_overflow_prepend)
                    for i in xrange(count):
                        overflow_items.append(self._custom_overflow_prepend[i])

                    # only show items that don't fit in the dropdown
                    count = len(self._items)
                    for i in xrange(count):
                    
                        if not self.GetToolFitsByIndex(i):
                            overflow_items.append(self._items[i])
                    
                    # add custom overflow append items, if any
                    count = len(self._custom_overflow_append)
                    for i in xrange(count):
                        overflow_items.append(self._custom_overflow_append[i])

                    res = self._art.ShowDropDown(self, overflow_items)
                    self._overflow_state = 0
                    self.Refresh(False)
                    if res != -1:
                        e = wx.CommandEvent(wx.wxEVT_COMMAND_MENU_SELECTED, res)
                        e.SetEventObject(self)
                        if not self.GetParent().ProcessEvent(e):
                            tool = self.FindTool(res)
                            if tool:
                                state = (tool.state & AUI_BUTTON_STATE_CHECKED and [True] or [False])[0]
                                self.ToggleTool(res, not state)
                    
                return
            
        self._dragging = False
        self._action_pos = wx.Point(*event.GetPosition())
        self._action_item = self.FindToolForPosition(*event.GetPosition())

        if self._action_item:
        
            if self._action_item.state & AUI_BUTTON_STATE_DISABLED:
            
                self._action_pos = wx.Point(-1, -1)
                self._action_item = None
                return
            
            self.SetPressedItem(self._action_item)

            # fire the tool dropdown event
            e = AuiToolBarEvent(wxEVT_COMMAND_AUITOOLBAR_TOOL_DROPDOWN, self._action_item.id)
            e.SetEventObject(self)
            e.SetToolId(self._action_item.id)
            e.SetDropDownClicked(False)

            mouse_x, mouse_y = event.GetX(), event.GetY()
            rect = wx.Rect(*self._action_item.sizer_item.GetRect())

            if self._action_item.dropdown:
                if (self._action_item.orientation == AUI_TBTOOL_HORIZONTAL and \
                    mouse_x >= (rect.x+rect.width-BUTTON_DROPDOWN_WIDTH-1) and \
                    mouse_x < (rect.x+rect.width)) or \
                    (self._action_item.orientation != AUI_TBTOOL_HORIZONTAL and \
                     mouse_y >= (rect.y+rect.height-BUTTON_DROPDOWN_WIDTH-1) and \
                     mouse_y < (rect.y+rect.height)):
                    
                    e.SetDropDownClicked(True)            
            
            e.SetClickPoint(event.GetPosition())
            e.SetItemRect(rect)
            self.ProcessEvent(e)
            self.DoIdleUpdate()
        

    def OnLeftUp(self, event):
        """
        Handles the ``wx.EVT_LEFT_UP`` event for :class:`AuiToolBar`.

        :param `event`: a :class:`MouseEvent` event to be processed.        
        """
        
        self.SetPressedItem(None)

        hit_item = self.FindToolForPosition(*event.GetPosition())
        
        if hit_item and not hit_item.state & AUI_BUTTON_STATE_DISABLED:
            self.SetHoverItem(hit_item)

        if self._dragging:
            # reset drag and drop member variables
            self._dragging = False
            self._action_pos = wx.Point(-1, -1)
            self._action_item = None
        
        else:

            if self._action_item and hit_item == self._action_item:
                self.SetToolTipString("")

                if hit_item.kind in [ITEM_CHECK, ITEM_RADIO]:
                    toggle = not (self._action_item.state & AUI_BUTTON_STATE_CHECKED)
                    self.ToggleTool(self._action_item.id, toggle)

                    # repaint immediately
                    self.Refresh(False)
                    self.Update()
                    
                    e = wx.CommandEvent(wx.wxEVT_COMMAND_MENU_SELECTED, self._action_item.id)
                    e.SetEventObject(self)
                    e.SetInt(toggle)
                    self._action_pos = wx.Point(-1, -1)
                    self._action_item = None
                    
                    self.ProcessEvent(e)
                    self.DoIdleUpdate()
                    
                else:

                    if self._action_item.id == ID_RESTORE_FRAME:
                        # find aui manager
                        manager = self.GetAuiManager()

                        if not manager:
                            return

                        if self._action_item.target:
                            pane = manager.GetPane(self._action_item.target)
                        else:
                            pane = manager.GetPane(self)
                            
                        e = framemanager.AuiManagerEvent(framemanager.wxEVT_AUI_PANE_MIN_RESTORE)

                        e.SetManager(manager)
                        e.SetPane(pane)

                        manager.ProcessEvent(e)
                        self.DoIdleUpdate()

                    else:

                        e = wx.CommandEvent(wx.wxEVT_COMMAND_MENU_SELECTED, self._action_item.id)
                        e.SetEventObject(self)
                        self.ProcessEvent(e)
                        self.DoIdleUpdate()
                
        # reset drag and drop member variables
        self._dragging = False
        self._action_pos = wx.Point(-1, -1)
        self._action_item = None


    def OnRightDown(self, event):
        """
        Handles the ``wx.EVT_RIGHT_DOWN`` event for :class:`AuiToolBar`.

        :param `event`: a :class:`MouseEvent` event to be processed.        
        """
        
        cli_rect = wx.RectPS(wx.Point(0, 0), self.GetClientSize())

        if self._gripper_sizer_item:
            gripper_rect = self._gripper_sizer_item.GetRect()
            if gripper_rect.Contains(event.GetPosition()):
                return
        
        if self._overflow_sizer_item:
        
            dropdown_size = self._art.GetElementSize(AUI_TBART_OVERFLOW_SIZE)
            if dropdown_size > 0 and event.GetX() > cli_rect.width - dropdown_size and \
               event.GetY() >= 0 and event.GetY() < cli_rect.height and self._art:
                return
            
        self._action_pos = wx.Point(*event.GetPosition())
        self._action_item = self.FindToolForPosition(*event.GetPosition())

        if self._action_item:
            if self._action_item.state & AUI_BUTTON_STATE_DISABLED:
            
                self._action_pos = wx.Point(-1, -1)
                self._action_item = None
                return


    def OnRightUp(self, event):
        """
        Handles the ``wx.EVT_RIGHT_UP`` event for :class:`AuiToolBar`.

        :param `event`: a :class:`MouseEvent` event to be processed.        
        """
        
        hit_item = self.FindToolForPosition(*event.GetPosition())

        if self._action_item and hit_item == self._action_item:
            
            e = AuiToolBarEvent(wxEVT_COMMAND_AUITOOLBAR_RIGHT_CLICK, self._action_item.id)
            e.SetEventObject(self)
            e.SetToolId(self._action_item.id)
            e.SetClickPoint(self._action_pos)
            self.ProcessEvent(e)
            self.DoIdleUpdate()
            
        else:
        
            # right-clicked on the invalid area of the toolbar
            e = AuiToolBarEvent(wxEVT_COMMAND_AUITOOLBAR_RIGHT_CLICK, -1)
            e.SetEventObject(self)
            e.SetToolId(-1)
            e.SetClickPoint(self._action_pos)
            self.ProcessEvent(e)
            self.DoIdleUpdate()
        
        # reset member variables
        self._action_pos = wx.Point(-1, -1)
        self._action_item = None


    def OnMiddleDown(self, event):
        """
        Handles the ``wx.EVT_MIDDLE_DOWN`` event for :class:`AuiToolBar`.

        :param `event`: a :class:`MouseEvent` event to be processed.        
        """
        
        cli_rect = wx.RectPS(wx.Point(0, 0), self.GetClientSize())

        if self._gripper_sizer_item:
        
            gripper_rect = self._gripper_sizer_item.GetRect()
            if gripper_rect.Contains(event.GetPosition()):
                return
        
        if self._overflow_sizer_item:
        
            dropdown_size = self._art.GetElementSize(AUI_TBART_OVERFLOW_SIZE)
            if dropdown_size > 0 and event.GetX() > cli_rect.width - dropdown_size and \
               event.GetY() >= 0 and event.GetY() < cli_rect.height and self._art:            
                return
            
        self._action_pos = wx.Point(*event.GetPosition())
        self._action_item = self.FindToolForPosition(*event.GetPosition())

        if self._action_item:
            if self._action_item.state & AUI_BUTTON_STATE_DISABLED:
            
                self._action_pos = wx.Point(-1, -1)
                self._action_item = None
                return


    def OnMiddleUp(self, event):
        """
        Handles the ``wx.EVT_MIDDLE_UP`` event for :class:`AuiToolBar`.

        :param `event`: a :class:`MouseEvent` event to be processed.        
        """
        
        hit_item = self.FindToolForPosition(*event.GetPosition())

        if self._action_item and hit_item == self._action_item:        
            if hit_item.kind == ITEM_NORMAL:
            
                e = AuiToolBarEvent(wxEVT_COMMAND_AUITOOLBAR_MIDDLE_CLICK, self._action_item.id)
                e.SetEventObject(self)
                e.SetToolId(self._action_item.id)
                e.SetClickPoint(self._action_pos)
                self.ProcessEvent(e)
                self.DoIdleUpdate()
            
        # reset member variables
        self._action_pos = wx.Point(-1, -1)
        self._action_item = None


    def OnMotion(self, event):
        """
        Handles the ``wx.EVT_MOTION`` event for :class:`AuiToolBar`.

        :param `event`: a :class:`MouseEvent` event to be processed.        
        """
        
        # start a drag event
        if not self._dragging and self._action_item != None and self._action_pos != wx.Point(-1, -1) and \
           abs(event.GetX() - self._action_pos.x) + abs(event.GetY() - self._action_pos.y) > 5:
        
            self.SetToolTipString("")
            self._dragging = True

            e = AuiToolBarEvent(wxEVT_COMMAND_AUITOOLBAR_BEGIN_DRAG, self.GetId())
            e.SetEventObject(self)
            e.SetToolId(self._action_item.id)
            self.ProcessEvent(e)
            self.DoIdleUpdate()
            return
        
        hit_item = self.FindToolForPosition(*event.GetPosition())
        
        if hit_item:        
            if not hit_item.state & AUI_BUTTON_STATE_DISABLED:
                self.SetHoverItem(hit_item)
            else:
                self.SetHoverItem(None)
        
        else:        
            # no hit item, remove any hit item
            self.SetHoverItem(hit_item)
        
        # figure out tooltips
        packing_hit_item = self.FindToolForPositionWithPacking(*event.GetPosition())
        
        if packing_hit_item:
        
            if packing_hit_item != self._tip_item:
                self._tip_item = packing_hit_item

                if packing_hit_item.short_help != "":
                    self.StartPreviewTimer()
                    self.SetToolTipString(packing_hit_item.short_help)
                else:
                    self.SetToolTipString("")
                    self.StopPreviewTimer()
            
        else:
        
            self.SetToolTipString("")
            self._tip_item = None
            self.StopPreviewTimer()
        
        # if we've pressed down an item and we're hovering
        # over it, make sure it's state is set to pressed
        if self._action_item:
        
            if self._action_item == hit_item:
                self.SetPressedItem(self._action_item)
            else:
                self.SetPressedItem(None)
        
        # figure out the dropdown button state (are we hovering or pressing it?)
        self.RefreshOverflowState()


    def OnLeaveWindow(self, event):
        """
        Handles the ``wx.EVT_LEAVE_WINDOW`` event for :class:`AuiToolBar`.

        :param `event`: a :class:`MouseEvent` event to be processed.        
        """

        self.RefreshOverflowState()
        self.SetHoverItem(None)
        self.SetPressedItem(None)

        self._tip_item = None
        self.StopPreviewTimer()


    def OnSetCursor(self, event):
        """
        Handles the ``wx.EVT_SET_CURSOR`` event for :class:`AuiToolBar`.

        :param `event`: a :class:`SetCursorEvent` event to be processed.        
        """
        
        cursor = wx.NullCursor

        if self._gripper_sizer_item:
        
            gripper_rect = self._gripper_sizer_item.GetRect()
            if gripper_rect.Contains((event.GetX(), event.GetY())):
                cursor = wx.StockCursor(wx.CURSOR_SIZING)
            
        event.SetCursor(cursor)


    def OnCustomRender(self, dc, item, rect):
        """
        Handles custom render for single :class:`AuiToolBar` items.
        
        :param `dc`: a :class:`DC` device context;
        :param `item`: an instance of :class:`AuiToolBarItem`;
        :param Rect `rect`: the toolbar item rect.

        :note: This method must be overridden to provide custom rendering of items.
        """
        
        pass


    def IsPaneMinimized(self):
        """ Returns whether this :class:`AuiToolBar` contains a minimized pane tool. """
        
        manager = self.GetAuiManager()
        if not manager:
            return False
        
        if manager.GetAGWFlags() & AUI_MGR_PREVIEW_MINIMIZED_PANES == 0:
            # No previews here
            return False

        self_name = manager.GetPane(self).name
        
        if not self_name.endswith("_min"):
            # Wrong tool name
            return False

        return self_name[0:-4]
    
        
    def StartPreviewTimer(self):
        """ Starts a timer in :class:`~lib.agw.aui.framemanager.AuiManager` to slide-in/slide-out the minimized pane. """

        self_name = self.IsPaneMinimized()
        if not self_name:
            return

        manager = self.GetAuiManager()        
        manager.StartPreviewTimer(self)


    def StopPreviewTimer(self):
        """ Stops a timer in :class:`~lib.agw.aui.framemanager.AuiManager` to slide-in/slide-out the minimized pane. """

        self_name = self.IsPaneMinimized()
        if not self_name:
            return

        manager = self.GetAuiManager()        
        manager.StopPreviewTimer()
            

########NEW FILE########
__FILENAME__ = auibook
"""
`auibook.py` contains a notebook control which implements many features common in
applications with dockable panes. Specifically, :class:`AuiNotebook` implements functionality
which allows the user to rearrange tab order via drag-and-drop, split the tab window
into many different splitter configurations, and toggle through different themes to
customize the control's look and feel.

An effort has been made to try to maintain an API as similar to that of :class:`Notebook`.

The default theme that is used is :class:`~lib.agw.aui.tabart.AuiDefaultTabArt`, which provides a modern, glossy
look and feel. The theme can be changed by calling :meth:`AuiNotebook.SetArtProvider() <AuiNotebook.SetArtProvider>`.
"""

__author__ = "Andrea Gavana <andrea.gavana@gmail.com>"
__date__ = "31 March 2009"


import wx
import types
import datetime

from wx.lib.expando import ExpandoTextCtrl

import framemanager
import tabart as TA

from aui_utilities import LightColour, MakeDisabledBitmap, TabDragImage
from aui_utilities import TakeScreenShot, RescaleScreenShot

from aui_constants import *

# AuiNotebook events
wxEVT_COMMAND_AUINOTEBOOK_PAGE_CLOSE = wx.NewEventType()
wxEVT_COMMAND_AUINOTEBOOK_PAGE_CLOSED = wx.NewEventType()
wxEVT_COMMAND_AUINOTEBOOK_PAGE_CHANGED = wx.NewEventType()
wxEVT_COMMAND_AUINOTEBOOK_PAGE_CHANGING = wx.NewEventType()
wxEVT_COMMAND_AUINOTEBOOK_BUTTON = wx.NewEventType()
wxEVT_COMMAND_AUINOTEBOOK_BEGIN_DRAG = wx.NewEventType()
wxEVT_COMMAND_AUINOTEBOOK_END_DRAG = wx.NewEventType()
wxEVT_COMMAND_AUINOTEBOOK_DRAG_MOTION = wx.NewEventType()
wxEVT_COMMAND_AUINOTEBOOK_ALLOW_DND = wx.NewEventType()
wxEVT_COMMAND_AUINOTEBOOK_DRAG_DONE = wx.NewEventType()
wxEVT_COMMAND_AUINOTEBOOK_TAB_MIDDLE_DOWN = wx.NewEventType()
wxEVT_COMMAND_AUINOTEBOOK_TAB_MIDDLE_UP = wx.NewEventType()
wxEVT_COMMAND_AUINOTEBOOK_TAB_RIGHT_DOWN = wx.NewEventType()
wxEVT_COMMAND_AUINOTEBOOK_TAB_RIGHT_UP = wx.NewEventType()
wxEVT_COMMAND_AUINOTEBOOK_TAB_DCLICK = wx.NewEventType()
wxEVT_COMMAND_AUINOTEBOOK_BG_MIDDLE_DOWN = wx.NewEventType()
wxEVT_COMMAND_AUINOTEBOOK_BG_MIDDLE_UP = wx.NewEventType()
wxEVT_COMMAND_AUINOTEBOOK_BG_RIGHT_DOWN = wx.NewEventType()
wxEVT_COMMAND_AUINOTEBOOK_BG_RIGHT_UP = wx.NewEventType()
wxEVT_COMMAND_AUINOTEBOOK_BG_DCLICK = wx.NewEventType()

# Define a new event for a drag cancelled
wxEVT_COMMAND_AUINOTEBOOK_CANCEL_DRAG = wx.NewEventType()

# Define events for editing a tab label
wxEVT_COMMAND_AUINOTEBOOK_BEGIN_LABEL_EDIT = wx.NewEventType()
wxEVT_COMMAND_AUINOTEBOOK_END_LABEL_EDIT = wx.NewEventType()

# Create event binders
EVT_AUINOTEBOOK_PAGE_CLOSE = wx.PyEventBinder(wxEVT_COMMAND_AUINOTEBOOK_PAGE_CLOSE, 1)
""" A tab in `AuiNotebook` is being closed. Can be vetoed by calling `Veto()`. """
EVT_AUINOTEBOOK_PAGE_CLOSED = wx.PyEventBinder(wxEVT_COMMAND_AUINOTEBOOK_PAGE_CLOSED, 1)
""" A tab in `AuiNotebook` has been closed. """
EVT_AUINOTEBOOK_PAGE_CHANGED = wx.PyEventBinder(wxEVT_COMMAND_AUINOTEBOOK_PAGE_CHANGED, 1)
""" The page selection was changed. """
EVT_AUINOTEBOOK_PAGE_CHANGING = wx.PyEventBinder(wxEVT_COMMAND_AUINOTEBOOK_PAGE_CHANGING, 1)
""" The page selection is being changed. """
EVT_AUINOTEBOOK_BUTTON = wx.PyEventBinder(wxEVT_COMMAND_AUINOTEBOOK_BUTTON, 1)
""" The user clicked on a button in the `AuiNotebook` tab area. """
EVT_AUINOTEBOOK_BEGIN_DRAG = wx.PyEventBinder(wxEVT_COMMAND_AUINOTEBOOK_BEGIN_DRAG, 1)
""" A drag-and-drop operation on a notebook tab has started. """
EVT_AUINOTEBOOK_END_DRAG = wx.PyEventBinder(wxEVT_COMMAND_AUINOTEBOOK_END_DRAG, 1)
""" A drag-and-drop operation on a notebook tab has finished. """
EVT_AUINOTEBOOK_DRAG_MOTION = wx.PyEventBinder(wxEVT_COMMAND_AUINOTEBOOK_DRAG_MOTION, 1)
""" A drag-and-drop operation on a notebook tab is ongoing. """
EVT_AUINOTEBOOK_ALLOW_DND = wx.PyEventBinder(wxEVT_COMMAND_AUINOTEBOOK_ALLOW_DND, 1)
""" Fires an event asking if it is OK to drag and drop a tab. """
EVT_AUINOTEBOOK_DRAG_DONE = wx.PyEventBinder(wxEVT_COMMAND_AUINOTEBOOK_DRAG_DONE, 1)
""" A drag-and-drop operation on a notebook tab has finished. """
EVT_AUINOTEBOOK_TAB_MIDDLE_DOWN = wx.PyEventBinder(wxEVT_COMMAND_AUINOTEBOOK_TAB_MIDDLE_DOWN, 1)
""" The user clicked with the middle mouse button on a tab. """
EVT_AUINOTEBOOK_TAB_MIDDLE_UP = wx.PyEventBinder(wxEVT_COMMAND_AUINOTEBOOK_TAB_MIDDLE_UP, 1)
""" The user clicked with the middle mouse button on a tab. """
EVT_AUINOTEBOOK_TAB_RIGHT_DOWN = wx.PyEventBinder(wxEVT_COMMAND_AUINOTEBOOK_TAB_RIGHT_DOWN, 1)
""" The user clicked with the right mouse button on a tab. """
EVT_AUINOTEBOOK_TAB_RIGHT_UP = wx.PyEventBinder(wxEVT_COMMAND_AUINOTEBOOK_TAB_RIGHT_UP, 1)
""" The user clicked with the right mouse button on a tab. """
EVT_AUINOTEBOOK_BG_MIDDLE_DOWN = wx.PyEventBinder(wxEVT_COMMAND_AUINOTEBOOK_BG_MIDDLE_DOWN, 1)
""" The user middle-clicked in the tab area but not over a tab or a button. """
EVT_AUINOTEBOOK_BG_MIDDLE_UP = wx.PyEventBinder(wxEVT_COMMAND_AUINOTEBOOK_BG_MIDDLE_UP, 1)
""" The user middle-clicked in the tab area but not over a tab or a button. """
EVT_AUINOTEBOOK_BG_RIGHT_DOWN = wx.PyEventBinder(wxEVT_COMMAND_AUINOTEBOOK_BG_RIGHT_DOWN, 1)
""" The user right-clicked in the tab area but not over a tab or a button. """
EVT_AUINOTEBOOK_BG_RIGHT_UP = wx.PyEventBinder(wxEVT_COMMAND_AUINOTEBOOK_BG_RIGHT_UP, 1)
""" The user right-clicked in the tab area but not over a tab or a button. """
EVT_AUINOTEBOOK_BG_DCLICK = wx.PyEventBinder(wxEVT_COMMAND_AUINOTEBOOK_BG_DCLICK, 1)
""" The user left-clicked on the tab area not occupied by `AuiNotebook` tabs. """
EVT_AUINOTEBOOK_CANCEL_DRAG = wx.PyEventBinder(wxEVT_COMMAND_AUINOTEBOOK_CANCEL_DRAG, 1)
""" A drag and drop operation has been cancelled. """
EVT_AUINOTEBOOK_TAB_DCLICK = wx.PyEventBinder(wxEVT_COMMAND_AUINOTEBOOK_TAB_DCLICK, 1)
""" The user double-clicked with the left mouse button on a tab. """
EVT_AUINOTEBOOK_BEGIN_LABEL_EDIT = wx.PyEventBinder(wxEVT_COMMAND_AUINOTEBOOK_BEGIN_LABEL_EDIT, 1)
""" The user double-clicked with the left mouse button on a tab which text is editable. """
EVT_AUINOTEBOOK_END_LABEL_EDIT = wx.PyEventBinder(wxEVT_COMMAND_AUINOTEBOOK_END_LABEL_EDIT, 1)
""" The user finished editing a tab label. """


# -----------------------------------------------------------------------------
# Auxiliary class: TabTextCtrl
# This is the temporary ExpandoTextCtrl created when you edit the text of a tab
# -----------------------------------------------------------------------------

class TabTextCtrl(ExpandoTextCtrl):
    """ Control used for in-place edit. """

    def __init__(self, owner, tab, page_index):
        """
        Default class constructor.
        For internal use: do not call it in your code!

        :param `owner`: the :class:`AuiNotebook` owning the tab;
        :param `tab`: the actual :class:`AuiTabCtrl` tab;
        :param integer `page_index`: the :class:`AuiTabContainer` page index for the tab.
        """

        self._owner = owner
        self._tabEdited = tab
        self._pageIndex = page_index
        self._startValue = tab.caption
        self._finished = False
        self._aboutToFinish = False
        self._currentValue = self._startValue

        x, y, w, h = self._tabEdited.rect

        wnd = self._tabEdited.control
        if wnd:
            x += wnd.GetSize()[0] + 2
            h = 0

        image_h = 0
        image_w = 0

        image = tab.bitmap

        if image.IsOk():
            image_w, image_h = image.GetWidth(), image.GetHeight()
            image_w += 6

        dc = wx.ClientDC(self._owner)
        h = max(image_h, dc.GetMultiLineTextExtent(tab.caption)[1])
        h = h + 2

        # FIXME: what are all these hardcoded 4, 8 and 11s really?
        x += image_w
        w -= image_w + 4

        y = (self._tabEdited.rect.height - h)/2 + 1

        expandoStyle = wx.WANTS_CHARS
        if wx.Platform in ["__WXGTK__", "__WXMAC__"]:
            expandoStyle |= wx.SIMPLE_BORDER
            xSize, ySize = w + 2, h
        else:
            expandoStyle |= wx.SUNKEN_BORDER
            xSize, ySize = w + 2, h+2

        ExpandoTextCtrl.__init__(self, self._owner, wx.ID_ANY, self._startValue,
                                 wx.Point(x, y), wx.Size(xSize, ySize),
                                 expandoStyle)

        if wx.Platform == "__WXMAC__":
            self.SetFont(owner.GetFont())
            bs = self.GetBestSize()
            self.SetSize((-1, bs.height))

        self.Bind(wx.EVT_CHAR, self.OnChar)
        self.Bind(wx.EVT_KEY_UP, self.OnKeyUp)
        self.Bind(wx.EVT_KILL_FOCUS, self.OnKillFocus)


    def AcceptChanges(self):
        """ Accepts/refuses the changes made by the user. """

        value = self.GetValue()
        notebook = self._owner.GetParent()

        if value == self._startValue:
            # nothing changed, always accept
            # when an item remains unchanged, the owner
            # needs to be notified that the user decided
            # not to change the tree item label, and that
            # the edit has been cancelled
            notebook.OnRenameCancelled(self._pageIndex)
            return True

        if not notebook.OnRenameAccept(self._pageIndex, value):
            # vetoed by the user
            return False

        # accepted, do rename the item
        notebook.SetPageText(self._pageIndex, value)

        return True


    def Finish(self):
        """ Finish editing. """

        if not self._finished:

            notebook = self._owner.GetParent()

            self._finished = True
            self._owner.SetFocus()
            notebook.ResetTextControl()


    def OnChar(self, event):
        """
        Handles the ``wx.EVT_CHAR`` event for :class:`TabTextCtrl`.

        :param `event`: a :class:`KeyEvent` event to be processed.
        """

        keycode = event.GetKeyCode()
        shiftDown = event.ShiftDown()

        if keycode == wx.WXK_RETURN:
            if shiftDown and self._tabEdited.IsMultiline():
                event.Skip()
            else:
                self._aboutToFinish = True
                self.SetValue(self._currentValue)
                # Notify the owner about the changes
                self.AcceptChanges()
                # Even if vetoed, close the control (consistent with MSW)
                wx.CallAfter(self.Finish)

        elif keycode == wx.WXK_ESCAPE:
            self.StopEditing()

        else:
            event.Skip()


    def OnKeyUp(self, event):
        """
        Handles the ``wx.EVT_KEY_UP`` event for :class:`TabTextCtrl`.

        :param `event`: a :class:`KeyEvent` event to be processed.
        """

        if not self._finished:

            # auto-grow the textctrl:
            mySize = self.GetSize()

            dc = wx.ClientDC(self)
            sx, sy, dummy = dc.GetMultiLineTextExtent(self.GetValue() + "M")

            self.SetSize((sx, -1))
            self._currentValue = self.GetValue()

        event.Skip()


    def OnKillFocus(self, event):
        """
        Handles the ``wx.EVT_KILL_FOCUS`` event for :class:`TabTextCtrl`.

        :param `event`: a :class:`FocusEvent` event to be processed.
        """

        if not self._finished and not self._aboutToFinish:

            # We must finish regardless of success, otherwise we'll get
            # focus problems:
            if not self.AcceptChanges():
                self._owner.GetParent().OnRenameCancelled(self._pageIndex)

        # We must let the native text control handle focus, too, otherwise
        # it could have problems with the cursor (e.g., in wxGTK).
        event.Skip()
        wx.CallAfter(self._owner.GetParent().ResetTextControl)


    def StopEditing(self):
        """ Suddenly stops the editing. """

        self._owner.GetParent().OnRenameCancelled(self._pageIndex)
        self.Finish()


    def item(self):
        """ Returns the item currently edited. """

        return self._tabEdited


# ----------------------------------------------------------------------

class AuiNotebookPage(object):
    """
    A simple class which holds information about tab captions, bitmaps and
    colours.
    """

    def __init__(self):
        """
        Default class constructor.
        Used internally, do not call it in your code!
        """

        self.window = None              # page's associated window
        self.caption = ""               # caption displayed on the tab
        self.bitmap = wx.NullBitmap     # tab's bitmap
        self.dis_bitmap = wx.NullBitmap # tab's disabled bitmap
        self.rect = wx.Rect()           # tab's hit rectangle
        self.active = False             # True if the page is currently active
        self.enabled = True             # True if the page is currently enabled
        self.hasCloseButton = True      # True if the page has a close button using the style
                                        # AUI_NB_CLOSE_ON_ALL_TABS
        self.control = None             # A control can now be inside a tab
        self.renamable = False          # If True, a tab can be renamed by a left double-click

        self.text_colour = wx.SystemSettings.GetColour(wx.SYS_COLOUR_BTNTEXT)

        self.access_time = datetime.datetime.now() # Last time this page was selected


    def IsMultiline(self):
        """ Returns whether the tab contains multiline text. """

        return "\n" in self.caption


# ----------------------------------------------------------------------

class AuiTabContainerButton(object):
    """
    A simple class which holds information about tab buttons and their state.
    """

    def __init__(self):
        """
        Default class constructor.
        Used internally, do not call it in your code!
        """

        self.id = -1                                      # button's id
        self.cur_state = AUI_BUTTON_STATE_NORMAL          # current state (normal, hover, pressed, etc.)
        self.location = wx.LEFT                           # buttons location (wxLEFT, wxRIGHT, or wxCENTER)
        self.bitmap = wx.NullBitmap                       # button's hover bitmap
        self.dis_bitmap = wx.NullBitmap                   # button's disabled bitmap
        self.rect = wx.Rect()                             # button's hit rectangle


# ----------------------------------------------------------------------

class CommandNotebookEvent(wx.PyCommandEvent):
    """ A specialized command event class for events sent by :class:`AuiNotebook` . """

    def __init__(self, command_type=None, win_id=0):
        """
        Default class constructor.

        :param `command_type`: the event kind or an instance of :class:`PyCommandEvent`.
        :param integer `win_id`: the window identification number.
        """

        if type(command_type) == types.IntType:
            wx.PyCommandEvent.__init__(self, command_type, win_id)
        else:
            wx.PyCommandEvent.__init__(self, command_type.GetEventType(), command_type.GetId())

        self.old_selection = -1
        self.selection = -1
        self.drag_source = None
        self.dispatched = 0
        self.label = ""
        self.editCancelled = False
        self.page = None


    def SetSelection(self, s):
        """
        Sets the selection member variable.

        :param integer `s`: the new selection.
        """

        self.selection = s
        self._commandInt = s


    def GetSelection(self):
        """ Returns the currently selected page, or -1 if none was selected. """

        return self.selection


    def SetOldSelection(self, s):
        """
        Sets the id of the page selected before the change.

        :param integer `s`: the old selection.
        """

        self.old_selection = s


    def GetOldSelection(self):
        """
        Returns the page that was selected before the change, or -1 if none was
        selected.
        """

        return self.old_selection


    def SetDragSource(self, s):
        """
        Sets the drag and drop source.

        :param `s`: the drag source.
        """

        self.drag_source = s


    def GetDragSource(self):
        """ Returns the drag and drop source. """

        return self.drag_source


    def SetDispatched(self, b):
        """
        Sets the event as dispatched (used for automatic :class:`AuiNotebook` ).

        :param `b`: whether the event was dispatched or not.
        """

        self.dispatched = b


    def GetDispatched(self):
        """ Returns whether the event was dispatched (used for automatic :class:`AuiNotebook` ). """

        return self.dispatched


    def IsEditCancelled(self):
        """ Returns the edit cancel flag (for ``EVT_AUINOTEBOOK_BEGIN`` | ``END_LABEL_EDIT`` only)."""

        return self.editCancelled


    def SetEditCanceled(self, editCancelled):
        """
        Sets the edit cancel flag (for ``EVT_AUINOTEBOOK_BEGIN`` | ``END_LABEL_EDIT`` only).

        :param bool `editCancelled`: whether the editing action has been cancelled or not.
        """

        self.editCancelled = editCancelled


    def GetLabel(self):
        """Returns the label-itemtext (for ``EVT_AUINOTEBOOK_BEGIN`` | ``END_LABEL_EDIT`` only)."""

        return self.label


    def SetLabel(self, label):
        """
        Sets the label. Useful only for ``EVT_AUINOTEBOOK_END_LABEL_EDIT``.

        :param string `label`: the new label.
        """

        self.label = label


    Page      = property(lambda self: self.page,
                         lambda self, page: setattr(self, 'page', page))
    Selection = property(lambda self: self.GetSelection(), lambda self, sel: self.SetSelection(sel))

# ----------------------------------------------------------------------

class AuiNotebookEvent(CommandNotebookEvent):
    """ A specialized command event class for events sent by :class:`AuiNotebook`. """

    def __init__(self, command_type=None, win_id=0):
        """
        Default class constructor.

        :param `command_type`: the event kind or an instance of :class:`PyCommandEvent`.
        :param integer `win_id`: the window identification number.
        """

        CommandNotebookEvent.__init__(self, command_type, win_id)

        if type(command_type) == types.IntType:
            self.notify = wx.NotifyEvent(command_type, win_id)
        else:
            self.notify = wx.NotifyEvent(command_type.GetEventType(), command_type.GetId())


    def GetNotifyEvent(self):
        """ Returns the actual :class:`NotifyEvent`. """

        return self.notify


    def IsAllowed(self):
        """ Returns whether the event is allowed or not. """

        return self.notify.IsAllowed()


    def Veto(self):
        """
        Prevents the change announced by this event from happening.

        It is in general a good idea to notify the user about the reasons for
        vetoing the change because otherwise the applications behaviour (which
        just refuses to do what the user wants) might be quite surprising.
        """

        self.notify.Veto()


    def Allow(self):
        """
        This is the opposite of :meth:`Veto`: it explicitly allows the event to be
        processed. For most events it is not necessary to call this method as the
        events are allowed anyhow but some are forbidden by default (this will
        be mentioned in the corresponding event description).
        """

        self.notify.Allow()


# ---------------------------------------------------------------------------- #
# Class TabNavigatorProps
# ---------------------------------------------------------------------------- #

class TabNavigatorProps(object):
    """
    Data storage class for managing and providing access to :class:`TabNavigatorWindow` properties.
    """

    def __init__(self):
        """ Default class constructor. """

        super(TabNavigatorProps, self).__init__()

        # Attributes
        self._icon = wx.NullBitmap
        self._font = wx.NullFont
        self._minsize = wx.DefaultSize

    # Accessors
    Icon = property(lambda self: self._icon,
                    lambda self, icon: setattr(self, '_icon', icon),
                    doc='Sets/Gets the icon for the L{TabNavigatorWindow}, an instance of :class:`Bitmap`.')
    Font = property(lambda self: self._font,
                    lambda self, font: setattr(self, '_font', font),
                    doc='Sets/Gets the font for the L{TabNavigatorWindow}, an instance of :class:`Font`.')
    MinSize = property(lambda self: self._minsize,
                       lambda self, size: setattr(self, '_minsize', size),
                       doc='Sets/Gets the minimum size for the L{TabNavigatorWindow}, an instance of :class:`Size`.')

# ---------------------------------------------------------------------------- #
# Class TabNavigatorWindow
# ---------------------------------------------------------------------------- #

class TabNavigatorWindow(wx.Dialog):
    """
    This class is used to create a modal dialog that enables "Smart Tabbing",
    similar to what you would get by hitting ``Alt`` + ``Tab`` on Windows.
    """

    def __init__(self, parent, props):
        """
        Default class constructor. Used internally.

        :param `parent`: the :class:`TabNavigatorWindow` parent;
        :param `props`: the :class:`TabNavigatorProps` object.
        """

        wx.Dialog.__init__(self, parent, wx.ID_ANY, "", size=props.MinSize, style=0)

        self._selectedItem = -1
        self._indexMap = []
        self._props = props

        if not self._props.Icon.IsOk():
            self._props.Icon = Mondrian.GetBitmap()

        if props.Icon.GetSize() != (16, 16):
            img = self._props.Icon.ConvertToImage()
            img.Rescale(16, 16, wx.IMAGE_QUALITY_HIGH)
            self._props.Icon = wx.BitmapFromImage(img)

        if self._props.Font.IsOk():
            self.Font = self._props.Font

        sz = wx.BoxSizer(wx.VERTICAL)

        self._listBox = wx.ListBox(self, wx.ID_ANY,
                                   wx.DefaultPosition,
                                   wx.Size(200, 150), [],
                                   wx.LB_SINGLE | wx.NO_BORDER)

        mem_dc = wx.MemoryDC()
        mem_dc.SelectObject(wx.EmptyBitmap(1,1))
        font = wx.SystemSettings_GetFont(wx.SYS_DEFAULT_GUI_FONT)
        font.SetWeight(wx.BOLD)
        mem_dc.SetFont(font)

        panelHeight = mem_dc.GetCharHeight()
        panelHeight += 4 # Place a spacer of 2 pixels

        # Out signpost bitmap is 24 pixels
        if panelHeight < 24:
            panelHeight = 24

        self._panel = wx.Panel(self, wx.ID_ANY, wx.DefaultPosition,
                               wx.Size(-1, panelHeight))

        sz.Add(self._panel, 0, wx.EXPAND)
        sz.Add(self._listBox, 1, wx.EXPAND)

        self.SetSizer(sz)

        # Connect events to the list box
        self._listBox.Bind(wx.EVT_KEY_UP, self.OnKeyUp)
        self._listBox.Bind(wx.EVT_NAVIGATION_KEY, self.OnNavigationKey)
        self._listBox.Bind(wx.EVT_LISTBOX_DCLICK, self.OnItemSelected)

        # Connect paint event to the panel
        self._panel.Bind(wx.EVT_PAINT, self.OnPanelPaint)
        self._panel.Bind(wx.EVT_ERASE_BACKGROUND, self.OnPanelEraseBg)

        self.SetBackgroundColour(wx.SystemSettings_GetColour(wx.SYS_COLOUR_3DFACE))
        self._listBox.SetBackgroundColour(wx.SystemSettings_GetColour(wx.SYS_COLOUR_3DFACE))
        self.PopulateListControl(parent)

        self.SetInitialSize(props.MinSize)
        self.Centre()

        # Set focus on the list box to avoid having to click on it to change
        # the tab selection under GTK.
        self._listBox.SetFocus()


    def OnKeyUp(self, event):
        """
        Handles the ``wx.EVT_KEY_UP`` for the :class:`TabNavigatorWindow`.

        :param `event`: a :class:`KeyEvent` event to be processed.
        """

        if event.GetKeyCode() == wx.WXK_CONTROL:
            self.CloseDialog()


    def OnNavigationKey(self, event):
        """
        Handles the ``wx.EVT_NAVIGATION_KEY`` for the :class:`TabNavigatorWindow`.

        :param `event`: a :class:`NavigationKeyEvent` event to be processed.
        """

        selected = self._listBox.GetSelection()
        bk = self.GetParent()
        maxItems = bk.GetPageCount()

        if event.GetDirection():

            # Select next page
            if selected == maxItems - 1:
                itemToSelect = 0
            else:
                itemToSelect = selected + 1

        else:

            # Previous page
            if selected == 0:
                itemToSelect = maxItems - 1
            else:
                itemToSelect = selected - 1

        self._listBox.SetSelection(itemToSelect)


    def PopulateListControl(self, book):
        """
        Populates the :class:`TabNavigatorWindow` listbox with a list of tabs.

        :param `book`: the actual :class:`AuiNotebook`.
        """
        # Index of currently selected page
        selection = book.GetSelection()
        # Total number of pages
        count = book.GetPageCount()
        # List of (index, AuiNotebookPage)
        pages = list(enumerate(book.GetTabContainer().GetPages()))
        if book.GetAGWWindowStyleFlag() & AUI_NB_ORDER_BY_ACCESS:
            # Sort pages using last access time. Most recently used is the
            # first in line
            pages.sort(
                key = lambda element: element[1].access_time,
                reverse = True
            )
        else:
            # Manually add the current selection as first item
            # Remaining ones are added in the next loop
            del pages[selection]
            self._listBox.Append(book.GetPageText(selection))
            self._indexMap.append(selection)

        for (index, page) in pages:
            self._listBox.Append(book.GetPageText(index))
            self._indexMap.append(index)

        # Select the next entry after the current selection
        self._listBox.SetSelection(0)
        dummy = wx.NavigationKeyEvent()
        dummy.SetDirection(True)
        self.OnNavigationKey(dummy)


    def OnItemSelected(self, event):
        """
        Handles the ``wx.EVT_LISTBOX_DCLICK`` event for the :class:`ListBox` inside :class:`TabNavigatorWindow`.

        :param `event`: a :class:`ListEvent` event to be processed.
        """

        self.CloseDialog()


    def CloseDialog(self):
        """ Closes the :class:`TabNavigatorWindow` dialog, setting selection in :class:`AuiNotebook`. """

        bk = self.GetParent()
        self._selectedItem = self._listBox.GetSelection()
        self.EndModal(wx.ID_OK)


    def GetSelectedPage(self):
        """ Gets the page index that was selected when the dialog was closed. """

        return self._indexMap[self._selectedItem]


    def OnPanelPaint(self, event):
        """
        Handles the ``wx.EVT_PAINT`` event for :class:`TabNavigatorWindow` top panel.

        :param `event`: a :class:`PaintEvent` event to be processed.
        """

        dc = wx.PaintDC(self._panel)
        rect = self._panel.GetClientRect()

        bmp = wx.EmptyBitmap(rect.width, rect.height)

        mem_dc = wx.MemoryDC()
        mem_dc.SelectObject(bmp)

        endColour = wx.SystemSettings_GetColour(wx.SYS_COLOUR_BTNSHADOW)
        startColour = LightColour(endColour, 50)
        mem_dc.GradientFillLinear(rect, startColour, endColour, wx.SOUTH)

        # Draw the caption title and place the bitmap
        # get the bitmap optimal position, and draw it
        bmpPt, txtPt = wx.Point(), wx.Point()
        bmpPt.y = (rect.height - self._props.Icon.GetHeight())/2
        bmpPt.x = 3
        mem_dc.DrawBitmap(self._props.Icon, bmpPt.x, bmpPt.y, True)

        # get the text position, and draw it
        font = wx.SystemSettings_GetFont(wx.SYS_DEFAULT_GUI_FONT)
        font.SetWeight(wx.BOLD)
        mem_dc.SetFont(font)
        fontHeight = mem_dc.GetCharHeight()

        txtPt.x = bmpPt.x + self._props.Icon.GetWidth() + 4
        txtPt.y = (rect.height - fontHeight)/2
        mem_dc.SetTextForeground(wx.WHITE)
        mem_dc.DrawText("Opened tabs:", txtPt.x, txtPt.y)
        mem_dc.SelectObject(wx.NullBitmap)

        dc.DrawBitmap(bmp, 0, 0)


    def OnPanelEraseBg(self, event):
        """
        Handles the ``wx.EVT_ERASE_BACKGROUND`` event for :class:`TabNavigatorWindow` top panel.

        :param `event`: a :class:`EraseEvent` event to be processed.

        :note: This is intentionally empty, to reduce flicker.
        """

        pass


# ----------------------------------------------------------------------
# -- AuiTabContainer class implementation --

class AuiTabContainer(object):
    """
    AuiTabContainer is a class which contains information about each tab.
    It also can render an entire tab control to a specified DC.
    It's not a window class itself, because this code will be used by
    the :class:`AuiNotebook`, where it is disadvantageous to have separate
    windows for each tab control in the case of "docked tabs".

    A derived class, :class:`AuiTabCtrl`, is an actual :class:`Window` - derived window
    which can be used as a tab control in the normal sense.
    """

    def __init__(self, auiNotebook):
        """
        Default class constructor.
        Used internally, do not call it in your code!

        :param `auiNotebook`: the parent :class:`AuiNotebook` window.
        """

        self._tab_offset = 0
        self._agwFlags = 0
        self._art = TA.AuiDefaultTabArt()

        self._buttons = []
        self._pages = []
        self._tab_close_buttons = []

        self._rect = wx.Rect()
        self._auiNotebook = auiNotebook

        self.AddButton(AUI_BUTTON_LEFT, wx.LEFT)
        self.AddButton(AUI_BUTTON_RIGHT, wx.RIGHT)
        self.AddButton(AUI_BUTTON_WINDOWLIST, wx.RIGHT)
        self.AddButton(AUI_BUTTON_CLOSE, wx.RIGHT)


    def SetArtProvider(self, art):
        """
        Instructs :class:`AuiTabContainer` to use art provider specified by parameter `art`
        for all drawing calls. This allows plugable look-and-feel features.

        :param `art`: an art provider.

        :note: The previous art provider object, if any, will be deleted by :class:`AuiTabContainer`.
        """

        del self._art
        self._art = art

        if self._art:
            self._art.SetAGWFlags(self._agwFlags)


    def GetArtProvider(self):
        """ Returns the current art provider being used. """

        return self._art


    def SetAGWFlags(self, agwFlags):
        """
        Sets the tab art flags.

        :param integer `agwFlags`: a combination of the following values:

         ==================================== ==================================
         Flag name                            Description
         ==================================== ==================================
         ``AUI_NB_TOP``                       With this style, tabs are drawn along the top of the notebook
         ``AUI_NB_LEFT``                      With this style, tabs are drawn along the left of the notebook. Not implemented yet
         ``AUI_NB_RIGHT``                     With this style, tabs are drawn along the right of the notebook. Not implemented yet
         ``AUI_NB_BOTTOM``                    With this style, tabs are drawn along the bottom of the notebook
         ``AUI_NB_TAB_SPLIT``                 Allows the tab control to be split by dragging a tab
         ``AUI_NB_TAB_MOVE``                  Allows a tab to be moved horizontally by dragging
         ``AUI_NB_TAB_EXTERNAL_MOVE``         Allows a tab to be moved to another tab control
         ``AUI_NB_TAB_FIXED_WIDTH``           With this style, all tabs have the same width
         ``AUI_NB_SCROLL_BUTTONS``            With this style, left and right scroll buttons are displayed
         ``AUI_NB_WINDOWLIST_BUTTON``         With this style, a drop-down list of windows is available
         ``AUI_NB_CLOSE_BUTTON``              With this style, a close button is available on the tab bar
         ``AUI_NB_CLOSE_ON_ACTIVE_TAB``       With this style, a close button is available on the active tab
         ``AUI_NB_CLOSE_ON_ALL_TABS``         With this style, a close button is available on all tabs
         ``AUI_NB_MIDDLE_CLICK_CLOSE``        Allows to close :class:`AuiNotebook` tabs by mouse middle button click
         ``AUI_NB_SUB_NOTEBOOK``              This style is used by :class:`~lib.agw.aui.framemanager.AuiManager` to create automatic AuiNotebooks
         ``AUI_NB_HIDE_ON_SINGLE_TAB``        Hides the tab window if only one tab is present
         ``AUI_NB_SMART_TABS``                Use Smart Tabbing, like ``Alt`` + ``Tab`` on Windows
         ``AUI_NB_USE_IMAGES_DROPDOWN``       Uses images on dropdown window list menu instead of check items
         ``AUI_NB_CLOSE_ON_TAB_LEFT``         Draws the tab close button on the left instead of on the right (a la Camino browser)
         ``AUI_NB_TAB_FLOAT``                 Allows the floating of single tabs. Known limitation: when the notebook is more or less full screen,
                                              tabs cannot be dragged far enough outside of the notebook to become floating pages
         ``AUI_NB_DRAW_DND_TAB``              Draws an image representation of a tab while dragging (on by default)
         ``AUI_NB_ORDER_BY_ACCESS``           Tab navigation order by last access time for the tabs
         ``AUI_NB_NO_TAB_FOCUS``              Don't draw tab focus rectangle
         ==================================== ==================================

        .. todo:: Implementation of flags ``AUI_NB_RIGHT`` and ``AUI_NB_LEFT``.

        """

        self._agwFlags = agwFlags

        # check for new close button settings
        self.RemoveButton(AUI_BUTTON_LEFT)
        self.RemoveButton(AUI_BUTTON_RIGHT)
        self.RemoveButton(AUI_BUTTON_WINDOWLIST)
        self.RemoveButton(AUI_BUTTON_CLOSE)

        if agwFlags & AUI_NB_SCROLL_BUTTONS:
            self.AddButton(AUI_BUTTON_LEFT, wx.LEFT)
            self.AddButton(AUI_BUTTON_RIGHT, wx.RIGHT)

        if agwFlags & AUI_NB_WINDOWLIST_BUTTON:
            self.AddButton(AUI_BUTTON_WINDOWLIST, wx.RIGHT)

        if agwFlags & AUI_NB_CLOSE_BUTTON:
            self.AddButton(AUI_BUTTON_CLOSE, wx.RIGHT)

        if self._art:
            self._art.SetAGWFlags(self._agwFlags)


    def GetAGWFlags(self):
        """
        Returns the tab art flags.

        .. seealso:: :meth:`SetAGWFlags` for a list of possible return values.
        """

        return self._agwFlags


    def SetNormalFont(self, font):
        """
        Sets the normal font for drawing tab labels.

        :param Font `font`: the new font to use to draw tab labels in their normal, un-selected state.
        """

        self._art.SetNormalFont(font)


    def SetSelectedFont(self, font):
        """
        Sets the selected tab font for drawing tab labels.

        :param Font `font`: the new font to use to draw tab labels in their selected state.
        """

        self._art.SetSelectedFont(font)


    def SetMeasuringFont(self, font):
        """
        Sets the font for calculating text measurements.

        :param Font `font`: the new font to use to measure tab label text extents.
        """

        self._art.SetMeasuringFont(font)


    def SetTabRect(self, rect):
        """
        Sets the tab area rectangle.

        :param Rect `rect`: the available area for :class:`AuiTabContainer`.
        """

        self._rect = rect

        if self._art:
            minMaxTabWidth = self._auiNotebook.GetMinMaxTabWidth()
            self._art.SetSizingInfo(rect.GetSize(), len(self._pages), minMaxTabWidth)


    def AddPage(self, page, info):
        """
        Adds a page to the tab control.

        :param Window `page`: the window associated with this tab;
        :param `info`: an instance of :class:`AuiNotebookPage`.
        """

        page_info = info
        page_info.window = page

        self._pages.append(page_info)

        # let the art provider know how many pages we have
        if self._art:
            minMaxTabWidth = self._auiNotebook.GetMinMaxTabWidth()
            self._art.SetSizingInfo(self._rect.GetSize(), len(self._pages), minMaxTabWidth)

        return True


    def InsertPage(self, page, info, idx):
        """
        Inserts a page in the tab control in the position specified by `idx`.

        :param Window `page`: the window associated with this tab;
        :param `info`: an instance of :class:`AuiNotebookPage`;
        :param integer `idx`: the page insertion index.
        """

        page_info = info
        page_info.window = page

        if idx >= len(self._pages):
            self._pages.append(page_info)
        else:
            self._pages.insert(idx, page_info)

        # let the art provider know how many pages we have
        if self._art:
            minMaxTabWidth = self._auiNotebook.GetMinMaxTabWidth()
            self._art.SetSizingInfo(self._rect.GetSize(), len(self._pages), minMaxTabWidth)

        return True


    def MovePage(self, page, new_idx):
        """
        Moves a page in a new position specified by `new_idx`.

        :param Window `page`: the window associated with this tab;
        :param integer `new_idx`: the new page position.
        """

        idx = self.GetIdxFromWindow(page)
        if idx == -1:
            return False

        # get page entry, make a copy of it
        p = self.GetPage(idx)

        # remove old page entry
        self.RemovePage(page)

        # insert page where it should be
        self.InsertPage(page, p, new_idx)

        return True


    def RemovePage(self, wnd):
        """
        Removes a page from the tab control.

        :param `wnd`: an instance of :class:`Window`, a window associated with this tab.
        """

        minMaxTabWidth = self._auiNotebook.GetMinMaxTabWidth()

        for page in self._pages:
            if page.window == wnd:
                self._pages.remove(page)
                self._tab_offset = min(self._tab_offset, len(self._pages) - 1)

                # let the art provider know how many pages we have
                if self._art:
                    self._art.SetSizingInfo(self._rect.GetSize(), len(self._pages), minMaxTabWidth)

                return True

        return False


    def SetActivePage(self, wndOrInt):
        """
        Sets the :class:`AuiNotebook` active page.

        :param `wndOrInt`: an instance of :class:`Window` or an integer specifying a tab index.
        """

        if type(wndOrInt) == types.IntType:

            if wndOrInt >= len(self._pages):
                return False

            wnd = self._pages[wndOrInt].window

        else:
            wnd = wndOrInt

        found = False

        for indx, page in enumerate(self._pages):
            if page.window == wnd:
                page.active = True
                found = True
            else:
                page.active = False

        return found


    def SetNoneActive(self):
        """ Sets all the tabs as inactive (non-selected). """

        for page in self._pages:
            page.active = False


    def GetActivePage(self):
        """ Returns the current selected tab or ``wx.NOT_FOUND`` if none is selected. """

        for indx, page in enumerate(self._pages):
            if page.active:
                return indx

        return wx.NOT_FOUND


    def GetWindowFromIdx(self, idx):
        """
        Returns the window associated with the tab with index `idx`.

        :param integer `idx`: the tab index.
        """

        if idx >= len(self._pages):
            return None

        return self._pages[idx].window


    def GetIdxFromWindow(self, wnd):
        """
        Returns the tab index based on the window `wnd` associated with it.

        :param `wnd`: an instance of :class:`Window`.
        """

        for indx, page in enumerate(self._pages):
            if page.window == wnd:
                return indx

        return wx.NOT_FOUND


    def GetPage(self, idx):
        """
        Returns the page specified by the given index.

        :param integer `idx`: the tab index.
        """

        if idx < 0 or idx >= len(self._pages):
            raise Exception("Invalid Page index")

        return self._pages[idx]


    def GetPages(self):
        """ Returns a list of all the pages in this :class:`AuiTabContainer`. """

        return self._pages


    def GetPageCount(self):
        """ Returns the number of pages in the :class:`AuiTabContainer`. """

        return len(self._pages)


    def GetEnabled(self, idx):
        """
        Returns whether a tab is enabled or not.

        :param integer `idx`: the tab index.
        """

        if idx < 0 or idx >= len(self._pages):
            return False

        return self._pages[idx].enabled


    def EnableTab(self, idx, enable=True):
        """
        Enables/disables a tab in the :class:`AuiTabContainer`.

        :param integer `idx`: the tab index;
        :param bool `enable`: ``True`` to enable a tab, ``False`` to disable it.
        """

        if idx < 0 or idx >= len(self._pages):
            raise Exception("Invalid Page index")

        self._pages[idx].enabled = enable
        wnd = self.GetWindowFromIdx(idx)
        wnd.Enable(enable)


    def AddButton(self, id, location, normal_bitmap=wx.NullBitmap, disabled_bitmap=wx.NullBitmap):
        """
        Adds a button in the tab area.

        :param integer `id`: the button identifier. This can be one of the following:

         ==============================  =================================
         Button Identifier               Description
         ==============================  =================================
         ``AUI_BUTTON_CLOSE``            Shows a close button on the tab area
         ``AUI_BUTTON_WINDOWLIST``       Shows a window list button on the tab area
         ``AUI_BUTTON_LEFT``             Shows a left button on the tab area
         ``AUI_BUTTON_RIGHT``            Shows a right button on the tab area
         ==============================  =================================

        :param integer `location`: the button location. Can be ``wx.LEFT`` or ``wx.RIGHT``;
        :param Bitmap `normal_bitmap`: the bitmap for an enabled tab;
        :param Bitmap `disabled_bitmap`: the bitmap for a disabled tab.
        """

        button = AuiTabContainerButton()
        button.id = id
        button.bitmap = normal_bitmap
        button.dis_bitmap = disabled_bitmap
        button.location = location
        button.cur_state = AUI_BUTTON_STATE_NORMAL

        self._buttons.append(button)


    def CloneButtons(self):
        """
        Clones the tab area buttons when the :class:`AuiNotebook` is being split.

        :see: :meth:`AddButton`

        :note: Standard buttons for :class:`AuiNotebook` are not cloned, only custom ones.
        """

        singleton_list = [AUI_BUTTON_CLOSE, AUI_BUTTON_WINDOWLIST, AUI_BUTTON_LEFT, AUI_BUTTON_RIGHT]
        clones = []

        for button in self._buttons:
            if button.id not in singleton_list:
                new_button = AuiTabContainerButton()
                new_button.id = button.id
                new_button.bitmap = button.bitmap
                new_button.dis_bitmap = button.dis_bitmap
                new_button.location = button.location
                clones.append(new_button)

        return clones


    def RemoveButton(self, id):
        """
        Removes a button from the tab area.

        :param integer `id`: the button identifier. See :meth:`AddButton` for a list of button identifiers.

        :see: :meth:`AddButton`
        """

        for button in self._buttons:
            if button.id == id:
                self._buttons.remove(button)
                return


    def GetTabOffset(self):
        """ Returns the tab offset. """

        return self._tab_offset


    def SetTabOffset(self, offset):
        """
        Sets the tab offset.

        :param integer `offset`: the tab offset.
        """

        self._tab_offset = offset


    def Render(self, raw_dc, wnd):
        """
        Renders the tab catalog to the specified :class:`DC`.

        It is a virtual function and can be overridden to provide custom drawing
        capabilities.

        :param `raw_dc`: a :class:`DC` device context;
        :param `wnd`: an instance of :class:`Window`.
        """

        if not raw_dc or not raw_dc.IsOk():
            return

        dc = wx.MemoryDC()

        # use the same layout direction as the window DC uses to ensure that the
        # text is rendered correctly
        dc.SetLayoutDirection(raw_dc.GetLayoutDirection())

        page_count = len(self._pages)
        button_count = len(self._buttons)

        # create off-screen bitmap
        bmp = wx.EmptyBitmap(self._rect.GetWidth(), self._rect.GetHeight())
        dc.SelectObject(bmp)

        if not dc.IsOk():
            return

        # prepare the tab-close-button array
        # make sure tab button entries which aren't used are marked as hidden
        for i in xrange(page_count, len(self._tab_close_buttons)):
            self._tab_close_buttons[i].cur_state = AUI_BUTTON_STATE_HIDDEN

        # make sure there are enough tab button entries to accommodate all tabs
        while len(self._tab_close_buttons) < page_count:
            tempbtn = AuiTabContainerButton()
            tempbtn.id = AUI_BUTTON_CLOSE
            tempbtn.location = wx.CENTER
            tempbtn.cur_state = AUI_BUTTON_STATE_HIDDEN
            self._tab_close_buttons.append(tempbtn)

        # find out if size of tabs is larger than can be
        # afforded on screen
        total_width = visible_width = 0
        tab_width = [0] * page_count

        for i in xrange(page_count):
            page = self._pages[i]

            # determine if a close button is on this tab
            close_button = False
            if (self._agwFlags & AUI_NB_CLOSE_ON_ALL_TABS and page.hasCloseButton) or \
               (self._agwFlags & AUI_NB_CLOSE_ON_ACTIVE_TAB and page.active and page.hasCloseButton):

                close_button = True

            control = page.control
            if control:
                try:
                    control.GetSize()
                except wx.PyDeadObjectError:
                    page.control = None

            size, x_extent = self._art.GetTabSize(dc, wnd, page.caption, page.bitmap, page.active,
                                                  (close_button and [AUI_BUTTON_STATE_NORMAL] or \
                                                   [AUI_BUTTON_STATE_HIDDEN])[0], page.control)

            if i+1 < page_count:
                total_width += x_extent
                tab_width[i] = x_extent
            else:
                total_width += size[0]
                tab_width[i] = size[0]

            if i >= self._tab_offset:            
                if i+1 < page_count:
                    visible_width += x_extent
                else:
                    visible_width += size[0]

        # Calculate the width of visible buttons
        buttons_width = 0

        for button in self._buttons:
            if not (button.cur_state & AUI_BUTTON_STATE_HIDDEN):
                buttons_width += button.rect.GetWidth()

        total_width += buttons_width

        if (total_width > self._rect.GetWidth() and page_count > 1) or self._tab_offset != 0:

            # show left/right buttons
            for button in self._buttons:
                if button.id == AUI_BUTTON_LEFT or \
                   button.id == AUI_BUTTON_RIGHT:

                    button.cur_state &= ~AUI_BUTTON_STATE_HIDDEN

        else:

            # hide left/right buttons
            for button in self._buttons:
                if button.id == AUI_BUTTON_LEFT or \
                   button.id == AUI_BUTTON_RIGHT:
                    
                    button.cur_state |= AUI_BUTTON_STATE_HIDDEN

        # Re-calculate the width of visible buttons (may have been hidden/shown)
        buttons_width = 0
        for button in self._buttons:
            if not (button.cur_state & AUI_BUTTON_STATE_HIDDEN):
                buttons_width += button.rect.GetWidth()

        # Shift the tab offset down to make use of available space
        available_width = self._rect.GetWidth() - buttons_width
        while self._tab_offset > 0 and visible_width + tab_width[self._tab_offset - 1] < available_width:
            self._tab_offset -= 1
            visible_width += tab_width[self._tab_offset]

        # determine whether left button should be enabled
        for button in self._buttons:
            if button.id == AUI_BUTTON_LEFT:
                if self._tab_offset == 0:
                    button.cur_state |= AUI_BUTTON_STATE_DISABLED
                else:
                    button.cur_state &= ~AUI_BUTTON_STATE_DISABLED

            if button.id == AUI_BUTTON_RIGHT:
                if visible_width < self._rect.GetWidth() - buttons_width:
                    button.cur_state |= AUI_BUTTON_STATE_DISABLED
                else:
                    button.cur_state &= ~AUI_BUTTON_STATE_DISABLED

        # draw background
        self._art.DrawBackground(dc, wnd, self._rect)

        # draw buttons
        left_buttons_width = 0
        right_buttons_width = 0

        # draw the buttons on the right side
        offset = self._rect.x + self._rect.width

        for i in xrange(button_count):
            button = self._buttons[button_count - i - 1]

            if button.location != wx.RIGHT:
                continue
            if button.cur_state & AUI_BUTTON_STATE_HIDDEN:
                continue

            button_rect = wx.Rect(*self._rect)
            button_rect.SetY(1)
            button_rect.SetWidth(offset)

            button.rect = self._art.DrawButton(dc, wnd, button_rect, button, wx.RIGHT)

            offset -= button.rect.GetWidth()
            right_buttons_width += button.rect.GetWidth()

        offset = 0

        # draw the buttons on the left side
        for i in xrange(button_count):
            button = self._buttons[button_count - i - 1]

            if button.location != wx.LEFT:
                continue
            if button.cur_state & AUI_BUTTON_STATE_HIDDEN:
                continue

            button_rect = wx.Rect(offset, 1, 1000, self._rect.height)

            button.rect = self._art.DrawButton(dc, wnd, button_rect, button, wx.LEFT)

            offset += button.rect.GetWidth()
            left_buttons_width += button.rect.GetWidth()

        offset = left_buttons_width

        if offset == 0:
            offset += self._art.GetIndentSize()

        # buttons before the tab offset must be set to hidden
        for i in xrange(self._tab_offset):
            self._tab_close_buttons[i].cur_state = AUI_BUTTON_STATE_HIDDEN
            if self._pages[i].control:
                if self._pages[i].control.IsShown():
                    self._pages[i].control.Hide()

        # draw tab before tab offset
        if self._tab_offset > 0:
            page = self._pages[self._tab_offset - 1]
            tab_button = self._tab_close_buttons[self._tab_offset - 1]
            size, x_extent = self._art.GetTabSize(dc, wnd, page.caption, page.bitmap, page.active, tab_button.cur_state, page.control)

            rect = wx.Rect(offset - x_extent, 0, self._rect.width - right_buttons_width - offset - x_extent - 2, self._rect.height)
            clip_rect = wx.Rect(*self._rect)
            clip_rect.x = offset

            dc.SetClippingRect(clip_rect)
            self._art.DrawTab(dc, wnd, page, rect, tab_button.cur_state)
            dc.DestroyClippingRegion()

        # draw the tabs
        active = 999
        active_offset = 0

        rect = wx.Rect(*self._rect)
        rect.y = 0
        rect.height = self._rect.height

        for i in xrange(self._tab_offset, page_count):

            page = self._pages[i]
            tab_button = self._tab_close_buttons[i]

            # determine if a close button is on this tab
            if (self._agwFlags & AUI_NB_CLOSE_ON_ALL_TABS and page.hasCloseButton) or \
               (self._agwFlags & AUI_NB_CLOSE_ON_ACTIVE_TAB and page.active and page.hasCloseButton):

                if tab_button.cur_state == AUI_BUTTON_STATE_HIDDEN:

                    tab_button.id = AUI_BUTTON_CLOSE
                    tab_button.cur_state = AUI_BUTTON_STATE_NORMAL
                    tab_button.location = wx.CENTER

            else:

                tab_button.cur_state = AUI_BUTTON_STATE_HIDDEN

            rect.x = offset
            rect.width = self._rect.width - right_buttons_width - offset - 2

            if rect.width <= 0:
                break

            page.rect, tab_button.rect, x_extent = self._art.DrawTab(dc, wnd, page, rect, tab_button.cur_state)

            if page.active:
                active = i
                active_offset = offset
                active_rect = wx.Rect(*rect)

            offset += x_extent

        lenPages = len(self._pages)
        # make sure to deactivate buttons which are off the screen to the right
        for j in xrange(i+1, len(self._tab_close_buttons)):
            self._tab_close_buttons[j].cur_state = AUI_BUTTON_STATE_HIDDEN
            if j > 0 and j <= lenPages:
                if self._pages[j-1].control:
                    if self._pages[j-1].control.IsShown():
                        self._pages[j-1].control.Hide()

        # draw the active tab again so it stands in the foreground
        if active >= self._tab_offset and active < len(self._pages):

            page = self._pages[active]
            tab_button = self._tab_close_buttons[active]

            rect.x = active_offset
            dummy = self._art.DrawTab(dc, wnd, page, active_rect, tab_button.cur_state)

        raw_dc.Blit(self._rect.x, self._rect.y, self._rect.GetWidth(), self._rect.GetHeight(), dc, 0, 0)


    def IsTabVisible(self, tabPage, tabOffset, dc, wnd):
        """
        Returns whether a tab is visible or not.

        :param integer `tabPage`: the tab index;
        :param integer `tabOffset`: the tab offset;
        :param `dc`: a :class:`DC` device context;
        :param `wnd`: an instance of :class:`Window` derived window.
        """

        if not dc or not dc.IsOk():
            return False

        page_count = len(self._pages)
        button_count = len(self._buttons)
        self.Render(dc, wnd)

        # Hasn't been rendered yet assume it's visible
        if len(self._tab_close_buttons) < page_count:
            return True

        if self._agwFlags & AUI_NB_SCROLL_BUTTONS:
            # First check if both buttons are disabled - if so, there's no need to
            # check further for visibility.
            arrowButtonVisibleCount = 0
            for i in xrange(button_count):

                button = self._buttons[i]
                if button.id == AUI_BUTTON_LEFT or \
                   button.id == AUI_BUTTON_RIGHT:

                    if button.cur_state & AUI_BUTTON_STATE_HIDDEN == 0:
                        arrowButtonVisibleCount += 1

            # Tab must be visible
            if arrowButtonVisibleCount == 0:
                return True

        # If tab is less than the given offset, it must be invisible by definition
        if tabPage < tabOffset:
            return False

        # draw buttons
        left_buttons_width = 0
        right_buttons_width = 0

        offset = 0

        # calculate size of the buttons on the right side
        offset = self._rect.x + self._rect.width

        for i in xrange(button_count):
            button = self._buttons[button_count - i - 1]

            if button.location != wx.RIGHT:
                continue
            if button.cur_state & AUI_BUTTON_STATE_HIDDEN:
                continue

            offset -= button.rect.GetWidth()
            right_buttons_width += button.rect.GetWidth()

        offset = 0

        # calculate size of the buttons on the left side
        for i in xrange(button_count):
            button = self._buttons[button_count - i - 1]

            if button.location != wx.LEFT:
                continue
            if button.cur_state & AUI_BUTTON_STATE_HIDDEN:
                continue

            offset += button.rect.GetWidth()
            left_buttons_width += button.rect.GetWidth()

        offset = left_buttons_width

        if offset == 0:
            offset += self._art.GetIndentSize()

        rect = wx.Rect(*self._rect)
        rect.y = 0
        rect.height = self._rect.height

        # See if the given page is visible at the given tab offset (effectively scroll position)
        for i in xrange(tabOffset, page_count):

            page = self._pages[i]
            tab_button = self._tab_close_buttons[i]

            rect.x = offset
            rect.width = self._rect.width - right_buttons_width - offset - 2

            if rect.width <= 0:
                return False # haven't found the tab, and we've run out of space, so return False

            size, x_extent = self._art.GetTabSize(dc, wnd, page.caption, page.bitmap, page.active, tab_button.cur_state, page.control)
            offset += x_extent

            if i == tabPage:

                # If not all of the tab is visible, and supposing there's space to display it all,
                # we could do better so we return False.
                if (self._rect.width - right_buttons_width - offset - 2) <= 0 and (self._rect.width - right_buttons_width - left_buttons_width) > x_extent:
                    return False
                else:
                    return True

        # Shouldn't really get here, but if it does, assume the tab is visible to prevent
        # further looping in calling code.
        return True


    def MakeTabVisible(self, tabPage, win):
        """
        Make the tab visible if it wasn't already.

        :param integer `tabPage`: the tab index;
        :param `win`: an instance of :class:`Window` derived window.
        """

        dc = wx.ClientDC(win)

        if not self.IsTabVisible(tabPage, self.GetTabOffset(), dc, win):
            for i in xrange(len(self._pages)):
                if self.IsTabVisible(tabPage, i, dc, win):
                    self.SetTabOffset(i)
                    win.Refresh()
                    return


    def TabHitTest(self, x, y):
        """
        TabHitTest() tests if a tab was hit, passing the window pointer
        back if that condition was fulfilled.

        :param integer `x`: the mouse `x` position;
        :param integer `y`: the mouse `y` position.
        """

        if not self._rect.Contains((x,y)):
            return None

        btn = self.ButtonHitTest(x, y)
        if btn:
            if btn in self._buttons:
                return None

        for i in xrange(self._tab_offset, len(self._pages)):
            page = self._pages[i]
            if page.rect.Contains((x,y)):
                return page.window

        return None


    def ButtonHitTest(self, x, y):
        """
        Tests if a button was hit.

        :param integer `x`: the mouse `x` position;
        :param integer `y`: the mouse `y` position.

        :returns: and instance of :class:`AuiTabContainerButton` if a button was hit, ``None`` otherwise.
        """

        if not self._rect.Contains((x,y)):
            return None

        for button in self._buttons:
            if button.rect.Contains((x,y)) and \
               (button.cur_state & (AUI_BUTTON_STATE_HIDDEN|AUI_BUTTON_STATE_DISABLED)) == 0:
                return button

        for button in self._tab_close_buttons:
            if button.rect.Contains((x,y)) and \
               (button.cur_state & (AUI_BUTTON_STATE_HIDDEN|AUI_BUTTON_STATE_DISABLED)) == 0:
                return button

        return None


    def DoShowHide(self):
        """
        This function shows the active window, then hides all of the other windows
        (in that order).
        """

        pages = self.GetPages()

        # show new active page first
        for page in pages:
            if page.active:
                page.window.Show(True)
                break

        # hide all other pages
        for page in pages:
            if not page.active:
                page.window.Show(False)


# ----------------------------------------------------------------------
# -- AuiTabCtrl class implementation --

class AuiTabCtrl(wx.PyControl, AuiTabContainer):
    """
    This is an actual :class:`Window` - derived window which can be used as a tab control in the normal sense.
    """

    def __init__(self, parent, id=wx.ID_ANY, pos=wx.DefaultPosition, size=wx.DefaultSize,
                 style=wx.NO_BORDER|wx.WANTS_CHARS|wx.TAB_TRAVERSAL):
        """
        Default class constructor.
        Used internally, do not call it in your code!

        :param `parent`: the :class:`AuiNotebook` parent;
        :param integer `id`: an identifier for the control: a value of -1 is taken to mean a default;
        :param Point `pos`: the control position. A value of (-1, -1) indicates a default position,
         chosen by either the windowing system or wxPython, depending on platform;
        :param Size `size`: the control size. A value of (-1, -1) indicates a default size,
         chosen by either the windowing system or wxPython, depending on platform;
        :param integer `style`: the window style.
        """

        wx.PyControl.__init__(self, parent, id, pos, size, style, name="AuiTabCtrl")
        AuiTabContainer.__init__(self, parent)

        self._click_pt = wx.Point(-1, -1)
        self._is_dragging = False
        self._hover_button = None
        self._pressed_button = None
        self._drag_image = None
        self._drag_img_offset = (0, 0)
        self._on_button = False

        self.Bind(wx.EVT_PAINT, self.OnPaint)
        self.Bind(wx.EVT_ERASE_BACKGROUND, self.OnEraseBackground)
        self.Bind(wx.EVT_SIZE, self.OnSize)
        self.Bind(wx.EVT_LEFT_DOWN, self.OnLeftDown)
        self.Bind(wx.EVT_LEFT_DCLICK, self.OnLeftDClick)
        self.Bind(wx.EVT_LEFT_UP, self.OnLeftUp)
        self.Bind(wx.EVT_MIDDLE_DOWN, self.OnMiddleDown)
        self.Bind(wx.EVT_MIDDLE_UP, self.OnMiddleUp)
        self.Bind(wx.EVT_RIGHT_DOWN, self.OnRightDown)
        self.Bind(wx.EVT_RIGHT_UP, self.OnRightUp)
        self.Bind(wx.EVT_SET_FOCUS, self.OnSetFocus)
        self.Bind(wx.EVT_KILL_FOCUS, self.OnKillFocus)
        self.Bind(wx.EVT_KEY_DOWN, self.OnKeyDown)
        self.Bind(wx.EVT_MOUSE_CAPTURE_LOST, self.OnCaptureLost)
        self.Bind(wx.EVT_MOTION, self.OnMotion)
        self.Bind(wx.EVT_LEAVE_WINDOW, self.OnLeaveWindow)
        self.Bind(EVT_AUINOTEBOOK_BUTTON, self.OnButton)


    def IsDragging(self):
        """ Returns whether the user is dragging a tab with the mouse or not. """

        return self._is_dragging


    def GetDefaultBorder(self):
        """ Returns the default border style for :class:`AuiTabCtrl`. """

        return wx.BORDER_NONE


    def OnPaint(self, event):
        """
        Handles the ``wx.EVT_PAINT`` event for :class:`AuiTabCtrl`.

        :param `event`: a :class:`PaintEvent` event to be processed.
        """

        dc = wx.PaintDC(self)
        dc.SetFont(self.GetFont())

        if self.GetPageCount() > 0:
            self.Render(dc, self)


    def OnEraseBackground(self, event):
        """
        Handles the ``wx.EVT_ERASE_BACKGROUND`` event for :class:`AuiTabCtrl`.

        :param `event`: a :class:`EraseEvent` event to be processed.

        :note: This is intentionally empty, to reduce flicker.
        """

        pass


    def DoGetBestSize(self):
        """
        Gets the size which best suits the window: for a control, it would be the
        minimal size which doesn't truncate the control, for a panel - the same
        size as it would have after a call to `Fit()`.

        :note: Overridden from :class:`PyControl`.
        """

        return wx.Size(self._rect.width, self._rect.height)


    def OnSize(self, event):
        """
        Handles the ``wx.EVT_SIZE`` event for :class:`AuiTabCtrl`.

        :param `event`: a :class:`SizeEvent` event to be processed.
        """

        s = event.GetSize()
        self.SetTabRect(wx.Rect(0, 0, s.GetWidth(), s.GetHeight()))


    def OnLeftDown(self, event):
        """
        Handles the ``wx.EVT_LEFT_DOWN`` event for :class:`AuiTabCtrl`.

        :param `event`: a :class:`MouseEvent` event to be processed.
        """

        if not self.HasCapture():
            self.CaptureMouse()

        self._click_pt = wx.Point(-1, -1)
        self._is_dragging = False
        self._click_tab = None
        self._pressed_button = None

        wnd = self.TabHitTest(event.GetX(), event.GetY())

        if wnd is not None:
            new_selection = self.GetIdxFromWindow(wnd)

            # AuiNotebooks always want to receive this event
            # even if the tab is already active, because they may
            # have multiple tab controls
            if (new_selection != self.GetActivePage() or isinstance(self.GetParent(), AuiNotebook)) and \
               not self._hover_button:
                e = AuiNotebookEvent(wxEVT_COMMAND_AUINOTEBOOK_PAGE_CHANGING, self.GetId())
                e.SetSelection(new_selection)
                e.SetOldSelection(self.GetActivePage())
                e.SetEventObject(self)
                self.GetEventHandler().ProcessEvent(e)

            self._click_pt.x = event.GetX()
            self._click_pt.y = event.GetY()
            self._click_tab = wnd

            wnd.SetFocus()
        else:
            page_index = self.GetActivePage()
            if page_index != wx.NOT_FOUND:
                self.GetWindowFromIdx(page_index).SetFocus()

            self._hover_button = self.ButtonHitTest(event.GetX(), event.GetY())

            if self._hover_button:
                self._pressed_button = self._hover_button
                self._pressed_button.cur_state = AUI_BUTTON_STATE_PRESSED
                self._on_button = True

                self.Refresh()
                self.Update()


    def OnCaptureLost(self, event):
        """
        Handles the ``wx.EVT_MOUSE_CAPTURE_LOST`` event for :class:`AuiTabCtrl`.

        :param `event`: a :class:`MouseCaptureLostEvent` event to be processed.
        """

        if self._is_dragging:
            self._is_dragging = False
            self._on_button = False

            if self._drag_image:
                self._drag_image.EndDrag()
                del self._drag_image
                self._drag_image = None

            event = AuiNotebookEvent(wxEVT_COMMAND_AUINOTEBOOK_CANCEL_DRAG, self.GetId())
            event.SetSelection(self.GetIdxFromWindow(self._click_tab))
            event.SetOldSelection(event.GetSelection())
            event.SetEventObject(self)
            self.GetEventHandler().ProcessEvent(event)


    def OnLeftUp(self, event):
        """
        Handles the ``wx.EVT_LEFT_UP`` event for :class:`AuiTabCtrl`.

        :param `event`: a :class:`MouseEvent` event to be processed.
        """

        self._on_button = False

        if self._is_dragging:

            if self.HasCapture():
                self.ReleaseMouse()

            self._is_dragging = False
            if self._drag_image:
                self._drag_image.EndDrag()
                del self._drag_image
                self._drag_image = None
                self.GetParent().Refresh()

            evt = AuiNotebookEvent(wxEVT_COMMAND_AUINOTEBOOK_END_DRAG, self.GetId())
            evt.SetSelection(self.GetIdxFromWindow(self._click_tab))
            evt.SetOldSelection(evt.GetSelection())
            evt.SetEventObject(self)
            self.GetEventHandler().ProcessEvent(evt)

            return

        self.GetParent()._mgr.HideHint()

        if self.HasCapture():
            self.ReleaseMouse()

        if self._hover_button:
            self._pressed_button = self._hover_button
            self._hover_button.cur_state = AUI_BUTTON_STATE_NORMAL

        if self._pressed_button:

            # make sure we're still clicking the button
            button = self.ButtonHitTest(event.GetX(), event.GetY())

            if button is None:
                return

            if button != self._pressed_button:
                self._pressed_button = None
                return

            self.Refresh()
            self.Update()

            if self._pressed_button.cur_state & AUI_BUTTON_STATE_DISABLED == 0:

                evt = AuiNotebookEvent(wxEVT_COMMAND_AUINOTEBOOK_BUTTON, self.GetId())
                evt.SetSelection(self.GetIdxFromWindow(self._click_tab))
                evt.SetInt(self._pressed_button.id)
                evt.SetEventObject(self)
                eventHandler = self.GetEventHandler()

                if eventHandler is not None:
                    eventHandler.ProcessEvent(evt)

            self._pressed_button = None

        self._click_pt = wx.Point(-1, -1)
        self._is_dragging = False
        self._click_tab = None


    def OnMiddleUp(self, event):
        """
        Handles the ``wx.EVT_MIDDLE_UP`` event for :class:`AuiTabCtrl`.

        :param `event`: a :class:`MouseEvent` event to be processed.
        """

        eventHandler = self.GetEventHandler()
        if not isinstance(eventHandler, AuiTabCtrl):
            event.Skip()
            return

        x, y = event.GetX(), event.GetY()
        wnd = self.TabHitTest(x, y)

        if wnd:
            e = AuiNotebookEvent(wxEVT_COMMAND_AUINOTEBOOK_TAB_MIDDLE_UP, self.GetId())
            e.SetEventObject(self)
            e.Page = wnd
            e.SetSelection(self.GetIdxFromWindow(wnd))
            self.GetEventHandler().ProcessEvent(e)
        elif not self.ButtonHitTest(x, y):
            e = AuiNotebookEvent(wxEVT_COMMAND_AUINOTEBOOK_BG_MIDDLE_UP, self.GetId())
            e.SetEventObject(self)
            self.GetEventHandler().ProcessEvent(e)


    def OnMiddleDown(self, event):
        """
        Handles the ``wx.EVT_MIDDLE_DOWN`` event for :class:`AuiTabCtrl`.

        :param `event`: a :class:`MouseEvent` event to be processed.
        """

        eventHandler = self.GetEventHandler()
        if not isinstance(eventHandler, AuiTabCtrl):
            event.Skip()
            return

        x, y = event.GetX(), event.GetY()
        wnd = self.TabHitTest(x, y)

        if wnd:
            e = AuiNotebookEvent(wxEVT_COMMAND_AUINOTEBOOK_TAB_MIDDLE_DOWN, self.GetId())
            e.SetEventObject(self)
            e.Page = wnd
            e.SetSelection(self.GetIdxFromWindow(wnd))
            self.GetEventHandler().ProcessEvent(e)
        elif not self.ButtonHitTest(x, y):
            e = AuiNotebookEvent(wxEVT_COMMAND_AUINOTEBOOK_BG_MIDDLE_DOWN, self.GetId())
            e.SetEventObject(self)
            self.GetEventHandler().ProcessEvent(e)


    def OnRightUp(self, event):
        """
        Handles the ``wx.EVT_RIGHT_UP`` event for :class:`AuiTabCtrl`.

        :param `event`: a :class:`MouseEvent` event to be processed.
        """

        x, y = event.GetX(), event.GetY()
        wnd = self.TabHitTest(x, y)

        if wnd:
            e = AuiNotebookEvent(wxEVT_COMMAND_AUINOTEBOOK_TAB_RIGHT_UP, self.GetId())
            e.SetEventObject(self)
            e.Selection = self.GetIdxFromWindow(wnd)
            e.Page = wnd
            self.GetEventHandler().ProcessEvent(e)
        elif not self.ButtonHitTest(x, y):
            e = AuiNotebookEvent(wxEVT_COMMAND_AUINOTEBOOK_BG_RIGHT_UP, self.GetId())
            e.SetEventObject(self)
            self.GetEventHandler().ProcessEvent(e)


    def OnRightDown(self, event):
        """
        Handles the ``wx.EVT_RIGHT_DOWN`` event for :class:`AuiTabCtrl`.

        :param `event`: a :class:`MouseEvent` event to be processed.
        """

        x, y = event.GetX(), event.GetY()
        wnd = self.TabHitTest(x, y)

        if wnd:
            e = AuiNotebookEvent(wxEVT_COMMAND_AUINOTEBOOK_TAB_RIGHT_DOWN, self.GetId())
            e.SetEventObject(self)
            e.SetSelection(self.GetIdxFromWindow(wnd))
            e.Page = wnd
            self.GetEventHandler().ProcessEvent(e)
        elif not self.ButtonHitTest(x, y):
            e = AuiNotebookEvent(wxEVT_COMMAND_AUINOTEBOOK_BG_RIGHT_DOWN, self.GetId())
            e.SetEventObject(self)
            self.GetEventHandler().ProcessEvent(e)


    def OnLeftDClick(self, event):
        """
        Handles the ``wx.EVT_LEFT_DCLICK`` event for :class:`AuiTabCtrl`.

        :param `event`: a :class:`MouseEvent` event to be processed.
        """

        x, y = event.GetX(), event.GetY()
        wnd = self.TabHitTest(x, y)

        if wnd:
            e = AuiNotebookEvent(wxEVT_COMMAND_AUINOTEBOOK_TAB_DCLICK, self.GetId())
            e.SetEventObject(self)
            e.SetSelection(self.GetIdxFromWindow(wnd))
            e.Page = wnd
            self.GetEventHandler().ProcessEvent(e)
        elif not self.ButtonHitTest(x, y):
            e = AuiNotebookEvent(wxEVT_COMMAND_AUINOTEBOOK_BG_DCLICK, self.GetId())
            e.SetEventObject(self)
            self.GetEventHandler().ProcessEvent(e)


    def OnMotion(self, event):
        """
        Handles the ``wx.EVT_MOTION`` event for :class:`AuiTabCtrl`.

        :param `event`: a :class:`MouseEvent` event to be processed.
        """

        pos = event.GetPosition()

        # check if the mouse is hovering above a button

        button = self.ButtonHitTest(pos.x, pos.y)
        wnd = self.TabHitTest(pos.x, pos.y)

        if wnd is not None:
            mouse_tab = self.GetIdxFromWindow(wnd)
            if not self._pages[mouse_tab].enabled:
                self._hover_button = None
                return

        if self._on_button:
            return

        if button:

            if self._hover_button and button != self._hover_button:
                self._hover_button.cur_state = AUI_BUTTON_STATE_NORMAL
                self._hover_button = None
                self.Refresh()
                self.Update()

            if button.cur_state != AUI_BUTTON_STATE_HOVER:
                button.cur_state = AUI_BUTTON_STATE_HOVER
                self.Refresh()
                self.Update()
                self._hover_button = button
                return

        else:

            if self._hover_button:
                self._hover_button.cur_state = AUI_BUTTON_STATE_NORMAL
                self._hover_button = None
                self.Refresh()
                self.Update()

        if not event.LeftIsDown() or self._click_pt == wx.Point(-1, -1):
            return

        if not self.HasCapture():
            return

        wnd = self.TabHitTest(pos.x, pos.y)

        if not self._is_dragging:

            drag_x_threshold = wx.SystemSettings.GetMetric(wx.SYS_DRAG_X)
            drag_y_threshold = wx.SystemSettings.GetMetric(wx.SYS_DRAG_Y)

            if abs(pos.x - self._click_pt.x) > drag_x_threshold or \
               abs(pos.y - self._click_pt.y) > drag_y_threshold:

                self._is_dragging = True

                if self._drag_image:
                    self._drag_image.EndDrag()
                    del self._drag_image
                    self._drag_image = None

                if self._agwFlags & AUI_NB_DRAW_DND_TAB:
                    # Create the custom draw image from the icons and the text of the item
                    mouse_tab = self.GetIdxFromWindow(wnd)
                    page = self._pages[mouse_tab]
                    tab_button = self._tab_close_buttons[mouse_tab]
                    self._drag_image = TabDragImage(self, page, tab_button.cur_state, self._art)

                    if self._agwFlags & AUI_NB_TAB_FLOAT:
                        self._drag_image.BeginDrag(wx.Point(0,0), self, fullScreen=True)
                    else:
                        self._drag_image.BeginDragBounded(wx.Point(0,0), self, self.GetParent())

                    # Capture the mouse cursor position offset relative to
                    # The tab image location
                    self._drag_img_offset = (pos[0] - page.rect.x,
                                             pos[1] - page.rect.y)

                    self._drag_image.Show()

        if not wnd:
            evt2 = AuiNotebookEvent(wxEVT_COMMAND_AUINOTEBOOK_BEGIN_DRAG, self.GetId())
            evt2.SetSelection(self.GetIdxFromWindow(self._click_tab))
            evt2.SetOldSelection(evt2.GetSelection())
            evt2.SetEventObject(self)
            self.GetEventHandler().ProcessEvent(evt2)
            if evt2.GetDispatched():
                return

        evt3 = AuiNotebookEvent(wxEVT_COMMAND_AUINOTEBOOK_DRAG_MOTION, self.GetId())
        evt3.SetSelection(self.GetIdxFromWindow(self._click_tab))
        evt3.SetOldSelection(evt3.GetSelection())
        evt3.SetEventObject(self)
        self.GetEventHandler().ProcessEvent(evt3)

        if self._drag_image:
            # Apply the drag images offset
            pos -= self._drag_img_offset
            self._drag_image.Move(pos)


    def OnLeaveWindow(self, event):
        """
        Handles the ``wx.EVT_LEAVE_WINDOW`` event for :class:`AuiTabCtrl`.

        :param `event`: a :class:`MouseEvent` event to be processed.
        """

        if self._hover_button:
            self._hover_button.cur_state = AUI_BUTTON_STATE_NORMAL
            self._hover_button = None
            self.Refresh()
            self.Update()


    def OnButton(self, event):
        """
        Handles the ``EVT_AUINOTEBOOK_BUTTON`` event for :class:`AuiTabCtrl`.

        :param `event`: a :class:`AuiNotebookEvent` event to be processed.
        """

        button = event.GetInt()

        if button == AUI_BUTTON_LEFT or button == AUI_BUTTON_RIGHT:
            if button == AUI_BUTTON_LEFT:
                if self.GetTabOffset() > 0:

                    self.SetTabOffset(self.GetTabOffset()-1)
                    self.Refresh()
                    self.Update()
            else:
                self.SetTabOffset(self.GetTabOffset()+1)
                self.Refresh()
                self.Update()

        elif button == AUI_BUTTON_WINDOWLIST:
            idx = self.GetArtProvider().ShowDropDown(self, self._pages, self.GetActivePage())

            if idx != -1:

                e = AuiNotebookEvent(wxEVT_COMMAND_AUINOTEBOOK_PAGE_CHANGING, self.GetId())
                e.SetSelection(idx)
                e.SetOldSelection(self.GetActivePage())
                e.SetEventObject(self)
                self.GetEventHandler().ProcessEvent(e)

        else:
            event.Skip()


    def OnSetFocus(self, event):
        """
        Handles the ``wx.EVT_SET_FOCUS`` event for :class:`AuiTabCtrl`.

        :param `event`: a :class:`FocusEvent` event to be processed.
        """

        self.Refresh()


    def OnKillFocus(self, event):
        """
        Handles the ``wx.EVT_KILL_FOCUS`` event for :class:`AuiTabCtrl`.

        :param `event`: a :class:`FocusEvent` event to be processed.
        """

        self.Refresh()


    def OnKeyDown(self, event):
        """
        Handles the ``wx.EVT_KEY_DOWN`` event for :class:`AuiTabCtrl`.

        :param `event`: a :class:`KeyEvent` event to be processed.
        """

        key = event.GetKeyCode()
        nb = self.GetParent()

        if key == wx.WXK_LEFT:
            nb.AdvanceSelection(False)
            self.SetFocus()

        elif key == wx.WXK_RIGHT:
            nb.AdvanceSelection(True)
            self.SetFocus()

        elif key == wx.WXK_HOME:
            newPage = 0
            nb.SetSelection(newPage)
            self.SetFocus()

        elif key == wx.WXK_END:
            newPage = nb.GetPageCount() - 1
            nb.SetSelection(newPage)
            self.SetFocus()

        elif key == wx.WXK_TAB:
            if not event.ControlDown():
                flags = 0
                if not event.ShiftDown(): flags |= wx.NavigationKeyEvent.IsForward
                if event.CmdDown():       flags |= wx.NavigationKeyEvent.WinChange
                self.Navigate(flags)
            else:

                if not nb or not isinstance(nb, AuiNotebook):
                    event.Skip()
                    return

                bForward = bWindowChange = 0
                if not event.ShiftDown(): bForward |= wx.NavigationKeyEvent.IsForward
                if event.CmdDown():       bWindowChange |= wx.NavigationKeyEvent.WinChange

                keyEvent = wx.NavigationKeyEvent()
                keyEvent.SetDirection(bForward)
                keyEvent.SetWindowChange(bWindowChange)
                keyEvent.SetFromTab(True)
                keyEvent.SetEventObject(nb)

                if not nb.GetEventHandler().ProcessEvent(keyEvent):

                    # Not processed? Do an explicit tab into the page.
                    win = self.GetWindowFromIdx(self.GetActivePage())
                    if win:
                        win.SetFocus()

                self.SetFocus()

                return

        else:
            event.Skip()


    def OnKeyDown2(self, event):
        """
        Handles the ``wx.EVT_KEY_DOWN`` event for :class:`AuiTabCtrl`.

        :param `event`: a :class:`KeyEvent` event to be processed.

        .. deprecated:: 0.6
           This implementation is now deprecated. Refer to :meth:`OnKeyDown` for the correct one.
        """

        if self.GetActivePage() == -1:
            event.Skip()
            return

        # We can't leave tab processing to the system on Windows, tabs and keys
        # get eaten by the system and not processed properly if we specify both
        # wxTAB_TRAVERSAL and wxWANTS_CHARS. And if we specify just wxTAB_TRAVERSAL,
        # we don't key arrow key events.

        key = event.GetKeyCode()

        if key == wx.WXK_NUMPAD_PAGEUP:
            key = wx.WXK_PAGEUP
        if key == wx.WXK_NUMPAD_PAGEDOWN:
            key = wx.WXK_PAGEDOWN
        if key == wx.WXK_NUMPAD_HOME:
            key = wx.WXK_HOME
        if key == wx.WXK_NUMPAD_END:
            key = wx.WXK_END
        if key == wx.WXK_NUMPAD_LEFT:
            key = wx.WXK_LEFT
        if key == wx.WXK_NUMPAD_RIGHT:
            key = wx.WXK_RIGHT

        if key == wx.WXK_TAB or key == wx.WXK_PAGEUP or key == wx.WXK_PAGEDOWN:

            bCtrlDown = event.ControlDown()
            bShiftDown = event.ShiftDown()

            bForward = (key == wx.WXK_TAB and not bShiftDown) or (key == wx.WXK_PAGEDOWN)
            bWindowChange = (key == wx.WXK_PAGEUP) or (key == wx.WXK_PAGEDOWN) or bCtrlDown
            bFromTab = (key == wx.WXK_TAB)

            nb = self.GetParent()
            if not nb or not isinstance(nb, AuiNotebook):
                event.Skip()
                return

            keyEvent = wx.NavigationKeyEvent()
            keyEvent.SetDirection(bForward)
            keyEvent.SetWindowChange(bWindowChange)
            keyEvent.SetFromTab(bFromTab)
            keyEvent.SetEventObject(nb)

            if not nb.GetEventHandler().ProcessEvent(keyEvent):

                # Not processed? Do an explicit tab into the page.
                win = self.GetWindowFromIdx(self.GetActivePage())
                if win:
                    win.SetFocus()

            return

        if len(self._pages) < 2:
            event.Skip()
            return

        newPage = -1

        if self.GetLayoutDirection() == wx.Layout_RightToLeft:
            forwardKey = wx.WXK_LEFT
            backwardKey = wx.WXK_RIGHT
        else:
            forwardKey = wx.WXK_RIGHT
            backwardKey = wx.WXK_LEFT

        if key == forwardKey:
            if self.GetActivePage() == -1:
                newPage = 0
            elif self.GetActivePage() < len(self._pages) - 1:
                newPage = self.GetActivePage() + 1

        elif key == backwardKey:
            if self.GetActivePage() == -1:
                newPage = len(self._pages) - 1
            elif self.GetActivePage() > 0:
                newPage = self.GetActivePage() - 1

        elif key == wx.WXK_HOME:
            newPage = 0

        elif key == wx.WXK_END:
            newPage = len(self._pages) - 1

        else:
            event.Skip()

        if newPage != -1:
            e = AuiNotebookEvent(wxEVT_COMMAND_AUINOTEBOOK_PAGE_CHANGING, self.GetId())
            e.SetSelection(newPage)
            e.SetOldSelection(newPage)
            e.SetEventObject(self)
            self.GetEventHandler().ProcessEvent(e)

        else:
            event.Skip()


# ----------------------------------------------------------------------

class TabFrame(wx.PyWindow):
    """
    TabFrame is an interesting case. It's important that all child pages
    of the multi-notebook control are all actually children of that control
    (and not grandchildren). TabFrame facilitates this. There is one
    instance of TabFrame for each tab control inside the multi-notebook.

    It's important to know that TabFrame is not a real window, but it merely
    used to capture the dimensions/positioning of the internal tab control and
    it's managed page windows.
    """

    def __init__(self, parent):
        """
        Default class constructor.
        Used internally, do not call it in your code!
        """

        pre = wx.PrePyWindow()

        self._tabs = None
        self._rect = wx.Rect(0, 0, 200, 200)
        self._tab_ctrl_height = 20
        self._tab_rect = wx.Rect()
        self._parent = parent

        self.PostCreate(pre)


    def SetTabCtrlHeight(self, h):
        """
        Sets the tab control height.

        :param integer `h`: the tab area height.
        """

        self._tab_ctrl_height = h


    def DoSetSize(self, x, y, width, height, flags=wx.SIZE_AUTO):
        """
        Sets the position and size of the window in pixels. The `flags`
        parameter indicates the interpretation of the other params if they are
        equal to -1.

        :param integer `x`: the window `x` position;
        :param integer `y`: the window `y` position;
        :param integer `width`: the window width;
        :param integer `height`: the window height;
        :param integer `flags`: may have one of this bit set:

         ===================================  ======================================
         Size Flags                           Description
         ===================================  ======================================
         ``wx.SIZE_AUTO``                     A -1 indicates that a class-specific default should be used.
         ``wx.SIZE_AUTO_WIDTH``               A -1 indicates that a class-specific default should be used for the width.
         ``wx.SIZE_AUTO_HEIGHT``              A -1 indicates that a class-specific default should be used for the height.
         ``wx.SIZE_USE_EXISTING``             Existing dimensions should be used if -1 values are supplied.
         ``wx.SIZE_ALLOW_MINUS_ONE``          Allow dimensions of -1 and less to be interpreted as real dimensions, not default values.
         ``wx.SIZE_FORCE``                    Normally, if the position and the size of the window are already the same as the
                                              parameters of this function, nothing is done. but with this flag a window resize
                                              may be forced even in this case (supported in wx 2.6.2 and later and only implemented
                                              for MSW and ignored elsewhere currently)
         ===================================  ======================================

        :note: Overridden from :class:`PyControl`.
        """

        self._rect = wx.Rect(x, y, max(1, width), max(1, height))
        self.DoSizing()


    def DoGetSize(self):
        """
        Returns the window size.

        :note: Overridden from :class:`PyControl`.
        """

        return self._rect.width, self._rect.height


    def DoGetClientSize(self):
        """
        Returns the window client size.

        :note: Overridden from :class:`PyControl`.
        """

        return self._rect.width, self._rect.height


    def Show(self, show=True):
        """
        Shows/hides the window.

        :param bool `show`: ``True`` to show the window, ``False`` otherwise.

        :note:

         Overridden from :class:`PyControl`, this method always returns ``False`` as
         :class:`TabFrame` should never be phisically shown on screen.
        """

        return False


    def DoSizing(self):
        """ Does the actual sizing of the tab control. """

        if not self._tabs:
            return

        hideOnSingle = ((self._tabs.GetAGWFlags() & AUI_NB_HIDE_ON_SINGLE_TAB) and \
                        self._tabs.GetPageCount() <= 1)

        if not hideOnSingle and not self._parent._hide_tabs:
            tab_height = self._tab_ctrl_height

            self._tab_rect = wx.Rect(self._rect.x, self._rect.y, self._rect.width, self._tab_ctrl_height)

            if self._tabs.GetAGWFlags() & AUI_NB_BOTTOM:
                self._tab_rect = wx.Rect(self._rect.x, self._rect.y + self._rect.height - tab_height,
                                         self._rect.width, tab_height)
                self._tabs.SetDimensions(self._rect.x, self._rect.y + self._rect.height - tab_height,
                                         self._rect.width, tab_height)
                self._tabs.SetTabRect(wx.Rect(0, 0, self._rect.width, tab_height))

            else:

                self._tab_rect = wx.Rect(self._rect.x, self._rect.y, self._rect.width, tab_height)
                self._tabs.SetDimensions(self._rect.x, self._rect.y, self._rect.width, tab_height)
                self._tabs.SetTabRect(wx.Rect(0, 0, self._rect.width, tab_height))

            # TODO: elif (GetAGWFlags() & AUI_NB_LEFT)
            # TODO: elif (GetAGWFlags() & AUI_NB_RIGHT)

            self._tabs.Refresh()
            self._tabs.Update()

        else:

            tab_height = 0
            self._tabs.SetDimensions(self._rect.x, self._rect.y, self._rect.width, tab_height)
            self._tabs.SetTabRect(wx.Rect(0, 0, self._rect.width, tab_height))

        pages = self._tabs.GetPages()

        for page in pages:

            height = self._rect.height - tab_height

            if height < 0:
                # avoid passing negative height to wx.Window.SetSize(), this
                # results in assert failures/GTK+ warnings
                height = 0

            if self._tabs.GetAGWFlags() & AUI_NB_BOTTOM:
                page.window.SetDimensions(self._rect.x, self._rect.y, self._rect.width, height)

            else:
                page.window.SetDimensions(self._rect.x, self._rect.y + tab_height,
                                          self._rect.width, height)

            # TODO: elif (GetAGWFlags() & AUI_NB_LEFT)
            # TODO: elif (GetAGWFlags() & AUI_NB_RIGHT)

            if repr(page.window.__class__).find("AuiMDIChildFrame") >= 0:
                page.window.ApplyMDIChildFrameRect()


    def Update(self):
        """
        Calling this method immediately repaints the invalidated area of the window
        and all of its children recursively while this would usually only happen when
        the flow of control returns to the event loop.

        :note: Notice that this function doesn't invalidate any area of the window so
         nothing happens if nothing has been invalidated (i.e. marked as requiring a redraw).
         Use `Refresh` first if you want to immediately redraw the window unconditionally.

        :note: Overridden from :class:`PyControl`.
        """

        # does nothing
        pass


# ----------------------------------------------------------------------
# -- AuiNotebook class implementation --

class AuiNotebook(wx.PyPanel):
    """
    AuiNotebook is a notebook control which implements many features common in applications with dockable panes.
    Specifically, AuiNotebook implements functionality which allows the user to rearrange tab
    order via drag-and-drop, split the tab window into many different splitter configurations, and toggle
    through different themes to customize the control's look and feel.

    An effort has been made to try to maintain an API as similar to that of :class:`Notebook`.

    The default theme that is used is :class:`~lib.agw.aui.tabart.AuiDefaultTabArt`, which provides a modern, glossy
    look and feel. The theme can be changed by calling :meth:`AuiNotebook.SetArtProvider`.
    """

    def __init__(self, parent, id=wx.ID_ANY, pos=wx.DefaultPosition, size=wx.DefaultSize,
                 style=0, agwStyle=AUI_NB_DEFAULT_STYLE, name="AuiNotebook"):
        """
        Default class constructor.

        :param Window `parent`: the :class:`AuiNotebook` parent;
        :param integer `id`: an identifier for the control: a value of -1 is taken to mean a default;
        :param Point `pos`: the control position. A value of (-1, -1) indicates a default position,
         chosen by either the windowing system or wxPython, depending on platform;
        :param Size `size`: the control size. A value of (-1, -1) indicates a default size,
         chosen by either the windowing system or wxPython, depending on platform;
        :param integer `style`: the underlying :class:`PyPanel` window style;
        :param integer `agwStyle`: the AGW-specific window style. This can be a combination of the following bits:

         ==================================== ==================================
         Flag name                            Description
         ==================================== ==================================
         ``AUI_NB_TOP``                       With this style, tabs are drawn along the top of the notebook
         ``AUI_NB_LEFT``                      With this style, tabs are drawn along the left of the notebook. Not implemented yet.
         ``AUI_NB_RIGHT``                     With this style, tabs are drawn along the right of the notebook. Not implemented yet.
         ``AUI_NB_BOTTOM``                    With this style, tabs are drawn along the bottom of the notebook
         ``AUI_NB_TAB_SPLIT``                 Allows the tab control to be split by dragging a tab
         ``AUI_NB_TAB_MOVE``                  Allows a tab to be moved horizontally by dragging
         ``AUI_NB_TAB_EXTERNAL_MOVE``         Allows a tab to be moved to another tab control
         ``AUI_NB_TAB_FIXED_WIDTH``           With this style, all tabs have the same width
         ``AUI_NB_SCROLL_BUTTONS``            With this style, left and right scroll buttons are displayed
         ``AUI_NB_WINDOWLIST_BUTTON``         With this style, a drop-down list of windows is available
         ``AUI_NB_CLOSE_BUTTON``              With this style, a close button is available on the tab bar
         ``AUI_NB_CLOSE_ON_ACTIVE_TAB``       With this style, a close button is available on the active tab
         ``AUI_NB_CLOSE_ON_ALL_TABS``         With this style, a close button is available on all tabs
         ``AUI_NB_MIDDLE_CLICK_CLOSE``        Allows to close :class:`AuiNotebook` tabs by mouse middle button click
         ``AUI_NB_SUB_NOTEBOOK``              This style is used by :class:`~lib.agw.aui.framemanager.AuiManager` to create automatic AuiNotebooks
         ``AUI_NB_HIDE_ON_SINGLE_TAB``        Hides the tab window if only one tab is present
         ``AUI_NB_SMART_TABS``                Use Smart Tabbing, like ``Alt`` + ``Tab`` on Windows
         ``AUI_NB_USE_IMAGES_DROPDOWN``       Uses images on dropdown window list menu instead of check items
         ``AUI_NB_CLOSE_ON_TAB_LEFT``         Draws the tab close button on the left instead of on the right (a la Camino browser)
         ``AUI_NB_TAB_FLOAT``                 Allows the floating of single tabs. Known limitation: when the notebook is more or less full screen,
                                              tabs cannot be dragged far enough outside of the notebook to become floating pages
         ``AUI_NB_DRAW_DND_TAB``              Draws an image representation of a tab while dragging (on by default)
         ``AUI_NB_ORDER_BY_ACCESS``           Tab navigation order by last access time for the tabs
         ``AUI_NB_NO_TAB_FOCUS``              Don't draw tab focus rectangle
         ==================================== ==================================

         Default value for `agwStyle` is:
         ``AUI_NB_DEFAULT_STYLE`` = ``AUI_NB_TOP`` | ``AUI_NB_TAB_SPLIT`` | ``AUI_NB_TAB_MOVE`` | ``AUI_NB_SCROLL_BUTTONS`` | ``AUI_NB_CLOSE_ON_ACTIVE_TAB`` | ``AUI_NB_MIDDLE_CLICK_CLOSE`` | ``AUI_NB_DRAW_DND_TAB``

        :param string `name`: the window name.
        """

        self._curpage = -1
        self._tab_id_counter = AuiBaseTabCtrlId
        self._dummy_wnd = None
        self._hide_tabs = False
        self._sash_dclick_unsplit = False
        self._tab_ctrl_height = 20
        self._requested_bmp_size = wx.Size(-1, -1)
        self._requested_tabctrl_height = -1
        self._textCtrl = None
        self._tabBounds = (-1, -1)
        self._click_tab = None

        wx.PyPanel.__init__(self, parent, id, pos, size, style|wx.BORDER_NONE|wx.TAB_TRAVERSAL, name=name)
        self._mgr = framemanager.AuiManager()
        self._tabs = AuiTabContainer(self)

        self.InitNotebook(agwStyle)

    NavigatorProps = property(lambda self: self._navProps)


    def Destroy(self):
        """
        Destroys the window safely.

        Use this function instead of the ``del`` operator, since different window
        classes can be destroyed differently. Frames and dialogs are not destroyed
        immediately when this function is called -- they are added to a list of
        windows to be deleted on idle time, when all the window's events have been
        processed. This prevents problems with events being sent to non-existent windows.

        :return: ``True`` if the window has either been successfully deleted, or
         it has been added to the list of windows pending real deletion.

        .. note::

           This method has been added to safely un-initialize the underlying
           :class:`~lib.agw.aui.framemanager.AuiManager` which manages the :class:`AuiNotebook`
           layout (i.e., tab split, re-ordering, tab floating etc...).
         
        """
        
        self._mgr.UnInit()
        return wx.PyPanel.Destroy(self)
        

    def __getitem__(self, index):
        """
        More Pythonic way to get a specific page, also useful for iterating
        over all pages.

        :param integer `index`: the page index.

        .. note::

           This method makes easier to iterate over all the pages in the notebook, i.e. you can
           safely do::

               for page in notebook:
                   DoSomething(page)


        """
        
        if index < self.GetPageCount():
            return self.GetPage(index)
        else:
            raise IndexError("Invalid page index")


    def GetTabContainer(self):
        """ Returns the instance of :class:`AuiTabContainer`. """

        return self._tabs


    def InitNotebook(self, agwStyle):
        """
        Contains common initialization code called by all constructors.

        :param integer `agwStyle`: the notebook style.

        :see: :meth:`~AuiNotebook.__init__` for a list of available `agwStyle` bits.
        """

        self._agwFlags = agwStyle

        self._popupWin = None
        self._imageList = None
        self._navProps = TabNavigatorProps()
        self._last_drag_x = 0

        self._normal_font = wx.SystemSettings.GetFont(wx.SYS_DEFAULT_GUI_FONT)
        self._selected_font = wx.SystemSettings.GetFont(wx.SYS_DEFAULT_GUI_FONT)
        self._selected_font.SetWeight(wx.BOLD)

        self.SetArtProvider(TA.AuiDefaultTabArt())

        self._dummy_wnd = wx.Window(self, wx.ID_ANY, wx.Point(0, 0), wx.Size(0, 0))
        self._dummy_wnd.SetSize((200, 200))
        self._dummy_wnd.Show(False)

        self._mgr.SetManagedWindow(self)
        self._mgr.SetAGWFlags(AUI_MGR_DEFAULT)
        self._mgr.SetDockSizeConstraint(1.0, 1.0) # no dock size constraint

        self._mgr.AddPane(self._dummy_wnd, framemanager.AuiPaneInfo().Name("dummy").Bottom().CaptionVisible(False).Show(False))
        self._mgr.Update()

        self.Bind(wx.EVT_SIZE, self.OnSize)
        self.Bind(wx.EVT_CHILD_FOCUS, self.OnChildFocusNotebook)
        self.Bind(EVT_AUINOTEBOOK_PAGE_CHANGING, self.OnTabClicked,
                  id=AuiBaseTabCtrlId, id2=AuiBaseTabCtrlId+500)
        self.Bind(EVT_AUINOTEBOOK_BEGIN_DRAG, self.OnTabBeginDrag,
                  id=AuiBaseTabCtrlId, id2=AuiBaseTabCtrlId+500)
        self.Bind(EVT_AUINOTEBOOK_END_DRAG, self.OnTabEndDrag,
                  id=AuiBaseTabCtrlId, id2=AuiBaseTabCtrlId+500)
        self.Bind(EVT_AUINOTEBOOK_DRAG_MOTION, self.OnTabDragMotion,
                  id=AuiBaseTabCtrlId, id2=AuiBaseTabCtrlId+500)
        self.Bind(EVT_AUINOTEBOOK_CANCEL_DRAG, self.OnTabCancelDrag,
                  id=AuiBaseTabCtrlId, id2=AuiBaseTabCtrlId+500)
        self.Bind(EVT_AUINOTEBOOK_BUTTON, self.OnTabButton,
                  id=AuiBaseTabCtrlId, id2=AuiBaseTabCtrlId+500)
        self.Bind(EVT_AUINOTEBOOK_TAB_MIDDLE_DOWN, self.OnTabMiddleDown,
                  id=AuiBaseTabCtrlId, id2=AuiBaseTabCtrlId+500)
        self.Bind(EVT_AUINOTEBOOK_TAB_MIDDLE_UP, self.OnTabMiddleUp,
                  id=AuiBaseTabCtrlId, id2=AuiBaseTabCtrlId+500)
        self.Bind(EVT_AUINOTEBOOK_TAB_RIGHT_DOWN, self.OnTabRightDown,
                  id=AuiBaseTabCtrlId, id2=AuiBaseTabCtrlId+500)
        self.Bind(EVT_AUINOTEBOOK_TAB_RIGHT_UP, self.OnTabRightUp,
                  id=AuiBaseTabCtrlId, id2=AuiBaseTabCtrlId+500)
        self.Bind(EVT_AUINOTEBOOK_BG_DCLICK, self.OnTabBgDClick,
                  id=AuiBaseTabCtrlId, id2=AuiBaseTabCtrlId+500)
        self.Bind(EVT_AUINOTEBOOK_TAB_DCLICK, self.OnTabDClick,
                  id=AuiBaseTabCtrlId, id2=AuiBaseTabCtrlId+500)

        self.Bind(wx.EVT_NAVIGATION_KEY, self.OnNavigationKeyNotebook)


    def SetArtProvider(self, art):
        """
        Sets the art provider to be used by the notebook.

        :param `art`: an art provider.
        """

        self._tabs.SetArtProvider(art)
        self.UpdateTabCtrlHeight(force=True)


    def SavePerspective(self):
        """
        Saves the entire user interface layout into an encoded string, which can then
        be stored by the application (probably using :class:`Config`). When a perspective
        is restored using :meth:`LoadPerspective`, the entire user interface will return
        to the state it was when the perspective was saved.
        """

        # Build list of panes/tabs
        tabs = ""
        all_panes = self._mgr.GetAllPanes()

        for pane in all_panes:

            if pane.name == "dummy":
                continue

            tabframe = pane.window

            if tabs:
                tabs += "|"

            tabs += pane.name + "="

            # add tab id's
            page_count = tabframe._tabs.GetPageCount()

            for p in xrange(page_count):

                page = tabframe._tabs.GetPage(p)
                page_idx = self._tabs.GetIdxFromWindow(page.window)

                if p:
                    tabs += ","

                if p == tabframe._tabs.GetActivePage():
                    tabs += "+"
                elif page_idx == self._curpage:
                    tabs += "*"

                tabs += "%u"%page_idx

        tabs += "@"

        # Add frame perspective
        tabs += self._mgr.SavePerspective()

        return tabs


    def LoadPerspective(self, layout):
        """
        Loads a layout which was saved with :meth:`SavePerspective`.

        :param string `layout`: a string which contains a saved :class:`AuiNotebook` layout.
        """

        # Remove all tab ctrls (but still keep them in main index)
        tab_count = self._tabs.GetPageCount()
        for i in xrange(tab_count):
            wnd = self._tabs.GetWindowFromIdx(i)

            # find out which onscreen tab ctrl owns this tab
            ctrl, ctrl_idx = self.FindTab(wnd)
            if not ctrl:
                return False

            # remove the tab from ctrl
            if not ctrl.RemovePage(wnd):
                return False

        self.RemoveEmptyTabFrames()

        sel_page = 0
        tabs = layout[0:layout.index("@")]
        to_break1 = False

        while 1:

            if "|" not in tabs:
                to_break1 = True
                tab_part = tabs
            else:
                tab_part = tabs[0:tabs.index('|')]

            if "=" not in tab_part:
                # No pages in this perspective...
                return False

            # Get pane name
            pane_name = tab_part[0:tab_part.index("=")]

            # create a new tab frame
            new_tabs = TabFrame(self)
            self._tab_id_counter += 1
            new_tabs._tabs = AuiTabCtrl(self, self._tab_id_counter)
            new_tabs._tabs.SetArtProvider(self._tabs.GetArtProvider().Clone())
            new_tabs.SetTabCtrlHeight(self._tab_ctrl_height)
            new_tabs._tabs.SetAGWFlags(self._agwFlags)
            dest_tabs = new_tabs._tabs

            # create a pane info structure with the information
            # about where the pane should be added
            pane_info = framemanager.AuiPaneInfo().Name(pane_name).Bottom().CaptionVisible(False)
            self._mgr.AddPane(new_tabs, pane_info)

            # Get list of tab id's and move them to pane
            tab_list = tab_part[tab_part.index("=")+1:]
            to_break2, active_found = False, False

            while 1:
                if "," not in tab_list:
                    to_break2 = True
                    tab = tab_list
                else:
                    tab = tab_list[0:tab_list.index(",")]
                    tab_list = tab_list[tab_list.index(",")+1:]

                # Check if this page has an 'active' marker
                c = tab[0]
                if c in ['+', '*']:
                    tab = tab[1:]

                tab_idx = int(tab)
                if tab_idx >= self.GetPageCount():
                    to_break1 = True
                    break

                # Move tab to pane
                page = self._tabs.GetPage(tab_idx)
                newpage_idx = dest_tabs.GetPageCount()
                dest_tabs.InsertPage(page.window, page, newpage_idx)

                if c == '+':
                    dest_tabs.SetActivePage(newpage_idx)
                    active_found = True
                elif c == '*':
                    sel_page = tab_idx

                if to_break2:
                    break

            if not active_found:
                dest_tabs.SetActivePage(0)

            new_tabs.DoSizing()
            dest_tabs.DoShowHide()
            dest_tabs.Refresh()

            if to_break1:
                break

            tabs = tabs[tabs.index('|')+1:]

        # Load the frame perspective
        frames = layout[layout.index('@')+1:]
        self._mgr.LoadPerspective(frames)

        # Force refresh of selection
        self._curpage = -1
        self.SetSelection(sel_page)

        return True


    def SetTabCtrlHeight(self, height):
        """
        Sets the tab height.

        By default, the tab control height is calculated by measuring the text
        height and bitmap sizes on the tab captions.

        Calling this method will override that calculation and set the tab control
        to the specified height parameter. A call to this method will override
        any call to :meth:`SetUniformBitmapSize`. Specifying -1 as the height will
        return the control to its default auto-sizing behaviour.

        :param integer `height`: the tab control area height.
        """

        self._requested_tabctrl_height = height

        # if window is already initialized, recalculate the tab height
        if self._dummy_wnd:
            self.UpdateTabCtrlHeight()


    def SetUniformBitmapSize(self, size):
        """
        Ensures that all tabs will have the same height, even if some tabs don't have bitmaps.
        Passing ``wx.DefaultSize`` to this method will instruct the control to use dynamic tab
        height, which is the default behaviour. Under the default behaviour, when a tab with a
        large bitmap is added, the tab control's height will automatically increase to accommodate
        the larger bitmap.

        :param Size `size`: the tab bitmap size.
        """

        self._requested_bmp_size = wx.Size(*size)

        # if window is already initialized, recalculate the tab height
        if self._dummy_wnd:
            self.UpdateTabCtrlHeight()


    def UpdateTabCtrlHeight(self, force=False):
        """
        :meth:`UpdateTabCtrlHeight` does the actual tab resizing. It's meant
        to be used interally.

        :param bool `force`: ``True`` to force the tab art to repaint.
        """

        # get the tab ctrl height we will use
        height = self.CalculateTabCtrlHeight()

        # if the tab control height needs to change, update
        # all of our tab controls with the new height
        if self._tab_ctrl_height != height or force:
            art = self._tabs.GetArtProvider()

            self._tab_ctrl_height = height

            all_panes = self._mgr.GetAllPanes()
            for pane in all_panes:

                if pane.name == "dummy":
                    continue

                tab_frame = pane.window
                tabctrl = tab_frame._tabs
                tab_frame.SetTabCtrlHeight(self._tab_ctrl_height)
                tabctrl.SetArtProvider(art.Clone())
                tab_frame.DoSizing()


    def UpdateHintWindowSize(self):
        """ Updates the :class:`~lib.agw.aui.framemanager.AuiManager` hint window size. """

        size = self.CalculateNewSplitSize()

        # the placeholder hint window should be set to this size
        info = self._mgr.GetPane("dummy")

        if info.IsOk():
            info.MinSize(size)
            info.BestSize(size)
            self._dummy_wnd.SetSize(size)


    def CalculateNewSplitSize(self):
        """ Calculates the size of the new split. """

        # count number of tab controls
        tab_ctrl_count = 0
        all_panes = self._mgr.GetAllPanes()

        for pane in all_panes:
            if pane.name == "dummy":
                continue

            tab_ctrl_count += 1

        # if there is only one tab control, the first split
        # should happen around the middle
        if tab_ctrl_count < 2:
            new_split_size = self.GetClientSize()
            new_split_size.x /= 2
            new_split_size.y /= 2

        else:

            # this is in place of a more complicated calculation
            # that needs to be implemented
            new_split_size = wx.Size(180, 180)

        return new_split_size


    def CalculateTabCtrlHeight(self):
        """ Calculates the tab control area height. """

        # if a fixed tab ctrl height is specified,
        # just return that instead of calculating a
        # tab height
        if self._requested_tabctrl_height != -1:
            return self._requested_tabctrl_height

        # find out new best tab height
        art = self._tabs.GetArtProvider()

        return art.GetBestTabCtrlSize(self, self._tabs.GetPages(), self._requested_bmp_size)


    def GetArtProvider(self):
        """ Returns the associated art provider. """

        return self._tabs.GetArtProvider()


    def SetAGWWindowStyleFlag(self, agwStyle):
        """
        Sets the AGW-specific style of the window.

        :param integer `agwStyle`: the new window style. This can be a combination of the following bits:

         ==================================== ==================================
         Flag name                            Description
         ==================================== ==================================
         ``AUI_NB_TOP``                       With this style, tabs are drawn along the top of the notebook
         ``AUI_NB_LEFT``                      With this style, tabs are drawn along the left of the notebook. Not implemented yet.
         ``AUI_NB_RIGHT``                     With this style, tabs are drawn along the right of the notebook. Not implemented yet.
         ``AUI_NB_BOTTOM``                    With this style, tabs are drawn along the bottom of the notebook
         ``AUI_NB_TAB_SPLIT``                 Allows the tab control to be split by dragging a tab
         ``AUI_NB_TAB_MOVE``                  Allows a tab to be moved horizontally by dragging
         ``AUI_NB_TAB_EXTERNAL_MOVE``         Allows a tab to be moved to another tab control
         ``AUI_NB_TAB_FIXED_WIDTH``           With this style, all tabs have the same width
         ``AUI_NB_SCROLL_BUTTONS``            With this style, left and right scroll buttons are displayed
         ``AUI_NB_WINDOWLIST_BUTTON``         With this style, a drop-down list of windows is available
         ``AUI_NB_CLOSE_BUTTON``              With this style, a close button is available on the tab bar
         ``AUI_NB_CLOSE_ON_ACTIVE_TAB``       With this style, a close button is available on the active tab
         ``AUI_NB_CLOSE_ON_ALL_TABS``         With this style, a close button is available on all tabs
         ``AUI_NB_MIDDLE_CLICK_CLOSE``        Allows to close :class:`AuiNotebook` tabs by mouse middle button click
         ``AUI_NB_SUB_NOTEBOOK``              This style is used by :class:`~lib.agw.aui.framemanager.AuiManager` to create automatic AuiNotebooks
         ``AUI_NB_HIDE_ON_SINGLE_TAB``        Hides the tab window if only one tab is present
         ``AUI_NB_SMART_TABS``                Use Smart Tabbing, like ``Alt`` + ``Tab`` on Windows
         ``AUI_NB_USE_IMAGES_DROPDOWN``       Uses images on dropdown window list menu instead of check items
         ``AUI_NB_CLOSE_ON_TAB_LEFT``         Draws the tab close button on the left instead of on the right (a la Camino browser)
         ``AUI_NB_TAB_FLOAT``                 Allows the floating of single tabs. Known limitation: when the notebook is more or less full screen,
                                              tabs cannot be dragged far enough outside of the notebook to become floating pages
         ``AUI_NB_DRAW_DND_TAB``              Draws an image representation of a tab while dragging (on by default)
         ``AUI_NB_ORDER_BY_ACCESS``           Tab navigation order by last access time for the tabs
         ``AUI_NB_NO_TAB_FOCUS``              Don't draw tab focus rectangle
         ==================================== ==================================

        :note: Please note that some styles cannot be changed after the window
         creation and that `Refresh` might need to be be called after changing the
         others for the change to take place immediately.

        .. todo:: Implementation of flags ``AUI_NB_RIGHT`` and ``AUI_NB_LEFT``.
        """

        self._agwFlags = agwStyle

        # if the control is already initialized
        if self._mgr.GetManagedWindow() == self:

            # let all of the tab children know about the new style

            all_panes = self._mgr.GetAllPanes()
            for pane in all_panes:
                if pane.name == "dummy":
                    continue

                tabframe = pane.window
                tabctrl = tabframe._tabs
                tabctrl.SetAGWFlags(self._agwFlags)
                tabframe.DoSizing()
                tabctrl.Refresh()
                tabctrl.Update()


    def GetAGWWindowStyleFlag(self):
        """
        Returns the AGW-specific style of the window.

        :see: :meth:`SetAGWWindowStyleFlag` for a list of possible AGW-specific window styles.
        """

        return self._agwFlags


    def AddPage(self, page, caption, select=False, bitmap=wx.NullBitmap, disabled_bitmap=wx.NullBitmap, control=None):
        """
        Adds a page. If the `select` parameter is ``True``, calling this will generate a
        page change event.

        :param Window `page`: the page to be added;
        :param string `caption`: specifies the text for the new page;
        :param bool `select`: specifies whether the page should be selected;
        :param Bitmap `bitmap`: the bitmap to display in the enabled tab;
        :param Bitmap `disabled_bitmap`: the bitmap to display in the disabled tab;
        :param Window `control`: almost any :class:`Window` -derived instance to be located
         inside a tab.
        """

        return self.InsertPage(self.GetPageCount(), page, caption, select, bitmap, disabled_bitmap, control)


    def InsertPage(self, page_idx, page, caption, select=False, bitmap=wx.NullBitmap, disabled_bitmap=wx.NullBitmap,
                   control=None):
        """
        This is similar to :meth:`AddPage`, but allows the ability to specify the insert location.

        :param integer `page_idx`: specifies the position for the new page;
        :param Window `page`: the page to be added;
        :param string `caption`: specifies the text for the new page;
        :param bool `select`: specifies whether the page should be selected;
        :param Bitmap `bitmap`: the bitmap to display in the enabled tab;
        :param Bitmap `disabled_bitmap`: the bitmap to display in the disabled tab;
        :param Window `control`: almost any :class:`Window` -derived instance to be located
         inside a tab.
        """

        if not page:
            return False

        page.Reparent(self)
        info = AuiNotebookPage()
        info.window = page
        info.caption = caption
        info.bitmap = bitmap
        info.active = False
        info.control = control

        originalPaneMgr = framemanager.GetManager(page)
        if originalPaneMgr:
            originalPane = originalPaneMgr.GetPane(page)

            if originalPane:
                info.hasCloseButton = originalPane.HasCloseButton()

        if bitmap.IsOk() and not disabled_bitmap.IsOk():
            disabled_bitmap = MakeDisabledBitmap(bitmap)

        info.dis_bitmap = disabled_bitmap

        # if there are currently no tabs, the first added
        # tab must be active
        if self._tabs.GetPageCount() == 0:
            info.active = True

        self._tabs.InsertPage(page, info, page_idx)

        # if that was the first page added, even if
        # select is False, it must become the "current page"
        # (though no select events will be fired)
        if not select and self._tabs.GetPageCount() == 1:
            select = True

        active_tabctrl = self.GetActiveTabCtrl()
        if page_idx >= active_tabctrl.GetPageCount():
            active_tabctrl.AddPage(page, info)
        else:
            active_tabctrl.InsertPage(page, info, page_idx)

        force = False
        if control:
            force = True
            control.Reparent(active_tabctrl)
            control.Show()

        self.UpdateTabCtrlHeight(force=force)
        self.DoSizing()
        active_tabctrl.DoShowHide()

        # adjust selected index
        if self._curpage >= page_idx:
            self._curpage += 1

        if select:
            self.SetSelectionToWindow(page)

        return True


    def DeletePage(self, page_idx):
        """
        Deletes a page at the given index. Calling this method will generate a page
        change event.

        :param integer `page_idx`: the page index to be deleted.

        :note:

         :meth:`DeletePage` removes a tab from the multi-notebook, and destroys the window as well.

        :see: :meth:`RemovePage`
        """

        if page_idx >= self._tabs.GetPageCount():
            return False

        wnd = self._tabs.GetWindowFromIdx(page_idx)
        # hide the window in advance, as this will
        # prevent flicker
        wnd.Show(False)

        self.RemoveControlFromPage(page_idx)

        if not self.RemovePage(page_idx):
            return False

        wnd.Destroy()

        return True


    def RemovePage(self, page_idx):
        """
        Removes a page, without deleting the window pointer.

        :param integer `page_idx`: the page index to be removed.

        :note:

         :meth:`RemovePage` removes a tab from the multi-notebook, but does not destroy the window.

        :see: :meth:`DeletePage`
        """

        # save active window pointer
        active_wnd = None
        if self._curpage >= 0:
            active_wnd = self._tabs.GetWindowFromIdx(self._curpage)

        # save pointer of window being deleted
        wnd = self._tabs.GetWindowFromIdx(page_idx)
        new_active = None

        # make sure we found the page
        if not wnd:
            return False

        # find out which onscreen tab ctrl owns this tab
        ctrl, ctrl_idx = self.FindTab(wnd)
        if not ctrl:
            return False

        currentPage = ctrl.GetPage(ctrl_idx)
        is_curpage = (self._curpage == page_idx)
        is_active_in_split = currentPage.active

        # remove the tab from main catalog
        if not self._tabs.RemovePage(wnd):
            return False

        # remove the tab from the onscreen tab ctrl
        ctrl.RemovePage(wnd)

        if is_active_in_split:

            ctrl_new_page_count = ctrl.GetPageCount()

            if ctrl_idx >= ctrl_new_page_count:
                ctrl_idx = ctrl_new_page_count - 1

            if ctrl_idx >= 0 and ctrl_idx < ctrl.GetPageCount():

                ctrl_idx = self.FindNextActiveTab(ctrl_idx, ctrl)

                # set new page as active in the tab split
                ctrl.SetActivePage(ctrl_idx)

                # if the page deleted was the current page for the
                # entire tab control, then record the window
                # pointer of the new active page for activation
                if is_curpage:
                    new_active = ctrl.GetWindowFromIdx(ctrl_idx)

        else:

            # we are not deleting the active page, so keep it the same
            new_active = active_wnd

        if not new_active:

            # we haven't yet found a new page to active,
            # so select the next page from the main tab
            # catalogue

            if 0 <= page_idx < self._tabs.GetPageCount():
                new_active = self._tabs.GetPage(page_idx).window
            if not new_active and self._tabs.GetPageCount() > 0:
                new_active = self._tabs.GetPage(0).window

        self.RemoveEmptyTabFrames()

        # set new active pane
        if new_active:
            if not self.IsBeingDeleted():
                self._curpage = -1
                self.SetSelectionToWindow(new_active)
        else:
            self._curpage = -1
            self._tabs.SetNoneActive()

        return True


    def FindNextActiveTab(self, ctrl_idx, ctrl):
        """
        Finds the next active tab (used mainly when :class:`AuiNotebook` has inactive/disabled
        tabs in it).

        :param integer `ctrl_idx`: the index of the first (most obvious) tab to check for active status;
        :param `ctrl`: an instance of :class:`AuiTabCtrl`.
        """

        if self.GetEnabled(ctrl_idx):
            return ctrl_idx

        for indx in xrange(ctrl_idx, ctrl.GetPageCount()):
            if self.GetEnabled(indx):
                return indx

        for indx in xrange(ctrl_idx, -1, -1):
            if self.GetEnabled(indx):
                return indx

        return 0


    def HideAllTabs(self, hidden=True):
        """
        Hides all tabs on the :class:`AuiNotebook` control.

        :param bool `hidden`: if ``True`` hides all tabs.
        """

        self._hide_tabs = hidden


    def SetSashDClickUnsplit(self, unsplit=True):
        """
        Sets whether to unsplit a splitted :class:`AuiNotebook` when double-clicking on a sash.

        :param bool `unsplit`: ``True`` to unsplit on sash double-clicking, ``False`` otherwise.
        """

        self._sash_dclick_unsplit = unsplit


    def GetSashDClickUnsplit(self):
        """
        Returns whether a splitted :class:`AuiNotebook` can be unsplitted by double-clicking
        on the splitter sash.
        """

        return self._sash_dclick_unsplit


    def SetMinMaxTabWidth(self, minTabWidth, maxTabWidth):
        """
        Sets the minimum and/or the maximum tab widths for :class:`AuiNotebook` when the
        ``AUI_NB_TAB_FIXED_WIDTH`` style is defined.

        Pass -1 to either `minTabWidth` or `maxTabWidth` to reset to the default tab
        width behaviour for :class:`AuiNotebook`.

        :param integer `minTabWidth`: the minimum allowed tab width, in pixels;
        :param integer `maxTabWidth`: the maximum allowed tab width, in pixels.

        :note: Minimum and maximum tabs widths are used only when the ``AUI_NB_TAB_FIXED_WIDTH``
         style is present.
        """

        if minTabWidth > maxTabWidth:
            raise Exception("Minimum tab width must be less or equal than maximum tab width")

        self._tabBounds = (minTabWidth, maxTabWidth)
        self.SetAGWWindowStyleFlag(self._agwFlags)


    def GetMinMaxTabWidth(self):
        """
        Returns the minimum and the maximum tab widths for :class:`AuiNotebook` when the
        ``AUI_NB_TAB_FIXED_WIDTH`` style is defined.

        :note: Minimum and maximum tabs widths are used only when the ``AUI_NB_TAB_FIXED_WIDTH``
         style is present.

        :see: :meth:`SetMinMaxTabWidth` for more information.
        """

        return self._tabBounds


    def GetPageIndex(self, page_wnd):
        """
        Returns the page index for the specified window. If the window is not
        found in the notebook, ``wx.NOT_FOUND`` is returned.

        :param Window `page_wnd`: the window we are looking for.
        """

        return self._tabs.GetIdxFromWindow(page_wnd)


    def SetPageText(self, page_idx, text):
        """
        Sets the tab label for the page.

        :param integer `page_idx`: the page index;
        :param string `text`: the new tab label.
        """

        if page_idx >= self._tabs.GetPageCount():
            return False

        # update our own tab catalog
        page_info = self._tabs.GetPage(page_idx)
        should_refresh = page_info.caption != text
        page_info.caption = text

        # update what's on screen
        ctrl, ctrl_idx = self.FindTab(page_info.window)
        if not ctrl:
            return False

        info = ctrl.GetPage(ctrl_idx)
        should_refresh = should_refresh or info.caption != text
        info.caption = text

        if should_refresh:
            ctrl.Refresh()
            ctrl.Update()

        self.UpdateTabCtrlHeight(force=True)

        return True


    def GetPageText(self, page_idx):
        """
        Returns the tab label for the page.

        :param integer `page_idx`: the page index.
        """

        if page_idx >= self._tabs.GetPageCount():
            return ""

        # update our own tab catalog
        page_info = self._tabs.GetPage(page_idx)
        return page_info.caption


    def SetPageBitmap(self, page_idx, bitmap):
        """
        Sets the tab bitmap for the page.

        :param integer `page_idx`: the page index;
        :param Bitmap `bitmap`: the bitmap to display on the page tab.
        """

        if page_idx >= self._tabs.GetPageCount():
            return False

        # update our own tab catalog
        page_info = self._tabs.GetPage(page_idx)
        should_refresh = page_info.bitmap is not bitmap
        page_info.bitmap = bitmap
        if bitmap.IsOk() and not page_info.dis_bitmap.IsOk():
            page_info.dis_bitmap = MakeDisabledBitmap(bitmap)

        # tab height might have changed
        self.UpdateTabCtrlHeight()

        # update what's on screen
        ctrl, ctrl_idx = self.FindTab(page_info.window)
        if not ctrl:
            return False

        info = ctrl.GetPage(ctrl_idx)
        should_refresh = should_refresh or info.bitmap is not bitmap
        info.bitmap = bitmap
        info.dis_bitmap = page_info.dis_bitmap
        if should_refresh:
            ctrl.Refresh()
            ctrl.Update()

        return True


    def GetPageBitmap(self, page_idx):
        """
        Returns the tab bitmap for the page.

        :param integer `page_idx`: the page index.
        """

        if page_idx >= self._tabs.GetPageCount():
            return wx.NullBitmap

        # update our own tab catalog
        page_info = self._tabs.GetPage(page_idx)
        return page_info.bitmap


    def SetImageList(self, imageList):
        """
        Sets the image list for the :class:`AuiNotebook` control.

        :param ImageList `imageList`: the bitmap image list to associate to :class:`AuiNotebook`.
        """

        self._imageList = imageList


    def AssignImageList(self, imageList):
        """
        Sets the image list for the :class:`AuiNotebook` control.

        :param `imageList`: an instance of :class:`ImageList`.
        """

        self.SetImageList(imageList)


    def GetImageList(self):
        """ Returns the associated image list (if any). """

        return self._imageList


    def SetPageImage(self, page, image):
        """
        Sets the image index for the given page.

        :param integer `page`: the page index;
        :param integer `image`: an index into the image list which was set with :meth:`SetImageList`.
        """

        if page >= self._tabs.GetPageCount():
            return False

        if not isinstance(image, types.IntType):
            raise Exception("The image parameter must be an integer, you passed " \
                            "%s"%repr(image))

        if not self._imageList:
            raise Exception("To use SetPageImage you need to associate an image list " \
                            "Using SetImageList or AssignImageList")

        if image >= self._imageList.GetImageCount():
            raise Exception("Invalid image index (%d), the image list contains only" \
                            " (%d) bitmaps"%(image, self._imageList.GetImageCount()))

        if image == -1:
            self.SetPageBitmap(page, wx.NullBitmap)
            return

        bitmap = self._imageList.GetBitmap(image)
        self.SetPageBitmap(page, bitmap)


    def GetPageImage(self, page):
        """
        Returns the image index for the given page.

        :param integer `page`: the given page for which to retrieve the image index.
        """

        if page >= self._tabs.GetPageCount():
            return wx.NOT_FOUND

        bitmap = self.GetPageBitmap(page)
        bmpData1 = bitmap.ConvertToImage().GetData()

        for indx in xrange(self._imageList.GetImageCount()):
            imgListBmp = self._imageList.GetBitmap(indx)
            bmpData2 = imgListBmp.ConvertToImage().GetData()
            if bmpData1 == bmpData2:
                return indx

        return wx.NOT_FOUND


    def SetPageTextColour(self, page_idx, colour):
        """
        Sets the tab text colour for the page.

        :param integer `page_idx`: the page index;
        :param Colour `colour`: the new tab label text colour.
        """

        if page_idx >= self._tabs.GetPageCount():
            return False

        # update our own tab catalog
        page_info = self._tabs.GetPage(page_idx)
        should_refresh = page_info.text_colour != colour
        page_info.text_colour = colour

        # update what's on screen
        ctrl, ctrl_idx = self.FindTab(page_info.window)
        if not ctrl:
            return False

        info = ctrl.GetPage(ctrl_idx)
        should_refresh = should_refresh or info.text_colour != colour
        info.text_colour = page_info.text_colour

        if should_refresh:
            ctrl.Refresh()
            ctrl.Update()

        return True


    def GetPageTextColour(self, page_idx):
        """
        Returns the tab text colour for the page.

        :param integer `page_idx`: the page index.
        """

        if page_idx >= self._tabs.GetPageCount():
            return wx.NullColour

        # update our own tab catalog
        page_info = self._tabs.GetPage(page_idx)
        return page_info.text_colour


    def AddControlToPage(self, page_idx, control):
        """
        Adds a control inside a tab (not in the tab area).

        :param integer `page_idx`: the page index;
        :param Window `control`: almost any :class:`Window` -derived instance to be located
         inside a tab.
        """

        if page_idx >= self._tabs.GetPageCount():
            return False

        # update our own tab catalog
        page_info = self._tabs.GetPage(page_idx)
        page_info.control = control

        # tab height might have changed
        self.UpdateTabCtrlHeight(force=True)

        # update what's on screen
        ctrl, ctrl_idx = self.FindTab(page_info.window)
        if not ctrl:
            return False

        control.Reparent(ctrl)

        info = ctrl.GetPage(ctrl_idx)
        info.control = control
        ctrl.Refresh()
        ctrl.Update()

        return True


    def RemoveControlFromPage(self, page_idx):
        """
        Removes a control from a tab (not from the tab area).

        :param integer `page_idx`: the page index.
        """

        if page_idx >= self._tabs.GetPageCount():
            return False

        page_info = self._tabs.GetPage(page_idx)
        if page_info.control is None:
            return False

        page_info.control.Destroy()
        page_info.control = None

        # tab height might have changed
        self.UpdateTabCtrlHeight(force=True)

        # update what's on screen
        ctrl, ctrl_idx = self.FindTab(page_info.window)
        if not ctrl:
            return False

        info = ctrl.GetPage(ctrl_idx)
        info.control = None
        ctrl.Refresh()
        ctrl.Update()

        return True


    def SetCloseButton(self, page_idx, hasCloseButton):
        """
        Sets whether a tab should display a close button or not.

        :param integer `page_idx`: the page index;
        :param bool `hasCloseButton`: ``True`` if the page displays a close button.

        :note: This can only be called if ``AUI_NB_CLOSE_ON_ALL_TABS`` is specified.
        """

        if page_idx >= self._tabs.GetPageCount():
            return False

        # There's really not a need for this exception. If the close on
        # all tabs is False, no close buttons get drawn.
        #if self._agwFlags & AUI_NB_CLOSE_ON_ALL_TABS == 0:
        #    raise Exception("SetCloseButton can only be used with AUI_NB_CLOSE_ON_ALL_TABS style.")

        # update our own tab catalog
        page_info = self._tabs.GetPage(page_idx)
        page_info.hasCloseButton = hasCloseButton

        # update what's on screen
        ctrl, ctrl_idx = self.FindTab(page_info.window)
        if not ctrl:
            return False

        info = ctrl.GetPage(ctrl_idx)
        info.hasCloseButton = page_info.hasCloseButton
        ctrl.Refresh()
        ctrl.Update()

        return True


    def HasCloseButton(self, page_idx):
        """
        Returns whether a tab displays a close button or not.

        :param integer `page_idx`: the page index.

        :note: This can only be called if ``AUI_NB_CLOSE_ON_ALL_TABS`` is specified.
        """

        if page_idx >= self._tabs.GetPageCount():
            return False

        page_info = self._tabs.GetPage(page_idx)
        return page_info.hasCloseButton


    def GetSelection(self):
        """ Returns the index of the currently active page, or -1 if none was selected. """

        return self._curpage


    def GetCurrentPage(self):
        """ Returns the currently active page (not the index), or ``None`` if none was selected. """

        if self._curpage >= 0 and self._curpage < self._tabs.GetPageCount():
            return self.GetPage(self._curpage)

        return None


    def EnsureVisible(self, indx):
        """
        Ensures the input page index `indx` is visible.

        :param integer `indx`: the page index.
        """

        self._tabs.MakeTabVisible(indx, self)


    def SetSelection(self, new_page, force=False):
        """
        Sets the page selection. Calling this method will generate a page change event.

        :param integer `new_page`: the index of the new selection;
        :param bool `force`: whether to force the selection or not.
        """
        wnd = self._tabs.GetWindowFromIdx(new_page)

        #Update page access time
        self._tabs.GetPages()[new_page].access_time = datetime.datetime.now()

        if not wnd or not self.GetEnabled(new_page):
            return self._curpage

        # don't change the page unless necessary
        # however, clicking again on a tab should give it the focus.
        if new_page == self._curpage and not force:

            ctrl, ctrl_idx = self.FindTab(wnd)
            if wx.Window.FindFocus() != ctrl:
                ctrl.SetFocus()

            return self._curpage

        evt = AuiNotebookEvent(wxEVT_COMMAND_AUINOTEBOOK_PAGE_CHANGING, self.GetId())
        evt.SetSelection(new_page)
        evt.SetOldSelection(self._curpage)
        evt.SetEventObject(self)

        if not self.GetEventHandler().ProcessEvent(evt) or evt.IsAllowed():

            old_curpage = self._curpage
            self._curpage = new_page

            # program allows the page change
            evt.SetEventType(wxEVT_COMMAND_AUINOTEBOOK_PAGE_CHANGED)
            self.GetEventHandler().ProcessEvent(evt)

            if not evt.IsAllowed(): # event is no longer allowed after handler
                return self._curpage

            ctrl, ctrl_idx = self.FindTab(wnd)

            if ctrl:
                self._tabs.SetActivePage(wnd)
                ctrl.SetActivePage(ctrl_idx)
                self.DoSizing()
                ctrl.DoShowHide()
                ctrl.MakeTabVisible(ctrl_idx, ctrl)

                # set fonts
                all_panes = self._mgr.GetAllPanes()
                for pane in all_panes:
                    if pane.name == "dummy":
                        continue

                    tabctrl = pane.window._tabs
                    if tabctrl != ctrl:
                        tabctrl.SetSelectedFont(self._normal_font)
                    else:
                        tabctrl.SetSelectedFont(self._selected_font)

                    tabctrl.Refresh()
                    tabctrl.Update()

                # Set the focus to the page if we're not currently focused on the tab.
                # This is Firefox-like behaviour.
                if wnd.IsShownOnScreen() and wx.Window.FindFocus() != ctrl:
                    wnd.SetFocus()

                return old_curpage

        return self._curpage


    def SetSelectionToWindow(self, win):
        """
        Sets the selection based on the input window `win`.

        :param `win`: a :class:`Window` derived window.
        """

        idx = self._tabs.GetIdxFromWindow(win)

        if idx == wx.NOT_FOUND:
            raise Exception("invalid notebook page")

        if not self.GetEnabled(idx):
            return

        # since a tab was clicked, let the parent know that we received
        # the focus, even if we will assign that focus immediately
        # to the child tab in the SetSelection call below
        # (the child focus event will also let AuiManager, if any,
        # know that the notebook control has been activated)

        parent = self.GetParent()
        if parent:
            eventFocus = wx.ChildFocusEvent(self)
            parent.GetEventHandler().ProcessEvent(eventFocus)

        self.SetSelection(idx)


    def SetSelectionToPage(self, page):
        """
        Sets the selection based on the input page.

        :param `page`: an instance of :class:`AuiNotebookPage`.
        """

        self.SetSelectionToWindow(page.window)


    def GetPageCount(self):
        """ Returns the number of pages in the notebook. """

        return self._tabs.GetPageCount()


    def GetPage(self, page_idx):
        """
        Returns the page specified by the given index.

        :param integer `page_idx`: the page index.
        """

        if page_idx >= self._tabs.GetPageCount():
            raise Exception("invalid notebook page")

        return self._tabs.GetWindowFromIdx(page_idx)


    def GetPageInfo(self, page_idx):
        """
        Returns the :class:`AuiNotebookPage` info structure specified by the given index.

        :param integer `page_idx`: the page index.
        """

        if page_idx >= self._tabs.GetPageCount():
            raise Exception("invalid notebook page")

        return self._tabs.GetPage(page_idx)


    def GetEnabled(self, page_idx):
        """
        Returns whether the page specified by the index `page_idx` is enabled.

        :param integer `page_idx`: the page index.
        """

        return self._tabs.GetEnabled(page_idx)


    def EnableTab(self, page_idx, enable=True):
        """
        Enables/disables a page in the notebook.

        :param integer `page_idx`: the page index;
        :param bool `enable`: ``True`` to enable the page, ``False`` to disable it.
        """

        self._tabs.EnableTab(page_idx, enable)
        self.Refresh()


    def DoSizing(self):
        """ Performs all sizing operations in each tab control. """

        all_panes = self._mgr.GetAllPanes()
        for pane in all_panes:
            if pane.name == "dummy":
                continue

            tabframe = pane.window
            tabframe.DoSizing()


    def GetAuiManager(self):
        """ Returns the associated :class:`~lib.agw.aui.framemanager.AuiManager`. """

        return self._mgr


    def GetActiveTabCtrl(self):
        """
        Returns the active tab control. It is called to determine which control
        gets new windows being added.
        """

        if self._curpage >= 0 and self._curpage < self._tabs.GetPageCount():

            # find the tab ctrl with the current page
            ctrl, idx = self.FindTab(self._tabs.GetPage(self._curpage).window)
            if ctrl:
                return ctrl

        # no current page, just find the first tab ctrl
        all_panes = self._mgr.GetAllPanes()
        for pane in all_panes:
            if pane.name == "dummy":
                continue

            tabframe = pane.window
            return tabframe._tabs

        # If there is no tabframe at all, create one
        tabframe = TabFrame(self)
        tabframe.SetTabCtrlHeight(self._tab_ctrl_height)
        self._tab_id_counter += 1
        tabframe._tabs = AuiTabCtrl(self, self._tab_id_counter)

        tabframe._tabs.SetAGWFlags(self._agwFlags)
        tabframe._tabs.SetArtProvider(self._tabs.GetArtProvider().Clone())
        self._mgr.AddPane(tabframe, framemanager.AuiPaneInfo().Center().CaptionVisible(False).
                          PaneBorder((self._agwFlags & AUI_NB_SUB_NOTEBOOK) == 0))

        self._mgr.Update()

        return tabframe._tabs


    def FindTab(self, page):
        """
        Finds the tab control that currently contains the window as well
        as the index of the window in the tab control. It returns ``True`` if the
        window was found, otherwise ``False``.

        :param `page`: an instance of :class:`AuiNotebookPage`.
        """

        all_panes = self._mgr.GetAllPanes()
        for pane in all_panes:
            if pane.name == "dummy":
                continue

            tabframe = pane.window

            page_idx = tabframe._tabs.GetIdxFromWindow(page)

            if page_idx != -1:

                ctrl = tabframe._tabs
                idx = page_idx
                return ctrl, idx

        return None, wx.NOT_FOUND


    def Split(self, page, direction):
        """
        Performs a split operation programmatically.

        :param integer `page`: indicates the page that will be split off. This page will also become
         the active page after the split.
        :param integer `direction`: specifies where the pane should go, it should be one of the
         following: ``wx.TOP``, ``wx.BOTTOM``, ``wx.LEFT``, or ``wx.RIGHT``.
        """

        cli_size = self.GetClientSize()

        # get the page's window pointer
        wnd = self.GetPage(page)
        if not wnd:
            return

        # notebooks with 1 or less pages can't be split
        if self.GetPageCount() < 2:
            return

        # find out which tab control the page currently belongs to

        src_tabs, src_idx = self.FindTab(wnd)
        if not src_tabs:
            return

        selection = self.GetSelection()
        
        # choose a split size
        if self.GetPageCount() > 2:
            split_size = self.CalculateNewSplitSize()
        else:
            # because there are two panes, always split them
            # equally
            split_size = self.GetClientSize()
            split_size.x /= 2
            split_size.y /= 2

        # create a new tab frame
        new_tabs = TabFrame(self)
        new_tabs._rect = wx.RectPS(wx.Point(0, 0), split_size)
        new_tabs.SetTabCtrlHeight(self._tab_ctrl_height)
        self._tab_id_counter += 1
        new_tabs._tabs = AuiTabCtrl(self, self._tab_id_counter)

        new_tabs._tabs.SetArtProvider(self._tabs.GetArtProvider().Clone())
        new_tabs._tabs.SetAGWFlags(self._agwFlags)
        dest_tabs = new_tabs._tabs

        page_info = src_tabs.GetPage(src_idx)
        if page_info.control:
            self.ReparentControl(page_info.control, dest_tabs)

        cloned_buttons = self.CloneTabAreaButtons()
        for clone in cloned_buttons:
            dest_tabs.AddButton(clone.id, clone.location, clone.bitmap, clone.dis_bitmap)
        # create a pane info structure with the information
        # about where the pane should be added
        pane_info = framemanager.AuiPaneInfo().Bottom().CaptionVisible(False)

        if direction == wx.LEFT:

            pane_info.Left()
            mouse_pt = wx.Point(0, cli_size.y/2)

        elif direction == wx.RIGHT:

            pane_info.Right()
            mouse_pt = wx.Point(cli_size.x, cli_size.y/2)

        elif direction == wx.TOP:

            pane_info.Top()
            mouse_pt = wx.Point(cli_size.x/2, 0)

        elif direction == wx.BOTTOM:

            pane_info.Bottom()
            mouse_pt = wx.Point(cli_size.x/2, cli_size.y)

        self._mgr.AddPane(new_tabs, pane_info, mouse_pt)
        self._mgr.Update()

        # remove the page from the source tabs
        page_info.active = False

        src_tabs.RemovePage(page_info.window)

        if src_tabs.GetPageCount() > 0:
            if selection < 0 or selection == src_idx:
                active_page = 0
            else:
                if selection > src_idx:
                    selection -= 1

                active_page = selection
            
            src_tabs.SetActivePage(active_page)
            src_tabs.DoShowHide()
            src_tabs.Refresh()

        # add the page to the destination tabs
        dest_tabs.InsertPage(page_info.window, page_info, 0)

        if src_tabs.GetPageCount() == 0:
            self.RemoveEmptyTabFrames()

        self.DoSizing()
        dest_tabs.DoShowHide()
        dest_tabs.Refresh()

        # force the set selection function reset the selection
        self._curpage = -1

        # set the active page to the one we just split off
        self.SetSelectionToPage(page_info)

        self.UpdateHintWindowSize()


    def UnSplit(self):
        """ Restores original view after a tab split. """

        self.Freeze()

        # remember the tab now selected
        nowSelected = self.GetSelection()
        # select first tab as destination
        self.SetSelection(0)
        # iterate all other tabs
        for idx in xrange(1, self.GetPageCount()):
            # get win reference
            win = self.GetPage(idx)
            # get tab title
            title = self.GetPageText(idx)
            # get page bitmap
            bmp = self.GetPageBitmap(idx)
            # remove from notebook
            self.RemovePage(idx)
            # re-add in the same position so it will tab
            self.InsertPage(idx, win, title, False, bmp)
        # restore orignial selected tab
        self.SetSelection(nowSelected)

        self.Thaw()


    def ReparentControl(self, control, dest_tabs):
        """
        Reparents a control added inside a tab.

        :param Window `control`: almost any :class:`Window` -derived instance to be located
         inside a tab;
        :param `dest_tabs`: the destination :class:`AuiTabCtrl`.
        """

        control.Hide()
        control.Reparent(dest_tabs)


    def UnsplitDClick(self, part, sash_size, pos):
        """
        Unsplit the :class:`AuiNotebook` on sash double-click.

        :param `part`: an UI part representing the sash;
        :param integer `sash_size`: the sash size;
        :param Point `pos`: the double-click mouse position.

        .. warning::

           Due to a bug on MSW, for disabled pages :func:`FindWindowAtPoint`
           returns the wrong window. See http://trac.wxwidgets.org/ticket/2942
           
        """

        if not self._sash_dclick_unsplit:
            # Unsplit not allowed
            return

        pos1 = wx.Point(*pos)
        pos2 = wx.Point(*pos)
        if part.orientation == wx.HORIZONTAL:
            pos1.y -= 2*sash_size
            pos2.y += 2*sash_size + self.GetTabCtrlHeight()
        elif part.orientation == wx.VERTICAL:
            pos1.x -= 2*sash_size
            pos2.x += 2*sash_size
        else:
            raise Exception("Invalid UI part orientation")

        pos1, pos2 = self.ClientToScreen(pos1), self.ClientToScreen(pos2)
        win1, win2 = wx.FindWindowAtPoint(pos1), wx.FindWindowAtPoint(pos2)

        if isinstance(win1, wx.ScrollBar):
            # Hopefully it will work
            pos1 = wx.Point(*pos)
            shift = wx.SystemSettings.GetMetric(wx.SYS_VSCROLL_X) + 2*(sash_size+1)
            if part.orientation == wx.HORIZONTAL:
                pos1.y -= shift
            else:
                pos1.x -= shift

            pos1 = self.ClientToScreen(pos1)
            win1 = wx.FindWindowAtPoint(pos1)

        if isinstance(win2, wx.ScrollBar):
            pos2 = wx.Point(*pos)
            shift = wx.SystemSettings.GetMetric(wx.SYS_VSCROLL_X) + 2*(sash_size+1)
            if part.orientation == wx.HORIZONTAL:
                pos2.y += shift
            else:
                pos2.x += shift

            pos2 = self.ClientToScreen(pos2)
            win2 = wx.FindWindowAtPoint(pos2)

        if not win1 or not win2:
            # How did we get here?
            return

        if isinstance(win1, AuiNotebook) or isinstance(win2, AuiNotebook):
            # This is a bug on MSW, for disabled pages wx.FindWindowAtPoint
            # returns the wrong window.
            # See http://trac.wxwidgets.org/ticket/2942
            return

        tab_frame1, tab_frame2 = self.GetTabFrameFromWindow(win1), self.GetTabFrameFromWindow(win2)

        if not tab_frame1 or not tab_frame2:
            return

        tab_ctrl_1, tab_ctrl_2 = tab_frame1._tabs, tab_frame2._tabs

        if tab_ctrl_1.GetPageCount() > tab_ctrl_2.GetPageCount():
            src_tabs = tab_ctrl_2
            dest_tabs = tab_ctrl_1
        else:
            src_tabs = tab_ctrl_1
            dest_tabs = tab_ctrl_2

        selection = -1
        page_count = dest_tabs.GetPageCount()

        for page in xrange(src_tabs.GetPageCount()-1, -1, -1):
            # remove the page from the source tabs
            page_info = src_tabs.GetPage(page)
            if page_info.active:
                selection = page_count + page
            src_tabs.RemovePage(page_info.window)

            # add the page to the destination tabs
            dest_tabs.AddPage(page_info.window, page_info)
            if page_info.control:
                self.ReparentControl(page_info.control, dest_tabs)

        self.RemoveEmptyTabFrames()

        dest_tabs.DoShowHide()
        self.DoSizing()
        dest_tabs.Refresh()
        self._mgr.Update()
        if selection > 0:
            wx.CallAfter(dest_tabs.MakeTabVisible, selection, self)


    def OnSize(self, event):
        """
        Handles the ``wx.EVT_SIZE`` event for :class:`AuiNotebook`.

        :param `event`: a :class:`SizeEvent` event to be processed.
        """

        self.UpdateHintWindowSize()
        event.Skip()


    def OnTabClicked(self, event):
        """
        Handles the ``EVT_AUINOTEBOOK_PAGE_CHANGING`` event for :class:`AuiNotebook`.

        :param `event`: a :class:`AuiNotebookEvent` event to be processed.
        """

        if self._textCtrl is not None:
            self._textCtrl.StopEditing()

        ctrl = event.GetEventObject()
        assert ctrl != None

        wnd = ctrl.GetWindowFromIdx(event.GetSelection())
        assert wnd != None

        self.SetSelectionToWindow(wnd)


    def OnTabBgDClick(self, event):
        """
        Handles the ``EVT_AUINOTEBOOK_BG_DCLICK`` event for :class:`AuiNotebook`.

        :param `event`: a :class:`AuiNotebookEvent` event to be processed.
        """

        if self._textCtrl is not None:
            self._textCtrl.StopEditing()

        # notify owner that the tabbar background has been double-clicked
        e = AuiNotebookEvent(wxEVT_COMMAND_AUINOTEBOOK_BG_DCLICK, self.GetId())
        e.SetEventObject(self)
        self.GetEventHandler().ProcessEvent(e)


    def OnTabDClick(self, event):
        """
        Handles the ``EVT_AUINOTEBOOK_TAB_DCLICK`` event for :class:`AuiNotebook`.

        :param `event`: a :class:`AuiNotebookEvent` event to be processed.
        """

        # notify owner that the tabbar background has been double-clicked
        e = AuiNotebookEvent(wxEVT_COMMAND_AUINOTEBOOK_TAB_DCLICK, self.GetId())
        e.SetEventObject(self)
        self.GetEventHandler().ProcessEvent(e)

        tabs = event.GetEventObject()
        if not tabs.GetEnabled(event.GetSelection()):
            return

        if not self.IsRenamable(event.GetSelection()):
            return

        self.EditTab(event.GetSelection())


    def OnTabBeginDrag(self, event):
        """
        Handles the ``EVT_AUINOTEBOOK_BEGIN_DRAG`` event for :class:`AuiNotebook`.

        :param `event`: a :class:`AuiNotebookEvent` event to be processed.
        """

        tabs = event.GetEventObject()
        if not tabs.GetEnabled(event.GetSelection()):
            return

        self._last_drag_x = 0


    def OnTabDragMotion(self, event):
        """
        Handles the ``EVT_AUINOTEBOOK_DRAG_MOTION`` event for :class:`AuiNotebook`.

        :param `event`: a :class:`AuiNotebookEvent` event to be processed.
        """

        self._curpage = event.GetSelection()

        tabs = event.GetEventObject()
        if not tabs.GetEnabled(event.GetSelection()):
            return

        if self._textCtrl is not None:
            self._textCtrl.StopEditing()

        screen_pt = wx.GetMousePosition()
        client_pt = self.ScreenToClient(screen_pt)
        zero = wx.Point(0, 0)

        src_tabs = event.GetEventObject()
        dest_tabs = self.GetTabCtrlFromPoint(client_pt)

        if dest_tabs == src_tabs:

            # always hide the hint for inner-tabctrl drag
            self._mgr.HideHint()

            # if tab moving is not allowed, leave
            if not self._agwFlags & AUI_NB_TAB_MOVE:
                return

            pt = dest_tabs.ScreenToClient(screen_pt)

            # this is an inner-tab drag/reposition
            dest_location_tab = dest_tabs.TabHitTest(pt.x, pt.y)

            if dest_location_tab:

                src_idx = event.GetSelection()
                dest_idx = dest_tabs.GetIdxFromWindow(dest_location_tab)

                # prevent jumpy drag
                if (src_idx == dest_idx) or dest_idx == -1 or \
                   (src_idx > dest_idx and self._last_drag_x <= pt.x) or \
                   (src_idx < dest_idx and self._last_drag_x >= pt.x):

                    self._last_drag_x = pt.x
                    return

                src_tab = dest_tabs.GetWindowFromIdx(src_idx)
                dest_tabs.MovePage(src_tab, dest_idx)
                self._tabs.MovePage(self._tabs.GetPage(src_idx).window, dest_idx)
                dest_tabs.SetActivePage(dest_idx)
                dest_tabs.DoShowHide()
                dest_tabs.Refresh()
                self._last_drag_x = pt.x

            return

        # if external drag is allowed, check if the tab is being dragged
        # over a different AuiNotebook control
        if self._agwFlags & AUI_NB_TAB_EXTERNAL_MOVE:

            tab_ctrl = wx.FindWindowAtPoint(screen_pt)

            # if we aren't over any window, stop here
            if not tab_ctrl:
                if self._agwFlags & AUI_NB_TAB_FLOAT:
                    if self.IsMouseWellOutsideWindow():
                        hintRect = wx.RectPS(screen_pt, (400, 300))
                        # Use CallAfter so we overwrite the hint that might be
                        # shown by our superclass:
                        wx.CallAfter(self._mgr.ShowHint, hintRect)
                return

            # make sure we are not over the hint window
            if not isinstance(tab_ctrl, wx.Frame):
                while tab_ctrl:
                    if isinstance(tab_ctrl, AuiTabCtrl):
                        break

                    tab_ctrl = tab_ctrl.GetParent()

                if tab_ctrl:
                    nb = tab_ctrl.GetParent()

                    if nb != self:

                        hint_rect = tab_ctrl.GetClientRect()
                        hint_rect.x, hint_rect.y = tab_ctrl.ClientToScreenXY(hint_rect.x, hint_rect.y)
                        self._mgr.ShowHint(hint_rect)
                        return

            else:

                if not dest_tabs:
                    # we are either over a hint window, or not over a tab
                    # window, and there is no where to drag to, so exit
                    return

        if self._agwFlags & AUI_NB_TAB_FLOAT:
            if self.IsMouseWellOutsideWindow():
                hintRect = wx.RectPS(screen_pt, (400, 300))
                # Use CallAfter so we overwrite the hint that might be
                # shown by our superclass:
                wx.CallAfter(self._mgr.ShowHint, hintRect)
                return

        # if there are less than two panes, split can't happen, so leave
        if self._tabs.GetPageCount() < 2:
            return

        # if tab moving is not allowed, leave
        if not self._agwFlags & AUI_NB_TAB_SPLIT:
            return

        if dest_tabs:

            hint_rect = dest_tabs.GetRect()
            hint_rect.x, hint_rect.y = self.ClientToScreenXY(hint_rect.x, hint_rect.y)
            self._mgr.ShowHint(hint_rect)

        else:
            rect = self._mgr.CalculateHintRect(self._dummy_wnd, client_pt, zero)
            if rect.IsEmpty():
                self._mgr.HideHint()
                return

            hit_wnd = wx.FindWindowAtPoint(screen_pt)
            if hit_wnd and not isinstance(hit_wnd, AuiNotebook):
                tab_frame = self.GetTabFrameFromWindow(hit_wnd)
                if tab_frame:
                    hint_rect = wx.Rect(*tab_frame._rect)
                    hint_rect.x, hint_rect.y = self.ClientToScreenXY(hint_rect.x, hint_rect.y)
                    rect.Intersect(hint_rect)
                    self._mgr.ShowHint(rect)
                else:
                    self._mgr.DrawHintRect(self._dummy_wnd, client_pt, zero)
            else:
                self._mgr.DrawHintRect(self._dummy_wnd, client_pt, zero)


    def OnTabEndDrag(self, event):
        """
        Handles the ``EVT_AUINOTEBOOK_END_DRAG`` event for :class:`AuiNotebook`.

        :param `event`: a :class:`AuiNotebookEvent` event to be processed.
        """

        tabs = event.GetEventObject()
        if not tabs.GetEnabled(event.GetSelection()):
            return

        self._mgr.HideHint()

        src_tabs = event.GetEventObject()
        if not src_tabs:
            raise Exception("no source object?")

        # get the mouse position, which will be used to determine the drop point
        mouse_screen_pt = wx.GetMousePosition()
        mouse_client_pt = self.ScreenToClient(mouse_screen_pt)

        # check for an external move
        if self._agwFlags & AUI_NB_TAB_EXTERNAL_MOVE:
            tab_ctrl = wx.FindWindowAtPoint(mouse_screen_pt)

            while tab_ctrl:

                if isinstance(tab_ctrl, AuiTabCtrl):
                    break

                tab_ctrl = tab_ctrl.GetParent()

            if tab_ctrl:

                nb = tab_ctrl.GetParent()

                if nb != self:

                    # find out from the destination control
                    # if it's ok to drop this tab here
                    e = AuiNotebookEvent(wxEVT_COMMAND_AUINOTEBOOK_ALLOW_DND, self.GetId())
                    e.SetSelection(event.GetSelection())
                    e.SetOldSelection(event.GetSelection())
                    e.SetEventObject(self)
                    e.SetDragSource(self)
                    e.Veto() # dropping must be explicitly approved by control owner

                    nb.GetEventHandler().ProcessEvent(e)

                    if not e.IsAllowed():

                        # no answer or negative answer
                        self._mgr.HideHint()
                        return

                    # drop was allowed
                    src_idx = event.GetSelection()
                    src_page = src_tabs.GetWindowFromIdx(src_idx)

                    # Check that it's not an impossible parent relationship
                    p = nb
                    while p and not p.IsTopLevel():
                        if p == src_page:
                            return

                        p = p.GetParent()

                    # get main index of the page
                    main_idx = self._tabs.GetIdxFromWindow(src_page)
                    if main_idx == wx.NOT_FOUND:
                        raise Exception("no source page?")

                    # make a copy of the page info
                    page_info = self._tabs.GetPage(main_idx)

                    # remove the page from the source notebook
                    self.RemovePage(main_idx)

                    # reparent the page
                    src_page.Reparent(nb)

                    # Reparent the control in a tab (if any)
                    if page_info.control:
                        self.ReparentControl(page_info.control, tab_ctrl)

                    # find out the insert idx
                    dest_tabs = tab_ctrl
                    pt = dest_tabs.ScreenToClient(mouse_screen_pt)

                    target = dest_tabs.TabHitTest(pt.x, pt.y)
                    insert_idx = -1
                    if target:
                        insert_idx = dest_tabs.GetIdxFromWindow(target)

                    # add the page to the new notebook
                    if insert_idx == -1:
                        insert_idx = dest_tabs.GetPageCount()

                    dest_tabs.InsertPage(page_info.window, page_info, insert_idx)
                    nb._tabs.AddPage(page_info.window, page_info)

                    nb.DoSizing()
                    dest_tabs.DoShowHide()
                    dest_tabs.Refresh()

                    # set the selection in the destination tab control
                    nb.SetSelectionToPage(page_info)

                    # notify owner that the tab has been dragged
                    e2 = AuiNotebookEvent(wxEVT_COMMAND_AUINOTEBOOK_DRAG_DONE, self.GetId())
                    e2.SetSelection(event.GetSelection())
                    e2.SetOldSelection(event.GetSelection())
                    e2.SetEventObject(self)
                    self.GetEventHandler().ProcessEvent(e2)

                    # notify the target notebook that the tab has been dragged
                    e3 = AuiNotebookEvent(wxEVT_COMMAND_AUINOTEBOOK_DRAG_DONE, nb.GetId())
                    e3.SetSelection(insert_idx)
                    e3.SetOldSelection(insert_idx)
                    e3.SetEventObject(nb)
                    nb.GetEventHandler().ProcessEvent(e3)

                    return

        if self._agwFlags & AUI_NB_TAB_FLOAT:
            self._mgr.HideHint()
            if self.IsMouseWellOutsideWindow():
                # Use CallAfter so we our superclass can deal with the event first
                wx.CallAfter(self.FloatPage, self.GetSelection())
                event.Skip()
                return

        # only perform a tab split if it's allowed
        dest_tabs = None

        if self._agwFlags & AUI_NB_TAB_SPLIT and self._tabs.GetPageCount() >= 2:

            # If the pointer is in an existing tab frame, do a tab insert
            hit_wnd = wx.FindWindowAtPoint(mouse_screen_pt)
            tab_frame = self.GetTabFrameFromTabCtrl(hit_wnd)
            insert_idx = -1

            if tab_frame:

                dest_tabs = tab_frame._tabs

                if dest_tabs == src_tabs:
                    return

                pt = dest_tabs.ScreenToClient(mouse_screen_pt)
                target = dest_tabs.TabHitTest(pt.x, pt.y)

                if target:
                    insert_idx = dest_tabs.GetIdxFromWindow(target)

            else:

                zero = wx.Point(0, 0)
                rect = self._mgr.CalculateHintRect(self._dummy_wnd, mouse_client_pt, zero)

                if rect.IsEmpty():
                    # there is no suitable drop location here, exit out
                    return

                # If there is no tabframe at all, create one
                new_tabs = TabFrame(self)
                new_tabs._rect = wx.RectPS(wx.Point(0, 0), self.CalculateNewSplitSize())
                new_tabs.SetTabCtrlHeight(self._tab_ctrl_height)
                self._tab_id_counter += 1
                new_tabs._tabs = AuiTabCtrl(self, self._tab_id_counter)
                new_tabs._tabs.SetArtProvider(self._tabs.GetArtProvider().Clone())
                new_tabs._tabs.SetAGWFlags(self._agwFlags)

                self._mgr.AddPane(new_tabs, framemanager.AuiPaneInfo().Bottom().CaptionVisible(False), mouse_client_pt)
                self._mgr.Update()
                dest_tabs = new_tabs._tabs

                cloned_buttons = self.CloneTabAreaButtons()
                for clone in cloned_buttons:
                    dest_tabs.AddButton(clone.id, clone.location, clone.bitmap, clone.dis_bitmap)
            # remove the page from the source tabs
            page_info = src_tabs.GetPage(event.GetSelection())

            if page_info.control:
                self.ReparentControl(page_info.control, dest_tabs)

            page_info.active = False
            src_tabs.RemovePage(page_info.window)

            if src_tabs.GetPageCount() > 0:
                src_tabs.SetActivePage(0)
                src_tabs.DoShowHide()
                src_tabs.Refresh()

            # add the page to the destination tabs
            if insert_idx == -1:
                insert_idx = dest_tabs.GetPageCount()

            dest_tabs.InsertPage(page_info.window, page_info, insert_idx)

            if src_tabs.GetPageCount() == 0:
                self.RemoveEmptyTabFrames()

            self.DoSizing()
            dest_tabs.DoShowHide()
            dest_tabs.Refresh()

            # force the set selection function reset the selection
            self._curpage = -1

            # set the active page to the one we just split off
            self.SetSelectionToPage(page_info)

            self.UpdateHintWindowSize()

        # notify owner that the tab has been dragged
        e = AuiNotebookEvent(wxEVT_COMMAND_AUINOTEBOOK_DRAG_DONE, self.GetId())
        e.SetSelection(event.GetSelection())
        e.SetOldSelection(event.GetSelection())
        e.SetEventObject(self)
        self.GetEventHandler().ProcessEvent(e)


    def OnTabCancelDrag(self, event):
        """
        Handles the ``EVT_AUINOTEBOOK_CANCEL_DRAG`` event for :class:`AuiNotebook`.

        :param `event`: a :class:`AuiNotebookEvent` event to be processed.
        """

        tabs = event.GetEventObject()
        if not tabs.GetEnabled(event.GetSelection()):
            return

        self._mgr.HideHint()

        src_tabs = event.GetEventObject()
        if not src_tabs:
            raise Exception("no source object?")


    def IsMouseWellOutsideWindow(self):
        """ Returns whether the mouse is well outside the :class:`AuiNotebook` screen rectangle. """

        screen_rect = self.GetScreenRect()
        screen_rect.Inflate(50, 50)

        return not screen_rect.Contains(wx.GetMousePosition())


    def FloatPage(self, page_index):
        """
        Float the page in `page_index` by reparenting it to a floating frame.

        :param integer `page_index`: the index of the page to be floated.

        .. warning::

           When the notebook is more or less full screen, tabs cannot be dragged far
           enough outside of the notebook to become floating pages.
           
        """

        root_manager = framemanager.GetManager(self)
        page_title = self.GetPageText(page_index)
        page_contents = self.GetPage(page_index)
        page_bitmap = self.GetPageBitmap(page_index)
        text_colour = self.GetPageTextColour(page_index)
        info = self.GetPageInfo(page_index)

        if root_manager and root_manager != self._mgr:
            root_manager = framemanager.GetManager(self)

            if hasattr(page_contents, "__floating_size__"):
                floating_size = wx.Size(*page_contents.__floating_size__)
            else:
                floating_size = page_contents.GetBestSize()
                if floating_size == wx.DefaultSize:
                    floating_size = wx.Size(300, 200)

            page_contents.__page_index__ = page_index
            page_contents.__aui_notebook__ = self
            page_contents.__text_colour__ = text_colour
            page_contents.__control__ = info.control

            if info.control:
                info.control.Reparent(page_contents)
                info.control.Hide()
                info.control = None

            self.RemovePage(page_index)
            self.RemoveEmptyTabFrames()

            pane_info = framemanager.AuiPaneInfo().Float().FloatingPosition(wx.GetMousePosition()). \
                        FloatingSize(floating_size).BestSize(floating_size).Name("__floating__%s"%page_title). \
                        Caption(page_title).Icon(page_bitmap)
            root_manager.AddPane(page_contents, pane_info)
            root_manager.Bind(framemanager.EVT_AUI_PANE_CLOSE, self.OnCloseFloatingPage)
            self.GetActiveTabCtrl().DoShowHide()
            self.DoSizing()
            root_manager.Update()

        else:
            frame = wx.Frame(self, title=page_title,
                             style=wx.DEFAULT_FRAME_STYLE|wx.FRAME_TOOL_WINDOW|
                                   wx.FRAME_FLOAT_ON_PARENT | wx.FRAME_NO_TASKBAR)

            if info.control:
                info.control.Reparent(frame)
                info.control.Hide()

            frame.bitmap = page_bitmap
            frame.page_index = page_index
            frame.text_colour = text_colour
            frame.control = info.control
            page_contents.Reparent(frame)
            frame.Bind(wx.EVT_CLOSE, self.OnCloseFloatingPage)
            frame.Move(wx.GetMousePosition())
            frame.Show()
            self.RemovePage(page_index)

            self.RemoveEmptyTabFrames()

        wx.CallAfter(self.RemoveEmptyTabFrames)


    def OnCloseFloatingPage(self, event):
        """
        Handles the ``wx.EVT_CLOSE`` event for a floating page in :class:`AuiNotebook`.

        :param `event`: a :class:`CloseEvent` event to be processed.
        """

        root_manager = framemanager.GetManager(self)
        if root_manager and root_manager != self._mgr:
            pane = event.pane
            if pane.name.startswith("__floating__"):
                self.ReDockPage(pane)
                return

            event.Skip()
        else:
            event.Skip()
            frame = event.GetEventObject()
            page_title = frame.GetTitle()
            page_contents = list(frame.GetChildren())[-1]
            page_contents.Reparent(self)
            self.InsertPage(frame.page_index, page_contents, page_title, select=True, bitmap=frame.bitmap, control=frame.control)

            if frame.control:
                src_tabs, idx = self.FindTab(page_contents)
                frame.control.Reparent(src_tabs)
                frame.control.Hide()
                frame.control = None

            self.SetPageTextColour(frame.page_index, frame.text_colour)


    def ReDockPage(self, pane):
        """
        Re-docks a floating :class:`AuiNotebook` tab in the original position, when possible.

        :param `pane`: an instance of :class:`~lib.agw.aui.framemanager.AuiPaneInfo`.
        """

        root_manager = framemanager.GetManager(self)

        pane.window.__floating_size__ = wx.Size(*pane.floating_size)
        page_index = pane.window.__page_index__
        text_colour = pane.window.__text_colour__
        control = pane.window.__control__

        root_manager.DetachPane(pane.window)
        self.InsertPage(page_index, pane.window, pane.caption, True, pane.icon, control=control)

        self.SetPageTextColour(page_index, text_colour)
        self.GetActiveTabCtrl().DoShowHide()
        self.DoSizing()
        if control:
            self.UpdateTabCtrlHeight(force=True)

        self._mgr.Update()
        root_manager.Update()


    def GetTabCtrlFromPoint(self, pt):
        """
        Returns the tab control at the specified point.

        :param Point `pt`: the mouse location.
        """

        # if we've just removed the last tab from the source
        # tab set, the remove the tab control completely
        all_panes = self._mgr.GetAllPanes()
        for pane in all_panes:
            if pane.name == "dummy":
                continue

            tabframe = pane.window
            if tabframe._tab_rect.Contains(pt):
                return tabframe._tabs

        return None


    def GetTabFrameFromTabCtrl(self, tab_ctrl):
        """
        Returns the tab frame associated with a tab control.

        :param `tab_ctrl`: an instance of :class:`AuiTabCtrl`.
        """

        # if we've just removed the last tab from the source
        # tab set, the remove the tab control completely
        all_panes = self._mgr.GetAllPanes()
        for pane in all_panes:
            if pane.name == "dummy":
                continue

            tabframe = pane.window
            if tabframe._tabs == tab_ctrl:
                return tabframe

        return None


    def GetTabFrameFromWindow(self, wnd):
        """
        Returns the tab frame associated with a window.

        :param Window `wnd`: the window for which we want to locate the :class:`TabFrame`.
        """

        all_panes = self._mgr.GetAllPanes()
        for pane in all_panes:
            if pane.name == "dummy":
                continue

            tabframe = pane.window
            for page in tabframe._tabs.GetPages():
                if wnd == page.window:
                    return tabframe

        return None


    def RemoveEmptyTabFrames(self):
        """ Removes all the empty tab frames. """

        # if we've just removed the last tab from the source
        # tab set, the remove the tab control completely
        all_panes = self._mgr.GetAllPanes()

        for indx in xrange(len(all_panes)-1, -1, -1):
            pane = all_panes[indx]
            if pane.name == "dummy":
                continue

            tab_frame = pane.window
            if tab_frame._tabs.GetPageCount() == 0:
                self._mgr.DetachPane(tab_frame)
                tab_frame._tabs.Destroy()
                tab_frame._tabs = None
                del tab_frame

        # check to see if there is still a center pane
        # if there isn't, make a frame the center pane
        first_good = None
        center_found = False

        all_panes = self._mgr.GetAllPanes()
        for pane in all_panes:
            if pane.name == "dummy":
                continue

            if pane.dock_direction == AUI_DOCK_CENTRE:
                center_found = True
            if not first_good:
                first_good = pane.window

        if not center_found and first_good:
            self._mgr.GetPane(first_good).Centre()

        if not self.IsBeingDeleted():
            self._mgr.Update()


    def OnChildFocusNotebook(self, event):
        """
        Handles the ``wx.EVT_CHILD_FOCUS`` event for :class:`AuiNotebook`.

        :param `event`: a :class:`ChildFocusEvent` event to be processed.
        """

        # if we're dragging a tab, don't change the current selection.
        # This code prevents a bug that used to happen when the hint window
        # was hidden.  In the bug, the focus would return to the notebook
        # child, which would then enter this handler and call
        # SetSelection, which is not desired turn tab dragging.

        event.Skip()

        all_panes = self._mgr.GetAllPanes()
        for pane in all_panes:
            if pane.name == "dummy":
                continue
            tabframe = pane.window
            if tabframe._tabs.IsDragging():
                return

##        # change the tab selection to the child
##        # which was focused
##        idx = self._tabs.GetIdxFromWindow(event.GetWindow())
##        if idx != -1 and idx != self._curpage:
##            self.SetSelection(idx)


    def SetNavigatorIcon(self, bmp):
        """
        Sets the icon used by the :class:`TabNavigatorWindow`.

        :param Bitmap `bmp`: the new bitmap for the :class:`TabNavigatorWindow`.
        """

        if isinstance(bmp, wx.Bitmap) and bmp.IsOk():
            self.NavigatorProps.Icon = bmp
        else:
            raise TypeError("SetNavigatorIcon requires a valid bitmap")


    def OnNavigationKeyNotebook(self, event):
        """
        Handles the ``wx.EVT_NAVIGATION_KEY`` event for :class:`AuiNotebook`.

        :param `event`: a :class:`NavigationKeyEvent` event to be processed.
        """

        if event.IsWindowChange():
            if self._agwFlags & AUI_NB_SMART_TABS:
                if not self._popupWin:
                    self._popupWin = TabNavigatorWindow(self, self.NavigatorProps)
                    self._popupWin.SetReturnCode(wx.ID_OK)
                    self._popupWin.ShowModal()
                    idx = self._popupWin.GetSelectedPage()
                    self._popupWin.Destroy()
                    self._popupWin = None
                    # Need to do CallAfter so that the selection and its
                    # associated events get processed outside the context of
                    # this key event. Not doing so causes odd issues with the
                    # window focus under certain use cases on Windows.
                    wx.CallAfter(self.SetSelection, idx, True)
                else:
                    # a dialog is already opened
                    self._popupWin.OnNavigationKey(event)
                    return
            else:
                # change pages
                # FIXME: the problem with this is that if we have a split notebook,
                # we selection may go all over the place.
                self.AdvanceSelection(event.GetDirection())

        else:
            # we get this event in 3 cases
            #
            # a) one of our pages might have generated it because the user TABbed
            # out from it in which case we should propagate the event upwards and
            # our parent will take care of setting the focus to prev/next sibling
            #
            # or
            #
            # b) the parent panel wants to give the focus to us so that we
            # forward it to our selected page. We can't deal with this in
            # OnSetFocus() because we don't know which direction the focus came
            # from in this case and so can't choose between setting the focus to
            # first or last panel child
            #
            # or
            #
            # c) we ourselves (see MSWTranslateMessage) generated the event
            #
            parent = self.GetParent()

            # the wxObject* casts are required to avoid MinGW GCC 2.95.3 ICE
            isFromParent = event.GetEventObject() == parent
            isFromSelf = event.GetEventObject() == self

            if isFromParent or isFromSelf:

                # no, it doesn't come from child, case (b) or (c): forward to a
                # page but only if direction is backwards (TAB) or from ourselves,
                if self.GetSelection() != wx.NOT_FOUND and (not event.GetDirection() or isFromSelf):

                    # so that the page knows that the event comes from it's parent
                    # and is being propagated downwards
                    event.SetEventObject(self)

                    page = self.GetPage(self.GetSelection())
                    if not page.GetEventHandler().ProcessEvent(event):
                        page.SetFocus()

                    #else: page manages focus inside it itself

                else: # otherwise set the focus to the notebook itself

                    self.SetFocus()

            else:

                # send this event back for the 'wraparound' focus.
                winFocus = event.GetCurrentFocus()

                if winFocus:
                    event.SetEventObject(self)
                    winFocus.GetEventHandler().ProcessEvent(event)


    def OnTabButton(self, event):
        """
        Handles the ``EVT_AUINOTEBOOK_BUTTON`` event for :class:`AuiNotebook`.

        :param `event`: a :class:`AuiNotebookEvent` event to be processed.
        """

        tabs = event.GetEventObject()
        button_id = event.GetInt()

        if button_id == AUI_BUTTON_CLOSE:

            selection = event.GetSelection()

            if selection == -1:

                # if the close button is to the right, use the active
                # page selection to determine which page to close
                selection = tabs.GetActivePage()

            if selection == -1 or not tabs.GetEnabled(selection):
                return

            if selection != -1:

                close_wnd = tabs.GetWindowFromIdx(selection)

                if close_wnd.GetName() == "__fake__page__":
                    # This is a notebook preview
                    previous_active, page_status = close_wnd.__previousStatus
                    for page, status in zip(tabs.GetPages(), page_status):
                        page.enabled = status

                    main_idx = self._tabs.GetIdxFromWindow(close_wnd)
                    self.DeletePage(main_idx)

                    if previous_active >= 0:
                        tabs.SetActivePage(previous_active)
                        page_count = tabs.GetPageCount()
                        selection = -1

                        for page in xrange(page_count):
                            # remove the page from the source tabs
                            page_info = tabs.GetPage(page)
                            if page_info.active:
                                selection = page
                                break

                        tabs.DoShowHide()
                        self.DoSizing()
                        tabs.Refresh()

                        if selection >= 0:
                            wx.CallAfter(tabs.MakeTabVisible, selection, self)

                    # Don't fire the event
                    return

                # ask owner if it's ok to close the tab
                e = AuiNotebookEvent(wxEVT_COMMAND_AUINOTEBOOK_PAGE_CLOSE, self.GetId())
                idx = self._tabs.GetIdxFromWindow(close_wnd)
                e.SetSelection(idx)
                e.SetOldSelection(event.GetSelection())
                e.SetEventObject(self)
                self.GetEventHandler().ProcessEvent(e)
                if not e.IsAllowed():
                    return

                if repr(close_wnd.__class__).find("AuiMDIChildFrame") >= 0:
                    close_wnd.Close()

                else:
                    main_idx = self._tabs.GetIdxFromWindow(close_wnd)
                    self.DeletePage(main_idx)

                # notify owner that the tab has been closed
                e2 = AuiNotebookEvent(wxEVT_COMMAND_AUINOTEBOOK_PAGE_CLOSED, self.GetId())
                e2.SetSelection(idx)
                e2.SetEventObject(self)
                self.GetEventHandler().ProcessEvent(e2)

                if self.GetPageCount() == 0:
                    mgr = self.GetAuiManager()
                    win = mgr.GetManagedWindow()
                    win.SendSizeEvent()


    def OnTabMiddleDown(self, event):
        """
        Handles the ``EVT_AUINOTEBOOK_TAB_MIDDLE_DOWN`` event for :class:`AuiNotebook`.

        :param `event`: a :class:`AuiNotebookEvent` event to be processed.
        """

        tabs = event.GetEventObject()
        if not tabs.GetEnabled(event.GetSelection()):
            return

        # patch event through to owner
        wnd = tabs.GetWindowFromIdx(event.GetSelection())

        e = AuiNotebookEvent(wxEVT_COMMAND_AUINOTEBOOK_TAB_MIDDLE_DOWN, self.GetId())
        e.SetSelection(self._tabs.GetIdxFromWindow(wnd))
        e.SetEventObject(self)
        self.GetEventHandler().ProcessEvent(e)


    def OnTabMiddleUp(self, event):
        """
        Handles the ``EVT_AUINOTEBOOK_TAB_MIDDLE_UP`` event for :class:`AuiNotebook`.

        :param `event`: a :class:`AuiNotebookEvent` event to be processed.
        """

        tabs = event.GetEventObject()
        if not tabs.GetEnabled(event.GetSelection()):
            return

        # if the AUI_NB_MIDDLE_CLICK_CLOSE is specified, middle
        # click should act like a tab close action.  However, first
        # give the owner an opportunity to handle the middle up event
        # for custom action

        wnd = tabs.GetWindowFromIdx(event.GetSelection())

        e = AuiNotebookEvent(wxEVT_COMMAND_AUINOTEBOOK_TAB_MIDDLE_UP, self.GetId())
        e.SetSelection(self._tabs.GetIdxFromWindow(wnd))
        e.SetEventObject(self)
        if self.GetEventHandler().ProcessEvent(e):
            return
        if not e.IsAllowed():
            return

        # check if we are supposed to close on middle-up
        if self._agwFlags & AUI_NB_MIDDLE_CLICK_CLOSE == 0:
            return

        # simulate the user pressing the close button on the tab
        event.SetInt(AUI_BUTTON_CLOSE)
        self.OnTabButton(event)


    def OnTabRightDown(self, event):
        """
        Handles the ``EVT_AUINOTEBOOK_TAB_RIGHT_DOWN`` event for :class:`AuiNotebook`.

        :param `event`: a :class:`AuiNotebookEvent` event to be processed.
        """

        tabs = event.GetEventObject()
        if not tabs.GetEnabled(event.GetSelection()):
            return

        # patch event through to owner
        wnd = tabs.GetWindowFromIdx(event.GetSelection())

        e = AuiNotebookEvent(wxEVT_COMMAND_AUINOTEBOOK_TAB_RIGHT_DOWN, self.GetId())
        e.SetSelection(self._tabs.GetIdxFromWindow(wnd))
        e.SetEventObject(self)
        self.GetEventHandler().ProcessEvent(e)


    def OnTabRightUp(self, event):
        """
        Handles the ``EVT_AUINOTEBOOK_TAB_RIGHT_UP`` event for :class:`AuiNotebook`.

        :param `event`: a :class:`AuiNotebookEvent` event to be processed.
        """

        tabs = event.GetEventObject()
        if not tabs.GetEnabled(event.GetSelection()):
            return

        # patch event through to owner
        wnd = tabs.GetWindowFromIdx(event.GetSelection())

        e = AuiNotebookEvent(wxEVT_COMMAND_AUINOTEBOOK_TAB_RIGHT_UP, self.GetId())
        e.SetSelection(self._tabs.GetIdxFromWindow(wnd))
        e.SetEventObject(self)
        self.GetEventHandler().ProcessEvent(e)


    def SetNormalFont(self, font):
        """
        Sets the normal font for drawing tab labels.

        :param Font `font`: the new font to use to draw tab labels in their normal, un-selected state.
        """

        self._normal_font = font
        self.GetArtProvider().SetNormalFont(font)


    def SetSelectedFont(self, font):
        """
        Sets the selected tab font for drawing tab labels.

        :param Font `font`: the new font to use to draw tab labels in their selected state.
        """

        self._selected_font = font
        self.GetArtProvider().SetSelectedFont(font)


    def SetMeasuringFont(self, font):
        """
        Sets the font for calculating text measurements.

        :param Font `font`: the new font to use to measure tab label text extents.
        """

        self.GetArtProvider().SetMeasuringFont(font)


    def SetFont(self, font):
        """
        Sets the tab font.

        :param Font `font`: the new font to use to draw tab labels in their normal, un-selected state.

        :note: Overridden from :class:`PyPanel`.
        """

        wx.PyPanel.SetFont(self, font)

        selectedFont = wx.Font(font.GetPointSize(), font.GetFamily(),
                               font.GetStyle(), wx.BOLD, font.GetUnderlined(),
                               font.GetFaceName(), font.GetEncoding())

        self.SetNormalFont(font)
        self.SetSelectedFont(selectedFont)
        self.SetMeasuringFont(selectedFont)

        # Recalculate tab container size based on new font
        self.UpdateTabCtrlHeight(force=False)
        self.DoSizing()

        return True


    def GetTabCtrlHeight(self):
        """ Returns the tab control height. """

        return self._tab_ctrl_height


    def GetHeightForPageHeight(self, pageHeight):
        """
        Gets the height of the notebook for a given page height.

        :param integer `pageHeight`: the given page height.
        """

        self.UpdateTabCtrlHeight()

        tabCtrlHeight = self.GetTabCtrlHeight()
        decorHeight = 2
        return tabCtrlHeight + pageHeight + decorHeight


    def AdvanceSelection(self, forward=True, wrap=True):
        """
        Cycles through the tabs.

        :param bool `forward`: whether to advance forward or backward;
        :param bool `wrap`: ``True`` to return to the first tab if we reach the last tab.

        :note: The call to this function generates the page changing events.
        """

        tabCtrl = self.GetActiveTabCtrl()
        newPage = -1

        focusWin = tabCtrl.FindFocus()
        activePage = tabCtrl.GetActivePage()
        lenPages = len(tabCtrl.GetPages())

        if lenPages == 1:
            return False

        if forward:
            if lenPages > 1:

                if activePage == -1 or activePage == lenPages - 1:
                    if not wrap:
                        return False

                    newPage = 0

                elif activePage < lenPages - 1:
                    newPage = activePage + 1

        else:

            if lenPages > 1:
                if activePage == -1 or activePage == 0:
                    if not wrap:
                        return False

                    newPage = lenPages - 1

                elif activePage > 0:
                    newPage = activePage - 1


        if newPage != -1:
            if not self.GetEnabled(newPage):
                return False

            e = AuiNotebookEvent(wxEVT_COMMAND_AUINOTEBOOK_PAGE_CHANGING, tabCtrl.GetId())
            e.SetSelection(newPage)
            e.SetOldSelection(activePage)
            e.SetEventObject(tabCtrl)
            self.GetEventHandler().ProcessEvent(e)

##        if focusWin:
##            focusWin.SetFocus()

        return True


    def ShowWindowMenu(self):
        """
        Shows the window menu for the active tab control associated with this
        notebook, and returns ``True`` if a selection was made.
        """

        tabCtrl = self.GetActiveTabCtrl()
        idx = tabCtrl.GetArtProvider().ShowDropDown(tabCtrl, tabCtrl.GetPages(), tabCtrl.GetActivePage())

        if not self.GetEnabled(idx):
            return False

        if idx != -1:
            e = AuiNotebookEvent(wxEVT_COMMAND_AUINOTEBOOK_PAGE_CHANGING, tabCtrl.GetId())
            e.SetSelection(idx)
            e.SetOldSelection(tabCtrl.GetActivePage())
            e.SetEventObject(tabCtrl)
            self.GetEventHandler().ProcessEvent(e)

            return True

        else:

            return False


    def AddTabAreaButton(self, id, location, normal_bitmap=wx.NullBitmap, disabled_bitmap=wx.NullBitmap):
        """
        Adds a button in the tab area.

        :param integer `id`: the button identifier. This can be one of the following:

         ==============================  =================================
         Button Identifier               Description
         ==============================  =================================
         ``AUI_BUTTON_CLOSE``            Shows a close button on the tab area
         ``AUI_BUTTON_WINDOWLIST``       Shows a window list button on the tab area
         ``AUI_BUTTON_LEFT``             Shows a left button on the tab area
         ``AUI_BUTTON_RIGHT``            Shows a right button on the tab area
         ==============================  =================================

        :param integer `location`: the button location. Can be ``wx.LEFT`` or ``wx.RIGHT``;
        :param Bitmap `normal_bitmap`: the bitmap for an enabled tab;
        :param Bitmap `disabled_bitmap`: the bitmap for a disabled tab.
        """

        active_tabctrl = self.GetActiveTabCtrl()
        active_tabctrl.AddButton(id, location, normal_bitmap, disabled_bitmap)


    def RemoveTabAreaButton(self, id):
        """
        Removes a button from the tab area.

        :param integer `id`: the button identifier.

        :see: :meth:`AddTabAreaButton` for a list of button identifiers.
        """

        active_tabctrl = self.GetActiveTabCtrl()
        active_tabctrl.RemoveButton(id)


    def CloneTabAreaButtons(self):
        """
        Clones the tab area buttons when the :class:`AuiNotebook` is being split.

        :see: :meth:`AddTabAreaButton`
        
        :note: Standard buttons for :class:`AuiNotebook` are not cloned, only custom ones.
        """

        active_tabctrl = self.GetActiveTabCtrl()
        clones = active_tabctrl.CloneButtons()

        return clones


    def HasMultiplePages(self):
        """
        This method should be overridden to return ``True`` if this window has multiple pages. All
        standard class with multiple pages such as :class:`Notebook`, :class:`Listbook` and :class:`Treebook`
        already override it to return ``True`` and user-defined classes with similar behaviour
        should do it as well to allow the library to handle such windows appropriately.

        :note: Overridden from :class:`PyPanel`.
        """

        return True


    def GetDefaultBorder(self):
        """ Returns the default border style for :class:`AuiNotebook`. """

        return wx.BORDER_NONE


    def NotebookPreview(self, thumbnail_size=200):
        """
        Generates a preview of all the pages in the notebook (MSW and GTK only).

        :param integer `thumbnail_size`: the maximum size of every page thumbnail
         (default=200 pixels).

        :note: this functionality is currently unavailable on wxMAC.
        """

        if wx.Platform == "__WXMAC__":
            return False

        tabCtrl = self.GetActiveTabCtrl()
        activePage = tabCtrl.GetActivePage()
        pages = tabCtrl.GetPages()

        pageStatus, pageText = [], []

        for indx, page in enumerate(pages):

            pageStatus.append(page.enabled)

            if not page.enabled:
                continue

            self.SetSelectionToPage(page)
            pageText.append(page.caption)

            rect = page.window.GetScreenRect()
            bmp = RescaleScreenShot(TakeScreenShot(rect), thumbnail_size)

            page.enabled = False
            if indx == 0:
                il = wx.ImageList(bmp.GetWidth(), bmp.GetHeight(), True)

            il.Add(bmp)

        # create the list control
        listCtrl = wx.ListCtrl(self, style=wx.LC_ICON|wx.LC_AUTOARRANGE|wx.LC_HRULES|wx.LC_VRULES,
                               name="__fake__page__")

        # assign the image list to it
        listCtrl.AssignImageList(il, wx.IMAGE_LIST_NORMAL)
        listCtrl.__previousStatus = [activePage, pageStatus]

        # create some items for the list
        for indx, text in enumerate(pageText):
            listCtrl.InsertImageStringItem(10000, text, indx)

        self.AddPage(listCtrl, "AuiNotebook Preview", True, bitmap=auinotebook_preview.GetBitmap(), disabled_bitmap=wx.NullBitmap)
        return True


    def SetRenamable(self, page_idx, renamable):
        """
        Sets whether a tab can be renamed via a left double-click or not.

        :param integer `page_idx`: the page index;
        :param bool `renamable`: ``True`` if the page can be renamed.
        """

        if page_idx >= self._tabs.GetPageCount():
            return False

        # update our own tab catalog
        page_info = self._tabs.GetPage(page_idx)
        page_info.renamable = renamable

        # update what's on screen
        ctrl, ctrl_idx = self.FindTab(page_info.window)
        if not ctrl:
            return False

        info = ctrl.GetPage(ctrl_idx)
        info.renamable = page_info.renamable

        return True


    def IsRenamable(self, page_idx):
        """
        Returns whether a tab can be renamed or not.

        :param integer `page_idx`: the page index.

        :returns: ``True`` is a page can be renamed, ``False`` otherwise.
        """

        if page_idx >= self._tabs.GetPageCount():
            return False

        page_info = self._tabs.GetPage(page_idx)
        return page_info.renamable


    def OnRenameCancelled(self, page_index):
        """
        Called by :class:`TabTextCtrl`, to cancel the changes and to send the
        ``EVT_AUINOTEBOOK_END_LABEL_EDIT`` event.

        :param integer `page_index`: the page index in the notebook.
        """

        # let owner know that the edit was cancelled
        evt = AuiNotebookEvent(wxEVT_COMMAND_AUINOTEBOOK_END_LABEL_EDIT, self.GetId())

        evt.SetSelection(page_index)
        evt.SetEventObject(self)
        evt.SetLabel("")
        evt.SetEditCanceled(True)
        self.GetEventHandler().ProcessEvent(evt)


    def OnRenameAccept(self, page_index, value):
        """
        Called by :class:`TabTextCtrl`, to accept the changes and to send the
        ``EVT_AUINOTEBOOK_END_LABEL_EDIT`` event.

        :param integer `page_index`: the page index in the notebook;
        :param string `value`: the new label for the tab.
        """

        evt = AuiNotebookEvent(wxEVT_COMMAND_AUINOTEBOOK_END_LABEL_EDIT, self.GetId())
        evt.SetSelection(page_index)
        evt.SetEventObject(self)
        evt.SetLabel(value)
        evt.SetEditCanceled(False)

        return not self.GetEventHandler().ProcessEvent(evt) or evt.IsAllowed()


    def ResetTextControl(self):
        """ Called by :class:`TabTextCtrl` when it marks itself for deletion. """

        if not self._textCtrl:
            return

        self._textCtrl.Destroy()
        self._textCtrl = None

        # tab height might have changed
        self.UpdateTabCtrlHeight(force=True)


    def EditTab(self, page_index):
        """
        Starts the editing of an item label, sending a ``EVT_AUINOTEBOOK_BEGIN_LABEL_EDIT`` event.

        :param integer `page_index`: the page index we want to edit.
        """

        if page_index >= self._tabs.GetPageCount():
            return False

        if not self.IsRenamable(page_index):
            return False

        page_info = self._tabs.GetPage(page_index)
        ctrl, ctrl_idx = self.FindTab(page_info.window)
        if not ctrl:
            return False

        evt = AuiNotebookEvent(wxEVT_COMMAND_AUINOTEBOOK_BEGIN_LABEL_EDIT, self.GetId())
        evt.SetSelection(page_index)
        evt.SetEventObject(self)
        if self.GetEventHandler().ProcessEvent(evt) and not evt.IsAllowed():
            # vetoed by user
            return False

        if self._textCtrl is not None and page_info != self._textCtrl.item():
            self._textCtrl.StopEditing()

        self._textCtrl = TabTextCtrl(ctrl, page_info, page_index)
        self._textCtrl.SetFocus()

        return True

########NEW FILE########
__FILENAME__ = aui_constants
"""
This module contains all the constants used by wxPython-AUI.

Especially important and meaningful are constants for AuiManager, AuiDockArt and
AuiNotebook.
"""

__author__ = "Andrea Gavana <andrea.gavana@gmail.com>"
__date__ = "31 March 2009"


import wx
from wx.lib.embeddedimage import PyEmbeddedImage

# ------------------------- #
# - AuiNotebook Constants - #
# ------------------------- #

# For tabart
# --------------

vertical_border_padding = 4
""" Border padding used in drawing tabs. """

if wx.Platform == "__WXMAC__":
    nb_close_bits = "\xFF\xFF\xFF\xFF\x0F\xFE\x03\xF8\x01\xF0\x19\xF3" \
                    "\xB8\xE3\xF0\xE1\xE0\xE0\xF0\xE1\xB8\xE3\x19\xF3" \
                    "\x01\xF0\x03\xF8\x0F\xFE\xFF\xFF"
    """ AuiNotebook close button image on wxMAC. """

elif wx.Platform == "__WXGTK__":
    nb_close_bits = "\xff\xff\xff\xff\x07\xf0\xfb\xef\xdb\xed\x8b\xe8" \
                    "\x1b\xec\x3b\xee\x1b\xec\x8b\xe8\xdb\xed\xfb\xef" \
                    "\x07\xf0\xff\xff\xff\xff\xff\xff"
    """ AuiNotebook close button image on wxGTK. """

else:
    nb_close_bits = "\xff\xff\xff\xff\xff\xff\xff\xff\xe7\xf3\xcf\xf9" \
                    "\x9f\xfc\x3f\xfe\x3f\xfe\x9f\xfc\xcf\xf9\xe7\xf3" \
                    "\xff\xff\xff\xff\xff\xff\xff\xff"
    """ AuiNotebook close button image on wxMSW. """

nb_left_bits = "\xff\xff\xff\xff\xff\xff\xff\xfe\x7f\xfe\x3f\xfe\x1f" \
               "\xfe\x0f\xfe\x1f\xfe\x3f\xfe\x7f\xfe\xff\xfe\xff\xff" \
               "\xff\xff\xff\xff\xff\xff"
""" AuiNotebook left button image. """

nb_right_bits = "\xff\xff\xff\xff\xff\xff\xdf\xff\x9f\xff\x1f\xff\x1f" \
                "\xfe\x1f\xfc\x1f\xfe\x1f\xff\x9f\xff\xdf\xff\xff\xff" \
                "\xff\xff\xff\xff\xff\xff"
""" AuiNotebook right button image. """

nb_list_bits = "\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x0f" \
               "\xf8\xff\xff\x0f\xf8\x1f\xfc\x3f\xfe\x7f\xff\xff\xff" \
               "\xff\xff\xff\xff\xff\xff"
""" AuiNotebook windows list button image. """


#----------------------------------------------------------------------
tab_active_center = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAAAEAAAAbCAYAAAC9WOV0AAAABHNCSVQICAgIfAhkiAAAADNJ"
    "REFUCJltzMEJwDAUw9DHX6OLdP/Bop4KDc3F2EIYrsFtrZow8GnH6OD1zvRTajvY2QMHIhNx"
    "jUhuAgAAAABJRU5ErkJggg==")
""" Center active tab image for the Chrome tab art. """

#----------------------------------------------------------------------
tab_active_left = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAAA8AAAAbCAYAAACjkdXHAAAABHNCSVQICAgIfAhkiAAAAglJ"
    "REFUOI2Nkk9rE0EYh5/J7mpW06xE2iSmeFHxEoqIAc/FQ5CKgn4DP4KlIQG/QVsQbBEKgop+"
    "Anvy4rV4bLT2JCGJPVXqwaZJd+f1kN26WTfJDrzszDLPPL/5o0jeFGAC54A0YKmEYAo4DzjA"
    "LHAZmElqtIGrhmEsvtzcfPNtb6/V6524SWALKBiGsfhxe/uzFhGth5XEmgVubWxsvA1Az68k"
    "1nngYbPZ7ASg69c06wxwe3V9/b3reVqHwGmwCZRs2370fX//wIuA0+CLwEKj0XilZTSu602G"
    "FcP7vLe7+7XlRaCgPw62gGv5fP6p63raiwFdLWKOgdNArl6vV1UqpQgcYdcYbwooAPfb7c7h"
    "mTWmUjGwCWTL5fL1K6VSLiqQyMTYyLVa/UEwe9IC0chFYKnb/XnkeiIDV+Q0UsG/qNkCnEql"
    "crNQLDpaxpskJnYayD1bXl4S/xrDoPLHKjQOmsHwlCuHv44+ZJ2sLTrGGqzg7zEc+VK1Wl1w"
    "HMcG0DFxw6sFsRVwAZhdWak9FoRJ+w2HCKzzwN3jXv+daVmGDkdWoMKb9fumHz0DFFfX1p5Y"
    "lmXo6N0G48jzVEDOt97pdA9ezOXzGU+PzBmN6VuDqyoDN3Z2vjyfKxQynhYkJuJ/L02Ara3X"
    "n3602r8HrpaTUy3HAy1/+hNq8O+r+q4WETirmFMNBwm3v+gdmytKNIUpAAAAAElFTkSuQmCC")
""" Left active tab image for the Chrome tab art. """

#----------------------------------------------------------------------
tab_active_right = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAAA8AAAAbCAYAAACjkdXHAAAABHNCSVQICAgIfAhkiAAAAkpJ"
    "REFUOI2NlM1rU0EUxX9zZ5KaWq3GKKnGutC0FEWCWAWLRUOxBetK/wdp6Re6F6TFXXGhuFdw"
    "b7dCQUUpiFt1XbB2q7Uf1iTvunjzkpe0afNgmLnDnHvOPe/OWCALtAFC+Cktfha4CRwBDnhg"
    "BQhaSrK19bf89dv35WfPX7y01haBbiAFmH3BlUA1Gm8WFt75BFkg0TK4VAl0Y3NL5+efvgIK"
    "wOH92EVjxRljGBi4VgTOeLDbk7kcqEZju1TWX7/Xgtm5J6+BS8ChvdilLhAhkUya4eFbxVQq"
    "1e3ZbUtgg8GKJd/Tk70/NjYCHCPsgX1kV8K5VA70z8amfvy0tAwMAcebSRfijikY8ez5/OlM"
    "JrOncbIjp4K1lmRb0sw8eDgCpAm7rwlz46YIzjpGb48WveyDNPhDfCOuHmNwzpHL5dK9fX3n"
    "mkmvaxJiayOCWMvM1PSdZtJrhiloLJMYIeESDFwf7Acyu0mXGLYmX0PpYi3ZbFdnoVDoBTpp"
    "uCxCjFob1tYKzlnGJyZHd5Mu6uVGkqvMCmCwzjE4eOMqcALoINauUic37hjhLXPWcTSdThWL"
    "QxcJX5yqdGk4H/cP9a4755iYnLpL+M/b8e0qjafrekb9TUskuNx/5TzQ5Y1zO9yOZEd1R7OI"
    "JdXebh/Pzt3zCToAMZv/AjU1orDWWKAGVJVSqcTqysp6X+/ZaeAL8KNac9wsVQ8yNeOsdZw8"
    "let4/2HpEdAPXDAb20HLj7xqeHT158ra4uLbz2bdg03krmetxrH9KDAmHP8Bn0j1t/01UV0A"
    "AAAASUVORK5CYII=")
""" Right active tab image for the Chrome tab art. """

#----------------------------------------------------------------------
tab_close = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAAAwAAAAMCAYAAABWdVznAAAABHNCSVQICAgIfAhkiAAAAI9J"
    "REFUKJG90MEKAWEUxfEfM4rxAFIommzZzNb7v4BsLJTsiGQlYjHfME3flrO75/xvnXv5p/qY"
    "R/wcWTUktWCKFbrYB6/AAhecmwunAI/RwQAjbLGpoFakwjLATxzqMLQjC68A3/FohkljLkKN"
    "Ha4YKg8+VkBag3Pll9a1GikmuPk+4qMMs0jFMXoR/0d6A9JRFV/jxY+iAAAAAElFTkSuQmCC")
""" Normal close button image for the Chrome tab art. """

#----------------------------------------------------------------------
tab_close_h = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAAAwAAAAMCAYAAABWdVznAAAABHNCSVQICAgIfAhkiAAAAOlJ"
    "REFUKJGVkiFuw0AQRd849hUS7iPUwGEllhyjYJ+gaK9Q4CsY9QTFIY4shQQucI8Q7l6h3Z0S"
    "r7UgjdrPZvVm52k0wpJLWe4y51qgVpECQFQnYPzabN4ra2cAAbgWxZMmyavAkTtROIn33fM0"
    "fcilLHep92+/wXHTd5K8JJlzbYD3w8C2aVZo2zTsh4FF5Zg516ZAHYBb35MbszbkxnDr+3hQ"
    "napIIUv1eT6vYPggvAGoSJE88r6XVFQnRA7BOdYIk8IUUZ1SYAQOsXOskRsT1+P/11pZO4v3"
    "ncLpESzed5W1c1jQn0/jBzPfck1qdmfjAAAAAElFTkSuQmCC")
""" Hover close button image for the Chrome tab art. """

#----------------------------------------------------------------------
tab_close_p = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAAAwAAAAMCAYAAABWdVznAAAABHNCSVQICAgIfAhkiAAAASxJ"
    "REFUKJF9kbFLQlEYxX/nvbs55OAkiJAE7k7Nibo9xf+hrTlyr3Boipb+BCGq0bApJEQcG0Ms"
    "aQ0Lmq5+Dc+nDtbZ7uHce37fd8VSlWwh50PfRKqClWJXI8y6bu5uHj5e3wEEcJDP75txLBSx"
    "RYbdS7QfJ5PnsJIt5BbB4hQjkrQtjxlFILOXyvQDH/qmUCSJznDAYetkFTxsndAZDggkhCIf"
    "+qaLmWP1bu8oN+qrC+VGnd7t3bpKqrp4wBjl+ux8FUweSLwlXCnYCv2PHGgE1BLmTYykad2i"
    "kcOsi1TbZN7EKDfq67NZV5VsIeedvzQjCv5YK8R/4bw7Cl+/P7920+kJkBEq/hWWaPem45cQ"
    "YDybTfdSmf5CizckwHaAH9ATZldu7i560/ELwC+6RXdU6KzezAAAAABJRU5ErkJggg==")
""" Pressed close button image for the Chrome tab art. """

#----------------------------------------------------------------------
tab_inactive_center = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAAAEAAAAbCAYAAAC9WOV0AAAABHNCSVQICAgIfAhkiAAAAElJ"
    "REFUCJlVyiEOgDAUBNHp3qmX5iYkyMpqBAaFILRdDGn4qybZB98yy3ZZrRu1PpABAQiDSLN+"
    "h4NLEU8CBAfoPHZUywr3M/wCTz8c3/qQrUcAAAAASUVORK5CYII=")
""" Center inactive tab image for the Chrome tab art. """

#----------------------------------------------------------------------
tab_inactive_left = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAAA8AAAAbCAYAAACjkdXHAAAABHNCSVQICAgIfAhkiAAAAf5J"
    "REFUOI2llE1rE1EUhp8bZwyhaZomk5DaD40hSWPQVkTd6KIIEUWlLqTEhTaLulBQ6sfKjeBC"
    "ECULXQku/Alx7d6/U1EQae45LjJpJ5NOnOKBgYG5z33Px3sG/iPMIc87QAmYBZKHgdOu69a2"
    "3/W2yrVGK5vPLTlxFV3Xrb3+8v1Ntd5oiSpWBmnEidKT972tar3R6ovSt4qoxoIdoFipNlpW"
    "B6AVRYFEHNWn3a8dz/PK1rIHEgN2UpnMseVTK7fUGBME48CFe88+3sh5+SXr1xmMSbABvJXz"
    "l9siYAVGWJ0Mu/OVZr5Q8CpWfFWzD2Imj2qu/fhtG4wRVUIZg0bDBsgtn15dt6qIKKBDQZ81"
    "kWmnzly6OZ+ZzhSt7jfK6CBjFMwEk5TWOy82AVQGhzVUb5RJEkC2fLK6JgIiPhioeZJJUhev"
    "3j2RTqdzooqge2ojCxwxqrnrG4/uq4Ida3HgAjMOJ4CZSq1+RVBUzCgQinDDstfa282jyeTU"
    "rhUGF4CJgMPKhbXbmw9VFfG7fBA4LCao7AAzi8cXz1kF0dENMqH38KgWnnd7nSMJxxE5wI4+"
    "MHyCaeeAYvPshQ0RJby3wVSDHxxgAVh99elb9/evndmfP3boW2FsqGNhMMCdBy8/fJ5KZ6at"
    "qL+3Q1dEzFkNGMX82ZWh18e0/vVT/wuFmdYVv/ruKgAAAABJRU5ErkJggg==")
""" Left inactive tab image for the Chrome tab art. """

#----------------------------------------------------------------------
tab_inactive_right = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAAA8AAAAbCAYAAACjkdXHAAAABHNCSVQICAgIfAhkiAAAAhBJ"
    "REFUOI2llM9rE1EQxz8zb1dSTKNuYtW01kQDRoKFWi9FEEq1IooUUWoPokWCtVqkR69KsSBU"
    "8OJRPOhBxZNe/At6FBER/HFUPEq1IGn3ecgm2ZjdJODCHPY9vvP9fufNDPzHZ4DDQBrYBKwB"
    "ftfoJys/Kw9ef/1y8/6rh67rHgKS3WLl6cqqtcCGD58+vn+zdPXorUql8g5Y7wTWdd+y4Vus"
    "teQK+yfKi8/KwM5umBXAAgioCIP54gTQBzgdwTbsQZR0JpOfXXw+0w27hn9EBGMcyRcPnulJ"
    "pbKd2JvACKgKnpcePH99+TSwvT3YEphusKsqB4ZHp4FMNWUn5loSEVSFbZ63b8eeUhpwu5Md"
    "JBFRjHHk7LXb08CuNuAaZTgEEaFQHJoEvDjpakOYmnURUFWSvam+0ujJfqAnmlnABhG2jlTZ"
    "j19YuEzMm7dUu34hihrDQG7vGLCViPq0VruuvdquyWSvN3xsKhclvbXaoUQiihFlfLJ8iYiq"
    "O/EtUC2xGGF3vjAObAnI6stCsZbYCLwnEonNY+dulALvHWSH2YN2PXLq4hz/9HpjnmOs18DZ"
    "bP9IIL0+afV5juqzRgLFcV1n9u6LGWAgWnaMBFHBOIbi0MgU1S3jAcjyyw9xqpvzWou1Pj++"
    "f/t8b/7EAvBW5u48agU37abWs99rv1YfL81fkT8V34YxbZ696d4CfwEszZSZx6Z26wAAAABJ"
    "RU5ErkJggg==")
""" Right inactive tab image for the Chrome tab art. """

# For auibook
# -----------

AuiBaseTabCtrlId = 5380
""" Base window identifier for AuiTabCtrl. """

AUI_NB_TOP                 = 1 << 0
""" With this style, tabs are drawn along the top of the notebook. """
AUI_NB_LEFT                = 1 << 1  # not implemented yet
""" With this style, tabs are drawn along the left of the notebook.
Not implemented yet. """
AUI_NB_RIGHT               = 1 << 2  # not implemented yet
""" With this style, tabs are drawn along the right of the notebook.
Not implemented yet. """
AUI_NB_BOTTOM              = 1 << 3
""" With this style, tabs are drawn along the bottom of the notebook. """
AUI_NB_TAB_SPLIT           = 1 << 4
""" Allows the tab control to be split by dragging a tab. """
AUI_NB_TAB_MOVE            = 1 << 5
""" Allows a tab to be moved horizontally by dragging. """
AUI_NB_TAB_EXTERNAL_MOVE   = 1 << 6
""" Allows a tab to be moved to another tab control. """
AUI_NB_TAB_FIXED_WIDTH     = 1 << 7
""" With this style, all tabs have the same width. """
AUI_NB_SCROLL_BUTTONS      = 1 << 8
""" With this style, left and right scroll buttons are displayed. """
AUI_NB_WINDOWLIST_BUTTON   = 1 << 9
""" With this style, a drop-down list of windows is available. """
AUI_NB_CLOSE_BUTTON        = 1 << 10
""" With this style, a close button is available on the tab bar. """
AUI_NB_CLOSE_ON_ACTIVE_TAB = 1 << 11
""" With this style, a close button is available on the active tab. """
AUI_NB_CLOSE_ON_ALL_TABS   = 1 << 12
""" With this style, a close button is available on all tabs. """
AUI_NB_MIDDLE_CLICK_CLOSE  = 1 << 13
""" Allows to close `AuiNotebook` tabs by mouse middle button click. """
AUI_NB_SUB_NOTEBOOK        = 1 << 14
""" This style is used by `AuiManager` to create automatic `AuiNotebooks`. """
AUI_NB_HIDE_ON_SINGLE_TAB  = 1 << 15
""" Hides the tab window if only one tab is present. """
AUI_NB_SMART_TABS          = 1 << 16
""" Use `Smart Tabbing`, like ``Alt`` + ``Tab`` on Windows. """
AUI_NB_USE_IMAGES_DROPDOWN = 1 << 17
""" Uses images on dropdown window list menu instead of check items. """
AUI_NB_CLOSE_ON_TAB_LEFT   = 1 << 18
""" Draws the tab close button on the left instead of on the right
(a la Camino browser). """
AUI_NB_TAB_FLOAT           = 1 << 19
""" Allows the floating of single tabs.
Known limitation: when the notebook is more or less full screen, tabs
cannot be dragged far enough outside of the notebook to become
floating pages. """
AUI_NB_DRAW_DND_TAB        = 1 << 20
""" Draws an image representation of a tab while dragging. """
AUI_NB_ORDER_BY_ACCESS     = 1 << 21
""" Tab navigation order by last access time. """
AUI_NB_NO_TAB_FOCUS        = 1 << 22
""" Don't draw tab focus rectangle. """

AUI_NB_DEFAULT_STYLE = AUI_NB_TOP | AUI_NB_TAB_SPLIT | AUI_NB_TAB_MOVE | \
                       AUI_NB_SCROLL_BUTTONS | AUI_NB_CLOSE_ON_ACTIVE_TAB | \
                       AUI_NB_MIDDLE_CLICK_CLOSE | AUI_NB_DRAW_DND_TAB
""" Default `AuiNotebook` style. """

#----------------------------------------------------------------------
Mondrian = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABHNCSVQICAgIfAhkiAAAAHFJ"
    "REFUWIXt1jsKgDAQRdF7xY25cpcWC60kioI6Fm/ahHBCMh+BRmGMnAgEWnvPpzK8dvrFCCCA"
    "coD8og4c5Lr6WB3Q3l1TBwLYPuF3YS1gn1HphgEEEABcKERrGy0E3B0HFJg7C1N/f/kTBBBA"
    "+Vi+AMkgFEvBPD17AAAAAElFTkSuQmCC")
""" Default icon for the Smart Tabbing dialog. """

# -------------------------- #
# - FrameManager Constants - #
# -------------------------- #

# Docking Styles
AUI_DOCK_NONE = 0
""" No docking direction. """
AUI_DOCK_TOP = 1
""" Top docking direction. """
AUI_DOCK_RIGHT = 2
""" Right docking direction. """
AUI_DOCK_BOTTOM = 3
""" Bottom docking direction. """
AUI_DOCK_LEFT = 4
""" Left docking direction. """
AUI_DOCK_CENTER = 5
""" Center docking direction. """
AUI_DOCK_CENTRE = AUI_DOCK_CENTER
""" Centre docking direction. """
AUI_DOCK_NOTEBOOK_PAGE = 6
""" Automatic AuiNotebooks docking style. """

# Floating/Dragging Styles
AUI_MGR_ALLOW_FLOATING           = 1 << 0
""" Allow floating of panes. """
AUI_MGR_ALLOW_ACTIVE_PANE        = 1 << 1
""" If a pane becomes active, "highlight" it in the interface. """
AUI_MGR_TRANSPARENT_DRAG         = 1 << 2
""" If the platform supports it, set transparency on a floating pane
while it is dragged by the user. """
AUI_MGR_TRANSPARENT_HINT         = 1 << 3
""" If the platform supports it, show a transparent hint window when
the user is about to dock a floating pane. """
AUI_MGR_VENETIAN_BLINDS_HINT     = 1 << 4
""" Show a "venetian blind" effect when the user is about to dock a
floating pane. """
AUI_MGR_RECTANGLE_HINT           = 1 << 5
""" Show a rectangle hint effect when the user is about to dock a
floating pane. """
AUI_MGR_HINT_FADE                = 1 << 6
""" If the platform supports it, the hint window will fade in and out. """
AUI_MGR_NO_VENETIAN_BLINDS_FADE  = 1 << 7
""" Disables the "venetian blind" fade in and out. """
AUI_MGR_LIVE_RESIZE              = 1 << 8
""" Live resize when the user drag a sash. """
AUI_MGR_ANIMATE_FRAMES           = 1 << 9
""" Fade-out floating panes when they are closed (all platforms which support
frames transparency) and show a moving rectangle when they are docked
(Windows < Vista and GTK only). """
AUI_MGR_AERO_DOCKING_GUIDES      = 1 << 10
""" Use the new Aero-style bitmaps as docking guides. """
AUI_MGR_PREVIEW_MINIMIZED_PANES  = 1 << 11
""" Slide in and out minimized panes to preview them. """
AUI_MGR_WHIDBEY_DOCKING_GUIDES   = 1 << 12
""" Use the new Whidbey-style bitmaps as docking guides. """
AUI_MGR_SMOOTH_DOCKING           = 1 << 13
""" Performs a "smooth" docking of panes (a la PyQT). """
AUI_MGR_USE_NATIVE_MINIFRAMES    = 1 << 14
""" Use miniframes with native caption bar as floating panes instead or custom
drawn caption bars (forced on wxMac). """
AUI_MGR_AUTONB_NO_CAPTION        = 1 << 15
""" Panes that merge into an automatic notebook will not have the pane
caption visible. """


AUI_MGR_DEFAULT = AUI_MGR_ALLOW_FLOATING | AUI_MGR_TRANSPARENT_HINT | \
                  AUI_MGR_HINT_FADE | AUI_MGR_NO_VENETIAN_BLINDS_FADE
""" Default `AuiManager` style. """

# Panes Customization
AUI_DOCKART_SASH_SIZE = 0
""" Customizes the sash size. """
AUI_DOCKART_CAPTION_SIZE = 1
""" Customizes the caption size. """
AUI_DOCKART_GRIPPER_SIZE = 2
""" Customizes the gripper size. """
AUI_DOCKART_PANE_BORDER_SIZE = 3
""" Customizes the pane border size. """
AUI_DOCKART_PANE_BUTTON_SIZE = 4
""" Customizes the pane button size. """
AUI_DOCKART_BACKGROUND_COLOUR = 5
""" Customizes the background colour. """
AUI_DOCKART_BACKGROUND_GRADIENT_COLOUR = 6
""" Customizes the background gradient colour. """
AUI_DOCKART_SASH_COLOUR = 7
""" Customizes the sash colour. """
AUI_DOCKART_ACTIVE_CAPTION_COLOUR = 8
""" Customizes the active caption colour. """
AUI_DOCKART_ACTIVE_CAPTION_GRADIENT_COLOUR = 9
""" Customizes the active caption gradient colour. """
AUI_DOCKART_INACTIVE_CAPTION_COLOUR = 10
""" Customizes the inactive caption colour. """
AUI_DOCKART_INACTIVE_CAPTION_GRADIENT_COLOUR = 11
""" Customizes the inactive gradient caption colour. """
AUI_DOCKART_ACTIVE_CAPTION_TEXT_COLOUR = 12
""" Customizes the active caption text colour. """
AUI_DOCKART_INACTIVE_CAPTION_TEXT_COLOUR = 13
""" Customizes the inactive caption text colour. """
AUI_DOCKART_BORDER_COLOUR = 14
""" Customizes the border colour. """
AUI_DOCKART_GRIPPER_COLOUR = 15
""" Customizes the gripper colour. """
AUI_DOCKART_CAPTION_FONT = 16
""" Customizes the caption font. """
AUI_DOCKART_GRADIENT_TYPE = 17
""" Customizes the gradient type (no gradient, vertical or horizontal). """
AUI_DOCKART_DRAW_SASH_GRIP = 18
""" Draw a sash grip on the sash. """
AUI_DOCKART_HINT_WINDOW_COLOUR = 19
""" Customizes the hint window background colour (currently light blue). """

# Caption Gradient Type
AUI_GRADIENT_NONE = 0
""" No gradient on the captions. """
AUI_GRADIENT_VERTICAL = 1
""" Vertical gradient on the captions. """
AUI_GRADIENT_HORIZONTAL = 2
""" Horizontal gradient on the captions. """

# Pane Button State
AUI_BUTTON_STATE_NORMAL = 0
""" Normal button state. """
AUI_BUTTON_STATE_HOVER = 1 << 1
""" Hovered button state. """
AUI_BUTTON_STATE_PRESSED = 1 << 2
""" Pressed button state. """
AUI_BUTTON_STATE_DISABLED = 1 << 3
""" Disabled button state. """
AUI_BUTTON_STATE_HIDDEN   = 1 << 4
""" Hidden button state. """
AUI_BUTTON_STATE_CHECKED  = 1 << 5
""" Checked button state. """

# Pane minimize mode
AUI_MINIMIZE_POS_SMART    = 0x01
""" Minimizes the pane on the closest tool bar. """
AUI_MINIMIZE_POS_TOP      = 0x02
""" Minimizes the pane on the top tool bar. """
AUI_MINIMIZE_POS_LEFT     = 0x03
""" Minimizes the pane on its left tool bar. """
AUI_MINIMIZE_POS_RIGHT    = 0x04
""" Minimizes the pane on its right tool bar. """
AUI_MINIMIZE_POS_BOTTOM   = 0x05
""" Minimizes the pane on its bottom tool bar. """
AUI_MINIMIZE_POS_TOOLBAR  = 0x06
""" Minimizes the pane on its bottom tool bar. """
AUI_MINIMIZE_POS_MASK     = 0x17
""" Mask to filter the position flags. """
AUI_MINIMIZE_CAPT_HIDE    = 0
""" Hides the caption of the minimized pane. """
AUI_MINIMIZE_CAPT_SMART   = 0x08
""" Displays the caption in the best rotation (horz or clockwise). """
AUI_MINIMIZE_CAPT_HORZ    = 0x10
""" Displays the caption horizontally. """
AUI_MINIMIZE_CAPT_MASK    = 0x18
""" Mask to filter the caption flags. """

# Button kind
AUI_BUTTON_CLOSE = 101
""" Shows a close button on the pane. """
AUI_BUTTON_MAXIMIZE_RESTORE = 102
""" Shows a maximize/restore button on the pane. """
AUI_BUTTON_MINIMIZE = 103
""" Shows a minimize button on the pane. """
AUI_BUTTON_PIN = 104
""" Shows a pin button on the pane. """
AUI_BUTTON_OPTIONS = 105
""" Shows an option button on the pane (not implemented). """
AUI_BUTTON_WINDOWLIST = 106
""" Shows a window list button on the pane (for AuiNotebook). """
AUI_BUTTON_LEFT = 107
""" Shows a left button on the pane (for AuiNotebook). """
AUI_BUTTON_RIGHT = 108
""" Shows a right button on the pane (for AuiNotebook). """
AUI_BUTTON_UP = 109
""" Shows an up button on the pane (not implemented). """
AUI_BUTTON_DOWN = 110
""" Shows a down button on the pane (not implemented). """
AUI_BUTTON_CUSTOM1 = 201
""" Shows a custom button on the pane. """
AUI_BUTTON_CUSTOM2 = 202
""" Shows a custom button on the pane. """
AUI_BUTTON_CUSTOM3 = 203
""" Shows a custom button on the pane. """
AUI_BUTTON_CUSTOM4 = 204
""" Shows a custom button on the pane. """
AUI_BUTTON_CUSTOM5 = 205
""" Shows a custom button on the pane. """
AUI_BUTTON_CUSTOM6 = 206
""" Shows a custom button on the pane. """
AUI_BUTTON_CUSTOM7 = 207
""" Shows a custom button on the pane. """
AUI_BUTTON_CUSTOM8 = 208
""" Shows a custom button on the pane. """
AUI_BUTTON_CUSTOM9 = 209
""" Shows a custom button on the pane. """

# Pane Insert Level
AUI_INSERT_PANE = 0
""" Level for inserting a pane. """
AUI_INSERT_ROW = 1
""" Level for inserting a row. """
AUI_INSERT_DOCK = 2
""" Level for inserting a dock. """

# Action constants
actionNone = 0
""" No current action. """
actionResize = 1
""" Resize action. """
actionClickButton = 2
""" Click on a pane button action. """
actionClickCaption = 3
""" Click on a pane caption action. """
actionDragToolbarPane = 4
""" Drag a floating toolbar action. """
actionDragFloatingPane = 5
""" Drag a floating pane action. """
actionDragMovablePane = 6
""" Move a pane action. """

# Drop/Float constants
auiInsertRowPixels = 10
""" Number of pixels between rows. """
auiNewRowPixels = 40
""" Number of pixels for a new inserted row. """
auiLayerInsertPixels = 40
""" Number of pixels between layers. """
auiLayerInsertOffset = 5
""" Number of offset pixels between layers. """
auiToolBarLayer = 10
""" AUI layer for a toolbar. """

# some built in bitmaps

if wx.Platform == "__WXMAC__":

    close_bits = "\xFF\xFF\xFF\xFF\x0F\xFE\x03\xF8\x01\xF0\x19\xF3\xB8\xE3\xF0" \
                 "\xE1\xE0\xE0\xF0\xE1\xB8\xE3\x19\xF3\x01\xF0\x03\xF8\x0F\xFE\xFF\xFF"
    """ Close button bitmap for a pane on wxMAC. """

elif wx.Platform == "__WXGTK__":

    close_bits = "\xff\xff\xff\xff\x07\xf0\xfb\xef\xdb\xed\x8b\xe8\x1b\xec\x3b\xee" \
                 "\x1b\xec\x8b\xe8\xdb\xed\xfb\xef\x07\xf0\xff\xff\xff\xff\xff\xff"
    """ Close button bitmap for a pane on wxGTK. """

else:

    close_bits = "\xff\xff\xff\xff\xff\xff\xff\xff\xcf\xf3\x9f\xf9\x3f\xfc\x7f\xfe" \
                 "\x3f\xfc\x9f\xf9\xcf\xf3\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"
    """ Close button bitmap for a pane on wxMSW. """

pin_bits     = '\xff\xff\xff\xff\xff\xff\x1f\xfc\xdf\xfc\xdf\xfc\xdf\xfc\xdf\xfc' \
               '\xdf\xfc\x0f\xf8\x7f\xff\x7f\xff\x7f\xff\xff\xff\xff\xff\xff\xff'
""" Pin button bitmap for a pane. """

max_bits     = '\xff\xff\xff\xff\xff\xff\x07\xf0\xf7\xf7\x07\xf0\xf7\xf7\xf7\xf7' \
               '\xf7\xf7\xf7\xf7\xf7\xf7\x07\xf0\xff\xff\xff\xff\xff\xff\xff\xff'
""" Maximize button bitmap for a pane. """

restore_bits = '\xff\xff\xff\xff\xff\xff\x1f\xf0\x1f\xf0\xdf\xf7\x07\xf4\x07\xf4' \
               '\xf7\xf5\xf7\xf1\xf7\xfd\xf7\xfd\x07\xfc\xff\xff\xff\xff\xff\xff'
""" Restore/maximize button bitmap for a pane. """

minimize_bits = '\xff\xff\xff\xff\xff\xff\x07\xf0\xf7\xf7\x07\xf0\xff\xff\xff\xff' \
                '\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff'
""" Minimize button bitmap for a pane. """

restore_xpm = ["16 15 3 1",
               "       c None",
               ".      c #000000",
               "+      c #FFFFFF",
               "                ",
               "     .......... ",
               "     .++++++++. ",
               "     .......... ",
               "     .++++++++. ",
               " ..........+++. ",
               " .++++++++.+++. ",
               " ..........+++. ",
               " .++++++++..... ",
               " .++++++++.     ",
               " .++++++++.     ",
               " .++++++++.     ",
               " .++++++++.     ",
               " ..........     ",
               "                "]
""" Restore/minimize button bitmap for a pane. """

#----------------------------------------------------------------------

down_focus_single = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAAB0AAAAgCAIAAABhFeQrAAAAA3NCSVQICAjb4U/gAAACaUlE"
    "QVRIib2WvWsUQRjGn5mdnWxyTaqz9q+QlLnGToSgWAYDNjbpNCAGDGIvaRPbNJGQyiAEbK+w"
    "sAo2qexyEhbxsvt+jMXc3u3liPfhmWeXnWVm9vc+vO/M7prVzTb+gxyA7Ye/nXPWWmvtXKBb"
    "B9YBcM5lWZam6by4QNcBsNamaeq9d87NmWutdc59+NgGoKIizCwsxMTMFI8oZmZilzomZiFm"
    "FWERaXbv7eyueO+TJEHM79LSkvfeWnv2qftgex2ASGDmkrUkKUspiIuCy5IL4qKQgnghdQVx"
    "ScKsxCKiaH8lIu99NOwAEFGsG4Dv5xeiQYOKBBYVUWJlFhIVVmIlEZGQJKVIYBbWoKqqwQN5"
    "nqdpuri42OMys6rGOG/X78yW0bXWNyLqcyyAEEIIYcYK3aB5Lazb4o5fsPc3ToFaloxBwMle"
    "6+9Pjfd7stda6HR85+dCPC86Y6ETcQEcHz32eZ7meZrnx0ePJnlk0vwenm70r/PkTgWdjjuV"
    "rnPPfvxaa+3NcL3GMaub7XdPtNFoZFn24tmX1/trAOLuM6aaFQwQYExAMPWNaUw1FW+eHj5/"
    "dbfZbDYajY33F7e1L4gUA5uo3fd8AWbQH70bjGqEyxLq3LoMYhKCgakCIWZoLLdkMRE43Iy0"
    "tWi9QOP8xoIFAyBUjF7dgOizb9iMhLmByxIAHbAGKYigUPX3hqog47hSvfCHfYRaDcNg3IzO"
    "7GmydRaGi37zMujrut/9l58nijROQ9yd3ZXLy8urq6vZWFmW9f+Yhrje++XlZR2keDpZa4f+"
    "H/pKkiR+/f9dDsDWgQW6QHcuxKg/ZbVtCjjzINkAAAAASUVORK5CYII=")
""" VS2005 focused docking guide window down bitmap. """

#----------------------------------------------------------------------
down_single = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAAB0AAAAgCAIAAABhFeQrAAAAA3NCSVQICAjb4U/gAAACY0lE"
    "QVRIib2WwWrUUBSG/3tzc5s2m0JhXPsU0u1s3Lkpui4W3PgAuhAFi2/QbesTVEphwCIU3Hbh"
    "wk2LG1fujJQgtMk55x4Xd2aS6VAzM479JyQhufnOz3/uzcQMBgP8BzkAeZ4756y11tqlQIui"
    "cACcc1mWpWm6ZK61Nk1T771zbilcxBxiAs659x/OAAQJIswsLMTEzBR/UczMxC51TMxCzEGE"
    "RaR39WB3b9N7nyTJkLu2tua9t9ZefLx69GYbgIgyc82hJqlrqYiriuuaK+Kqkop4JXUVcU3C"
    "HIhFJODsCxF57xu/RBT7BuDb958SNGgQUZYgEogDs5AE4UAcSEREk6QWUWbhoCGEENQDZVmm"
    "abq6ujrkMnMIIdZ5t31vsUC3+l+JaMyxAFRVVRds0C1azsS6O273hH24cwq0UjIGipP9/t+f"
    "6vZ7st9fKQpf/FqJ28+iEzoTF8Dx0RNflmlZpmV5fPR4lkdmzffwdGe8XyZ3Luh83Ll0k3vx"
    "4/dWf3+B/Q2OGQwGGxsbeZ5nWfbi2efXB1sA4uozZjRKDaAwRqGmvTCNGQ3F26eHz1/d7/V6"
    "eZ6fn5/f1bogCmhsonU+9AWY5nr0bjCtKS6LtrltGcQQ1MCMCiEm1MmtWUwETh6mjq1qw0Jd"
    "fmPD1ADQEWPYNyD6HBs2U2Vu4bIoEBpWE0EE6ej68NaoSBdXRi/8SR/a6qE29830yKFmm2c6"
    "2fTbp8FYN/0evPw0U6UuTXB39zYvLy+vr68XY2VZNv5imuB679fX10MT8Xyy1k58P4yVJEn8"
    "9/93OQBFURRFsRTcWH8An5lwqISXsWUAAAAASUVORK5CYII=")
""" VS2005 unfocused docking guide window down bitmap. """

#----------------------------------------------------------------------
left_focus_single = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAACAAAAAdCAIAAABE/PnQAAAAA3NCSVQICAjb4U/gAAACVElE"
    "QVRIibWWvW8TQRDF3+7Ors8ShSsaSpo0dEgoFcINVChSBFRUkajpIKKgiPgP0pqGJiAhITqE"
    "FIk2BQUVHT2VK+y7ndmhWN/5Ixcbh8tYWvtO8vvdm5mdPXPv+RmuMgjA670/RGSttdZ2q354"
    "YgkAERVF4b3vHABMCIC11nsfQiCiqwJYa4noxbNvOw/6AJIk62ySJMLMwhI5MnPMnxzMzJHJ"
    "E0dmicxJhEXk+uTO0fFuCME5h1yDxbh5+zEz93q+LGOv50WUmStOVZSqkjJyWXJVcRm5LKWM"
    "3PNURq6iMKfIIpJw9n08Hg8Gg36/3wL4+eu3iHpykcWTS5pElCWJpMiJWaIk4RQ5RRERda4S"
    "UWbhpCmllDQA0+k0pZQFVwF3bzEAZ5N3jgje+0COnPVknbUAdm5cW5/1/eGPxcuL2saoAczC"
    "DQWAV0/fr1c/HxcBFNC8QGEMMu3NuyddAfIjG9QLjKJTB3NIHV050EZuoQI6+93q4P7B6TYA"
    "A2gW1xlC61K0OXi492HZ6EbAnGFqEmBmhlYc7A9HutRq/wgA5plSwDT9tORgfzgCNsmv2QfQ"
    "OvEwps7BooOPpwebxFsB83wazdWdl321BjOGWWejrciZ0+wBMwef76LPnx6trXFrivIfVOsl"
    "P2V7FwH4MhpuCTBLX7mjckU628naTImlrdDdLDJ59OT+XDDU8SwyTX+Y2bC7hIPVA+fty6/b"
    "SmwBODreHY/H0+n0P0WLomjegJYAIYTBYNAcp5cOa20IoQXgnMuvAh0GATg8scAEmHQrneMv"
    "3LAo6X/e0vAAAAAASUVORK5CYII=")
""" VS2005 focused docking guide window left bitmap. """

#----------------------------------------------------------------------
left_single = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAACAAAAAdCAIAAABE/PnQAAAAA3NCSVQICAjb4U/gAAACTklE"
    "QVRIibWWPWsUURSG3/u5u8RiKxtLmzR2gqQSttFKhKBWqQL+BQXL4D9IGxsrBUGEFCIEbC0s"
    "rOzshYHt3Jl7PizuzsduJhs3Ts7C3Z2BfZ95zzn33DGnp6e4zvAAdnZ2vPfWWmvtsOpFUXgA"
    "3vvxeBxCuC6AtTaEEGP03g8LQE5RTo73/sXzr7sPJwCExTorLMxExMSJEhGl/MlBRJTIB0+J"
    "iBORMBMz3/xz7+h4L8bonFsCunH77lMiGo1CWabRKDArEVUkVeKq4jJRWVJVUZmoLLlMNAq+"
    "TFQlJpJEzCz49n0+n0+n08lk0gP4+es3swbvEnHwTlSYlViYJZEQcWJhkkSSmJnVuYpZiZhE"
    "RUREI7BYLESkTVE37t8hAM5KcM57hBCid97Z4K2zFsDurRubk74/+9G9vKhtjBrAdG4oALw6"
    "eLdZ/XxcBFBA8wKFMci012+fDQXIj2xQLzCKQR20kDqGcqCNXKcCuvzd6+DB4dk2AANoFtcl"
    "QutS9Dl49Pj9qtFLAS3D1CTALA2tOdifnehKq/0jAGgzpYBp+mnFwf7sBLhMfsM+gNaJhzF1"
    "DroOPpwdXibeC2jzaTRXty37eg2WDLPJRl+RM6fZA6YFn++iTx+fbKxxb4ryH1TrJT9lfxcB"
    "+Hwy2xJgVr5yR+WKDLaTtZkSK1thuFlk8ujJ/dkxNPAsMk1/mOWwu4KD9QPnzcsv20psATg6"
    "3pvP54vF4j9Fx+Nx8wa0AogxTqfT5ji9clhrY4w9AOdcfhUYMDyAoiiKohhWt4m/9Qss43IB"
    "CBMAAAAASUVORK5CYII=")
""" VS2005 unfocused docking guide window left bitmap. """

#----------------------------------------------------------------------
right_focus_single = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAACAAAAAdCAIAAABE/PnQAAAAA3NCSVQICAjb4U/gAAACWElE"
    "QVRIibWWv2/TQBTHv3e+uyRbJwZWFv4AJNSRLjChSkhlYqrEzFZVDAwVC3PXsrAUISTExlKJ"
    "tQMSWzcmFqaqQqT2+8VwtuMkbiBp+mzF0pPz/dzX7z373IMXp7jJCABebf8JIXjvvffrVd8/"
    "9gFACGE4HMYY1w4AxgGA9z7GmFIKIdwUwHsfQth7/vXuoxEAFfWFV1ERZhYWYmJmykcOZmbi"
    "EAMTsxCzirCI3BrfPzjcTCkVRYFcg27cubfDzINBLEsaDKKIMXPFWpFUlZTEZclVxSVxWUpJ"
    "PIihJK5ImJVYRBSn387Pzzc2NkajUQ/g7McvEYuhIJYYCjUVMRYVUWJlFhIVVmIlERErikrE"
    "mIXVVFXVEnB5eamqWXAW8Gb39uKHevbzNwARZVFirUSIlFkqEVUD8Pb71P1Lt83LZ+8BAA7O"
    "AYABMAPcFfcvDXj97ikA5wxmHVVrf64LyA7Mau1so770uVjRQa1lzaKtSc2ZWAR4uHsyn2xq"
    "YBnjbFp4zsRCBw6Ptz/M5GoHgLla15AfUV8F/gEwA/Bk66jPgXNwMNhkyf199F816DIaB5bx"
    "yB2aO2qFLsp/+Xiy22YmczA1Cq4hLQlwsK56xwHgumLWln0pgPv8aWcmNdVF7TKujkWAL0db"
    "88nagXWb0xYgVn4XWf0CymdzWQNgapJzWC7HCnPQF5M5aBhXzthqgMkcoF57Zxx6YvaDMzO3"
    "148pwMHhJhFdXFwQ0XVEh8NhuwOaAqSUUkoxxvaLulp471NKPYC80ci7gXVFALB/7IExMF6j"
    "bht/AXIQRaTUgkiHAAAAAElFTkSuQmCC")
""" VS2005 focused docking guide window right bitmap. """

#----------------------------------------------------------------------
right_single = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAACAAAAAdCAIAAABE/PnQAAAAA3NCSVQICAjb4U/gAAACVElE"
    "QVRIibWWv2sUQRTHvzM7M3dHmlQWtjb+AYKkTaOVCEKsrAL+CxaWwcY6bWysRAQRUtgEbC0E"
    "u3RWNsJCCILZfb8sZvdu925zej/yveMWHnvvM9837+2OOz09xU0qANjZ2QkheO+999vNXpZl"
    "ABBCGI/HMcabAnjvY4wppRDCdgHIJcrFCSG8eP7l7sMJABX1hVdREWYWFmJiZsqfLGZm4hAD"
    "E7MQs4qwiNz6c//oeC+lVBRFA+jqzr0DZh6NYlXRaBRFjJlr1pqkrqUiriqua66Iq0oq4lEM"
    "FXFNwqzEIqL4+u3i4mJ3d3cymQwAzn/8ErEYCmKJoVBTEWNRESVWZiFRYSVWEhGxoqhFjFlY"
    "TVVVLQFXV1eqOitRV68Pby+v6fnP3wBElEWJtRYhUmapRVQNwJvvvftXbpuXz94BABycAwAD"
    "YAa4a+5fGfDq7VMAzhnMOllt+rMpIDswa3JnG81lyMWaDppc1i7a2tCCiWWAB4dni8F2Dyxj"
    "nPUTL5hY6sDh0eP3c7HGAWCuyWvIJRragX8AzAA82T8ZcuAcHAw2W/JwH/3XHnQZrQPLeOQO"
    "zR21Rhflv3w4O5xGZnPQGwXXklYEOFg3e8cB4LrJbLrtKwHcp48Hc6FeF02Xcb2WAT6f7C8G"
    "GwfWbU5bglj7WWTNAyh/28sWAL1JzrK8HWvMwZBmc9Ayrp2x9QCzOUCz9s44DGj+hTM3t5ur"
    "Bzg63iOiy8tLItok6Xg8np6AeoCUUkopxjh9o64n731KaQCQDxr5NLAtBQBlWZZlucWkXf0F"
    "imtJnvbT2psAAAAASUVORK5CYII=")
""" VS2005 unfocused docking guide window right bitmap. """

#----------------------------------------------------------------------
tab_focus_single = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAAB0AAAAdCAIAAADZ8fBYAAAAA3NCSVQICAjb4U/gAAAC10lE"
    "QVRIidWWT0gUcRTH387+ZveXZgzsbmvSsmqEfzBJSYz+gUsHCYJgISPytCQKFhJdpIN0qIUO"
    "ezIUaU/roQ5eEzp46ZT/DhG4haCXdSUPK+Wuzvze+02HgdFmFqMtD76Bx8yb3/v8vr/3Zn4z"
    "np6ReTgCYwAwdqfEGFMURVGU/wIdfaswAGCMcc5VVf1fXIBdBgCKoqiq+nxkobn3BABIkgBA"
    "hIiEJFAgorAOyxARBTKVoUAkgSiJkIhO73a/nLjGOd/nWkrPXbqLiH6/CgBEJiIaKA1BhkG6"
    "QF1Hw0BdoK6TLtCvMl2gIQhRCiQiCfPLm5ubtbW1YNXXtuzadyJTZV4AkKYkMpEkkRQoEUmQ"
    "JJQCpSAiMr1eg8hEJJSmlFJK0wdQLBYR0cl9laj7l6LGY5/tc2ejsrmdgeGJbG5nYHgym9uJ"
    "x9KHeGuMNd7B8fSMzCfvyerq6rHHn2bmEgPDE09G+/9WaSqZmRofisfSiadnotHoozclp94K"
    "oGWznNxn/e8q4LqznNwXmb4KuO6s4643lZyugOvOcj8PDyrgurOOe30r05tKZv7ALavXmszt"
    "rXZZL7EjhTmuU8lpRxNSyemZuUEAmJlLOPzU+CAAuKFluO7OWpF4LO1OPsTcejOOTcRepqXR"
    "tngs7Y6U4bbcqNrIF6bGh6yt0prAgm7kC6E2fSNfWF9b2d7e1jStvqGlbMSmeRsuP7zZZvp8"
    "PvCoW1s/a2qq7vddD57y3b7VZfmNfGFxadUQBgqztbWps7Pdy04uLq0WSyVJnoMRgUY45NM0"
    "bXZZ7OvtaA8vLOdeT85mP+4eXN35K/6W5nBjxFz5tv7+w8LWF3+oTW+IBpsavStf1+xIfTTY"
    "cNbknDPGfqsD5/xCa6AuDFe791xtEJyHIhHedTGw17tnj49EeFdH8GAkEAhwzgF+7HMZY5qm"
    "cc6tD6rDGGOMMUS075aN2Ho9R/R/9gsXZ7dKHM+ODQAAAABJRU5ErkJggg==")
""" VS2005 focused docking guide window center bitmap. """

#----------------------------------------------------------------------
tab_single = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAAB0AAAAdCAIAAADZ8fBYAAAAA3NCSVQICAjb4U/gAAAC1klE"
    "QVRIidWVTWgTQRTHJ5vZZEyMLKSx1RbSImJbioeiCKIechLBU8CCtadAaaGIFC/iQTxowENO"
    "hUohp/Tiocdce/Gk/TiIpTm0JCnmA+OaFJs2u/PerIcp27IbKsZ66Ft47P5n3m/evLc768lm"
    "s+Q/GCWEBINBSqmiKIqinApU13VKCKGUMsZUVT1lrqIoqqq+frYyeP8cIUSgIIQgAgACcuAA"
    "wOUlDQCAA1UpcADkAAIREPHiwa2383cYY0TWwa7AlRuPAMDvVwkhiBYAmCBMjqaJBgfDANME"
    "g4NhoMHBr1KDg8kRQHBAREE+r1er1Z6enkOubbn8d0RLpV5CiLAEogUoEAUHAYAcBYLgIDgi"
    "ouX1mogWAIKwhBBCWD5Cms0mADi57xKX/6Ws8dgX+97ZqFxpb3JmPlfam5x5nyvtxWPpE7yc"
    "I+c7OJ5sNhsOh4PB4Kunn5aWE5Mz87MvJv4201QyszA3HY+lE88vRaPRYrHozLcDaNsoJ/fl"
    "xIcOuO4oJ/dNZqwDrjvqrOebSi52wHVHud+HJx1w3VFnvb6d5ZtKZv7AbZuvXMztZbvkR+wI"
    "oY7nVHLR0YRUcnFpeYoQsrSccPiFuSlCiBvahuvurFTisbQ7+ARz55txHCL2NmWOtsVjabfS"
    "hjt0L1Cu1BfmpuVRKReQ0HKlHhkxypV6Ib/ZaDQ0TesfGGqr2DTv+Ph4IBDw+XzEo9Zqv0Kh"
    "wOOxu10XfA8f3JS+XKmvrm2Z3ARuDQ9fGx297qXnV9e2mvv7Aj3HFQ5md8Snadru7u7Rua6q"
    "6sp6aTNXzX08OL67q7f9Q4PdTP1ZKCn5Qq321R8ZMQaiXf19VuGbJ1/8IZX+aNdAnxWJRHp7"
    "e7e3t4+4oVCo0Wjout5qtdx9YIwxxlqtlj3aVgmHw5qmbWxsHNWXUqppGmNM/lCd/aWUUgoA"
    "9mhbhTFGKT3sm67ruq7v7Oy4cR3bb5uW079be13FAAAAAElFTkSuQmCC")
""" VS2005 unfocused docking guide window center bitmap. """

#----------------------------------------------------------------------
up_focus_single = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAAB0AAAAgCAIAAABhFeQrAAAAA3NCSVQICAjb4U/gAAACTUlE"
    "QVRIic2WP28TMRjGH/85c1miqEF8CnbUgSFdukVRmZGQ+gW6Vgwd+hW60Yq1gMQMQzpHGZAg"
    "C6JS+QIMmUju/L5+Ge6ulzoRTcMh5TmdZfv8/vT4Pcu26h2N8R9kAZwMfltrtdZa60agx5fa"
    "ArDWpmmaJElTXGBmAWitkyRxzllrG+Zqra21bz+OAQQOzETExJ48EfniKURE5MkmljwRe6LA"
    "TMz8ZPbs9GzXOWeMQZHfW33/NOufvALALESUU8g95zlnnrKM8pwyT1nGmadHic085Z6Jgidm"
    "Dhh/mU6nnU6n1WrFXAA/fv7iIEECsxAH5uApELHnwBQ8Bc/MLMbkzELEFCSEEII4YD6fhxAK"
    "Tsx9/tQDEIgqOzRggAQQQEEBguIFgKoNqDdfvy1yYq41emG4QKkSpDQAiNQfFQClpBoZcaK2"
    "s0awEHzXVVyri1gxN7FaFuILu6qwtAyokqWWwEvcxNTTKsIK95Cqs4JJzV02vMJvHS/1cFFQ"
    "UGV+K3tSzWlZq/5bOWGllIio0mzpX+pZSJXdVRmOuabcItRC+ZfKcn+pFRvN65fvNihj9Y7G"
    "o9FoMplcX18f9M5lUx30zofD4WQyubm56R2Nm9oYY20B98XeRfPcAro+ei1uf/DBt9u+3c7b"
    "7f7gfTPc/cOr7HE36+5k3Z28u5N1u/uHV/dG3X+gfb7YW8dgpC1YD1vBjfP7oEW6Lvf0bHc6"
    "nc7n881YaZre3pjucJ1znU7n9qx+qLTWzrkVXGNMcav4d1kAx5camAGzRoiF/gCKPmudbgYP"
    "HQAAAABJRU5ErkJggg==")
""" VS2005 focused docking guide window up bitmap. """

#----------------------------------------------------------------------
up_single = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAAB0AAAAgCAIAAABhFeQrAAAAA3NCSVQICAjb4U/gAAACTklE"
    "QVRIic2WP4vUQBjGn/mTMUtgWS6yvb29XGGzzXXHwdWCcGBzH8BCweK+wnWyWKtot6DNge0V"
    "gjYnNn4BA9vdJvO+81ok2ewmi7d3RtgnZEgm8/545skwiZrNZvgPsgCSJLHWaq211r1Asyyz"
    "AKy1cRxHUdQzV2sdRZFzzlrbCxdlDmUC1to3Hy8BBA7MRMTEnjwR+fIoRUTkyUaWPBF7osBM"
    "zDy+fnR2vu+cM8ZU3KV+fLo+fPUUALMQUUGh8FwUnHvKcyoKyj3lOeee7kU291R4JgqemDng"
    "8ut8Ph+NRoPBoM0F8PPXbw4SJDALcWAOngIRew5MwVPwzMxiTMEsRExBQgghiAMWi0UIoclh"
    "VY8fegACUVWHBgwQAQIoKEBQngBQ3wPq9bfv7XzX7o1eGS5QqgIpDQAizUMFQCmpR3bf26qc"
    "NYKV4nVX7aumaavNjayWlfrSriotdQF1WKoD7nAj00yrLCvdQ+rOGiYNt2t4g9+mXprhoqCg"
    "qnxre1LPqatN762asFJKRFRltvIvzSykTndTwm2uqbYItdL+5aLbX2nDRvPiyds7tC2p2WyW"
    "pmmSJHEcP3/25cPFSXfQNjqeTE9fPhiPx0mSXF1d9bMxdrUD3OPJtH9uCd0evRX38Oi9Hw79"
    "cFgMh4dH7/rhHpxc5PfTPN3L070i3cvT9ODk4saqmz9on6eTbQy2tAPrYSe47XxvtUi35Z6d"
    "78/n88VicTdWHMfLP6Y1rnNuNBotv9W3ldbaObeBa4wp/yr+XRZAlmVZlvWCW+oP2FUt8NYb"
    "g5wAAAAASUVORK5CYII=")
""" VS2005 unfocused docking guide window up bitmap. """

#----------------------------------------------------------------------
down = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAAB0AAAAgCAIAAABhFeQrAAAAA3NCSVQICAjb4U/gAAACFUlE"
    "QVRIidWVPWvbUBSG3+tv8KKpnYtH/4DuJtCti2nntBm7depQWih0zT9w/AtSQsDQ0JIfkKFD"
    "wRC61Iu3uBgRiKXz1eFalizb8QfxkFdCurofz3l1zhVyg8EAe1BhH9BHyC3NWkTU/XYFQEVF"
    "mFlYiImZyR9ezMzEpXKJiVmIWUVYRJ7cPT/uHizhFgqF6+93Lz8fAhAxZo5ZY5I4log4ijiO"
    "OSKOIomIq+VSRByTMCuxiCiufo3H4yAI8txisQjgz98bUVNTEWNRESVWZiFRYSVWEhGxYjEW"
    "MWZhNVVVtQoQhuESrtfXw6e7JbTd+k1E6dv3+/3dQPeo3+8/3n22Si+OLgFLn52D4aLTun/V"
    "er8XnVZ1NKqM/lX9eTNaC92IC+D87HUlDMthWA7D87NXmyzZNL+nl0ez60Nyt4Jux91Kee71"
    "8Lbd6uxwzXFcr9drNpv+4f2bn59O2gDMAMC5ZJY5wOCcwZxlV7tkKr68PX338Vmj0cBev7f8"
    "d0GkSG0i0576Alza7707LGqBy2JZblYOPgnm4JJA8Blay41ZnAfO3xbumWjTQOv8+oKZA2AJ"
    "Y1o3wPucGXYLYVZwWQzQlJWmwIMs6Z8OJUHWcUU1aWZ9WKaGlo67xZlTbbbPbL7oq7fBTHm/"
    "Jx9+bBRpnea4x92D4XA4mUx2Y9VqteVcAEEQ1Ov13bhZ5fP7IFB4v/v41f8HFQ1ap0nfm7YA"
    "AAAASUVORK5CYII=")
""" VS2005 unfocused docking guide window down bitmap. """

#----------------------------------------------------------------------
down_focus = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAAB0AAAAgCAIAAABhFeQrAAAAA3NCSVQICAjb4U/gAAACaUlE"
    "QVRIib2WvWsUQRjGn5mdnWxyTaqz9q+QlLnGToSgWAYDNjbpNCAGDGIvaRPbNJGQyiAEbK+w"
    "sAo2qexyEhbxsvt+jMXc3u3liPfhmWeXnWVm9vc+vO/M7prVzTb+gxyA7Ye/nXPWWmvtXKBb"
    "B9YBcM5lWZam6by4QNcBsNamaeq9d87NmWutdc59+NgGoKIizCwsxMTMFI8oZmZilzomZiFm"
    "FWERaXbv7eyueO+TJEHM79LSkvfeWnv2qftgex2ASGDmkrUkKUspiIuCy5IL4qKQgnghdQVx"
    "ScKsxCKiaH8lIu99NOwAEFGsG4Dv5xeiQYOKBBYVUWJlFhIVVmIlEZGQJKVIYBbWoKqqwQN5"
    "nqdpuri42OMys6rGOG/X78yW0bXWNyLqcyyAEEIIYcYK3aB5Lazb4o5fsPc3ToFaloxBwMle"
    "6+9Pjfd7stda6HR85+dCPC86Y6ETcQEcHz32eZ7meZrnx0ePJnlk0vwenm70r/PkTgWdjjuV"
    "rnPPfvxaa+3NcL3GMaub7XdPtNFoZFn24tmX1/trAOLuM6aaFQwQYExAMPWNaUw1FW+eHj5/"
    "dbfZbDYajY33F7e1L4gUA5uo3fd8AWbQH70bjGqEyxLq3LoMYhKCgakCIWZoLLdkMRE43Iy0"
    "tWi9QOP8xoIFAyBUjF7dgOizb9iMhLmByxIAHbAGKYigUPX3hqog47hSvfCHfYRaDcNg3IzO"
    "7GmydRaGi37zMujrut/9l58nijROQ9yd3ZXLy8urq6vZWFmW9f+Yhrje++XlZR2keDpZa4f+"
    "H/pKkiR+/f9dDsDWgQW6QHcuxKg/ZbVtCjjzINkAAAAASUVORK5CYII=")
""" VS2005 focused docking guide window down bitmap. """

#----------------------------------------------------------------------
left = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAACAAAAAdCAIAAABE/PnQAAAAA3NCSVQICAjb4U/gAAACMElE"
    "QVRIib2WPYsTURSG3zv3ThKJRSqblDYLwU6wFMKCViIEtbKQ/QdWgrXt/oO4hZWCIEIKUfYH"
    "WFgIATuraewHM3PPh8XNZCaTSWI2oydwMx/kfeY959wzMbPZDC3FaDTavOi23Wgron8n/Z8A"
    "rnry/NmXk/vXAAhLZCNhYSYiJvbkiciHTwgiIk8uduSJ2BMJMzHzjd93zi9OmwEAbt5+TETd"
    "bpxlvtuNmZWIcpLcc55z5inLKM8p85RlnHnqxi7zlHsmEk/MLPj6LUmS4XDYDPjx8xezxs56"
    "4thZUWFWYmEWT0LEnoVJPIlnZlZrc2YlYhIVERHtAIvFYquDu7cIgI0kttY5xHHccdbZKHaR"
    "jSIAJ8Pru5M+GX+vnm4rslEDmMoFBYCXT9/uVt+MbQAFNCxQGINAe/XmSVuA8MgGxQKjaNVB"
    "CSmiLQe6kqtUQJfHjQ7unV0eAjCABnFdIrQoRZODBw/frRvdCygZpiABZmmo5mAynupaq/0l"
    "ACgzpYBZ9dOag8l4CuyT37EPoEXiYUyRg6qD95dn+8QbAWU+jYbqlmWv12DJMLtsNBU5cFZ7"
    "wJTgzS76+OHRzho3pij8QLVYwlM2dxGAT9PxgQCz9hU6KlSktZ2sqymxthXam0UmjJ7QnxVD"
    "Lc8is+oPsxx2V3BQf+G8fvH5UIkDAOcXp0mSVF94V4ter5emab/frwMADAaDcOOYSNO00+mE"
    "4zrgePWaiAMwn8+PF932//MPv0Uk8OspzrYAAAAASUVORK5CYII=")
""" VS2005 unfocused docking guide window left bitmap. """

#----------------------------------------------------------------------
left_focus = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAACAAAAAdCAIAAABE/PnQAAAAA3NCSVQICAjb4U/gAAACVElE"
    "QVRIibWWvW8TQRDF3+7Ors8ShSsaSpo0dEgoFcINVChSBFRUkajpIKKgiPgP0pqGJiAhITqE"
    "FIk2BQUVHT2VK+y7ndmhWN/5Ixcbh8tYWvtO8vvdm5mdPXPv+RmuMgjA670/RGSttdZ2q354"
    "YgkAERVF4b3vHABMCIC11nsfQiCiqwJYa4noxbNvOw/6AJIk62ySJMLMwhI5MnPMnxzMzJHJ"
    "E0dmicxJhEXk+uTO0fFuCME5h1yDxbh5+zEz93q+LGOv50WUmStOVZSqkjJyWXJVcRm5LKWM"
    "3PNURq6iMKfIIpJw9n08Hg8Gg36/3wL4+eu3iHpykcWTS5pElCWJpMiJWaIk4RQ5RRERda4S"
    "UWbhpCmllDQA0+k0pZQFVwF3bzEAZ5N3jgje+0COnPVknbUAdm5cW5/1/eGPxcuL2saoAczC"
    "DQWAV0/fr1c/HxcBFNC8QGEMMu3NuyddAfIjG9QLjKJTB3NIHV050EZuoQI6+93q4P7B6TYA"
    "A2gW1xlC61K0OXi492HZ6EbAnGFqEmBmhlYc7A9HutRq/wgA5plSwDT9tORgfzgCNsmv2QfQ"
    "OvEwps7BooOPpwebxFsB83wazdWdl321BjOGWWejrciZ0+wBMwef76LPnx6trXFrivIfVOsl"
    "P2V7FwH4MhpuCTBLX7mjckU628naTImlrdDdLDJ59OT+XDDU8SwyTX+Y2bC7hIPVA+fty6/b"
    "SmwBODreHY/H0+n0P0WLomjegJYAIYTBYNAcp5cOa20IoQXgnMuvAh0GATg8scAEmHQrneMv"
    "3LAo6X/e0vAAAAAASUVORK5CYII=")
""" VS2005 focused docking guide window left bitmap. """

#----------------------------------------------------------------------
right = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAACAAAAAdCAIAAABE/PnQAAAAA3NCSVQICAjb4U/gAAACMklE"
    "QVRIibWWvY7TUBCFz83vojSuKNiShgdAol8hQYWQkJaKAuUNtqWmoeANFgoqhJAQHRLaB6BA"
    "orC0HWnSUEURK2LPmRmKayeO4wTysydWbI+c+e7xzDgOo9EIK0rTdDW4m0Ij4FBK07R1fdmj"
    "rh3QqZ6cPf965+ENAKbWardMTZWkUoVCUuIniiSFnW6HQqqQpkpVvfnn3uu395sBAG7fPSXZ"
    "73ezTPr9rqqTzGm5aJ5rJswy5jkzYZZpJux3O5kwFyVNqKqGb9/H4/Hx8XEz4PLnL1XvdtpC"
    "7Xba5qbqVFM1oZEqakoTmqiqerudqzqpNDczM+8Bs9lsrYNXw1ub7+nl+DcAVaOa0HJVESM1"
    "VzVzAG9+LF2/dZFfPHsPAAgIAQAcgDsQ1ly/NeDlu6cAQnC4V7L6/GtfQHTgXuSONopdk4sd"
    "HRS5vFy0l6EVE5sAD4YXq8GyBh4xwZcTr5jY6CDg0eMPtVjhAPBQ5HXEW9RUgX8A3AE8OTlv"
    "chACAhy+WHJzH/1XDaqM0oFHPGKHxo7aoYviTz5eDOeRxRwsjUIoSVsCAryaveIACNVkPi/7"
    "VoDw+dNpLbTURfNlrNcmwJfzk9Vg4cCrzekbEDs/i7x4AMWt3B0AsDTJUR7LscMcNGkxByVj"
    "7YztBljMAYq1V8ahQfU/nNrc7q/6e9FkMplOpyKyT9Kjo6MkSQaDQZqmdQdJkiRJsk92AFdX"
    "V71eLx7XAQfRYDCYH68FHOr19C8Ad0k9S0aHzwAAAABJRU5ErkJggg==")
""" VS2005 unfocused docking guide window right bitmap. """

#----------------------------------------------------------------------
right_focus = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAACAAAAAdCAIAAABE/PnQAAAAA3NCSVQICAjb4U/gAAACWElE"
    "QVRIibWWv2/TQBTHv3e+uyRbJwZWFv4AJNSRLjChSkhlYqrEzFZVDAwVC3PXsrAUISTExlKJ"
    "tQMSWzcmFqaqQqT2+8VwtuMkbiBp+mzF0pPz/dzX7z373IMXp7jJCABebf8JIXjvvffrVd8/"
    "9gFACGE4HMYY1w4AxgGA9z7GmFIKIdwUwHsfQth7/vXuoxEAFfWFV1ERZhYWYmJmykcOZmbi"
    "EAMTsxCzirCI3BrfPzjcTCkVRYFcg27cubfDzINBLEsaDKKIMXPFWpFUlZTEZclVxSVxWUpJ"
    "PIihJK5ImJVYRBSn387Pzzc2NkajUQ/g7McvEYuhIJYYCjUVMRYVUWJlFhIVVmIlERErikrE"
    "mIXVVFXVEnB5eamqWXAW8Gb39uKHevbzNwARZVFirUSIlFkqEVUD8Pb71P1Lt83LZ+8BAA7O"
    "AYABMAPcFfcvDXj97ikA5wxmHVVrf64LyA7Mau1so770uVjRQa1lzaKtSc2ZWAR4uHsyn2xq"
    "YBnjbFp4zsRCBw6Ptz/M5GoHgLla15AfUV8F/gEwA/Bk66jPgXNwMNhkyf199F816DIaB5bx"
    "yB2aO2qFLsp/+Xiy22YmczA1Cq4hLQlwsK56xwHgumLWln0pgPv8aWcmNdVF7TKujkWAL0db"
    "88nagXWb0xYgVn4XWf0CymdzWQNgapJzWC7HCnPQF5M5aBhXzthqgMkcoF57Zxx6YvaDMzO3"
    "148pwMHhJhFdXFwQ0XVEh8NhuwOaAqSUUkoxxvaLulp471NKPYC80ci7gXVFALB/7IExMF6j"
    "bht/AXIQRaTUgkiHAAAAAElFTkSuQmCC")
""" VS2005 focused docking guide window right bitmap. """

#----------------------------------------------------------------------
tab = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAAB0AAAAdCAIAAADZ8fBYAAAAA3NCSVQICAjb4U/gAAACq0lE"
    "QVRIidWWTWgTQRTHJ+3ETEugERrtF6QhFhKsIlgQRITm5LkBvdiDhBZKc5DiRXryoAEPPRUi"
    "pTnVi4cee5NePAitFtFoVxSyheYDa02KCd3deW/Gw2Cy7MZaIz307TK7/Gfeb9587Nvx6LpO"
    "TsA6TgJ6glyqHgcHB4/ub0ZvdRFCBApCCCIAICAHDgBcXcoAADhQLwUOgBxAIAIinju89iRz"
    "gzHW5Pb09BBCImO3AcDn8xJCECUAWCAsjpaFJgfTBMsCk4NposnB56UmB4sjgOCAiIJsbJXL"
    "5b6+PsYYtQev5b8hSi/tJIQIKRAloEAUHAQAchQIgoPgiIiys9NClAAIQgohhJBnCKnX6wDQ"
    "jFfZ0+TA/8xpIv6+8e5cN61Qm05ltEJtOvVMK9QS8ewRpWqj2js4nsb+nbv3cnU9OZ3KzD2c"
    "/NdIF9IrS4sziXg2+aA/FAr5/X5nvG1AW3o5ufOTL9rgur2c3Mcrd9rgur1Oe7wL6edtcN1e"
    "7v1wtw2u2+u0z2978S6kV/7CbRmv6sxdquVSH7HTR/9tE+PLUsqp2cz27k/7PTWbkcezifHl"
    "tbW1XC6n6zp1dONeWaUk4tnjTwtx5F81KEcSaQxzdT1p1xPxrFtpwY3d7C6WKkuLMypVqg4U"
    "tFiqBEfNYqmi57er1WogEBgOx1oqDVoz/77e2Onu6hq7emGg/6w9imKp8ubt149a/mI0rGqV"
    "8u7DlyuXRuzKp8/5yzG/yr9NrmEYm1uFba2svTq0c0eu+2LR88z7Qy905PW9vZwvOGqGQ73D"
    "Q1Lf9eR3vitlONQbHpLBYHBwcJAx5rGfd6rV6v7+vmEY7nVgjDHGDMNo1LZUIpGIc34ppYFA"
    "gDGmfqgOo5RSSgGgUdtSUSUANLmqWp0q/mTK82hFcX4Bm24GMv+uL+EAAAAASUVORK5CYII=")
""" VS2005 unfocused docking guide window center bitmap. """

#----------------------------------------------------------------------
tab_focus = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAAB0AAAAdCAIAAADZ8fBYAAAAA3NCSVQICAjb4U/gAAAC10lE"
    "QVRIidWWT0gUcRTH387+ZveXZgzsbmvSsmqEfzBJSYz+gUsHCYJgISPytCQKFhJdpIN0qIUO"
    "ezIUaU/roQ5eEzp46ZT/DhG4haCXdSUPK+Wuzvze+02HgdFmFqMtD76Bx8yb3/v8vr/3Zn4z"
    "np6ReTgCYwAwdqfEGFMURVGU/wIdfaswAGCMcc5VVf1fXIBdBgCKoqiq+nxkobn3BABIkgBA"
    "hIiEJFAgorAOyxARBTKVoUAkgSiJkIhO73a/nLjGOd/nWkrPXbqLiH6/CgBEJiIaKA1BhkG6"
    "QF1Hw0BdoK6TLtCvMl2gIQhRCiQiCfPLm5ubtbW1YNXXtuzadyJTZV4AkKYkMpEkkRQoEUmQ"
    "JJQCpSAiMr1eg8hEJJSmlFJK0wdQLBYR0cl9laj7l6LGY5/tc2ejsrmdgeGJbG5nYHgym9uJ"
    "x9KHeGuMNd7B8fSMzCfvyerq6rHHn2bmEgPDE09G+/9WaSqZmRofisfSiadnotHoozclp94K"
    "oGWznNxn/e8q4LqznNwXmb4KuO6s4643lZyugOvOcj8PDyrgurOOe30r05tKZv7ALavXmszt"
    "rXZZL7EjhTmuU8lpRxNSyemZuUEAmJlLOPzU+CAAuKFluO7OWpF4LO1OPsTcejOOTcRepqXR"
    "tngs7Y6U4bbcqNrIF6bGh6yt0prAgm7kC6E2fSNfWF9b2d7e1jStvqGlbMSmeRsuP7zZZvp8"
    "PvCoW1s/a2qq7vddD57y3b7VZfmNfGFxadUQBgqztbWps7Pdy04uLq0WSyVJnoMRgUY45NM0"
    "bXZZ7OvtaA8vLOdeT85mP+4eXN35K/6W5nBjxFz5tv7+w8LWF3+oTW+IBpsavStf1+xIfTTY"
    "cNbknDPGfqsD5/xCa6AuDFe791xtEJyHIhHedTGw17tnj49EeFdH8GAkEAhwzgF+7HMZY5qm"
    "cc6tD6rDGGOMMUS075aN2Ho9R/R/9gsXZ7dKHM+ODQAAAABJRU5ErkJggg==")
""" VS2005 focused docking guide window center bitmap. """

#----------------------------------------------------------------------
up = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAAB0AAAAgCAIAAABhFeQrAAAAA3NCSVQICAjb4U/gAAACHUlE"
    "QVRIidWWP4vUQBjGn8mfcyGQYiM2W8mWsRcLm22uWw6uFpQt7WwVLPwKVsp+gFMsAwqynY2F"
    "oLAgNu4HsEiz3E7mfee1yN9Lcueu7oo+IcPMZN4fz7yZzEQlSYIDyAMQx/F+ocvl0tkvsdKh"
    "uF6z8eLsAwDLlpmImNiQISKTX7mIiAx5vkeGiA2RZSZmvnF++9nzO0EQ9HC/vj2fPr0PgFmI"
    "KCObGc4y1oa0piwjbUhr1oau+Z42lBkmsoaY2eLjpzRN+7kAvn3/wVasWGYhtszWkCViw5bJ"
    "GrKGmVlcN2MWIiYr1lpr5QjYbDb9eQBw95YBIBBVdDiAC/iAAAoKEOQ3AJRtQL38/OXS/ALw"
    "XKcxXKBUAVIOAIjUDxUApaQcecV7A3DkuYJG8EVX7VpdtNXm+p4jjfjcrsotdQFlslQH3OH6"
    "bj2tPCx3Dyk7S5jU3K7hHr91vNTDRUFBFfkt7Uk5p6763lsxYaWUiKjCbOFf6llImd2+DLe5"
    "ruM0UlA5uazS7S/Usz88vnf2G2VLKkmSap989OD9m8WsO2gbnU7mD5/cHI/H+C/3yR24p5P5"
    "/rk5dHv0VtzpyWsThiYMszCcnrzaD/d4ttDXIx0NdTTMoqGOouPZ4pdR7e+iq3fzyTYGWzrY"
    "etj7zwOAOI7/yjmPHRfpFVKr1apqrNfrNE2bx+pOGgwGo9Eor1/wGwRB9QPwh/oH9oed9BPW"
    "YyQlBOJt4AAAAABJRU5ErkJggg==")
""" VS2005 unfocused docking guide window up bitmap. """
#----------------------------------------------------------------------
up_focus = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAAB0AAAAgCAIAAABhFeQrAAAAA3NCSVQICAjb4U/gAAACTUlE"
    "QVRIic2WP28TMRjGH/85c1miqEF8CnbUgSFdukVRmZGQ+gW6Vgwd+hW60Yq1gMQMQzpHGZAg"
    "C6JS+QIMmUju/L5+Ge6ulzoRTcMh5TmdZfv8/vT4Pcu26h2N8R9kAZwMfltrtdZa60agx5fa"
    "ArDWpmmaJElTXGBmAWitkyRxzllrG+Zqra21bz+OAQQOzETExJ48EfniKURE5MkmljwRe6LA"
    "TMz8ZPbs9GzXOWeMQZHfW33/NOufvALALESUU8g95zlnnrKM8pwyT1nGmadHic085Z6Jgidm"
    "Dhh/mU6nnU6n1WrFXAA/fv7iIEECsxAH5uApELHnwBQ8Bc/MLMbkzELEFCSEEII4YD6fhxAK"
    "Tsx9/tQDEIgqOzRggAQQQEEBguIFgKoNqDdfvy1yYq41emG4QKkSpDQAiNQfFQClpBoZcaK2"
    "s0awEHzXVVyri1gxN7FaFuILu6qwtAyokqWWwEvcxNTTKsIK95Cqs4JJzV02vMJvHS/1cFFQ"
    "UGV+K3tSzWlZq/5bOWGllIio0mzpX+pZSJXdVRmOuabcItRC+ZfKcn+pFRvN65fvNihj9Y7G"
    "o9FoMplcX18f9M5lUx30zofD4WQyubm56R2Nm9oYY20B98XeRfPcAro+ei1uf/DBt9u+3c7b"
    "7f7gfTPc/cOr7HE36+5k3Z28u5N1u/uHV/dG3X+gfb7YW8dgpC1YD1vBjfP7oEW6Lvf0bHc6"
    "nc7n881YaZre3pjucJ1znU7n9qx+qLTWzrkVXGNMcav4d1kAx5camAGzRoiF/gCKPmudbgYP"
    "HQAAAABJRU5ErkJggg==")
""" VS2005 focused docking guide window up bitmap. """

#----------------------------------------------------------------------
aero_dock_pane = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAAGcAAABlCAMAAABnVw3AAAAAAXNSR0IArs4c6QAAAARnQU1B"
    "AACxjwv8YQUAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAA"
    "AwBQTFRFAAAAb3WKdHqPdnyRd3+deYGge4OifISifoallZaWgIy1g463hZC5hZG6iJO8o6Sk"
    "pKSkpKWlpaampqenqKmpqaqqqqurq6ysrKysra6urq+vr7CwsLGxsbKysrOzs7S0tLS0tLW1"
    "tba2tre3t7i4uLm5uru7vLy8vL29vr6+iZfLjJrNjpzPjpzQkZ7PkJ/SlKHSkaHek6Pgk6Th"
    "labjmKjlnqzhnqzjoa/npbPov8DAwMDAwMHBwsLCwsPDw8TExMXFxsbGycnJycrKysvLzMzM"
    "zM3Nzc7Ozs/Pz9DQ0NDQ0NHR0dLS0tPT09TU1NTU1tbW1tfX0tTY19jY1tjd2NjY2dnZ2dra"
    "2tvb29zc29zf3Nzc3N3d3d7e3t/fxs7szNPt0NXo0dfu1djk09js2tzk3d/k3d/m2Nzv3N/r"
    "1Nr02N713OH13OL23+X43+X54ODg4eHh4eLi4+Pj4uPm4uPn4+Tk5OTk5OXl5ubm5+fn4eLo"
    "4uTs5eXp5efv5+jo6Ojo6enp6urq6+vr6Onv7Ozs7O3t7e7u7u/v4Ob55Oj16Ov37e/26+/9"
    "7/D28PDw8fHx8vLy8/Pz8/P09PT09fX19vb29vf38vT89ff9+Pj4+Pj5+vr6+vr7+/v8/Pz8"
    "/f39/v7+////AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAsPpcmgAAAQB0Uk5T////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////AFP3ByUAAAAYdEVYdFNvZnR3YXJlAFBhaW50Lk5FVCB2My4zNqnn"
    "4iUAAAf+SURBVGhD7Zr7d9tEGoa9UKBZCiapneBQN3bUQlgo13DbhXBrnRQnS0LJNhDbUO7s"
    "ErCtZWWZm2Rj2YHdbWQsCSQL2/yjZkaypBlpdKH14XA4vL8kkuebx3PR6HtnHBtHkfxyZoGs"
    "zMtR4sfjWJRi0mJRHZGlFhej1BCNs1XyocDbpa0ooEjtSfcDOHp6apyFAMzop4XfF2f0K7Vn"
    "qpyhr0bT5AwHvhpOkzPQ/TVNjt73lT6c4jzQNV/1p8npq77SBlNsj6b4Sr1Ozmtr99xpvQpm"
    "6LKvquyMVezOe9Ze81uDfNbRHLUtiPaqNi8KvrqqztvlRGGbypFJRM7mMoOtnPNHDV8JisOB"
    "QczyJolE4qy/MMAX6Pl23VdNGeeMBi+sE0AEzsYl92tgXqj5ipNcnNHo0oYX5OVsnfe8beab"
    "VVQcelHveTij895XrJdD6SGc4b+HCIglcHTK0yAPJ4dPAYOJtUd/78b3dAdE4owYz6zzcM4Q"
    "3tEop/v18ePHv+7aICJndMbdIDdn93Iwp/vh7VAf2iAy5/KuC+TmPN0J5HQ+eNDUB51Ji8ic"
    "zjMhnAwpIbT7TfjXU4+ZeuqfbRNE5miZEE5qGNSe2g//s/RDLYgzSoVwiKlammMmvVTjLE0w"
    "NH+UJmV37peFe3yInM3NZp0liz/azk+NM0ptt3tkdXZSxGQ1vD3EDOpiep6s9EVSeW+y5e03"
    "/1Qt+ie/Fseb1HnaE5AS+ieL7k+IHMwTzqDDcDofkB+6P8qfRkPtpAEkD9Bbxsa4J+RHyCgo"
    "hZRRm/xi9sxZH61smMBUQUEiRzwyC6G3jLk8IY8PdvElWMdf/6745om9DQP0UhELxDjQW8Zc"
    "ntDF6Z8CdXSoID/XuxtyTmlBHD0dcy0ALs4oCRLrdiBHpmDuncT7wdWenxZ+I5xhEgxMWHvg"
    "2AW3Z+RpD4c/ChMO6WVhjZlMmRwscMjhQwo5WM9+hT8WgyQwCgIVtOLIFPQSSdyKDb7CpwXg"
    "DLGa2b49g/W+1jc4LSrgcR1IJgdYpL5tk/o6i4YMYL/hX6TmYD76XtN0k9MPAE044Pt9/5ED"
    "qmERQ8DBPWHNMlT6O08eaqqeBManRWn+vrEvUdAbJTVVO3zyHX0SrtXQCOAtAQd71BnVdFQ/"
    "fvnQ6qGq9BOyLDcp1d83aj0KFJETqqIerj705Y9muMqgEcBbxhZwT1iVJSjt/dvOrR4q8oQj"
    "+/tGtWtyFEk5XD132/saDJeVKhYxABwNFrNVMV7P2he3nDi3+oksaQkQxVMSVga7ABxYc0Lu"
    "yZ+snjtxyxcarECqoIVUHXBUowGWSl1RFKVXbrj5xP2rH0tdNQGCeKqLlcEuZJGCFSckUfp4"
    "9f4TN9/wigRq6JXQQjLkiC1U2xx0VOKnN91636MHQqN7EnxIL7exMthFm1+G1yeFunDw6H23"
    "3vSpCOK5xjZaqKMCTodHtVVjgGryu5DT5ETIqWabWBnsojnhNJkm5Lwrwwpq9S20UEsBnDaW"
    "mOWrhrOuaJ8/8MgBx1ydA8a0nOV9sjdwm6tnoXed48vcwSMPfK5VjHAmj0bwEuC0aFTrpaIp"
    "4coTB2y1Mwe+VznLYmWwC5bNwq8+xxbZgyeuCGZwqbKOFuIgB/eEueL+RI03vq2U27Ogt4vZ"
    "SZKLuUcrE65l4YjO1vYr377RmMQWyjm0LNsL4BQblf2yMAvaXwjhwC4CnP1Kw/qSETiFPUSA"
    "A4x2IRPcHujFZxk0br8U2h43B8ye/RAOnKHXxykJd4Dx3AvmZOCQ33Fd7Zlwlpx+oxnXjgX3"
    "Hyoap4XNohzWb6VWHHx62eHQbMt2WuY/teeegxXEw9qT5i2vZvAwzn6VT0CO02+McDpt6PSp"
    "U+bf9N+MuEQF/YL4PICeL7a12UK9Wr5SclTlN1YMjv2cgqfSeHHIWm4H/lX0s/8wOCvnmbIT"
    "WMbWA+D5NmNj3KuVOsgCyF2cMyq5i7NutjfOmtsyytkj46+wWDb7fW6DdSKFoxJi/zqXUvBc"
    "Jr+EHCHNzMUdJWBrgJ5fNDsL6O61lFF6MWsGUevW8K4knMDZBOoXlvLecybXMmRVUrBEWnq8"
    "98BCE+br8eUuWrWeUr95zr1JZNjQf5P3kpp8re05uXPks4F9tHOSALpGzsqu/z65sjuZlCju"
    "GjkJMYDThUuGS+GcVIP2hsVtzP+/sfRf654Kl0CX6t2w/SqwxARx3nr8YVOPvxnAofl22P7b"
    "0wXCu9Npj3LlL6auOD3pbQ/dpMP2E3fXsd1ps21xxc5ilbf/DPU2csfLqXXyYfuj42zL23Fx"
    "M7k3pHx27NixzxT7WlY8HJqXlsP2e8e5Hd4DiqPJ8nev/unV75AbHg7NdvbC96/HSy3PVIhL"
    "6Caf/LqMXbrbwzRF9ywg/S5gc80DiveABXAELYWtroRzaIbvPus9miGcl6xfEOp417k4GFTE"
    "OTTb7G4QDmaI5z9rnQbL0A4rLl71Fcqh6RrfEZ+NeP4zHm8uXT4SeM5O+We7ARwZpsaG6nzr"
    "qrSXiXyeBebkhcyFCmuPdkLq+qpnWD5DEkfnMhd+wfkcLArOG+20Yaaw66s92kkFfvl5I/6l"
    "FgLPAad4TtsJOgecIifgHBB4wun9PgT3lphvrHtSKCI20u9qfJI6Yy33vjr/4Fg98Ee/hZ8H"
    "k2bLAu4tsYRomvPN5S1RDvSEU3tOXd4S2yICnnBqHJe3RLMD6AmjKNJ64PKW6C8VoSeMop8B"
    "XFekjMjBOHUAAAAASUVORK5CYII=")

#----------------------------------------------------------------------
aero_dock_pane_denied = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAAGcAAABlCAYAAABQif3yAAAAAXNSR0IArs4c6QAAAARnQU1B"
    "AACxjwv8YQUAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAA"
    "ABh0RVh0U29mdHdhcmUAUGFpbnQuTkVUIHYzLjM2qefiJQAAELhJREFUeF7tnfmPHNURx81v"
    "hEsCIQQCxCnu60d+AH5BCCGBAAkEP/AHABKKkEhCCErCHcA4WGAIYJwYbOMrGHzgE9vYxvje"
    "9drYa+99etd7zHov766PSn3avFFvu3v6dU9Pz2Q9K5Vmtt9VVd9X76zqOWtSCf4NDw9LfX39"
    "pMbGxklHR0YKxuHvzj570tVXXz3ptttuO6tgjUykioeGhuTbRYukrr5eRkZG5OTJkwUj6qcd"
    "2ptIOiyYLFV79khDQ0PBAPEDm/Zot2BCTZSKFy9eLGNjY6mCc+zYMaHdiaLDgsmxYOHCVIHB"
    "kvij3YIJNVEqLoNTwkgWAxysp2w5Fp2iDI6FkoqVxYBz4sQJSYPM6q1sORaIoyRAOX78eCpE"
    "W+VhzQIYsgAOwLC8TYvK4EQAB1DY66RBtIX1lIc1C4BQEgobHR1NhegAZXAsgDHDGgrj3CsN"
    "ohMwjJYtxwIglITCjh49mgrRAc5YcGpqa2Xjxo2yZs0aWaiKR/m5aNonn0hLS4vodUEq1NTc"
    "LO3t7UK7YbzBP3IgD3JZ9LXSzLJj505Zvny57Nu3T7p7eqS/v9/qzGzBggVO3h4tkwb19fU5"
    "wyft2lxPGN6QC/mQszQR8OGqqqpKlv3wg7S2tloJ61UISjpy5IgcPnw4FaIDMITaguPlFzmR"
    "F7lLGqRdu3bJ1q1bnTHcphf65UFJvb29cujQoVSoq6tLuHmNCw4yIC9yI39JAlRRUSH7q6tj"
    "g5I9RlFw6M1tbW2pUEdHh3D7mg84hnfkRw8lBRC3iNu3b88bGGenruDQm5t1oo5KKDpqGSx0"
    "cHAwEXDgHz2U1K0qEyMbx7hDmbtcXHDYSDa3tDsbyigAsVJLEhz0gD5KwnpYrcSd/IPmnKiW"
    "MzZ2TOoaWuWPr051PvnfFqCkwUEm9FESq7jlK1YkYjHuOScKOAMDA9LRmZG/vj07S/zPcxuA"
    "CgEOsqCXolpPtU6ABw8eLBo4AFDb0CX/+GjNacRzG4AKBQ56QT9FA2j9Tz9JJpMpCji0W12b"
    "kQ//XRVIpJMvlwUVCpxebXfDhg3FA2fp0qWJO/7ZLAhYalfXD8nsJR3yr7ltgUT63oODzr4p"
    "CKBCgcP5IPopmuX899tvndVREqu0KHMOe6DhoyekKxNOg5qP/GmDgzzop2jgFMIZ43t17mO/"
    "woon13CEwskXRrmA4YC1s7PTOS6i3SQ7WdFvVwsBDmdUu5VYsbFBZNgpFBlgOMTcvXt3GRyb"
    "3slwgMKYK9ggFopYLOzfv98Zfmz4ipqnqBd4hXRjqqisdPyX5+txTqGI+mknaResknC3KiQ4"
    "SSsszfrK4KTkdBgX1JJYEKTpAJiWo2G+7STuqLh3715n0xR2j+5O59496nyweMkSZ2WUlsNg"
    "Eu3AL3xHkZXNtI1fgluf6B8cxu2N4ob5sRTFfKOYPlfCtXV1zgrJT3HcSm7dtk2WLlvmHB6u"
    "WLmyoLTmxx+dC7IgEOETfuE7ipzoxejHdpV3WhhkPmF+NB6FYXdeDciVSl0peZWybv162aO9"
    "B2Wk4VjIMh1w/ACCP/iMI2MccAyI2TDIfML88gEHx8Hvvv9+HDjsO37QiyrbnpZUPgBatXr1"
    "aR0F/uggaYOTDYPMZ5efDzgodv78+eP8odl0couYlNJt62EopV2vbzb8xQHGLAiiDmuG32wY"
    "ZBmck473TRkcz95knvZM97zSE9FyRvTgs2X6dNn3zDNSdd99DvGdZ6RFtRzvHAd/xbCc7B4p"
    "H8vhRDjungChg8AJu4Y4zssd3nxTKq64QpruvVd6nn9eMq+9Jn36rOfFF6Xp/vul4sornTzk"
    "DQPJWE4QOHFkRAb0E9Z2ULpzLpfPEcwhbTzuPgKBAccdScAlGsNLrt46qouG3Q89JLU33yyZ"
    "d9+VgVmzfCkzebLU3Xqrk5cyueo04HijGuAvbiAX5dBPHMsbZzlUEEfJHOUzidoseU1AFHkp"
    "4wdOd3e3A04QL2O6vK56/HGpv/126fv4YznyxRdyZOZM6Z87Vwa0p0F85xlp5Km/4w6nDGX9"
    "6oUPnApp1w8cd6wQfNvEDpl86CeqXo23bNZy4vYOLrJsgaltGpL+wePZ/DDttRzAYSlthPMK"
    "1qIK//XSS6Xr9del7/PPpV979oC+t2bQQzwjjTzkpQxlgxQFOLTrB46788E/ctgChH6igjMu"
    "0s5EksUJ8WvVxsMCnGhsT3W3zFx0SBrbT0WrUcaA447DMeAY63LzNKoK3HXTTdLy5JPS9+mn"
    "MvjVV1ZE3tannnLKUoefnAYcb0yQmRPhF57gHzmQB/5zyU5+9BNVr77g2FiANw9XyTAYFOh0"
    "7NhxaTuUkY9nVsknczTmRoUz+WF63rx5zjLWELefpgd72+pWT5bKSy6RHp3kB6dNi0S9b78t"
    "lZddJtThJyebUNp188J3+DP88gn/yIE8yIV8QbKTH/1E1eu4MEgsJ26YH3f8CEHP89LIyKh6"
    "X7bLW1NXyZQvK7PgIAxlcoFDurdXNrz3ntTcfbcMqKI7dXXWpRbRrcNWr1JGqY/5R6lfaRDS"
    "ZwOap++555wytffcI9Th19vxbwsCB36RjU8DDvIgF/Ihp1d2+Cc/+gkbWfzSs5F2JszP22ts"
    "/m9qavK9Qqa3tLV1yqtvfiVvfbhSpkw/BU5D22gWTPLM1Z7pFowdNUrimbf9mpdektZHHpHB"
    "l1+WtqeflhNaPuzvpObpffhhp0zro48KdXjrRTkGHK+S4Y/8WBaf8I8cyINcyIecyOK9Sqcu"
    "9GOjR3ceM+RnFwQ88Ov9Yc84oEMwor0MUaZqb7W89Mo/5S9vGHAqZJoDzql2KEObCO8WyoBD"
    "urftuldekfYHHpChZ5+VVlW4LTg9N94oA7paa3/wQaEOv14O73QKr4JN5yGdcvCPHFOmVzjg"
    "IB9yIi/pbj1QF/oJ06EfP8w7WXColMk4KuGEwUbLG+hEfc0th+TPr/1H3piyXCZ/vlM+mtUk"
    "dS3DTuwNUWsAMOebb8a1iasSUWKcsXl5adBhqvGaa2ToscekQ0Fqf/996fjgA+nUvc5hHba6"
    "lLqVmF8ySn3vvCNHdH7KXH+9DN51lzRee61Qh7de2qJT0K43Df7gF/n4hH/kQB7kQj7kRF63"
    "DtAJMjohlxH1yuGvEwZpNqE8gMGotEfjclguMvG5yXH602HgYG3raeAw6cM8AnnBYYzmHoc8"
    "Xl7ata09uiAYUksY1n3O8J13yvAtt8jwDTeE0pDmoSx1eOs1bQWBQzqy8ekFB/mQ06sD/gcs"
    "9BNVp4DphEEacOg9cXzDKvWGEIX6RT4z3jJZNrd2y9QZFfLR142OcMZhkEDZ2XPmjIv7pB7A"
    "QSA/fvY+8YS06Z5l5KqrIhFlKOtXp7F82vXGocIfvMAX+RxwVA7kQS7kQ06v/DwDUPQTVa+0"
    "50TaGXBAiyElKhEDybjKhVQQMRxU/tohMxa2SG3zsMMsgGKtRnjTuww45PHjpWHTJtmhFtB5"
    "8cUypgq3IfJShrJ+dRrlmU7h7unwRzqy8Qn/yIE8yBUkMzoBIPQTVafZMEgDTpR4GLeL7E4N"
    "nILBWo3Jz0X0yM27uqWj62i2p2Gts2fPHjdWUxdKyuVCWztjhmw5/3ypvuACGbrwQjl+0UW+"
    "RBp5yEuZINdeE3tKu965E/5IRzaUDf/IgTy55K3Ta206GvqxiRFy58k61qcFDkpHIAREKBin"
    "581S4d1mj1Bh4CBInZbbfvnlsv6cc2THuedKzXnnSdNvxHeekUYe8ob5XAMA7XqHIPgz4BiA"
    "kCOsQ5YMODBSU1MTidzguKOmcaTAAyWX5RhFN+p4Xv3CC7L9uutkkwLx02/Ed57t1zTyhPVc"
    "t+V4I7gBh7kjqnwAydBWdMvJFxz3Kg+h/MABTNLwa8bRfceOHbJlyxbnNSfr9HUna/REYLXe"
    "5zj02WeyVv0BCFz65ZdfnOhmXJtY1qJklOYGzA2Od9V5RoKDgpxhTe9i3BMmygsChzQUjEfM"
    "NnWd+vnnn2W9euqsViBWqAvVMh2WKMvR/6pVq2TdunUOeOblDfiDEQpoJmsDUBYcLeudvOHv"
    "jLOcXOAssRjWmLsMoWSUapTtVrCxhFwvnGB11KJDF6CWJDgspcPGZr90xtQ4wxrg0ObX2jPd"
    "9dKzbcAxgDCBU09YAFWudI71N6kVQl4Z4a+oloPfGmv7sEiypMBh7qAu2uTsyguO7YIAfhka"
    "cZNFBl/SNHzPoKB0ItoYHv3kgz8sNGoHjLsgcEfaOa/vx+OTSZYeGDWSjIkW5rEEWzLA4GH5"
    "o7rC+oETtAl1DzvuzaPftQXPOC3GullIeA8YOSLhgBF33wMHDviCA3/bdEFBR2BRYisjeSmD"
    "fqKcELgj7bJvoYobSVavoLDTj3K4xxBDwNIc3X379dZF333nDFNhdbKJ3aUAo9ygV7sMKwAr"
    "NZ2YTz8vFywPP3GUGTSswycdyQyhYXyRTr20iX6iROU5kXb67oLTAn1BmfE+apQBzDM22xK3"
    "iziPBylj8+bNjsIChyrXEIYL7QZdkSGMH9+LtB42l0EysQjYqUcsYfMt/MK3rYwswRkSo0YZ"
    "oH9wSCQCG6HjHv2EKYQNaRiF1VGs9HFHMIloOkYlhQSnWIpNot0yODHex5aE4m3qmPDgrF27"
    "1vFrsx3n4+SjftqxUXiUPBMaHG5I9+nylxVPId8vTf20Q3tRlB+Wd8KCw96CV2EVEhRv3bTn"
    "3XOFAZArfcKCwxIU/4I0wcHZxHta8X8PDvsLLp/cB4/5CEVZ5g4bYDJ9w9LaMRRKPZlTDn65"
    "CG8X7zlfPnJw0gLgRX1rFOdg5qglH2HcZW3B2b2/V+/zm2TqzPpAIn3HnlMv9U4LHHM+xglG"
    "Ud+3xpsKORS0ubm0Bc8WHJS9Wx0t3v10eyCRHgaMSU/KcgCHjTmfRX1TIRMpxx9x3uccBJYB"
    "x8aNFcX+Wt0qf5+87DTiufHLDquLfEmBQ0fljAy3qKK+45NDBW4gjWuVrXXkyoeSgpzj/Vxb"
    "UWxTc4f86W9fZon/jQN6mDuscTpPAhwzpNEmTooxDl2SLcL7k9krcNydxMIAJYUp1Js+MDAo"
    "+6rr5Pd/eM/55P8odSRhOcjO/IvVHNQr9ZJ4rzRQc5qK9SSxODDgRDlqN1EANbUN2aiAKOWx"
    "nnwtx7jssg0o6kLAa3tcDOFMkQRAKAnFuj32bb97Ix5sypmIhrjgYDEAw8hBXRvVs7Tkfq4F"
    "11NcloxXftwhLh9wbMDwy8MQGAccM5SxOgMYLv9K9mdaYAwLYtxlc8owR68y18s2CwaUhAJx"
    "dE+DTOyNLThGFlZlWAuyUgcWU7LAmKEOk2YOOqCeNBwsYkkIwXLb5j6dW0R6YRrA0AaKZc7x"
    "ugb78crOH1kYvimLxRlfu5IbynKt+xjimBj5xAnEHAaGTdQmmgyA0iD48Yuy8+MTMBw/N51n"
    "cBwx8iW7/k2xNvevHdr4J3DvzqkDG7g0iJ6Psm3v+yfErx3GxR8Ai/KDeoRclP9yawBwmGRT"
    "/0G9MjjhXRNw0vxBvXFhfuHsndk5ACduGGTUED/yZ39Qr2w54R0vbXerkrhSDldLaeQog1Ma"
    "OPhyUQanDE7WFao8rEXoDGXLiaCstLOWwUlb4xHaM0tpmxPsJPKUh7UI4OQTBhkVrNPC/CLw"
    "eUZmzScM0uZKwp3HN8zvjNR6BKHjhkGGXUd40wPD/CLwekZmjRMGaXMl4c6TaJhfAVD6HyAO"
    "VvwtWIicAAAAAElFTkSuQmCC")

#----------------------------------------------------------------------
aero_dock_pane_bottom = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAAGcAAABlCAYAAABQif3yAAAALHRFWHRDcmVhdGlvbiBUaW1l"
    "AG1lciAyNSBtYXIgMjAwOSAxNzoyMTozMiArMDEwMExUiZ4AAAAHdElNRQfZAxkQJgE7q5VA"
    "AAAACXBIWXMAAAsSAAALEgHS3X78AAAABGdBTUEAALGPC/xhBQAAEFtJREFUeNrtXVtsHFcZ"
    "/me8a+9617Ed3x3HcXNxnDhxmsShQQqEolKq0pLeVakSqA8g8YIEQvDAC0g8IB6okEAoPEBB"
    "QEvbJKWFJqBSWpSUosYpdpzaiXN1Yju+xJfYXtu73hnOd3bPerz3uezMoPqTRrM7u3PO///f"
    "ufz/ucxI5EKEQiH16tWrdP36dVpYXCxYPn6fj1paWmjdunVHmpub33Bab9djfn5ePX7ihHrl"
    "6lV1cXFRVRSlYAfSRz7Ib3Bw8FmndU+G5LQAyeg5f14tCwZp06ZNtuV548YNmp2bo47du11l"
    "D9lpAZJx/do12rBhg615NjU18XzdBteRsxQOk8fjsTVP5Id83QbXkbOGFayRw6CqqtMipMUa"
    "OS6GvY27DthVmiXJVQ7aKriSHBBjZ1PjVoI+8eQgn6KiIqdVTotPPDmoNW51CFxJDuBWg9kJ"
    "V5Jjd5/j1oKwRo6LUXByBi5fVm+PjNDS0hJNT09TLpOPjY3xIxqN2mIASZbJ6/HwPF997bWs"
    "4sGnq6iooJKSEqpvaKBtW7cW1M0rCDlHjx5t29/Z2TfOFI6Ew7Rj504q9nopGAzmvPfYsWNU"
    "Xl5OkUikkHonAE/N5/NRbU0NPfnEEzn/Pzc3x2UbHR2lkydPqjW1tdS5f39BSLKcnJ6eHvXm"
    "rVtUX1dH+/buNZQGmjS7ao7IL1+IAlZZWUltbW00PDxMf33rLXVjUxN1dHRYSpKl5Jw7d05d"
    "WFigLz74IMmy8ZEhEGNbs2bSlW5sbKT6+nrq6uri+u/bt88ygiwbW/voo49Uf2kpHThwwBQx"
    "AIylKIotBwqBWecD+kJv6A87WGVTS8jB7OXy8jJtb221RChhNL0H+g+991jpGUJ/2AH2sCI9"
    "S8gZYn3Mvffea4mCRoHZ03BE0T2LarXLDjvAHlbANDlnu7rU3bt3Ozo+VV/fQNcHR+jnR1/l"
    "Z3x3CrAD7AG7mE3LNDnj4+O8U3QK8Jomp+boty+9R77San7Gd1x3CrAH7GIWpsjp7+9Xt2ze"
    "7JgRQMDoxCK9+EoXlZbVJQ58x3UnCYJdYB8zaZgi5zYLxGpY8OYEysrKaGh0mf7y7gj5grUp"
    "B67jd/zPCVQzu2DUwQxMxTlzs7Pk9/ttVzwQCNDoVDF19c2Sz1+V8X9dfUu0Z3uQGquDPLK3"
    "VUbmVt+9e9dUGqbIwXIir9drq9LA4uIiNTdUUFWlL+d//ewvM5MztssIu5hdbmWKHMQjVk/x"
    "FpeU8PgDgR3STwf8PjV5Oy8PcSaUebQBsovYCPlajUzy5wvXTRnc09JCo6ytbmxo4AFdtjgk"
    "H+VBQKZFimLQc2hoiFpsXP6bL1xHzq5du+jE66/zYXyMWRUXFxcsL4wuY+Cyr7+fHn/sMadV"
    "T4El5FgdZT925AiGQOj06dO0uLRUMOV9rCnb2NzM87NSB6uaetfVHIEOFmXj+CRjbcVnAWBV"
    "LTRdc9bm+1NhVbOWSKW3t1fVu80PEbDeEQJ4R5tYO79z506bTGUeH3/8Md0YHOTxVb6AYcfG"
    "x6m2tjbve8Q2SOYUSSINwra7PXv20IbGRl3eEQb3QI6emhNmgdkQ85C6u7vpy48+mvI7PKjz"
    "vb08bbi6hV4qCze7av167iWmwxtvvklGbAO5hX2M2OaJxx+XJDPb/JB5dXW1IaNgqx+GN9rb"
    "21ddP33mDE9z65YtpmdU8wEKw8DAAP+cTNCFCxewmdeQbYyQo7UNtkHKTmzzA/hWPyaEFhj/"
    "whqEdtbkYfkRhkAKfZSWltK2bdtofGIiRUbI55htGC8eJ7b5AcgzzGIYbZOIz06s90cNjaYZ"
    "jYB8TtkGvKy50i6GY0Eod8FpdUzgtEOeXHOckkfIYYocMzFONi+MN28u2tBkVEez8V+CHCMJ"
    "qQbvy6hAUv9jN9LlaaYAGrWPKJgeIYCRuQeV3ZOv8Oh0xX+RebqaIdIxOw+i1xDZ5NfaRsid"
    "Sz6hmxpfuKhXHnG/rDWKXugh5sZwmBbDcs77rKiNenUQ+Wb7HYD80CNX/CX0M9Qaae7zJF/Q"
    "lRDlNiSi/P4rM3SuL0KH71tPDVWU4j5nM4idyNasoTRP3o3SmXN3WSzmpbYt5TnXcxspaNoW"
    "xVSfI/qITPd6PF4am5il9/4zTLK3cpWy/J6kQqHmSK9QyJhvSg2QaH5hmekzTuvLi6i2uoyW"
    "lyPZEjalS6JZM3JkWyAuSTIN3hqjF1/5kMLLikbe3AIrmr7MriMbcUIeAegDvaAf9EzWXWsf"
    "IzYVeclaAfQemQRAhHvnzjT95g9vx2qXmihIq/+bVDBE52nnLoNkIrLJl+An9gPXD3pC33SF"
    "1oge2hpsuuYkC4A28+LANXrhF3/UeMYqiW43uXSkK7121pxMsmivrfxnRQ9R2KAn9BVeXK6C"
    "m488ArzPwVB12MAaKwxSzs/PpzQLLc2N9M1vPEu//PXfUkoG5kRERyq+J5oLJgPSwkixXe40"
    "PC/kh3yT52uEfJAL0wWK4k/RB3pWlAdWLSAEUUgX9sGhB3CghDfIyTG6k0y7x0WL2dlZqq6q"
    "pOefe4D+9Mb5FIWT23ABUXqQpl3k5NP/ZZIH+lVXldPU1NSqdETsZNSuKa60IXKyCI65jOam"
    "evrqMwfoxN9vJjw7/B/r0bRVX2sIrUHsQKYmRfyGa5A3MTrNrnk9Mj3D9IK3Njp6O4XgxGJF"
    "g3oIOTxmjKFkqDkCw8NDfGf04fsaeJyDvyXXnHT32rknVItMsqzITBTwF9G+fQ3sLHH90kHE"
    "KooBPbQBrrkgNEOJ0wJVvrFmHYWW/BRkCi2FIqvinHQ1x85FI8mOSNKPCf3QLwVLJWrb7Gf6"
    "KFyvTBBDMEb0SHGlCw3McG5tUhgxY4nnC6R3VZ2dNEjnSgtAbsgPPezasWDL0ihU7ZmZmYz3"
    "Jz7HLtiieC5Z0umnx6u1oqA5vuIz05SB47K4AI6QkzBChrE1R5CuBXCYLMdrTjL0mEN0vGZm"
    "TeHyRpir7ManFXqEknZD6xBor+ULEUsgckccYhTLrD/EOrGydetS8ne6kfOUMOVy7SSzEtrd"
    "ZOm2LOZbTJAO1radef/9zM2PZtZSTlcA4+5uOSNmc5pd4ZDPKduAF0/LPffwx1Nh77wYY8oX"
    "iJpx6BEcmcOo2LRUk2G1aD5NFQyGZ7jh/Pn7788Ypff29vKFg83NzSn3Q/Z/vPMONTSkf6gE"
    "5Mt3l11y3sI2eta9rdpp19JCHrz54tjx46rHwE4ybGzCclU9UTCUHB4Zob6+Pjp06NCq3yAY"
    "2n8YLpcc+A9WZEJulPB0fQbkm5iYoIMHD6bd9Y1AMhQK8cKSDlgJig1c2GVXV1eXt20EOWFW"
    "2GGffMF32sE2/f149ttK8ezu7lYHb97UtZIeuwwqKyr4GFK+wEPxqliJbGWKp8OtW7f48w08"
    "eXTQPmZwEIpxvHS1F2l4mUEzjQwHAwGqZUavybHe+9LAAN1hJIfzfECfIOfOnTu6dhlAl+aN"
    "G7FwfmWXgVHgsYufO3xY97B4PsjHEMUObLPPByAGNebkqVP09FNPGbax61xpAbca3k6srZV2"
    "MVxXcyZCsfONSz3051ulNLZYuPJT61PoSFOINrV28O/VpU5rvxquIwf4/qmbpO74Ej3wnEqb"
    "/RLBzypmLTd8JQ87w1XIlzI4v/Alo+wDQtUldobLg3HlgZBKR/8lkXzqffrRQxudVjsFriPn"
    "2sVukrY8TD/+dJQCKotVmDU9MshgnyUeN3IvRk8vC4LgyymY7GOxyjKIYhcOSCo9eb9M3104"
    "yPJ9i6r37nFa/VVwXZ9z/GaAWg5JVBzNPnwiM3ZAWq5DzsIiSPJGFap8KJav22Cq5ojF6Va+"
    "SWMqLFOrTyIlS7gFgxezdurufO48MXupsrZQyfBX1KhGv0wXwtaVU2EPs3taTZFTYnLQ0SiK"
    "mc79A/P09r+naHImc/7ryz302c4K6thVRss2LUkQy6IQ7ZeYfG6PKXKCZWU8AEVka+WCDJRm"
    "NcMBLLKsdrQFCdXrxWMXM6bzzIPbacfOMprX8KddtCnGFKwe0wQ5WM+nZ+gmHUyRg0fiT8/M"
    "0IZAwFpy1JVVvPwM48mxz+hCmJ9AIWbw9vYa+lpRhF741bspaXzr65+j1rYamouoq9NSNekX"
    "YE5ADKjemZzUNXSTNi0zN7e1tUl4wweEsXJOCGRE4h4VXGDhCic8LiV2vhtWqXV7I/3wO1+g"
    "2akbiQPfcR2/KyoljmjSZ6QfUVZqkFmIMTUMkGJkGfYxk57pXrCuvp4/RgQCWUWQwpcjqbFz"
    "/FAZY/wzxY/49ZmwQg11FfSD7z1NodlhfsZ3XE/cS0lpaNPla9KsIUZM/uEpHBjFNgvT5OD1"
    "JFeuXOGCWfU4FBiLxyKa0q4t9YqoRRSrVRPLRdS+YzP97Cff5md8j9LKfxK1heI1UV1JP6Ja"
    "M+MJvcXUxaWLFy15bYsl/iMeNIT5GZQaKwgSzZmS4VCTDlwbXiCqaNrEz+n+I/qcVWQJYkzU"
    "HOGdgRg4Rt09PSkTe46Sg/fG4HHCeOoUJq7M9kFKvERHNCVc2+9oa4D2WIimvw5nTdTCaLxW"
    "RuL9TTievlFixMwuZlsHLl/mjyy26j06lkVeeG8MShAef4USJEjCNb0rZBCTRKLxGqQ5lLhx"
    "hUOQ96HEak1UWSFIOARwMvX0OUIX0b9ghhW6/re7m2di5ftzLB1bg2B48xSe/NTa2spdbQSp"
    "Yv4937UGsT5BZWcczBCqFO9n4kUc42s6SrtKq709ni5qUHzYQEiVa75fNGEgRkyPYy3ERdbH"
    "oClz9ZunACHg2bNn1YFLl/i6BDzWCorkG5Rh0GFZiZdsOWZYGUaVKNF7yzrMkOxOC/cczZmk"
    "rtScXPKBHOw9QuCNKfqRkRGu3yOPPPL/8c42gc7OTi4w3nY4ODjIV8pMTU/ncWc1vTypUh1r"
    "19aXSFTmlShQJJGvKDZs45Vjo9NFOswhRqHDjJ0ldp5nF2YjGMdTWCWU6CWW1mH2P0wr50Kl"
    "5m2H+wv0Ij2Bgk8Z6H1d48M/fVddZDVnjhmuRJK5gEXc3ZJILYr1HXrIEU0ayFli5GDoZ4GR"
    "E2Lexnw4FutEIrHRDTPz/YWA6+ZzgKVIbHimlElXwuzGKg9vxkRThgk3RSc53DNjaS3FD3h2"
    "yIM7Cvbv08oLriQHrto8K+oBZjQf62iK0ZRFV1xLVSc5fJiGsRBG7Ymi9sSO0HJsSfAaOXrA"
    "SjSatiV2hFlThqkWT7wp45zIMYLygSBHjKMlalA8D441cvRB0RzZpg9yIdO9Im03w3XT1GtY"
    "wRo5LsYaOS7GGjkuxho5LoY7yZHtE8ydBojBda50tV+iAPNxg8VywQ3nY9oHvDKVxfN1G1xH"
    "zvO7vfTPniLa8Jko+VlwGGTRZ9BL5GcRaElRbODTY2BsLaJI5FNUKmH3e2WViotUquHPspGo"
    "6qREX9nrod85rXwSXEfO/o5d1P7hB/T7Cwdpx6dU2lYqUwUjJcjI8LOqVMLO2Lnj0TNCoMZm"
    "PBfYMc9q5TQ7JhljlxaJhk4TtSkfUOeeXfklaCNcV5dVhunpafqw5wK93K/Q7fnCxfH1AZme"
    "bZPpQEc7VVRUYL7GVfb4H1Voiukj7VWUAAAAAElFTkSuQmCC")

#----------------------------------------------------------------------
aero_dock_pane_center = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAAGcAAABlCAYAAABQif3yAAAALHRFWHRDcmVhdGlvbiBUaW1l"
    "AG1lciAyNSBtYXIgMjAwOSAxNzoyMTozMiArMDEwMExUiZ4AAAAHdElNRQfZAxkQKidFE1+x"
    "AAAACXBIWXMAAAsSAAALEgHS3X78AAAABGdBTUEAALGPC/xhBQAAEAxJREFUeNrtXdtvHNUZ"
    "/2Zv3l2vb7HjWxzbcRzjJCQOcSKQiBSQEBclFAgX0VYt4qnq9blP/Qeqqi+t2gi1BaQCJYQg"
    "oAQQD6VKHhBxwCGJc784dhzbcRzHt73O9Pxm96xnd2e9c9uZqdifdLT27syc832/c77zfec2"
    "ArkQS0tL0pUrV+jatWu0HI2WLZ9QMEjd3d1UW1v7TGdn54dOy+16LC4uSu8fOSJdvnJFikaj"
    "kiiKZUt4PvJBfqOjoy87LXs+BKcLkI9T330n1UQi1NXVZVue169fp/mFBdq+bZur9OFxugD5"
    "uHb1Kq1bt87WPDs6OuR83QbXkROLx8nn89maJ/JDvm6D68ipYAUVchgkSXK6CKqokONi2Gvc"
    "dcCu2iwIrnLQcuBKckCMnabGrQR978lBPl6v12mRVfG9Jwetxq0OgSvJAdyqMDvhSnLs7nPc"
    "WhEq5LgYZSfn4qVL0q2JCYrFYnT37l0qpfKpqSk5pVIpWxQgeDzk9/nkPA+9996qxYNPV19f"
    "T1VVVdTa1kabenvL6uaVhZyDBw/2D+7aNTLNBE7E47R5yxYK+P0UiURK3nv48GGqq6ujRCJR"
    "TrmzgKcWDAapee1aev7AgZLXLywsyGWbnJyko0ePSmubm2nX4GBZSLKcnFOnTkk3xsaotaWF"
    "dj7wgKFnwKTZ1XJ4flrBK1hDQwP19/fTzZs36d+ffCKt7+ig7du3W0qSpeScPHlSWl5epice"
    "f5w8HuMjQyDGNrNm0pVub2+n1tZWGhoakuXfuXOnZQRZNrb2zTffSKFwmHbv3m2KGADKEkXR"
    "loRKYNb5gLyQG/JDD1bp1BJyMHuZTCbpvr4+SwrFlaY3of/Qe4+VniHkhx6gDyueZwk546yP"
    "2bFjhyUCGgVmT+MJUfcsqtUuO/QAfVgB0+ScGBqStm3b5uj4VGtrG10bnaA/HTwkf+J/pwA9"
    "QB/Qi9lnmSZnenpa7hSdArymO7ML9MbbX1Iw3CR/4n987xSgD+jFLEyRc+7cOWljT49jSgAB"
    "k7ej9Pq7QxSuackm/I/vnSQIeoF+zDzDFDm3WCC2lgVvTqCmpobGJ5P08X8mKBhpLkj4Hr/j"
    "OifQxPSCUQczMBXnLMzPUygUsl3w6upqmpwN0NDIPAVDjUWvGxqJ0cB9EWpvisiRva1lZG71"
    "vXv3TD3DFDlYTuT3+20VGohGo9TZVk+NDcGS14bYJXN35mwvI/RidrmVKXIQj1g9xRuoqpLj"
    "DwR2eL4a8PvsnVuaPMS5peKjDSg7j42Qr9UoVn6tcN2UwYbubppktrq9rU0O6FaLQ7QIDwKK"
    "LVLkg57j4+PUbePyX61wHTn3338/HfngA3kYH2NWgUCgbHlhdBkDlyPnztFzzz7rtOgFsIQc"
    "q6PsZ595BkMgdOzYMYrGYmUTPshM2frOTjk/K2WwytS7ruVwbGdRNtL3GZUVn2WAVa3QdMup"
    "zPcXwiqzln3K6dOnJb3b/BAB6x0hgHfUxez8li1bil7zuze/oKszMQoG/GVfjenziNRZH6Df"
    "vvxo0WvOnj1L10dH5fhKK1Dqqelpam5u1nwP3wbJnCKBP4Ow7W5gYIDWtbfr8o4wuAdy9LSc"
    "OAvMxpmHNDw8TD94+umC33/9189ocGsvdXa0UjjooZDPQ1U+gQIs7vEyI+xFbOKBPRZID28o"
    "okgSpZj3nZLSnzHmit9ZiNHvX/uCHtpSr0rQhx99REZ0g0rF9WNENweee07wmd3mp9ekQUDE"
    "Mh5W+DNnztDWrVtzfl9IEj390Ca6siBRiMWYQZb8HharMEIYR/J9HiHdWeppUygloiIRJLEy"
    "J9mnl30RYh7bL3+ylw59/lXBPSjfAzt22LYFUqkb8OJxYpsfIG/1u3495zuMf3kzzcHOXizC"
    "lJJIFeaI8jmmG8aLz4ltfgDyjLMYRtnynHYs8vNH+ZzSjcyLo9pYBTBBkuKTKLc16aVR7V7+"
    "fLfCMXJkF5xya6uUSegX5I6bWTjRw/uJdB/D+xk5QNPtEKw8S5kkRZly7nFQN4ApcszEOKu5"
    "yFBiEuR40iSJQlqJnsxvQuZTTwTNSZA/FcSkpNKtx6iMZs10lhwjD5IM3ldUgMzf8KbizM1N"
    "sH99EnOdQYzEGwquSXtseqq20lNLZUiBxyayL8UMPWqymKmARvXDK66PF8DI3IPE7tFaeMzP"
    "8GuRuVrL4aYua9bEXLMmtxp2m8BbgU6zpmraKNe0qZWJ64aXu5SuuGxSZuGiXmL4/R5eACPQ"
    "Q8z1m3GKxj2a7oOy4kymRKZ2pxTmhys0Jan3H8WS2v3Z1lNCRg6UH3KUWtHK5TNkjRT3+fK/"
    "0PUgKk0sJrTOXZ6jkyMJ2vvgGmprpJLuM5QWZcFokOkgIGBUQBF0ZrwCj85RHSVJIAR9WkJc"
    "+b5YWZSt/c69FB0/eY+Wl/3Uv7Gu5HpuI2ZNaVFM9Tm8jyh2r8/np6nb8/TlVzfJ42/IEVbK"
    "2Bk1oqCshCQyJQo5LcfL/k+bNkm3KyXmmbQU73vE9FCOqhwFLUCgxeUkk2ea1tR5qbmphpLJ"
    "VbaqmBwUzpo1I2m1BeKC4KHRsSl6/d2vKZ4UFeUtXeAcsyZmPDdOEuWZKK2Jcu9P8WdrMGti"
    "pm/lgDyQC/JBznzZlfoxolOel0dZAL2pWAEQ4c7M3KV//POLTE+crUi51+ZVDPlZlFYaq6AU"
    "Q8qYn4SoIIonSUfK3MOfwZ+ZYGwlU7kVp1j5svykf5Dlg5yQV63SGtGrsgWb6nNEFW8Nfcz5"
    "i1fpzbeOUlV2TZmU4aewdhSaEqJ7rMl8PBqjDREvtYY91FAlUK1foGqfIA+EBjIDoeiLtHQ9"
    "Eq20lDhrRlFGxiJrMsgnzr6fn1yULyrW56ysMlqRg1e2P/75Lfrpj56ijRvW5/RBfPWQXr3i"
    "Hr6qSCYHQ9VxA2ussFFqcXGxoADdne30m5+/TH/5+2cFNQNzIlwI/j+HXAYpXaNn2Z9rWMuJ"
    "sFTlw8h0mgywwYdd9JKTENMtEeQss7SUSpvPWMau5c/X8PKhXBgxFsVQgTyQs76uOmcBIYgE"
    "OdAPkh6AGO4NyuQY3Umm3OOixPz8PDU1NtCrP36M/vXhdwUCF6tR3JRAiXOsn11kaYmREwZB"
    "njRBntTKyIBogJx4SkFQcsVMSkU8DL5XSC1egXxNjXU0OzubIw/fLWdUrwVmzRA5qxQcE02Y"
    "MHvlpd105PMbWc8O12M9mtImKxUBNSXZ9/dYlV5ICDI5yymBQilBNmdeeT4H5jFt2rSSI/cz"
    "8sgDI4cxhbTMUoI9N5GTf66S8B3Kmx2dZt/5WcYvMbngrU1O3iqoaNnFihn96AUvh4//Y+gh"
    "RVoOx82b4/LO6L0Ptslxjhyh57UctXuz3prSAVB6XoqRA63kZO9TxDvcQRAVDkE+eOVLl5mo"
    "OuSlnTvb2Kcgy6cGHquIBlqOMsA1F4QqvJNiQJNvX1tLS7EQRZhAsaVETpxT2HKcQ0H+Cvmw"
    "ADESFqi/J8TkEWW5ioEPwRjRa4ErXW5ghrO3Q2TETGXPF1B3VZ2fbMt3pTlQbpQfcti1Y8GW"
    "pVFo2nNzc0Xvz/5ti8iry7KafHq8WisqmuMzoWpTBnYjHYk7P02eD0fIySpBZWxN1KEfDH76"
    "MytyVs2P0hN3PuZ7C6n0fJC8AgdzOX6JZlJRCvhUDotwmCzHW45RgJgwU2hjFXMyoqVNjTy2"
    "5mGEsM84oyvKUrOXfS4t0emh07S1w/5NYKUgk+PEGZeqawjY31qnAtBimoIC/eGNo6u6q/zx"
    "xUSs8hJtbvPQU1vWuGYNAYevKhAouZPMSih3k6ltWYR+sHiwjv0U8aN1EIV8aSUGPOnk95K8"
    "CnRpYYnVLole+8VjqoEgAsfjx4/Lm3Y3b96c8zvkRf5vv/MO9WzYQJ3r1xeUBb87pRvw4utm"
    "BcPxVNg7D3dRT6cI4ZH0FByZ47wybFpa29RU8PtyLE5hIUX71geoiZkstI5axkgEJHkFCmRW"
    "gGIQ9OvhcVpTlZKfp7a+bJGZLOxa27dvn+pxYpAbY2JNKuUAUD6tu+zylcx1o2fdW85Ou+7u"
    "dIB9+P33pc39/bp3kmGhdkN9va4oGEJO3LpFI2fP0p49ewp+/9vn39K3k0kKBkrv96xj5D3a"
    "lqSpiTHVMqDmQ1iM9amhvq6OOru6qHfjxqJTz9jAhVbX0tKiWTecnJk7d+Rz3LQCjQPHB2Dh"
    "/PMHDqxY4uHhYWn0xg1dK+mxy0AmR0fLwaF4jaxG9m3apPr72NiYXECfhs24wVBIVj7G8dRa"
    "L57hZwotNjIcqa6mZqb0tUVaDseFixdp5vZtims8oC9LzsyMrl0GkAXmdWBgYGWXgVHg2MVH"
    "9u7VPSyuBVoUEXBgm70WgJja2lo6+umn9OILLxjWsWtdabcq3k5Uth26GK5tOZcuXaJp2Pky"
    "vnQIHTz6m97eXqfFVYUryTnGYhMcKjc4OFjWcwj4TjLkt+fhh50WuwCuI+ci84xwqq4du8mU"
    "O8mQ76YiHqRTcF2fA1Nm9+F62L2GfN0GUy2HL0638k0aCMS0nEQVjUm0GC2dZ4gFquHg6t4s"
    "8rPykHGuD7OnBJsiB+M/iPidwOhElIbOzNP8YvHRiZpqL22/L0Jbe8O2lYsviwLZVSb7S1Pk"
    "RGpq5AAUka2dJ6gDfd0hIjFOn/73RtFrHtm1nvp6ShNj9SQbyMF6PgSiZmCKHByJf3dujtZV"
    "V1tOjhaF9fXUkc+bpEMfDxf89uL+AerpqtP0HCunTEBMdlxNx9CN6rPM3Nzf3y/gDR8ojJUC"
    "6ln03dPVSK++NEjL87eyCf/jey0Lya0EH1ODF4iRZejHzPNMe2stra3y6DQKZBVBepQGAtY0"
    "ROiVHz5C0aUZ+RP/a53GsIogPhcjE8NiJ4xim4VpcvB6ksuXL8sFQ7KSIK0JWXZ3ttGvfvai"
    "/In/9W69sIIceH3QwYXz5y15bYslQSgOGhoZGZHnPRB1m315g5E9qri+taVJt/doNgzgCwj5"
    "3NG3w8PUyfRhBSwJQvHeGBwnjFOn+KykU+sS7LiHg5syyBwOh/GWLfnIYqveo2PZCAHeGwNP"
    "BbN4qEGcJHxXbPd0Mdj1ehYj6wK4LLx/wbnakBUtBgsgrHx/jqVjaygY3jyFgcS+vj7Z1YaZ"
    "4fPvWk+ztbvV8TxLzffzABPE4FqYMqyFOM/6GJgyV795CuAFPHHihHTxwgV5XQLOHIMgWoIy"
    "3trsAlc4n70sdS3WIyDwxhT9xMSELN/+/fvLUpvKXkWVbzucvXu35PUQ+sknnrD9hXo49E5L"
    "0Njw//62QyX0CoB1CViqFCvjkcVKgBx05iDGzHx/OeC6+RzA6GYuI6i8m1onjHpSRvOqkKMD"
    "Rg9KMoIKOTph5y43txIDuG6auoIVVMhxMSrkuBgVclyMCjkuhivJcWK6wY1wHTnKbZDlRv42"
    "P7fBdXGOmW2QepG/zc9tcKX9MLoNUi/yt/k5LXc+XFcgDiPbIPUif5uf2/A/9n+1U7cLqMYA"
    "AAAASUVORK5CYII=")

#----------------------------------------------------------------------
aero_dock_pane_left = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAAGcAAABlCAYAAABQif3yAAAALHRFWHRDcmVhdGlvbiBUaW1l"
    "AG1lciAyNSBtYXIgMjAwOSAxNzoyMTozMiArMDEwMExUiZ4AAAAHdElNRQfZAxkQKBW/8myz"
    "AAAACXBIWXMAAAsSAAALEgHS3X78AAAABGdBTUEAALGPC/xhBQAAD+tJREFUeNrtXWlsVNcV"
    "Pm8Wz9iewTYYbxhjjDFmM4SloKwkipI0QiIhIU2VSlV+VVGrqlX6p5XaRpXa/kilVmqriD/N"
    "IqWtQkjSJA2ozdJUQJMGEwwYAwZjDLaxjbHB23iW93q/O3PtWT1vmzevynzS9fO8eXOX893l"
    "nHOXJ5ENMT09rfT09FBvby/NBAI5S6fY66XGxkZatGjRnoaGhnfzXW7bY2pqSnnr7beVSz09"
    "SiAQUGRZzllA/EgH6fX19T2d77InQ8p3BpJx6vRpxe/z0YoVKyxL88qVKzQxOUltGzfaSh6O"
    "fGcgGb2XL9OyZcssTbO+vp6nazfYjpzZYJBcLpelaSI9pGs32I6cAuZRIIdBUZR8ZyEtCuTY"
    "GNZ27hpgVW2WJFspaAmwJTkgxsquxq4EfeXJQTpOpzPfRU6Lrzw5aDV2VQhsSQ5gV4FZCVuS"
    "Y/WYY9eKUCDHxsg5Od0XLyrXBwdpdnaWxsfHKZvIh4eHeYhEIpYIQHI4yO1y8TQPvPnmgtmD"
    "TldeXk4ej4dqamtpdXNzTtW8nJCzf//+1q3btnWNsAKHgkFau24dFbnd5PP5sv724MGDVFZW"
    "RqFQKJflngM0Na/XS1VLl9ITe/dmfX5ycpLnbWhoiA4dOqQsraqibVu35oQk08k5deqUcvXa"
    "NaqprqYtd9yhKw50aVa1HJGeWogKVlFRQa2trTQwMEB//+ADZXl9PbW1tZlKkqnknDhxQpmZ"
    "maGHH3qIHA79niEQY1m3ZlCVrquro5qaGmpvb+fl37Jli2kEmeZb+/LLL5XikhLavn27IWIA"
    "CEuWZUsCKoFR5QPlRblRfsjBLJmaQg5mL8PhMK1paTElU0JoWgPGD62/MVMzRPkhB8jDjPhM"
    "IaefjTGbN282pYB6gdnTYEjWPItqtsoOOUAeZsAwOcfb25WNGzfm1T9VU1NLvX2D9If9B/gV"
    "n/MFyAHygFyMxmWYnJGRET4o5gvQmm6OTdKrf/mUvCWV/IrPuJ8vQB6Qi1EYIufcuXPKqqam"
    "vAkBBAzdCNArb7RTib96LuAz7ueTIMgF8jEShyFyrjNDbCkz3vIBv99P/UNhev9fg+T1VaUE"
    "3Mf3eC4fqGRygdfBCAzZOZMTE1RcXGx5wUtLS2lorIjauybIW7wk43PtXbO0aY2P6ip93LK3"
    "NI9Mrb59+7ahOAyRg+VEbrfb0kIDgUCAGmrLaUmFN+uzxeyRWzdvWZ5HyMXocitD5MAeMXuK"
    "t8jj4fYHDDvEnw74fuzmdVUa4q3pzN4G5F3YRkjXbGTKv1rYbspgZWMjDbG+uq62lht0C9kh"
    "agoPAjItUhROz/7+fmq0cPmvWtiOnA0bNtDb77zD3fjwWRUVFeUsLXiX4bjsOneOHn/ssXwX"
    "PQWmkGO2lf3Ynj1wgdCRI0coMDubs8J7WVe2vKGBp2dmGczq6m3XcgTamJWN8FVGYcVnDmBW"
    "KzTccgrz/akwq1vjsQwODv68u+fyC691hmlg0pj6lw21pRJ9a52T7t65I/dSMglnz56lK319"
    "3L5SCwh2eGSEqqqqVP9GbINkShHnRWJWrPKNP50mpfVOum+nQqtKJILN72VfQ0+CJeGSov2f"
    "lj4QFMO6CLNGBVMsyK4z7Hp5RqF/fiaRo+sY/e27X0v5HTSo02fOcMchVN1cL5WFmr1k8WKu"
    "JabDu++9R5s2baJldXWaNEfkG2XQ4t4KMqO1n2mPHR0dtPfxxyXpkyPHlBdv7qBf3qeQj/Ht"
    "dMTI4EGKXkWCGgqtiMD+RBSQpVBYjt4LsUh/+LFCzy86RvfeuTPhd0eOHqXKykpqXrXK8Iyq"
    "GqAydHd38/+TCers7MRmXl1bIPWQIyC2QTpePh2i+nskKpKjtT3XiLBEXOzP2l0SvXo2MUX4"
    "v7AGYf26dXz5EVwguQ4lJSW0evVqGrlxIyWvvUxIVm+BBMQ2SMcN1s1Usz7MyiEdaVV5JELa"
    "QqEQIR/r/dFCIzFvRHwIMhvL6i2QgNgGWVClbQxeLVCT5bgrQnwNVmKftbYuJUMA5Ng/8Wp4"
    "vhXyZJMgX/kR+eDkwH+IsSDCGHBi7HFElQA5lkMoBYqkQyFQoiQosTTwPzQ4KUupefdmow1N"
    "eu04o/ZflBwlLkhR4c0N1bEmo1VUijLfUuRYfPwai1iZe05J/JFJBTNLmEaMbEVnOUTF5ORE"
    "WAQhFhxytMVIjmgrigor2mQkjQTNdZNKNP5ip0RT7Aq7x0EKpfP2i4IYnQfRKoiFBCgWOIpn"
    "EbLlTwhXiS1c1Jof8XtHVBhxLScmUEWOq+1K4nikJvCWEwtlbqbzX52hSsytSFHDNJM89NY2"
    "vRBpKVm+BwJBB10ZCGa1v+I1Pj35SRhzImHiBqIzNuYgbUloAHo0AZrv1sqLJOrqHKaPPp+l"
    "J79eS0WLnRRgbMtxmVlIIFZioW4Ntfnm7QgdPXGb2WJual1VlnU9t56KFj/Wxro1oqAcHfjh"
    "rpn7OqYI8CtpVAjYDxpKJerrH6MDH/SQ01PN76MShCJxY0+accZqcjKmm9ICWNc8E6ZPPx+h"
    "xWVOqqr0UzgcWihiQ2VxCIGFWW2OsL4sjO0XGBPmujmFjxmyhoAM1Xki1HXhKr3wm8PMoJqv"
    "YTJLI6LMq9LpgH462SDMdViIOJEfgSAT2CtvfEF914ZZTXekLI4XceopR3xanBwIKyRHSYpQ"
    "TLVW5v+PH3vUhMUeBw0MjtDPfvV6quApNubEtZz4jMULxIqQTERCSLknHoy2ipdf/5BGR8e5"
    "RZ9cDiFkPflJIAfdDLo1BJAUUkRrigoyIshSEbxs4Dp78iQ994Nfp62JiB8NKZKGnHy0nPia"
    "mq41JT6jULz6gFu//eOf6Xz35TktLpkYPfkR4GPOayMKLQmEqMIjURkbwH1MpYLq62EDkJt7"
    "qSWuLDhUDjot6zfRS7/7MT3/01dTvuu5LdOVSZneY/WigShhjgQuc2QQnmKr1GloXkgP6SbP"
    "1yAPuId8YbpAlotTavr3n3uaystKExYQgijECycughZgmkRog1GFgI1pE0xjK2Kf3JGo1ibF"
    "lAHepUmkiZyu8QjdW7uUfvGTZ+jFl44kfDfLIpwOzysE8RC1B1qQVeRkG7DFXqF0+Xn2mQep"
    "ckkZjY2NJcQjbCe9O/QSVGli5EwxgRWz4GWkFcXI4FzgOUeUILXkQH/5x3WiR1uW0ws/eoR+"
    "/9r5ue/Qpc3ENDZR+HhBxAvECmTqUsR3uIf1c3PeaXbP7XLQU09t59ra0ND1FILnFivqLIfI"
    "R4ycCCNHptKIgwIsriIn7B2FT7YJPlwayAEw/rxxOUQbFpfRvkebuJ3DyWHxTrO0QmlU6bnf"
    "WrgnNJmMdHmZH0eISoudtGVLLbtKNDDQnzYeYavIOsoRb+BGyZFTFQA55gCN9xxogRxTEL4Y"
    "CdP6+iW0IzBB5T4HjYxH5hyt/Lk0Lcfqg4mS04/7cq71YFzylUjU2lRMdUtl3pVlgnDB6ClH"
    "iiqda3SOyVTc5KcDw2EamF5Yfc0n0qnSAiBndnqYmutly3YsWDLNN8Oa0H8YMbdCC7tqlOgN"
    "SwqeDtm80tDagip3DphR0fK+4jPTlEHe82ID2IqcvAonXbeaZ7LyTk4ytIhDDLxGZk2h8oaY"
    "qmzH0wqj5DisXTSNtIQo9LYcYUvAcocdohdhpupinZh/0SLbrCEQcFUyfb2UKVD+IoclBHlY"
    "dfC7HTTBSl5RlKqgq20DIAdr244eO5a5+4mbtXSka10xdbeMEdOUZlc41rVl22VnJuJ32nlY"
    "pXM9u9FNn5x0Uv097AYzTvyuqG+thAVvzLfm1uhbA2DjhGPebm+EeFweV3R9nJ9VCP8nRHvq"
    "pzJmMltXBYHhDDdcH7j//oxW+pkzZ/jCwYaGhpTfw+r/6OOPqbY2/aESSysrVe+yS04bcYug"
    "Fgk77RobydW2ds2H67/47MG/du6klTsUWsMMrXLGhJ+Rwv4ljxR157glbV0fJ4ZdZ5Wou2aS"
    "XW8zknrYjdP/JWq99Rltf6At4TfIGPp/CC7bumQ8gxWZKDxqeLoxAxuvbty4QTt37ky76xuG"
    "5PT0NG+B6YCVoNjAhV121dXVqtdKC3KCzDbCcl614DvtBgf5Trsn9u6NVs+bDMdPn6346zmZ"
    "rk/ltvlWemR6dNk0rd+8kcrSNMVr167x8w1cKgZoLxM4CMWa5HTdDuJwM4Fm8gz7Skupigkd"
    "LWQhXOjuplFGclDlAX2CnNHRUU27DFCWhuXLsXA+usvAiKBx7OKu++7T7BZXAzWCKMrDNns1"
    "ADFoMYcOH6Z9Tz6pW8a2U6UF7Cp4K1FYK21j2LblXLx4kW/LUOvL0gMM8Bhvmpub813ctLAl"
    "OdhAhUPltm7dmtNzCMROMqR391135bvYKbAdOdhlhlN1rXihHojHiSEwUJEuVGc7wXZjDroy"
    "qw/Xw+61dDvb8g1DLQeGoFiqapZHGYaYmpOoAsyYnQpkT7OYWdEl3oW1WaRn5iHjQh5G97Qa"
    "Isdj0OloBH2DAWrvnKCJqcxz9P5SJ7Wt8dH65hLL8iWWRYFsj8Hx0hA5Pr+fG6CwbK1ekNHS"
    "WEwkB+nwv69mfGbXtuXU0pSdGLPnkUDO1NSUJtdNOhgiB0fij9+6RctKS00nR43AWprKyOUM"
    "04H3O1K+27d7EzWtKFMVj5m76IRDdfTmTU2um7RxGflxa2urhDd8IDNmFlDL0tWmFUvo2ae2"
    "0szE9bmAz7ivZjmsmRA+NWiB8CxDPkbiM6ytVdfU8GNEkCGzCNIiNBCwuMJH3/7mLgpMj/Ir"
    "PqudfzGLoPjJP9hO8GIbhWFy8HqSS5cu8YyZeRyKlsXfSLKxoZa+9519/MqXEpu0BUQLOWLq"
    "4sL586a8tsUUI3RFQwN1dXXR2rVrudVt9OUN6ZbGZgOer6mu1Kw9GjUDxMQgiIFidLKjI2Vi"
    "Ty9MMULx3hgcJ9zb28snrsweg9RC7x5MvRBdGcqM2dbuixf5kcVmvUfHNA8B3hsDTQXHX6EG"
    "CZJwT+sKGas2TulZFyDKIsYXzLCirGgxWMtg5vtzTPWtIWN48xQciS0tLVzVRjcj5t/VnmZr"
    "dasTaWab7xcGJogR0+M4wPU8G2PQldn6zVOAyODx48eV7gsX+Am3ONYKBVFjlInWZhWEwMXs"
    "ZbZnJyYmuOGNo/AHBwd5+Xbv3p2T2pTzKhr/tsOx8fGsz6PQjzz8sOUv1MOhd2qMxor/97cd"
    "xkNrAbAuAYfhzebwyOJ4gBwM5iDGyHx/LmC7+RzAyp1thXdTa4ReTUpvWgVyNECPEaoXBXI0"
    "Il/bDu0G201TFzCPAjk2RoEcG6NAjo1RIMfGsCU5djoZN5+wHTlYTiS2+uUaydv87Abb2TmN"
    "K1fS0NAQX/UpjtrKFZK3+dkNtuw/Dr71lrK2tdWSF+phFx0mCLHNL9/lTobtMiTQ0dGh9F29"
    "qumFQlqRvM3PbvgfnhklmOdyrPoAAAAASUVORK5CYII=")

#----------------------------------------------------------------------
aero_dock_pane_right = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAAGcAAABlCAYAAABQif3yAAAALHRFWHRDcmVhdGlvbiBUaW1l"
    "AG1lciAyNSBtYXIgMjAwOSAxNzoyMTozMiArMDEwMExUiZ4AAAAHdElNRQfZAxkQJBxqm5sb"
    "AAAACXBIWXMAAAsSAAALEgHS3X78AAAABGdBTUEAALGPC/xhBQAAD6VJREFUeNrtXVlsVNcZ"
    "/mc89oztGWyDd8xgjDEGgx02BSVEkKRK8kCWkkWpIjVKX6pIbdVK6UP7UFWV2r60ah8aRbw0"
    "SdUsDSFEJAW60SQCSlIMMXYwqwEb23gBY7zNfnu+O3PG1zN3PHebe2+V+dBhPHfuPcv/nfOf"
    "/z/bdZANMTs7K/T19dG1a9doLhDIWTrFHg81NjbSkiVLnvT7/QetLrftMTMzI3xw4IBwpa9P"
    "CAQCQiwWy1lA/EgH6fX39z9vddlT4bA6A6k4290t+LxeWrlypWlpXr9+naamp6l940ZbycNp"
    "dQZSce3qVVq+fLmpaTY0NIjp2g22IycYCpHL5TI1TaSHdO0G25GTxzzy5DAIgmB1FmSRJ8fG"
    "MFe5q4BZtdnhsJWBtgC2JAfEmKlq7ErQ154cpFNQUGB1kWXxtScHrcauBoEtyQHsKjAzYUty"
    "zO5z7FoR8uTYGDkn59Lly8LN4WEKBoN0584dyiby0dFRMUSjUVME4HA6qdDlEtPc9/77i2YP"
    "Nl15eTm53W6qraujNc3NOTXzckLO3r17W7ds3do7xgocDoVo3fr1VFRYSF6vN+uz+/fvp7Ky"
    "MgqHw7ksdxKw1DweD1VXVdHTe/ZkvX96elrM28jICB0+fFioqq6mrVu25IQkw8k5e/asMHDj"
    "BtXW1NDmTZs0xQGVZlbL4ekpBa9gFRUV1NraSkNDQ/TXQ4eEFQ0N1N7ebihJhpJz+vRpYW5u"
    "jh595BFyOrWPDIEY09SaTlO6vr6eamtrqbOzUyz/5s2bDSPIsLG1M2fOCMUlJbRt2zZdxAAQ"
    "ViwWMyWgEug1PlBelBvlhxyMkqkh5GD2MhKJ0NqWFkMyxYWmNqD/UPuMkZYhyg85QB5GxGcI"
    "OYOsj7nnnnsMKaBWYPY0FI6pnkU12mSHHCAPI6CbnFOdncLGjRstHZ+qra2ja/3D9Ie9+8RP"
    "fLcKkAPkAbnojUs3OWNjY2KnaBVgNd2emKY33/mUPCWV4ie+47pVgDwgF73QRc758+eF1U1N"
    "lgkBBIyMB+iN9zqpxFeTDPiO61YSBLlAPnri0EXOTeaIVTHnzQr4fD4aHInQx58Mk8dbnRZw"
    "Hb/jPitQyeSCUQc90OXnTE9NUXFxsekFLy0tpZGJIursnSJP8bKM93X2BqljrZfqK72iZ29q"
    "HplZfffuXV1x6CIHy4kKCwtNLTQQCATIX1dOyyo8We8tZrdM3p40PY+Qi97lVrrIgT9i9BRv"
    "kdst+h9w7BC/HPD7xO2biizEydnMow3IO/eNkK7RyJR/pbDdlMGqxkYaYbq6vq5OdOgW80OU"
    "FB4EZFqkyAc9BwcHqdHE5b9KYTtyNmzYQAc+/FAcxseYVVFRUc7SwugyBi57z5+nbz71lNVF"
    "T4Mh5BjtZT/15JMYAqFjx45RIBjMWeE9TJWt8PvF9Iwsg1Gq3nYth6OdedkIX2fkV3zmAEa1"
    "Qt0tJz/fnw6j1Foylp6eHkHtNj94wGpHCGAdrWR6fv369SaJSj+Onfyc/nwuSsMzua2E9V4n"
    "fbvNRZvaN4ozriI52HbX0dFBy+vrVVlHGNwDOWpaTog5ZoPMQurq6qInHn887XdYUN09PWLc"
    "MHVzvVQWZvaypUtFK1EOT7z6BQmt99HO7QKtLnEQxkM8LEuQErwslyPeN6jpH+AAwPOKMLHB"
    "TQ2xzzn2eXVOoH+cdJCz9wS9+52N5NCzzQ8CrKys1CQUbPXD8EZbW9uC68eOHxfjbF69WveM"
    "qhKgMly6dEn8O5Wgz06cpN9O3ke/3CkQ6nGBM0GGGBzxz8S9aqqQwAP7LyqALIEisfi1MIv0"
    "R0cF+nHF5+S0YpsfIG71YwRJgfEvrEFoYyoPy48wBJLrUFJSQmvWrKGx8fG0PL55LkYNDzio"
    "KBav7blGlCXiYv+t2+Wg17vD5LRimx+ANEPMh+EGBQ9WrPdHC40mRiOkYZypmRqmw8w0d5BW"
    "tdshpp03pW0My5xQsXbSQp/AaoNczrDBlZjkE8GR8rtDQ96FDAGIJf7QRY4eH2cxK0xUbzbZ"
    "0ISxVfQFUZadAvQ9zrgRIPZBQtw4EBwaDAIhToKQSAN/w4JzSMSZJEeLkAWNzy2IQ/q8tBVZ"
    "4NjKpRkTJMERF17SOEg0GbXVSBDmW0osEZ/4mYiY58LFM6Vl7kFgzyhtPeh0k50+axVyLYPH"
    "o3ceRA2yrfiMst/CLDhZltysyZQwW3oO9q+QUGgJwtQQlFSTQjz+aMKkht/DpJQkySkVilqo"
    "Ieb6UIgCIWfW54xojWrLwNOVFWRC5cC/qWY6bHxgjsoLHfO1XVjYHykJgpAeeFwRYV6BJMnR"
    "FBQ8C2LOX5mk46fv0u270QUCSU1b7poZIVO6QDRCooNYVOCgm7eidPDoLbp4bowqipwLCNIT"
    "opLACQR09Tmc4kzPulyFNDo+RZ9+PkTOwop0MmSEozkvOrBYuhBYKBYnCMM1k9MR2ndokL5f"
    "WUgrl1dQ/4wQ78hVpCdtcYgXrQWf4Vg8njS1piUstkDc4XBS/41ReuO9/1IoMt+HKFGFMUlf"
    "ZnbrSYUoPCbJmGSMIBiK0s9/c4R6Lw5QvTu+3jqmMuAf+hve+vB3RIjFW0+qWtOyQp8/l1pQ"
    "eP+3bt2h19/657xpQly/ZlaL3BAwc5dBagtKU2tCvEZHZWyUn/3qLRoaHqOlzFJQo8aSVlqK"
    "SuNGgWBUy0kVJKyfC5eu0u9efVtiGQvEu13pc6lpW9FyMuWFXwtHE2otQ+N6+Ye/pt4vvyQP"
    "65OiMsKWC0lVxtVZQnWGovHAK4LY52AYP6RhjRUGKWdmZtLUQqO/nn7w8vP02h//llZTseaM"
    "L1Xi3zmQB8SFkWKzzGkYLEgP6QZk5rL+NCbQskCYCdFFHc70nuW13/+EXJW1dHFS+WYvTlKY"
    "NZ0gK2aAfZlhhsdkSCDGMX3E2oyfk6N1J5l0j4sUU1NTVLmsgl564Rv0l4PdC36TqsRU8BqL"
    "OM0iJ1v/Fw2z8jDBBZCdlJHIX/z0Baqvq6JPRqOqhm+4+gqLxMTDLEtjJhonJCZtOVr3YEYT"
    "m5zkBIm5Hn9DLb343DY68PeBpGWH+7EeTaoSOfjffPOUGZDr8xaAkYNaHYxS0rZ1FxXQK688"
    "Rn5mrX08EBGvOVWYa5wcUZXF4nGLJLGoMGcUjkrI0SqMWIaWwzE0NCjujN55bx2d7g3Hna2U"
    "liNrvpq4J1QK2XIwSc2wjiEUi48IlHld9PDDTTTlLaN3+kLkYqzwCTil4EYG4kQfE2QXoNow"
    "8uBMmNRAsuVoGltbrMYlMDExQfVVS2g2WEzeYgcFZ8ML/By5lmPmopFUQyQNCR9nbE6g8ion"
    "3dvhI1ruo5OjEXE4xykda1OITA4o0gHRUam1lmtghrO5IcaIGU2eL5BphMFKLJaXG7Mxevtm"
    "hIpW+ah7wpxWbcrSKKioycnJjM8n/45fMKXg2fIih5tzMTo2IhDTbFTsyv2UhuUrPjNNGVie"
    "FxvAEnKSQsgwtmYJbKBWU2F5y0mFGvHweSE9s6ZYGxdmpr0dTyt08UKaDdk1BCpqLt/4hEWQ"
    "8Ju0IsL6Q6yh8y1ZIp++09wF5UiLVxOXmxUu204yIyHdTSa3ZVFpNUE8WNt2/MSJzH0Vu4eX"
    "ySlXAROzoGWMmCaZXeEVRTEqZY/7ipymEORmTcVX6KQpVpxK5na4GletEo+nwt55PsakFBh9"
    "RlBDKoiBULFpqSrDalElqgqVCWe44fOhBx9MyzevBD09PeLCQb/fn/Y88v6vo0eprk7+UIk9"
    "K2bos54CanggSm7mlPiYheZlAVPVHla9mRypEOlocEL58I2HWeWIy+2Kr4/zMVJ8/yZxzbQL"
    "b77Y/8EHgkvDTjJsbFrCap0abx4qaGh4mHp7e2nHjh0LfsMid+h/CC5bPnAPVowi32iBcn0G"
    "8jc+Pk7bt2+X3fUNB3l2dlasLHLYtqmD2vpO0rtfbadV9wq0tsRB5YwJH9YSMDLcWDPtAEHq"
    "VJ9IDPsMYo00I2iafWKSuI9d6P6CqHXyJG3t2DCvRbq6uoT+gQHZkdlMwC6DivJycYxNKXAo"
    "3jLWYlrWrJH9/caNG+L5Bi4FHbSHCRyEYhxPrvUijkJGMkbP5eAtLaXqmpqMLRhAi/zPmW46"
    "NFhC48HcKrfaUic93+qkbe1t4omIuiwBHLu4a+fOjIXXg5CCkwqLLNhmrwRozdAoh48coWef"
    "eUazjG1nSnPYVfBmIr9W2sawbcu5fPmyuC1DywytUsDoQH/T3NxsdXFlYUtysIEKh8pt2bIl"
    "p+cQ8F12SG/H/fdbXew02I4c7DLDqbpmvFAPxOPEEDioSHdNBgvSKtiuz4EqM/twPezsk9vZ"
    "ZjV0tRy+ON3IN2lglELJSVQB5rDNBLKnWcw8xRLP4tYs0jPykHEuD717WnWR49Y56KgH/cMB"
    "6vxqiqZmMo9O+EoLqH2tl9qaS0zLF4jhy63cOvtLXeR4fT7RAYWXbvaCjJbGYqJYiI58NpDx"
    "nl1bV1BLU3ZijJ7HATlYzwdHVA90kYMj8e9MTtLy0lLDyVEisJamMnIVRGjfx11pvz27u4Oa"
    "VpYpisfIKRM+oHrr9m2qrq7WF5eeh1tbWx14wwcyY2QB1SylbVq5jF56bgvNTd1MBnzHdSXL"
    "eo0EP9sNViDOcIN89MSn21qrqa2l0bExMUNGEaRGaCBgaYWXXvzWLgrM3hI/8V3pNIZRBEkn"
    "/+A71TCtohe6ycHrSa5cuSJmzMjjUNQsRkeSjf46+t53nxU/8d2oLSBqyOFTFxcvXDDktS2G"
    "OKE4aAjzM+vWrRO9br0vb8i2UFEOuL+2plK19ajXDeATgyAGhtGXXV1pE3taYYgTivfG4Dhh"
    "nDqFiSuj+yCl0LpqVSu4KkOZMdt66fJl8chio96jY9gIAd4bA0vl3LlzYg3iJOGa2hUyZm2c"
    "0rJmgpeF9y+YYUVZ0WKwlsHI9+cYOraGjOHNUxhIbGlpEU1tqBl+yq3S02zNbnU8zWxnAHEH"
    "E8Tw6XGshbjA+hioMlu/eQrgGTx16pRw6eJFcV0CzmRDQZQ4Zby1mQUucD57me1e7D2C440p"
    "+uHhYbF8u3fvzkltynkVlb7tcOLOnaz3o9CPPfqo6S/UO/jRR4qcxor/97cdSqG2AFiXgMPw"
    "gjk8slgKkIPOHMTome/PBWw3nwOYubMt/25qldBqSWlNK0+OCmhxQrUiT45KWLXt0G6w3TR1"
    "HvPIk2Nj5MmxMfLk2Bh5cmwMW5Jjl5NxrYbtyJFug8w1pFsg9S5jygVs5+fo2QapFgteqNfY"
    "aHXR02BL/YFtkOtaW015oR520WGC8Ok9e2wnC9tliEPLNki1QKvxr1hBHR0dtpTD/wDriTgZ"
    "SBhbDwAAAABJRU5ErkJggg==")

#----------------------------------------------------------------------
aero_dock_pane_top = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAAGcAAABlCAYAAABQif3yAAAALHRFWHRDcmVhdGlvbiBUaW1l"
    "AG1lciAyNSBtYXIgMjAwOSAxNzoyMTozMiArMDEwMExUiZ4AAAAHdElNRQfZAxkQKSNpU8hr"
    "AAAACXBIWXMAAAsSAAALEgHS3X78AAAABGdBTUEAALGPC/xhBQAAEFhJREFUeNrtXWlsXNUV"
    "Pm8W22OPYzu24yXxEscxzk621kDaAGVTFVqxCoRaxJ9WlSr6j1+V2p+tVLX9U1URUlNVXdgK"
    "EhRCgYKgSShtFpw4qx3I6iReEie2x57tvZ7vzVz7eebNzNtm3kPyJ109+828e885313Oucsb"
    "iTyISCSiHDzyOf3peIKGp+SildMa9tH31wVoZXvbi21tbT9wW+9MSG4LkInp6Wnl8Rc/J2XN"
    "nXRfn0JdIYlCfL+MJS3ja4Cvfr76DOancEoi8R8Jvkb5OsvXKU6DEYU+/UQi3xcHaPdj7S8x"
    "QU+7rb8WAbcFyMR/j/STtKqPfnFHkqoUifxszYAPZPDfTIwkpWqUmVoFgtD+ZAVJoQSI4hvb"
    "JYUeu8dHL8z00dD5z57ir3iKHKMVsGTYcyxOnTskKkumjFpMgKRgUqa6h1Lleg2eI2dsRqGm"
    "ComKN9IsBMppDfnUcr0Gz5GziHl4bswBUJuVHAmQyFyXp+j8LcYhtbxSNVOT8GTLwcCtKGlC"
    "cE0bT0kzZLYDUpSFSc7436vwZMsBGXE2mo+vki/loamMpK+Skr5nEHKa0KQiPLa0ay0vbEFe"
    "gyfJgbsrswVlad6YPjajTCk/WnWlTdR4lQC1lShz+Qm3mtSy/G6rrAtvkiOn3Fw/SEmnpOZz"
    "lRwTLUd0ZSIYVVtNOikWuslSwZPkoLtJLqjhCwNPswOldvyaD0ZTZah5erRf8yQ5MFxc03Ik"
    "zXiDq3oxUd0XEJJulXE5lZBfwqNNx5PkJLj/iSdT82gQEC1lriuT0/9bcQjSLVJc0ULVLBdb"
    "jnGkxgSFr0gStyApVfPF6CCZdwiSmi5NzRctSE5l4lFuik/O4NCQcvXKFYpGozQxMVFw8N1z"
    "gY2WSNVqdezxpQyrOgWa6NNnsuVox5lk2jlIpLtM0XJefe21vOKhyNraWiovL6fmlhZa3d1d"
    "1Fn9opCze/fu3q3btp0cHRmheCxGa9aupbJgkMLhcMFn9/z2E3rpukJN3K8tLZeoOihRlV+i"
    "CvZ2y5iooC81O+03YRYxCx1jdqJ8neYbk3GiGzE45xL9jfPayd977NFHC+Y1NTVF8Xicrl27"
    "Rnv37lUaly2jbVu3FoUkx8k5evSocvHSJWpuaqItmzdbymOWW84UG66cI1AI6FfdLYkUf8rj"
    "MkOO6NJATpTJmeUmM8PkRNjjmI4paqwTjyeNZcYQFayuro56e3tpeHiY3n7nHaVtxQrauHGj"
    "oyQ5Ss7hw4eVmZkZevCBB8jnsz4zFOVaHWGCKlm6crYbNx61GxNdGRwF2SQ58MxinFc0nWaS"
    "qTJAdtI4N1lobW2l5uZmOnTokKr/li1bHCPIsbm1I0eOKKHKStq+fbstYlRwTZ7mqj7Do/Ys"
    "J9T4WDKV4rL5pD7LA4varaXzRIpwGRG+2iFHNSLrC72hP+zglE0dIefosWNKgkfx23p6nJEq"
    "keraoolUbVdTOi5BDyScBW2C9xXmJpaU9T9X3XNZ04I0ZZBNcgSgP+wAeziRnyPkXOYx5vbb"
    "b3dGwzRkTVIKJHR33+0I0IrpS+rVJxV+Rpu/k4AdYA8nYJucg4cOKRs2bCC/353JQzgG326V"
    "6PjJL+gnL/xaveJ/M96co/KwHWAP2MVuXrbJGR0dVQdFt7BxaYCuXJugn//yVaqsblWv+B/3"
    "3QLsAbvYhS1yTp06pazq6nLNCJvrAzR58Sr97FfvU3Vdx1zC/7iPz90C7AL72MnDFjlXORBr"
    "bGx0RfmeGj9dPzdOL77yBYVr27MS7uPz2/h7bvRwDWyXEQ7C7cBW1ZqanKRQKFRyxTurfRQd"
    "jtAHn82oXVku4PNvJqepu62KTtxIlFTGKnarb926ZSsPW+REYzEKBoPOa+bL36SvRhS6t6uK"
    "WpsqC2YVrpToo7HcvnKxNlHALrCPHdgiR+bATjIzd28ADSGJqhCzlPlyGm6Wg8qP2eAhA9LP"
    "jKema/RQwc9XBX1UnS7Xacg21yI8t2Tw3PoAfXTMT8u/wcbnCh8OSBxcEoXYNy73pyY+A+m5"
    "tYQB3bGVd0mZxMGnRBWyQuX8fNCnUJlfoUbmrIpJqd8r0fc2e84U3iNn51130LqDn9Kfj/fR"
    "mq8ptLrSR7VMSpjJCLGhy/mKjjRgYm4NDSfGCZs6p5nQCU7XufWdmeUAeh9Rr/wf+taOO9xW"
    "PQuOkKM4vPnr7ef76P1/H6CX35NpKFK8NeTVPB79tNdH9z9zp6M6ONXVe67lCNz/jTs5uS2F"
    "u/Dkjs+vOpxqhbZbDgRxulv7qsOpbm0ul4GBAeXcuXM0Mztr+GFEwGZnCCoqKqijvZ3Wrl1b"
    "IlPZx4kTJ+j8hQs0a8I2MOzI6CgtW7bM8DMhtk1nZyetX79eEnnQ62+8oWzatImWt7ZSWVmZ"
    "4cwwuQdyzLScGAdml4eHqb+/n77z8MNZn2N9/tjAgJo3ZnidjqMyEQgEqH7pUhhE9/M333qL"
    "rNgGcgv7WLHNo488IklYGKoOh6mjo8O0Yii8oaHBklHOnz+vTm+sW7duwf19+/ereXavWmV/"
    "RdUAUBkGBwfVvzMJOn78OC1ZssSSbayQo7XN5NQU+c59+SUtX7686EbIxIoVK+gcC6EFdrZg"
    "D8I67vKw/QhTIMVOlZWVtHr1ahodG8uSEfK5ZhvmJYD5HzTtUgNlxqLRBV0i/nZjBhktNJlI"
    "ZHXPkM8t24CXRVfaw3AtCFVdcFoYE7jtkGe2HLfkEXLYIsdOjJPPC1O7tyJ7aWb1LOVzAnPk"
    "WMlIsfhcTgUyxp9SQ69MOxXQqn1ExQwIAaysPSj8jFHhMeiK76JwvZYh8rG7DmLWEPnk19pG"
    "yF1IPqEb7GNWF61tfFqjmIUZYs4Px2g25iv4nBOt0awOotx8nwOQH3oUir+EfpZ6I81zgcwb"
    "pjKiwoZElH/q7E06fDJOO7++lFrqKct9zmeQUiJft4bafP1WkvYfvsWxWJB6V9VQssA+XisV"
    "Tduj2BpzxBiR69lAIEgjY5P08WfD5AvWLVBWSZ9k1iOq1OTkLDerBUg0PZNgfUZpaY2fljVU"
    "UyIRz5exLV3mujUrSU73qXpJknx04dII/fGV/1FMs55spJXKmrGsVCkfcUIeAegDvaAf9MzU"
    "XWsfKzYVZfm0AphNuQRAhDs+PkF7/vLBgrPkipJRETIqhhg8rcpjJWUSkU++OX7SR7OhH/SE"
    "vnqV1ooe2hZsu+VkCoA+8/Tgl/Sb3/1V4xkrJIbdzNqhV3tL2XJyyaK9N/+deT1EZYOe0Fd4"
    "cYUqrhF5BNQxB1PVMQt7rDBJOT09ndUtdLa30vM/eop+/4d/ZtUMrImIgVT8P9ddsAyKetIs"
    "XjJ3Gp4XykO5mes1Qj7IheUCWQ5l6QM9a2uqFmwgBFHIF/ZBMgM4UMIbVMmBsQp5HnoQz2WS"
    "Mzk5SQ31dfTcM/fRy28ey1I4sw8XELUHeZaKHCPjXy55oF9DfQ3duHFjQT4idrJq1yxX2hI5"
    "eQTHWkb7imZ69snt9MZ7F+c8O3wfB4y0TV9rCK1BSoFcXYr4DPcg79zsNN8LBnz0JOsFb+3a"
    "tatZBIMctICkRT2EHAE7xpBztByB4eHLVFNTw/FNixrnKEp2y9F71mqNs4tcsszLjE2Iftqy"
    "pUXdjAj99CBiFdmCHtoA114QmqPGaYEm39q4hCLREIVZoWgkviDO0Ws5pdw0kumIZHw4px/G"
    "Jey77u0KsT6yqlcuiCkYK3pkudLFBlY4u1fITMyIqqQwSrar6u6igZ4rLQC5IT/0gD6lQEm2"
    "RqFp37x5M+fzc3+nbpRE8UKy6Olnxqt1oqK5vuMz15KB67J4AK6QM2eEHHNrrkCvB3CZLNdb"
    "TibMmEMMvHZWTeHyxtlVdus0eD4EhJKlhtYh0N4zChFLIHJHHGIVCR4PsU+sesmSrPLd7uQC"
    "5awcBmz416WIyucCNC5T78ii0WqCfLC3bf+BA7m7H82qpU+vAqbd3RompkvnVDjkc8s24CXQ"
    "uXKl+noqnJ0Xc0xGgagZyYzgKBxGxduWGnPsFjXSVcFgeIcbrvfec0/OKH1gYEDdONje3p71"
    "PGT/14cfUktLi24ZkO/ayAi18ucJnX1t+YwsbGNm3xvkxV7yy5cvq3umAxs3bJD+/vrrCjLB"
    "24/M7AeeZeNgu6qZKBhKDl+5QidPnqQdO3Ys+AyCof+H4QrJge9gRybkRg3XGzMg39jYGPX1"
    "9eme+kYgGYlE1MqiB+wE3bdvHwW5jKamJsO2EeTEuLLDPkaBxqHa5tQpvPttvnr29/crFy5e"
    "NLWTHqcM6mpr1Tkko8BL8eq5Rvaw4nq4dOmS+n6DgIEBuoINDkIxj6fXepFHkA2aa2Y4XFVF"
    "y9jojQX2e58ZHKRxJjkWN/ZLIYKc8fFxU6cMoEt7Wxs2zs+fMrAKvHbx7p07TU+LG4ERQ5QV"
    "45i9AwAxaDF7332Xnnj8ccs29pwrLeBVw5cSi3ulPQzPtpyhoSH1WIaVFVqjwACP8aa7u9tt"
    "dXXhSXJwgAovldu6dasp79EsxEkylLfjrrvcVjsLniMHp8zwVl0rp8nMAsSv5HgCASrKXZ3D"
    "g3QLnhtz0JWV+uV6OL2md7LNbdhqOWJzeqHN4GaAQMzIm6hmowpNzxYuM1QuUWVFfm8W5cUN"
    "xjBGIOxh90yrLXLKbU462sGFK7N06PgkTU7nnp2orvLTxtvCtK678Ku/nILYFgWyy22Ol7bI"
    "CVdXqwEoIttSb8jo6QwRyTF695OLOb9z97Y26ukqTIzT60ggB/v5zEzd6MEWOXgl/sTNm7S8"
    "qspxcowYrKerhgL+BL36j/6sz57YtYm6OmoM5ePkkomYUB2/ft3U1I1uXnYe7u3tlfALHxDG"
    "SQXNbF3t6qin557cSjOTV+cS/sd9I9thnYSYU4MXiJll2MdOfra9tabmZvU1IhDIKYLMGA0E"
    "LK0L07NP302zkXH1iv+NLmM4RZB28Q+xE2ax7cI2Ofh5krNnz6qCOfk6FDObv1FkZ3sL/fiH"
    "T6hX/O/UERAz5IilizOnTzvysy2OBKF40RDWZ9asWaNG3fl2gRolxuzKI77f3NRg2nu0GwaI"
    "hUEQA8fo8/7+rIU9q3AkCMXvxlSxU4C3TmHhyukxyCis7lq1CtGVQWestg4ODamvLHbqd3Qc"
    "myHA78bAU8Hrr1CDBEm4Z3aHTKkOTlnZFyB0EeMLVlihK1oM9jI4+fs5js6tQTD88hQmEnt6"
    "elRXG92MWH83Ygy7W52sQJRZaL1fBJggRiyPYy/EaR5j0JV5+penACHgwYMHlcEzZ9R9CXit"
    "FRQxEpSJ1lYqCIOL1ctC38XZIwTeWKK/wmEE9Nu1a1dRalPRq6j21w5vTEwU/D6UfujBBx2d"
    "68oHseMFL70zEjTWfdV/7VALswpgXwJehgcySwGQg8EcxNhZ7y8GPLeeA5TyZJuTM+pOw7Pk"
    "lOpMaK7zqV6AJ8mxEoRaxSI5JuHWsUOvwXPL1IuYxyI5HsYiOR7GIjkexiI5HoYnyfHSm3Hd"
    "hOfI0R6DLDYyj/l5DZ6Lc+wcgzSLzGN+XoMn+w8cg1zT22v6GKRZgHycosMCIY75ua13Jjwn"
    "kICVY5BmkXnMz2v4P+EM9joepX/9AAAAAElFTkSuQmCC")

#----------------------------------------------------------------------
aero_down = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAAB8AAAAgCAYAAADqgqNBAAAALHRFWHRDcmVhdGlvbiBUaW1l"
    "AG1lciAyNSBtYXIgMjAwOSAxNzo1MTo0MyArMDEwMMndnrAAAAAHdElNRQfZAxkQNALaVrQp"
    "AAAACXBIWXMAAAsSAAALEgHS3X78AAAABGdBTUEAALGPC/xhBQAAAhJJREFUeNrtl01v2kAQ"
    "ht81FgECjUQUyeKjBrfi0EOJktxzg0uOSaWe0lNP/Wk99lBy7A+oSiO1ORE+BChSTjGfBuPs"
    "rATCNSkmyHtpX2ll2czOs+OdWTMMXIPBwKnVaqjX6xiORghK0UgEuVwOhmEgFosx1u/3ncrV"
    "FYrFItKpFMLhcGBwy7LQ7nRQrVZRLpXAfl5fO4l4HLquBwb9U41GA2avB6V+e4t0Oi0NTMpk"
    "MiCuOuavQlXVtRNGFs+NobPWLhphiO783YZ4gut3tc3OEN9/9fDQt5+0ebEbwttCHG9eR335"
    "9A0v5LhDx0LlW+tJm6OTLAr59WDHcTaDiwXk96AqNj5/+eH57fzsEIa+t4k7KMur8TMMPYkP"
    "744xMO8Wg+7puZ/5HrhfMI3ZbIb9ZByX708xHt6LK93Tc78+XHu+alXrlNdT+PTxgpepBtu2"
    "fc8nu1AotB18Op1C0w7EdRMxxrwJtyn8uXOW9ezIt5ErctlwT+SUrTKkKIo7cvrUTSYTKXDK"
    "dEo6V+RULrLkipxeuSy4p9QILmvP5yfhAi4z4VbCZZXaMkfZws/W+g//R+Hz4046fIe3R3S6"
    "0YEftChIOtuJR1zRLvHiQ4r3afRxCbLeCRzhzWK73Rb/gNRXvGP8WqmILkLTtEAbRQqu0+3i"
    "980NyuUyxGabpila5GarhVGALTJF/TKbFS1yIpFgj6VqglrJraorAAAAAElFTkSuQmCC")

#----------------------------------------------------------------------
aero_down_focus = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAAB8AAAAgCAYAAADqgqNBAAAALHRFWHRDcmVhdGlvbiBUaW1l"
    "AG1lciAyNSBtYXIgMjAwOSAxNzo1NDo1OSArMDEwMEcuCiQAAAAHdElNRQfZAxkQNxVyqGIt"
    "AAAACXBIWXMAAAsSAAALEgHS3X78AAAABGdBTUEAALGPC/xhBQAABENJREFUeNrtV02IHEUU"
    "/qq6529nFnezLtGNEEk0O5NZI4GoQaLxoCJ4NgjBgAe9K/5c9SToQbx6UaJgQLyJXgIRDUkk"
    "t+iS1YDgwSWHMGOyO7Mz0z/l97qqZ3vGnd0ZYb1oDY9XXT39vve+eu9VtwJHo9H4+ufrK8+f"
    "XQ6xuh5jt8ZCReNM3Ue9uvjl3NzcKUXgH06fvX7C1B7H08cNDpQUSvxjXlGofWqPWo8JYCiR"
    "CCchdZe6Q71OudE2uPy9gv7tEj57qXpeXbh4yXzQfAzvnTQoGwWPKL4WMM4JrERgZdwhDgh/"
    "sRExCMURLhjOu1rjrW8M3tz3I/QnPwW4/4RCPrIPjRpaWad2Er2Nl+JELoox+xwguP6tDYOD"
    "RYW4sz1wnjzeaW3nnh2VKQXDvYpH/FUYWShpLBPXH4fGPCNaudHC+ctNNG6HI/+35y4fTx6b"
    "wZGlaYTRznb91BszQmR0aKhWrUDo+fSrX0YaO/XsImqHp9HK+GcyOq2jOM6CG0kGByhabmo7"
    "ly1kHqJNg/X6PF7xAnz48Xd/A37t1adwqDqP9cAM2jIZ+0NbkVSQgAUuI6VE0lLpZ2xs9Z2e"
    "waHFBbz7xjNYa/7eF7mWdbkfG/QlGpqL/SDeZEDbyPlQbKx2YuhRMocTt367F+PevTN45+0X"
    "0F5bTbRcy3r/WQzZyNplJIO0x7YMPIp2ks2XpM4zJXQr9FCvHcBH77+OBw7ux83OYJmmVKcM"
    "JlE7SbekD57SnaUs21iGu5s8vLoBzNy3P9HDI7vnm83GYqg0w7MJF2QiV8YhO52oLep2Y0Q5"
    "DQA6VgO332IvNNnIaSSIbB/3XaR9qmN3PUF/jV3kUZrA8WbCqeFSs3tiqEXY043tUHG6O2rr"
    "yEcNM1QtiV1hwLW9NNtt5KH1Ktl7bR9Mki6lHtv37K0iz+5zWr6h29KByM81DPaS9z0Fhemc"
    "QpnHWdGzbTWn7enmTQCenmI9onepW1xYC4Amy1Hx9wVtnUzBO4x8nTcKSicLXpKuPCA8m7GT"
    "gKeUC3iX4NKaNwjeZka3erbWgyDajLwb2PY5xasC1xl8QnNKtSRiPCG4ZHaPtrpOpDIEQ4KJ"
    "ogztkuotulrmYpEbnReqo836NhOCJ22UKD2JPpLorbRDY50bAA8t9V1Kj1T3tHt9cm8xySEz"
    "IXjax/sMOIxkDIDDlQV2Pl7HAd9KUtvZMe574a6M/8H/q+D63/Mii+Pfzc+jMmugwka+2w4U"
    "WdjlnMY054Lrv/xQDheuedj3RIQSi7/C7lLJASV2mIJnDxb/H/T2gC2xyN5e4PM5HpF5vqnM"
    "c71M0LlvFc4c9eEfXTq8Ur96pfr58nHUHjV4cEpjhqAVgvHDgocNHYDteOOCy6nGMwT8KEGL"
    "rP5JadCjX/mu98dFoBpfwbGHl2z3bDab5uq1ZZxbiXGztXufyPeUNV6sajxypI7Z2Vn1F7X+"
    "m7ZM/KBNAAAAAElFTkSuQmCC")

#----------------------------------------------------------------------
aero_down_focus_single = aero_down_focus

#----------------------------------------------------------------------
aero_down_single = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAAB8AAAAgCAYAAADqgqNBAAAALHRFWHRDcmVhdGlvbiBUaW1l"
    "AG1lciAyNSBtYXIgMjAwOSAxNzo1MTo0MyArMDEwMMndnrAAAAAHdElNRQfZAxkQNALaVrQp"
    "AAAACXBIWXMAAAsSAAALEgHS3X78AAAABGdBTUEAALGPC/xhBQAAAhJJREFUeNrtl01v2kAQ"
    "ht81FgECjUQUyeKjBrfi0EOJktxzg0uOSaWe0lNP/Wk99lBy7A+oSiO1ORE+BChSTjGfBuPs"
    "rATCNSkmyHtpX2ll2czOs+OdWTMMXIPBwKnVaqjX6xiORghK0UgEuVwOhmEgFosx1u/3ncrV"
    "FYrFItKpFMLhcGBwy7LQ7nRQrVZRLpXAfl5fO4l4HLquBwb9U41GA2avB6V+e4t0Oi0NTMpk"
    "MiCuOuavQlXVtRNGFs+NobPWLhphiO783YZ4gut3tc3OEN9/9fDQt5+0ebEbwttCHG9eR335"
    "9A0v5LhDx0LlW+tJm6OTLAr59WDHcTaDiwXk96AqNj5/+eH57fzsEIa+t4k7KMur8TMMPYkP"
    "744xMO8Wg+7puZ/5HrhfMI3ZbIb9ZByX708xHt6LK93Tc78+XHu+alXrlNdT+PTxgpepBtu2"
    "fc8nu1AotB18Op1C0w7EdRMxxrwJtyn8uXOW9ezIt5ErctlwT+SUrTKkKIo7cvrUTSYTKXDK"
    "dEo6V+RULrLkipxeuSy4p9QILmvP5yfhAi4z4VbCZZXaMkfZws/W+g//R+Hz4046fIe3R3S6"
    "0YEftChIOtuJR1zRLvHiQ4r3afRxCbLeCRzhzWK73Rb/gNRXvGP8WqmILkLTtEAbRQqu0+3i"
    "980NyuUyxGabpila5GarhVGALTJF/TKbFS1yIpFgj6VqglrJraorAAAAAElFTkSuQmCC")

#----------------------------------------------------------------------
aero_left = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAACAAAAAfCAYAAACGVs+MAAAALHRFWHRDcmVhdGlvbiBUaW1l"
    "AG1lciAyNSBtYXIgMjAwOSAxNzo0NDo0MCArMDEwMN+SkKkAAAAHdElNRQfZAxkQMBKjjWFJ"
    "AAAACXBIWXMAAAsRAAALEQF/ZF+RAAAABGdBTUEAALGPC/xhBQAAAkJJREFUeNrtV02P0lAU"
    "PS2lUEIlkxlHpCAEZ89Ol27M8A/czMK4duO/caeJiSZu3SgTN25M3DhBFkMmDhQJEK0apnwM"
    "0wK1t+Z1YOqyr2w8yWuT95qcc9+97/UeAS6m06nTarWg6zrOZzPwhJJMolQqoVwuI5VKCcJk"
    "MnFqh4eoVCrQcjnIssxVgGVZ6PX7qNfrqO7vQ/jSaDhqOo1isciV+Co6nQ5G4zFEvd2GpmmR"
    "khPy+TyIW7xwt0SSpMgFECdxi5EzX8HGBDiOs1kBDH7ymaKoIAjCpQAiXy6XXAlFUfR4aBA5"
    "EyBGET2R630LM+tvxpmQNQG8BpE3T8/w8cjEb3MREMe1BuLxOL4bY3z4NIAob/nzq1x+DYQt"
    "IBaLodM18PpNA0p6Fwn5kpzqjXZmTUCYRUiR//x1hucv3yOl3lhbY4Gyd+g7QJGffG3jxau3"
    "SCg7gXUWLH3nC6BfJI2wUC4V8OTxAZ4+qwXWiGexWPgp8J40EeYwTRM72xk8OrgfEMC+CRzD"
    "sEUYhoFi4ToePriDuBTzBdD20zqrOWl1Mmz0ej1kMhncu3sTn5u2XwORHEOG4XAIbfcazm0F"
    "aUXExdQO3oS8MXZbrz1t6ZL/gG3ba2uRtEKUYirMf2Hj/cB/AZ4A1hxsREDCdUKrVyNvULD0"
    "HyBO4vackXsokXNtGR0R3t0RkSddf0iX1Hw+h3TbNYnvajXPKGSzWe7ekILsDwY4bjZRrVbh"
    "JX80Gnnu+Fu3ixlnd0zR3yoUPHesqqrwB18A5ik1mQXQAAAAAElFTkSuQmCC")

#----------------------------------------------------------------------
aero_left_focus = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAACAAAAAfCAYAAACGVs+MAAAALHRFWHRDcmVhdGlvbiBUaW1l"
    "AG1lciAyNSBtYXIgMjAwOSAxNzo0NjozNCArMDEwMCXtbZ4AAAAHdElNRQfZAxkQLw561jOY"
    "AAAACXBIWXMAAAsSAAALEgHS3X78AAAABGdBTUEAALGPC/xhBQAABAVJREFUeNrtV02IHEUY"
    "fVXTO70/M+yOExNd4oIRkgljDIiyQZR4FD0rQlDw6E1RDwkoIqiHXLzlKK4Iwb2peFDJHgxx"
    "dS+LcTMhhw0qJkvG7Jjsz8xOd1f5qqu6p9eNMB2Y9WLBm6+nf+p79X2vvqoSYFtdXf3ql8bl"
    "52aWQlxbVxhkmyxJvFz3UK8dmq1Wqy8IOv/+xEzjSV17AsePaTw0KjDCF4cFUKQtEB6vJSz6"
    "bWYYERFqoEvbpW3TXm1rfDsvIBsX8OlLte/E3PkL+vTqNN4/rlGCQEE6hzGEta5TkYOATsCf"
    "SBtCGqGy9wJ2+vo5jbcqP0J+fDHA/qcEisqyHnSL6MTjz+GnBYxv+SdDso/x1rvgPBudvb6A"
    "8Z0nrQNpXsJIZaxBNt/a/c8bJf0vME3pDAGlbG4ieikYLUgrPOV6MULU4i5EqK0j7XyYazMz"
    "RGYkXsImhbAvpIJ0Q8/jHM55MmLl+out6hFMCUR8OyCksiMX0kYj7gV26CInCZVxbvofKQhs"
    "0Jq6IPkkISKTFKQRcB9plWGtt+ujH8QRcBgfEmj+3sYe1hVTY0J3PyUQhYiLhHkQa8Hlalvo"
    "7hITRYErl5r44txNrNyMUGQkEpKZFLBUKiu2AjKhduKLLXKKkB9MjQn89kcLs18vo+Dvi++b"
    "gQZRTwtecjMk3UiaHAlb97VlGidfO2306dy8N+krNK5cx+kz51GamMKo77TB3Ea6Nw1lEoFA"
    "WSKR00SaBpU/Dff4EteuN/HOB5/dUZyh01hKwITEpMDAEAl0EpV/6KIPDDPHlxYX8eprH94x"
    "Oqb/bmT7TFMw09SodgJUWJ/HKZoSpWqmjU9BDMWrI1dJt0L20w7Wj+LMRyfxxtuf7Hi2fFvh"
    "V+45vuTYp9IUBMAaZ8IGmW0SbaKjLLZULzr9ovFXhMn778V7p07sIGD62wyxvQ6ABDZC+6BD"
    "bEUWXYdA5UOH33yzAhw++ADeffMZ+MVCSsD013YzIUMgIgHFkWt+TFBJW6TYpQ2IxOaB6efz"
    "qwHWS+N4/tkDGC95lgCfbdJXkNUA1E7RKbcoZStknqacKBeaIer7q5jurGGC+8Em05Msfr0I"
    "DLgttRRGDpQxe4Ob3s3tQ/F2g4BJ7Q90fivYuaP4z3dE/xOQye9uMjG+ksrg7RkRGKMwy0W5"
    "KyR8yr7M+r5GPRrf3itHhjC3WODhJILPyVv27FowSgy7tWAo51pgmqkBoVtlhyPEffmePX+U"
    "6bg8h/iM6D16pH6jvjC/9+zSMTw4rXGIZ8MJeivTMS/hmzOiMCTypSl2Trulbeldp71NIsu8"
    "cfEnoHZrHo8dfdjuMVqtll74eQlnLyusbAz2gHbfmMSLNYnHH6mjUqmIvwGdqbciWIcx6wAA"
    "AABJRU5ErkJggg==")

#----------------------------------------------------------------------
aero_left_focus_single = aero_left_focus

#----------------------------------------------------------------------
aero_left_single = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAACAAAAAfCAYAAACGVs+MAAAALHRFWHRDcmVhdGlvbiBUaW1l"
    "AG1lciAyNSBtYXIgMjAwOSAxNzo0NDo0MCArMDEwMN+SkKkAAAAHdElNRQfZAxkQMBKjjWFJ"
    "AAAACXBIWXMAAAsRAAALEQF/ZF+RAAAABGdBTUEAALGPC/xhBQAAAkJJREFUeNrtV02P0lAU"
    "PS2lUEIlkxlHpCAEZ89Ol27M8A/czMK4duO/caeJiSZu3SgTN25M3DhBFkMmDhQJEK0apnwM"
    "0wK1t+Z1YOqyr2w8yWuT95qcc9+97/UeAS6m06nTarWg6zrOZzPwhJJMolQqoVwuI5VKCcJk"
    "MnFqh4eoVCrQcjnIssxVgGVZ6PX7qNfrqO7vQ/jSaDhqOo1isciV+Co6nQ5G4zFEvd2GpmmR"
    "khPy+TyIW7xwt0SSpMgFECdxi5EzX8HGBDiOs1kBDH7ymaKoIAjCpQAiXy6XXAlFUfR4aBA5"
    "EyBGET2R630LM+tvxpmQNQG8BpE3T8/w8cjEb3MREMe1BuLxOL4bY3z4NIAob/nzq1x+DYQt"
    "IBaLodM18PpNA0p6Fwn5kpzqjXZmTUCYRUiR//x1hucv3yOl3lhbY4Gyd+g7QJGffG3jxau3"
    "SCg7gXUWLH3nC6BfJI2wUC4V8OTxAZ4+qwXWiGexWPgp8J40EeYwTRM72xk8OrgfEMC+CRzD"
    "sEUYhoFi4ToePriDuBTzBdD20zqrOWl1Mmz0ej1kMhncu3sTn5u2XwORHEOG4XAIbfcazm0F"
    "aUXExdQO3oS8MXZbrz1t6ZL/gG3ba2uRtEKUYirMf2Hj/cB/AZ4A1hxsREDCdUKrVyNvULD0"
    "HyBO4vackXsokXNtGR0R3t0RkSddf0iX1Hw+h3TbNYnvajXPKGSzWe7ekILsDwY4bjZRrVbh"
    "JX80Gnnu+Fu3ixlnd0zR3yoUPHesqqrwB18A5ik1mQXQAAAAAElFTkSuQmCC")

#----------------------------------------------------------------------
aero_right = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAACAAAAAfCAYAAACGVs+MAAAALHRFWHRDcmVhdGlvbiBUaW1l"
    "AG1lciAyNSBtYXIgMjAwOSAxNzo0NToxOCArMDEwMEtfu5QAAAAHdElNRQfZAxkQLyM/CW/t"
    "AAAACXBIWXMAAAsSAAALEgHS3X78AAAABGdBTUEAALGPC/xhBQAAAkpJREFUeNrtVz2PEkEY"
    "fnbZQ+AgGD+R5YSAxVkRLfwF5vgH11xlbeNPsbE2Ftf4C+RiY2OijeGu8GIusEjgiJ4Ej689"
    "YHedd8zgsBgt3Fkan+TNZnY3eZ55v2ZeDQzj8dir1+uwLAsT24ZKxGMxFAoFFItFJBIJTRuN"
    "Rl714ADlchlmNotoNKpUwHQ6RbvTQa1WQ2VnB9rh0ZGXSiaRz+eVEvvRbDYxGA6hW40GTNMM"
    "lZyQy+VA3PoFc4lhGKELIE7i1kNn9mFtAjzPW68AgUXwhaKwoGnaLwFE7rru4gOZWKsiFwJ0"
    "/+7tqQ6rw7JTVxcd4hOchvyCVPXOHbz9cA57soHtUhqO4yjxgMBSDogPo4mDN+/OcCVt4Ob1"
    "JGazmTJvLEIgu4Uwmzt48fI9mq2vPBzyP/9qlF9LZeh/KeP5/mucffuOSCTC/wnCBOcfPSDj"
    "6bN9fDppBOYJucJ4DtARSfbzKI6vCHjyeA+X05sYstMrCJA3RZVxAZTpwvx4tPcQ166m0ev1"
    "Ak2+lTIkctk1G0YEu7sPeBV0u91AyQmCyxALEiBUbcYjuH/vFnsC7XY7cHK5yS01Iqr3ZELH"
    "3VIc5g0X/X4/cHKx4d+ehiTgYvwFd0w3sIT7G1auQiRCZefzY+33gf8CuAD5eAxdwCXWfqkH"
    "qLyAyKDNUismTuLmkxErSmTZWEbZr/puSOQxNh9Sg5vP5zBKbEh8Va3yQSGTySifDWmTndNT"
    "fDw+RqVSAQ/+YDDg0/HnVgu24umYdn97a4tPx6lUSvsBjEDOU65zEi4AAAAASUVORK5CYII=")

#----------------------------------------------------------------------
aero_right_focus = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAACAAAAAfCAYAAACGVs+MAAAALHRFWHRDcmVhdGlvbiBUaW1l"
    "AG1lciAyNSBtYXIgMjAwOSAxNzo0ODo0NiArMDEwMKZ+RR0AAAAHdElNRQfZAxkQMQU5RdXP"
    "AAAACXBIWXMAAAsSAAALEgHS3X78AAAABGdBTUEAALGPC/xhBQAAA/ZJREFUeNrtV09oVEcY"
    "/83sy27UfZhtNLWxKNaDK6sNlJZIabHgpdB7KYiCR28W7EEPIkLbgz1481hIaSt4a6UUWkyh"
    "Imm9hKbpSg7pIUVjotnGJG5235uZft+bmc1bk8A+NTn1W743b98bvt9vvn9vRoBkbm7uxp/V"
    "ux8Mjce4t6ixkdJflDhZCVApH7je29v7oSDwX48PVd8x5bdx9IjB/q0CW2hitwDyNOZIA7qX"
    "sNqp8DIUaWyAJo1NGus0/l03+GlEQFZv46sT5Z/F8K3b5vLcID49alCEQE46wESFHZ1RkYGA"
    "8UoXZZiQQazts4iMfnzT4JPSb5BfjkV49V2BvLasN1oUgQR0OfieAGPLh+SSl8nfZhPA097p"
    "KwgwdpawbogEnpFOjazpeBv3P6uXzDrKok2KgNY2NopQcpwL0iaedlY4EY14hiQ0Fsg4DL7n"
    "yhCplQSeTUuFndBKSLf0LOBw4H7F2tlLRr1CsEVA0eyIVNLLAi19K9VhnWvHOOc7UllI6BQ4"
    "21euHLkvSHrjiUgfAp7I9d9H/n44VUdPl1hhbdrzoxM1ZrV6W7FfmyegYiRNIp8TmH6k8N3N"
    "R5j4axalvGwj8TyqUupJrhDgdqktCZb5xRjXf5jEvw9q2EutudXNMgKyPT96jVgV2kNgX1Jc"
    "Ur2w0VS4+MWPqE5Mob+giAS9z6j84/jrVC7ERrcW0+aByJXi03Lhs69x7/4sXqLszOIBg7Xd"
    "7xPRpD3ALklCsE6nOX3mc1RHR9FNOaLWMLiWxs5e7O4jF+amsuoXm5Th0KxB73JEEwMMyNXF"
    "dvXKOQQ7dmFiXnVchp5IRC5oENgy/VmiZJ+n7zKtA9/T2ve0+kAELNDLZY1VH/1L54+j/5Wd"
    "+GVGZWrF3tVRAm71CWEsKQuq0x4AEWB2DdV6gkI+h7Nn38ee3SXcmIptvDJ0Ik8gcbu2thMi"
    "ZIr3HJFqI6CIgKaJtvNtLwY4duw1LBS349vJJgJC9puULASiBNwkMW/QAw4Dd1jpynGFgKvR"
    "Wfo+9+yUGBwIgd0hRmbipDXL9LehQ1mvCTEOL0alq8DLP080vpmOkd8XYqzWecI9j6zakEzX"
    "NW49iFGPs6TcCySw2fI/Aemvm8mEsXLuPtixRWAblURI3/7NIFGgwg+7JBYoxxk7OHW4C8Oj"
    "OTqcKBSoaEMq0iIpb8u6iSbNRRedkHLP0Ih8K+6mimZbhcCeP0ICDoeRnBGDNw5XZip3Rvqu"
    "jR/BvkGDA7QB6SG0kPeGBFjgM6JgEtnClIDT2OAzIZFYpPExEZmkB2O/A+X5Ebw5cMjuM2u1"
    "mrnzxziu3dWYXtrYA9qubRIflSXeer2CUqkk/gNN/sDRnOMoBAAAAABJRU5ErkJggg==")

#----------------------------------------------------------------------
aero_right_focus_single = aero_right_focus

#----------------------------------------------------------------------
aero_right_single = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAACAAAAAfCAYAAACGVs+MAAAALHRFWHRDcmVhdGlvbiBUaW1l"
    "AG1lciAyNSBtYXIgMjAwOSAxNzo0NToxOCArMDEwMEtfu5QAAAAHdElNRQfZAxkQLyM/CW/t"
    "AAAACXBIWXMAAAsSAAALEgHS3X78AAAABGdBTUEAALGPC/xhBQAAAkpJREFUeNrtVz2PEkEY"
    "fnbZQ+AgGD+R5YSAxVkRLfwF5vgH11xlbeNPsbE2Ftf4C+RiY2OijeGu8GIusEjgiJ4Ej689"
    "YHedd8zgsBgt3Fkan+TNZnY3eZ55v2ZeDQzj8dir1+uwLAsT24ZKxGMxFAoFFItFJBIJTRuN"
    "Rl714ADlchlmNotoNKpUwHQ6RbvTQa1WQ2VnB9rh0ZGXSiaRz+eVEvvRbDYxGA6hW40GTNMM"
    "lZyQy+VA3PoFc4lhGKELIE7i1kNn9mFtAjzPW68AgUXwhaKwoGnaLwFE7rru4gOZWKsiFwJ0"
    "/+7tqQ6rw7JTVxcd4hOchvyCVPXOHbz9cA57soHtUhqO4yjxgMBSDogPo4mDN+/OcCVt4Ob1"
    "JGazmTJvLEIgu4Uwmzt48fI9mq2vPBzyP/9qlF9LZeh/KeP5/mucffuOSCTC/wnCBOcfPSDj"
    "6bN9fDppBOYJucJ4DtARSfbzKI6vCHjyeA+X05sYstMrCJA3RZVxAZTpwvx4tPcQ166m0ev1"
    "Ak2+lTIkctk1G0YEu7sPeBV0u91AyQmCyxALEiBUbcYjuH/vFnsC7XY7cHK5yS01Iqr3ZELH"
    "3VIc5g0X/X4/cHKx4d+ehiTgYvwFd0w3sIT7G1auQiRCZefzY+33gf8CuAD5eAxdwCXWfqkH"
    "qLyAyKDNUismTuLmkxErSmTZWEbZr/puSOQxNh9Sg5vP5zBKbEh8Va3yQSGTySifDWmTndNT"
    "fDw+RqVSAQ/+YDDg0/HnVgu24umYdn97a4tPx6lUSvsBjEDOU65zEi4AAAAASUVORK5CYII=")

#----------------------------------------------------------------------
aero_tab = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAACAAAAAfCAMAAACxiD++AAAAAXNSR0IArs4c6QAAAARnQU1B"
    "AACxjwv8YQUAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAA"
    "AwBQTFRFq6ysra6urq+vr7CwsLGxsbKysrOzs7S0tLS0tLW1tba2tre3t7i4uLm5uru7vL29"
    "v8DAwMDAwsPDxMXFxsbGycrKzc3Nzc7Ozs/P09TU19fX2dnZ2tra29vb3Nzc3N3d3t7e4ODg"
    "4uLi4+Pj4+Tk5OTk5OXl5ubm5+fn6Ojo6enp6+vr7Ozs7e3t7e7u7+/v8fHx8vLy8/Pz9PT0"
    "9fX19vb29vf3+Pj4+fn5+vr6+/v7/Pz8/f39/v7+AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAA0PbvAwAAABh0RVh0U29mdHdhcmUAUGFpbnQuTkVUIHYzLjM2"
    "qefiJQAAAP9JREFUOE+t0tlSwjAUgOFjZQuxuOBSFURSSOyq0qYNEd//tUzCaIeLk9743Zyb"
    "f5LOSUH3AC3vyEWIuIw06KvHRmGqKIJ3+u1RzaD0BpL+S3DwfIO5oqAHDxPk1LOpr9oGe0/h"
    "ArXHmSCjLbpIpSobyBa3o5DSWqJaF+xqlPykEE/LHFWmU2AkS1GZCdYkFajkjZhAxCghCLwS"
    "zlCcE1j1BpOeE176gqU/mMBy3F0Rb/mpZENh0QWxyJNTfD6HRXfFthgNndFgcJzDa2aCv0WZ"
    "tUj7blLdP9nZ6PCZATtPft+qjELt/vAm/HCzCNYmuA2O5xqzmzOwAuIG0AfGfgDFvqY+8bKe"
    "lgAAAABJRU5ErkJggg==")

#----------------------------------------------------------------------
aero_tab_focus = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAACAAAAAfCAIAAAAJNFjbAAAAAXNSR0IArs4c6QAAAARnQU1B"
    "AACxjwv8YQUAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAA"
    "ABh0RVh0U29mdHdhcmUAUGFpbnQuTkVUIHYzLjM2qefiJQAABPtJREFUSEu9ldtPI2UYxovR"
    "jZd65Z3xxv/AO2/0wnihiZpodgV21cSsiyYbs8ZkiQQSDUaynBaIB0ACLOsegJaWlkNpObSW"
    "XQ5dlgUqPQ3DtPRIW9pO5/DNtPGZFjeVte2F4uTtxcz3e96n7/t+802VJEkqlapx2LQXE589"
    "80xVVRVu//319FO5F587c/Xc6yoYXOrW983vzrqOrExqPcBuRTLOQ94T5/cSApMU/EnxIFUh"
    "wIAEDxW0jyKZRSr+Vv3d724YFYPaDn2Iyy5H5I2Y/MeR7EllaTbrz2QDXC7E5yJ8LlopwIAE"
    "DxW0yOBOylOO8CedOlUikfio0wAD239tYPEkatu0qng8/j8ZWCPyg5i8cyS78y3y/dWicL5L"
    "5QNMoUVQQYsMzqR8XEEsHr/QaQhksosheS0qbyVkZzJLpbP7yhgUTYjLQV8+wOQHkIMKWmTA"
    "LJcKLSoYYDimgHw/Ij9U5qxMiU5nGTZ3AI+M4lE+wIAEDxW0yLCdkBeODWIxGDCsPOUn1jBZ"
    "P5TyRcjelEynZaawnSoFGJDgoYIWGTZjktkTUyo4PDw832nA2iRDFoNkNSptxpXNin1GpeX9"
    "dNaX9ygfYECChwpaZNiISXPuWM1jAyolj9NkLkCWIxJGjQLxRzwpeS9d6FWFAAMSPFTQIsPa"
    "oTRbbADnmx5iYMhSUFqJKpPYgQdeOgw8P4/yAQYkeKigRYZ7EWnala8gGo2iRVgbdAvafdGc"
    "L8KOSaBRCdmFOtCrVIUAAxI8VNAigzVE9LtFBljrdQpjtDjrJ5aQhEngj6BYNLTgUT6U7EcK"
    "DxW0yLAQJLqCQTgcru00bMXk6zvCTY+oY4g5INnC0nq+Udv5OlBf+QADEjxU0CKD0U/UO48N"
    "Ogy2kPTGdPKilW20cx3b/K9O4bZXnKDFKYYANR+Q+dKBVTAgwUMFLTK0bPENJqamVavy+Xy1"
    "7YbFgPSKNnl2gb2ywjVv8j0OYdAl3qZEDU30DJn2kZnSgVUwIMFDBS0yNG3wXxvzBgzD1LQb"
    "5vzSy2PJt43sJRvXYOdbt4RfdsVht3iXUpS6fTJZOrAKBiR4qKBFhqtr/JUZprp1QkXTdE27"
    "Hv/ihd8SrxlSF5bYr1YzzQ+5rh2+3ymMeIQ7XnF8T1SXDqyCAQkeKmiR4fI9rq7YAG/A8yOJ"
    "VydT1Qvsl/cz325wndt8764w7BJuecRRShwrHVgFAxI8VNAiw+c27jNDvgKKolDBKRp4vd7T"
    "NfCcuoHHc0oV1GEG1yZUbrf7w7YKM8A+0dGifp/8Y2AHT9BklCI33GLvrti+JTTa+QY7V6dz"
    "fdyhrWyALYhNvIrzi8mUiqX9zDzNGilW706P7aZGHMn+9eC7Tepv+iZVLperfIvUlLgWlc61"
    "6j5o0TwZ7/+gQTz5vLZVU//zxO82m2JQ3aaf9ZGX7iTenEl9amXr1zMtj7gfHfwgXgKvoHwk"
    "9pK1rdp0Op0qunDL87zJZFpZWSl+zrKsKIqDQ0MWiwXHhGLw3vdqq5//YjnTZOe6d/ght/Lq"
    "4vAyHSjfHxyQP5kcl7vVhJDc3680yw4NDeGje+J5MBjs6u52OByKAX5N/bp3mtVnr2lLxcUu"
    "3a1R9fWurvaOjuLo7unp6+8/8RC3AwMDJrMZh9CxwfLyslqj0ZW+jHNzFqt1XK0eHRsrDo1G"
    "ozcYTjzE7fT0tP3BA2TH9Sf2aVnapn4zWAAAAABJRU5ErkJggg==")

#----------------------------------------------------------------------
aero_tab_focus_single = aero_tab_focus

#----------------------------------------------------------------------
aero_tab_single = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAACAAAAAfCAMAAACxiD++AAAAAXNSR0IArs4c6QAAAARnQU1B"
    "AACxjwv8YQUAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAA"
    "AwBQTFRFq6ysra6urq+vr7CwsLGxsbKysrOzs7S0tLS0tLW1tba2tre3t7i4uLm5uru7vL29"
    "v8DAwMDAwsPDxMXFxsbGycrKzc3Nzc7Ozs/P09TU19fX2dnZ2tra29vb3Nzc3N3d3t7e4ODg"
    "4uLi4+Pj4+Tk5OTk5OXl5ubm5+fn6Ojo6enp6+vr7Ozs7e3t7e7u7+/v8fHx8vLy8/Pz9PT0"
    "9fX19vb29vf3+Pj4+fn5+vr6+/v7/Pz8/f39/v7+AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAA0PbvAwAAABh0RVh0U29mdHdhcmUAUGFpbnQuTkVUIHYzLjM2"
    "qefiJQAAAP9JREFUOE+t0tlSwjAUgOFjZQuxuOBSFURSSOyq0qYNEd//tUzCaIeLk9743Zyb"
    "f5LOSUH3AC3vyEWIuIw06KvHRmGqKIJ3+u1RzaD0BpL+S3DwfIO5oqAHDxPk1LOpr9oGe0/h"
    "ArXHmSCjLbpIpSobyBa3o5DSWqJaF+xqlPykEE/LHFWmU2AkS1GZCdYkFajkjZhAxCghCLwS"
    "zlCcE1j1BpOeE176gqU/mMBy3F0Rb/mpZENh0QWxyJNTfD6HRXfFthgNndFgcJzDa2aCv0WZ"
    "tUj7blLdP9nZ6PCZATtPft+qjELt/vAm/HCzCNYmuA2O5xqzmzOwAuIG0AfGfgDFvqY+8bKe"
    "lgAAAABJRU5ErkJggg==")

#----------------------------------------------------------------------
aero_up = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAAB8AAAAgCAYAAADqgqNBAAAALHRFWHRDcmVhdGlvbiBUaW1l"
    "AG1lciAyNSBtYXIgMjAwOSAxNzo1MToxNCArMDEwMESarloAAAAHdElNRQfZAxkQMyBAd2MK"
    "AAAACXBIWXMAAAsSAAALEgHS3X78AAAABGdBTUEAALGPC/xhBQAAAh9JREFUeNrFl0tv2kAU"
    "hY+NBXbAElS0QTwColKX4Q+gbvmDXXXVriq160olq7b7Rk2zICsejWyUqkmQgEIMxvWxZAti"
    "0eCoHo40ssZj+5vrO3fmXgmuut2u4zb0+33MZjPEJU3TUKvVUK/X2SRlOp067ZMTNBoNNJtN"
    "JJPJ2OCWZcEwTXw/OwO50o/zc0fPZFCtVmOD3tdgMMB4MoHc7/VQKpWEgalyuQxy5Tv3VyiK"
    "IhROHrmyUOo97QXuOM7+4L4CZ/uziVuSJG3CCRYFX5+AcDg5iURiP3Ba7bOE+3xde/H5huWi"
    "4SHLV6uVEKAsy5uW86hbLBZC4FzpoVCzbVsI3OcFcP5yUfBQqBEuyufkhFb7Y+BMubheHguX"
    "fXiURjH7sSw7yIKivh/Ao4g+KxQK6A1MvHr9wbuyv35a7arI8Gw2i+ubCd6++4KUlveu7PN+"
    "rPBcLoer33d48/4bDvTDoLHP+xyPop0zR13XYfxaov3VhJZ5Fhr/+NlE62UFh090jMfj/wdP"
    "p9O4uk3itDNB6iC/9bnTjoXjFxmUnu42AQ/+0GKZz+c4KuaQz6kPflBTJYxuRrtZnnJjlbsb"
    "N/xtsc7x2+thkIH8S6M/9tbdkkbyGxwn1yuX3OBDsVj0Dpc4j1aCVVWFYRhYLpdQnrsV46d2"
    "26siGK9xFoo0zhwO0bm4QKvVgudsd3F4JfLPy0vPv3GJVh9VKl6J7EaP9Be4+2JJRD7+lAAA"
    "AABJRU5ErkJggg==")

#----------------------------------------------------------------------
aero_up_focus = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAAB8AAAAgCAYAAADqgqNBAAAALHRFWHRDcmVhdGlvbiBUaW1l"
    "AG1lciAyNSBtYXIgMjAwOSAxNzo1NTo1MyArMDEwMAycPlQAAAAHdElNRQfZAxkQOBMcU9vX"
    "AAAACXBIWXMAAAsSAAALEgHS3X78AAAABGdBTUEAALGPC/xhBQAABFhJREFUeNq1V82LHEUU"
    "/1VNz863yWyUyCSaEPzYuGtkwY8QYwLiQfTgwYsgBPMXeDJXvYmo+Qc8KEFIULyJHhQWNcSE"
    "3KLrLgqLoMYVkplIdmZ2PrrL36uqnulOsu50YB68ed3V3fV771fvvZpSoDSbzS9/Xll9+czy"
    "EFc3IkxLGlWNE/MBjj17RBljPlQE/uH1MytHzcEjeOGwwYGSQokvzigqbUCbo9UTAhhqKMqL"
    "IW2PdpN2g/pbx+DH7xX02gWcPblwWi2dv2Debz2Dd48bVIxCjiiBFjBeE1iJwumkIg4If5ER"
    "NRiKIxxgtOhpjVNfGby15xL0xz8NsP+owkzoPpqmiBP5MEL9RUBw9bWuwe6iwvRWOi2C0yhp"
    "CO6kSzkVCWJvzBYqopBtScwdruM8sHj+wkYuiWGMBxTrHxrvQdZcMCat0S33qcgFbMBBTau0"
    "y3CL6K0yfmxCibzDoYkz3pdelGbA0U53Ir4RqfHLmq9FcHVmSy1D+GbEphnNF5cdLFYuAR65"
    "MsgJqNcwMZkFzxB5THXcbGzUXk1iGS240BGmPEw3lqwlkcyfcbNxGHbOKEW7W/M4cpVYb7Em"
    "I+0pQM/qIHIq8w1NMnLyMwhdHw98pCOqI39/NwnnGY2tMKwwLjUL7tbE0Iqyp1Ot5/HqqOwJ"
    "FyYot/MKA5EZMTOOfOi8smuv3Yc26RLdRWeMPLnOoU++oV/SVOTnmuzv5H22oFDLK1S4nRVZ"
    "DTN0JK/d7pbLAB7vYn2i92jbHLg5AFp9KV6Fs5zreAy+ycg3+KDADiMDOZuuCibnMjYLeEy5"
    "gPcIvsmQuwTvMKPbfWNrfTAIx5H36FWHDpR5V+A4g7c0x1RLIkYZwSWz+5yr57UbOgwJJgwT"
    "tEuqt+lqhYNFLvSMUB2O69tkBB/adm1IuwBL9E47ZMA6lwIfOup71D6p7mv/98m3VvHC3AIu"
    "tzuYI//2zG27WJy8cW1bBjyGFQ8+al5RQs02Ksvxyr4Ae9t/WqvV9t8k548l858JYeOlhsLy"
    "yhrePHXaWrnPUg13DX5oNsDf/9zAO+99jnKtYa3cy/hUwRd3Bbj5xzre/uAb1Or7Rir3Mi7P"
    "s8jEbz+yI4fm79fxyRdrqO588LbnH322hjdezePRvbP4pRVONOdE4PtrGr2rHXx7qWup3krk"
    "+bGwjYceqNCB4bbzOnD9//yv86Tx/IEKGrvL205YLSssXds68iROcC+PRxXmf5WNfCsHpEF8"
    "xwlLE/DUve7a6Z2kyO8reY0arwU3OPl4HktXctjzHCenw1V2l2oeKLF2Cjm3scQNZzjByUKO"
    "WvfwoDdgSyyytxf4fZ5b5Az/qdxHnyoE3fW1wonFAMHiwmOr85cvzn26fBgHnzZ4uKyxk6BV"
    "gvFgwc2GDsB1vEnEdjj+cA8BDyVo0+Eb1CbZ+5Unxr/OA3PRRTz5xILrnq1Wy1y+soxzqxHW"
    "29M7ON1f0XhtTuOpQ/Oo1+vqPxxtdiUOpmR7AAAAAElFTkSuQmCC")

#----------------------------------------------------------------------
aero_up_focus_single = aero_up_focus

#----------------------------------------------------------------------
aero_up_single = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAAB8AAAAgCAYAAADqgqNBAAAALHRFWHRDcmVhdGlvbiBUaW1l"
    "AG1lciAyNSBtYXIgMjAwOSAxNzo1MToxNCArMDEwMESarloAAAAHdElNRQfZAxkQMyBAd2MK"
    "AAAACXBIWXMAAAsSAAALEgHS3X78AAAABGdBTUEAALGPC/xhBQAAAh9JREFUeNrFl0tv2kAU"
    "hY+NBXbAElS0QTwColKX4Q+gbvmDXXXVriq160olq7b7Rk2zICsejWyUqkmQgEIMxvWxZAti"
    "0eCoHo40ssZj+5vrO3fmXgmuut2u4zb0+33MZjPEJU3TUKvVUK/X2SRlOp067ZMTNBoNNJtN"
    "JJPJ2OCWZcEwTXw/OwO50o/zc0fPZFCtVmOD3tdgMMB4MoHc7/VQKpWEgalyuQxy5Tv3VyiK"
    "IhROHrmyUOo97QXuOM7+4L4CZ/uziVuSJG3CCRYFX5+AcDg5iURiP3Ba7bOE+3xde/H5huWi"
    "4SHLV6uVEKAsy5uW86hbLBZC4FzpoVCzbVsI3OcFcP5yUfBQqBEuyufkhFb7Y+BMubheHguX"
    "fXiURjH7sSw7yIKivh/Ao4g+KxQK6A1MvHr9wbuyv35a7arI8Gw2i+ubCd6++4KUlveu7PN+"
    "rPBcLoer33d48/4bDvTDoLHP+xyPop0zR13XYfxaov3VhJZ5Fhr/+NlE62UFh090jMfj/wdP"
    "p9O4uk3itDNB6iC/9bnTjoXjFxmUnu42AQ/+0GKZz+c4KuaQz6kPflBTJYxuRrtZnnJjlbsb"
    "N/xtsc7x2+thkIH8S6M/9tbdkkbyGxwn1yuX3OBDsVj0Dpc4j1aCVVWFYRhYLpdQnrsV46d2"
    "26siGK9xFoo0zhwO0bm4QKvVgudsd3F4JfLPy0vPv3GJVh9VKl6J7EaP9Be4+2JJRD7+lAAA"
    "AABJRU5ErkJggg==")

#----------------------------------------------------------------------
aero_denied = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAABYAAAAWCAYAAADEtGw7AAADxklEQVQ4jbWUzWuUVxTGn3Pe"
    "+955k8nMJE5m0vqRZCaUYomG0uJGjDR0UXBRUj+6Kqg7kSy6SBf5A7ropiB07aK4qIsWIYsu"
    "ioXBQoRKqWhJ1eq0sWqSmWQyk8y8H/e+p4t8oJ2YuPHA2dzD+fHwnHMuiQheR/BroQJQOxWv"
    "Z7N9cRB8nAA+dIEBAIiAvwPgJ04kro1Vq/Mv66XtrCgVi9osLEx1K/V57+HD6a5Dh8B9fSDH"
    "ga1WsXr7Niq3btVrUfS1yue/HH34MNwV/HM+n1HN5vd7+/vHsmfPQu3bt60i8+wZli5fxr/l"
    "8nXT2fnJBwsLK8/XX/B4ZnhYqWbzyv5icaz34kXwnj2IrYUoBXge4HkQpRBbC85kkL1wAfuH"
    "hsZUs3llZnhYvRQclMvnsqnUidTp04DWoEwGnE6DEwmQ44AcB5xIgNNpUCYDaI3UqVPIplIn"
    "gnL53LbgmULB9YCp9LFjcHM5KM8D+z6o0QD+l9RogH0fyvPg5nLIHD8OD5iaKRTcTd6W/KhS"
    "OZJOJgc7R0ag4ngd8gqhAHSOjMArlQbrlcoRAL+8oJhFjiaLRWhmrN29ixYzfNdF6LqIXBdG"
    "a1itEWsNaA24LoQZ5s4duAC6hobAIkfbFDOQ78jlQPU6zNIS3jh/Hqz1jmolDFE7eRIqk4GX"
    "zYKBfDtYJGDfB9VqkNXVV7IBAOT+fYjrrs9DJGgDE/Ns+OABkExCBQHmL10CM4OMAVkLAkAb"
    "3hEAIgJZC7YW9OgRwnodzDy7xds8kF97et70iMrFfF6T1gAzEEWAMburBvBwcTH0RQbfX15+"
    "Cjw3vIOl0tMgiq7VVlbA9Tq4VgOvrYGDYNes1esIoujawVLpaZtiAPitu/sta8yt/o6OVI/a"
    "8X/aimVj8E+r1XCUeu/dWu3+tmAA+D2dHvetvdqtlDrgOEgQbQsMRDBnLWrGGM9xzozU6z88"
    "X28D29VV/LF370d+HH/bFOntIkKGCJuLFwJYEcGqCDqJKh7zZ+88efKj09WFHcFbtuTzOW61"
    "vghEPo1EDtiNdweASzSnib6Tjo6vum/eXCwUCm39dO/ePUxMTDizs7Oq0WjoMAy1tVbHceyK"
    "iJsFOs4wv32AqF8AzMXx3FWRP5cAn4hCZo6YOdRah8lkMhwYGDCTk5NGzc/PY21tDcYYiuOY"
    "RIQ30gGgKiL4xpi/AJSxvsIWAIjIAaBEJBYRx1rLxhhqtVqoVqu0rRXT09N048YNPH78mKrV"
    "KjWbTfi+TwDgeZ4kEgn09vZKX1+fjI6OYnx8vA3yHxWIwp50Lj49AAAAAElFTkSuQmCC")

#----------------------------------------------------------------------
auinotebook_preview = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABGdBTUEAAK/INwWK6QAAABl0"
    "RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAJXSURBVHjahFJRSBNxGP/d/+52"
    "W66ildPKJB9EMSwjFSNoUkS+GYg9pi9R9tJeopcgC3yKYvRUMHA+VBJUmpQPQSySKINqEGSB"
    "Np3aNjs3N8+7285d/7sxa9yw3/G777v/932/+76PP6PrOgw8D876dYImWJAEZPpW8l89nYea"
    "i8KGgMHRYPitvgkCw0G9qaNXD4x80Qs1BknRnzaBEfX1e+G758PQaEgvnP8VULA5lCS8/T7T"
    "NUQK4ApO4j/1l3s6N/zA8MiGTxiGgUGowGwkhqkfc5Bl1SKwlM6i90y75dzsoKX9fNPLF2Mt"
    "sZVGuMt3YPDpK7jsDnj7uiEIfH6ClAjF5rAKHD1xcW99a927C5e6hP3luwCGwONpRjwm4tqA"
    "H7du9pmJDG9HrsSeSE3dvmdnz512tFZVQaGjaCyBjedRubscxzva8PrNJzNR0xmsKsQq4KzY"
    "fqDW7UY8o4KjxRzLmpYlBLUNNZj48BVRMQlWA7I5yTqCvcyuq+s0qmkQiC1/QeiTo1ajNpWS"
    "oMoMVJVyXbZ2sDj9S5sMh2l7CjJUJGswq0HNZBCNLmEhPA0xsQpJUSHJJUZILCbuxuZF7fv8"
    "ApbTaaysrSEpSVgURdy//RDJxAp2RvzgMgkQzbpEziVEbgQfBeuXPY1dqcMS4W08cnIWY0Pj"
    "iIXjuNI2A0dsDmXyT3yUTtESZ5EAU3CuDvhD7ydDB1mWg6zQWelSj2ydwbE9v1Fd4TQZmHLj"
    "yTfBzP88PsgUCZTCne4qFycID7Zt4TuqK50TFaTmZMP1x5l/c/4IMABbKBvEcRELXgAAAABJ"
    "RU5ErkJggg==")

#----------------------------------------------------------------------
whidbey_down = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAACsAAAAeCAMAAACCNBfsAAAAAXNSR0IArs4c6QAAAARnQU1B"
    "AACxjwv8YQUAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAA"
    "AwBQTFRFAAAAaHWVZ3egZ3e1cYCncYa0dpC4cYXGcpDBc5fWd6Dld6Pwi5OzgJbUkJjQkqHC"
    "hafggqfwh7Dwk6Xgl7fwoKjWp7fXsbbWoLfnoLjwpMLwscHnsMfxtdD0wMHg5eTo5/D49/f3"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAverH2wAAAQB0Uk5T////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////AFP3ByUAAAAYdEVYdFNvZnR3YXJlAFBhaW50Lk5FVCB2My4zNqnn"
    "4iUAAAF4SURBVDhPbZTpYoIwEITRGqAQ1ChqOFrx/R8y3SObq8yvsHwZhglaOdH7HZbJIp1W"
    "YW7t7w68LOcwDaxd5+lhC3q18zwOMhTWIjtZ+3wGfFmWFYZjgJl9vWC/1x30AI2zzExzIcqz"
    "a2RxC2Ak2n4zJmEx1TgaY8R7AtHsdgMS1IivJRZHyN5lA6PMEgwZ2JVYs23bxwuWG3PGdF3X"
    "ImvtBO/KqAl38ytgO+WqMz1SDDz7KXaCbatU5YYARt+SbUHg61zT9/iMHsQZKHBI9A1S6njk"
    "fpuCRTjmJVQBymfxlfuCc5IX0cMhnhvCMYO8KCdCV0L9GbMz8Fhqous1ugbWw/32k2oDtFUn"
    "do2sz1ywqWvCElz6pq4pS3CRVxooMvjqsI2+v5LwXCVrljfrGclhqH2v5e+Nr6VnYltgBct7"
    "iDDExm+grvm0ouL/QwrjN1CHXvczYAz0xF5Pp9w168zfAhjeH9gSle8hnWutldL6H7rHOq2P"
    "agd1f/M7VhKuYPh3AAAAAElFTkSuQmCC")

#----------------------------------------------------------------------
whidbey_down_single = whidbey_down

#----------------------------------------------------------------------
whidbey_down_focus = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAACsAAAAeCAMAAACCNBfsAAAAAXNSR0IArs4c6QAAAARnQU1B"
    "AACxjwv8YQUAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAA"
    "AwBQTFRFAAAAECBXFC9vECiQBS2oIDKMIDigC0CVJUqQIkewJFKlJlayMEiwMlSiK2G0JFTR"
    "LmnSKGHmKHDoInDwMGjgNnDgNXLwSFeKQFizR2OkUGagcHiYZ3egcHilUHjRQXLwR4DwU4Pw"
    "YIfTcYXGcIjVc5fWZpHxcJj3d6PwgJbUkJjAkJjQkqHChafggqfwh7Dgh7Dwl7fwoKjAqLDI"
    "sLDIl8D4pMLw4Of35/D4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAQS37pgAAAQB0Uk5T////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////AFP3ByUAAAAYdEVYdFNvZnR3YXJlAFBhaW50Lk5FVCB2My4zNqnn"
    "4iUAAAGeSURBVDhPfdOLUsIwEAVQCCixFSggVfBFQWpVjKJo+f8fi3ezSZq2jDsDhHB62Wyh"
    "o319Vctg9V2tO34p5H0bHw5D4Xe9FULK5bKhb6UcDs/cprNdMYiprhee30khaStx2NpudwCb"
    "JHG8WAhbEkU0cZgtUge0iYrjCEUuilheOWysS2U9GpluGJJ1mKyg1LHZn6NYNNYUCWuozSjr"
    "FVxnLGQUjZPJlLJKCk7piar0Nk2zS90RAhINVDZN5yUeNZuhbjq6BzmZomYoICr/Yr5mtcry"
    "fL2mfnvjSd2anvkSsqBZUazN2XS/YVNLrc2Qut3yHAj/10OWFwVRtrpPvZo5cL+28A7fnxfv"
    "G6Ps74GwsfXCsXKkMnWWko39DKukAbjUygKfskFqYLnnKvcHdQT9sA0EPdgD1ts9Vr2G/fpp"
    "pDMeAg3gWe2fgn9V9d+0yW5edCylQurnwJejZ/7VPJpZ7V+C1PBsFrPFXAul6rSRi2S2uFmq"
    "kdrK1frcWOq1kXrC6osHulnq963Wa3Nm9kOySrVpq1/yr5vNbtdK1foPGIxy6qmqIg0AAAAA"
    "SUVORK5CYII=")

#----------------------------------------------------------------------
whidbey_down_focus_single = whidbey_down_focus

#----------------------------------------------------------------------
whidbey_dock_pane = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAAF0AAABdCAMAAADwr5rxAAAAAXNSR0IArs4c6QAAAARnQU1B"
    "AACxjwv8YQUAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAA"
    "AwBQTFRFAAAAaHWVcHiYZ3egZ3e1cHilcYCncYa0dpC4ZobHcYXGcpDBc5fWcZjgd6Dld6Pw"
    "i5Ozl6e3q62xgIjQgpXEgJbUkJjAkJjQgJjggKDXkqHCk6TWhafggqfwh7Dwk6Xgk7Tkl7fw"
    "oKjAoKjWqLDIp7fXsLDIsbbWoLfnoLjwsLjjl8D4pMLwscHnsMfxtdD0wMHg6tTN4Njk5eTo"
    "4Of35/D48Ofh9/f3AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAA1jVbdgAAAQB0Uk5T////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////AFP3ByUAAAAYdEVYdFNvZnR3YXJlAFBhaW50Lk5FVCB2My4zNqnn"
    "4iUAAAdFSURBVGhDtZpxe6I4EMbtbQVXrHJuaY8KWq/XW3Sr196u8v0/GTfzThICRIh9nssf"
    "u4rw42UyM5kJHVVXjDQah/EV51ejK05+SKMwjK/BX0Gfzu9ms2kY3PgL8qd/nc/vCB+GN/54"
    "b/p0sVjMaRA+9Mb70hku9GvUe9IBV3TC+9rejy5wTfdX70VneJ7LHRaLu7uIPNPL9j50hp+a"
    "w9NzPOhQfvrHHqeZn/phOmzeofvZfpA+zTFa2rNsFk2GPWeIruB5y+5En00mg1E7QNfw/CSP"
    "oEaZ51kWDavvpxu4phOWB+hJMqi+l17DFb0sBa+eJB3KOX30xLIFeAQXvKYTvtf2PfTVbrtd"
    "6xsonrKMoafhJAwu5/vL9NWO6Rp/iZ5OJsFlfI/2onh7oxvQYKOsaeALjTV944fK2DFn489o"
    "ryqmA69NDrtjWPSwZyHs9RlWr+h5Qzt9UdqzPvhATTBMn/Uu4QOxut9r24vFdzSUvUh+lk37"
    "6wMXfVNf8sF0mdrt9nGF8YbB3ppNl/WpK8eNHPTNxuCXHx/a9q+vZz3exZvW6+m5NPhi58B3"
    "6Yfj2zYRHcuSgOI5Bi0fDgeiT/nT8oxTi2K3U1dZz9ChH5gu+GXJ9HNRvP/dgoOfyEGox/Tn"
    "nVlo04kNm34DHPRfv7psxuujywqm4rBo41t0Vs4uvl4/PXHUNLj7/f6VRvte5RJTjxBo4Zv0"
    "A3sDxw2d+EeTcnzd4qnIdR43zZ/EbSUjNfEN+oHppFsiEZOmxn5/ZJOBvt1uNivrNyvk2nib"
    "fmA6W0W0Z6FGkL0sNvLYt0L/aKeLtnqLTvCD2FzRNR53VelSZ8l1IfhfdqqDbRaWcWo6nWZs"
    "zrk1SZLVvww40oBeZTG9oDwbOm6pDy8svKHzA9Y2Z3oUgU5WOSIXdOjAv/Nv1hLJ5aZRr+lQ"
    "XhNYevSEZye6ZJo2PZNpd9ANXtFFuYtOM0p50UnP4Dm2VeQZavVCZ6cqudziCOL/szSKYkh7"
    "hReu62UJv/MyS8+HM2AZuUwNgwcdTlVSkasrrppOgSL0Rg2ME9l6uD8/cqmWd643T0Y90xEO"
    "azku48RzCu0vau1z0lNEhJu++Epkoks4dOhjPPaL+Hl+gf4upmlplzaIPGdUIbewXls7OTvo"
    "xktbdK6auNyAWz266fOHaoQ4ZKNpOl940vRXHQN99BU9XMkzqylo3+7u0nTEdkHkKzoKRUNH"
    "tccxeoEOwxs6XQqK0GdRNFoVKkqEDo+8lk4Syq2UsDWd2ubxKHtm5dzVid1Fe5bOjCx4kUt7"
    "mohf8QPCMg3ttGERjp4z1Yk27O5HV15r6MbuVF1S2xbHo+pRNblNf88SaN9sVIpyaSfDYhnU"
    "dEQK7A54ELO/f6VJqC2joknF4bmfPgadw4UtY+hmo4Vj9ZanWNtd07PsRfmDuYqTgc43nAei"
    "e8TEu4OuWh7kGcb70kViKfR7phdvVA808gw34thHkBzJ+EZHSquH5NfzN5p1ZU+S/kM3fZxE"
    "owBnCF2lWFAivcWi8jvUYydDBujAZ0JX7XD5Q0yTMT0EnVf6emHh9FC3anptgu3nc5ueppC2"
    "0nfT//OdqRcOA5HeoVsbFGZdFbxFJ3/7C3ShyTPoz/C4PwHnhau+rLmxVdcEwNunRdEYNcFK"
    "8Wv6jO4cBL8DfuC1xbqssbVi1TOMN6chHoSu1Ws6ByLZBfDzObEX8yRqNvd2LaZsLzt3k8lY"
    "1g8aDw+Ukc3gfatAzMJjapTnOdEb2yqNOtLgSdwkMHBWGEIxxmQS/iYTqvAyGSmN9rZEswZW"
    "eJkaC0Af4/ieBrPHY6kWWniCh+0NoVb9DjzbPLhZNhH07f4+CIK4heYbT0V7d0ui3XvcSvLk"
    "QEbXROPnz859zFGOLGptZhRDru2UTt9EeB3ISj31TQ784fBIRwVeVTQtrq2gbs93G0Vfvtg9"
    "3/Ft92KqdXWfI1cpVCspOOMnjg3QLr0aRwpOxuGOj+i7orD6JarnqVugEE2sfnXs2khx0CsD"
    "r6rv33U3w/3MZvNCQ/dP3EI+1c2pa5fGRbfa2e/SApohXbw6RmFk0a2rzMd+ujRclAI0XnYh"
    "pBRH1ujfhuil6yZX6LTEmlEnl158H91uFVVtr+t7ne0o9iKXSdSxHjpvLJieqLmXar5xaPfs"
    "Ll2mP8IMWqRzTy/PSTplzIvqe7Qndit3gc4581Paq4p23lHpYP+dH6K5lyoZSce1U3+vz0xb"
    "dMZLgcD/AB5aode9Qb+/S5VmtEsDUNMH334MxKqpcxw+4/HWbIAuNSbXgc3RLIo+4zNyjeBR"
    "ZdbjRKuFKec+F03qqrpCtuieb/uGLGNXyDbdR7mugXsezlUhn06D3iJED+2qvkcDpCpUvzdl"
    "nnTVnSg6vavxfT/spb1Wz9qpnPN7Q+mrXTsmF1I+78j0PHpq13jOLR7v966mV6jS0BX0vAJq"
    "OZ+3dlLP8UnDH+7nkUpRHMf/399CVFUcf7nu7zj+A8yummsi9EdGAAAAAElFTkSuQmCC")

#----------------------------------------------------------------------
whidbey_dock_pane_bottom = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAAF0AAABdCAMAAADwr5rxAAAAAXNSR0IArs4c6QAAAARnQU1B"
    "AACxjwv8YQUAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAA"
    "AwBQTFRFAAAAECBXFC9vECiQBS2oIDKMIDigC0CVJUqQIkewJFKlJlayMEiwMlSiK2G0JFTR"
    "LmnSKGHmKHDoInDwMGjgNnDgNXLwSFeKQFizR2OkUGagaHWVcHiYZ3egZ3e1cHilUHjRQXLw"
    "cYCncYa0dpC4R4DwU4PwZobHYIfTcYXGcIjVcpDBc5fWZpHxcZjgcJj3d6Dld6Pwi5Ozl6e3"
    "q62xgIjQgpXEgJbUkJjAkJjQgJjggKDXkqHCk6TWhafggqfwh7Dgh7Dwk6Xgk7Tkl7fwoKjA"
    "oKjWqLDIp7fXsLDIsbbWoLfnoLjwsLjjl8D4pMLwscHnsMfxtdD0wMHg6tTN4Njk5eTo4Of3"
    "5/D48Ofh9/f3AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAaHenigAAAQB0Uk5T////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////AFP3ByUAAAAYdEVYdFNvZnR3YXJlAFBhaW50Lk5FVCB2My4zNqnn"
    "4iUAAAejSURBVGhDpZkLe9o2FIYpTVeWrG3Srmy9stk0LTPJMKMhmYM9KOuSERqydAX8//+H"
    "dy6SLF+QRXeepwtg+9XnT+fotlqyRQRey+1vcX9S2+Lm08Bz3f42+C3ond5xt9txnRf2guzp"
    "b3u9Y8C77gt7vDW94/t+DwLwrjXelo5wpm+j3pJOcEEHvK33dnSGS7q9eis6wqOIW/D942MP"
    "MtPKexs6wlfZsMwcCzopX/2jx6prp76aTp4X6HbeV9I7EUVOexh2vXZ15lTRBTzK+Q70brtd"
    "WbUVdAmPVvwKIuIoCkOvWr2ZruCSDlgMog+HleqN9BQu6HHMePEmQdWYY6IPNS+IB3DGSzrg"
    "jd4b6KOr6XQsGxA84YyiB27bdTaP95vpoyukS/wmetBuO5vxBu2z2fU1NACBpowh6AvEGL7h"
    "S4WYmN3W12hPEqQTXlpOvlNodNcwERpzBtULepTRDl+E9tAEr1gTVNO7xim8olbnc+k9O34F"
    "IfwC+WHYMa8PyuiT9JHPSOeunU7PRhTXFJitYWeQ3joqaaiEPpko/ODzZ+n9xcVaxi1n03jc"
    "WccKP7sqwRfpi5vr6ZB1DGIAcuYoNH9YLIDewU+DNd06m11diae0dyjQF0hn/CBG+no2u73M"
    "wYk/5B9JPXV/VOiFPB3Y5Ol7ghN9uSyyES9/HSRkFZZFHp+jo3JM8fH4/ByrJsOdz+cXEPm2"
    "4gF1PZVADp+lLzAbsG7gxt+zlJuLKb0VpM7ZJHuJ05ZHpCw+Q18gHXRzJVKniZjPb9Ayok+n"
    "k8lIu6aVXB6v0xdIR1dYe+hKBPilsWkcez+TF/XhIq9eowN8wZ4LusRTq2K4lKPkeMb4pT7U"
    "kTe+Zk5Kh9uU5zi2DofD0b8IuIEgvcIxOaF8UHRqUv7sa3hFxxdMPUe65xEdXLmhsaBAJ/wt"
    "XtOmSFxuKvWSTspTAkr3zundgc4jTZ4ecreX0BVe0Fl5GR16FMbFUnpImaO7wu+Qqmc6JlWM"
    "yy2sIPwbBp7XJ2kXlIXjdFqi6zjNwvvRHeQMPyZC4YlOSRXDIleuuFI6FArTM2tguhHdo/bx"
    "lWMxveN6c6XUI53KYcy/c6ywT0n7RzH3ldIDqohyuv8WyEDncijQW/TaHznPow30W7Ymp523"
    "QZA5tYTGFtSra4dkJ7rK0hwdV0243KC0Oiun906TGtUhmibp+OBK0i9kDZjoI3i5GHtWUmj7"
    "dnwcBDX0hSpf0GmhqOi02sMa3UAn4xUdHiUK07ueVxvNRJUwnTJyWzpIiKe8hE3psG1u1cIP"
    "qBx3dew7aw+DrpJFWVSmPRhyXuELkjMZ7XBg4dY+hGInmvHdji6yVtGV77C6hG1bv19LzsQm"
    "N5vv4ZC0TyZiiCrTDsbSNCjpVCnkO8GdPub7W+iE1BlRTaIO12Z6i+hYLuiMoquDFqzV19jF"
    "0ndJD8OPIh/UUzgYyPEGxwHvhGritoQutjw0ziDels4SY6afIH12DeuBzDiDG3E6R+AxEvGZ"
    "HSnMHjy+rt9Drws/QfonuenDQdRz6A6miyGWKJ48YhHjO6mnkwwOohM+ZLrYDsef2JoQ6S7R"
    "caZPJxYcHtKtmpybyPteT6cHAUkbydbkX2wZ9sKuw9ILdO2AQs2rjNfokG9/EZ1p/A7yM2Xc"
    "nwTHiSt9LHuwla4JCK/f5nktWhOMBD+ld6Flx/mN4AucW7THMkcr2noG8eo2qgemS/WSjoUI"
    "vhB8vR7qk/nQy27u9bWY8J5P7trtFs8fEKenMCKrwHMrh23B6CjlUQT0zLFKZh2p8CCu7Sg4"
    "KnRJMUW77b7kDhV47owAIn8skV0DCzx3jQaAj/3+CQSyWy1eLeTwAHfzB0K59Tvh0XPnxSCL"
    "gG8nJ47j9HNobLjD2otHEvm9x2sePLGQadcE8UVZrLf3hdIVKwu2Nl2oobLjlMK+CfCykIX6"
    "ekPvAdHC5eWDOtNp3wTdUnYUVNzzvfa8V6+0PV+93mg8f56z6WWj8eDBPaSLLaXbbZccgBbp"
    "ScsTcDBnvb5Tv7+H8cMz1cCrRr2BP+3f0/arrbKDlBJ6ouBJ8vedO/eBvr+/t/fsWV1EAwLh"
    "+/v3ztPNadkpTRld286C8vuIgdjb24VA8u4us78HvHZvyUczXSpn/sOH5BGjkV6JN9LrqPwR"
    "kZ5CMDP32XjKYaITXOhcZkNryTOYY6ADe3f30f7BY9S7RPFN/A/GUtGbzcPvNuM30+t1YIMt"
    "Kb3ZfLqEfxn6IcSPG/EG7XeBffAY4gkEYDHUH3qVN28Oj47evfsa7Uly99FBlk7ecyNIB/ih"
    "7xvg5lO3nRy9KeCCfgjKu8ZjN3O+7xidOTzy/f91preDnlPOsO8i4Bu4cuR/zZme3kuIJ3o2"
    "oEOPQHnFgWH1/wEFPNFx6lexxGSpVC7XkaaxaKeUbqPchp6Q96n2TxArgP9RZYtaA5vHUcRn"
    "bV9ZeJ6usM10Vt98wgmDyfJrNP2l4hm6XDF7CATiZTZih0aRFdySjup5/PqZMlEe5Vbpt9Oe"
    "AJ7pkOewhSie+Ja3Y0tPdpgOBRrZKrf1HZV9Q3T03Fb5NvTk25+wQKPrsyq30+vWzsAjSI+i"
    "LeC2OcNyTjudc219VP0O/wGW4JFYg7jH7QAAAABJRU5ErkJggg==")

#----------------------------------------------------------------------
whidbey_dock_pane_center = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAAF0AAABdCAMAAADwr5rxAAAAAXNSR0IArs4c6QAAAARnQU1B"
    "AACxjwv8YQUAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAA"
    "AwBQTFRFAAAAGDeAJUqQIEOkIkewJFKlJlayMlSiMle1K2G0LmnSNnDgR2OkQ2O1UGagUHCo"
    "VXSzaHWVZ3egZ3e1cHilQ2TAQHDAQnLSVnfFQXfgcYCncYa0dpC4VYTTRIDjVYbgZobHYIfT"
    "ZpPXcYXGcpDBc5fWYIjgYZHgcZjgd6Dld6Pwi5Ozq62xgIjQgJbUkJjAkJjQgJjggKDXkqHC"
    "k6TWlrDXhafggqfwh7Dwk6Xgk7Tkl7fwoKjWqLDIp7fXsLDIsbbWoLfnoLjwsLjjpMLwscHn"
    "sMfxtdD0wMHg6tTN4Njk5eTo4Of35/D48Ofh9/f3AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAXehG6QAAAQB0Uk5T////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////AFP3ByUAAAAYdEVYdFNvZnR3YXJlAFBhaW50Lk5FVCB2My4zNqnn"
    "4iUAAAdqSURBVGhDtZoNW9pIEMc5emrB651VUDRUpEkqb5d6SBOUXq9Q8dprke//aXLzsrvZ"
    "hGWz+NzN87RCzP74M5mZzGyspDvYOGh4wx3OTys7nPx+HHjecBf8DnS/3wtD37t47S7InX7V"
    "7/cA73mv3fHOdH8wGPTBAO85413pCGf6Luod6QQXdMC7+t6NznBJd1fvREd4kvAnDAa9XgCR"
    "6eR7FzrCV3lzjBwHOilf/a3bKnRTX04nn2/Q3XxfSvcTsoL2OA6DdnnklNEFPCn4Hehhu12a"
    "tSV0CU9W/BWErZMkjoNy9Xa6gks6YNGIHkWl6q30DC7o6zXjxTcZl9UcGz3SfEE8gDNe0gFv"
    "9b2FPlnMZlP5AYInPKPoY6/tXWyv99vpkwXSJX4bfdxuX2zHW7TP5w8P8AFg6JQpGL0Bm8I7"
    "/FIxBmbYeI72NEU64aXLye9kGt2z3AitMYPqBT3JaYc3Qntsg5f0BOX00HoLL8nVL1+k79nj"
    "CzDhL5Afx769PzDR77Il35DOl3Y2u5mQPZBhtMb+KDt1YvggA/3uTuFH375J33/69CTtK0fT"
    "dOo/rRV+vjDgN+nLx4dZxDpGawBy5Cg0v1guge7jq9ETnTqfLxZilfYdNuhLpDN+tEb603z+"
    "9a8CnPgRHyT1dPmTjatQpAObfPo7wYn+48cmG/Hy6CglV2FaFPEFOirHEJ9Ob28xazRuFIYt"
    "sjjOf9p6RJeeUqCAz9OXGA2YN3DiHzrjw4du66zT6VyCNZvNdzk+hy1XpDw+R18iHXRzJtJF"
    "Y4uvrrpdgBP98vJds9vNfqmlXBGv05dIR6+w9tiThLet62tkn50h+xzs8GVL/lIvF0X1Gh3g"
    "S/a5oEt8+PYtws/AFP2wxfgfeqkj3ww052R0OE35HGtrFEWTfxBwDUZ6NauDnSq6LNNM1/CK"
    "jl8w8znSg4DoEcDZG0U64b9indBukdhuKvWSTsqVV+iOH9zSBe0C3Eiv/3yFJxjoCi/orNxE"
    "73YBbqbXiS5vAJn+TD3TMajW2G5hBuHPeBwEQ1wbtjrklfuCoePrtVDgsV3QujWFJzoF1Rqa"
    "XNlxafSOoOO1zeye6TWkf8KvvBa3d+w3V8r3SKd0mPJxthVeU9Q+adno9Rco3kwfXAEZ6JwO"
    "G/QG6nKhg+cL2nkMgsippFRbUK+uHYKd6G/edDoUiPcmz9TrB3jSjZnef59WqLag0yQd262V"
    "pLfedC5L6RMImzXEPK1EjTS+9XrjcQX9Qpkv6NQoKnqzc8lZZNOu6LBUo4dBUJnMRV1hOkXk"
    "rnRIqPWMW9iMDmNzoxLfo3Kc6tjvrD0eh1Qhm5BI27XX9qt06YnOSzW673mV+1hMojm/P4+u"
    "/A7dJYxtw2ElvRFDbj7e44i0d09F9TL5vba/f6Rrp0yhq0rwiyHG+xVc4swzIpugijnQq0TH"
    "dEHPKLraaMFcPcEAkn6X9Dj+CAs/NM/PMedVzMhyg3Vg/6A6xhpsoIuRh+oM4rfSD/P0Q3qP"
    "dQbolEzzB+gHcnUGB3HaR+AaifjcRAp3j3iCS3svqV5J7Z37jL63R9IFXZRYogRyi0XUd1JP"
    "OxlsRCc8weuQTmwd/gGH9gUd7/SyjcCF+vaQvDeR7/t9nT4mZZNXzC8asKsBnrBB1zYo1H2V"
    "8RodEvnPrfRaDei/ERwb8GxZfmMr6wkIr58WBA3qCU5Pi7qJXf2V4Eu8X2rLclsrWj+DeHUa"
    "5QPTnwr0GhjQCQ4tQ+bzJImC/HCv92LC97xz1243qMKjvXpVq0n9NchQpRx/6SvlRM9tq+T6"
    "SIUPcfdFwZ8mk9oLVMxksJ+OKEnZfAywOB6DFbcl8j2wwPOlydbDq/DgYG8P/6Funa3wAPeK"
    "G0KF/p3w6POL16McHfQfHR1Uq9W9XwIKRM2GpB7gG1sSxdnjhIsnJjJNTWDfvxdo2lG8Y8Bo"
    "E0IOmbZTNuYmwMtEFuphbjLgl8sbOMrwNPXMG1mbM99JEBwf6zPf48Pi47zAf8QuJUK6GCm9"
    "sG3YAN2kp41AwME5OPEBfTGfa/Mq9PmPcBAmQ21ebZg2Ugz0VMHT9PNn3odAgyn57iPYjBta"
    "bKz922w4Ne3SmOjaOPuZR0BlPMWLY5BGGl1bpV7a6TxwQXmQeN6F4FacqoZ9G8JKl0Mu0++0"
    "75AVFyveRtdHRdHby/5eVjvIvcDkEnHMQseNBTUT5fdS1TtMbcvu0nb6TW6SM+7pJQlIh4K+"
    "Vb1Fe6SPclvoAdiztKcp7LxTp0P77+jp/F4qVySZ10b91pjxC3TEczeF/xHc01Jv8wPs8c5d"
    "mtLOA0BGL336UZKrqs8xxIzDU7MSOveY2AfmLd8UPSdmeA3jqcvMbAV3C9XOPS+bxKqsQ9bo"
    "jk/7yjyjd8g63UW57IEtX87UIa9WpdHCRAftor+nAYhbl//0OZ+cTgQdntW4Ph920p6pR+XQ"
    "zrk9oXT0jApMbKRcnpHJ6+ioXcY91haH53s701Pq0mgOtTwCKgSfs3ZQj/kJ5g53i0ihaDgc"
    "/n9/C5Gmw+Hxbn/H8S+cD8xcYY4GnAAAAABJRU5ErkJggg==")

#----------------------------------------------------------------------
whidbey_dock_pane_left = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAAF0AAABdCAMAAADwr5rxAAAAAXNSR0IArs4c6QAAAARnQU1B"
    "AACxjwv8YQUAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAA"
    "AwBQTFRFAAAAECBXFC9vECiQBS2oIDKMIDigC0CVJUqQIkewJFKlJlayMEiwMlSiK2G0JFTR"
    "LmnSKGHmKHDoInDwMGjgNnDgNXLwSFeKQFizR2OkUGagaHWVcHiYZ3egZ3e1cHilUHjRQXLw"
    "cYCncYa0dpC4R4DwU4PwZobHYIfTcYXGcIjVcpDBc5fWZpHxcZjgcJj3d6Dld6Pwi5Ozl6e3"
    "q62xgIjQgpXEgJbUkJjAkJjQgKDXkqHCk6TWhafggqfwh7Dgh7Dwk6Xgk7Tkl7fwoKjAoKjW"
    "qLDIp7fXsLDIsbbWoLfnoLjwsLjjl8D4pMLwscHnsMfxtdD0wMHg6tTN4Njk5eTo4Of35/D4"
    "8Ofh9/f3AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAA+wCLtAAAAQB0Uk5T////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////AFP3ByUAAAAYdEVYdFNvZnR3YXJlAFBhaW50Lk5FVCB2My4zNqnn"
    "4iUAAAeDSURBVGhDtZr/f9JGGMdprZPJnHSKm9OKI4DG0K5kWAptGIw5FGqpdQL5//+Q7Ply"
    "d7kkR3L4ms8PWmjyzifP3T33PM+1FO1gQ6/u+DtcH5V2uPh86DmOvwt+B7p7etLpuE7jmb0g"
    "e/qr09MTwDvOM3u8Nd3tdrunYIB3rPG2dIQzfRf1lnSCCzrgbX1vR2e4pNurt6IjfDTiJ3S7"
    "JycezEwr39vQEb5OmuXMsaCT8vUn3dYdO/XFdPJ5hm7n+0K6OyJLaQ+CjtcsnjlFdAEfpfwO"
    "9E6zWbhqC+gSPlrzKwgLR6Mg8IrV59MVXNIBi0b0fr9QfS49hgt6GDJevMmwKObk0fuaL4gH"
    "cMZLOuBzfZ9Dv1xMp2P5AMETnlH0odN0Gtvj/Xb65QLpEr+NPmw2G9vxOdrn8+treAAYOmUM"
    "Rh/AxvAJXyrAidmpf432KEI64aXLye9kGt3J2Qhz5wyqF/RRQjt8ENqDPHhBTlBM7+Ru4QVr"
    "9epK+p49vgAT/gL5QeDm5wcm+n58y2ek89BOp4NLsmsynK2B24svvTQ8yEC/s6/wvc+fpe9n"
    "s420W55N47G7CRV+vjDgs/Q7D+/fE/heCECeOQrNPyyXQHfxp96GNM/ni0U/oz5DP3iIdML3"
    "QqRv5vPb9yk48fv8Jamn4R9lRiFNPzg8rCJ+j+BEX62ybMTLb3sRuQqXRRqfogP88BDo9/b2"
    "LnDVJLhXV1czsPSzwh4NPS2BFD5JP3j0E1j1YeUeqE9SbmZTmikwdQaT5K942nJESuIT9INH"
    "TK9WAL+n46+ubm54HqJNJpcaX1tyabxOBzjR0fWofl8ilkudTXHs7Vz+Ug8XafUaHeFEl+ol"
    "frlcgmy5pjhKjueMX+mhjnzT1ZwT0w8eVcHwCfg/eqdc/hsBN2BMVNGeMH8pOj1Q7jNdDa/o"
    "oDxDr/+LMw/gpDtDJ/wt/k7bIjHdVOolHd2SpFcrv9K7A50jTZoe0FrdGOgKL+jkcyMdRhTi"
    "opEe0MzRvcLvEKtnOsJXutXQ7yRtRrNwHG9LIaVltO9xLCDPhPw1m8ITnZSv4M1XT9BqtRXS"
    "f8ZbYaEwPZEDfxJ0ws/QaaHY3jHfXCv1SP+OmCl65elTvPWd2PuM9KGznd59BWSgf0/wtPYK"
    "wYHO+/YW+i27JqWdyyCYOaXo5csamK79SW1V/fE+rVRc/DRXUnTMmjDduMCLBmb66XlUOm+3"
    "k3T0vaLPbOiX8HIhjizmgOh3Kt9OTobDknt8nKCvVjiq1Qprp2wvRzs5XtEBr9E7npem07Tc"
    "lQ4SwimnsDEdyuZ66WLUPW63flN+B+3o90qZtctlbvL7sO/58gXJMwnt0LBwgD46Pm614lHd"
    "ge6l6MrvkF1C2eb7pWhwDeqBv/qorSapfTIRIcqkHRxL2yAODmqnzJ5GleANH+f7ACLDcbtt"
    "pG/y6XWi44JL0FWjBddqf4r4BL1WuV8+Eo5XmjAYyHiDUcY7q+Mltwa6KHkozvTRNxl62Uhn"
    "B4RMP8NL5teQDyTiDBbi1EfgGAnqf1+vtSBZk47fvA107R9l0RcMPc9rULBgOsVIESk92WIR"
    "8R0KMJ45HCNrSC8/x3sDpotyOPzIrgmQ7hAd9lxtY8HwEJdqcm96MwXntFtM5m21Un5PvkE2"
    "1DD0FPyfDdgsPUPXGhRqX33TpXmp6LhrM13ydDrNONrTl7hxyX01qVz6HX3v/onqdfqDB/8Q"
    "XvBjegdmeqPxB8GXuLdo9ERrRctnoFWi06uVB/uYEyj1ko4LEfxC8M2mr2/mfS9Z3Ou5mBvg"
    "qmo9Qbc/flyt3uX7N5vz875m2LdqsFvQXKV8NAJ6oq2SyCNJfatFdA2OCh1STNZsOs95QAWe"
    "B2YIlm5LJHNgUk/0JBwwvn8Ghux6nSJjGg9wJ90QSuXvLvqG4b0kAj6dnTUaDT+Fxge7rD3b"
    "kkjXHp0O8GHW38Xag/lfvmSeo77FlQWlTQfWkKmdkqmbmE5RQqiHusmAXy4H8C3DowiGxdQK"
    "ytZ8r1+320dcvXHNd3O9eKeydfGcGywJIFcScMQ3DQ1QQ736uv2DLA1B/Rzpi/lcq5cgn4dq"
    "AZZoX6tX66ZGioEe/RLXnR8+yGoG65nJ5B2YrJ+whLyILzV1aUz0+I7oA1RLXCuxcRUvvoNl"
    "pNG1u9SP+XQuuCAESDp3ITiZp+CS34bIpcsil+mwxSqLg0suPo+ul4q08bCJ9J2kQ0bnmVwi"
    "vsuhY2NBJkupXqrqrGLCmNNd2k4fkBtk5Db29FA7Rsyt6nO0w1Ye2xY6xsyv0g67FZ90cP+d"
    "8oxEL5XTuSOxro36c+eMm6IjnhME/IfgTh68oKf3IqmdC4CYXnj6UbBWER97Rg0Day/qYOs5"
    "gXngST08wXB2UKi8mB4xvps+96C0oPDMqcAz8ELs+/SJ0P90ZsP4DN1GuYVnhPpvdlYm1FMB"
    "LTJUu5MyO+3S94IOZzW258PFo0ozVc571A7pnN0Jpa12oR5Phq3OyOTasdQu8RhbLM73dqZH"
    "L1A3VQU5R0CpBW+tHdTj+gSzh+/0txC+73+7v4WIIt8/2u3vOP4D32mBB1S/lsMAAAAASUVO"
    "RK5CYII=")

#----------------------------------------------------------------------
whidbey_dock_pane_right = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAAF0AAABdCAMAAADwr5rxAAAAAXNSR0IArs4c6QAAAARnQU1B"
    "AACxjwv8YQUAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAA"
    "AwBQTFRFAAAAECBXFC9vECiQBS2oIDKMIDigC0CVJUqQIkewJFKlJlayMEiwMlSiK2G0JFTR"
    "LmnSKGHmKHDoInDwMGjgNnDgNXLwSFeKQFizR2OkUGagaHWVcHiYZ3egZ3e1cHilUHjRQXLw"
    "cYCncYa0dpC4R4DwU4PwZobHYIfTcYXGcIjVcpDBc5fWZpHxcZjgcJj3d6Dld6Pwi5Ozl6e3"
    "q62xgIjQgpXEgJbUkJjAkJjQgJjggKDXkqHCk6TWhafggqfwh7Dgh7Dwk6Xgk7Tkl7fwoKjA"
    "oKjWqLDIp7fXsLDIsbbWoLfnoLjwsLjjl8D4pMLwscHnsMfxtdD0wMHg6tTN4Njk5eTo4Of3"
    "5/D48Ofh9/f3AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAaHenigAAAQB0Uk5T////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////AFP3ByUAAAAYdEVYdFNvZnR3YXJlAFBhaW50Lk5FVCB2My4zNqnn"
    "4iUAAAe+SURBVGhDtZr/W9pWFMYtW1en67RzunWdpUvQlgWdMCoyJFkotbaRCrMryP//f2Tn"
    "yz25N19ILn2enV8Qkn7y5s2555570414jRh4dbezxvnxxhonXww81+2sg1+D3jw7bbWarvPM"
    "XpA9/eXZ2SngXfeZPd6a3my322cQgHet8bZ0hDN9HfWWdIIrOuBtvbejM1zo9uqt6AgPAr5C"
    "u3166kFmWnlvQ0f4Ih2WmWNBJ+WLf8xYtOzUV9PJ8xzdzvtKejOgyGj3/ZbXqM6cKrqCBxnf"
    "gd5qNCpHbQVd4MGCb0HFMgh836tWX05P4EIHLAbRe71K9aV0DVf05ZLx6k4GVTWnjN4zvCAe"
    "wBkvdMCXel9CH96Mx6FcQPGUMwl94DZcZ3W9X00f3iBd8Kvog0bDWY0v0R5Ft7dwAQg0JYSg"
    "LxAhfMOb8jExW/Uv0R7HSCe8WE6+Uxh0t2QiLM0ZVK/oQUo7fFHa/TJ4RU9QTW+VTuEVY3Uy"
    "Ee/Z8RsI5RfI9/1meX9QRB/pf/IJ6fxox+P+kOKWArPVb3b1qT8XXKiAPhol+O6nT+L99fW9"
    "xB1nUxg275cJ/rvjV3l8nj6d3Y57fGJ3CUDOnATNf0ynQG/iX917OjU6Pn6Vx+foU6QzvrtE"
    "+n0U3b3PwInf4x9JfbR/cHzSzj3iLB3Y5OlrghN9Ps+zES+/duO7h/tMz+IzdFSOKR6Gl5c4"
    "alLcyWRyDZG91rL7cBfjGPiZHErTp5gNOG5grPyVpsyux3RXkDr9UfoQw3ePgJ5J0RR9inTQ"
    "zSORHpqKyWSGlhF9PB6NhsYxgP9IdMSn1Zv0KdLRFdbuu4IAvww21bHXkRxEONEPjtCblHqD"
    "DvApe67ogqerqnIpVTKMGD+vPd5mY3b3ITLqNR3yOvEca2uv1xv+i4AZBOlVjsmE8gYPvnv8"
    "eFvhmX7S/ls/2oSO4097jnTPIzq4MqNakKMT/v2mST86Anz7dxm1QiflmoDSvUu6d6BzpcnS"
    "fXrsSGfxqB28B/xY8IrOyovo8EShLhbSfcqcXzc3t5lMgeqDQJUSpmMdX2K7hSMIP/2B53VI"
    "+jVlYainJTqO0yzcH51RQ/pcx2LxR6AqFdGpDi6hyZWOS9OhAjM91QPTiege0jc3t7b350r7"
    "PAw/zsEcVo90moFC7EM1HZ4pab9Sc18hfUAj4jBHh7xk9UDnCp6j1+m2rzjPgxX0O7EmpR1H"
    "VRD0kU61BfsrUzskO9GTLM3QsWvCdoPSCo1P0Skvg9t+vEHjEEe+0PEfLoR+LWOgmn5wMIeU"
    "Ad9D+OTMudxAX2jkKzo1igmduj0coyvoZDxrBzJgFf03rGhAH0ZqlDCdMnJd+hbSKSWFjvl/"
    "ctLc8N+gclzVse+s3R+0SNYQnyi1v+mMJN8HPc6rGtH3Te1Cf+OrlWjKdzu6ytra1ve75Ln2"
    "nSra8cVG3FeL3HS++z3SPhqVaG95Hk2DRFeFQPmO9BcvMN9fwgpdO0M+LGQc3pfT60R/ipVA"
    "j9VwvkcV51seq89x70J8F7rvXynj+Rflu9QbrAPeOY2Jpzk6wb9RlYDwtnSeO5ZMP0f6T1CA"
    "M9r39va+ljrD6lMrUpg9uL7ev4anrrV/lEUfFlHPoTOwvJs1cj4XuHTYpJ52MjiITnif6Wo5"
    "vPzI1vhId4n+i8yrwNzDWQQ/STn7jkHen52Z9MGApA3lavKJV4a1sOuw9CK6guvVAeMNOuTb"
    "O6Izje9B/sb9K+ctHq4n86rWLnBj7UF4TW8BvU49wVDxNR2POc6fePAtzHvKmoSewM2VDeIT"
    "OqzlXJfpol7ocAi2ZxgOQ6n26BHyf6AwPDd9N7znnbtGo87zB8TFBVTkJHDfymFbEvzO7pMn"
    "iq6V66dqPlqEw/5FAgdGzyXFFI2G+ys/UI4HD7T6JFvSOZPKHN5zNADwZ6dzDoHsep27BY1H"
    "c3bIG0lFlYmZ/p0eLXruPOumEfDt/NxxnE4GjRdG9Vs7TyBMW4x8l97sOTrAOxe0aoL4/Dl3"
    "neRXHFmwtHlQAzpYn4HnV8OAh4Sg3UalHtZNBfjptA+/MjyOIXO2dnay8IK19nPPOzzkW+E1"
    "3+z25irp1tV1ZtilQK+k4IAH+ldiQPJZsF6tewpO6iOk30SRsV6Cfh5WCzCf94z1aq2Whxfu"
    "EyTwOP7wQVYzuJ4Zja4gZP0Es1bzUsut5ZRn8j1//AMvAZPgVbz6DWZ7g14At9rjgBIgeN6F"
    "4Facqkb5NoTF/gxCaKVn3INeKZTiy+jG7gxOHjKlqvadpMPY84osKR6r5plRRGsONTVJ9eSJ"
    "Sr7h0C7ZXVqtvU9GCKZwTw+1Y8Vcqb7EmV6C1mrT+5FBgDXzi7THMey8U6dD++94E+m9VK5I"
    "Mq4L9ZfmTDNDR7z2neCuMfTyFyjfdeMuLdFOm9fJU7V481Sxp5f0Oen9d/pm8dasgi59Tvad"
    "Da6ZLN7bVNEVnrpMHQuAyyxQMpgs3q/qDtmgWymvrJHSiGS1Wym3ouc75MXCwvNst7TSQcmc"
    "dlt1qHZvyuy0y+oE8h7p8K7G9v1wZc7oNgpHFdE9oJdlij5mSZe8x9pS+ZZpfbrCY22xeL8n"
    "fFvt4D3qplVBySugjGH2dMRDrgDdznPrjFS4Tqfz//1fiDjudA7X+38c/wE5II6oZulXWgAA"
    "AABJRU5ErkJggg==")

#----------------------------------------------------------------------
whidbey_dock_pane_top = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAAF0AAABdCAMAAADwr5rxAAAAAXNSR0IArs4c6QAAAARnQU1B"
    "AACxjwv8YQUAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAA"
    "AwBQTFRFAAAAECBXFC9vECiQBS2oIDKMIDigC0CVJUqQIkewJFKlJlayMEiwMlSiK2G0JFTR"
    "LmnSKGHmKHDoInDwMGjgNnDgNXLwSFeKQFizR2OkUGagaHWVcHiYZ3egZ3e1cHilUHjRQXLw"
    "cYCncYa0dpC4R4DwU4PwZobHYIfTcYXGcIjVcpDBc5fWZpHxcZjgcJj3d6Dld6Pwi5Ozl6e3"
    "q62xgIjQgpXEgJbUkJjAkJjQgJjggKDXkqHCk6TWhafggqfwh7Dgh7Dwk6Xgk7Tkl7fwoKjA"
    "oKjWqLDIp7fXsLDIsbbWoLfnoLjwsLjjl8D4pMLwscHnsMfxtdD0wMHg6tTN4Njk5eTo4Of3"
    "5/D48Ofh9/f3AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAaHenigAAAQB0Uk5T////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////AFP3ByUAAAAYdEVYdFNvZnR3YXJlAFBhaW50Lk5FVCB2My4zNqnn"
    "4iUAAAe1SURBVGhDpZkNexJHEMcxrTVNao3G0PoSaXmJ4l1soBhCCUdBmkaPCDFWCN//e1z/"
    "M7O7t/fC3aHzPMqFu/3t/2ZnZmeTUrCBnZ83m2cbPB+UNni4NxweHx/9tsGIDei92bBF9B+L"
    "44vTu6T8AFb+oTC+ML07gfIjppe/L4ovSofy1nGjIfT9oviC9O6kBZ83flf0ovhi9NccLY2y"
    "sv39gvhC9NeT4R/HR5q+Xwa9GL4IvQmvLBcRK4gvQG/+DZcvP8JG2hYF1efTSflxY2HIdLHY"
    "gxVwTi696VGCptLz8Xl0Ud4oR90u2vOXNodOyjlYFjoa+VPT89Rn010ol+xXdP1Bq/oI9jA7"
    "azPprguX23T4R7QbejY+i/6q1YJXpLYwlZ0foz/4LqOkZdBfvaJgaZQzPbP3IAu/nv7rEYxi"
    "g+xgIfVrgX+44FV99HAP7J2dra216jO0/3RULkfpPAP9p+lg37u3Hp65r/oHByE9GvDy/e4u"
    "2Bnw7F3bD+kQbGbS1w/y4Dk9wd29vcePtc5dtp9/1rOQ8jt3MjfBnFwlPLtgd2dnG7YD291V"
    "88Et2fBU7eNQz2fgiU3kLWVPnhBflHfCRwcpb5GifTw2+M5n4Mkf21vbh7fanvzCPoLy25XB"
    "+9MUfJI+v55NuqKjswLw7v3729vPDVounj6ld6Grzi0/6vvTqRplvUOCPie64Dsrot9u3X//"
    "PgbHj5VthgPP8BkGDZtx58TpYNODo7cMZ/ri3yQb3/yjv+0EN77QE/gYnZTjuclodH4OONON"
    "XV1dXcLic606V7PZdDoaDRP4KH0O4TPaOPHgX1HK9eWE32oy6fXG0VtXRJ/QmDg+Qp8THbqZ"
    "PmxGZF+Ty5g+mYzHA+see4X8ksTb9DnRySui3atpBPxlsQk1euvrm+JzQ4/43qIDPhefK7rG"
    "86x4d8tGI1/wC7CnfEtpH7asyAnpeMz4fOh5XrfbHfxHgGsY61Ue05h3hs7TGrqFN3R6wdDn"
    "RHccpsMr1ywuQWf8Dd3TZPpstUK8prPykEDSnXN+d9Dl1eN0T5Y9hW7wii7K0+hY0ekauseR"
    "Y3tF3iFUL3Ra9tUSRhlEn17fcdos7ZIDYkQ3lNH9JSB4P36CPSPDlBk80zmoVp8+faJBZCEd"
    "iSJ03LVM0Rl/Sa+8kmQaLpmi8UTngB3J95qONWXtFyqYU+l9zoh0euslyKBLOiToFX7tC4nz"
    "4Rr6jbgmph3SW60TxH0p4Npi3klpR7Az3URpjL5iv7suh1UvnX5yFpQ4D8lp2jM0cKnplzoH"
    "sugDvNyKVlZTWiewN2/6/RL5hTNf0VcR+gB+4ThfQ2fHGzqGMkXoruOUBr7KEqFzRIbai9Eh"
    "YTXheLXorlurlLx3pByrENHu9V0ji5ciTXu/K3FFEtgzEe1us1YrvfOYbejivWJ0FbWGbvzu"
    "wmq1drsU9Jgd0iWbvC5rH49ViUrTDsfyNqjpJptaDK+2Kd5fYhFS6JLm2fQK0yldyDOG/obg"
    "z55xNgUvaIm131UlQAm+UPFgRlEl0MWGqoxzyjlxk0KvgS65KviidJG4Evop0f0Z+oFInXFE"
    "uaIz3qpxqJEw2ZnfYtXVakH6R1pzolMRdar8hNBViWWKU6syXHeprB4mYynLQWe8J/ShTL76"
    "KK7xiF5jOu304cZC5UErN3Tx/cmJTe/3WdpAz6Y/aWbPA1ukJ+jkF9XymX1V8BYd8cYt3kBo"
    "8g76miOOe705bVzhMFt5qF1Fjv2Y41S4Jxgofkh3MXO1+ifD57S3WMMs5TadnWMe43wQulav"
    "6ZSI8AvDb2+79mbedep1iRYxuxdTvicPuW69XpH9A3Z2hopsDMsJn5sWuGmUD4egq2hJ0vXS"
    "EhyPGTgprLFitnq99lwWVKwpi9GHRZVHtSvfE5yCygLgst0+hRG7UpFuIYYHvBZVHqeLevJ5"
    "9VknisBPp6fVarUdQ9PErB5wlaHpfueiIMWTloZPTbAvXxLzmG8ps3C0cZFDgJs4T1tV/g54"
    "nchKve/zzh+z+byHbwQeBFiWuM/jMSMzvnCcw0O5ZPX+9Wx6Ybp1Ncc1dSmo0QpO+HpCecLv"
    "xKw4Cg484ESf+r51XkI/j9MCUrRrnVcr1Wro77WewQ0DD4IPH/Rphs4z4/EFTJ+f6Ah5HhJT"
    "4Hl/mfggR0Bj1FmZ8xPSyKInlad6xnpMjkQoARqPZnuqW3GuGokDcGSSzN9x6EOu0LHFGguL"
    "SyY+i24f5lRvr/t7Xe2Qe06aS9R3GXT6xYI5E+neW21UFv2kth6/nt6LnOQUXW2rZi5IR8Vc"
    "i8/Qjr/ShLaGTjXzq7QHAX5/zZ0O7eZMl0aUtnD6TyqSzutU/Zkx04zRCS8NgqKjcFmpVyxX"
    "w6ekSzPa5QAQ0pMlNzZBzu/0TJ+TEjNwS0rhKp5NVDGlz2lFOjXq1aKtxZqoydGu8dxlhrYE"
    "3LRzX5dNalTYIVv0QsrzqphsJ7pDtulFlBeiJzvk5TI3WuTFc/1u1PPxR3WokXbum/yu8Rz3"
    "RO92sYVa7dw308X3mu6kbdCbVwJrhIp7qi1prcXXxrseJ3gqXPF27ts9Q4FJuvlUkLb7p09R"
    "KGZkKHdpsOLwYhGphLXbbTqeZ3gifmsD7UHQbh/WNoEH/wMcYo64Ex2PFwAAAABJRU5ErkJg"
    "gg==")

#----------------------------------------------------------------------
whidbey_left = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAAB4AAAArCAMAAABYWciOAAAAAXNSR0IArs4c6QAAAARnQU1B"
    "AACxjwv8YQUAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAA"
    "AwBQTFRFAAAAaHWVZ3egZ3e1cHilcYCncYa0dpC4ZobHcYXGcpDBc5fWd6Dld6Pwi5OzgIjQ"
    "gJbUkJjQgJjggKDXkqHCk6TWhafggqfwh7Dwk6Xgk7Tkl7fwoKjWqLDIoLfnpMLwscHnsMfx"
    "tdD04Njk5/D49/f3AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAQ3JLMwAAAQB0Uk5T////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////AFP3ByUAAAAYdEVYdFNvZnR3YXJlAFBhaW50Lk5FVCB2My4zNqnn"
    "4iUAAAF4SURBVDhPfdTbdoIwEAVQL6htAi0tElBaoVb+/xPTM5M7wc6LLvc6GTIJbnRel/DT"
    "ZkUvwXOefsahdqGMJ2LvSwaO4P7d5BdMWejQ9+dzzhOiY4/quu4z44kYSebudbH4REwLm7Q6"
    "Jr2hk+lrGR4e7Rb17ZRSdV23v55vxL4vsRCBOesXRrquBbZm0yb7jIHD/EDNKPpUjRBvbmOU"
    "Heb7/f6g/aISJhz6R8J4MJvmbM6FGSrPmRaM09i0YZ4zDdHxTN8909I8RMtzyu3NztgwbyxK"
    "qytlq6pK0qqROC/0vipGzx0v7ll/MAY2Y1G1SWv9UpXlCvNlpiPZlyjX2w4VJ/rlZk7+D3Oe"
    "DsoXwqoNV5HzKHtidJlUC3eXifuXZcxNE91U4xFLIb6jm8oeWIKLcFPN/jxLKY/HhM3+TUl5"
    "OhU48eQN9Y6VTwe6D+kLbJ0W3m5X3m926ntgXb7+eg/z2ZzJhcuusN4Lsds9/WfSuhBes94U"
    "C6r/AM3yZVcU56/qAAAAAElFTkSuQmCC")

#----------------------------------------------------------------------
whidbey_left_single = whidbey_left

#----------------------------------------------------------------------
whidbey_left_focus = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAAB4AAAArCAMAAABYWciOAAAAAXNSR0IArs4c6QAAAARnQU1B"
    "AACxjwv8YQUAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAA"
    "AwBQTFRFAAAAECBXFC9vECiQBS2oIDKMIDigC0CVJUqQIkewJFKlJlayMEiwMlSiK2G0JFTR"
    "LmnSKGHmKHDoInDwMGjgNnDgNXLwSFeKQFizR2OkUGagcHiYZ3egcHilUHjRQXLwR4DwU4Pw"
    "YIfTcYXGcIjVc5fWZpHxcJj3d6PwgJbUkJjAkJjQkqHChafggqfwh7Dgh7Dwl7fwoKjAqLDI"
    "sLDIl8D4pMLw4Of35/D4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAQS37pgAAAQB0Uk5T////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////AFP3ByUAAAAYdEVYdFNvZnR3YXJlAFBhaW50Lk5FVCB2My4zNqnn"
    "4iUAAAGNSURBVDhPfdRrW8IgFAdwLyuXZLIUy67D6dK0pd3w+38xOuewAYOMN3ue/fbnwHZG"
    "R8ej5251Yu33nMfcHw8H1iNOxsiNh5xkGUfvmqIBg2YZ8KBrvM3J5BoGH7NBnW9xMjHMGTjl"
    "fQYlxvKYh/V5jErc5MEdJxMOAx/BKxZI0w/LkI340aZx5jZzdmdrU92TjKr8IbB2szHKqv1+"
    "r2Y4hFDINzWf082A2Xxu+II0TDNU4KcnAcNPz4TiV0P6pp1XKduM9R0XZdlipXBpnNXpgGl3"
    "Hu+qdSnzZ1sb0libpab2rqrKMs/d0tqstz+QhwfUt/dabFrrbYXzy1OsNwf0Fgs2TB+ad77B"
    "6SNOba9B/uV49D6ZqIvX3bJp1m++mEBO710rLg8wv8wNmVZj6ZdrxeWatmcZW9FjXbxj3ufR"
    "6NPr8wLyHnM28vtc6+INX08+w9LTKednwS9I+TwnJg3+UMoTGw3/7wKndxqyXq3gAdg9ZaO0"
    "1oab8yo+mRYLKe1p9se5tpCX/7G+dUfhL8vucupsrDz0AAAAAElFTkSuQmCC")

#----------------------------------------------------------------------
whidbey_left_focus_single = whidbey_left_focus

#----------------------------------------------------------------------
whidbey_right = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAAB4AAAArCAMAAABYWciOAAAAAXNSR0IArs4c6QAAAARnQU1B"
    "AACxjwv8YQUAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAA"
    "AwBQTFRFAAAAaHWVcHilcYCncYa0dpC4ZobHcYXGcpDBc5fWcZjgd6Dld6Pwi5OzgJbUkJjA"
    "kJjQgKDXk6TWhafggqfwh7Dwl7fwp7fXoLfnoLjwsLjjpMLwscHntdD0wMHg4Of35/D49/f3"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAWZqHkAAAAQB0Uk5T////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////AFP3ByUAAAAYdEVYdFNvZnR3YXJlAFBhaW50Lk5FVCB2My4zNqnn"
    "4iUAAAFySURBVDhPddPbeoIwDABglDqoFDcVGBVw8P4PyXJoQ0sxN+L3m0NDzVaJx/YoT5k8"
    "9fbAhfve2luS77kfhq5rir077pkTZ34Ng7Vt2yRO/ELuUPeOTIWxdOrA3Fc46p/9AVobsgnm"
    "Z0b1xRsTeLa+EV1f+jCBQ+8DlnzgsDBX2fLxYFR8WeYtxJF/u65tF95KM0/TNEv+ZzZfkElL"
    "TbKhuDEVnJ/4Z1+cufpmfsBwC47newNV1fV6v8cMTqMx67Jkhs0s3YIRsNbqHDCePczWhVIx"
    "S28NoVRdRyxrMaR5zZPjdcDJha+opxOf+33ACthtrR/glkY7LzmXs5npjbn3VqqcFHmE2i0E"
    "934+fd9PjKXdvylbR7yn/q7FuVB8HOF9uMJUOsjF3retb9PcysuFZ+aA0QrJJXYzC6/Fk+IO"
    "Eee628IOquJcx5wP6nYV9cYvGpYBKucNRqNHpfW+r9+580uS63vjD855vvXcF4fvB7r+A9+i"
    "Xf4K/oDaAAAAAElFTkSuQmCC")

#----------------------------------------------------------------------
whidbey_right_single = whidbey_right

#----------------------------------------------------------------------
whidbey_right_focus = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAAB4AAAArCAMAAABYWciOAAAAAXNSR0IArs4c6QAAAARnQU1B"
    "AACxjwv8YQUAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAA"
    "AwBQTFRFAAAAECBXFC9vECiQBS2oIDKMIDigC0CVJUqQIkewJFKlJlayMEiwMlSiK2G0JFTR"
    "LmnSKGHmKHDoInDwMGjgNnDgNXLwSFeKQFizR2OkUGagcHiYZ3egcHilUHjRQXLwR4DwU4Pw"
    "YIfTcYXGcIjVc5fWZpHxcJj3d6PwgJbUkJjAkJjQkqHChafggqfwh7Dgh7Dwl7fwoKjAqLDI"
    "sLDIl8D4pMLw4Of35/D4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAQS37pgAAAQB0Uk5T////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////AFP3ByUAAAAYdEVYdFNvZnR3YXJlAFBhaW50Lk5FVCB2My4zNqnn"
    "4iUAAAGXSURBVDhPdZTZVoNADEDpaC2CFSqC1hVaxWoVqdv0/39szDIraF7gcHuTTCankbJx"
    "6V7tW2TfTprVmDvcNKsxt7ismnbzOPQ1npaMh5zxNMdo4Afr0CfMNK8Bv4UcMdBzwshDHzBS"
    "wlWN6QM/UmKecu68hBj40ed8nmrOuN28u/qR+op9XNfANw+mf8asow31ge8Mh9au4zhlRIF+"
    "1z2zjwcTiKWL/f6p2zFHHMdJWkpty77/lpCffcQ3IwzHY5+GitkDG8fTddv/MB2v+9n6dlVJ"
    "aBxq9/Dk/l+95IDgu8b3eD0GJ1ibTmYwzqFt12wTLn07xKc51XW16XqaF20D1jPVtRHf3XHn"
    "Sxyqm1ovC5r+MZ97OcJEj/TULuA+B3ZRFIdm5njd/o1JaSgmvzK7Bh8LXAt8kku1/8KaAr61"
    "u+ZsQ1X0Aauks1tsKdhCzGb4gzMKr66uTTzLFwuNnctjmUycb3t2m6om7JPtu3qZyE+yBURI"
    "+UogvwAM5QfUYOw/ybIhtVghPuBUXrg/LiHG1NmwcSNXqV+4tHLqnJPo+QAAAABJRU5ErkJg"
    "gg==")

#----------------------------------------------------------------------
whidbey_right_focus_single = whidbey_right_focus

#----------------------------------------------------------------------
whidbey_up = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAACsAAAAeCAMAAACCNBfsAAAAAXNSR0IArs4c6QAAAARnQU1B"
    "AACxjwv8YQUAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAA"
    "AwBQTFRFAAAAaHWVcHilcYCncYa0dpC4ZobHcYXGcpDBc5fWcZjgd6Dld6Pwi5OzgJbUkJjA"
    "kJjQgKDXk6TWhafggqfwh7Dwl7fwp7fXoLfnoLjwsLjjpMLwscHntdD0wMHg4Of35/D49/f3"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAWZqHkAAAAQB0Uk5T////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////AFP3ByUAAAAYdEVYdFNvZnR3YXJlAFBhaW50Lk5FVCB2My4zNqnn"
    "4iUAAAFmSURBVDhPhdTtdoMgDAZgW3GKWjsL2i/X2vu/SJaEBBXcWf6Jz3l5i9bMpdNXR3Xa"
    "Wc/StXNfKXXawaktm1rrUuWHJCWxX01TA1bqkODYlm3bNjCAVYwji9TbneStJcoWcNR5Yz0V"
    "mySvLVJrvW/buq7g7NadVxbpvJ3taSyWUuef9cx6kxwsdU3sprPY0tJEucboqginwZapjfqC"
    "1UUhT9BboXb28Twfa42pQjLZQMUCwiHbdZKMdqFsPx+PeZee3w2w3WpXugvUY7GAsXPmLvdx"
    "HITzXe4QbK8Klbvsckcr+C/bF0WeZ+52ez6Bw+D2AwxdwAxwhRsaPDp9hA4OLWGpSn1pVlZh"
    "X8Cg2dpNLlxwrgFKFpP/sRqZf26Ph3T2Te8w3AyijSlJ8fuA1v/Acfy+0Dxp8DyZig2dr9fw"
    "WXj5ExoGnxpy5TSi78c0gRUacvE0XjvfsGnqwuryH3q/d6hz07L6CxOEXf5LAPv7AAAAAElF"
    "TkSuQmCC")

#----------------------------------------------------------------------
whidbey_up_single = whidbey_up

#----------------------------------------------------------------------
whidbey_up_focus = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAACsAAAAeCAMAAACCNBfsAAAAAXNSR0IArs4c6QAAAARnQU1B"
    "AACxjwv8YQUAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAA"
    "AwBQTFRFAAAAECBXFC9vECiQBS2oIDKMIDigC0CVJUqQIkewJFKlJlayMEiwMlSiK2G0JFTR"
    "LmnSKGHmKHDoInDwMGjgNnDgNXLwSFeKQFizR2OkUGagcHiYZ3egcHilUHjRQXLwR4DwU4Pw"
    "YIfTcYXGcIjVc5fWZpHxcJj3d6PwgJbUkJjAkJjQkqHChafggqfwh7Dgh7Dwl7fwoKjAqLDI"
    "sLDIl8D4pMLw4Of35/D4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAQS37pgAAAQB0Uk5T////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////AFP3ByUAAAAYdEVYdFNvZnR3YXJlAFBhaW50Lk5FVCB2My4zNqnn"
    "4iUAAAGTSURBVDhPfdQNV4IwFAZgpEyCVBRZaR8OUcI0yrLw//8xuvfuy22e7jkKZz68uxtg"
    "0Pm135fl24XxwB/bNU1VFS/+D77d/TY12lsPe3aLqTkUu3Gxa7cHSC3IsmsHOxZS64pzYTMH"
    "23Z7qKFXvpTWwZZd0w5wJivLbHxu14fmtSqUzRhYC5/ZEuY/tVbZ2NjyA1o9/UB9qmrtZG0x"
    "teKtdnjSplCmDWXLd7xZF63G0opUzux2Ra5eoLCYShvQqv2io7IymewGUsV9lVYdcG1TqAnd"
    "QbSbDbR6bqETkastYbCruob5xTNAhpp27PgK7WqFG8DZvz2kY8DBQwGF68XKW/HUtPCBE1rb"
    "dJKCjOMwDLq7gjHbkscvZUEOBiGtLc+NtTdYjCcJyFDsQ2cshOnr1PlYUmH7aTqbqYyEajRS"
    "12Bqr6f2V2CaLInjCCqGShJ5NTRAVOQSRokulDWfozap2gLGmaMwetIv7/yeulGpxnb94TCK"
    "Hp23fLHAedSgeS/C4fHo/y89R5qqfhF9+xJGvszoH5Xccuo6pVT3AAAAAElFTkSuQmCC")

#----------------------------------------------------------------------
whidbey_up_focus_single = whidbey_up_focus

#----------------------------------------------------------------------

whidbey_denied = aero_denied

#----------------------------------------------------------------------

# ------------------------ #
# - AuiToolBar Constants - #
# ------------------------ #

ITEM_CONTROL = wx.ITEM_MAX
""" The item in the AuiToolBar is a control. """
ITEM_LABEL = ITEM_CONTROL + 1
""" The item in the AuiToolBar is a text label. """
ITEM_SPACER = ITEM_CONTROL + 2
""" The item in the AuiToolBar is a spacer. """
ITEM_SEPARATOR = wx.ITEM_SEPARATOR
""" The item in the AuiToolBar is a separator. """
ITEM_CHECK = wx.ITEM_CHECK
""" The item in the AuiToolBar is a toolbar check item. """
ITEM_NORMAL = wx.ITEM_NORMAL
""" The item in the AuiToolBar is a standard toolbar item. """
ITEM_RADIO = wx.ITEM_RADIO
""" The item in the AuiToolBar is a toolbar radio item. """
ID_RESTORE_FRAME = wx.ID_HIGHEST + 10000
""" Identifier for restoring a minimized pane. """

BUTTON_DROPDOWN_WIDTH = 10
""" Width of the drop-down button in AuiToolBar. """

DISABLED_TEXT_GREY_HUE = 153.0
""" Hue text colour for the disabled text in AuiToolBar. """
DISABLED_TEXT_COLOUR = wx.Colour(DISABLED_TEXT_GREY_HUE,
                                 DISABLED_TEXT_GREY_HUE,
                                 DISABLED_TEXT_GREY_HUE)
""" Text colour for the disabled text in AuiToolBar. """

AUI_TB_TEXT             = 1 << 0
""" Shows the text in the toolbar buttons; by default only icons are shown. """
AUI_TB_NO_TOOLTIPS      = 1 << 1
""" Don't show tooltips on `AuiToolBar` items. """
AUI_TB_NO_AUTORESIZE    = 1 << 2
""" Do not auto-resize the `AuiToolBar`. """
AUI_TB_GRIPPER          = 1 << 3
""" Shows a gripper on the `AuiToolBar`. """
AUI_TB_OVERFLOW         = 1 << 4
""" The `AuiToolBar` can contain overflow items. """
AUI_TB_VERTICAL         = 1 << 5
""" The `AuiToolBar` is vertical. """
AUI_TB_HORZ_LAYOUT      = 1 << 6
""" Shows the text and the icons alongside, not vertically stacked.
This style must be used with ``AUI_TB_TEXT``. """
AUI_TB_PLAIN_BACKGROUND = 1 << 7
""" Don't draw a gradient background on the toolbar. """
AUI_TB_CLOCKWISE        = 1 << 8
AUI_TB_COUNTERCLOCKWISE = 1 << 9

AUI_TB_HORZ_TEXT        = AUI_TB_HORZ_LAYOUT | AUI_TB_TEXT
""" Combination of ``AUI_TB_HORZ_LAYOUT`` and ``AUI_TB_TEXT``. """
AUI_TB_VERT_TEXT        = AUI_TB_VERTICAL | AUI_TB_CLOCKWISE | AUI_TB_TEXT

AUI_TB_DEFAULT_STYLE    = 0
""" `AuiToolBar` default style. """

# AuiToolBar settings
AUI_TBART_SEPARATOR_SIZE = 0
""" Separator size in AuiToolBar. """
AUI_TBART_GRIPPER_SIZE = 1
""" Gripper size in AuiToolBar. """
AUI_TBART_OVERFLOW_SIZE = 2
""" Overflow button size in AuiToolBar. """

# AuiToolBar text orientation
AUI_TBTOOL_TEXT_LEFT = 0     # unused/unimplemented
""" Text in AuiToolBar items is aligned left. """
AUI_TBTOOL_TEXT_RIGHT = 1
""" Text in AuiToolBar items is aligned right. """
AUI_TBTOOL_TEXT_TOP = 2      # unused/unimplemented
""" Text in AuiToolBar items is aligned top. """
AUI_TBTOOL_TEXT_BOTTOM = 3
""" Text in AuiToolBar items is aligned bottom. """

# AuiToolBar tool orientation
AUI_TBTOOL_HORIZONTAL = 0             # standard
AUI_TBTOOL_VERT_CLOCKWISE = 1         # rotation of 90 on the right
AUI_TBTOOL_VERT_COUNTERCLOCKWISE = 2  # rotation of 90 on the left


# --------------------- #
# - AuiMDI* Constants - #
# --------------------- #

wxWINDOWCLOSE = 4001
""" Identifier for the AuiMDI "close window" menu. """
wxWINDOWCLOSEALL = 4002
""" Identifier for the AuiMDI "close all windows" menu. """
wxWINDOWNEXT = 4003
""" Identifier for the AuiMDI "next window" menu. """
wxWINDOWPREV = 4004
""" Identifier for the AuiMDI "previous window" menu. """

# ----------------------------- #
# - AuiDockingGuide Constants - #
# ----------------------------- #

colourTargetBorder = wx.Colour(180, 180, 180)
colourTargetShade = wx.Colour(206, 206, 206)
colourTargetBackground = wx.Colour(224, 224, 224)
colourIconBorder = wx.Colour(82, 65, 156)
colourIconBackground = wx.Colour(255, 255, 255)
colourIconDockingPart1 = wx.Colour(215, 228, 243)
colourIconDockingPart2 = wx.Colour(180, 201, 225)
colourIconShadow = wx.Colour(198, 198, 198)
colourIconArrow = wx.Colour(77, 79, 170)
colourHintBackground = wx.Colour(0, 64, 255)
guideSizeX, guideSizeY = 29, 32
aeroguideSizeX, aeroguideSizeY = 31, 32
whidbeySizeX, whidbeySizeY = 43, 30

# ------------------------------- #
# - AuiSwitcherDialog Constants - #
# ------------------------------- #

SWITCHER_TEXT_MARGIN_X = 4
SWITCHER_TEXT_MARGIN_Y = 1

########NEW FILE########
__FILENAME__ = aui_switcherdialog
"""
Description
===========

The idea of `SwitcherDialog` is to make it easier to implement keyboard
navigation in AUI and other applications that have multiple panes and
tabs.

A key combination with a modifier (such as ``Ctrl`` + ``Tab``) shows the
dialog, and the user holds down the modifier whilst navigating with
``Tab`` and arrow keys before releasing the modifier to dismiss the dialog
and activate the selected pane.

The switcher dialog is a multi-column menu with no scrolling, implemented
by the :class:`MultiColumnListCtrl` class. You can have headings for your items
for logical grouping, and you can force a column break if you need to.

The modifier used for invoking and dismissing the dialog can be customised,
as can the colours, number of rows, and the key used for cycling through
the items. So you can use different keys on different platforms if
required (especially since ``Ctrl`` + ``Tab`` is reserved on some platforms).

Items are shown as names and optional 16x16 images.


Base Functionalities
====================

To use the dialog, you set up the items in a `SwitcherItems` object,
before passing this to the `SwitcherDialog` instance.

Call :meth:`SwitcherItems.AddItem` and optionally :meth:`SwitcherItems.AddGroup`
to add items and headings. These functions take a label (to be displayed to the user),
an identifying name, an integer id, and a bitmap. The name and id are purely for
application-defined identification. You may also set a description to be displayed
when each item is selected; and you can set a window pointer for convenience when
activating the desired window after the dialog returns.

Have created the dialog, you call :meth:`~Dialog.ShowModal`, and if the return value is
``wx.ID_OK``, retrieve the selection from the dialog and activate the pane.

The sample code below shows a generic method of finding panes and notebook
tabs within the current :class:`~lib.agw.aui.framemanager.AuiManager`, and using the pane name or notebook
tab position to display the pane.

The only other code to add is a menu item with the desired accelerator,
whose modifier matches the one you pass to :meth:`SwitcherDialog.SetModifierKey` 
(the default being ``wx.WXK_CONTROL``).


Usage
=====

Menu item::

    if wx.Platform == "__WXMAC__":
        switcherAccel = "Alt+Tab"
    elif wx.Platform == "__WXGTK__":
        switcherAccel = "Ctrl+/"
    else:
        switcherAccel = "Ctrl+Tab"

    view_menu.Append(ID_SwitchPane, _("S&witch Window...") + "\t" + switcherAccel)


Event handler::

    def OnSwitchPane(self, event):

        items = SwitcherItems()
        items.SetRowCount(12)

        # Add the main windows and toolbars, in two separate columns
        # We'll use the item 'id' to store the notebook selection, or -1 if not a page

        for k in xrange(2):
            if k == 0:
                items.AddGroup(_("Main Windows"), "mainwindows")
            else:
                items.AddGroup(_("Toolbars"), "toolbars").BreakColumn()

            for pane in self._mgr.GetAllPanes():
                name = pane.name
                caption = pane.caption

                toolbar = isinstance(info.window, wx.ToolBar) or isinstance(info.window, aui.AuiToolBar)
                if caption and (toolBar  and k == 1) or (not toolBar and k == 0):
                    items.AddItem(caption, name, -1).SetWindow(pane.window)

        # Now add the wxAuiNotebook pages

        items.AddGroup(_("Notebook Pages"), "pages").BreakColumn()

        for pane in self._mgr.GetAllPanes():
            nb = pane.window
            if isinstance(nb, aui.AuiNotebook):
                for j in xrange(nb.GetPageCount()):

                    name = nb.GetPageText(j)
                    win = nb.GetPage(j)

                    items.AddItem(name, name, j, nb.GetPageBitmap(j)).SetWindow(win)

        # Select the focused window

        idx = items.GetIndexForFocus()
        if idx != wx.NOT_FOUND:
            items.SetSelection(idx)

        if wx.Platform == "__WXMAC__":
            items.SetBackgroundColour(wx.WHITE)
        
        # Show the switcher dialog

        dlg = SwitcherDialog(items, wx.GetApp().GetTopWindow())

        # In GTK+ we can't use Ctrl+Tab; we use Ctrl+/ instead and tell the switcher
        # to treat / in the same was as tab (i.e. cycle through the names)

        if wx.Platform == "__WXGTK__":
            dlg.SetExtraNavigationKey(wxT('/'))

        if wx.Platform == "__WXMAC__":
            dlg.SetBackgroundColour(wx.WHITE)
            dlg.SetModifierKey(wx.WXK_ALT)

        ans = dlg.ShowModal()

        if ans == wx.ID_OK and dlg.GetSelection() != -1:
            item = items.GetItem(dlg.GetSelection())

            if item.GetId() == -1:
                info = self._mgr.GetPane(item.GetName())
                info.Show()
                self._mgr.Update()
                info.window.SetFocus()

            else:
                nb = item.GetWindow().GetParent()
                win = item.GetWindow();
                if isinstance(nb, aui.AuiNotebook):
                    nb.SetSelection(item.GetId())
                    win.SetFocus()


"""

import wx

import auibook
from aui_utilities import FindFocusDescendant
from aui_constants import SWITCHER_TEXT_MARGIN_X, SWITCHER_TEXT_MARGIN_Y


# Define a translation function
_ = wx.GetTranslation

    
class SwitcherItem(object):
    """ An object containing information about one item. """
    
    def __init__(self, item=None):
        """ Default class constructor. """

        self._id = 0
        self._isGroup = False
        self._breakColumn = False
        self._rowPos = 0
        self._colPos = 0
        self._window = None
        self._description = ""

        self._textColour = wx.NullColour
        self._bitmap = wx.NullBitmap
        self._font = wx.NullFont
        
        if item:
            self.Copy(item)


    def Copy(self, item):
        """
        Copy operator between 2 :class:`SwitcherItem` instances.

        :param `item`: another instance of :class:`SwitcherItem`.
        """

        self._id = item._id
        self._name = item._name
        self._title = item._title
        self._isGroup = item._isGroup
        self._breakColumn = item._breakColumn
        self._rect = item._rect
        self._font = item._font
        self._textColour = item._textColour
        self._bitmap = item._bitmap
        self._description = item._description
        self._rowPos = item._rowPos
        self._colPos = item._colPos
        self._window = item._window


    def SetTitle(self, title):

        self._title = title
        return self
    

    def GetTitle(self):
        
        return self._title


    def SetName(self, name):

        self._name = name
        return self

    
    def GetName(self):

        return self._name


    def SetDescription(self, descr):

        self._description = descr
        return self


    def GetDescription(self):

        return self._description
    

    def SetId(self, id):

        self._id = id
        return self

    
    def GetId(self):

        return self._id


    def SetIsGroup(self, isGroup):

        self._isGroup = isGroup
        return self

    
    def GetIsGroup(self):

        return self._isGroup
    

    def BreakColumn(self, breakCol=True):

        self._breakColumn = breakCol
        return self

    
    def GetBreakColumn(self):

        return self._breakColumn


    def SetRect(self, rect):

        self._rect = rect
        return self

    
    def GetRect(self):
        
        return self._rect


    def SetTextColour(self, colour):

        self._textColour = colour
        return self

    
    def GetTextColour(self):

        return self._textColour
    

    def SetFont(self, font):

        self._font = font
        return self

    
    def GetFont(self):

        return self._font
    

    def SetBitmap(self, bitmap):

        self._bitmap = bitmap
        return self

    
    def GetBitmap(self):

        return self._bitmap


    def SetRowPos(self, pos):

        self._rowPos = pos
        return self

    
    def GetRowPos(self):

        return self._rowPos
    

    def SetColPos(self, pos):

        self._colPos = pos
        return self

    
    def GetColPos(self):

        return self._colPos
    

    def SetWindow(self, win):

        self._window = win
        return self
    

    def GetWindow(self):

        return self._window

    
class SwitcherItems(object):
    """ An object containing switcher items. """

    def __init__(self, items=None):
        """ Default class constructor. """

        self._selection = -1
        self._rowCount = 10
        self._columnCount = 0

        self._backgroundColour = wx.NullColour
        self._textColour = wx.NullColour
        self._selectionColour = wx.NullColour
        self._selectionOutlineColour = wx.NullColour
        self._itemFont = wx.NullFont

        self._items = []        
        
        if wx.Platform == "__WXMSW__":
            # If on Windows XP/Vista, use more appropriate colours
            self.SetSelectionOutlineColour(wx.Colour(49, 106, 197))
            self.SetSelectionColour(wx.Colour(193, 210, 238))

        if items:
            self.Copy(items)
            

    def Copy(self, items):
        """
        Copy operator between 2 :class:`SwitcherItems`.

        :param `items`: another instance of :class:`SwitcherItems`.
        """
        
        self.Clear()

        for item in items._items:
            self._items.append(item)
        
        self._selection = items._selection
        self._rowCount = items._rowCount
        self._columnCount = items._columnCount

        self._backgroundColour = items._backgroundColour
        self._textColour = items._textColour
        self._selectionColour = items._selectionColour
        self._selectionOutlineColour = items._selectionOutlineColour
        self._itemFont = items._itemFont


    def AddItem(self, titleOrItem, name=None, id=0, bitmap=wx.NullBitmap):

        if isinstance(titleOrItem, SwitcherItem):
            self._items.append(titleOrItem)
            return self._items[-1]
        
        item = SwitcherItem()
        item.SetTitle(titleOrItem)
        item.SetName(name)
        item.SetId(id)
        item.SetBitmap(bitmap)

        self._items.append(item)
        return self._items[-1]


    def AddGroup(self, title, name, id=0, bitmap=wx.NullBitmap):

        item = self.AddItem(title, name, id, bitmap)
        item.SetIsGroup(True)

        return item


    def Clear(self):

        self._items = []


    def FindItemByName(self, name):

        for i in xrange(len(self._items)):
            if self._items[i].GetName() == name:
                return i
        
        return wx.NOT_FOUND


    def FindItemById(self, id):

        for i in xrange(len(self._items)):
            if self._items[i].GetId() == id:
                return i
        
        return wx.NOT_FOUND


    def SetSelection(self, sel):

        self._selection = sel


    def SetSelectionByName(self, name):

        idx = self.FindItemByName(name)
        if idx != wx.NOT_FOUND:
            self.SetSelection(idx)


    def GetSelection(self):

        return self._selection
    

    def GetItem(self, i):

        return self._items[i]


    def GetItemCount(self):

        return len(self._items)
    

    def SetRowCount(self, rows):

        self._rowCount = rows

        
    def GetRowCount(self):

        return self._rowCount


    def SetColumnCount(self, cols):

        self._columnCount = cols

        
    def GetColumnCount(self):

        return self._columnCount
    

    def SetBackgroundColour(self, colour):

        self._backgroundColour = colour

        
    def GetBackgroundColour(self):

        return self._backgroundColour
    

    def SetTextColour(self, colour):

        self._textColour = colour

        
    def GetTextColour(self):

        return self._textColour
    

    def SetSelectionColour(self, colour):

        self._selectionColour = colour

        
    def GetSelectionColour(self):

        return self._selectionColour
    

    def SetSelectionOutlineColour(self, colour):

        self._selectionOutlineColour = colour

        
    def GetSelectionOutlineColour(self):

        return self._selectionOutlineColour
    

    def SetItemFont(self, font):

        self._itemFont = font

        
    def GetItemFont(self):

        return self._itemFont 
    

    def PaintItems(self, dc, win):

        backgroundColour = wx.SystemSettings.GetColour(wx.SYS_COLOUR_3DFACE)
        standardTextColour = wx.SystemSettings.GetColour(wx.SYS_COLOUR_WINDOWTEXT)
        selectionColour = wx.SystemSettings.GetColour(wx.SYS_COLOUR_HIGHLIGHT)
        selectionOutlineColour = wx.SystemSettings.GetColour(wx.SYS_COLOUR_WINDOWTEXT)
        standardFont = wx.SystemSettings.GetFont(wx.SYS_DEFAULT_GUI_FONT)
        groupFont = wx.SystemSettings.GetFont(wx.SYS_DEFAULT_GUI_FONT)
        groupFont.SetWeight(wx.BOLD)

        if self.GetBackgroundColour().IsOk():
            backgroundColour = self.GetBackgroundColour()

        if self.GetTextColour().IsOk():
            standardTextColour = self.GetTextColour()

        if self.GetSelectionColour().IsOk():
            selectionColour = self.GetSelectionColour()

        if self.GetSelectionOutlineColour().IsOk():
            selectionOutlineColour = self.GetSelectionOutlineColour()

        if self.GetItemFont().IsOk():
        
            standardFont = self.GetItemFont()   
            groupFont = wx.Font(standardFont.GetPointSize(), standardFont.GetFamily(), standardFont.GetStyle(),
                                wx.BOLD, standardFont.GetUnderlined(), standardFont.GetFaceName())
        
        textMarginX = SWITCHER_TEXT_MARGIN_X

        dc.SetLogicalFunction(wx.COPY)
        dc.SetBrush(wx.Brush(backgroundColour))
        dc.SetPen(wx.TRANSPARENT_PEN)
        dc.DrawRectangleRect(win.GetClientRect())
        dc.SetBackgroundMode(wx.TRANSPARENT)

        for i in xrange(len(self._items)):
            item = self._items[i]
            if i == self._selection:
                dc.SetPen(wx.Pen(selectionOutlineColour))
                dc.SetBrush(wx.Brush(selectionColour))
                dc.DrawRectangleRect(item.GetRect())
            
            clippingRect = wx.Rect(*item.GetRect())
            clippingRect.Deflate(1, 1)

            dc.SetClippingRect(clippingRect)

            if item.GetTextColour().IsOk():
                dc.SetTextForeground(item.GetTextColour())
            else:
                dc.SetTextForeground(standardTextColour)
            
            if item.GetFont().IsOk():
                dc.SetFont(item.GetFont())
            else:
                if item.GetIsGroup():
                    dc.SetFont(groupFont)
                else:
                    dc.SetFont(standardFont)
            
            w, h = dc.GetTextExtent(item.GetTitle())
            x = item.GetRect().x

            x += textMarginX

            if not item.GetIsGroup():
                if item.GetBitmap().IsOk() and item.GetBitmap().GetWidth() <= 16 \
                   and item.GetBitmap().GetHeight() <= 16:
                    x -= textMarginX
                    dc.DrawBitmap(item.GetBitmap(), x, item.GetRect().y + \
                                  (item.GetRect().height - item.GetBitmap().GetHeight())/2,
                                  True)
                    x += 16 + textMarginX
                #x += textMarginX
            
            y = item.GetRect().y + (item.GetRect().height - h)/2
            dc.DrawText(item.GetTitle(), x, y)
            dc.DestroyClippingRegion()
    

    def CalculateItemSize(self, dc):

        # Start off allowing for an icon
        sz = wx.Size(150, 16)
        standardFont = wx.SystemSettings.GetFont(wx.SYS_DEFAULT_GUI_FONT)
        groupFont = wx.SystemSettings.GetFont(wx.SYS_DEFAULT_GUI_FONT)
        groupFont.SetWeight(wx.BOLD)

        textMarginX = SWITCHER_TEXT_MARGIN_X
        textMarginY = SWITCHER_TEXT_MARGIN_Y
        maxWidth = 300
        maxHeight = 40

        if self.GetItemFont().IsOk():
            standardFont = self.GetItemFont()   

        for item in self._items:
            if item.GetFont().IsOk():
                dc.SetFont(item.GetFont())
            else:
                if item.GetIsGroup():
                    dc.SetFont(groupFont)
                else:
                    dc.SetFont(standardFont)

            w, h = dc.GetTextExtent(item.GetTitle())
            w += 16 + 2*textMarginX

            if w > sz.x:
                sz.x = min(w, maxWidth)
            if h > sz.y:
                sz.y = min(h, maxHeight)
        
        if sz == wx.Size(16, 16):
            sz = wx.Size(100, 25)
        else:
            sz.x += textMarginX*2
            sz.y += textMarginY*2
        
        return sz


    def GetIndexForFocus(self):

        for i, item in enumerate(self._items):        
            if item.GetWindow():
            
                if FindFocusDescendant(item.GetWindow()):
                    return i
            
        return wx.NOT_FOUND


class MultiColumnListCtrl(wx.PyControl):
    """ A control for displaying several columns (not scrollable). """

    def __init__(self, parent, aui_manager, id=wx.ID_ANY, pos=wx.DefaultPosition, size=wx.DefaultSize,
                 style=0, validator=wx.DefaultValidator, name="MultiColumnListCtrl"):

        wx.PyControl.__init__(self, parent, id, pos, size, style, validator, name)

        self._overallSize = wx.Size(200, 100)
        self._modifierKey = wx.WXK_CONTROL
        self._extraNavigationKey = 0
        self._aui_manager = aui_manager
        
        self.SetInitialSize(size)
        self.SetBackgroundStyle(wx.BG_STYLE_CUSTOM)

        self.Bind(wx.EVT_PAINT, self.OnPaint)
        self.Bind(wx.EVT_ERASE_BACKGROUND, self.OnEraseBackground)
        self.Bind(wx.EVT_MOUSE_EVENTS, self.OnMouseEvent)
        self.Bind(wx.EVT_CHAR, self.OnChar)
        self.Bind(wx.EVT_KEY_DOWN, self.OnKey)
        self.Bind(wx.EVT_KEY_UP, self.OnKey)


    def __del__(self):

        self._aui_manager.HideHint()

        
    def DoGetBestSize(self):

        return self._overallSize


    def OnEraseBackground(self, event):
        
        pass


    def OnPaint(self, event):

        dc = wx.AutoBufferedPaintDC(self)
        rect = self.GetClientRect()

        if self._items.GetColumnCount() == 0:
            self.CalculateLayout(dc)

        if self._items.GetColumnCount() == 0:
            return

        self._items.PaintItems(dc, self)


    def OnMouseEvent(self, event):

        if event.LeftDown():
            self.SetFocus()
    

    def OnChar(self, event):

        event.Skip()        


    def OnKey(self, event):

        if event.GetEventType() == wx.wxEVT_KEY_UP:
            if event.GetKeyCode() == self.GetModifierKey():
                topLevel = wx.GetTopLevelParent(self)
                closeEvent = wx.CloseEvent(wx.wxEVT_CLOSE_WINDOW, topLevel.GetId())
                closeEvent.SetEventObject(topLevel)
                closeEvent.SetCanVeto(False)
                
                topLevel.GetEventHandler().ProcessEvent(closeEvent)
                return
                
            event.Skip()
            return

        keyCode = event.GetKeyCode()
        
        if keyCode in [wx.WXK_ESCAPE, wx.WXK_RETURN]:
            if keyCode == wx.WXK_ESCAPE:
                self._items.SetSelection(-1)

            topLevel = wx.GetTopLevelParent(self)
            closeEvent = wx.CloseEvent(wx.wxEVT_CLOSE_WINDOW, topLevel.GetId())
            closeEvent.SetEventObject(topLevel)
            closeEvent.SetCanVeto(False)
            
            topLevel.GetEventHandler().ProcessEvent(closeEvent)
            return
        
        elif keyCode in [wx.WXK_TAB, self.GetExtraNavigationKey()]:
            if event.ShiftDown():
            
                self._items.SetSelection(self._items.GetSelection() - 1)
                if self._items.GetSelection() < 0:
                    self._items.SetSelection(self._items.GetItemCount() - 1)

                self.AdvanceToNextSelectableItem(-1)
            
            else:
            
                self._items.SetSelection(self._items.GetSelection() + 1)
                if self._items.GetSelection() >= self._items.GetItemCount():
                    self._items.SetSelection(0)

                self.AdvanceToNextSelectableItem(1)
            
            self.GenerateSelectionEvent()
            self.Refresh()
        
        elif keyCode in [wx.WXK_DOWN, wx.WXK_NUMPAD_DOWN]:
            self._items.SetSelection(self._items.GetSelection() + 1)
            if self._items.GetSelection() >= self._items.GetItemCount():
                self._items.SetSelection(0)
            
            self.AdvanceToNextSelectableItem(1)
            self.GenerateSelectionEvent()
            self.Refresh()
        
        elif keyCode in [wx.WXK_UP, wx.WXK_NUMPAD_UP]:
            self._items.SetSelection(self._items.GetSelection() - 1)
            if self._items.GetSelection() < 0:
                self._items.SetSelection(self._items.GetItemCount() - 1)
            
            self.AdvanceToNextSelectableItem(-1)
            self.GenerateSelectionEvent()
            self.Refresh()
        
        elif keyCode in [wx.WXK_HOME, wx.WXK_NUMPAD_HOME]:
            self._items.SetSelection(0)
            self.AdvanceToNextSelectableItem(1)
            self.GenerateSelectionEvent()
            self.Refresh()
        
        elif keyCode in [wx.WXK_END, wx.WXK_NUMPAD_END]:
            self._items.SetSelection(self._items.GetItemCount() - 1)
            self.AdvanceToNextSelectableItem(-1)
            self.GenerateSelectionEvent()
            self.Refresh()
        
        elif keyCode in [wx.WXK_LEFT, wx.WXK_NUMPAD_LEFT]:
            item = self._items.GetItem(self._items.GetSelection())

            row = item.GetRowPos()
            newCol = item.GetColPos() - 1
            if newCol < 0:
                newCol = self._items.GetColumnCount() - 1

            # Find the first item from the end whose row matches and whose column is equal or lower
            for i in xrange(self._items.GetItemCount()-1, -1, -1):
                item2 = self._items.GetItem(i)
                if item2.GetColPos() == newCol and item2.GetRowPos() <= row:
                    self._items.SetSelection(i)
                    break

            self.AdvanceToNextSelectableItem(-1)
            self.GenerateSelectionEvent()
            self.Refresh()
        
        elif keyCode in [wx.WXK_RIGHT, wx.WXK_NUMPAD_RIGHT]:
            item = self._items.GetItem(self._items.GetSelection())

            row = item.GetRowPos()
            newCol = item.GetColPos() + 1
            if newCol >= self._items.GetColumnCount():
                newCol = 0

            # Find the first item from the end whose row matches and whose column is equal or lower
            for i in xrange(self._items.GetItemCount()-1, -1, -1):
                item2 = self._items.GetItem(i)
                if item2.GetColPos() == newCol and item2.GetRowPos() <= row:
                    self._items.SetSelection(i)
                    break

            self.AdvanceToNextSelectableItem(1)
            self.GenerateSelectionEvent()
            self.Refresh()
        
        else:
            event.Skip()


    def AdvanceToNextSelectableItem(self, direction):

        if self._items.GetItemCount() < 2:
            return

        if self._items.GetSelection() == -1:
            self._items.SetSelection(0)

        oldSel = self._items.GetSelection()

        while 1:
        
            if self._items.GetItem(self._items.GetSelection()).GetIsGroup():
            
                self._items.SetSelection(self._items.GetSelection() + direction)
                if self._items.GetSelection() == -1:
                    self._items.SetSelection(self._items.GetItemCount()-1)
                elif self._items.GetSelection() == self._items.GetItemCount():
                    self._items.SetSelection(0)
                if self._items.GetSelection() == oldSel:
                    break
            
            else:
                break

        self.SetTransparency()
        selection = self._items.GetItem(self._items.GetSelection()).GetWindow()
        pane = self._aui_manager.GetPane(selection)

        if not pane.IsOk():
            if isinstance(selection.GetParent(), auibook.AuiNotebook):
                self.SetTransparency(selection)
                self._aui_manager.ShowHint(selection.GetScreenRect())
                wx.CallAfter(self.SetFocus)
                self.SetFocus()
                return
            else:
                self._aui_manager.HideHint()
                return
        if not pane.IsShown():
            self._aui_manager.HideHint()
            return

        self.SetTransparency(selection)
        self._aui_manager.ShowHint(selection.GetScreenRect())
        # NOTE: this is odd but it is the only way for the focus to
        #       work correctly on wxMac...
        wx.CallAfter(self.SetFocus)
        self.SetFocus()        
    

    def SetTransparency(self, selection=None):

        if not self.GetParent().CanSetTransparent():
            return
        
        if selection is not None:
            intersects = False
            if selection.GetScreenRect().Intersects(self.GetParent().GetScreenRect()):
                intersects = True
                self.GetParent().SetTransparent(200)
                return

        self.GetParent().SetTransparent(255)


    def GenerateSelectionEvent(self):

        event = wx.CommandEvent(wx.wxEVT_COMMAND_LISTBOX_SELECTED, self.GetId())
        event.SetEventObject(self)
        event.SetInt(self._items.GetSelection())
        self.GetEventHandler().ProcessEvent(event)


    def CalculateLayout(self, dc=None):

        if dc is None:
            dc = wx.ClientDC(self)

        if self._items.GetSelection() == -1:
            self._items.SetSelection(0)

        columnCount = 1

        # Spacing between edge of window or between columns
        xMargin = 4
        yMargin = 4

        # Inter-row spacing
        rowSpacing = 2

        itemSize = self._items.CalculateItemSize(dc)
        self._overallSize = wx.Size(350, 200)

        currentRow = 0
        x = xMargin
        y = yMargin

        breaking = False
        i = 0
        
        while 1:
        
            oldOverallSize = self._overallSize
            item = self._items.GetItem(i)
            
            item.SetRect(wx.Rect(x, y, itemSize.x, itemSize.y))
            item.SetColPos(columnCount-1)
            item.SetRowPos(currentRow)

            if item.GetRect().GetBottom() > self._overallSize.y:
                self._overallSize.y = item.GetRect().GetBottom() + yMargin

            if item.GetRect().GetRight() > self._overallSize.x:
                self._overallSize.x = item.GetRect().GetRight() + xMargin

            currentRow += 1

            y += rowSpacing + itemSize.y
            stopBreaking = breaking

            if currentRow > self._items.GetRowCount() or (item.GetBreakColumn() and not breaking and currentRow != 1):
                currentRow = 0
                columnCount += 1
                x += xMargin + itemSize.x
                y = yMargin

                # Make sure we don't orphan a group
                if item.GetIsGroup() or (item.GetBreakColumn() and not breaking):
                    self._overallSize = oldOverallSize

                    if item.GetBreakColumn():
                        breaking = True

                    # Repeat the last item, in the next column
                    i -= 1
                
            if stopBreaking:
                breaking = False

            i += 1
            
            if i >= self._items.GetItemCount():
                break
            
        self._items.SetColumnCount(columnCount)
        self.InvalidateBestSize()


    def SetItems(self, items):
        
        self._items = items

        
    def GetItems(self):

        return self._items

 
    def SetExtraNavigationKey(self, keyCode):
        """
        Set an extra key that can be used to cycle through items,
        in case not using the ``Ctrl`` + ``Tab`` combination.
        """

        self._extraNavigationKey = keyCode


    def GetExtraNavigationKey(self):

        return self._extraNavigationKey


    def SetModifierKey(self, modifierKey):
        """
        Set the modifier used to invoke the dialog, and therefore to test for release.
        """

        self._modifierKey = modifierKey

        
    def GetModifierKey(self):

        return self._modifierKey

    

class SwitcherDialog(wx.Dialog):
    """
    SwitcherDialog shows a :class:`Dialog` with a list of panes and tabs for the user to choose.
    ``Ctrl`` + ``Tab`` cycles through them.
    """

    def __init__(self, items, parent, aui_manager, id=wx.ID_ANY, title=_("Pane Switcher"), pos=wx.DefaultPosition,
                 size=wx.DefaultSize, style=wx.STAY_ON_TOP|wx.DIALOG_NO_PARENT|wx.BORDER_SIMPLE):
        """ Default class constructor. """
        
        self._switcherBorderStyle = (style & wx.BORDER_MASK)
        if self._switcherBorderStyle == wx.BORDER_NONE:
            self._switcherBorderStyle = wx.BORDER_SIMPLE

        style &= wx.BORDER_MASK
        style |= wx.BORDER_NONE

        wx.Dialog.__init__(self, parent, id, title, pos, size, style)

        self._listCtrl = MultiColumnListCtrl(self, aui_manager,
                                             style=wx.WANTS_CHARS|wx.NO_BORDER)
        self._listCtrl.SetItems(items)
        self._listCtrl.CalculateLayout()

        self._descriptionCtrl = wx.html.HtmlWindow(self, size=(-1, 100), style=wx.BORDER_NONE)
        self._descriptionCtrl.SetBackgroundColour(self.GetBackgroundColour())

        if wx.Platform == "__WXGTK__":
            fontSize = 11
            self._descriptionCtrl.SetStandardFonts(fontSize)

        sizer = wx.BoxSizer(wx.VERTICAL)
        self.SetSizer(sizer)
        sizer.Add(self._listCtrl, 1, wx.ALL|wx.EXPAND, 10)
        sizer.Add(self._descriptionCtrl, 0, wx.ALL|wx.EXPAND, 10)
        sizer.SetSizeHints(self)

        self._listCtrl.SetFocus()

        self.Centre(wx.BOTH)

        if self._listCtrl.GetItems().GetSelection() == -1:
            self._listCtrl.GetItems().SetSelection(0)

        self._listCtrl.AdvanceToNextSelectableItem(1)

        self.ShowDescription(self._listCtrl.GetItems().GetSelection())

        self.Bind(wx.EVT_CLOSE, self.OnCloseWindow)
        self.Bind(wx.EVT_ACTIVATE, self.OnActivate)
        self.Bind(wx.EVT_LISTBOX, self.OnSelectItem)
        self.Bind(wx.EVT_PAINT, self.OnPaint)

        # Attributes
        self._closing = False
        if wx.Platform == "__WXMSW__":
            self._borderColour = wx.Colour(49, 106, 197)
        else:
            self._borderColour = wx.BLACK

        self._aui_manager = aui_manager
        

    def OnCloseWindow(self, event):

        if self._closing:
            return

        if self.IsModal():
            self._closing = True

            if self.GetSelection() == -1:
                self.EndModal(wx.ID_CANCEL)
            else:
                self.EndModal(wx.ID_OK)
    
        self._aui_manager.HideHint()


    def GetSelection(self):

        return self._listCtrl.GetItems().GetSelection()


    def OnActivate(self, event):

        if not event.GetActive():
            if not self._closing:
                self._closing = True
                self.EndModal(wx.ID_CANCEL)
            

    def OnPaint(self, event):

        dc = wx.PaintDC(self)

        if self._switcherBorderStyle == wx.BORDER_SIMPLE:
        
            dc.SetPen(wx.Pen(self._borderColour))
            dc.SetBrush(wx.TRANSPARENT_BRUSH)

            rect = self.GetClientRect()
            dc.DrawRectangleRect(rect)

            # Draw border around the HTML control
            rect = wx.Rect(*self._descriptionCtrl.GetRect())
            rect.Inflate(1, 1)
            dc.DrawRectangleRect(rect)

    
    def OnSelectItem(self, event):

        self.ShowDescription(event.GetSelection())


    # Convert a colour to a 6-digit hex string
    def ColourToHexString(self, col):

        hx = '%02x%02x%02x' % tuple([int(c) for c in col])
        return hx


    def ShowDescription(self, i):

        item = self._listCtrl.GetItems().GetItem(i)
        colour = self._listCtrl.GetItems().GetBackgroundColour()
        
        if not colour.IsOk():
            colour = self.GetBackgroundColour()

        backgroundColourHex = self.ColourToHexString(colour)
        html = _("<body bgcolor=\"#") + backgroundColourHex + _("\"><b>") + item.GetTitle() + _("</b>")

        if item.GetDescription():
            html += _("<p>")
            html += item.GetDescription()
        
        html += _("</body>")
        self._descriptionCtrl.SetPage(html)


    def SetExtraNavigationKey(self, keyCode):

        self._extraNavigationKey = keyCode
        if self._listCtrl:
            self._listCtrl.SetExtraNavigationKey(keyCode)


    def GetExtraNavigationKey(self):

        return self._extraNavigationKey
    
        
    def SetModifierKey(self, modifierKey):

        self._modifierKey = modifierKey
        if self._listCtrl:
            self._listCtrl.SetModifierKey(modifierKey)


    def GetModifierKey(self):

        return self._modifierKey        


    def SetBorderColour(self, colour):

        self._borderColour = colour

        
########NEW FILE########
__FILENAME__ = aui_utilities
"""
This module contains some common functions used by :mod:`lib.agw.aui` to
manipulate colours, bitmaps, text, gradient shadings and custom dragging images
for :class:`~lib.agw.aui.auibook.AuiNotebook` tabs.
"""

__author__ = "Andrea Gavana <andrea.gavana@gmail.com>"
__date__ = "31 March 2009"


import wx

from aui_constants import *


if wx.Platform == "__WXMAC__":
    import Carbon.Appearance
    
    
def BlendColour(fg, bg, alpha):
    """
    Blends the two colour component `fg` and `bg` into one colour component, adding
    an optional alpha channel.

    :param Colour `fg`: the first colour component;
    :param Colour `bg`: the second colour component;
    :param integer `alpha`: an optional transparency value.
    """
    
    result = bg + (alpha*(fg - bg))
    
    if result < 0.0:
        result = 0.0
    if result > 255:
        result = 255
        
    return result


def StepColour(c, ialpha):
    """
    Darken/lighten the input colour `c`.

    :param Colour `c`: a colour to darken/lighten;
    :param integer `ialpha`: a transparency value.
    """
    
    if ialpha == 100:
        return c
        
    r, g, b = c.Red(), c.Green(), c.Blue()

    # ialpha is 0..200 where 0 is completely black
    # and 200 is completely white and 100 is the same
    # convert that to normal alpha 0.0 - 1.0
    ialpha = min(ialpha, 200)
    ialpha = max(ialpha, 0)
    alpha = (ialpha - 100.0)/100.0

    if ialpha > 100:
    
        # blend with white
        bg = 255
        alpha = 1.0 - alpha  # 0 = transparent fg 1 = opaque fg
    
    else:
    
        # blend with black
        bg = 0
        alpha = 1.0 + alpha  # 0 = transparent fg 1 = opaque fg
    
    r = BlendColour(r, bg, alpha)
    g = BlendColour(g, bg, alpha)
    b = BlendColour(b, bg, alpha)

    return wx.Colour(r, g, b)


def LightContrastColour(c):
    """
    Creates a new, lighter colour based on the input colour `c`.

    :param Colour `c`: the input colour to analyze.
    """

    amount = 120

    # if the colour is especially dark, then
    # make the contrast even lighter
    if c.Red() < 128 and c.Green() < 128 and c.Blue() < 128:
        amount = 160

    return StepColour(c, amount)


def ChopText(dc, text, max_size):
    """
    Chops the input `text` if its size does not fit in `max_size`, by cutting the
    text and adding ellipsis at the end.

    :param `dc`: a :class:`DC` device context;
    :param string `text`: the text to chop;
    :param integer `max_size`: the maximum size in which the text should fit.
    """
    
    # first check if the text fits with no problems
    x, y, dummy = dc.GetMultiLineTextExtent(text)
    
    if x <= max_size:
        return text

    textLen = len(text)
    last_good_length = 0
    
    for i in xrange(textLen, -1, -1):
        s = text[0:i]
        s += "..."

        x, y = dc.GetTextExtent(s)
        last_good_length = i
        
        if x < max_size:
            break

    ret = text[0:last_good_length] + "..."    
    return ret


def BitmapFromBits(bits, w, h, colour):
    """
    A utility function that creates a masked bitmap from raw bits (XBM format).

    :param string `bits`: the raw bits of the bitmap;
    :param integer `w`: the bitmap width;
    :param integer `h`: the bitmap height;
    :param Colour `colour`: the colour which will replace all white pixels in the
     raw bitmap.
    """

    img = wx.BitmapFromBits(bits, w, h).ConvertToImage()
    img.Replace(0, 0, 0, 123, 123, 123)
    img.Replace(255, 255, 255, colour.Red(), colour.Green(), colour.Blue())
    img.SetMaskColour(123, 123, 123)
    return wx.BitmapFromImage(img)


def IndentPressedBitmap(rect, button_state):
    """
    Indents the input rectangle `rect` based on the value of `button_state`.

    :param Rect `rect`: the button bitmap rectangle;
    :param integer `button_state`: the button state.
    """

    if button_state == AUI_BUTTON_STATE_PRESSED:
        rect.x += 1
        rect.y += 1

    return rect


def GetBaseColour():
    """
    Returns the face shading colour on push buttons/backgrounds,
    mimicking as closely as possible the platform UI colours.
    """

    if wx.Platform == "__WXMAC__":

        if hasattr(wx, 'MacThemeColour'):
            base_colour = wx.MacThemeColour(Carbon.Appearance.kThemeBrushToolbarBackground)
        else:
            brush = wx.Brush(wx.BLACK)
            brush.MacSetTheme(Carbon.Appearance.kThemeBrushToolbarBackground)
            base_colour = brush.GetColour()

    else:
        
        base_colour = wx.SystemSettings.GetColour(wx.SYS_COLOUR_3DFACE)

    # the base_colour is too pale to use as our base colour,
    # so darken it a bit
    if ((255-base_colour.Red()) +
        (255-base_colour.Green()) +
        (255-base_colour.Blue()) < 60):
    
        base_colour = StepColour(base_colour, 92)
    
    return base_colour


def MakeDisabledBitmap(bitmap):
    """
    Convert the given image (in place) to a grayed-out version, appropriate for a 'disabled' appearance.

    :param Bitmap `bitmap`: the bitmap to gray-out.
    """

    anImage = bitmap.ConvertToImage()    
    factor = 0.7        # 0 < f < 1.  Higher Is Grayer
    
    if anImage.HasMask():
        maskColour = (anImage.GetMaskRed(), anImage.GetMaskGreen(), anImage.GetMaskBlue())
    else:
        maskColour = None
        
    data = map(ord, list(anImage.GetData()))

    for i in range(0, len(data), 3):
        
        pixel = (data[i], data[i+1], data[i+2])
        pixel = MakeGray(pixel, factor, maskColour)

        for x in range(3):
            data[i+x] = pixel[x]

    anImage.SetData(''.join(map(chr, data)))
    
    return anImage.ConvertToBitmap()


def MakeGray(rgbTuple, factor, maskColour):
    """
    Make a pixel grayed-out.

    If the pixel matches the `maskColour`, it won't be changed.

    :param tuple `rgbTuple`: a tuple representing a pixel colour;
    :param integer `factor`: a graying-out factor;
    :param Colour `maskColour`: a colour mask.
    """

    if rgbTuple != maskColour:
        r, g, b = rgbTuple
        return map(lambda x: int((230 - x) * factor) + x, (r, g, b))
    else:
        return rgbTuple


def Clip(a, b, c):
    """
    Clips the value in `a` based on the extremes `b` and `c`.

    :param `a`: the value to analyze;
    :param `b`: a minimum value;
    :param `c`: a maximum value.
    """

    return ((a < b and [b]) or [(a > c and [c] or [a])[0]])[0]


def LightColour(colour, percent):
    """
    Brighten input `colour` by `percent`.

    :param Colour `colour`: the colour to be brightened;
    :param integer `percent`: brightening percentage.
    """
    
    end_colour = wx.WHITE
    
    rd = end_colour.Red() - colour.Red()
    gd = end_colour.Green() - colour.Green()
    bd = end_colour.Blue() - colour.Blue()

    high = 100

    # We take the percent way of the colour from colour -. white
    i = percent
    r = colour.Red() + ((i*rd*100)/high)/100
    g = colour.Green() + ((i*gd*100)/high)/100
    b = colour.Blue() + ((i*bd*100)/high)/100
    return wx.Colour(r, g, b)


def PaneCreateStippleBitmap():
    """
    Creates a stipple bitmap to be used in a :class:`Brush`.
    
    This is used to draw sash resize hints.
    """

    data = [0, 0, 0, 192, 192, 192, 192, 192, 192, 0, 0, 0]
    img = wx.EmptyImage(2, 2)
    counter = 0
    
    for ii in xrange(2):
        for jj in xrange(2):
            img.SetRGB(ii, jj, data[counter], data[counter+1], data[counter+2])
            counter = counter + 3
    
    return img.ConvertToBitmap()


def DrawMACCloseButton(colour, backColour=None):
    """
    Draws the wxMAC tab close button using :class:`GraphicsContext`.

    :param Colour `colour`: the colour to use to draw the circle;
    :param Colour `backColour`: the optional background colour for the circle.
    """

    bmp = wx.EmptyBitmapRGBA(16, 16)
    dc = wx.MemoryDC()
    dc.SelectObject(bmp)

    gc = wx.GraphicsContext.Create(dc)    
    gc.SetBrush(wx.Brush(colour))
    path = gc.CreatePath()
    path.AddCircle(6.5, 7, 6.5)
    path.CloseSubpath()
    gc.FillPath(path)
    
    path = gc.CreatePath()
    if backColour is not None:
        pen = wx.Pen(backColour, 2)
    else:
        pen = wx.Pen("white", 2)
        
    pen.SetCap(wx.CAP_BUTT)
    pen.SetJoin(wx.JOIN_BEVEL)
    gc.SetPen(pen)
    path.MoveToPoint(3.5, 4)
    path.AddLineToPoint(9.5, 10)
    path.MoveToPoint(3.5, 10)
    path.AddLineToPoint(9.5, 4)
    path.CloseSubpath()
    gc.DrawPath(path)

    dc.SelectObject(wx.NullBitmap)
    return bmp


def DarkenBitmap(bmp, caption_colour, new_colour):
    """
    Darkens the input bitmap on wxMAC using the input colour.
    
    :param Bitmap `bmp`: the bitmap to be manipulated;
    :param Colour `caption_colour`: the colour of the pane caption;
    :param Colour `new_colour`: the colour used to darken the bitmap.
    """

    image = bmp.ConvertToImage()
    red = caption_colour.Red()/float(new_colour.Red())
    green = caption_colour.Green()/float(new_colour.Green())
    blue = caption_colour.Blue()/float(new_colour.Blue())
    image = image.AdjustChannels(red, green, blue)
    return image.ConvertToBitmap()

    
def DrawGradientRectangle(dc, rect, start_colour, end_colour, direction, offset=0, length=0):
    """
    Draws a gradient-shaded rectangle.

    :param `dc`: a :class:`DC` device context;
    :param Rect `rect`: the rectangle in which to draw the gradient;
    :param Colour `start_colour`: the first colour of the gradient;
    :param Colour `end_colour`: the second colour of the gradient;
    :param integer `direction`: the gradient direction (horizontal or vertical).
    """
    
    if direction == AUI_GRADIENT_VERTICAL:
        dc.GradientFillLinear(rect, start_colour, end_colour, wx.SOUTH)
    else:
        dc.GradientFillLinear(rect, start_colour, end_colour, wx.EAST)
        

def FindFocusDescendant(ancestor):
    """
    Find a window with the focus, that is also a descendant of the given window.
    This is used to determine the window to initially send commands to.

    :param Window `ancestor`: the window to check for ancestry.    
    """

    # Process events starting with the window with the focus, if any.
    focusWin = wx.Window.FindFocus()
    win = focusWin

    # Check if this is a descendant of this frame.
    # If not, win will be set to NULL.
    while win:
        if win == ancestor:
            break
        else:
            win = win.GetParent()

    if win is None:
        focusWin = None

    return focusWin


def GetLabelSize(dc, label, vertical):
    """
    Returns the :class:`~lib.agw.aui.auibar.AuiToolBar` item label size.

    :param string `label`: the toolbar tool label;
    :param bool `vertical`: whether the toolbar tool orientation is vertical or not.
    """

    text_width = text_height = 0

    # get the text height
    dummy, text_height = dc.GetTextExtent("ABCDHgj")
    # get the text width
    if label.strip():
        text_width, dummy = dc.GetTextExtent(label)

    if vertical:
        tmp = text_height
        text_height = text_width
        text_width = tmp

    return wx.Size(text_width, text_height)


#---------------------------------------------------------------------------
# TabDragImage implementation
# This class handles the creation of a custom image when dragging
# AuiNotebook tabs
#---------------------------------------------------------------------------

class TabDragImage(wx.DragImage):
    """
    This class handles the creation of a custom image in case of drag and drop of a notebook tab.
    """

    def __init__(self, notebook, page, button_state, tabArt):
        """
        Default class constructor.
        
        For internal use: do not call it in your code!

        :param `notebook`: an instance of :class:`~lib.agw.aui.auibook.AuiNotebook`;
        :param `page`: the dragged :class:`~lib.agw.aui.auibook.AuiNotebookPage` page;
        :param integer `button_state`: the state of the close button on the tab;
        :param `tabArt`: an instance of :class:`~lib.agw.aui.tabart.AuiDefaultTabArt` or one of its derivations.
        """

        self._backgroundColour = wx.NamedColour("pink")        
        self._bitmap = self.CreateBitmap(notebook, page, button_state, tabArt)
        wx.DragImage.__init__(self, self._bitmap)


    def CreateBitmap(self, notebook, page, button_state, tabArt):
        """
        Actually creates the drag and drop bitmap.

        :param `notebook`: an instance of :class:`~lib.agw.aui.auibook.AuiNotebook`;
        :param `page`: the dragged :class:`~lib.agw.aui.auibook.AuiNotebookPage` page;
        :param integer `button_state`: the state of the close button on the tab;
        :param `tabArt`: an instance of :class:`~lib.agw.aui.tabart.AuiDefaultTabArt` or one of its derivations.
        """

        control = page.control
        memory = wx.MemoryDC(wx.EmptyBitmap(1, 1))

        tab_size, x_extent = tabArt.GetTabSize(memory, notebook, page.caption, page.bitmap, page.active,
                                               button_state, control)
            
        tab_width, tab_height = tab_size
        rect = wx.Rect(0, 0, tab_width, tab_height)

        bitmap = wx.EmptyBitmap(tab_width+1, tab_height+1)
        memory.SelectObject(bitmap)

        if wx.Platform == "__WXMAC__":
            memory.SetBackground(wx.TRANSPARENT_BRUSH)
        else:
            memory.SetBackground(wx.Brush(self._backgroundColour))
            
        memory.SetBackgroundMode(wx.TRANSPARENT)
        memory.Clear()

        paint_control = wx.Platform != "__WXMAC__"
        tabArt.DrawTab(memory, notebook, page, rect, button_state, paint_control=paint_control)
        
        memory.SetBrush(wx.TRANSPARENT_BRUSH)
        memory.SetPen(wx.BLACK_PEN)
        memory.DrawRoundedRectangle(0, 0, tab_width+1, tab_height+1, 2)

        memory.SelectObject(wx.NullBitmap)
        
        # Gtk and Windows unfortunatly don't do so well with transparent
        # drawing so this hack corrects the image to have a transparent
        # background.
        if wx.Platform != '__WXMAC__':
            timg = bitmap.ConvertToImage()
            if not timg.HasAlpha():
                timg.InitAlpha()
            for y in xrange(timg.GetHeight()):
                for x in xrange(timg.GetWidth()):
                    pix = wx.Colour(timg.GetRed(x, y),
                                    timg.GetGreen(x, y),
                                    timg.GetBlue(x, y))
                    if pix == self._backgroundColour:
                        timg.SetAlpha(x, y, 0)
            bitmap = timg.ConvertToBitmap()
        return bitmap        


def GetDockingImage(direction, useAero, center):
    """
    Returns the correct name of the docking bitmap depending on the input parameters.

    :param bool `useAero`: whether :class:`~lib.agw.aui.framemanager.AuiManager` is using
     Aero-style or Whidbey-style docking images or not;
    :param bool `center`: whether we are looking for the center diamond-shaped bitmap or not. 
    """

    suffix = (center and [""] or ["_single"])[0]
    prefix = ""
    if useAero == 2:
        # Whidbey docking guides
        prefix = "whidbey_"
    elif useAero == 1:
        # Aero docking style
        prefix = "aero_"
        
    if direction == wx.TOP:
        bmp_unfocus = eval("%sup%s"%(prefix, suffix)).GetBitmap()
        bmp_focus = eval("%sup_focus%s"%(prefix, suffix)).GetBitmap()
    elif direction == wx.BOTTOM:
        bmp_unfocus = eval("%sdown%s"%(prefix, suffix)).GetBitmap()
        bmp_focus = eval("%sdown_focus%s"%(prefix, suffix)).GetBitmap()
    elif direction == wx.LEFT:
        bmp_unfocus = eval("%sleft%s"%(prefix, suffix)).GetBitmap()
        bmp_focus = eval("%sleft_focus%s"%(prefix, suffix)).GetBitmap()
    elif direction == wx.RIGHT:
        bmp_unfocus = eval("%sright%s"%(prefix, suffix)).GetBitmap()
        bmp_focus = eval("%sright_focus%s"%(prefix, suffix)).GetBitmap()
    else:
        bmp_unfocus = eval("%stab%s"%(prefix, suffix)).GetBitmap()
        bmp_focus = eval("%stab_focus%s"%(prefix, suffix)).GetBitmap()

    return bmp_unfocus, bmp_focus


def TakeScreenShot(rect):
    """
    Takes a screenshot of the screen at given position and size (`rect`).

    :param Rect `rect`: the screen rectangle for which we want to take a screenshot.
    """

    # Create a DC for the whole screen area
    dcScreen = wx.ScreenDC()

    # Create a Bitmap that will later on hold the screenshot image
    # Note that the Bitmap must have a size big enough to hold the screenshot
    # -1 means using the current default colour depth
    bmp = wx.EmptyBitmap(rect.width, rect.height)

    # Create a memory DC that will be used for actually taking the screenshot
    memDC = wx.MemoryDC()

    # Tell the memory DC to use our Bitmap
    # all drawing action on the memory DC will go to the Bitmap now
    memDC.SelectObject(bmp)

    # Blit (in this case copy) the actual screen on the memory DC
    # and thus the Bitmap
    memDC.Blit( 0,            # Copy to this X coordinate
                0,            # Copy to this Y coordinate
                rect.width,   # Copy this width
                rect.height,  # Copy this height
                dcScreen,     # From where do we copy?
                rect.x,       # What's the X offset in the original DC?
                rect.y        # What's the Y offset in the original DC?
                )

    # Select the Bitmap out of the memory DC by selecting a new
    # uninitialized Bitmap
    memDC.SelectObject(wx.NullBitmap)

    return bmp


def RescaleScreenShot(bmp, thumbnail_size=200):
    """
    Rescales a bitmap to be `thumbnail_size` pixels wide (or tall) at maximum.

    :param Bitmap `bmp`: the bitmap to rescale;
    :param integer `thumbnail_size`: the maximum size of every page thumbnail.
    """

    bmpW, bmpH = bmp.GetWidth(), bmp.GetHeight()
    img = bmp.ConvertToImage()

    newW, newH = bmpW, bmpH
    
    if bmpW > bmpH:
        if bmpW > thumbnail_size:
            ratio = bmpW/float(thumbnail_size)
            newW, newH = int(bmpW/ratio), int(bmpH/ratio)
            img.Rescale(newW, newH, wx.IMAGE_QUALITY_HIGH)
    else:
        if bmpH > thumbnail_size:
            ratio = bmpH/float(thumbnail_size)
            newW, newH = int(bmpW/ratio), int(bmpH/ratio)
            img.Rescale(newW, newH, wx.IMAGE_QUALITY_HIGH)

    newBmp = img.ConvertToBitmap()
    otherBmp = wx.EmptyBitmap(newW+5, newH+5)    

    memDC = wx.MemoryDC()
    memDC.SelectObject(otherBmp)
    memDC.SetBackground(wx.WHITE_BRUSH)
    memDC.Clear()
    
    memDC.SetPen(wx.TRANSPARENT_PEN)

    pos = 0
    for i in xrange(5, 0, -1):
        brush = wx.Brush(wx.Colour(50*i, 50*i, 50*i))
        memDC.SetBrush(brush)
        memDC.DrawRoundedRectangle(0, 0, newW+5-pos, newH+5-pos, 2)
        pos += 1

    memDC.DrawBitmap(newBmp, 0, 0, True)
     
    # Select the Bitmap out of the memory DC by selecting a new
    # uninitialized Bitmap
    memDC.SelectObject(wx.NullBitmap)

    return otherBmp


def GetSlidingPoints(rect, size, direction):
    """
    Returns the point at which the sliding in and out of a minimized pane begins.

    :param Rect `rect`: the :class:`~lib.agw.aui.auibar.AuiToolBar` tool screen rectangle;
    :param Size `size`: the pane window size;
    :param integer `direction`: the pane docking direction.
    """

    if direction == AUI_DOCK_LEFT:
        startX, startY = rect.x + rect.width + 2, rect.y
    elif direction == AUI_DOCK_TOP:
        startX, startY = rect.x, rect.y + rect.height + 2
    elif direction == AUI_DOCK_RIGHT:
        startX, startY = rect.x - size.x - 2, rect.y
    elif direction == AUI_DOCK_BOTTOM:
        startX, startY = rect.x, rect.y - size.y - 2
    else:
        raise Exception("How did we get here?")

    caption_height = wx.SystemSettings.GetMetric(wx.SYS_CAPTION_Y)
    frame_border_x = wx.SystemSettings.GetMetric(wx.SYS_FRAMESIZE_X)
    frame_border_y = wx.SystemSettings.GetMetric(wx.SYS_FRAMESIZE_Y)
    
    stopX = size.x + caption_height + frame_border_x
    stopY = size.x + frame_border_y
    
    return startX, startY, stopX, stopY


def CopyAttributes(newArt, oldArt):
    """
    Copies pens, brushes, colours and fonts from the old tab art to the new one.

    :param `newArt`: the new instance of :class:`~lib.agw.aui.tabart.AuiDefaultTabArt`;
    :param `oldArt`: the old instance of :class:`~lib.agw.aui.tabart.AuiDefaultTabArt`.
    """    
    
    attrs = dir(oldArt)

    for attr in attrs:
        if attr.startswith("_") and (attr.endswith("_colour") or attr.endswith("_font") or \
                                     attr.endswith("_font") or attr.endswith("_brush") or \
                                     attr.endswith("Pen") or attr.endswith("_pen")):
            setattr(newArt, attr, getattr(oldArt, attr))

    return newArt            


########NEW FILE########
__FILENAME__ = dockart
"""
Dock art provider code - a dock provider provides all drawing functionality to
the AUI dock manager. This allows the dock manager to have a plugable look-and-feel.

By default, a :class:`~lib.agw.aui.framemanager` uses an instance of this class called :mod:`~lib.agw.aui.dockart`
which provides bitmap art and a colour scheme that is adapted to the major platforms'
look. You can either derive from that class to alter its behaviour or write a
completely new dock art class. Call :meth:`AuiManager.SetArtProvider() <lib.agw.aui.framemanager.AuiManager.SetArtProvider>`
to make use this new dock art.
"""

__author__ = "Andrea Gavana <andrea.gavana@gmail.com>"
__date__ = "31 March 2009"


import wx
import types

from aui_utilities import BitmapFromBits, StepColour, ChopText, GetBaseColour
from aui_utilities import DrawGradientRectangle, DrawMACCloseButton
from aui_utilities import DarkenBitmap, LightContrastColour
from aui_constants import *

optionActive = 2**14
""" Indicates that a pane is active and should display an active caption (if present). """

_ctypes = False

# Try to import winxptheme for ModernDockArt
if wx.Platform == "__WXMSW__":
    try:
        import ctypes
        import winxptheme
        _ctypes = True
    except ImportError:
        pass

# -- AuiDefaultDockArt class implementation --

class AuiDefaultDockArt(object):
    """
    Dock art provider code - a dock provider provides all drawing functionality to the AUI dock manager.
    This allows the dock manager to have a plugable look-and-feel.

    By default, a :class:`~lib.agw.aui.framemanager.AuiManager` uses an instance of this class called
    :class:`AuiDefaultDockArt` which provides bitmap art and a colour scheme that is adapted to the major
    platforms' look. You can either derive from that class to alter its behaviour or
    write a completely new dock art class.

    Call :meth:`AuiManager.SetArtProvider() <lib.agw.aui.framemanager.AuiManager.SetArtProvider>`
    to make use this new dock art.


    **Metric Ordinals**

    These are the possible pane dock art settings for :class:`AuiDefaultDockArt`:

    ================================================  ======================================
    Metric Ordinal Constant                           Description
    ================================================  ======================================
    ``AUI_DOCKART_SASH_SIZE``                         Customizes the sash size
    ``AUI_DOCKART_CAPTION_SIZE``                      Customizes the caption size
    ``AUI_DOCKART_GRIPPER_SIZE``                      Customizes the gripper size
    ``AUI_DOCKART_PANE_BORDER_SIZE``                  Customizes the pane border size
    ``AUI_DOCKART_PANE_BUTTON_SIZE``                  Customizes the pane button size
    ``AUI_DOCKART_BACKGROUND_COLOUR``                 Customizes the background colour
    ``AUI_DOCKART_BACKGROUND_GRADIENT_COLOUR``        Customizes the background gradient colour
    ``AUI_DOCKART_SASH_COLOUR``                       Customizes the sash colour
    ``AUI_DOCKART_ACTIVE_CAPTION_COLOUR``             Customizes the active caption colour
    ``AUI_DOCKART_ACTIVE_CAPTION_GRADIENT_COLOUR``    Customizes the active caption gradient colour
    ``AUI_DOCKART_INACTIVE_CAPTION_COLOUR``           Customizes the inactive caption colour
    ``AUI_DOCKART_INACTIVE_CAPTION_GRADIENT_COLOUR``  Customizes the inactive gradient caption colour
    ``AUI_DOCKART_ACTIVE_CAPTION_TEXT_COLOUR``        Customizes the active caption text colour
    ``AUI_DOCKART_INACTIVE_CAPTION_TEXT_COLOUR``      Customizes the inactive caption text colour
    ``AUI_DOCKART_BORDER_COLOUR``                     Customizes the border colour
    ``AUI_DOCKART_GRIPPER_COLOUR``                    Customizes the gripper colour
    ``AUI_DOCKART_CAPTION_FONT``                      Customizes the caption font
    ``AUI_DOCKART_GRADIENT_TYPE``                     Customizes the gradient type (no gradient, vertical or horizontal)
    ``AUI_DOCKART_DRAW_SASH_GRIP``                    Draw a sash grip on the sash
    ``AUI_DOCKART_HINT_WINDOW_COLOUR``                Customizes the hint window background colour (currently light blue)
    ================================================  ======================================


    **Gradient Types**

    These are the possible gradient dock art settings for :class:`AuiDefaultDockArt`:

    ============================================  ======================================
    Gradient Constant                             Description
    ============================================  ======================================
    ``AUI_GRADIENT_NONE``                         No gradient on the captions
    ``AUI_GRADIENT_VERTICAL``                     Vertical gradient on the captions
    ``AUI_GRADIENT_HORIZONTAL``                   Horizontal gradient on the captions
    ============================================  ======================================


    **Button States**

    These are the possible pane button / :class:`~lib.agw.aui.auibook.AuiNotebook` button /
    :class:`~lib.agw.aui.auibar.AuiToolBar` button states:

    ============================================  ======================================
    Button State Constant                         Description
    ============================================  ======================================
    ``AUI_BUTTON_STATE_NORMAL``                   Normal button state
    ``AUI_BUTTON_STATE_HOVER``                    Hovered button state
    ``AUI_BUTTON_STATE_PRESSED``                  Pressed button state
    ``AUI_BUTTON_STATE_DISABLED``                 Disabled button state
    ``AUI_BUTTON_STATE_HIDDEN``                   Hidden button state
    ``AUI_BUTTON_STATE_CHECKED``                  Checked button state
    ============================================  ======================================


    **Button Identifiers**

    These are the possible pane button / :class:`~lib.agw.aui.auibook.AuiNotebook` button /
    :class:`~lib.agw.aui.auibar.AuiToolBar` button identifiers:

    ============================================  ======================================
    Button Identifier                             Description
    ============================================  ======================================
    ``AUI_BUTTON_CLOSE``                          Shows a close button on the pane
    ``AUI_BUTTON_MAXIMIZE_RESTORE``               Shows a maximize/restore button on the pane
    ``AUI_BUTTON_MINIMIZE``                       Shows a minimize button on the pane
    ``AUI_BUTTON_PIN``                            Shows a pin button on the pane
    ``AUI_BUTTON_OPTIONS``                        Shows an option button on the pane (not implemented)
    ``AUI_BUTTON_WINDOWLIST``                     Shows a window list button on the pane (for :class:`~lib.agw.aui.auibook.AuiNotebook`)
    ``AUI_BUTTON_LEFT``                           Shows a left button on the pane (for :class:`~lib.agw.aui.auibook.AuiNotebook`)
    ``AUI_BUTTON_RIGHT``                          Shows a right button on the pane (for :class:`~lib.agw.aui.auibook.AuiNotebook`)
    ``AUI_BUTTON_UP``                             Shows an up button on the pane (not implemented)
    ``AUI_BUTTON_DOWN``                           Shows a down button on the pane (not implemented)
    ``AUI_BUTTON_CUSTOM1``                        Shows a custom button on the pane (not implemented)
    ``AUI_BUTTON_CUSTOM2``                        Shows a custom button on the pane (not implemented)
    ``AUI_BUTTON_CUSTOM3``                        Shows a custom button on the pane (not implemented)
    ============================================  ======================================

    """

    def __init__(self):
        """ Default class constructor. """

        self.Init()

        isMac = wx.Platform == "__WXMAC__"

        if isMac:
            self._caption_font = wx.SMALL_FONT
        else:
            self._caption_font = wx.Font(8, wx.DEFAULT, wx.NORMAL, wx.NORMAL, False)

        self.SetDefaultPaneBitmaps(isMac)
        self._restore_bitmap = wx.BitmapFromXPMData(restore_xpm)

        # default metric values
        self._sash_size = 4

        if isMac:
            # This really should be implemented in wx.SystemSettings
            # There is no way to do this that I am aware outside of using
            # the cocoa python bindings. 8 pixels looks correct on my system
            # so hard coding it for now.

            # How do I translate this?!? Not sure of the below implementation...
            # SInt32 height;
            # GetThemeMetric( kThemeMetricSmallPaneSplitterHeight , &height );
            # self._sash_size = height;

            self._sash_size = 8 # Carbon.Appearance.kThemeMetricPaneSplitterHeight

        elif wx.Platform == "__WXGTK__":
            self._sash_size = wx.RendererNative.Get().GetSplitterParams(wx.GetTopLevelWindows()[0]).widthSash

        else:
            self._sash_size = 4

        self._caption_size = 19
        self._border_size = 1
        self._button_size = 14
        self._gripper_size = 9
        self._gradient_type = AUI_GRADIENT_VERTICAL
        self._draw_sash = False


    def Init(self):
        """ Initializes the dock art. """

        self.SetDefaultColours()

        isMac = wx.Platform == "__WXMAC__"

        if isMac:
            self._active_caption_colour = wx.SystemSettings.GetColour(wx.SYS_COLOUR_HIGHLIGHT)
        else:
            self._active_caption_colour = wx.SystemSettings.GetColour(wx.SYS_COLOUR_ACTIVECAPTION)

        self._active_caption_gradient_colour = LightContrastColour(wx.SystemSettings.GetColour(wx.SYS_COLOUR_HIGHLIGHT))
        self._active_caption_text_colour = wx.SystemSettings.GetColour(wx.SYS_COLOUR_HIGHLIGHTTEXT)
        self._inactive_caption_text_colour = wx.BLACK


    def SetDefaultColours(self, base_colour=None):
        """
        Sets the default colours, which are calculated from the given base colour.

        :param `base_colour`: an instance of :class:`Colour`. If defaulted to ``None``, a colour
         is generated accordingly to the platform and theme.
        """

        if base_colour is None:
            base_colour = GetBaseColour()

        darker1_colour = StepColour(base_colour, 85)
        darker2_colour = StepColour(base_colour, 75)
        darker3_colour = StepColour(base_colour, 60)
        darker4_colour = StepColour(base_colour, 40)

        self._background_colour = base_colour
        self._background_gradient_colour = StepColour(base_colour, 180)

        self._inactive_caption_colour = darker1_colour
        self._inactive_caption_gradient_colour = StepColour(base_colour, 97)

        self._sash_brush = wx.Brush(base_colour)
        self._background_brush = wx.Brush(base_colour)
        self._border_pen = wx.Pen(darker2_colour)
        self._gripper_brush = wx.Brush(base_colour)
        self._gripper_pen1 = wx.Pen(darker4_colour)
        self._gripper_pen2 = wx.Pen(darker3_colour)
        self._gripper_pen3 = wx.WHITE_PEN

        self._hint_background_colour = colourHintBackground


    def GetMetric(self, id):
        """
        Gets the value of a certain setting.

        :param integer `id`: can be one of the size values in `Metric Ordinals`.
        """


        if id == AUI_DOCKART_SASH_SIZE:
            return self._sash_size
        elif id == AUI_DOCKART_CAPTION_SIZE:
            return self._caption_size
        elif id == AUI_DOCKART_GRIPPER_SIZE:
            return self._gripper_size
        elif id == AUI_DOCKART_PANE_BORDER_SIZE:
            return self._border_size
        elif id == AUI_DOCKART_PANE_BUTTON_SIZE:
            return self._button_size
        elif id == AUI_DOCKART_GRADIENT_TYPE:
            return self._gradient_type
        elif id == AUI_DOCKART_DRAW_SASH_GRIP:
            return self._draw_sash
        else:
            raise Exception("Invalid Metric Ordinal.")


    def SetMetric(self, id, new_val):
        """
        Sets the value of a certain setting using `new_val`

        :param integer `id`: can be one of the size values in `Metric Ordinals`;
        :param `new_val`: the new value of the setting.
        """

        if id == AUI_DOCKART_SASH_SIZE:
            self._sash_size = new_val
        elif id == AUI_DOCKART_CAPTION_SIZE:
            self._caption_size = new_val
        elif id == AUI_DOCKART_GRIPPER_SIZE:
            self._gripper_size = new_val
        elif id == AUI_DOCKART_PANE_BORDER_SIZE:
            self._border_size = new_val
        elif id == AUI_DOCKART_PANE_BUTTON_SIZE:
            self._button_size = new_val
        elif id == AUI_DOCKART_GRADIENT_TYPE:
            self._gradient_type = new_val
        elif id == AUI_DOCKART_DRAW_SASH_GRIP:
            self._draw_sash = new_val
        else:
            raise Exception("Invalid Metric Ordinal.")


    def GetColor(self, id):
        """
        Gets the colour of a certain setting.

        :param integer `id`: can be one of the colour values in `Metric Ordinals`.
        """

        if id == AUI_DOCKART_BACKGROUND_COLOUR:
            return self._background_brush.GetColour()
        elif id == AUI_DOCKART_BACKGROUND_GRADIENT_COLOUR:
            return self._background_gradient_colour
        elif id == AUI_DOCKART_SASH_COLOUR:
            return self._sash_brush.GetColour()
        elif id == AUI_DOCKART_INACTIVE_CAPTION_COLOUR:
            return self._inactive_caption_colour
        elif id == AUI_DOCKART_INACTIVE_CAPTION_GRADIENT_COLOUR:
            return self._inactive_caption_gradient_colour
        elif id == AUI_DOCKART_INACTIVE_CAPTION_TEXT_COLOUR:
            return self._inactive_caption_text_colour
        elif id == AUI_DOCKART_ACTIVE_CAPTION_COLOUR:
            return self._active_caption_colour
        elif id == AUI_DOCKART_ACTIVE_CAPTION_GRADIENT_COLOUR:
            return self._active_caption_gradient_colour
        elif id == AUI_DOCKART_ACTIVE_CAPTION_TEXT_COLOUR:
            return self._active_caption_text_colour
        elif id == AUI_DOCKART_BORDER_COLOUR:
            return self._border_pen.GetColour()
        elif id == AUI_DOCKART_GRIPPER_COLOUR:
            return self._gripper_brush.GetColour()
        elif id == AUI_DOCKART_HINT_WINDOW_COLOUR:
            return self._hint_background_colour
        else:
            raise Exception("Invalid Colour Ordinal.")


    def SetColor(self, id, colour):
        """
        Sets the colour of a certain setting.

        :param integer `id`: can be one of the colour values in `Metric Ordinals`;
        :param `colour`: the new value of the setting.
        :type `colour`: :class:`Colour` or tuple or integer
        """

        if isinstance(colour, basestring):
            colour = wx.NamedColour(colour)
        elif isinstance(colour, types.TupleType):
            colour = wx.Colour(*colour)
        elif isinstance(colour, types.IntType):
            colour = wx.ColourRGB(colour)

        if id == AUI_DOCKART_BACKGROUND_COLOUR:
            self._background_brush.SetColour(colour)
        elif id == AUI_DOCKART_BACKGROUND_GRADIENT_COLOUR:
            self._background_gradient_colour = colour
        elif id == AUI_DOCKART_SASH_COLOUR:
            self._sash_brush.SetColour(colour)
        elif id == AUI_DOCKART_INACTIVE_CAPTION_COLOUR:
            self._inactive_caption_colour = colour
            if not self._custom_pane_bitmaps and wx.Platform == "__WXMAC__":
                # No custom bitmaps for the pane close button
                # Change the MAC close bitmap colour
                self._inactive_close_bitmap = DrawMACCloseButton(wx.WHITE, colour)

        elif id == AUI_DOCKART_INACTIVE_CAPTION_GRADIENT_COLOUR:
            self._inactive_caption_gradient_colour = colour
        elif id == AUI_DOCKART_INACTIVE_CAPTION_TEXT_COLOUR:
            self._inactive_caption_text_colour = colour
        elif id == AUI_DOCKART_ACTIVE_CAPTION_COLOUR:
            self._active_caption_colour = colour
            if not self._custom_pane_bitmaps and wx.Platform == "__WXMAC__":
                # No custom bitmaps for the pane close button
                # Change the MAC close bitmap colour
                self._active_close_bitmap = DrawMACCloseButton(wx.WHITE, colour)

        elif id == AUI_DOCKART_ACTIVE_CAPTION_GRADIENT_COLOUR:
            self._active_caption_gradient_colour = colour
        elif id == AUI_DOCKART_ACTIVE_CAPTION_TEXT_COLOUR:
            self._active_caption_text_colour = colour
        elif id == AUI_DOCKART_BORDER_COLOUR:
            self._border_pen.SetColour(colour)
        elif id == AUI_DOCKART_GRIPPER_COLOUR:
            self._gripper_brush.SetColour(colour)
            self._gripper_pen1.SetColour(StepColour(colour, 40))
            self._gripper_pen2.SetColour(StepColour(colour, 60))
        elif id == AUI_DOCKART_HINT_WINDOW_COLOUR:
            self._hint_background_colour = colour
        else:
            raise Exception("Invalid Colour Ordinal.")


    GetColour = GetColor
    SetColour = SetColor

    def SetFont(self, id, font):
        """
        Sets a font setting.

        :param integer `id`: must be ``AUI_DOCKART_CAPTION_FONT``;
        :param `font`: an instance of :class:`Font`.
        """

        if id == AUI_DOCKART_CAPTION_FONT:
            self._caption_font = font


    def GetFont(self, id):
        """
        Gets a font setting.

        :param integer `id`: must be ``AUI_DOCKART_CAPTION_FONT``, otherwise :class:`NullFont` is returned.
        """

        if id == AUI_DOCKART_CAPTION_FONT:
            return self._caption_font

        return wx.NullFont


    def DrawSash(self, dc, window, orient, rect):
        """
        Draws a sash between two windows.

        :param `dc`: a :class:`DC` device context;
        :param `window`: an instance of :class:`Window`;
        :param integer `orient`: the sash orientation;
        :param Rect `rect`: the sash rectangle.
        """

        # AG: How do we make this work?!?
        # RendererNative does not use the sash_brush chosen by the user
        # and the rect.GetSize() is ignored as the sash is always drawn
        # 3 pixel wide
        # wx.RendererNative.Get().DrawSplitterSash(window, dc, rect.GetSize(), pos, orient)

        dc.SetPen(wx.TRANSPARENT_PEN)
        dc.SetBrush(self._sash_brush)
        dc.DrawRectangle(rect.x, rect.y, rect.width, rect.height)

        draw_sash = self.GetMetric(AUI_DOCKART_DRAW_SASH_GRIP)
        if draw_sash:
            self.DrawSashGripper(dc, orient, rect)


    def DrawBackground(self, dc, window, orient, rect):
        """
        Draws a background.

        :param `dc`: a :class:`DC` device context;
        :param `window`: an instance of :class:`Window`;
        :param integer `orient`: the gradient (if any) orientation;
        :param Rect `rect`: the background rectangle.
        """

        dc.SetPen(wx.TRANSPARENT_PEN)
        if wx.Platform == "__WXMAC__":
            # we have to clear first, otherwise we are drawing a light striped pattern
            # over an already darker striped background
            dc.SetBrush(wx.WHITE_BRUSH)
            dc.DrawRectangle(rect.x, rect.y, rect.width, rect.height)

        DrawGradientRectangle(dc, rect, self._background_brush.GetColour(),
                              self._background_gradient_colour,
                              AUI_GRADIENT_HORIZONTAL, rect.x, 700)


    def DrawBorder(self, dc, window, rect, pane):
        """
        Draws the pane border.

        :param `dc`: a :class:`DC` device context;
        :param `window`: an instance of :class:`Window`;
        :param Rect `rect`: the border rectangle;
        :param `pane`: the pane for which the border is drawn.
        """

        drect = wx.Rect(*rect)

        dc.SetPen(self._border_pen)
        dc.SetBrush(wx.TRANSPARENT_BRUSH)

        border_width = self.GetMetric(AUI_DOCKART_PANE_BORDER_SIZE)

        if pane.IsToolbar():

            for ii in xrange(0, border_width):

                dc.SetPen(wx.WHITE_PEN)
                dc.DrawLine(drect.x, drect.y, drect.x+drect.width, drect.y)
                dc.DrawLine(drect.x, drect.y, drect.x, drect.y+drect.height)
                dc.SetPen(self._border_pen)
                dc.DrawLine(drect.x, drect.y+drect.height-1,
                            drect.x+drect.width, drect.y+drect.height-1)
                dc.DrawLine(drect.x+drect.width-1, drect.y,
                            drect.x+drect.width-1, drect.y+drect.height)
                drect.Deflate(1, 1)

        else:

            for ii in xrange(0, border_width):

                dc.DrawRectangle(drect.x, drect.y, drect.width, drect.height)
                drect.Deflate(1, 1)


    def DrawCaptionBackground(self, dc, rect, pane):
        """
        Draws the text caption background in the pane.

        :param `dc`: a :class:`DC` device context;
        :param Rect `rect`: the text caption rectangle;
        :param `pane`: the pane for which the text background is drawn.
        """

        active = pane.state & optionActive

        if self._gradient_type == AUI_GRADIENT_NONE:
            if active:
                dc.SetBrush(wx.Brush(self._active_caption_colour))
            else:
                dc.SetBrush(wx.Brush(self._inactive_caption_colour))

            dc.DrawRectangle(rect.x, rect.y, rect.width, rect.height)

        else:

            switch_gradient = pane.HasCaptionLeft()
            gradient_type = self._gradient_type
            if switch_gradient:
                gradient_type = (self._gradient_type == AUI_GRADIENT_HORIZONTAL and [AUI_GRADIENT_VERTICAL] or \
                                 [AUI_GRADIENT_HORIZONTAL])[0]

            if active:
                if wx.Platform == "__WXMAC__":
                    DrawGradientRectangle(dc, rect, self._active_caption_colour,
                                          self._active_caption_gradient_colour,
                                          gradient_type)
                else:
                    DrawGradientRectangle(dc, rect, self._active_caption_gradient_colour,
                                          self._active_caption_colour,
                                          gradient_type)
            else:
                if wx.Platform == "__WXMAC__":
                    DrawGradientRectangle(dc, rect, self._inactive_caption_gradient_colour,
                                          self._inactive_caption_colour,
                                          gradient_type)
                else:
                    DrawGradientRectangle(dc, rect, self._inactive_caption_colour,
                                          self._inactive_caption_gradient_colour,
                                          gradient_type)


    def DrawIcon(self, dc, rect, pane):
        """
        Draws the icon in the pane caption area.

        :param `dc`: a :class:`DC` device context;
        :param Rect `rect`: the pane caption rectangle;
        :param `pane`: the pane for which the icon is drawn.
        """

        # Draw the icon centered vertically
        if pane.icon.Ok():
            if pane.HasCaptionLeft():
                bmp = wx.ImageFromBitmap(pane.icon).Rotate90(clockwise=False)
                dc.DrawBitmap(bmp.ConvertToBitmap(), rect.x+(rect.width-pane.icon.GetWidth())/2, rect.y+rect.height-2-pane.icon.GetHeight(), True)
            else:
                dc.DrawBitmap(pane.icon, rect.x+2, rect.y+(rect.height-pane.icon.GetHeight())/2, True)


    def DrawCaption(self, dc, window, text, rect, pane):
        """
        Draws the text in the pane caption.

        :param `dc`: a :class:`DC` device context;
        :param `window`: an instance of :class:`Window`;
        :param string `text`: the text to be displayed;
        :param Rect `rect`: the pane caption rectangle;
        :param `pane`: the pane for which the text is drawn.
        """

        dc.SetPen(wx.TRANSPARENT_PEN)
        dc.SetFont(self._caption_font)

        self.DrawCaptionBackground(dc, rect, pane)

        if pane.state & optionActive:
            dc.SetTextForeground(self._active_caption_text_colour)
        else:
            dc.SetTextForeground(self._inactive_caption_text_colour)

        w, h = dc.GetTextExtent("ABCDEFHXfgkj")

        clip_rect = wx.Rect(*rect)
        btns = pane.CountButtons()

        captionLeft = pane.HasCaptionLeft()
        variable = (captionLeft and [rect.height] or [rect.width])[0]

        variable -= 3      # text offset
        variable -= 2      # button padding

        caption_offset = 0
        if pane.icon:
            if captionLeft:
                caption_offset += pane.icon.GetHeight() + 3
            else:
                caption_offset += pane.icon.GetWidth() + 3

            self.DrawIcon(dc, rect, pane)

        variable -= caption_offset
        variable -= btns*(self._button_size + self._border_size)
        draw_text = ChopText(dc, text, variable)

        if captionLeft:
            dc.DrawRotatedText(draw_text, rect.x+(rect.width/2)-(h/2)-1, rect.y+rect.height-3-caption_offset, 90)
        else:
            dc.DrawText(draw_text, rect.x+3+caption_offset, rect.y+(rect.height/2)-(h/2)-1)


    def RequestUserAttention(self, dc, window, text, rect, pane):
        """
        Requests the user attention by intermittently highlighting the pane caption.

        :param `dc`: a :class:`DC` device context;
        :param `window`: an instance of :class:`Window`;
        :param string `text`: the text to be displayed;
        :param Rect `rect`: the pane caption rectangle;
        :param `pane`: the pane for which we want to attract the user attention.
        """

        state = pane.state
        pane.state &= ~optionActive

        for indx in xrange(6):
            active = (indx%2 == 0 and [True] or [False])[0]
            if active:
                pane.state |= optionActive
            else:
                pane.state &= ~optionActive

            self.DrawCaptionBackground(dc, rect, pane)
            self.DrawCaption(dc, window, text, rect, pane)
            wx.SafeYield()
            wx.MilliSleep(350)

        pane.state = state


    def DrawGripper(self, dc, window, rect, pane):
        """
        Draws a gripper on the pane.

        :param `dc`: a :class:`DC` device context;
        :param `window`: an instance of :class:`Window`;
        :param Rect `rect`: the pane caption rectangle;
        :param `pane`: the pane for which the gripper is drawn.
        """

        dc.SetPen(wx.TRANSPARENT_PEN)
        dc.SetBrush(self._gripper_brush)

        dc.DrawRectangle(rect.x, rect.y, rect.width, rect.height)

        if not pane.HasGripperTop():
            y = 4
            while 1:
                dc.SetPen(self._gripper_pen1)
                dc.DrawPoint(rect.x+3, rect.y+y)
                dc.SetPen(self._gripper_pen2)
                dc.DrawPoint(rect.x+3, rect.y+y+1)
                dc.DrawPoint(rect.x+4, rect.y+y)
                dc.SetPen(self._gripper_pen3)
                dc.DrawPoint(rect.x+5, rect.y+y+1)
                dc.DrawPoint(rect.x+5, rect.y+y+2)
                dc.DrawPoint(rect.x+4, rect.y+y+2)
                y = y + 4
                if y > rect.GetHeight() - 4:
                    break
        else:
            x = 4
            while 1:
                dc.SetPen(self._gripper_pen1)
                dc.DrawPoint(rect.x+x, rect.y+3)
                dc.SetPen(self._gripper_pen2)
                dc.DrawPoint(rect.x+x+1, rect.y+3)
                dc.DrawPoint(rect.x+x, rect.y+4)
                dc.SetPen(self._gripper_pen3)
                dc.DrawPoint(rect.x+x+1, rect.y+5)
                dc.DrawPoint(rect.x+x+2, rect.y+5)
                dc.DrawPoint(rect.x+x+2, rect.y+4)
                x = x + 4
                if x > rect.GetWidth() - 4:
                    break


    def DrawPaneButton(self, dc, window, button, button_state, _rect, pane):
        """
        Draws a pane button in the pane caption area.

        :param `dc`: a :class:`DC` device context;
        :param `window`: an instance of :class:`Window`;
        :param integer `button`: the button to be drawn;
        :param integer `button_state`: the pane button state;
        :param Rect `_rect`: the pane caption rectangle;
        :param `pane`: the pane for which the button is drawn.
        """

        if not pane:
            return

        if button == AUI_BUTTON_CLOSE:
            if pane.state & optionActive:
                bmp = self._active_close_bitmap
            else:
                bmp = self._inactive_close_bitmap

        elif button == AUI_BUTTON_PIN:
            if pane.state & optionActive:
                bmp = self._active_pin_bitmap
            else:
                bmp = self._inactive_pin_bitmap

        elif button == AUI_BUTTON_MAXIMIZE_RESTORE:
            if pane.IsMaximized():
                if pane.state & optionActive:
                    bmp = self._active_restore_bitmap
                else:
                    bmp = self._inactive_restore_bitmap
            else:
                if pane.state & optionActive:
                    bmp = self._active_maximize_bitmap
                else:
                    bmp = self._inactive_maximize_bitmap

        elif button == AUI_BUTTON_MINIMIZE:
            if pane.state & optionActive:
                bmp = self._active_minimize_bitmap
            else:
                bmp = self._inactive_minimize_bitmap

        isVertical = pane.HasCaptionLeft()

        rect = wx.Rect(*_rect)

        if isVertical:
            old_x = rect.x
            rect.x = rect.x + (rect.width/2) - (bmp.GetWidth()/2)
            rect.width = old_x + rect.width - rect.x - 1
        else:
            old_y = rect.y
            rect.y = rect.y + (rect.height/2) - (bmp.GetHeight()/2)
            rect.height = old_y + rect.height - rect.y - 1

        if button_state == AUI_BUTTON_STATE_PRESSED:
            rect.x += 1
            rect.y += 1

        if button_state in [AUI_BUTTON_STATE_HOVER, AUI_BUTTON_STATE_PRESSED]:

            if pane.state & optionActive:

                dc.SetBrush(wx.Brush(StepColour(self._active_caption_colour, 120)))
                dc.SetPen(wx.Pen(StepColour(self._active_caption_colour, 70)))

            else:

                dc.SetBrush(wx.Brush(StepColour(self._inactive_caption_colour, 120)))
                dc.SetPen(wx.Pen(StepColour(self._inactive_caption_colour, 70)))

            if wx.Platform != "__WXMAC__":
                # draw the background behind the button
                dc.DrawRectangle(rect.x, rect.y, 15, 15)
            else:
                # Darker the bitmap a bit
                bmp = DarkenBitmap(bmp, self._active_caption_colour, StepColour(self._active_caption_colour, 110))

        if isVertical:
            bmp = wx.ImageFromBitmap(bmp).Rotate90(clockwise=False).ConvertToBitmap()

        # draw the button itself
        dc.DrawBitmap(bmp, rect.x, rect.y, True)


    def DrawSashGripper(self, dc, orient, rect):
        """
        Draws a sash gripper on a sash between two windows.

        :param `dc`: a :class:`DC` device context;
        :param integer `orient`: the sash orientation;
        :param Rect `rect`: the sash rectangle.
        """

        dc.SetBrush(self._gripper_brush)

        if orient == wx.HORIZONTAL:  # horizontal sash

            x = rect.x + int((1.0/4.0)*rect.width)
            xend = rect.x + int((3.0/4.0)*rect.width)
            y = rect.y + (rect.height/2) - 1

            while 1:
                dc.SetPen(self._gripper_pen3)
                dc.DrawRectangle(x, y, 2, 2)
                dc.SetPen(self._gripper_pen2)
                dc.DrawPoint(x+1, y+1)
                x = x + 5

                if x >= xend:
                    break

        else:

            y = rect.y + int((1.0/4.0)*rect.height)
            yend = rect.y + int((3.0/4.0)*rect.height)
            x = rect.x + (rect.width/2) - 1

            while 1:
                dc.SetPen(self._gripper_pen3)
                dc.DrawRectangle(x, y, 2, 2)
                dc.SetPen(self._gripper_pen2)
                dc.DrawPoint(x+1, y+1)
                y = y + 5

                if y >= yend:
                    break


    def SetDefaultPaneBitmaps(self, isMac):
        """
        Assigns the default pane bitmaps.

        :param bool `isMac`: whether we are on wxMAC or not.
        """

        if isMac:
            self._inactive_close_bitmap = DrawMACCloseButton(wx.WHITE, self._inactive_caption_colour)
            self._active_close_bitmap = DrawMACCloseButton(wx.WHITE, self._active_caption_colour)
        else:
            self._inactive_close_bitmap = BitmapFromBits(close_bits, 16, 16, self._inactive_caption_text_colour)
            self._active_close_bitmap = BitmapFromBits(close_bits, 16, 16, self._active_caption_text_colour)

        if isMac:
            self._inactive_maximize_bitmap = BitmapFromBits(max_bits, 16, 16, wx.WHITE)
            self._active_maximize_bitmap = BitmapFromBits(max_bits, 16, 16, wx.WHITE)
        else:
            self._inactive_maximize_bitmap = BitmapFromBits(max_bits, 16, 16, self._inactive_caption_text_colour)
            self._active_maximize_bitmap = BitmapFromBits(max_bits, 16, 16, self._active_caption_text_colour)

        if isMac:
            self._inactive_restore_bitmap = BitmapFromBits(restore_bits, 16, 16, wx.WHITE)
            self._active_restore_bitmap = BitmapFromBits(restore_bits, 16, 16, wx.WHITE)
        else:
            self._inactive_restore_bitmap = BitmapFromBits(restore_bits, 16, 16, self._inactive_caption_text_colour)
            self._active_restore_bitmap = BitmapFromBits(restore_bits, 16, 16, self._active_caption_text_colour)

        if isMac:
            self._inactive_minimize_bitmap = BitmapFromBits(minimize_bits, 16, 16, wx.WHITE)
            self._active_minimize_bitmap = BitmapFromBits(minimize_bits, 16, 16, wx.WHITE)
        else:
            self._inactive_minimize_bitmap = BitmapFromBits(minimize_bits, 16, 16, self._inactive_caption_text_colour)
            self._active_minimize_bitmap = BitmapFromBits(minimize_bits, 16, 16, self._active_caption_text_colour)

        self._inactive_pin_bitmap = BitmapFromBits(pin_bits, 16, 16, self._inactive_caption_text_colour)
        self._active_pin_bitmap = BitmapFromBits(pin_bits, 16, 16, self._active_caption_text_colour)

        self._custom_pane_bitmaps = False


    def SetCustomPaneBitmap(self, bmp, button, active, maximize=False):
        """
        Sets a custom button bitmap for the pane button.

        :param Bitmap `bmp`: the actual bitmap to set;
        :param integer `button`: the button identifier;
        :param bool `active`: whether it is the bitmap for the active button or not;
        :param bool `maximize`: used to distinguish between the maximize and restore bitmaps.
        """

        if bmp.GetWidth() > 16 or bmp.GetHeight() > 16:
            raise Exception("The input bitmap is too big")

        if button == AUI_BUTTON_CLOSE:
            if active:
                self._active_close_bitmap = bmp
            else:
                self._inactive_close_bitmap = bmp

            if wx.Platform == "__WXMAC__":
                self._custom_pane_bitmaps = True

        elif button == AUI_BUTTON_PIN:
            if active:
                self._active_pin_bitmap = bmp
            else:
                self._inactive_pin_bitmap = bmp

        elif button == AUI_BUTTON_MAXIMIZE_RESTORE:
            if maximize:
                if active:
                    self._active_maximize_bitmap = bmp
                else:
                    self._inactive_maximize_bitmap = bmp
            else:
                if active:
                    self._active_restore_bitmap = bmp
                else:
                    self._inactive_restore_bitmap = bmp

        elif button == AUI_BUTTON_MINIMIZE:
            if active:
                self._active_minimize_bitmap = bmp
            else:
                self._inactive_minimize_bitmap = bmp


if _ctypes:
    class RECT(ctypes.Structure):
        """ Used to handle :class:`ModernDockArt` on Windows XP/Vista/7. """
        _fields_ = [('left', ctypes.c_ulong),('top', ctypes.c_ulong),('right', ctypes.c_ulong),('bottom', ctypes.c_ulong)]

        def dump(self):
            """ Dumps `self` as a :class:`Rect`. """
            return map(int, (self.left, self.top, self.right, self.bottom))


    class SIZE(ctypes.Structure):
        """ Used to handle :class:`ModernDockArt` on Windows XP/Vista/7. """
        _fields_ = [('x', ctypes.c_long),('y', ctypes.c_long)]


class ModernDockArt(AuiDefaultDockArt):
    """
    ModernDockArt is a custom `AuiDockArt` class, that implements a look similar to Firefox and other recents applications.

    Is uses the `winxptheme <http://sourceforge.net/projects/pywin32/>`_ module and
    XP themes whenever possible, so it should look good even if the user has a custom theme.

    :note: This dock art is Windows only and will only work if you have installed
     Mark Hammond's `pywin32` module (http://sourceforge.net/projects/pywin32/).
    """

    def __init__(self, win):
        """
        Default class constructor.

        :param Window `win`: the window managed by :class:`~lib.agw.aui.framemanager.AuiManager`.
        """

        AuiDefaultDockArt.__init__(self)

        self.win = win

        # Get the size of a small close button (themed)
        hwnd = self.win.GetHandle()
        self.usingTheme = False

        if _ctypes:
            self.hTheme1 = winxptheme.OpenThemeData(hwnd, "Window")
            self.usingTheme = True

        if not self.hTheme1:
            self.usingTheme = False

        self._button_size = 13

        self._button_border_size = 3
        self._caption_text_indent = 6
        self._caption_size = 22

        # We only highlight the active pane with the caption text being in bold.
        # So we do not want a special colour for active elements.
        self._active_close_bitmap = self._inactive_close_bitmap

        self.Init()


    def Init(self):
        """ Initializes the dock art. """

        AuiDefaultDockArt.Init(self)

        self._active_caption_colour = self._inactive_caption_colour
        self._active_caption_text_colour = wx.SystemSettings.GetColour(wx.SYS_COLOUR_CAPTIONTEXT)
        self._inactive_caption_text_colour = self._active_caption_text_colour


    def DrawCaption(self, dc, window, text, rect, pane):
        """
        Draws the text in the pane caption.

        :param `dc`: a :class:`DC` device context;
        :param `window`: an instance of :class:`Window`;
        :param string `text`: the text to be displayed;
        :param Rect `rect`: the pane caption rectangle;
        :param `pane`: the pane for which the text is drawn.
        """

        dc.SetPen(wx.TRANSPARENT_PEN)
        self.DrawCaptionBackground(dc, rect, pane)

        active = ((pane.state & optionActive) and [True] or [False])[0]

        self._caption_font.SetWeight(wx.FONTWEIGHT_BOLD)
        dc.SetFont(self._caption_font)

        if active:
            dc.SetTextForeground(self._active_caption_text_colour)
        else:
            dc.SetTextForeground(self._inactive_caption_text_colour)

        w, h = dc.GetTextExtent("ABCDEFHXfgkj")

        clip_rect = wx.Rect(*rect)
        btns = pane.CountButtons()

        captionLeft = pane.HasCaptionLeft()
        variable = (captionLeft and [rect.height] or [rect.width])[0]

        variable -= 3      # text offset
        variable -= 2      # button padding

        caption_offset = 0
        if pane.icon:
            if captionLeft:
                caption_offset += pane.icon.GetHeight() + 3
            else:
                caption_offset += pane.icon.GetWidth() + 3

            self.DrawIcon(dc, rect, pane)

        diff = -2
        if self.usingTheme:
            diff = -1

        variable -= caption_offset
        variable -= btns*(self._button_size + self._button_border_size)
        draw_text = ChopText(dc, text, variable)

        if captionLeft:
            dc.DrawRotatedText(draw_text, rect.x+(rect.width/2)-(h/2)-diff, rect.y+rect.height-3-caption_offset, 90)
        else:
            dc.DrawText(draw_text, rect.x+3+caption_offset, rect.y+(rect.height/2)-(h/2)-diff)


    def DrawCaptionBackground(self, dc, rect, pane):
        """
        Draws the text caption background in the pane.

        :param `dc`: a :class:`DC` device context;
        :param Rect `rect`: the text caption rectangle;
        :param `pane`: the pane for which we are drawing the caption background.
        """

        dc.SetBrush(self._background_brush)
        dc.DrawRectangle(rect.x, rect.y, rect.width, rect.height)

        active = ((pane.state & optionActive) and [True] or [False])[0]

        if self.usingTheme:

            rectangle = wx.Rect()

            rc = RECT(rectangle.x, rectangle.y, rectangle.width, rectangle.height)

            # If rect x/y values are negative rc.right/bottom values will overflow and winxptheme.DrawThemeBackground
            # will raise a TypeError. Ensure they are never negative.
            rect.x = max(0, rect.x)
            rect.y = max(0, rect.y)

            rc.top = rect.x
            rc.left = rect.y
            rc.right = rect.x + rect.width
            rc.bottom = rect.y + rect.height

            if active:
                winxptheme.DrawThemeBackground(self.hTheme1, dc.GetHDC(), 5, 1, (rc.top, rc.left, rc.right, rc.bottom), None)
            else:
                winxptheme.DrawThemeBackground(self.hTheme1, dc.GetHDC(), 5, 2, (rc.top, rc.left, rc.right, rc.bottom), None)

        else:

            AuiDefaultDockArt.DrawCaptionBackground(self, dc, rect, pane)


    def RequestUserAttention(self, dc, window, text, rect, pane):
        """
        Requests the user attention by intermittently highlighting the pane caption.

        :param `dc`: a :class:`DC` device context;
        :param `window`: an instance of :class:`Window`;
        :param string `text`: the text to be displayed;
        :param Rect `rect`: the pane caption rectangle;
        :param `pane`: the pane for which the text is drawn.
        """

        state = pane.state
        pane.state &= ~optionActive

        for indx in xrange(6):
            active = (indx%2 == 0 and [True] or [False])[0]
            if active:
                pane.state |= optionActive
            else:
                pane.state &= ~optionActive

            self.DrawCaptionBackground(dc, rect, pane)
            self.DrawCaption(dc, window, text, rect, pane)
            wx.SafeYield()
            wx.MilliSleep(350)

        pane.state = state


    def DrawPaneButton(self, dc, window, button, button_state, rect, pane):
        """
        Draws a pane button in the pane caption area.

        :param `dc`: a :class:`DC` device context;
        :param `window`: an instance of :class:`Window`;
        :param integer `button`: the button to be drawn;
        :param integer `button_state`: the pane button state;
        :param Rect `rect`: the pane caption rectangle;
        :param `pane`: the pane for which the button is drawn.
        """

        if self.usingTheme:

            hTheme = self.hTheme1

            # Get the real button position (compensating for borders)
            drect = wx.Rect(rect.x, rect.y, self._button_size, self._button_size)

            # Draw the themed close button
            rc = RECT(0, 0, 0, 0)
            if pane.HasCaptionLeft():
                rc.top = rect.x + self._button_border_size
                rc.left = int(rect.y + 1.5*self._button_border_size)
                rc.right = rect.x + self._button_size + self._button_border_size
                rc.bottom = int(rect.y + self._button_size + 1.5*self._button_border_size)
            else:
                rc.top = rect.x - self._button_border_size
                rc.left = int(rect.y + 1.5*self._button_border_size)
                rc.right = rect.x + self._button_size- self._button_border_size
                rc.bottom = int(rect.y + self._button_size + 1.5*self._button_border_size)

            if button == AUI_BUTTON_CLOSE:
                btntype = 19

            elif button == AUI_BUTTON_PIN:
                btntype = 23

            elif button == AUI_BUTTON_MAXIMIZE_RESTORE:
                if not pane.IsMaximized():
                    btntype = 17
                else:
                    btntype = 21
            else:
                btntype = 15

            state = 4 # CBS_DISABLED

            if pane.state & optionActive:

                if button_state == AUI_BUTTON_STATE_NORMAL:
                    state = 1 # CBS_NORMAL

                elif button_state == AUI_BUTTON_STATE_HOVER:
                    state = 2 # CBS_HOT

                elif button_state == AUI_BUTTON_STATE_PRESSED:
                    state = 3 # CBS_PUSHED

                else:
                    raise Exception("ERROR: Unknown State.")

            else: # inactive pane

                if button_state == AUI_BUTTON_STATE_NORMAL:
                    state = 5 # CBS_NORMAL

                elif button_state == AUI_BUTTON_STATE_HOVER:
                    state = 6 # CBS_HOT

                elif button_state == AUI_BUTTON_STATE_PRESSED:
                    state = 7 # CBS_PUSHED

                else:
                    raise Exception("ERROR: Unknown State.")

            try:
                winxptheme.DrawThemeBackground(hTheme, dc.GetHDC(), btntype, state, (rc.top, rc.left, rc.right, rc.bottom), None)
            except TypeError:
                return

        else:

            # Fallback to default closebutton if themes are not enabled
            rect2 = wx.Rect(rect.x-4, rect.y+2, rect.width, rect.height)
            AuiDefaultDockArt.DrawPaneButton(self, dc, window, button, button_state, rect2, pane)


########NEW FILE########
__FILENAME__ = framemanager
# --------------------------------------------------------------------------- #
# AUI Library wxPython IMPLEMENTATION
#
# Original C++ Code From Kirix (wxAUI). You Can Find It At:
#
#    License: wxWidgets license
#
# http:#www.kirix.com/en/community/opensource/wxaui/about_wxaui.html
#
# Current wxAUI Version Tracked: wxWidgets 2.9.4 SVN HEAD
#
#
# Python Code By:
#
# Andrea Gavana, @ 23 Dec 2005
# Latest Revision: 25 Apr 2012, 21.00 GMT
#
# For All Kind Of Problems, Requests Of Enhancements And Bug Reports, Please
# Write To Me At:
#
# andrea.gavana@gmail.com
# andrea.gavana@maerskoil.com
#
# Or, Obviously, To The wxPython Mailing List!!!
#
# End Of Comments
# --------------------------------------------------------------------------- #

"""
Description
===========

`framemanager.py` is the central module of the AUI class framework.

:class:`AuiManager` manages the panes associated with it for a particular :class:`Frame`, using
a pane's :class:`AuiPaneInfo` information to determine each pane's docking and floating
behavior. AuiManager uses wxPython' sizer mechanism to plan the layout of each frame.
It uses a replaceable dock art class to do all drawing, so all drawing is localized
in one area, and may be customized depending on an application's specific needs.

AuiManager works as follows: the programmer adds panes to the class, or makes
changes to existing pane properties (dock position, floating state, show state, etc...).
To apply these changes, AuiManager's :meth:`AuiManager.Update() <AuiManager.Update>` function is called. This batch
processing can be used to avoid flicker, by modifying more than one pane at a time,
and then "committing" all of the changes at once by calling `Update()`.

Panes can be added quite easily::

    text1 = wx.TextCtrl(self, -1)
    text2 = wx.TextCtrl(self, -1)
    self._mgr.AddPane(text1, AuiPaneInfo().Left().Caption("Pane Number One"))
    self._mgr.AddPane(text2, AuiPaneInfo().Bottom().Caption("Pane Number Two"))

    self._mgr.Update()


Later on, the positions can be modified easily. The following will float an
existing pane in a tool window::

    self._mgr.GetPane(text1).Float()


Layers, Rows and Directions, Positions
======================================

Inside AUI, the docking layout is figured out by checking several pane parameters.
Four of these are important for determining where a pane will end up.

**Direction** - Each docked pane has a direction, `Top`, `Bottom`, `Left`, `Right`, or `Center`.
This is fairly self-explanatory. The pane will be placed in the location specified
by this variable.

**Position** - More than one pane can be placed inside of a "dock". Imagine two panes
being docked on the left side of a window. One pane can be placed over another.
In proportionally managed docks, the pane position indicates it's sequential position,
starting with zero. So, in our scenario with two panes docked on the left side, the
top pane in the dock would have position 0, and the second one would occupy position 1.

**Row** - A row can allow for two docks to be placed next to each other. One of the most
common places for this to happen is in the toolbar. Multiple toolbar rows are allowed,
the first row being in row 0, and the second in row 1. Rows can also be used on
vertically docked panes.

**Layer** - A layer is akin to an onion. Layer 0 is the very center of the managed pane.
Thus, if a pane is in layer 0, it will be closest to the center window (also sometimes
known as the "content window"). Increasing layers "swallow up" all layers of a lower
value. This can look very similar to multiple rows, but is different because all panes
in a lower level yield to panes in higher levels. The best way to understand layers
is by running the AUI sample (`AUI.py`).
"""

__author__ = "Andrea Gavana <andrea.gavana@gmail.com>"
__date__ = "31 March 2009"


import wx
import time
import types
import warnings

import auibar
import auibook
import tabmdi
import dockart
import tabart

from aui_utilities import Clip, PaneCreateStippleBitmap, GetDockingImage, GetSlidingPoints

from aui_constants import *

# Define this as a translation function
_ = wx.GetTranslation

_winxptheme = False
if wx.Platform == "__WXMSW__":
    try:
        import winxptheme
        _winxptheme = True
    except ImportError:
        pass

# wxPython version string
_VERSION_STRING = wx.VERSION_STRING

# AUI Events
wxEVT_AUI_PANE_BUTTON = wx.NewEventType()
wxEVT_AUI_PANE_CLOSE = wx.NewEventType()
wxEVT_AUI_PANE_MAXIMIZE = wx.NewEventType()
wxEVT_AUI_PANE_RESTORE = wx.NewEventType()
wxEVT_AUI_RENDER = wx.NewEventType()
wxEVT_AUI_FIND_MANAGER = wx.NewEventType()
wxEVT_AUI_PANE_MINIMIZE = wx.NewEventType()
wxEVT_AUI_PANE_MIN_RESTORE = wx.NewEventType()
wxEVT_AUI_PANE_FLOATING = wx.NewEventType()
wxEVT_AUI_PANE_FLOATED = wx.NewEventType()
wxEVT_AUI_PANE_DOCKING = wx.NewEventType()
wxEVT_AUI_PANE_DOCKED = wx.NewEventType()
wxEVT_AUI_PANE_ACTIVATED = wx.NewEventType()
wxEVT_AUI_PERSPECTIVE_CHANGED = wx.NewEventType()

EVT_AUI_PANE_BUTTON = wx.PyEventBinder(wxEVT_AUI_PANE_BUTTON, 0)
""" Fires an event when the user left-clicks on a pane button. """
EVT_AUI_PANE_CLOSE = wx.PyEventBinder(wxEVT_AUI_PANE_CLOSE, 0)
""" A pane in `AuiManager` has been closed. """
EVT_AUI_PANE_MAXIMIZE = wx.PyEventBinder(wxEVT_AUI_PANE_MAXIMIZE, 0)
""" A pane in `AuiManager` has been maximized. """
EVT_AUI_PANE_RESTORE = wx.PyEventBinder(wxEVT_AUI_PANE_RESTORE, 0)
""" A pane in `AuiManager` has been restored from a maximized state. """
EVT_AUI_RENDER = wx.PyEventBinder(wxEVT_AUI_RENDER, 0)
""" Fires an event every time the AUI frame is being repainted. """
EVT_AUI_FIND_MANAGER = wx.PyEventBinder(wxEVT_AUI_FIND_MANAGER, 0)
""" Used to find which AUI manager is controlling a certain pane. """
EVT_AUI_PANE_MINIMIZE = wx.PyEventBinder(wxEVT_AUI_PANE_MINIMIZE, 0)
""" A pane in `AuiManager` has been minimized. """
EVT_AUI_PANE_MIN_RESTORE = wx.PyEventBinder(wxEVT_AUI_PANE_MIN_RESTORE, 0)
""" A pane in `AuiManager` has been restored from a minimized state. """
EVT_AUI_PANE_FLOATING = wx.PyEventBinder(wxEVT_AUI_PANE_FLOATING, 0)
""" A pane in `AuiManager` is about to be floated. """
EVT_AUI_PANE_FLOATED = wx.PyEventBinder(wxEVT_AUI_PANE_FLOATED, 0)
""" A pane in `AuiManager` has been floated. """
EVT_AUI_PANE_DOCKING = wx.PyEventBinder(wxEVT_AUI_PANE_DOCKING, 0)
""" A pane in `AuiManager` is about to be docked. """
EVT_AUI_PANE_DOCKED = wx.PyEventBinder(wxEVT_AUI_PANE_DOCKED, 0)
""" A pane in `AuiManager` has been docked. """
EVT_AUI_PANE_ACTIVATED = wx.PyEventBinder(wxEVT_AUI_PANE_ACTIVATED, 0)
""" A pane in `AuiManager` has been activated. """
EVT_AUI_PERSPECTIVE_CHANGED = wx.PyEventBinder(wxEVT_AUI_PERSPECTIVE_CHANGED, 0)
""" The layout in `AuiManager` has been changed. """

# ---------------------------------------------------------------------------- #

class AuiDockInfo(object):
    """ A class to store all properties of a dock. """

    def __init__(self):
        """
        Default class constructor.
        Used internally, do not call it in your code!
        """

        object.__init__(self)

        self.dock_direction = 0
        self.dock_layer = 0
        self.dock_row = 0
        self.size = 0
        self.min_size = 0
        self.resizable = True
        self.fixed = False
        self.toolbar = False
        self.rect = wx.Rect()
        self.panes = []


    def IsOk(self):
        """
        Returns whether a dock is valid or not.

        In order to be valid, a dock needs to have a non-zero `dock_direction`.
        """

        return self.dock_direction != 0


    def IsHorizontal(self):
        """ Returns whether the dock is horizontal or not. """

        return self.dock_direction in [AUI_DOCK_TOP, AUI_DOCK_BOTTOM]


    def IsVertical(self):
        """ Returns whether the dock is vertical or not. """

        return self.dock_direction in [AUI_DOCK_LEFT, AUI_DOCK_RIGHT, AUI_DOCK_CENTER]


# ---------------------------------------------------------------------------- #

class AuiDockingGuideInfo(object):
    """ A class which holds information about VS2005 docking guide windows. """

    def __init__(self, other=None):
        """
        Default class constructor.
        Used internally, do not call it in your code!

        :param `other`: another instance of :class:`AuiDockingGuideInfo`.
        """

        if other:
            self.Assign(other)
        else:
            # window representing the docking target
            self.host = None
            # dock direction (top, bottom, left, right, center)
            self.dock_direction = AUI_DOCK_NONE


    def Assign(self, other):
        """
        Assigns the properties of the `other` :class:`AuiDockingGuideInfo` to `self`.

        :param `other`: another instance of :class:`AuiDockingGuideInfo`.
        """

        self.host = other.host
        self.dock_direction = other.dock_direction


    def Host(self, h):
        """
        Hosts a docking guide window.

        :param `h`: an instance of :class:`AuiDockingGuideWindow` or :class:`AuiDockingHintWindow`.
        """

        self.host = h
        return self


    def Left(self):
        """ Sets the guide window to left docking. """

        self.dock_direction = AUI_DOCK_LEFT
        return self


    def Right(self):
        """ Sets the guide window to right docking. """

        self.dock_direction = AUI_DOCK_RIGHT
        return self


    def Top(self):
        """ Sets the guide window to top docking. """

        self.dock_direction = AUI_DOCK_TOP
        return self


    def Bottom(self):
        """ Sets the guide window to bottom docking. """

        self.dock_direction = AUI_DOCK_BOTTOM
        return self


    def Center(self):
        """ Sets the guide window to center docking. """

        self.dock_direction = AUI_DOCK_CENTER
        return self


    def Centre(self):
        """ Sets the guide window to centre docking. """

        self.dock_direction = AUI_DOCK_CENTRE
        return self


# ---------------------------------------------------------------------------- #

class AuiDockUIPart(object):
    """ A class which holds attributes for a UI part in the interface. """

    typeCaption = 0
    typeGripper = 1
    typeDock = 2
    typeDockSizer = 3
    typePane = 4
    typePaneSizer = 5
    typeBackground = 6
    typePaneBorder = 7
    typePaneButton = 8

    def __init__(self):
        """
        Default class constructor.
        Used internally, do not call it in your code!
        """

        self.orientation = wx.VERTICAL
        self.type = 0
        self.rect = wx.Rect()


# ---------------------------------------------------------------------------- #

class AuiPaneButton(object):
    """ A simple class which describes the caption pane button attributes. """

    def __init__(self, button_id):
        """
        Default class constructor.
        Used internally, do not call it in your code!

        :param integer `button_id`: the pane button identifier.
        """

        self.button_id = button_id


# ---------------------------------------------------------------------------- #

# event declarations/classes

class AuiManagerEvent(wx.PyCommandEvent):
    """ A specialized command event class for events sent by :class:`AuiManager`. """

    def __init__(self, eventType, id=1):
        """
        Default class constructor.

        :param integer `eventType`: the event kind;
        :param integer `id`: the event identification number.
        """

        wx.PyCommandEvent.__init__(self, eventType, id)

        self.manager = None
        self.pane = None
        self.button = 0
        self.veto_flag = False
        self.canveto_flag = True
        self.dc = None


    def SetManager(self, mgr):
        """
        Associates a :class:`AuiManager` to the current event.

        :param `mgr`: an instance of :class:`AuiManager`.
        """

        self.manager = mgr


    def SetDC(self, pdc):
        """
        Associates a :class:`DC` device context to this event.

        :param `pdc`: a :class:`DC` device context object.
        """

        self.dc = pdc


    def SetPane(self, p):
        """
        Associates a :class:`AuiPaneInfo` instance to this event.

        :param `p`: a :class:`AuiPaneInfo` instance.
        """

        self.pane = p


    def SetButton(self, b):
        """
        Associates a :class:`AuiPaneButton` instance to this event.

        :param `b`: a :class:`AuiPaneButton` instance.
        """

        self.button = b


    def GetManager(self):
        """ Returns the associated :class:`AuiManager` (if any). """

        return self.manager


    def GetDC(self):
        """ Returns the associated :class:`DC` device context (if any). """

        return self.dc


    def GetPane(self):
        """ Returns the associated :class:`AuiPaneInfo` structure (if any). """

        return self.pane


    def GetButton(self):
        """ Returns the associated :class:`AuiPaneButton` instance (if any). """

        return self.button


    def Veto(self, veto=True):
        """
        Prevents the change announced by this event from happening.

        It is in general a good idea to notify the user about the reasons for
        vetoing the change because otherwise the applications behaviour (which
        just refuses to do what the user wants) might be quite surprising.

        :param bool `veto`: ``True`` to veto the event, ``False`` otherwise.
        """

        self.veto_flag = veto


    def GetVeto(self):
        """ Returns whether the event has been vetoed or not. """

        return self.veto_flag


    def SetCanVeto(self, can_veto):
        """
        Sets whether the event can be vetoed or not.

        :param bool `can_veto`: ``True`` if the event can be vetoed, ``False`` otherwise.
        """

        self.canveto_flag = can_veto


    def CanVeto(self):
        """ Returns whether the event can be vetoed and has been vetoed. """

        return  self.canveto_flag and self.veto_flag


# ---------------------------------------------------------------------------- #

class AuiPaneInfo(object):
    """
    AuiPaneInfo specifies all the parameters for a pane. These parameters specify where
    the pane is on the screen, whether it is docked or floating, or hidden. In addition,
    these parameters specify the pane's docked position, floating position, preferred
    size, minimum size, caption text among many other parameters.
    """

    optionFloating         = 2**0
    optionHidden           = 2**1
    optionLeftDockable     = 2**2
    optionRightDockable    = 2**3
    optionTopDockable      = 2**4
    optionBottomDockable   = 2**5
    optionFloatable        = 2**6
    optionMovable          = 2**7
    optionResizable        = 2**8
    optionPaneBorder       = 2**9
    optionCaption          = 2**10
    optionGripper          = 2**11
    optionDestroyOnClose   = 2**12
    optionToolbar          = 2**13
    optionActive           = 2**14
    optionGripperTop       = 2**15
    optionMaximized        = 2**16
    optionDockFixed        = 2**17
    optionNotebookDockable = 2**18
    optionMinimized        = 2**19
    optionLeftSnapped      = 2**20
    optionRightSnapped     = 2**21
    optionTopSnapped       = 2**22
    optionBottomSnapped    = 2**23
    optionFlyOut           = 2**24
    optionCaptionLeft      = 2**25

    buttonClose            = 2**26
    buttonMaximize         = 2**27
    buttonMinimize         = 2**28
    buttonPin              = 2**29

    buttonCustom1          = 2**30
    buttonCustom2          = 2**31
    buttonCustom3          = 2**32

    savedHiddenState       = 2**33    # used internally
    actionPane             = 2**34    # used internally
    wasMaximized           = 2**35    # used internally
    needsRestore           = 2**36    # used internally


    def __init__(self):
        """ Default class constructor. """

        self.window = None
        self.frame = None
        self.state = 0
        self.dock_direction = AUI_DOCK_LEFT
        self.dock_layer = 0
        self.dock_row = 0
        self.dock_pos = 0
        self.minimize_mode = AUI_MINIMIZE_POS_SMART
        self.floating_pos = wx.Point(-1, -1)
        self.floating_size = wx.Size(-1, -1)
        self.best_size = wx.Size(-1, -1)
        self.min_size = wx.Size(-1, -1)
        self.max_size = wx.Size(-1, -1)
        self.dock_proportion = 0
        self.caption = ""
        self.buttons = []
        self.name = ""
        self.icon = wx.NullIcon
        self.rect = wx.Rect()
        self.notebook_id = -1
        self.transparent = 255
        self.needsTransparency = False
        self.previousDockPos = None
        self.previousDockSize = 0
        self.snapped = 0
        self.minimize_target = None

        self.DefaultPane()


    def dock_direction_get(self):
        """
        Getter for the `dock_direction`.

        :see: :meth:`~AuiPaneInfo.dock_direction_set` for a set of valid docking directions.
        """

        if self.IsMaximized():
            return AUI_DOCK_CENTER
        else:
            return self._dock_direction


    def dock_direction_set(self, value):
        """
        Setter for the `dock_direction`.

        :param integer `value`: the docking direction. This can be one of the following bits:

        ============================ ======= =============================================
        Dock Flag                     Value  Description
        ============================ ======= =============================================
        ``AUI_DOCK_NONE``                  0 No docking direction.
        ``AUI_DOCK_TOP``                   1 Top docking direction.
        ``AUI_DOCK_RIGHT``                 2 Right docking direction.
        ``AUI_DOCK_BOTTOM``                3 Bottom docking direction.
        ``AUI_DOCK_LEFT``                  4 Left docking direction.
        ``AUI_DOCK_CENTER``                5 Center docking direction.
        ``AUI_DOCK_CENTRE``                5 Centre docking direction.
        ``AUI_DOCK_NOTEBOOK_PAGE``         6 Automatic AuiNotebooks docking style.
        ============================ ======= =============================================

        """

        self._dock_direction = value

    dock_direction = property(dock_direction_get, dock_direction_set)

    def IsOk(self):
        """
        Returns ``True`` if the :class:`AuiPaneInfo` structure is valid.

        :note: A pane structure is valid if it has an associated window.
        """

        return self.window != None


    def IsMaximized(self):
        """ Returns ``True`` if the pane is maximized. """

        return self.HasFlag(self.optionMaximized)


    def IsMinimized(self):
        """ Returns ``True`` if the pane is minimized. """

        return self.HasFlag(self.optionMinimized)


    def IsFixed(self):
        """ Returns ``True`` if the pane cannot be resized. """

        return not self.HasFlag(self.optionResizable)


    def IsResizeable(self):
        """ Returns ``True`` if the pane can be resized. """

        return self.HasFlag(self.optionResizable)


    def IsShown(self):
        """ Returns ``True`` if the pane is currently shown. """

        return not self.HasFlag(self.optionHidden)


    def IsFloating(self):
        """ Returns ``True`` if the pane is floating. """

        return self.HasFlag(self.optionFloating)


    def IsDocked(self):
        """ Returns ``True`` if the pane is docked. """

        return not self.HasFlag(self.optionFloating)


    def IsToolbar(self):
        """ Returns ``True`` if the pane contains a toolbar. """

        return self.HasFlag(self.optionToolbar)


    def IsTopDockable(self):
        """
        Returns ``True`` if the pane can be docked at the top
        of the managed frame.
        """

        return self.HasFlag(self.optionTopDockable)


    def IsBottomDockable(self):
        """
        Returns ``True`` if the pane can be docked at the bottom
        of the managed frame.
        """

        return self.HasFlag(self.optionBottomDockable)


    def IsLeftDockable(self):
        """
        Returns ``True`` if the pane can be docked at the left
        of the managed frame.
        """

        return self.HasFlag(self.optionLeftDockable)


    def IsRightDockable(self):
        """
        Returns ``True`` if the pane can be docked at the right
        of the managed frame.
        """

        return self.HasFlag(self.optionRightDockable)


    def IsDockable(self):
        """ Returns ``True`` if the pane can be docked. """

        return self.IsTopDockable() or self.IsBottomDockable() or self.IsLeftDockable() or \
               self.IsRightDockable() or self.IsNotebookDockable()


    def IsFloatable(self):
        """
        Returns ``True`` if the pane can be undocked and displayed as a
        floating window.
        """

        return self.HasFlag(self.optionFloatable)


    def IsMovable(self):
        """
        Returns ``True`` if the docked frame can be undocked or moved to
        another dock position.
        """

        return self.HasFlag(self.optionMovable)


    def IsDestroyOnClose(self):
        """
        Returns ``True`` if the pane should be destroyed when it is closed.

        Normally a pane is simply hidden when the close button is clicked. Calling :meth:`~AuiPaneInfo.DestroyOnClose`
        with a ``True`` input parameter will cause the window to be destroyed when the user clicks
        the pane's close button.
        """

        return self.HasFlag(self.optionDestroyOnClose)


    def IsNotebookDockable(self):
        """
        Returns ``True`` if a pane can be docked on top to another to create a
        :class:`~lib.agw.aui.auibook.AuiNotebook`.
        """

        return self.HasFlag(self.optionNotebookDockable)


    def IsTopSnappable(self):
        """ Returns ``True`` if the pane can be snapped at the top of the managed frame. """

        return self.HasFlag(self.optionTopSnapped)


    def IsBottomSnappable(self):
        """ Returns ``True`` if the pane can be snapped at the bottom of the managed frame. """

        return self.HasFlag(self.optionBottomSnapped)


    def IsLeftSnappable(self):
        """ Returns ``True`` if the pane can be snapped on the left of the managed frame. """

        return self.HasFlag(self.optionLeftSnapped)


    def IsRightSnappable(self):
        """ Returns ``True`` if the pane can be snapped on the right of the managed frame. """

        return self.HasFlag(self.optionRightSnapped)


    def IsSnappable(self):
        """ Returns ``True`` if the pane can be snapped. """

        return self.IsTopSnappable() or self.IsBottomSnappable() or self.IsLeftSnappable() or \
               self.IsRightSnappable()


    def IsFlyOut(self):
        """ Returns ``True`` if the floating pane has a "fly-out" effect. """

        return self.HasFlag(self.optionFlyOut)


    def HasCaption(self):
        """ Returns ``True`` if the pane displays a caption. """

        return self.HasFlag(self.optionCaption)


    def HasCaptionLeft(self):
        """ Returns ``True`` if the pane displays a caption on the left (rotated by 90 degrees). """

        return self.HasFlag(self.optionCaptionLeft)


    def HasGripper(self):
        """ Returns ``True`` if the pane displays a gripper. """

        return self.HasFlag(self.optionGripper)


    def HasBorder(self):
        """ Returns ``True`` if the pane displays a border. """

        return self.HasFlag(self.optionPaneBorder)


    def HasCloseButton(self):
        """ Returns ``True`` if the pane displays a button to close the pane. """

        return self.HasFlag(self.buttonClose)


    def HasMaximizeButton(self):
        """ Returns ``True`` if the pane displays a button to maximize the pane. """

        return self.HasFlag(self.buttonMaximize)


    def HasMinimizeButton(self):
        """ Returns ``True`` if the pane displays a button to minimize the pane. """

        return self.HasFlag(self.buttonMinimize)


    def GetMinimizeMode(self):
        """
        Returns the minimization style for this pane.

        Possible return values are:

        ============================== ========= ==============================
        Minimize Mode Flag             Hex Value Description
        ============================== ========= ==============================
        ``AUI_MINIMIZE_POS_SMART``          0x01 Minimizes the pane on the closest tool bar
        ``AUI_MINIMIZE_POS_TOP``            0x02 Minimizes the pane on the top tool bar
        ``AUI_MINIMIZE_POS_LEFT``           0x03 Minimizes the pane on its left tool bar
        ``AUI_MINIMIZE_POS_RIGHT``          0x04 Minimizes the pane on its right tool bar
        ``AUI_MINIMIZE_POS_BOTTOM``         0x05 Minimizes the pane on its bottom tool bar
        ``AUI_MINIMIZE_POS_TOOLBAR``        0x06 Minimizes the pane on a target :class:`~lib.agw.aui.auibar.AuiToolBar`
        ``AUI_MINIMIZE_POS_MASK``           0x17 Mask to filter the position flags
        ``AUI_MINIMIZE_CAPT_HIDE``           0x0 Hides the caption of the minimized pane
        ``AUI_MINIMIZE_CAPT_SMART``         0x08 Displays the caption in the best rotation (horizontal or clockwise)
        ``AUI_MINIMIZE_CAPT_HORZ``          0x10 Displays the caption horizontally
        ``AUI_MINIMIZE_CAPT_MASK``          0x18 Mask to filter the caption flags
        ============================== ========= ==============================

        The flags can be filtered with the following masks:

        ============================== ========= ==============================
        Minimize Mask Flag             Hex Value Description
        ============================== ========= ==============================
        ``AUI_MINIMIZE_POS_MASK``           0x17 Filters the position flags
        ``AUI_MINIMIZE_CAPT_MASK``          0x18 Filters the caption flags
        ============================== ========= ==============================

        """

        return self.minimize_mode


    def HasPinButton(self):
        """ Returns ``True`` if the pane displays a button to float the pane. """

        return self.HasFlag(self.buttonPin)


    def HasGripperTop(self):
        """ Returns ``True`` if the pane displays a gripper at the top. """

        return self.HasFlag(self.optionGripperTop)


    def Window(self, w):
        """
        Associate a :class:`Window` derived window to this pane.

        This normally does not need to be specified, as the window pointer is
        automatically assigned to the :class:`AuiPaneInfo` structure as soon as it is
        added to the manager.

        :param `w`: a :class:`Window` derived window.
        """

        self.window = w
        return self


    def Name(self, name):
        """
        Sets the name of the pane so it can be referenced in lookup functions.

        If a name is not specified by the user, a random name is assigned to the pane
        when it is added to the manager.

        :param `name`: a string specifying the pane name.

        .. warning::

           If you are using :meth:`AuiManager.SavePerspective` and :meth:`AuiManager.LoadPerspective`,
           you will have to specify a name for your pane using :meth:`~AuiPaneInfo.Name`, as perspectives
           containing randomly generated names can not be properly restored.
        """

        self.name = name
        return self


    def Caption(self, caption):
        """
        Sets the caption of the pane.

        :param string `caption`: a string specifying the pane caption.
        """

        self.caption = caption
        return self


    def Left(self):
        """
        Sets the pane dock position to the left side of the frame.

        :note: This is the same thing as calling :meth:`~AuiPaneInfo.Direction` with ``AUI_DOCK_LEFT`` as
         parameter.
        """

        self.dock_direction = AUI_DOCK_LEFT
        return self


    def Right(self):
        """
        Sets the pane dock position to the right side of the frame.

        :note: This is the same thing as calling :meth:`~AuiPaneInfo.Direction` with ``AUI_DOCK_RIGHT`` as
         parameter.
        """

        self.dock_direction = AUI_DOCK_RIGHT
        return self


    def Top(self):
        """
        Sets the pane dock position to the top of the frame.

        :note: This is the same thing as calling :meth:`~AuiPaneInfo.Direction` with ``AUI_DOCK_TOP`` as
         parameter.
        """

        self.dock_direction = AUI_DOCK_TOP
        return self


    def Bottom(self):
        """
        Sets the pane dock position to the bottom of the frame.

        :note: This is the same thing as calling :meth:`~AuiPaneInfo.Direction` with ``AUI_DOCK_BOTTOM`` as
         parameter.
        """

        self.dock_direction = AUI_DOCK_BOTTOM
        return self


    def Center(self):
        """
        Sets the pane to the center position of the frame.

        The centre pane is the space in the middle after all border panes (left, top,
        right, bottom) are subtracted from the layout.

        :note: This is the same thing as calling :meth:`~AuiPaneInfo.Direction` with ``AUI_DOCK_CENTER`` as
         parameter.
        """

        self.dock_direction = AUI_DOCK_CENTER
        return self


    def Centre(self):
        """
        Sets the pane to the center position of the frame.

        The centre pane is the space in the middle after all border panes (left, top,
        right, bottom) are subtracted from the layout.

        :note: This is the same thing as calling :meth:`~AuiPaneInfo.Direction` with ``AUI_DOCK_CENTRE`` as
         parameter.
        """

        self.dock_direction = AUI_DOCK_CENTRE
        return self


    def Direction(self, direction):
        """
        Determines the direction of the docked pane. It is functionally the
        same as calling :meth:`Left`, :meth:`Right`, :meth:`Top` or :meth:`Bottom`,
        except that docking direction may be specified programmatically via the parameter `direction`.

        :param integer `direction`: the direction of the docked pane.

        :see: :meth:`dock_direction_set` for a list of valid docking directions.
        """

        self.dock_direction = direction
        return self


    def Layer(self, layer):
        """
        Determines the layer of the docked pane.

        The dock layer is similar to an onion, the inner-most layer being layer 0. Each
        shell moving in the outward direction has a higher layer number. This allows for
        more complex docking layout formation.

        :param integer `layer`: the layer of the docked pane.
        """

        self.dock_layer = layer
        return self


    def Row(self, row):
        """
        Determines the row of the docked pane.

        :param integer `row`: the row of the docked pane.
        """

        self.dock_row = row
        return self


    def Position(self, pos):
        """
        Determines the position of the docked pane.

        :param integer `pos`: the position of the docked pane.
        """

        self.dock_pos = pos
        return self


    def MinSize(self, arg1=None, arg2=None):
        """
        Sets the minimum size of the pane.

        This method is split in 2 versions depending on the input type. If `arg1` is
        a :class:`Size` object, then :meth:`~AuiPaneInfo.MinSize1` is called. Otherwise, :meth:`~AuiPaneInfo.MinSize2` is called.

        :param `arg1`: a :class:`Size` object, a (x, y) tuple or or a `x` coordinate.
        :param `arg2`: a `y` coordinate (only if `arg1` is a `x` coordinate, otherwise unused).
        """

        if isinstance(arg1, wx.Size):
            ret = self.MinSize1(arg1)
        elif isinstance(arg1, types.TupleType):
            ret = self.MinSize1(wx.Size(*arg1))
        elif isinstance(arg1, types.IntType) and arg2 is not None:
            ret = self.MinSize2(arg1, arg2)
        else:
            raise Exception("Invalid argument passed to `MinSize`: arg1=%s, arg2=%s"%(repr(arg1), repr(arg2)))

        return ret


    def MinSize1(self, size):
        """
        Sets the minimum size of the pane.

        :see: :meth:`MinSize` for an explanation of input parameters.
        """
        self.min_size = size
        return self


    def MinSize2(self, x, y):
        """
        Sets the minimum size of the pane.

        :see: :meth:`MinSize` for an explanation of input parameters.
        """

        self.min_size = wx.Size(x, y)
        return self


    def MaxSize(self, arg1=None, arg2=None):
        """
        Sets the maximum size of the pane.

        This method is split in 2 versions depending on the input type. If `arg1` is
        a :class:`Size` object, then :meth:`~AuiPaneInfo.MaxSize1` is called. Otherwise, :meth:`~AuiPaneInfo.MaxSize2` is called.

        :param `arg1`: a :class:`Size` object, a (x, y) tuple or a `x` coordinate.
        :param `arg2`: a `y` coordinate (only if `arg1` is a `x` coordinate, otherwise unused).
        """

        if isinstance(arg1, wx.Size):
            ret = self.MaxSize1(arg1)
        elif isinstance(arg1, types.TupleType):
            ret = self.MaxSize1(wx.Size(*arg1))
        elif isinstance(arg1, types.IntType) and arg2 is not None:
            ret = self.MaxSize2(arg1, arg2)
        else:
            raise Exception("Invalid argument passed to `MaxSize`: arg1=%s, arg2=%s"%(repr(arg1), repr(arg2)))

        return ret


    def MaxSize1(self, size):
        """
        Sets the maximum size of the pane.

        :see: :meth:`MaxSize` for an explanation of input parameters.
        """

        self.max_size = size
        return self


    def MaxSize2(self, x, y):
        """
        Sets the maximum size of the pane.

        :see: :meth:`MaxSize` for an explanation of input parameters.
        """

        self.max_size.Set(x,y)
        return self


    def BestSize(self, arg1=None, arg2=None):
        """
        Sets the ideal size for the pane. The docking manager will attempt to use
        this size as much as possible when docking or floating the pane.

        This method is split in 2 versions depending on the input type. If `arg1` is
        a :class:`Size` object, then :meth:`BestSize1` is called. Otherwise, :meth:`BestSize2` is called.

        :param `arg1`: a :class:`Size` object, a (x, y) tuple or a `x` coordinate.
        :param `arg2`: a `y` coordinate (only if `arg1` is a `x` coordinate, otherwise unused).
        """

        if isinstance(arg1, wx.Size):
            ret = self.BestSize1(arg1)
        elif isinstance(arg1, types.TupleType):
            ret = self.BestSize1(wx.Size(*arg1))
        elif isinstance(arg1, types.IntType) and arg2 is not None:
            ret = self.BestSize2(arg1, arg2)
        else:
            raise Exception("Invalid argument passed to `BestSize`: arg1=%s, arg2=%s"%(repr(arg1), repr(arg2)))

        return ret


    def BestSize1(self, size):
        """
        Sets the best size of the pane.

        :see: :meth:`BestSize` for an explanation of input parameters.
        """

        self.best_size = size
        return self


    def BestSize2(self, x, y):
        """
        Sets the best size of the pane.

        :see: :meth:`BestSize` for an explanation of input parameters.
        """

        self.best_size.Set(x,y)
        return self


    def FloatingPosition(self, pos):
        """
        Sets the position of the floating pane.

        :param `pos`: a :class:`Point` or a tuple indicating the pane floating position.
        """

        self.floating_pos = wx.Point(*pos)
        return self


    def FloatingSize(self, size):
        """
        Sets the size of the floating pane.

        :param `size`: a :class:`Size` or a tuple indicating the pane floating size.
        """

        self.floating_size = wx.Size(*size)
        return self


    def Maximize(self):
        """ Makes the pane take up the full area."""

        return self.SetFlag(self.optionMaximized, True)


    def Minimize(self):
        """
        Makes the pane minimized in a :class:`~lib.agw.aui.auibar.AuiToolBar`.

        Clicking on the minimize button causes a new :class:`~lib.agw.aui.auibar.AuiToolBar` to be created
        and added to the frame manager, (currently the implementation is such that
        panes at West will have a toolbar at the right, panes at South will have
        toolbars at the bottom etc...) and the pane is hidden in the manager.

        Clicking on the restore button on the newly created toolbar will result in the
        toolbar being removed and the original pane being restored.
        """

        return self.SetFlag(self.optionMinimized, True)


    def MinimizeMode(self, mode):
        """
        Sets the expected minimized mode if the minimize button is visible.

        :param integer `mode`: the minimized pane can have a specific position in the work space:

        ============================== ========= ==============================
        Minimize Mode Flag             Hex Value Description
        ============================== ========= ==============================
        ``AUI_MINIMIZE_POS_SMART``          0x01 Minimizes the pane on the closest tool bar
        ``AUI_MINIMIZE_POS_TOP``            0x02 Minimizes the pane on the top tool bar
        ``AUI_MINIMIZE_POS_LEFT``           0x03 Minimizes the pane on its left tool bar
        ``AUI_MINIMIZE_POS_RIGHT``          0x04 Minimizes the pane on its right tool bar
        ``AUI_MINIMIZE_POS_BOTTOM``         0x05 Minimizes the pane on its bottom tool bar
        ``AUI_MINIMIZE_POS_TOOLBAR``        0x06 Minimizes the pane on a target :class:`~lib.agw.aui.auibar.AuiToolBar`
        ============================== ========= ==============================

        The caption of the minimized pane can be displayed in different modes:

        ============================== ========= ==============================
        Caption Mode Flag              Hex Value Description
        ============================== ========= ==============================
        ``AUI_MINIMIZE_CAPT_HIDE``           0x0 Hides the caption of the minimized pane
        ``AUI_MINIMIZE_CAPT_SMART``         0x08 Displays the caption in the best rotation (horizontal in the top and in
                                                 the bottom tool bar or clockwise in the right and in the left tool bar)
        ``AUI_MINIMIZE_CAPT_HORZ``          0x10 Displays the caption horizontally
        ============================== ========= ==============================

        .. note::

           In order to use the ``AUI_MINIMIZE_POS_TOOLBAR`` flag, the instance of :class:`AuiManager`
           you pass as an input for :meth:`MinimizeTarget` **must** have a real name and not the randomly
           generated one. Remember to set the :meth:`Name` property of the toolbar pane before calling this method.

        """

        self.minimize_mode = mode
        return self


    def MinimizeTarget(self, toolbarPane):
        """
        Minimizes the panes using a :class:`AuiPaneInfo` as a target. As :class:`AuiPaneInfo` properties
        need to be copied back and forth every time the perspective has changed, we
        only store the toobar **name**.

        :param `toolbarPane`: an instance of :class:`AuiPaneInfo`, containing a :class:`~lib.agw.aui.auibar.AuiToolBar`.

        .. note::

           In order to use this functionality (and with the ``AUI_MINIMIZE_POS_TOOLBAR``
           flag set), the instance of :class:`AuiPaneInfo` you pass as an input **must** have a real
           name and not the randomly generated one. Remember to set the :meth:`Name` property of
           the toolbar pane before calling this method.

        """

        self.minimize_target = toolbarPane.name
        return self


    def Restore(self):
        """ Is the reverse of :meth:`Maximize` and :meth:`Minimize`."""

        return self.SetFlag(self.optionMaximized or self.optionMinimized, False)


    def Fixed(self):
        """
        Forces a pane to be fixed size so that it cannot be resized.
        After calling :meth:`Fixed`, :meth:`IsFixed` will return ``True``.
        """

        return self.SetFlag(self.optionResizable, False)


    def Resizable(self, resizable=True):
        """
        Allows a pane to be resizable if `resizable` is ``True``, and forces
        it to be a fixed size if `resizeable` is ``False``.

        If `resizable` is ``False``, this is simply an antonym for :meth:`Fixed`.

        :param bool `resizable`: whether the pane will be resizeable or not.
        """

        return self.SetFlag(self.optionResizable, resizable)


    def Transparent(self, alpha):
        """
        Makes the pane transparent when floating.

        :param integer `alpha`: a value between 0 and 255 for pane transparency.
        """

        if alpha < 0 or alpha > 255:
            raise Exception("Invalid transparency value (%s)"%repr(alpha))

        self.transparent = alpha
        self.needsTransparency = True


    def Dock(self):
        """ Indicates that a pane should be docked. It is the opposite of :meth:`Float`. """

        if self.IsNotebookPage():
            self.notebook_id = -1
            self.dock_direction = AUI_DOCK_NONE

        return self.SetFlag(self.optionFloating, False)


    def Float(self):
        """ Indicates that a pane should be floated. It is the opposite of :meth:`Dock`. """

        if self.IsNotebookPage():
            self.notebook_id = -1
            self.dock_direction = AUI_DOCK_NONE

        return self.SetFlag(self.optionFloating, True)


    def Hide(self):
        """
        Indicates that a pane should be hidden.

        Calling :meth:`Show(False) <Show>` achieve the same effect.
        """

        return self.SetFlag(self.optionHidden, True)


    def Show(self, show=True):
        """
        Indicates that a pane should be shown.

        :param bool `show`: whether the pane should be shown or not.
        """

        return self.SetFlag(self.optionHidden, not show)


    # By defaulting to 1000, the tab will get placed at the end
    def NotebookPage(self, id, tab_position=1000):
        """
        Forces a pane to be a notebook page, so that the pane can be
        docked on top to another to create a :class:`~lib.agw.aui.auibook.AuiNotebook`.

        :param integer `id`: the notebook id;
        :param integer `tab_position`: the tab number of the pane once docked in a notebook.
        """

        # Remove any floating frame
        self.Dock()
        self.notebook_id = id
        self.dock_pos = tab_position
        self.dock_row = 0
        self.dock_layer = 0
        self.dock_direction = AUI_DOCK_NOTEBOOK_PAGE

        return self


    def NotebookControl(self, id):
        """
        Forces a pane to be a notebook control (:class:`~lib.agw.aui.auibook.AuiNotebook`).

        :param integer `id`: the notebook id.
        """

        self.notebook_id = id
        self.window = None
        self.buttons = []

        if self.dock_direction == AUI_DOCK_NOTEBOOK_PAGE:
            self.dock_direction = AUI_DOCK_NONE

        return self


    def HasNotebook(self):
        """ Returns whether a pane has a :class:`~lib.agw.aui.auibook.AuiNotebook` or not. """

        return self.notebook_id >= 0


    def IsNotebookPage(self):
        """ Returns whether the pane is a notebook page in a :class:`~lib.agw.aui.auibook.AuiNotebook`. """

        return self.notebook_id >= 0 and self.dock_direction == AUI_DOCK_NOTEBOOK_PAGE


    def IsNotebookControl(self):
        """ Returns whether the pane is a notebook control (:class:`~lib.agw.aui.auibook.AuiNotebook`). """

        return not self.IsNotebookPage() and self.HasNotebook()


    def SetNameFromNotebookId(self):
        """ Sets the pane name once docked in a :class:`~lib.agw.aui.auibook.AuiNotebook` using the notebook id. """

        if self.notebook_id >= 0:
            self.name = "__notebook_%d"%self.notebook_id

        return self


    def CaptionVisible(self, visible=True, left=False):
        """
        Indicates that a pane caption should be visible. If `visible` is ``False``, no pane
        caption is drawn.

        :param bool `visible`: whether the caption should be visible or not;
        :param bool `left`: whether the caption should be drawn on the left (rotated by 90 degrees) or not.
        """

        if left:
            self.SetFlag(self.optionCaption, False)
            return self.SetFlag(self.optionCaptionLeft, visible)

        self.SetFlag(self.optionCaptionLeft, False)
        return self.SetFlag(self.optionCaption, visible)


    def PaneBorder(self, visible=True):
        """
        Indicates that a border should be drawn for the pane.

        :param bool `visible`: whether the pane border should be visible or not.
        """

        return self.SetFlag(self.optionPaneBorder, visible)


    def Gripper(self, visible=True):
        """
        Indicates that a gripper should be drawn for the pane.

        :param bool `visible`: whether the gripper should be visible or not.
        """

        return self.SetFlag(self.optionGripper, visible)


    def GripperTop(self, attop=True):
        """
        Indicates that a gripper should be drawn at the top of the pane.

        :param bool `attop`: whether the gripper should be drawn at the top or not.
        """

        return self.SetFlag(self.optionGripperTop, attop)


    def CloseButton(self, visible=True):
        """
        Indicates that a close button should be drawn for the pane.

        :param bool `visible`: whether the close button should be visible or not.
        """

        return self.SetFlag(self.buttonClose, visible)


    def MaximizeButton(self, visible=True):
        """
        Indicates that a maximize button should be drawn for the pane.

        :param bool `visible`: whether the maximize button should be visible or not.
        """

        return self.SetFlag(self.buttonMaximize, visible)


    def MinimizeButton(self, visible=True):
        """
        Indicates that a minimize button should be drawn for the pane.

        :param bool `visible`: whether the minimize button should be visible or not.
        """

        return self.SetFlag(self.buttonMinimize, visible)


    def PinButton(self, visible=True):
        """
        Indicates that a pin button should be drawn for the pane.

        :param bool `visible`: whether the pin button should be visible or not.
        """

        return self.SetFlag(self.buttonPin, visible)


    def DestroyOnClose(self, b=True):
        """
        Indicates whether a pane should be destroyed when it is closed.

        Normally a pane is simply hidden when the close button is clicked. Setting
        `b` to ``True`` will cause the window to be destroyed when the user clicks
        the pane's close button.

        :param bool `b`: whether the pane should be destroyed when it is closed or not.
        """

        return self.SetFlag(self.optionDestroyOnClose, b)


    def TopDockable(self, b=True):
        """
        Indicates whether a pane can be docked at the top of the frame.

        :param bool `b`: whether the pane can be docked at the top or not.
        """

        return self.SetFlag(self.optionTopDockable, b)


    def BottomDockable(self, b=True):
        """
        Indicates whether a pane can be docked at the bottom of the frame.

        :param bool `b`: whether the pane can be docked at the bottom or not.
        """

        return self.SetFlag(self.optionBottomDockable, b)


    def LeftDockable(self, b=True):
        """
        Indicates whether a pane can be docked on the left of the frame.

        :param bool `b`: whether the pane can be docked at the left or not.
        """

        return self.SetFlag(self.optionLeftDockable, b)


    def RightDockable(self, b=True):
        """
        Indicates whether a pane can be docked on the right of the frame.

        :param bool `b`: whether the pane can be docked at the right or not.
        """

        return self.SetFlag(self.optionRightDockable, b)


    def Floatable(self, b=True):
        """
        Sets whether the user will be able to undock a pane and turn it
        into a floating window.

        :param bool `b`: whether the pane can be floated or not.
        """

        return self.SetFlag(self.optionFloatable, b)


    def Movable(self, b=True):
        """
        Indicates whether a pane can be moved.

        :param bool `b`: whether the pane can be moved or not.
        """

        return self.SetFlag(self.optionMovable, b)


    def NotebookDockable(self, b=True):
        """
        Indicates whether a pane can be docked in an automatic :class:`~lib.agw.aui.auibook.AuiNotebook`.

        :param bool `b`: whether the pane can be docked in a notebook or not.
        """

        return self.SetFlag(self.optionNotebookDockable, b)


    def DockFixed(self, b=True):
        """
        Causes the containing dock to have no resize sash. This is useful
        for creating panes that span the entire width or height of a dock, but should
        not be resizable in the other direction.

        :param bool `b`: whether the pane will have a resize sash or not.
        """

        return self.SetFlag(self.optionDockFixed, b)


    def Dockable(self, b=True):
        """
        Specifies whether a frame can be docked or not. It is the same as specifying
        :meth:`TopDockable` . :meth:`BottomDockable` . :meth:`LeftDockable` . :meth:`RightDockable` .

        :param bool `b`: whether the frame can be docked or not.
        """

        return self.TopDockable(b).BottomDockable(b).LeftDockable(b).RightDockable(b)


    def TopSnappable(self, b=True):
        """
        Indicates whether a pane can be snapped at the top of the main frame.

        :param bool `b`: whether the pane can be snapped at the top of the main frame or not.
        """

        return self.SetFlag(self.optionTopSnapped, b)


    def BottomSnappable(self, b=True):
        """
        Indicates whether a pane can be snapped at the bottom of the main frame.

        :param bool `b`: whether the pane can be snapped at the bottom of the main frame or not.
        """

        return self.SetFlag(self.optionBottomSnapped, b)


    def LeftSnappable(self, b=True):
        """
        Indicates whether a pane can be snapped on the left of the main frame.

        :param bool `b`: whether the pane can be snapped at the left of the main frame or not.
        """

        return self.SetFlag(self.optionLeftSnapped, b)


    def RightSnappable(self, b=True):
        """
        Indicates whether a pane can be snapped on the right of the main frame.

        :param bool `b`: whether the pane can be snapped at the right of the main frame or not.
        """

        return self.SetFlag(self.optionRightSnapped, b)


    def Snappable(self, b=True):
        """
        Indicates whether a pane can be snapped on the main frame. This is
        equivalent as calling :meth:`TopSnappable` . :meth:`BottomSnappable` . :meth:`LeftSnappable` . :meth:`RightSnappable` .

        :param bool `b`: whether the pane can be snapped on the main frame or not.
        """

        return self.TopSnappable(b).BottomSnappable(b).LeftSnappable(b).RightSnappable(b)


    def FlyOut(self, b=True):
        """
        Indicates whether a pane, when floating, has a "fly-out" effect
        (i.e., floating panes which only show themselves when moused over).

        :param bool `b`: whether the pane can be snapped on the main frame or not.
        """

        return self.SetFlag(self.optionFlyOut, b)


    # Copy over the members that pertain to docking position
    def SetDockPos(self, source):
        """
        Copies the `source` pane members that pertain to docking position to `self`.

        :param AuiPaneInfo `source`: the source pane from where to copy the attributes.
        """

        self.dock_direction = source.dock_direction
        self.dock_layer = source.dock_layer
        self.dock_row = source.dock_row
        self.dock_pos = source.dock_pos
        self.dock_proportion = source.dock_proportion
        self.floating_pos = wx.Point(*source.floating_pos)
        self.floating_size = wx.Size(*source.floating_size)
        self.rect = wx.Rect(*source.rect)

        return self


    def DefaultPane(self):
        """ Specifies that the pane should adopt the default pane settings. """

        state = self.state
        state |= self.optionTopDockable | self.optionBottomDockable | \
                 self.optionLeftDockable | self.optionRightDockable | \
                 self.optionNotebookDockable | \
                 self.optionFloatable | self.optionMovable | self.optionResizable | \
                 self.optionCaption | self.optionPaneBorder | self.buttonClose

        self.state = state
        return self


    def CentrePane(self):
        """
        Specifies that the pane should adopt the default center pane settings.

        Centre panes usually do not have caption bars. This function provides an easy way of
        preparing a pane to be displayed in the center dock position.
        """

        return self.CenterPane()


    def CenterPane(self):
        """
        Specifies that the pane should adopt the default center pane settings.

        Centre panes usually do not have caption bars. This function provides an easy way of
        preparing a pane to be displayed in the center dock position.
        """

        self.state = 0
        return self.Center().PaneBorder().Resizable()


    def ToolbarPane(self):
        """ Specifies that the pane should adopt the default toolbar pane settings. """

        self.DefaultPane()
        state = self.state

        state |= (self.optionToolbar | self.optionGripper)
        state &= ~(self.optionResizable | self.optionCaption | self.optionCaptionLeft | self.buttonClose)

        if self.dock_layer == 0:
            self.dock_layer = 10

        self.state = state

        return self


    def Icon(self, icon):
        """
        Specifies whether an icon is drawn on the left of the caption text when
        the pane is docked. If `icon` is ``None`` or :class:`NullIcon`, no icon is drawn on
        the caption space.

        :param icon: an icon to draw on the caption space, or ``None``.
        :type `icon`: :class:`Icon` or ``None``
        """

        if icon is None:
            icon = wx.NullIcon

        self.icon = icon
        return self


    def SetFlag(self, flag, option_state):
        """
        Turns the property given by `flag` on or off with the `option_state`
        parameter.

        :param integer `flag`: the property to set;
        :param bool `option_state`: either ``True`` or ``False``.
        """

        state = self.state

        if option_state:
            state |= flag
        else:
            state &= ~flag

        self.state = state

        if flag in [self.buttonClose, self.buttonMaximize, self.buttonMinimize, self.buttonPin]:
            self.ResetButtons()

        return self


    def HasFlag(self, flag):
        """
        Returns ``True`` if the the property specified by flag is active for the pane.

        :param integer `flag`: the property to check for activity.
        """

        return (self.state & flag and [True] or [False])[0]


    def ResetButtons(self):
        """
        Resets all the buttons and recreates them from scratch depending on the
        :class:`AuiManager` flags.
        """

        floating = self.HasFlag(self.optionFloating)
        self.buttons = []

        if not floating and self.HasMinimizeButton():
            button = AuiPaneButton(AUI_BUTTON_MINIMIZE)
            self.buttons.append(button)

        if not floating and self.HasMaximizeButton():
            button = AuiPaneButton(AUI_BUTTON_MAXIMIZE_RESTORE)
            self.buttons.append(button)

        if not floating and self.HasPinButton():
            button = AuiPaneButton(AUI_BUTTON_PIN)
            self.buttons.append(button)

        if self.HasCloseButton():
            button = AuiPaneButton(AUI_BUTTON_CLOSE)
            self.buttons.append(button)


    def CountButtons(self):
        """ Returns the number of visible buttons in the docked pane. """

        n = 0

        if self.HasCaption() or self.HasCaptionLeft():
            if isinstance(wx.GetTopLevelParent(self.window), AuiFloatingFrame):
                return 1

            if self.HasCloseButton():
                n += 1
            if self.HasMaximizeButton():
                n += 1
            if self.HasMinimizeButton():
                n += 1
            if self.HasPinButton():
                n += 1

        return n


    def IsHorizontal(self):
        """ Returns ``True`` if the pane `dock_direction` is horizontal. """

        return self.dock_direction in [AUI_DOCK_TOP, AUI_DOCK_BOTTOM]

    def IsVertical(self):
        """ Returns ``True`` if the pane `dock_direction` is vertical. """

        return self.dock_direction in [AUI_DOCK_LEFT, AUI_DOCK_RIGHT]


# Null AuiPaneInfo reference
NonePaneInfo = AuiPaneInfo()
""" Null :class:`AuiPaneInfo` reference, an invalid instance of :class:`AuiPaneInfo`. """


# ---------------------------------------------------------------------------- #

class AuiDockingGuide(wx.Frame):
    """ Base class for :class:`AuiSingleDockingGuide` and :class:`AuiCenterDockingGuide`."""

    def __init__(self, parent, id=wx.ID_ANY, title="", pos=wx.DefaultPosition,
                 size=wx.DefaultSize, style=wx.FRAME_TOOL_WINDOW | wx.STAY_ON_TOP |
                 wx.FRAME_NO_TASKBAR | wx.NO_BORDER, name="AuiDockingGuide"):
        """
        Default class constructor. Used internally, do not call it in your code!

        :param `parent`: the :class:`AuiManager` parent;
        :param integer `id`: the window identifier. It may take a value of -1 to indicate a default value.
        :param string `title`: the caption to be displayed on the frame's title bar.
        :param Point `pos`: the window position. A value of (-1, -1) indicates a default position,
         chosen by either the windowing system or wxPython, depending on platform.
        :param Size `size`: the window size. A value of (-1, -1) indicates a default size, chosen by
         either the windowing system or wxPython, depending on platform.
        :param integer `style`: the window style.
        :param string `name`: the name of the window. This parameter is used to associate a name with the
         item, allowing the application user to set Motif resource values for individual windows.
        """

        wx.Frame.__init__(self, parent, id, title, pos, size, style, name=name)


    def HitTest(self, x, y):
        """
        To be overridden by parent classes.

        :param integer `x`: the `x` mouse position;
        :param integer `y`: the `y` mouse position.
        """

        return 0


    def ValidateNotebookDocking(self, valid):
        """
        To be overridden by parent classes.

        :param bool `valid`: whether a pane can be docked on top to another to form an automatic
         :class:`~lib.agw.aui.auibook.AuiNotebook`.
        """

        return 0

# ============================================================================
# implementation
# ============================================================================

# ---------------------------------------------------------------------------
# AuiDockingGuideWindow
# ---------------------------------------------------------------------------

class AuiDockingGuideWindow(wx.Window):
    """ Target class for :class:`AuiDockingGuide` and :class:`AuiCenterDockingGuide`. """

    def __init__(self, parent, rect, direction=0, center=False, useAero=False):
        """
        Default class constructor. Used internally, do not call it in your code!

        :param `parent`: the :class:`AuiManager` parent;
        :param Rect `rect`: the window rect;
        :param integer `direction`: one of ``wx.TOP``, ``wx.BOTTOM``, ``wx.LEFT``, ``wx.RIGHT``,
         ``wx.CENTER``;
        :param bool `center`: whether the calling class is a :class:`AuiCenterDockingGuide`;
        :param bool `useAero`: whether to use the new Aero-style bitmaps or Whidbey-style bitmaps
         for the docking guide.
        """

        wx.Window.__init__(self, parent, -1, rect.GetPosition(), rect.GetSize(), wx.NO_BORDER)

        self._direction = direction
        self._center = center
        self._valid = True
        self._useAero = useAero

        self._bmp_unfocus, self._bmp_focus = GetDockingImage(direction, useAero, center)

        self._currentImage = self._bmp_unfocus
        self.SetBackgroundStyle(wx.BG_STYLE_CUSTOM)

        self.Bind(wx.EVT_ERASE_BACKGROUND, self.OnEraseBackground)
        self.Bind(wx.EVT_PAINT, self.OnPaint)


    def SetValid(self, valid):
        """
        Sets the docking direction as valid or invalid.

        :param bool `valid`: whether the docking direction is allowed or not.
        """

        self._valid = valid


    def IsValid(self):
        """ Returns whether the docking direction is valid. """

        return self._valid


    def OnEraseBackground(self, event):
        """
        Handles the ``wx.EVT_ERASE_BACKGROUND`` event for :class:`AuiDockingGuideWindow`.

        :param `event`: a :class:`EraseEvent` to be processed.

        :note: This is intentionally empty to reduce flickering while drawing.
        """

        pass


    def DrawBackground(self, dc):
        """
        Draws the docking guide background.

        :param `dc`: a :class:`DC` device context object.
        """

        rect = self.GetClientRect()

        dc.SetPen(wx.TRANSPARENT_PEN)
        dc.SetBrush(wx.Brush(colourTargetBackground))
        dc.DrawRectangleRect(rect)

        dc.SetPen(wx.Pen(colourTargetBorder))

        left = rect.GetLeft()
        top = rect.GetTop()
        right = rect.GetRight()
        bottom = rect.GetBottom()

        if self._direction != wx.CENTER:

            if not self._center or self._direction != wx.BOTTOM:
                dc.DrawLine(left, top, right+1, top)
            if not self._center or self._direction != wx.RIGHT:
                dc.DrawLine(left, top, left, bottom+1)
            if not self._center or self._direction != wx.LEFT:
                dc.DrawLine(right, top, right, bottom+1)
            if not self._center or self._direction != wx.TOP:
                dc.DrawLine(left, bottom, right+1, bottom)

            dc.SetPen(wx.Pen(colourTargetShade))

            if self._direction != wx.RIGHT:
                dc.DrawLine(left + 1, top + 1, left + 1, bottom)
            if self._direction != wx.BOTTOM:
                dc.DrawLine(left + 1, top + 1, right, top + 1)


    def DrawDottedLine(self, dc, point, length, vertical):
        """
        Draws a dotted line (not used if the docking guide images are ok).

        :param `dc`: a :class:`DC` device context object;
        :param `point`: a :class:`Point` where to start drawing the dotted line;
        :param integer `length`: the length of the dotted line;
        :param bool `vertical`: whether it is a vertical docking guide window or not.
        """

        for i in xrange(0, length, 2):
            dc.DrawPoint(point.x, point.y)
            if vertical:
                point.y += 2
            else:
                point.x += 2


    def DrawIcon(self, dc):
        """
        Draws the docking guide icon (not used if the docking guide images are ok).

        :param `dc`: a :class:`DC` device context object.
        """

        rect = wx.Rect(*self.GetClientRect())
        point = wx.Point()
        length = 0

        rect.Deflate(4, 4)
        dc.SetPen(wx.Pen(colourIconBorder))
        dc.SetBrush(wx.Brush(colourIconBackground))
        dc.DrawRectangleRect(rect)

        right1 = rect.GetRight() + 1
        bottom1 = rect.GetBottom() + 1

        dc.SetPen(wx.Pen(colourIconShadow))
        dc.DrawLine(rect.x + 1, bottom1, right1 + 1, bottom1)
        dc.DrawLine(right1, rect.y + 1, right1, bottom1 + 1)

        rect.Deflate(1, 1)

        if self._direction == wx.TOP:
            rect.height -= rect.height / 2
            point = rect.GetBottomLeft()
            length = rect.width

        elif self._direction == wx.LEFT:
            rect.width -= rect.width / 2
            point = rect.GetTopRight()
            length = rect.height

        elif self._direction == wx.RIGHT:
            rect.x += rect.width / 2
            rect.width -= rect.width / 2
            point = rect.GetTopLeft()
            length = rect.height

        elif self._direction == wx.BOTTOM:
            rect.y += rect.height / 2
            rect.height -= rect.height / 2
            point = rect.GetTopLeft()
            length = rect.width

        elif self._direction == wx.CENTER:
            rect.Deflate(1, 1)
            point = rect.GetTopLeft()
            length = rect.width

        dc.GradientFillLinear(rect, colourIconDockingPart1,
                              colourIconDockingPart2, self._direction)

        dc.SetPen(wx.Pen(colourIconBorder))

        if self._direction == wx.CENTER:
            self.DrawDottedLine(dc, rect.GetTopLeft(), rect.width, False)
            self.DrawDottedLine(dc, rect.GetTopLeft(), rect.height, True)
            self.DrawDottedLine(dc, rect.GetBottomLeft(), rect.width, False)
            self.DrawDottedLine(dc, rect.GetTopRight(), rect.height, True)

        elif self._direction in [wx.TOP, wx.BOTTOM]:
            self.DrawDottedLine(dc, point, length, False)

        else:
            self.DrawDottedLine(dc, point, length, True)


    def DrawArrow(self, dc):
        """
        Draws the docking guide arrow icon (not used if the docking guide images are ok).

        :param `dc`: a :class:`DC` device context object.
        """

        rect = self.GetClientRect()
        point = wx.Point()

        point.x = (rect.GetLeft() + rect.GetRight()) / 2
        point.y = (rect.GetTop() + rect.GetBottom()) / 2
        rx, ry = wx.Size(), wx.Size()

        if self._direction == wx.TOP:
            rx = wx.Size(1, 0)
            ry = wx.Size(0, 1)

        elif self._direction == wx.LEFT:
            rx = wx.Size(0, -1)
            ry = wx.Size(1, 0)

        elif self._direction == wx.RIGHT:
            rx = wx.Size(0, 1)
            ry = wx.Size(-1, 0)

        elif self._direction == wx.BOTTOM:
            rx = wx.Size(-1, 0)
            ry = wx.Size(0, -1)

        point.x += ry.x*3
        point.y += ry.y*3

        dc.SetPen(wx.Pen(colourIconArrow))

        for i in xrange(4):
            pt1 = wx.Point(point.x - rx.x*i, point.y - rx.y*i)
            pt2 = wx.Point(point.x + rx.x*(i+1), point.y + rx.y*(i+1))
            dc.DrawLinePoint(pt1, pt2)
            point.x += ry.x
            point.y += ry.y


    def OnPaint(self, event):
        """
        Handles the ``wx.EVT_PAINT`` event for :class:`AuiDockingGuideWindow`.

        :param `event`: a :class:`PaintEvent` to be processed.
        """

        dc = wx.AutoBufferedPaintDC(self)
        if self._currentImage.IsOk() and self._valid:
            dc.DrawBitmap(self._currentImage, 0, 0, True)
        else:
            self.Draw(dc)


    def Draw(self, dc):
        """
        Draws the whole docking guide window (not used if the docking guide images are ok).

        :param `dc`: a :class:`DC` device context object.
        """

        self.DrawBackground(dc)

        if self._valid:
            self.DrawIcon(dc)
            self.DrawArrow(dc)


    def UpdateDockGuide(self, pos):
        """
        Updates the docking guide images depending on the mouse position, using focused
        images if the mouse is inside the docking guide or unfocused images if it is
        outside.

        :param `pos`: a :class:`Point` mouse position.
        """

        inside = self.GetScreenRect().Contains(pos)

        if inside:
            image = self._bmp_focus
        else:
            image = self._bmp_unfocus

        if image != self._currentImage:
            self._currentImage = image
            self.Refresh()
            self.Update()


# ---------------------------------------------------------------------------
# AuiSingleDockingGuide
# ---------------------------------------------------------------------------

class AuiSingleDockingGuide(AuiDockingGuide):
    """ A docking guide window for single docking hint (not diamond-shaped HUD). """

    def __init__(self, parent, direction=0):
        """
        Default class constructor. Used internally, do not call it in your code!

        :param `parent`: the :class:`AuiManager` parent;
        :param integer `direction`: one of ``wx.TOP``, ``wx.BOTTOM``, ``wx.LEFT``, ``wx.RIGHT``.
        """

        self._direction = direction

        style = wx.FRAME_TOOL_WINDOW | wx.STAY_ON_TOP | \
                wx.FRAME_NO_TASKBAR | wx.NO_BORDER

        # Use of FRAME_SHAPED on wxMac causes the frame to be visible
        # breaking the docking hints.
        if wx.Platform != '__WXMAC__':
            style |= wx.FRAME_SHAPED

        AuiDockingGuide.__init__(self, parent, style=style, name="auiSingleDockTarget")

        self.Hide()

        useAero = GetManager(self.GetParent()).GetAGWFlags() & AUI_MGR_AERO_DOCKING_GUIDES
        useWhidbey = GetManager(self.GetParent()).GetAGWFlags() & AUI_MGR_WHIDBEY_DOCKING_GUIDES

        self._useAero = useAero or useWhidbey
        self._valid = True

        if useAero:
            sizeX, sizeY = aeroguideSizeX, aeroguideSizeY
        elif useWhidbey:
            sizeX, sizeY = whidbeySizeX, whidbeySizeY
        else:
            sizeX, sizeY = guideSizeX, guideSizeY

        if direction not in [wx.TOP, wx.BOTTOM]:
            sizeX, sizeY = sizeY, sizeX

        if self._useAero:
            self.CreateShapesWithStyle(useWhidbey)

            if wx.Platform == "__WXGTK__":
                self.Bind(wx.EVT_WINDOW_CREATE, self.SetGuideShape)
            else:
                self.SetGuideShape()

            self.SetSize(self.region.GetBox().GetSize())
        else:
            self.SetSize((sizeX, sizeY))

        self.rect = wx.Rect(0, 0, sizeX, sizeY)

        if self._useAero:
            useAero = (useWhidbey and [2] or [1])[0]
        else:
            useAero = 0

        self.target = AuiDockingGuideWindow(self, self.rect, direction, False, useAero)


    def CreateShapesWithStyle(self, useWhidbey):
        """
        Creates the docking guide window shape based on which docking bitmaps are used.

        :param bool `useWhidbey`: if ``True``, use Whidbey-style bitmaps; if ``False``, use the
         Aero-style bitmaps.
         """

        sizeX, sizeY = aeroguideSizeX, aeroguideSizeY
        if useWhidbey:
            sizeX, sizeY = whidbeySizeX, whidbeySizeY

        if self._direction not in [wx.TOP, wx.BOTTOM]:
            sizeX, sizeY = sizeY, sizeX

        useAero = (useWhidbey and [2] or [1])[0]
        bmp, dummy = GetDockingImage(self._direction, useAero, False)
        region = wx.RegionFromBitmap(bmp)

        self.region = region


    def AeroMove(self, pos):
        """
        Moves the docking window to the new position. Overridden in children classes.

        :param Point `pos`: the new docking guide position.
        """

        pass


    def SetGuideShape(self, event=None):
        """
        Sets the correct shape for the docking guide window.

        :param `event`: on wxGTK, a :class:`WindowCreateEvent` event to process.
        """

        self.SetShape(self.region)

        if event is not None:
            # Skip the event on wxGTK
            event.Skip()
            wx.CallAfter(wx.SafeYield, self, True)


    def SetShape(self, region):
        """
        If the platform supports it, sets the shape of the window to that depicted by `region`.
        The system will not display or respond to any mouse event for the pixels that lie
        outside of the region. To reset the window to the normal rectangular shape simply call
        :meth:`SetShape` again with an empty region.

        :param Region `region`: the shape of the frame.

        :note: Overridden for wxMAC.
        """

        if wx.Platform == '__WXMAC__':
            # HACK so we don't crash when SetShape is called
            return
        else:
            super(AuiSingleDockingGuide, self).SetShape(region)


    def SetValid(self, valid):
        """
        Sets the docking direction as valid or invalid.

        :param bool `valid`: whether the docking direction is allowed or not.
        """

        self._valid = valid


    def IsValid(self):
        """ Returns whether the docking direction is valid. """

        return self._valid


    def UpdateDockGuide(self, pos):
        """
        Updates the docking guide images depending on the mouse position, using focused
        images if the mouse is inside the docking guide or unfocused images if it is
        outside.

        :param Point `pos`: the mouse position.
        """

        self.target.UpdateDockGuide(pos)


    def HitTest(self, x, y):
        """
        Checks if the mouse position is inside the target window rect.

        :param integer `x`: the `x` mouse position;
        :param integer `y`: the `y` mouse position.
        """

        if self.target.GetScreenRect().Contains((x, y)):
            return wx.ALL

        return -1


# ---------------------------------------------------------------------------
# AuiCenterDockingGuide
# ---------------------------------------------------------------------------

class AuiCenterDockingGuide(AuiDockingGuide):
    """ A docking guide window for multiple docking hint (diamond-shaped HUD). """

    def __init__(self, parent):
        """
        Default class constructor.
        Used internally, do not call it in your code!

        :param `parent`: the :class:`AuiManager` parent.
        """

        AuiDockingGuide.__init__(self, parent, style=wx.FRAME_TOOL_WINDOW | wx.STAY_ON_TOP |
                                 wx.FRAME_NO_TASKBAR | wx.NO_BORDER | wx.FRAME_SHAPED,
                                 name="auiCenterDockTarget")

        self.Hide()

        self.CreateShapesWithStyle()
        self.SetBackgroundStyle(wx.BG_STYLE_CUSTOM)

        if wx.Platform == "__WXGTK__":
            self.Bind(wx.EVT_WINDOW_CREATE, self.SetGuideShape)
        else:
            self.SetGuideShape()

        self.SetSize(self.region.GetBox().GetSize())

        self.Bind(wx.EVT_ERASE_BACKGROUND, self.OnEraseBackground)
        self.Bind(wx.EVT_PAINT, self.OnPaint)


    def CreateShapesWithStyle(self):
        """ Creates the docking guide window shape based on which docking bitmaps are used. """

        useAero = (GetManager(self.GetParent()).GetAGWFlags() & AUI_MGR_AERO_DOCKING_GUIDES) != 0
        useWhidbey = (GetManager(self.GetParent()).GetAGWFlags() & AUI_MGR_WHIDBEY_DOCKING_GUIDES) != 0

        self._useAero = 0
        if useAero:
            self._useAero = 1
        elif useWhidbey:
            self._useAero = 2

        if useAero:
            sizeX, sizeY = aeroguideSizeX, aeroguideSizeY
        elif useWhidbey:
            sizeX, sizeY = whidbeySizeX, whidbeySizeY
        else:
            sizeX, sizeY = guideSizeX, guideSizeY

        rectLeft = wx.Rect(0, sizeY, sizeY, sizeX)
        rectTop = wx.Rect(sizeY, 0, sizeX, sizeY)
        rectRight = wx.Rect(sizeY+sizeX, sizeY, sizeY, sizeX)
        rectBottom = wx.Rect(sizeY, sizeX + sizeY, sizeX, sizeY)
        rectCenter = wx.Rect(sizeY, sizeY, sizeX, sizeX)

        if not self._useAero:

            self.targetLeft = AuiDockingGuideWindow(self, rectLeft, wx.LEFT, True, useAero)
            self.targetTop = AuiDockingGuideWindow(self, rectTop, wx.TOP, True, useAero)
            self.targetRight = AuiDockingGuideWindow(self, rectRight, wx.RIGHT, True, useAero)
            self.targetBottom = AuiDockingGuideWindow(self, rectBottom, wx.BOTTOM, True, useAero)
            self.targetCenter = AuiDockingGuideWindow(self, rectCenter, wx.CENTER, True, useAero)


            # top-left diamond
            tld = [wx.Point(rectTop.x, rectTop.y+rectTop.height-8),
                   wx.Point(rectLeft.x+rectLeft.width-8, rectLeft.y),
                   rectTop.GetBottomLeft()]
            # bottom-left diamond
            bld = [wx.Point(rectLeft.x+rectLeft.width-8, rectLeft.y+rectLeft.height),
                   wx.Point(rectBottom.x, rectBottom.y+8),
                   rectBottom.GetTopLeft()]
            # top-right diamond
            trd = [wx.Point(rectTop.x+rectTop.width, rectTop.y+rectTop.height-8),
                   wx.Point(rectRight.x+8, rectRight.y),
                   rectRight.GetTopLeft()]
            # bottom-right diamond
            brd = [wx.Point(rectRight.x+8, rectRight.y+rectRight.height),
                   wx.Point(rectBottom.x+rectBottom.width, rectBottom.y+8),
                   rectBottom.GetTopRight()]

            self._triangles = [tld[0:2], bld[0:2],
                               [wx.Point(rectTop.x+rectTop.width-1, rectTop.y+rectTop.height-8),
                                wx.Point(rectRight.x+7, rectRight.y)],
                               [wx.Point(rectRight.x+7, rectRight.y+rectRight.height),
                                wx.Point(rectBottom.x+rectBottom.width-1, rectBottom.y+8)]]

            region = wx.Region()
            region.UnionRect(rectLeft)
            region.UnionRect(rectTop)
            region.UnionRect(rectRight)
            region.UnionRect(rectBottom)
            region.UnionRect(rectCenter)
            region.UnionRegion(wx.RegionFromPoints(tld))
            region.UnionRegion(wx.RegionFromPoints(bld))
            region.UnionRegion(wx.RegionFromPoints(trd))
            region.UnionRegion(wx.RegionFromPoints(brd))

        elif useAero:

            self._aeroBmp = aero_dock_pane.GetBitmap()
            region = wx.RegionFromBitmap(self._aeroBmp)

            self._allAeroBmps = [aero_dock_pane_left.GetBitmap(), aero_dock_pane_top.GetBitmap(),
                                 aero_dock_pane_right.GetBitmap(), aero_dock_pane_bottom.GetBitmap(),
                                 aero_dock_pane_center.GetBitmap(), aero_dock_pane.GetBitmap()]
            self._deniedBitmap = aero_denied.GetBitmap()
            self._aeroRects = [rectLeft, rectTop, rectRight, rectBottom, rectCenter]
            self._valid = True

        elif useWhidbey:

            self._aeroBmp = whidbey_dock_pane.GetBitmap()
            region = wx.RegionFromBitmap(self._aeroBmp)

            self._allAeroBmps = [whidbey_dock_pane_left.GetBitmap(), whidbey_dock_pane_top.GetBitmap(),
                                 whidbey_dock_pane_right.GetBitmap(), whidbey_dock_pane_bottom.GetBitmap(),
                                 whidbey_dock_pane_center.GetBitmap(), whidbey_dock_pane.GetBitmap()]
            self._deniedBitmap = whidbey_denied.GetBitmap()
            self._aeroRects = [rectLeft, rectTop, rectRight, rectBottom, rectCenter]
            self._valid = True


        self.region = region


    def SetGuideShape(self, event=None):
        """
        Sets the correct shape for the docking guide window.

        :param `event`: on wxGTK, a :class:`WindowCreateEvent` event to process.
        """

        self.SetShape(self.region)

        if event is not None:
            # Skip the event on wxGTK
            event.Skip()
            wx.CallAfter(wx.SafeYield, self, True)


    def UpdateDockGuide(self, pos):
        """
        Updates the docking guides images depending on the mouse position, using focused
        images if the mouse is inside the docking guide or unfocused images if it is
        outside.

        :param Point `pos`: the mouse position.
        """

        if not self._useAero:
            for target in self.GetChildren():
                target.UpdateDockGuide(pos)
        else:
            lenRects = len(self._aeroRects)
            for indx, rect in enumerate(self._aeroRects):
                if rect.Contains(pos):
                    if self._allAeroBmps[indx] != self._aeroBmp:
                        if indx < lenRects - 1 or (indx == lenRects - 1 and self._valid):
                            self._aeroBmp = self._allAeroBmps[indx]
                            self.Refresh()
                        else:
                            self._aeroBmp = self._allAeroBmps[-1]
                            self.Refresh()

                    return

            if self._aeroBmp != self._allAeroBmps[-1]:
                self._aeroBmp = self._allAeroBmps[-1]
                self.Refresh()


    def HitTest(self, x, y):
        """
        Checks if the mouse position is inside the target windows rect.

        :param integer `x`: the `x` mouse position;
        :param integer `y`: the `y` mouse position.
        """

        if not self._useAero:
            if self.targetLeft.GetScreenRect().Contains((x, y)):
                return wx.LEFT
            if self.targetTop.GetScreenRect().Contains((x, y)):
                return wx.UP
            if self.targetRight.GetScreenRect().Contains((x, y)):
                return wx.RIGHT
            if self.targetBottom.GetScreenRect().Contains((x, y)):
                return wx.DOWN
            if self.targetCenter.IsValid() and self.targetCenter.GetScreenRect().Contains((x, y)):
                return wx.CENTER
        else:
            constants = [wx.LEFT, wx.UP, wx.RIGHT, wx.DOWN, wx.CENTER]
            lenRects = len(self._aeroRects)
            for indx, rect in enumerate(self._aeroRects):
                if rect.Contains((x, y)):
                    if indx < lenRects or (indx == lenRects-1 and self._valid):
                        return constants[indx]

        return -1


    def ValidateNotebookDocking(self, valid):
        """
        Sets whether a pane can be docked on top of another to create an automatic
        :class:`~lib.agw.aui.auibook.AuiNotebook`.

        :param bool `valid`: whether a pane can be docked on top to another to form an automatic
         :class:`~lib.agw.aui.auibook.AuiNotebook`.
        """

        if not self._useAero:
            if self.targetCenter.IsValid() != valid:
                self.targetCenter.SetValid(valid)
                self.targetCenter.Refresh()
        else:
            if self._valid != valid:
                self._valid = valid
                self.Refresh()


    def AeroMove(self, pos):
        """
        Moves the docking guide window to the new position.

        :param Point `pos`: the new docking guide position.
        """

        if not self._useAero:
            return

        useWhidbey = (GetManager(self.GetParent()).GetAGWFlags() & AUI_MGR_WHIDBEY_DOCKING_GUIDES) != 0

        if useWhidbey:
            sizeX, sizeY = whidbeySizeX, whidbeySizeY
        else:
            sizeX, sizeY = aeroguideSizeX, aeroguideSizeY

        size = self.GetSize()

        leftRect, topRect, rightRect, bottomRect, centerRect = self._aeroRects
        thePos = pos + wx.Point((size.x-sizeY)/2, (size.y-sizeX)/2)

        centerRect.SetPosition(thePos)

        leftRect.SetPosition(thePos + wx.Point(-sizeY, 0))
        topRect.SetPosition(thePos + wx.Point(0, -sizeY))
        rightRect.SetPosition(thePos + wx.Point(sizeX, 0))
        bottomRect.SetPosition(thePos + wx.Point(0, sizeX))


    def OnEraseBackground(self, event):
        """
        Handles the ``wx.EVT_ERASE_BACKGROUND`` event for :class:`AuiCenterDockingGuide`.

        :param `event`: :class:`EraseEvent` to be processed.

        :note: This is intentionally empty to reduce flickering while drawing.
        """

        pass


    def OnPaint(self, event):
        """
        Handles the ``wx.EVT_PAINT`` event for :class:`AuiCenterDockingGuide`.

        :param `event`: a :class:`PaintEvent` to be processed.
        """

        dc = wx.AutoBufferedPaintDC(self)

        if self._useAero:
            dc.SetBrush(wx.TRANSPARENT_BRUSH)
            dc.SetPen(wx.TRANSPARENT_PEN)
        else:
            dc.SetBrush(wx.Brush(colourTargetBackground))
            dc.SetPen(wx.Pen(colourTargetBorder))

        rect = self.GetClientRect()
        dc.DrawRectangle(rect.x, rect.y, rect.width, rect.height)

        if self._useAero:
            dc.DrawBitmap(self._aeroBmp, 0, 0, True)
            if not self._valid:
                diff = (self._useAero == 2 and [1] or [0])[0]
                bmpX, bmpY = self._deniedBitmap.GetWidth(), self._deniedBitmap.GetHeight()
                xPos, yPos = (rect.x + (rect.width)/2 - bmpX/2), (rect.y + (rect.height)/2 - bmpY/2)
                dc.DrawBitmap(self._deniedBitmap, xPos+1, yPos+diff, True)

            return

        dc.SetPen(wx.Pen(colourTargetBorder, 2))
        for pts in self._triangles:
            dc.DrawLinePoint(pts[0], pts[1])


# ----------------------------------------------------------------------------
# AuiDockingHintWindow
# ----------------------------------------------------------------------------

class AuiDockingHintWindow(wx.Frame):
    """ The original wxAUI docking window hint. """

    def __init__(self, parent, id=wx.ID_ANY, title="", pos=wx.DefaultPosition,
                 size=wx.Size(1, 1), style=wx.FRAME_TOOL_WINDOW | wx.FRAME_FLOAT_ON_PARENT |
                 wx.FRAME_NO_TASKBAR | wx.NO_BORDER | wx.FRAME_SHAPED,
                 name="auiHintWindow"):
        """
        Default class constructor. Used internally, do not call it in your code!

        :param `parent`: the :class:`AuiManager` parent;
        :param integer `id`: the window identifier. It may take a value of -1 to indicate a default value.
        :param string `title`: the caption to be displayed on the frame's title bar;
        :param Point `pos`: the window position. A value of (-1, -1) indicates a default position,
         chosen by either the windowing system or wxPython, depending on platform;
        :param Size `size`: the window size. A value of (-1, -1) indicates a default size, chosen by
         either the windowing system or wxPython, depending on platform;
        :param integer `style`: the window style;
        :param string `name`: the name of the window. This parameter is used to associate a name with the
         item, allowing the application user to set Motif resource values for individual windows.
        """
        if wx.Platform == '__WXMAC__' and style & wx.FRAME_SHAPED:
            # Having the shaped frame causes the frame to not be visible
            # with the transparent style hints.
            style -= wx.FRAME_SHAPED

        wx.Frame.__init__(self, parent, id, title, pos, size, style, name=name)

        self._blindMode = False

        self._art = parent.GetEventHandler().GetArtProvider()
        background = self._art.GetColour(AUI_DOCKART_HINT_WINDOW_COLOUR)
        self.SetBackgroundColour(background)

        # Can't set background colour on a frame on wxMac
        # so add a panel to set the colour on.
        if wx.Platform == '__WXMAC__':
            sizer = wx.BoxSizer(wx.HORIZONTAL)
            self.panel = wx.Panel(self)
            sizer.Add(self.panel, 1, wx.EXPAND)
            self.SetSizer(sizer)
            self.panel.SetBackgroundColour(background)
        else:
            self.Bind(wx.EVT_PAINT, self.OnPaint)

        self.Bind(wx.EVT_SIZE, self.OnSize)


    def MakeVenetianBlinds(self):
        """
        Creates the "venetian blind" effect if :class:`AuiManager` has the ``AUI_MGR_VENETIAN_BLINDS_HINT``
        flag set.
        """

        amount = 128
        size = self.GetClientSize()
        region = wx.Region(0, 0, size.x, 1)

        for y in xrange(size.y):

            # Reverse the order of the bottom 4 bits
            j = (y & 8 and [1] or [0])[0] | (y & 4 and [2] or [0])[0] | \
                (y & 2 and [4] or [0])[0] | (y & 1 and [8] or [0])[0]

            if 16*j+8 < amount:
                region.Union(0, y, size.x, 1)

        self.SetShape(region)


    def SetBlindMode(self, agwFlags):
        """
        Sets whether venetian blinds or transparent hints will be shown as docking hint.
        This depends on the :class:`AuiManager` flags.

        :param integer `agwFlags`: the :class:`AuiManager` flags.
        """

        self._blindMode = (agwFlags & AUI_MGR_VENETIAN_BLINDS_HINT) != 0

        if self._blindMode or not self.CanSetTransparent():
            self.MakeVenetianBlinds()
            self.SetTransparent(255)

        else:
            self.SetShape(wx.Region())
            if agwFlags & AUI_MGR_HINT_FADE == 0:
                self.SetTransparent(80)
            else:
                self.SetTransparent(0)


    def SetShape(self, region):
        """
        If the platform supports it, sets the shape of the window to that depicted by `region`.
        The system will not display or respond to any mouse event for the pixels that lie
        outside of the region. To reset the window to the normal rectangular shape simply call
        :meth:`SetShape` again with an empty region.

        :param Region `region`: the shape of the frame.

        :note: Overridden for wxMAC.
        """

        if wx.Platform == '__WXMAC__':
            # HACK so we don't crash when SetShape is called
            return
        else:
            super(AuiDockingHintWindow, self).SetShape(region)


    def Show(self, show=True):
        """
        Show the hint window.

        :param bool `show`: whether to show or hide the hint docking window.
        """

        background = self._art.GetColour(AUI_DOCKART_HINT_WINDOW_COLOUR)

        if wx.Platform == '__WXMAC__':
            self.panel.SetBackgroundColour(background)
        else:
            self.SetBackgroundColour(background)

        super(AuiDockingHintWindow, self).Show(show)
        self.Refresh()

        if wx.Platform == '__WXMAC__':
            # Need to manually do layout since its a borderless frame.
            self.Layout()


    def OnSize(self, event):
        """
        Handles the ``wx.EVT_SIZE`` event for :class:`AuiDockingHintWindow`.

        :param `event`: a :class:`SizeEvent` to be processed.
        """

        if self._blindMode or not self.CanSetTransparent():
            self.MakeVenetianBlinds()

        self.Refresh()


    def OnPaint(self, event):
        """
        Handles the ``wx.EVT_PAINT`` event for :class:`AuiDockingHintWindow`.

        :param `event`: an instance of :class:`PaintEvent` to be processed.
        """

        rect = wx.RectPS(wx.Point(0, 0), self.GetSize())

        dc = wx.PaintDC(self)
        event.Skip()

        dc.SetBrush(wx.TRANSPARENT_BRUSH)
        dc.SetPen(wx.Pen(wx.Colour(60, 60, 60), 5))
        rect.Deflate(1, 1)
        dc.DrawRectangleRect(rect)


# ---------------------------------------------------------------------------- #

# -- AuiFloatingFrame class implementation --

class AuiFloatingFrame(wx.MiniFrame):
    """ AuiFloatingFrame is the frame class that holds floating panes. """

    def __init__(self, parent, owner_mgr, pane=None, id=wx.ID_ANY, title="",
                 style=wx.FRAME_TOOL_WINDOW | wx.FRAME_FLOAT_ON_PARENT |
                 wx.FRAME_NO_TASKBAR | wx.CLIP_CHILDREN):
        """
        Default class constructor. Used internally, do not call it in your code!

        :param `parent`: the :class:`AuiManager` parent;
        :param `owner_mgr`: the :class:`AuiManager` that manages the floating pane;
        :param `pane`: the :class:`AuiPaneInfo` pane that is about to float;
        :param integer `id`: the window identifier. It may take a value of -1 to indicate a default value.
        :param string `title`: the caption to be displayed on the frame's title bar.
        :param integer `style`: the window style.
        """

        if pane and pane.IsResizeable():
            style |= wx.RESIZE_BORDER
        if pane:
            self._is_toolbar = pane.IsToolbar()

        self._useNativeMiniframes = False
        if AuiManager_UseNativeMiniframes(owner_mgr):
            # On wxMac we always use native miniframes
            self._useNativeMiniframes = True
            # windows does not support min/max boxes nor toggling the state
            # of the close button. The only way to toggle that button is to
            # toggle the system menu style. But the close box flag needs to
            # be set from the beginning.
            if wx.Platform == '__WXMSW__':
                style |= wx.CAPTION | wx.CLOSE_BOX
                if pane.HasCloseButton():
                    style |= wx.SYSTEM_MENU
            else:
                style |= wx.CAPTION | wx.SYSTEM_MENU
                if pane.HasCloseButton():
                    style |= wx.CLOSE_BOX
                if pane.HasMaximizeButton():
                    style |= wx.MAXIMIZE_BOX
                if pane.HasMinimizeButton():
                    style |= wx.MINIMIZE_BOX

        wx.MiniFrame.__init__(self, parent, id, title, pos=pane.floating_pos,
                              size=pane.floating_size, style=style, name="auiFloatingFrame")

        self._fly_timer = wx.Timer(self, wx.ID_ANY)
        self._check_fly_timer = wx.Timer(self, wx.ID_ANY)

        self.Bind(wx.EVT_CLOSE, self.OnClose)
        self.Bind(wx.EVT_SIZE, self.OnSize)
        self.Bind(wx.EVT_ACTIVATE, self.OnActivate)
        self.Bind(wx.EVT_TIMER, self.OnCheckFlyTimer, self._check_fly_timer)
        self.Bind(wx.EVT_TIMER, self.OnFlyTimer, self._fly_timer)
        self.Bind(EVT_AUI_FIND_MANAGER, self.OnFindManager)

        if self._useNativeMiniframes:
            self.Bind(wx.EVT_MOVE, self.OnMoveEvent)
            self.Bind(wx.EVT_MOVING, self.OnMoveEvent)
            self.Bind(wx.EVT_IDLE, self.OnIdle)
            self._useNativeMiniframes = True
            self.SetExtraStyle(wx.WS_EX_PROCESS_IDLE)
        else:
            self.Bind(wx.EVT_MOVE, self.OnMove)

        self._fly = False
        self._send_size = True
        self._alpha_amount = 255

        self._owner_mgr = owner_mgr
        self._moving = False
        self._lastDirection = None
        self._transparent = 255

        self._last_rect = wx.Rect()
        self._last2_rect = wx.Rect()
        self._last3_rect = wx.Rect()

        self._mgr = AuiManager()
        self._mgr.SetManagedWindow(self)
        self._mgr.SetArtProvider(owner_mgr.GetArtProvider())
        self._mgr.SetAGWFlags(owner_mgr.GetAGWFlags())


    def CopyAttributes(self, pane):
        """
        Copies all the attributes of the input `pane` into another :class:`AuiPaneInfo`.

        :param `pane`: the source :class:`AuiPaneInfo` from where to copy attributes.
        """

        contained_pane = AuiPaneInfo()

        contained_pane.name = pane.name
        contained_pane.caption = pane.caption
        contained_pane.window = pane.window
        contained_pane.frame = pane.frame
        contained_pane.state = pane.state
        contained_pane.dock_direction = pane.dock_direction
        contained_pane.dock_layer = pane.dock_layer
        contained_pane.dock_row = pane.dock_row
        contained_pane.dock_pos = pane.dock_pos
        contained_pane.best_size = wx.Size(*pane.best_size)
        contained_pane.min_size = wx.Size(*pane.min_size)
        contained_pane.max_size = wx.Size(*pane.max_size)
        contained_pane.floating_pos = wx.Point(*pane.floating_pos)
        contained_pane.floating_size = wx.Size(*pane.floating_size)
        contained_pane.dock_proportion = pane.dock_proportion
        contained_pane.buttons = pane.buttons
        contained_pane.rect = wx.Rect(*pane.rect)
        contained_pane.icon = pane.icon
        contained_pane.notebook_id = pane.notebook_id
        contained_pane.transparent = pane.transparent
        contained_pane.snapped = pane.snapped
        contained_pane.minimize_mode = pane.minimize_mode
        contained_pane.minimize_target = pane.minimize_target

        return contained_pane


    def SetPaneWindow(self, pane):
        """
        Sets all the properties of a pane.

        :param `pane`: the :class:`AuiPaneInfo` to analyze.
        """

        self._is_toolbar = pane.IsToolbar()
        self._pane_window = pane.window

        if isinstance(pane.window, auibar.AuiToolBar):
            pane.window.SetAuiManager(self._mgr)

        self._pane_window.Reparent(self)

        contained_pane = self.CopyAttributes(pane)

        contained_pane.Dock().Center().Show(). \
                       CaptionVisible(False). \
                       PaneBorder(False). \
                       Layer(0).Row(0).Position(0)

        if not contained_pane.HasGripper() and not self._useNativeMiniframes:
            contained_pane.CaptionVisible(True)

        indx = self._owner_mgr._panes.index(pane)

        # Carry over the minimum size
        pane_min_size = pane.window.GetMinSize()

        # if the best size is smaller than the min size
        # then set the min size to the best size as well
        pane_best_size = contained_pane.best_size
        if pane_best_size.IsFullySpecified() and (pane_best_size.x < pane_min_size.x or \
                                                  pane_best_size.y < pane_min_size.y):

            pane_min_size = pane_best_size
            self._pane_window.SetMinSize(pane_min_size)

        # if the frame window's max size is greater than the min size
        # then set the max size to the min size as well
        cur_max_size = self.GetMaxSize()
        if cur_max_size.IsFullySpecified() and  (cur_max_size.x < pane_min_size.x or \
                                                 cur_max_size.y < pane_min_size.y):
            self.SetMaxSize(pane_min_size)

        art_provider = self._mgr.GetArtProvider()
        caption_size = art_provider.GetMetric(AUI_DOCKART_CAPTION_SIZE)
        button_size = art_provider.GetMetric(AUI_DOCKART_PANE_BUTTON_SIZE) + \
                      4*art_provider.GetMetric(AUI_DOCKART_PANE_BORDER_SIZE)

        min_size = pane.window.GetMinSize()

        if min_size.y < caption_size or min_size.x < button_size:
            new_x, new_y = min_size.x, min_size.y
            if min_size.y < caption_size:
                new_y = (pane.IsResizeable() and [2*wx.SystemSettings.GetMetric(wx.SYS_EDGE_Y)+caption_size] or [1])[0]
            if min_size.x < button_size:
                new_x = (pane.IsResizeable() and [2*wx.SystemSettings.GetMetric(wx.SYS_EDGE_X)+button_size] or [1])[0]

            self.SetMinSize((new_x, new_y))
        else:
            self.SetMinSize(min_size)

        self._mgr.AddPane(self._pane_window, contained_pane)
        self._mgr.Update()

        if pane.min_size.IsFullySpecified():
            # because SetSizeHints() calls Fit() too (which sets the window
            # size to its minimum allowed), we keep the size before calling
            # SetSizeHints() and reset it afterwards...
            tmp = self.GetSize()
            self.GetSizer().SetSizeHints(self)
            self.SetSize(tmp)

        self.SetTitle(pane.caption)

        if pane.floating_size != wx.Size(-1, -1):
            self.SetSize(pane.floating_size)
        else:
            size = pane.best_size
            if size == wx.Size(-1, -1):
                size = pane.min_size
            if size == wx.Size(-1, -1):
                size = self._pane_window.GetSize()
            if self._owner_mgr and pane.HasGripper():
                if pane.HasGripperTop():
                    size.y += self._owner_mgr._art.GetMetric(AUI_DOCKART_GRIPPER_SIZE)
                else:
                    size.x += self._owner_mgr._art.GetMetric(AUI_DOCKART_GRIPPER_SIZE)

            if not self._useNativeMiniframes:
                size.y += self._owner_mgr._art.GetMetric(AUI_DOCKART_CAPTION_SIZE)

            pane.floating_size = size

            self.SetClientSize(size)

        self._owner_mgr._panes[indx] = pane

        self._fly_step = abs(pane.floating_size.y - \
                             (caption_size + 2*wx.SystemSettings.GetMetric(wx.SYS_EDGE_Y)))/10

        self._floating_size = wx.Size(*self.GetSize())

        if pane.IsFlyOut():
            self._check_fly_timer.Start(50)


    def GetOwnerManager(self):
        """ Returns the :class:`AuiManager` that manages the pane. """

        return self._owner_mgr


    def OnSize(self, event):
        """
        Handles the ``wx.EVT_SIZE`` event for :class:`AuiFloatingFrame`.

        :param `event`: a :class:`SizeEvent` to be processed.
        """

        if self._owner_mgr and self._send_size:
            self._owner_mgr.OnFloatingPaneResized(self._pane_window, event.GetSize())


    def OnClose(self, event):
        """
        Handles the ``wx.EVT_CLOSE`` event for :class:`AuiFloatingFrame`.

        :param `event`: a :class:`CloseEvent` to be processed.
        """

        if self._owner_mgr:
            self._owner_mgr.OnFloatingPaneClosed(self._pane_window, event)

        if not event.GetVeto():
            self._mgr.DetachPane(self._pane_window)

            if isinstance(self._pane_window, auibar.AuiToolBar):
                self._pane_window.SetAuiManager(self._owner_mgr)

            # if we do not do this, then we can crash...
            if self._owner_mgr and self._owner_mgr._action_window == self:
                self._owner_mgr._action_window = None

            self._mgr.UnInit()
            self.Destroy()


    def OnActivate(self, event):
        """
        Handles the ``wx.EVT_ACTIVATE`` event for :class:`AuiFloatingFrame`.

        :param `event`: a :class:`ActivateEvent` to be processed.
        """

        if self._owner_mgr and event.GetActive():
            self._owner_mgr.OnFloatingPaneActivated(self._pane_window)


    def OnMove(self, event):
        """
        Handles the ``wx.EVT_MOVE`` event for :class:`AuiFloatingFrame`.

        :param `event`: a :class:`MoveEvent` to be processed.

        .. note::

           This event is not processed on wxMAC or if :class:`AuiManager` is not using the
           ``AUI_MGR_USE_NATIVE_MINIFRAMES`` style.

        """

        if self._owner_mgr:
            self._owner_mgr.OnFloatingPaneMoved(self._pane_window, event)


    def OnMoveEvent(self, event):
        """
        Handles the ``wx.EVT_MOVE`` and ``wx.EVT_MOVING`` events for :class:`AuiFloatingFrame`.

        :param `event`: a :class:`MoveEvent` to be processed.

        .. note::

           This event is only processed on wxMAC or if :class:`AuiManager` is using the
           ``AUI_MGR_USE_NATIVE_MINIFRAMES`` style.
        """

        win_rect = self.GetRect()

        if win_rect == self._last_rect:
            return

        # skip the first move event
        if self._last_rect.IsEmpty():
            self._last_rect = wx.Rect(*win_rect)
            return

        # As on OSX moving windows are not getting all move events, only sporadically, this difference
        # is almost always big on OSX, so avoid this early exit opportunity
        if wx.Platform != '__WXMAC__':
            # skip if moving too fast to avoid massive redraws and
            # jumping hint windows
            if abs(win_rect.x - self._last_rect.x) > 3 or abs(win_rect.y - self._last_rect.y) > 3:
                self._last3_rect = wx.Rect(*self._last2_rect)
                self._last2_rect = wx.Rect(*self._last_rect)
                self._last_rect = wx.Rect(*win_rect)

                # However still update the internally stored position to avoid
                # snapping back to the old one later.
                if self._owner_mgr:
                    self._owner_mgr.GetPane(self._pane_window).floating_pos = win_rect.GetPosition()

                return

        # prevent frame redocking during resize
        if self._last_rect.GetSize() != win_rect.GetSize():
            self._last3_rect = wx.Rect(*self._last2_rect)
            self._last2_rect = wx.Rect(*self._last_rect)
            self._last_rect = wx.Rect(*win_rect)
            return

        dir = wx.ALL

        horiz_dist = abs(win_rect.x - self._last3_rect.x)
        vert_dist = abs(win_rect.y - self._last3_rect.y)

        if vert_dist >= horiz_dist:
            if win_rect.y < self._last3_rect.y:
                dir = wx.NORTH
            else:
                dir = wx.SOUTH
        else:
            if win_rect.x < self._last3_rect.x:
                dir = wx.WEST
            else:
                dir = wx.EAST

        self._last3_rect = wx.Rect(*self._last2_rect)
        self._last2_rect = wx.Rect(*self._last_rect)
        self._last_rect = wx.Rect(*win_rect)

        if _VERSION_STRING < "2.9":
            leftDown = wx.GetMouseState().LeftDown()
        else:
            leftDown = wx.GetMouseState().LeftIsDown()

        if not leftDown:
            return

        if not self._moving:
            self.OnMoveStart(event)
            self._moving = True

        if self._last3_rect.IsEmpty():
            return

        if event.GetEventType() == wx.wxEVT_MOVING:
            self.OnMoving(event.GetRect(), dir)
        else:
            self.OnMoving(wx.RectPS(event.GetPosition(), self.GetSize()), dir)


    def OnIdle(self, event):
        """
        Handles the ``wx.EVT_IDLE`` event for :class:`AuiFloatingFrame`.

        :param `event`: a :class:`IdleEvent` event to be processed.

        .. note::

           This event is only processed on wxMAC if :class:`AuiManager` is using the
           ``AUI_MGR_USE_NATIVE_MINIFRAMES`` style.

        """

        if self._moving:
            if _VERSION_STRING < "2.9":
                leftDown = wx.GetMouseState().LeftDown()
            else:
                leftDown = wx.GetMouseState().LeftIsDown()

            if not leftDown:
                self._moving = False
                self.OnMoveFinished()
            else:
                event.RequestMore()


    def OnMoveStart(self, event):
        """
        The user has just started moving the floating pane.

        :param `event`: an instance of :class:`MouseEvent`.

        .. note::

           This event is only processed on wxMAC if :class:`AuiManager` is using the
           ``AUI_MGR_USE_NATIVE_MINIFRAMES`` style.

        """

        # notify the owner manager that the pane has started to move
        if self._owner_mgr:
            if self._owner_mgr._from_move:
                return
            self._owner_mgr._action_window = self._pane_window
            point = wx.GetMousePosition()
            action_offset = point - self.GetPosition()

            if self._is_toolbar:
                self._owner_mgr._toolbar_action_offset = action_offset
                self._owner_mgr.OnMotion_DragToolbarPane(point)
            else:
                self._owner_mgr._action_offset = action_offset
                self._owner_mgr.OnMotion_DragFloatingPane(point)


    def OnMoving(self, rect, direction):
        """
        The user is moving the floating pane.

        :param Rect `rect`: the pane client rectangle;
        :param integer `direction`: the direction in which the pane is moving, can be one of
         ``wx.NORTH``, ``wx.SOUTH``, ``wx.EAST`` or ``wx.WEST``.

        .. note::

           This event is only processed on wxMAC if :class:`AuiManager` is using the
           ``AUI_MGR_USE_NATIVE_MINIFRAMES`` style.
        """

        # notify the owner manager that the pane is moving
        self.OnMoveStart(None)
        self._lastDirection = direction


    def OnMoveFinished(self):
        """
        The user has just finished moving the floating pane.

        .. note::

           This method is used only on wxMAC if :class:`AuiManager` is using the
           ``AUI_MGR_USE_NATIVE_MINIFRAMES`` style.

        """

        # notify the owner manager that the pane has finished moving
        if self._owner_mgr:
            self._owner_mgr._action_window = self._pane_window
            point = wx.GetMousePosition()
            if self._is_toolbar:
                self._owner_mgr.OnLeftUp_DragToolbarPane(point)
            else:
                self._owner_mgr.OnLeftUp_DragFloatingPane(point)

            self._owner_mgr.OnFloatingPaneMoved(self._pane_window, point)


    def OnCheckFlyTimer(self, event):
        """
        Handles the ``wx.EVT_TIMER`` event for :class:`AuiFloatingFrame`.

        :param `event`: a :class:`TimerEvent` to be processed.

        :note: This is used solely for "fly-out" panes.
        """

        if self._owner_mgr:
            pane = self._mgr.GetPane(self._pane_window)
            if pane.IsFlyOut():
                if self.IsShownOnScreen():
                    self.FlyOut()


    def OnFindManager(self, event):
        """
        Handles the ``EVT_AUI_FIND_MANAGER`` event for :class:`AuiFloatingFrame`.

        :param `event`: a :class:`AuiManagerEvent` event to be processed.
        """

        event.SetManager(self._owner_mgr)


    def FlyOut(self):
        """ Starts the flying in and out of a floating pane. """

        if self._fly_timer.IsRunning():
            return

        if _VERSION_STRING < "2.9":
            leftDown = wx.GetMouseState().LeftDown()
        else:
            leftDown = wx.GetMouseState().LeftIsDown()

        if leftDown:
            return

        rect = wx.Rect(*self.GetScreenRect())
        rect.Inflate(10, 10)

        if rect.Contains(wx.GetMousePosition()):
            if not self._fly:
                return
            self._send_size = False
            self._fly_timer.Start(5)
        else:
            if self._fly:
                return
            self._send_size = False
            self._fly_timer.Start(5)


    def OnFlyTimer(self, event):
        """
        Handles the ``wx.EVT_TIMER`` event for :class:`AuiFloatingFrame`.

        :param `event`: a :class:`TimerEvent` to be processed.
        """

        current_size = self.GetClientSize()
        floating_size = wx.Size(*self._owner_mgr.GetPane(self._pane_window).floating_size)

        if floating_size.y == -1:
            floating_size = self._floating_size

        if not self._fly:
            min_size = self._mgr.GetArtProvider().GetMetric(AUI_DOCKART_CAPTION_SIZE)

            if wx.Platform != "__WXMSW__":
                min_size += 2*wx.SystemSettings.GetMetric(wx.SYS_EDGE_Y)

            if current_size.y - self._fly_step <= min_size:
                self.SetClientSize((current_size.x, min_size))
                self._fly = True
                self._fly_timer.Stop()
                self._send_size = True
            else:
                self.SetClientSize((current_size.x, current_size.y-self._fly_step))

        else:
            if current_size.y + self._fly_step >= floating_size.y:
                self.SetClientSize((current_size.x, floating_size.y))
                self._fly = False
                self._fly_timer.Stop()
                self._send_size = True
            else:
                self.SetClientSize((current_size.x, current_size.y+self._fly_step))

        self.Update()
        self.Refresh()


    def FadeOut(self):
        """ Actually starts the fading out of the floating pane. """

        while 1:
            self._alpha_amount -= 10
            if self._alpha_amount <= 0:
                self._alpha_amount = 255
                return

            self.SetTransparent(self._alpha_amount)
            wx.SafeYield()
            wx.MilliSleep(15)


# -- static utility functions --

def DrawResizeHint(dc, rect):
    """
    Draws a resize hint while a sash is dragged.

    :param Rect `rect`: a rectangle which specifies the sash dimensions.
    """

    if wx.Platform == "__WXMSW__" and wx.App.GetComCtl32Version() >= 600:
        if wx.GetOsVersion()[1] > 5:
            # Windows Vista
            dc.SetPen(wx.Pen("black", 2, wx.SOLID))
            dc.SetBrush(wx.TRANSPARENT_BRUSH)
        else:
            # Draw the nice XP style splitter
            dc.SetPen(wx.TRANSPARENT_PEN)
            dc.SetBrush(wx.BLACK_BRUSH)
        dc.SetLogicalFunction(wx.INVERT)
        dc.DrawRectangleRect(rect)
        dc.SetLogicalFunction(wx.COPY)
    else:
        stipple = PaneCreateStippleBitmap()
        brush = wx.BrushFromBitmap(stipple)
        dc.SetBrush(brush)
        dc.SetPen(wx.TRANSPARENT_PEN)

        dc.SetLogicalFunction(wx.XOR)
        dc.DrawRectangleRect(rect)


def CopyDocksAndPanes(src_docks, src_panes):
    """
    This utility function creates shallow copies of
    the dock and pane info. :class:`AuiManager` usually contain pointers
    to :class:`AuiPaneInfo` classes, thus this function is necessary to reliably
    reconstruct that relationship in the new dock info and pane info arrays.

    :param `src_docks`: a list of :class:`AuiDockInfo` classes;
    :param `src_panes`: a list of :class:`AuiPaneInfo` classes.
    """

    dest_docks = src_docks
    dest_panes = src_panes

    for ii in xrange(len(dest_docks)):
        dock = dest_docks[ii]
        for jj in xrange(len(dock.panes)):
            for kk in xrange(len(src_panes)):
                if dock.panes[jj] == src_panes[kk]:
                    dock.panes[jj] = dest_panes[kk]

    return dest_docks, dest_panes


def CopyDocksAndPanes2(src_docks, src_panes):
    """
    This utility function creates full copies of
    the dock and pane info. :class:`AuiManager` usually contain pointers
    to :class:`AuiPaneInfo` classes, thus this function is necessary to reliably
    reconstruct that relationship in the new dock info and pane info arrays.

    :param `src_docks`: a list of :class:`AuiDockInfo` classes;
    :param `src_panes`: a list of :class:`AuiPaneInfo` classes.
    """

    dest_docks = []

    for ii in xrange(len(src_docks)):
        dest_docks.append(AuiDockInfo())
        dest_docks[ii].dock_direction = src_docks[ii].dock_direction
        dest_docks[ii].dock_layer = src_docks[ii].dock_layer
        dest_docks[ii].dock_row = src_docks[ii].dock_row
        dest_docks[ii].size = src_docks[ii].size
        dest_docks[ii].min_size = src_docks[ii].min_size
        dest_docks[ii].resizable = src_docks[ii].resizable
        dest_docks[ii].fixed = src_docks[ii].fixed
        dest_docks[ii].toolbar = src_docks[ii].toolbar
        dest_docks[ii].panes = src_docks[ii].panes
        dest_docks[ii].rect = wx.Rect(*src_docks[ii].rect)

    dest_panes = []

    for ii in xrange(len(src_panes)):
        dest_panes.append(AuiPaneInfo())
        dest_panes[ii].name = src_panes[ii].name
        dest_panes[ii].caption = src_panes[ii].caption
        dest_panes[ii].window = src_panes[ii].window
        dest_panes[ii].frame = src_panes[ii].frame
        dest_panes[ii].state = src_panes[ii].state
        dest_panes[ii].dock_direction = src_panes[ii].dock_direction
        dest_panes[ii].dock_layer = src_panes[ii].dock_layer
        dest_panes[ii].dock_row = src_panes[ii].dock_row
        dest_panes[ii].dock_pos = src_panes[ii].dock_pos
        dest_panes[ii].best_size = wx.Size(*src_panes[ii].best_size)
        dest_panes[ii].min_size = wx.Size(*src_panes[ii].min_size)
        dest_panes[ii].max_size = wx.Size(*src_panes[ii].max_size)
        dest_panes[ii].floating_pos = wx.Point(*src_panes[ii].floating_pos)
        dest_panes[ii].floating_size = wx.Size(*src_panes[ii].floating_size)
        dest_panes[ii].dock_proportion = src_panes[ii].dock_proportion
        dest_panes[ii].buttons = src_panes[ii].buttons
        dest_panes[ii].rect = wx.Rect(*src_panes[ii].rect)
        dest_panes[ii].icon = src_panes[ii].icon
        dest_panes[ii].notebook_id = src_panes[ii].notebook_id
        dest_panes[ii].transparent = src_panes[ii].transparent
        dest_panes[ii].snapped = src_panes[ii].snapped
        dest_panes[ii].minimize_mode = src_panes[ii].minimize_mode
        dest_panes[ii].minimize_target = src_panes[ii].minimize_target

    for ii in xrange(len(dest_docks)):
        dock = dest_docks[ii]
        for jj in xrange(len(dock.panes)):
            for kk in xrange(len(src_panes)):
                if dock.panes[jj] == src_panes[kk]:
                    dock.panes[jj] = dest_panes[kk]

        dest_docks[ii] = dock

    return dest_docks, dest_panes


def GetMaxLayer(docks, dock_direction):
    """
    This is an internal function which returns
    the highest layer inside the specified dock.

    :param `docks`: a list of :class:`AuiDockInfo`;
    :param `dock_direction`: the :class:`AuiDockInfo` docking direction to analyze.
    """

    max_layer = 0

    for dock in docks:
        if dock.dock_direction == dock_direction and dock.dock_layer > max_layer and not dock.fixed:
            max_layer = dock.dock_layer

    return max_layer


def GetMaxRow(panes, dock_direction, dock_layer):
    """
    This is an internal function which returns
    the highest layer inside the specified dock.

    :param `panes`: a list of :class:`AuiPaneInfo`;
    :param integer `dock_direction`: the :class:`AuiDockInfo` docking direction to analyze;
    :param integer `dock_layer`: the :class:`AuiDockInfo` layer to analyze.
    """

    max_row = 0

    for pane in panes:
        if pane.dock_direction == dock_direction and pane.dock_layer == dock_layer and \
           pane.dock_row > max_row:
            max_row = pane.dock_row

    return max_row


def DoInsertDockLayer(panes, dock_direction, dock_layer):
    """
    This is an internal function that inserts a new dock
    layer by incrementing all existing dock layer values by one.

    :param `panes`: a list of :class:`AuiPaneInfo`;
    :param integer `dock_direction`: the :class:`AuiDockInfo` docking direction to analyze;
    :param integer `dock_layer`: the :class:`AuiDockInfo` layer to analyze.
    """

    for ii in xrange(len(panes)):
        pane = panes[ii]
        if not pane.IsFloating() and pane.dock_direction == dock_direction and pane.dock_layer >= dock_layer:
            pane.dock_layer = pane.dock_layer + 1

        panes[ii] = pane

    return panes


def DoInsertDockRow(panes, dock_direction, dock_layer, dock_row):
    """
    This is an internal function that inserts a new dock
    row by incrementing all existing dock row values by one.

    :param `panes`: a list of :class:`AuiPaneInfo`;
    :param integer `dock_direction`: the :class:`AuiDockInfo` docking direction to analyze;
    :param integer `dock_layer`: the :class:`AuiDockInfo` layer to analyze;
    :param integer `dock_row`: the :class:`AuiDockInfo` row to analyze.
    """

    for pane in panes:
        if not pane.IsFloating() and pane.dock_direction == dock_direction and \
           pane.dock_layer == dock_layer and pane.dock_row >= dock_row:
            pane.dock_row += 1

    return panes


def DoInsertPane(panes, dock_direction, dock_layer, dock_row, dock_pos):
    """
    This is an internal function that inserts a new pane
    by incrementing all existing dock position values by one.

    :param `panes`: a list of :class:`AuiPaneInfo`;
    :param integer `dock_direction`: the :class:`AuiDockInfo` docking direction to analyze;
    :param integer `dock_layer`: the :class:`AuiDockInfo` layer to analyze.
    :param integer `dock_row`: the :class:`AuiDockInfo` row to analyze;
    :param integer `dock_pos`: the :class:`AuiDockInfo` position to analyze.
    """

    for ii in xrange(len(panes)):
        pane = panes[ii]
        if not pane.IsFloating() and pane.dock_direction == dock_direction and \
           pane.dock_layer == dock_layer and  pane.dock_row == dock_row and \
           pane.dock_pos >= dock_pos:
            pane.dock_pos = pane.dock_pos + 1

        panes[ii] = pane

    return panes


def FindDocks(docks, dock_direction, dock_layer=-1, dock_row=-1, reverse=False):
    """
    This is an internal function that returns a list of docks which meet
    the specified conditions in the parameters and returns a sorted array
    (sorted by layer and then row).

    :param `docks`: a list of :class:`AuiDockInfo`;
    :param integer `dock_direction`: the :class:`AuiDockInfo` docking direction to analyze;
    :param integer `dock_layer`: the :class:`AuiDockInfo` layer to analyze.
    :param integer `dock_row`: the :class:`AuiDockInfo` row to analyze;
    """

    matchDocks = [(d.dock_layer, d.dock_row, d.dock_direction, d) for d in docks if \
                  (dock_direction == -1 or dock_direction == d.dock_direction) and \
                  ((dock_layer == -1 or dock_layer == d.dock_layer) and \
                  (dock_row == -1 or dock_row == d.dock_row))]

    arr = [x[-1] for x in sorted(matchDocks, reverse=reverse)]

    return arr


def FindOppositeDocks(docks, dock_direction):
    """
    This is an internal function that returns a list of docks
    which is related to the opposite direction.

    :param `docks`: a list of :class:`AuiDockInfo`;
    :param integer `dock_direction`: the :class:`AuiDockInfo` docking direction to analyze;
    """

    if dock_direction == AUI_DOCK_LEFT:
        arr = FindDocks(docks, AUI_DOCK_RIGHT, -1, -1)
    elif dock_direction == AUI_DOCK_TOP:
        arr = FindDocks(docks, AUI_DOCK_BOTTOM, -1, -1)
    elif dock_direction == AUI_DOCK_RIGHT:
        arr = FindDocks(docks, AUI_DOCK_LEFT, -1, -1)
    elif dock_direction == AUI_DOCK_BOTTOM:
        arr = FindDocks(docks, AUI_DOCK_TOP, -1, -1)

    return arr


def FindPaneInDock(dock, window):
    """
    This method looks up a specified window pointer inside a dock.
    If found, the corresponding :class:`AuiDockInfo` pointer is returned, otherwise ``None``.

    :param `dock`: a :class:`AuiDockInfo` structure;
    :param Window `window`: the window associated to the pane we are seeking.
    """

    for p in dock.panes:
        if p.window == window:
            return p

    return None


def GetToolBarDockOffsets(docks):
    """
    Returns the toolbar dock offsets (top-left and bottom-right).

    :param `docks`: a list of :class:`AuiDockInfo` to analyze.
    """

    top_left = wx.Size(0, 0)
    bottom_right = wx.Size(0, 0)

    for dock in docks:
        if dock.toolbar:
            dock_direction = dock.dock_direction
            if dock_direction == AUI_DOCK_LEFT:
                top_left.x += dock.rect.width
                bottom_right.x += dock.rect.width

            elif dock_direction == AUI_DOCK_TOP:
                top_left.y += dock.rect.height
                bottom_right.y += dock.rect.height

            elif dock_direction == AUI_DOCK_RIGHT:
                bottom_right.x += dock.rect.width

            elif dock_direction == AUI_DOCK_BOTTOM:
                bottom_right.y += dock.rect.height

    return top_left, bottom_right


def GetInternalFrameRect(window, docks):
    """
    Returns the window rectangle excluding toolbars.

    :param `window`: a :class:`Window` derived window;
    :param `docks`: a list of :class:`AuiDockInfo` structures.
    """

    frameRect = wx.Rect()

    frameRect.SetTopLeft(window.ClientToScreen(window.GetClientAreaOrigin()))
    frameRect.SetSize(window.GetClientSize())

    top_left, bottom_right = GetToolBarDockOffsets(docks)

    # make adjustments for toolbars
    frameRect.x += top_left.x
    frameRect.y += top_left.y
    frameRect.width -= bottom_right.x
    frameRect.height -= bottom_right.y

    return frameRect


def CheckOutOfWindow(window, pt):
    """
    Checks if a point is outside the window rectangle.

    :param `window`: a :class:`Window` derived window;
    :param `pt`: a :class:`Point` object.
    """

    auiWindowMargin = 30
    marginRect = wx.Rect(*window.GetClientRect())
    marginRect.Inflate(auiWindowMargin, auiWindowMargin)

    return not marginRect.Contains(pt)


def CheckEdgeDrop(window, docks, pt):
    """
    Checks on which edge of a window the drop action has taken place.

    :param `window`: a :class:`Window` derived window;
    :param `docks`: a list of :class:`AuiDockInfo` structures;
    :param `pt`: a :class:`Point` object.
    """

    screenPt = window.ClientToScreen(pt)
    clientSize = window.GetClientSize()
    frameRect = GetInternalFrameRect(window, docks)

    if screenPt.y >= frameRect.GetTop() and screenPt.y < frameRect.GetBottom():
        if pt.x < auiLayerInsertOffset and pt.x > auiLayerInsertOffset - auiLayerInsertPixels:
            return wx.LEFT

        if pt.x >= clientSize.x - auiLayerInsertOffset and \
           pt.x < clientSize.x - auiLayerInsertOffset + auiLayerInsertPixels:
            return wx.RIGHT

    if screenPt.x >= frameRect.GetLeft() and screenPt.x < frameRect.GetRight():
        if pt.y < auiLayerInsertOffset and pt.y > auiLayerInsertOffset - auiLayerInsertPixels:
            return wx.TOP

        if pt.y >= clientSize.y - auiLayerInsertOffset and \
           pt.y < clientSize.y - auiLayerInsertOffset + auiLayerInsertPixels:
            return wx.BOTTOM

    return -1


def RemovePaneFromDocks(docks, pane, exc=None):
    """
    Removes a pane window from all docks
    with a possible exception specified by parameter `exc`.

    :param `docks`: a list of :class:`AuiDockInfo` structures;
    :param AuiPaneInfo `pane`: the pane to be removed;
    :param AuiPaneInfo `exc`: the possible pane exception.
    """

    for ii in xrange(len(docks)):
        d = docks[ii]
        if d == exc:
            continue
        pi = FindPaneInDock(d, pane.window)
        if pi:
            d.panes.remove(pi)

        docks[ii] = d

    return docks


def RenumberDockRows(docks):
    """
    Takes a dock and assigns sequential numbers
    to existing rows.  Basically it takes out the gaps so if a
    dock has rows with numbers 0, 2, 5, they will become 0, 1, 2.

    :param `docks`: a list of :class:`AuiDockInfo` structures.
    """

    for ii in xrange(len(docks)):
        dock = docks[ii]
        dock.dock_row = ii
        for jj in xrange(len(dock.panes)):
            dock.panes[jj].dock_row = ii

        docks[ii] = dock

    return docks


def SetActivePane(panes, active_pane):
    """
    Sets the active pane, as well as cycles through
    every other pane and makes sure that all others' active flags
    are turned off.

    :param `panes`: a list of :class:`AuiPaneInfo` structures;
    :param AuiPaneInfo `active_pane`: the pane to be made active (if found).
    """

    for pane in panes:
        pane.state &= ~AuiPaneInfo.optionActive

    for pane in panes:
        if pane.window == active_pane and not pane.IsNotebookPage():
            pane.state |= AuiPaneInfo.optionActive
            return True, panes

    return False, panes


def ShowDockingGuides(guides, show):
    """
    Shows or hide the docking guide windows.

    :param `guides`: a list of :class:`AuiDockingGuide` classes;
    :param bool `show`: whether to show or hide the docking guide windows.
    """

    for target in guides:

        if show and not target.host.IsShown():
            target.host.Show()
            target.host.Update()

        elif not show and target.host.IsShown():
            target.host.Hide()


def RefreshDockingGuides(guides):
    """
    Refreshes the docking guide windows.

    :param `guides`: a list of :class:`AuiDockingGuide` classes;
    """

    for target in guides:
        if target.host.IsShown():
            target.host.Refresh()


def PaneSortFunc(p1, p2):
    """
    This function is used to sort panes by dock position.

    :param AuiPaneInfo `p1`: the first pane instance to compare;
    :param AuiPaneInfo `p2`: the second pane instance to compare.
    """

    return (p1.dock_pos < p2.dock_pos and [-1] or [1])[0]


def GetNotebookRoot(panes, notebook_id):
    """
    Returns the :class:`~lib.agw.aui.auibook.AuiNotebook` which has the specified `notebook_id`.

    :param `panes`: a list of :class:`AuiPaneInfo` instances;
    :param integer `notebook_id`: the target notebook id.
    """

    for paneInfo in panes:
        if paneInfo.IsNotebookControl() and paneInfo.notebook_id == notebook_id:
            return paneInfo

    return None


def EscapeDelimiters(s):
    """
    Changes ``;`` into ``\`` and ``|`` into ``\|`` in the input string.

    :param string `s`: the string to be analyzed.

    :note: This is an internal functions which is used for saving perspectives.
    """

    result = s.replace(";", "\\")
    result = result.replace("|", "|\\")

    return result


def IsDifferentDockingPosition(pane1, pane2):
    """
    Returns whether `pane1` and `pane2` are in a different docking position
    based on pane status, docking direction, docking layer and docking row.

    :param `pane1`: a :class:`AuiPaneInfo` instance;
    :param `pane2`: another :class:`AuiPaneInfo` instance.
    """

    return pane1.IsFloating() != pane2.IsFloating() or \
           pane1.dock_direction != pane2.dock_direction or \
           pane1.dock_layer != pane2.dock_layer or \
           pane1.dock_row != pane2.dock_row


# Convenience function
def AuiManager_HasLiveResize(manager):
    """
    Static function which returns if the input `manager` should have "live resize"
    behaviour.

    :param `manager`: an instance of :class:`AuiManager`.

    .. note::

       This method always returns ``True`` on wxMAC as this platform doesn't have
       the ability to use :class:`ScreenDC` to draw sashes.

    """

    # With Core Graphics on Mac, it's not possible to show sash feedback,
    # so we'll always use live update instead.

    if wx.Platform == "__WXMAC__":
        return True
    else:
        return (manager.GetAGWFlags() & AUI_MGR_LIVE_RESIZE) == AUI_MGR_LIVE_RESIZE


# Convenience function
def AuiManager_UseNativeMiniframes(manager):
    """
    Static function which returns if the input `manager` should use native :class:`MiniFrame` as
    floating panes.

    :param `manager`: an instance of :class:`AuiManager`.

    .. note::

       This method always returns ``True`` on wxMAC as this platform doesn't have
       the ability to use custom drawn miniframes.

    """

    # With Core Graphics on Mac, it's not possible to show sash feedback,
    # so we'll always use live update instead.

    if wx.Platform == "__WXMAC__":
        return True
    else:
        return (manager.GetAGWFlags() & AUI_MGR_USE_NATIVE_MINIFRAMES) == AUI_MGR_USE_NATIVE_MINIFRAMES


def GetManager(window):
    """
    This function will return the aui manager for a given window.

    :param Window `window`: this parameter should be any child window or grand-child
     window (and so on) of the frame/window managed by :class:`AuiManager`. The window
     does not need to be managed by the manager itself, nor does it even need
     to be a child or sub-child of a managed window. It must however be inside
     the window hierarchy underneath the managed window.
    """

    if not isinstance(wx.GetTopLevelParent(window), AuiFloatingFrame):
        if isinstance(window, auibar.AuiToolBar):
            return window.GetAuiManager()

    evt = AuiManagerEvent(wxEVT_AUI_FIND_MANAGER)
    evt.SetManager(None)
    evt.ResumePropagation(wx.EVENT_PROPAGATE_MAX)

    if not window.GetEventHandler().ProcessEvent(evt):
        return None

    return evt.GetManager()


# ---------------------------------------------------------------------------- #

class AuiManager(wx.EvtHandler):
    """
    AuiManager manages the panes associated with it for a particular :class:`Frame`,
    using a pane's :class:`AuiManager` information to determine each pane's docking and
    floating behavior. :class:`AuiManager` uses wxPython's sizer mechanism to plan the
    layout of each frame. It uses a replaceable dock art class to do all drawing,
    so all drawing is localized in one area, and may be customized depending on an
    applications' specific needs.

    :class:`AuiManager` works as follows: the programmer adds panes to the class, or makes
    changes to existing pane properties (dock position, floating state, show state, etc...).
    To apply these changes, the :meth:`AuiManager.Update() <AuiManager.Update>` function is called. This batch
    processing can be used to avoid flicker, by modifying more than one pane at a time,
    and then "committing" all of the changes at once by calling `Update()`.

    Panes can be added quite easily::

        text1 = wx.TextCtrl(self, -1)
        text2 = wx.TextCtrl(self, -1)
        self._mgr.AddPane(text1, AuiPaneInfo().Left().Caption("Pane Number One"))
        self._mgr.AddPane(text2, AuiPaneInfo().Bottom().Caption("Pane Number Two"))

        self._mgr.Update()


    Later on, the positions can be modified easily. The following will float an
    existing pane in a tool window::

        self._mgr.GetPane(text1).Float()


    **Layers, Rows and Directions, Positions:**

    Inside AUI, the docking layout is figured out by checking several pane parameters.
    Four of these are important for determining where a pane will end up.

    **Direction** - Each docked pane has a direction, `Top`, `Bottom`, `Left`, `Right`, or `Center`.
    This is fairly self-explanatory. The pane will be placed in the location specified
    by this variable.

    **Position** - More than one pane can be placed inside of a "dock". Imagine two panes
    being docked on the left side of a window. One pane can be placed over another.
    In proportionally managed docks, the pane position indicates it's sequential position,
    starting with zero. So, in our scenario with two panes docked on the left side, the
    top pane in the dock would have position 0, and the second one would occupy position 1.

    **Row** - A row can allow for two docks to be placed next to each other. One of the most
    common places for this to happen is in the toolbar. Multiple toolbar rows are allowed,
    the first row being in row 0, and the second in row 1. Rows can also be used on
    vertically docked panes.

    **Layer** - A layer is akin to an onion. Layer 0 is the very center of the managed pane.
    Thus, if a pane is in layer 0, it will be closest to the center window (also sometimes
    known as the "content window"). Increasing layers "swallow up" all layers of a lower
    value. This can look very similar to multiple rows, but is different because all panes
    in a lower level yield to panes in higher levels. The best way to understand layers
    is by running the AUI sample (`AUI.py`).
    """

    def __init__(self, managed_window=None, agwFlags=None):
        """
        Default class constructor.

        :param Window `managed_window`: specifies the window which should be managed;
        :param integer `agwFlags`: specifies options which allow the frame management behavior to be
         modified. `agwFlags` can be a combination of the following style bits:

         ==================================== ==================================
         Flag name                            Description
         ==================================== ==================================
         ``AUI_MGR_ALLOW_FLOATING``           Allow floating of panes
         ``AUI_MGR_ALLOW_ACTIVE_PANE``        If a pane becomes active, "highlight" it in the interface
         ``AUI_MGR_TRANSPARENT_DRAG``         If the platform supports it, set transparency on a floating pane while it is dragged by the user
         ``AUI_MGR_TRANSPARENT_HINT``         If the platform supports it, show a transparent hint window when the user is about to dock a floating pane
         ``AUI_MGR_VENETIAN_BLINDS_HINT``     Show a "venetian blind" effect when the user is about to dock a floating pane
         ``AUI_MGR_RECTANGLE_HINT``           Show a rectangle hint effect when the user is about to dock a floating pane
         ``AUI_MGR_HINT_FADE``                If the platform supports it, the hint window will fade in and out
         ``AUI_MGR_NO_VENETIAN_BLINDS_FADE``  Disables the "venetian blind" fade in and out
         ``AUI_MGR_LIVE_RESIZE``              Live resize when the user drag a sash
         ``AUI_MGR_ANIMATE_FRAMES``           Fade-out floating panes when they are closed (all platforms which support frames transparency)
                                              and show a moving rectangle when they are docked (Windows < Vista and GTK only)
         ``AUI_MGR_AERO_DOCKING_GUIDES``      Use the new Aero-style bitmaps as docking guides
         ``AUI_MGR_PREVIEW_MINIMIZED_PANES``  Slide in and out minimized panes to preview them
         ``AUI_MGR_WHIDBEY_DOCKING_GUIDES``   Use the new Whidbey-style bitmaps as docking guides
         ``AUI_MGR_SMOOTH_DOCKING``           Performs a "smooth" docking of panes (a la PyQT)
         ``AUI_MGR_USE_NATIVE_MINIFRAMES``    Use miniframes with native caption bar as floating panes instead or custom drawn caption bars (forced on wxMAC)
         ``AUI_MGR_AUTONB_NO_CAPTION``        Panes that merge into an automatic notebook will not have the pane caption visible
         ==================================== ==================================

         Default value for `agwFlags` is:
         ``AUI_MGR_DEFAULT`` = ``AUI_MGR_ALLOW_FLOATING`` | ``AUI_MGR_TRANSPARENT_HINT`` | ``AUI_MGR_HINT_FADE`` | ``AUI_MGR_NO_VENETIAN_BLINDS_FADE``

         .. note::

            If using the ``AUI_MGR_USE_NATIVE_MINIFRAMES``, double-clicking on a
            floating pane caption will not re-dock the pane, but simply maximize it (if
            :meth:`AuiPaneInfo.MaximizeButton` has been set to ``True``) or do nothing.

        """

        wx.EvtHandler.__init__(self)

        self._action = actionNone
        self._action_window = None
        self._hover_button = None
        self._art = dockart.AuiDefaultDockArt()
        self._hint_window = None
        self._active_pane = None
        self._has_maximized = False
        self._has_minimized = False

        self._frame = None
        self._dock_constraint_x = 0.3
        self._dock_constraint_y = 0.3
        self._reserved = None

        self._panes = []
        self._docks = []
        self._uiparts = []

        self._guides = []
        self._notebooks = []

        self._masterManager = None
        self._currentDragItem = -1
        self._lastknowndocks = {}

        self._hint_fadetimer = wx.Timer(self, wx.ID_ANY)
        self._hint_fademax = 50
        self._last_hint = wx.Rect()

        self._from_move = False
        self._last_rect = wx.Rect()

        if agwFlags is None:
            agwFlags = AUI_MGR_DEFAULT

        self._agwFlags = agwFlags
        self._is_docked = (False, wx.RIGHT, wx.TOP, 0)
        self._snap_limits = (15, 15)

        if wx.Platform == "__WXMSW__":
            self._animation_step = 30.0
        else:
            self._animation_step = 5.0

        self._hint_rect = wx.Rect()

        self._preview_timer = wx.Timer(self, wx.ID_ANY)
        self._sliding_frame = None

        self._autoNBTabArt = tabart.AuiDefaultTabArt()
        self._autoNBStyle = AUI_NB_DEFAULT_STYLE | AUI_NB_BOTTOM | \
                            AUI_NB_SUB_NOTEBOOK | AUI_NB_TAB_EXTERNAL_MOVE
        self._autoNBStyle -= AUI_NB_DRAW_DND_TAB

        if managed_window:
            self.SetManagedWindow(managed_window)

        self.Bind(wx.EVT_PAINT, self.OnPaint)
        self.Bind(wx.EVT_ERASE_BACKGROUND, self.OnEraseBackground)
        self.Bind(wx.EVT_SIZE, self.OnSize)
        self.Bind(wx.EVT_SET_CURSOR, self.OnSetCursor)
        self.Bind(wx.EVT_LEFT_DOWN, self.OnLeftDown)
        self.Bind(wx.EVT_LEFT_DCLICK, self.OnLeftDClick)
        self.Bind(wx.EVT_LEFT_UP, self.OnLeftUp)
        self.Bind(wx.EVT_MOTION, self.OnMotion)
        self.Bind(wx.EVT_LEAVE_WINDOW, self.OnLeaveWindow)
        self.Bind(wx.EVT_CHILD_FOCUS, self.OnChildFocus)
        self.Bind(wx.EVT_MOUSE_CAPTURE_LOST, self.OnCaptureLost)
        self.Bind(wx.EVT_TIMER, self.OnHintFadeTimer, self._hint_fadetimer)
        self.Bind(wx.EVT_TIMER, self.SlideIn, self._preview_timer)
        self.Bind(wx.EVT_WINDOW_DESTROY, self.OnDestroy)

        self.Bind(wx.EVT_MOVE, self.OnMove)
        self.Bind(wx.EVT_SYS_COLOUR_CHANGED, self.OnSysColourChanged)

        self.Bind(EVT_AUI_PANE_BUTTON, self.OnPaneButton)
        self.Bind(EVT_AUI_RENDER, self.OnRender)
        self.Bind(EVT_AUI_FIND_MANAGER, self.OnFindManager)
        self.Bind(EVT_AUI_PANE_MIN_RESTORE, self.OnRestoreMinimizedPane)
        self.Bind(EVT_AUI_PANE_DOCKED, self.OnPaneDocked)

        self.Bind(auibook.EVT_AUINOTEBOOK_BEGIN_DRAG, self.OnTabBeginDrag)
        self.Bind(auibook.EVT_AUINOTEBOOK_PAGE_CLOSE, self.OnTabPageClose)
        self.Bind(auibook.EVT_AUINOTEBOOK_PAGE_CHANGED, self.OnTabSelected)


    def CreateFloatingFrame(self, parent, pane_info):
        """
        Creates a floating frame for the windows.

        :param Window `parent`: the floating frame parent;
        :param `pane_info`: the :class:`AuiPaneInfo` class with all the pane's information.
        """

        return AuiFloatingFrame(parent, self, pane_info)


    def CanDockPanel(self, p):
        """
        Returns whether a pane can be docked or not.

        :param `p`: the :class:`AuiPaneInfo` class with all the pane's information.
        """

        # is the pane dockable?
        if not p.IsDockable():
            return False

        # if a key modifier is pressed while dragging the frame,
        # don't dock the window
        return not (wx.GetKeyState(wx.WXK_CONTROL) or wx.GetKeyState(wx.WXK_ALT))


    def GetPaneByWidget(self, window):
        """
        This version of :meth:`GetPane` looks up a pane based on a 'pane window'.

        :param `window`: a :class:`Window` derived window.

        :see: :meth:`~AuiManager.GetPane`
        """

        for p in self._panes:
            if p.window == window:
                return p

        return NonePaneInfo


    def GetPaneByName(self, name):
        """
        This version of :meth:`GetPane` looks up a pane based on a 'pane name'.

        :param string `name`: the pane name.

        :see: :meth:`GetPane`
        """

        for p in self._panes:
            if p.name == name:
                return p

        return NonePaneInfo


    def GetPane(self, item):
        """
        Looks up a :class:`AuiPaneInfo` structure based on the supplied window pointer. Upon failure,
        :meth:`GetPane` returns an empty :class:`AuiPaneInfo`, a condition which can be checked
        by calling :meth:`AuiPaneInfo.IsOk() <AuiPaneInfo.IsOk>`.

        The pane info's structure may then be modified. Once a pane's info is modified, :meth:`Update`
        must be called to realize the changes in the UI.

        :param `item`: either a pane name or a :class:`Window`.
        """

        if isinstance(item, basestring):
            return self.GetPaneByName(item)
        else:
            return self.GetPaneByWidget(item)


    def GetAllPanes(self):
        """ Returns a reference to all the pane info structures. """

        return self._panes


    def ShowPane(self, window, show):
        """
        Shows or hides a pane based on the window passed as input.

        :param Window `window`: any subclass or derivation of :class:`Window`;
        :param bool `show`: ``True`` to show the pane, ``False`` otherwise.
        """

        p = self.GetPane(window)

        if p.IsOk():
            if p.IsNotebookPage():
                if show:

                    notebook = self._notebooks[p.notebook_id]
                    id = notebook.GetPageIndex(p.window)
                    if id >= 0:
                        notebook.SetSelection(id)
                    self.ShowPane(notebook, True)

            else:
                p.Show(show)

            if p.frame:
                p.frame.Raise()

            self.Update()


    def HitTest(self, x, y):
        """
        This is an internal function which determines
        which UI item the specified coordinates are over.

        :param integer `x`: specifies a x position in client coordinates;
        :param integer `y`: specifies a y position in client coordinates.
        """

        result = None

        for item in self._uiparts:
            # we are not interested in typeDock, because this space
            # isn't used to draw anything, just for measurements
            # besides, the entire dock area is covered with other
            # rectangles, which we are interested in.
            if item.type == AuiDockUIPart.typeDock:
                continue

            # if we already have a hit on a more specific item, we are not
            # interested in a pane hit.  If, however, we don't already have
            # a hit, returning a pane hit is necessary for some operations
            if item.type in [AuiDockUIPart.typePane, AuiDockUIPart.typePaneBorder] and result:
                continue

            # if the point is inside the rectangle, we have a hit
            if item.rect.Contains((x, y)):
                result = item

        return result


    def PaneHitTest(self, panes, pt):
        """
        Similar to :meth:`HitTest`, but it checks in which :class:`AuiManager` rectangle the
        input point belongs to.

        :param `panes`: a list of :class:`AuiPaneInfo` instances;
        :param Point `pt`: the mouse position.
        """

        for paneInfo in panes:
            if paneInfo.IsDocked() and paneInfo.IsShown() and paneInfo.rect.Contains(pt):
                return paneInfo

        return NonePaneInfo


    # SetAGWFlags() and GetAGWFlags() allow the owner to set various
    # options which are global to AuiManager

    def SetAGWFlags(self, agwFlags):
        """
        This method is used to specify :class:`AuiManager` 's settings flags.

        :param integer `agwFlags`: specifies options which allow the frame management behavior
         to be modified. `agwFlags` can be one of the following style bits:

         ==================================== ==================================
         Flag name                            Description
         ==================================== ==================================
         ``AUI_MGR_ALLOW_FLOATING``           Allow floating of panes
         ``AUI_MGR_ALLOW_ACTIVE_PANE``        If a pane becomes active, "highlight" it in the interface
         ``AUI_MGR_TRANSPARENT_DRAG``         If the platform supports it, set transparency on a floating pane while it is dragged by the user
         ``AUI_MGR_TRANSPARENT_HINT``         If the platform supports it, show a transparent hint window when the user is about to dock a floating pane
         ``AUI_MGR_VENETIAN_BLINDS_HINT``     Show a "venetian blind" effect when the user is about to dock a floating pane
         ``AUI_MGR_RECTANGLE_HINT``           Show a rectangle hint effect when the user is about to dock a floating pane
         ``AUI_MGR_HINT_FADE``                If the platform supports it, the hint window will fade in and out
         ``AUI_MGR_NO_VENETIAN_BLINDS_FADE``  Disables the "venetian blind" fade in and out
         ``AUI_MGR_LIVE_RESIZE``              Live resize when the user drag a sash
         ``AUI_MGR_ANIMATE_FRAMES``           Fade-out floating panes when they are closed (all platforms which support frames transparency)
                                              and show a moving rectangle when they are docked (Windows < Vista and GTK only)
         ``AUI_MGR_AERO_DOCKING_GUIDES``      Use the new Aero-style bitmaps as docking guides
         ``AUI_MGR_PREVIEW_MINIMIZED_PANES``  Slide in and out minimized panes to preview them
         ``AUI_MGR_WHIDBEY_DOCKING_GUIDES``   Use the new Whidbey-style bitmaps as docking guides
         ``AUI_MGR_SMOOTH_DOCKING``           Performs a "smooth" docking of panes (a la PyQT)
         ``AUI_MGR_USE_NATIVE_MINIFRAMES``    Use miniframes with native caption bar as floating panes instead or custom drawn caption bars (forced on wxMAC)
         ``AUI_MGR_AUTONB_NO_CAPTION``        Panes that merge into an automatic notebook will not have the pane caption visible
         ==================================== ==================================

         .. note::

            If using the ``AUI_MGR_USE_NATIVE_MINIFRAMES``, double-clicking on a
            floating pane caption will not re-dock the pane, but simply maximize it (if
            :meth:`AuiPaneInfo.MaximizeButton` has been set to ``True``) or do nothing.

        """

        self._agwFlags = agwFlags

        if len(self._guides) > 0:
            self.CreateGuideWindows()

        if self._hint_window and agwFlags & AUI_MGR_RECTANGLE_HINT == 0:
            self.CreateHintWindow()


    def GetAGWFlags(self):
        """
        Returns the current manager's flags.

        :see: :meth:`SetAGWFlags` for a list of possible :class:`AuiManager` flags.
        """

        return self._agwFlags


    def SetManagedWindow(self, managed_window):
        """
        Called to specify the frame or window which is to be managed by :class:`AuiManager`.
        Frame management is not restricted to just frames. Child windows or custom
        controls are also allowed.

        :param Window `managed_window`: specifies the window which should be managed by
         the AUI manager.
        """

        if not managed_window:
            raise Exception("Specified managed window must be non-null. ")

        self.UnInit()

        self._frame = managed_window
        self._frame.PushEventHandler(self)

        # if the owner is going to manage an MDI parent frame,
        # we need to add the MDI client window as the default
        # center pane

        if isinstance(self._frame, wx.MDIParentFrame):
            mdi_frame = self._frame
            client_window = mdi_frame.GetClientWindow()

            if not client_window:
                raise Exception("Client window is None!")

            self.AddPane(client_window, AuiPaneInfo().Name("mdiclient").
                         CenterPane().PaneBorder(False))

        elif isinstance(self._frame, tabmdi.AuiMDIParentFrame):

            mdi_frame = self._frame
            client_window = mdi_frame.GetClientWindow()

            if not client_window:
                raise Exception("Client window is None!")

            self.AddPane(client_window, AuiPaneInfo().Name("mdiclient").
                         CenterPane().PaneBorder(False))


    def GetManagedWindow(self):
        """ Returns the window being managed by :class:`AuiManager`. """

        return self._frame


    def SetFrame(self, managed_window):
        """
        Called to specify the frame or window which is to be managed by :class:`AuiManager`.
        Frame management is not restricted to just frames. Child windows or custom
        controls are also allowed.

        :param Window `managed_window`: specifies the window which should be managed by
         the AUI manager.

        .. deprecated:: 0.6
           This method is now deprecated, use :meth:`SetManagedWindow` instead.
        """

        DeprecationWarning("This method is deprecated, use SetManagedWindow instead.")
        return self.SetManagedWindow(managed_window)


    def GetFrame(self):
        """
        Returns the window being managed by :class:`AuiManager`.

        .. deprecated:: 0.6
           This method is now deprecated, use :meth:`GetManagedWindow` instead.
        """

        DeprecationWarning("This method is deprecated, use GetManagedWindow instead.")
        return self._frame


    def CreateGuideWindows(self):
        """ Creates the VS2005 HUD guide windows. """

        self.DestroyGuideWindows()

        self._guides.append(AuiDockingGuideInfo().Left().
                            Host(AuiSingleDockingGuide(self._frame, wx.LEFT)))
        self._guides.append(AuiDockingGuideInfo().Top().
                            Host(AuiSingleDockingGuide(self._frame, wx.TOP)))
        self._guides.append(AuiDockingGuideInfo().Right().
                            Host(AuiSingleDockingGuide(self._frame, wx.RIGHT)))
        self._guides.append(AuiDockingGuideInfo().Bottom().
                            Host(AuiSingleDockingGuide(self._frame, wx.BOTTOM)))
        self._guides.append(AuiDockingGuideInfo().Centre().
                            Host(AuiCenterDockingGuide(self._frame)))


    def DestroyGuideWindows(self):
        """ Destroys the VS2005 HUD guide windows. """

        for guide in self._guides:
            if guide.host:
                guide.host.Destroy()

        self._guides = []


    def CreateHintWindow(self):
        """ Creates the standard wxAUI hint window. """

        self.DestroyHintWindow()

        self._hint_window = AuiDockingHintWindow(self._frame)
        self._hint_window.SetBlindMode(self._agwFlags)


    def DestroyHintWindow(self):
        """ Destroys the standard wxAUI hint window. """

        if self._hint_window:

            self._hint_window.Destroy()
            self._hint_window = None


    def UnInit(self):
        """
        Uninitializes the framework and should be called before a managed frame or
        window is destroyed. :meth:`UnInit` is usually called in the managed :class:`Frame` / :class:`Window`
        destructor.

        It is necessary to call this function before the managed frame or window is
        destroyed, otherwise the manager cannot remove its custom event handlers
        from a window.
        """

        if not self._frame:
            return

        for klass in [self._frame] + list(self._frame.GetChildren()):
            handler = klass.GetEventHandler()
            if klass is not handler:
                if isinstance(handler, AuiManager):
                    klass.RemoveEventHandler(handler)


    def OnDestroy(self, event) :

        if self._frame == event.GetEventObject():
            self.UnInit();


    def GetArtProvider(self):
        """ Returns the current art provider being used. """

        return self._art


    def ProcessMgrEvent(self, event):
        """
        Process the AUI events sent to the manager.

        :param `event`: the event to process, an instance of :class:`AuiManagerEvent`.
        """

        # first, give the owner frame a chance to override
        if self._frame:
            if self._frame.GetEventHandler().ProcessEvent(event):
                return

        self.ProcessEvent(event)


    def FireEvent(self, evtType, pane, canVeto=False):
        """
        Fires one of the ``EVT_AUI_PANE_FLOATED`` / ``FLOATING`` / ``DOCKING`` / ``DOCKED`` / ``ACTIVATED`` event.

        :param integer `evtType`: one of the aforementioned events;
        :param `pane`: the :class:`AuiPaneInfo` instance associated to this event;
        :param bool `canVeto`: whether the event can be vetoed or not.
        """

        event = AuiManagerEvent(evtType)
        event.SetPane(pane)
        event.SetCanVeto(canVeto)
        self.ProcessMgrEvent(event)

        return event


    def CanUseModernDockArt(self):
        """
        Returns whether :class:`dockart` can be used (Windows XP / Vista / 7 only,
        requires Mark Hammonds's `pywin32 <http://sourceforge.net/projects/pywin32/>`_ package).
        """

        if not _winxptheme:
            return False

        # Get the size of a small close button (themed)
        hwnd = self._frame.GetHandle()
        hTheme = winxptheme.OpenThemeData(hwnd, "Window")

        if not hTheme:
            return False

        return True


    def SetArtProvider(self, art_provider):
        """
        Instructs :class:`AuiManager` to use art provider specified by the parameter
        `art_provider` for all drawing calls. This allows plugable look-and-feel
        features.

        :param `art_provider`: a AUI dock art provider.

        :note: The previous art provider object, if any, will be deleted by :class:`AuiManager`.
        """

        # delete the last art provider, if any
        del self._art

        # assign the new art provider
        self._art = art_provider

        for pane in self.GetAllPanes():
            if pane.IsFloating() and pane.frame:
                pane.frame._mgr.SetArtProvider(art_provider)
                pane.frame._mgr.Update()


    def AddPane(self, window, arg1=None, arg2=None, target=None):
        """
        Tells the frame manager to start managing a child window. There
        are four versions of this function. The first verison allows the full spectrum
        of pane parameter possibilities (:meth:`AddPane1`). The second version is used for
        simpler user interfaces which do not require as much configuration (:meth:`AddPane2`).
        The :meth:`AddPane3` version allows a drop position to be specified, which will determine
        where the pane will be added. The :meth:`AddPane4` version allows to turn the target
        :class:`AuiPaneInfo` pane into a notebook and the added pane into a page.

        In your code, simply call :meth:`AddPane`.

        :param Window `window`: the child window to manage;
        :param `arg1`: a :class:`AuiPaneInfo` or an integer value (direction);
        :param `arg2`: a :class:`AuiPaneInfo` or a :class:`Point` (drop position);
        :param `target`: a :class:`AuiPaneInfo` to be turned into a notebook
         and new pane added to it as a page. (additionally, target can be any pane in
         an existing notebook)
         """

        if target in self._panes:
            return self.AddPane4(window, arg1, target)

        if type(arg1) == type(1):
            # This Is Addpane2
            if arg1 is None:
                arg1 = wx.LEFT
            if arg2 is None:
                arg2 = ""
            return self.AddPane2(window, arg1, arg2)
        else:
            if isinstance(arg2, wx.Point):
                return self.AddPane3(window, arg1, arg2)
            else:
                return self.AddPane1(window, arg1)


    def AddPane1(self, window, pane_info):
        """ See comments on :meth:`AddPane`. """

        # check if the pane has a valid window
        if not window:
            return False

        # check if the pane already exists
        if self.GetPane(pane_info.window).IsOk():
            return False

        # check if the pane name already exists, this could reveal a
        # bug in the library user's application
        already_exists = False
        if pane_info.name != "" and self.GetPane(pane_info.name).IsOk():
            warnings.warn("A pane with the name '%s' already exists in the manager!"%pane_info.name)
            already_exists = True

        # if the new pane is docked then we should undo maximize
        if pane_info.IsDocked():
            self.RestoreMaximizedPane()

        self._panes.append(pane_info)
        pinfo = self._panes[-1]

        # set the pane window
        pinfo.window = window

        # if the pane's name identifier is blank, create a random string
        if pinfo.name == "" or already_exists:
            pinfo.name = ("%s%08x%08x%08x")%(pinfo.window.GetName(), time.time(),
                                             time.clock(), len(self._panes))

        # set initial proportion (if not already set)
        if pinfo.dock_proportion == 0:
            pinfo.dock_proportion = 100000

        floating = isinstance(self._frame, AuiFloatingFrame)

        pinfo.buttons = []

        if not floating and pinfo.HasMinimizeButton():
            button = AuiPaneButton(AUI_BUTTON_MINIMIZE)
            pinfo.buttons.append(button)

        if not floating and pinfo.HasMaximizeButton():
            button = AuiPaneButton(AUI_BUTTON_MAXIMIZE_RESTORE)
            pinfo.buttons.append(button)

        if not floating and pinfo.HasPinButton():
            button = AuiPaneButton(AUI_BUTTON_PIN)
            pinfo.buttons.append(button)

        if pinfo.HasCloseButton():
            button = AuiPaneButton(AUI_BUTTON_CLOSE)
            pinfo.buttons.append(button)

        if pinfo.HasGripper():
            if isinstance(pinfo.window, auibar.AuiToolBar):
                # prevent duplicate gripper -- both AuiManager and AuiToolBar
                # have a gripper control.  The toolbar's built-in gripper
                # meshes better with the look and feel of the control than ours,
                # so turn AuiManager's gripper off, and the toolbar's on.

                tb = pinfo.window
                pinfo.SetFlag(AuiPaneInfo.optionGripper, False)
                tb.SetGripperVisible(True)

        if pinfo.window:
            if pinfo.best_size == wx.Size(-1, -1):
                pinfo.best_size = pinfo.window.GetClientSize()

            if isinstance(pinfo.window, wx.ToolBar):
                # GetClientSize() doesn't get the best size for
                # a toolbar under some newer versions of wxWidgets,
                # so use GetBestSize()
                pinfo.best_size = pinfo.window.GetBestSize()

                # this is needed for Win2000 to correctly fill toolbar backround
                # it should probably be repeated once system colour change happens
                if wx.Platform == "__WXMSW__" and pinfo.window.UseBgCol():
                    pinfo.window.SetBackgroundColour(self.GetArtProvider().GetColour(AUI_DOCKART_BACKGROUND_COLOUR))

            if pinfo.min_size != wx.Size(-1, -1):
                if pinfo.best_size.x < pinfo.min_size.x:
                    pinfo.best_size.x = pinfo.min_size.x
                if pinfo.best_size.y < pinfo.min_size.y:
                    pinfo.best_size.y = pinfo.min_size.y

        self._panes[-1] = pinfo
        if isinstance(window, auibar.AuiToolBar):
            window.SetAuiManager(self)

        return True


    def AddPane2(self, window, direction, caption):
        """ See comments on :meth:`AddPane`. """

        pinfo = AuiPaneInfo()
        pinfo.Caption(caption)

        if direction == wx.TOP:
            pinfo.Top()
        elif direction == wx.BOTTOM:
            pinfo.Bottom()
        elif direction == wx.LEFT:
            pinfo.Left()
        elif direction == wx.RIGHT:
            pinfo.Right()
        elif direction == wx.CENTER:
            pinfo.CenterPane()

        return self.AddPane(window, pinfo)


    def AddPane3(self, window, pane_info, drop_pos):
        """ See comments on :meth:`AddPane`. """

        if not self.AddPane(window, pane_info):
            return False

        pane = self.GetPane(window)
        indx = self._panes.index(pane)

        ret, pane = self.DoDrop(self._docks, self._panes, pane, drop_pos, wx.Point(0, 0))
        self._panes[indx] = pane

        return True


    def AddPane4(self, window, pane_info, target):
        """ See comments on :meth:`AddPane`. """

        if not self.AddPane(window, pane_info):
            return False

        paneInfo = self.GetPane(window)

        if not paneInfo.IsNotebookDockable():
            return self.AddPane1(window, pane_info)
        if not target.IsNotebookDockable() and not target.IsNotebookControl():
            return self.AddPane1(window, pane_info)

        if not target.HasNotebook():
            self.CreateNotebookBase(self._panes, target)

        # Add new item to notebook
        paneInfo.NotebookPage(target.notebook_id)

        # we also want to remove our captions sometimes
        self.RemoveAutoNBCaption(paneInfo)
        self.UpdateNotebook()

        return True


    def InsertPane(self, window, pane_info, insert_level=AUI_INSERT_PANE):
        """
        This method is used to insert either a previously unmanaged pane window
        into the frame manager, or to insert a currently managed pane somewhere else.
        :meth:`InsertPane` will push all panes, rows, or docks aside and insert the window
        into the position specified by `pane_info`.

        Because `pane_info` can specify either a pane, dock row, or dock layer, the
        `insert_level` parameter is used to disambiguate this. The parameter `insert_level`
        can take a value of ``AUI_INSERT_PANE``, ``AUI_INSERT_ROW`` or ``AUI_INSERT_DOCK``.

        :param Window `window`: the window to be inserted and managed;
        :param `pane_info`: the insert location for the new window;
        :param integer `insert_level`: the insertion level of the new pane.
        """

        if not window:
            raise Exception("Invalid window passed to InsertPane.")

        # shift the panes around, depending on the insert level
        if insert_level == AUI_INSERT_PANE:
            self._panes = DoInsertPane(self._panes, pane_info.dock_direction,
                                       pane_info.dock_layer, pane_info.dock_row,
                                       pane_info.dock_pos)

        elif insert_level == AUI_INSERT_ROW:
            self._panes = DoInsertDockRow(self._panes, pane_info.dock_direction,
                                          pane_info.dock_layer, pane_info.dock_row)

        elif insert_level == AUI_INSERT_DOCK:
            self._panes = DoInsertDockLayer(self._panes, pane_info.dock_direction,
                                            pane_info.dock_layer)

        # if the window already exists, we are basically just moving/inserting the
        # existing window.  If it doesn't exist, we need to add it and insert it
        existing_pane = self.GetPane(window)
        indx = self._panes.index(existing_pane)

        if not existing_pane.IsOk():

            return self.AddPane(window, pane_info)

        else:

            if pane_info.IsFloating():
                existing_pane.Float()
                if pane_info.floating_pos != wx.Point(-1, -1):
                    existing_pane.FloatingPosition(pane_info.floating_pos)
                if pane_info.floating_size != wx.Size(-1, -1):
                    existing_pane.FloatingSize(pane_info.floating_size)
            else:
                # if the new pane is docked then we should undo maximize
                self.RestoreMaximizedPane()

                existing_pane.Direction(pane_info.dock_direction)
                existing_pane.Layer(pane_info.dock_layer)
                existing_pane.Row(pane_info.dock_row)
                existing_pane.Position(pane_info.dock_pos)

            self._panes[indx] = existing_pane

        return True


    def DetachPane(self, window):
        """
        Tells the :class:`AuiManager` to stop managing the pane specified
        by `window`. The window, if in a floated frame, is reparented to the frame
        managed by :class:`AuiManager`.

        :param Window `window`: the window to be un-managed.
        """

        for p in self._panes:
            if p.window == window:
                if p.frame:
                    # we have a floating frame which is being detached. We need to
                    # reparent it to self._frame and destroy the floating frame

                    # reduce flicker
                    p.window.SetSize((1, 1))
                    if p.frame.IsShown():
                        p.frame.Show(False)

                    if self._action_window == p.frame:
                        self._action_window = None

                    # reparent to self._frame and destroy the pane
                    p.window.Reparent(self._frame)
                    p.frame.SetSizer(None)
                    p.frame.Destroy()
                    p.frame = None

                elif p.IsNotebookPage():
                    notebook = self._notebooks[p.notebook_id]
                    id = notebook.GetPageIndex(p.window)
                    notebook.RemovePage(id)

                # make sure there are no references to this pane in our uiparts,
                # just in case the caller doesn't call Update() immediately after
                # the DetachPane() call.  This prevets obscure crashes which would
                # happen at window repaint if the caller forgets to call Update()
                counter = 0
                for pi in xrange(len(self._uiparts)):
                    part = self._uiparts[counter]
                    if part.pane == p:
                        self._uiparts.pop(counter)
                        counter -= 1

                    counter += 1

                self._panes.remove(p)
                return True

        return False


    def ClosePane(self, pane_info):
        """
        Destroys or hides the pane depending on its flags.

        :param `pane_info`: a :class:`AuiPaneInfo` instance.
        """
        # if we were maximized, restore
        if pane_info.IsMaximized():
            self.RestorePane(pane_info)

        if pane_info.frame:
            if self._agwFlags & AUI_MGR_ANIMATE_FRAMES:
                pane_info.frame.FadeOut()

        # first, hide the window
        if pane_info.window and pane_info.window.IsShown():
            pane_info.window.Show(False)

        # make sure that we are the parent of this window
        if pane_info.window and pane_info.window.GetParent() != self._frame:
            pane_info.window.Reparent(self._frame)

        # if we have a frame, destroy it
        if pane_info.frame:
            pane_info.frame.Destroy()
            pane_info.frame = None

        elif pane_info.IsNotebookPage():
            # if we are a notebook page, remove ourselves...
            # the  code would index out of bounds
            # if the last page of a sub-notebook was closed
            # because the notebook would be deleted, before this
            # code is executed.
            # This code just prevents an out-of bounds error.
            if self._notebooks:
                nid = pane_info.notebook_id
                if nid >= 0 and nid < len(self._notebooks):
                    notebook = self._notebooks[nid]
                    page_idx = notebook.GetPageIndex(pane_info.window)
                    if page_idx >= 0:
                        notebook.RemovePage(page_idx)

        # now we need to either destroy or hide the pane
        to_destroy = 0
        if pane_info.IsDestroyOnClose():
            to_destroy = pane_info.window
            self.DetachPane(to_destroy)
        else:
            if isinstance(pane_info.window, auibar.AuiToolBar) and pane_info.IsFloating():
                tb = pane_info.window
                if pane_info.dock_direction in [AUI_DOCK_LEFT, AUI_DOCK_RIGHT]:
                    tb.SetAGWWindowStyleFlag(tb.GetAGWWindowStyleFlag() | AUI_TB_VERTICAL)

            #pane_info.Dock().Hide()
            # We don't want to dock the pane when it's closed. Just hide 
            # it so that if it's currently floated, it's re-floated the
            # next time it is shown.
            pane_info.Hide()

        if pane_info.IsNotebookControl():

            notebook = self._notebooks[pane_info.notebook_id]
            while notebook.GetPageCount():
                window = notebook.GetPage(0)
                notebook.RemovePage(0)
                info = self.GetPane(window)
                if info.IsOk():
                    info.notebook_id = -1
                    info.dock_direction = AUI_DOCK_NONE
                    # Note: this could change our paneInfo reference ...
                    self.ClosePane(info)

        if to_destroy:
            to_destroy.Destroy()


    def MaximizePane(self, pane_info, savesizes=True):
        """
        Maximizes the input pane.

        :param `pane_info`: a :class:`AuiPaneInfo` instance.
        :param bool `savesizes`: whether to save previous dock sizes.
        """

        if savesizes:
            self.SavePreviousDockSizes(pane_info)

        for p in self._panes:

            # save hidden state
            p.SetFlag(p.savedHiddenState, p.HasFlag(p.optionHidden))

            if not p.IsToolbar() and not p.IsFloating():
                p.Restore()

                # hide the pane, because only the newly
                # maximized pane should show
                p.Hide()

        pane_info.previousDockPos = pane_info.dock_pos

        # mark ourselves maximized
        pane_info.Maximize()
        pane_info.Show()
        self._has_maximized = True

        # last, show the window
        if pane_info.window and not pane_info.window.IsShown():
            pane_info.window.Show(True)


    def SavePreviousDockSizes(self, pane_info):
        """
        Stores the previous dock sizes, to be used in a "restore" action later.

        :param `pane_info`: a :class:`AuiPaneInfo` instance.
        """

        for d in self._docks:
            if not d.toolbar:
                for p in d.panes:
                    p.previousDockSize = d.size
                    if pane_info is not p:
                        p.SetFlag(p.needsRestore, True)


    def RestorePane(self, pane_info):
        """
        Restores the input pane from a previous maximized or minimized state.

        :param `pane_info`: a :class:`AuiPaneInfo` instance.
        """

        # restore all the panes
        for p in self._panes:
            if not p.IsToolbar():
                p.SetFlag(p.optionHidden, p.HasFlag(p.savedHiddenState))

        pane_info.SetFlag(pane_info.needsRestore, True)

        # mark ourselves non-maximized
        pane_info.Restore()
        self._has_maximized = False
        self._has_minimized = False

        # last, show the window
        if pane_info.window and not pane_info.window.IsShown():
            pane_info.window.Show(True)


    def RestoreMaximizedPane(self):
        """ Restores the current maximized pane (if any). """

        # restore all the panes
        for p in self._panes:
            if p.IsMaximized():
                self.RestorePane(p)
                break


    def ActivatePane(self, window):
        """
        Activates the pane to which `window` is associated.

        :param `window`: a :class:`Window` derived window.
        """

        if self.GetAGWFlags() & AUI_MGR_ALLOW_ACTIVE_PANE:
            while window:
                ret, self._panes = SetActivePane(self._panes, window)
                if ret:
                    break

                window = window.GetParent()

            self.RefreshCaptions()
            self.FireEvent(wxEVT_AUI_PANE_ACTIVATED, window, canVeto=False)


    def CreateNotebook(self):
        """
        Creates an automatic :class:`~lib.agw.aui.auibook.AuiNotebook` when a pane is docked on
        top of another pane.
        """

        notebook = auibook.AuiNotebook(self._frame, -1, wx.Point(0, 0), wx.Size(0, 0), agwStyle=self._autoNBStyle)

        # This is so we can get the tab-drag event.
        notebook.GetAuiManager().SetMasterManager(self)
        notebook.SetArtProvider(self._autoNBTabArt.Clone())
        self._notebooks.append(notebook)

        return notebook


    def SetAutoNotebookTabArt(self, art):
        """
        Sets the default tab art provider for automatic notebooks.

        :param `art`: a tab art provider.
        """

        for nb in self._notebooks:
            nb.SetArtProvider(art.Clone())
            nb.Refresh()
            nb.Update()

        self._autoNBTabArt = art


    def GetAutoNotebookTabArt(self):
        """ Returns the default tab art provider for automatic notebooks. """

        return self._autoNBTabArt


    def SetAutoNotebookStyle(self, agwStyle):
        """
        Sets the default AGW-specific window style for automatic notebooks.

        :param integer `agwStyle`: the underlying :class:`~lib.agw.aui.auibook.AuiNotebook` window style.
         This can be a combination of the following bits:

         ==================================== ==================================
         Flag name                            Description
         ==================================== ==================================
         ``AUI_NB_TOP``                       With this style, tabs are drawn along the top of the notebook
         ``AUI_NB_LEFT``                      With this style, tabs are drawn along the left of the notebook. Not implemented yet.
         ``AUI_NB_RIGHT``                     With this style, tabs are drawn along the right of the notebook. Not implemented yet.
         ``AUI_NB_BOTTOM``                    With this style, tabs are drawn along the bottom of the notebook
         ``AUI_NB_TAB_SPLIT``                 Allows the tab control to be split by dragging a tab
         ``AUI_NB_TAB_MOVE``                  Allows a tab to be moved horizontally by dragging
         ``AUI_NB_TAB_EXTERNAL_MOVE``         Allows a tab to be moved to another tab control
         ``AUI_NB_TAB_FIXED_WIDTH``           With this style, all tabs have the same width
         ``AUI_NB_SCROLL_BUTTONS``            With this style, left and right scroll buttons are displayed
         ``AUI_NB_WINDOWLIST_BUTTON``         With this style, a drop-down list of windows is available
         ``AUI_NB_CLOSE_BUTTON``              With this style, a close button is available on the tab bar
         ``AUI_NB_CLOSE_ON_ACTIVE_TAB``       With this style, a close button is available on the active tab
         ``AUI_NB_CLOSE_ON_ALL_TABS``         With this style, a close button is available on all tabs
         ``AUI_NB_MIDDLE_CLICK_CLOSE``        Allows to close :class:`~lib.agw.aui.auibook.AuiNotebook` tabs by mouse middle button click
         ``AUI_NB_SUB_NOTEBOOK``              This style is used by :class:`AuiManager` to create automatic AuiNotebooks
         ``AUI_NB_HIDE_ON_SINGLE_TAB``        Hides the tab window if only one tab is present
         ``AUI_NB_SMART_TABS``                Use Smart Tabbing, like ``Alt`` + ``Tab`` on Windows
         ``AUI_NB_USE_IMAGES_DROPDOWN``       Uses images on dropdown window list menu instead of check items
         ``AUI_NB_CLOSE_ON_TAB_LEFT``         Draws the tab close button on the left instead of on the right (a la Camino browser)
         ``AUI_NB_TAB_FLOAT``                 Allows the floating of single tabs. Known limitation: when the notebook is more or less
                                              full screen, tabs cannot be dragged far enough outside of the notebook to become floating pages
         ``AUI_NB_DRAW_DND_TAB``              Draws an image representation of a tab while dragging (on by default)
         ``AUI_NB_ORDER_BY_ACCESS``           Tab navigation order by last access time for the tabs
         ``AUI_NB_NO_TAB_FOCUS``              Don't draw tab focus rectangle
         ==================================== ==================================

        """

        for nb in self._notebooks:
            nb.SetAGWWindowStyleFlag(agwStyle)
            nb.Refresh()
            nb.Update()

        self._autoNBStyle = agwStyle


    def GetAutoNotebookStyle(self):
        """
        Returns the default AGW-specific window style for automatic notebooks.

        :see: :meth:`SetAutoNotebookStyle` method for a list of possible styles.
        """

        return self._autoNBStyle


    def SavePaneInfo(self, pane):
        """
        This method is similar to :meth:`SavePerspective`, with the exception
        that it only saves information about a single pane. It is used in
        combination with :meth:`LoadPaneInfo`.

        :param `pane`: a :class:`AuiPaneInfo` instance to save.
        """

        result = "name=" + EscapeDelimiters(pane.name) + ";"
        result += "caption=" + EscapeDelimiters(pane.caption) + ";"

        result += "state=%u;"%pane.state
        result += "dir=%d;"%pane.dock_direction
        result += "layer=%d;"%pane.dock_layer
        result += "row=%d;"%pane.dock_row
        result += "pos=%d;"%pane.dock_pos
        result += "prop=%d;"%pane.dock_proportion
        result += "bestw=%d;"%pane.best_size.x
        result += "besth=%d;"%pane.best_size.y
        result += "minw=%d;"%pane.min_size.x
        result += "minh=%d;"%pane.min_size.y
        result += "maxw=%d;"%pane.max_size.x
        result += "maxh=%d;"%pane.max_size.y
        result += "floatx=%d;"%pane.floating_pos.x
        result += "floaty=%d;"%pane.floating_pos.y
        result += "floatw=%d;"%pane.floating_size.x
        result += "floath=%d;"%pane.floating_size.y
        result += "notebookid=%d;"%pane.notebook_id
        result += "transparent=%d"%pane.transparent

        return result


    def LoadPaneInfo(self, pane_part, pane):
        """
        This method is similar to to :meth:`LoadPerspective`, with the exception that
        it only loads information about a single pane. It is used in combination
        with :meth:`SavePaneInfo`.

        :param string `pane_part`: the string to analyze;
        :param `pane`: the :class:`AuiPaneInfo` structure in which to load `pane_part`.
        """

        # replace escaped characters so we can
        # split up the string easily
        pane_part = pane_part.replace("\\|", "\a")
        pane_part = pane_part.replace("\\;", "\b")

        options = pane_part.split(";")
        for items in options:

            val_name, value = items.split("=")
            val_name = val_name.strip()

            if val_name == "name":
                pane.name = value
            elif val_name == "caption":
                pane.caption = value
            elif val_name == "state":
                pane.state = int(value)
            elif val_name == "dir":
                pane.dock_direction = int(value)
            elif val_name == "layer":
                pane.dock_layer = int(value)
            elif val_name == "row":
                pane.dock_row = int(value)
            elif val_name == "pos":
                pane.dock_pos = int(value)
            elif val_name == "prop":
                pane.dock_proportion = int(value)
            elif val_name == "bestw":
                pane.best_size.x = int(value)
            elif val_name == "besth":
                pane.best_size.y = int(value)
                pane.best_size = wx.Size(pane.best_size.x, pane.best_size.y)
            elif val_name == "minw":
                pane.min_size.x = int(value)
            elif val_name == "minh":
                pane.min_size.y = int(value)
                pane.min_size = wx.Size(pane.min_size.x, pane.min_size.y)
            elif val_name == "maxw":
                pane.max_size.x = int(value)
            elif val_name == "maxh":
                pane.max_size.y = int(value)
                pane.max_size = wx.Size(pane.max_size.x, pane.max_size.y)
            elif val_name == "floatx":
                pane.floating_pos.x = int(value)
            elif val_name == "floaty":
                pane.floating_pos.y = int(value)
                pane.floating_pos = wx.Point(pane.floating_pos.x, pane.floating_pos.y)
            elif val_name == "floatw":
                pane.floating_size.x = int(value)
            elif val_name == "floath":
                pane.floating_size.y = int(value)
                pane.floating_size = wx.Size(pane.floating_size.x, pane.floating_size.y)
            elif val_name == "notebookid":
                pane.notebook_id = int(value)
            elif val_name == "transparent":
                pane.transparent = int(value)
            else:
                raise Exception("Bad perspective string")

        # replace escaped characters so we can
        # split up the string easily
        pane.name = pane.name.replace("\a", "|")
        pane.name = pane.name.replace("\b", ";")
        pane.caption = pane.caption.replace("\a", "|")
        pane.caption = pane.caption.replace("\b", ";")
        pane_part = pane_part.replace("\a", "|")
        pane_part = pane_part.replace("\b", ";")

        return pane


    def SavePerspective(self):
        """
        Saves the entire user interface layout into an encoded string, which can then
        be stored by the application (probably using :class:`Config`).

        When a perspective is restored using :meth:`LoadPerspective`, the entire user
        interface will return to the state it was when the perspective was saved.
        """

        result = "layout2|"

        for pane in self._panes:
            result += self.SavePaneInfo(pane) + "|"

        for dock in self._docks:
            result = result + ("dock_size(%d,%d,%d)=%d|")%(dock.dock_direction,
                                                           dock.dock_layer,
                                                           dock.dock_row,
                                                           dock.size)
        return result


    def LoadPerspective(self, layout, update=True, restorecaption=False):
        """
        Loads a layout which was saved with :meth:`SavePerspective`.

        If the `update` flag parameter is ``True``, :meth:`Update` will be
        automatically invoked, thus realizing the saved perspective on screen.

        :param string `layout`: a string which contains a saved AUI layout;
        :param bool `update`: whether to update immediately the window or not;
        :param bool `restorecaption`: ``False``, restore from persist storage,
         otherwise use the caption defined in code.
        """

        input = layout

        # check layout string version
        #    'layout1' = wxAUI 0.9.0 - wxAUI 0.9.2
        #    'layout2' = wxAUI 0.9.2 (wxWidgets 2.8)
        index = input.find("|")
        part = input[0:index].strip()
        input = input[index+1:]

        if part != "layout2":
            return False

        # mark all panes currently managed as docked and hidden
        saveCapt = {} # see restorecaption param
        for pane in self._panes:
            pane.Dock().Hide()
            saveCapt[pane.name] = pane.caption

        # clear out the dock array; this will be reconstructed
        self._docks = []

        # replace escaped characters so we can
        # split up the string easily
        input = input.replace("\\|", "\a")
        input = input.replace("\\;", "\b")

        while 1:

            pane = AuiPaneInfo()
            index = input.find("|")
            pane_part = input[0:index].strip()
            input = input[index+1:]

            # if the string is empty, we're done parsing
            if pane_part == "":
                break

            if pane_part[0:9] == "dock_size":
                index = pane_part.find("=")
                val_name = pane_part[0:index]
                value = pane_part[index+1:]

                index = val_name.find("(")
                piece = val_name[index+1:]
                index = piece.find(")")
                piece = piece[0:index]

                vals = piece.split(",")
                dir = int(vals[0])
                layer = int(vals[1])
                row = int(vals[2])
                size = int(value)

                dock = AuiDockInfo()
                dock.dock_direction = dir
                dock.dock_layer = layer
                dock.dock_row = row
                dock.size = size
                self._docks.append(dock)

                continue

            # Undo our escaping as LoadPaneInfo needs to take an unescaped
            # name so it can be called by external callers
            pane_part = pane_part.replace("\a", "|")
            pane_part = pane_part.replace("\b", ";")

            pane = self.LoadPaneInfo(pane_part, pane)

            p = self.GetPane(pane.name)
            # restore pane caption from code
            if restorecaption:
                if pane.name in saveCapt:
                    pane.Caption(saveCapt[pane.name])

            if not p.IsOk():
                if pane.IsNotebookControl():
                    # notebook controls - auto add...
                    self._panes.append(pane)
                    indx = self._panes.index(pane)
                else:
                    # the pane window couldn't be found
                    # in the existing layout -- skip it
                    continue

            else:
                indx = self._panes.index(p)
            pane.window = p.window
            pane.frame = p.frame
            pane.buttons = p.buttons
            self._panes[indx] = pane

            if isinstance(pane.window, auibar.AuiToolBar) and (pane.IsFloatable() or pane.IsDockable()):
                pane.window.SetGripperVisible(True)

        for p in self._panes:
            if p.IsMinimized():
                self.MinimizePane(p, False)

        if update:
            self.Update()

        return True


    def GetPanePositionsAndSizes(self, dock):
        """
        Returns all the panes positions and sizes in a dock.

        :param `dock`: a :class:`AuiDockInfo` instance.
        """

        caption_size = self._art.GetMetric(AUI_DOCKART_CAPTION_SIZE)
        pane_border_size = self._art.GetMetric(AUI_DOCKART_PANE_BORDER_SIZE)
        gripper_size = self._art.GetMetric(AUI_DOCKART_GRIPPER_SIZE)

        positions = []
        sizes = []

        action_pane = -1
        pane_count = len(dock.panes)

        # find the pane marked as our action pane
        for pane_i in xrange(pane_count):
            pane = dock.panes[pane_i]
            if pane.HasFlag(AuiPaneInfo.actionPane):
                if action_pane != -1:
                    raise Exception("Too many action panes!")
                action_pane = pane_i

        # set up each panes default position, and
        # determine the size (width or height, depending
        # on the dock's orientation) of each pane
        for pane in dock.panes:
            positions.append(pane.dock_pos)
            size = 0

            if pane.HasBorder():
                size += pane_border_size*2

            if dock.IsHorizontal():
                if pane.HasGripper() and not pane.HasGripperTop():
                    size += gripper_size

                if pane.HasCaptionLeft():
                    size += caption_size

                size += pane.best_size.x

            else:
                if pane.HasGripper() and pane.HasGripperTop():
                    size += gripper_size

                if pane.HasCaption() and not pane.HasCaptionLeft():
                    size += caption_size

                size += pane.best_size.y

            sizes.append(size)

        # if there is no action pane, just return the default
        # positions (as specified in pane.pane_pos)
        if action_pane == -1:
            return positions, sizes

        offset = 0
        for pane_i in xrange(action_pane-1, -1, -1):
            amount = positions[pane_i+1] - (positions[pane_i] + sizes[pane_i])
            if amount >= 0:
                offset += amount
            else:
                positions[pane_i] -= -amount

            offset += sizes[pane_i]

        # if the dock mode is fixed, make sure none of the panes
        # overlap we will bump panes that overlap
        offset = 0
        for pane_i in xrange(action_pane, pane_count):
            amount = positions[pane_i] - offset
            if amount >= 0:
                offset += amount
            else:
                positions[pane_i] += -amount

            offset += sizes[pane_i]

        return positions, sizes


    def LayoutAddPane(self, cont, dock, pane, uiparts, spacer_only):
        """
        Adds a pane into the existing layout (in an existing dock).

        :param `cont`: a :class:`Sizer` object;
        :param `dock`: the :class:`AuiDockInfo` structure in which to add the pane;
        :param `pane`: the :class:`AuiPaneInfo` instance to add to the dock;
        :param `uiparts`: a list of UI parts in the interface;
        :param bool `spacer_only`: whether to add a simple spacer or a real window.
        """

        sizer_item = wx.SizerItem()
        caption_size = self._art.GetMetric(AUI_DOCKART_CAPTION_SIZE)
        gripper_size = self._art.GetMetric(AUI_DOCKART_GRIPPER_SIZE)
        pane_border_size = self._art.GetMetric(AUI_DOCKART_PANE_BORDER_SIZE)
        pane_button_size = self._art.GetMetric(AUI_DOCKART_PANE_BUTTON_SIZE)

        # find out the orientation of the item (orientation for panes
        # is the same as the dock's orientation)

        if dock.IsHorizontal():
            orientation = wx.HORIZONTAL
        else:
            orientation = wx.VERTICAL

        # this variable will store the proportion
        # value that the pane will receive
        pane_proportion = pane.dock_proportion

        horz_pane_sizer = wx.BoxSizer(wx.HORIZONTAL)
        vert_pane_sizer = wx.BoxSizer(wx.VERTICAL)

        if pane.HasGripper():

            part = AuiDockUIPart()
            if pane.HasGripperTop():
                sizer_item = vert_pane_sizer.Add((1, gripper_size), 0, wx.EXPAND)
            else:
                sizer_item = horz_pane_sizer.Add((gripper_size, 1), 0, wx.EXPAND)

            part.type = AuiDockUIPart.typeGripper
            part.dock = dock
            part.pane = pane
            part.button = None
            part.orientation = orientation
            part.cont_sizer = horz_pane_sizer
            part.sizer_item = sizer_item
            uiparts.append(part)

        button_count = len(pane.buttons)
        button_width_total = button_count*pane_button_size
        if button_count >= 1:
            button_width_total += 3

        caption, captionLeft = pane.HasCaption(), pane.HasCaptionLeft()
        button_count = len(pane.buttons)

        if captionLeft:
            caption_sizer = wx.BoxSizer(wx.VERTICAL)

            # add pane buttons to the caption
            dummy_parts = []
            for btn_id in xrange(len(pane.buttons)-1, -1, -1):
                sizer_item = caption_sizer.Add((caption_size, pane_button_size), 0, wx.EXPAND)
                part = AuiDockUIPart()
                part.type = AuiDockUIPart.typePaneButton
                part.dock = dock
                part.pane = pane
                part.button = pane.buttons[btn_id]
                part.orientation = orientation
                part.cont_sizer = caption_sizer
                part.sizer_item = sizer_item
                dummy_parts.append(part)

            sizer_item = caption_sizer.Add((caption_size, 1), 1, wx.EXPAND)
            vert_pane_sizer = wx.BoxSizer(wx.HORIZONTAL)

            # create the caption sizer
            part = AuiDockUIPart()

            part.type = AuiDockUIPart.typeCaption
            part.dock = dock
            part.pane = pane
            part.button = None
            part.orientation = orientation
            part.cont_sizer = vert_pane_sizer
            part.sizer_item = sizer_item
            caption_part_idx = len(uiparts)
            uiparts.append(part)
            uiparts.extend(dummy_parts)

        elif caption:

            caption_sizer = wx.BoxSizer(wx.HORIZONTAL)
            sizer_item = caption_sizer.Add((1, caption_size), 1, wx.EXPAND)

            # create the caption sizer
            part = AuiDockUIPart()

            part.type = AuiDockUIPart.typeCaption
            part.dock = dock
            part.pane = pane
            part.button = None
            part.orientation = orientation
            part.cont_sizer = vert_pane_sizer
            part.sizer_item = sizer_item
            caption_part_idx = len(uiparts)
            uiparts.append(part)

            # add pane buttons to the caption
            for button in pane.buttons:
                sizer_item = caption_sizer.Add((pane_button_size, caption_size), 0, wx.EXPAND)
                part = AuiDockUIPart()
                part.type = AuiDockUIPart.typePaneButton
                part.dock = dock
                part.pane = pane
                part.button = button
                part.orientation = orientation
                part.cont_sizer = caption_sizer
                part.sizer_item = sizer_item
                uiparts.append(part)

        if caption or captionLeft:
            # if we have buttons, add a little space to the right
            # of them to ease visual crowding
            if button_count >= 1:
                if captionLeft:
                    caption_sizer.Add((caption_size, 3), 0, wx.EXPAND)
                else:
                    caption_sizer.Add((3, caption_size), 0, wx.EXPAND)

            # add the caption sizer
            sizer_item = vert_pane_sizer.Add(caption_sizer, 0, wx.EXPAND)
            uiparts[caption_part_idx].sizer_item = sizer_item

        # add the pane window itself
        if spacer_only or not pane.window:
            sizer_item = vert_pane_sizer.Add((1, 1), 1, wx.EXPAND)
        else:
            sizer_item = vert_pane_sizer.Add(pane.window, 1, wx.EXPAND)
            vert_pane_sizer.SetItemMinSize(pane.window, (1, 1))

        part = AuiDockUIPart()
        part.type = AuiDockUIPart.typePane
        part.dock = dock
        part.pane = pane
        part.button = None
        part.orientation = orientation
        part.cont_sizer = vert_pane_sizer
        part.sizer_item = sizer_item
        uiparts.append(part)

        # determine if the pane should have a minimum size if the pane is
        # non-resizable (fixed) then we must set a minimum size. Alternatively,
        # if the pane.min_size is set, we must use that value as well

        min_size = pane.min_size
        if pane.IsFixed():
            if min_size == wx.Size(-1, -1):
                min_size = pane.best_size
                pane_proportion = 0

        if min_size != wx.Size(-1, -1):
            vert_pane_sizer.SetItemMinSize(len(vert_pane_sizer.GetChildren())-1, (min_size.x, min_size.y))

        # add the vertical/horizontal sizer (caption, pane window) to the
        # horizontal sizer (gripper, vertical sizer)
        horz_pane_sizer.Add(vert_pane_sizer, 1, wx.EXPAND)

        # finally, add the pane sizer to the dock sizer
        if pane.HasBorder():
            # allowing space for the pane's border
            sizer_item = cont.Add(horz_pane_sizer, pane_proportion,
                                  wx.EXPAND | wx.ALL, pane_border_size)
            part = AuiDockUIPart()
            part.type = AuiDockUIPart.typePaneBorder
            part.dock = dock
            part.pane = pane
            part.button = None
            part.orientation = orientation
            part.cont_sizer = cont
            part.sizer_item = sizer_item
            uiparts.append(part)
        else:
            sizer_item = cont.Add(horz_pane_sizer, pane_proportion, wx.EXPAND)

        return uiparts


    def LayoutAddDock(self, cont, dock, uiparts, spacer_only):
        """
        Adds a dock into the existing layout.

        :param `cont`: a :class:`Sizer` object;
        :param `dock`: the :class:`AuiDockInfo` structure to add to the layout;
        :param `uiparts`: a list of UI parts in the interface;
        :param bool `spacer_only`: whether to add a simple spacer or a real window.
        """

        sizer_item = wx.SizerItem()
        part = AuiDockUIPart()

        sash_size = self._art.GetMetric(AUI_DOCKART_SASH_SIZE)

        # WHAT IS THIS?! I DON'T EVEN...
        #orientation = (dock.IsHorizontal() and [wx.HORIZONTAL] or [wx.VERTICAL])[0]
        orientation = wx.HORIZONTAL if dock.IsHorizontal() else wx.VERTICAL

        # resizable bottom and right docks have a sash before them
        if not self._has_maximized and not dock.fixed and \
           dock.dock_direction in [AUI_DOCK_BOTTOM, AUI_DOCK_RIGHT]:

            sizer_item = cont.Add((sash_size, sash_size), 0, wx.EXPAND)

            part.type = AuiDockUIPart.typeDockSizer
            part.orientation = orientation
            part.dock = dock
            part.pane = None
            part.button = None
            part.cont_sizer = cont
            part.sizer_item = sizer_item
            uiparts.append(part)

        # create the sizer for the dock
        dock_sizer = wx.BoxSizer(orientation)

        # add each pane to the dock
        has_maximized_pane = False
        pane_count = len(dock.panes)

        if dock.fixed:

            # figure out the real pane positions we will
            # use, without modifying the each pane's pane_pos member
            pane_positions, pane_sizes = self.GetPanePositionsAndSizes(dock)

            offset = 0
            for pane_i in xrange(pane_count):

                pane = dock.panes[pane_i]
                pane_pos = pane_positions[pane_i]

                if pane.IsMaximized():
                    has_maximized_pane = True

                amount = pane_pos - offset
                if amount > 0:

                    if dock.IsVertical():
                        sizer_item = dock_sizer.Add((1, amount), 0, wx.EXPAND)
                    else:
                        sizer_item = dock_sizer.Add((amount, 1), 0, wx.EXPAND)

                    part = AuiDockUIPart()
                    part.type = AuiDockUIPart.typeBackground
                    part.dock = dock
                    part.pane = None
                    part.button = None
                    part.orientation = (orientation==wx.HORIZONTAL and \
                                        [wx.VERTICAL] or [wx.HORIZONTAL])[0]
                    part.cont_sizer = dock_sizer
                    part.sizer_item = sizer_item
                    uiparts.append(part)

                    offset = offset + amount

                uiparts = self.LayoutAddPane(dock_sizer, dock, pane, uiparts, spacer_only)

                offset = offset + pane_sizes[pane_i]

            # at the end add a very small stretchable background area
            sizer_item = dock_sizer.Add((0, 0), 1, wx.EXPAND)
            part = AuiDockUIPart()
            part.type = AuiDockUIPart.typeBackground
            part.dock = dock
            part.pane = None
            part.button = None
            part.orientation = orientation
            part.cont_sizer = dock_sizer
            part.sizer_item = sizer_item
            uiparts.append(part)

        else:

            for pane_i in xrange(pane_count):

                pane = dock.panes[pane_i]

                if pane.IsMaximized():
                    has_maximized_pane = True

                # if this is not the first pane being added,
                # we need to add a pane sizer
                if not self._has_maximized and pane_i > 0:
                    sizer_item = dock_sizer.Add((sash_size, sash_size), 0, wx.EXPAND)
                    part = AuiDockUIPart()
                    part.type = AuiDockUIPart.typePaneSizer
                    part.dock = dock
                    part.pane = dock.panes[pane_i-1]
                    part.button = None
                    part.orientation = (orientation==wx.HORIZONTAL and \
                                        [wx.VERTICAL] or [wx.HORIZONTAL])[0]
                    part.cont_sizer = dock_sizer
                    part.sizer_item = sizer_item
                    uiparts.append(part)

                uiparts = self.LayoutAddPane(dock_sizer, dock, pane, uiparts, spacer_only)

        if dock.dock_direction == AUI_DOCK_CENTER or has_maximized_pane:
            sizer_item = cont.Add(dock_sizer, 1, wx.EXPAND)
        else:
            sizer_item = cont.Add(dock_sizer, 0, wx.EXPAND)

        part = AuiDockUIPart()
        part.type = AuiDockUIPart.typeDock
        part.dock = dock
        part.pane = None
        part.button = None
        part.orientation = orientation
        part.cont_sizer = cont
        part.sizer_item = sizer_item
        uiparts.append(part)

        if dock.IsHorizontal():
            cont.SetItemMinSize(dock_sizer, (0, dock.size))
        else:
            cont.SetItemMinSize(dock_sizer, (dock.size, 0))

        #  top and left docks have a sash after them
        if not self._has_maximized and not dock.fixed and \
           dock.dock_direction in [AUI_DOCK_TOP, AUI_DOCK_LEFT]:

            sizer_item = cont.Add((sash_size, sash_size), 0, wx.EXPAND)

            part = AuiDockUIPart()
            part.type = AuiDockUIPart.typeDockSizer
            part.dock = dock
            part.pane = None
            part.button = None
            part.orientation = orientation
            part.cont_sizer = cont
            part.sizer_item = sizer_item
            uiparts.append(part)

        return uiparts


    def LayoutAll(self, panes, docks, uiparts, spacer_only=False, oncheck=True):
        """
        Layouts all the UI structures in the interface.

        :param `panes`: a list of :class:`AuiPaneInfo` instances;
        :param `docks`: a list of :class:`AuiDockInfo` classes;
        :param `uiparts`: a list of UI parts in the interface;
        :param bool `spacer_only`: whether to add a simple spacer or a real window;
        :param bool `oncheck`: whether to store the results in a class member or not.
        """
        container = wx.BoxSizer(wx.VERTICAL)

        pane_border_size = self._art.GetMetric(AUI_DOCKART_PANE_BORDER_SIZE)
        caption_size = self._art.GetMetric(AUI_DOCKART_CAPTION_SIZE)
        cli_size = self._frame.GetClientSize()

        # empty all docks out
        for dock in docks:
            dock.panes = []
            if dock.fixed:
                # always reset fixed docks' sizes, because
                # the contained windows may have been resized
                dock.size = 0

        dock_count = len(docks)

        # iterate through all known panes, filing each
        # of them into the appropriate dock. If the
        # pane does not exist in the dock, add it
        for p in panes:

            # don't layout hidden panes.
            if p.IsShown():

                # find any docks with the same dock direction, dock layer, and
                # dock row as the pane we are working on
                arr = FindDocks(docks, p.dock_direction, p.dock_layer, p.dock_row)

                if arr:
                    dock = arr[0]

                else:
                    # dock was not found, so we need to create a new one
                    d = AuiDockInfo()
                    d.dock_direction = p.dock_direction
                    d.dock_layer = p.dock_layer
                    d.dock_row = p.dock_row
                    docks.append(d)
                    dock = docks[-1]

                    if p.HasFlag(p.needsRestore) and not p.HasFlag(p.wasMaximized):

                        isHor = dock.IsHorizontal()
                        sashSize = self._art.GetMetric(AUI_DOCKART_SASH_SIZE)

                        # get the sizes of any docks that might
                        # overlap with our restored dock

                        # make list of widths or heights from the size in the dock rects
                        sizes = [d.rect[2:][isHor] for \
                                 d in docks if d.IsOk() and \
                                 (d.IsHorizontal() == isHor) and \
                                 not d.toolbar and \
                                 d.dock_direction != AUI_DOCK_CENTER]

                        frameRect = GetInternalFrameRect(self._frame, self._docks)

                        # set max size allowing for sashes and absolute minimum
                        maxsize = frameRect[2:][isHor] - sum(sizes) - (len(sizes)*10) - (sashSize*len(sizes))
                        dock.size = min(p.previousDockSize,maxsize)

                    else:
                        dock.size = 0

                if p.HasFlag(p.wasMaximized):
                    self.MaximizePane(p, savesizes=False)
                    p.SetFlag(p.wasMaximized, False)

                if p.HasFlag(p.needsRestore):
                    if p.previousDockPos is not None:
                        DoInsertPane(dock.panes, dock.dock_direction, dock.dock_layer, dock.dock_row, p.previousDockPos)
                        p.dock_pos = p.previousDockPos
                        p.previousDockPos = None
                    p.SetFlag(p.needsRestore, False)

                if p.IsDocked():
                    # remove the pane from any existing docks except this one
                    docks = RemovePaneFromDocks(docks, p, dock)

                    # pane needs to be added to the dock,
                    # if it doesn't already exist
                    if not FindPaneInDock(dock, p.window):
                        dock.panes.append(p)
                else:
                    # remove the pane from any existing docks
                    docks = RemovePaneFromDocks(docks, p)

        # remove any empty docks
        docks = [dock for dock in docks if dock.panes]

        dock_count = len(docks)
        # configure the docks further
        for ii, dock in enumerate(docks):
            # sort the dock pane array by the pane's
            # dock position (dock_pos), in ascending order
            dock.panes.sort(PaneSortFunc)
            dock_pane_count = len(dock.panes)

            # for newly created docks, set up their initial size
            if dock.size == 0:
                size = 0
                for pane in dock.panes:
                    pane_size = pane.best_size
                    if pane_size == wx.Size(-1, -1):
                        pane_size = pane.min_size
                    if pane_size == wx.Size(-1, -1) and pane.window:
                        pane_size = pane.window.GetSize()
                    if dock.IsHorizontal():
                        size = max(pane_size.y, size)
                    else:
                        size = max(pane_size.x, size)

                # add space for the border (two times), but only
                # if at least one pane inside the dock has a pane border
                for pane in dock.panes:
                    if pane.HasBorder():
                        size = size + pane_border_size*2
                        break

                # if pane is on the top or bottom, add the caption height,
                # but only if at least one pane inside the dock has a caption
                if dock.IsHorizontal():
                    for pane in dock.panes:
                        if pane.HasCaption() and not pane.HasCaptionLeft():
                            size = size + caption_size
                            break
                else:
                    for pane in dock.panes:
                        if pane.HasCaptionLeft() and not pane.HasCaption():
                            size = size + caption_size
                            break

                # new dock's size may not be more than the dock constraint
                # parameter specifies.  See SetDockSizeConstraint()
                max_dock_x_size = int(self._dock_constraint_x*float(cli_size.x))
                max_dock_y_size = int(self._dock_constraint_y*float(cli_size.y))
                if cli_size <= wx.Size(20, 20):
                    max_dock_x_size = 10000
                    max_dock_y_size = 10000

                if dock.IsHorizontal():
                    size = min(size, max_dock_y_size)
                else:
                    size = min(size, max_dock_x_size)

                # absolute minimum size for a dock is 10 pixels
                if size < 10:
                    size = 10

                dock.size = size

            # determine the dock's minimum size
            plus_border = False
            plus_caption = False
            plus_caption_left = False
            dock_min_size = 0
            for pane in dock.panes:
                if pane.min_size != wx.Size(-1, -1):
                    if pane.HasBorder():
                        plus_border = True
                    if pane.HasCaption():
                        plus_caption = True
                    if pane.HasCaptionLeft():
                        plus_caption_left = True
                    if dock.IsHorizontal():
                        if pane.min_size.y > dock_min_size:
                            dock_min_size = pane.min_size.y
                    else:
                        if pane.min_size.x > dock_min_size:
                            dock_min_size = pane.min_size.x

            if plus_border:
                dock_min_size += pane_border_size*2
            if plus_caption and dock.IsHorizontal():
                dock_min_size += caption_size
            if plus_caption_left and dock.IsVertical():
                dock_min_size += caption_size

            dock.min_size = dock_min_size

            # if the pane's current size is less than it's
            # minimum, increase the dock's size to it's minimum
            if dock.size < dock.min_size:
                dock.size = dock.min_size

            # determine the dock's mode (fixed or proportional)
            # determine whether the dock has only toolbars
            action_pane_marked = False
            dock.fixed = True
            dock.toolbar = True
            for pane in dock.panes:
                if not pane.IsFixed():
                    dock.fixed = False
                if not pane.IsToolbar():
                    dock.toolbar = False
                if pane.HasFlag(AuiPaneInfo.optionDockFixed):
                    dock.fixed = True
                if pane.HasFlag(AuiPaneInfo.actionPane):
                    action_pane_marked = True

            # if the dock mode is proportional and not fixed-pixel,
            # reassign the dock_pos to the sequential 0, 1, 2, 3
            # e.g. remove gaps like 1, 2, 30, 500
            if not dock.fixed:
                for jj in xrange(dock_pane_count):
                    pane = dock.panes[jj]
                    pane.dock_pos = jj

            # if the dock mode is fixed, and none of the panes
            # are being moved right now, make sure the panes
            # do not overlap each other.  If they do, we will
            # adjust the panes' positions
            if dock.fixed and not action_pane_marked:
                pane_positions, pane_sizes = self.GetPanePositionsAndSizes(dock)
                offset = 0
                for jj in xrange(dock_pane_count):
                    pane = dock.panes[jj]
                    pane.dock_pos = pane_positions[jj]
                    amount = pane.dock_pos - offset
                    if amount >= 0:
                        offset += amount
                    else:
                        pane.dock_pos += -amount

                    offset += pane_sizes[jj]
                    dock.panes[jj] = pane

            if oncheck:
                self._docks[ii] = dock

        # shrink docks if needed
##        docks = self.SmartShrink(docks, AUI_DOCK_TOP)
##        docks = self.SmartShrink(docks, AUI_DOCK_LEFT)

        if oncheck:
            self._docks = docks

        # discover the maximum dock layer
        max_layer = 0
        dock_count = len(docks)

        for ii in xrange(dock_count):
            max_layer = max(max_layer, docks[ii].dock_layer)

        # clear out uiparts
        uiparts = []

        # create a bunch of box sizers,
        # from the innermost level outwards.
        cont = None
        middle = None

        if oncheck:
            docks = self._docks

        for layer in xrange(max_layer+1):
            # find any docks in this layer
            arr = FindDocks(docks, -1, layer, -1)
            # if there aren't any, skip to the next layer
            if not arr:
                continue

            old_cont = cont

            # create a container which will hold this layer's
            # docks (top, bottom, left, right)
            cont = wx.BoxSizer(wx.VERTICAL)

            # find any top docks in this layer
            arr = FindDocks(docks, AUI_DOCK_TOP, layer, -1)
            for row in arr:
                uiparts = self.LayoutAddDock(cont, row, uiparts, spacer_only)

            # fill out the middle layer (which consists
            # of left docks, content area and right docks)

            middle = wx.BoxSizer(wx.HORIZONTAL)

            # find any left docks in this layer
            arr = FindDocks(docks, AUI_DOCK_LEFT, layer, -1)
            for row in arr:
                uiparts = self.LayoutAddDock(middle, row, uiparts, spacer_only)

            # add content dock (or previous layer's sizer
            # to the middle
            if not old_cont:
                # find any center docks
                arr = FindDocks(docks, AUI_DOCK_CENTER, -1, -1)
                if arr:
                    for row in arr:
                       uiparts = self.LayoutAddDock(middle, row, uiparts, spacer_only)

                elif not self._has_maximized:
                    # there are no center docks, add a background area
                    sizer_item = middle.Add((1, 1), 1, wx.EXPAND)
                    part = AuiDockUIPart()
                    part.type = AuiDockUIPart.typeBackground
                    part.pane = None
                    part.dock = None
                    part.button = None
                    part.cont_sizer = middle
                    part.sizer_item = sizer_item
                    uiparts.append(part)
            else:
                middle.Add(old_cont, 1, wx.EXPAND)

            # find any right docks in this layer
            arr = FindDocks(docks, AUI_DOCK_RIGHT, layer, -1, reverse=True)
            for row in arr:
                uiparts = self.LayoutAddDock(middle, row, uiparts, spacer_only)

            if len(middle.GetChildren()) > 0:
                cont.Add(middle, 1, wx.EXPAND)

            # find any bottom docks in this layer
            arr = FindDocks(docks, AUI_DOCK_BOTTOM, layer, -1, reverse=True)
            for row in arr:
                    uiparts = self.LayoutAddDock(cont, row, uiparts, spacer_only)

        if not cont:
            # no sizer available, because there are no docks,
            # therefore we will create a simple background area
            cont = wx.BoxSizer(wx.VERTICAL)
            sizer_item = cont.Add((1, 1), 1, wx.EXPAND)
            part = AuiDockUIPart()
            part.type = AuiDockUIPart.typeBackground
            part.pane = None
            part.dock = None
            part.button = None
            part.cont_sizer = middle
            part.sizer_item = sizer_item
            uiparts.append(part)

        if oncheck:
            self._uiparts = uiparts
            self._docks = docks

        container.Add(cont, 1, wx.EXPAND)

        if oncheck:
            return container
        else:
            return container, panes, docks, uiparts


    def SetDockSizeConstraint(self, width_pct, height_pct):
        """
        When a user creates a new dock by dragging a window into a docked position,
        often times the large size of the window will create a dock that is unwieldly
        large.

        :class:`AuiManager` by default limits the size of any new dock to 1/3 of the window
        size. For horizontal docks, this would be 1/3 of the window height. For vertical
        docks, 1/3 of the width. Calling this function will adjust this constraint value.

        The numbers must be between 0.0 and 1.0. For instance, calling :meth:`SetDockSizeConstraint`
        with (0.5, 0.5) will cause new docks to be limited to half of the size of the entire
        managed window.

        :param float `width_pct`: a number representing the `x` dock size constraint;
        :param float `width_pct`: a number representing the `y` dock size constraint.
        """

        self._dock_constraint_x = max(0.0, min(1.0, width_pct))
        self._dock_constraint_y = max(0.0, min(1.0, height_pct))


    def GetDockSizeConstraint(self):
        """
        Returns the current dock constraint values.

        :see: :meth:`SetDockSizeConstraint`
        """

        return self._dock_constraint_x, self._dock_constraint_y


    def Update(self):
        """
        This method is called after any number of changes are made to any of the
        managed panes. :meth:`Update` must be invoked after :meth:`AddPane`
        or :meth:`InsertPane` are called in order to "realize" or "commit" the changes.

        In addition, any number of changes may be made to :class:`AuiManager` structures
        (retrieved with :meth:`GetPane`), but to realize the changes, :meth:`Update`
        must be called. This construction allows pane flicker to be avoided by updating
        the whole layout at one time.
        """
        self._hover_button = None
        self._action_part = None

        # destroy floating panes which have been
        # redocked or are becoming non-floating
        for p in self._panes:
            if p.IsFloating() or not p.frame:
                continue

            # because the pane is no longer in a floating, we need to
            # reparent it to self._frame and destroy the floating frame
            # reduce flicker
            p.window.SetSize((1, 1))

            # the following block is a workaround for bug #1531361
            # (see wxWidgets sourceforge page).  On wxGTK (only), when
            # a frame is shown/hidden, a move event unfortunately
            # also gets fired.  Because we may be dragging around
            # a pane, we need to cancel that action here to prevent
            # a spurious crash.
            if self._action_window == p.frame:
                if self._frame.HasCapture():
                    self._frame.ReleaseMouse()
                self._action = actionNone
                self._action_window = None

            # hide the frame
            if p.frame.IsShown():
                p.frame.Show(False)

            if self._action_window == p.frame:
                self._action_window = None

            # reparent to self._frame and destroy the pane
            p.window.Reparent(self._frame)
            if isinstance(p.window, auibar.AuiToolBar):
                p.window.SetAuiManager(self)

            if p.frame:
                p.frame.SetSizer(None)
                p.frame.Destroy()
            p.frame = None

        # Only the master manager should create/destroy notebooks...
        if not self._masterManager:
            self.UpdateNotebook()

        # delete old sizer first
        self._frame.SetSizer(None)

        # create a layout for all of the panes
        sizer = self.LayoutAll(self._panes, self._docks, self._uiparts, False)

        # hide or show panes as necessary,
        # and float panes as necessary

        pane_count = len(self._panes)

        for ii in xrange(pane_count):
            p = self._panes[ii]
            pFrame = p.frame
            if p.IsFloating():
                if pFrame is None:
                    # we need to create a frame for this
                    # pane, which has recently been floated
                    frame = self.CreateFloatingFrame(self._frame, p)

                    # on MSW and Mac, if the owner desires transparent dragging, and
                    # the dragging is happening right now, then the floating
                    # window should have this style by default
                    if self._action in [actionDragFloatingPane, actionDragToolbarPane] and \
                       self._agwFlags & AUI_MGR_TRANSPARENT_DRAG:
                        frame.SetTransparent(150)

                    if p.IsToolbar():
                        bar = p.window
                        if isinstance(bar, auibar.AuiToolBar):
                            bar.SetGripperVisible(False)
                            agwStyle = bar.GetAGWWindowStyleFlag()
                            bar.SetAGWWindowStyleFlag(agwStyle & ~AUI_TB_VERTICAL)
                            bar.Realize()

                        s = p.window.GetMinSize()
                        p.BestSize(s)
                        p.FloatingSize(wx.DefaultSize)

                    frame.SetPaneWindow(p)
                    p.needsTransparency = True
                    p.frame = pFrame = frame
                    if p.IsShown() and not frame.IsShown():
                        frame.Show()
                        frame.Update()
                else:

                    # frame already exists, make sure it's position
                    # and size reflect the information in AuiPaneInfo
                    if pFrame.GetPosition() != p.floating_pos or pFrame.GetSize() != p.floating_size:
                        pFrame.SetDimensions(p.floating_pos.x, p.floating_pos.y,
                                             p.floating_size.x, p.floating_size.y, wx.SIZE_USE_EXISTING)

                    # update whether the pane is resizable or not
                    style = p.frame.GetWindowStyleFlag()
                    if p.IsFixed():
                        style &= ~wx.RESIZE_BORDER
                    else:
                        style |= wx.RESIZE_BORDER

                    # update the close button
                    if p.HasCloseButton():
                       style |= wx.CLOSE_BOX
                       if wx.Platform == '__WXMSW__':
                           style |= wx.SYSTEM_MENU
                    else:
                       style &= ~wx.CLOSE_BOX
                       if wx.Platform == '__WXMSW__':
                           style &= ~wx.SYSTEM_MENU

                    p.frame.SetWindowStyleFlag(style)

                    if pFrame.IsShown() != p.IsShown():
                        p.needsTransparency = True
                        pFrame.Show(p.IsShown())

                if pFrame.GetTitle() != p.caption:
                    pFrame.SetTitle(p.caption)
                if p.icon.IsOk():
                    pFrame.SetIcon(wx.IconFromBitmap(p.icon))

            else:

                if p.IsToolbar():
                    #self.SwitchToolBarOrientation(p)
                    p.best_size = p.window.GetBestSize()

                if p.window and not p.IsNotebookPage() and p.window.IsShown() != p.IsShown():
                    p.window.Show(p.IsShown())

            if pFrame and p.needsTransparency:
                if pFrame.IsShown() and pFrame._transparent != p.transparent:
                    pFrame.SetTransparent(p.transparent)
                    pFrame._transparent = p.transparent

                p.needsTransparency = False

            # if "active panes" are no longer allowed, clear
            # any optionActive values from the pane states
            if self._agwFlags & AUI_MGR_ALLOW_ACTIVE_PANE == 0:
                p.state &= ~AuiPaneInfo.optionActive

            self._panes[ii] = p

        old_pane_rects = []
        pane_count = len(self._panes)

        for p in self._panes:
            r = wx.Rect()
            if p.window and p.IsShown() and p.IsDocked():
                r = p.rect

            old_pane_rects.append(r)

        # apply the new sizer
        self._frame.SetSizer(sizer)
        self._frame.SetAutoLayout(False)
        self.DoFrameLayout()

        # now that the frame layout is done, we need to check
        # the new pane rectangles against the old rectangles that
        # we saved a few lines above here.  If the rectangles have
        # changed, the corresponding panes must also be updated
        for ii in xrange(pane_count):
            p = self._panes[ii]
            if p.window and p.IsShown() and p.IsDocked():
                if p.rect != old_pane_rects[ii]:
                    p.window.Refresh()
                    p.window.Update()

        if wx.Platform == "__WXMAC__":
            self._frame.Refresh()
        else:
            self.Repaint()

        if not self._masterManager:
            e = self.FireEvent(wxEVT_AUI_PERSPECTIVE_CHANGED, None, canVeto=False)


    def UpdateNotebook(self):
        """ Updates the automatic :class:`~lib.agw.aui.auibook.AuiNotebook` in the layout (if any exists). """

        # Workout how many notebooks we need.
        max_notebook = -1

        # destroy floating panes which have been
        # redocked or are becoming non-floating
        for paneInfo in self._panes:
            if max_notebook < paneInfo.notebook_id:
                max_notebook = paneInfo.notebook_id

        # We are the master of our domain
        extra_notebook = len(self._notebooks)
        max_notebook += 1

        for i in xrange(extra_notebook, max_notebook):
            self.CreateNotebook()

        # Remove pages from notebooks that no-longer belong there ...
        for nb, notebook in enumerate(self._notebooks):
            pages = notebook.GetPageCount()
            pageCounter, allPages = 0, pages

            # Check each tab ...
            for page in xrange(pages):

                if page >= allPages:
                    break

                window = notebook.GetPage(pageCounter)
                paneInfo = self.GetPane(window)
                if paneInfo.IsOk() and paneInfo.notebook_id != nb:
                    notebook.RemovePage(pageCounter)
                    window.Hide()
                    window.Reparent(self._frame)
                    pageCounter -= 1
                    allPages -= 1

                pageCounter += 1

            notebook.DoSizing()

        # Add notebook pages that aren't there already...
        for paneInfo in self._panes:
            if paneInfo.IsNotebookPage():

                title = (paneInfo.caption == "" and [paneInfo.name] or [paneInfo.caption])[0]

                notebook = self._notebooks[paneInfo.notebook_id]
                page_id = notebook.GetPageIndex(paneInfo.window)

                if page_id < 0:

                    paneInfo.window.Reparent(notebook)
                    notebook.AddPage(paneInfo.window, title, True, paneInfo.icon)

                # Update title and icon ...
                else:

                    notebook.SetPageText(page_id, title)
                    notebook.SetPageBitmap(page_id, paneInfo.icon)

                notebook.DoSizing()

            # Wire-up newly created notebooks
            elif paneInfo.IsNotebookControl() and not paneInfo.window:
                paneInfo.window = self._notebooks[paneInfo.notebook_id]

        # Delete empty notebooks, and convert notebooks with 1 page to
        # normal panes...
        remap_ids = [-1]*len(self._notebooks)
        nb_idx = 0

        for nb, notebook in enumerate(self._notebooks):
            if notebook.GetPageCount() == 1:

                # Convert notebook page to pane...
                window = notebook.GetPage(0)
                child_pane = self.GetPane(window)
                notebook_pane = self.GetPane(notebook)
                if child_pane.IsOk() and notebook_pane.IsOk():

                    child_pane.SetDockPos(notebook_pane)
                    child_pane.window.Hide()
                    child_pane.window.Reparent(self._frame)
                    child_pane.frame = None
                    child_pane.notebook_id = -1
                    if notebook_pane.IsFloating():
                        child_pane.Float()

                    self.DetachPane(notebook)

                    notebook.RemovePage(0)
                    notebook.Destroy()

                else:

                    raise Exception("Odd notebook docking")

            elif notebook.GetPageCount() == 0:

                self.DetachPane(notebook)
                notebook.Destroy()

            else:

                # Correct page ordering. The original wxPython code
                # for this did not work properly, and would misplace
                # windows causing errors.
                notebook.Freeze()
                self._notebooks[nb_idx] = notebook
                pages = notebook.GetPageCount()
                selected = notebook.GetPage(notebook.GetSelection())

                # Take each page out of the notebook, group it with
                # its current pane, and sort the list by pane.dock_pos
                # order
                pages_and_panes = []
                for idx in reversed(range(pages)):
                    page = notebook.GetPage(idx)
                    pane = self.GetPane(page)
                    pages_and_panes.append((page, pane))
                    notebook.RemovePage(idx)
                sorted_pnp = sorted(pages_and_panes, key=lambda tup: tup[1].dock_pos)

                # Grab the attributes from the panes which are ordered
                # correctly, and copy those attributes to the original
                # panes. (This avoids having to change the ordering
                # of self._panes) Then, add the page back into the notebook
                sorted_attributes = [self.GetAttributes(tup[1])
                                     for tup in sorted_pnp]
                for attrs, tup in zip(sorted_attributes, pages_and_panes):
                    pane = tup[1]
                    self.SetAttributes(pane, attrs)
                    notebook.AddPage(pane.window, pane.caption)

                notebook.SetSelection(notebook.GetPageIndex(selected), True)
                notebook.DoSizing()
                notebook.Thaw()

                # It's a keeper.
                remap_ids[nb] = nb_idx
                nb_idx += 1

        # Apply remap...
        nb_count = len(self._notebooks)

        if nb_count != nb_idx:

            self._notebooks = self._notebooks[0:nb_idx]
            for p in self._panes:
                if p.notebook_id >= 0:
                    p.notebook_id = remap_ids[p.notebook_id]
                    if p.IsNotebookControl():
                        p.SetNameFromNotebookId()

        # Make sure buttons are correct ...
        for notebook in self._notebooks:
            want_max = True
            want_min = True
            want_close = True

            pages = notebook.GetPageCount()
            for page in xrange(pages):

                win = notebook.GetPage(page)
                pane = self.GetPane(win)
                if pane.IsOk():

                    if not pane.HasCloseButton():
                        want_close = False
                    if not pane.HasMaximizeButton():
                        want_max = False
                    if not pane.HasMinimizeButton():
                        want_min = False

            notebook_pane = self.GetPane(notebook)
            if notebook_pane.IsOk():
                if notebook_pane.HasMinimizeButton() != want_min:
                    if want_min:
                        button = AuiPaneButton(AUI_BUTTON_MINIMIZE)
                        notebook_pane.state |= AuiPaneInfo.buttonMinimize
                        notebook_pane.buttons.append(button)

                    # todo: remove min/max

                if notebook_pane.HasMaximizeButton() != want_max:
                    if want_max:
                        button = AuiPaneButton(AUI_BUTTON_MAXIMIZE_RESTORE)
                        notebook_pane.state |= AuiPaneInfo.buttonMaximize
                        notebook_pane.buttons.append(button)

                    # todo: remove min/max

                if notebook_pane.HasCloseButton() != want_close:
                    if want_close:
                        button = AuiPaneButton(AUI_BUTTON_CLOSE)
                        notebook_pane.state |= AuiPaneInfo.buttonClose
                        notebook_pane.buttons.append(button)

                    # todo: remove close


    def SmartShrink(self, docks, direction):
        """
        Used to intelligently shrink the docks' size (if needed).

        :param `docks`: a list of :class:`AuiDockInfo` instances;
        :param integer `direction`: the direction in which to shrink.
        """

        sashSize = self._art.GetMetric(AUI_DOCKART_SASH_SIZE)
        caption_size = self._art.GetMetric(AUI_DOCKART_CAPTION_SIZE)
        clientSize = self._frame.GetClientSize()
        ourDocks = FindDocks(docks, direction, -1, -1)
        oppositeDocks = FindOppositeDocks(docks, direction)
        oppositeSize = self.GetOppositeDockTotalSize(docks, direction)
        ourSize = 0

        for dock in ourDocks:
            ourSize += dock.size

            if not dock.toolbar:
                ourSize += sashSize

        shrinkSize = ourSize + oppositeSize

        if direction == AUI_DOCK_TOP or direction == AUI_DOCK_BOTTOM:
            shrinkSize -= clientSize.y
        else:
            shrinkSize -= clientSize.x

        if shrinkSize <= 0:
            return docks

        # Combine arrays
        for dock in oppositeDocks:
            ourDocks.append(dock)

        oppositeDocks = []

        for dock in ourDocks:
            if dock.toolbar or not dock.resizable:
                continue

            dockRange = dock.size - dock.min_size

            if dock.min_size == 0:
                dockRange -= sashSize
                if direction == AUI_DOCK_TOP or direction == AUI_DOCK_BOTTOM:
                    dockRange -= caption_size

            if dockRange >= shrinkSize:

                dock.size -= shrinkSize
                return docks

            else:

                dock.size -= dockRange
                shrinkSize -= dockRange

        return docks


    def UpdateDockingGuides(self, paneInfo):
        """
        Updates the docking guide windows positions and appearance.

        :param `paneInfo`: a :class:`AuiPaneInfo` instance.
        """

        if len(self._guides) == 0:
            self.CreateGuideWindows()

        captionSize = self._art.GetMetric(AUI_DOCKART_CAPTION_SIZE)
        frameRect = GetInternalFrameRect(self._frame, self._docks)
        mousePos = wx.GetMousePosition()

        for indx, guide in enumerate(self._guides):

            pt = wx.Point()
            guide_size = guide.host.GetSize()
            if not guide.host:
                raise Exception("Invalid docking host")

            direction = guide.dock_direction

            if direction == AUI_DOCK_LEFT:
                pt.x = frameRect.x + guide_size.x / 2 + 16
                pt.y = frameRect.y + frameRect.height / 2

            elif direction == AUI_DOCK_TOP:
                pt.x = frameRect.x + frameRect.width / 2
                pt.y = frameRect.y + guide_size.y / 2 + 16

            elif direction == AUI_DOCK_RIGHT:
                pt.x = frameRect.x + frameRect.width - guide_size.x / 2 - 16
                pt.y = frameRect.y + frameRect.height / 2

            elif direction == AUI_DOCK_BOTTOM:
                pt.x = frameRect.x + frameRect.width / 2
                pt.y = frameRect.y + frameRect.height - guide_size.y / 2 - 16

            elif direction == AUI_DOCK_CENTER:
                rc = paneInfo.window.GetScreenRect()
                pt.x = rc.x + rc.width / 2
                pt.y = rc.y + rc.height / 2
                if paneInfo.HasCaption():
                    pt.y -= captionSize / 2
                elif paneInfo.HasCaptionLeft():
                    pt.x -= captionSize / 2

            # guide will be centered around point 'pt'
            targetPosition = wx.Point(pt.x - guide_size.x / 2, pt.y - guide_size.y / 2)

            if guide.host.GetPosition() != targetPosition:
                guide.host.Move(targetPosition)

            guide.host.AeroMove(targetPosition)

            if guide.dock_direction == AUI_DOCK_CENTER:
                guide.host.ValidateNotebookDocking(paneInfo.IsNotebookDockable())

            guide.host.UpdateDockGuide(mousePos)

        paneInfo.window.Lower()


    def DoFrameLayout(self):
        """
        This is an internal function which invokes :meth:`Sizer.Layout() <Sizer.Layout>`
        on the frame's main sizer, then measures all the various UI items
        and updates their internal rectangles.

        :note: This should always be called instead of calling
         `self._managed_window.Layout()` directly.
        """

        self._frame.Layout()

        for part in self._uiparts:
            # get the rectangle of the UI part
            # originally, this code looked like this:
            #    part.rect = wx.Rect(part.sizer_item.GetPosition(),
            #                       part.sizer_item.GetSize())
            # this worked quite well, with one exception: the mdi
            # client window had a "deferred" size variable
            # that returned the wrong size.  It looks like
            # a bug in wx, because the former size of the window
            # was being returned.  So, we will retrieve the part's
            # rectangle via other means

            part.rect = part.sizer_item.GetRect()
            flag = part.sizer_item.GetFlag()
            border = part.sizer_item.GetBorder()

            if flag & wx.TOP:
                part.rect.y -= border
                part.rect.height += border
            if flag & wx.LEFT:
                part.rect.x -= border
                part.rect.width += border
            if flag & wx.BOTTOM:
                part.rect.height += border
            if flag & wx.RIGHT:
                part.rect.width += border

            if part.type == AuiDockUIPart.typeDock:
                part.dock.rect = part.rect
            if part.type == AuiDockUIPart.typePane:
                part.pane.rect = part.rect


    def GetPanePart(self, wnd):
        """
        Looks up the pane border UI part of the
        pane specified. This allows the caller to get the exact rectangle
        of the pane in question, including decorations like caption and border.

        :param Window `wnd`: the window to which the pane border belongs to.
        """

        for part in self._uiparts:
            if part.type == AuiDockUIPart.typePaneBorder and \
               part.pane and part.pane.window == wnd:
                return part

        for part in self._uiparts:
            if part.type == AuiDockUIPart.typePane and \
               part.pane and part.pane.window == wnd:
                return part

        return None


    def GetDockPixelOffset(self, test):
        """
        This is an internal function which returns a dock's offset in pixels from
        the left side of the window (for horizontal docks) or from the top of the
        window (for vertical docks).

        This value is necessary for calculating fixed-pane/toolbar offsets
        when they are dragged.

        :param `test`: a fake :class:`AuiPaneInfo` for testing purposes.
        """

        # the only way to accurately calculate the dock's
        # offset is to actually run a theoretical layout
        docks, panes = CopyDocksAndPanes2(self._docks, self._panes)
        panes.append(test)

        sizer, panes, docks, uiparts = self.LayoutAll(panes, docks, [], True, False)
        client_size = self._frame.GetClientSize()
        sizer.SetDimension(0, 0, client_size.x, client_size.y)
        sizer.Layout()

        for part in uiparts:
            pos = part.sizer_item.GetPosition()
            size = part.sizer_item.GetSize()
            part.rect = wx.RectPS(pos, size)
            if part.type == AuiDockUIPart.typeDock:
                part.dock.rect = part.rect

        sizer.Destroy()

        for dock in docks:
            if test.dock_direction == dock.dock_direction and \
               test.dock_layer == dock.dock_layer and  \
               test.dock_row == dock.dock_row:

                if dock.IsVertical():
                    return dock.rect.y
                else:
                    return dock.rect.x

        return 0


    def GetPartnerDock(self, dock):
        """
        Returns the partner dock for the input dock.

        :param `dock`: a :class:`AuiDockInfo` instance.
        """

        for layer in xrange(dock.dock_layer, -1, -1):

            bestDock = None

            for tmpDock in self._docks:

                if tmpDock.dock_layer != layer:
                    continue

                if tmpDock.dock_direction != dock.dock_direction:
                    continue

                if tmpDock.dock_layer < dock.dock_layer:

                    if not bestDock or tmpDock.dock_row < bestDock.dock_row:
                        bestDock = tmpDock

                elif tmpDock.dock_row > dock.dock_row:

                    if not bestDock or tmpDock.dock_row > bestDock.dock_row:
                        bestDock = tmpDock

            if bestDock:
                return bestDock

        return None


    def GetPartnerPane(self, dock, pane):
        """
        Returns the partner pane for the input pane. They both need to live
        in the same :class:`AuiDockInfo`.

        :param `dock`: a :class:`AuiDockInfo` instance;
        :param `pane`: a :class:`AuiPaneInfo` class.
        """

        panePosition = -1

        for i, tmpPane in enumerate(dock.panes):
            if tmpPane.window == pane.window:
                panePosition = i
            elif not tmpPane.IsFixed() and panePosition != -1:
                return tmpPane

        return None


    def GetTotalPixSizeAndProportion(self, dock):
        """
        Returns the dimensions and proportion of the input dock.

        :param `dock`: the :class:`AuiDockInfo` structure to analyze.
        """

        totalPixsize = 0
        totalProportion = 0

        # determine the total proportion of all resizable panes,
        # and the total size of the dock minus the size of all
        # the fixed panes
        for tmpPane in dock.panes:

            if tmpPane.IsFixed():
                continue

            totalProportion += tmpPane.dock_proportion

            if dock.IsHorizontal():
                totalPixsize += tmpPane.rect.width
            else:
                totalPixsize += tmpPane.rect.height

##            if tmpPane.min_size.IsFullySpecified():
##
##                if dock.IsHorizontal():
##                    totalPixsize -= tmpPane.min_size.x
##                else:
##                    totalPixsize -= tmpPane.min_size.y

        return totalPixsize, totalProportion


    def GetOppositeDockTotalSize(self, docks, direction):
        """
        Returns the dimensions of the dock which lives opposite of the input dock.

        :param `docks`: a list of :class:`AuiDockInfo` structures to analyze;
        :param integer `direction`: the direction in which to look for the opposite dock.
        """

        sash_size = self._art.GetMetric(AUI_DOCKART_SASH_SIZE)
        caption_size = self._art.GetMetric(AUI_DOCKART_CAPTION_SIZE)
        pane_border_size = self._art.GetMetric(AUI_DOCKART_PANE_BORDER_SIZE)
        minSizeMax = 0
        result = sash_size
        vertical = False

        if direction in [AUI_DOCK_TOP, AUI_DOCK_BOTTOM]:
            vertical = True

        # Get minimum size of the most inner area
        for tmpDock in docks:

            if tmpDock.dock_layer != 0:
                continue

            if tmpDock.dock_direction != AUI_DOCK_CENTER and tmpDock.IsVertical() != vertical:
                continue

            for tmpPane in tmpDock.panes:

                minSize = pane_border_size*2 - sash_size

                if vertical:
                    minSize += tmpPane.min_size.y + caption_size
                else:
                    minSize += tmpPane.min_size.x

                if minSize > minSizeMax:
                    minSizeMax = minSize

        result += minSizeMax

        # Get opposite docks
        oppositeDocks = FindOppositeDocks(docks, direction)

        # Sum size of the opposite docks and their sashes
        for dock in oppositeDocks:
            result += dock.size
            # if it's not a toolbar add the sash_size too
            if not dock.toolbar:
                result += sash_size

        return result


    def CalculateDockSizerLimits(self, dock):
        """
        Calculates the minimum and maximum sizes allowed for the input dock.

        :param `dock`: the :class:`AuiDockInfo` structure to analyze.
        """

        docks, panes = CopyDocksAndPanes2(self._docks, self._panes)

        sash_size = self._art.GetMetric(AUI_DOCKART_SASH_SIZE)
        caption_size = self._art.GetMetric(AUI_DOCKART_CAPTION_SIZE)
        opposite_size = self.GetOppositeDockTotalSize(docks, dock.dock_direction)

        for tmpDock in docks:

            if tmpDock.dock_direction == dock.dock_direction and \
               tmpDock.dock_layer == dock.dock_layer and \
               tmpDock.dock_row == dock.dock_row:

                tmpDock.size = 1
                break

        sizer, panes, docks, uiparts = self.LayoutAll(panes, docks, [], True, False)
        client_size = self._frame.GetClientSize()
        sizer.SetDimension(0, 0, client_size.x, client_size.y)
        sizer.Layout()

        for part in uiparts:

            part.rect = wx.RectPS(part.sizer_item.GetPosition(), part.sizer_item.GetSize())
            if part.type == AuiDockUIPart.typeDock:
                part.dock.rect = part.rect

        sizer.Destroy()
        new_dock = None

        for tmpDock in docks:
            if tmpDock.dock_direction == dock.dock_direction and \
               tmpDock.dock_layer == dock.dock_layer and \
               tmpDock.dock_row == dock.dock_row:

                new_dock = tmpDock
                break

        partnerDock = self.GetPartnerDock(dock)

        if partnerDock:
            partnerRange = partnerDock.size - partnerDock.min_size
            if partnerDock.min_size == 0:
                partnerRange -= sash_size
                if dock.IsHorizontal():
                    partnerRange -= caption_size

            direction = dock.dock_direction

            if direction == AUI_DOCK_LEFT:
                minPix = new_dock.rect.x + new_dock.rect.width
                maxPix = dock.rect.x + dock.rect.width
                maxPix += partnerRange

            elif direction == AUI_DOCK_TOP:
                minPix = new_dock.rect.y + new_dock.rect.height
                maxPix = dock.rect.y + dock.rect.height
                maxPix += partnerRange

            elif direction == AUI_DOCK_RIGHT:
                minPix = dock.rect.x - partnerRange - sash_size
                maxPix = new_dock.rect.x - sash_size

            elif direction == AUI_DOCK_BOTTOM:
                minPix = dock.rect.y - partnerRange - sash_size
                maxPix = new_dock.rect.y - sash_size

            return minPix, maxPix

        direction = new_dock.dock_direction

        if direction == AUI_DOCK_LEFT:
            minPix = new_dock.rect.x + new_dock.rect.width
            maxPix = client_size.x - opposite_size - sash_size

        elif direction == AUI_DOCK_TOP:
            minPix = new_dock.rect.y + new_dock.rect.height
            maxPix = client_size.y - opposite_size - sash_size

        elif direction == AUI_DOCK_RIGHT:
            minPix = opposite_size
            maxPix = new_dock.rect.x - sash_size

        elif direction == AUI_DOCK_BOTTOM:
            minPix = opposite_size
            maxPix = new_dock.rect.y - sash_size

        return minPix, maxPix


    def CalculatePaneSizerLimits(self, dock, pane):
        """
        Calculates the minimum and maximum sizes allowed for the input pane.

        :param `dock`: the :class:`AuiDockInfo` structure to which `pane` belongs to;
        :param `pane`: a :class:`AuiPaneInfo` class for which calculation are requested.
        """

        if pane.IsFixed():
            if dock.IsHorizontal():
                minPix = maxPix = pane.rect.x + 1 + pane.rect.width
            else:
                minPix = maxPix = pane.rect.y + 1 + pane.rect.height

            return minPix, maxPix

        totalPixsize, totalProportion = self.GetTotalPixSizeAndProportion(dock)
        partnerPane = self.GetPartnerPane(dock, pane)

        if dock.IsHorizontal():

            minPix = pane.rect.x + 1
            maxPix = pane.rect.x + 1 + pane.rect.width

            if pane.min_size.IsFullySpecified():
                minPix += pane.min_size.x
            else:
                minPix += 1

            if partnerPane:
                maxPix += partnerPane.rect.width

                if partnerPane.min_size.IsFullySpecified():
                    maxPix -= partnerPane.min_size.x - 1

            else:
                minPix = maxPix

        else:

            minPix = pane.rect.y + 1
            maxPix = pane.rect.y + 1 + pane.rect.height

            if pane.min_size.IsFullySpecified():
                minPix += pane.min_size.y
            else:
                minPix += 1

            if partnerPane:
                maxPix += partnerPane.rect.height

                if partnerPane.min_size.IsFullySpecified():
                    maxPix -= partnerPane.min_size.y - 1

            else:
                minPix = maxPix

        return minPix, maxPix


    def CheckMovableSizer(self, part):
        """
        Checks if a UI part can be actually resized.

        :param AuiDockUIPart `part`: a UI part.
        """

        # a dock may not be resized if it has a single
        # pane which is not resizable
        if part.type == AuiDockUIPart.typeDockSizer and part.dock and \
           len(part.dock.panes) == 1 and part.dock.panes[0].IsFixed():

            return False

        if part.pane:

            # panes that may not be resized should be ignored here
            minPix, maxPix = self.CalculatePaneSizerLimits(part.dock, part.pane)

            if minPix == maxPix:
                return False

        return True


    def PaneFromTabEvent(self, event):
        """
        Returns a :class:`AuiPaneInfo` from a :class:`~lib.agw.aui.auibook.AuiNotebook` event.

        :param `event`: a :class:`~lib.agw.aui.auibook.AuiNotebookEvent` event.
        """

        obj = event.GetEventObject()

        if obj and isinstance(obj, auibook.AuiTabCtrl):

            page_idx = obj.GetActivePage()

            if page_idx >= 0:
                page = obj.GetPage(page_idx)
                window = page.window
                if window:
                    return self.GetPane(window)

        elif obj and isinstance(obj, auibook.AuiNotebook):

            page_idx = event.GetSelection()

            if page_idx >= 0:
                window = obj.GetPage(page_idx)
                if window:
                    return self.GetPane(window)

        return NonePaneInfo


    def OnTabBeginDrag(self, event):
        """
        Handles the ``EVT_AUINOTEBOOK_BEGIN_DRAG`` event.

        :param `event`: a :class:`~lib.agw.aui.auibook.AuiNotebookEvent` event to be processed.
        """

        if self._masterManager:
            self._masterManager.OnTabBeginDrag(event)

        else:
            paneInfo = self.PaneFromTabEvent(event)

            if paneInfo.IsOk():

                # It's one of ours!
                self._action = actionDragFloatingPane
                mouse = wx.GetMousePosition()

                # set initial float position - may have to think about this
                # offset a bit more later ...
                self._action_offset = wx.Point(20, 10)
                self._toolbar_action_offset = wx.Point(20, 10)

                paneInfo.floating_pos = mouse - self._action_offset
                paneInfo.dock_pos = AUI_DOCK_NONE
                paneInfo.notebook_id = -1

                tab = event.GetEventObject()

                if tab.HasCapture():
                    tab.ReleaseMouse()

                # float the window
                if paneInfo.IsMaximized():
                    self.RestorePane(paneInfo)
                paneInfo.Float()
                self.Update()

                self._action_window = paneInfo.window

                self._frame.CaptureMouse()
                event.SetDispatched(True)

            else:

                # not our window
                event.Skip()


    def OnTabPageClose(self, event):
        """
        Handles the ``EVT_AUINOTEBOOK_PAGE_CLOSE`` event.

        :param `event`: a :class:`~lib.agw.aui.auibook.AuiNotebookEvent` event to be processed.
        """

        if self._masterManager:
            self._masterManager.OnTabPageClose(event)

        else:

            p = self.PaneFromTabEvent(event)
            if p.IsOk():

                # veto it because we will call "RemovePage" ourselves
                event.Veto()

                # Now ask the app if they really want to close...
                # fire pane close event
                e = AuiManagerEvent(wxEVT_AUI_PANE_CLOSE)
                e.SetPane(p)
                e.SetCanVeto(True)
                self.ProcessMgrEvent(e)

                if e.GetVeto():
                    return

                self.ClosePane(p)
                self.Update()
            else:
                event.Skip()


    def OnTabSelected(self, event):
        """
        Handles the ``EVT_AUINOTEBOOK_PAGE_CHANGED`` event.

        :param `event`: a :class:`~lib.agw.aui.auibook.AuiNotebookEvent` event to be processed.
        """

        if self._masterManager:
            self._masterManager.OnTabSelected(event)
            return

        obj = event.GetEventObject()

        if obj and isinstance(obj, auibook.AuiNotebook):

            notebook = obj
            page = notebook.GetPage(event.GetSelection())
            paneInfo = self.GetPane(page)

            if paneInfo.IsOk():
                notebookRoot = GetNotebookRoot(self._panes, paneInfo.notebook_id)
                if notebookRoot:

                    notebookRoot.Caption(paneInfo.caption)
                    self.RefreshCaptions()

        event.Skip()


    def GetNotebooks(self):
        """ Returns all the automatic :class:`~lib.agw.aui.auibook.AuiNotebook` in the :class:`AuiManager`. """

        if self._masterManager:
            return self._masterManager.GetNotebooks()

        return self._notebooks


    def SetMasterManager(self, manager):
        """
        Sets the master manager for an automatic :class:`~lib.agw.aui.auibook.AuiNotebook`.

        :param `manager`: an instance of :class:`AuiManager`.
        """

        self._masterManager = manager


    def ProcessDockResult(self, target, new_pos):
        """
        This is a utility function used by :meth:`DoDrop` - it checks
        if a dock operation is allowed, the new dock position is copied into
        the target info. If the operation was allowed, the function returns ``True``.

        :param `target`: the :class:`AuiPaneInfo` instance to be docked;
        :param integer `new_pos`: the new docking position if the docking operation is allowed.
        """

        allowed = False
        direction = new_pos.dock_direction

        if direction == AUI_DOCK_TOP:
            allowed = target.IsTopDockable()
        elif direction == AUI_DOCK_BOTTOM:
            allowed = target.IsBottomDockable()
        elif direction == AUI_DOCK_LEFT:
            allowed = target.IsLeftDockable()
        elif direction == AUI_DOCK_RIGHT:
            allowed = target.IsRightDockable()

        if allowed:
            target = new_pos

            if target.IsToolbar():
                self.SwitchToolBarOrientation(target)

        return allowed, target


    def SwitchToolBarOrientation(self, pane):
        """
        Switches the toolbar orientation from vertical to horizontal and vice-versa.
        This is especially useful for vertical docked toolbars once they float.

        :param `pane`: an instance of :class:`AuiPaneInfo`, which may have a :class:`~lib.agw.aui.auibar.AuiToolBar`
         window associated with it.
        """
        if not isinstance(pane.window, auibar.AuiToolBar):
            return pane

        if pane.IsFloating():
            return pane

        toolBar = pane.window
        direction = pane.dock_direction
        vertical = direction in [AUI_DOCK_LEFT, AUI_DOCK_RIGHT]

        agwStyle = toolBar.GetAGWWindowStyleFlag()
        new_agwStyle = agwStyle

        if vertical:
            new_agwStyle |= AUI_TB_VERTICAL
        else:
            new_agwStyle &= ~(AUI_TB_VERTICAL)

        if agwStyle != new_agwStyle:
            toolBar.SetAGWWindowStyleFlag(new_agwStyle)
        if not toolBar.GetGripperVisible():
            toolBar.SetGripperVisible(True)

        s = pane.window.GetMinSize()
        pane.BestSize(s)
        if new_agwStyle != agwStyle:
            toolBar.Realize()

        return pane


    def DoDrop(self, docks, panes, target, pt, offset=wx.Point(0, 0)):
        """
        This is an important function. It basically takes a mouse position,
        and determines where the panes new position would be. If the pane is to be
        dropped, it performs the drop operation using the specified dock and pane
        arrays. By specifying copy dock and pane arrays when calling, a "what-if"
        scenario can be performed, giving precise coordinates for drop hints.

        :param `docks`: a list of :class:`AuiDockInfo` classes;
        :param `panes`: a list of :class:`AuiPaneInfo` instances;
        :param Point `pt`: a mouse position to check for a drop operation;
        :param Point `offset`: a possible offset from the input point `pt`.
        """

        if target.IsToolbar():
            return self.DoDropToolbar(docks, panes, target, pt, offset)
        elif target.IsFloating():
            return self.DoDropFloatingPane(docks, panes, target, pt)
        else:
            return self.DoDropNonFloatingPane(docks, panes, target, pt)


    def CopyTarget(self, target):
        """
        Copies all the attributes of the input `target` into another :class:`AuiPaneInfo`.

        :param `target`: the source :class:`AuiPaneInfo` from where to copy attributes.
        """

        drop = AuiPaneInfo()
        drop.name = target.name
        drop.caption = target.caption
        drop.window = target.window
        drop.frame = target.frame
        drop.state = target.state
        drop.dock_direction = target.dock_direction
        drop.dock_layer = target.dock_layer
        drop.dock_row = target.dock_row
        drop.dock_pos = target.dock_pos
        drop.best_size = wx.Size(*target.best_size)
        drop.min_size = wx.Size(*target.min_size)
        drop.max_size = wx.Size(*target.max_size)
        drop.floating_pos = wx.Point(*target.floating_pos)
        drop.floating_size = wx.Size(*target.floating_size)
        drop.dock_proportion = target.dock_proportion
        drop.buttons = target.buttons
        drop.rect = wx.Rect(*target.rect)
        drop.icon = target.icon
        drop.notebook_id = target.notebook_id
        drop.transparent = target.transparent
        drop.snapped = target.snapped
        drop.minimize_mode = target.minimize_mode
        drop.minimize_target = target.minimize_target

        return drop


    def DoDropToolbar(self, docks, panes, target, pt, offset):
        """
        Handles the situation in which the dropped pane contains a toolbar.

        :param `docks`: a list of :class:`AuiDockInfo` classes;
        :param `panes`: a list of :class:`AuiPaneInfo` instances;
        :param AuiPaneInfo `target`: the target pane containing the toolbar;
        :param Point `pt`: a mouse position to check for a drop operation;
        :param Point `offset`: a possible offset from the input point `pt`.
        """

        drop = self.CopyTarget(target)

        # The result should always be shown
        drop.Show()

        # Check to see if the toolbar has been dragged out of the window
        if CheckOutOfWindow(self._frame, pt):
            if self._agwFlags & AUI_MGR_ALLOW_FLOATING and drop.IsFloatable():
                drop.Float()

            return self.ProcessDockResult(target, drop)

        # Allow directional change when the cursor leaves this rect
        safeRect = wx.Rect(*target.rect)
        if target.IsHorizontal():
            safeRect.Inflate(100, 50)
        else:
            safeRect.Inflate(50, 100)

        # Check to see if the toolbar has been dragged to edge of the frame
        dropDir = CheckEdgeDrop(self._frame, docks, pt)

        if dropDir != -1:

            if dropDir == wx.LEFT:
                drop.Dock().Left().Layer(auiToolBarLayer).Row(0). \
                    Position(pt.y - self.GetDockPixelOffset(drop) - offset.y)

            elif dropDir == wx.RIGHT:
                drop.Dock().Right().Layer(auiToolBarLayer).Row(0). \
                    Position(pt.y - self.GetDockPixelOffset(drop) - offset.y)

            elif dropDir == wx.TOP:
                drop.Dock().Top().Layer(auiToolBarLayer).Row(0). \
                    Position(pt.x - self.GetDockPixelOffset(drop) - offset.x)

            elif dropDir == wx.BOTTOM:
                drop.Dock().Bottom().Layer(auiToolBarLayer).Row(0). \
                    Position(pt.x - self.GetDockPixelOffset(drop) - offset.x)

            if not target.IsFloating() and safeRect.Contains(pt) and \
               target.dock_direction != drop.dock_direction:
                return False, target

            return self.ProcessDockResult(target, drop)

        # If the windows is floating and out of the client area, do nothing
        if drop.IsFloating() and not self._frame.GetClientRect().Contains(pt):
            return False, target

        # Ok, can't drop on edge - check internals ...

        clientSize = self._frame.GetClientSize()
        x = Clip(pt.x, 0, clientSize.x - 1)
        y = Clip(pt.y, 0, clientSize.y - 1)
        part = self.HitTest(x, y)

        if not part or not part.dock:
            return False, target

        dock = part.dock

        # toolbars may only be moved in and to fixed-pane docks,
        # otherwise we will try to float the pane.  Also, the pane
        # should float if being dragged over center pane windows
        if not dock.fixed or dock.dock_direction == AUI_DOCK_CENTER:

            if (self._agwFlags & AUI_MGR_ALLOW_FLOATING and drop.IsFloatable()) or \
               dock.dock_direction not in [AUI_DOCK_CENTER, AUI_DOCK_NONE]:
                if drop.IsFloatable():
                    drop.Float()

            return self.ProcessDockResult(target, drop)

        # calculate the offset from where the dock begins
        # to the point where the user dropped the pane
        dockDropOffset = 0
        if dock.IsHorizontal():
            dockDropOffset = pt.x - dock.rect.x - offset.x
        else:
            dockDropOffset = pt.y - dock.rect.y - offset.y

        drop.Dock().Direction(dock.dock_direction).Layer(dock.dock_layer). \
            Row(dock.dock_row).Position(dockDropOffset)

        if (pt.y <= dock.rect.GetTop() + 2 and dock.IsHorizontal()) or \
           (pt.x <= dock.rect.GetLeft() + 2 and dock.IsVertical()):

            if dock.dock_direction in [AUI_DOCK_TOP, AUI_DOCK_LEFT]:
                row = drop.dock_row
                panes = DoInsertDockRow(panes, dock.dock_direction, dock.dock_layer, dock.dock_row)
                drop.dock_row = row

            else:
                panes = DoInsertDockRow(panes, dock.dock_direction, dock.dock_layer, dock.dock_row+1)
                drop.dock_row = dock.dock_row + 1

        if (pt.y >= dock.rect.GetBottom() - 2 and dock.IsHorizontal()) or \
           (pt.x >= dock.rect.GetRight() - 2 and dock.IsVertical()):

            if dock.dock_direction in [AUI_DOCK_TOP, AUI_DOCK_LEFT]:
                panes = DoInsertDockRow(panes, dock.dock_direction, dock.dock_layer, dock.dock_row+1)
                drop.dock_row = dock.dock_row+1

            else:
                row = drop.dock_row
                panes = DoInsertDockRow(panes, dock.dock_direction, dock.dock_layer, dock.dock_row)
                drop.dock_row = row

        if not target.IsFloating() and safeRect.Contains(pt) and \
           target.dock_direction != drop.dock_direction:
            return False, target

        return self.ProcessDockResult(target, drop)


    def DoDropFloatingPane(self, docks, panes, target, pt):
        """
        Handles the situation in which the dropped pane contains a normal window.

        :param `docks`: a list of :class:`AuiDockInfo` classes;
        :param `panes`: a list of :class:`AuiPaneInfo` instances;
        :param AuiPaneInfo `target`: the target pane containing the window;
        :param Point `pt`: a mouse position to check for a drop operation.
        """
        screenPt = self._frame.ClientToScreen(pt)
        paneInfo = self.PaneHitTest(panes, pt)

        if paneInfo.IsMaximized():
            return False, target

        if paneInfo.window is None:
            return False, target

        # search the dock guides.
        # reverse order to handle the center first.
        for i in xrange(len(self._guides)-1, -1, -1):
            guide = self._guides[i]

            # do hit testing on the guide
            dir = guide.host.HitTest(screenPt.x, screenPt.y)

            if dir == -1:  # point was outside of the dock guide
                continue

            if dir == wx.ALL:   # target is a single dock guide
                return self.DoDropLayer(docks, target, guide.dock_direction)

            elif dir == wx.CENTER:

                if not target.IsNotebookDockable():
                    continue
                if not paneInfo.IsNotebookDockable() and not paneInfo.IsNotebookControl():
                    continue

                if not paneInfo.HasNotebook():

                    # Add a new notebook pane with the original as a tab...
                    self.CreateNotebookBase(panes, paneInfo)

                # Add new item to notebook
                target.NotebookPage(paneInfo.notebook_id)

            else:

                drop_pane = False
                drop_row = False

                insert_dir = paneInfo.dock_direction
                insert_layer = paneInfo.dock_layer
                insert_row = paneInfo.dock_row
                insert_pos = paneInfo.dock_pos

                if insert_dir == AUI_DOCK_CENTER:

                    insert_layer = 0
                    if dir == wx.LEFT:
                        insert_dir = AUI_DOCK_LEFT
                    elif dir == wx.UP:
                        insert_dir = AUI_DOCK_TOP
                    elif dir == wx.RIGHT:
                        insert_dir = AUI_DOCK_RIGHT
                    elif dir == wx.DOWN:
                        insert_dir = AUI_DOCK_BOTTOM

                if insert_dir == AUI_DOCK_LEFT:

                    drop_pane = (dir == wx.UP   or dir == wx.DOWN)
                    drop_row  = (dir == wx.LEFT or dir == wx.RIGHT)
                    if dir == wx.RIGHT:
                        insert_row += 1
                    elif dir == wx.DOWN:
                        insert_pos += 1

                elif insert_dir == AUI_DOCK_RIGHT:

                    drop_pane = (dir == wx.UP   or dir == wx.DOWN)
                    drop_row  = (dir == wx.LEFT or dir == wx.RIGHT)
                    if dir == wx.LEFT:
                        insert_row += 1
                    elif dir == wx.DOWN:
                        insert_pos += 1

                elif insert_dir == AUI_DOCK_TOP:

                    drop_pane = (dir == wx.LEFT or dir == wx.RIGHT)
                    drop_row  = (dir == wx.UP   or dir == wx.DOWN)
                    if dir == wx.DOWN:
                        insert_row += 1
                    elif dir == wx.RIGHT:
                        insert_pos += 1

                elif insert_dir == AUI_DOCK_BOTTOM:

                    drop_pane = (dir == wx.LEFT or dir == wx.RIGHT)
                    drop_row  = (dir == wx.UP   or dir == wx.DOWN)
                    if dir == wx.UP:
                        insert_row += 1
                    elif dir == wx.RIGHT:
                        insert_pos += 1

                if paneInfo.dock_direction == AUI_DOCK_CENTER:
                    insert_row = GetMaxRow(panes, insert_dir, insert_layer) + 1

                if drop_pane:
                    return self.DoDropPane(panes, target, insert_dir, insert_layer, insert_row, insert_pos)

                if drop_row:
                    return self.DoDropRow(panes, target, insert_dir, insert_layer, insert_row)

            return True, target

        return False, target


    def DoDropNonFloatingPane(self, docks, panes, target, pt):
        """
        Handles the situation in which the dropped pane is not floating.

        :param `docks`: a list of :class:`AuiDockInfo` classes;
        :param `panes`: a list of :class:`AuiPaneInfo` instances;
        :param AuiPaneInfo `target`: the target pane containing the toolbar;
        :param Point `pt`: a mouse position to check for a drop operation.
        """

        screenPt = self._frame.ClientToScreen(pt)
        clientSize = self._frame.GetClientSize()
        frameRect = GetInternalFrameRect(self._frame, self._docks)

        drop = self.CopyTarget(target)

        # The result should always be shown
        drop.Show()

        part = self.HitTest(pt.x, pt.y)

        if not part:
            return False, target

        if part.type == AuiDockUIPart.typeDockSizer:

            if len(part.dock.panes) != 1:
                return False, target

            part = self.GetPanePart(part.dock.panes[0].window)
            if not part:
                return False, target

        if not part.pane:
            return False, target

        part = self.GetPanePart(part.pane.window)
        if not part:
            return False, target

        insert_dock_row = False
        insert_row = part.pane.dock_row
        insert_dir = part.pane.dock_direction
        insert_layer = part.pane.dock_layer

        direction = part.pane.dock_direction

        if direction == AUI_DOCK_TOP:
            if pt.y >= part.rect.y and pt.y < part.rect.y+auiInsertRowPixels:
                insert_dock_row = True

        elif direction == AUI_DOCK_BOTTOM:
            if pt.y > part.rect.y+part.rect.height-auiInsertRowPixels and \
               pt.y <= part.rect.y + part.rect.height:
                insert_dock_row = True

        elif direction == AUI_DOCK_LEFT:
            if pt.x >= part.rect.x and pt.x < part.rect.x+auiInsertRowPixels:
                insert_dock_row = True

        elif direction == AUI_DOCK_RIGHT:
            if pt.x > part.rect.x+part.rect.width-auiInsertRowPixels and \
               pt.x <= part.rect.x+part.rect.width:
                insert_dock_row = True

        elif direction == AUI_DOCK_CENTER:

                # "new row pixels" will be set to the default, but
                # must never exceed 20% of the window size
                new_row_pixels_x = auiNewRowPixels
                new_row_pixels_y = auiNewRowPixels

                if new_row_pixels_x > (part.rect.width*20)/100:
                    new_row_pixels_x = (part.rect.width*20)/100

                if new_row_pixels_y > (part.rect.height*20)/100:
                    new_row_pixels_y = (part.rect.height*20)/100

                # determine if the mouse pointer is in a location that
                # will cause a new row to be inserted.  The hot spot positions
                # are along the borders of the center pane

                insert_layer = 0
                insert_dock_row = True
                pr = part.rect

                if pt.x >= pr.x and pt.x < pr.x + new_row_pixels_x:
                    insert_dir = AUI_DOCK_LEFT
                elif pt.y >= pr.y and pt.y < pr.y + new_row_pixels_y:
                    insert_dir = AUI_DOCK_TOP
                elif pt.x >= pr.x + pr.width - new_row_pixels_x and pt.x < pr.x + pr.width:
                    insert_dir = AUI_DOCK_RIGHT
                elif pt.y >= pr.y+ pr.height - new_row_pixels_y and pt.y < pr.y + pr.height:
                    insert_dir = AUI_DOCK_BOTTOM
                else:
                    return False, target

                insert_row = GetMaxRow(panes, insert_dir, insert_layer) + 1

        if insert_dock_row:

            panes = DoInsertDockRow(panes, insert_dir, insert_layer, insert_row)
            drop.Dock().Direction(insert_dir).Layer(insert_layer). \
                Row(insert_row).Position(0)

            return self.ProcessDockResult(target, drop)

        # determine the mouse offset and the pane size, both in the
        # direction of the dock itself, and perpendicular to the dock

        if part.orientation == wx.VERTICAL:

            offset = pt.y - part.rect.y
            size = part.rect.GetHeight()

        else:

            offset = pt.x - part.rect.x
            size = part.rect.GetWidth()

        drop_position = part.pane.dock_pos

        # if we are in the top/left part of the pane,
        # insert the pane before the pane being hovered over
        if offset <= size/2:

            drop_position = part.pane.dock_pos
            panes = DoInsertPane(panes,
                                 part.pane.dock_direction,
                                 part.pane.dock_layer,
                                 part.pane.dock_row,
                                 part.pane.dock_pos)

        # if we are in the bottom/right part of the pane,
        # insert the pane before the pane being hovered over
        if offset > size/2:

            drop_position = part.pane.dock_pos+1
            panes = DoInsertPane(panes,
                                 part.pane.dock_direction,
                                 part.pane.dock_layer,
                                 part.pane.dock_row,
                                 part.pane.dock_pos+1)


        drop.Dock(). \
                     Direction(part.dock.dock_direction). \
                     Layer(part.dock.dock_layer).Row(part.dock.dock_row). \
                     Position(drop_position)

        return self.ProcessDockResult(target, drop)


    def DoDropLayer(self, docks, target, dock_direction):
        """
        Handles the situation in which `target` is a single dock guide.

        :param `docks`: a list of :class:`AuiDockInfo` classes;
        :param AuiPaneInfo `target`: the target pane;
        :param integer `dock_direction`: the docking direction.
        """

        drop = self.CopyTarget(target)

        if dock_direction == AUI_DOCK_LEFT:
            drop.Dock().Left()
            drop_new_layer = max(max(GetMaxLayer(docks, AUI_DOCK_LEFT),
                                     GetMaxLayer(docks, AUI_DOCK_BOTTOM)),
                                 GetMaxLayer(docks, AUI_DOCK_TOP)) + 1

        elif dock_direction == AUI_DOCK_TOP:
            drop.Dock().Top()
            drop_new_layer = max(max(GetMaxLayer(docks, AUI_DOCK_TOP),
                                     GetMaxLayer(docks, AUI_DOCK_LEFT)),
                                 GetMaxLayer(docks, AUI_DOCK_RIGHT)) + 1

        elif dock_direction == AUI_DOCK_RIGHT:
            drop.Dock().Right()
            drop_new_layer = max(max(GetMaxLayer(docks, AUI_DOCK_RIGHT),
                                     GetMaxLayer(docks, AUI_DOCK_TOP)),
                                 GetMaxLayer(docks, AUI_DOCK_BOTTOM)) + 1

        elif dock_direction == AUI_DOCK_BOTTOM:
            drop.Dock().Bottom()
            drop_new_layer = max(max(GetMaxLayer(docks, AUI_DOCK_BOTTOM),
                                     GetMaxLayer(docks, AUI_DOCK_LEFT)),
                                 GetMaxLayer(docks, AUI_DOCK_RIGHT)) + 1

        else:
            return False, target


        drop.Dock().Layer(drop_new_layer)
        return self.ProcessDockResult(target, drop)


    def DoDropPane(self, panes, target, dock_direction, dock_layer, dock_row, dock_pos):
        """
        Drop a pane in the interface.

        :param `panes`: a list of :class:`AuiPaneInfo` classes;
        :param AuiPaneInfo `target`: the target pane;
        :param integer `dock_direction`: the docking direction;
        :param integer `dock_layer`: the docking layer;
        :param integer `dock_row`: the docking row;
        :param integer `dock_pos`: the docking position.
        """

        drop = self.CopyTarget(target)
        panes = DoInsertPane(panes, dock_direction, dock_layer, dock_row, dock_pos)

        drop.Dock().Direction(dock_direction).Layer(dock_layer).Row(dock_row).Position(dock_pos)
        return self.ProcessDockResult(target, drop)


    def DoDropRow(self, panes, target, dock_direction, dock_layer, dock_row):
        """
        Insert a row in the interface before dropping.

        :param `panes`: a list of :class:`AuiPaneInfo` classes;
        :param AuiPaneInfo `target`: the target pane;
        :param integer `dock_direction`: the docking direction;
        :param integer `dock_layer`: the docking layer;
        :param integer `dock_row`: the docking row.
        """

        drop = self.CopyTarget(target)
        panes = DoInsertDockRow(panes, dock_direction, dock_layer, dock_row)

        drop.Dock().Direction(dock_direction).Layer(dock_layer).Row(dock_row).Position(0)
        return self.ProcessDockResult(target, drop)


    def ShowHint(self, rect):
        """
        Shows the AUI hint window.

        :param Rect `rect`: the hint rect calculated in advance.
        """

        if rect == self._last_hint:
            return

        if self._agwFlags & AUI_MGR_RECTANGLE_HINT and wx.Platform != "__WXMAC__":

            if self._last_hint != rect:
                # remove the last hint rectangle
                self._last_hint = wx.Rect(*rect)
                self._frame.Refresh()
                self._frame.Update()

            screendc = wx.ScreenDC()
            clip = wx.Region(1, 1, 10000, 10000)

            # clip all floating windows, so we don't draw over them
            for pane in self._panes:
                if pane.IsFloating() and pane.frame.IsShown():

                    rect2 = wx.Rect(*pane.frame.GetRect())
                    if wx.Platform == "__WXGTK__":
                        # wxGTK returns the client size, not the whole frame size
                        rect2.width += 15
                        rect2.height += 35
                        rect2.Inflate(5, 5)

                    clip.SubtractRect(rect2)

            # As we can only hide the hint by redrawing the managed window, we
            # need to clip the region to the managed window too or we get
            # nasty redrawn problems.
            clip.IntersectRect(self._frame.GetRect())
            screendc.SetClippingRegionAsRegion(clip)

            stipple = PaneCreateStippleBitmap()
            brush = wx.BrushFromBitmap(stipple)
            screendc.SetBrush(brush)
            screendc.SetPen(wx.TRANSPARENT_PEN)
            screendc.DrawRectangle(rect.x, rect.y, 5, rect.height)
            screendc.DrawRectangle(rect.x+5, rect.y, rect.width-10, 5)
            screendc.DrawRectangle(rect.x+rect.width-5, rect.y, 5, rect.height)
            screendc.DrawRectangle(rect.x+5, rect.y+rect.height-5, rect.width-10, 5)
            RefreshDockingGuides(self._guides)

            return

        if not self._hint_window:
            self.CreateHintWindow()

        if self._hint_window:
            self._hint_window.SetRect(rect)
            self._hint_window.Show()

        self._hint_fadeamt = self._hint_fademax

        if self._agwFlags & AUI_MGR_HINT_FADE:
            self._hint_fadeamt = 0
            self._hint_window.SetTransparent(self._hint_fadeamt)

        if self._action == actionDragFloatingPane and self._action_window:
            self._action_window.SetFocus()

        if self._hint_fadeamt != self._hint_fademax: #  Only fade if we need to
            # start fade in timer
            self._hint_fadetimer.Start(5)

        self._last_hint = wx.Rect(*rect)


    def HideHint(self):
        """ Hides a transparent window hint if there is one. """

        # hides a transparent window hint if there is one
        if self._hint_window:
            self._hint_window.Hide()

        self._hint_fadetimer.Stop()
        self._last_hint = wx.Rect()


    def IsPaneButtonVisible(self, part):
        """
        Returns whether a pane button in the pane caption is visible.

        :param AuiDockUIPart `part`: the UI part to analyze.
        """

        captionRect = wx.Rect()

        for temp_part in self._uiparts:
            if temp_part.pane == part.pane and \
               temp_part.type == AuiDockUIPart.typeCaption:
                captionRect = temp_part.rect
                break

        return captionRect.ContainsRect(part.rect)


    def DrawPaneButton(self, dc, part, pt):
        """
        Draws a pane button in the caption (convenience function).

        :param `dc`: a :class:`DC` device context object;
        :param AuiDockUIPart `part`: the UI part to analyze;
        :param Point `pt`: the mouse location.
        """

        if not self.IsPaneButtonVisible(part):
            return

        state = AUI_BUTTON_STATE_NORMAL

        if part.rect.Contains(pt):

            if _VERSION_STRING < "2.9":
                leftDown = wx.GetMouseState().LeftDown()
            else:
                leftDown = wx.GetMouseState().LeftIsDown()

            if leftDown:
                state = AUI_BUTTON_STATE_PRESSED
            else:
                state = AUI_BUTTON_STATE_HOVER

        self._art.DrawPaneButton(dc, self._frame, part.button.button_id,
                                 state, part.rect, part.pane)


    def RefreshButton(self, part):
        """
        Refreshes a pane button in the caption.

        :param AuiDockUIPart `part`: the UI part to analyze.
        """

        rect = wx.Rect(*part.rect)
        rect.Inflate(2, 2)
        self._frame.Refresh(True, rect)
        self._frame.Update()


    def RefreshCaptions(self):
        """ Refreshes all pane captions. """

        for part in self._uiparts:
            if part.type == AuiDockUIPart.typeCaption:
                self._frame.Refresh(True, part.rect)
                self._frame.Update()


    def CalculateHintRect(self, pane_window, pt, offset):
        """
        Calculates the drop hint rectangle.

        The method first calls :meth:`DoDrop` to determine the exact position the pane would
        be at were if dropped. If the pane would indeed become docked at the
        specified drop point, the the rectangle hint will be returned in
        screen coordinates. Otherwise, an empty rectangle is returned.

        :param Window `pane_window`: it is the window pointer of the pane being dragged;
        :param Point `pt`: is the mouse position, in client coordinates;
        :param Point `offset`: describes the offset that the mouse is from the upper-left
         corner of the item being dragged.
        """

        # we need to paint a hint rectangle to find out the exact hint rectangle,
        # we will create a new temporary layout and then measure the resulting
        # rectangle we will create a copy of the docking structures (self._docks)
        # so that we don't modify the real thing on screen

        rect = wx.Rect()
        pane = self.GetPane(pane_window)

        attrs = self.GetAttributes(pane)
        hint = AuiPaneInfo()
        hint = self.SetAttributes(hint, attrs)

        if hint.name != "__HINT__":
            self._oldname = hint.name

        hint.name = "__HINT__"
        hint.PaneBorder(True)
        hint.Show()

        if not hint.IsOk():
            hint.name = self._oldname
            return rect

        docks, panes = CopyDocksAndPanes2(self._docks, self._panes)

        # remove any pane already there which bears the same window
        # this happens when you are moving a pane around in a dock
        for ii in xrange(len(panes)):
            if panes[ii].window == pane_window:
                docks = RemovePaneFromDocks(docks, panes[ii])
                panes.pop(ii)
                break

        # find out where the new pane would be
        allow, hint = self.DoDrop(docks, panes, hint, pt, offset)

        if not allow:
            return rect

        panes.append(hint)

        sizer, panes, docks, uiparts = self.LayoutAll(panes, docks, [], True, False)

        client_size = self._frame.GetClientSize()
        sizer.SetDimension(0, 0, client_size.x, client_size.y)
        sizer.Layout()

        sought = "__HINT__"

        # For a notebook page, actually look for the notebook itself.
        if hint.IsNotebookPage():
            id = hint.notebook_id
            for pane in panes:
                if pane.IsNotebookControl() and pane.notebook_id==id:
                    sought = pane.name
                    break

        for part in uiparts:
            if part.pane and part.pane.name == sought:
                rect.Union(wx.RectPS(part.sizer_item.GetPosition(),
                                     part.sizer_item.GetSize()))

        sizer.Destroy()

        # check for floating frame ...
        if rect.IsEmpty():
            for p in panes:
                if p.name == sought and p.IsFloating():
                    return wx.RectPS(p.floating_pos, p.floating_size)

        if rect.IsEmpty():
            return rect

        # actually show the hint rectangle on the screen
        rect.x, rect.y = self._frame.ClientToScreen((rect.x, rect.y))
        if self._frame.GetLayoutDirection() == wx.Layout_RightToLeft:
            # Mirror rectangle in RTL mode
            rect.x -= rect.GetWidth()

        return rect


    def DrawHintRect(self, pane_window, pt, offset):
        """
        Calculates the hint rectangle by calling :meth:`CalculateHintRect`. If there is a
        rectangle, it shows it by calling :meth:`ShowHint`, otherwise it hides any hint
        rectangle currently shown.

        :param Window `pane_window`: it is the window pointer of the pane being dragged;
        :param Point `pt`: is the mouse position, in client coordinates;
        :param Point `offset`: describes the offset that the mouse is from the upper-left
         corner of the item being dragged.
        """

        rect = self.CalculateHintRect(pane_window, pt, offset)

        if rect.IsEmpty():
            self.HideHint()
            self._hint_rect = wx.Rect()
        else:
            self.ShowHint(rect)
            self._hint_rect = wx.Rect(*rect)


    def GetPartSizerRect(self, uiparts):
        """
        Returns the rectangle surrounding the specified UI parts.

        :param list `uiparts`: list of :class:`AuiDockUIPart` parts.
        """

        rect = wx.Rect()

        for part in self._uiparts:
            if part.pane and part.pane.name == "__HINT__":
                rect.Union(wx.RectPS(part.sizer_item.GetPosition(),
                                     part.sizer_item.GetSize()))

        return rect


    def GetAttributes(self, pane):
        """
        Returns all the attributes of a :class:`AuiPaneInfo`.

        :param `pane`: a :class:`AuiPaneInfo` instance.
        """

        attrs = []
        attrs.extend([pane.window, pane.frame, pane.state, pane.dock_direction,
                      pane.dock_layer, pane.dock_pos, pane.dock_row, pane.dock_proportion,
                      pane.floating_pos, pane.floating_size, pane.best_size,
                      pane.min_size, pane.max_size, pane.caption, pane.name,
                      pane.buttons, pane.rect, pane.icon, pane.notebook_id,
                      pane.transparent, pane.snapped, pane.minimize_mode, pane.minimize_target])

        return attrs


    def SetAttributes(self, pane, attrs):
        """
        Sets all the attributes contained in `attrs` to a :class:`AuiPaneInfo`.

        :param `pane`: a :class:`AuiPaneInfo` instance;
        :param list `attrs`: a list of attributes.
        """

        pane.window = attrs[0]
        pane.frame = attrs[1]
        pane.state = attrs[2]
        pane.dock_direction = attrs[3]
        pane.dock_layer = attrs[4]
        pane.dock_pos = attrs[5]
        pane.dock_row = attrs[6]
        pane.dock_proportion = attrs[7]
        pane.floating_pos = attrs[8]
        pane.floating_size = attrs[9]
        pane.best_size = attrs[10]
        pane.min_size = attrs[11]
        pane.max_size = attrs[12]
        pane.caption = attrs[13]
        pane.name = attrs[14]
        pane.buttons = attrs[15]
        pane.rect = attrs[16]
        pane.icon = attrs[17]
        pane.notebook_id = attrs[18]
        pane.transparent = attrs[19]
        pane.snapped = attrs[20]
        pane.minimize_mode = attrs[21]
        pane.minimize_target = attrs[22]

        return pane


    def OnFloatingPaneResized(self, wnd, size):
        """
        Handles the resizing of a floating pane.

        :param Window `wnd`: the window managed by the pane;
        :param Size `size`: the new pane floating size.
        """

        # try to find the pane
        pane = self.GetPane(wnd)
        if not pane.IsOk():
            raise Exception("Pane window not found")

        if pane.frame:
            indx = self._panes.index(pane)
            pane.floating_pos = pane.frame.GetPosition()
            pane.floating_size = size
            self._panes[indx] = pane
            if pane.IsSnappable():
                self.SnapPane(pane, pane.floating_pos, pane.floating_size, True)


    def OnFloatingPaneClosed(self, wnd, event):
        """
        Handles the close event of a floating pane.

        :param Window `wnd`: the window managed by the pane;
        :param `event`: a :class:`CloseEvent` to be processed.
        """

        # try to find the pane
        pane = self.GetPane(wnd)
        if not pane.IsOk():
            raise Exception("Pane window not found")

        # fire pane close event
        e = AuiManagerEvent(wxEVT_AUI_PANE_CLOSE)
        e.SetPane(pane)
        e.SetCanVeto(event.CanVeto())
        self.ProcessMgrEvent(e)

        if e.GetVeto():
            event.Veto()
            return
        else:
            # close the pane, but check that it
            # still exists in our pane array first
            # (the event handler above might have removed it)

            check = self.GetPane(wnd)
            if check.IsOk():
                self.ClosePane(pane)


    def OnFloatingPaneActivated(self, wnd):
        """
        Handles the activation event of a floating pane.

        :param Window `wnd`: the window managed by the pane.
        """

        pane = self.GetPane(wnd)
        if not pane.IsOk():
            raise Exception("Pane window not found")

        if self.GetAGWFlags() & AUI_MGR_ALLOW_ACTIVE_PANE:
            ret, self._panes = SetActivePane(self._panes, wnd)
            self.RefreshCaptions()
            self.FireEvent(wxEVT_AUI_PANE_ACTIVATED, wnd, canVeto=False)


    def OnFloatingPaneMoved(self, wnd, eventOrPt):
        """
        Handles the move event of a floating pane.

        :param Window `wnd`: the window managed by the pane;
        :param `eventOrPt`: a :class:`MoveEvent` to be processed or an instance of :class:`Point`.
        """

        pane = self.GetPane(wnd)
        if not pane.IsOk():
            raise Exception("Pane window not found")

        if not pane.IsSnappable():
            return

        if isinstance(eventOrPt, wx.Point):
            pane_pos = wx.Point(*eventOrPt)
        else:
            pane_pos = eventOrPt.GetPosition()

        pane_size = pane.floating_size

        self.SnapPane(pane, pane_pos, pane_size, False)


    def SnapPane(self, pane, pane_pos, pane_size, toSnap=False):
        """
        Snaps a floating pane to one of the main frame sides.

        :param `pane`: a :class:`AuiPaneInfo` instance;
        :param Point `pane_pos`: the new pane floating position;
        :param Size `pane_size`: the new pane floating size;
        :param bool `toSnap`: a bool variable to check if :meth:`SnapPane` was called from
         a move event.
        """

        if self._from_move:
            return

        managed_window = self.GetManagedWindow()
        wnd_pos = managed_window.GetPosition()
        wnd_size = managed_window.GetSize()
        snapX, snapY = self._snap_limits

        if not toSnap:
            pane.snapped = 0
            if pane.IsLeftSnappable():
                # Check if we can snap to the left
                diff = wnd_pos.x - (pane_pos.x + pane_size.x)
                if -snapX <= diff <= snapX:
                    pane.snapped = wx.LEFT
                    pane.floating_pos = wx.Point(wnd_pos.x-pane_size.x, pane_pos.y)
            elif pane.IsTopSnappable():
                # Check if we can snap to the top
                diff = wnd_pos.y - (pane_pos.y + pane_size.y)
                if -snapY <= diff <= snapY:
                    pane.snapped = wx.TOP
                    pane.floating_pos = wx.Point(pane_pos.x, wnd_pos.y-pane_size.y)
            elif pane.IsRightSnappable():
                # Check if we can snap to the right
                diff = pane_pos.x - (wnd_pos.x + wnd_size.x)
                if -snapX <= diff <= snapX:
                    pane.snapped = wx.RIGHT
                    pane.floating_pos = wx.Point(wnd_pos.x + wnd_size.x, pane_pos.y)
            elif pane.IsBottomSnappable():
                # Check if we can snap to the bottom
                diff = pane_pos.y - (wnd_pos.y + wnd_size.y)
                if -snapY <= diff <= snapY:
                    pane.snapped = wx.BOTTOM
                    pane.floating_pos = wx.Point(pane_pos.x, wnd_pos.y + wnd_size.y)

        self.RepositionPane(pane, wnd_pos, wnd_size)


    def RepositionPane(self, pane, wnd_pos, wnd_size):
        """
        Repositions a pane after the main frame has been moved/resized.

        :param `pane`: a :class:`AuiPaneInfo` instance;
        :param Point `wnd_pos`: the main frame position;
        :param Size `wnd_size`: the main frame size.
        """

        pane_pos = pane.floating_pos
        pane_size = pane.floating_size

        snap = pane.snapped
        if snap == wx.LEFT:
            floating_pos = wx.Point(wnd_pos.x - pane_size.x, pane_pos.y)
        elif snap == wx.TOP:
            floating_pos = wx.Point(pane_pos.x, wnd_pos.y - pane_size.y)
        elif snap == wx.RIGHT:
            floating_pos = wx.Point(wnd_pos.x + wnd_size.x, pane_pos.y)
        elif snap == wx.BOTTOM:
            floating_pos = wx.Point(pane_pos.x, wnd_pos.y + wnd_size.y)

        if snap:
            if pane_pos != floating_pos:
                pane.floating_pos = floating_pos
                self._from_move = True
                pane.frame.SetPosition(pane.floating_pos)
                self._from_move = False


    def OnGripperClicked(self, pane_window, start, offset):
        """
        Handles the mouse click on the pane gripper.

        :param Window `pane_window`: the window managed by the pane;
        :param Point `start`: the mouse-click position;
        :param Point `offset`: an offset point from the `start` position.
        """

        # try to find the pane
        paneInfo = self.GetPane(pane_window)

        if not paneInfo.IsOk():
            raise Exception("Pane window not found")

        if self.GetAGWFlags() & AUI_MGR_ALLOW_ACTIVE_PANE:
            # set the caption as active
            ret, self._panes = SetActivePane(self._panes, pane_window)
            self.RefreshCaptions()
            self.FireEvent(wxEVT_AUI_PANE_ACTIVATED, pane_window, canVeto=False)

        self._action_part = None
        self._action_pane = paneInfo
        self._action_window = pane_window
        self._action_start = start
        self._action_offset = offset
        self._toolbar_action_offset = wx.Point(*self._action_offset)

        self._frame.CaptureMouse()

        if paneInfo.IsDocked():
            self._action = actionClickCaption
        else:
            if paneInfo.IsToolbar():
                self._action = actionDragToolbarPane
            else:
                self._action = actionDragFloatingPane

            if paneInfo.frame:

                windowPt = paneInfo.frame.GetRect().GetTopLeft()
                originPt = paneInfo.frame.ClientToScreen(wx.Point())
                self._action_offset += originPt - windowPt
                self._toolbar_action_offset = wx.Point(*self._action_offset)

                if self._agwFlags & AUI_MGR_TRANSPARENT_DRAG:
                    paneInfo.frame.SetTransparent(150)

            if paneInfo.IsToolbar():
                self._frame.SetCursor(wx.StockCursor(wx.CURSOR_SIZING))


    def OnRender(self, event):
        """
        Draws all of the pane captions, sashes, backgrounds, captions, grippers, pane borders and buttons.
        It renders the entire user interface. It binds the ``EVT_AUI_RENDER`` event.

        :param `event`: an instance of :class:`AuiManagerEvent`.
        """

        # if the frame is about to be deleted, don't bother
        if not self._frame or self._frame.IsBeingDeleted():
            return

        if not self._frame.GetSizer():
            return

        mouse = wx.GetMouseState()
        mousePos = wx.Point(mouse.GetX(), mouse.GetY())
        point = self._frame.ScreenToClient(mousePos)
        art = self._art

        dc = event.GetDC()

        for part in self._uiparts:

            # don't draw hidden pane items or items that aren't windows
            if part.sizer_item and ((not part.sizer_item.IsWindow() and \
                                     not part.sizer_item.IsSpacer() and \
                                     not part.sizer_item.IsSizer()) or \
                                    not part.sizer_item.IsShown()):

                continue

            ptype = part.type

            # Let's not allocate a list inside a loop, inside a paint event...
            #if ptype in [AuiDockUIPart.typesDockSizer, AuiDockUIPart.typePaneSizer]:
            if ptype == AuiDockUIPart.typeDockSizer or ptype == AuiDockUIPart.typePaneSizer:
                art.DrawSash(dc, self._frame, part.orientation, part.rect)

            elif ptype == AuiDockUIPart.typeBackground:
                art.DrawBackground(dc, self._frame, part.orientation, part.rect)

            elif ptype == AuiDockUIPart.typeCaption:
                art.DrawCaption(dc, self._frame, part.pane.caption, part.rect, part.pane)

            elif ptype == AuiDockUIPart.typeGripper:
                art.DrawGripper(dc, self._frame, part.rect, part.pane)

            elif ptype == AuiDockUIPart.typePaneBorder:
                art.DrawBorder(dc, self._frame, part.rect, part.pane)

            elif ptype == AuiDockUIPart.typePaneButton:
                self.DrawPaneButton(dc, part, point)


    def Repaint(self, dc=None):
        """
        Repaints the entire frame decorations (sashes, borders, buttons and so on).
        It renders the entire user interface.

        :param `dc`: if not ``None``, an instance of :class:`PaintDC`.
        """

        w, h = self._frame.GetClientSize()

        # Figure out which dc to use; if one
        # has been specified, use it, otherwise
        # make a client dc
        if dc is None:
            client_dc = wx.ClientDC(self._frame)
            dc = client_dc

        # If the frame has a toolbar, the client area
        # origin will not be (0, 0).
        pt = self._frame.GetClientAreaOrigin()
        if pt.x != 0 or pt.y != 0:
            dc.SetDeviceOrigin(pt.x, pt.y)

        # Render all the items
        self.Render(dc)


    def Render(self, dc):
        """
        Fires a render event, which is normally handled by :meth:`OnRender`. This allows the
        render function to be overridden via the render event.

        This can be useful for painting custom graphics in the main window.
        Default behavior can be invoked in the overridden function by calling
        :meth:`OnRender`.

        :param `dc`: a :class:`DC` device context object.
        """

        e = AuiManagerEvent(wxEVT_AUI_RENDER)
        e.SetManager(self)
        e.SetDC(dc)
        self.ProcessMgrEvent(e)


    def OnCaptionDoubleClicked(self, pane_window):
        """
        Handles the mouse double click on the pane caption.

        :param Window `pane_window`: the window managed by the pane.
        """

        # try to find the pane
        paneInfo = self.GetPane(pane_window)
        if not paneInfo.IsOk():
            raise Exception("Pane window not found")

        if not paneInfo.IsFloatable() or not paneInfo.IsDockable() or \
           self._agwFlags & AUI_MGR_ALLOW_FLOATING == 0:
            return

        indx = self._panes.index(paneInfo)
        win_rect = None

        if paneInfo.IsFloating():
            if paneInfo.name.startswith("__floating__"):
                # It's a floating tab from a AuiNotebook
                notebook = paneInfo.window.__aui_notebook__
                notebook.ReDockPage(paneInfo)
                self.Update()
                return
            else:

                e = self.FireEvent(wxEVT_AUI_PANE_DOCKING, paneInfo, canVeto=True)
                if e.GetVeto():
                    self.HideHint()
                    ShowDockingGuides(self._guides, False)
                    return

                win_rect = paneInfo.frame.GetRect()
                paneInfo.Dock()
                if paneInfo.IsToolbar():
                    paneInfo = self.SwitchToolBarOrientation(paneInfo)

                e = self.FireEvent(wxEVT_AUI_PANE_DOCKED, paneInfo, canVeto=False)

        else:

            e = self.FireEvent(wxEVT_AUI_PANE_FLOATING, paneInfo, canVeto=True)
            if e.GetVeto():
                return

            # float the window
            if paneInfo.IsMaximized():
                self.RestorePane(paneInfo)

            if paneInfo.floating_pos == wx.Point(-1, -1):
                captionSize = self._art.GetMetric(AUI_DOCKART_CAPTION_SIZE)
                paneInfo.floating_pos = pane_window.GetScreenPosition()
                paneInfo.floating_pos.y -= captionSize

            paneInfo.Float()
            e = self.FireEvent(wxEVT_AUI_PANE_FLOATED, paneInfo, canVeto=False)

        self._panes[indx] = paneInfo
        self.Update()

        if win_rect and self._agwFlags & AUI_MGR_ANIMATE_FRAMES:
            paneInfo = self.GetPane(pane_window)
            pane_rect = paneInfo.window.GetScreenRect()
            self.AnimateDocking(win_rect, pane_rect)


    def OnPaint(self, event):
        """
        Handles the ``wx.EVT_PAINT`` event for :class:`AuiManager`.

        :param `event`: an instance of :class:`PaintEvent` to be processed.
        """

        dc = wx.PaintDC(self._frame)
        self.Repaint(dc)


    def OnEraseBackground(self, event):
        """
        Handles the ``wx.EVT_ERASE_BACKGROUND`` event for :class:`AuiManager`.

        :param `event`: :class:`EraseEvent` to be processed.

        :note: This is intentionally empty (excluding wxMAC) to reduce
         flickering while drawing.
        """

        if wx.Platform == "__WXMAC__":
            event.Skip()


    def OnSize(self, event):
        """
        Handles the ``wx.EVT_SIZE`` event for :class:`AuiManager`.

        :param `event`: a :class:`SizeEvent` to be processed.
        """

        skipped = False
        if isinstance(self._frame, AuiFloatingFrame) and self._frame.IsShownOnScreen():
            skipped = True
            event.Skip()

        if self._frame:

            self.DoFrameLayout()
            if wx.Platform == "__WXMAC__":
                self._frame.Refresh()
            else:
                self.Repaint()

            if isinstance(self._frame, wx.MDIParentFrame) or isinstance(self._frame, tabmdi.AuiMDIClientWindow) \
               or isinstance(self._frame, tabmdi.AuiMDIParentFrame):
                # for MDI parent frames, this event must not
                # be "skipped".  In other words, the parent frame
                # must not be allowed to resize the client window
                # after we are finished processing sizing changes
                return

        if not skipped:
            event.Skip()

        # For the snap to screen...
        self.OnMove(None)


    def OnFindManager(self, event):
        """
        Handles the ``EVT_AUI_FIND_MANAGER`` event for :class:`AuiManager`.

        :param `event`: a :class:`AuiManagerEvent` event to be processed.
        """

        # Initialize to None
        event.SetManager(None)

        if not self._frame:
            return

        # See it this window wants to overwrite
        self._frame.ProcessEvent(event)

        # if no, it must be us
        if not event.GetManager():
           event.SetManager(self)


    def OnSetCursor(self, event):
        """
        Handles the ``wx.EVT_SET_CURSOR`` event for :class:`AuiManager`.

        :param `event`: a :class:`SetCursorEvent` to be processed.
        """

        # determine cursor
        part = self.HitTest(event.GetX(), event.GetY())
        cursor = wx.NullCursor

        if part:
            if part.type in [AuiDockUIPart.typeDockSizer, AuiDockUIPart.typePaneSizer]:

                if not self.CheckMovableSizer(part):
                    return

                if part.orientation == wx.VERTICAL:
                    cursor = wx.StockCursor(wx.CURSOR_SIZEWE)
                else:
                    cursor = wx.StockCursor(wx.CURSOR_SIZENS)

            elif part.type == AuiDockUIPart.typeGripper:
                cursor = wx.StockCursor(wx.CURSOR_SIZING)

        event.SetCursor(cursor)


    def UpdateButtonOnScreen(self, button_ui_part, event):
        """
        Updates/redraws the UI part containing a pane button.

        :param AuiDockUIPart `button_ui_part`: the UI part the button belongs to;
        :param `event`: a :class:`MouseEvent` to be processed.
        """

        hit_test = self.HitTest(*event.GetPosition())

        if not hit_test or not button_ui_part:
            return

        state = AUI_BUTTON_STATE_NORMAL

        if hit_test == button_ui_part:
            if event.LeftDown():
                state = AUI_BUTTON_STATE_PRESSED
            else:
                state = AUI_BUTTON_STATE_HOVER
        else:
            if event.LeftDown():
                state = AUI_BUTTON_STATE_HOVER

        # now repaint the button with hover state
        cdc = wx.ClientDC(self._frame)

        # if the frame has a toolbar, the client area
        # origin will not be (0,0).
        pt = self._frame.GetClientAreaOrigin()
        if pt.x != 0 or pt.y != 0:
            cdc.SetDeviceOrigin(pt.x, pt.y)

        if hit_test.pane:
            self._art.DrawPaneButton(cdc, self._frame,
                      button_ui_part.button.button_id,
                      state,
                      button_ui_part.rect, hit_test.pane)


    def OnLeftDown(self, event):
        """
        Handles the ``wx.EVT_LEFT_DOWN`` event for :class:`AuiManager`.

        :param `event`: a :class:`MouseEvent` to be processed.
        """

        part = self.HitTest(*event.GetPosition())

        if not part:
            event.Skip()
            return

        self._currentDragItem = -1

        if part.type in [AuiDockUIPart.typeDockSizer, AuiDockUIPart.typePaneSizer]:

            if not self.CheckMovableSizer(part):
                return

            self._action = actionResize
            self._action_part = part
            self._action_pane = None
            self._action_rect = wx.Rect()
            self._action_start = wx.Point(event.GetX(), event.GetY())
            self._action_offset = wx.Point(event.GetX() - part.rect.x,
                                           event.GetY() - part.rect.y)

            # draw the resize hint
            rect = wx.RectPS(self._frame.ClientToScreen(part.rect.GetPosition()),
                             part.rect.GetSize())

            self._action_rect = wx.Rect(*rect)

            if not AuiManager_HasLiveResize(self):
                if wx.Platform == "__WXMAC__":
                    dc = wx.ClientDC(self._frame)
                else:
                    dc = wx.ScreenDC()

                DrawResizeHint(dc, rect)

            self._frame.CaptureMouse()

        elif part.type == AuiDockUIPart.typePaneButton:
            if self.IsPaneButtonVisible(part):
                self._action = actionClickButton
                self._action_part = part
                self._action_pane = None
                self._action_start = wx.Point(*event.GetPosition())
                self._frame.CaptureMouse()

                self.RefreshButton(part)

        elif part.type in [AuiDockUIPart.typeCaption, AuiDockUIPart.typeGripper]:

            # if we are managing a AuiFloatingFrame window, then
            # we are an embedded AuiManager inside the AuiFloatingFrame.
            # We want to initiate a toolbar drag in our owner manager
            if isinstance(part.pane.window.GetParent(), AuiFloatingFrame):
                rootManager = GetManager(part.pane.window)
            else:
                rootManager = self

            offset = wx.Point(event.GetX() - part.rect.x, event.GetY() - part.rect.y)
            rootManager.OnGripperClicked(part.pane.window, event.GetPosition(), offset)

        if wx.Platform != "__WXMAC__":
            event.Skip()


    def OnLeftDClick(self, event):
        """
        Handles the ``wx.EVT_LEFT_DCLICK`` event for :class:`AuiManager`.

        :param `event`: a :class:`MouseEvent` to be processed.
        """

        part = self.HitTest(event.GetX(), event.GetY())

        if part and part.type == AuiDockUIPart.typeCaption:
            if isinstance(part.pane.window.GetParent(), AuiFloatingFrame):
                rootManager = GetManager(part.pane.window)
            else:
                rootManager = self

            rootManager.OnCaptionDoubleClicked(part.pane.window)

        elif part and part.type in [AuiDockUIPart.typeDockSizer, AuiDockUIPart.typePaneSizer]:
            # Handles double click on AuiNotebook sashes to unsplit
            sash_size = self._art.GetMetric(AUI_DOCKART_SASH_SIZE)
            for child in part.cont_sizer.GetChildren():
                if child.IsSizer():
                    win = child.GetSizer().GetContainingWindow()
                    if isinstance(win, auibook.AuiNotebook):
                        win.UnsplitDClick(part, sash_size, event.GetPosition())
                        break

        event.Skip()


    def DoEndResizeAction(self, event):
        """
        Ends a resize action, or for live update, resizes the sash.

        :param `event`: a :class:`MouseEvent` to be processed.
        """

        clientPt = event.GetPosition()
        screenPt = self._frame.ClientToScreen(clientPt)

        return self.RestrictResize(clientPt, screenPt, createDC=False)


    def RestrictResize(self, clientPt, screenPt, createDC):
        """ Common method between :meth:`DoEndResizeAction` and :meth:`OnLeftUp_Resize`. """

        dock = self._action_part.dock
        pane = self._action_part.pane

        if createDC:
            if wx.Platform == "__WXMAC__":
                dc = wx.ClientDC(self._frame)
            else:
                dc = wx.ScreenDC()

            DrawResizeHint(dc, self._action_rect)
            self._action_rect = wx.Rect()

        newPos = clientPt - self._action_offset

        if self._action_part.type == AuiDockUIPart.typeDockSizer:
            minPix, maxPix = self.CalculateDockSizerLimits(dock)
        else:
            if not self._action_part.pane:
                return
            minPix, maxPix = self.CalculatePaneSizerLimits(dock, pane)

        if self._action_part.orientation == wx.HORIZONTAL:
            newPos.y = Clip(newPos.y, minPix, maxPix)
        else:
            newPos.x = Clip(newPos.x, minPix, maxPix)

        if self._action_part.type == AuiDockUIPart.typeDockSizer:

            partnerDock = self.GetPartnerDock(dock)
            sash_size = self._art.GetMetric(AUI_DOCKART_SASH_SIZE)
            new_dock_size = 0
            direction = dock.dock_direction

            if direction == AUI_DOCK_LEFT:
                new_dock_size = newPos.x - dock.rect.x

            elif direction == AUI_DOCK_TOP:
                new_dock_size = newPos.y - dock.rect.y

            elif direction == AUI_DOCK_RIGHT:
                new_dock_size = dock.rect.x + dock.rect.width - newPos.x - sash_size

            elif direction == AUI_DOCK_BOTTOM:
                new_dock_size = dock.rect.y + dock.rect.height - newPos.y - sash_size

            deltaDockSize = new_dock_size - dock.size

            if partnerDock:
                if deltaDockSize > partnerDock.size - sash_size:
                    deltaDockSize = partnerDock.size - sash_size

                partnerDock.size -= deltaDockSize

            dock.size += deltaDockSize
            self.Update()

        else:

            # determine the new pixel size that the user wants
            # this will help us recalculate the pane's proportion
            if dock.IsHorizontal():
                oldPixsize = pane.rect.width
                newPixsize = oldPixsize + newPos.x - self._action_part.rect.x

            else:
                oldPixsize = pane.rect.height
                newPixsize = oldPixsize + newPos.y - self._action_part.rect.y

            totalPixsize, totalProportion = self.GetTotalPixSizeAndProportion(dock)
            partnerPane = self.GetPartnerPane(dock, pane)

            # prevent division by zero
            if totalPixsize <= 0 or totalProportion <= 0 or not partnerPane:
                return

            # adjust for the surplus
            while (oldPixsize > 0 and totalPixsize > 10 and \
                  oldPixsize*totalProportion/totalPixsize < pane.dock_proportion):

                totalPixsize -= 1

            # calculate the new proportion of the pane

            newProportion = newPixsize*totalProportion/totalPixsize
            newProportion = Clip(newProportion, 1, totalProportion)
            deltaProp = newProportion - pane.dock_proportion

            if partnerPane.dock_proportion - deltaProp < 1:
                deltaProp = partnerPane.dock_proportion - 1
                newProportion = pane.dock_proportion + deltaProp

            # borrow the space from our neighbor pane to the
            # right or bottom (depending on orientation)
            partnerPane.dock_proportion -= deltaProp
            pane.dock_proportion = newProportion

            self.Update()

        return True


    def OnLeftUp(self, event):
        """
        Handles the ``wx.EVT_LEFT_UP`` event for :class:`AuiManager`.

        :param `event`: a :class:`MouseEvent` to be processed.
        """

        if self._action == actionResize:
##            self._frame.Freeze()
            self.OnLeftUp_Resize(event)
##            self._frame.Thaw()

        elif self._action == actionClickButton:
            self.OnLeftUp_ClickButton(event)

        elif self._action == actionDragFloatingPane:
            self.OnLeftUp_DragFloatingPane(event)

        elif self._action == actionDragToolbarPane:
            self.OnLeftUp_DragToolbarPane(event)

        elif self._action == actionDragMovablePane:
            self.OnLeftUp_DragMovablePane(event)

        else:
            event.Skip()

        try:
            if self._frame.HasCapture():
                self._frame.ReleaseMouse()
        except wx.PyDeadObjectError:
            pass

        self._action = actionNone


    def OnMotion(self, event):
        """
        Handles the ``wx.EVT_MOTION`` event for :class:`AuiManager`.

        :param `event`: a :class:`MouseEvent` to be processed.
        """

        if self._action == actionResize:
            self.OnMotion_Resize(event)

        elif self._action == actionClickCaption:
            self.OnMotion_ClickCaption(event)

        elif self._action == actionDragFloatingPane:
            self.OnMotion_DragFloatingPane(event)

        elif self._action == actionDragToolbarPane:
            self.OnMotion_DragToolbarPane(event)

        elif self._action == actionDragMovablePane:
            self.OnMotion_DragMovablePane(event)

        else:
            self.OnMotion_Other(event)


    def OnLeaveWindow(self, event):
        """
        Handles the ``wx.EVT_LEAVE_WINDOW`` event for :class:`AuiManager`.

        :param `event`: a :class:`MouseEvent` to be processed.
        """

        if self._hover_button:
            self.RefreshButton(self._hover_button)
            self._hover_button = None


    def OnCaptureLost(self, event):
        """
        Handles the ``wx.EVT_MOUSE_CAPTURE_LOST`` event for :class:`AuiManager`.

        :param `event`: a :class:`MouseCaptureLostEvent` to be processed.
        """

        # cancel the operation in progress, if any
        if self._action != actionNone:
            self._action = actionNone
            self.HideHint()


    def OnHintFadeTimer(self, event):
        """
        Handles the ``wx.EVT_TIMER`` event for :class:`AuiManager`.

        :param `event`: a :class:`TimerEvent` to be processed.
        """

        if not self._hint_window or self._hint_fadeamt >= self._hint_fademax:
            self._hint_fadetimer.Stop()
            return

        self._hint_fadeamt += 4
        self._hint_window.SetTransparent(self._hint_fadeamt)


    def OnMove(self, event):
        """
        Handles the ``wx.EVT_MOVE`` event for :class:`AuiManager`.

        :param `event`: a :class:`MoveEvent` to be processed.
        """

        if event is not None:
            event.Skip()

        if isinstance(self._frame, AuiFloatingFrame) and self._frame.IsShownOnScreen():
            return

        docked, hAlign, vAlign, monitor = self._is_docked
        if docked:
            self.Snap()

        for pane in self._panes:
            if pane.IsSnappable():
                if pane.IsFloating() and pane.IsShown():
                    self.SnapPane(pane, pane.floating_pos, pane.floating_size, True)


    def OnSysColourChanged(self, event):
        """
        Handles the ``wx.EVT_SYS_COLOUR_CHANGED`` event for :class:`AuiManager`.

        :param `event`: a :class:`SysColourChangedEvent` to be processed.
        """

        # This event is probably triggered by a theme change
        # so we have to re-init the art provider.
        if self._art:
            self._art.Init()

        if self._frame:
            self.Update()
            self._frame.Refresh()


    def OnChildFocus(self, event):
        """
        Handles the ``wx.EVT_CHILD_FOCUS`` event for :class:`AuiManager`.

        :param `event`: a :class:`ChildFocusEvent` to be processed.
        """

        # when a child pane has it's focus set, we should change the
        # pane's active state to reflect this. (this is only true if
        # active panes are allowed by the owner)

        window = event.GetWindow()
        if isinstance(window, wx.Dialog):
            # Ignore EVT_CHILD_FOCUS events originating from dialogs not
            # managed by AUI
            rootManager = None
        elif isinstance(window.GetParent(), AuiFloatingFrame):
            rootManager = GetManager(window)
        else:
            rootManager = self

        if rootManager:
            rootManager.ActivatePane(window)

        event.Skip()


    def OnMotion_ClickCaption(self, event):
        """
        Sub-handler for the :meth:`OnMotion` event.

        :param `event`: a :class:`MouseEvent` to be processed.
        """

        clientPt = event.GetPosition()
        screenPt = self._frame.ClientToScreen(clientPt)

        drag_x_threshold = wx.SystemSettings.GetMetric(wx.SYS_DRAG_X)
        drag_y_threshold = wx.SystemSettings.GetMetric(wx.SYS_DRAG_Y)

        if not self._action_pane:
            return

        # we need to check if the mouse is now being dragged
        if not (abs(clientPt.x - self._action_start.x) > drag_x_threshold or \
                abs(clientPt.y - self._action_start.y) > drag_y_threshold):

            return

        # dragged -- we need to change the mouse action to 'drag'
        if self._action_pane.IsToolbar():
            self._action = actionDragToolbarPane
            self._action_window = self._action_pane.window

        elif self._action_pane.IsFloatable() and self._agwFlags & AUI_MGR_ALLOW_FLOATING:

            e = self.FireEvent(wxEVT_AUI_PANE_FLOATING, self._action_pane, canVeto=True)
            if e.GetVeto():
                return

            self._action = actionDragFloatingPane

            # set initial float position
            self._action_pane.floating_pos = screenPt - self._action_offset

            # float the window
            if self._action_pane.IsMaximized():
                self.RestorePane(self._action_pane)

            self._action_pane.Hide()
            self._action_pane.Float()
            if wx.Platform == "__WXGTK__":
                self._action_pane.Show()

            e = self.FireEvent(wxEVT_AUI_PANE_FLOATED, self._action_pane, canVeto=False)

            if not self._action_pane.frame:
                self.Update()

            self._action_window = self._action_pane.window

            # adjust action offset for window frame
            windowPt = self._action_pane.frame.GetRect().GetTopLeft()
            originPt = self._action_pane.frame.ClientToScreen(wx.Point())
            self._toolbar_action_offset = originPt - windowPt

            if self._agwFlags & AUI_MGR_USE_NATIVE_MINIFRAMES:
                originPt = windowPt + wx.Point(3, 3)

            self._action_offset += originPt - windowPt

            # action offset is used here to make it feel "natural" to the user
            # to drag a docked pane and suddenly have it become a floating frame.
            # Sometimes, however, the offset where the user clicked on the docked
            # caption is bigger than the width of the floating frame itself, so
            # in that case we need to set the action offset to a sensible value
            frame_size = self._action_pane.frame.GetSize()
            if self._action_offset.x > frame_size.x * 2 / 3:
                self._action_offset.x = frame_size.x / 2
            if self._action_offset.y > frame_size.y * 2 / 3:
                self._action_offset.y = frame_size.y / 2

            self.OnMotion_DragFloatingPane(event)
            if wx.Platform != "__WXGTK__":
                self._action_pane.Show()

            self.Update()

        elif self._action_pane.IsMovable():
            self._action = actionDragMovablePane
            self._action_window = self._action_pane.window


    def OnMotion_Resize(self, event):
        """
        Sub-handler for the :meth:`OnMotion` event.

        :param `event`: a :class:`MouseEvent` to be processed.
        """

        if AuiManager_HasLiveResize(self):
            if self._currentDragItem != -1:
                self._action_part = self._uiparts[self._currentDragItem]
            else:
                self._currentDragItem = self._uiparts.index(self._action_part)

            if self._frame.HasCapture():
                self._frame.ReleaseMouse()

            self.DoEndResizeAction(event)
            self._frame.CaptureMouse()
            return

        if not self._action_part or not self._action_part.dock or not self._action_part.orientation:
            return

        clientPt = event.GetPosition()
        screenPt = self._frame.ClientToScreen(clientPt)

        dock = self._action_part.dock
        pos = self._action_part.rect.GetPosition()

        if self._action_part.type == AuiDockUIPart.typeDockSizer:
            minPix, maxPix = self.CalculateDockSizerLimits(dock)
        else:
            if not self._action_part.pane:
                return

            pane = self._action_part.pane
            minPix, maxPix = self.CalculatePaneSizerLimits(dock, pane)

        if self._action_part.orientation == wx.HORIZONTAL:
            pos.y = Clip(clientPt.y - self._action_offset.y, minPix, maxPix)
        else:
            pos.x = Clip(clientPt.x - self._action_offset.x, minPix, maxPix)

        hintrect = wx.RectPS(self._frame.ClientToScreen(pos), self._action_part.rect.GetSize())

        if hintrect != self._action_rect:

            if wx.Platform == "__WXMAC__":
                dc = wx.ClientDC(self._frame)
            else:
                dc = wx.ScreenDC()

            DrawResizeHint(dc, self._action_rect)
            DrawResizeHint(dc, hintrect)
            self._action_rect = wx.Rect(*hintrect)


    def OnLeftUp_Resize(self, event):
        """
        Sub-handler for the :meth:`OnLeftUp` event.

        :param `event`: a :class:`MouseEvent` to be processed.
        """

        if self._currentDragItem != -1 and AuiManager_HasLiveResize(self):
            self._action_part = self._uiparts[self._currentDragItem]

            if self._frame.HasCapture():
                self._frame.ReleaseMouse()

            self.DoEndResizeAction(event)
            self._currentDragItem = -1
            return

        if not self._action_part or not self._action_part.dock:
            return

        clientPt = event.GetPosition()
        screenPt = self._frame.ClientToScreen(clientPt)

        return self.RestrictResize(clientPt, screenPt, createDC=True)


    def OnLeftUp_ClickButton(self, event):
        """
        Sub-handler for the :meth:`OnLeftUp` event.

        :param `event`: a :class:`MouseEvent` to be processed.
        """

        self._hover_button = None

        if self._action_part:
            self.RefreshButton(self._action_part)

            # make sure we're still over the item that was originally clicked
            if self._action_part == self.HitTest(*event.GetPosition()):

                # fire button-click event
                e = AuiManagerEvent(wxEVT_AUI_PANE_BUTTON)
                e.SetManager(self)
                e.SetPane(self._action_part.pane)
                e.SetButton(self._action_part.button.button_id)
                self.ProcessMgrEvent(e)


    def CheckPaneMove(self, pane):
        """
        Checks if a pane has moved by a visible amount.

        :param `pane`: an instance of :class:`AuiPaneInfo`.
        """

        win_rect = pane.frame.GetRect()
        win_rect.x, win_rect.y = pane.floating_pos

        if win_rect == self._last_rect:
            return False

        # skip the first move event
        if self._last_rect.IsEmpty():
            self._last_rect = wx.Rect(*win_rect)
            return False

        # skip if moving too fast to avoid massive redraws and
        # jumping hint windows
        if abs(win_rect.x - self._last_rect.x) > 10 or \
           abs(win_rect.y - self._last_rect.y) > 10:
            self._last_rect = wx.Rect(*win_rect)
            return False

        return True


    def OnMotion_DragFloatingPane(self, eventOrPt):
        """
        Sub-handler for the :meth:`OnMotion` event.

        :param `event`: a :class:`MouseEvent` to be processed.
        """

        isPoint = False
        if isinstance(eventOrPt, wx.Point):
            clientPt = self._frame.ScreenToClient(eventOrPt)
            screenPt = wx.Point(*eventOrPt)
            isPoint = True
        else:
            clientPt = eventOrPt.GetPosition()
            screenPt = self._frame.ClientToScreen(clientPt)

        framePos = wx.Point()

        # try to find the pane
        pane = self.GetPane(self._action_window)
        if not pane.IsOk():
            raise Exception("Pane window not found")

        # update floating position
        if pane.IsFloating():
            diff = pane.floating_pos - (screenPt - self._action_offset)
            pane.floating_pos = screenPt - self._action_offset

        framePos = pane.floating_pos

        # Move the pane window
        if pane.frame:

            if diff.x != 0 or diff.y != 0:
                if wx.Platform == "__WXMSW__" and (self._agwFlags & AUI_MGR_TRANSPARENT_DRAG) == 0: # and not self.CheckPaneMove(pane):
                    # return
                    # HACK: Terrible hack on wxMSW (!)
                    pane.frame.SetTransparent(254)

                self._from_move = True
                pane.frame.Move(pane.floating_pos)
                self._from_move = False

            if self._agwFlags & AUI_MGR_TRANSPARENT_DRAG:
                pane.frame.SetTransparent(150)

        # calculate the offset from the upper left-hand corner
        # of the frame to the mouse pointer
        action_offset = screenPt - framePos

        # is the pane dockable?
        if not self.CanDockPanel(pane):
            self.HideHint()
            ShowDockingGuides(self._guides, False)
            return

        for paneInfo in self._panes:

            if not paneInfo.IsDocked() or not paneInfo.IsShown():
                continue
            if paneInfo.IsToolbar() or paneInfo.IsNotebookControl():
                continue
            if paneInfo.IsMaximized():
                continue

            if paneInfo.IsNotebookPage():

                notebookRoot = GetNotebookRoot(self._panes, paneInfo.notebook_id)

                if not notebookRoot or not notebookRoot.IsDocked():
                    continue

            rc = paneInfo.window.GetScreenRect()
            if rc.Contains(screenPt):
                if rc.height < 20 or rc.width < 20:
                    return

                self.UpdateDockingGuides(paneInfo)
                ShowDockingGuides(self._guides, True)
                break

        self.DrawHintRect(pane.window, clientPt, action_offset)


    def OnMotion_DragMovablePane(self, eventOrPt):
        """
        Sub-handler for the :meth:`OnMotion` event.

        :param `event`: a :class:`MouseEvent` to be processed.
        """

        # Try to find the pane.
        pane = self.GetPane(self._action_window)
        if not pane.IsOk():
            raise Exception("Pane window not found")

        # Draw a hint for where the window will be moved.
        if isinstance(eventOrPt, wx.Point):
            pt = wx.Point(*eventOrPt)
        else:
            pt = eventOrPt.GetPosition()

        self.DrawHintRect(self._action_window, pt, wx.Point(0, 0))

        # Reduces flicker.
        self._frame.Update()


    def OnLeftUp_DragFloatingPane(self, eventOrPt):
        """
        Sub-handler for the :meth:`OnLeftUp` event.

        :param `event`: a :class:`MouseEvent` to be processed.
        """

        if isinstance(eventOrPt, wx.Point):
            clientPt = self._frame.ScreenToClient(eventOrPt)
            screenPt = wx.Point(*eventOrPt)
        else:
            clientPt = eventOrPt.GetPosition()
            screenPt = self._frame.ClientToScreen(clientPt)

        # try to find the pane
        paneInfo = self.GetPane(self._action_window)
        if not paneInfo.IsOk():
            raise Exception("Pane window not found")

        ret = False

        if paneInfo.frame:

            # calculate the offset from the upper left-hand corner
            # of the frame to the mouse pointer
            framePos = paneInfo.frame.GetPosition()
            action_offset = screenPt - framePos

            # is the pane dockable?
            if self.CanDockPanel(paneInfo):
                # do the drop calculation
                indx = self._panes.index(paneInfo)
                ret, paneInfo = self.DoDrop(self._docks, self._panes, paneInfo, clientPt, action_offset)

                if ret:
                    e = self.FireEvent(wxEVT_AUI_PANE_DOCKING, paneInfo, canVeto=True)
                    if e.GetVeto():
                        self.HideHint()
                        ShowDockingGuides(self._guides, False)
                        return

                    e = self.FireEvent(wxEVT_AUI_PANE_DOCKED, paneInfo, canVeto=False)

                    if self._agwFlags & AUI_MGR_SMOOTH_DOCKING:
                        self.SmoothDock(paneInfo)

                self._panes[indx] = paneInfo

        # if the pane is still floating, update it's floating
        # position (that we store)
        if paneInfo.IsFloating():
            paneInfo.floating_pos = paneInfo.frame.GetPosition()
            if paneInfo.frame._transparent != paneInfo.transparent or self._agwFlags & AUI_MGR_TRANSPARENT_DRAG:
                paneInfo.frame.SetTransparent(paneInfo.transparent)
                paneInfo.frame._transparent = paneInfo.transparent

        elif self._has_maximized:
            self.RestoreMaximizedPane()

        # reorder for dropping to a new notebook
        # (caution: this code breaks the reference!)
        tempPaneInfo = self.CopyTarget(paneInfo)
        self._panes.remove(paneInfo)
        self._panes.append(tempPaneInfo)

        if ret:
            self.Update()

        if tempPaneInfo.IsFloating():
            self.SnapPane(tempPaneInfo, tempPaneInfo.floating_pos, tempPaneInfo.floating_size, False)

        self.HideHint()
        ShowDockingGuides(self._guides, False)


    def OnLeftUp_DragMovablePane(self, event):
        """
        Sub-handler for the :meth:`OnLeftUp` event.

        :param `event`: a :class:`MouseEvent` to be processed.
        """

        # Try to find the pane.
        paneInfo = self.GetPane(self._action_window)
        if not paneInfo.IsOk():
            raise Exception("Pane window not found")

        # Hide the hint as it is no longer needed.
        self.HideHint()

        # is the pane dockable?
        if self.CanDockPanel(paneInfo):
            # Move the pane to new position.
            pt = event.GetPosition()
            # do the drop calculation
            indx = self._panes.index(paneInfo)
            ret, paneInfo = self.DoDrop(self._docks, self._panes, paneInfo, pt, wx.Point(0,0))

            if ret:
                e = self.FireEvent(wxEVT_AUI_PANE_DOCKING, paneInfo, canVeto=True)
                if e.GetVeto():
                    self.HideHint()
                    ShowDockingGuides(self._guides, False)
                    return

                e = self.FireEvent(wxEVT_AUI_PANE_DOCKED, paneInfo, canVeto=False)

                if self._agwFlags & AUI_MGR_SMOOTH_DOCKING:
                    self.SmoothDock(paneInfo)

            self._panes[indx] = paneInfo

            if ret:
                # Update the layout to realize new position and e.g. form notebooks if needed.
                self.Update()

        if self.GetAGWFlags() & AUI_MGR_ALLOW_ACTIVE_PANE:
            # Ensure active before doing actual display.
            ret, self._panes = SetActivePane(self._panes, paneInfo.window)

        # Make changes visible to user.
        self.Repaint()

        # Cancel the action and release the mouse.
        self._action = actionNone
        self._frame.ReleaseMouse()
        self._action_window = None


    def OnMotion_DragToolbarPane(self, eventOrPt):
        """
        Sub-handler for the :meth:`OnMotion` event.

        :param `event`: a :class:`MouseEvent` to be processed.
        """

        isPoint = False
        if isinstance(eventOrPt, wx.Point):
            clientPt = self._frame.ScreenToClient(eventOrPt)
            screenPt = wx.Point(*eventOrPt)
            isPoint = True
        else:
            clientPt = eventOrPt.GetPosition()
            screenPt = self._frame.ClientToScreen(clientPt)

        pane = self.GetPane(self._action_window)
        if not pane.IsOk():
            raise Exception("Pane window not found")

        pane.state |= AuiPaneInfo.actionPane
        indx = self._panes.index(pane)

        ret = False
        wasFloating = pane.IsFloating()
        # is the pane dockable?
        if self.CanDockPanel(pane):
            # do the drop calculation
            ret, pane = self.DoDrop(self._docks, self._panes, pane, clientPt, self._action_offset)

        # update floating position
        if pane.IsFloating():
            pane.floating_pos = screenPt - self._toolbar_action_offset

        # move the pane window
        if pane.frame:
            if wx.Platform == "__WXMSW__" and (self._agwFlags & AUI_MGR_TRANSPARENT_DRAG) == 0: # and not self.CheckPaneMove(pane):
                # return
                # HACK: Terrible hack on wxMSW (!)
                pane.frame.SetTransparent(254)

            self._from_move = True
            pane.frame.Move(pane.floating_pos)
            self._from_move = False

            if self._agwFlags & AUI_MGR_TRANSPARENT_DRAG:
                pane.frame.SetTransparent(150)

        self._panes[indx] = pane
        if ret and wasFloating != pane.IsFloating() or (ret and not wasFloating):
            wx.CallAfter(self.Update)

        # when release the button out of the window.
        # TODO: a better fix is needed.

        if _VERSION_STRING < "2.9":
            leftDown = wx.GetMouseState().LeftDown()
        else:
            leftDown = wx.GetMouseState().LeftIsDown()

        if not leftDown:
            self._action = actionNone
            self.OnLeftUp_DragToolbarPane(eventOrPt)


    def OnMotion_Other(self, event):
        """
        Sub-handler for the :meth:`OnMotion` event.

        :param `event`: a :class:`MouseEvent` to be processed.
        """

        part = self.HitTest(*event.GetPosition())

        if part and part.type == AuiDockUIPart.typePaneButton \
           and self.IsPaneButtonVisible(part):
            if part != self._hover_button:

                if self._hover_button:
                    self.RefreshButton(self._hover_button)

                self._hover_button = part
                self.RefreshButton(part)

        else:

            if self._hover_button:
                self.RefreshButton(self._hover_button)
            else:
                event.Skip()

            self._hover_button = None


    def OnLeftUp_DragToolbarPane(self, eventOrPt):
        """
        Sub-handler for the :meth:`OnLeftUp` event.

        :param `event`: a :class:`MouseEvent` to be processed.
        """

        isPoint = False
        if isinstance(eventOrPt, wx.Point):
            clientPt = self._frame.ScreenToClient(eventOrPt)
            screenPt = wx.Point(*eventOrPt)
            isPoint = True
        else:
            clientPt = eventOrPt.GetPosition()
            screenPt = self._frame.ClientToScreen(clientPt)

        # try to find the pane
        pane = self.GetPane(self._action_window)
        if not pane.IsOk():
            raise Exception("Pane window not found")

        if pane.IsFloating():
            pane.floating_pos = pane.frame.GetPosition()
            if pane.frame._transparent != pane.transparent or self._agwFlags & AUI_MGR_TRANSPARENT_DRAG:
                pane.frame.SetTransparent(pane.transparent)
                pane.frame._transparent = pane.transparent

        # save the new positions
        docks = FindDocks(self._docks, pane.dock_direction, pane.dock_layer, pane.dock_row)
        if len(docks) == 1:
            dock = docks[0]
            pane_positions, pane_sizes = self.GetPanePositionsAndSizes(dock)

            for i in xrange(len(dock.panes)):
                dock.panes[i].dock_pos = pane_positions[i]

        pane.state &= ~AuiPaneInfo.actionPane
        self.Update()


    def OnPaneButton(self, event):
        """
        Handles the ``EVT_AUI_PANE_BUTTON`` event for :class:`AuiManager`.

        :param `event`: a :class:`AuiManagerEvent` event to be processed.
        """

        if not event.pane:
            raise Exception("Pane Info passed to AuiManager.OnPaneButton must be non-null")

        pane = event.pane

        if event.button == AUI_BUTTON_CLOSE:

            if isinstance(pane.window.GetParent(), AuiFloatingFrame):
                rootManager = GetManager(pane.window)
            else:
                rootManager = self

            if rootManager != self:
                self._frame.Close()
                return

            # fire pane close event
            e = AuiManagerEvent(wxEVT_AUI_PANE_CLOSE)
            e.SetManager(self)
            e.SetPane(event.pane)
            self.ProcessMgrEvent(e)

            if not e.GetVeto():

                # close the pane, but check that it
                # still exists in our pane array first
                # (the event handler above might have removed it)
                check = self.GetPane(pane.window)
                if check.IsOk():
                    # Use the checked pane, because the ui part which 
                    # emitted this event may actually have a pane that's 
                    # different from the panes in self._panes. This seems
                    # to be a fairly endemic problem with this framework.
                    self.ClosePane(check)

                self.Update()

        # mn this performs the minimizing of a pane
        elif event.button == AUI_BUTTON_MINIMIZE:
            e = AuiManagerEvent(wxEVT_AUI_PANE_MINIMIZE)
            e.SetManager(self)
            e.SetPane(event.pane)
            self.ProcessMgrEvent(e)

            if not e.GetVeto():
                self.MinimizePane(pane)

        elif event.button == AUI_BUTTON_MAXIMIZE_RESTORE and not pane.IsMaximized():

            # fire pane close event
            e = AuiManagerEvent(wxEVT_AUI_PANE_MAXIMIZE)
            e.SetManager(self)
            e.SetPane(event.pane)
            self.ProcessMgrEvent(e)

            if not e.GetVeto():

                self.MaximizePane(pane)
                self.Update()

        elif event.button == AUI_BUTTON_MAXIMIZE_RESTORE and pane.IsMaximized():

            # fire pane close event
            e = AuiManagerEvent(wxEVT_AUI_PANE_RESTORE)
            e.SetManager(self)
            e.SetPane(event.pane)
            self.ProcessMgrEvent(e)

            if not e.GetVeto():

                self.RestorePane(pane)
                self.Update()

        elif event.button == AUI_BUTTON_PIN:

            if self._agwFlags & AUI_MGR_ALLOW_FLOATING and pane.IsFloatable():
                e = self.FireEvent(wxEVT_AUI_PANE_FLOATING, pane, canVeto=True)
                if e.GetVeto():
                    return

                pane.Float()
                e = self.FireEvent(wxEVT_AUI_PANE_FLOATED, pane, canVeto=False)

            self.Update()


    def MinimizePane(self, paneInfo, mgrUpdate=True):
        """
        Minimizes a pane in a newly and automatically created :class:`~lib.agw.aui.auibar.AuiToolBar`.

        Clicking on the minimize button causes a new :class:`~lib.agw.aui.auibar.AuiToolBar` to be created
        and added to the frame manager (currently the implementation is such that
        panes at West will have a toolbar at the right, panes at South will have
        toolbars at the bottom etc...) and the pane is hidden in the manager.

        Clicking on the restore button on the newly created toolbar will result in the
        toolbar being removed and the original pane being restored.

        :param `paneInfo`: a :class:`AuiPaneInfo` instance for the pane to be minimized;
        :param bool `mgrUpdate`: ``True`` to call :meth:`Update` to realize the new layout,
         ``False`` otherwise.

        .. note::

           The `mgrUpdate` parameter is currently only used while loading perspectives using
           :meth:`LoadPerspective`, as minimized panes were not correctly taken into account before.

        """

        if not paneInfo.IsToolbar():

            if paneInfo.IsMinimized() and mgrUpdate:
                # We are already minimized
                return

            # Basically the idea is this.
            #
            # 1) create a toolbar, with a restore button
            #
            # 2) place the new toolbar in the toolbar area representative of the location of the pane
            #  (NORTH/SOUTH/EAST/WEST, central area always to the right)
            #
            # 3) Hide the minimizing pane

            # personalize the toolbar style

            tbStyle = AUI_TB_DEFAULT_STYLE
            posMask = paneInfo.minimize_mode & AUI_MINIMIZE_POS_MASK
            captMask = paneInfo.minimize_mode & AUI_MINIMIZE_CAPT_MASK
            dockDirection = paneInfo.dock_direction
            if captMask != 0:
                tbStyle |= AUI_TB_TEXT

            if posMask == AUI_MINIMIZE_POS_TOOLBAR:
                minimize_toolbar = self.GetPane(paneInfo.minimize_target)
                if not minimize_toolbar.IsOk():
                    posMask = AUI_MINIMIZE_POS_SMART
                    if paneInfo.dock_direction in [AUI_DOCK_TOP, AUI_DOCK_BOTTOM]:
                        tbStyle |= AUI_TB_HORZ_LAYOUT

                    elif paneInfo.dock_direction in [AUI_DOCK_LEFT, AUI_DOCK_RIGHT, AUI_DOCK_CENTER]:
                        tbStyle |= AUI_TB_VERTICAL
                        if captMask == AUI_MINIMIZE_CAPT_SMART:
                            tbStyle |= AUI_TB_CLOCKWISE
                else:
                    minimize_toolbar = minimize_toolbar.window

            elif posMask == AUI_MINIMIZE_POS_SMART:
                if paneInfo.dock_direction in [AUI_DOCK_TOP, AUI_DOCK_BOTTOM]:
                    tbStyle |= AUI_TB_HORZ_LAYOUT

                elif paneInfo.dock_direction in [AUI_DOCK_LEFT, AUI_DOCK_RIGHT, AUI_DOCK_CENTER]:
                    tbStyle |= AUI_TB_VERTICAL
                    if captMask == AUI_MINIMIZE_CAPT_SMART:
                        tbStyle |= AUI_TB_CLOCKWISE

            elif posMask in [AUI_MINIMIZE_POS_TOP, AUI_MINIMIZE_POS_BOTTOM]:
                tbStyle |= AUI_TB_HORZ_LAYOUT
                if posMask == AUI_MINIMIZE_POS_TOP:
                    dockDirection = AUI_DOCK_TOP
                else:
                    dockDirection = AUI_DOCK_BOTTOM

            else:
                tbStyle |= AUI_TB_VERTICAL
                if captMask == AUI_MINIMIZE_CAPT_SMART:
                    tbStyle |= AUI_TB_CLOCKWISE
                if posMask == AUI_MINIMIZE_POS_LEFT:
                    dockDirection = AUI_DOCK_LEFT
                elif posMask == AUI_MINIMIZE_POS_RIGHT:
                    dockDirection = AUI_DOCK_RIGHT
                elif posMask == AUI_MINIMIZE_POS_BOTTOM:
                    dockDirection = AUI_DOCK_BOTTOM

            # Create a new toolbar
            # give it the same name as the minimized pane with _min appended

            win_rect = paneInfo.window.GetScreenRect()

            if posMask != AUI_MINIMIZE_POS_TOOLBAR:
                minimize_toolbar = auibar.AuiToolBar(self.GetManagedWindow(), agwStyle=tbStyle)
                minimize_toolbar.Hide()
                minimize_toolbar.SetToolBitmapSize(wx.Size(16, 16))

            if paneInfo.icon and paneInfo.icon.IsOk():
                restore_bitmap = paneInfo.icon
            else:
                restore_bitmap = self._art._restore_bitmap

            if posMask == AUI_MINIMIZE_POS_TOOLBAR:
                xsize, ysize = minimize_toolbar.GetToolBitmapSize()
                if xsize != restore_bitmap.GetWidth():
                    img = restore_bitmap.ConvertToImage()
                    img.Rescale(xsize, ysize, wx.IMAGE_QUALITY_HIGH)
                    restore_bitmap = img.ConvertToBitmap()

            target = None
            if posMask == AUI_MINIMIZE_POS_TOOLBAR:
                target = paneInfo.name

            minimize_toolbar.AddSimpleTool(ID_RESTORE_FRAME, paneInfo.caption, restore_bitmap,
                                           _(u"Restore %s")%paneInfo.caption, target=target)
            minimize_toolbar.SetAuiManager(self)
            minimize_toolbar.Realize()
            toolpanelname = paneInfo.name + "_min"

            if paneInfo.IsMaximized():
                paneInfo.SetFlag(paneInfo.wasMaximized, True)

            if posMask != AUI_MINIMIZE_POS_TOOLBAR:

                if dockDirection == AUI_DOCK_TOP:
                    self.AddPane(minimize_toolbar, AuiPaneInfo(). \
                        Name(toolpanelname).Caption(paneInfo.caption). \
                        ToolbarPane().Top().BottomDockable(False). \
                        LeftDockable(False).RightDockable(False).DestroyOnClose())

                elif dockDirection == AUI_DOCK_BOTTOM:
                    self.AddPane(minimize_toolbar, AuiPaneInfo(). \
                        Name(toolpanelname).Caption(paneInfo.caption). \
                        ToolbarPane().Bottom().TopDockable(False). \
                        LeftDockable(False).RightDockable(False).DestroyOnClose())

                elif dockDirection == AUI_DOCK_LEFT:
                    self.AddPane(minimize_toolbar, AuiPaneInfo(). \
                        Name(toolpanelname).Caption(paneInfo.caption). \
                        ToolbarPane().Left().TopDockable(False). \
                        BottomDockable(False).RightDockable(False).DestroyOnClose())

                elif dockDirection in [AUI_DOCK_RIGHT, AUI_DOCK_CENTER]:
                    self.AddPane(minimize_toolbar, AuiPaneInfo(). \
                        Name(toolpanelname).Caption(paneInfo.caption). \
                        ToolbarPane().Right().TopDockable(False). \
                        LeftDockable(False).BottomDockable(False).DestroyOnClose())

            arr = FindDocks(self._docks, paneInfo.dock_direction, paneInfo.dock_layer, paneInfo.dock_row)

            if arr:
                dock = arr[0]
                paneInfo.previousDockSize = dock.size

            paneInfo.previousDockPos = paneInfo.dock_pos

            # mark ourselves minimized
            paneInfo.Minimize()
            paneInfo.Show(False)
            self._has_minimized = True
            # last, hide the window
            if paneInfo.window and paneInfo.window.IsShown():
                paneInfo.window.Show(False)

            minimize_toolbar.Show()

            if mgrUpdate:
                self.Update()
                if self._agwFlags & AUI_MGR_ANIMATE_FRAMES:
                    self.AnimateDocking(win_rect, minimize_toolbar.GetScreenRect())


    def OnRestoreMinimizedPane(self, event):
        """
        Handles the ``EVT_AUI_PANE_MIN_RESTORE`` event for :class:`AuiManager`.

        :param `event`: an instance of :class:`AuiManagerEvent` to be processed.
        """

        self.RestoreMinimizedPane(event.pane)


    def OnPaneDocked(self, event):
        """
        Handles the ``EVT_AUI_PANE_DOCKED`` event for :class:`AuiManager`.

        :param `event`: an instance of :class:`AuiManagerEvent` to be processed.
        """

        event.Skip()
        self.RemoveAutoNBCaption(event.GetPane())


    def CreateNotebookBase(self, panes, paneInfo):
        """
        Creates an auto-notebook base from a pane, and then add that pane as a page.

        :param list `panes`: set of panes to append new notebook base pane to
        :param AuiPaneInfo `paneInfo`: the pane to be converted to a new notebook.
        """

        # Create base notebook pane ...
        nbid = len(self._notebooks)

        baseInfo = AuiPaneInfo()
        baseInfo.SetDockPos(paneInfo).NotebookControl(nbid). \
            CloseButton(False).SetNameFromNotebookId(). \
            NotebookDockable(False).Floatable(paneInfo.IsFloatable())
        baseInfo.best_size = paneInfo.best_size
        panes.append(baseInfo)

        # add original pane as tab ...
        paneInfo.NotebookPage(nbid)


    def RemoveAutoNBCaption(self, pane):
        """
        Removes the caption on newly created automatic notebooks.

        :param `pane`: an instance of :class:`AuiPaneInfo` (the target notebook).
        """

        if self._agwFlags & AUI_MGR_AUTONB_NO_CAPTION == 0:
            return False

        def RemoveCaption():
            """ Sub-function used to remove the pane caption on automatic notebooks. """

            if pane.HasNotebook():
                notebook = self._notebooks[pane.notebook_id]
                self.GetPane(notebook).CaptionVisible(False).PaneBorder(False)
                self.Update()

        # it seems the notebook isnt created by this stage, so remove
        # the caption a moment later
        wx.CallAfter(RemoveCaption)
        return True


    def RestoreMinimizedPane(self, paneInfo):
        """
        Restores a previously minimized pane.

        :param `paneInfo`: a :class:`AuiPaneInfo` instance for the pane to be restored.
        """

        panename = paneInfo.name

        if paneInfo.minimize_mode & AUI_MINIMIZE_POS_TOOLBAR:
            pane = self.GetPane(panename)
            hasTarget = True
        else:
            panename = panename[0:-4]
            hasTarget = False

        pane = self.GetPane(panename)
        pane.SetFlag(pane.needsRestore, True)

        if not pane.IsOk():
            panename = paneInfo.name
            pane = self.GetPane(panename)
            paneInfo = self.GetPane(panename + "_min")
            if not paneInfo.IsOk():
                # Already minimized
                return

        if pane.IsOk():
            if not pane.IsMinimized():
                return


            if pane.HasFlag(pane.wasMaximized):
                self.SavePreviousDockSizes(pane)

            self.ShowPane(pane.window, True)
            pane.Show(True)
            self._has_minimized = False
            pane.SetFlag(pane.optionMinimized, False)

            if hasTarget:
                targetName = pane.minimize_target
                toolbarPane = self.GetPane(targetName)
                toolbar = toolbarPane.window
                item = toolbar.FindToolByLabel(pane.caption)
                toolbar.DeleteTool(item.id)
            else:
                paneInfo.window.Show(False)
                self.DetachPane(paneInfo.window)
                paneInfo.Show(False)
                paneInfo.Hide()

            self.Update()


    def AnimateDocking(self, win_rect, pane_rect):
        """
        Animates the minimization/docking of a pane a la Eclipse, using a :class:`ScreenDC`
        to draw a "moving docking rectangle" on the screen.

        :param Rect `win_rect`: the original pane screen rectangle;
        :param Rect `pane_rect`: the newly created toolbar/pane screen rectangle.

        :note: This functionality is not available on wxMAC as this platform doesn't have
         the ability to use :class:`ScreenDC` to draw on-screen and on Windows > Vista.
        """

        if wx.Platform == "__WXMAC__":
            # No wx.ScreenDC on the Mac...
            return
        if wx.Platform == "__WXMSW__" and wx.GetOsVersion()[1] > 5:
            # No easy way to handle this on Vista...
            return

        xstart, ystart = win_rect.x, win_rect.y
        xend, yend = pane_rect.x, pane_rect.y

        step = self.GetAnimationStep()

        wstep = int(abs(win_rect.width - pane_rect.width)/step)
        hstep = int(abs(win_rect.height - pane_rect.height)/step)
        xstep = int(win_rect.x - pane_rect.x)/step
        ystep = int(win_rect.y - pane_rect.y)/step

        dc = wx.ScreenDC()
        dc.SetLogicalFunction(wx.INVERT)
        dc.SetBrush(wx.TRANSPARENT_BRUSH)
        dc.SetPen(wx.LIGHT_GREY_PEN)

        for i in xrange(int(step)):
            width, height = win_rect.width - i*wstep, win_rect.height - i*hstep
            x, y = xstart - i*xstep, ystart - i*ystep
            new_rect = wx.Rect(x, y, width, height)
            dc.DrawRoundedRectangleRect(new_rect, 3)
            wx.SafeYield()
            wx.MilliSleep(10)
            dc.DrawRoundedRectangleRect(new_rect, 3)


    def SmoothDock(self, paneInfo):
        """
        This method implements a smooth docking effect for floating panes, similar to
        what the PyQT library does with its floating windows.

        :param `paneInfo`: an instance of :class:`AuiPaneInfo`.

        :note: The smooth docking effect can only be used if you set the ``AUI_MGR_SMOOTH_DOCKING``
         style to :class:`AuiManager`.
        """

        if paneInfo.IsToolbar():
            return

        if not paneInfo.frame or self._hint_rect.IsEmpty():
            return

        hint_rect = self._hint_rect
        win_rect = paneInfo.frame.GetScreenRect()

        xstart, ystart = win_rect.x, win_rect.y
        xend, yend = hint_rect.x, hint_rect.y

        step = self.GetAnimationStep()/3

        wstep = int((win_rect.width - hint_rect.width)/step)
        hstep = int((win_rect.height - hint_rect.height)/step)
        xstep = int((win_rect.x - hint_rect.x))/step
        ystep = int((win_rect.y - hint_rect.y))/step

        for i in xrange(int(step)):
            width, height = win_rect.width - i*wstep, win_rect.height - i*hstep
            x, y = xstart - i*xstep, ystart - i*ystep
            new_rect = wx.Rect(x, y, width, height)
            paneInfo.frame.SetRect(new_rect)
            wx.MilliSleep(10)


    def SetSnapLimits(self, x, y):
        """
        Modifies the snap limits used when snapping the `managed_window` to the screen
        (using :meth:`SnapToScreen`) or when snapping the floating panes to one side of the
        `managed_window` (using :meth:`SnapPane`).

        To change the limit after which the `managed_window` or the floating panes are
        automatically stickled to the screen border (or to the `managed_window` side),
        set these two variables. Default values are 15 pixels.

        :param integer `x`: the minimum horizontal distance below which the snap occurs;
        :param integer `y`: the minimum vertical distance below which the snap occurs.
        """

        self._snap_limits = (x, y)
        self.Snap()


    def Snap(self):
        """
        Snaps the main frame to specified position on the screen.

        :see: :meth:`SnapToScreen`
        """

        snap, hAlign, vAlign, monitor = self._is_docked
        if not snap:
            return

        managed_window = self.GetManagedWindow()
        snap_pos = self.GetSnapPosition()
        wnd_pos = managed_window.GetPosition()
        snapX, snapY = self._snap_limits

        if abs(snap_pos.x - wnd_pos.x) < snapX and abs(snap_pos.y - wnd_pos.y) < snapY:
            managed_window.SetPosition(snap_pos)


    def SnapToScreen(self, snap=True, monitor=0, hAlign=wx.RIGHT, vAlign=wx.TOP):
        """
        Snaps the main frame to specified position on the screen.

        :param bool `snap`: whether to snap the main frame or not;
        :param integer `monitor`: the monitor display in which snapping the window;
        :param integer `hAlign`: the horizontal alignment of the snapping position;
        :param integer `vAlign`: the vertical alignment of the snapping position.
        """

        if not snap:
            self._is_docked = (False, wx.RIGHT, wx.TOP, 0)
            return

        displayCount = wx.Display.GetCount()
        if monitor > displayCount:
            raise Exception("Invalid monitor selected: you only have %d monitors"%displayCount)

        self._is_docked = (True, hAlign, vAlign, monitor)
        self.GetManagedWindow().SetPosition(self.GetSnapPosition())


    def GetSnapPosition(self):
        """ Returns the main frame snapping position. """

        snap, hAlign, vAlign, monitor = self._is_docked

        display = wx.Display(monitor)
        area = display.GetClientArea()
        size = self.GetManagedWindow().GetSize()

        pos = wx.Point()
        if hAlign == wx.LEFT:
            pos.x = area.x
        elif hAlign == wx.CENTER:
            pos.x = area.x + (area.width - size.x)/2
        else:
            pos.x = area.x + area.width - size.x

        if vAlign == wx.TOP:
            pos.y = area.y
        elif vAlign == wx.CENTER:
            pos.y = area.y + (area.height - size.y)/2
        else:
            pos.y = area.y + area.height - size.y

        return pos


    def GetAnimationStep(self):
        """ Returns the animation step speed (a float) to use in :meth:`AnimateDocking`. """

        return self._animation_step


    def SetAnimationStep(self, step):
        """
        Sets the animation step speed (a float) to use in :meth:`AnimateDocking`.

        :param float `step`: the animation speed.
        """

        self._animation_step = float(step)


    def RequestUserAttention(self, pane_window):
        """
        Requests the user attention by intermittently highlighting the pane caption.

        :param Window `pane_window`: the window managed by the pane;
        """

        # try to find the pane
        paneInfo = self.GetPane(pane_window)
        if not paneInfo.IsOk():
            raise Exception("Pane window not found")

        dc = wx.ClientDC(self._frame)

        # if the frame is about to be deleted, don't bother
        if not self._frame or self._frame.IsBeingDeleted():
            return

        if not self._frame.GetSizer():
            return

        for part in self._uiparts:
            if part.pane == paneInfo:
                self._art.RequestUserAttention(dc, self._frame, part.pane.caption, part.rect, part.pane)
                self._frame.RefreshRect(part.rect, True)
                break


    def StartPreviewTimer(self, toolbar):
        """
        Starts a timer for sliding in and out a minimized pane.

        :param `toolbar`: the :class:`~lib.agw.aui.auibar.AuiToolBar` containing the minimized pane tool.
        """

        toolbar_pane = self.GetPane(toolbar)
        toolbar_name = toolbar_pane.name

        pane_name = toolbar_name[0:-4]

        self._sliding_pane = self.GetPane(pane_name)
        self._sliding_rect = toolbar.GetScreenRect()
        self._sliding_direction = toolbar_pane.dock_direction
        self._sliding_frame = None

        self._preview_timer.Start(1000, wx.TIMER_ONE_SHOT)


    def StopPreviewTimer(self):
        """ Stops a timer for sliding in and out a minimized pane. """

        if self._preview_timer.IsRunning():
            self._preview_timer.Stop()

        self.SlideOut()
        self._sliding_pane = None


    def SlideIn(self, event):
        """
        Handles the ``wx.EVT_TIMER`` event for :class:`AuiManager`.

        :param `event`: a :class:`TimerEvent` to be processed.

        :note: This is used solely for sliding in and out minimized panes.
        """

        window = self._sliding_pane.window
        self._sliding_frame = wx.MiniFrame(None, -1, title=_("Pane Preview"),
                                           style=wx.FRAME_TOOL_WINDOW | wx.STAY_ON_TOP |
                                           wx.FRAME_NO_TASKBAR | wx.CAPTION)
        window.Reparent(self._sliding_frame)
        self._sliding_frame.SetSize((0, 0))
        window.Show()
        self._sliding_frame.Show()

        size = window.GetBestSize()

        startX, startY, stopX, stopY = GetSlidingPoints(self._sliding_rect, size, self._sliding_direction)

        step = stopX/10
        window_size = 0

        for i in xrange(0, stopX, step):
            window_size = i
            self._sliding_frame.SetDimensions(startX, startY, window_size, stopY)
            self._sliding_frame.Refresh()
            self._sliding_frame.Update()
            wx.MilliSleep(10)

        self._sliding_frame.SetDimensions(startX, startY, stopX, stopY)
        self._sliding_frame.Refresh()
        self._sliding_frame.Update()


    def SlideOut(self):
        """
        Slides out a preview of a minimized pane.

        :note: This is used solely for sliding in and out minimized panes.
        """

        if not self._sliding_frame:
            return

        window = self._sliding_frame.GetChildren()[0]
        size = window.GetBestSize()

        startX, startY, stopX, stopY = GetSlidingPoints(self._sliding_rect, size, self._sliding_direction)

        step = stopX/10
        window_size = 0

        for i in xrange(stopX, 0, -step):
            window_size = i
            self._sliding_frame.SetDimensions(startX, startY, window_size, stopY)
            self._sliding_frame.Refresh()
            self._sliding_frame.Update()
            self._frame.RefreshRect(wx.Rect(startX+window_size, startY, step, stopY))
            self._frame.Update()
            wx.MilliSleep(10)

        self._sliding_frame.SetDimensions(startX, startY, 0, stopY)

        window.Hide()
        window.Reparent(self._frame)

        self._sliding_frame.Hide()
        self._sliding_frame.Destroy()
        self._sliding_frame = None
        self._sliding_pane = None


class AuiManager_DCP(AuiManager):
    """
    A class similar to :class:`AuiManager` but with a Dummy Center Pane (**DCP**).
    The code for this class is still flickery due to the call to :func:`CallAfter`
    and the double-update call.
    """

    def __init__(self, *args, **keys):
        """ See :meth:`AuiManager.__init__` for the class construction. """

        AuiManager.__init__(self, *args, **keys)
        self.hasDummyPane = False


    def _createDummyPane(self):
        """ Creates a Dummy Center Pane (**DCP**). """

        if self.hasDummyPane:
            return

        self.hasDummyPane = True
        dummy = wx.Panel(self.GetManagedWindow())
        info = AuiPaneInfo().CenterPane().NotebookDockable(True).Name('dummyCenterPane').DestroyOnClose(True)
        self.AddPane(dummy, info)


    def _destroyDummyPane(self):
        """ Destroys the Dummy Center Pane (**DCP**). """

        if not self.hasDummyPane:
            return

        self.hasDummyPane = False
        self.ClosePane(self.GetPane('dummyCenterPane'))


    def Update(self):
        """
        This method is called after any number of changes are made to any of the
        managed panes. :meth:`Update` must be invoked after :meth:`AuiManager.AddPane` or
        :meth:`AuiManager.InsertPane` are called in order to "realize" or "commit" the changes.

        In addition, any number of changes may be made to :class:`AuiManager` structures
        (retrieved with :meth:`AuiManager.GetPane`), but to realize the changes,
        :meth:`Update` must be called. This construction allows pane flicker to
        be avoided by updating the whole layout at one time.
        """
        AuiManager.Update(self)

        # check if there's already a center pane (except our dummy pane)
        dummyCenterPane = self.GetPane('dummyCenterPane')
        haveCenterPane = any((pane != dummyCenterPane) and (pane.dock_direction == AUI_DOCK_CENTER) and
                             not pane.IsFloating() and pane.IsShown() for pane in self.GetAllPanes())
        if haveCenterPane:
            if self.hasDummyPane:
                # there's our dummy pane and also another center pane, therefor let's remove our dummy
                def do():
                    self._destroyDummyPane()
                    self.Update()
                wx.CallAfter(do)
        else:
            # if we get here, there's no center pane, create our dummy
            if not self.hasDummyPane:
                self._createDummyPane()



########NEW FILE########
__FILENAME__ = tabart
"""
Tab art provider code - a tab provider provides all drawing functionality to
the :class:`~lib.agw.aui.auibook.AuiNotebook`. This allows the
:class:`~lib.agw.aui.auibook.AuiNotebook` to have a plugable look-and-feel.

By default, a :class:`~lib.agw.aui.auibook.AuiNotebook` uses an instance of this class
called :class:`AuiDefaultTabArt` which provides bitmap art and a colour scheme that is
adapted to the major platforms' look. You can either derive from that class to alter its
behaviour or write a completely new tab art class.
Call :meth:`AuiNotebook.SetArtProvider() <lib.agw.aui.auibook.AuiNotebook.SetArtProvider>`
to make use this new tab art.
"""

__author__ = "Andrea Gavana <andrea.gavana@gmail.com>"
__date__ = "31 March 2009"


import wx

if wx.Platform == '__WXMAC__':
    import Carbon.Appearance

from aui_utilities import BitmapFromBits, StepColour, IndentPressedBitmap, ChopText
from aui_utilities import GetBaseColour, DrawMACCloseButton, LightColour, TakeScreenShot
from aui_utilities import CopyAttributes

from aui_constants import *


# -- GUI helper classes and functions --
class AuiCommandCapture(wx.PyEvtHandler):
    """ A class to handle the dropdown window menu. """

    def __init__(self):
        """ Default class constructor. """

        wx.PyEvtHandler.__init__(self)        
        self._last_id = 0


    def GetCommandId(self):
        """ Returns the event command identifier. """

        return self._last_id 


    def ProcessEvent(self, event):
        """
        Processes an event, searching event tables and calling zero or more suitable
        event handler function(s).

        :param `event`: the event to process.

        :note: Normally, your application would not call this function: it is called
         in the wxPython implementation to dispatch incoming user interface events
         to the framework (and application).
         However, you might need to call it if implementing new functionality (such as
         a new control) where you define new event types, as opposed to allowing the
         user to override functions.

         An instance where you might actually override the :meth:`ProcessEvent` function is where
         you want to direct event processing to event handlers not normally noticed by
         wxPython. For example, in the document/view architecture, documents and views
         are potential event handlers. When an event reaches a frame, :meth:`ProcessEvent` will
         need to be called on the associated document and view in case event handler
         functions are associated with these objects. 

         The normal order of event table searching is as follows:

         1. If the object is disabled (via a call to :meth:`EvtHandler.SetEvtHandlerEnabled`) the function
            skips to step (6).
         2. If the object is a :class:`Window`, :meth:`ProcessEvent` is recursively called on the window's 
            :class:`Validator`. If this returns ``True``, the function exits.
         3. wxWidgets `SearchEventTable` is called for this event handler. If this fails, the
            base class table is tried, and so on until no more tables exist or an appropriate
            function was found, in which case the function exits.
         4. The search is applied down the entire chain of event handlers (usually the chain
            has a length of one). If this succeeds, the function exits.
         5. If the object is a :class:`Window` and the event is a :class:`CommandEvent`, :meth:`ProcessEvent` is
            recursively applied to the parent window's event handler. If this returns ``True``,
            the function exits.
         6. Finally, :meth:`ProcessEvent` is called on the :class:`App` object.
        """
        
        if event.GetEventType() == wx.wxEVT_COMMAND_MENU_SELECTED:
            self._last_id = event.GetId()
            return True
        
        if self.GetNextHandler():
            return self.GetNextHandler().ProcessEvent(event)

        return False
    

class AuiDefaultTabArt(object):
    """
    Tab art provider code - a tab provider provides all drawing functionality to the :class:`~lib.agw.aui.auibook.AuiNotebook`.
    This allows the :class:`~lib.agw.aui.auibook.AuiNotebook` to have a plugable look-and-feel.

    By default, a :class:`~lib.agw.aui.auibook.AuiNotebook` uses an instance of this class called
    :class:`AuiDefaultTabArt` which provides bitmap art and a colour scheme that is adapted to the major platforms'
    look. You can either derive from that class to alter its behaviour or write a
    completely new tab art class. Call :meth:`AuiNotebook.SetArtProvider() <lib.agw.aui.auibook.AuiNotebook.SetArtProvider>` to make use this
    new tab art.
    """
    
    def __init__(self):
        """ Default class constructor. """

        self._normal_font = wx.SystemSettings_GetFont(wx.SYS_DEFAULT_GUI_FONT)
        self._selected_font = wx.SystemSettings_GetFont(wx.SYS_DEFAULT_GUI_FONT)
        self._selected_font.SetWeight(wx.BOLD)
        self._measuring_font = self._selected_font

        self._fixed_tab_width = 100
        self._tab_ctrl_height = 0
        self._buttonRect = wx.Rect()

        self.SetDefaultColours()

        if wx.Platform == "__WXMAC__":
            bmp_colour = wx.SystemSettings.GetColour(wx.SYS_COLOUR_3DDKSHADOW)
            self._active_close_bmp = DrawMACCloseButton(bmp_colour)
            self._disabled_close_bmp = DrawMACCloseButton(wx.Colour(128, 128, 128))
        else:
            self._active_close_bmp = BitmapFromBits(nb_close_bits, 16, 16, wx.BLACK)
            self._disabled_close_bmp = BitmapFromBits(nb_close_bits, 16, 16, wx.Colour(128, 128, 128))

        self._hover_close_bmp = self._active_close_bmp
        self._pressed_close_bmp = self._active_close_bmp

        self._active_left_bmp = BitmapFromBits(nb_left_bits, 16, 16, wx.BLACK)
        self._disabled_left_bmp = BitmapFromBits(nb_left_bits, 16, 16, wx.Colour(128, 128, 128))

        self._active_right_bmp = BitmapFromBits(nb_right_bits, 16, 16, wx.BLACK)
        self._disabled_right_bmp = BitmapFromBits(nb_right_bits, 16, 16, wx.Colour(128, 128, 128))

        self._active_windowlist_bmp = BitmapFromBits(nb_list_bits, 16, 16, wx.BLACK)
        self._disabled_windowlist_bmp = BitmapFromBits(nb_list_bits, 16, 16, wx.Colour(128, 128, 128))

        if wx.Platform == "__WXMAC__":
            # Get proper highlight colour for focus rectangle from the
            # current Mac theme.  kThemeBrushFocusHighlight is
            # available on Mac OS 8.5 and higher
            if hasattr(wx, 'MacThemeColour'):
                c = wx.MacThemeColour(Carbon.Appearance.kThemeBrushFocusHighlight)
            else:
                brush = wx.Brush(wx.BLACK)
                brush.MacSetTheme(Carbon.Appearance.kThemeBrushFocusHighlight)
                c = brush.GetColour()
            self._focusPen = wx.Pen(c, 2, wx.SOLID)
        else:
            self._focusPen = wx.Pen(wx.BLACK, 1, wx.USER_DASH)
            self._focusPen.SetDashes([1, 1])
            self._focusPen.SetCap(wx.CAP_BUTT)
            
            
    def SetBaseColour(self, base_colour):
        """
        Sets a new base colour.

        :param `base_colour`: an instance of :class:`Colour`.
        """
        
        self._base_colour = base_colour
        self._base_colour_pen = wx.Pen(self._base_colour)
        self._base_colour_brush = wx.Brush(self._base_colour)


    def SetDefaultColours(self, base_colour=None):
        """
        Sets the default colours, which are calculated from the given base colour.

        :param `base_colour`: an instance of :class:`Colour`. If defaulted to ``None``, a colour
         is generated accordingly to the platform and theme.
        """

        if base_colour is None:
            base_colour = GetBaseColour()

        self.SetBaseColour( base_colour )
        self._border_colour = StepColour(base_colour, 75)
        self._border_pen = wx.Pen(self._border_colour)

        self._background_top_colour = StepColour(self._base_colour, 90)
        self._background_bottom_colour = StepColour(self._base_colour, 170)
        
        self._tab_top_colour = self._base_colour
        self._tab_bottom_colour = wx.WHITE
        self._tab_gradient_highlight_colour = wx.WHITE

        self._tab_inactive_top_colour = self._base_colour
        self._tab_inactive_bottom_colour = StepColour(self._tab_inactive_top_colour, 160)
        
        self._tab_text_colour = lambda page: page.text_colour
        self._tab_disabled_text_colour = wx.SystemSettings.GetColour(wx.SYS_COLOUR_GRAYTEXT)


    def Clone(self):
        """ Clones the art object. """

        art = type(self)()
        art.SetNormalFont(self.GetNormalFont())
        art.SetSelectedFont(self.GetSelectedFont())
        art.SetMeasuringFont(self.GetMeasuringFont())

        art = CopyAttributes(art, self)
        return art


    def SetAGWFlags(self, agwFlags):
        """
        Sets the tab art flags.

        :param integer `agwFlags`: a combination of the following values:

         ==================================== ==================================
         Flag name                            Description
         ==================================== ==================================
         ``AUI_NB_TOP``                       With this style, tabs are drawn along the top of the notebook
         ``AUI_NB_LEFT``                      With this style, tabs are drawn along the left of the notebook. Not implemented yet.
         ``AUI_NB_RIGHT``                     With this style, tabs are drawn along the right of the notebook. Not implemented yet.
         ``AUI_NB_BOTTOM``                    With this style, tabs are drawn along the bottom of the notebook
         ``AUI_NB_TAB_SPLIT``                 Allows the tab control to be split by dragging a tab
         ``AUI_NB_TAB_MOVE``                  Allows a tab to be moved horizontally by dragging
         ``AUI_NB_TAB_EXTERNAL_MOVE``         Allows a tab to be moved to another tab control
         ``AUI_NB_TAB_FIXED_WIDTH``           With this style, all tabs have the same width
         ``AUI_NB_SCROLL_BUTTONS``            With this style, left and right scroll buttons are displayed
         ``AUI_NB_WINDOWLIST_BUTTON``         With this style, a drop-down list of windows is available
         ``AUI_NB_CLOSE_BUTTON``              With this style, a close button is available on the tab bar
         ``AUI_NB_CLOSE_ON_ACTIVE_TAB``       With this style, a close button is available on the active tab
         ``AUI_NB_CLOSE_ON_ALL_TABS``         With this style, a close button is available on all tabs
         ``AUI_NB_MIDDLE_CLICK_CLOSE``        Allows to close :class:`~lib.agw.aui.auibook.AuiNotebook` tabs by mouse middle button click
         ``AUI_NB_SUB_NOTEBOOK``              This style is used by :class:`~lib.agw.aui.framemanager.AuiManager` to create automatic AuiNotebooks
         ``AUI_NB_HIDE_ON_SINGLE_TAB``        Hides the tab window if only one tab is present
         ``AUI_NB_SMART_TABS``                Use Smart Tabbing, like ``Alt`` + ``Tab`` on Windows
         ``AUI_NB_USE_IMAGES_DROPDOWN``       Uses images on dropdown window list menu instead of check items
         ``AUI_NB_CLOSE_ON_TAB_LEFT``         Draws the tab close button on the left instead of on the right (a la Camino browser)
         ``AUI_NB_TAB_FLOAT``                 Allows the floating of single tabs. Known limitation: when the notebook is more or less
                                              full screen, tabs cannot be dragged far enough outside of the notebook to become floating pages
         ``AUI_NB_DRAW_DND_TAB``              Draws an image representation of a tab while dragging (on by default)
         ``AUI_NB_ORDER_BY_ACCESS``           Tab navigation order by last access time for the tabs
         ``AUI_NB_NO_TAB_FOCUS``              Don't draw tab focus rectangle
         ==================================== ==================================
        
        """

        self._agwFlags = agwFlags


    def GetAGWFlags(self):
        """
        Returns the tab art flags.

        :see: :meth:`~AuiDefaultTabArt.SetAGWFlags` for a list of possible return values.
        """

        return self._agwFlags
    
            
    def SetSizingInfo(self, tab_ctrl_size, tab_count, minMaxTabWidth):
        """
        Sets the tab sizing information.
        
        :param Size `tab_ctrl_size`: the size of the tab control area;
        :param integer `tab_count`: the number of tabs;
        :param tuple `minMaxTabWidth`: a tuple containing the minimum and maximum tab widths
         to be used when the ``AUI_NB_TAB_FIXED_WIDTH`` style is active.
        """
        
        self._fixed_tab_width = 100
        minTabWidth, maxTabWidth = minMaxTabWidth

        tot_width = tab_ctrl_size.x - self.GetIndentSize() - 4
        agwFlags = self.GetAGWFlags()
        
        if agwFlags & AUI_NB_CLOSE_BUTTON:
            tot_width -= self._active_close_bmp.GetWidth()
        if agwFlags & AUI_NB_WINDOWLIST_BUTTON:
            tot_width -= self._active_windowlist_bmp.GetWidth()

        if tab_count > 0:
            self._fixed_tab_width = tot_width/tab_count

        if self._fixed_tab_width < 100:
            self._fixed_tab_width = 100

        if self._fixed_tab_width > tot_width/2:
            self._fixed_tab_width = tot_width/2

        if self._fixed_tab_width > 220:
            self._fixed_tab_width = 220

        if minTabWidth > -1:
            self._fixed_tab_width = max(self._fixed_tab_width, minTabWidth)
        if maxTabWidth > -1:
            self._fixed_tab_width = min(self._fixed_tab_width, maxTabWidth)

        self._tab_ctrl_height = tab_ctrl_size.y
    

    def DrawBackground(self, dc, wnd, rect):
        """
        Draws the tab area background.

        :param `dc`: a :class:`DC` device context;
        :param `wnd`: a :class:`Window` instance object;
        :param Rect `rect`: the tab control rectangle.
        """

        self._buttonRect = wx.Rect()

        # draw background
        agwFlags = self.GetAGWFlags()
        if agwFlags & AUI_NB_BOTTOM:
            r = wx.Rect(rect.x, rect.y, rect.width+2, rect.height)

        # TODO: else if (agwFlags & AUI_NB_LEFT) 
        # TODO: else if (agwFlags & AUI_NB_RIGHT) 
        else: #for AUI_NB_TOP
            r = wx.Rect(rect.x, rect.y, rect.width+2, rect.height-3)

        dc.GradientFillLinear(r, self._background_top_colour, self._background_bottom_colour, wx.SOUTH)

        # draw base lines

        dc.SetPen(self._border_pen)
        y = rect.GetHeight()
        w = rect.GetWidth()

        if agwFlags & AUI_NB_BOTTOM:
            dc.SetBrush(wx.Brush(self._background_bottom_colour))
            dc.DrawRectangle(-1, 0, w+2, 4)

        # TODO: else if (agwFlags & AUI_NB_LEFT) 
        # TODO: else if (agwFlags & AUI_NB_RIGHT)
        
        else: # for AUI_NB_TOP
            dc.SetBrush(self._base_colour_brush)
            dc.DrawRectangle(-1, y-4, w+2, 4)


    def DrawTab(self, dc, wnd, page, in_rect, close_button_state, paint_control=False):
        """
        Draws a single tab.

        :param `dc`: a :class:`DC` device context;
        :param `wnd`: a :class:`Window` instance object;
        :param `page`: the tab control page associated with the tab;
        :param Rect `in_rect`: rectangle the tab should be confined to;
        :param integer `close_button_state`: the state of the close button on the tab;
        :param bool `paint_control`: whether to draw the control inside a tab (if any) on a :class:`MemoryDC`.
        """

        # if the caption is empty, measure some temporary text
        caption = page.caption
        if not caption:
            caption = "Xj"

        dc.SetFont(self._selected_font)
        selected_textx, selected_texty, dummy = dc.GetMultiLineTextExtent(caption)

        dc.SetFont(self._normal_font)
        normal_textx, normal_texty, dummy = dc.GetMultiLineTextExtent(caption)

        control = page.control

        # figure out the size of the tab
        tab_size, x_extent = self.GetTabSize(dc, wnd, page.caption, page.bitmap,
                                             page.active, close_button_state, control)

        tab_height = self._tab_ctrl_height - 3
        tab_width = tab_size[0]
        tab_x = in_rect.x
        tab_y = in_rect.y + in_rect.height - tab_height

        caption = page.caption

        # select pen, brush and font for the tab to be drawn

        if page.active:
        
            dc.SetFont(self._selected_font)
            textx, texty = selected_textx, selected_texty
        
        else:
        
            dc.SetFont(self._normal_font)
            textx, texty = normal_textx, normal_texty

        if not page.enabled:
            dc.SetTextForeground(self._tab_disabled_text_colour)
            pagebitmap = page.dis_bitmap
        else:
            dc.SetTextForeground(self._tab_text_colour(page))
            pagebitmap = page.bitmap
            
        # create points that will make the tab outline

        clip_width = tab_width
        if tab_x + clip_width > in_rect.x + in_rect.width:
            clip_width = in_rect.x + in_rect.width - tab_x

        # since the above code above doesn't play well with WXDFB or WXCOCOA,
        # we'll just use a rectangle for the clipping region for now --
        dc.SetClippingRegion(tab_x, tab_y, clip_width+1, tab_height-3)

        border_points = [wx.Point() for i in xrange(6)]
        agwFlags = self.GetAGWFlags()
        
        if agwFlags & AUI_NB_BOTTOM:
        
            border_points[0] = wx.Point(tab_x,             tab_y)
            border_points[1] = wx.Point(tab_x,             tab_y+tab_height-6)
            border_points[2] = wx.Point(tab_x+2,           tab_y+tab_height-4)
            border_points[3] = wx.Point(tab_x+tab_width-2, tab_y+tab_height-4)
            border_points[4] = wx.Point(tab_x+tab_width,   tab_y+tab_height-6)
            border_points[5] = wx.Point(tab_x+tab_width,   tab_y)
        
        else: #if (agwFlags & AUI_NB_TOP) 
        
            border_points[0] = wx.Point(tab_x,             tab_y+tab_height-4)
            border_points[1] = wx.Point(tab_x,             tab_y+2)
            border_points[2] = wx.Point(tab_x+2,           tab_y)
            border_points[3] = wx.Point(tab_x+tab_width-2, tab_y)
            border_points[4] = wx.Point(tab_x+tab_width,   tab_y+2)
            border_points[5] = wx.Point(tab_x+tab_width,   tab_y+tab_height-4)
        
        # TODO: else if (agwFlags & AUI_NB_LEFT) 
        # TODO: else if (agwFlags & AUI_NB_RIGHT) 

        drawn_tab_yoff = border_points[1].y
        drawn_tab_height = border_points[0].y - border_points[1].y

        if page.active:
        
            # draw active tab

            # draw base background colour
            r = wx.Rect(tab_x, tab_y, tab_width, tab_height)
            dc.SetPen(self._base_colour_pen)
            dc.SetBrush(self._base_colour_brush)
            dc.DrawRectangle(r.x+1, r.y+1, r.width-1, r.height-4)

            # this white helps fill out the gradient at the top of the tab
            dc.SetPen( wx.Pen(self._tab_gradient_highlight_colour) )
            dc.SetBrush( wx.Brush(self._tab_gradient_highlight_colour) )
            dc.DrawRectangle(r.x+2, r.y+1, r.width-3, r.height-4)

            # these two points help the rounded corners appear more antialiased
            dc.SetPen(self._base_colour_pen)
            dc.DrawPoint(r.x+2, r.y+1)
            dc.DrawPoint(r.x+r.width-2, r.y+1)

            # set rectangle down a bit for gradient drawing
            r.SetHeight(r.GetHeight()/2)
            r.x += 2
            r.width -= 2
            r.y += r.height
            r.y -= 2

            # draw gradient background
            top_colour = self._tab_bottom_colour
            bottom_colour = self._tab_top_colour
            dc.GradientFillLinear(r, bottom_colour, top_colour, wx.NORTH)
        
        else:
        
            # draw inactive tab

            r = wx.Rect(tab_x, tab_y+1, tab_width, tab_height-3)

            # start the gradent up a bit and leave the inside border inset
            # by a pixel for a 3D look.  Only the top half of the inactive
            # tab will have a slight gradient
            r.x += 3
            r.y += 1
            r.width -= 4
            r.height /= 2
            r.height -= 1

            # -- draw top gradient fill for glossy look
            top_colour = self._tab_inactive_top_colour
            bottom_colour = self._tab_inactive_bottom_colour
            dc.GradientFillLinear(r, bottom_colour, top_colour, wx.NORTH)

            r.y += r.height
            r.y -= 1

            # -- draw bottom fill for glossy look
            top_colour = self._tab_inactive_bottom_colour
            bottom_colour = self._tab_inactive_bottom_colour
            dc.GradientFillLinear(r, top_colour, bottom_colour, wx.SOUTH)
        
        # draw tab outline
        dc.SetPen(self._border_pen)
        dc.SetBrush(wx.TRANSPARENT_BRUSH)
        dc.DrawPolygon(border_points)

        # there are two horizontal grey lines at the bottom of the tab control,
        # this gets rid of the top one of those lines in the tab control
        if page.active:
        
            if agwFlags & AUI_NB_BOTTOM:
                dc.SetPen(wx.Pen(self._background_bottom_colour))
                
            # TODO: else if (agwFlags & AUI_NB_LEFT) 
            # TODO: else if (agwFlags & AUI_NB_RIGHT) 
            else: # for AUI_NB_TOP
                dc.SetPen(self._base_colour_pen)
                
            dc.DrawLine(border_points[0].x+1,
                        border_points[0].y,
                        border_points[5].x,
                        border_points[5].y)
        
        text_offset = tab_x + 8
        close_button_width = 0

        if close_button_state != AUI_BUTTON_STATE_HIDDEN:
            close_button_width = self._active_close_bmp.GetWidth()

            if agwFlags & AUI_NB_CLOSE_ON_TAB_LEFT:
                text_offset += close_button_width - 5
                
        bitmap_offset = 0
        
        if pagebitmap.IsOk():
        
            bitmap_offset = tab_x + 8
            if agwFlags & AUI_NB_CLOSE_ON_TAB_LEFT and close_button_width:
                bitmap_offset += close_button_width - 5

            # draw bitmap
            dc.DrawBitmap(pagebitmap,
                          bitmap_offset,
                          drawn_tab_yoff + (drawn_tab_height/2) - (pagebitmap.GetHeight()/2),
                          True)

            text_offset = bitmap_offset + pagebitmap.GetWidth()
            text_offset += 3 # bitmap padding

        else:

            if agwFlags & AUI_NB_CLOSE_ON_TAB_LEFT == 0 or not close_button_width:
                text_offset = tab_x + 8
        
        draw_text = ChopText(dc, caption, tab_width - (text_offset-tab_x) - close_button_width)

        ypos = drawn_tab_yoff + (drawn_tab_height)/2 - (texty/2) - 1

        offset_focus = text_offset     
        if control is not None:
            if control.GetPosition() != wx.Point(text_offset+1, ypos):
                control.SetPosition(wx.Point(text_offset+1, ypos))

            if not control.IsShown():
                control.Show()

            if paint_control:
                bmp = TakeScreenShot(control.GetScreenRect())
                dc.DrawBitmap(bmp, text_offset+1, ypos, True)
                
            controlW, controlH = control.GetSize()
            text_offset += controlW + 4
            textx += controlW + 4
            
        # draw tab text
        rectx, recty, dummy = dc.GetMultiLineTextExtent(draw_text)
        dc.DrawLabel(draw_text, wx.Rect(text_offset, ypos, rectx, recty))

        # draw focus rectangle
        if (agwFlags & AUI_NB_NO_TAB_FOCUS) == 0:
            self.DrawFocusRectangle(dc, page, wnd, draw_text, offset_focus, bitmap_offset, drawn_tab_yoff, drawn_tab_height, rectx, recty)
        
        out_button_rect = wx.Rect()
        
        # draw close button if necessary
        if close_button_state != AUI_BUTTON_STATE_HIDDEN:
        
            bmp = self._disabled_close_bmp

            if close_button_state == AUI_BUTTON_STATE_HOVER:
                bmp = self._hover_close_bmp
            elif close_button_state == AUI_BUTTON_STATE_PRESSED:
                bmp = self._pressed_close_bmp

            shift = (agwFlags & AUI_NB_BOTTOM and [1] or [0])[0]

            if agwFlags & AUI_NB_CLOSE_ON_TAB_LEFT:
                rect = wx.Rect(tab_x + 4, tab_y + (tab_height - bmp.GetHeight())/2 - shift,
                               close_button_width, tab_height)
            else:
                rect = wx.Rect(tab_x + tab_width - close_button_width - 1,
                               tab_y + (tab_height - bmp.GetHeight())/2 - shift,
                               close_button_width, tab_height)

            rect = IndentPressedBitmap(rect, close_button_state)
            dc.DrawBitmap(bmp, rect.x, rect.y, True)

            out_button_rect = rect
        
        out_tab_rect = wx.Rect(tab_x, tab_y, tab_width, tab_height)

        dc.DestroyClippingRegion()

        return out_tab_rect, out_button_rect, x_extent
    

    def SetCustomButton(self, bitmap_id, button_state, bmp):
        """
        Sets a custom bitmap for the close, left, right and window list buttons.
        
        :param integer `bitmap_id`: the button identifier;
        :param integer `button_state`: the button state;
        :param Bitmap `bmp`: the custom bitmap to use for the button.
        """

        if bitmap_id == AUI_BUTTON_CLOSE:
            if button_state == AUI_BUTTON_STATE_NORMAL:
                self._active_close_bmp = bmp
                self._hover_close_bmp = self._active_close_bmp
                self._pressed_close_bmp = self._active_close_bmp
                self._disabled_close_bmp = self._active_close_bmp
                    
            elif button_state == AUI_BUTTON_STATE_HOVER:
                self._hover_close_bmp = bmp
            elif button_state == AUI_BUTTON_STATE_PRESSED:
                self._pressed_close_bmp = bmp
            else:
                self._disabled_close_bmp = bmp

        elif bitmap_id == AUI_BUTTON_LEFT:
            if button_state & AUI_BUTTON_STATE_DISABLED:
                self._disabled_left_bmp = bmp
            else:
                self._active_left_bmp = bmp

        elif bitmap_id == AUI_BUTTON_RIGHT:
            if button_state & AUI_BUTTON_STATE_DISABLED:
                self._disabled_right_bmp = bmp
            else:
                self._active_right_bmp = bmp

        elif bitmap_id == AUI_BUTTON_WINDOWLIST:
            if button_state & AUI_BUTTON_STATE_DISABLED:
                self._disabled_windowlist_bmp = bmp
            else:
                self._active_windowlist_bmp = bmp
        

    def GetIndentSize(self):
        """ Returns the tabs indent size. """

        return 5


    def GetTabSize(self, dc, wnd, caption, bitmap, active, close_button_state, control=None):
        """
        Returns the tab size for the given caption, bitmap and button state.

        :param `dc`: a :class:`DC` device context;
        :param `wnd`: a :class:`Window` instance object;
        :param string `caption`: the tab text caption;
        :param Bitmap `bitmap`: the bitmap displayed on the tab;
        :param bool `active`: whether the tab is selected or not;
        :param integer `close_button_state`: the state of the close button on the tab;
        :param Window `control`: a :class:`Window` instance inside a tab (or ``None``).
        """

        dc.SetFont(self._measuring_font)
        measured_textx, measured_texty, dummy = dc.GetMultiLineTextExtent(caption)

        # add padding around the text
        tab_width = measured_textx
        tab_height = measured_texty

        # if the close button is showing, add space for it
        if close_button_state != AUI_BUTTON_STATE_HIDDEN:
            tab_width += self._active_close_bmp.GetWidth() + 3

        # if there's a bitmap, add space for it
        if bitmap.IsOk():
            tab_width += bitmap.GetWidth()
            tab_width += 3 # right side bitmap padding
            tab_height = max(tab_height, bitmap.GetHeight())
        
        # add padding
        tab_width += 16
        tab_height += 10

        agwFlags = self.GetAGWFlags()
        if agwFlags & AUI_NB_TAB_FIXED_WIDTH:
            tab_width = self._fixed_tab_width

        if control is not None:
            tab_width += control.GetSize().GetWidth() + 4
            
        x_extent = tab_width

        return (tab_width, tab_height), x_extent


    def DrawButton(self, dc, wnd, in_rect, button, orientation):
        """
        Draws a button on the tab or on the tab area, depending on the button identifier. 

        :param `dc`: a :class:`DC` device context;
        :param `wnd`: a :class:`Window` instance object;
        :param Rect `in_rect`: rectangle the tab should be confined to;
        :param `button`: an instance of the button class;
        :param integer `orientation`: the tab orientation.
        """

        bitmap_id, button_state = button.id, button.cur_state
        
        if bitmap_id == AUI_BUTTON_CLOSE:
            if button_state & AUI_BUTTON_STATE_DISABLED:
                bmp = self._disabled_close_bmp
            elif button_state & AUI_BUTTON_STATE_HOVER:
                bmp = self._hover_close_bmp
            elif button_state & AUI_BUTTON_STATE_PRESSED:
                bmp = self._pressed_close_bmp
            else:
                bmp = self._active_close_bmp

        elif bitmap_id == AUI_BUTTON_LEFT:
            if button_state & AUI_BUTTON_STATE_DISABLED:
                bmp = self._disabled_left_bmp
            else:
                bmp = self._active_left_bmp

        elif bitmap_id == AUI_BUTTON_RIGHT:
            if button_state & AUI_BUTTON_STATE_DISABLED:
                bmp = self._disabled_right_bmp
            else:
                bmp = self._active_right_bmp

        elif bitmap_id == AUI_BUTTON_WINDOWLIST:
            if button_state & AUI_BUTTON_STATE_DISABLED:
                bmp = self._disabled_windowlist_bmp
            else:
                bmp = self._active_windowlist_bmp

        else:
            if button_state & AUI_BUTTON_STATE_DISABLED:
                bmp = button.dis_bitmap
            else:
                bmp = button.bitmap
                
        if not bmp.IsOk():
            return

        rect = wx.Rect(*in_rect)

        if orientation == wx.LEFT:
        
            rect.SetX(in_rect.x)
            rect.SetY(((in_rect.y + in_rect.height)/2) - (bmp.GetHeight()/2))
            rect.SetWidth(bmp.GetWidth())
            rect.SetHeight(bmp.GetHeight())
        
        else:
        
            rect = wx.Rect(in_rect.x + in_rect.width - bmp.GetWidth(),
                           ((in_rect.y + in_rect.height)/2) - (bmp.GetHeight()/2),
                           bmp.GetWidth(), bmp.GetHeight())
        
        rect = IndentPressedBitmap(rect, button_state)
        dc.DrawBitmap(bmp, rect.x, rect.y, True)

        out_rect = rect

        if bitmap_id == AUI_BUTTON_RIGHT:
            self._buttonRect = wx.Rect(rect.x, rect.y, 30, rect.height)
        
        return out_rect


    def DrawFocusRectangle(self, dc, page, wnd, draw_text, text_offset, bitmap_offset, drawn_tab_yoff, drawn_tab_height, textx, texty):
        """
        Draws the focus rectangle on a tab.

        :param `dc`: a :class:`DC` device context;
        :param `page`: the page associated with the tab;
        :param `wnd`: a :class:`Window` instance object;
        :param string `draw_text`: the text that has been drawn on the tab;
        :param integer `text_offset`: the text offset on the tab;
        :param integer `bitmap_offset`: the bitmap offset on the tab;
        :param integer `drawn_tab_yoff`: the y offset of the tab text;
        :param integer `drawn_tab_height`: the height of the tab;
        :param integer `textx`: the x text extent;
        :param integer `texty`: the y text extent.
        """

        if self.GetAGWFlags() & AUI_NB_NO_TAB_FOCUS:
            return
        
        if page.active and wx.Window.FindFocus() == wnd:
        
            focusRectText = wx.Rect(text_offset, (drawn_tab_yoff + (drawn_tab_height)/2 - (texty/2)),
                                    textx, texty)

            if page.bitmap.IsOk():
                focusRectBitmap = wx.Rect(bitmap_offset, drawn_tab_yoff + (drawn_tab_height/2) - (page.bitmap.GetHeight()/2),
                                          page.bitmap.GetWidth(), page.bitmap.GetHeight())

            if page.bitmap.IsOk() and draw_text == "":
                focusRect = wx.Rect(*focusRectBitmap)
            elif not page.bitmap.IsOk() and draw_text != "":
                focusRect = wx.Rect(*focusRectText)
            elif page.bitmap.IsOk() and draw_text != "":
                focusRect = focusRectText.Union(focusRectBitmap)

            focusRect.Inflate(2, 2)

            dc.SetBrush(wx.TRANSPARENT_BRUSH)
            dc.SetPen(self._focusPen)
            dc.DrawRoundedRectangleRect(focusRect, 2)
        

    def GetBestTabCtrlSize(self, wnd, pages, required_bmp_size):
        """
        Returns the best tab control size.

        :param `wnd`: a :class:`Window` instance object;
        :param list `pages`: the pages associated with the tabs;
        :param Size `required_bmp_size`: the size of the bitmap on the tabs.
        """

        dc = wx.ClientDC(wnd)
        dc.SetFont(self._measuring_font)

        # sometimes a standard bitmap size needs to be enforced, especially
        # if some tabs have bitmaps and others don't.  This is important because
        # it prevents the tab control from resizing when tabs are added.

        measure_bmp = wx.NullBitmap
        
        if required_bmp_size.IsFullySpecified():
            measure_bmp = wx.EmptyBitmap(required_bmp_size.x,
                                         required_bmp_size.y)
        
        max_y = 0
        
        for page in pages:
        
            if measure_bmp.IsOk():
                bmp = measure_bmp
            else:
                bmp = page.bitmap

            # we don't use the caption text because we don't
            # want tab heights to be different in the case
            # of a very short piece of text on one tab and a very
            # tall piece of text on another tab
            s, x_ext = self.GetTabSize(dc, wnd, page.caption, bmp, True, AUI_BUTTON_STATE_HIDDEN, None)
            max_y = max(max_y, s[1])

            if page.control:
                controlW, controlH = page.control.GetSize()
                max_y = max(max_y, controlH+4)

        return max_y + 2


    def SetNormalFont(self, font):
        """
        Sets the normal font for drawing tab labels.

        :param Font `font`: the new font to use to draw tab labels in their normal, un-selected state.
        """

        self._normal_font = font


    def SetSelectedFont(self, font):
        """
        Sets the selected tab font for drawing tab labels.

        :param Font `font`: the new font to use to draw tab labels in their selected state.
        """

        self._selected_font = font


    def SetMeasuringFont(self, font):
        """
        Sets the font for calculating text measurements.

        :param Font `font`: the new font to use to measure tab labels text extents.
        """

        self._measuring_font = font


    def GetNormalFont(self):
        """ Returns the normal font for drawing tab labels. """

        return self._normal_font


    def GetSelectedFont(self):
        """ Returns the selected tab font for drawing tab labels. """

        return self._selected_font


    def GetMeasuringFont(self):
        """ Returns the font for calculating text measurements. """

        return self._measuring_font
    

    def ShowDropDown(self, wnd, pages, active_idx):
        """
        Shows the drop-down window menu on the tab area.

        :param `wnd`: a :class:`Window` derived window instance;
        :param list `pages`: the pages associated with the tabs;
        :param integer `active_idx`: the active tab index.
        """
        
        useImages = self.GetAGWFlags() & AUI_NB_USE_IMAGES_DROPDOWN
        menuPopup = wx.Menu()

        longest = 0
        for i, page in enumerate(pages):
        
            caption = page.caption

            # if there is no caption, make it a space.  This will prevent
            # an assert in the menu code.
            if caption == "":
                caption = " "

            # Save longest caption width for calculating menu width with
            width = wnd.GetTextExtent(caption)[0]
            if width > longest:
                longest = width

            if useImages:
                menuItem = wx.MenuItem(menuPopup, 1000+i, caption)
                if page.bitmap:
                    menuItem.SetBitmap(page.bitmap)

                menuPopup.AppendItem(menuItem)
                
            else:
                
                menuPopup.AppendCheckItem(1000+i, caption)
                
            menuPopup.Enable(1000+i, page.enabled)

        if active_idx != -1 and not useImages:
        
            menuPopup.Check(1000+active_idx, True)
        
        # find out the screen coordinate at the bottom of the tab ctrl
        cli_rect = wnd.GetClientRect()

        # Calculate the approximate size of the popupmenu for setting the
        # position of the menu when its shown.
        # Account for extra padding on left/right of text on mac menus
        if wx.Platform in ['__WXMAC__', '__WXMSW__']:
            longest += 32

        # Bitmap/Checkmark width + padding
        longest += 20

        if self.GetAGWFlags() & AUI_NB_CLOSE_BUTTON:
            longest += 16

        pt = wx.Point(cli_rect.x + cli_rect.GetWidth() - longest,
                     cli_rect.y + cli_rect.height)

        cc = AuiCommandCapture()
        wnd.PushEventHandler(cc)
        wnd.PopupMenu(menuPopup, pt)
        command = cc.GetCommandId()
        wnd.PopEventHandler(True)

        if command >= 1000:
            return command - 1000

        return -1


class AuiSimpleTabArt(object):
    """ A simple-looking implementation of a tab art. """

    def __init__(self):
        """ Default class constructor. """

        self._normal_font = wx.SystemSettings.GetFont(wx.SYS_DEFAULT_GUI_FONT)
        self._selected_font = wx.SystemSettings.GetFont(wx.SYS_DEFAULT_GUI_FONT)
        self._selected_font.SetWeight(wx.BOLD)
        self._measuring_font = self._selected_font

        self._agwFlags = 0
        self._fixed_tab_width = 100

        base_colour = wx.SystemSettings.GetColour(wx.SYS_COLOUR_3DFACE)

        background_colour = base_colour
        normaltab_colour = base_colour
        selectedtab_colour = wx.WHITE

        self._bkbrush = wx.Brush(background_colour)
        self._normal_bkbrush = wx.Brush(normaltab_colour)
        self._normal_bkpen = wx.Pen(normaltab_colour)
        self._selected_bkbrush = wx.Brush(selectedtab_colour)
        self._selected_bkpen = wx.Pen(selectedtab_colour)

        self._active_close_bmp = BitmapFromBits(nb_close_bits, 16, 16, wx.BLACK)
        self._disabled_close_bmp = BitmapFromBits(nb_close_bits, 16, 16, wx.Colour(128, 128, 128))

        self._active_left_bmp = BitmapFromBits(nb_left_bits, 16, 16, wx.BLACK)
        self._disabled_left_bmp = BitmapFromBits(nb_left_bits, 16, 16, wx.Colour(128, 128, 128))

        self._active_right_bmp = BitmapFromBits(nb_right_bits, 16, 16, wx.BLACK)
        self._disabled_right_bmp = BitmapFromBits(nb_right_bits, 16, 16, wx.Colour(128, 128, 128))

        self._active_windowlist_bmp = BitmapFromBits(nb_list_bits, 16, 16, wx.BLACK)
        self._disabled_windowlist_bmp = BitmapFromBits(nb_list_bits, 16, 16, wx.Colour(128, 128, 128))


    def Clone(self):
        """ Clones the art object. """

        art = type(self)()
        art.SetNormalFont(self.GetNormalFont())
        art.SetSelectedFont(self.GetSelectedFont())
        art.SetMeasuringFont(self.GetMeasuringFont())

        art = CopyAttributes(art, self)
        return art


    def SetAGWFlags(self, agwFlags):
        """
        Sets the tab art flags.

        :param integer `agwFlags`: a combination of the following values:

         ==================================== ==================================
         Flag name                            Description
         ==================================== ==================================
         ``AUI_NB_TOP``                       With this style, tabs are drawn along the top of the notebook
         ``AUI_NB_LEFT``                      With this style, tabs are drawn along the left of the notebook. Not implemented yet.
         ``AUI_NB_RIGHT``                     With this style, tabs are drawn along the right of the notebook. Not implemented yet.
         ``AUI_NB_BOTTOM``                    With this style, tabs are drawn along the bottom of the notebook
         ``AUI_NB_TAB_SPLIT``                 Allows the tab control to be split by dragging a tab
         ``AUI_NB_TAB_MOVE``                  Allows a tab to be moved horizontally by dragging
         ``AUI_NB_TAB_EXTERNAL_MOVE``         Allows a tab to be moved to another tab control
         ``AUI_NB_TAB_FIXED_WIDTH``           With this style, all tabs have the same width
         ``AUI_NB_SCROLL_BUTTONS``            With this style, left and right scroll buttons are displayed
         ``AUI_NB_WINDOWLIST_BUTTON``         With this style, a drop-down list of windows is available
         ``AUI_NB_CLOSE_BUTTON``              With this style, a close button is available on the tab bar
         ``AUI_NB_CLOSE_ON_ACTIVE_TAB``       With this style, a close button is available on the active tab
         ``AUI_NB_CLOSE_ON_ALL_TABS``         With this style, a close button is available on all tabs
         ``AUI_NB_MIDDLE_CLICK_CLOSE``        Allows to close :class:`~lib.agw.aui.auibook.AuiNotebook` tabs by mouse middle button click
         ``AUI_NB_SUB_NOTEBOOK``              This style is used by :class:`~lib.agw.aui.framemanager.AuiManager` to create automatic AuiNotebooks
         ``AUI_NB_HIDE_ON_SINGLE_TAB``        Hides the tab window if only one tab is present
         ``AUI_NB_SMART_TABS``                Use Smart Tabbing, like ``Alt`` + ``Tab`` on Windows
         ``AUI_NB_USE_IMAGES_DROPDOWN``       Uses images on dropdown window list menu instead of check items
         ``AUI_NB_CLOSE_ON_TAB_LEFT``         Draws the tab close button on the left instead of on the right (a la Camino browser)
         ``AUI_NB_TAB_FLOAT``                 Allows the floating of single tabs. Known limitation: when the notebook is more or less full
                                              screen, tabs cannot be dragged far enough outside of the notebook to become floating pages
         ``AUI_NB_DRAW_DND_TAB``              Draws an image representation of a tab while dragging (on by default)
         ``AUI_NB_ORDER_BY_ACCESS``           Tab navigation order by last access time for the tabs
         ``AUI_NB_NO_TAB_FOCUS``              Don't draw tab focus rectangle
         ==================================== ==================================
        
        """

        self._agwFlags = agwFlags


    def GetAGWFlags(self):
        """
        Returns the tab art flags.

        :see: :meth:`~AuiSimpleTabArt.SetAGWFlags` for a list of possible return values.
        """

        return self._agwFlags
    

    def SetSizingInfo(self, tab_ctrl_size, tab_count, minMaxTabWidth):
        """
        Sets the tab sizing information.
        
        :param Size `tab_ctrl_size`: the size of the tab control area;
        :param integer `tab_count`: the number of tabs;
        :param tuple `minMaxTabWidth`: a tuple containing the minimum and maximum tab widths
         to be used when the ``AUI_NB_TAB_FIXED_WIDTH`` style is active.
        """
        
        self._fixed_tab_width = 100
        minTabWidth, maxTabWidth = minMaxTabWidth

        tot_width = tab_ctrl_size.x - self.GetIndentSize() - 4

        if self._agwFlags & AUI_NB_CLOSE_BUTTON:
            tot_width -= self._active_close_bmp.GetWidth()
        if self._agwFlags & AUI_NB_WINDOWLIST_BUTTON:
            tot_width -= self._active_windowlist_bmp.GetWidth()

        if tab_count > 0:
            self._fixed_tab_width = tot_width/tab_count
        
        if self._fixed_tab_width < 100:
            self._fixed_tab_width = 100

        if self._fixed_tab_width > tot_width/2:
            self._fixed_tab_width = tot_width/2

        if self._fixed_tab_width > 220:
            self._fixed_tab_width = 220

        if minTabWidth > -1:
            self._fixed_tab_width = max(self._fixed_tab_width, minTabWidth)
        if maxTabWidth > -1:
            self._fixed_tab_width = min(self._fixed_tab_width, maxTabWidth)

        self._tab_ctrl_height = tab_ctrl_size.y
        

    def DrawBackground(self, dc, wnd, rect):
        """
        Draws the tab area background.

        :param `dc`: a :class:`DC` device context;
        :param `wnd`: a :class:`Window` instance object;
        :param Rect `rect`: the tab control rectangle.
        """
        
        # draw background
        dc.SetBrush(self._bkbrush)
        dc.SetPen(wx.TRANSPARENT_PEN)
        dc.DrawRectangle(-1, -1, rect.GetWidth()+2, rect.GetHeight()+2)

        # draw base line
        dc.SetPen(wx.GREY_PEN)
        dc.DrawLine(0, rect.GetHeight()-1, rect.GetWidth(), rect.GetHeight()-1)


    def DrawTab(self, dc, wnd, page, in_rect, close_button_state, paint_control=False):
        """
        Draws a single tab.

        :param `dc`: a :class:`DC` device context;
        :param `wnd`: a :class:`Window` instance object;
        :param `page`: the tab control page associated with the tab;
        :param Rect `in_rect`: rectangle the tab should be confined to;
        :param integer `close_button_state`: the state of the close button on the tab;
        :param bool `paint_control`: whether to draw the control inside a tab (if any) on a :class:`MemoryDC`.
        """
        
        # if the caption is empty, measure some temporary text
        caption = page.caption
        if caption == "":
            caption = "Xj"

        agwFlags = self.GetAGWFlags()
        
        dc.SetFont(self._selected_font)
        selected_textx, selected_texty, dummy = dc.GetMultiLineTextExtent(caption)

        dc.SetFont(self._normal_font)
        normal_textx, normal_texty, dummy = dc.GetMultiLineTextExtent(caption)

        control = page.control

        # figure out the size of the tab
        tab_size, x_extent = self.GetTabSize(dc, wnd, page.caption, page.bitmap,
                                             page.active, close_button_state, control)

        tab_height = tab_size[1]
        tab_width = tab_size[0]
        tab_x = in_rect.x
        tab_y = in_rect.y + in_rect.height - tab_height

        caption = page.caption
        # select pen, brush and font for the tab to be drawn

        if page.active:
        
            dc.SetPen(self._selected_bkpen)
            dc.SetBrush(self._selected_bkbrush)
            dc.SetFont(self._selected_font)
            textx = selected_textx
            texty = selected_texty
        
        else:
        
            dc.SetPen(self._normal_bkpen)
            dc.SetBrush(self._normal_bkbrush)
            dc.SetFont(self._normal_font)
            textx = normal_textx
            texty = normal_texty

        if not page.enabled:
            dc.SetTextForeground(wx.SystemSettings.GetColour(wx.SYS_COLOUR_GRAYTEXT))
        else:
            dc.SetTextForeground(page.text_colour)
        
        # -- draw line --

        points = [wx.Point() for i in xrange(7)]
        points[0].x = tab_x
        points[0].y = tab_y + tab_height - 1
        points[1].x = tab_x + tab_height - 3
        points[1].y = tab_y + 2
        points[2].x = tab_x + tab_height + 3
        points[2].y = tab_y
        points[3].x = tab_x + tab_width - 2
        points[3].y = tab_y
        points[4].x = tab_x + tab_width
        points[4].y = tab_y + 2
        points[5].x = tab_x + tab_width
        points[5].y = tab_y + tab_height - 1
        points[6] = points[0]

        dc.SetClippingRect(in_rect)
        dc.DrawPolygon(points)

        dc.SetPen(wx.GREY_PEN)
        dc.DrawLines(points)

        close_button_width = 0
        
        if close_button_state != AUI_BUTTON_STATE_HIDDEN:
        
            close_button_width = self._active_close_bmp.GetWidth()
            if agwFlags & AUI_NB_CLOSE_ON_TAB_LEFT:
                if control:
                    text_offset = tab_x + (tab_height/2) + close_button_width - (textx/2) - 2
                else:
                    text_offset = tab_x + (tab_height/2) + ((tab_width+close_button_width)/2) - (textx/2) - 2
            else:
                if control:
                    text_offset = tab_x + (tab_height/2) + close_button_width - (textx/2)
                else:
                    text_offset = tab_x + (tab_height/2) + ((tab_width-close_button_width)/2) - (textx/2)
        
        else:
        
            text_offset = tab_x + (tab_height/3) + (tab_width/2) - (textx/2)
            if control:
                if agwFlags & AUI_NB_CLOSE_ON_TAB_LEFT:
                    text_offset = tab_x + (tab_height/3) - (textx/2) + close_button_width + 2
                else:
                    text_offset = tab_x + (tab_height/3) - (textx/2)
        
        # set minimum text offset
        if text_offset < tab_x + tab_height:
            text_offset = tab_x + tab_height

        # chop text if necessary
        if agwFlags & AUI_NB_CLOSE_ON_TAB_LEFT:
            draw_text = ChopText(dc, caption, tab_width - (text_offset-tab_x))
        else:
            draw_text = ChopText(dc, caption,
                                 tab_width - (text_offset-tab_x) - close_button_width)

        ypos = (tab_y + tab_height)/2 - (texty/2) + 1

        if control is not None:
            if control.GetPosition() != wx.Point(text_offset+1, ypos):
                control.SetPosition(wx.Point(text_offset+1, ypos))

            if not control.IsShown():
                control.Show()

            if paint_control:
                bmp = TakeScreenShot(control.GetScreenRect())
                dc.DrawBitmap(bmp, text_offset+1, ypos, True)
                
            controlW, controlH = control.GetSize()
            text_offset += controlW + 4

        # draw tab text
        rectx, recty, dummy = dc.GetMultiLineTextExtent(draw_text)
        dc.DrawLabel(draw_text, wx.Rect(text_offset, ypos, rectx, recty))

        # draw focus rectangle
        if page.active and wx.Window.FindFocus() == wnd and (agwFlags & AUI_NB_NO_TAB_FOCUS) == 0:
        
            focusRect = wx.Rect(text_offset, ((tab_y + tab_height)/2 - (texty/2) + 1),
                                selected_textx, selected_texty)

            focusRect.Inflate(2, 2)
            # TODO:
            # This should be uncommented when DrawFocusRect will become
            # available in wxPython
            # wx.RendererNative.Get().DrawFocusRect(wnd, dc, focusRect, 0)

        out_button_rect = wx.Rect()        
        # draw close button if necessary
        if close_button_state != AUI_BUTTON_STATE_HIDDEN:
        
            if page.active:
                bmp = self._active_close_bmp
            else:
                bmp = self._disabled_close_bmp

            if agwFlags & AUI_NB_CLOSE_ON_TAB_LEFT:
                rect = wx.Rect(tab_x + tab_height - 2,
                               tab_y + (tab_height/2) - (bmp.GetHeight()/2) + 1,
                               close_button_width, tab_height - 1)
            else:                
                rect = wx.Rect(tab_x + tab_width - close_button_width - 1,
                               tab_y + (tab_height/2) - (bmp.GetHeight()/2) + 1,
                               close_button_width, tab_height - 1)
            
            self.DrawButtons(dc, rect, bmp, wx.WHITE, close_button_state)
            out_button_rect = wx.Rect(*rect)
        
        out_tab_rect = wx.Rect(tab_x, tab_y, tab_width, tab_height)
        dc.DestroyClippingRegion()

        return out_tab_rect, out_button_rect, x_extent  


    def DrawButtons(self, dc, _rect, bmp, bkcolour, button_state):
        """
        Convenience method to draw tab buttons.

        :param `dc`: a :class:`DC` device context;
        :param Rect `_rect`: the tab rectangle;
        :param Bitmap `bmp`: the tab bitmap;
        :param Colour `bkcolour`: the tab background colour;
        :param integer `button_state`: the state of the tab button.
        """

        rect = wx.Rect(*_rect)

        if button_state == AUI_BUTTON_STATE_PRESSED:
            rect.x += 1
            rect.y += 1

        if button_state in [AUI_BUTTON_STATE_HOVER, AUI_BUTTON_STATE_PRESSED]:
            dc.SetBrush(wx.Brush(StepColour(bkcolour, 120)))
            dc.SetPen(wx.Pen(StepColour(bkcolour, 75)))

            # draw the background behind the button
            dc.DrawRectangle(rect.x, rect.y, 15, 15)

        # draw the button itself
        dc.DrawBitmap(bmp, rect.x, rect.y, True)

    
    def GetIndentSize(self):
        """ Returns the tabs indent size. """
        
        return 0


    def GetTabSize(self, dc, wnd, caption, bitmap, active, close_button_state, control=None):
        """
        Returns the tab size for the given caption, bitmap and button state.

        :param `dc`: a :class:`DC` device context;
        :param `wnd`: a :class:`Window` instance object;
        :param string `caption`: the tab text caption;
        :param Bitmap `bitmap`: the bitmap displayed on the tab;
        :param bool `active`: whether the tab is selected or not;
        :param integer `close_button_state`: the state of the close button on the tab;
        :param Window `control`: a :class:`Window` instance inside a tab (or ``None``).
        """
        
        dc.SetFont(self._measuring_font)
        measured_textx, measured_texty, dummy = dc.GetMultiLineTextExtent(caption)

        tab_height = measured_texty + 4
        tab_width = measured_textx + tab_height + 5

        if close_button_state != AUI_BUTTON_STATE_HIDDEN:
            tab_width += self._active_close_bmp.GetWidth()

        if self._agwFlags & AUI_NB_TAB_FIXED_WIDTH:
            tab_width = self._fixed_tab_width

        if control is not None:
            controlW, controlH = control.GetSize()
            tab_width += controlW + 4

        x_extent = tab_width - (tab_height/2) - 1

        return (tab_width, tab_height), x_extent


    def DrawButton(self, dc, wnd, in_rect, button, orientation):
        """
        Draws a button on the tab or on the tab area, depending on the button identifier. 

        :param `dc`: a :class:`DC` device context;
        :param `wnd`: a :class:`Window` instance object;
        :param Rect `in_rect`: rectangle the tab should be confined to;
        :param `button`: an instance of the button class;
        :param integer `orientation`: the tab orientation.
        """

        bitmap_id, button_state = button.id, button.cur_state
        
        if bitmap_id == AUI_BUTTON_CLOSE:
            if button_state & AUI_BUTTON_STATE_DISABLED:
                bmp = self._disabled_close_bmp
            else:
                bmp = self._active_close_bmp

        elif bitmap_id == AUI_BUTTON_LEFT:
            if button_state & AUI_BUTTON_STATE_DISABLED:
                bmp = self._disabled_left_bmp
            else:
                bmp = self._active_left_bmp

        elif bitmap_id == AUI_BUTTON_RIGHT:
            if button_state & AUI_BUTTON_STATE_DISABLED:
                bmp = self._disabled_right_bmp
            else:
                bmp = self._active_right_bmp

        elif bitmap_id == AUI_BUTTON_WINDOWLIST:
            if button_state & AUI_BUTTON_STATE_DISABLED:
                bmp = self._disabled_windowlist_bmp
            else:
                bmp = self._active_windowlist_bmp

        else:
            if button_state & AUI_BUTTON_STATE_DISABLED:
                bmp = button.dis_bitmap
            else:
                bmp = button.bitmap
            
        if not bmp.IsOk():
            return

        rect = wx.Rect(*in_rect)

        if orientation == wx.LEFT:
        
            rect.SetX(in_rect.x)
            rect.SetY(((in_rect.y + in_rect.height)/2) - (bmp.GetHeight()/2))
            rect.SetWidth(bmp.GetWidth())
            rect.SetHeight(bmp.GetHeight())
        
        else:
        
            rect = wx.Rect(in_rect.x + in_rect.width - bmp.GetWidth(),
                           ((in_rect.y + in_rect.height)/2) - (bmp.GetHeight()/2),
                           bmp.GetWidth(), bmp.GetHeight())

        self.DrawButtons(dc, rect, bmp, wx.WHITE, button_state)

        out_rect = wx.Rect(*rect)
        return out_rect


    def ShowDropDown(self, wnd, pages, active_idx):
        """
        Shows the drop-down window menu on the tab area.

        :param `wnd`: a :class:`Window` derived window instance;
        :param list `pages`: the pages associated with the tabs;
        :param integer `active_idx`: the active tab index.
        """
        
        menuPopup = wx.Menu()
        useImages = self.GetAGWFlags() & AUI_NB_USE_IMAGES_DROPDOWN
        
        for i, page in enumerate(pages):

            if useImages:
                menuItem = wx.MenuItem(menuPopup, 1000+i, page.caption)
                if page.bitmap:
                    menuItem.SetBitmap(page.bitmap)

                menuPopup.AppendItem(menuItem)
                
            else:
                
                menuPopup.AppendCheckItem(1000+i, page.caption)
                
            menuPopup.Enable(1000+i, page.enabled)
        
        if active_idx != -1 and not useImages:
            menuPopup.Check(1000+active_idx, True)
        
        # find out where to put the popup menu of window
        # items.  Subtract 100 for now to center the menu
        # a bit, until a better mechanism can be implemented
        pt = wx.GetMousePosition()
        pt = wnd.ScreenToClient(pt)
        
        if pt.x < 100:
            pt.x = 0
        else:
            pt.x -= 100

        # find out the screen coordinate at the bottom of the tab ctrl
        cli_rect = wnd.GetClientRect()
        pt.y = cli_rect.y + cli_rect.height

        cc = AuiCommandCapture()
        wnd.PushEventHandler(cc)
        wnd.PopupMenu(menuPopup, pt)
        command = cc.GetCommandId()
        wnd.PopEventHandler(True)

        if command >= 1000:
            return command-1000

        return -1


    def GetBestTabCtrlSize(self, wnd, pages, required_bmp_size):
        """
        Returns the best tab control size.

        :param `wnd`: a :class:`Window` instance object;
        :param list `pages`: the pages associated with the tabs;
        :param Size `required_bmp_size`: the size of the bitmap on the tabs.
        """
        
        dc = wx.ClientDC(wnd)
        dc.SetFont(self._measuring_font)
        s, x_extent = self.GetTabSize(dc, wnd, "ABCDEFGHIj", wx.NullBitmap, True,
                                      AUI_BUTTON_STATE_HIDDEN, None)

        max_y = s[1]

        for page in pages:
            if page.control:
                controlW, controlH = page.control.GetSize()
                max_y = max(max_y, controlH+4)
                
            textx, texty, dummy = dc.GetMultiLineTextExtent(page.caption)
            max_y = max(max_y, texty)
        
        return max_y + 3


    def SetNormalFont(self, font):
        """
        Sets the normal font for drawing tab labels.

        :param Font `font`: the new font to use to draw tab labels in their normal, un-selected state.
        """
        
        self._normal_font = font


    def SetSelectedFont(self, font):
        """
        Sets the selected tab font for drawing tab labels.

        :param Font `font`: the new font to use to draw tab labels in their selected state.
        """
        
        self._selected_font = font


    def SetMeasuringFont(self, font):
        """
        Sets the font for calculating text measurements.

        :param Font `font`: the new font to use to measure tab labels text extents.
        """
        
        self._measuring_font = font


    def GetNormalFont(self):
        """ Returns the normal font for drawing tab labels. """

        return self._normal_font


    def GetSelectedFont(self):
        """ Returns the selected tab font for drawing tab labels. """

        return self._selected_font


    def GetMeasuringFont(self):
        """ Returns the font for calculating text measurements. """

        return self._measuring_font


    def SetCustomButton(self, bitmap_id, button_state, bmp):
        """
        Sets a custom bitmap for the close, left, right and window list buttons.
        
        :param integer `bitmap_id`: the button identifier;
        :param integer `button_state`: the button state;
        :param Bitmap `bmp`: the custom bitmap to use for the button.
        """
        
        if bitmap_id == AUI_BUTTON_CLOSE:
            if button_state == AUI_BUTTON_STATE_NORMAL:
                self._active_close_bmp = bmp
                self._hover_close_bmp = self._active_close_bmp
                self._pressed_close_bmp = self._active_close_bmp
                self._disabled_close_bmp = self._active_close_bmp
                    
            elif button_state == AUI_BUTTON_STATE_HOVER:
                self._hover_close_bmp = bmp
            elif button_state == AUI_BUTTON_STATE_PRESSED:
                self._pressed_close_bmp = bmp
            else:
                self._disabled_close_bmp = bmp

        elif bitmap_id == AUI_BUTTON_LEFT:
            if button_state & AUI_BUTTON_STATE_DISABLED:
                self._disabled_left_bmp = bmp
            else:
                self._active_left_bmp = bmp

        elif bitmap_id == AUI_BUTTON_RIGHT:
            if button_state & AUI_BUTTON_STATE_DISABLED:
                self._disabled_right_bmp = bmp
            else:
                self._active_right_bmp = bmp

        elif bitmap_id == AUI_BUTTON_WINDOWLIST:
            if button_state & AUI_BUTTON_STATE_DISABLED:
                self._disabled_windowlist_bmp = bmp
            else:
                self._active_windowlist_bmp = bmp
    

class VC71TabArt(AuiDefaultTabArt):
    """ A class to draw tabs using the Visual Studio 2003 (VC71) style. """

    def __init__(self):
        """ Default class constructor. """

        AuiDefaultTabArt.__init__(self)


    def Clone(self):
        """ Clones the art object. """

        art = type(self)()
        art.SetNormalFont(self.GetNormalFont())
        art.SetSelectedFont(self.GetSelectedFont())
        art.SetMeasuringFont(self.GetMeasuringFont())

        art = CopyAttributes(art, self)
        return art


    def DrawTab(self, dc, wnd, page, in_rect, close_button_state, paint_control=False):
        """
        Draws a single tab.

        :param `dc`: a :class:`DC` device context;
        :param `wnd`: a :class:`Window` instance object;
        :param `page`: the tab control page associated with the tab;
        :param Rect `in_rect`: rectangle the tab should be confined to;
        :param integer `close_button_state`: the state of the close button on the tab;
        :param bool `paint_control`: whether to draw the control inside a tab (if any) on a :class:`MemoryDC`.
        """
        
        # Visual studio 7.1 style
        # This code is based on the renderer included in FlatNotebook

        # figure out the size of the tab

        control = page.control
        tab_size, x_extent = self.GetTabSize(dc, wnd, page.caption, page.bitmap, page.active,
                                             close_button_state, control)

        tab_height = self._tab_ctrl_height - 3
        tab_width = tab_size[0]
        tab_x = in_rect.x
        tab_y = in_rect.y + in_rect.height - tab_height
        clip_width = tab_width

        if tab_x + clip_width > in_rect.x + in_rect.width - 4:
            clip_width = (in_rect.x + in_rect.width) - tab_x - 4
            
        dc.SetClippingRegion(tab_x, tab_y, clip_width + 1, tab_height - 3)
        agwFlags = self.GetAGWFlags()

        if agwFlags & AUI_NB_BOTTOM:
            tab_y -= 1

        dc.SetPen((page.active and [wx.Pen(wx.SystemSettings.GetColour(wx.SYS_COLOUR_3DHIGHLIGHT))] or \
                   [wx.Pen(wx.SystemSettings.GetColour(wx.SYS_COLOUR_3DSHADOW))])[0])
        dc.SetBrush((page.active and [wx.Brush(wx.SystemSettings.GetColour(wx.SYS_COLOUR_3DFACE))] or \
                     [wx.TRANSPARENT_BRUSH])[0])

        if page.active:

            tabH = tab_height - 2
            dc.DrawRectangle(tab_x, tab_y, tab_width, tabH)

            rightLineY1 = (agwFlags & AUI_NB_BOTTOM and [vertical_border_padding - 2] or \
                           [vertical_border_padding - 1])[0]
            rightLineY2 = tabH + 3
            dc.SetPen(wx.Pen(wx.SystemSettings.GetColour(wx.SYS_COLOUR_3DSHADOW)))
            dc.DrawLine(tab_x + tab_width - 1, rightLineY1 + 1, tab_x + tab_width - 1, rightLineY2)
            
            if agwFlags & AUI_NB_BOTTOM:
                dc.DrawLine(tab_x + 1, rightLineY2 - 3 , tab_x + tab_width - 1, rightLineY2 - 3)
                
            dc.SetPen(wx.Pen(wx.SystemSettings.GetColour(wx.SYS_COLOUR_3DDKSHADOW)))
            dc.DrawLine(tab_x + tab_width, rightLineY1, tab_x + tab_width, rightLineY2)
            
            if agwFlags & AUI_NB_BOTTOM:
                dc.DrawLine(tab_x, rightLineY2 - 2, tab_x + tab_width, rightLineY2 - 2)

        else:
        
            # We dont draw a rectangle for non selected tabs, but only
            # vertical line on the right
            blackLineY1 = (agwFlags & AUI_NB_BOTTOM and [vertical_border_padding + 2] or \
                           [vertical_border_padding + 1])[0]
            blackLineY2 = tab_height - 5
            dc.DrawLine(tab_x + tab_width, blackLineY1, tab_x + tab_width, blackLineY2)
        
        border_points = [0, 0]
        
        if agwFlags & AUI_NB_BOTTOM:
        
            border_points[0] = wx.Point(tab_x, tab_y)
            border_points[1] = wx.Point(tab_x, tab_y + tab_height - 6)
        
        else: # if (agwFlags & AUI_NB_TOP)
        
            border_points[0] = wx.Point(tab_x, tab_y + tab_height - 4)
            border_points[1] = wx.Point(tab_x, tab_y + 2)

        drawn_tab_yoff = border_points[1].y
        drawn_tab_height = border_points[0].y - border_points[1].y

        text_offset = tab_x + 8
        close_button_width = 0

        if close_button_state != AUI_BUTTON_STATE_HIDDEN:
            close_button_width = self._active_close_bmp.GetWidth()
            if agwFlags & AUI_NB_CLOSE_ON_TAB_LEFT:
                text_offset += close_button_width - 5

        if not page.enabled:
            dc.SetTextForeground(wx.SystemSettings.GetColour(wx.SYS_COLOUR_GRAYTEXT))
            pagebitmap = page.dis_bitmap
        else:
            dc.SetTextForeground(page.text_colour)
            pagebitmap = page.bitmap

        shift = 0
        if agwFlags & AUI_NB_BOTTOM:
            shift = (page.active and [1] or [2])[0]
            
        bitmap_offset = 0
        if pagebitmap.IsOk():
            bitmap_offset = tab_x + 8
            if agwFlags & AUI_NB_CLOSE_ON_TAB_LEFT and close_button_width:
                bitmap_offset += close_button_width - 5

            # draw bitmap
            dc.DrawBitmap(pagebitmap, bitmap_offset,
                          drawn_tab_yoff + (drawn_tab_height/2) - (pagebitmap.GetHeight()/2) + shift,
                          True)

            text_offset = bitmap_offset + pagebitmap.GetWidth()
            text_offset += 3 # bitmap padding
        
        else:
            if agwFlags & AUI_NB_CLOSE_ON_TAB_LEFT == 0 or not close_button_width:
                text_offset = tab_x + 8
        
        # if the caption is empty, measure some temporary text
        caption = page.caption

        if caption == "":
            caption = "Xj"

        if page.active:
            dc.SetFont(self._selected_font)
            textx, texty, dummy = dc.GetMultiLineTextExtent(caption)
        else:
            dc.SetFont(self._normal_font)
            textx, texty, dummy = dc.GetMultiLineTextExtent(caption)

        draw_text = ChopText(dc, caption, tab_width - (text_offset-tab_x) - close_button_width)

        ypos = drawn_tab_yoff + (drawn_tab_height)/2 - (texty/2) - 1 + shift

        offset_focus = text_offset
        
        if control is not None:
            if control.GetPosition() != wx.Point(text_offset+1, ypos):
                control.SetPosition(wx.Point(text_offset+1, ypos))

            if not control.IsShown():
                control.Show()

            if paint_control:
                bmp = TakeScreenShot(control.GetScreenRect())
                dc.DrawBitmap(bmp, text_offset+1, ypos, True)
                
            controlW, controlH = control.GetSize()
            text_offset += controlW + 4
            textx += controlW + 4

        # draw tab text
        rectx, recty, dummy = dc.GetMultiLineTextExtent(draw_text)
        dc.DrawLabel(draw_text, wx.Rect(text_offset, ypos, rectx, recty))

        out_button_rect = wx.Rect()

        # draw focus rectangle
        if (agwFlags & AUI_NB_NO_TAB_FOCUS) == 0:
            self.DrawFocusRectangle(dc, page, wnd, draw_text, offset_focus, bitmap_offset, drawn_tab_yoff+shift,
                                    drawn_tab_height+shift, rectx, recty)
                
        # draw 'x' on tab (if enabled)
        if close_button_state != AUI_BUTTON_STATE_HIDDEN:
            close_button_width = self._active_close_bmp.GetWidth()

            bmp = self._disabled_close_bmp

            if close_button_state == AUI_BUTTON_STATE_HOVER:
                bmp = self._hover_close_bmp
            elif close_button_state == AUI_BUTTON_STATE_PRESSED:
                bmp = self._pressed_close_bmp

            if agwFlags & AUI_NB_CLOSE_ON_TAB_LEFT:
                rect = wx.Rect(tab_x + 4,
                               drawn_tab_yoff + (drawn_tab_height / 2) - (bmp.GetHeight() / 2) + shift,
                               close_button_width, tab_height)
            else:
                rect = wx.Rect(tab_x + tab_width - close_button_width - 3,
                               drawn_tab_yoff + (drawn_tab_height / 2) - (bmp.GetHeight() / 2) + shift,
                               close_button_width, tab_height)

            # Indent the button if it is pressed down:
            rect = IndentPressedBitmap(rect, close_button_state)
            dc.DrawBitmap(bmp, rect.x, rect.y, True)

            out_button_rect = rect        

        out_tab_rect = wx.Rect(tab_x, tab_y, tab_width, tab_height)
        dc.DestroyClippingRegion()

        return out_tab_rect, out_button_rect, x_extent


class FF2TabArt(AuiDefaultTabArt):
    """ A class to draw tabs using the Firefox 2 (FF2) style. """

    def __init__(self):
        """ Default class constructor. """

        AuiDefaultTabArt.__init__(self)


    def Clone(self):
        """ Clones the art object. """

        art = type(self)()
        art.SetNormalFont(self.GetNormalFont())
        art.SetSelectedFont(self.GetSelectedFont())
        art.SetMeasuringFont(self.GetMeasuringFont())

        art = CopyAttributes(art, self)
        return art


    def GetTabSize(self, dc, wnd, caption, bitmap, active, close_button_state, control):
        """
        Returns the tab size for the given caption, bitmap and button state.

        :param `dc`: a :class:`DC` device context;
        :param `wnd`: a :class:`Window` instance object;
        :param string `caption`: the tab text caption;
        :param Bitmap `bitmap`: the bitmap displayed on the tab;
        :param bool `active`: whether the tab is selected or not;
        :param integer `close_button_state`: the state of the close button on the tab;
        :param Window `control`: a :class:`Window` instance inside a tab (or ``None``).
        """
        
        tab_size, x_extent = AuiDefaultTabArt.GetTabSize(self, dc, wnd, caption, bitmap,
                                                         active, close_button_state, control)

        tab_width, tab_height = tab_size        

        # add some vertical padding
        tab_height += 2
        
        return (tab_width, tab_height), x_extent


    def DrawTab(self, dc, wnd, page, in_rect, close_button_state, paint_control=False):
        """
        Draws a single tab.

        :param `dc`: a :class:`DC` device context;
        :param `wnd`: a :class:`Window` instance object;
        :param `page`: the tab control page associated with the tab;
        :param Rect `in_rect`: rectangle the tab should be confined to;
        :param integer `close_button_state`: the state of the close button on the tab;
        :param bool `paint_control`: whether to draw the control inside a tab (if any) on a :class:`MemoryDC`.
        """
        
        # Firefox 2 style

        control = page.control

        # figure out the size of the tab
        tab_size, x_extent = self.GetTabSize(dc, wnd, page.caption, page.bitmap,
                                             page.active, close_button_state, control)

        tab_height = self._tab_ctrl_height - 2
        tab_width = tab_size[0]
        tab_x = in_rect.x
        tab_y = in_rect.y + in_rect.height - tab_height

        clip_width = tab_width
        if tab_x + clip_width > in_rect.x + in_rect.width - 4:
            clip_width = (in_rect.x + in_rect.width) - tab_x - 4
            
        dc.SetClippingRegion(tab_x, tab_y, clip_width + 1, tab_height - 3)

        tabPoints = [wx.Point() for i in xrange(7)]
        
        adjust = 0
        if not page.active:
            adjust = 1

        agwFlags = self.GetAGWFlags()
        
        tabPoints[0].x = tab_x + 3
        tabPoints[0].y = (agwFlags & AUI_NB_BOTTOM and [3] or [tab_height - 2])[0]

        tabPoints[1].x = tabPoints[0].x
        tabPoints[1].y = (agwFlags & AUI_NB_BOTTOM and [tab_height - (vertical_border_padding + 2) - adjust] or \
                          [(vertical_border_padding + 2) + adjust])[0]

        tabPoints[2].x = tabPoints[1].x+2
        tabPoints[2].y = (agwFlags & AUI_NB_BOTTOM and [tab_height - vertical_border_padding - adjust] or \
                          [vertical_border_padding + adjust])[0]

        tabPoints[3].x = tab_x + tab_width - 2
        tabPoints[3].y = tabPoints[2].y

        tabPoints[4].x = tabPoints[3].x + 2
        tabPoints[4].y = tabPoints[1].y

        tabPoints[5].x = tabPoints[4].x
        tabPoints[5].y = tabPoints[0].y

        tabPoints[6].x = tabPoints[0].x
        tabPoints[6].y = tabPoints[0].y

        rr = wx.RectPP(tabPoints[2], tabPoints[5])
        self.DrawTabBackground(dc, rr, page.active, (agwFlags & AUI_NB_BOTTOM) == 0)

        dc.SetBrush(wx.TRANSPARENT_BRUSH)
        dc.SetPen(wx.Pen(wx.SystemSettings_GetColour(wx.SYS_COLOUR_BTNSHADOW)))

        # Draw the tab as rounded rectangle
        dc.DrawPolygon(tabPoints)

        if page.active:
            dc.DrawLine(tabPoints[0].x + 1, tabPoints[0].y, tabPoints[5].x , tabPoints[0].y)
        
        drawn_tab_yoff = tabPoints[1].y
        drawn_tab_height = tabPoints[0].y - tabPoints[2].y

        text_offset = tab_x + 8
        close_button_width = 0
        if close_button_state != AUI_BUTTON_STATE_HIDDEN:
            close_button_width = self._active_close_bmp.GetWidth()
            if agwFlags & AUI_NB_CLOSE_ON_TAB_LEFT:
                text_offset += close_button_width - 4

        if not page.enabled:
            dc.SetTextForeground(wx.SystemSettings.GetColour(wx.SYS_COLOUR_GRAYTEXT))
            pagebitmap = page.dis_bitmap
        else:
            dc.SetTextForeground(page.text_colour)
            pagebitmap = page.bitmap

        shift = -1
        if agwFlags & AUI_NB_BOTTOM:
            shift = 2
        
        bitmap_offset = 0
        if pagebitmap.IsOk():
            bitmap_offset = tab_x + 8
            if agwFlags & AUI_NB_CLOSE_ON_TAB_LEFT and close_button_width:
                bitmap_offset += close_button_width - 4

            # draw bitmap
            dc.DrawBitmap(pagebitmap, bitmap_offset,
                          drawn_tab_yoff + (drawn_tab_height/2) - (pagebitmap.GetHeight()/2) + shift,
                          True)

            text_offset = bitmap_offset + pagebitmap.GetWidth()
            text_offset += 3 # bitmap padding
        
        else:
        
            if agwFlags & AUI_NB_CLOSE_ON_TAB_LEFT == 0 or not close_button_width:
                text_offset = tab_x + 8
        
        # if the caption is empty, measure some temporary text
        caption = page.caption
        if caption == "":
            caption = "Xj"

        if page.active:
            dc.SetFont(self._selected_font)
            textx, texty, dummy = dc.GetMultiLineTextExtent(caption)
        else:
            dc.SetFont(self._normal_font)
            textx, texty, dummy = dc.GetMultiLineTextExtent(caption)

        if agwFlags & AUI_NB_CLOSE_ON_TAB_LEFT:
            draw_text = ChopText(dc, caption, tab_width - (text_offset-tab_x) - close_button_width + 1)
        else:
            draw_text = ChopText(dc, caption, tab_width - (text_offset-tab_x) - close_button_width)

        ypos = drawn_tab_yoff + drawn_tab_height/2 - texty/2 - 1 + shift

        offset_focus = text_offset
        
        if control is not None:
            if control.GetPosition() != wx.Point(text_offset+1, ypos):
                control.SetPosition(wx.Point(text_offset+1, ypos))

            if not control.IsShown():
                control.Show()

            if paint_control:
                bmp = TakeScreenShot(control.GetScreenRect())
                dc.DrawBitmap(bmp, text_offset+1, ypos, True)
                
            controlW, controlH = control.GetSize()
            text_offset += controlW + 4
            textx += controlW + 4
        
        # draw tab text
        rectx, recty, dummy = dc.GetMultiLineTextExtent(draw_text)
        dc.DrawLabel(draw_text, wx.Rect(text_offset, ypos, rectx, recty))

        # draw focus rectangle
        if (agwFlags & AUI_NB_NO_TAB_FOCUS) == 0:
            self.DrawFocusRectangle(dc, page, wnd, draw_text, offset_focus, bitmap_offset, drawn_tab_yoff+shift,
                                    drawn_tab_height, rectx, recty)
        
        out_button_rect = wx.Rect()
        # draw 'x' on tab (if enabled)
        if close_button_state != AUI_BUTTON_STATE_HIDDEN:
        
            close_button_width = self._active_close_bmp.GetWidth()
            bmp = self._disabled_close_bmp

            if close_button_state == AUI_BUTTON_STATE_HOVER:
                bmp = self._hover_close_bmp
            elif close_button_state == AUI_BUTTON_STATE_PRESSED:
                bmp = self._pressed_close_bmp

            if agwFlags & AUI_NB_CLOSE_ON_TAB_LEFT:
                rect = wx.Rect(tab_x + 5,
                               drawn_tab_yoff + (drawn_tab_height / 2) - (bmp.GetHeight() / 2) + shift,
                               close_button_width, tab_height)
            else:
                rect = wx.Rect(tab_x + tab_width - close_button_width - 3,
                               drawn_tab_yoff + (drawn_tab_height / 2) - (bmp.GetHeight() / 2) + shift,
                               close_button_width, tab_height)

            # Indent the button if it is pressed down:
            rect = IndentPressedBitmap(rect, close_button_state)
            dc.DrawBitmap(bmp, rect.x, rect.y, True)
            out_button_rect = rect
        
        out_tab_rect = wx.Rect(tab_x, tab_y, tab_width, tab_height)
        dc.DestroyClippingRegion()
    
        return out_tab_rect, out_button_rect, x_extent


    def DrawTabBackground(self, dc, rect, focus, upperTabs):
        """
        Draws the tab background for the Firefox 2 style.
        This is more consistent with :class:`~lib.agw.flatnotebook.FlatNotebook` than before.

        :param `dc`: a :class:`DC` device context;
        :param Rect `rect`: rectangle the tab should be confined to;
        :param bool `focus`: whether the tab has focus or not;
        :param bool `upperTabs`: whether the style is ``AUI_NB_TOP`` or ``AUI_NB_BOTTOM``.
        """

        # Define the rounded rectangle base on the given rect
        # we need an array of 9 points for it
        regPts = [wx.Point() for indx in xrange(9)]

        if focus:
            if upperTabs:
                leftPt = wx.Point(rect.x, rect.y + (rect.height / 10)*8)
                rightPt = wx.Point(rect.x + rect.width - 2, rect.y + (rect.height / 10)*8)
            else:
                leftPt = wx.Point(rect.x, rect.y + (rect.height / 10)*5)
                rightPt = wx.Point(rect.x + rect.width - 2, rect.y + (rect.height / 10)*5)
        else:
            leftPt = wx.Point(rect.x, rect.y + (rect.height / 2))
            rightPt = wx.Point(rect.x + rect.width - 2, rect.y + (rect.height / 2))

        # Define the top region
        top = wx.RectPP(rect.GetTopLeft(), rightPt)
        bottom = wx.RectPP(leftPt, rect.GetBottomRight())

        topStartColour = wx.WHITE

        if not focus:
            topStartColour = LightColour(wx.SystemSettings_GetColour(wx.SYS_COLOUR_3DFACE), 50)

        topEndColour = wx.SystemSettings_GetColour(wx.SYS_COLOUR_3DFACE)
        bottomStartColour = topEndColour
        bottomEndColour = topEndColour

        # Incase we use bottom tabs, switch the colours
        if upperTabs:
            if focus:
                dc.GradientFillLinear(top, topStartColour, topEndColour, wx.SOUTH)
                dc.GradientFillLinear(bottom, bottomStartColour, bottomEndColour, wx.SOUTH)
            else:
                dc.GradientFillLinear(top, topEndColour , topStartColour, wx.SOUTH)
                dc.GradientFillLinear(bottom, bottomStartColour, bottomEndColour, wx.SOUTH)

        else:
            if focus:
                dc.GradientFillLinear(bottom, topEndColour, bottomEndColour, wx.SOUTH)
                dc.GradientFillLinear(top, topStartColour, topStartColour, wx.SOUTH)
            else:
                dc.GradientFillLinear(bottom, bottomStartColour, bottomEndColour, wx.SOUTH)
                dc.GradientFillLinear(top, topEndColour, topStartColour, wx.SOUTH)
        
        dc.SetBrush(wx.TRANSPARENT_BRUSH)


class VC8TabArt(AuiDefaultTabArt):
    """ A class to draw tabs using the Visual Studio 2005 (VC8) style. """

    def __init__(self):
        """ Default class constructor. """

        AuiDefaultTabArt.__init__(self)


    def Clone(self):
        """ Clones the art object. """

        art = type(self)()
        art.SetNormalFont(self.GetNormalFont())
        art.SetSelectedFont(self.GetSelectedFont())
        art.SetMeasuringFont(self.GetMeasuringFont())

        art = CopyAttributes(art, self)
        return art


    def SetSizingInfo(self, tab_ctrl_size, tab_count, minMaxTabWidth):
        """
        Sets the tab sizing information.
        
        :param Size `tab_ctrl_size`: the size of the tab control area;
        :param integer `tab_count`: the number of tabs;
        :param tuple `minMaxTabWidth`: a tuple containing the minimum and maximum tab widths
         to be used when the ``AUI_NB_TAB_FIXED_WIDTH`` style is active.
        """
        
        AuiDefaultTabArt.SetSizingInfo(self, tab_ctrl_size, tab_count, minMaxTabWidth)

        minTabWidth, maxTabWidth = minMaxTabWidth
        if minTabWidth > -1:
            self._fixed_tab_width = max(self._fixed_tab_width, minTabWidth)
        if maxTabWidth > -1:
            self._fixed_tab_width = min(self._fixed_tab_width, maxTabWidth)
        
        self._fixed_tab_width -= 5


    def GetTabSize(self, dc, wnd, caption, bitmap, active, close_button_state, control=None):
        """
        Returns the tab size for the given caption, bitmap and button state.

        :param `dc`: a :class:`DC` device context;
        :param `wnd`: a :class:`Window` instance object;
        :param string `caption`: the tab text caption;
        :param Bitmap `bitmap`: the bitmap displayed on the tab;
        :param bool `active`: whether the tab is selected or not;
        :param integer `close_button_state`: the state of the close button on the tab;
        :param Window `control`: a :class:`Window` instance inside a tab (or ``None``).
        """
        
        tab_size, x_extent = AuiDefaultTabArt.GetTabSize(self, dc, wnd, caption, bitmap,
                                                         active, close_button_state, control)

        tab_width, tab_height = tab_size        

        # add some padding
        tab_width += 10

        if not bitmap.IsOk():
            tab_width += 5
            
        tab_height += 2

        return (tab_width, tab_height), x_extent


    def DrawTab(self, dc, wnd, page, in_rect, close_button_state, paint_control=False):
        """
        Draws a single tab.

        :param `dc`: a :class:`DC` device context;
        :param `wnd`: a :class:`Window` instance object;
        :param `page`: the tab control page associated with the tab;
        :param Rect `in_rect`: rectangle the tab should be confined to;
        :param integer `close_button_state`: the state of the close button on the tab;
        :param bool `paint_control`: whether to draw the control inside a tab (if any) on a :class:`MemoryDC`.
        """
        
        # Visual Studio 8 style

        control = page.control

        # figure out the size of the tab
        tab_size, x_extent = self.GetTabSize(dc, wnd, page.caption, page.bitmap,
                                             page.active, close_button_state, control)

        tab_height = self._tab_ctrl_height - 1
        tab_width = tab_size[0]
        tab_x = in_rect.x
        tab_y = in_rect.y + in_rect.height - tab_height

        clip_width = tab_width + 3
        if tab_x + clip_width > in_rect.x + in_rect.width - 4:
            clip_width = (in_rect.x + in_rect.width) - tab_x - 4
        
        tabPoints = [wx.Point() for i in xrange(8)]

        # If we draw the first tab or the active tab, 
        # we draw a full tab, else we draw a truncated tab
        #
        #             X(2)                  X(3)
        #        X(1)                            X(4)
        #                                          
        #                                           X(5)
        #                                           
        # X(0),(7)                                  X(6)
        #
        #

        adjust = 0
        if not page.active:
            adjust = 1

        agwFlags = self.GetAGWFlags()
        tabPoints[0].x = (agwFlags & AUI_NB_BOTTOM and [tab_x] or [tab_x + adjust])[0]
        tabPoints[0].y = (agwFlags & AUI_NB_BOTTOM and [2] or [tab_height - 3])[0]

        tabPoints[1].x = tabPoints[0].x + tab_height - vertical_border_padding - 3 - adjust
        tabPoints[1].y = (agwFlags & AUI_NB_BOTTOM and [tab_height - (vertical_border_padding+2)] or \
                          [(vertical_border_padding+2)])[0]

        tabPoints[2].x = tabPoints[1].x + 4
        tabPoints[2].y = (agwFlags & AUI_NB_BOTTOM and [tab_height - vertical_border_padding] or \
                          [vertical_border_padding])[0]

        tabPoints[3].x = tabPoints[2].x + tab_width - tab_height + vertical_border_padding
        tabPoints[3].y = (agwFlags & AUI_NB_BOTTOM and [tab_height - vertical_border_padding] or \
                          [vertical_border_padding])[0]

        tabPoints[4].x = tabPoints[3].x + 1
        tabPoints[4].y = (agwFlags & AUI_NB_BOTTOM and [tabPoints[3].y - 1] or [tabPoints[3].y + 1])[0]

        tabPoints[5].x = tabPoints[4].x + 1
        tabPoints[5].y = (agwFlags & AUI_NB_BOTTOM and [(tabPoints[4].y - 1)] or [tabPoints[4].y + 1])[0]

        tabPoints[6].x = tabPoints[2].x + tab_width - tab_height + 2 + vertical_border_padding
        tabPoints[6].y = tabPoints[0].y

        tabPoints[7].x = tabPoints[0].x
        tabPoints[7].y = tabPoints[0].y

        self.FillVC8GradientColour(dc, tabPoints, page.active)        

        dc.SetBrush(wx.TRANSPARENT_BRUSH)

        dc.SetPen(wx.Pen(wx.SystemSettings.GetColour(wx.SYS_COLOUR_BTNSHADOW)))
        dc.DrawPolygon(tabPoints)

        if page.active:
            # Delete the bottom line (or the upper one, incase we use wxBOTTOM) 
            dc.SetPen(wx.WHITE_PEN)
            dc.DrawLine(tabPoints[0].x, tabPoints[0].y, tabPoints[6].x, tabPoints[6].y)

        dc.SetClippingRegion(tab_x, tab_y, clip_width + 2, tab_height - 3)            

        drawn_tab_yoff = tabPoints[1].y
        drawn_tab_height = tabPoints[0].y - tabPoints[2].y

        text_offset = tab_x + 20
        close_button_width = 0
        if close_button_state != AUI_BUTTON_STATE_HIDDEN:
            close_button_width = self._active_close_bmp.GetWidth()
            if agwFlags & AUI_NB_CLOSE_ON_TAB_LEFT:
                text_offset += close_button_width

        if not page.enabled:
            dc.SetTextForeground(wx.SystemSettings.GetColour(wx.SYS_COLOUR_GRAYTEXT))
            pagebitmap = page.dis_bitmap
        else:
            dc.SetTextForeground(page.text_colour)
            pagebitmap = page.bitmap

        shift = 0
        if agwFlags & AUI_NB_BOTTOM:
            shift = (page.active and [1] or [2])[0]
        
        bitmap_offset = 0
        if pagebitmap.IsOk():
            bitmap_offset = tab_x + 20
            if agwFlags & AUI_NB_CLOSE_ON_TAB_LEFT and close_button_width:
                bitmap_offset += close_button_width

            # draw bitmap
            dc.DrawBitmap(pagebitmap, bitmap_offset,
                          drawn_tab_yoff + (drawn_tab_height/2) - (pagebitmap.GetHeight()/2) + shift,
                          True)

            text_offset = bitmap_offset + pagebitmap.GetWidth()
            text_offset += 3 # bitmap padding
        
        else:
            if agwFlags & AUI_NB_CLOSE_ON_TAB_LEFT == 0 or not close_button_width:
                text_offset = tab_x + tab_height
        
        # if the caption is empty, measure some temporary text
        caption = page.caption
        if caption == "":
            caption = "Xj"

        if page.active:
            dc.SetFont(self._selected_font)
            textx, texty, dummy = dc.GetMultiLineTextExtent(caption)
        else:
            dc.SetFont(self._normal_font)
            textx, texty, dummy = dc.GetMultiLineTextExtent(caption)

        if agwFlags & AUI_NB_CLOSE_ON_TAB_LEFT:
            draw_text = ChopText(dc, caption, tab_width - (text_offset-tab_x))
        else:
            draw_text = ChopText(dc, caption, tab_width - (text_offset-tab_x) - close_button_width)

        ypos = drawn_tab_yoff + drawn_tab_height/2 - texty/2 - 1 + shift

        offset_focus = text_offset
        
        if control is not None:
            if control.GetPosition() != wx.Point(text_offset+1, ypos):
                control.SetPosition(wx.Point(text_offset+1, ypos))

            if not control.IsShown():
                control.Show()

            if paint_control:
                bmp = TakeScreenShot(control.GetScreenRect())
                dc.DrawBitmap(bmp, text_offset+1, ypos, True)
                
            controlW, controlH = control.GetSize()
            text_offset += controlW + 4
            textx += controlW + 4

        # draw tab text
        rectx, recty, dummy = dc.GetMultiLineTextExtent(draw_text)
        dc.DrawLabel(draw_text, wx.Rect(text_offset, ypos, rectx, recty))
        
        # draw focus rectangle
        if (agwFlags & AUI_NB_NO_TAB_FOCUS) == 0:
            self.DrawFocusRectangle(dc, page, wnd, draw_text, offset_focus, bitmap_offset, drawn_tab_yoff+shift,
                                    drawn_tab_height+shift, rectx, recty)
        
        out_button_rect = wx.Rect()
        # draw 'x' on tab (if enabled)
        if close_button_state != AUI_BUTTON_STATE_HIDDEN:
        
            close_button_width = self._active_close_bmp.GetWidth()
            bmp = self._disabled_close_bmp

            if close_button_state == AUI_BUTTON_STATE_HOVER:
                bmp = self._hover_close_bmp
            elif close_button_state == AUI_BUTTON_STATE_PRESSED:
                bmp = self._pressed_close_bmp
                
            if page.active:
                xpos = tab_x + tab_width - close_button_width + 3
            else:
                xpos = tab_x + tab_width - close_button_width - 5

            if agwFlags & AUI_NB_CLOSE_ON_TAB_LEFT:
                rect = wx.Rect(tab_x + 20,
                               drawn_tab_yoff + (drawn_tab_height / 2) - (bmp.GetHeight() / 2) + shift,
                               close_button_width, tab_height)
            else:
                rect = wx.Rect(xpos,
                               drawn_tab_yoff + (drawn_tab_height / 2) - (bmp.GetHeight() / 2) + shift,
                               close_button_width, tab_height)

            # Indent the button if it is pressed down:
            rect = IndentPressedBitmap(rect, close_button_state)
            dc.DrawBitmap(bmp, rect.x, rect.y, True)
            out_button_rect = rect
        
        out_tab_rect = wx.Rect(tab_x, tab_y, x_extent, tab_height)
        dc.DestroyClippingRegion()

        return out_tab_rect, out_button_rect, x_extent
        

    def FillVC8GradientColour(self, dc, tabPoints, active):
        """
        Fills the tab with the Visual Studio 2005 gradient background.

        :param `dc`: a :class:`DC` device context;
        :param list `tabPoints`: a list of :class:`Point` objects describing the tab shape;
        :param bool `active`: whether the tab is selected or not.
        """

        xList = [pt.x for pt in tabPoints]
        yList = [pt.y for pt in tabPoints]
        
        minx, maxx = min(xList), max(xList)
        miny, maxy = min(yList), max(yList)

        rect = wx.Rect(minx, maxy, maxx-minx, miny-maxy+1)        
        region = wx.RegionFromPoints(tabPoints)

        if self._buttonRect.width > 0:
            buttonRegion = wx.Region(*self._buttonRect)
            region.XorRegion(buttonRegion)
        
        dc.SetClippingRegionAsRegion(region)

        if active:
            bottom_colour = top_colour = wx.WHITE
        else:
            bottom_colour = StepColour(self._base_colour, 90)
            top_colour = StepColour(self._base_colour, 170)

        dc.GradientFillLinear(rect, top_colour, bottom_colour, wx.SOUTH)
        dc.DestroyClippingRegion()
        

class ChromeTabArt(AuiDefaultTabArt):
    """
    A class to draw tabs using the Google Chrome browser style.
    It uses custom bitmap to render the tabs, so that the look and feel is as close
    as possible to the Chrome style.
    """

    def __init__(self):
        """ Default class constructor. """

        AuiDefaultTabArt.__init__(self)

        self.SetBitmaps(mirror=False)
        
        closeBmp = tab_close.GetBitmap()
        closeHBmp = tab_close_h.GetBitmap()
        closePBmp = tab_close_p.GetBitmap()

        self.SetCustomButton(AUI_BUTTON_CLOSE, AUI_BUTTON_STATE_NORMAL, closeBmp)
        self.SetCustomButton(AUI_BUTTON_CLOSE, AUI_BUTTON_STATE_HOVER, closeHBmp)
        self.SetCustomButton(AUI_BUTTON_CLOSE, AUI_BUTTON_STATE_PRESSED, closePBmp)
        

    def SetAGWFlags(self, agwFlags):
        """
        Sets the tab art flags.

        :param integer `agwFlags`: a combination of the following values:

         ==================================== ==================================
         Flag name                            Description
         ==================================== ==================================
         ``AUI_NB_TOP``                       With this style, tabs are drawn along the top of the notebook
         ``AUI_NB_LEFT``                      With this style, tabs are drawn along the left of the notebook. Not implemented yet.
         ``AUI_NB_RIGHT``                     With this style, tabs are drawn along the right of the notebook. Not implemented yet.
         ``AUI_NB_BOTTOM``                    With this style, tabs are drawn along the bottom of the notebook
         ``AUI_NB_TAB_SPLIT``                 Allows the tab control to be split by dragging a tab
         ``AUI_NB_TAB_MOVE``                  Allows a tab to be moved horizontally by dragging
         ``AUI_NB_TAB_EXTERNAL_MOVE``         Allows a tab to be moved to another tab control
         ``AUI_NB_TAB_FIXED_WIDTH``           With this style, all tabs have the same width
         ``AUI_NB_SCROLL_BUTTONS``            With this style, left and right scroll buttons are displayed
         ``AUI_NB_WINDOWLIST_BUTTON``         With this style, a drop-down list of windows is available
         ``AUI_NB_CLOSE_BUTTON``              With this style, a close button is available on the tab bar
         ``AUI_NB_CLOSE_ON_ACTIVE_TAB``       With this style, a close button is available on the active tab
         ``AUI_NB_CLOSE_ON_ALL_TABS``         With this style, a close button is available on all tabs
         ``AUI_NB_MIDDLE_CLICK_CLOSE``        Allows to close :class:`~lib.agw.aui.auibook.AuiNotebook` tabs by mouse middle button click
         ``AUI_NB_SUB_NOTEBOOK``              This style is used by :class:`~lib.agw.aui.framemanager.AuiManager` to create automatic AuiNotebooks
         ``AUI_NB_HIDE_ON_SINGLE_TAB``        Hides the tab window if only one tab is present
         ``AUI_NB_SMART_TABS``                Use Smart Tabbing, like ``Alt`` + ``Tab`` on Windows
         ``AUI_NB_USE_IMAGES_DROPDOWN``       Uses images on dropdown window list menu instead of check items
         ``AUI_NB_CLOSE_ON_TAB_LEFT``         Draws the tab close button on the left instead of on the right (a la Camino browser)
         ``AUI_NB_TAB_FLOAT``                 Allows the floating of single tabs. Known limitation: when the notebook is more or less full
                                              screen, tabs cannot be dragged far enough outside of the notebook to become floating pages
         ``AUI_NB_DRAW_DND_TAB``              Draws an image representation of a tab while dragging (on by default)
         ``AUI_NB_ORDER_BY_ACCESS``           Tab navigation order by last access time for the tabs
         ``AUI_NB_NO_TAB_FOCUS``              Don't draw tab focus rectangle
         ==================================== ==================================

        :note: Overridden from :class:`AuiDefaultTabArt`.
        """

        if agwFlags & AUI_NB_TOP:
            self.SetBitmaps(mirror=False)
        elif agwFlags & AUI_NB_BOTTOM:
            self.SetBitmaps(mirror=True)

        AuiDefaultTabArt.SetAGWFlags(self, agwFlags)            


    def SetBitmaps(self, mirror):
        """
        Assigns the tab custom bitmaps

        :param bool `mirror`: whether to vertically mirror the bitmap or not.
        """

        bmps = [tab_active_left.GetBitmap(), tab_active_center.GetBitmap(),
                tab_active_right.GetBitmap(), tab_inactive_left.GetBitmap(),
                tab_inactive_center.GetBitmap(), tab_inactive_right.GetBitmap()]

        if mirror:
            for indx, bmp in enumerate(bmps):
                img = bmp.ConvertToImage()
                img = img.Mirror(horizontally=False)
                bmps[indx] = img.ConvertToBitmap()
                
        self._leftActiveBmp = bmps[0]
        self._centerActiveBmp = bmps[1]
        self._rightActiveBmp = bmps[2]
        self._leftInactiveBmp = bmps[3]
        self._centerInactiveBmp = bmps[4]
        self._rightInactiveBmp = bmps[5]
            

    def Clone(self):
        """ Clones the art object. """

        art = type(self)()
        art.SetNormalFont(self.GetNormalFont())
        art.SetSelectedFont(self.GetSelectedFont())
        art.SetMeasuringFont(self.GetMeasuringFont())

        art = CopyAttributes(art, self)
        return art


    def SetSizingInfo(self, tab_ctrl_size, tab_count, minMaxTabWidth):
        """
        Sets the tab sizing information.
        
        :param Size `tab_ctrl_size`: the size of the tab control area;
        :param integer `tab_count`: the number of tabs;
        :param tuple `minMaxTabWidth`: a tuple containing the minimum and maximum tab widths
         to be used when the ``AUI_NB_TAB_FIXED_WIDTH`` style is active.
        """
        
        AuiDefaultTabArt.SetSizingInfo(self, tab_ctrl_size, tab_count, minMaxTabWidth)

        minTabWidth, maxTabWidth = minMaxTabWidth
        if minTabWidth > -1:
            self._fixed_tab_width = max(self._fixed_tab_width, minTabWidth)
        if maxTabWidth > -1:
            self._fixed_tab_width = min(self._fixed_tab_width, maxTabWidth)

        self._fixed_tab_width -= 5


    def GetTabSize(self, dc, wnd, caption, bitmap, active, close_button_state, control=None):
        """
        Returns the tab size for the given caption, bitmap and button state.

        :param `dc`: a :class:`DC` device context;
        :param `wnd`: a :class:`Window` instance object;
        :param string `caption`: the tab text caption;
        :param Bitmap `bitmap`: the bitmap displayed on the tab;
        :param bool `active`: whether the tab is selected or not;
        :param integer `close_button_state`: the state of the close button on the tab;
        :param Window `control`: a :class:`Window` instance inside a tab (or ``None``).
        """
        
        tab_size, x_extent = AuiDefaultTabArt.GetTabSize(self, dc, wnd, caption, bitmap,
                                                         active, close_button_state, control)

        tab_width, tab_height = tab_size        

        # add some padding
        tab_width += self._leftActiveBmp.GetWidth()
        tab_height += 2

        tab_height = max(tab_height, self._centerActiveBmp.GetHeight())        

        return (tab_width, tab_height), x_extent


    def DrawTab(self, dc, wnd, page, in_rect, close_button_state, paint_control=False):
        """
        Draws a single tab.

        :param `dc`: a :class:`DC` device context;
        :param `wnd`: a :class:`Window` instance object;
        :param `page`: the tab control page associated with the tab;
        :param Rect `in_rect`: rectangle the tab should be confined to;
        :param integer `close_button_state`: the state of the close button on the tab;
        :param bool `paint_control`: whether to draw the control inside a tab (if any) on a :class:`MemoryDC`.
        """
        
        # Chrome tab style

        control = page.control
        # figure out the size of the tab
        tab_size, x_extent = self.GetTabSize(dc, wnd, page.caption, page.bitmap, page.active,
                                             close_button_state, control)

        agwFlags = self.GetAGWFlags()
        
        tab_height = self._tab_ctrl_height - 1
        tab_width = tab_size[0]
        tab_x = in_rect.x
        tab_y = in_rect.y + in_rect.height - tab_height
        clip_width = tab_width

        if tab_x + clip_width > in_rect.x + in_rect.width - 4:
            clip_width = (in_rect.x + in_rect.width) - tab_x - 4
            
        dc.SetClippingRegion(tab_x, tab_y, clip_width + 1, tab_height - 3)
        drawn_tab_yoff = 1

        if page.active:
            left = self._leftActiveBmp
            center = self._centerActiveBmp
            right = self._rightActiveBmp
        else:
            left = self._leftInactiveBmp
            center = self._centerInactiveBmp
            right = self._rightInactiveBmp

        dc.DrawBitmap(left, tab_x, tab_y)
        leftw = left.GetWidth()
        centerw = center.GetWidth()
        rightw = right.GetWidth()

        available = tab_x + tab_width - rightw
        posx = tab_x + leftw
        
        while 1:
            if posx >= available:
                break
            dc.DrawBitmap(center, posx, tab_y)
            posx += centerw

        dc.DrawBitmap(right, posx, tab_y)

        drawn_tab_height = center.GetHeight()
        text_offset = tab_x + leftw
        
        close_button_width = 0
        if close_button_state != AUI_BUTTON_STATE_HIDDEN:
            close_button_width = self._active_close_bmp.GetWidth()
            if agwFlags & AUI_NB_CLOSE_ON_TAB_LEFT:
                text_offset += close_button_width

        if not page.enabled:
            dc.SetTextForeground(wx.SystemSettings.GetColour(wx.SYS_COLOUR_GRAYTEXT))
            pagebitmap = page.dis_bitmap
        else:
            dc.SetTextForeground(page.text_colour)
            pagebitmap = page.bitmap
        
        bitmap_offset = 0
        if pagebitmap.IsOk():
            bitmap_offset = tab_x + leftw
            if agwFlags & AUI_NB_CLOSE_ON_TAB_LEFT and close_button_width:
                bitmap_offset += close_button_width

            # draw bitmap
            dc.DrawBitmap(pagebitmap, bitmap_offset,
                          drawn_tab_yoff + (drawn_tab_height/2) - (pagebitmap.GetHeight()/2),
                          True)

            text_offset = bitmap_offset + pagebitmap.GetWidth()
            text_offset += 3 # bitmap padding
        
        else:
        
            if agwFlags & AUI_NB_CLOSE_ON_TAB_LEFT == 0 or not close_button_width:
                text_offset = tab_x + leftw
        
        # if the caption is empty, measure some temporary text
        caption = page.caption
        if caption == "":
            caption = "Xj"

        if page.active:
            dc.SetFont(self._selected_font)
            textx, texty, dummy = dc.GetMultiLineTextExtent(caption)
        else:
            dc.SetFont(self._normal_font)
            textx, texty, dummy = dc.GetMultiLineTextExtent(caption)

        if agwFlags & AUI_NB_CLOSE_ON_TAB_LEFT:
            draw_text = ChopText(dc, caption, tab_width - (text_offset-tab_x) - leftw)
        else:
            draw_text = ChopText(dc, caption, tab_width - (text_offset-tab_x) - close_button_width - leftw)

        ypos = drawn_tab_yoff + drawn_tab_height/2 - texty/2 - 1

        if control is not None:
            if control.GetPosition() != wx.Point(text_offset+1, ypos):
                control.SetPosition(wx.Point(text_offset+1, ypos))

            if not control.IsShown():
                control.Show()

            if paint_control:
                bmp = TakeScreenShot(control.GetScreenRect())
                dc.DrawBitmap(bmp, text_offset+1, ypos, True)
                
            controlW, controlH = control.GetSize()
            text_offset += controlW + 4

        # draw tab text
        rectx, recty, dummy = dc.GetMultiLineTextExtent(draw_text)
        dc.DrawLabel(draw_text, wx.Rect(text_offset, ypos, rectx, recty))
                
        out_button_rect = wx.Rect()
        # draw 'x' on tab (if enabled)
        if close_button_state != AUI_BUTTON_STATE_HIDDEN:
        
            close_button_width = self._active_close_bmp.GetWidth()
            bmp = self._disabled_close_bmp

            if close_button_state == AUI_BUTTON_STATE_HOVER:
                bmp = self._hover_close_bmp
            elif close_button_state == AUI_BUTTON_STATE_PRESSED:
                bmp = self._pressed_close_bmp

            if agwFlags & AUI_NB_CLOSE_ON_TAB_LEFT:
                rect = wx.Rect(tab_x + leftw - 2,
                               drawn_tab_yoff + (drawn_tab_height / 2) - (bmp.GetHeight() / 2) + 1,
                               close_button_width, tab_height)
            else:
                rect = wx.Rect(tab_x + tab_width - close_button_width - rightw + 2,
                               drawn_tab_yoff + (drawn_tab_height / 2) - (bmp.GetHeight() / 2) + 1,
                               close_button_width, tab_height)

            if agwFlags & AUI_NB_BOTTOM:
                rect.y -= 1
                
            # Indent the button if it is pressed down:
            rect = IndentPressedBitmap(rect, close_button_state)
            dc.DrawBitmap(bmp, rect.x, rect.y, True)
            out_button_rect = rect
            
        out_tab_rect = wx.Rect(tab_x, tab_y, tab_width, tab_height)
        dc.DestroyClippingRegion()

        return out_tab_rect, out_button_rect, x_extent        



########NEW FILE########
__FILENAME__ = tabmdi
__author__ = "Andrea Gavana <andrea.gavana@gmail.com>"
__date__ = "31 March 2009"


import wx

import auibook
from aui_constants import *

_ = wx.GetTranslation

#-----------------------------------------------------------------------------
# AuiMDIParentFrame
#-----------------------------------------------------------------------------

class AuiMDIParentFrame(wx.Frame):

    def __init__(self, parent, id=wx.ID_ANY, title="", pos=wx.DefaultPosition,
                 size=wx.DefaultSize, style=wx.DEFAULT_FRAME_STYLE|wx.VSCROLL|wx.HSCROLL,
                 name="AuiMDIParentFrame"):

        wx.Frame.__init__(self, parent, id, title, pos, size, style, name=name)
        self.Init()

        self.Bind(wx.EVT_MENU, self.DoHandleMenu, id=wx.ID_ANY)

        # this style can be used to prevent a window from having the standard MDI
        # "Window" menu
        if not style & wx.FRAME_NO_WINDOW_MENU:
        
            self._pWindowMenu = wx.Menu()
            self._pWindowMenu.Append(wxWINDOWCLOSE,    _("Cl&ose"))
            self._pWindowMenu.Append(wxWINDOWCLOSEALL, _("Close All"))
            self._pWindowMenu.AppendSeparator()
            self._pWindowMenu.Append(wxWINDOWNEXT,     _("&Next"))
            self._pWindowMenu.Append(wxWINDOWPREV,     _("&Previous"))
    
        self._pClientWindow = self.OnCreateClient()


    def SetArtProvider(self, provider):

        if self._pClientWindow:
            self._pClientWindow.SetArtProvider(provider)
    

    def GetArtProvider(self):

        if not self._pClientWindow:
            return None

        return self._pClientWindow.GetArtProvider()


    def GetNotebook(self):

        return self._pClientWindow


    def SetWindowMenu(self, pMenu):

        # Replace the window menu from the currently loaded menu bar.
        pMenuBar = self.GetMenuBar()

        if self._pWindowMenu:
            self.RemoveWindowMenu(pMenuBar)
            del self._pWindowMenu
            self._pWindowMenu = None

        if pMenu:
            self._pWindowMenu = pMenu
            self.AddWindowMenu(pMenuBar)
        

    def GetWindowMenu(self):

        return self._pWindowMenu
    

    def SetMenuBar(self, pMenuBar):

        # Remove the Window menu from the old menu bar
        self.RemoveWindowMenu(self.GetMenuBar())

        # Add the Window menu to the new menu bar.
        self.AddWindowMenu(pMenuBar)

        wx.Frame.SetMenuBar(self, pMenuBar)


    def SetChildMenuBar(self, pChild):

        if not pChild:
        
            # No Child, set Our menu bar back.
            if self._pMyMenuBar:
                self.SetMenuBar(self._pMyMenuBar)
            else:
                self.SetMenuBar(self.GetMenuBar())

            # Make sure we know our menu bar is in use
            self._pMyMenuBar = None
        
        else:
        
            if pChild.GetMenuBar() == None:
                return

            # Do we need to save the current bar?
            if self._pMyMenuBar == None:
                self._pMyMenuBar = self.GetMenuBar()

            self.SetMenuBar(pChild.GetMenuBar())
    

    def ProcessEvent(self, event):

        # stops the same event being processed repeatedly
        if self._pLastEvt == event:
            return False
        
        self._pLastEvt = event

        # let the active child (if any) process the event first.
        res = False
        if self._pActiveChild and event.IsCommandEvent() and \
           event.GetEventObject() != self._pClientWindow and \
           event.GetEventType() not in [wx.wxEVT_ACTIVATE, wx.wxEVT_SET_FOCUS,
                                        wx.wxEVT_KILL_FOCUS, wx.wxEVT_CHILD_FOCUS,
                                        wx.wxEVT_COMMAND_SET_FOCUS, wx.wxEVT_COMMAND_KILL_FOCUS]:
        
            res = self._pActiveChild.GetEventHandler().ProcessEvent(event)
        
        if not res:
        
            # if the event was not handled this frame will handle it,
            # which is why we need the protection code at the beginning
            # of this method
            res = self.GetEventHandler().ProcessEvent(event)
        
        self._pLastEvt = None

        return res


    def GetActiveChild(self):

        return self._pActiveChild


    def SetActiveChild(self, pChildFrame):

        self._pActiveChild = pChildFrame


    def GetClientWindow(self):

        return self._pClientWindow


    def OnCreateClient(self):

        return AuiMDIClientWindow(self)


    def ActivateNext(self):

        if self._pClientWindow and self._pClientWindow.GetSelection() != wx.NOT_FOUND:
        
            active = self._pClientWindow.GetSelection() + 1
            if active >= self._pClientWindow.GetPageCount():
                active = 0

            self._pClientWindow.SetSelection(active)
        

    def ActivatePrevious(self):

        if self._pClientWindow and self._pClientWindow.GetSelection() != wx.NOT_FOUND:
        
            active = self._pClientWindow.GetSelection() - 1
            if active < 0:
                active = self._pClientWindow.GetPageCount() - 1

            self._pClientWindow.SetSelection(active)
    

    def Init(self):

        self._pLastEvt = None

        self._pClientWindow = None
        self._pActiveChild = None
        self._pWindowMenu = None
        self._pMyMenuBar = None


    def RemoveWindowMenu(self, pMenuBar):

        if pMenuBar and self._pWindowMenu:
        
            # Remove old window menu
            pos = pMenuBar.FindMenu(_("&Window"))
            if pos != wx.NOT_FOUND:            
                pMenuBar.Remove(pos)
            

    def AddWindowMenu(self, pMenuBar):

        if pMenuBar and self._pWindowMenu:
        
            pos = pMenuBar.FindMenu(wx.GetStockLabel(wx.ID_HELP, wx.STOCK_NOFLAGS))
            if pos == wx.NOT_FOUND:
                pMenuBar.Append(self._pWindowMenu, _("&Window"))
            else:
                pMenuBar.Insert(pos, self._pWindowMenu, _("&Window"))
    

    def DoHandleMenu(self, event):

        evId = event.GetId()
        
        if evId == wxWINDOWCLOSE:
            if self._pActiveChild:
                self._pActiveChild.Close()

        elif evId == wxWINDOWCLOSEALL:
            
            while self._pActiveChild:            
                if not self._pActiveChild.Close():
                    return # failure
                
        elif evId == wxWINDOWNEXT:
            self.ActivateNext()

        elif evId == wxWINDOWPREV:
            self.ActivatePrevious()

        else:
            event.Skip()

    
    def Tile(self, orient=wx.HORIZONTAL):

        client_window = self.GetClientWindow()
        if not client_window:
            raise Exception("Missing MDI Client Window")

        cur_idx = client_window.GetSelection()
        if cur_idx == -1:
            return

        if orient == wx.VERTICAL:
        
            client_window.Split(cur_idx, wx.LEFT)
        
        elif orient == wx.HORIZONTAL:
        
            client_window.Split(cur_idx, wx.TOP)
    

#-----------------------------------------------------------------------------
# AuiMDIChildFrame
#-----------------------------------------------------------------------------

class AuiMDIChildFrame(wx.PyPanel):

    def __init__(self, parent, id=wx.ID_ANY, title="", pos=wx.DefaultPosition,
                 size=wx.DefaultSize, style=wx.DEFAULT_FRAME_STYLE, name="AuiMDIChildFrame"):

        pClientWindow = parent.GetClientWindow()
        if pClientWindow is None:
            raise Exception("Missing MDI client window.")

        self.Init()
        
        # see comment in constructor
        if style & wx.MINIMIZE:
            self._activate_on_create = False

        cli_size = pClientWindow.GetClientSize()

        # create the window off-screen to prevent flicker
        wx.PyPanel.__init__(self, pClientWindow, id, wx.Point(cli_size.x+1, cli_size.y+1),
                            size, wx.NO_BORDER, name=name)

        self.SetBackgroundStyle(wx.BG_STYLE_CUSTOM)
        self.Show(False)
        self.SetMDIParentFrame(parent)

        # this is the currently active child
        parent.SetActiveChild(self)
        self._title = title

        pClientWindow.AddPage(self, title, self._activate_on_create)
        pClientWindow.Refresh()

        self.Bind(wx.EVT_MENU_HIGHLIGHT_ALL, self.OnMenuHighlight)
        self.Bind(wx.EVT_ACTIVATE, self.OnActivate)
        self.Bind(wx.EVT_CLOSE, self.OnCloseWindow)


    def Init(self):

        # There are two ways to create an tabbed mdi child fram without
        # making it the active document.  Either Show(False) can be called
        # before Create() (as is customary on some ports with wxFrame-type
        # windows), or wx.MINIMIZE can be passed in the style flags.  Note that
        # AuiMDIChildFrame is not really derived from wxFrame, as MDIChildFrame
        # is, but those are the expected symantics.  No style flag is passed
        # onto the panel underneath.

        self._activate_on_create = True

        self._pMDIParentFrame = None
        self._pMenuBar = None
        
        self._mdi_currect = None
        self._mdi_newrect = wx.Rect()
        self._icon = None
        self._icon_bundle = None


    def Destroy(self):

        pParentFrame = self.GetMDIParentFrame()
        if not pParentFrame:
            raise Exception("Missing MDI Parent Frame")

        pClientWindow = pParentFrame.GetClientWindow()
        if not pClientWindow:
            raise Exception("Missing MDI Client Window")

        if pParentFrame.GetActiveChild() == self:
        
            # deactivate ourself
            event = wx.ActivateEvent(wx.wxEVT_ACTIVATE, False, self.GetId())
            event.SetEventObject(self)
            self.GetEventHandler().ProcessEvent(event)

            pParentFrame.SetActiveChild(None)
            pParentFrame.SetChildMenuBar(None)
        
        for pos in xrange(pClientWindow.GetPageCount()):
            if pClientWindow.GetPage(pos) == self:
                return pClientWindow.DeletePage(pos)

        return False


    def SetMenuBar(self, menu_bar):

        pOldMenuBar = self._pMenuBar
        self._pMenuBar = menu_bar

        if self._pMenuBar:
        
            pParentFrame = self.GetMDIParentFrame()
            if not pParentFrame:
                raise Exception("Missing MDI Parent Frame")

            self._pMenuBar.Reparent(pParentFrame)
            if pParentFrame.GetActiveChild() == self:
            
                # replace current menu bars
                if pOldMenuBar:
                    pParentFrame.SetChildMenuBar(None)
                    
                pParentFrame.SetChildMenuBar(self)
            

    def GetMenuBar(self):

        return self._pMenuBar


    def SetTitle(self, title):

        self._title = title

        pParentFrame = self.GetMDIParentFrame()
        if not pParentFrame:
            raise Exception("Missing MDI Parent Frame")
        
        pClientWindow = pParentFrame.GetClientWindow()
        if pClientWindow is not None:
        
            for pos in xrange(pClientWindow.GetPageCount()):
                if pClientWindow.GetPage(pos) == self:
                    pClientWindow.SetPageText(pos, self._title)
                    break


    def GetTitle(self):

        return self._title


    def SetIcons(self, icons):

        # get icon with the system icon size
        self.SetIcon(icons.GetIcon(-1))
        self._icon_bundle = icons


    def GetIcons(self):

        return self._icon_bundle


    def SetIcon(self, icon):

        pParentFrame = self.GetMDIParentFrame()
        if not pParentFrame:
            raise Exception("Missing MDI Parent Frame")

        self._icon = icon

        bmp = wx.BitmapFromIcon(self._icon)

        pClientWindow = pParentFrame.GetClientWindow()
        if pClientWindow is not None:
            idx = pClientWindow.GetPageIndex(self)
            if idx != -1:
                pClientWindow.SetPageBitmap(idx, bmp)
        

    def GetIcon(self):

        return self._icon


    def Activate(self):

        pParentFrame = self.GetMDIParentFrame()
        if not pParentFrame:
            raise Exception("Missing MDI Parent Frame")
        
        pClientWindow = pParentFrame.GetClientWindow()
        if pClientWindow is not None:
        
            for pos in xrange(pClientWindow.GetPageCount()):
                if pClientWindow.GetPage(pos) == self:
                    pClientWindow.SetSelection(pos)
                    break
            

    def OnMenuHighlight(self, event):

        if self._pMDIParentFrame:
    
            # we don't have any help text for this item,
            # but may be the MDI frame does?
            self._pMDIParentFrame.OnMenuHighlight(event)


    def OnActivate(self, event):

        # do nothing
        pass


    def OnCloseWindow(self, event):

        pParentFrame = self.GetMDIParentFrame()
        if pParentFrame:
            if pParentFrame.GetActiveChild() == self:
            
                pParentFrame.SetActiveChild(None)
                pParentFrame.SetChildMenuBar(None)
            
            pClientWindow = pParentFrame.GetClientWindow()
            idx = pClientWindow.GetPageIndex(self)
            
            if idx != wx.NOT_FOUND:
                pClientWindow.RemovePage(idx)

        self.Destroy()


    def SetMDIParentFrame(self, parentFrame):

        self._pMDIParentFrame = parentFrame


    def GetMDIParentFrame(self):

        return self._pMDIParentFrame


    def CreateStatusBar(self, number=1, style=1, winid=1, name=""):
        
        return None


    def GetStatusBar(self):

        return None
    

    def SetStatusText(self, text, number=0):

        pass

    
    def SetStatusWidths(self, widths_field):

        pass
    

    # no toolbar bars
    def CreateToolBar(self, style=1, winid=-1, name=""):
        
        return None

    
    def GetToolBar(self):

        return None
    

    # no maximize etc
    def Maximize(self, maximize=True):

        pass


    def Restore(self):
    
        pass

    
    def Iconize(self, iconize=True):

        pass

    
    def IsMaximized(self):

        return True

    
    def IsIconized(self):

        return False

    
    def ShowFullScreen(self, show=True, style=0):

        return False

    
    def IsFullScreen(self):

        return False        


    def IsTopLevel(self):

        return False


    # renamed from Show().
    def ActivateOnCreate(self, activate_on_create):

        self._activate_on_create = activate_on_create
        return True

    
    def Show(self, show=True):

        wx.PyPanel.Show(self, show)


    def ApplyMDIChildFrameRect(self):

        if self._mdi_currect != self._mdi_newrect:
            self.SetDimensions(*self._mdi_newrect)
            self._mdi_currect = wx.Rect(*self._mdi_newrect)


#-----------------------------------------------------------------------------
# AuiMDIClientWindow
#-----------------------------------------------------------------------------

class AuiMDIClientWindow(auibook.AuiNotebook):

    def __init__(self, parent, agwStyle=0):

        auibook.AuiNotebook.__init__(self, parent, wx.ID_ANY, wx.Point(0, 0), wx.Size(100, 100),
                                     agwStyle=AUI_NB_DEFAULT_STYLE|wx.NO_BORDER)

        caption_icon_size = wx.Size(wx.SystemSettings.GetMetric(wx.SYS_SMALLICON_X),
                                    wx.SystemSettings.GetMetric(wx.SYS_SMALLICON_Y))
        self.SetUniformBitmapSize(caption_icon_size)

        bkcolour = wx.SystemSettings.GetColour(wx.SYS_COLOUR_APPWORKSPACE)
        self.SetOwnBackgroundColour(bkcolour)

        self._mgr.GetArtProvider().SetColour(AUI_DOCKART_BACKGROUND_COLOUR, bkcolour)

        self.Bind(auibook.EVT_AUINOTEBOOK_PAGE_CHANGED, self.OnPageChanged)
        self.Bind(auibook.EVT_AUINOTEBOOK_PAGE_CLOSE, self.OnPageClose)
        self.Bind(wx.EVT_SIZE, self.OnSize)


    def SetSelection(self, nPage):

        return auibook.AuiNotebook.SetSelection(self, nPage)


    def PageChanged(self, old_selection, new_selection):

        # don't do anything if the page doesn't actually change
        if old_selection == new_selection:
            return

        # notify old active child that it has been deactivated
        if old_selection != -1 and old_selection < self.GetPageCount():
        
            old_child = self.GetPage(old_selection)
            if not old_child:
                raise Exception("AuiMDIClientWindow.PageChanged - null page pointer")

            event = wx.ActivateEvent(wx.wxEVT_ACTIVATE, False, old_child.GetId())
            event.SetEventObject(old_child)
            old_child.GetEventHandler().ProcessEvent(event)
        
        # notify new active child that it has been activated
        if new_selection != -1:
        
            active_child = self.GetPage(new_selection)
            if not active_child:
                raise Exception("AuiMDIClientWindow.PageChanged - null page pointer")

            event = wx.ActivateEvent(wx.wxEVT_ACTIVATE, True, active_child.GetId())
            event.SetEventObject(active_child)
            active_child.GetEventHandler().ProcessEvent(event)

            if active_child.GetMDIParentFrame():
                active_child.GetMDIParentFrame().SetActiveChild(active_child)
                active_child.GetMDIParentFrame().SetChildMenuBar(active_child)


    def OnPageClose(self, event):

        wnd = self.GetPage(event.GetSelection())
        wnd.Close()

        # regardless of the result of wnd.Close(), we've
        # already taken care of the close operations, so
        # suppress further processing
        event.Veto()


    def OnPageChanged(self, event):

        self.PageChanged(event.GetOldSelection(), event.GetSelection())


    def OnSize(self, event):

        auibook.AuiNotebook.OnSize(self, event)

        for pos in xrange(self.GetPageCount()):
            self.GetPage(pos).ApplyMDIChildFrameRect()

########NEW FILE########
__FILENAME__ = wx_widget
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
import wx

from enaml.colors import parse_color

from .wx_layout_request import wxEvtLayoutRequested
from .wx_object import WxObject


def wx_parse_color(color):
    """ Convert a color string into a wxColour.

    Parameters
    ----------
    color : string
        A CSS3 color string to convert to a wxColour.

    Returns
    -------
    result : wxColour
        The wxColour for the given color string

    """
    rgba = parse_color(color)
    if rgba is None:
        wx_color = wx.NullColour
    else:
        r, g, b, a = rgba
        i = int
        wx_color = wx.Colour(i(r * 255), i(g * 255), i(b * 255), i(a * 255))
    return wx_color


class WxWidget(WxObject):
    """ A Wx implementation of an Enaml WidgetComponent.

    """
    #: An attribute which indicates whether or not the background
    #: color of the widget has been changed.
    _bgcolor_changed = False

    #: An attribute which indicates whether or not the foreground
    #: color of the widget has been changed.
    _fgcolor_changed = False

    #--------------------------------------------------------------------------
    # Setup Methods
    #--------------------------------------------------------------------------
    def create_widget(self, parent, tree):
        """ Creates the underlying wx.Panel widget.

        """
        return wx.Panel(parent)

    def create(self, tree):
        """ Create and initialize the widget control.

        """
        super(WxWidget, self).create(tree)
        self.set_minimum_size(tree['minimum_size'])
        self.set_maximum_size(tree['maximum_size'])
        self.set_bgcolor(tree['bgcolor'])
        self.set_fgcolor(tree['fgcolor'])
        self.set_font(tree['font'])
        self.set_enabled(tree['enabled'])
        self.set_visible(tree['visible'])
        self.set_show_focus_rect(tree['show_focus_rect'])
        self.set_tool_tip(tree['tool_tip'])
        self.set_status_tip(tree['status_tip'])

    #--------------------------------------------------------------------------
    # Public API
    #--------------------------------------------------------------------------
    def update_geometry(self):
        """ Notify the layout system that this widget has changed.

        This method should be called when the geometry of the widget has
        changed and the layout system should update the layout. This will
        post a wxEvtLayoutRequested event to the parent of this widget.

        """
        widget = self.widget()
        if widget:
            parent = widget.GetParent()
            if parent:
                event = wxEvtLayoutRequested(widget.GetId())
                wx.PostEvent(parent, event)

    #--------------------------------------------------------------------------
    # Message Handlers
    #--------------------------------------------------------------------------
    def on_action_set_enabled(self, content):
        """ Handle the 'set_enabled' action from the Enaml widget.

        """
        self.set_enabled(content['enabled'])

    def on_action_set_visible(self, content):
        """ Handle the 'set_visible' action from the Enaml widget.

        """
        self.set_visible(content['visible'])

    def on_action_set_bgcolor(self, content):
        """ Handle the 'set_bgcolor' action from the Enaml widget.

        """
        self.set_bgcolor(content['bgcolor'])

    def on_action_set_fgcolor(self, content):
        """ Handle the 'set_fgcolor' action from the Enaml widget.

        """
        self.set_fgcolor(content['fgcolor'])

    def on_action_set_font(self, content):
        """ Handle the 'set_font' action from the Enaml widget.

        """
        self.set_font(content['font'])

    def on_action_set_minimum_size(self, content):
        """ Handle the 'set_minimum_size' action from the Enaml widget.

        """
        self.set_minimum_size(content['minimum_size'])

    def on_action_set_maximum_size(self, content):
        """ Handle the 'set_maximum_size' action from the Enaml widget.

        """
        self.set_maximum_size(content['maximum_size'])

    def on_action_set_show_focus_rect(self, content):
        """ Handle the 'set_show_focus_rect' action from the Enaml
        widget.

        """
        self.set_show_focus_rect(content['show_focus_rect'])

    def on_action_set_tool_tip(self, content):
        """ Handle the 'set_tool_tip' action from the Enaml widget.

        """
        self.set_tool_tip(content['tool_tip'])

    def on_action_set_status_tip(self, content):
        """ Handle the 'set_status_tip' action from the Enaml widget.

        """
        self.set_status_tip(content['status_tip'])

    #--------------------------------------------------------------------------
    # Widget Update Methods
    #--------------------------------------------------------------------------
    def set_minimum_size(self, min_size):
        """ Sets the minimum size on the underlying widget.

        Parameters
        ----------
        min_size : (int, int)
            The minimum size allowable for the widget. A value of
            (-1, -1) indicates the default min size.

        """
        self.widget().SetMinSize(wx.Size(*min_size))

    def set_maximum_size(self, max_size):
        """ Sets the maximum size on the underlying widget.

        Parameters
        ----------
        max_size : (int, int)
            The minimum size allowable for the widget. A value of
            (-1, -1) indicates the default max size.

        """
        self.widget().SetMaxSize(wx.Size(*max_size))

    def set_enabled(self, enabled):
        """ Set the enabled state on the underlying widget.

        Parameters
        ----------
        enabled : bool
            Whether or not the widget is enabled.

        """
        self.widget().Enable(enabled)

    def set_visible(self, visible):
        """ Set the visibility state on the underlying widget.

        Parameters
        ----------
        visible : bool
            Whether or not the widget is visible.

        """
        self.widget().Show(visible)

    def set_bgcolor(self, bgcolor):
        """ Set the background color on the underlying widget.

        Parameters
        ----------
        bgcolor : str
            The background color of the widget as a CSS color string.

        """
        if bgcolor or self._bgcolor_changed:
            wx_color = wx_parse_color(bgcolor)
            widget = self.widget()
            widget.SetBackgroundColour(wx_color)
            widget.Refresh()
            self._bgcolor_changed = True

    def set_fgcolor(self, fgcolor):
        """ Set the foreground color on the underlying widget.

        Parameters
        ----------
        fgcolor : str
            The foreground color of the widget as a CSS color string.

        """
        if fgcolor or self._fgcolor_changed:
            wx_color = wx_parse_color(fgcolor)
            widget = self.widget()
            widget.SetForegroundColour(wx_color)
            widget.Refresh()
            self._fgcolor_changed = True

    def set_font(self, font):
        """ Set the font on the underlying widget.

        Parameters
        ----------
        font : str
            The font for the widget as a CSS font string.

        """
        pass

    def set_show_focus_rect(self, show):
        """ Sets whether or not to show the focus rectangle around
        the widget.

        This is currently not supported on Wx.

        """
        pass

    def set_tool_tip(self, tool_tip):
        """ Set the tool tip of for this widget.

        """
        self.widget().SetToolTipString(tool_tip)

    def set_status_tip(self, status_tip):
        """ Set the status tip of for this widget.

        """
        # Status tips are not currently supported on Wx
        pass


########NEW FILE########
__FILENAME__ = wx_widget_registry
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from collections import defaultdict


class WxWidgetRegistry(object):
    """ A class for registering Wx widget factories.

    This is a process-widget registry class. Interaction is done through
    the two classmethods `register` and `lookup`.

    """
    #: Private storage for the widget factories.
    _groups = defaultdict(dict)

    @classmethod
    def register(cls, name, factory, group, strict=False):
        """ Registery a widget factory.

        Parameters
        ----------
        name : str
            The name of the Enaml widget class which is implemented
            by the class returned by the given factory.

        factory : callable
            A callable which takes no arguments and returns the class
            which implements the widget.

        group : str
            The widget group with which this factory is associated.

        strict : bool, optional
            If True, attempting to register a factory for a widget
            which is already registered will raise a ValueError.
            The default is False.

        """
        thisgroup = cls._groups[group]
        if strict and name in thisgroup:
            msg = ('Factory already registered for the `%s` widget in the '
                   '`%s` widget group.')
            raise ValueError(msg % (name, group))
        thisgroup[name] = factory

    @classmethod
    def lookup(cls, name, groups):
        """ Lookup a widget factory.

        Parameters
        ----------
        name : str
            The name of the Enaml widget for which to lookup a factory.

        groups : list of str
            The list of groups to check for a matching factory. The
            groups are checked in order with the first match being
            returned. If no match is found, None will be returned.

        """
        thesegroups = cls._groups
        for group in groups:
            if group in thesegroups:
                thisgroup = thesegroups[group]
                if name in thisgroup:
                    return thisgroup[name]


########NEW FILE########
__FILENAME__ = wx_window
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
import wx

from .wx_action import wxAction
from .wx_container import WxContainer
from .wx_layout_request import EVT_COMMAND_LAYOUT_REQUESTED
from .wx_single_widget_sizer import wxSingleWidgetSizer
from .wx_widget import WxWidget


class wxCustomWindow(wx.Frame):
    """ A custom wxFrame which manages a central widget.

    The window layout computes the min/max size of the window based
    on its central widget, unless the user explicitly changes them.

    """
    def __init__(self, *args, **kwargs):
        """ Initialize a wxCustomWindow.

        Parameters
        ----------
        *args, **kwargs
            The positional and keyword arguments needed to initialize
            a wxFrame.

        """
        super(wxCustomWindow, self).__init__(*args, **kwargs)
        self._central_widget = None
        self.SetSizer(wxSingleWidgetSizer())
        self.Bind(wx.EVT_MENU, self.OnMenu)
        self.Bind(wx.EVT_CLOSE, self.OnClose)

    #--------------------------------------------------------------------------
    # Event Handlers
    #--------------------------------------------------------------------------
    def OnMenu(self, event):
        """ The event handler for the EVT_MENU event.

        This event handler will be called when an action is triggered
        in a Menu or a ToolBar.

        """
        action = wxAction.FindById(event.GetId())
        if action is not None:
            if action.IsCheckable():
                action.SetChecked(event.Checked())
            action.Trigger()

    def OnClose(self, event):
        """ The event handler for the EVT_CLOSE event.

        This event handler prevents the frame from being destroyed on
        close. Instead it just sets the visibility to False.

        """
        self.Hide()

    #--------------------------------------------------------------------------
    # Public API
    #--------------------------------------------------------------------------
    def UpdateClientSizeHints(self):
        """ Update the client size hints for the window.

        This will update the min and max sizes for the window according
        to the current window state. This method is called automatically
        when the central widget is changed.

        """
        sizer = self.GetSizer()
        min_w, min_h = self.ClientToWindowSize(sizer.CalcMin())
        max_w, max_h= self.ClientToWindowSize(sizer.CalcMax())
        self.SetSizeHints(min_w, min_h, max_w, max_h)
        cur_w, cur_h = self.GetSize()
        new_w = min(max_w, max(min_w, cur_w))
        new_h = min(max_h, max(min_h, cur_h))
        if cur_w != new_w or cur_h != new_h:
            self.SetSize(wx.Size(new_w, new_h))

    def GetCentralWidget(self):
        """ Returns the central widget for the window.

        Returns
        -------
        result : wxWindow or None
            The central widget of the window, or None if no widget
            was provided.

        """
        return self._central_widget

    def SetCentralWidget(self, widget):
        """ Set the central widget for this window.

        Parameters
        ----------
        widget : wxWindow
            The widget to use as the content of the window.

        """
        self._central_widget = widget
        self.GetSizer().Add(widget)
        self.UpdateClientSizeHints()


class WxWindow(WxWidget):
    """ A Wx implementation of an Enaml Window.

    """
    #--------------------------------------------------------------------------
    # Setup Methods
    #--------------------------------------------------------------------------
    def create_widget(self, parent, tree):
        """ Create the underlying wx.Frame widget.

        """
        return wxCustomWindow(parent)

    def create(self, tree):
        """ Create and initialize the window control.

        """
        super(WxWindow, self).create(tree)
        self.set_title(tree['title'])
        self.set_initial_size(tree['initial_size'])
        self.set_modality(tree['modality'])
        self.set_always_on_top(tree['always_on_top'])
        self.widget().Bind(wx.EVT_CLOSE, self.on_close)

    def init_layout(self):
        """ Perform layout initialization for the control.

        """
        super(WxWindow, self).init_layout()
        widget = self.widget()
        widget.SetCentralWidget(self.central_widget())
        widget.Bind(EVT_COMMAND_LAYOUT_REQUESTED, self.on_layout_requested)

    #--------------------------------------------------------------------------
    # Utility Methods
    #--------------------------------------------------------------------------
    def central_widget(self):
        """ Find and return the central widget child for this widget.

        Returns
        -------
        result : wxWindos or None
            The central widget defined for this widget, or None if one
            is not defined.

        """
        widget = None
        for child in self.children():
            if isinstance(child, WxContainer):
                widget = child.widget()
        return widget

    #--------------------------------------------------------------------------
    # Child Events
    #--------------------------------------------------------------------------
    def child_removed(self, child):
        """ Handle the child removed event for a QtWindow.

        """
        if isinstance(child, WxContainer):
            self.widget().SetCentralWidget(self.central_widget())

    def child_added(self, child):
        """ Handle the child added event for a QtWindow.

        """
        if isinstance(child, WxContainer):
            self.widget().SetCentralWidget(self.central_widget())

    #--------------------------------------------------------------------------
    # Event Handlers
    #--------------------------------------------------------------------------
    def on_close(self, event):
        """ The event handler for the EVT_CLOSE event.

        """
        event.Skip()
        # Make sure the frame is not modal when closing, or no other
        # windows will be unblocked.
        self.widget().MakeModal(False)
        self.send_action('closed', {})

    def on_layout_requested(self, event):
        """ Handle the layout request event from the central widget.

        """
        # wx likes to send events after the widget is destroyed.
        widget = self.widget()
        if widget is not None:
            widget.UpdateClientSizeHints()

    #--------------------------------------------------------------------------
    # Message Handlers
    #--------------------------------------------------------------------------
    def on_action_close(self, content):
        """ Handle the 'close' action from the Enaml widget.

        """
        self.close()

    def on_action_maximize(self, content):
        """ Handle the 'maximize' action from the Enaml widget.

        """
        self.maximize()

    def on_action_minimize(self, content):
        """ Handle the 'minimize' action from the Enaml widget.

        """
        self.minimize()

    def on_action_restore(self, content):
        """ Handle the 'restore' action from the Enaml widget.

        """
        self.restore()

    def on_action_send_to_front(self, content):
        """ Handle the 'send_to_front' action from the Enaml widget.

        """
        self.send_to_front()

    def on_action_send_to_back(self, content):
        """ Handle the 'send_to_back' action from the Enaml widget.

        """
        self.send_to_back()

    def on_action_set_icon_source(self, content):
        """ Handle the 'set_icon_source' action from the Enaml widget.

        """
        pass

    def on_action_set_title(self, content):
        """ Handle the 'set_title' action from the Enaml widget.

        """
        self.set_title(content['title'])

    def on_action_set_modality(self, content):
        """ Handle the 'set_modality' action from the Enaml widget.

        """
        self.set_modality(content['modality'])

    def on_action_set_always_on_top(self, content):
        """ Handle the 'set_always_on_top' action from the Enaml widget.

        """
        self.set_always_on_top(content['always_on_top'])

    #--------------------------------------------------------------------------
    # Widget Update Methods
    #--------------------------------------------------------------------------
    def close(self):
        """ Close the window

        """
        self.widget().Close()

    def maximize(self):
        """ Maximize the window.

        """
        self.widget().Maximize(True)

    def minimize(self):
        """ Minimize the window.

        """
        self.widget().Iconize(True)

    def restore(self):
        """ Restore the window after a minimize or maximize.

        """
        self.widget().Maximize(False)

    def send_to_front(self):
        """ Move the window to the front of all other windows.

        """
        self.widget().Raise()

    def send_to_back(self):
        """ Move the window to the back of all other windows.

        """
        self.widget().Lower()

    def set_title(self, title):
        """ Set the title of the window.

        """
        self.widget().SetTitle(title)

    def set_initial_size(self, size):
        """ Set the initial size of the window.

        """
        self.widget().SetSize(wx.Size(*size))

    def set_modality(self, modality):
        """ Set the modality of the window.

        """
        if modality == 'non_modal':
            self.widget().MakeModal(False)
        else:
            self.widget().MakeModal(True)

    def set_always_on_top(self, always_on_top):
        """ Set the stickyness of the window.

        """
        widget = self.widget()
        flags = widget.GetWindowStyleFlag()
        if always_on_top:
            flags |= wx.STAY_ON_TOP
        else:
            flags &= ~wx.STAY_ON_TOP
        widget.SetWindowStyleFlag(flags)

    def set_visible(self, visible):
        """ Set the visibility on the window.

        This is an overridden parent class method to set the visibility
        at a later time, so that layout can be initialized before the
        window is displayed.

        """
        # XXX this could be done better.
        wx.CallAfter(super(WxWindow, self).set_visible, visible)


########NEW FILE########
__FILENAME__ = zmq_server
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
import json

import zmq
from zmq.eventloop.ioloop import IOLoop
from zmq.eventloop.zmqstream import ZMQStream

from enaml.message import Message
from enaml.request import BaseRequest, BasePushHandler
from enaml.utils import log_exceptions


def pack_message(routing_id, message):
    """ Pack a routing id and Message into a mutlipart zmq message.

    Parameters
    ----------
    routing_id : str
        The zmq socket identity to place first in the message.

    message : Message
        The Message object to serialized into the multipart message.

    """
    multipart = [routing_id]
    dumps = json.dumps
    multipart.extend(dumps(part) for part in message)
    return multipart


def unpack_message(multipart):
    """ Unpack a mutlipart Enaml message received by the server.

    Parameters
    ----------
    multipart : list
        The 5-element list representing the routing_id, header, 
        parent_header, metadata, and content of a client message.

    Returns
    -------
    routing_id, message : str, Message
        The zmq routing id and the deserialized Message object.

    """
    if len(multipart) != 5:
        raise TypeError('Invalid wire message: %s' % multipart)
    routing_id = multipart[0]
    loads = json.loads
    return routing_id, Message(loads(part) for part in multipart[1:])


class ZMQRequest(BaseRequest):
    """ A concrete BaseRequest implementation for the ZMQServer.

    """
    def __init__(self, message, routing_id, stream, ioloop):
        """ Initialize a ZMQRequest.

        Parameters
        ----------
        message : Message
            The Message instance that generated this request.

        routing_id : str
            The zmq identity string for the client.

        stream : ZMQStream
            The zmq socket stream for this request.

        ioloop : IOLoop
            The zmq IOLoop instance for this request.

        """
        self._message = message
        self._routing_id = routing_id
        self._stream = stream
        self._ioloop = ioloop
        self._finished = False

    #--------------------------------------------------------------------------
    # Abstract API implementation
    #--------------------------------------------------------------------------
    @property
    def message(self):
        """ The Message object for this request.

        Returns
        -------
        result : Message
            The Message instance pertaining to this request.

        """
        return self._message

    def add_callback(self, callback):
        """ Add a callback to the event queue to be called later.

        This is can be used by the request handlers to defer long 
        running work until a future time, at which point the results
        can be pushed to the client with the 'push_handler()'.

        Parameters
        ----------
        callback : callable
            A callable which should be invoked by the event loop at 
            some future time. This method will return immediately.

        """
        self._ioloop.add_callback(callback)

    @log_exceptions
    def send_reply(self, message):
        """ Send the given message to the client as a reply.

        Parameters
        ----------
        message : Message
            A Message instance to send to the client as a reply to
            this particular request.

        Notes
        -----
        * Users should not usually call this method directly. Instead,
          users should call the 'reply' convenience method. 
        * Calling this method effectively closes the request and further 
          calls to this method will log an error.

        """
        if self._finished:
            raise RuntimeError('Request already finished')
        packed = pack_message(self._routing_id, message)
        self._stream.send_multipart(packed)
        self._finished = True

    def push_handler(self):
        """ Returns an object that can be used to push unsolicited 
        messages to this client.

        Returns
        -------
        result : ZMQPushHandler
            A ZMQPushHandler instance which can be used to push messages
            to this client, without the client initiating a request.

        """
        return ZMQPushHandler(self._routing_id, self._stream, self._ioloop)


class ZMQPushHandler(BasePushHandler):
    """ A concrete BasePushHandler implementation for the ZMQServer.

    Instances of this class will remain functional for the lifetime
    of the originating client. If the client disconnects, then 
    this handler will silently drop the messages.

    """
    def __init__(self, routing_id, stream, ioloop):
        """ Initialize a ZMQPushHandler.

        Parameters
        ----------
        routing_id : str
            The zmq identity string for the client.

        stream : ZMQStream
            The zmq socket stream for this push handler.

        ioloop : IOLoop
            The zmq IOLoop instance for this push handler.

        """
        self._routing_id = routing_id
        self._stream = stream
        self._ioloop = ioloop

    @log_exceptions
    def push_message(self, message):
        """ Push the given message to the client.

        Parameters
        ----------
        message : Message
            The Message instance that should be pushed to the client.

        """
        packed = pack_message(self._routing_id, message)
        self._stream.send_multipart(packed)

    def add_callback(self, callback):
        """ Add a callback to the event queue to be called later.

        This is used as a convenience for Session objects to provide
        a way to run callables in a deferred fashion. It does not 
        imply any communication with the client. It is merely an
        abstract entry point into the zmq event loop. 

        Call it a concession to practicality over purity - SCC

        Parameters
        ----------
        callback : callable
            A callable which should be invoked by the event loop at 
            some future time. This method returns immediately.

        """
        self._ioloop.add_callback(callback)


class ZMQServer(object):
    """ An Enaml Application server which uses ZeroMQ sockets.

    """
    def __init__(self, app, host, port):
        """ Initialize a ZMQServer.

        Parameters
        ----------
        app : Application
            The Enaml Application instance which should be served by 
            this server.

        host : string
            The host address for tcp communication. e.g. '127.0.0.1'

        port : int
            The host port to use for communication. e.g. 8888

        """
        ctxt = zmq.Context()
        router = ctxt.socket(zmq.ROUTER)
        router.bind('tcp://%s:%s' % (host, port))
        self._app = app
        self._router = router
        self._stream = ZMQStream(router)
        self._stream.on_recv(self._on_recv)
        self._ioloop = IOLoop.instance()

    #--------------------------------------------------------------------------
    # Private API
    #--------------------------------------------------------------------------
    @log_exceptions
    def _on_recv(self, multipart):
        """ The zmq stream message receive handler.

        Parameters
        ----------
        multipart : list
            The multipart message received by the client.

        """
        routing_id, message = unpack_message(multipart)
        request = ZMQRequest(message, routing_id, self._stream, self._ioloop)
        self._app.handle_request(request)

    #--------------------------------------------------------------------------
    # Public API
    #--------------------------------------------------------------------------
    def start(self):
        """ Start the server's io loop. This call will block until
        the 'stop' method is called.

        """
        self._ioloop.start()

    def stop(self):
        """ Stop the server's io loop. This will cause a previous call
        to 'start' to return.

        """
        self._ioloop.stop()


########NEW FILE########
__FILENAME__ = enaml_domain
# -*- coding: utf-8 -*-
"""
    sphinx.domains.enaml
    ~~~~~~~~~~~~~~~~~~~~~

    The Enaml domain.
    (Subclassed extensively from the Python domain)

    :copyright: Copyright 2012 by Enthought, Inc
"""

from sphinx.locale import l_, _
from sphinx.domains import Domain, ObjType, Index
from sphinx.util.nodes import make_refnode

# Subclass objects defined in the Python domain
from sphinx.domains.python import PythonDomain, PyModulelevel, PyClasslike, PyClassmember
from sphinx.domains.python import PyModule,  PyXRefRole

## class EnamlDefn(PyClasslike):
##     """
##     Enaml defn formatting particulars
##     """

##     def get_signature_prefix(self, sig):
##         return 'Enaml defn '

##     def get_index_text(self, modname, name_cls):
##         return _('%s (Enaml defn)') % name_cls[0]

class EnamlDeclaration(PyClasslike):
    """
    Enaml Declaration formatting particulars.
    """

    def get_signature_prefix(self, sig):
        ## import pdb; pdb.set_trace()
        return 'Enaml declared component '

    def get_index_text(self, modname, name_cls):
        """return a signature to appear in the index listing"""

        if modname is not None:
            # if the declaration was in a module, report it 
            return _('%s (Enaml declaration in %s)') % (name_cls[0], modname)
        else:
            # give a simple description if the directive is self-contained
            return _('%s (Enaml declaration)') % (name_cls[0])

class EnamlDomain(PythonDomain):
    """Enaml language domain."""
    name = 'enaml'
    label = 'Enaml'
    object_types = {
        'enaml_module':    ObjType(l_('enaml module'),    'mod', 'obj'),
        ## 'enaml_defn':      ObjType(l_('enaml built-in'),  'enaml_comp', 'obj'),
        'enaml_decl':      ObjType(l_('enaml derived'),   'enaml_comp', 'obj'),
        }

    directives = {
        ## 'enaml_defn':      EnamlDefn,
        'enaml_decl':      EnamlDeclaration,
        'enaml_module':    PyModule,
        }
    roles = {
        'mod':   PyXRefRole(),
        'enaml_comp': PyXRefRole(),
        }

########NEW FILE########
__FILENAME__ = sphinx_ext
# -*- coding: utf-8 -*-
"""
    enamldoc
    ~~~~~~~~

    Automatically insert docstrings for enaml built-in and derived widgets and
    components, mirroring and borrowing heavily from the autodoc
    extension. Enaml widgets and components are Python objects that are
    imported in the enaml.imports() context

"""

import re
import inspect
from types import FunctionType, BuiltinFunctionType

from sphinx.application import ExtensionError
from sphinx.util.inspect import getargspec
from sphinx.ext.autodoc import Documenter
from sphinx.ext.autodoc import ModuleLevelDocumenter
from sphinx.ext.autodoc import DocstringSignatureMixin
from sphinx.ext.autodoc import ModuleDocumenter

from enaml_domain import EnamlDomain

from enaml.core.import_hooks import EnamlImporter
EnamlImporter.install()

from enaml.core.declarative import Declarative

class EnamlComponentDocumenter(ModuleLevelDocumenter):
    """ Enaml component documenter class

    The main purpose of this class is to be distinct from Python components and
    change the domain in the Documenter instance to 'enaml'

    """

    def __init__(self, directive, name, indent=u''):
        """ Need to override the parent __init__ so that we can set
        self.domain, which is an instance variable.

        """

        super(EnamlComponentDocumenter, self).__init__(directive, name, indent)
        self.domain = 'enaml'

    def check_module(self):
        """ For Enaml objects, the module name returned by
        self.object.__module__ points to the enaml parsing compiler, rather
        than the logical module name stored in self.modname. Therefore, this
        check will verify that the module points to
        enaml.parsing.enaml_compiler.

        Note - after a fix to correct the .__module__ and .__file__ attributes,
        this method will not be necessary and will need to be deleted.

        """

        #import pdb; pdb.set_trace()
        return self.get_attr(self.object, '__module__', None) == \
            'enaml.parsing.enaml_compiler'

    def format_signature(self):
        """ Thin method for debugging signature formatting.

        """

        super(EnamlComponentDocumenter, self).format_signature()


class EnamlDocstringSignatureMixin(DocstringSignatureMixin):
    """ Mixin for FunctionDocumenter and MethodDocumenter to provide the
    feature of reading the signature from the docstring.

    identical to the autodoc.DocstringSignatureMixin it subclasses and included
    here as an indicator of a possible future avenue for working with docstring
    signatures in enaml -- possibly to replace refactordoc.

    """

    pass


class DeclarativeDocumenter(EnamlDocstringSignatureMixin,
                                 EnamlComponentDocumenter):
    """ Specialized Documenter subclass for Enaml declarations.

    """

    objtype = 'enaml_decl'
    member_order = 35

    @classmethod
    def can_document_member(cls, member, membername, isattr, parent):
        return isinstance(member, Declarative)

    def format_args(self):
        """ Derivation is shown where normally arguments are shown in a
        function prototype.

        """

        ## import pdb; pdb.set_trace()
        return ' (derives from {0})'.format(self.object.__base__)

    def document_members(self, all_members=False):
        pass


## class EnamlDefnDocumenter(EnamlDocstringSignatureMixin,
##                           EnamlComponentDocumenter):
##     """ Specialized Documenter subclass for Enaml defns.

##     """

##     objtype = 'enaml_defn'
##     member_order = 32

##     @classmethod
##     def can_document_member(cls, member, membername, isattr, parent):
##         return isinstance(member, EnamlDefn)

##     def format_args(self):
##         ## if inspect.isbuiltin(self.object) or \
##         ##        inspect.ismethoddescriptor(self.object):
##         ##     # cannot introspect arguments of a C function or method
##         ##     return None
##         try:
##             argspec = getargspec(self.object.__func__)
##         except TypeError:
##             # if a class should be documented as function (yay duck
##             # typing) we try to use the constructor signature as function
##             # signature without the first argument.
##             try:
##                 argspec = getargspec(self.object.__new__)
##             except TypeError:
##                 argspec = getargspec(self.object.__init__)
##                 if argspec[0]:
##                     del argspec[0][0]
##         args = inspect.formatargspec(*argspec)
##         # escape backslashes for reST
##         args = args.replace('\\', '\\\\')
##         return args

##     def document_members(self, all_members=False):
##         """ We may want to use this in the future to include submembers of a
##         defn.

##         """
##         pass


class EnamlModuleDocumenter(ModuleDocumenter):
    """ Subclass of the module documenter for enaml autodocumenting.

    The main purpose of the subclass is to set the domain so that member
    directives are formed properly.

    """

    objtype = 'enaml_module'

    def __init__(self, directive, name, indent=u''):
        """ Need to override the parent __init__ so that we can set
        self.domain, which is an instance variable.

        """
        super(EnamlModuleDocumenter, self).__init__(directive, name, indent)
        self.domain = 'enaml'

    def get_object_members(self, want_all):
        """ Shim method for debugging """
        ## print "EnamlModuleDocumenter: self.options.members:\n {0}".format(
        ##     self.options.members)
        ## import pdb; pdb.set_trace()
        return super(EnamlModuleDocumenter, self).get_object_members(want_all)


def add_documenter(cls):
    """ Register a new Documenter.

    This autodoc function is overridden here solely for the sake of the proper
    error message.

    """
    if not issubclass(cls, Documenter):
        raise ExtensionError('enamldoc documenter %r must be a subclass '
                             'of autodoc.Documenter' % cls)
    AutoDirective._registry[cls.objtype] = cls


def setup(app):
    """ enamldoc extension setup function.

    The setup function is called by Sphinx when loading extensions.  app is the
    instance of the calling app, Sphinx in this case.

    enamldoc borrows heavily from autodoc, so additions to setup and
    configuration are minimal.

    """

    app.add_autodocumenter(EnamlModuleDocumenter)
    app.add_autodocumenter(DeclarativeDocumenter)
    ## app.add_autodocumenter(EnamlDefnDocumenter)

    # import the Enaml domain into the sphinx app
    app.domains['enaml'] = EnamlDomain


    ## app.add_event('enamldoc-import-component')
    ## app.add_event('enamldoc-process-component')


class testcls:
    """ test doc string """

    def __getattr__(self, x):
        return x

    def __setattr__(self, x, y):
        """Attr setter."""

########NEW FILE########
__FILENAME__ = icons
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
""" An example of using icons and icon providers in Enaml.

"""
from os.path import dirname, join

import enaml
from enaml.session import Session
from enaml.image_provider import Image
from enaml.icon_provider import IconProvider, Icon, IconImage


ROOT = join(dirname(__file__), 'example_icons')


class MyIconProvider(IconProvider):
    """ A custom icon provider for the icon example.

    """
    path_map = {
        '/seek-forward': 'media-seek-forward.png',
        '/seek-backward': 'media-seek-backward.png',
        '/left-justify': 'format-justify-left.png',
        '/right-justify': 'format-justify-right.png',
        '/center-justify': 'format-justify-center.png',
        '/align-justify': 'format-justify-fill.png',
        '/window-icon': 'weather-clear.png',
        '/close': 'process-stop.png',
    }

    def request_icon(self, path, callback):
        """ Load the requested icon.

        Parameters
        ----------
        path : str
            The requested path of the icon, with the provider prefix
            removed. For example, if the full icon source path was:
            'icon://myicons/window-icon' then the path passed to this
            method will be `/window-icon`.

        callback : callable
            A callable which should be invoked when the icon is loaded.
            It accepts a single argument, which is the loaded `Icon`
            object. It is safe to invoke this callable from a thread.

        """
        # The mapping from icon name -> path is hard coded here, but
        # a typical application will have a way to resolve these paths
        # at runtime.
        if path == '/play-pause':
            with open(join(ROOT, 'media-playback-start.png'), 'rb') as f:
                off_data = f.read()
            with open(join(ROOT, 'media-playback-pause.png'), 'rb') as f:
                on_data = f.read()
            off_image = Image(data=off_data)
            on_image = Image(data=on_data)
            off_icon_img = IconImage(image=off_image)
            on_icon_img = IconImage(image=on_image, state='on')
            icon = Icon(images=[off_icon_img, on_icon_img])
        else:
            pth = self.path_map.get(path)
            if pth is not None:
                with open(join(ROOT, pth), 'rb') as f:
                    data = f.read()
                image = Image(data=data)
                icon_img = IconImage(image=image)
                icon = Icon(images=[icon_img])
            else:
                icon = None
        callback(icon)


class IconSession(Session):
    """ A simple session object for the icon example.

    """
    def on_open(self):
        """ Setup the windows and resources for the session.

        """
        self.resource_manager.icon_providers['myicons'] = MyIconProvider()
        with enaml.imports():
            from icons_view import IconsView
        self.windows.append(IconsView())


if __name__ == '__main__':
    from enaml.qt.qt_application import QtApplication
    app = QtApplication([IconSession.factory('main')])
    app.start_session('main')
    app.start()


########NEW FILE########
__FILENAME__ = images
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
""" An example of using images and image providers in Enaml.

"""
from os import listdir
from os.path import dirname, join, splitext

import enaml
from enaml.session import Session
from enaml.image_provider import ImageProvider, Image


ROOT = join(dirname(__file__), 'example_images')
PATHS = {}
for p in listdir(ROOT):
    name = splitext(p)[0]
    PATHS[name] = join(ROOT, p)


class MyImageProvider(ImageProvider):
    """ A custom image provider for the image example.

    """
    def request_image(self, path, size, callback):
        """ Request an image from this provider.

        Parameters
        ----------
        path : str
            The requested path of the image, with the provider prefix
            removed. For example, if the full image source path was:
            `image://myimages/yellowstone` then the path passed to
            this method will be `/yellowstone`.

        size : tuple
            A tuple of (width, height) which is the requested size of
            the image. If this value is (-1, -1), then the image should
            be loaded in its original size. Otherwise, the image should
            be loaded in the requested size if possible.

        callback : callable
            A callable which should be invoked when the image is loaded.
            It accepts a single argument, which is the loaded `Image`
            object. It is safe to invoke this callable from a thread.

        """
        p = PATHS.get(path.lstrip('/'))
        if p is not None:
            with open(p, 'rb') as f:
                data = f.read()
            image = Image(data=data)
        else:
            image = None
        callback(image)


class ImageSession(Session):
    """ A simple session object for the image example.

    """
    def on_open(self):
        """ Setup the windows and resources for the session.

        """
        self.resource_manager.image_providers['myimages'] = MyImageProvider()
        with enaml.imports():
            from images_view import ImagesView
        images = sorted(PATHS.keys())
        self.windows.append(ImagesView(images=images))


if __name__ == '__main__':
    from enaml.qt.qt_application import QtApplication
    app = QtApplication([ImageSession.factory('main')])
    app.start_session('main')
    app.start()


########NEW FILE########
__FILENAME__ = lotka_volterra
#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
""" A Lotka-Volterra model. 

This example plots a non-trivial system and allows the user to explore the
parameter space using sliders. The system is a first order Lotka-Volterra 
model, also known as a predator-prey model::

    http://en.wikipedia.org/wiki/Lotka%E2%80%93Volterra_equation

As in the sine plot example, the plot is on the left while the parameter 
sliders and the color controls are on the right. The plot will update as 
the slider values change.

This is the main driver for the example. The Enaml UI is defined in 
lotka_volterra_ui.enaml

This demo requires numpy and Chaco.

"""
import numpy as np

from traits.api import Array, HasTraits, Float, on_trait_change

import enaml


class LotkaVolterra(HasTraits):
    """ A simple Lotka-Volterra model.

    """

    dt = Float(1./128)
    total_time = Float(20.0)

    prey0 = Float(5.0)
    predator0 = Float(2.0)
    prey_growth = Float(1.0)
    predation_rate = Float(0.2)
    predator_growth = Float(0.04)
    predator_death = Float(0.5)

    t = Array()
    prey = Array()
    predator = Array()

    @on_trait_change('dt,total_time,prey0,predator0,prey_growth,predation_rate,predator_growth,predator_death')
    def integrate(self):
        """ Use a modifed Euler's method to integrate the ODE.
        """
        nsteps = int(round(self.total_time / self.dt))
        t = self.dt * np.arange(nsteps)
        x = self.prey0
        y = self.predator0
        prey = np.empty(nsteps)
        prey[0] = x
        predator = np.empty(nsteps)
        predator[0] = y
        for i in xrange(1, nsteps):
            x2 = x + self.dt * (self.prey_growth*x - self.predation_rate*x*y)
            y2 = y + self.dt * (-self.predator_death*y + self.predator_growth*x2*y)
            prey[i] = x2
            predator[i] = y2
            x = x2
            y = y2
        self.trait_set(
            t=t,
            prey=prey,
            predator=predator,
        )


def main():
    from simple_plot import SimplePlot
    SimplePlot.activate()

    with enaml.imports():
        from lotka_volterra_ui import Main

    model = LotkaVolterra()
    model.integrate()
    window = Main(model=model)
    window.show()


if __name__ == '__main__':
    main()


########NEW FILE########
__FILENAME__ = simple_plot
#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
""" A simple Chaco Plot Component.

"""
import functools

from chaco.api import ArrayPlotData
from chaco.tools.api import PanTool, ZoomTool
from chaco.shell.scaly_plot import ScalyPlot
from chaco.scales.api import CalendarScaleSystem
from traits.api import (
    Array, Bool, DelegatesTo, Dict, Enum, Instance, List, Str, on_trait_change,
)

from enaml.core.toolkit import Toolkit
from enaml.components.enable_canvas import EnableCanvas


class DeferredCall(object):
    def __init__(self, obj, func, *args, **kwds):
        self.obj = obj
        self.func = func
        self.args = args
        self.kwds = kwds

    def __call__(self):
        return self.func(self.obj, *self.args, **self.kwds)


def plot_command(func):
    """ Create an object that represents a call to a method on a Plot 
    object.

    """
    @functools.wraps(func)
    def wrapper(self, *args, **kwds):
        return DeferredCall(self, func, *args, **kwds)
    return wrapper


class SimplePlot(EnableCanvas):
    """ A Component that encapsulates a simple Chaco Plot.

    """

    #: The data.
    data = Dict(Str, Array)

    #: Titles.
    title = Str()
    xtitle = Str()
    ytitle = Str()

    #: The axis scales.
    xscale = Enum('linear', 'time', 'log')
    yscale = Enum('linear', 'time', 'log')

    #: Whether to show the legend or not.
    legend = Bool(False)

    #: The list of commands to execute on the Plot object.
    commands = List(Instance(DeferredCall))

    #: The plot data object.
    plot_data = Instance(ArrayPlotData, ())

    #: The plot object.
    component = Instance(ScalyPlot)
    def _component_default(self):
        plot = ScalyPlot(self.plot_data)
        return plot

    #: Delegates.
    plot_bgcolor = DelegatesTo('component', 'bgcolor')
    default_origin = DelegatesTo('component')
    orientation = DelegatesTo('component')
    padding_top = DelegatesTo('component')
    padding_bottom = DelegatesTo('component')
    padding_left = DelegatesTo('component')
    padding_right = DelegatesTo('component')
    padding = DelegatesTo('component')
    border_visible = DelegatesTo('component')
    title = DelegatesTo('component')
    title_font = DelegatesTo('component')
    title_position = DelegatesTo('component')
    title_text = DelegatesTo('component')
    title_color = DelegatesTo('component')
    title_angle = DelegatesTo('component')
    legend_alignment = DelegatesTo('component')

    @classmethod
    def activate(cls):
        """ Add this component to the active toolkit.

        """
        tk = Toolkit.active_toolkit()
        cons = tk['EnableCanvas'].clone(shell_loader=lambda:cls)
        tk[cls.__name__] = cons

    def _setup_init_widgets(self):
        super(SimplePlot, self)._setup_init_widgets()
        self.set_data()
        self.set_commands()
        self._xtitle_changed(self.xtitle)
        self._ytitle_changed(self.ytitle)
        self._title_changed(self.title)

    @on_trait_change('commands[]')
    def set_commands(self):
        """ Execute the commands on the plot.

        """
        for command in self.commands:
            command()

    @on_trait_change('data[]')
    def set_data(self):
        for name, array in self.data.iteritems():
            self.plot_data.set_data(name, array)

    @plot_command
    def plot(self, *args, **kwds):
        self.component.plot(*args, **kwds)

    @plot_command
    def img_plot(self, *args, **kwds):
        self.component.img_plot(*args, **kwds)

    @plot_command
    def contour_plot(self, *args, **kwds):
        self.component.contour_plot(*args, **kwds)

    @plot_command
    def semilogx(self, *args, **kwds):
        kwds['index_scale'] = 'log'
        self.component.plot(*args, **kwds)

    @plot_command
    def semilogy(self, *args, **kwds):
        kwds['value_scale'] = 'log'
        self.component.plot(*args, **kwds)

    @plot_command
    def loglog(self, *args, **kwds):
        kwds['index_scale'] = 'log'
        kwds['value_scale'] = 'log'
        self.component.plot(*args, **kwds)

    @plot_command
    def xaxis(self, **kwds):
        self.component.x_axis.trait_set(**kwds)
        self.component.request_redraw()

    @plot_command
    def yaxis(self, **kwds):
        self.component.y_axis.trait_set(**kwds)
        self.component.request_redraw()

    @plot_command
    def xrange(self, **kwds):
        self.component.index_range.trait_set(**kwds)

    @plot_command
    def yrange(self, **kwds):
        self.component.value_range.trait_set(**kwds)

    @plot_command
    def pan_tool(self, **kwds):
        self.component.tools.append(PanTool(self.component, **kwds))

    @plot_command
    def zoom_tool(self, **kwds):
        self.component.overlays.append(ZoomTool(self.component, **kwds))

    def _xtitle_changed(self, new):
        self.component.x_axis.title = new
        self.component.request_redraw()

    def _ytitle_changed(self, new):
        self.component.y_axis.title = new
        self.component.request_redraw()

    def _title_changed(self, new):
        self.component.title = new
        self.component.request_redraw()

    def _set_scale(self, axis, system):
        p = self.component
        if axis == 'x':
            log_linear_trait = 'index_scale'
            ticks = p.x_ticks
        else:
            log_linear_trait = 'value_scale'
            ticks = p.y_ticks
        if system == 'time':
            system = CalendarScaleSystem()
        if isinstance(system, basestring):
            setattr(p, log_linear_trait, system)
        else:
            if system is None:
                system = dict(linear=p.linear_scale, log=p.log_scale).get(
                    p.get(log_linear_trait), p.linear_scale)
            ticks.scale = system
        p.request_redraw()

    def _xscale_changed(self, new):
        self._set_scale('x', new)

    def _yscale_changed(self, new):
        self._set_scale('y', new)

    def _legend_changed(self, new):
        self.component.legend = new
        self.component.request_redraw()

    def _plot_bgcolor_changed(self, new):
        self.component.request_redraw()


########NEW FILE########
__FILENAME__ = sine_plot
#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
""" Driver for the sine plot example.

The window will show a Chaco plot on the left with sin(x) and cos(x) 
functions. The right side of the window will be a Form showing sliders 
that control the phase, amplitude, and angular frequency of the sinusoidal 
functions. The plot will update whenever the slider values change.

This demo requires numpy and Chaco.

"""
import numpy as np

from traits.api import HasTraits, Array, Float, Property

import enaml


class SineModel(HasTraits):
    #: The phase of the sine wave.
    phase = Float()

    #: The amplitude of the sine wave.
    amplitude = Float(1.0)

    #: The angular frequency of the sine wave.
    w = Float(1.0)

    #: The data.
    x = Array()
    def _x_default(self):
        return np.linspace(-6*np.pi, 6*np.pi, 301)

    y_sin = Property(Array, depends_on=['phase', 'amplitude', 'w'])
    def _get_y_sin(self):
        return self.amplitude * np.sin(self.w * self.x + self.phase)

    y_cos = Property(Array, depends_on=['phase', 'amplitude', 'w'])
    def _get_y_cos(self):
        return self.amplitude * np.cos(self.w * self.x + self.phase)


def main():
    from simple_plot import SimplePlot
    SimplePlot.activate()

    with enaml.imports():
        from sine_plot import Main

    model = SineModel()
    window = Main(model=model)
    window.show()


if __name__ == '__main__':
    main()


########NEW FILE########
__FILENAME__ = data_generator
#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
""" A fake data generated which can generate data at various frequencies.
This is not intended for production use, but rather as a stand-in for
some external data generation feed.

"""
from abc import ABCMeta, abstractmethod
from collections import defaultdict
import threading
import time


class AbstractDataGenerator(object):
    """ An abstract base class which defines the dummy api for a 
    data generator.

    """
    __metaclass__ = ABCMeta

    @abstractmethod
    def subscribe(self, id, callback):
        """ Register a callback to be called when data is available
        for the given id.
        
        """
        raise NotImplementedError
        
 
class DummyDataGenerator(object):
    """ A dummy data generator which generates timestamp data on a
    specified frequency.

    This class is for demonstration purposes only, and will be 
    replaced with an actualy production data source.

    """
    def __init__(self, frequency, *value_gens):
        """ Initialize a DummyDataGenerator

        Parameters
        ----------
        frequencey : float
            A floating point frequency (Hz) which indicates how
            freqeuntly data should be generated.
        
        *value_gens : callables
            Callables which are called with the time stamp and return
            a tuple of (id, value) where id is a string representing
            the feed id and value is the datapoint for the time stamp.
            These values will be republished to any listeners.

        """
        self.callback = None
        self.go = True
        self.frequency = frequency
        self.callbacks = defaultdict(list)
        self.value_gens = value_gens

    def start(self):
        """ Start the generator's generation thread. Any registered
        callbacks will be called when new data is available.

        """
        def inner(data_generator):
            while(data_generator.go):
                time_stamp =  time.clock()
                callbacks = data_generator.callbacks
                for gen in data_generator.value_gens:
                    id, data = gen(time_stamp)
                    for cb in callbacks[id]:
                        cb((id, time_stamp, data))
                time.sleep(1.0 / data_generator.frequency)
        thread = threading.Thread(target=inner, args=(self,))
        thread.daemon = True
        thread.start()

    def stop(self):
        """ Stop the generator's generation thread.

        """
        self.go = False

    def subscribe(self, id, callback):
        """ Register a callback to be called when data is available
        for the given id.
        
        """
        self.callbacks[id].append(callback)


########NEW FILE########
__FILENAME__ = data_sampler
#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
""" A data sampler api for subsampling a data stream.

"""
from abc import ABCMeta, abstractmethod
import numpy as np


class AbstractDataSampler(object):
    """ An abstract base class which defines the api necessary for a
    data sampler.

    """
    __metaclass__ = ABCMeta
    @abstractmethod
    def sample(self, data):
        """ Samples the given data buffer and returns a possibly new
        buffer with subsampled data.

        Parameters
        ----------
        data : np.ndarray
            The buffer of data to be sampled.
        
        Returns
        -------
        result : np.ndarray
            A new buffer of sampled data, or the original buffer if 
            no sampling needs to be performed.

        """
        raise NotImplementedError


class ProbabilitySampler(AbstractDataSampler):
    """ A concrete implementation of AbstractDataSampler which sub 
    samples data based on a uniform probability distribution.

    """
    def __init__(self, probability=1.0):
        """ Initialized a ProbabilitySampler.

        Parameters
        ----------
        probability : float, optional
            A floating point probability in the range(0.0, 1.0)
        
        """
        prob = probability
        assert 0.0 <= prob <= 1.0, "Probability must be 0.0 <= val <= 1.0"
        self.probability = prob 

    def sample(self, data):
        num_entries = data.shape[0]
        coin_flips = np.random.random(num_entries)
        mask = coin_flips < self.probability
        return data[mask]


########NEW FILE########
__FILENAME__ = data_source
#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
""" The DataSource api for providing live streaming data to a Chaco plot.

"""
from abc import ABCMeta, abstractmethod
from enaml.core.signaling import Signal
import numpy as np


class AbstractDataSource(object):
    """ An abstract base class which defines the interface for a data
    source to be used by a live plot.

    """
    __metaclass__ = ABCMeta

    @abstractmethod
    def subscribe(self, callback):
        """ Subscribe a callback to be called by the data source when
        new data is available. The argument will be a structured numpy
        array representing all of the data. Only a weak reference is
        maintained to the callback.

        """
        raise NotImplementedError

    @abstractmethod
    def unsubscribe(self, callback):
        """ Unsubscribe a callback that was registered previously 
        via a call to subscribe.

        """
        raise NotImplementedError

    @abstractmethod
    def bind(self):
        """ Bind this data source to the publisher. The data source
        will start listening to the publisher immediately.

        """
        raise NotImplementedError


class DataSource(AbstractDataSource):
    """ A trival but concrete implementation of AbstractDataSource which 
    handles basic functionality for manipulation of incoming timestamp 
    data.

    """
    #: The signal object used to manage subscriptions
    _data_changed = Signal()

    def __init__(self, publisher, buffer_size=1000000, sampler=None):
        """ Initialize a TimeStampDataSource.

        Parameters
        ----------
        publisher : AbstractPublisher
            A publisher instance which is publishing the feed we're
            interested in, at the rate at which we need it.

        buffer_size : int, optional
            The size of the data buffer to maintain. A full buffer is
            implemented as a sliding window across the incoming data.
            The default buffer size is 1e6.
        
        sampler : AbstractDataSampler, optional
            If provided, an instance of AbstractDataSampler which has
            the opportunity to subsample the data before it is 
            republished to subcribers.

        """
        self.buffer_size = buffer_size
        self.sampler = sampler
        self.publisher = publisher
        self._buffer = None

    def dispatch(self, data):
        """ The publisher callback which aggregates the new data and 
        emits the _data_changed signal.

        """
        buf = self._buffer
        max_size = self.buffer_size
        if len(data) >= max_size:
            buf = np.copy(data[-max_size:])
        else:
            if buf is None:
                buf = np.copy(data)
            else:
                offset = max_size - len(data)
                buf = np.hstack((buf[-offset:], data))
        sampler = self.sampler
        if sampler is not None:
            buf = sampler(buf)

        self._buffer = buf
        self._data_changed(buf)

    def bind(self):
        """ Bind the data source to the given publisher. This may only
        happen once.

        """
        self.publisher.subscribe(self.dispatch)

    def subscribe(self, callback):
        """ Subscribe the given callback to be notified when new
        data is available.

        """
        self._data_changed.connect(callback)

    def unsubscribe(self, callback):
        """ Unsubscribe a previously registered callback.

        """
        self._data_changed.disconnect(callback)


########NEW FILE########
__FILENAME__ = publisher
#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
""" A simple publisher api that acts as a throttling broadcaster for a 
high frequency data source.

"""
import threading
import time
from abc import ABCMeta, abstractmethod
import numpy as np
from enaml.core.signaling import Signal


TIMESTAMP_FLOAT32_DTYPE = np.dtype(
    [('index', np.float64), ('value', np.float32)]
)


class AbstractPublisher(object):
    """ An abstract base class representing a data republisher. A 
    publisher subcsribes to a given feed id but throttles updates 
    to a rate which is manageable for the given task.

    """
    __metaclass__ = ABCMeta

    @abstractmethod
    def start(self):
        """ Start the publisher feed.

        """
        raise NotImplementedError

    @abstractmethod
    def stop(self):
        """ Stop the publisher feed.

        """
        raise NotImplementedError

    @abstractmethod
    def subscribe(self, callback):
        """ Subscribe a callback to the feed which will be called with
        a structured numpy array when data is available.

        """
        raise NotImplementedError

    @abstractmethod
    def unsubscribe(self, callback):
        """ Unsubscribe a callback previously registered via subscribe.

        """
        raise NotImplementedError


class BasePublisher(AbstractPublisher):
    """ A base publisher class which provides a simple event loop for
    processing a feed.

    """
    #: The signal used to implement notification
    _data_changed = Signal()

    #: The default event loop frequency
    frequency = 30

    def start_event_loop(self):
        """ A simple event loop implemented with a daemon thread.

        """
        def inner(publisher):
            while publisher._go_thread:
                buf = publisher.process_feed()
                publisher._data_changed(buf)
                time.sleep(1.0 / publisher.frequency)
        self._go_thread = True
        thread = threading.Thread(target=inner, args=(self,))
        thread.daemon = True
        thread.start()
    
    def stop_event_loop(self):
        """ Stop the event loop thread.

        """
        self._go_thread = False
    
    def subscribe(self, callback):
        """ Subscribe a callback to the publisher. Callbacks will be
        notified from a thread.

        """
        self._data_changed.connect(callback)

    def unsubscribe(self, callback):
        """ Unsubscribe a previously registered callback.

        """
        self._data_changed.disconnect(callback)

    @abstractmethod
    def process_feed(self):
        """ Do any necessary processing on the queued feed and return
        the value to be emitted to any listeners. This method will be 
        called from a thread.

        """
        raise NotImplementedError


class NumpyPublisher(BasePublisher):
    """ A concrete implementation of BasePublisher which acummulates the
    data into a numpy array.

    """

    def __init__(self, data_gen, id, size=1000000, frequency=30, sampler=None):
        """ Initialize a NumpyPublisher.

        Parameters
        ----------
        data_gen : AbstractDataGenerator
            An AbstractDataGenerator instance which provides the feeds
            we are interested in.
        
        id : string
            The identifier for the particular data feed from the data
            generator which should be republished to any subscribers.
        
        size : int, optional
            The size of the buffer to queue incoming data. The default
            is 1e6.
        
        frequency : int, optional
            The frequency with which to republish data. The default
            is 30 (Hz)
        
        sampler : AbstractDataSampler, optional
            If provided, an instance of AbstractDataSampler which has
            the opportunity to subsample the data before it is 
            republished to subcribers.
        
        """
        self.data_gen = data_gen
        self.feed_id = id
        self.frequency = frequency
        self.sampler = sampler
        self._buffer = np.empty(size, dtype=TIMESTAMP_FLOAT32_DTYPE)
        self.size = size
        self.index = 0
        self.lock = threading.Lock()
    
    #--------------------------------------------------------------------------
    # AbstractPublisher Implementation
    #--------------------------------------------------------------------------
    def start(self):
        """ Bind to the data feed with the given id and start the 
        event loop.

        """
        self.data_gen.subscribe(self.feed_id, self.insert)
        self.start_event_loop()

    def stop(self):
        """ Stop the publisher feed.

        """
        self.stop_event_loop()

    def process_feed(self):
        """ Process and return the current buffered data.

        """
        with self.lock:
            data = np.copy(self._buffer[:self.index])
        sampler = self.sampler
        if sampler is not None:
            data = sampler.sample(data)
        self.index = 0
        return data

    #--------------------------------------------------------------------------
    # Processing Helpers
    #--------------------------------------------------------------------------    
    def insert(self, value):
        """ The callback from the data feed which inserts the data point
        into the internal buffer.

        """
        with self.lock:
            if self.index >= self.size:
                raise BufferError
            id, idx, val = value
            item = self._buffer[self.index]
            item['index'] = idx
            item['value'] = val
            self.index += 1
            

########NEW FILE########
__FILENAME__ = updating_plot_example
#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
""" An example which assembles a data-flow pipeline and connects the
output to a live chaco plot. The input of the pipeline can be driven
at several thousand Hz, while the output remains throttled at a rate
that is useful for a UI application.

"""
from math import sin

from chaco.api import (
    LinePlot, LinearMapper, DataRange1D, ArrayDataSource, PlotAxis,
    OverlayPlotContainer,
)

import enaml

from data_generator import DummyDataGenerator
from publisher import NumpyPublisher
from data_source import DataSource



class SinGenerator(object):
    """ A simple data generator which computes the sin of the timestamp
    for a given frequency.

    """
    def __init__(self, frequency=1.0):
        self.frequency = frequency
    
    def __call__(self, ts):
        return ('sin', sin(self.frequency * ts))


class ModGenerator(object):
    """ A simple data generator which mods a timestamp by a given
    amount.

    """
    def __init__(self, frequency=1.5):
        self.frequency = frequency
    
    def __call__(self, ts):
        return ('mod', ts % self.frequency)


if __name__ == '__main__':
    #--------------------------------------------------------------------------
    # Data Source Generation
    #--------------------------------------------------------------------------
    sin_gen = SinGenerator()
    mod_gen = ModGenerator()

    # Create reactive data generator
    reactive_data_generator = DummyDataGenerator(1000, sin_gen, mod_gen)

    # Create the data publishers
    sin_publisher = NumpyPublisher(
        reactive_data_generator, 'sin', frequency=30,
    )
    mod_publisher = NumpyPublisher(
        reactive_data_generator, 'mod', frequency=30,
    )

    # Create a data sources
    sin_data_source = DataSource(publisher=sin_publisher, buffer_size=2250)
    mod_data_source = DataSource(publisher=mod_publisher, buffer_size=2250)

    # Bind the data sources to their publishers
    sin_data_source.bind()
    mod_data_source.bind()

    #--------------------------------------------------------------------------
    # Plot Generation
    #--------------------------------------------------------------------------
    sin_index = ArrayDataSource([])
    sin_value = ArrayDataSource([])

    mod_index = ArrayDataSource([])
    mod_value = ArrayDataSource([])

    x_mapper = LinearMapper(range=DataRange1D(sin_index))
    y_mapper = LinearMapper(range=DataRange1D(sin_value))

    y_mapper.range.low_setting = -2.2
    y_mapper.range.high_setting = 2.2

    sin_line_plot = LinePlot(
        index=sin_index, value=sin_value, index_mapper=x_mapper, 
        value_mapper=y_mapper, color='darkblue',
    )

    mod_line_plot = LinePlot(
        index=mod_index, value=mod_value, index_mapper=x_mapper,
        value_mapper=y_mapper, color='darkred',
    )

    container = OverlayPlotContainer(
        bgcolor='white', padding=50, fill_padding=False, border_visible=True,
    )
    container.add(sin_line_plot)
    container.add(mod_line_plot)

    left_axis = PlotAxis(
        mapper=y_mapper, component=container, orientation='left',
    )
    container.overlays.append(left_axis)

    #--------------------------------------------------------------------------
    # View Generation
    #--------------------------------------------------------------------------
    # Import and create the viewer for the plot
    with enaml.imports():
        from updating_plot_view import PlotView

    view = PlotView(
        component=container, publishers=[sin_publisher, mod_publisher],
        data_sources=[sin_data_source, mod_data_source],
        feed=reactive_data_generator, mod_gen=mod_gen, sin_gen=sin_gen,
    )

    # Create a subscription function that will update the plot on the
    # main gui thread.
    def sin_update_func(data):
        def closure():
            sin_line_plot.index.set_data(data['index'])
            sin_line_plot.value.set_data(data['value'])
        view.toolkit.app.call_on_main(closure)

    def mod_update_func(data):
        def closure():
            mod_line_plot.index.set_data(data['index'])
            mod_line_plot.value.set_data(data['value'])
        view.toolkit.app.call_on_main(closure)
    
    # Attach the update functions to the data sources
    sin_data_source.subscribe(sin_update_func)
    mod_data_source.subscribe(mod_update_func)

    # Start the publisher's event loops
    sin_publisher.start()
    mod_publisher.start()

    # Schedule the data generator to start once the ui is up and
    # running
    view.toolkit.app.schedule(reactive_data_generator.start)

    def closed_cb():
        # Shut.Down.Everything
        reactive_data_generator.stop()
        sin_publisher.stop()
        mod_publisher.stop()
    
    # Assign the callback to be called when the window is closed.
    view.closed_cb = closed_cb

    # Start the application.
    view.show()


########NEW FILE########
__FILENAME__ = employee
#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
import datetime

from traits.api import HasTraits, Str, Int, Instance, Tuple, Date, Property

import enaml
from enaml.stdlib.sessions import simple_app
from enaml.qt.qt_local_server import QtLocalServer


class Person(HasTraits):
    """ A simple class representing a person object.

    """
    # The last name of the person as a string
    last_name = Str

    # The first name of the person as a string
    first_name = Str

    # The date of birth of the person
    dob = Date(datetime.date(1970, 1, 1))

    # The age of the person computed from their dob
    age = Property(Int, depends_on='dob')

    # This method is called when the age of the person needs to
    # be computed
    def _get_age(self):
        today = datetime.date.today()
        dob = self.dob
        age = today.year - dob.year
        birthday_this_year = dob.replace(year=today.year)
        if today < birthday_this_year:
            age -= 1
        return age


class Employer(Person):
    """ An employer is a person who runs a company.

    """
    # The name of the company
    company_name = Str


class Employee(Person):
    """ An employee is person with a boss and a phone number.

    """
    # The employee's boss
    boss = Instance(Employer)

    # The employee's phone number as a tuple of 3 ints
    phone = Tuple(Int, Int, Int)

    # This method is called automatically by traits to get the
    # default value for the phone number.
    def _phone_default(self):
        return (555, 555, 5555)

    # This method will be called automatically by traits when the 
    # employee's phone number changes
    def _phone_changed(self, val):
        print 'received new phone number for %s: %s' % (self.first_name, val)


if __name__ == '__main__':
    # Create an employee with a boss
    boss_john = Employer(
        first_name='John', last_name='Paw', company_name="Packrat's Cats"
    )
    employee_mary = Employee(
        first_name='Mary', last_name='Sue', boss=boss_john
    )

    # Import our Enaml EmployeeView
    with enaml.imports():
        from employee_view import EmployeeView
    
    # Create a view and show it.
    app = simple_app(
        'mary', 'A view of the Employee mary', EmployeeView, 
        employee=employee_mary
    ) 

    server = QtLocalServer(app)
    client = server.local_client()
    client.start_session('mary')
    server.start()


########NEW FILE########
__FILENAME__ = phone_validator
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
import re

from enaml.validation.api import Validator


class PhoneNumberValidator(Validator):
    """ A really dumb phone number validator.

    """
    all_digits = re.compile(r'[0-9]{10}$')
    
    dashes = re.compile(r'([0-9]{3})\-([0-9]{3})\-([0-9]{4})$')
    
    proper = re.compile(r'\(([0-9]{3})\)\ ([0-9]{3})\-([0-9]{4})$')

    def validate(self, text, component):
        match = self.proper.match(text) or self.dashes.match(text)
        if match:
            area = match.group(1)
            prefix = match.group(2)
            suffix = match.group(3)
            formatted_text = '(%s) %s-%s' % (area, prefix, suffix)
            return formatted_text, True
        match = self.all_digits.match(text)
        if match:
            area = text[:3]
            prefix = text[3:6]
            suffix = text[6:10]
            formatted_text = '(%s) %s-%s' % (area, prefix, suffix)
            return formatted_text, True
        return text, False


########NEW FILE########
__FILENAME__ = main
#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from processing_model import ProcessorModel


def main():
    import enaml
    with enaml.imports():
        from processing_view import Main
    window = Main(model=ProcessorModel())
    window.show()


if __name__ == "__main__":
    main()


########NEW FILE########
__FILENAME__ = processing_model
#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
import numpy as np
from scipy.misc import imread

from skimage.filter import canny
from skimage.transform import probabilistic_hough

from chaco.api import Plot, ArrayPlotData, bone
from enable.api import ColorTrait
from traits.api import (
    HasTraits, File, Array, Property, Instance, Any, Int, List, Tuple, Range,
    DelegatesTo, cached_property, on_trait_change,
)

from segments_overlay import SegmentsOverlay


class ImageProcessor(HasTraits):

    original_image = Array

    canny_sigma = Range(value=1, low=0.0)
    canny_low_threshold = Range(value=0.1, low=0.0)
    canny_high_threshold = Range(value=0.2, low=0.0)
    canny_image = Property(
        Array, depends_on=['original_image', 'canny_sigma', 
                           'canny_low_threshold', 'canny_high_threshold'],
    )

    hough_threshold = Int(10)
    hough_line_length = Int(50)
    hough_line_gap = Int(10)
    hough_segments = Property(
        List, depends_on=['canny_image', 'hough_threshold', 
                          'hough_line_length', 'hough_line_gap'],
    )

    def _original_image_default(self):
        return np.array([[0]])

    @cached_property
    def _get_canny_image(self):
        ci = canny(
            self.original_image, sigma=self.canny_sigma,
            low_threshold=self.canny_low_threshold,
            high_threshold=self.canny_high_threshold,
        )
        return ci

    @cached_property
    def _get_hough_segments(self):
        segs = probabilistic_hough(
            self.canny_image, threshold=self.hough_threshold,
            line_length=self.hough_line_length, line_gap=self.hough_line_gap,
        )
        return segs


class ProcessorModel(HasTraits):

    filename = File

    image = Instance(ImageProcessor, ())
    
    shape = Property(Tuple, depends_on=['image'])
    width = Property(Int, depends_on=['shape'])
    height = Property(Int, depends_on=['shape'])

    original_image = DelegatesTo('image')
    canny_sigma = DelegatesTo('image')
    canny_low_threshold = DelegatesTo('image')
    canny_high_threshold = DelegatesTo('image')
    canny_image = DelegatesTo('image')

    hough_threshold = DelegatesTo('image')
    hough_line_length = DelegatesTo('image')
    hough_line_gap = DelegatesTo('image')
    hough_segments = DelegatesTo('image')

    segments_overlay = Any

    original_alpha = Range(value=1.0, low=0.0, high=1.0) 

    plot_data = Instance(ArrayPlotData)
    main_plot = Instance(Plot)

    canny_color = ColorTrait('red')
    canny_alpha = Range(value=1.0, low=0.0, high=1.0)
    canny_plot_image = Property(
        Array, depends_on=['image', 'canny_image', 'canny_sigma',
                           'canny_low_threshold', 'canny_high_threshold',
                           'canny_color'],
    )

    hough_segments_alpha = Range(value=1.0, low=0.0, high=1.0) 
    hough_segments_color = ColorTrait('green')

    original_plot = Any
    canny_plot = Any

    background_color = ColorTrait('black')

    #--------------------------------------------------------------------------
    # Trait defaults
    #--------------------------------------------------------------------------
    def _plot_data_default(self):
        pd = ArrayPlotData(
            original_image=self.image.original_image,
            canny_plot_image=self.canny_plot_image,
        )
        return pd

    def _main_plot_default(self):
        p = Plot(self.plot_data, default_origin='top left', padding=0)
        self.original_plot = p.img_plot(
            'original_image', colormap=bone, alpha=self.original_alpha,
            bgcolor=self.background_color_,
        )[0]
        self.canny_plot = p.img_plot(
            'canny_plot_image', alpha=self.canny_alpha,
        )[0]
        p.x_axis = None
        p.y_axis = None
        self.segments_overlay = SegmentsOverlay(
            component=self.canny_plot, image_size=self.image.canny_image.shape,
        )
        p.overlays.append(self.segments_overlay)
        return p

    #--------------------------------------------------------------------------
    # Trait property methods
    #--------------------------------------------------------------------------
    @cached_property
    def _get_shape(self):
        shape = self.image.original_image.shape
        return shape

    @cached_property
    def _get_width(self):
        width = self.shape[1]
        return width

    @cached_property
    def _get_height(self):
        height = self.shape[0]
        return height

    @cached_property
    def _get_canny_plot_image(self):
        # self.image.canny_image is an array of bools.
        # self.canny_plot_image is a 3D array (2D image with (r,g,b,a)
        # values).  The color (0,0,0,0) (transparent) is assigned where
        # canny_image is False, and (canny_color_, 255) is assigned where
        # canny_image is True.
        ci = self.image.canny_image
        x = np.zeros(ci.shape + (4,), dtype=np.uint8)
        x[ci, :3] = [255 * c for c in self.canny_color_[:3]]
        x[ci, 3] = 255
        return x

    #--------------------------------------------------------------------------
    # Trait change handlers
    #--------------------------------------------------------------------------
    def _filename_changed(self):
        try:
            image_data = imread(self.filename, flatten=True).astype(np.float32)
            image_data /= image_data.max()
            image = ImageProcessor(original_image=image_data)
        except IOError:
            image = ImageProcessor(original_image=np.array([[0]]))
        self.image = image

        self.plot_data['original_image'] = self.image.original_image
        self.plot_data['canny_plot_image'] = self.canny_plot_image
        self.segments_overlay.image_size = self.image.canny_image.shape
        self.segments_overlay.segments = self.image.hough_segments

    @on_trait_change('canny_plot_image')
    def _canny_parameter_changed(self):
        self.plot_data['canny_plot_image'] = self.canny_plot_image

    def _original_alpha_changed(self):
        self.original_plot.alpha = self.original_alpha
        # Temporary hack...
        self.plot_data['original_image'] = self.image.original_image
        self.plot_data['canny_plot_image'] = self.canny_plot_image

    @on_trait_change('canny_alpha, canny_color')
    def _canny_display_parameters_changed(self):
        self.canny_plot.alpha = self.canny_alpha
        # Temporary hack...
        self.plot_data['original_image'] = self.image.original_image
        self.plot_data['canny_plot_image'] = self.canny_plot_image

    @on_trait_change('hough_segments_alpha, hough_segments_color')
    def _hough_display_parameters_changed(self):
        self.segments_overlay.line_color = self.hough_segments_color
        self.segments_overlay.alpha = self.hough_segments_alpha
        self.segments_overlay.request_redraw()

    def _background_color_changed(self):
        self.original_plot.bgcolor = self.background_color_
        self.original_plot.request_redraw()

    @on_trait_change('hough_segments')
    def _update_hough_segments_plot(self):
        self.segments_overlay.segments = self.image.hough_segments
        self.canny_plot.request_redraw()


########NEW FILE########
__FILENAME__ = segments_overlay
""" Defines the SegmentsOverlay class.
"""

from numpy import array

from enable.api import Component, ColorTrait
from traits.api import Instance, List, Tuple, Range

from chaco.api import AbstractOverlay


# XXX -- This code was copied from a more complicated overlay and pared
#        down to its current state.  There may still be some unecessary code.
#
# XXX -- Requires the padding of the component to be 0.

class SegmentsOverlay(AbstractOverlay):
    """
    Draw selectable line segments.
    """
    
    # The component that this tool overlays
    component = Instance(Component)
    
    # XXX Necessary?
    image_shape = Tuple

    # Color of the line segments.
    line_color = ColorTrait('green')
    
    alpha = Range(low=0.0, high=1.0, value=1.0)

    # The list of line segments.  Each segment is a tuple of the
    # form ((x0, y0), (x1, y1))
    # XXX Maybe use a numpy array?
    segments = List
    
    #------------------------------------------------------------------------
    # Object interface
    #------------------------------------------------------------------------
    
    def __init__(self, component=None, **kwtraits):
        if "component" in kwtraits:
            component = kwtraits["component"]
        super(SegmentsOverlay, self).__init__(**kwtraits)
        self.component = component
        return

    #------------------------------------------------------------------------
    # Drawing tool methods
    #------------------------------------------------------------------------

    def reset(self):
        """ Resets the tool in the current plot.
        """
        if self.component is not None:
            c1, c2 = self._data_corners()
            dx = c2[0] - c1[0]
            dy = c2[1] - c1[1]
            pt1 = (c1[0] + 0.05*dx, c1[1] + 0.05*dy)
            pt2 = (c2[0] - 0.05*dx, c2[1] - 0.05*dy)
            self.points = [pt1, pt2]
            self.event_state = "normal"
            self.line.points = list(self.component.map_screen(array(self.points)))
            self.request_redraw()
        return

    def _activate(self):
        """
        Called by a PlotComponent when this becomes the active tool.
        """
        pass

    def _deactivate(self, component=None):
        """
        Called by a PlotComponent when this is no longer the active tool.
        """
        # XXX  Is this the correct thing to do?  Do we even need to implement
        # this method?
        self.visible = False
        self.request_redraw()
        return


    #------------------------------------------------------------------------
    # override AbstractOverlay methods
    #------------------------------------------------------------------------

    def overlay(self, component, gc, view_bounds, mode="normal"):
        """ Draws this component overlaid on another component.
        
        Implements AbstractOverlay.
        """
        with gc:
            gc.clip_to_rect(component.x, component.y,
                            component.width-1, component.height-1)
            self._really_draw(gc)
        return
    
    def request_redraw(self):
        """ Requests that the component redraw itself. 
        
        Overrides Enable Component.
        """
        self.component.invalidate_draw()
        self.component.request_redraw()
        return

    #------------------------------------------------------------------------
    # Private methods
    #------------------------------------------------------------------------

    def _data_corners(self):
        """Get the dataspace points at the corners of the plot."""
        index_range = self.component.index_mapper.range
        value_range = self.component.value_mapper.range
        pts = [(index_range.low, value_range.low),
                (index_range.high, value_range.high)]
        return pts

    def _map_data(self, point):
        """ Maps values from screen space into data space.
        """
        index_mapper = self.component.index_mapper
        value_mapper = self.component.value_mapper
        if self.component.orientation == 'h':
            ndx = index_mapper.map_data(point[0])
            val = value_mapper.map_data(point[1])
        else:
            ndx = index_mapper.map_data(point[1])
            val = value_mapper.map_data(point[0])
        return (ndx, val)

    def _map_screen(self, point):
        """ Maps values from data space into screen space.
        """
        # Temporary hack--this object should know nothing about "canny_plot"!
        x_mapper = self.component.x_mapper
        y_mapper = self.component.y_mapper

        x = x_mapper.map_screen(point[0])
        y = y_mapper.map_screen(point[1])
        return (x, y)

    def _really_draw(self, gc):
        """Render the line segments."""
        w = self.component.width
        h = self.component.height
        padl, padr, padt, padb = self.component.padding
        aw = w - padl - padr
        ah = h - padt - padb
        outerw, outerh = self.component.outer_bounds
        with gc:
            gc.set_stroke_color(self.line_color_[:3] + (self.alpha,))
            gc.set_line_width(2.5)
            for p0, p1 in self.segments:
                # XXX These calculations should be in a mapper or something...
                x0 = padl + p0[0] * aw / float(self.image_size[1])
                y0 = padb + (self.image_size[0] - p0[1]) * ah / float(self.image_size[0])
                x1 = padl + p1[0] * aw / float(self.image_size[1])
                y1 = padb + (self.image_size[0] - p1[1]) * ah / float(self.image_size[0])
                gc.move_to(x0, y0)
                gc.line_to(x1, y1)
                gc.stroke_path()

        return


    #------------------------------------------------------------------------
    # Trait event handlers
    #------------------------------------------------------------------------
    
    def _component_changed(self, old, new):
        if new:
            self.container = new
        return

########NEW FILE########
__FILENAME__ = preview_app
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
""" The entry point launcher for the Enaml Preview application.

"""
import os
import enaml

from preview_config import ViewConfig


if __name__ == '__main__':
    path = os.path.join(os.path.expanduser('~'), 'Desktop')
    if not os.path.exists(path):
        path = '.'

    config = ViewConfig(search_dir=path)
    
    with enaml.imports():
        from viewer import PreviewMain
    
    view = PreviewMain(view_config=config, initial_size=(640, 480))
    view.show()


########NEW FILE########
__FILENAME__ = preview_config
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from traits.api import (
    HasTraits, Bool, Range, Enum, on_trait_change, Property, Str, List, Int,
    cached_property, Instance
)

from enaml.styling.color import Color


# An enum defining a image extension.
ImageFileExt = Enum(
    'bmp', 'png', 'jpg', 'jpeg', 'gif', 'pbm', 
    'pgm', 'ppm', 'tiff', 'xbm', 'xpm',
)


class ViewConfig(HasTraits):
    """ A simple state object to share amongst the various ui widgets. 
    This is not strictly required when developing an Enaml application, 
    but as the view complexity grows, it makes the code more unified and
    manageable. It's also easier to see the view logic in centralized
    place.

    """
    #: The types of images for which to search.
    search_image_exts = List(ImageFileExt, value=['png', 'jpg', 'jpeg'])

    #: The regex pattern to use when searching for images.
    image_file_pattern = Property(Str, depends_on='search_image_exts')

    #: The directory currently being searched.
    search_dir = Str('.')
    
    #: The minimum allowed thumbnail size.
    min_thumb_size = Int(16)

    #: The maximum allowed thumbnail size.
    max_thumb_size = Int(256)

    #: The size of the thumbnails in the ui.
    thumb_size = Range('min_thumb_size', 'max_thumb_size', value=150)

    #: Select which browsing widget should be visible
    visible_browser_widget = Enum('textual', 'thumbnails')

    #: The layout mode to use for the thumbnails view.
    thumb_layout = Enum('vertical', 'horizontal', 'grid')
 
    #: The location of the dock pane
    dock_area = Enum('left', 'right', 'top', 'bottom', value='left')

    #: Whether or not the dock pane is floating
    floating_dock = Bool(False)

    #: Whether or not to recrusively load the thumbnails
    recursive_load = Bool(True)

    #: The background color of the image viewing widget.
    viewer_bgcolor = Instance(Color, (146, 146, 146))

    #: The background color of the browser widgets.
    browser_bgcolor = Instance(Color, (235, 239, 246))

    @cached_property
    def _get_image_file_pattern(self):
        """ Creates a search regex for the requested image types.

        """
        return r'.*?\.(%s)$' % '|'.join(self.search_image_exts)

    @on_trait_change('dock_area, floating_dock')
    def _update_thumb_layout(self):
        """ Updates the thumbnail layout mode based on the position
        of the dock pane.

        """
        if self.floating_dock:
            self.thumb_layout = 'grid'
        elif self.dock_area in ('left', 'right'):
            self.thumb_layout = 'vertical'
        else:
            self.thumb_layout = 'horizontal'


########NEW FILE########
__FILENAME__ = plot_driver
#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from traits.api import HasTraits, Any, on_trait_change

from chaco.api import (ArrayPlotData, ArrayDataSource, DataRange1D, 
                       LinearMapper, VPlotContainer, PlotAxis, FilledLinePlot, 
                       add_default_grids, Plot)
from chaco.tools.api import RangeSelection
from chaco.scales.api import CalendarScaleSystem
from chaco.scales_tick_generator import ScalesTickGenerator

from zoom_overlay import ZoomOverlay


class PlotDriver(HasTraits):

    model = Any

    def __init__(self, model):
        super(PlotDriver, self).__init__(model=model)

    @on_trait_change('model:data')
    def update_plots(self, data):
        self.close_plot.index.set_data(data['dates'])
        self.close_plot.value.set_data(data['close'])
        self.low_plot.index.set_data(data['dates'])
        self.low_plot.value.set_data(data['low'])
        self.bar_plot.index.set_data(data['dates'])
        self.bar_plot.value.set_data(data['volume'])
        self.close_plot.controller.deselect()

    def get_plot_component(self):
        # Create the array plot data that will feed our plots
        data = self.model.data
        plot_data = ArrayPlotData(index=data['dates'], 
                                  close=data['close'],
                                  volume=data['volume'],)
        self.plot_data = plot_data
        
        # Need to make the FilledLinePlot manually since Plot doesn't
        # support that plot type.
        times = ArrayDataSource(data['dates'])
        prices = ArrayDataSource(data['close'])
        close_plot =  FilledLinePlot(index=times, value=prices,
                        index_mapper = LinearMapper(range=DataRange1D(times)),
                        value_mapper = LinearMapper(range=DataRange1D(prices)),
                        edge_color = 'blue',
                        face_color = 'paleturquoise',
                        bgcolor = 'white',
                        border_visible = True)
        close_plot.padding = [40, 15, 15, 20]
        self.close_plot = close_plot

        # The second plotter object which generates our candle plot
        plotter2 = Plot(data=plot_data)
        low_plot = plotter2.plot(('index', 'close'),)[0]
        low_plot.height = 100
        low_plot.resizable = 'h'
        low_plot.bgcolor = 'white'
        low_plot.border_visible = True
        low_plot.padding = [40, 15, 15, 20]
        low_plot.color = 'darkred'
        low_plot.line_width = 1.5
        self.low_plot = low_plot

        # The third plotter for the bar plot.
        plotter3 = Plot(data=plot_data)
        bar_plot = plotter3.plot(('index', 'volume'), type='bar')[0]
        bar_plot.height = 100
        bar_plot.resizable = 'h'
        bar_plot.bgcolor = 'white'
        bar_plot.border_visible = True
        bar_plot.padding = [40, 15, 15, 20]
        bar_plot.line_color = 'transparent'
        bar_plot.fill_color = 'black'
        bar_plot.bar_width = 3.0
        bar_plot.bar_width_type = 'screen'
        bar_plot.antialias = False
        bar_plot.index_mapper = low_plot.index_mapper
        self.bar_plot = bar_plot
    
        for plot in (close_plot, low_plot, bar_plot):
            ticker = ScalesTickGenerator(scale=CalendarScaleSystem())
            bottom_axis = PlotAxis(plot, orientation='bottom', 
                                   tick_generator=ticker)
            plot.overlays.append(bottom_axis)
            plot.overlays.append(PlotAxis(plot, orientation='left'))
            hgrid, vgrid = add_default_grids(plot)
            vgrid.tick_generator = bottom_axis.tick_generator
        
        def vol_label_formatter(val):
            return '%.1E' % val
        
        bar_plot.overlays[-1].tick_label_formatter = vol_label_formatter

        container = VPlotContainer(
            bgcolor=(240/255., 240/255., 240/255., 1.0),
            spacing=20,
            padding=20,
            fill_padding=True,
            stack_order='top_to_bottom',
            use_back_buffer=True,
        )

        container.add(close_plot)
        container.add(low_plot)
        container.add(bar_plot)

        close_plot.controller = RangeSelection(close_plot)
        zoom_overlay = ZoomOverlay(source=close_plot, destination=low_plot,
                                   other=bar_plot)
        container.overlays.append(zoom_overlay)

        return container


########NEW FILE########
__FILENAME__ = stock_data
#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
""" A simple module that acts like a remote db for stock info. """
import time
import datetime
import numpy as np


def datestr2ts(date):
    year, month, day = date.split('-')
    dt = datetime.date(int(year), int(month), int(day))
    return time.mktime(dt.timetuple())


class TickData(object):

    usecols = (2, 3, 4, 5, 6, 7)

    converters = {
        2: datestr2ts,
        3: float,
        4: float,
        5: float,
        6: float,
        7: int,
    }

    dtype = np.dtype([
        ('dates', 'float'), 
        ('open', 'float'), 
        ('high', 'float'),
        ('low', 'float'), 
        ('close', 'float'), 
        ('volume', 'int'),
    ])

    def __init__(self, path):
        self._arr = np.loadtxt(path, dtype=self.dtype, usecols=self.usecols,
                               delimiter=',', converters=self.converters)[::-1]
        
    @property
    def min_date(self):
        return self._arr['dates'][0]
    
    @property
    def max_date(self):
        return self._arr['dates'][-1]
    
    def get_data(self, start, end, numpoints):
        arr = self._arr
        dates = np.linspace(start, end, numpoints)
        out = np.empty((numpoints,), dtype=self.dtype)
        out['dates'] = dates
        indexes = arr['dates']
        out['open'] = np.interp(dates, indexes, arr['open'])
        out['close'] = np.interp(dates, indexes, arr['close'])
        out['low'] = np.interp(dates, indexes, arr['low'])
        out['high'] = np.interp(dates, indexes, arr['high'])
        out['volume'] = np.interp(dates, indexes, arr['volume'])
        return out


_db_symbols = {
    'MSFT': TickData('./demo_support/msft.csv'),
    'AAPL': TickData('./demo_support/aapl.csv'),
    'GOOG': TickData('./demo_support/goog.csv'),
}


def get_symbols():
    return sorted(_db_symbols.keys())


def get_symbol_date_range(symbol):
    tick_data = _db_symbols.get(symbol)
    if not tick_data:
        return
    return (datetime.date.fromtimestamp(tick_data.min_date), 
            datetime.date.fromtimestamp(tick_data.max_date))


def get_data(symbol, start_date, end_date, numpoints):
    tick_data = _db_symbols.get(symbol)
    if not tick_data:
        return
    startts = time.mktime(start_date.timetuple())
    endts = time.mktime(end_date.timetuple())
    return tick_data.get_data(startts, endts, numpoints)


########NEW FILE########
__FILENAME__ = stock_example
#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
import datetime

from traits.api import (
    HasTraits, List, Str, Date, Enum, Property, Array, Int, Tuple, 
    on_trait_change, Instance, Event, cached_property, DelegatesTo, Float,
)

import enaml
from enaml.core.item_model import AbstractTableModel
from enaml.styling.color import Color
from enaml.styling.brush import Brush

import stock_data
from plot_driver import PlotDriver

with enaml.imports():
    from stock_view import MainView


class HistoricData(HasTraits):

    available_symbols = List(Str)

    symbol = Enum(values='available_symbols')

    date_range = Tuple(Date, Date)

    end_date = Date

    days_of_history_choices = Property(depends_on='date_range')

    days_of_history = Enum(values='days_of_history_choices')

    start_date = Property(depends_on=['end_date', 'days_of_history'])

    num_points = Int(500)

    data = Array

    value = Float(42)

    def _available_symbols_default(self):
        return stock_data.get_symbols()

    def _date_range_default(self):
        return stock_data.get_symbol_date_range(self.symbol)

    def _end_date_default(self):
        return self.date_range[1] - datetime.timedelta(days=1)

    def _get_days_of_history_choices(self):
        start, end = self.date_range
        return range(100, (end - start).days, 100)

    def _get_start_date(self):
        return self.end_date - datetime.timedelta(days=self.days_of_history)

    def _compute_data(self):
        symbol = self.symbol
        start = self.start_date
        end = self.end_date
        num_points = self.num_points
        return stock_data.get_data(symbol, start, end, num_points)

    def _data_default(self):
        return self._compute_data()

    @on_trait_change('symbol')
    def _refresh_date_range(self, symbol):
        self.date_range = stock_data.get_symbol_date_range(symbol)

    @on_trait_change('symbol, start_date, end_date, num_points')
    def _refresh_data(self):
        self.data = self._compute_data()


class GridDataAdapter(HasTraits):

    model = Instance(HistoricData, ())

    data = DelegatesTo('model')

    available_columns = List(Str)

    grid_columns = List(Str)

    thresh = Property(depends_on='data')

    grid_size = Property(depends_on=['data', 'grid_columns'])

    grid_changed = Event

    def _available_columns_default(self):
        return ['open', 'close', 'low', 'high', 'volume']

    def _grid_columns_default(self):
        return ['open', 'close', 'low', 'high', 'volume']

    @cached_property
    def _get_grid_size(self):
        return (len(self.model.data), len(self.grid_columns))

    @on_trait_change('data, grid_columns')
    def grid_updated(self):
        self.grid_changed = True

    @cached_property
    def _get_thresh(self):
        data = self.data
        min = data['close'].min()
        max = data['close'].max()
        return 0.9 * (max - min) + min


HIGHLIGHT = Brush(Color.from_string('lightskyblue'), None)

TEXTCOLOR = Brush(Color.from_string('darkgray'), None)

NULLBRUSH = None


class StockDataTable(AbstractTableModel):

    def __init__(self, adapter):
        super(StockDataTable, self).__init__()
        self.adapter = adapter
        adapter.on_trait_change(self.refresh_table, 'grid_changed')

    def refresh_table(self):
        self.begin_reset_model()
        self.end_reset_model()

    def column_count(self, parent=None):
        if parent is None:
            return self.adapter.grid_size[1]
        return 0

    def row_count(self, parent=None):
        if parent is None:
            return self.adapter.grid_size[0]
        return 0
        
    def data(self, index):
        adapter = self.adapter
        data = adapter.data
        column = adapter.grid_columns[index.column]
        data = data[column][index.row]
        if data > 1e4:
            res = '%.2E' % data
        else:
            res = '%.2f' % data
        return res
    
    def background(self, index):
        adapter = self.adapter
        data = adapter.data['close'][index.row]
        if data > adapter.thresh:
            return HIGHLIGHT
        return NULLBRUSH
    
    def foreground(self, index):
        adapter = self.adapter
        data = adapter.data['close'][index.row]
        if data > adapter.thresh:
            return NULLBRUSH
        return TEXTCOLOR

    def vertical_header_data(self, section):
        data = self.adapter.data
        ts = data['dates'][section]
        return str(datetime.date.fromtimestamp(ts))
    
    def horizontal_header_data(self, section):
        return self.adapter.grid_columns[section].capitalize()


if __name__ == '__main__':
    model = HistoricData()
    plot_driver = PlotDriver(model)
    adapter = GridDataAdapter(model=model)
    data_table = StockDataTable(adapter)

    view = MainView(model=model, adapter=adapter, plot=plot_driver,
                    stock_data_table=data_table)
    view.show()


########NEW FILE########
__FILENAME__ = zoom_overlay
#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------

from __future__ import with_statement

import numpy as np

from enable.api import ColorTrait, Component
from traits.api import Float, Instance, Int
from chaco.api import AbstractOverlay, BaseXYPlot


class ZoomOverlay(AbstractOverlay):
    """
    Draws a trapezoidal selection overlay from the source plot to the
    destination plot.  Assumes that the source plot lies above the destination
    plot.
    """
    source = Instance(BaseXYPlot)
    destination = Instance(Component)
    other = Instance(Component)

    border_color = ColorTrait((0, 0, 0.7, 1))
    border_width = Int(1)
    fill_color = ColorTrait("dodgerblue")
    alpha = Float(0.3)

    def calculate_points(self, component):
        """
        Calculate the overlay polygon based on the selection and the location
        of the source and destination plots.
        """
        # find selection range on source plot
        x_start, x_end = self._get_selection_screencoords()
        if x_start > x_end:
            x_start, x_end = x_end, x_start

        y_end = self.source.y
        y_start = self.source.y2

        left_top = np.array([x_start, y_start])
        left_mid = np.array([x_start, y_end])
        right_top = np.array([x_end, y_start])
        right_mid = np.array([x_end, y_end])

        # Offset y because we want to avoid overlapping the trapezoid with the topmost
        # pixels of the destination plot.
        y = self.destination.y2 + 1

        left_end = np.array([self.destination.x, y])
        right_end = np.array([self.destination.x2, y])

        polygon = np.array((left_top, left_mid, left_end,
                         right_end,right_mid, right_top))
        left_line = np.array((left_top, left_mid, left_end))
        right_line = np.array((right_end,right_mid, right_top))

        return left_line, right_line, polygon

    def overlay(self, component, gc, view_bounds=None, mode="normal"):
        """
        Draws this overlay onto 'component', rendering onto 'gc'.
        """

        tmp = self._get_selection_screencoords()
        if tmp is None:
            return

        left_line, right_line, polygon = self.calculate_points(component)

        with gc:
            gc.translate_ctm(*component.position)
            gc.set_alpha(self.alpha)
            gc.set_fill_color(self.fill_color_)
            gc.set_line_width(self.border_width)
            gc.set_stroke_color(self.border_color_)
            gc.begin_path()
            gc.lines(polygon)
            gc.fill_path()

            gc.begin_path()
            gc.lines(left_line)
            gc.lines(right_line)
            gc.stroke_path()

        return

    def _get_selection_screencoords(self):
        """
        Returns a tuple of (x1, x2) screen space coordinates of the start
        and end selection points.  If there is no current selection, then
        returns None.
        """
        selection = self.source.index.metadata["selections"]
        if selection is not None and len(selection) == 2:
            mapper = self.source.index_mapper
            return mapper.map_screen(np.array(selection))
        else:
            return None

    #------------------------------------------------------------------------
    # Trait event handlers
    #------------------------------------------------------------------------

    def _source_changed(self, old, new):
        if old is not None and old.controller is not None:
            old.controller.on_trait_change(self._selection_update_handler, "selection",
                                           remove=True)
        if new is not None and new.controller is not None:
            new.controller.on_trait_change(self._selection_update_handler, "selection")
        return

    def _selection_update_handler(self, value):
        if value is not None and self.destination is not None:
            r = self.destination.index_mapper.range
            start, end = np.amin(value), np.amax(value)
            r.low = start
            r.high = end

            start_idx, end_idx = np.searchsorted(self.destination.index.get_data(), [start, end])
            value = self.destination.value.get_data()[start_idx:end_idx]
            if len(value):
                r = self.destination.value_mapper.range
                start, end = np.min(value), np.max(value)
                r.low = start
                r.high = end

            value = self.other.value.get_data()[start_idx:end_idx]
            if len(value):
                r = self.other.value_mapper.range
                start, end = np.min(value), np.max(value)
                r.low = start
                r.high = end
        else:
            self.destination.index_mapper.range.low = 'auto'
            self.destination.index_mapper.range.high = 'auto'
            self.destination.value_mapper.range.low = 'auto'
            self.destination.value_mapper.range.high = 'auto'
            self.other.value_mapper.range.low = 'auto'
            self.other.value_mapper.range.high = 'auto'

        self.source.request_redraw()
        self.destination.request_redraw()
        self.other.request_redraw()

########NEW FILE########
__FILENAME__ = main
#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from datetime import datetime
import os

import numpy as np

from chaco.api import Plot, ArrayPlotData

import enaml
from enaml.core.item_model import AbstractItemModel, ALIGN_LEFT


class Node(object):
    """ A simple node class for building up a filesystem tree.

    """
    def __init__(self, parent, text, stat, files=None, children=None):
        self.parent = parent
        self.text = text
        self.stat = stat
        self.children = children or []


def make_fs_tree():
    """ Returns the root node of a filesystem tree for the directory 
    downward.

    """
    this_path = os.path.abspath(__file__)
    root_path = os.path.split(os.path.dirname(this_path))[0]
    node_cache = {}
    root = Node(None, '', '')
    node_cache[root_path] = root
    gen = os.walk(root_path)

    while True:
        try:
            dirpath, dirnames, filenames = gen.next()
        except StopIteration:
            break
        if dirpath not in node_cache:
            continue
        parent = node_cache[dirpath]
        for dn in dirnames:
            if not dn.startswith('.'):
                fd = os.path.join(dirpath, dn)
                s = os.stat(fd)
                node = Node(parent, dn, s)
                node_cache[fd] = node
                parent.children.append(node)
        for fn in filenames:
            if not fn.startswith('.'):
                s = os.stat(os.path.join(dirpath, fn))
                parent.children.append(Node(parent, fn, s))

    return root


class FSModel(AbstractItemModel):
    """ An AbstractItemModel implementation which exposes the
    filesystem tree.

    """
    fs_root = make_fs_tree()

    def index(self, row, column, parent=None):
        """ Abstract method implementation that will create a valid
        model index for the given row and column if they are valid.
        Otherwise, returns an invalid index.

        """
        if self.has_index(row, column, parent):
            if parent is None:
                parent_node = self.fs_root
            else:
                parent_node = parent.context
            child = parent_node.children[row]
            return self.create_index(row, column, child)

    def parent(self, index):
        """ Abstract method implementation that always returns None, 
        forcing the model to be flat.

        """
        if index is None:
            return
        node = index.context
        node_parent = node.parent
        if node_parent is self.fs_root:
            return None
        node_parent_parent = node.parent.parent
        idx = node_parent_parent.children.index(node_parent)
        return self.create_index(idx, index.column, node_parent)
    
    def row_count(self, idx):
        if idx is None:
            node = self.fs_root
        else:
            node = idx.context
        return len(node.children)
    
    def column_count(self, idx):
        return 3
    
    def data(self, idx):
        col = idx.column
        node = idx.context
        if col == 0:
            res = node.text
        elif col == 1:
            res = str(node.stat.st_size / 1024) + ' kb'
        else:
            dt = datetime.fromtimestamp(node.stat.st_mtime)
            res = dt.strftime('%c')
        return res
    
    def horizontal_header_data(self, section):
        return ['Name', 'Size', 'Last Modified'][section]

    def alignment(self, index):
        if index.column == 0:
            return ALIGN_LEFT
        return super(FSModel, self).alignment(index)


def make_sin_plot():
    """ Returns a chaco plot which plots a simple sin curve.

    """
    idx = np.linspace(0, np.pi * 2, 100)
    val = np.sin(idx)
    plt = Plot(ArrayPlotData(x=idx, y=val), padding_top=30, padding_bottom=30, 
               padding_left=35, padding_right=10, title='Sin Plot',
               fill_padding=False, background='transparent')
    plt.plot(('x', 'y'), color='red')
    return plt


def make_html_table():
    """ Returns a string of html table data.

    """
    html = """
    <html>
        <h1> Simple HTML </h1>
        <body>
            <h4>Cell that spans two columns:</h4>
            <table border="1">
                <tr>
                  <th>Name</th>
                  <th colspan="2">Telephone</th>
                </tr>
                <tr>
                  <td>Tony Stark</td>
                  <td>555 77 854</td>
                  <td>555 77 855</td>
                </tr>
            </table>
            <h4>Cell that spans two rows:</h4>
            <table border="1">
                <tr>
                  <th>First Name:</th>
                  <td>Pepper Potts</td>
                </tr>
                <tr>
                  <th rowspan="2">Telephone:</th>
                  <td>555 77 854</td>
                </tr>
                <tr>
                  <td>555 77 855</td>
                </tr>
            </table>
        </body>
    </html>
    """
    return html


def main():
    with enaml.imports():
        from widget_gallery import WidgetGallery

    img_path = os.path.join(os.path.dirname(__file__), 'lena.png')
    view = WidgetGallery(
        fs_model=FSModel(), sin_plot=make_sin_plot(),
        html_data=make_html_table(), img_path=img_path,
    )
    view.show()


if __name__ == '__main__':
    main()


########NEW FILE########
__FILENAME__ = employee
#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
import datetime

from traits.api import HasTraits, Str, Int, Instance, Tuple, Date, Property

import enaml
from enaml.stdlib.sessions import show_simple_view


class Person(HasTraits):
    """ A simple class representing a person object.

    """
    # The last name of the person as a string
    last_name = Str

    # The first name of the person as a string
    first_name = Str

    # The date of birth of the person
    dob = Date(datetime.date(1970, 1, 1))

    # The age of the person computed from their dob
    age = Property(Int, depends_on='dob')

    # This method is called when the age of the person needs to
    # be computed
    def _get_age(self):
        today = datetime.date.today()
        dob = self.dob
        age = today.year - dob.year
        birthday_this_year = dob.replace(year=today.year)
        if today < birthday_this_year:
            age -= 1
        return age


class Employer(Person):
    """ An employer is a person who runs a company.

    """
    # The name of the company
    company_name = Str


class Employee(Person):
    """ An employee is person with a boss and a phone number.

    """
    # The employee's boss
    boss = Instance(Employer)

    # The employee's phone number as a tuple of 3 ints
    phone = Tuple(Int, Int, Int)

    # This method is called automatically by traits to get the
    # default value for the phone number.
    def _phone_default(self):
        return (555, 555, 5555)

    # This method will be called automatically by traits when the 
    # employee's phone number changes
    def _phone_changed(self, val):
        print 'received new phone number for %s: %s' % (self.first_name, val)


if __name__ == '__main__':
    # Create an employee with a boss
    boss_john = Employer(
        first_name='John', last_name='Paw', company_name="Packrat's Cats"
    )
    employee_mary = Employee(
        first_name='Mary', last_name='Sue', boss=boss_john
    )

    # Import our Enaml EmployeeView
    with enaml.imports():
        from employee_view import EmployeeView

    # Create a view and show it.
    view = EmployeeView(employee=employee_mary)
    show_simple_view(view)


########NEW FILE########
__FILENAME__ = phone_validator
#------------------------------------------------------------------------------
#  Copyright (c) 2012, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
import re

from enaml.validation.api import Validator


class PhoneNumberValidator(Validator):
    """ A really dumb phone number validator.

    """
    all_digits = re.compile(r'[0-9]{10}$')
    
    dashes = re.compile(r'([0-9]{3})\-([0-9]{3})\-([0-9]{4})$')
    
    proper = re.compile(r'\(([0-9]{3})\)\ ([0-9]{3})\-([0-9]{4})$')

    def validate(self, text, component):
        match = self.proper.match(text) or self.dashes.match(text)
        if match:
            area = match.group(1)
            prefix = match.group(2)
            suffix = match.group(3)
            formatted_text = '(%s) %s-%s' % (area, prefix, suffix)
            return formatted_text, True
        match = self.all_digits.match(text)
        if match:
            area = text[:3]
            prefix = text[3:6]
            suffix = text[6:10]
            formatted_text = '(%s) %s-%s' % (area, prefix, suffix)
            return formatted_text, True
        return text, False


########NEW FILE########
__FILENAME__ = hello_world
#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
import enaml
from enaml.stdlib.sessions import show_simple_view


if __name__ == '__main__':
    with enaml.imports():
        from hello_world_view import Main

    main_view = Main()
    show_simple_view(main_view)


########NEW FILE########
__FILENAME__ = hello_world_sessions
#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
import enaml
from enaml.stdlib.sessions import simple_session


if __name__ == '__main__':
    with enaml.imports():
        from hello_world_view import Main

    sess_one = simple_session('hello-world', 'A hello world example', Main)
    sess_two = simple_session(
        'hello-world-python', 'A customized hello world example',
        Main, message="Hello, world, from Python!"
    )

    from enaml.qt.qt_application import QtApplication
    app = QtApplication([sess_one, sess_two])
    app.start_session('hello-world')
    app.start_session('hello-world-python')
    app.start()

########NEW FILE########
__FILENAME__ = person
#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
from traits.api import HasTraits, Str, Range, Bool, on_trait_change

import enaml
from enaml.stdlib.sessions import simple_session
from enaml.qt.qt_application import QtApplication


class Person(HasTraits):
    """ A simple class representing a person object.

    """
    last_name = Str

    first_name = Str

    age = Range(low=0)

    debug = Bool(False)

    @on_trait_change('age')
    def debug_print(self):
        """ Prints out a debug message whenever the person's age changes.

        """
        if self.debug:
            templ = "{first} {last} is {age} years old."
            s = templ.format(
                first=self.first_name, last=self.last_name, age=self.age,
            )
            print s


if __name__ == '__main__':
    with enaml.imports():
        from person_view import PersonView

    john = Person(first_name='John', last_name='Doe', age=42)
    john.debug = True

    session = simple_session(
        'john', 'A view of the Person john', PersonView, person=john
    )

    app = QtApplication([session])
    app.start_session('john')
    app.start()


########NEW FILE########
