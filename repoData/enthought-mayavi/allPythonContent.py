__FILENAME__ = adjust_cropping_extents
"""
A custom dialog to adjust the parameters of a GeometryFilter to crop
data points.

This example shows how to use a GeometryFilter to crop data points, but
also how to build a custom dialog to easily set interactively parameters
of a filter, or any other Mayavi object.

The GeometryFilter crops all data within a bounding box specified by
'extents'. In this example, we want to be able to tweak these extents
interactively. For this, we build a Traits object that has 'x_min',
'x_max', 'y_min', ... attributes. Traits enables us to represent this
object as a dialog box. We use a callback called when these attributes
are modified to propagate them to the filter. For more information
on creating GUIs with Traits:

    http://code.enthought.com/projects/traits/docs/html/tutorials/traits_ui_scientific_app.html

    http://code.enthought.com/projects/traits/documentation.php

"""
# Author: Gael Varoquaux <gael.varoquaux@normalesup.org>
# Copyright (c) 2010, Enthought, Inc.
# License: BSD Style.


################################################################################
# Create a set of points, with given density
import numpy as np
x, y, z, s = np.random.random((4, 500))

################################################################################
# A dialog to edit a range interactively and propagate it to the filter
from traits.api import HasTraits, Range, Float, Instance, \
    on_trait_change
from traitsui.api import View

class ExtentDialog(HasTraits):
    """ A dialog to graphical adjust the extents of a filter.
    """

    # Data extents
    data_x_min = Float
    data_x_max = Float
    data_y_min = Float
    data_y_max = Float
    data_z_min = Float
    data_z_max = Float

    x_min = Range('data_x_min', 'data_x_max', 'data_x_min')
    x_max = Range('data_x_min', 'data_x_max', 'data_x_max')
    y_min = Range('data_y_min', 'data_y_max', 'data_y_min')
    y_max = Range('data_y_min', 'data_y_max', 'data_y_max')
    z_min = Range('data_z_min', 'data_z_max', 'data_z_min')
    z_max = Range('data_z_min', 'data_z_max', 'data_z_max')

    filter = Instance(HasTraits, allow_none=False)

    @on_trait_change('x_min,x_max,y_min,y_max,z_min,z_max')
    def update_extent(self):
        if (self.filter is not None
                    and self.x_min < self.x_max
                    and self.y_min < self.y_max
                    and self.z_min < self.z_max
                            ):
            self.filter.extent = (self.x_min, self.x_max,
                                  self.y_min, self.y_max,
                                  self.z_min, self.z_max)

    view = View('x_min', 'x_max', 'y_min', 'y_max', 'z_min', 'z_max',
                title='Edit extent', resizable=True)


################################################################################
# Now build the visualization using mlab
from mayavi import mlab
fig = mlab.figure(1, bgcolor=(1, 1, 1))

# Create unconnected points
pts = mlab.pipeline.scalar_scatter(x, y, z, s)
mlab.outline(pts)

# Use a geometry_filter to filter with a bounding box
geometry_filter = mlab.pipeline.user_defined(pts,
                                   filter='GeometryFilter')
geometry_filter.filter.extent_clipping = True
# Connect our dialog to the filter
extent_dialog = ExtentDialog(
            data_x_min=0, data_x_max=1,
            data_y_min=0, data_y_max=1,
            data_z_min=0, data_z_max=1,
            filter=geometry_filter.filter)
# We need to use 'edit_traits' and not 'configure_traits()' as we do
# not want to start the GUI event loop (the call to mlab.show())
# at the end of the script will do it.
extent_dialog.edit_traits()

# The geometry_filter leaves hanging points, we need to add a
# CleanPolyData filter to get rid of these.
clip = mlab.pipeline.user_defined(geometry_filter,
                                    filter='CleanPolyData')

# Finally, visualize the remaining points with spheres using a glyph
# module
spheres = mlab.pipeline.glyph(clip, scale_factor=.1)

mlab.show()

########NEW FILE########
__FILENAME__ = atomic_orbital
"""
An example showing the norm and phase of an atomic orbital: isosurfaces of
the norm, with colors  displaying the phase.

This example shows how you can apply a filter on one data set, and dislay
a second data set on the output of the filter. Here we use the contour
filter to extract isosurfaces of the norm of a complex field, and we
display the phase of the field with the colormap.

The field we choose to plot is a simplified version of the 3P_y atomic
orbital for hydrogen-like atoms.

The first step is to create a data source with two scalar datasets. The
second step is to apply filters and modules, using the
'set_active_attribute' filter to select on which data these apply.

Creating a data source with two scalar datasets is actually slighlty
tricky, as it requires some understanding of the layout of the datasets
in TVTK. The reader is referred to :ref:`data-structures-used-by-mayavi`
for more details.
"""
# Author: Gael Varoquaux <gael.varoquaux@normalesup.org>
# Copyright (c) 2008, Enthought, Inc.
# License: BSD Style.

# Create the data ############################################################
import numpy as np

x, y, z = np.ogrid[- .5:.5:200j, - .5:.5:200j, - .5:.5:200j]
r = np.sqrt(x ** 2 + y ** 2 + z ** 2)


# Generalized Laguerre polynomial (3, 2)
L = - r ** 3 / 6 + 5. / 2 * r ** 2 - 10 * r + 6

# Spherical harmonic (3, 2)
Y = (x + y * 1j) ** 2 * z / r ** 3

Phi = L * Y * np.exp(- r) * r ** 2

# Plot it ####################################################################
from mayavi import mlab
mlab.figure(1, fgcolor=(1, 1, 1), bgcolor=(0, 0, 0))
# We create a scalar field with the module of Phi as the scalar
src = mlab.pipeline.scalar_field(np.abs(Phi))

# And we add the phase of Phi as an additional array
# This is a tricky part: the layout of the new array needs to be the same
# as the existing dataset, and no checks are performed. The shape needs
# to be the same, and so should the data. Failure to do so can result in
# segfaults.
src.image_data.point_data.add_array(np.angle(Phi).T.ravel())
# We need to give a name to our new dataset.
src.image_data.point_data.get_array(1).name = 'angle'
# Make sure that the dataset is up to date with the different arrays:
src.image_data.point_data.update()

# We select the 'scalar' attribute, ie the norm of Phi
src2 = mlab.pipeline.set_active_attribute(src,
                                    point_scalars='scalar')

# Cut isosurfaces of the norm
contour = mlab.pipeline.contour(src2)

# Now we select the 'angle' attribute, ie the phase of Phi
contour2 = mlab.pipeline.set_active_attribute(contour,
                                    point_scalars='angle')

# And we display the surface. The colormap is the current attribute: the phase.
mlab.pipeline.surface(contour2, colormap='hsv')

mlab.colorbar(title='Phase', orientation='vertical', nb_labels=3)

mlab.show()

########NEW FILE########
__FILENAME__ = boy
"""
A script to generate the Mayavi logo: a Boy surface.

The boy surface is a mathematical parametric surface, see
http://en.wikipedia.org/wiki/Boy%27s_surface . We display it by sampling
the two parameters of the surface on a grid and using the mlab's mesh
function: :func:`mayavi.mlab.mesh`.
"""

# Author: Gael Varoquaux <gael.varoquaux@normalesup.org>
# Copyright (c) 2007, Enthought, Inc.
# License: BSD Style.


from numpy import sin, cos, mgrid, pi, sqrt
from mayavi import mlab

mlab.figure(fgcolor=(0, 0, 0), bgcolor=(1, 1, 1))
u, v = mgrid[- 0.035:pi:0.01, - 0.035:pi:0.01]

X = 2 / 3. * (cos(u) * cos(2 * v)
        + sqrt(2) * sin(u) * cos(v)) * cos(u) / (sqrt(2) -
                                                 sin(2 * u) * sin(3 * v))
Y = 2 / 3. * (cos(u) * sin(2 * v) -
        sqrt(2) * sin(u) * sin(v)) * cos(u) / (sqrt(2)
        - sin(2 * u) * sin(3 * v))
Z = -sqrt(2) * cos(u) * cos(u) / (sqrt(2) - sin(2 * u) * sin(3 * v))
S = sin(u)

mlab.mesh(X, Y, Z, scalars=S, colormap='YlGnBu', )

# Nice view from the front
mlab.view(.0, - 5.0, 4)
mlab.show()

########NEW FILE########
__FILENAME__ = canyon
"""
Retrieve radar data from the NASA and plot a view of the Grand Canyon
landscape.

We cannot display the whole data, as it would be too big. To display
more, see the canyon decimation example.

This example is interesting as it shows how numpy can be used to load
and crop data completly foreign to Mayavi.
"""
# Author: Gael Varoquaux <gael.varoquaux@normalesup.org>
# Copyright (c) 2008, Enthought, Inc.
# License: BSD Style.

# Retrieve the grand Canyon topological data ##################################
import os
# Original file:
#'ftp://e0srp01u.ecs.nasa.gov/srtm/version2/SRTM1/Region_04/N36W113.hgt.zip'
if not os.path.exists('N36W113.hgt.zip'):
    # Download the data
    import urllib
    print 'Downloading data, please wait (10M)'
    opener = urllib.urlopen(
    'http://staging.enthought.com/projects/mayavi/N36W113.hgt.zip'
        )
    open('N36W113.hgt.zip', 'wb').write(opener.read())

# Load the data (signed 2 byte integers, big endian) ##########################
import zipfile
import numpy as np

data = np.fromstring(zipfile.ZipFile('N36W113.hgt.zip').read('N36W113.hgt'),
                    '>i2')
data.shape = (3601, 3601)
data = data.astype(np.float32)

# Plot an interesting section #################################################
from mayavi import mlab
data = data[:1000, 900:1900]
# Convert missing values into something more sensible.
data[data == -32768] = data[data > 0].min()

mlab.figure(size=(400, 320), bgcolor=(0.16, 0.28, 0.46))
mlab.surf(data, colormap='gist_earth', warp_scale=0.2,
            vmin=1200, vmax=1610)
# The data takes a lot of memory, and the surf command has created a
# copy. We free the inital memory.
del data

# A view of the canyon
mlab.view(-5.9, 83, 570, [5.3, 20, 238])
mlab.show()

########NEW FILE########
__FILENAME__ = canyon_decimation
"""
Use the greedy-terrain-decimator to display a decimated terrain view.

This example illustrates decimating a terrain. We use the
greedy-terrain-decimator to create a reduced mesh with an optimized grid that
approximates the initial regular grid.

The initial grid is displayed in white, and the optimized grid is displayed in
black, with the surface it creates. The initial grid can be seen
disappearing as it goes under the surface of the approximated grid:
although the decimated mesh follows closely the orginal, it is not
exactly the same.

One can see that the reduction in number of polygons is huge: the white
grid is much finer than the black grid. It is interesting to note that
the decimated mesh follows closely the original mesh, including in number
of polygons, in spots where the terrain changes most quickly.

This example uses the Grand Canyon topological radar data, from NASA.

The greedy-terrain-decimator is only useful to decimate a surface
warped from 2D data. To decimated more general meshes, you can use the
less-efficient decimate-pro filter (see :ref:`example_julia_set_decimation`).
"""
# Author: Gael Varoquaux <gael.varoquaux@normalesup.org>
# Copyright (c) 2008, Enthought, Inc.
# License: BSD Style.

# Retrieve the grand Canyon topological data ###################################
# Original file:
#'ftp://e0srp01u.ecs.nasa.gov/srtm/version2/SRTM1/Region_04/N36W113.hgt.zip'
import os
if not os.path.exists('N36W113.hgt.zip'):
    # Download the data
    import urllib
    print 'Downloading data, please wait (10M)'
    opener = urllib.urlopen(
    'http://staging.enthought.com/projects/mayavi/N36W113.hgt.zip'
        )
    open('N36W113.hgt.zip', 'wb').write(opener.read())

# Load the data (signed 2 byte integers, big endian) ###########################
import zipfile
import numpy as np

data = np.fromstring(zipfile.ZipFile('N36W113.hgt.zip').read('N36W113.hgt'),
                    '>i2')
data.shape = (3601, 3601)
data = data[200:400, 1200:1400]
data = data.astype(np.float32)

# Plot an interecting section ##################################################
from mayavi import mlab
mlab.figure(1, size=(450, 390))
mlab.clf()
data = mlab.pipeline.array2d_source(data)

# Use a greedy_terrain_decimation to created a decimated mesh
terrain = mlab.pipeline.greedy_terrain_decimation(data)
terrain.filter.error_measure = 'number_of_triangles'
terrain.filter.number_of_triangles = 5000
terrain.filter.compute_normals = True

# Plot it black the lines of the mesh
lines = mlab.pipeline.surface(terrain, color=(0, 0, 0),
                                      representation='wireframe')
# The terrain decimator has done the warping. We control the warping
# scale via the actor's scale.
lines.actor.actor.scale = [1, 1, 0.2]

# Display the surface itself.
surf = mlab.pipeline.surface(terrain, colormap='gist_earth',
                                      vmin=1450, vmax=1650)
surf.actor.actor.scale = [1, 1, 0.2]

# Display the original regular grid. This time we have to use a
# warp_scalar filter.
warp = mlab.pipeline.warp_scalar(data, warp_scale=0.2)
grid = mlab.pipeline.surface(warp, color=(1, 1, 1),
                                      representation='wireframe')

mlab.view(-17, 46, 143, [1.46, 8.46, 269.4])

mlab.show()


########NEW FILE########
__FILENAME__ = chemistry
"""
In this example, we display the H2O molecule, and use volume rendering to
display the electron localization function.

The atoms and the bounds are displayed using mlab.points3d and
mlab.plot3d, with scalar information to control the color.

The electron localization function is displayed using volume rendering.
Good use of the `vmin` and `vmax` argument to
`mlab.pipeline.volume` is critical to achieve a good visualization: the
`vmin` threshold should placed high-enough for features to stand out.

The original is an electron localization function from Axel Kohlmeyer.
"""
# Author: Gael Varoquaux <gael.varoquaux@normalesup.org>
# Copyright (c) 2008, Enthought, Inc.
# License: BSD Style.

# Retrieve the electron localization data for H2O #############################
import os
if not os.path.exists('h2o-elf.cube'):
    # Download the data
    import urllib
    print 'Downloading data, please wait'
    opener = urllib.urlopen(
        'http://code.enthought.com/projects/mayavi/data/h2o-elf.cube'
        )
    open('h2o-elf.cube', 'wb').write(opener.read())


# Plot the atoms and the bonds ################################################
import numpy as np
from mayavi import mlab
mlab.figure(1, bgcolor=(0, 0, 0), size=(350, 350))
mlab.clf()

# The position of the atoms
atoms_x = np.array([2.9, 2.9, 3.8]) * 40 / 5.5
atoms_y = np.array([3.0, 3.0, 3.0]) * 40 / 5.5
atoms_z = np.array([3.8, 2.9, 2.7]) * 40 / 5.5

O = mlab.points3d(atoms_x[1:-1], atoms_y[1:-1], atoms_z[1:-1],
                  scale_factor=3,
                  resolution=20,
                  color=(1, 0, 0),
                  scale_mode='none')

H1 = mlab.points3d(atoms_x[:1], atoms_y[:1], atoms_z[:1],
                   scale_factor=2,
                   resolution=20,
                   color=(1, 1, 1),
                   scale_mode='none')

H2 = mlab.points3d(atoms_x[-1:], atoms_y[-1:], atoms_z[-1:],
                   scale_factor=2,
                   resolution=20,
                   color=(1, 1, 1),
                   scale_mode='none')

# The bounds between the atoms, we use the scalar information to give
# color
mlab.plot3d(atoms_x, atoms_y, atoms_z, [1, 2, 1],
            tube_radius=0.4, colormap='Reds')

# Display the electron localization function ##################################

# Load the data, we need to remove the first 8 lines and the '\n'
str = ' '.join(file('h2o-elf.cube').readlines()[9:])
data = np.fromstring(str, sep=' ')
data.shape = (40, 40, 40)

source = mlab.pipeline.scalar_field(data)
min = data.min()
max = data.max()
vol = mlab.pipeline.volume(source, vmin=min + 0.65 * (max - min),
                                   vmax=min + 0.9 * (max - min))

mlab.view(132, 54, 45, [21, 20, 21.5])

mlab.show()

########NEW FILE########
__FILENAME__ = coil_design_application
"""
An full-blown application demoing a domain-specific usecase with Mayavi:
interactive design of coils.

This is example of electromagnetic coils design, an application is built to
enable a user to interactively position current loops while visualizing the
resulting magnetic field. For this purpose, it is best to use object-oriented
programming. Each current loop is written as an object (the `Loop` class), with
position, radius and direction attributes, and that knows how to calculate the
magnetic field it generates: its `Bnorm` is a property, that is recomputed when
the loop characteristic changes. These loop objects are available to the main
application class as a list. The total magnetic field created is the sum of
each individual magnetic field. It can be visualized via a Mayavi scene
embedded in the application class. As we use Traited objects for the current
loops, a dialog enabling modification of their attributes can be generated by
Traits and embedded in our application.

The full power of Mayavi is available to the application. Via the pipeline tree
view, the user can modify the visualization. Familiar interaction and movements
are possible in the figure. So is saving the visualization, or loading data. In
addition, as the visualization model, described by the pipeline, is separated
from the data that is visualized, contained in the data source, any
visualization module added by the user will update when coils are added or
changed.

Simpler examples of magnetic field visualization can be found on
:ref:`example_magnetic_field_lines` and :ref:`example_magnetic_field`.
The material required to understand this example is covered in section
:ref:`builing_applications`.

"""
# Author: Gael Varoquaux <gael.varoquaux@normalesup.org>
# Copyright (c) 2009, Enthought, Inc.
# License: BSD Style.

# Major scientific library imports
import numpy as np
from scipy import linalg, special

# Enthought library imports:
from traits.api import HasTraits, Array, CFloat, List, \
   Instance, on_trait_change, Property
from traitsui.api import Item, View, ListEditor, \
        HSplit, VSplit
from mayavi.core.ui.api import EngineView, MlabSceneModel, \
        SceneEditor

##############################################################################
# Module-level variables

# The grid of points on which we want to evaluate the field
X, Y, Z = np.mgrid[-0.15:0.15:20j, -0.15:0.15:20j, -0.15:0.15:20j]
# Avoid rounding issues :
f = 1e4  # this gives the precision we are interested by :
X = np.round(X * f) / f
Y = np.round(Y * f) / f
Z = np.round(Z * f) / f

##############################################################################
# A current loop class
class Loop(HasTraits):
    """ A current loop class.
    """

    #-------------------------------------------------------------------------
    # Public traits
    #-------------------------------------------------------------------------
    direction = Array(float, value=(0, 0, 1), cols=3,
                    shape=(3,), desc='directing vector of the loop',
                    enter_set=True, auto_set=False)

    radius    = CFloat(0.1, desc='radius of the loop',
                    enter_set=True, auto_set=False)

    position  = Array(float, value=(0, 0, 0), cols=3,
                    shape=(3,), desc='position of the center of the loop',
                    enter_set=True, auto_set=False)

    _plot      = None

    Bnorm   = Property(depends_on='direction,position,radius')

    view = View('position', 'direction', 'radius', '_')


    #-------------------------------------------------------------------------
    # Loop interface
    #-------------------------------------------------------------------------
    def base_vectors(self):
        """ Returns 3 orthognal base vectors, the first one colinear to
            the axis of the loop.
        """
        # normalize n
        n = self.direction / (self.direction**2).sum(axis=-1)

        # choose two vectors perpendicular to n
        # choice is arbitrary since the coil is symetric about n
        if  np.abs(n[0])==1 :
            l = np.r_[n[2], 0, -n[0]]
        else:
            l = np.r_[0, n[2], -n[1]]

        l /= (l**2).sum(axis=-1)
        m = np.cross(n, l)
        return n, l, m


    @on_trait_change('Bnorm')
    def redraw(self):
        if hasattr(self, 'app') and self.app.scene._renderer is not None:
            self.display()
            self.app.visualize_field()


    def display(self):
        """
        Display the coil in the 3D view.
        """
        n, l, m = self.base_vectors()
        theta = np.linspace(0, 2*np.pi, 30)[..., np.newaxis]
        coil = self.radius*(np.sin(theta)*l + np.cos(theta)*m)
        coil += self.position
        coil_x, coil_y, coil_z = coil.T
        if self._plot is None:
            self._plot = self.app.scene.mlab.plot3d(coil_x, coil_y, coil_z,
                                    tube_radius=0.007, color=(0, 0, 1),
                                    name='Coil')
        else:
            self._plot.mlab_source.set(x=coil_x, y=coil_y, z=coil_z)


    def _get_Bnorm(self):
        """
        returns the magnetic field for the current loop calculated
        from eqns (1) and (2) in Phys Rev A Vol. 35, N 4, pp. 1535-1546; 1987.
        """
        ### Translate the coordinates in the coil's frame
        n, l, m = self.base_vectors()
        R       = self.radius
        r0      = self.position
        r       = np.c_[np.ravel(X), np.ravel(Y), np.ravel(Z)]

        # transformation matrix coil frame to lab frame
        trans = np.vstack((l, m, n))

        r -= r0   #point location from center of coil
        r = np.dot(r, linalg.inv(trans) )           #transform vector to coil frame

        #### calculate field

        # express the coordinates in polar form
        x = r[:, 0]
        y = r[:, 1]
        z = r[:, 2]
        rho = np.sqrt(x**2 + y**2)
        theta = np.arctan2(x, y)

        E = special.ellipe((4 * R * rho)/( (R + rho)**2 + z**2))
        K = special.ellipk((4 * R * rho)/( (R + rho)**2 + z**2))
        Bz =  1/np.sqrt((R + rho)**2 + z**2) * (
                    K
                  + E * (R**2 - rho**2 - z**2)/((R - rho)**2 + z**2)
                )
        Brho = z/(rho*np.sqrt((R + rho)**2 + z**2)) * (
                -K
                + E * (R**2 + rho**2 + z**2)/((R - rho)**2 + z**2)
                )
        # On the axis of the coil we get a divided by zero here. This returns a
        # NaN, where the field is actually zero :
        Brho[np.isnan(Brho)] = 0

        B = np.c_[np.cos(theta)*Brho, np.sin(theta)*Brho, Bz ]

        # Rotate the field back in the lab's frame
        B = np.dot(B, trans)

        Bx, By, Bz = B.T
        Bx = np.reshape(Bx, X.shape)
        By = np.reshape(By, X.shape)
        Bz = np.reshape(Bz, X.shape)

        Bnorm = np.sqrt(Bx**2 + By**2 + Bz**2)

        # We need to threshold ourselves, rather than with VTK, to be able
        # to use an ImageData
        Bmax = 10 * np.median(Bnorm)

        Bx[Bnorm > Bmax] = np.NAN
        By[Bnorm > Bmax] = np.NAN
        Bz[Bnorm > Bmax] = np.NAN
        Bnorm[Bnorm > Bmax] = np.NAN

        self.Bx = Bx
        self.By = By
        self.Bz = Bz
        return Bnorm


##############################################################################
# The application object
class Application(HasTraits):

    scene = Instance(MlabSceneModel, (), editor=SceneEditor())

    # The mayavi engine view.
    engine_view = Instance(EngineView)

    coils = List(Instance(Loop, (), allow_none=False),
                        editor=ListEditor(style='custom'),
                        value=[ Loop(position=(0, 0, -0.05), ),
                                 Loop(position=(0, 0,  0.05), ), ])


    Bx    = Array(value=np.zeros_like(X))
    By    = Array(value=np.zeros_like(X))
    Bz    = Array(value=np.zeros_like(X))
    Bnorm = Array(value=np.zeros_like(X))

    vector_field = None

    def __init__(self, **traits):
        HasTraits.__init__(self, **traits)
        self.engine_view = EngineView(engine=self.scene.engine)


    @on_trait_change('scene.activated,coils')
    def init_view(self):
        if self.scene._renderer is not None:
            self.scene.scene_editor.background = (0, 0, 0)
            for coil in self.coils:
                coil.app = self
                coil.display()

            self.visualize_field()

    def visualize_field(self):
        self.Bx    = np.zeros_like(X)
        self.By    = np.zeros_like(X)
        self.Bz    = np.zeros_like(X)
        self.Bnorm = np.zeros_like(X)
        self.scene.scene.disable_render = True
        for coil in self.coils:
            self.Bx += coil.Bx
            self.By += coil.By
            self.Bz += coil.Bz

        self.Bnorm = np.sqrt(self.Bx**2 + self.By**2 + self.Bz**2)

        if self.vector_field is None:
            self.vector_field = self.scene.mlab.pipeline.vector_field(
                                    X, Y, Z, self.Bx, self.By, self.Bz,
                                    scalars=self.Bnorm,
                                    name='B field')
            vectors = self.scene.mlab.pipeline.vectors(self.vector_field,
                                    mode='arrow', resolution=10,
                                    mask_points=6, colormap='YlOrRd',
                                    scale_factor=2*np.abs(X[0,0,0]
                                                          -X[1,1,1]) )
            vectors.module_manager.vector_lut_manager.reverse_lut = True
            vectors.glyph.mask_points.random_mode = False
            self.scene.mlab.axes()
            self.scp = self.scene.mlab.pipeline.scalar_cut_plane(
                                                      self.vector_field,
                                                      colormap='hot')
        else:
            # Modify in place the data source. The visualization will
            # update automaticaly
            self.vector_field.mlab_source.set(u=self.Bx, v=self.By, w=self.Bz,
                                              scalars=self.Bnorm)
        self.scene.scene.disable_render = False


    view = View(HSplit(
                    VSplit(Item(name='engine_view',
                                   style='custom',
                                   resizable=True),
                            Item('coils', springy=True),
                        show_labels=False),
                        'scene',
                        show_labels=False),
                    resizable=True,
                    title='Coils...',
                    height=0.8,
                    width=0.8,
                )


##############################################################################
if __name__ == '__main__':
    app = Application()
    app.configure_traits()


########NEW FILE########
__FILENAME__ = compute_in_thread
#!/usr/bin/env python
"""
This script demonstrates how one can do a computation in another thread
and update the mayavi pipeline. It also shows how to create a numpy array
data and visualize it as image data using a few modules.
"""
# Author: Prabhu Ramachandran <prabhu_r@users.sf.net>
# Copyright (c) 2007-2008, Enthought, Inc.
# License: BSD Style.

# Standard library imports
import numpy
from threading import Thread
from time import sleep

# Enthought library imports
from mayavi.scripts import mayavi2
from traits.api import HasTraits, Button, Instance
from traitsui.api import View, Item
from mayavi.sources.array_source import ArraySource
from mayavi.modules.outline import Outline
from mayavi.modules.image_plane_widget import ImagePlaneWidget
from pyface.api import GUI


def make_data(dims=(128, 128, 128)):
    """Creates some simple array data of the given dimensions to test
    with."""
    np = dims[0]*dims[1]*dims[2]

    # Create some scalars to render.
    x, y, z = numpy.ogrid[-5:5:dims[0]*1j,-5:5:dims[1]*1j,-5:5:dims[2]*1j]
    x = x.astype('f')
    y = y.astype('f')
    z = z.astype('f')

    scalars = (numpy.sin(x*y*z)/(x*y*z))
    # The copy makes the data contiguous and the transpose makes it
    # suitable for display via tvtk.  Please note that we assume here
    # that the ArraySource is configured to not transpose the data.
    s = numpy.transpose(scalars).copy()
    # Reshaping the array is needed since the transpose messes up the
    # dimensions of the data.  The scalars themselves are ravel'd and
    # used internally by VTK so the dimension does not matter for the
    # scalars.
    s.shape = s.shape[::-1]
    return s


class ThreadedAction(Thread):
    def __init__(self, data, **kwargs):
        Thread.__init__(self, **kwargs)
        self.data = data

    def run(self):
        print "Performing expensive calculation in %s..."%self.getName(),
        sleep(3)
        sd = self.data.scalar_data
        sd += numpy.sin(numpy.random.rand(*sd.shape)*2.0*numpy.pi)
        GUI.invoke_later(self.data.update)
        print 'done.'


class Controller(HasTraits):
    run_calculation = Button('Run calculation')
    data = Instance(ArraySource)

    view = View(Item(name='run_calculation'))

    def _run_calculation_changed(self, value):
        action = ThreadedAction(self.data)
        action.start()


@mayavi2.standalone
def view_numpy():
    """Example showing how to view a 3D numpy array in mayavi2.
    """
    # 'mayavi' is always defined on the interpreter.
    mayavi.new_scene()
    # Make the data and add it to the pipeline.
    data = make_data()
    src = ArraySource(transpose_input_array=False)
    src.scalar_data = data
    mayavi.add_source(src)
    # Visualize the data.
    o = Outline()
    mayavi.add_module(o)
    ipw = ImagePlaneWidget()
    mayavi.add_module(ipw)
    ipw.module_manager.scalar_lut_manager.show_scalar_bar = True

    ipw_y = ImagePlaneWidget()
    mayavi.add_module(ipw_y)
    ipw_y.ipw.plane_orientation = 'y_axes'

    computation = Controller(data=src)
    computation.edit_traits()


if __name__ == '__main__':
    view_numpy()


########NEW FILE########
__FILENAME__ = contour
#!/usr/bin/env python
"""
This script demonstrates how one can script Mayavi and use its
contour related modules.

"""
# Author: Prabhu Ramachandran <prabhu_r@users.sf.net>
# Copyright (c) 2005-2008, Enthought, Inc.
# License: BSD Style.

# Standard library imports
from os.path import join, abspath, dirname

# Enthought library imports
from mayavi.scripts import mayavi2
from mayavi.sources.vtk_file_reader import VTKFileReader
from mayavi.modules.outline import Outline
from mayavi.modules.grid_plane import GridPlane
from mayavi.modules.contour_grid_plane import ContourGridPlane
from mayavi.modules.iso_surface import IsoSurface
from mayavi.modules.scalar_cut_plane import ScalarCutPlane

@mayavi2.standalone
def contour():
    """The script itself.  We needn't have defined a function but
    having a function makes this more reusable.
    """
    # 'mayavi' is always defined on the interpreter.
    # Create a new scene.
    mayavi.new_scene()

    # Read a VTK (old style) data file.
    r = VTKFileReader()
    filename = join(mayavi2.get_data_dir(dirname(abspath(__file__))),
                    'heart.vtk')
    r.initialize(filename)
    mayavi.add_source(r)

    # Create an outline for the data.
    o = Outline()
    mayavi.add_module(o)

    # Create three simple grid plane modules.
    # First normal to 'x' axis.
    gp = GridPlane()
    mayavi.add_module(gp)
    # Second normal to 'y' axis.
    gp = GridPlane()
    mayavi.add_module(gp)
    gp.grid_plane.axis = 'y'
    # Third normal to 'z' axis.
    gp = GridPlane()
    mayavi.add_module(gp)
    gp.grid_plane.axis = 'z'

    # Create one ContourGridPlane normal to the 'x' axis.
    cgp = ContourGridPlane()
    mayavi.add_module(cgp)
    # Set the position to the middle of the data.
    cgp.grid_plane.position = 15

    # Another with filled contours normal to 'y' axis.
    cgp = ContourGridPlane()
    mayavi.add_module(cgp)
    # Set the axis and position to the middle of the data.
    cgp.grid_plane.axis = 'y'
    cgp.grid_plane.position = 15
    cgp.contour.filled_contours = True

    # An isosurface module.
    iso = IsoSurface(compute_normals=True)
    mayavi.add_module(iso)
    iso.contour.contours = [220.0]

    # An interactive scalar cut plane.
    cp = ScalarCutPlane()
    mayavi.add_module(cp)
    cp.implicit_plane.normal = 0,0,1


if __name__ == '__main__':
    contour()

########NEW FILE########
__FILENAME__ = contour_contour
#!/usr/bin/env python
"""This example shows how you can produce contours on an IsoSurface.
"""
# Author: Prabhu Ramachandran <prabhu [at] aero . iitb . ac . in>
# Copyright (c) 2008,  Enthought, Inc.
# License: BSD Style.

# Standard library imports
from os.path import join, abspath, dirname

# Mayavi imports.
from mayavi.scripts import mayavi2
from mayavi.sources.api import VTKXMLFileReader
from mayavi.filters.contour import Contour
from mayavi.filters.api import PolyDataNormals
from mayavi.filters.set_active_attribute import SetActiveAttribute
from mayavi.modules.api import Surface, Outline

@mayavi2.standalone
def main():
    mayavi.new_scene()

    # Read the example data: fire_ug.vtu.
    r = VTKXMLFileReader()
    filename = join(mayavi2.get_data_dir(dirname(abspath(__file__))),
                    'fire_ug.vtu')
    r.initialize(filename)
    mayavi.add_source(r)
    # Set the active point scalars to 'u'.
    r.point_scalars_name = 'u'

    # Simple outline for the data.
    o = Outline()
    mayavi.add_module(o)

    # Branch the pipeline with a contour -- the outline above is
    # directly attached to the source whereas the contour below is a
    # filter and will branch the flow of data.   An isosurface in the
    # 'u' data attribute is generated and normals generated for it.

    c = Contour()
    mayavi.add_filter(c)
    n = PolyDataNormals()
    mayavi.add_filter(n)

    # Now we want to show the temperature 't' on the surface of the 'u'
    # iso-contour.  This is easily done by using the SetActiveAttribute
    # filter below.

    aa = SetActiveAttribute()
    mayavi.add_filter(aa)
    aa.point_scalars_name = 't'

    # Now view the iso-contours of 't' with a Surface filter.
    s = Surface(enable_contours=True)
    mayavi.add_module(s)


if __name__ == "__main__":
    main()


########NEW FILE########
__FILENAME__ = custom_colormap
"""
An example showing how a custom colormap (or look up table) can be used
for a given object.

Although the end user specifies colormaps by giving the name of a set of
predefined colormaps, Mayavi (and VTK) deal with color internally using
'Look Up Tables' (LUT): a table that associate a scalar value to a
color defined by its RGBA components.

In this example, we show how the LUT of an object can be retrieved and
modified. Specificaly, we start by giving a surf object the 'cool'
colormap, but we modify add to add a transparency effect.

Notice in the resulting image how the surface becomes more transparent
for its lower points.

Note that if you want to use a different number of colors, you can
change the 'number_of_colors' attribute of the lut object and assign a
new array of the right shape to its 'table' attribute.
"""

# Create some data
import numpy as np

x, y = np.mgrid[-10:10:200j, -10:10:200j]
z = 100 * np.sin(x * y) / (x * y)

# Visualize it with mlab.surf
from mayavi import mlab
mlab.figure(bgcolor=(1, 1, 1))
surf = mlab.surf(z, colormap='cool')

# Retrieve the LUT of the surf object.
lut = surf.module_manager.scalar_lut_manager.lut.table.to_array()

# The lut is a 255x4 array, with the columns representing RGBA
# (red, green, blue, alpha) coded with integers going from 0 to 255.

# We modify the alpha channel to add a transparency gradient
lut[:, -1] = np.linspace(0, 255, 256)
# and finally we put this LUT back in the surface object. We could have
# added any 255*4 array rather than modifying an existing LUT.
surf.module_manager.scalar_lut_manager.lut.table = lut

# We need to force update of the figure now that we have changed the LUT.
mlab.draw()
mlab.view(40, 85)

mlab.show()

########NEW FILE########
__FILENAME__ = datasets
"""
A Mayavi example to show the different data sets. See
:ref:`data-structures-used-by-mayavi` for a discussion.

The following images are created:

.. hlist::

    * **ImageData**

      .. image:: ../image_data.jpg
            :scale: 50

    * **RectilinearGrid**

      .. image:: ../rectilinear_grid.jpg
            :scale: 50

    * **StructuredGrid**

      .. image:: ../structured_grid.jpg
            :scale: 50

    * **UnstructuredGrid**

      .. image:: ../unstructured_grid.jpg
            :scale: 50

"""
# Author: Gael Varoquaux <gael dot varoquaux at normalesup.org>
# Copyright (c) 2008, Enthought, Inc.
# License: BSD style.

from numpy import array, random, linspace, pi, ravel, cos, sin, empty
from tvtk.api import tvtk

from mayavi.sources.vtk_data_source import VTKDataSource

from mayavi import mlab


def image_data():
    data = random.random((3, 3, 3))
    i = tvtk.ImageData(spacing=(1, 1, 1), origin=(0, 0, 0))
    i.point_data.scalars = data.ravel()
    i.point_data.scalars.name = 'scalars'
    i.dimensions = data.shape
    return i


def rectilinear_grid():
    data = random.random((3, 3, 3))
    r = tvtk.RectilinearGrid()
    r.point_data.scalars = data.ravel()
    r.point_data.scalars.name = 'scalars'
    r.dimensions = data.shape
    r.x_coordinates = array((0, 0.7, 1.4))
    r.y_coordinates = array((0, 1, 3))
    r.z_coordinates = array((0, .5, 2))
    return r


def generate_annulus(r, theta, z):
    """ Generate points for structured grid for a cylindrical annular
        volume.  This method is useful for generating a unstructured
        cylindrical mesh for VTK (and perhaps other tools).
    """
    # Find the x values and y values for each plane.
    x_plane = (cos(theta)*r[:,None]).ravel()
    y_plane = (sin(theta)*r[:,None]).ravel()

    # Allocate an array for all the points.  We'll have len(x_plane)
    # points on each plane, and we have a plane for each z value, so
    # we need len(x_plane)*len(z) points.
    points = empty([len(x_plane)*len(z),3])

    # Loop through the points for each plane and fill them with the
    # correct x,y,z values.
    start = 0
    for z_plane in z:
        end = start+len(x_plane)
        # slice out a plane of the output points and fill it
        # with the x,y, and z values for this plane.  The x,y
        # values are the same for every plane.  The z value
        # is set to the current z
        plane_points = points[start:end]
        plane_points[:,0] = x_plane
        plane_points[:,1] = y_plane
        plane_points[:,2] = z_plane
        start = end

    return points


def structured_grid():
    # Make the data.
    dims = (3, 4, 3)
    r = linspace(5, 15, dims[0])
    theta = linspace(0, 0.5*pi, dims[1])
    z = linspace(0, 10, dims[2])
    pts = generate_annulus(r, theta, z)
    sgrid = tvtk.StructuredGrid(dimensions=(dims[1], dims[0], dims[2]))
    sgrid.points = pts
    s = random.random((dims[0]*dims[1]*dims[2]))
    sgrid.point_data.scalars = ravel(s.copy())
    sgrid.point_data.scalars.name = 'scalars'
    return sgrid


def unstructured_grid():
    points = array([[0,1.2,0.6], [1,0,0], [0,1,0], [1,1,1], # tetra
                    [1,0,-0.5], [2,0,0], [2,1.5,0], [0,1,0],
                    [1,0,0], [1.5,-0.2,1], [1.6,1,1.5], [1,1,1], # Hex
                    ], 'f')
    # The cells
    cells = array([4, 0, 1, 2, 3, # tetra
                   8, 4, 5, 6, 7, 8, 9, 10, 11 # hex
                   ])
    # The offsets for the cells, i.e. the indices where the cells
    # start.
    offset = array([0, 5])
    tetra_type = tvtk.Tetra().cell_type # VTK_TETRA == 10
    hex_type = tvtk.Hexahedron().cell_type # VTK_HEXAHEDRON == 12
    cell_types = array([tetra_type, hex_type])
    # Create the array of cells unambiguously.
    cell_array = tvtk.CellArray()
    cell_array.set_cells(2, cells)
    # Now create the UG.
    ug = tvtk.UnstructuredGrid(points=points)
    # Now just set the cell types and reuse the ug locations and cells.
    ug.set_cells(cell_types, offset, cell_array)
    scalars = random.random(points.shape[0])
    ug.point_data.scalars = scalars
    ug.point_data.scalars.name = 'scalars'
    return ug


def polydata():
    # The numpy array data.
    points = array([[0,-0.5,0], [1.5,0,0], [0,1,0], [0,0,0.5],
                    [-1,-1.5,0.1], [0,-1, 0.5], [-1, -0.5, 0],
                    [1,0.8,0]], 'f')
    triangles = array([[0,1,3], [1,2,3], [1,0,5],
                       [2,3,4], [3,0,4], [0,5,4], [2, 4, 6],
                        [2, 1, 7]])
    scalars = random.random(points.shape)

    # The TVTK dataset.
    mesh = tvtk.PolyData(points=points, polys=triangles)
    mesh.point_data.scalars = scalars
    mesh.point_data.scalars.name = 'scalars'
    return mesh


def view(dataset):
    """ Open up a mayavi scene and display the dataset in it.
    """
    fig = mlab.figure(bgcolor=(1, 1, 1), fgcolor=(0, 0, 0),
                      figure=dataset.class_name[3:])
    surf = mlab.pipeline.surface(dataset, opacity=0.1)
    mlab.pipeline.surface(mlab.pipeline.extract_edges(surf),
                            color=(0, 0, 0), )


@mlab.show
def main():
    view(image_data())
    view(rectilinear_grid())
    view(structured_grid())
    view(unstructured_grid())
    view(polydata())

if __name__ == '__main__':
    main()


########NEW FILE########
__FILENAME__ = delaunay_graph
"""
An example illustrating graph manipulation and display with Mayavi
and NetworkX.

This example shows how to use Mayavi in a purely algorithmic way, to
compute a Delaunay from data points, extract it and pass it to networkx.
It also shows how to plot a graph using quiver.

Starting from points positioned regularly on a sphere, we first use VTK
to create the Delaunay graph, and also to plot it. We then create a
matching NetworkX graph, calling it's minimum spanning tree function. We
display it using Mayavi.

The visualization clearly shows that the minimum spanning tree of the
points, considering all possible connections, is included in the Delaunay
graph.

_____

The function `compute_delaunay_edges` uses VTK to retrieve the Delaunay
graph of a set of points. First a structure of unconnected points is
created using `mlab.points3d`. The Delaunay filter applied to it builds
an unstructured grid (see :ref:`data-structures-used-by-mayavi`). We
apply an ExtractEdges filter to it, which returns a structure of points
connected by edges: the :ref:`PolyData structure <poly_data>`. The
dataset structure can be retrieved as the first item of the `outputs`
list of the ExtractEdges filter object, returned by the
`mlab.pipeline.extract_edges` factory function. Once we have this object,
we extract the points and edge list from it. This graph-plotting
technique differs from the technique used in the examples
:ref:`example_protein` and :ref:`example_flight_graph` where points are
created and connected by lines. Unlike these techniques, it enables
storing scalar data on each line.

_____

To visualize the graph (function `graph_plot`), we build a list of
vectors giving the edges, and use `mlab.quiver3d` to display them. To
display an unoriented graph, it is best to use the `2ddash` mode of
`quiver3d`.

"""
# Author: Gary Ruben
#         Gael Varoquaux <gael dot varoquaux at normalesup dot org>
# Copyright (c) 2009, Enthought, Inc.
# License: BSD style.

from mayavi import mlab
import numpy as np
import networkx as nx

def compute_delaunay_edges(x, y, z, visualize=False):
    """ Given 3-D points, returns the edges of their
        Delaunay triangulation.

        Parameters
        -----------
        x: ndarray
            x coordinates of the points
        y: ndarray
            y coordinates of the points
        z: ndarray
            z coordinates of the points

        Returns
        ---------
        new_x: ndarray
            new x coordinates of the points (same coords but different
            assignment of points)
        new_y: ndarray
            new y coordinates of the points (same coords but different
            assignment of points)
        new_z: ndarray
            new z coordinates of the points (same coords but different
            assignment of points)
        edges: 2D ndarray.
            The indices of the edges of the Delaunay triangulation as a
            (N, 2) array [[pair1_index1, pair1_index2],
                          [pair2_index1, pair2_index2],
                          ...                         ]
    """
    if visualize:
        vtk_source = mlab.points3d(x, y, z, opacity=0.3, mode='2dvertex')
        vtk_source.actor.property.point_size = 3
    else:
        vtk_source =  mlab.pipeline.scalar_scatter(x, y, z, figure=False)
    delaunay =  mlab.pipeline.delaunay3d(vtk_source)
    delaunay.filter.offset = 999    # seems more reliable than the default
    edges = mlab.pipeline.extract_edges(delaunay)
    if visualize:
        mlab.pipeline.surface(edges, opacity=0.3, line_width=3)

    # We extract the output array. the 'points' attribute itself
    # is a TVTK array, that we convert to a numpy array using
    # its 'to_array' method.
    new_x, new_y, new_z = edges.outputs[0].points.to_array().T
    lines = edges.outputs[0].lines.to_array()
    return new_x, new_y, new_z, np.array([lines[1::3], lines[2::3]]).T


def graph_plot(x, y, z, start_idx, end_idx, edge_scalars=None, **kwargs):
    """ Show the graph edges using Mayavi

        Parameters
        -----------
        x: ndarray
            x coordinates of the points
        y: ndarray
            y coordinates of the points
        z: ndarray
            z coordinates of the points
        edge_scalars: ndarray, optional
            optional data to give the color of the edges.
        kwargs:
            extra keyword arguments are passed to quiver3d.
    """
    vec = mlab.quiver3d(x[start_idx],
                        y[start_idx],
                        z[start_idx],
                        x[end_idx] - x[start_idx],
                        y[end_idx] - y[start_idx],
                        z[end_idx] - z[start_idx],
                        scalars=edge_scalars,
                        mode='2ddash',
                        scale_factor=1,
                        **kwargs)
    if edge_scalars is not None:
        vec.glyph.color_mode = 'color_by_scalar'
    return vec


def build_geometric_graph(x, y, z, edges):
    """ Build a NetworkX graph with xyz node coordinates and the node indices
        of the end nodes.

        Parameters
        -----------
        x: ndarray
            x coordinates of the points
        y: ndarray
            y coordinates of the points
        z: ndarray
            z coordinates of the points
        edges: the (2, N) array returned by compute_delaunay_edges()
            containing node indices of the end nodes. Weights are applied to
            the edges based on their euclidean length for use by the MST
            algorithm.

        Returns
        ---------
        g: A NetworkX undirected graph

        Notes
        ------
        We don't bother putting the coordinates into the NX graph.
        Instead the graph node is an index to the column.
    """
    xyz = np.array((x, y, z))
    def euclidean_dist(i, j):
        d = xyz[:,i] - xyz[:,j]
        return np.sqrt(np.dot(d, d))

    g = nx.Graph()
    for i, j in edges:
        if nx.__version__.split('.')[0] > '0':
            g.add_edge(i, j, weight=euclidean_dist(i, j))
        else:
            g.add_edge(i, j, euclidean_dist(i, j))
    return g


def points_on_sphere(N):
    """ Generate N evenly distributed points on the unit sphere centered at
        the origin. Uses the 'Golden Spiral'.
        Code by Chris Colbert from the numpy-discussion list.
    """
    phi = (1 + np.sqrt(5)) / 2  # the golden ratio
    long_incr = 2*np.pi / phi   # how much to increment the longitude

    dz = 2.0 / float(N)         # a unit sphere has diameter 2
    bands = np.arange(N)        # each band will have one point placed on it
    z = bands * dz - 1 + (dz/2) # the height z of each band/point
    r = np.sqrt(1 - z*z)        # project onto xy-plane
    az = bands * long_incr      # azimuthal angle of point modulo 2 pi
    x = r * np.cos(az)
    y = r * np.sin(az)
    return x, y, z


################################################################################
if __name__ == '__main__':
    # generate some points
    x, y, z = points_on_sphere(50)
    # Avoid triangulation problems on the sphere
    z *= 1.01

    mlab.figure(1, bgcolor=(0,0,0))
    mlab.clf()

    # Now get the Delaunay Triangulation from vtk via mayavi mlab. Vtk stores
    # its points in a different order so overwrite ours to match the edges
    new_x, new_y, new_z, edges = compute_delaunay_edges(x, y, z, visualize=True)
    assert(x.shape == new_x.shape)   # check triangulation got everything
    x, y, z = new_x, new_y, new_z

    if nx.__version__ < '0.99':
        raise ImportError('The version of NetworkX must be at least '
                    '0.99 to run this example')

    # Make a NetworkX graph out of our point and edge data
    g = build_geometric_graph(x, y, z, edges)

    # Compute minimum spanning tree using networkx
    # nx.mst returns an edge generator
    edges = nx.minimum_spanning_tree(g).edges(data=True)
    start_idx, end_idx, _ = np.array(list(edges)).T
    start_idx = start_idx.astype(np.int)
    end_idx   = end_idx.astype(np.int)

    # Plot this with Mayavi
    graph_plot(x, y, z, start_idx, end_idx,
                edge_scalars=z[start_idx],
                opacity=0.8,
                colormap='summer',
                line_width=4,
                )

    mlab.view(60, 46, 4)
    mlab.show()

########NEW FILE########
__FILENAME__ = flight_graph
"""
An example showing a graph display between cities positionned on the
Earth surface.

This graph displays the longest fligh routes operated by Boing
777. The two main interests of this example are that it shows how to
build a graph of arbitrary connectivity, and that it shows how to
position data on the surface of the Earth.

The graph is created by first building a scalar scatter dataset with the
mlab.points3d command, and adding line information to it. One of the
difficulties is that the lines are specified using the indexing number of
the points, so we must 'massage' our data when loading it. A similar
technique to plot the graph is done in the :ref:`example_protein`.
Another example of graph plotting, showing a different technique to plot
the graph, can be seen on :ref:`example_delaunay_graph`.

To simplify things we do not plot the connection on the surface of the
Earth, but as straight lines going throught the Earth. As a result
must use transparency to show the connection.

Data source: http://www.777fleetpage.com/777fleetpage3.htm
"""

###############################################################################
# The data. This could be loaded from a file, or scraped from a website

routes_data = """
Bombay,Atlanta
Johannesburg,Atlanta
Dubai,Los Angeles
Dubai,Houston
Dubai,San Francisco
New York,Hong Kong
Newark,Hong Kong
Doha,Houston
Toronto,Hong Kong
Bombay,Newark
Bombay,New York
Vancouver,Hong Kong
Dubai,Sao Paulo
Los Angeles,Sydney
Chicago,Delhi
"""

cities_data = """
Toronto,-79.38,43.65
Chicago,-87.68,41.84
Houston,-95.39,29.77
New York,-73.94,40.67
Vancouver,-123.13,49.28
Los Angeles,-118.41,34.11
San Francisco,-122.45,37.77
Atlanta,-84.42,33.76
Dubai,55.33,25.27
Sydney,151.21,-33.87
Hong Kong,114.19,22.38
Bombay,72.82,18.96
Delhi,77.21,28.67
Newark,-82.43,40.04
Johannesburg,28.04,-26.19
Doha,51.53,25.29
Sao Paulo,-46.63,-23.53
"""

###############################################################################
# Load the data, and put it in data structures we can use
import csv
routes_table = [i for i in csv.reader(routes_data.split('\n')[1:-1])]

# Build a dictionnary returning GPS coordinates for each city
cities_coord = dict()
for line in list(csv.reader(cities_data.split('\n')))[1:-1]:
    name, long, lat = line
    cities_coord[name] = (float(long), float(lat))

# Store all the coordinates of connected cities in a list also keep
# track of which city corresponds to a given index in the list. The
# connectivity information is specified as connecting the i-th point
# with the j-th.
cities = dict()
coords = list()
connections = list()
for city1, city2 in routes_table[1:-1]:
    if not city1 in cities:
        cities[city1] = len(coords)
        coords.append(cities_coord[city1])
    if not city2 in cities:
        cities[city2] = len(coords)
        coords.append(cities_coord[city2])
    connections.append((cities[city1], cities[city2]))


###############################################################################
from mayavi import mlab
mlab.figure(1, bgcolor=(0.48, 0.48, 0.48), fgcolor=(0, 0, 0),
               size=(400, 400))
mlab.clf()

###############################################################################
# Display points at city positions
import numpy as np
coords = np.array(coords)
# First we have to convert latitude/longitude information to 3D
# positioning.
lat, long = coords.T * np.pi / 180
x = np.cos(long) * np.cos(lat)
y = np.cos(long) * np.sin(lat)
z = np.sin(long)

points = mlab.points3d(x, y, z,
                     scale_mode='none',
                     scale_factor=0.03,
                     color=(0, 0, 1))

###############################################################################
# Display connections between cities
connections = np.array(connections)
# We add lines between the points that we have previously created by
# directly modifying the VTK dataset.
points.mlab_source.dataset.lines = connections
points.mlab_source.update()
# To represent the lines, we use the surface module. Using a wireframe
# representation allows to control the line-width.
mlab.pipeline.surface(points, color=(1, 1, 1),
                              representation='wireframe',
                              line_width=4,
                              name='Connections')

###############################################################################
# Display city names
for city, index in cities.iteritems():
    label = mlab.text(x[index], y[index], city, z=z[index],
                      width=0.016 * len(city), name=city)
    label.property.shadow = True

###############################################################################
# Display continents outline, using the VTK Builtin surface 'Earth'
from mayavi.sources.builtin_surface import BuiltinSurface
continents_src = BuiltinSurface(source='earth', name='Continents')
# The on_ratio of the Earth source controls the level of detail of the
# continents outline.
continents_src.data_source.on_ratio = 2
continents = mlab.pipeline.surface(continents_src, color=(0, 0, 0))

###############################################################################
# Display a semi-transparent sphere, for the surface of the Earth

# We use a sphere Glyph, throught the points3d mlab function, rather than
# building the mesh ourselves, because it gives a better transparent
# rendering.
sphere = mlab.points3d(0, 0, 0, scale_mode='none',
                                scale_factor=2,
                                color=(0.67, 0.77, 0.93),
                                resolution=50,
                                opacity=0.7,
                                name='Earth')

# These parameters, as well as the color, where tweaked through the GUI,
# with the record mode to produce lines of code usable in a script.
sphere.actor.property.specular = 0.45
sphere.actor.property.specular_power = 5
# Backface culling is necessary for more a beautiful transparent
# rendering.
sphere.actor.property.backface_culling = True

###############################################################################
# Plot the equator and the tropiques
theta = np.linspace(0, 2 * np.pi, 100)
for angle in (- np.pi / 6, 0, np.pi / 6):
    x = np.cos(theta) * np.cos(angle)
    y = np.sin(theta) * np.cos(angle)
    z = np.ones_like(theta) * np.sin(angle)

    mlab.plot3d(x, y, z, color=(1, 1, 1),
                        opacity=0.2, tube_radius=None)

mlab.view(63.4, 73.8, 4, [-0.05, 0, 0])
mlab.show()

########NEW FILE########
__FILENAME__ = glyph
#!/usr/bin/env python
"""
This script demonstrates using the Mayavi core API to add a VectorCutPlane,
split the pipeline using a MaskPoints filter and then view the filtered data
with the Glyph module.
"""
# Author: Prabhu Ramachandran <prabhu_r@users.sf.net>
# Copyright (c) 2005-2008, Enthought, Inc.
# License: BSD Style.

# Standard library imports
from os.path import join, abspath, dirname

# Enthought library imports
from mayavi.scripts import mayavi2
from mayavi.sources.vtk_xml_file_reader import VTKXMLFileReader
from mayavi.modules.outline import Outline
from mayavi.modules.glyph import Glyph
from mayavi.modules.vector_cut_plane import VectorCutPlane
from mayavi.filters.mask_points import MaskPoints

@mayavi2.standalone
def glyph():
    """The script itself.  We needn't have defined a function but
    having a function makes this more reusable.
    """
    # 'mayavi' is always defined on the interpreter.
    # Create a new VTK scene.
    mayavi.new_scene()

    # Read a VTK (old style) data file.
    r = VTKXMLFileReader()
    r.initialize(join(mayavi2.get_data_dir(dirname(abspath(__file__))),
                      'fire_ug.vtu'))
    mayavi.add_source(r)

    # Create an outline and a vector cut plane.
    mayavi.add_module(Outline())

    v = VectorCutPlane()
    mayavi.add_module(v)
    v.glyph.color_mode = 'color_by_scalar'

    # Now mask the points and show glyphs (we could also use
    # Vectors but glyphs are a bit more generic)
    m = MaskPoints()
    m.filter.set(on_ratio=10, random_mode=True)
    mayavi.add_filter(m)

    g = Glyph()
    mayavi.add_module(g)
    # Note that this adds the module to the filtered output.
    g.glyph.scale_mode = 'scale_by_vector'
    # Use arrows to view the scalars.
    gs = g.glyph.glyph_source
    gs.glyph_source = gs.glyph_dict['arrow_source']


if __name__ == '__main__':
    glyph()

########NEW FILE########
__FILENAME__ = image_cursor_filter
"""
Excample using the UserDefined filter to paint a cross-shaped cursor on data,
in order to point out a special position.

We use the UserDefined filter `ImageCursor3D` to create the cursor. A Gaussian
data field is painted with the cursor, and then visualized using the
ImagePlaneWIdget module.

ImageCursor3D is one example among many of the use of the UserDefined, which
allows to use TVTK filters that are not. See :ref:`using_userdefined_filter`
for more details. Also, other examples using the UserDefined filter are
provided in :ref:`example_mri` and :ref:`example_tvtk_segmentation`.

Selecting the UserDefined filter in the Mayavi pipeline is a convenient
way to look for additional filters. This pops up a dialog called `TVTK
class chooser`, with a `Search` field that allows to search for desired
actions or properties. For example, searching for `cursor` returns
several filters, among which Cursor3D and ImageCursor3D. As a rule of
thumb, the name of TVTK filters acting on TVTK ImageData dataset starts
with `Image` (ImageData is the type of VTK data set created by e.g.
mlab.pipeline.scalar_field. See :ref:`data-structures-used-by-mayavi` for
more details about VTK datasets). In the dialog used to interactively
add the UserDefined filet, we can therefore select `ImageCursor3D`.
The documentation of the filter is displayed when selecting its name
within the `Class name` field of the dialog.
"""

# Authors: Emmanuelle Gouillart <emmanuelle.gouillart@normalesup.org>
# and Gael Varoquaux <gael.varoquaux@normalesup.org>
# Copyright (c) 2009, Enthought, Inc.
# License: BSD Style.


from mayavi import mlab
import numpy as np

# Define Gaussian data field
x, y, z = np.ogrid[0:1:40j, 0:1:40j, 0:1:40j]
sig = 0.5
center = 0.5
g = np.exp(-((x-center)**2 + (y-center)**2 + (z-center)**2)/(2*sig**2))

################################################################################

mlab.figure(fgcolor=(0, 0, 0), bgcolor=(1, 1, 1))

# Define the cursor
s = mlab.pipeline.scalar_field(g)
cursor = mlab.pipeline.user_defined(s, filter='ImageCursor3D')

# The TVTK filter used by Mayavi is accessible as the '.filter'
# attribute of the Mayavi filtered returned by user_defined.
# We can set the graphical properties of the cross via attributes of
# cursor.filter, and not of cursor itself. Here cursor is a Mayavi filter,
# that is an object that inserts in the Mayavi pipeline, whereas
# cursor.filter is the TVTK filter that actually does the work.

# Put the cursor at the center of the field volume (default is (0, 0, 0))
cursor.filter.cursor_position = np.array([20, 20, 20])
# Define the value of the cursor (default is 255) so that there is
# enough contrast between the cursor and the data values in the neighbourhood
# of the cursor. The cursor value is within the data value range so that
# the contrast of the data is not altered.
cursor.filter.cursor_value = 0
# Define the radius of the cross (the extent of the cross is 2xcursor_radius)
cursor.filter.cursor_radius = 10


# Display data and cursor using an image_plane_widget that intersects the
# cursor.
ipw = mlab.pipeline.image_plane_widget(cursor, plane_orientation='x_axes',
            slice_index=20)

# View
mlab.colorbar()
mlab.view(15, 70, 100, [20, 20, 20])
mlab.show()

########NEW FILE########
__FILENAME__ = julia_set
"""
An example showing the Julia set displayed as a z-warped surface.

The Julia set is a fractal (see http://en.wikipedia.org/wiki/Julia_set
). We display it here in a canyon-like view using mlab's surf function:
:func:`mayavi.mlab.surf`.
"""

# Author: Gael Varoquaux <gael.varoquaux@normalesup.org>
# Copyright (c) 2008, Enthought, Inc.
# License: BSD Style.


from mayavi import mlab
import numpy as np

# Calculate the Julia set on a grid
x, y = np.ogrid[-1.5:0.5:500j, -1:1:500j]
z = x + 1j * y

julia = np.zeros(z.shape)

for i in range(50):
    z = z ** 2 - 0.70176 - 0.3842j
    julia += 1 / float(2 + i) * (z * np.conj(z) > 4)

# Display it
mlab.figure(size=(400, 300))
mlab.surf(julia, colormap='gist_earth', warp_scale='auto', vmax=1.5)

# A view into the "Canyon"
mlab.view(65, 27, 322, [30., -13.7,  136])
mlab.show()

########NEW FILE########
__FILENAME__ = julia_set_decimation
"""
The Julia set, but with a decimated mesh: unecessary triangles due to the
initial grid and not matching the geometry of the Julia set
are removed.

We first build the mesh, applying a warp_scalar filter to a
array2d_source, to warp the Julia set along the z direction.

Then when have to convert the rectangles in the mesh to triangles, in
order to apply the decimate_pro filter. This filter does the decimation,
and we can represent the result using surface modules.

The triangle-generation filter generates warnings: some polygons
are degenerate, as the grid has subdivided flat parts of the Julia
set.

We have shown in white the decimated mesh, and in black the non-decimated
one. The view is zoom to the center of the Julia set. If you turn of the
wireframes and zoom out, you can appreciate the quality of the
decimation.

In the specific case of decimating a surface warped from 2D data, it is
more efficient to use the greedy-terrain-decimator, see the
:ref:`example_canyon_decimation`.
"""

# Author: Gael Varoquaux <gael.varoquaux@normalesup.org>
# Copyright (c) 2008, Enthought, Inc.
# License: BSD Style.


from mayavi import mlab
import numpy as np

# Calculate the Julia set on a grid
x, y = np.ogrid[-1.5:0.5:500j, -1:1:500j]
z = x + 1j * y

julia = np.zeros(z.shape)

for i in range(50):
    z = z ** 2 - 0.70176 - 0.3842j
    julia += 1 / float(2 + i) * (z * np.conj(z) > 4)


mlab.figure(size=(400, 300))

# Create the mesh
mesh = mlab.pipeline.warp_scalar(mlab.pipeline.array2d_source(julia),
                                 warp_scale=100)

# The decimate_pro filter works only on triangles. We need to apply the
# triangle_filter before applying decimate_pro.
dec = mlab.pipeline.decimate_pro(mlab.pipeline.triangle_filter(mesh))
# Set a very low feature_angle, so that the decimate_pro detects
dec.filter.feature_angle = 1
dec.filter.target_reduction = 0.5

# We display the lines of decimated mesh in white
mlab.pipeline.surface(dec, representation='wireframe', line_width=3,
                           color=(1, 1, 1))
# The decimated mesh itself.
mlab.pipeline.surface(dec, colormap='gist_earth', vmin=-0.1, vmax=0.4)

# The lines of the non-decimated mesh, in black, for comparisation.
mlab.pipeline.surface(mesh, representation='wireframe',  color=(0, 0, 0))

mlab.view(-66, 25, 9.7, [-5.8, -54.5,  18.4])

mlab.show()

########NEW FILE########
__FILENAME__ = lorenz
"""
An example displaying the trajectories for the Lorenz system of
equations along with the z-nullcline.

The vector field of the Lorenz system flow is integrated to display
trajectories using mlab's flow function:
:func:`mayavi.mlab.flow`.

The z-nullcline is plotted by extracting the z component of the vector
field data source with the ExtractVectorComponent filter, and applying
an IsoSurface module on this scalar component.
"""
# Author: Prabhu Ramachandran <prabhu@aero.iitb.ac.in>
# Copyright (c) 2008-2009, Enthought, Inc.
# License: BSD Style.

import numpy
from mayavi import mlab


def lorenz(x, y, z, s=10., r=28., b=8. / 3.):
    """The Lorenz system."""
    u = s * (y - x)
    v = r * x - y - x * z
    w = x * y - b * z
    return u, v, w

# Sample the space in an interesting region.
x, y, z = numpy.mgrid[-50:50:100j, -50:50:100j, -10:60:70j]
u, v, w = lorenz(x, y, z)
fig = mlab.figure(size=(400, 300), bgcolor=(0, 0, 0))

# Plot the flow of trajectories with suitable parameters.
f = mlab.flow(x, y, z, u, v, w, line_width=3, colormap='Paired')
f.module_manager.scalar_lut_manager.reverse_lut = True
f.stream_tracer.integration_direction = 'both'
f.stream_tracer.maximum_propagation = 200
# Uncomment the following line if you want to hide the seed:
#f.seed.widget.enabled = False

# Extract the z-velocity from the vectors and plot the 0 level set
# hence producing the z-nullcline.
src = f.mlab_source.m_data
e = mlab.pipeline.extract_vector_components(src)
e.component = 'z-component'
zc = mlab.pipeline.iso_surface(e, opacity=0.5, contours=[0, ],
            color=(0.6, 1, 0.2))
# When using transparency, hiding 'backface' triangles often gives better
# results
zc.actor.property.backface_culling = True

# A nice view of the plot.
mlab.view(140, 120, 113, [0.65, 1.5, 27])
mlab.show()

########NEW FILE########
__FILENAME__ = lorenz_ui
"""
This example displays the trajectories for the Lorenz system of
equations using mlab along with the z-nullcline.  It provides a simple
UI where a user can change the parameters and the system of equations on
the fly.  This primarily demonstrates how one can build powerful tools
with a UI using Traits and Mayavi.

For explanations and more examples of interactive application building
with Mayavi, please refer to section :ref:`builing_applications`.
"""
# Author: Prabhu Ramachandran <prabhu@aero.iitb.ac.in>
# Copyright (c) 2008-2009, Enthought, Inc.
# License: BSD Style.

import numpy as np
import scipy

from traits.api import HasTraits, Range, Instance, \
        on_trait_change, Array, Tuple, Str
from traitsui.api import View, Item, HSplit, Group

from mayavi import mlab
from mayavi.core.ui.api import MayaviScene, MlabSceneModel, \
    SceneEditor

################################################################################
# `Lorenz` class.
################################################################################
class Lorenz(HasTraits):

    # The parameters for the Lorenz system, defaults to the standard ones.
    s = Range(0.0, 20.0, 10.0, desc='the parameter s', enter_set=True,
              auto_set=False)
    r = Range(0.0, 50.0, 28.0, desc='the parameter r', enter_set=True,
              auto_set=False)
    b = Range(0.0, 10.0, 8./3., desc='the parameter b', enter_set=True,
              auto_set=False)

    # These expressions are evaluated to compute the right hand sides of
    # the ODE.  Defaults to the Lorenz system.
    u = Str('s*(y-x)', desc='the x component of the velocity',
            auto_set=False, enter_set=True)
    v = Str('r*x - y - x*z', desc='the y component of the velocity',
            auto_set=False, enter_set=True)
    w = Str('x*y - b*z', desc='the z component of the velocity',
            auto_set=False, enter_set=True)

    # Tuple of x, y, z arrays where the field is sampled.
    points = Tuple(Array, Array, Array)

    # The mayavi(mlab) scene.
    scene = Instance(MlabSceneModel, args=())

    # The "flow" which is a Mayavi streamline module.
    flow = Instance(HasTraits)

    ########################################
    # The UI view to show the user.
    view = View(HSplit(
                    Group(
                        Item('scene', editor=SceneEditor(scene_class=MayaviScene),
                             height=500, width=500, show_label=False)),
                    Group(
                        Item('s'),
                        Item('r'),
                        Item('b'),
                        Item('u'), Item('v'), Item('w')),
                    ),
                resizable=True
                )

    ######################################################################
    # Trait handlers.
    ######################################################################

    # Note that in the `on_trait_change` call below we listen for the
    # `scene.activated` trait.  This conveniently ensures that the flow
    # is generated as soon as the mlab `scene` is activated (which
    # happens when the configure/edit_traits method is called).  This
    # eliminates the need to manually call the `update_flow` method etc.
    @on_trait_change('s, r, b, scene.activated')
    def update_flow(self):
        x, y, z = self.points
        u, v, w = self.get_uvw()
        self.flow.mlab_source.set(u=u, v=v, w=w)

    @on_trait_change('u')
    def update_u(self):
        self.flow.mlab_source.set(u=self.get_vel('u'))

    @on_trait_change('v')
    def update_v(self):
        self.flow.mlab_source.set(v=self.get_vel('v'))

    @on_trait_change('w')
    def update_w(self):
        self.flow.mlab_source.set(w=self.get_vel('w'))

    def get_uvw(self):
        return self.get_vel('u'), self.get_vel('v'), self.get_vel('w')

    def get_vel(self, comp):
        """This function basically evaluates the user specified system
        of equations using scipy.
        """
        func_str = getattr(self, comp)
        try:
            g = scipy.__dict__
            x, y, z = self.points
            s, r, b = self.s, self.r, self.b
            val = eval(func_str, g,
                        {'x': x, 'y': y, 'z': z,
                         's':s, 'r':r, 'b': b})
        except:
            # Mistake, so return the original value.
            val = getattr(self.flow.mlab_source, comp)
        return val

    ######################################################################
    # Private interface.
    ######################################################################
    def _points_default(self):
        x, y, z = np.mgrid[-50:50:100j,-50:50:100j,-10:60:70j]
        return x, y, z

    def _flow_default(self):
        x, y, z = self.points
        u, v, w = self.get_uvw()
        f = self.scene.mlab.flow(x, y, z, u, v, w)
        f.stream_tracer.integration_direction = 'both'
        f.stream_tracer.maximum_propagation = 200
        src = f.mlab_source.m_data
        o = mlab.outline()
        mlab.view(120, 60, 150)
        return f


if __name__ == '__main__':
    # Instantiate the class and configure its traits.
    lor = Lorenz()
    lor.configure_traits()


########NEW FILE########
__FILENAME__ = magnetic_field
"""
An example mixing numerical caculation and 3D visualization of the
magnetic field created by an arbitrary number of current loops.

The goal of this example is to show how Mayavi can be used with scipy to
debug and understand physics and electromagnetics computation.

The field is caculated for an arbitrary number of current loops using the
corresponding exact formula. The coils are plotted in 3D with a synthetic
view of the magnetic_field. A VectorCutPlane is used as it enables good
inspection of the magnetic field.

This example originated from a real-life case of coil design in Python (
Atomic sources for long-time-of-flight interferometric inertial sensors,
G. Varoquaux, http://tel.archives-ouvertes.fr/tel-00265714/, page 148).

For another visualization of magnetic field, see the
:ref:`example_magnetic_field_lines`.
"""
# Author: Gael Varoquaux <gael.varoquaux@normalesup.org>
# Copyright (c) 2009, Enthought, Inc.
# License: BSD Style.


import numpy as np
from scipy import special
from mayavi import mlab

##############################################################################
# Function to caculate the Magnetic field generated by a current loop

def base_vectors(n):
    """ Returns 3 orthognal base vectors, the first one colinear to n.

        Parameters
        -----------
        n: ndarray, shape (3, )
            A vector giving direction of the basis

        Returns
        -----------
        n: ndarray, shape (3, )
            The first vector of the basis
        l: ndarray, shape (3, )
            The second vector of the basis
        m: ndarray, shape (3, )
            The first vector of the basis

    """
    # normalize n
    n = n / (n**2).sum(axis=-1)

    # choose two vectors perpendicular to n
    # choice is arbitrary since the coil is symetric about n
    if  np.abs(n[0])==1 :
        l = np.r_[n[2], 0, -n[0]]
    else:
        l = np.r_[0, n[2], -n[1]]

    l = l / (l**2).sum(axis=-1)
    m = np.cross(n, l)
    return n, l, m


def magnetic_field(r, n, r0, R):
    """
    Returns the magnetic field from an arbitrary current loop calculated from
    eqns (1) and (2) in Phys Rev A Vol. 35, N 4, pp. 1535-1546; 1987.

    Arguments
    ----------
        n: ndarray, shape (3, )
            The normal vector to the plane of the loop at the center,
            current is oriented by the right-hand-rule.
        r: ndarray, shape (m, 3)
            A position vector where the magnetic field is evaluated:
            [x1 y2 z3 ; x2 y2 z2 ; ... ]
            r is in units of d
        r0: ndarray, shape (3, )
            The location of the center of the loop in units of d: [x y z]
        R: float
            The radius of the current loop

    Returns
    --------
    B: ndarray, shape (m, 3)
        a vector for the B field at each position specified in r
        in inverse units of (mu I) / (2 pi d)
        for I in amps and d in meters and mu = 4 pi * 10^-7 we get Tesla
    """
    ### Translate the coordinates in the coil's frame
    n, l, m = base_vectors(n)

    # transformation matrix coil frame to lab frame
    trans = np.vstack((l, m, n))
    # transformation matrix to lab frame to coil frame
    inv_trans = np.linalg.inv(trans)

    # point location from center of coil
    r = r - r0
    # transform vector to coil frame
    r = np.dot(r, inv_trans)

    #### calculate field

    # express the coordinates in polar form
    x = r[:, 0]
    y = r[:, 1]
    z = r[:, 2]
    rho = np.sqrt(x**2 + y**2)
    theta = np.arctan(x/y)
    theta[y==0] = 0

    E = special.ellipe((4 * R * rho)/( (R + rho)**2 + z**2))
    K = special.ellipk((4 * R * rho)/( (R + rho)**2 + z**2))
    Bz =  1/np.sqrt((R + rho)**2 + z**2) * (
                K
              + E * (R**2 - rho**2 - z**2)/((R - rho)**2 + z**2)
              )
    Brho = z/(rho*np.sqrt((R + rho)**2 + z**2)) * (
               -K
              + E * (R**2 + rho**2 + z**2)/((R - rho)**2 + z**2)
              )
    # On the axis of the coil we get a divided by zero here. This returns a
    # NaN, where the field is actually zero :
    Brho[np.isnan(Brho)] = 0
    Brho[np.isinf(Brho)] = 0
    Bz[np.isnan(Bz)]     = 0
    Bz[np.isinf(Bz)]     = 0

    B = np.c_[np.cos(theta)*Brho, np.sin(theta)*Brho, Bz ]

    # Rotate the field back in the lab's frame
    B = np.dot(B, trans)
    return B


def display_coil(n, r0, R, half=False):
    """
    Display a coils in the 3D view.
    If half is True, display only one half of the coil.
    """
    n, l, m = base_vectors(n)
    theta = np.linspace(0, (2-half)*np.pi, 30)
    theta = theta[..., np.newaxis]
    coil = np.atleast_1d(R)*(np.sin(theta)*l + np.cos(theta)*m)
    coil += r0
    coil_x = coil[:, 0]
    coil_y = coil[:, 1]
    coil_z = coil[:, 2]
    mlab.plot3d(coil_x, coil_y, coil_z,
            tube_radius=0.01,
            name='Coil %i' % display_coil.num,
            color=(0, 0, 0))
    display_coil.num += 1
    return coil_x, coil_y, coil_z

display_coil.num = 0

##############################################################################
# The grid of points on which we want to evaluate the field
X, Y, Z = np.mgrid[-0.15:0.15:31j, -0.15:0.15:31j, -0.15:0.15:31j]
# Avoid rounding issues :
f = 1e4  # this gives the precision we are interested by :
X = np.round(X * f) / f
Y = np.round(Y * f) / f
Z = np.round(Z * f) / f

r = np.c_[X.ravel(), Y.ravel(), Z.ravel()]

##############################################################################
# The coil positions

# The center of the coil
r0 = np.r_[0, 0, 0.1]
# The normal to the coils
n  = np.r_[0, 0, 1]
# The radius
R  = 0.1

# Add the mirror image of this coils relatively to the xy plane :
r0 = np.vstack((r0, -r0 ))
R  = np.r_[R, R]
n  = np.vstack((n, n))      # Helmoltz like configuration

##############################################################################
# Calculate field
# First initialize a container matrix for the field vector :
B = np.empty_like(r)
# Then loop through the different coils and sum the fields :
for this_n, this_r0, this_R in zip(n, r0, R):
  this_n    = np.array(this_n)
  this_r0   = np.array(this_r0)
  this_R    = np.array(this_R)
  B += magnetic_field(r, this_n, this_r0, this_R)


Bx = B[:, 0]
By = B[:, 1]
Bz = B[:, 2]
Bx.shape = X.shape
By.shape = Y.shape
Bz.shape = Z.shape

Bnorm = np.sqrt(Bx**2 + By**2 + Bz**2)

##############################################################################
# Visualization

# We threshold the data ourselves, as the threshold filter produce a
# data structure inefficient with IsoSurface
Bmax = 100

Bx[Bnorm > Bmax] = 0
By[Bnorm > Bmax] = 0
Bz[Bnorm > Bmax] = 0
Bnorm[Bnorm > Bmax] = Bmax

mlab.figure(1, bgcolor=(1, 1, 1), fgcolor=(0.5, 0.5, 0.5),
               size=(480, 480))
mlab.clf()

for this_n, this_r0, this_R in zip(n, r0, R):
  display_coil(this_n, this_r0, this_R)

field = mlab.pipeline.vector_field(X, Y, Z, Bx, By, Bz,
                                  scalars=Bnorm, name='B field')
vectors = mlab.pipeline.vectors(field,
                      scale_factor=(X[1, 0, 0] - X[0, 0, 0]),
                      )
# Mask random points, to have a lighter visualization.
vectors.glyph.mask_input_points = True
vectors.glyph.mask_points.on_ratio = 6

vcp = mlab.pipeline.vector_cut_plane(field)
vcp.glyph.glyph.scale_factor=5*(X[1, 0, 0] - X[0, 0, 0])
# For prettier picture:
#vcp.implicit_plane.widget.enabled = False

iso = mlab.pipeline.iso_surface(field,
                                contours=[0.1*Bmax, 0.4*Bmax],
                                opacity=0.6,
                                colormap='YlOrRd')

# A trick to make transparency look better: cull the front face
iso.actor.property.frontface_culling = True

mlab.view(39, 74, 0.59, [.008, .0007, -.005])

mlab.show()

########NEW FILE########
__FILENAME__ = magnetic_field_lines
"""
This example uses the streamline module to display field lines of a
magnetic dipole (a current loop).

This example requires scipy.

The magnetic field from an arbitrary current loop is calculated from
eqns (1) and (2) in Phys Rev A Vol. 35, N 4, pp. 1535-1546; 1987.

To get a prettier result, we use a fairly large grid to sample the
field. As a consequence, we need to clear temporary arrays as soon as
possible.

For a more thorough example of magnetic field calculation and
visualization with Mayavi and scipy, see
:ref:`example_magnetic_field`.
"""
# Author: Gael Varoquaux <gael.varoquaux@normalesup.org>
# Copyright (c) 2007, Enthought, Inc.
# License: BSD Style.

import numpy as np
from scipy import special

#### Calculate the field ####################################################
radius = 1  # Radius of the coils

x, y, z = [e.astype(np.float32) for e in
            np.ogrid[-10:10:150j, -10:10:150j, -10:10:150j]]

# express the coordinates in polar form
rho = np.sqrt(x ** 2 + y ** 2)
x_proj = x / rho
y_proj = y / rho
# Free memory early
del x, y

E = special.ellipe((4 * radius * rho) / ((radius + rho) ** 2 + z ** 2))
K = special.ellipk((4 * radius * rho) / ((radius + rho) ** 2 + z ** 2))
Bz = 1 / np.sqrt((radius + rho) ** 2 + z ** 2) * (
                K
                + E * (radius ** 2 - rho ** 2 - z ** 2) /
                    ((radius - rho) ** 2 + z ** 2)
            )
Brho = z / (rho * np.sqrt((radius + rho) ** 2 + z ** 2)) * (
                - K
                + E * (radius ** 2 + rho ** 2 + z ** 2) /
                    ((radius - rho) ** 2 + z ** 2)
            )
del E, K, z, rho
# On the axis of the coil we get a divided by zero. This returns a
# NaN, where the field is actually zero :
Brho[np.isnan(Brho)] = 0

Bx, By = x_proj * Brho, y_proj * Brho

del x_proj, y_proj, Brho

#### Visualize the field ####################################################
from mayavi import mlab
fig = mlab.figure(1, size=(400, 400), bgcolor=(1, 1, 1), fgcolor=(0, 0, 0))

field = mlab.pipeline.vector_field(Bx, By, Bz)
# Unfortunately, the above call makes a copy of the arrays, so we delete
# this copy to free memory.
del Bx, By, Bz

magnitude = mlab.pipeline.extract_vector_norm(field)
contours = mlab.pipeline.iso_surface(magnitude,
                                        contours=[0.01, 0.8, 3.8, ],
                                        transparent=True,
                                        opacity=0.4,
                                        colormap='YlGnBu',
                                        vmin=0, vmax=2)


field_lines = mlab.pipeline.streamline(magnitude, seedtype='line',
                                        integration_direction='both',
                                        colormap='bone',
                                        vmin=0, vmax=1)

# Tweak a bit the streamline.
field_lines.stream_tracer.maximum_propagation = 100.
field_lines.seed.widget.point1 = [69, 75.5, 75.5]
field_lines.seed.widget.point2 = [82, 75.5, 75.5]
field_lines.seed.widget.resolution = 50
field_lines.seed.widget.enabled = False

mlab.view(42, 73, 104, [79,  75,  76])

mlab.show()

########NEW FILE########
__FILENAME__ = mayavi_traits_ui
#!/usr/bin/env python
"""
An example of how to create a UI similar to the complete Mayavi application
inside a Traits UI view.

This does not use Envisage and provides a similar UI as seen in the full
Mayavi application.

This example uses `traitsUI <http://code.enthought.com/projects/traits/>`_
to create a dialog mimicking the mayavi2 application: a scene on the
right, and on the left a pipeline tree view, and below it a panel to
edit the currently-selected object.
"""

# Authors: Prabhu Ramachandran <prabhu [at] aero.iitb.ac.in>
# Copyright (c) 2007, Enthought, Inc.
# License: BSD Style.

# Standard imports.
from numpy import sqrt, sin, mgrid

# Enthought imports.
from traits.api import HasTraits, Instance, Property, Enum
from traitsui.api import View, Item, HSplit, VSplit, InstanceEditor
from tvtk.pyface.scene_editor import SceneEditor
from mayavi.core.ui.engine_view import EngineView
from mayavi.tools.mlab_scene_model import MlabSceneModel


######################################################################
class Mayavi(HasTraits):

    # The scene model.
    scene = Instance(MlabSceneModel, ())

    # The mayavi engine view.
    engine_view = Instance(EngineView)

    # The current selection in the engine tree view.
    current_selection = Property


    ######################
    view = View(HSplit(VSplit(Item(name='engine_view',
                                   style='custom',
                                   resizable=True,
                                   show_label=False
                                   ),
                              Item(name='current_selection',
                                   editor=InstanceEditor(),
                                   enabled_when='current_selection is not None',
                                   style='custom',
                                   springy=True,
                                   show_label=False),
                                   ),
                               Item(name='scene',
                                    editor=SceneEditor(),
                                    show_label=False,
                                    resizable=True,
                                    height=500,
                                    width=500),
                        ),
                resizable=True,
                scrollable=True
                )

    def __init__(self, **traits):
        HasTraits.__init__(self, **traits)
        self.engine_view = EngineView(engine=self.scene.engine)

        # Hook up the current_selection to change when the one in the engine
        # changes.  This is probably unnecessary in Traits3 since you can show
        # the UI of a sub-object in T3.
        self.scene.engine.on_trait_change(self._selection_change,
                                          'current_selection')

        self.generate_data_mayavi()

    def generate_data_mayavi(self):
        """Shows how you can generate data using mayavi instead of mlab."""
        from mayavi.sources.api import ParametricSurface
        from mayavi.modules.api import Outline, Surface
        e = self.scene.engine
        s = ParametricSurface()
        e.add_source(s)
        e.add_module(Outline())
        e.add_module(Surface())

    def _selection_change(self, old, new):
        self.trait_property_changed('current_selection', old, new)

    def _get_current_selection(self):
        return self.scene.engine.current_selection


if __name__ == '__main__':
    m = Mayavi()
    m.configure_traits()

########NEW FILE########
__FILENAME__ = mlab_3D_to_2D
"""
A script to calculate the projection of 3D world coordinates to
2D display coordinates (pixel coordinates) for a given scene.

The 2D pixel locations of objects in the image plane are related to their
3D world coordinates by a series of linear transformations. The specific
transformations fall under the group known as projective transformations.
This set includes pure projectivities, affine transformations,
perspective transformations, and euclidean transformations. In the case
of mlab (and most other computer visualization software), we deal with
only the perspective and euclidean cases. An overview of Projective space
can be found here: http://en.wikipedia.org/wiki/Projective_space and a
thorough treatment of projective geometry can be had in the book
"Multiple View Geometry in Computer Vision" by Richard Hartley.

The essential thing to know for this example is that points in 3-space
are related to points in 2-space through a series of multiplications of
4x4 matrices which are the perspective and euclidean transformations. The
4x4 matrices predicate the use of length 4 vectors to represent points.
This representation is known as homogeneous coordinates, and while they
appear foriegn at first, they truly simplify all the mathematics
involved. In short, homogeneous coordinates are your friend, and you
should read about them here:
http://en.wikipedia.org/wiki/Homogeneous_coordinates

In the normal pinhole camera model (the ideal real world model), 3D world
points are related to 2D image points by the matrix termed the
'essential' matrix which is a combination of a perspective transformation
and a euclidean transformation. The perspective transformation is defined
by the camera intrinsics (focal length, imaging sensor offset, etc...)
and the euclidean transformation is defined by the cameras position and
orientation. In computer graphics, things are not so simple. This is
because computer graphics have the benefit of being able to do things
which are not possible in the real world: adding clipping planes, offset
projection centers, arbitrary distortions, etc... Thus, a slightly
different model is used.

What follows is the camera/view model for OpenGL and thus, VTK. I can not
guarantee that other packages follow this model.

There are 4 different transformations that are applied 3D world
coordinates to map them to 2D pixel coordinates. They are: the model
transform, the view transform, the perspective transform, and the
viewport or display transform.

In OpenGL the first two transformations are concatenated to yield the
modelview transform (called simply the view transform in VTK). The
modelview transformation applies arbitrary scaling and distortions to the
model (if they are specified) and transforms them so that the orientation
is the equivalent of looking down the negative Z axis. Imagine its as if
you relocate your camera to look down the negative Z axis, and then move
everything in the world so that you see it now as you did before you
moved the camera. The resulting coordinates are termed "eye" coordinates
in OpenGL (I don't know that they have a name in VTK).

The perspective transformation applies the camera perspective to the eye
coordinates. This transform is what makes objects in the foreground look
bigger than equivalent objects in the background. In the pinhole camera
model, this transform is determined uniquely by the focal length of the
camera and its position in 3-space. In Vtk/OpenGL it is determined by the
frustum. A frustum is simply a pyramid with the top lopped off. The top
of the pyramid (a point) is the camera location, the base of the pyramid
is a plane (the far clipping plane) defined as normal to principle camera
ray at distance termed the far clipping distance, the top of the frustum
(where it's lopped off) is the near clipping plane, with a definition
similar to that of the far clipping plane. The sides of the frustum are
determined by the aspect ratio of the camera (width/height) and its
field-of-view. Any points not lying within the frustum are not mapped to
the screen (as they would lie outside the viewable area). The
perpspective transformation has the effect of scaling everything within
the frustum to fit within a cube defined in the range (-1,1)(-1,1)(-1,1)
as represented by homogeneous coordinates. The last phrase there is
important, the first 3 coordinates will not, in general, be within the
unity range until we divide through by the last coordinate (See the
wikipedia on homogeneous coordinates if this is confusing). The resulting
coordinates are termed (appropriately enough) normalized view
coordinates.

The last transformation (the viewport transformation) takes us from
normalized view coordinates to display coordinates. At this point, you
may be asking yourself 'why not just go directly to display coordinates,
why need normalized view coordinates at all?', the answer is that we may
want to embed more than one view in a particular window, there will
therefore be different transformations to take each view to an
appropriate position an size in the window. The normalized view
coordinates provide a nice common ground so-to-speak. At any rate, the
viewport transformation simply scales and translates the X and Y
coordinates of the normalized view coordinates to the appropriate pixel
coordinates. We don't use the Z value in our example because we don't
care about it. It is used for other various things however.

That's all there is to it, pretty simple right? Right. Here is an overview:

Given a set of 3D world coordinates:
 - Apply the modelview transformation (view transform in VTK) to get eye
   coordinates
 - Apply the perspective transformation to get normalized view coordinates
 - Apply the viewport transformation to get display coordinates

VTK provides a nice method to retrieve a 4x4 matrix that combines the
first two operations. As far as I can tell, VTK does not export a method
to retrieve the 4x4 matrix representing the viewport transformation, so
we are on our there to create one (no worries though, its not hard, as
you will see).

Now that the prelimenaries are out of the way, lets get started.

"""

# Author: S. Chris Colbert <sccolbert@gmail.com>
# Copyright (c) 2009, S. Chris Colbert
# License: BSD Style

# this import is here because we need to ensure that matplotlib uses the
# wx backend and having regular code outside the main block is PyTaboo.
# It needs to be imported first, so that matplotlib can impose the
# version of Wx it requires.
import matplotlib
matplotlib.use('WXAgg')
import pylab as pl


import numpy as np
from mayavi import mlab
from mayavi.core.ui.mayavi_scene import MayaviScene

def get_world_to_view_matrix(mlab_scene):
    """returns the 4x4 matrix that is a concatenation of the modelview transform and
    perspective transform. Takes as input an mlab scene object."""

    if not isinstance(mlab_scene, MayaviScene):
        raise TypeError('argument must be an instance of MayaviScene')


    # The VTK method needs the aspect ratio and near and far clipping planes
    # in order to return the proper transform. So we query the current scene
    # object to get the parameters we need.
    scene_size = tuple(mlab_scene.get_size())
    clip_range = mlab_scene.camera.clipping_range
    aspect_ratio = float(scene_size[0])/float(scene_size[1])

    # this actually just gets a vtk matrix object, we can't really do anything with it yet
    vtk_comb_trans_mat = mlab_scene.camera.get_composite_perspective_transform_matrix(
                                aspect_ratio, clip_range[0], clip_range[1])

     # get the vtk mat as a numpy array
    np_comb_trans_mat = vtk_comb_trans_mat.to_array()

    return np_comb_trans_mat


def get_view_to_display_matrix(mlab_scene):
    """ this function returns a 4x4 matrix that will convert normalized
        view coordinates to display coordinates. It's assumed that the view should
        take up the entire window and that the origin of the window is in the
        upper left corner"""

    if not (isinstance(mlab_scene, MayaviScene)):
        raise TypeError('argument must be an instance of MayaviScene')

    # this gets the client size of the window
    x, y = tuple(mlab_scene.get_size())

    # normalized view coordinates have the origin in the middle of the space
    # so we need to scale by width and height of the display window and shift
    # by half width and half height. The matrix accomplishes that.
    view_to_disp_mat = np.array([[x/2.0,      0.,   0.,   x/2.0],
                                 [   0.,  -y/2.0,   0.,   y/2.0],
                                 [   0.,      0.,   1.,      0.],
                                 [   0.,      0.,   0.,      1.]])

    return view_to_disp_mat


def apply_transform_to_points(points, trans_mat):
    """a function that applies a 4x4 transformation matrix to an of
        homogeneous points. The array of points should have shape Nx4"""

    if not trans_mat.shape == (4, 4):
        raise ValueError('transform matrix must be 4x4')

    if not points.shape[1] == 4:
        raise ValueError('point array must have shape Nx4')

    return np.dot(trans_mat, points.T).T


if __name__ == '__main__':
    f = mlab.figure()

    N = 4

    # create a few points in 3-space
    X = np.random.random_integers(-3, 3, N)
    Y = np.random.random_integers(-3, 3, N)
    Z = np.random.random_integers(-3, 3, N)

    # plot the points with mlab
    pts = mlab.points3d(X, Y, Z)

    # now were going to create a single N x 4 array of our points
    # adding a fourth column of ones expresses the world points in
    # homogenous coordinates
    W = np.ones(X.shape)
    hmgns_world_coords = np.column_stack((X, Y, Z, W))

    # applying the first transform will give us 'unnormalized' view
    # coordinates we also have to get the transform matrix for the
    # current scene view
    comb_trans_mat = get_world_to_view_matrix(f.scene)
    view_coords = \
            apply_transform_to_points(hmgns_world_coords, comb_trans_mat)

    # to get normalized view coordinates, we divide through by the fourth
    # element
    norm_view_coords = view_coords / (view_coords[:, 3].reshape(-1, 1))

    # the last step is to transform from normalized view coordinates to
    # display coordinates.
    view_to_disp_mat = get_view_to_display_matrix(f.scene)
    disp_coords = apply_transform_to_points(norm_view_coords, view_to_disp_mat)

    # at this point disp_coords is an Nx4 array of homogenous coordinates
    # where X and Y are the pixel coordinates of the X and Y 3D world
    # coordinates, so lets take a screenshot of mlab view and open it
    # with matplotlib so we can check the accuracy
    img = mlab.screenshot()
    pl.imshow(img)

    for i in range(N):
        print  'Point %d:  (x, y) ' % i, disp_coords[:, 0:2][i]
        pl.plot([disp_coords[:, 0][i]], [disp_coords[:, 1][i]], 'ro')

    pl.show()

    # you should check that the printed coordinates correspond to the
    # proper points on the screen

    mlab.show()

#EOF

########NEW FILE########
__FILENAME__ = mlab_interactive_dialog
#!/usr/bin/env python
"""
An example of how to modify the data visualized  via an interactive dialog.

A dialog is created via `TraitsUI
<http://code.enthought.com/projects/traits/>`_ from an object (MyModel).
Some attributes of the objects are represented on the dialog: first a
Mayavi scene, that will host our visualization, and two parameters that
control the data plotted.

A curve is plotted in the embedded scene using the associated
mlab.points3d function. The visualization object created is stored
as an attribute on the main MyModel object, to modify it inplace later.

When the `n_meridional` and `n_longitudinal` attributes are modified, eg via
the slide bars on the dialog, the curve is recomputed, and the
visualization is updated by modifying inplace the stored plot
object (see :ref:`mlab-animating-data`).

This example is discussed in details in the section
:ref:`embedding_mayavi_traits`.
"""
# Author: Gael Varoquaux <gael.varoquaux@normalesup.org>
# Copyright (c) 2008, Enthought, Inc.
# License: BSD Style.


from numpy import arange, pi, cos, sin

from traits.api import HasTraits, Range, Instance, \
        on_trait_change
from traitsui.api import View, Item, Group

from mayavi.core.api import PipelineBase
from mayavi.core.ui.api import MayaviScene, SceneEditor, \
                MlabSceneModel


dphi = pi/1000.
phi = arange(0.0, 2*pi + 0.5*dphi, dphi, 'd')

def curve(n_mer, n_long):
    mu = phi*n_mer
    x = cos(mu) * (1 + cos(n_long * mu/n_mer)*0.5)
    y = sin(mu) * (1 + cos(n_long * mu/n_mer)*0.5)
    z = 0.5 * sin(n_long*mu/n_mer)
    t = sin(mu)
    return x, y, z, t


class MyModel(HasTraits):
    n_meridional    = Range(0, 30, 6, )#mode='spinner')
    n_longitudinal  = Range(0, 30, 11, )#mode='spinner')

    scene = Instance(MlabSceneModel, ())

    plot = Instance(PipelineBase)


    # When the scene is activated, or when the parameters are changed, we
    # update the plot.
    @on_trait_change('n_meridional,n_longitudinal,scene.activated')
    def update_plot(self):
        x, y, z, t = curve(self.n_meridional, self.n_longitudinal)
        if self.plot is None:
            self.plot = self.scene.mlab.plot3d(x, y, z, t,
                                tube_radius=0.025, colormap='Spectral')
        else:
            self.plot.mlab_source.set(x=x, y=y, z=z, scalars=t)


    # The layout of the dialog created
    view = View(Item('scene', editor=SceneEditor(scene_class=MayaviScene),
                     height=250, width=300, show_label=False),
                Group(
                        '_', 'n_meridional', 'n_longitudinal',
                     ),
                resizable=True,
                )

my_model = MyModel()
my_model.configure_traits()

########NEW FILE########
__FILENAME__ = mlab_traits_ui
#!/usr/bin/env python
"""A simple example of how to use mayavi.mlab inside a traits UI dialog.

This example uses traitsUI (
`traitsUI <http://code.enthought.com/projects/traits/>`_ ) to create a
the simplest possible dialog: a single Mayavi scene in a window.
"""

# Authors: Prabhu Ramachandran <prabhu [at] aero.iitb.ac.in>
#          Gael Varoquaux
# Copyright (c) 2007, Enthought, Inc.
# License: BSD Style.

# Standard imports.
from numpy import sqrt, sin, mgrid

# Enthought imports.
from traits.api import HasTraits, Instance
from traitsui.api import View, Item
from tvtk.pyface.scene_editor import SceneEditor

from mayavi.tools.mlab_scene_model import MlabSceneModel
from mayavi.core.ui.mayavi_scene import MayaviScene


######################################################################
class ActorViewer(HasTraits):

    # The scene model.
    scene = Instance(MlabSceneModel, ())

    ######################
    # Using 'scene_class=MayaviScene' adds a Mayavi icon to the toolbar,
    # to pop up a dialog editing the pipeline.
    view = View(Item(name='scene',
                     editor=SceneEditor(scene_class=MayaviScene),
                     show_label=False,
                     resizable=True,
                     height=500,
                     width=500),
                resizable=True
                )

    def __init__(self, **traits):
        HasTraits.__init__(self, **traits)
        self.generate_data()

    def generate_data(self):
        # Create some data
        X, Y = mgrid[-2:2:100j, -2:2:100j]
        R = 10*sqrt(X**2 + Y**2)
        Z = sin(R)/R

        self.scene.mlab.surf(X, Y, Z, colormap='gist_earth')


if __name__ == '__main__':
    a = ActorViewer()
    a.configure_traits()

########NEW FILE########
__FILENAME__ = mlab_visual
#!/usr/bin/env python
"""
A very simple example to show how you can use TVTK's visual module
with mlab and create simple animations.

In the example, the grey box bounces back and forth between the two red
ones.

The `tvtk.tools.visual` module exposes an API similar to
`VPython <http://vpython.org/>`_ and is useful to create animation based
on rigid object movement.

The `@animate` decorator ( :func:`mayavi.mlab.animate` ) is
detailed on section :ref:`animating_a_visualization`.

If you want to modify the data plotted by the mlab (as in the
`mlab.test_plot3d()` call) to create an animation, please see section
:ref:`mlab-animating-data`.

"""
# Author: Prabhu Ramachandran <prabhu [at] aero.iitb.ac.in>
# Copyright (c) 2009, Enthought, Inc.
# License: BSD Style.

from mayavi import mlab
from tvtk.tools import visual
# Create a figure
f = mlab.figure(size=(500,500))
# Tell visual to use this as the viewer.
visual.set_viewer(f)

# A silly visualization.
mlab.test_plot3d()

# Even sillier animation.
b1 = visual.box()
b2 = visual.box(x=4., color=visual.color.red)
b3 = visual.box(x=-4, color=visual.color.red)
b1.v = 5.0

@mlab.show
@mlab.animate(delay=250)
def anim():
    """Animate the b1 box."""
    while 1:
        b1.x = b1.x + b1.v*0.1
        if b1.x > 2.5 or b1.x < -2.5:
            b1.v = -b1.v
        yield

# Run the animation.
anim()

########NEW FILE########
__FILENAME__ = mri
"""
Viewing MRI data with cut plane and iso surface.

This example downloads an MRI scan, turns it into a 3D numpy array and
visualizes it.

First we extract some internal structures of the brain by defining a
volume of interest around them, and using iso surfaces.

Then we display two cut planes to show the raw MRI data itself.

Finally we display the outer surface, but we restrict it to volume of
interest to leave a cut for the cut planes.

For an example of feature extraction from MRI data using Mayavi and vtk,
see :ref:`example_tvtk_segmentation`.
"""

### Download the data, if not already on disk #################################
import os
if not os.path.exists('mri_data.tar.gz'):
    # Download the data
    import urllib
    print "Downloading data, Please Wait (7.8MB)"
    opener = urllib.urlopen(
                'http://www-graphics.stanford.edu/data/voldata/MRbrain.tar.gz')
    open('mri_data.tar.gz', 'wb').write(opener.read())

# Extract the data
import tarfile
tar_file = tarfile.open('mri_data.tar.gz')
try:
    os.mkdir('mri_data')
except:
    pass
tar_file.extractall('mri_data')
tar_file.close()


### Read the data in a numpy 3D array #########################################
import numpy as np
data = np.array([np.fromfile(os.path.join('mri_data', 'MRbrain.%i' % i),
                                        dtype='>u2') for i in range(1, 110)])
data.shape = (109, 256, 256)
data = data.T

# Display the data ############################################################
from mayavi import mlab

mlab.figure(bgcolor=(0, 0, 0), size=(400, 400))

src = mlab.pipeline.scalar_field(data)
# Our data is not equally spaced in all directions:
src.spacing = [1, 1, 1.5]
src.update_image_data = True


# Extract some inner structures: the ventricles and the inter-hemisphere
# fibers. We define a volume of interest (VOI) that restricts the
# iso-surfaces to the inner of the brain. We do this with the ExtractGrid
# filter.
blur = mlab.pipeline.user_defined(src, filter='ImageGaussianSmooth')
voi = mlab.pipeline.extract_grid(blur)
voi.set(x_min=125, x_max=193, y_min=92, y_max=125, z_min=34, z_max=75)

mlab.pipeline.iso_surface(voi, contours=[1610, 2480], colormap='Spectral')

# Add two cut planes to show the raw MRI data. We use a threshold filter
# to remove cut the planes outside the brain.
thr = mlab.pipeline.threshold(src, low=1120)
cut_plane = mlab.pipeline.scalar_cut_plane(thr,
                                plane_orientation='y_axes',
                                colormap='black-white',
                                vmin=1400,
                                vmax=2600)
cut_plane.implicit_plane.origin = (136, 111.5, 82)
cut_plane.implicit_plane.widget.enabled = False

cut_plane2 = mlab.pipeline.scalar_cut_plane(thr,
                                plane_orientation='z_axes',
                                colormap='black-white',
                                vmin=1400,
                                vmax=2600)
cut_plane2.implicit_plane.origin = (136, 111.5, 82)
cut_plane2.implicit_plane.widget.enabled = False

# Extract two views of the outside surface. We need to define VOIs in
# order to leave out a cut in the head.
voi2 = mlab.pipeline.extract_grid(src)
voi2.set(y_min=112)
outer = mlab.pipeline.iso_surface(voi2, contours=[1776, ],
                                        color=(0.8, 0.7, 0.6))

voi3 = mlab.pipeline.extract_grid(src)
voi3.set(y_max=112, z_max=53)
outer3 = mlab.pipeline.iso_surface(voi3, contours=[1776, ],
                                         color=(0.8, 0.7, 0.6))


mlab.view(-125, 54, 326, (145.5, 138, 66.5))
mlab.roll(-175)

mlab.show()

import shutil
shutil.rmtree('mri_data')

########NEW FILE########
__FILENAME__ = multiple_engines
"""
An example to show how you can have multiple engines in one application.

Mutliple engines can be useful for more separation, eg to script each
engine separately, or to avoid side effects between scenes.

This example shows how to explicitely set the engine for an embedded
scene.

To define default arguments, it makes use of the Traits initialization
style, rather than overridding the __init__.
"""
# Author:  Gael Varoquaux <gael _dot_ varoquaux _at_ normalesup _dot_ org>
# Copyright (c) 2009, Enthought, Inc.
# License: BSD Style.

from traits.api import HasTraits, Instance, on_trait_change
from traitsui.api import View, Group, Item

from mayavi.core.api import Engine
from mayavi.core.ui.api import MayaviScene, MlabSceneModel, \
            SceneEditor

################################################################################
class MyApp(HasTraits):

    # The first engine. As default arguments (an empty tuple) are given,
    # traits initializes it.
    engine1 = Instance(Engine, args=())

    scene1 = Instance(MlabSceneModel)

    def _scene1_default(self):
        " The default initializer for 'scene1' "
        self.engine1.start()
        scene1 = MlabSceneModel(engine=self.engine1)
        return scene1

    engine2 = Instance(Engine, ())

    scene2 = Instance(MlabSceneModel)

    def _scene2_default(self):
        " The default initializer for 'scene2' "
        self.engine2.start()
        scene2 = MlabSceneModel(engine=self.engine2)
        return scene2

    # We populate the scenes only when it is activated, to avoid problems
    # with VTK objects that expect an active scene
    @on_trait_change('scene1.activated')
    def populate_scene1(self):
        self.scene1.mlab.test_surf()

    @on_trait_change('scene2.activated')
    def populate_scene2(self):
        self.scene2.mlab.test_mesh()

    # The layout of the view
    view = View(Group(Item('scene1',
                        editor=SceneEditor(scene_class=MayaviScene),
                        width=480, height=480)),
                Group(Item('scene2',
                        editor=SceneEditor(scene_class=MayaviScene),
                        width=480, height=480)),
                resizable=True)


if __name__ == '__main__':
    MyApp().configure_traits()


########NEW FILE########
__FILENAME__ = multiple_mlab_scene_models
""" Example showing a dialog with multiple embedded scenes.

When using several embedded scenes with mlab, you should be very careful
always to pass the scene you want to use for plotting to the mlab
function used, elsewhere it uses the current scene. In this example,
failing to do so would result in only one scene being used, the last
one created.

The trick is to use the 'mayavi_scene' attribute of the MlabSceneModel,
and pass it as a keyword argument to the mlab functions.

For more examples on embedding mlab scenes in dialog, see also:
the examples :ref:`example_mlab_interactive_dialog`, and
:ref:`example_lorenz_ui`, as well as the section of the user manual
:ref:`embedding_mayavi_traits`.
"""
import numpy as np

from traits.api import HasTraits, Instance, Button, \
    on_trait_change
from traitsui.api import View, Item, HSplit, Group

from mayavi import mlab
from mayavi.core.ui.api import MlabSceneModel, SceneEditor


class MyDialog(HasTraits):

    scene1 = Instance(MlabSceneModel, ())
    scene2 = Instance(MlabSceneModel, ())

    button1 = Button('Redraw')
    button2 = Button('Redraw')

    @on_trait_change('button1')
    def redraw_scene1(self):
        self.redraw_scene(self.scene1)

    @on_trait_change('button2')
    def redraw_scene2(self):
        self.redraw_scene(self.scene2)

    def redraw_scene(self, scene):
        # Notice how each mlab call points explicitely to the figure it
        # applies to.
        mlab.clf(figure=scene.mayavi_scene)
        x, y, z, s = np.random.random((4, 100))
        mlab.points3d(x, y, z, s, figure=scene.mayavi_scene)

    # The layout of the dialog created
    view = View(HSplit(
                  Group(
                       Item('scene1',
                            editor=SceneEditor(), height=250,
                            width=300),
                       'button1',
                       show_labels=False,
                  ),
                  Group(
                       Item('scene2',
                            editor=SceneEditor(), height=250,
                            width=300, show_label=False),
                       'button2',
                       show_labels=False,
                  ),
                ),
                resizable=True,
                )


m = MyDialog()
m.configure_traits()

########NEW FILE########
__FILENAME__ = nongui
#!/usr/bin/env python
"""
This script demonstrates how one can use the Mayavi application framework
without displaying Mayavi's UI.

Note: look at the end of this file to see how the non gui plugin is
chosen instead of the default gui mayavi plugin.

This should be run as::

  $ python nongui.py

Or::

  $ mayavi2 script.py

"""
# Author: Prabhu Ramachandran <prabhu_r@users.sf.net>
# Copyright (c) 2005, Enthought, Inc.
# License: BSD Style.

# Standard library imports
from os.path import join, abspath

# Enthought library imports
from mayavi.scripts.util import get_data_dir
from mayavi.plugins.app import Mayavi, get_non_gui_plugins

class MyApp(Mayavi):
    def run(self):
        """This is executed once the application GUI has started.
        *Make sure all other MayaVi specific imports are made here!*
        """

        # Various imports to do different things.
        from mayavi.sources.vtk_file_reader import VTKFileReader
        from mayavi.modules.outline import Outline
        from mayavi.modules.axes import Axes
        from mayavi.modules.grid_plane import GridPlane
        from mayavi.modules.image_plane_widget import ImagePlaneWidget
        from mayavi.modules.text import Text
        from mayavi.modules.contour_grid_plane import ContourGridPlane
        from mayavi.modules.iso_surface import IsoSurface

        script = self.script

        # Create a new scene.
        script.new_scene()

        # Read a VTK (old style) data file.
        r = VTKFileReader()
        r.initialize(join(get_data_dir(abspath(__file__)),
                          'heart.vtk'))
        script.add_source(r)

        # Put up some text.
        t = Text(text='MayaVi rules!', x_position=0.2, y_position=0.9, width=0.8)
        t.property.color = 1, 1, 0  # Bright yellow, yeah!
        script.add_module(t)

        # Create an outline for the data.
        o = Outline()
        script.add_module(o)

        # Create an axes for the data.
        a = Axes()
        script.add_module(a)

        # Create three simple grid plane modules.
        # First normal to 'x' axis.
        gp = GridPlane()
        script.add_module(gp)
        # Second normal to 'y' axis.
        gp = GridPlane()
        gp.grid_plane.axis = 'y'
        script.add_module(gp)
        # Third normal to 'z' axis.
        gp = GridPlane()
        script.add_module(gp)
        gp.grid_plane.axis = 'z'

        # Create one ImagePlaneWidget.
        ipw = ImagePlaneWidget()
        script.add_module(ipw)
        # Set the position to the middle of the data.
        ipw.ipw.slice_position = 16

        # Create one ContourGridPlane normal to the 'x' axis.
        cgp = ContourGridPlane()
        script.add_module(cgp)
        # Set the position to the middle of the data.
        cgp.grid_plane.axis = 'y'
        cgp.grid_plane.position = 15

        # An isosurface module.
        iso = IsoSurface(compute_normals=True)
        script.add_module(iso)
        iso.contour.contours = [200.0]

        # Set the view.
        s = script.engine.current_scene
        cam = s.scene.camera
        cam.azimuth(45)
        cam.elevation(15)
        s.render()


if __name__ == '__main__':
    m = MyApp()
    # Get the default non GUI plugins.
    plugins = get_non_gui_plugins()
    # Start the app with these plugins.
    m.main(plugins=plugins)

########NEW FILE########
__FILENAME__ = numeric_source
#!/usr/bin/env python

"""This script demonstrates how to create a numpy array data and
visualize it as image data using a few modules.

"""
# Author: Prabhu Ramachandran <prabhu_r@users.sf.net>
# Copyright (c) 2005-2008, Enthought, Inc.
# License: BSD Style.

# Standard library imports
import numpy

# Enthought library imports
from mayavi.scripts import mayavi2
from mayavi.sources.array_source import ArraySource
from mayavi.modules.outline import Outline
from mayavi.modules.image_plane_widget import ImagePlaneWidget


def make_data(dims=(128, 128, 128)):
    """Creates some simple array data of the given dimensions to test
    with."""
    np = dims[0]*dims[1]*dims[2]

    # Create some scalars to render.
    x, y, z = numpy.ogrid[-5:5:dims[0]*1j,-5:5:dims[1]*1j,-5:5:dims[2]*1j]
    x = x.astype('f')
    y = y.astype('f')
    z = z.astype('f')

    scalars = (numpy.sin(x*y*z)/(x*y*z))
    # The copy makes the data contiguous and the transpose makes it
    # suitable for display via tvtk.  Please note that we assume here
    # that the ArraySource is configured to not transpose the data.
    s = numpy.transpose(scalars).copy()
    # Reshaping the array is needed since the transpose messes up the
    # dimensions of the data.  The scalars themselves are ravel'd and
    # used internally by VTK so the dimension does not matter for the
    # scalars.
    s.shape = s.shape[::-1]

    return s


@mayavi2.standalone
def view_numpy():
    """Example showing how to view a 3D numpy array in mayavi2.
    """
    # 'mayavi' is always defined on the interpreter.
    mayavi.new_scene()
    # Make the data and add it to the pipeline.
    data = make_data()
    src = ArraySource(transpose_input_array=False)
    src.scalar_data = data
    mayavi.add_source(src)
    # Visualize the data.
    o = Outline()
    mayavi.add_module(o)
    ipw = ImagePlaneWidget()
    mayavi.add_module(ipw)
    ipw.module_manager.scalar_lut_manager.show_scalar_bar = True

    ipw_y = ImagePlaneWidget()
    mayavi.add_module(ipw_y)
    ipw_y.ipw.plane_orientation = 'y_axes'


if __name__ == '__main__':
    view_numpy()


########NEW FILE########
__FILENAME__ = offscreen
#!/usr/bin/env python
"""A simple example of how you can use Mayavi without using Envisage
or the Mayavi Envisage application and do off screen rendering.

On Linux/Mac, with VTK < 5.2, you should see a small black window popup
and disappear, see the section :ref:`offscreen_rendering` to avoid this.
On Win32 you will not see any windows popping up at all. In the end you
should have an offscreen.png image in the same directory with the
rendered visualization.

It can be run as::

    $ python offscreen.py
"""

# Author: Prabhu Ramachandran <prabhu@aero.iitb.ac.in>
# Copyright (c) 2007, Enthought, Inc.
# License: BSD Style.

from os.path import join, abspath, dirname

# The offscreen Engine.
from mayavi.api import OffScreenEngine

# Usual MayaVi imports
from mayavi.scripts.util import get_data_dir
from mayavi.sources.api import VTKXMLFileReader
from mayavi.modules.api import Outline, ScalarCutPlane, Streamline


def main():
    # Create the MayaVi offscreen engine and start it.
    e = OffScreenEngine()
    # Starting the engine registers the engine with the registry and
    # notifies others that the engine is ready.
    e.start()

    # Create a new scene.
    win = e.new_scene()

    # Now setup a normal MayaVi pipeline.
    src = VTKXMLFileReader()
    src.initialize(join(get_data_dir(dirname(abspath(__file__))),
                        'fire_ug.vtu'))
    e.add_source(src)
    e.add_module(Outline())
    e.add_module(ScalarCutPlane())
    e.add_module(Streamline())
    win.scene.isometric_view()
    # Change the size argument to anything you want.
    win.scene.save('offscreen.png', size=(800, 800))


if __name__ == '__main__':
    main()

########NEW FILE########
__FILENAME__ = pick_on_surface
""" Example showing how to pick data on a surface, going all the way back
to the index in the numpy arrays.

In this example, two views of the same data are shown. One with the data
on a sphere, the other with the data flat.

We use the 'on_mouse_pick' method of the scene to register a callback on
clicking on the sphere. The callback is called with a picker object as
andan argument. We use the point_id of the point that has been picked,
andand  go back to the 2D index on the data matrix to find its position.
"""

################################################################################
# Create some data
import numpy as np
pi  = np.pi
cos = np.cos
sin = np.sin

phi, theta = np.mgrid[0:pi:180j,0:2*pi:180j]
m0 = 4; m1 = 3; m2 = 2; m3 = 3; m4 = 1; m5 = 2; m6 = 2; m7 = 4;
s = sin(m0*phi)**m1 + cos(m2*phi)**m3 + sin(m4*theta)**m5 + cos(m6*theta)**m7
x = sin(phi)*cos(theta)
y = cos(phi)
z = sin(phi)*sin(theta)

################################################################################
# Plot the data
from mayavi import mlab

# A first plot in 3D
fig = mlab.figure(1)
mlab.clf()
mesh = mlab.mesh(x, y, z, scalars=s)
cursor3d = mlab.points3d(0., 0., 0., mode='axes',
                                color=(0, 0, 0),
                                scale_factor=0.5)
mlab.title('Click on the ball')

# A second plot, flat
fig2d = mlab.figure(2)
mlab.clf()
im = mlab.imshow(s)
cursor = mlab.points3d(0, 0, 0, mode='2dthick_cross',
                                color=(0, 0, 0),
                                scale_factor=10)
mlab.view(90, 0)

################################################################################
# Some logic to select 'mesh' and the data index when picking.

def picker_callback(picker_obj):
    picked = picker_obj.actors
    if mesh.actor.actor._vtk_obj in [o._vtk_obj for o in picked]:
        # m.mlab_source.points is the points array underlying the vtk
        # dataset. GetPointId return the index in this array.
        x_, y_ = np.lib.index_tricks.unravel_index(picker_obj.point_id,
                                                                s.shape)
        print "Data indices: %i, %i" % (x_, y_)
        n_x, n_y = s.shape
        cursor.mlab_source.set(x=x_ - n_x/2.,
                               y=y_ - n_y/2.)
        cursor3d.mlab_source.set(x=x[x_, y_],
                                 y=y[x_, y_],
                                 z=z[x_, y_])

fig.on_mouse_pick(picker_callback)

mlab.show()


########NEW FILE########
__FILENAME__ = plotting_many_lines
"""
This examples shows how many lines can be grouped together in a single
object, for convenience and efficiency.

We want to plot a large number of lines. We could use mlab.plot3d for
this, but it will create an object for each line, this will be
inefficient. This example shows how to create one object comprised of
many lines.

The underlying idea is the same as that used to plot graphes (see for
instance :ref:`example_flight_graph`): create a set of points, and
specify explicitely the connectivity between them. First we create the
set of unconnected point (the underlying data structure is a
:ref:`poly_data`) using `mlab.pipeline.scalar_scatter`. To add the
connections, we need to keep track of which point is connected to which.
As we only have lines, this is fairly easy: in a line, each point is
connected to the following one.

"""

# Author: Gael Varoquaux <gael dot varoquaux at normalesup dot org>
# Copyright (c) 2010, Enthought
# License: BSD style

import numpy as np

# The number of points per line
N = 300

# The scalar parameter for each line
t = np.linspace(-2 * np.pi, 2 * np.pi, N)

from mayavi import mlab
mlab.figure(1, size=(400, 400), bgcolor=(0, 0, 0))
mlab.clf()

# We create a list of positions and connections, each describing a line.
# We will collapse them in one array before plotting.
x = list()
y = list()
z = list()
s = list()
connections = list()

# The index of the current point in the total amount of points
index = 0

# Create each line one after the other in a loop
for i in range(50):
    x.append(np.sin(t))
    y.append(np.cos((2 + .02 * i) * t))
    z.append(np.cos((3 + .02 * i) * t))
    s.append(t)
    # This is the tricky part: in a line, each point is connected
    # to the one following it. We have to express this with the indices
    # of the final set of points once all lines have been combined
    # together, this is why we need to keep track of the total number of
    # points already created (index)
    connections.append(np.vstack(
                       [np.arange(index,   index + N - 1.5),
                        np.arange(index + 1, index + N - .5)]
                            ).T)
    index += N

# Now collapse all positions, scalars and connections in big arrays
x = np.hstack(x)
y = np.hstack(y)
z = np.hstack(z)
s = np.hstack(s)
connections = np.vstack(connections)

# Create the points
src = mlab.pipeline.scalar_scatter(x, y, z, s)

# Connect them
src.mlab_source.dataset.lines = connections

# The stripper filter cleans up connected lines
lines = mlab.pipeline.stripper(src)

# Finally, display the set of lines
mlab.pipeline.surface(lines, colormap='Accent', line_width=1, opacity=.4)

# And choose a nice view
mlab.view(33.6, 106, 5.5, [0, 0, .05])
mlab.roll(125)
mlab.show()

########NEW FILE########
__FILENAME__ = poll_file
#!/usr/bin/env python
"""A simple script that polls a data file for changes and then updates
the mayavi pipeline automatically.

This script is to be run like so::

 $ mayavi2 -x poll_file.py

Or::

 $ python poll_file.py

The script currently defaults to using the example data in
examples/data/heart.vtk.  You can try editing that data file or change
this script to point to other data which you can edit.
"""

# Author: Prabhu Ramachandran <prabhu@aero.iitb.ac.in>
# Copyright (c) 2006-2007, Enthought Inc.
# License: BSD Style.

# Standard imports.
import os
from os.path import join, abspath, dirname

# Enthought library imports
from mayavi.scripts import mayavi2
from mayavi.sources.vtk_file_reader import VTKFileReader
from mayavi.modules.outline import Outline
from mayavi.modules.contour_grid_plane import ContourGridPlane
from pyface.timer.api import Timer


######################################################################
# `Pollster` class.
class Pollster(object):
    """Given a file name and a mayavi2 data reader object, this class
    polls the file for any changes and automatically updates the
    mayavi pipeline.
    """
    def __init__(self, fname, data):
        """Initialize the object.

        Parameters:
        -----------
        fname -- filename to poll.
        data -- the MayaVi source object to update.
        """
        self.fname = fname
        self.data = data
        self.last_stat = os.stat(fname)

    def poll_file(self):
        # Check the file's time stamp.
        s = os.stat(self.fname)
        if s[-2] == self.last_stat[-2]:
            return
        else:
            self.last_stat = s
            self.update_pipeline()

    def update_pipeline(self):
        """Override this to do something else if needed.
        """
        print "file changed"
        # Force the reader to re-read the file.
        d = self.data
        d.reader.modified()
        d.update()
        # Propagate the changes in the pipeline.
        d.data_changed = True



def setup_data(fname):
    """Given a VTK file name `fname`, this creates a mayavi2 reader
    for it and adds it to the pipeline.  It returns the reader
    created.
    """
    # 'mayavi' is always defined on the interpreter.
    mayavi.new_scene()
    d = VTKFileReader()
    d.initialize(fname)
    mayavi.add_source(d)
    return d

def view_data():
    """Sets up the mayavi pipeline for the visualization.
    """
    # 'mayavi' is always defined on the interpreter.
    o = Outline()
    mayavi.add_module(o)

    c = ContourGridPlane()
    mayavi.add_module(c)
    c.grid_plane.position = 16
    c.module_manager.scalar_lut_manager.show_scalar_bar = True

@mayavi2.standalone
def main():
    # Change this to suit your needs.  Edit the file after running this
    # script and the pipeline should be updated automatically.

    fname = join(mayavi2.get_data_dir(abspath(dirname(__file__))),
                 'heart.vtk')

    data = setup_data(fname)
    view_data()

    # Poll the file.
    p = Pollster(fname, data)
    timer = Timer(1000, p.poll_file)
    # Keep a reference on the timer
    mayavi2.savedtimerbug = timer

    # To stop polling the file do:
    #timer.Stop()

if __name__ == '__main__':
    main()


########NEW FILE########
__FILENAME__ = polydata
"""
An example of how to generate a polydata dataset using numpy arrays.

The example is similar to tvtk/examples/tiny_mesh.py.  Also shown is a
way to visualize this data with mayavi2.  The script can be run like so::

  $ mayavi2 -x polydata.py

It can be alternatively run as::

  $ python polydata.py

"""

# Author: Prabhu Ramachandran <prabhu at aero dot iitb dot ac dot in>
# Copyright (c) 2007, Enthought, Inc.
# License: BSD style.

from numpy import array
from tvtk.api import tvtk
from mayavi.scripts import mayavi2

# The numpy array data.
points = array([[0,0,0], [1,0,0], [0,1,0], [0,0,1]], 'f')
triangles = array([[0,1,3], [0,3,2], [1,2,3], [0,2,1]])
temperature = array([10., 20., 30., 40.])

# The TVTK dataset.
mesh = tvtk.PolyData(points=points, polys=triangles)
mesh.point_data.scalars = temperature
mesh.point_data.scalars.name = 'Temperature'

# Uncomment the next two lines to save the dataset to a VTK XML file.
#w = tvtk.XMLPolyDataWriter(input=mesh, file_name='polydata.vtp')
#w.write()

# Now view the data.
@mayavi2.standalone
def view():
    from mayavi.sources.vtk_data_source import VTKDataSource
    from mayavi.modules.surface import Surface

    mayavi.new_scene()
    src = VTKDataSource(data = mesh)
    mayavi.add_source(src)
    s = Surface()
    mayavi.add_module(s)

if __name__ == '__main__':
    view()


########NEW FILE########
__FILENAME__ = probe_filter
"""
Using the probe filter to visualize a scalar field along an arbitrary
surface.

This example shows how a data set can be 'projected' (or interpolated) on
another given source using the probe filter. It is also an example of a
complex VTK pipeline and shows how to inspect it with the
PipelineBrowser.

In this example, a function is sampled on a regular grid and can be
visualized using an ImagePlaneWidget. The function we are interested is
independent of the distance to the origin and a function only of the
angle. This is why it may be interesting to visualize its value sampled
on a sphere center at the origin, but we have the data sampled throughout
the volume on a regular grid.

We create a sphere with the BuiltinSurface source and use the VTK
ProbeFilter to sample the data on this surface. The ProbeFilter takes one
input, which is the data structure to project the data on, and a
'source', which is where the data values come from.

We need to use the UserDefined filter to insert this VTK filter in the
Mayavi pipeline (see :ref:`using_userdefined_filter` as well as
:ref:`example_image_cursor_filter` and :ref:`example_tvtk_segmentation`).
Specifying its input is done automatical when it is inserted on the
pipeline, be its source needs to be specified explicitely. As it is a VTK
filter, the source is the VTK dataset output by the Mayavi object: we can
find it in `.outputs[0]`.

Note that this filter violates slightly the simple pipeline model that
Mayavi tries to expose to the users: it has two entries. As a result,
the Mayavi pipeline is not longer really a tree. However, if you open up
the Mayavi :ref:`pipeline view <mlab-changing-objects-interactively>`,
you can see that the ProbeFilter has only one parent in the view. To
inspect the actually VTK pipeline underlying this visualization, we
use the TVTK PipelineBrowser at the end of the example. You can see that
the VTK pipeline is much more complex that the pipeline represented
in Mayavi: actors, data mappers, and other elements of the VTK pipeline
are collapsed in the Mayavi filters and modules.

Note that, as we know the expression of the function, it would be simpler
and more efficient to directly sample it on the sphere.
"""
import numpy as np

from mayavi import mlab
from tvtk.api import tvtk

# The angular par of the spherical harmonic (3, 2)
x, y, z = np.mgrid[-.5:.5:100j, -.5:.5:100j, -.5:.5:100j]
Phi = np.angle((x+y*1j)**2*z)

field = mlab.pipeline.scalar_field(x, y, z, Phi)
ipw = mlab.pipeline.image_plane_widget(field)
mlab.outline(field)

surface = mlab.pipeline.builtin_surface()
surface.source = 'sphere'
surface.data_source.radius = .4
surface.data_source.phi_resolution = 200
surface.data_source.theta_resolution = 200
probe_filter = tvtk.ProbeFilter(source=field.outputs[0])
probe = mlab.pipeline.user_defined(surface, filter=probe_filter)

surf = mlab.pipeline.surface(probe)

fig = mlab.gcf()

################################################################################
# Finally, to inspect the VTK Pipeline (and not the Mayavi one, we
# use the TVTK pipeline browser)
# Note that for Mayavi version < 3.4.1, there is a bug in the
# PipelineBrowser preventing a good display of this pipeline.
from tvtk.pipeline.browser import PipelineBrowser
browser = PipelineBrowser(fig.scene)
browser.show()

mlab.show()


########NEW FILE########
__FILENAME__ = protein
"""
Visualize a protein graph structure downloaded from the protein database in
standard pdb format.

We parse the pdb file, but extract only a very small amount of
information: the type of atoms, their positions, and the links between them.

Most of the complexity of this example comes from the code turning the
PDB information into a list of 3D positions, with associated scalar
and connection information.

We assign a scalar value for the atoms to differenciate the different
types of atoms, but it does not correspond to the atomic mass. The size
and the color of the atom on the visualization is therefore not
chemicaly-significant.

The atoms are plotted using mlab.points3d, and connections between atoms
are added to the dataset, and visualized using a surface module.

The graph is created by adding connection information to points. For this, each
point is designated by its number (in the order of the array passed to
mlab.points3d), and the connection array, made of pairs of these numbers, is
constructed. There is some slightly tedious data manipulation to go from the
named-node graph representation as stored in the pdb file, to the index-based
connection pairs. A similar technique to plot the graph is done in the
:ref:`example_flight_graph`. Another example of graph plotting, showing a
different technique to plot the graph, can be seen on
:ref:`example_delaunay_graph`.

To visualize the local atomic density, we use a gaussian splatter filter
that builds a kernel density estimation of the continuous density field:
each point is convoluted by a Gaussian kernel, and the sum of these
Gaussians form the resulting density field. We visualize this field using
volume rendering.

Reference for the pdb file standard:
http://mmcif.pdb.org/dictionaries/pdb-correspondence/pdb2mmcif.html
"""

# Author: Gael Varoquaux <gael.varoquaux@normalesup.org>
# Copyright (c) 2008, Enthought, Inc.
# License: BSD Style.

# The pdb code for the protein.
protein_code = '2q09'

# Retrieve the file from the protein database #################################
import os
if not os.path.exists('pdb%s.ent.gz' % protein_code):
    # Download the data
    import urllib
    print 'Downloading protein data, please wait'
    opener = urllib.urlopen(
      'ftp://ftp.wwpdb.org/pub/pdb/data/structures/divided/pdb/q0/pdb%s.ent.gz'
      % protein_code)
    open('pdb%s.ent.gz' % protein_code, 'wb').write(opener.read())

# Parse the pdb file ##########################################################
import gzip
infile = gzip.GzipFile('pdb%s.ent.gz' % protein_code, 'rb')

# A graph represented by a dictionary associating nodes with keys
# (numbers), and edges (pairs of node keys).
nodes = dict()
edges = list()
atoms = set()

# Build the graph from the PDB information
last_atom_label = None
last_chain_label = None
for line in infile:
    line = line.split()
    if line[0] in ('ATOM', 'HETATM'):
        nodes[line[1]] = (line[2], line[6], line[7], line[8])
        atoms.add(line[2])
        chain_label = line[5]
        if chain_label == last_chain_label:
            edges.append((line[1], last_atom_label))
        last_atom_label = line[1]
        last_chain_label = chain_label
    elif line[0] == 'CONECT':
        for start, stop in zip(line[1:-1], line[2:]):
            edges.append((start, stop))

atoms = list(atoms)
atoms.sort()
atoms = dict(zip(atoms, range(len(atoms))))

# Turn the graph into 3D positions, and a connection list.
labels = dict()

x = list()
y = list()
z = list()
scalars = list()

for index, label in enumerate(nodes):
    labels[label] = index
    this_scalar, this_x, this_y, this_z = nodes[label]
    scalars.append(atoms[this_scalar])
    x.append(float(this_x))
    y.append(float(this_y))
    z.append(float(this_z))

connections = list()

for start, stop in edges:
    connections.append((labels[start], labels[stop]))

import numpy as np
x = np.array(x)
y = np.array(y)
z = np.array(z)
scalars = np.array(scalars)

# Visualize the data ##########################################################
from mayavi import mlab
mlab.figure(1, bgcolor=(0, 0, 0))
mlab.clf()

pts = mlab.points3d(x, y, z, 1.5 * scalars.max() - scalars,
                                    scale_factor=0.015, resolution=10)
pts.mlab_source.dataset.lines = np.array(connections)

# Use a tube fiter to plot tubes on the link, varying the radius with the
# scalar value
tube = mlab.pipeline.tube(pts, tube_radius=0.15)
tube.filter.radius_factor = 1.
tube.filter.vary_radius = 'vary_radius_by_scalar'
mlab.pipeline.surface(tube, color=(0.8, 0.8, 0))

# Visualize the local atomic density
mlab.pipeline.volume(mlab.pipeline.gaussian_splatter(pts))

mlab.view(49, 31.5, 52.8, (4.2, 37.3, 20.6))

mlab.show()

########NEW FILE########
__FILENAME__ = qt_embedding
"""
This example demonstrates using Mayavi as a component of a large Qt
application.

For this use, Mayavi is embedded in a QWidget. To understand this
example, please read section :ref:`builing-applications`.
"""

# First, and before importing any Enthought packages, set the ETS_TOOLKIT
# environment variable to qt4, to tell Traits that we will use Qt.
import os
os.environ['ETS_TOOLKIT'] = 'qt4'
# By default, the PySide binding will be used. If you want the PyQt bindings
# to be used, you need to set the QT_API environment variable to 'pyqt'
#os.environ['QT_API'] = 'pyqt'

# To be able to use PySide or PyQt4 and not run in conflicts with traits,
# we need to import QtGui and QtCore from pyface.qt
from pyface.qt import QtGui, QtCore
# Alternatively, you can bypass this line, but you need to make sure that
# the following lines are executed before the import of PyQT:
#   import sip
#   sip.setapi('QString', 2)

from traits.api import HasTraits, Instance, on_trait_change
from traitsui.api import View, Item
from mayavi.core.ui.api import MayaviScene, MlabSceneModel, \
        SceneEditor


################################################################################
#The actual visualization
class Visualization(HasTraits):
    scene = Instance(MlabSceneModel, ())

    @on_trait_change('scene.activated')
    def update_plot(self):
        # This function is called when the view is opened. We don't
        # populate the scene when the view is not yet open, as some
        # VTK features require a GLContext.

        # We can do normal mlab calls on the embedded scene.
        self.scene.mlab.test_points3d()

    # the layout of the dialog screated
    view = View(Item('scene', editor=SceneEditor(scene_class=MayaviScene),
                     height=250, width=300, show_label=False),
                resizable=True # We need this to resize with the parent widget
                )


################################################################################
# The QWidget containing the visualization, this is pure PyQt4 code.
class MayaviQWidget(QtGui.QWidget):
    def __init__(self, parent=None):
        QtGui.QWidget.__init__(self, parent)
        layout = QtGui.QVBoxLayout(self)
        layout.setContentsMargins(0,0,0,0)
        layout.setSpacing(0)
        self.visualization = Visualization()

        # If you want to debug, beware that you need to remove the Qt
        # input hook.
        #QtCore.pyqtRemoveInputHook()
        #import pdb ; pdb.set_trace()
        #QtCore.pyqtRestoreInputHook()

        # The edit_traits call will generate the widget to embed.
        self.ui = self.visualization.edit_traits(parent=self,
                                                 kind='subpanel').control
        layout.addWidget(self.ui)
        self.ui.setParent(self)


if __name__ == "__main__":
    # Don't create a new QApplication, it would unhook the Events
    # set by Traits on the existing QApplication. Simply use the
    # '.instance()' method to retrieve the existing one.
    app = QtGui.QApplication.instance()
    container = QtGui.QWidget()
    container.setWindowTitle("Embedding Mayavi in a PyQt4 Application")
    # define a "complex" layout to test the behaviour
    layout = QtGui.QGridLayout(container)

    # put some stuff around mayavi
    label_list = []
    for i in range(3):
        for j in range(3):
            if (i==1) and (j==1):continue
            label = QtGui.QLabel(container)
            label.setText("Your QWidget at (%d, %d)" % (i,j))
            label.setAlignment(QtCore.Qt.AlignHCenter|QtCore.Qt.AlignVCenter)
            layout.addWidget(label, i, j)
            label_list.append(label)
    mayavi_widget = MayaviQWidget(container)

    layout.addWidget(mayavi_widget, 1, 1)
    container.show()
    window = QtGui.QMainWindow()
    window.setCentralWidget(container)
    window.show()

    # Start the main event loop.
    app.exec_()



########NEW FILE########
__FILENAME__ = scatter_plot
"""
An example of plotting scatter points with Mayavi's core API.

This script creates a bunch of random points with random scalar data
and then shows these as a "scatter" plot of points.  The script
illustrates how to

 1. create a dataset easily using tvtk and numpy,

 2. use a created dataset in Mayavi and visualize it.

This example achieve the same functionnality as mlab's points3d
function ( :func:`mayavi.mlab.points3d`), but explicitely
creating the objects and adding them to the pipeline engine via the Mayavi
core API. Compared to using mlab, this method has the advantage of giving
more control on which objects are created, and there life cycle.

Run this script like so::

  $ mayavi2 -x scatter_plot.py

Alternatively it can be run as::

  $ python scatter_plot.py
"""

# Author: Prabhu Ramachandran <prabhu@aero.iitb.ac.in>
# Copyright (c) 2007 Prabhu Ramachandran.
# License: BSD Style.

import numpy as np
from tvtk.api import tvtk
from mayavi.scripts import mayavi2


@mayavi2.standalone
def main():
    # Create some random points to view.
    pd = tvtk.PolyData()
    pd.points = np.random.random((1000, 3))
    verts = np.arange(0, 1000, 1)
    verts.shape = (1000, 1)
    pd.verts = verts
    pd.point_data.scalars = np.random.random(1000)
    pd.point_data.scalars.name = 'scalars'

    # Now visualize it using mayavi2.
    from mayavi.sources.vtk_data_source import VTKDataSource
    from mayavi.modules.outline import Outline
    from mayavi.modules.surface import Surface

    mayavi.new_scene()
    d = VTKDataSource()
    d.data = pd
    mayavi.add_source(d)
    mayavi.add_module(Outline())
    s = Surface()
    mayavi.add_module(s)
    s.actor.property.set(representation='p', point_size=2)
    # You could also use glyphs to render the points via the Glyph module.

if __name__ == '__main__':
    main()

########NEW FILE########
__FILENAME__ = select_red_balls
"""
This example shows how to use a callback to select a red ball amongst white
balls.

The example uses the figure method 'on_mouse_pick', added in Mayavi
3.4, to register a callback when the left mouse is pressed. The callback
is called with a picker, enabling to identify the object selected.
Specificaly, actors are selected, each object is represented on the scene
via actors. The selected actors can be found in 'picker.actors'. In this
example, we have plotted red balls and white ball. We want to select the
red balls, and thus test if any actor in picker.actors corresponds to an
actor of red balls.

To identify which ball has been selected, we use the point id. However,
each ball is represented by several points. Thus we need to retrieve the
number of points per ball, and divide the point id by this number.

We use an outline to display which ball was selected by positioning it on
the corresponding ball.
"""

# Author: Gael Varoquaux <gael dot varoquaux at normalesup.org>
# Copyright (c) 2009, Enthought, Inc.
# License: BSD style.

import numpy as np
from mayavi import mlab

################################################################################
# Disable the rendering, to get bring up the figure quicker:
figure = mlab.gcf()
mlab.clf()
figure.scene.disable_render = True

# Creates two set of points using mlab.points3d: red point and
# white points
x1, y1, z1 = np.random.random((3, 10))
red_glyphs = mlab.points3d(x1, y1, z1, color=(1, 0, 0),
                resolution=20)

x2, y2, z2 = np.random.random((3, 10))
white_glyphs = mlab.points3d(x2, y2, z2, color=(0.9, 0.9, 0.9),
                resolution=20)

# Add an outline to show the selected point and center it on the first
# data point.
outline = mlab.outline(line_width=3)
outline.outline_mode = 'cornered'
outline.bounds = (x1[0]-0.1, x1[0]+0.1,
                  y1[0]-0.1, y1[0]+0.1,
                  z1[0]-0.1, z1[0]+0.1)

# Every object has been created, we can reenable the rendering.
figure.scene.disable_render = False
################################################################################


# Here, we grab the points describing the individual glyph, to figure
# out how many points are in an individual glyph.
glyph_points = red_glyphs.glyph.glyph_source.glyph_source.output.points.to_array()


def picker_callback(picker):
    """ Picker callback: this get called when on pick events.
    """
    if picker.actor in red_glyphs.actor.actors:
        # Find which data point corresponds to the point picked:
        # we have to account for the fact that each data point is
        # represented by a glyph with several points
        point_id = picker.point_id/glyph_points.shape[0]
        # If the no points have been selected, we have '-1'
        if point_id != -1:
            # Retrieve the coordinnates coorresponding to that data
            # point
            x, y, z = x1[point_id], y1[point_id], z1[point_id]
            # Move the outline to the data point.
            outline.bounds = (x-0.1, x+0.1,
                              y-0.1, y+0.1,
                              z-0.1, z+0.1)


picker = figure.on_mouse_pick(picker_callback)

# Decrease the tolerance, so that we can more easily select a precise
# point.
picker.tolerance = 0.01

mlab.title('Click on red balls')

mlab.show()

########NEW FILE########
__FILENAME__ = simple_structured_grid
"""
An example creating a structured grid data set from numpy arrays using TVTK
and visualizing it using mlab.

In this example, we create a structured-grid data set: we describe
data, both scalar and vector, lying on a structured-grid, ie a grid where
each vertex has 6 neighboors. For this we directly create a
StructuredGrid tvtk object, rather than using the mlab.pipeline source
functions, as it gives us more control.

To visualize the resulting dataset, we apply several modules, using the
mlab.pipeline interface (see :ref:`controlling-the-pipeline-with-mlab-scripts`)
"""
# Author: Prabhu Ramachandran <prabhu@aero.iitb.ac.in>
# Copyright (c) 2008, Prabhu Ramachandran.
# License: BSD Style.

from numpy import mgrid, empty, sin, pi
from tvtk.api import tvtk
from mayavi import mlab

# Generate some points.
x, y, z = mgrid[1:6:11j, 0:4:13j, 0:3:6j]
base = x[..., 0] + y[..., 0]
# Some interesting z values.
for i in range(z.shape[2]):
    z[..., i] = base * 0.25 * i

# The actual points.
pts = empty(z.shape + (3,), dtype=float)
pts[..., 0] = x
pts[..., 1] = y
pts[..., 2] = z

# Simple scalars.
scalars = x * x + y * y + z * z
# Some vectors
vectors = empty(z.shape + (3,), dtype=float)
vectors[..., 0] = (4 - y * 2)
vectors[..., 1] = (x * 3 - 12)
vectors[..., 2] = sin(z * pi)

# We reorder the points, scalars and vectors so this is as per VTK's
# requirement of x first, y next and z last.
pts = pts.transpose(2, 1, 0, 3).copy()
pts.shape = pts.size / 3, 3
scalars = scalars.T.copy()
vectors = vectors.transpose(2, 1, 0, 3).copy()
vectors.shape = vectors.size / 3, 3

# Create the dataset.
sg = tvtk.StructuredGrid(dimensions=x.shape, points=pts)
sg.point_data.scalars = scalars.ravel()
sg.point_data.scalars.name = 'temperature'
sg.point_data.vectors = vectors
sg.point_data.vectors.name = 'velocity'

# Thats it!

# Now visualize the data.
d = mlab.pipeline.add_dataset(sg)
gx = mlab.pipeline.grid_plane(d)
gy = mlab.pipeline.grid_plane(d)
gy.grid_plane.axis = 'y'
gz = mlab.pipeline.grid_plane(d)
gz.grid_plane.axis = 'z'
iso = mlab.pipeline.iso_surface(d)
iso.contour.maximum_contour = 75.0
vec = mlab.pipeline.vectors(d)
vec.glyph.mask_input_points = True
vec.glyph.glyph.scale_factor = 1.5

mlab.show()

########NEW FILE########
__FILENAME__ = spherical_harmonics
"""
Plot spherical harmonics on the surface of the sphere, as well as a 3D
polar plot.

This example requires scipy.

In this example we use the mlab's mesh function:
:func:`mayavi.mlab.mesh`.
For plotting surfaces this is a very versatile function. The surfaces can
be defined as functions of a 2D grid.

For each spherical harmonic, we plot its value on the surface of a
sphere, and then in polar. The polar plot is simply obtained by varying
the radius of the previous sphere.
"""

# Author: Gael Varoquaux <gael.varoquaux@normalesup.org>
# Copyright (c) 2008, Enthought, Inc.
# License: BSD Style.

from mayavi import mlab
import numpy as np
from scipy.special import sph_harm

# Create a sphere
r = 0.3
pi = np.pi
cos = np.cos
sin = np.sin
phi, theta = np.mgrid[0:pi:101j, 0:2 * pi:101j]

x = r * sin(phi) * cos(theta)
y = r * sin(phi) * sin(theta)
z = r * cos(phi)

mlab.figure(1, bgcolor=(1, 1, 1), fgcolor=(0, 0, 0), size=(400, 300))
mlab.clf()
# Represent spherical harmonics on the surface of the sphere
for n in range(1, 6):
    for m in range(n):
        s = sph_harm(m, n, theta, phi).real

        mlab.mesh(x - m, y - n, z, scalars=s, colormap='jet')

        s[s < 0] *= 0.97

        s /= s.max()
        mlab.mesh(s * x - m, s * y - n, s * z + 1.3,
                  scalars=s, colormap='Spectral')

mlab.view(90, 70, 6.2, (-1.3, -2.9, 0.25))
mlab.show()

########NEW FILE########
__FILENAME__ = standalone
#!/usr/bin/env python
"""A simple example of how you can use Mayavi without
using Envisage or the Mayavi Envisage application.

"""
# Author: Prabhu Ramachandran <prabhu@aero.iitb.ac.in>
# Copyright (c) 2007, Enthought, Inc.
# License: BSD Style.

from os.path import join, abspath

from pyface.api import GUI
# The core Engine.
from mayavi.core.api import Engine
from mayavi.core.ui.engine_view import EngineView
# Usual MayaVi imports
from mayavi.scripts.util import get_data_dir
from mayavi.sources.api import VTKXMLFileReader
from mayavi.modules.api import Outline, ScalarCutPlane, Streamline


def main():
    # Create the MayaVi engine and start it.
    e = Engine()
    # Starting the engine registers the engine with the registry and
    # notifies others that the engine is ready.
    e.start()

    # Do this if you need to see the MayaVi tree view UI.
    ev = EngineView(engine=e)
    ui = ev.edit_traits()

    # Create a new scene.
    scene = e.new_scene()
    # Now create a new scene just for kicks.
    scene1 = e.new_scene()

    # Now setup a normal MayaVi pipeline.
    src = VTKXMLFileReader()
    src.initialize(join(get_data_dir(abspath(__file__)),
                        'fire_ug.vtu'))
    e.add_source(src)
    e.add_module(Outline())
    e.add_module(ScalarCutPlane())
    e.add_module(Streamline())
    return e, ui

if __name__ == '__main__':
    # When main returns the ui to go out of scope and be gc'd causing the view
    # to disappear with qt4.
    e, ui = main()
    # Create a GUI instance and start the event loop.  We do this here so that
    # main can be run from IPython -wthread if needed.
    gui = GUI()
    gui.start_event_loop()


########NEW FILE########
__FILENAME__ = streamline
#!/usr/bin/env mayavi2
"""This script demonstrates how one can script Mayavi's core API to display
streamlines and an iso surface.
"""
# Author: Prabhu Ramachandran <prabhu_r@users.sf.net>
# Copyright (c) 2005-2007, Enthought, Inc.
# License: BSD Style.

# Standard library imports
from os.path import join, abspath, dirname

# Enthought library imports
from mayavi.scripts import mayavi2
from mayavi.sources.vtk_xml_file_reader import VTKXMLFileReader
from mayavi.sources.vrml_importer import VRMLImporter
from mayavi.modules.outline import Outline
from mayavi.modules.streamline import Streamline
from mayavi.modules.iso_surface import IsoSurface

def setup_data(fname):
    """Given a VTK XML file name `fname`, this creates a mayavi2
    reader for it and adds it to the pipeline.  It returns the reader
    created.
    """
    r = VTKXMLFileReader()
    r.initialize(fname)
    mayavi.add_source(r)
    return r

def show_vrml(fname):
    """Given a VRML file name it imports it into the scene.
    """
    r = VRMLImporter()
    r.initialize(fname)
    mayavi.add_source(r)
    return r

def streamline():
    """Sets up the mayavi pipeline for the visualization.
    """
    # Create an outline for the data.
    o = Outline()
    mayavi.add_module(o)

    s = Streamline(streamline_type='tube')
    mayavi.add_module(s)
    s.stream_tracer.integration_direction = 'both'
    s.seed.widget.center = 3.5, 0.625, 1.25
    s.module_manager.scalar_lut_manager.show_scalar_bar = True

    i = IsoSurface()
    mayavi.add_module(i)
    i.contour.contours[0] = 550
    i.actor.property.opacity = 0.5

@mayavi2.standalone
def main():
    mayavi.new_scene()

    data_dir = mayavi2.get_data_dir(dirname(abspath(__file__)))
    vrml_fname = join(data_dir, 'room_vis.wrl')
    r = show_vrml(vrml_fname)

    fname = join(data_dir, 'fire_ug.vtu')
    r = setup_data(fname)
    streamline()


if __name__ == '__main__':
    main()

########NEW FILE########
__FILENAME__ = structured_grid
"""An example of how to generate a structured grid dataset using
numpy arrays.  Also shown is a way to visualize this data with
the mayavi2 application.

The script can be run like so::

  $ mayavi2 -x structured_grid.py

Alternatively, it can be run as::

  $ python structured_grid.py


"""

# Authors: Eric Jones <eric at enthought dot com>
#          Prabhu Ramachandran <prabhu at aero dot iitb dot ac dot in>
# Copyright (c) 2007, Enthought, Inc.
# License: BSD style.

import numpy as np
from numpy import cos, sin, pi
from tvtk.api import tvtk
from mayavi.scripts import mayavi2

def generate_annulus(r=None, theta=None, z=None):
    """ Generate points for structured grid for a cylindrical annular
        volume.  This method is useful for generating a structured
        cylindrical mesh for VTK (and perhaps other tools).

        Parameters
        ----------
        r : array : The radial values of the grid points.
                    It defaults to linspace(1.0, 2.0, 11).

        theta : array : The angular values of the x axis for the grid
                        points. It defaults to linspace(0,2*pi,11).

        z: array : The values along the z axis of the grid points.
                   It defaults to linspace(0,0,1.0, 11).

        Return
        ------
        points : array
            Nx3 array of points that make up the volume of the annulus.
            They are organized in planes starting with the first value
            of z and with the inside "ring" of the plane as the first
            set of points.  The default point array will be 1331x3.
    """
    # Default values for the annular grid.
    if r is None: r = np.linspace(1.0, 2.0, 11)
    if theta is None: theta = np.linspace(0, 2*pi, 11)
    if z is None: z = np.linspace(0.0, 1.0, 11)

    # Find the x values and y values for each plane.
    x_plane = (cos(theta)*r[:,None]).ravel()
    y_plane = (sin(theta)*r[:,None]).ravel()

    # Allocate an array for all the points.  We'll have len(x_plane)
    # points on each plane, and we have a plane for each z value, so
    # we need len(x_plane)*len(z) points.
    points = np.empty([len(x_plane)*len(z),3])

    # Loop through the points for each plane and fill them with the
    # correct x,y,z values.
    start = 0
    for z_plane in z:
        end = start + len(x_plane)
        # slice out a plane of the output points and fill it
        # with the x,y, and z values for this plane.  The x,y
        # values are the same for every plane.  The z value
        # is set to the current z
        plane_points = points[start:end]
        plane_points[:,0] = x_plane
        plane_points[:,1] = y_plane
        plane_points[:,2] = z_plane
        start = end

    return points

# Make the data.
dims = (51, 25, 25)
# Note here that the 'x' axis corresponds to 'theta'
theta = np.linspace(0, 2*np.pi, dims[0])
# 'y' corresponds to varying 'r'
r = np.linspace(1, 10, dims[1])
z = np.linspace(0, 5, dims[2])
pts = generate_annulus(r, theta, z)
# Uncomment the following if you want to add some noise to the data.
#pts += np.random.randn(dims[0]*dims[1]*dims[2], 3)*0.04
sgrid = tvtk.StructuredGrid(dimensions=dims)
sgrid.points = pts
s = np.sqrt(pts[:,0]**2 + pts[:,1]**2 + pts[:,2]**2)
sgrid.point_data.scalars = np.ravel(s.copy())
sgrid.point_data.scalars.name = 'scalars'

# Uncomment the next two lines to save the dataset to a VTK XML file.
#w = tvtk.XMLStructuredGridWriter(input=sgrid, file_name='sgrid.vts')
#w.write()

# View the data.
@mayavi2.standalone
def view():
    from mayavi.sources.vtk_data_source import VTKDataSource
    from mayavi.modules.api import Outline, GridPlane

    mayavi.new_scene()
    src = VTKDataSource(data=sgrid)
    mayavi.add_source(src)
    mayavi.add_module(Outline())
    g = GridPlane()
    g.grid_plane.axis = 'x'
    mayavi.add_module(g)
    g = GridPlane()
    g.grid_plane.axis = 'y'
    mayavi.add_module(g)
    g = GridPlane()
    g.grid_plane.axis = 'z'
    mayavi.add_module(g)

if __name__ == '__main__':
    view()

########NEW FILE########
__FILENAME__ = structured_points2d
"""An example of how to generate a 2D structured points dataset
using numpy arrays.  Also shown is a way to visualize this data with
the mayavi2 application.

The script can be run like so::

  $ mayavi2 -x structured_points2d.py

Alternatively, it can be run as::

  $ python structured_points2d.py

"""
# Author: Prabhu Ramachandran <prabhu at aero dot iitb dot ac dot in>
# Copyright (c) 2007, Enthought, Inc.
# License: BSD style.

from numpy import arange, sqrt, sin
from tvtk.api import tvtk
from mayavi.scripts import mayavi2

# Generate the scalar values.
x = (arange(0.1, 50.0)-25)/2.0
y = (arange(0.1, 50.0)-25)/2.0
r = sqrt(x[:,None]**2+y**2)
z = 5.0*sin(r)/r  #

# Make the tvtk dataset.
# tvtk.ImageData is identical and could also be used here.
spoints = tvtk.StructuredPoints(origin=(-12.5,-12.5,0),
                                spacing=(0.5,0.5,1),
                                dimensions=(50,50,1))
# Transpose the array data due to VTK's implicit ordering. VTK assumes
# an implicit ordering of the points: X co-ordinate increases first, Y
# next and Z last.  We flatten it so the number of components is 1.
spoints.point_data.scalars = z.T.flatten()
spoints.point_data.scalars.name = 'scalar'

# Uncomment the next two lines to save the dataset to a VTK XML file.
#w = tvtk.XMLImageDataWriter(input=spoints, file_name='spoints2d.vti')
#w.write()

# Now view the data.
@mayavi2.standalone
def view():
    from mayavi.sources.vtk_data_source import VTKDataSource
    from mayavi.filters.warp_scalar import WarpScalar
    from mayavi.filters.poly_data_normals import PolyDataNormals
    from mayavi.modules.surface import Surface

    mayavi.new_scene()
    src = VTKDataSource(data = spoints)
    mayavi.add_source(src)
    mayavi.add_filter(WarpScalar())
    mayavi.add_filter(PolyDataNormals())
    s = Surface()
    mayavi.add_module(s)

if __name__ == '__main__':
    view()

########NEW FILE########
__FILENAME__ = structured_points3d
"""An example of how to generate a 3D structured points dataset
using numpy arrays.  Also shown is a way to visualize this data with
the mayavi2 application.

The script can be run like so::

  $ mayavi2 -x structured_points3d.py

Alternatively, it can be run as::

  $ python structured_points3d.py

"""
# Author: Prabhu Ramachandran <prabhu at aero dot iitb dot ac dot in>
# Copyright (c) 2007, Enthought, Inc.
# License: BSD style.

from tvtk.api import tvtk
from tvtk.array_handler import get_vtk_array_type
from numpy import array, ogrid, sin, ravel
from mayavi.scripts import mayavi2

# Make the data.
dims = array((128, 128, 128))
vol = array((-5., 5, -5, 5, -5, 5))
origin = vol[::2]
spacing = (vol[1::2] - origin)/(dims -1)
xmin, xmax, ymin, ymax, zmin, zmax = vol
x, y, z = ogrid[xmin:xmax:dims[0]*1j,
                ymin:ymax:dims[1]*1j,
                zmin:zmax:dims[2]*1j]
x, y, z = [t.astype('f') for t in (x, y, z)]
scalars = sin(x*y*z)/(x*y*z)

# Make the tvtk dataset.
spoints = tvtk.StructuredPoints(origin=origin, spacing=spacing,
                                dimensions=dims)
# The copy makes the data contiguous and the transpose makes it
# suitable for display via tvtk.  Note that it is not necessary to
# make the data contiguous since in that case the array is copied
# internally.
s = scalars.transpose().copy()
spoints.point_data.scalars = ravel(s)
spoints.point_data.scalars.name = 'scalars'

# This is needed in slightly older versions of VTK (like the 5.0.2
# release) to prevent a segfault.  VTK does not detect the correct
# data type.
spoints.scalar_type = get_vtk_array_type(s.dtype)

# Uncomment the next two lines to save the dataset to a VTK XML file.
#w = tvtk.XMLImageDataWriter(input=spoints, file_name='spoints3d.vti')
#w.write()

# Now view the data.
@mayavi2.standalone
def view():
    from mayavi.sources.vtk_data_source import VTKDataSource
    from mayavi.modules.outline import Outline
    from mayavi.modules.image_plane_widget import ImagePlaneWidget

    mayavi.new_scene()
    src = VTKDataSource(data = spoints)
    mayavi.add_source(src)
    mayavi.add_module(Outline())
    mayavi.add_module(ImagePlaneWidget())

if __name__ == '__main__':
    view()

########NEW FILE########
__FILENAME__ = subclassing_mayavi_application
#!/usr/bin/env python
"""
This script demonstrates how one can script the Mayavi application by
subclassing the application, create a new scene and create a few
simple modules.

This should be run as::

   $ python test.py

"""
# Author: Prabhu Ramachandran <prabhu_r@users.sf.net>
# Copyright (c) 2005-2007, Enthought, Inc.
# License: BSD Style.

# Standard library imports
from os.path import join, abspath, dirname

# Enthought library imports
from mayavi.plugins.app import Mayavi
from mayavi.scripts.util import get_data_dir

class MyApp(Mayavi):
    def run(self):
        """This is executed once the application GUI has started.
        *Make sure all other MayaVi specific imports are made here!*
        """
        # Various imports to do different things.
        from mayavi.sources.vtk_file_reader import VTKFileReader
        from mayavi.modules.outline import Outline
        from mayavi.modules.axes import Axes
        from mayavi.modules.grid_plane import GridPlane
        from mayavi.modules.image_plane_widget import ImagePlaneWidget
        from mayavi.modules.text import Text

        script = self.script
        # Create a new scene.
        script.new_scene()

        # Read a VTK (old style) data file.
        r = VTKFileReader()
        r.initialize(join(get_data_dir(dirname(abspath(__file__))), 'heart.vtk'))
        script.add_source(r)

        # Put up some text.
        t = Text(text='MayaVi rules!', x_position=0.2,
                 y_position=0.9, width=0.8)
        t.property.color = 1, 1, 0  # Bright yellow, yeah!
        script.add_module(t)

        # Create an outline for the data.
        o = Outline()
        script.add_module(o)

        # Create an axes for the data.
        a = Axes()
        script.add_module(a)

        # Create an orientation axes for the scene.  This only works with
        # VTK-4.5 and above which is why we have the try block.
        try:
            from mayavi.modules.orientation_axes import OrientationAxes
        except ImportError:
            pass
        else:
            a = OrientationAxes()
            a.marker.set_viewport(0.0, 0.8, 0.2, 1.0)
            script.add_module(a)

        # Create three simple grid plane modules.
        # First normal to 'x' axis.
        gp = GridPlane()
        script.add_module(gp)
        # Second normal to 'y' axis.
        gp = GridPlane()
        gp.grid_plane.axis = 'y'
        script.add_module(gp)
        # Third normal to 'z' axis.
        gp = GridPlane()
        script.add_module(gp)
        gp.grid_plane.axis = 'z'

        # Create one ImagePlaneWidget.
        ipw = ImagePlaneWidget()
        script.add_module(ipw)
        # Set the position to the middle of the data.
        ipw.ipw.slice_position = 16



if __name__ == '__main__':
    a = MyApp()
    a.main()

########NEW FILE########
__FILENAME__ = surface_from_irregular_data
"""
An example which shows how to plot a surface from data acquired
irregularly.

Data giving the variation of a parameter 'z' as a function of two others
('x' and 'y') is often plotted as a `carpet plot`, using a surface to
visualize the underlying function. when the data has been acquired on a
regular grid for parameters 'x' and 'y', it can simply be view with the
mlab.surf function. However, when there are some missing points, or the
data has been acquired at random, the surf function cannot be used.

The difficulty stems from the fact that points positionned in 3D do
not define a surface if no connectivity information is given. With the
surf function, this information is implicite from the shape of the input
arrays.

In this example, randomly-positionned points in the (x, y) plane are
embedded in a surface in the z axis. We first visualize the points using
mlab.points3d. We then use the delaunay2d filter to extract the mesh by
nearest-neighboor matching, and visualize it using the surface module.
"""
# Author: Gael Varoquaux <gael.varoquaux@normalesup.org>
# Copyright (c) 2009, Enthought, Inc.
# License: BSD Style.

import numpy as np

# Create data with x and y random in the [-2, 2] segment, and z a
# Gaussian function of x and y.
np.random.seed(12345)
x = 4 * (np.random.random(500) - 0.5)
y = 4 * (np.random.random(500) - 0.5)


def f(x, y):
    return np.exp(-(x ** 2 + y ** 2))

z = f(x, y)

from mayavi import mlab
mlab.figure(1, fgcolor=(0, 0, 0), bgcolor=(1, 1, 1))

# Visualize the points
pts = mlab.points3d(x, y, z, z, scale_mode='none', scale_factor=0.2)

# Create and visualize the mesh
mesh = mlab.pipeline.delaunay2d(pts)
surf = mlab.pipeline.surface(mesh)

mlab.view(47, 57, 8.2, (0.1, 0.15, 0.14))
mlab.show()

########NEW FILE########
__FILENAME__ = surf_regular_mlab
#!/usr/bin/env python
"""Shows how to view data created by `tvtk.tools.mlab` with
mayavi2.
"""

# Author: Prabhu Ramachandran <prabhu@aero.iitb.ac.in>
# Copyright (c) 2006-2007, Enthought Inc.
# License: BSD Style.

import numpy

from mayavi.scripts import mayavi2
from tvtk.tools import mlab
from mayavi.sources.vtk_data_source import VTKDataSource
from mayavi.filters.warp_scalar import WarpScalar
from mayavi.modules.outline import Outline
from mayavi.modules.surface import Surface


def make_data():
    """Make some test numpy data and create a TVTK data object from it
    that we will visualize.
    """
    def f(x, y):
        """Some test function.
        """
        return numpy.sin(x*y)/(x*y)

    x = numpy.arange(-7., 7.05, 0.1)
    y = numpy.arange(-5., 5.05, 0.05)
    s = mlab.SurfRegular(x, y, f)
    return s.data

def add_data(tvtk_data):
    """Add a TVTK data object `tvtk_data` to the mayavi pipleine.
    """
    d = VTKDataSource()
    d.data = tvtk_data
    mayavi.add_source(d)

def surf_regular():
    """Now visualize the data as done in mlab.
    """
    w = WarpScalar()
    mayavi.add_filter(w)
    o = Outline()
    s = Surface()
    mayavi.add_module(o)
    mayavi.add_module(s)

@mayavi2.standalone
def main():
    mayavi.new_scene()
    d = make_data()
    add_data(d)
    surf_regular()

if __name__ == '__main__':
    main()

########NEW FILE########
__FILENAME__ = tvtk_in_mayavi
"""
An example of pure TVTK programming to build TVTK objects, which are then
added to a Mayavi scene.

This example show how pure TVTK objects can be added to a Mayavi scene.

This programming style does not allow to benefit from the data-management
facilities of Mayavi (the pipeline, the data-oriented mlab functions),
but it allows to easily reuse VTK code together with Mayavi or mlab code.

If you want to use arbritrary VTK filters with Mayavi, it is best to use
the UserDefined Mayavi filter, which enables the user to insert any VTK
filter in the Mayavi pipeline. See, for instance, the :ref:`example_mri`
for example of the UserDefined filter. For a full-blown example of a
complex VTK pipeline built with Mayavi, see
:ref:`example_tvtk_segmentation`.
"""

# Author: Gael Varoquaux <gael.varoquaux@normalesup.org>
# Copyright (c) 2008, Enthought, Inc.
# License: BSD Style.

from mayavi import mlab

# To access any VTK object, we use 'tvtk', which is a Python wrapping of
# VTK replacing C++ setters and getters by Python properties and
# converting numpy arrays to VTK arrays when setting data.
from tvtk.api import tvtk

v = mlab.figure()

# Create a first sphere
# The source generates data points
sphere = tvtk.SphereSource(center=(0, 0, 0), radius=0.5)
# The mapper converts them into position in, 3D with optionally color (if
# scalar information is available).
sphere_mapper = tvtk.PolyDataMapper(input=sphere.output)
# The Property will give the parameters of the material.
p = tvtk.Property(opacity=0.2, color=(1, 0, 0))
# The actor is the actually object in the scene.
sphere_actor = tvtk.Actor(mapper=sphere_mapper, property=p)
v.scene.add_actor(sphere_actor)

# Create a second sphere
sphere2 = tvtk.SphereSource(center=(7, 0, 1), radius=0.2)
sphere_mapper2 = tvtk.PolyDataMapper(input=sphere2.output)
p = tvtk.Property(opacity=0.3, color=(1, 0, 0))
sphere_actor2 = tvtk.Actor(mapper=sphere_mapper2, property=p)
v.scene.add_actor(sphere_actor2)

# Create a line between the two spheres
line = tvtk.LineSource(point1=(0, 0, 0), point2=(7, 0, 1))
line_mapper = tvtk.PolyDataMapper(input=line.output)
line_actor = tvtk.Actor(mapper=line_mapper)
v.scene.add_actor(line_actor)

# And display text
vtext = tvtk.VectorText()
vtext.text = 'Mayavi'
text_mapper = tvtk.PolyDataMapper(input=vtext.get_output())
p2 = tvtk.Property(color=(0, 0.3, 0.3))
text_actor = tvtk.Follower(mapper=text_mapper, property=p2)
text_actor.position = (0, 0, 0)
v.scene.add_actor(text_actor)

# Choose a view angle, and display the figure
mlab.view(85, -17, 15, [3.5, -0.3, -0.8])
mlab.show()

########NEW FILE########
__FILENAME__ = tvtk_segmentation
"""
Using VTK to assemble a pipeline for segmenting MRI images. This example
shows how to insert well-controled custom VTK filters in Mayavi.

This example downloads an MRI scan, turns it into a 3D numpy array,
applies a segmentation procedure made of VTK filters to extract the
gray-matter/white-matter boundary.

The segmentation algorithm used here is very naive and should, of course,
not be used as an example of segmentation.

"""

### Download the data, if not already on disk ##################################
import os
if not os.path.exists('mri_data.tar.gz'):
    # Download the data
    import urllib
    print "Downloading data, Please Wait (7.8MB)"
    opener = urllib.urlopen(
                'http://www-graphics.stanford.edu/data/voldata/MRbrain.tar.gz')
    open('mri_data.tar.gz', 'wb').write(opener.read())

# Extract the data
import tarfile
tar_file = tarfile.open('mri_data.tar.gz')
try:
    os.mkdir('mri_data')
except:
    pass
tar_file.extractall('mri_data')
tar_file.close()


### Read the data in a numpy 3D array ##########################################
import numpy as np
data = np.array([np.fromfile(os.path.join('mri_data', 'MRbrain.%i' % i),
                                        dtype='>u2') for i in range(1, 110)])
data.shape = (109, 256, 256)
data = data.T

################################################################################
# Heuristic for finding the threshold for the brain

# Exctract the percentile 20 and 80 (without using
# scipy.stats.scoreatpercentile)
sorted_data = np.sort(data.ravel())
l = len(sorted_data)
lower_thr = sorted_data[0.2*l]
upper_thr = sorted_data[0.8*l]

# The white matter boundary: find the densest part of the upper half
# of histogram, and take a value 10% higher, to cut _in_ the white matter
hist, bins = np.histogram(data[data > np.mean(data)], bins=50)
brain_thr_idx = np.argmax(hist)
brain_thr =  bins[brain_thr_idx + 4]

del hist, bins, brain_thr_idx

# Display the data #############################################################
from mayavi import mlab
from tvtk.api import tvtk

fig = mlab.figure(bgcolor=(0, 0, 0), size=(400, 500))
# to speed things up
fig.scene.disable_render = True

src = mlab.pipeline.scalar_field(data)
# Our data is not equally spaced in all directions:
src.spacing = [1, 1, 1.5]
src.update_image_data = True

#----------------------------------------------------------------------
# Brain extraction pipeline

# In the following, we create a Mayavi pipeline that strongly
# relies on VTK filters. For this, we make heavy use of the
# mlab.pipeline.user_defined function, to include VTK filters in
# the Mayavi pipeline.

# Apply image-based filters to clean up noise
thresh_filter = tvtk.ImageThreshold()
thresh_filter.threshold_between(lower_thr, upper_thr)
thresh = mlab.pipeline.user_defined(src, filter=thresh_filter)

median_filter = tvtk.ImageMedian3D()
median_filter.set_kernel_size(3, 3, 3)
median = mlab.pipeline.user_defined(thresh, filter=median_filter)

diffuse_filter = tvtk.ImageAnisotropicDiffusion3D(
                                    diffusion_factor=1.0,
                                    diffusion_threshold=100.0,
                                    number_of_iterations=5, )

diffuse = mlab.pipeline.user_defined(median, filter=diffuse_filter)

# Extract brain surface
contour = mlab.pipeline.contour(diffuse, )
contour.filter.contours = [brain_thr, ]

# Apply mesh filter to clean up the mesh (decimation and smoothing)
dec = mlab.pipeline.decimate_pro(contour)
dec.filter.feature_angle = 60.
dec.filter.target_reduction = 0.7

smooth_ = tvtk.SmoothPolyDataFilter(
                    number_of_iterations=10,
                    relaxation_factor=0.1,
                    feature_angle=60,
                    feature_edge_smoothing=False,
                    boundary_smoothing=False,
                    convergence=0.,
                )
smooth = mlab.pipeline.user_defined(dec, filter=smooth_)

# Get the largest connected region
connect_ = tvtk.PolyDataConnectivityFilter(extraction_mode=4)
connect = mlab.pipeline.user_defined(smooth, filter=connect_)

# Compute normals for shading the surface
compute_normals = mlab.pipeline.poly_data_normals(connect)
compute_normals.filter.feature_angle = 80

surf = mlab.pipeline.surface(compute_normals,
                                        color=(0.9, 0.72, 0.62))

#----------------------------------------------------------------------
# Display a cut plane of the raw data
ipw = mlab.pipeline.image_plane_widget(src, colormap='bone',
                plane_orientation='z_axes',
                slice_index=55)

mlab.view(-165, 32, 350, [143, 133, 73])
mlab.roll(180)

fig.scene.disable_render = False

#----------------------------------------------------------------------
# To make the link between the Mayavi pipeline and the much more
# complex VTK pipeline, we display both:
mlab.show_pipeline(rich_view=False)
from tvtk.pipeline.browser import PipelineBrowser
browser = PipelineBrowser(fig.scene)
browser.show()

mlab.show()

########NEW FILE########
__FILENAME__ = unstructured_grid
"""A MayaVi example of how to generate an unstructured grid dataset
using numpy arrays.  Also shown is a way to visualize this data with
mayavi2.  The script can be run like so:

  $ mayavi2 -x unstructured_grid.py

Alternatively, it can be run as:

  $ python unstructured_grid.py

Author: Prabhu Ramachandran <prabhu at aero dot iitb dot ac dot in>

Copyright (c) 2007, Enthought, Inc.
License: BSD style.
"""

from numpy import array, arange, random
from tvtk.api import tvtk
from mayavi.scripts import mayavi2

def single_type_ug():
    """Simple example showing how to create an unstructured grid
    consisting of cells of a single type.
    """
    points = array([[0,0,0], [1,0,0], [0,1,0], [0,0,1], # tets
                    [1,0,0], [2,0,0], [1,1,0], [1,0,1],
                    [2,0,0], [3,0,0], [2,1,0], [2,0,1],
                    ], 'f')
    tets = array([[0, 1, 2, 3], [4, 5, 6, 7], [8, 9, 10, 11]])
    tet_type = tvtk.Tetra().cell_type
    ug = tvtk.UnstructuredGrid(points=points)
    ug.set_cells(tet_type, tets)
    return ug

def mixed_type_ug():
    """A slightly more complex example of how to generate an
    unstructured grid with different cell types.  Returns a created
    unstructured grid.
    """
    points = array([[0,0,0], [1,0,0], [0,1,0], [0,0,1], # tetra
                    [2,0,0], [3,0,0], [3,1,0], [2,1,0],
                    [2,0,1], [3,0,1], [3,1,1], [2,1,1], # Hex
                    ], 'f')
    # shift the points so we can show both.
    points[:,1] += 2.0
    # The cells
    cells = array([4, 0, 1, 2, 3, # tetra
                   8, 4, 5, 6, 7, 8, 9, 10, 11 # hex
                   ])
    # The offsets for the cells, i.e. the indices where the cells
    # start.
    offset = array([0, 5])
    tetra_type = tvtk.Tetra().cell_type # VTK_TETRA == 10
    hex_type = tvtk.Hexahedron().cell_type # VTK_HEXAHEDRON == 12
    cell_types = array([tetra_type, hex_type])
    # Create the array of cells unambiguously.
    cell_array = tvtk.CellArray()
    cell_array.set_cells(2, cells)
    # Now create the UG.
    ug = tvtk.UnstructuredGrid(points=points)
    # Now just set the cell types and reuse the ug locations and cells.
    ug.set_cells(cell_types, offset, cell_array)
    return ug

def save_xml(ug, file_name):
    """Shows how you can save the unstructured grid dataset to a VTK
    XML file."""
    w = tvtk.XMLUnstructuredGridWriter(input=ug, file_name=file_name)
    w.write()

# ----------------------------------------------------------------------
# Create the unstructured grids and assign scalars and vectors.
ug1 = single_type_ug()
ug2 = mixed_type_ug()
temperature = arange(0, 120, 10, 'd')
velocity = random.randn(12, 3)
for ug in ug1, ug2:
    ug.point_data.scalars = temperature
    ug.point_data.scalars.name = 'temperature'
    # Some vectors.
    ug.point_data.vectors = velocity
    ug.point_data.vectors.name = 'velocity'

# Uncomment this to save the file to a VTK XML file.
#save_xml(ug2, 'file.vtu')

# Now view the data.
@mayavi2.standalone
def view():
    from mayavi.sources.vtk_data_source import VTKDataSource
    from mayavi.modules.outline import Outline
    from mayavi.modules.surface import Surface
    from mayavi.modules.vectors import Vectors

    mayavi.new_scene()
    # The single type one
    src = VTKDataSource(data = ug1)
    mayavi.add_source(src)
    mayavi.add_module(Outline())
    mayavi.add_module(Surface())
    mayavi.add_module(Vectors())

    # Mixed types.
    src = VTKDataSource(data = ug2)
    mayavi.add_source(src)
    mayavi.add_module(Outline())
    mayavi.add_module(Surface())
    mayavi.add_module(Vectors())

if __name__ == '__main__':
    view()

########NEW FILE########
__FILENAME__ = user_mayavi
"""
Sample Mayavi customization file.

This code is not to be executed as `mayavi2 -x user_mayavi.py` or
`python user_mayavi.py`.

Put this file in ~/.mayavi2/user_mayavi.py and rerun mayavi2 to see what
it does -- the worker view may not show up by default so you will have
to go to View->Other and in the Show View dialog, activate the "Custom
Mayavi2 View".

The added modules should show up in the menus (Look for UserOutline in
the Modules)

____

This module demonstrates how to extend Mayavi.  It extends the  modules
provided by mayavi by adding these to the Mayavi registry.  Note that
the registry imports customize which in turn imports this file.

It also defines an Envisage plugin that is added to the default list of
plugins to extend the running mayavi application.  This plugin is
returned by the `get_plugins()` function.

This file must be placed inside the `~/.mayavi2` directory and called
`user_mayavi.py`.  Please note that `~/.mayavi2` is placed in `sys.path`
(if the directory exists) so make sure that you choose your module names
carefully (so as not to override any common module names).

The file may also be placed anywhere on sys.path and called
`site_mayavi.py` for global system level customizations.

"""
# Author: Prabhu Ramachandran <prabhu@aero.iitb.ac.in>
# Copyright (c) 2006-2008, Enthought, Inc.
# License: BSD Style.

from mayavi.core.registry import registry
from mayavi.core.pipeline_info import PipelineInfo
from mayavi.core.metadata import ModuleMetadata

# Metadata for the new module we want to add -- notice that we use a
# factory function here for convenience, we could also use a class but
# the reasons for doing this are documented below.
user_outline = ModuleMetadata(
    id            = "UserOutlineModule",
    menu_name          = "&UserOutline",
    factory = 'user_mayavi.user_outline',
    desc   = "Draw a cornered outline for given input",
    tooltip       = "Draw a cornered outline for given input",
    help       = "Draw a cornered outline for given input",
    input_info = PipelineInfo(datasets=['any'],
                              attribute_types=['any'],
                              attributes=['any'])
)

# Register the module with the mayavi registry.
registry.modules.append(user_outline)

#######
# The all important function that returns the plugin we wish to add to
# the default mayavi application.
def get_plugins():
    # We simply return a list containing the WorkerPlugin defined below.
    return [WorkerPlugin()]

######################################################################
# Thats it, basically.  The rest of the code should really be in another
# module but is in the same module for convenience here.  There are
# problems with doing any significant non-core module imports in this
# module as documented below.
######################################################################


######################################################################
# THE CODE BELOW SHOULD REALLY BE IN SEPARATE MODULES.
#
# The following can very well be in a separate module but I've kept it
# here to make this a compact demo of how to customize things.
######################################################################


######################################################################
# A new module to expose to mayavi.
#
# WARNING: Do not do other mayavi imports right here like for example:
# 'from mayavi.modules.outline import Outline' etc.  This is
# because the user_mayavi is imported at a time when many of the imports
# are not complete and this will cause hard-to-debug circular import
# problems.  The registry is given only metadata mostly in the form of
# strings and this will cause no problem.  Therefore to define new
# modules, we strongly recommend that the modules be defined in another
# module or be defined in a factory function as done below.

def user_outline():
    """A Factory function that creates a new module to add to the
    pipeline.  Note that the method safely does any mayavi imports
    inside avoiding any circular imports.
    """
    print "User Outline"
    from mayavi.modules.outline import Outline
    o = Outline(outline_mode='cornered', name='UserOutline')
    return o


######################################################################
# This code simulates something the user would like to do.  In this case
# we just want to create some data, view it with mayavi and modify the
# data.  We want to add this as a view to the standard mayavi.  The code
# below is simply traits code with a few extra things to be able to grab
# the running mayavi instance and script it.  The object we create we
# offer as an envisage service offer -- this instantiates the worker.
# The WorkerPlugin exposes the service offer and shows the view of this
# worker.

import numpy

from traits.api import HasTraits, Range, Button, Instance, List
from traitsui.api import Item, View

######################################################################
# `Worker` class
######################################################################
class Worker(HasTraits):
    """This class basically allows you to create a data set, view it
    and modify the dataset.  This is a rather crude example but
    demonstrates how things can be done.
    """

    # Set by envisage when this is contributed as a ServiceOffer.
    window = Instance('pyface.workbench.api.WorkbenchWindow')

    create_data = Button('Create data')
    reset_data = Button('Reset data')
    view_data = Button('View data')
    scale = Range(0.0, 1.0)
    source = Instance('mayavi.core.source.Source')

    # Our UI view.
    view = View(Item('create_data', show_label=False),
                Item('view_data', show_label=False),
                Item('reset_data', show_label=False),
                Item('scale'),
                resizable=True
                )

    def get_mayavi(self):
        from mayavi.plugins.script import Script
        return self.window.get_service(Script)

    def _make_data(self):
        dims = [64, 64, 64]
        np = dims[0]*dims[1]*dims[2]
        x, y, z = numpy.ogrid[-5:5:dims[0]*1j,-5:5:dims[1]*1j,-5:5:dims[2]*1j]
        x = x.astype('f')
        y = y.astype('f')
        z = z.astype('f')
        s = (numpy.sin(x*y*z)/(x*y*z))
        s = s.transpose().copy() # This makes the data contiguous.
        return s

    def _create_data_fired(self):
        mayavi = self.get_mayavi()
        from mayavi.sources.array_source import ArraySource
        s = self._make_data()
        src = ArraySource(transpose_input_array=False, scalar_data=s)
        self.source = src
        mayavi.add_source(src)

    def _reset_data_fired(self):
        self.source.scalar_data = self._make_data()

    def _view_data_fired(self):
        mayavi = self.get_mayavi()
        from mayavi.modules.outline import Outline
        from mayavi.modules.image_plane_widget import ImagePlaneWidget
        # Visualize the data.
        o = Outline()
        mayavi.add_module(o)
        ipw = ImagePlaneWidget()
        mayavi.add_module(ipw)
        ipw.module_manager.scalar_lut_manager.show_scalar_bar = True

        ipw_y = ImagePlaneWidget()
        mayavi.add_module(ipw_y)
        ipw_y.ipw.plane_orientation = 'y_axes'

    def _scale_changed(self, value):
        src = self.source
        data = src.scalar_data
        data += value*0.01
        numpy.mod(data, 1.0, data)
        src.update()

######################################################################
# The following code is the small amount of envisage code that brings
# the users code (above) and Envisage/Mayavi UI together.
from envisage.api import Plugin, ServiceOffer

######################################################################
# `WorkerPlugin` class
######################################################################
class WorkerPlugin(Plugin):

    # Extension point Ids.
    SERVICE_OFFERS = 'envisage.ui.workbench.service_offers'
    VIEWS          = 'envisage.ui.workbench.views'

    # Services we contribute.
    service_offers = List(contributes_to=SERVICE_OFFERS)
    # Views.
    views = List(contributes_to=VIEWS)

    ######################################################################
    # Private methods.
    def _service_offers_default(self):
        """ Trait initializer. """
        worker_service_offer = ServiceOffer(
            protocol = 'user_mayavi.Worker',
            factory  = 'user_mayavi.Worker'
        )
        return [worker_service_offer]

    def _views_default(self):
        """ Trait initializer. """
        return [self._worker_view_factory]

    def _worker_view_factory(self, window, **traits):
        """ Factory method for the current selection of the engine. """

        from pyface.workbench.traits_ui_view import \
                TraitsUIView

        worker = window.get_service(Worker)
        tui_worker_view = TraitsUIView(obj=worker,
                                       view='view',
                                       id='user_mayavi.Worker.view',
                                       name='Custom Mayavi2 View',
                                       window=window,
                                       position='left',
                                       **traits
                                       )
        return tui_worker_view

# END OF CODE THAT SHOULD REALLY BE IN SEPARATE MODULES.
######################################################################

if __name__ == '__main__':
    import sys
    print "*"*80
    print "ERROR: This script isn't supposed to be executed."
    print __doc__
    print "*"*80

    from traits.util.home_directory import get_home_directory
    print "Your .mayavi2 directory should be in %s"%get_home_directory()
    print "*"*80
    sys.exit(1)

########NEW FILE########
__FILENAME__ = volume_slicer
"""
Example of an elaborate dialog showing a multiple views on the same data, with
3 cuts synchronized.

This example shows how to have multiple views on the same data, how to
embedded multiple scenes in a dialog, and the caveat in populating them
with data, as well as how to add some interaction logic on an
ImagePlaneWidget.

The order in which things happen in this example is important, and it is
easy to get it wrong. First of all, many properties of the visualization
objects cannot be changed if there is not a scene created to view them.
This is why we put a lot of the visualization logic in the callback of
scene.activated, which is called after creation of the scene.
Second, default values created via the '_xxx_default' callback are created
lazyly, that is, when the attributes are accessed. As the establishement
of the VTK pipeline can depend on the order in which it is built, we
trigger these access by explicitely calling the attributes.
In particular, properties like scene background color, or interaction
properties cannot be set before the scene is activated.

The same data is exposed in the different scenes by sharing the VTK
dataset between different Mayavi data sources. See
the :ref:`sharing_data_between_scenes` tip for more details.

In this example, the interaction with the scene and the various elements
on it is strongly simplified by turning off interaction, and choosing
specific scene interactor styles. Indeed, non-technical users can be
confused with too rich interaction.
"""
# Author: Gael Varoquaux <gael.varoquaux@normalesup.org>
# Copyright (c) 2009, Enthought, Inc.
# License: BSD Style.

import numpy as np

from traits.api import HasTraits, Instance, Array, \
    on_trait_change
from traitsui.api import View, Item, HGroup, Group

from tvtk.api import tvtk
from tvtk.pyface.scene import Scene

from mayavi import mlab
from mayavi.core.api import PipelineBase, Source
from mayavi.core.ui.api import SceneEditor, MayaviScene, \
                                MlabSceneModel

################################################################################
# Create some data
x, y, z = np.ogrid[-5:5:64j, -5:5:64j, -5:5:64j]
data = np.sin(3*x)/x + 0.05*z**2 + np.cos(3*y)

################################################################################
# The object implementing the dialog
class VolumeSlicer(HasTraits):
    # The data to plot
    data = Array()

    # The 4 views displayed
    scene3d = Instance(MlabSceneModel, ())
    scene_x = Instance(MlabSceneModel, ())
    scene_y = Instance(MlabSceneModel, ())
    scene_z = Instance(MlabSceneModel, ())

    # The data source
    data_src3d = Instance(Source)

    # The image plane widgets of the 3D scene
    ipw_3d_x = Instance(PipelineBase)
    ipw_3d_y = Instance(PipelineBase)
    ipw_3d_z = Instance(PipelineBase)

    _axis_names = dict(x=0, y=1, z=2)


    #---------------------------------------------------------------------------
    def __init__(self, **traits):
        super(VolumeSlicer, self).__init__(**traits)
        # Force the creation of the image_plane_widgets:
        self.ipw_3d_x
        self.ipw_3d_y
        self.ipw_3d_z


    #---------------------------------------------------------------------------
    # Default values
    #---------------------------------------------------------------------------
    def _data_src3d_default(self):
        return mlab.pipeline.scalar_field(self.data,
                            figure=self.scene3d.mayavi_scene)

    def make_ipw_3d(self, axis_name):
        ipw = mlab.pipeline.image_plane_widget(self.data_src3d,
                        figure=self.scene3d.mayavi_scene,
                        plane_orientation='%s_axes' % axis_name)
        return ipw

    def _ipw_3d_x_default(self):
        return self.make_ipw_3d('x')

    def _ipw_3d_y_default(self):
        return self.make_ipw_3d('y')

    def _ipw_3d_z_default(self):
        return self.make_ipw_3d('z')


    #---------------------------------------------------------------------------
    # Scene activation callbaks
    #---------------------------------------------------------------------------
    @on_trait_change('scene3d.activated')
    def display_scene3d(self):
        outline = mlab.pipeline.outline(self.data_src3d,
                        figure=self.scene3d.mayavi_scene,
                        )
        self.scene3d.mlab.view(40, 50)
        # Interaction properties can only be changed after the scene
        # has been created, and thus the interactor exists
        for ipw in (self.ipw_3d_x, self.ipw_3d_y, self.ipw_3d_z):
            # Turn the interaction off
            ipw.ipw.interaction = 0
        self.scene3d.scene.background = (0, 0, 0)
        # Keep the view always pointing up
        self.scene3d.scene.interactor.interactor_style = \
                                 tvtk.InteractorStyleTerrain()


    def make_side_view(self, axis_name):
        scene = getattr(self, 'scene_%s' % axis_name)

        # To avoid copying the data, we take a reference to the
        # raw VTK dataset, and pass it on to mlab. Mlab will create
        # a Mayavi source from the VTK without copying it.
        # We have to specify the figure so that the data gets
        # added on the figure we are interested in.
        outline = mlab.pipeline.outline(
                            self.data_src3d.mlab_source.dataset,
                            figure=scene.mayavi_scene,
                            )
        ipw = mlab.pipeline.image_plane_widget(
                            outline,
                            plane_orientation='%s_axes' % axis_name)
        setattr(self, 'ipw_%s' % axis_name, ipw)

        # Synchronize positions between the corresponding image plane
        # widgets on different views.
        ipw.ipw.sync_trait('slice_position',
                            getattr(self, 'ipw_3d_%s'% axis_name).ipw)

        # Make left-clicking create a crosshair
        ipw.ipw.left_button_action = 0
        # Add a callback on the image plane widget interaction to
        # move the others
        def move_view(obj, evt):
            position = obj.GetCurrentCursorPosition()
            for other_axis, axis_number in self._axis_names.iteritems():
                if other_axis == axis_name:
                    continue
                ipw3d = getattr(self, 'ipw_3d_%s' % other_axis)
                ipw3d.ipw.slice_position = position[axis_number]

        ipw.ipw.add_observer('InteractionEvent', move_view)
        ipw.ipw.add_observer('StartInteractionEvent', move_view)

        # Center the image plane widget
        ipw.ipw.slice_position = 0.5*self.data.shape[
                    self._axis_names[axis_name]]

        # Position the view for the scene
        views = dict(x=( 0, 90),
                     y=(90, 90),
                     z=( 0,  0),
                     )
        scene.mlab.view(*views[axis_name])
        # 2D interaction: only pan and zoom
        scene.scene.interactor.interactor_style = \
                                 tvtk.InteractorStyleImage()
        scene.scene.background = (0, 0, 0)


    @on_trait_change('scene_x.activated')
    def display_scene_x(self):
        return self.make_side_view('x')

    @on_trait_change('scene_y.activated')
    def display_scene_y(self):
        return self.make_side_view('y')

    @on_trait_change('scene_z.activated')
    def display_scene_z(self):
        return self.make_side_view('z')


    #---------------------------------------------------------------------------
    # The layout of the dialog created
    #---------------------------------------------------------------------------
    view = View(HGroup(
                  Group(
                       Item('scene_y',
                            editor=SceneEditor(scene_class=Scene),
                            height=250, width=300),
                       Item('scene_z',
                            editor=SceneEditor(scene_class=Scene),
                            height=250, width=300),
                       show_labels=False,
                  ),
                  Group(
                       Item('scene_x',
                            editor=SceneEditor(scene_class=Scene),
                            height=250, width=300),
                       Item('scene3d',
                            editor=SceneEditor(scene_class=MayaviScene),
                            height=250, width=300),
                       show_labels=False,
                  ),
                ),
                resizable=True,
                title='Volume Slicer',
                )


m = VolumeSlicer(data=data)
m.configure_traits()

########NEW FILE########
__FILENAME__ = volume_slicer_advanced
"""
An efficient implementation of the triple-plane view showing 3 cut planes
on volumetric data, and side views showing each cut, with a cursor to
move the other cuts.

This is an example of complex callback interaction. It builds on the
:ref:`example_volume_slicer` but has more complex logic. You should try
to understand the :ref:`example_volume_slicer` first.

In this example, the VolumeSlicer object displays a position attribute
giving the position of the cut in data coordinates. Traits callbacks are
used to move the cut planes when this position attribute is modifed.

In the 3D window, the 3D cuts are displayed using ImagePlaneWidgets
cutting the 3D volumetric data. The data extracted by the
ImagePlaneWidgets for plotting is captured using the TVTK
ImagePlaneWidget's `_get_reslice_output` method. The resulting dataset is
plotted in each side view using another ImagePlaneWidget. As a result the
data is not copied (at the VTK level, there is only one pipeline), and
modifications of the data plotted on the planes in the 3D view (for
instance when these planes are moved) are propagated to the 2D side views
by the VTK pipeline.

A cursor is displayed in each side view using a glyph. The cursor
indicates the position of the cut.

In the side view, when the mouse button is pressed on the planes, it
creates a VTK `InteractionEvent`. When this happens, VTK calls an
callback (observer, it VTK terms), that we use to move the position of
the cut. The Traits callbacks do the rest for the updating.
"""
import numpy as np

from traits.api import HasTraits, Instance, Array, \
    Bool, Dict, on_trait_change
from traitsui.api import View, Item, HGroup, Group

from tvtk.api import tvtk
from tvtk.pyface.scene import Scene

from mayavi import mlab
from mayavi.core.api import PipelineBase, Source
from mayavi.core.ui.api import SceneEditor, MlabSceneModel


################################################################################
# The object implementing the dialog
class VolumeSlicer(HasTraits):
    # The data to plot
    data = Array

    # The position of the view
    position = Array(shape=(3,))

    # The 4 views displayed
    scene3d = Instance(MlabSceneModel, ())
    scene_x = Instance(MlabSceneModel, ())
    scene_y = Instance(MlabSceneModel, ())
    scene_z = Instance(MlabSceneModel, ())

    # The data source
    data_src = Instance(Source)

    # The image plane widgets of the 3D scene
    ipw_3d_x = Instance(PipelineBase)
    ipw_3d_y = Instance(PipelineBase)
    ipw_3d_z = Instance(PipelineBase)

    # The cursors on each view:
    cursors = Dict()

    disable_render = Bool

    _axis_names = dict(x=0, y=1, z=2)

    #---------------------------------------------------------------------------
    # Object interface
    #---------------------------------------------------------------------------
    def __init__(self, **traits):
        super(VolumeSlicer, self).__init__(**traits)
        # Force the creation of the image_plane_widgets:
        self.ipw_3d_x
        self.ipw_3d_y
        self.ipw_3d_z


    #---------------------------------------------------------------------------
    # Default values
    #---------------------------------------------------------------------------
    def _position_default(self):
        return 0.5*np.array(self.data.shape)

    def _data_src_default(self):
        return mlab.pipeline.scalar_field(self.data,
                            figure=self.scene3d.mayavi_scene,
                            name='Data',)

    def make_ipw_3d(self, axis_name):
        ipw = mlab.pipeline.image_plane_widget(self.data_src,
                        figure=self.scene3d.mayavi_scene,
                        plane_orientation='%s_axes' % axis_name,
                        name='Cut %s' % axis_name)
        return ipw

    def _ipw_3d_x_default(self):
        return self.make_ipw_3d('x')

    def _ipw_3d_y_default(self):
        return self.make_ipw_3d('y')

    def _ipw_3d_z_default(self):
        return self.make_ipw_3d('z')


    #---------------------------------------------------------------------------
    # Scene activation callbacks
    #---------------------------------------------------------------------------
    @on_trait_change('scene3d.activated')
    def display_scene3d(self):
        outline = mlab.pipeline.outline(self.data_src,
                        figure=self.scene3d.mayavi_scene,
                        )
        self.scene3d.mlab.view(40, 50)
        # Interaction properties can only be changed after the scene
        # has been created, and thus the interactor exists
        for ipw in (self.ipw_3d_x, self.ipw_3d_y, self.ipw_3d_z):
            ipw.ipw.interaction = 0
        self.scene3d.scene.background = (0, 0, 0)
        # Keep the view always pointing up
        self.scene3d.scene.interactor.interactor_style = \
                                 tvtk.InteractorStyleTerrain()
        self.update_position()


    def make_side_view(self, axis_name):
        scene = getattr(self, 'scene_%s' % axis_name)
        scene.scene.parallel_projection = True
        ipw_3d   = getattr(self, 'ipw_3d_%s' % axis_name)

        # We create the image_plane_widgets in the side view using a
        # VTK dataset pointing to the data on the corresponding
        # image_plane_widget in the 3D view (it is returned by
        # ipw_3d._get_reslice_output())
        side_src = ipw_3d.ipw._get_reslice_output()
        ipw = mlab.pipeline.image_plane_widget(
                            side_src,
                            plane_orientation='z_axes',
                            vmin=self.data.min(),
                            vmax=self.data.max(),
                            figure=scene.mayavi_scene,
                            name='Cut view %s' % axis_name,
                            )
        setattr(self, 'ipw_%s' % axis_name, ipw)

        # Extract the spacing of the side_src to convert coordinates
        # into indices
        spacing = side_src.spacing

        # Make left-clicking create a crosshair
        ipw.ipw.left_button_action = 0

        x, y, z = self.position
        cursor = mlab.points3d(x, y, z,
                            mode='axes',
                            color=(0, 0, 0),
                            scale_factor=2*max(self.data.shape),
                            figure=scene.mayavi_scene,
                            name='Cursor view %s' % axis_name,
                        )
        self.cursors[axis_name] = cursor

        # Add a callback on the image plane widget interaction to
        # move the others
        this_axis_number = self._axis_names[axis_name]
        def move_view(obj, evt):
            # Disable rendering on all scene
            position = list(obj.GetCurrentCursorPosition()*spacing)[:2]
            position.insert(this_axis_number, self.position[this_axis_number])
            # We need to special case y, as the view has been rotated.
            if axis_name is 'y':
                position = position[::-1]
            self.position = position

        ipw.ipw.add_observer('InteractionEvent', move_view)
        ipw.ipw.add_observer('StartInteractionEvent', move_view)

        # Center the image plane widget
        ipw.ipw.slice_position = 0.5*self.data.shape[
                                        self._axis_names[axis_name]]

        # 2D interaction: only pan and zoom
        scene.scene.interactor.interactor_style = \
                                 tvtk.InteractorStyleImage()
        scene.scene.background = (0, 0, 0)

        # Some text:
        mlab.text(0.01, 0.8, axis_name, width=0.08)

        # Choose a view that makes sens
        views = dict(x=(0, 0), y=(90, 180), z=(0, 0))
        mlab.view(views[axis_name][0],
                  views[axis_name][1],
                  focalpoint=0.5*np.array(self.data.shape),
                  figure=scene.mayavi_scene)
        scene.scene.camera.parallel_scale = 0.52*np.mean(self.data.shape)

    @on_trait_change('scene_x.activated')
    def display_scene_x(self):
        return self.make_side_view('x')

    @on_trait_change('scene_y.activated')
    def display_scene_y(self):
        return self.make_side_view('y')

    @on_trait_change('scene_z.activated')
    def display_scene_z(self):
        return self.make_side_view('z')


    #---------------------------------------------------------------------------
    # Traits callback
    #---------------------------------------------------------------------------
    @on_trait_change('position')
    def update_position(self):
        """ Update the position of the cursors on each side view, as well
            as the image_plane_widgets in the 3D view.
        """
        # First disable rendering in all scenes to avoid unecessary
        # renderings
        self.disable_render = True

        # For each axis, move image_plane_widget and the cursor in the
        # side view
        for axis_name, axis_number in self._axis_names.iteritems():
            ipw3d = getattr(self, 'ipw_3d_%s' % axis_name)
            ipw3d.ipw.slice_position = self.position[axis_number]

            # Go from the 3D position, to the 2D coordinates in the
            # side view
            position2d = list(self.position)
            position2d.pop(axis_number)
            if axis_name is 'y':
                position2d = position2d[::-1]
            # Move the cursor
            # For the following to work, you need Mayavi 3.4.0, if you
            # have a less recent version, use 'x=[position2d[0]]'
            self.cursors[axis_name].mlab_source.set(
                                                x=position2d[0],
                                                y=position2d[1],
                                                z=0)

        # Finally re-enable rendering
        self.disable_render = False

    @on_trait_change('disable_render')
    def _render_enable(self):
        for scene in (self.scene3d, self.scene_x, self.scene_y,
                                                  self.scene_z):
            scene.scene.disable_render = self.disable_render


    #---------------------------------------------------------------------------
    # The layout of the dialog created
    #---------------------------------------------------------------------------
    view = View(HGroup(
                  Group(
                       Item('scene_y',
                            editor=SceneEditor(scene_class=Scene),
                            height=250, width=300),
                       Item('scene_z',
                            editor=SceneEditor(scene_class=Scene),
                            height=250, width=300),
                       show_labels=False,
                  ),
                  Group(
                       Item('scene_x',
                            editor=SceneEditor(scene_class=Scene),
                            height=250, width=300),
                       Item('scene3d',
                            editor=SceneEditor(scene_class=Scene),
                            height=250, width=300),
                       show_labels=False,
                  ),
                ),
                resizable=True,
                title='Volume Slicer',
                )


################################################################################
if __name__ == '__main__':
    # Create some data
    x, y, z = np.ogrid[-5:5:100j, -5:5:100j, -5:5:100j]
    data = np.sin(3*x)/x + 0.05*z**2 + np.cos(3*y)

    m = VolumeSlicer(data=data)
    m.configure_traits()

########NEW FILE########
__FILENAME__ = wigner
"""
An example in which 3 functions of x and y  are displayed with a surf plot,
while the z scaling is kept constant, to allow comparison between them.

The important aspect of this example is that the 3 functions should not
be displayed on top of each other, but side by side. For this we use the
extent keyword argument.

In addition, the relative scale between the different plots is important.
This is why we also use the `warp_scale` keyword argument, to have the same
scale on all plots.

Finally, we have to adjust the data bounds: as we want the "horizon" of
the wigner function in the middle of our extents, we put this to zero.

We add a set of axes and outlines to the plot. We have to play we extents
and ranges in order to make them fit with the data.
"""
# Author: Gael Varoquaux <gael.varoquaux@normalesup.org>
# Copyright (c) 2007, Enthought, Inc.
# License: BSD Style.


import numpy
from mayavi import mlab


def cat(x, y, alpha, eta=1, purity=1):
    """ Multiphoton shrodinger cat. eta is the fidelity, alpha the number
        of photons"""
    cos = numpy.cos
    exp = numpy.exp
    return (1 + eta * (exp(-x ** 2 - (y - alpha) ** 2) + exp(-x ** 2 -
    (y + alpha) ** 2) + 2 * purity * exp(-x ** 2 - y ** 2) * cos(2 * \
    alpha * x)) / (2 * (1 + exp(- alpha ** 2)))) / 2

x, y = numpy.mgrid[-4:4.15:0.1, -4:4.15:0.1]

mlab.figure(1, size=(500, 250), fgcolor=(1, 1, 1),
                                    bgcolor=(0.5, 0.5, 0.5))
mlab.clf()

cat1 = cat(x, y, 1)
cat2 = cat(x, y, 2)
cat3 = cat(x, y, 3)

# The cats lie in a [0, 1] interval, with .5 being the assymptotique
# value. We want to reposition this value to 0, so as to put it in the
# center of our extents.
cat1 -= 0.5
cat2 -= 0.5
cat3 -= 0.5

cat1_extent = (-14, -6, -4, 4, 0, 5)
surf_cat1 = mlab.surf(x - 10, y, cat1, colormap='Spectral', warp_scale=5,
            extent=cat1_extent, vmin=-0.5, vmax=0.5)
mlab.outline(surf_cat1, color=(.7, .7, .7), extent=cat1_extent)
mlab.axes(surf_cat1, color=(.7, .7, .7), extent=cat1_extent,
            ranges=(0, 1, 0, 1, 0, 1), xlabel='', ylabel='',
            zlabel='Probability',
            x_axis_visibility=False, z_axis_visibility=False)

mlab.text(-18, -4, '1 photon', z=-4, width=0.13)

cat2_extent = (-4, 4, -4, 4, 0, 5)
surf_cat2 = mlab.surf(x, y, cat2, colormap='Spectral', warp_scale=5,
            extent=cat2_extent, vmin=-0.5, vmax=0.5)
mlab.outline(surf_cat2, color=(0.7, .7, .7), extent=cat2_extent)

mlab.text(-4, -3, '2 photons', z=-4, width=0.14)

cat3_extent = (6, 14, -4, 4, 0, 5)
surf_cat3 = mlab.surf(x + 10, y, cat3, colormap='Spectral', warp_scale=5,
            extent=cat3_extent, vmin=-0.5, vmax=0.5)
mlab.outline(surf_cat3, color=(.7, .7, .7), extent=cat3_extent)

mlab.text(6, -2.5, '3 photons', z=-4, width=0.14)

mlab.title('Multi-photons cats Wigner function')

mlab.view(142, -72, 32)

mlab.show()

########NEW FILE########
__FILENAME__ = wx_embedding
"""
This example shows to embed a Mayavi view in a wx frame.

The trick is to create a `HasTraits` object, as in the
mlab_traits_ui.py, mayavi_traits_ui.py, or the modifying_mlab_source.py
examples (:ref:`example_mlab_traits_ui`, :ref:`example_mayavi_traits_ui`,
:ref:`example_mlab_interactive_dialog`).

Calling the `edit_traits` method returns a `ui` object whose
`control` attribute is the wx widget. It can thus be embedded in a
standard wx application.

In this example, the wx part is very simple. See
:ref:`example_wx_mayavi_embed_in_notebook` for an example of more complex
embedding of Mayavi scenes in Wx applications.
"""

from numpy import ogrid, sin

from traits.api import HasTraits, Instance
from traitsui.api import View, Item

from mayavi.sources.api import ArraySource
from mayavi.modules.api import IsoSurface

from mayavi.core.ui.api import SceneEditor, MlabSceneModel


class MayaviView(HasTraits):

    scene = Instance(MlabSceneModel, ())

    # The layout of the panel created by Traits
    view = View(Item('scene', editor=SceneEditor(), resizable=True,
                    show_label=False),
                    resizable=True)

    def __init__(self):
        HasTraits.__init__(self)
        # Create some data, and plot it using the embedded scene's engine
        x, y, z = ogrid[-10:10:100j, -10:10:100j, -10:10:100j]
        scalars = sin(x*y*z)/(x*y*z)
        src = ArraySource(scalar_data=scalars)
        self.scene.engine.add_source(src)
        src.add_module(IsoSurface())

#-----------------------------------------------------------------------------
# Wx Code
import wx

class MainWindow(wx.Frame):

    def __init__(self, parent, id):
        wx.Frame.__init__(self, parent, id, 'Mayavi in Wx')
        self.mayavi_view = MayaviView()
        # Use traits to create a panel, and use it as the content of this
        # wx frame.
        self.control = self.mayavi_view.edit_traits(
                        parent=self,
                        kind='subpanel').control
        self.Show(True)

app = wx.PySimpleApp()
frame = MainWindow(None, wx.ID_ANY)
app.MainLoop()


########NEW FILE########
__FILENAME__ = wx_mayavi_embed_in_notebook
"""
This example show how to embedded Mayavi in a wx notebook.

This is a slightly more complex example than the `wx_embedding` example (
:ref:`example_wx_embedding`), and can be used to see how a large wx
application can use different Mayavi views.

In this example, we embed one single Mayavi scene in a Wx notebook, with
2 tabs, each one of them hosting a different view of the scene.
"""

# First thing, we need to make sure that we are importing a
# recent-enough version of wx
import wxversion
wxversion.ensureMinimal('2.8')

from numpy import ogrid, sin

from traits.api import HasTraits, Instance
from traitsui.api import View, Item

from mayavi.sources.api import ArraySource
from mayavi.modules.api import IsoSurface

from mayavi.core.ui.api import MlabSceneModel, SceneEditor

#-------------------------------------------------------------------------------
class MayaviView(HasTraits):

    scene = Instance(MlabSceneModel, ())

    # The layout of the panel created by traits.
    view = View(Item('scene', editor=SceneEditor(),
                    resizable=True,
                    show_label=False),
                resizable=True)

    def __init__(self):
        HasTraits.__init__(self)
        x, y, z = ogrid[-10:10:100j, -10:10:100j, -10:10:100j]
        scalars = sin(x*y*z)/(x*y*z)
        src = ArraySource(scalar_data=scalars)
        self.scene.mayavi_scene.add_child(src)
        src.add_module(IsoSurface())


#-------------------------------------------------------------------------------
# Wx Code
import wx

class MainWindow(wx.Frame):

    def __init__(self, parent, id):
        wx.Frame.__init__(self, parent, id, 'Mayavi in a Wx notebook')
        self.notebook = wx.aui.AuiNotebook(self, id=-1,
                style=wx.aui.AUI_NB_TAB_SPLIT | wx.aui.AUI_NB_CLOSE_ON_ALL_TABS
                        | wx.aui.AUI_NB_LEFT)

        self.mayavi_view = MayaviView()

        # The edit_traits method opens a first view of our 'MayaviView'
        # object
        self.control = self.mayavi_view.edit_traits(
                        parent=self,
                        kind='subpanel').control
        self.notebook.AddPage(page=self.control, caption='Display 1')

        self.mayavi_view2 = MayaviView()

        # The second call to edit_traits opens a second view
        self.control2 = self.mayavi_view2.edit_traits(
                        parent=self,
                        kind='subpanel').control
        self.notebook.AddPage(page=self.control2, caption='Display 2')

        sizer = wx.BoxSizer()
        sizer.Add(self.notebook,1, wx.EXPAND)
        self.SetSizer(sizer)

        self.Show(True)

if __name__ == '__main__':
    app = wx.PySimpleApp()
    frame = MainWindow(None, wx.ID_ANY)
    app.MainLoop()

########NEW FILE########
__FILENAME__ = zzz_reader
"""This is a simple example that shows how to create a reader factory
and register that reader with mayavi.

To use this:

    - put this in ~/.mayavi2/
    - then import this module in your ~/.mayavi2/user_mayavi.py.

that's it.

What you should get:

    - Options to open .zzz files from the file->open menu.
    - Open .zzz files via right click.
    - Open .zzz files from the engine or mlab (via open)
    - do mayavi2 -d foo.zzz.

"""

from mayavi.core.api import registry, SourceMetadata, PipelineInfo

def zzz_reader(fname, engine):
    """Reader for .zzz files.

    Parameters:
    -----------

    fname -- Filename to be read.

    engine -- The engine the source will be associated with.
    """
    from tvtk.api import tvtk
    from mayavi.sources.vtk_data_source import VTKDataSource
    # Do your own reader stuff here, I'm just reading a VTK file with a
    # different extension here.
    r = tvtk.StructuredPointsReader(file_name=fname)
    r.update()

    src = VTKDataSource(data=r.output)
    return src

zzz_reader_info = SourceMetadata(
    id            = "ZZZReader",
    factory = 'zzz_reader.zzz_reader',
    tooltip       = "Load a ZZZ file",
    desc   = "Load a ZZZ file",
    help   = "Load a ZZZ file",
    menu_name        = "&ZZZ file",
    extensions = ['zzz'],
    wildcard = 'ZZZ files (*.zzz)|*.zzz',
    output_info = PipelineInfo(datasets=['unstructured_grid'],
                               attribute_types=['any'],
                               attributes=['any'])
)
# Inject this information in the mayavi registry
registry.sources.append(zzz_reader_info)

if __name__ == '__main__':
    import sys
    print "*"*80
    print "ERROR: This script isn't supposed to be executed."
    print __doc__
    print "*"*80
    sys.exit(1)


########NEW FILE########
__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# Mayavi documentation build configuration file, created by
# sphinx-quickstart on Sat Apr 12 23:25:24 2008.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# The contents of this file are pickled, so don't put values in the namespace
# that aren't pickleable (module imports are okay, they're removed automatically).
#
# All configuration values have a default value; values that are commented out
# serve to show the default value.


# Adding the current directory to the path, so that sphinx finds the
# extensions.
import sys, os
sys.path.append(os.path.abspath('sphinxext'))


# General configuration
# ---------------------

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc', 'traitsdoc']

## An autodocumentation processor, to insert title of functions before
## the auto-documented functions:
#def add_title(app, what, name, obj, options, signature, return_annotation):
#    """ Add a section title with the name of the function before the
#        docstring.
#    """
#    if what is not 'function':
#        return
#    short_name = name.split('.')[-1]
#    extra_lines = """
#
#%s
#...........................................
#
#    """ % short_name
#    return extra_lines + signature, return_annotation
#
#
#def setup(app):
#    """ Register our docstring processor.
#    """
#    app.connect('autodoc-process-signature', add_title)


# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The master toctree document.
master_doc = 'index'

# General substitutions.
project = 'mayavi'
copyright = u'2008-2014, Prabhu Ramachandran, Gaël Varoquaux'

# The default replacements for |version| and |release|, also used in various
# other places throughout the built documents.
d = {}
execfile(os.path.join('..', '..', '..', 'mayavi', '__init__.py'), d)
version = release = d['__version__']

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
today_fmt = '%B %d, %Y'

# List of documents that shouldn't be included in the build.
#unused_docs = []

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'


# Options for HTML output
# -----------------------

# The style sheet to use for HTML and HTML Help pages. A file of that name
# must exist either in Sphinx' static/ path, or in one of the custom paths
# given in html_static_path.
html_style = 'default.css'

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Content template for the index page.
#html_index = ''

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
html_use_modindex = False

# If true, the reST sources are included in the HTML build as _sources/<name>.
#html_copy_source = True

# Output file base name for HTML help builder.
htmlhelp_basename = 'Mayavidoc'

# A logo displayed in the html sidebar.
html_logo = 'mayavi-logo.png'

# Options for LaTeX output
# ------------------------

# The paper size ('letter' or 'a4').
#latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
#latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, document class [howto/manual]).
latex_documents = [('index', 'mayavi_user_guide.tex', 'Mayavi User Guide',
                        'Prabhu Ramachandran, Gael Varoquaux', 'manual')]

# Additional stuff for the LaTeX preamble.
latex_preamble = """
\definecolor{VerbatimColor}{rgb}{0.95,1,0.833}
\definecolor{VerbatimBorderColor}{rgb}{0.6,0.6,0.6}
"""

# A logo displayed on the cover page.
latex_logo = 'm2_about.jpg'


# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_use_modindex = True

################################################################################
# A hack:
import shutil
shutil.copyfile('../../CHANGES.txt', './auto/changes.rst')

########NEW FILE########
__FILENAME__ = comment_eater
from cStringIO import StringIO
import compiler
import inspect
import textwrap
import tokenize

from compiler_unparse import unparse


class Comment(object):
    """ A comment block.
    """
    is_comment = True
    def __init__(self, start_lineno, end_lineno, text):
        # int : The first line number in the block. 1-indexed.
        self.start_lineno = start_lineno
        # int : The last line number. Inclusive!
        self.end_lineno = end_lineno
        # str : The text block including '#' character but not any leading spaces.
        self.text = text

    def add(self, string, start, end, line):
        """ Add a new comment line.
        """
        self.start_lineno = min(self.start_lineno, start[0])
        self.end_lineno = max(self.end_lineno, end[0])
        self.text += string

    def __repr__(self):
        return '%s(%r, %r, %r)' % (self.__class__.__name__, self.start_lineno,
            self.end_lineno, self.text)


class NonComment(object):
    """ A non-comment block of code.
    """
    is_comment = False
    def __init__(self, start_lineno, end_lineno):
        self.start_lineno = start_lineno
        self.end_lineno = end_lineno

    def add(self, string, start, end, line):
        """ Add lines to the block.
        """
        if string.strip():
            # Only add if not entirely whitespace.
            self.start_lineno = min(self.start_lineno, start[0])
            self.end_lineno = max(self.end_lineno, end[0])

    def __repr__(self):
        return '%s(%r, %r)' % (self.__class__.__name__, self.start_lineno,
            self.end_lineno)


class CommentBlocker(object):
    """ Pull out contiguous comment blocks.
    """
    def __init__(self):
        # Start with a dummy.
        self.current_block = NonComment(0, 0)

        # All of the blocks seen so far.
        self.blocks = []

        # The index mapping lines of code to their associated comment blocks.
        self.index = {}

    def process_file(self, file):
        """ Process a file object.
        """
        for token in tokenize.generate_tokens(file.next):
            self.process_token(*token)
        self.make_index()

    def process_token(self, kind, string, start, end, line):
        """ Process a single token.
        """
        if self.current_block.is_comment:
            if kind == tokenize.COMMENT:
                self.current_block.add(string, start, end, line)
            else:
                self.new_noncomment(start[0], end[0])
        else:
            if kind == tokenize.COMMENT:
                self.new_comment(string, start, end, line)
            else:
                self.current_block.add(string, start, end, line)

    def new_noncomment(self, start_lineno, end_lineno):
        """ We are transitioning from a noncomment to a comment.
        """
        block = NonComment(start_lineno, end_lineno)
        self.blocks.append(block)
        self.current_block = block

    def new_comment(self, string, start, end, line):
        """ Possibly add a new comment.

        Only adds a new comment if this comment is the only thing on the line.
        Otherwise, it extends the noncomment block.
        """
        prefix = line[:start[1]]
        if prefix.strip():
            # Oops! Trailing comment, not a comment block.
            self.current_block.add(string, start, end, line)
        else:
            # A comment block.
            block = Comment(start[0], end[0], string)
            self.blocks.append(block)
            self.current_block = block

    def make_index(self):
        """ Make the index mapping lines of actual code to their associated
        prefix comments.
        """
        for prev, block in zip(self.blocks[:-1], self.blocks[1:]):
            if not block.is_comment:
                self.index[block.start_lineno] = prev

    def search_for_comment(self, lineno, default=None):
        """ Find the comment block just before the given line number.

        Returns None (or the specified default) if there is no such block.
        """
        if not self.index:
            self.make_index()
        block = self.index.get(lineno, None)
        text = getattr(block, 'text', default)
        return text


def strip_comment_marker(text):
    """ Strip # markers at the front of a block of comment text.
    """
    lines = []
    for line in text.splitlines():
        lines.append(line.lstrip('#'))
    text = textwrap.dedent('\n'.join(lines))
    return text


def get_class_traits(klass):
    """ Yield all of the documentation for trait definitions on a class object.
    """
    # FIXME: gracefully handle errors here or in the caller?
    source = inspect.getsource(klass)
    cb = CommentBlocker()
    cb.process_file(StringIO(source))
    mod_ast = compiler.parse(source)
    class_ast = mod_ast.node.nodes[0]
    for node in class_ast.code.nodes:
        # FIXME: handle other kinds of assignments?
        if isinstance(node, compiler.ast.Assign):
            name = node.nodes[0].name
            rhs = unparse(node.expr).strip()
            doc = strip_comment_marker(cb.search_for_comment(node.lineno, default=''))
            yield name, rhs, doc


########NEW FILE########
__FILENAME__ = compiler_unparse
""" Turn compiler.ast structures back into executable python code.

    The unparse method takes a compiler.ast tree and transforms it back into
    valid python code.  It is incomplete and currently only works for
    import statements, function calls, function definitions, assignments, and
    basic expressions.

    Inspired by python-2.5-svn/Demo/parser/unparse.py

    fixme: We may want to move to using _ast trees because the compiler for
           them is about 6 times faster than compiler.compile.
"""

import sys
import cStringIO
from compiler.ast import Const, Name, Tuple, Div, Mul, Sub, Add

def unparse(ast, single_line_functions=False):
    s = cStringIO.StringIO()
    UnparseCompilerAst(ast, s, single_line_functions)
    return s.getvalue().lstrip()

op_precedence = { 'compiler.ast.Power':3, 'compiler.ast.Mul':2, 'compiler.ast.Div':2,
                  'compiler.ast.Add':1, 'compiler.ast.Sub':1 }

class UnparseCompilerAst:
    """ Methods in this class recursively traverse an AST and
        output source code for the abstract syntax; original formatting
        is disregarged.
    """

    #########################################################################
    # object interface.
    #########################################################################

    def __init__(self, tree, file = sys.stdout, single_line_functions=False):
        """ Unparser(tree, file=sys.stdout) -> None.

            Print the source for tree to file.
        """
        self.f = file
        self._single_func = single_line_functions
        self._do_indent = True
        self._indent = 0
        self._dispatch(tree)
        self._write("\n")
        self.f.flush()

    #########################################################################
    # Unparser private interface.
    #########################################################################

    ### format, output, and dispatch methods ################################

    def _fill(self, text = ""):
        "Indent a piece of text, according to the current indentation level"
        if self._do_indent:
            self._write("\n"+"    "*self._indent + text)
        else:
            self._write(text)

    def _write(self, text):
        "Append a piece of text to the current line."
        self.f.write(text)

    def _enter(self):
        "Print ':', and increase the indentation."
        self._write(": ")
        self._indent += 1

    def _leave(self):
        "Decrease the indentation level."
        self._indent -= 1

    def _dispatch(self, tree):
        "_dispatcher function, _dispatching tree type T to method _T."
        if isinstance(tree, list):
            for t in tree:
                self._dispatch(t)
            return
        meth = getattr(self, "_"+tree.__class__.__name__)
        if tree.__class__.__name__ == 'NoneType' and not self._do_indent:
            return
        meth(tree)


    #########################################################################
    # compiler.ast unparsing methods.
    #
    # There should be one method per concrete grammar type. They are
    # organized in alphabetical order.
    #########################################################################

    def _Add(self, t):
        self.__binary_op(t, '+')

    def _And(self, t):
        self._write(" (")
        for i, node in enumerate(t.nodes):
            self._dispatch(node)
            if i != len(t.nodes)-1:
                self._write(") and (")
        self._write(")")

    def _AssAttr(self, t):
        """ Handle assigning an attribute of an object
        """
        self._dispatch(t.expr)
        self._write('.'+t.attrname)

    def _Assign(self, t):
        """ Expression Assignment such as "a = 1".

            This only handles assignment in expressions.  Keyword assignment
            is handled separately.
        """
        self._fill()
        for target in t.nodes:
            self._dispatch(target)
            self._write(" = ")
        self._dispatch(t.expr)
        if not self._do_indent:
            self._write('; ')

    def _AssName(self, t):
        """ Name on left hand side of expression.

            Treat just like a name on the right side of an expression.
        """
        self._Name(t)

    def _AssTuple(self, t):
        """ Tuple on left hand side of an expression.
        """

        # _write each elements, separated by a comma.
        for element in t.nodes[:-1]:
            self._dispatch(element)
            self._write(", ")

        # Handle the last one without writing comma
        last_element = t.nodes[-1]
        self._dispatch(last_element)

    def _AugAssign(self, t):
        """ +=,-=,*=,/=,**=, etc. operations
        """

        self._fill()
        self._dispatch(t.node)
        self._write(' '+t.op+' ')
        self._dispatch(t.expr)
        if not self._do_indent:
            self._write(';')

    def _Bitand(self, t):
        """ Bit and operation.
        """

        for i, node in enumerate(t.nodes):
            self._write("(")
            self._dispatch(node)
            self._write(")")
            if i != len(t.nodes)-1:
                self._write(" & ")

    def _Bitor(self, t):
        """ Bit or operation
        """

        for i, node in enumerate(t.nodes):
            self._write("(")
            self._dispatch(node)
            self._write(")")
            if i != len(t.nodes)-1:
                self._write(" | ")

    def _CallFunc(self, t):
        """ Function call.
        """
        self._dispatch(t.node)
        self._write("(")
        comma = False
        for e in t.args:
            if comma: self._write(", ")
            else: comma = True
            self._dispatch(e)
        if t.star_args:
            if comma: self._write(", ")
            else: comma = True
            self._write("*")
            self._dispatch(t.star_args)
        if t.dstar_args:
            if comma: self._write(", ")
            else: comma = True
            self._write("**")
            self._dispatch(t.dstar_args)
        self._write(")")

    def _Compare(self, t):
        self._dispatch(t.expr)
        for op, expr in t.ops:
            self._write(" " + op + " ")
            self._dispatch(expr)

    def _Const(self, t):
        """ A constant value such as an integer value, 3, or a string, "hello".
        """
        self._dispatch(t.value)

    def _Decorators(self, t):
        """ Handle function decorators (eg. @has_units)
        """
        for node in t.nodes:
            self._dispatch(node)

    def _Dict(self, t):
        self._write("{")
        for  i, (k, v) in enumerate(t.items):
            self._dispatch(k)
            self._write(": ")
            self._dispatch(v)
            if i < len(t.items)-1:
                self._write(", ")
        self._write("}")

    def _Discard(self, t):
        """ Node for when return value is ignored such as in "foo(a)".
        """
        self._fill()
        self._dispatch(t.expr)

    def _Div(self, t):
        self.__binary_op(t, '/')

    def _Ellipsis(self, t):
        self._write("...")

    def _From(self, t):
        """ Handle "from xyz import foo, bar as baz".
        """
        # fixme: Are From and ImportFrom handled differently?
        self._fill("from ")
        self._write(t.modname)
        self._write(" import ")
        for i, (name,asname) in enumerate(t.names):
            if i != 0:
                self._write(", ")
            self._write(name)
            if asname is not None:
                self._write(" as "+asname)

    def _Function(self, t):
        """ Handle function definitions
        """
        if t.decorators is not None:
            self._fill("@")
            self._dispatch(t.decorators)
        self._fill("def "+t.name + "(")
        defaults = [None] * (len(t.argnames) - len(t.defaults)) + list(t.defaults)
        for i, arg in enumerate(zip(t.argnames, defaults)):
            self._write(arg[0])
            if arg[1] is not None:
                self._write('=')
                self._dispatch(arg[1])
            if i < len(t.argnames)-1:
                self._write(', ')
        self._write(")")
        if self._single_func:
            self._do_indent = False
        self._enter()
        self._dispatch(t.code)
        self._leave()
        self._do_indent = True

    def _Getattr(self, t):
        """ Handle getting an attribute of an object
        """
        if isinstance(t.expr, (Div, Mul, Sub, Add)):
            self._write('(')
            self._dispatch(t.expr)
            self._write(')')
        else:
            self._dispatch(t.expr)

        self._write('.'+t.attrname)

    def _If(self, t):
        self._fill()

        for i, (compare,code) in enumerate(t.tests):
            if i == 0:
                self._write("if ")
            else:
                self._write("elif ")
            self._dispatch(compare)
            self._enter()
            self._fill()
            self._dispatch(code)
            self._leave()
            self._write("\n")

        if t.else_ is not None:
            self._write("else")
            self._enter()
            self._fill()
            self._dispatch(t.else_)
            self._leave()
            self._write("\n")

    def _IfExp(self, t):
        self._dispatch(t.then)
        self._write(" if ")
        self._dispatch(t.test)

        if t.else_ is not None:
            self._write(" else (")
            self._dispatch(t.else_)
            self._write(")")

    def _Import(self, t):
        """ Handle "import xyz.foo".
        """
        self._fill("import ")

        for i, (name,asname) in enumerate(t.names):
            if i != 0:
                self._write(", ")
            self._write(name)
            if asname is not None:
                self._write(" as "+asname)

    def _Keyword(self, t):
        """ Keyword value assignment within function calls and definitions.
        """
        self._write(t.name)
        self._write("=")
        self._dispatch(t.expr)

    def _List(self, t):
        self._write("[")
        for  i,node in enumerate(t.nodes):
            self._dispatch(node)
            if i < len(t.nodes)-1:
                self._write(", ")
        self._write("]")

    def _Module(self, t):
        if t.doc is not None:
            self._dispatch(t.doc)
        self._dispatch(t.node)

    def _Mul(self, t):
        self.__binary_op(t, '*')

    def _Name(self, t):
        self._write(t.name)

    def _NoneType(self, t):
        self._write("None")

    def _Not(self, t):
        self._write('not (')
        self._dispatch(t.expr)
        self._write(')')

    def _Or(self, t):
        self._write(" (")
        for i, node in enumerate(t.nodes):
            self._dispatch(node)
            if i != len(t.nodes)-1:
                self._write(") or (")
        self._write(")")

    def _Pass(self, t):
        self._write("pass\n")

    def _Printnl(self, t):
        self._fill("print ")
        if t.dest:
            self._write(">> ")
            self._dispatch(t.dest)
            self._write(", ")
        comma = False
        for node in t.nodes:
            if comma: self._write(', ')
            else: comma = True
            self._dispatch(node)

    def _Power(self, t):
        self.__binary_op(t, '**')

    def _Return(self, t):
        self._fill("return ")
        if t.value:
            if isinstance(t.value, Tuple):
                text = ', '.join([ name.name for name in t.value.asList() ])
                self._write(text)
            else:
                self._dispatch(t.value)
            if not self._do_indent:
                self._write('; ')

    def _Slice(self, t):
        self._dispatch(t.expr)
        self._write("[")
        if t.lower:
            self._dispatch(t.lower)
        self._write(":")
        if t.upper:
            self._dispatch(t.upper)
        #if t.step:
        #    self._write(":")
        #    self._dispatch(t.step)
        self._write("]")

    def _Sliceobj(self, t):
        for i, node in enumerate(t.nodes):
            if i != 0:
                self._write(":")
            if not (isinstance(node, Const) and node.value is None):
                self._dispatch(node)

    def _Stmt(self, tree):
        for node in tree.nodes:
            self._dispatch(node)

    def _Sub(self, t):
        self.__binary_op(t, '-')

    def _Subscript(self, t):
        self._dispatch(t.expr)
        self._write("[")
        for i, value in enumerate(t.subs):
            if i != 0:
                self._write(",")
            self._dispatch(value)
        self._write("]")

    def _TryExcept(self, t):
        self._fill("try")
        self._enter()
        self._dispatch(t.body)
        self._leave()

        for handler in t.handlers:
            self._fill('except ')
            self._dispatch(handler[0])
            if handler[1] is not None:
                self._write(', ')
                self._dispatch(handler[1])
            self._enter()
            self._dispatch(handler[2])
            self._leave()

        if t.else_:
            self._fill("else")
            self._enter()
            self._dispatch(t.else_)
            self._leave()

    def _Tuple(self, t):

        if not t.nodes:
            # Empty tuple.
            self._write("()")
        else:
            self._write("(")

            # _write each elements, separated by a comma.
            for element in t.nodes[:-1]:
                self._dispatch(element)
                self._write(", ")

            # Handle the last one without writing comma
            last_element = t.nodes[-1]
            self._dispatch(last_element)

            self._write(")")

    def _UnaryAdd(self, t):
        self._write("+")
        self._dispatch(t.expr)

    def _UnarySub(self, t):
        self._write("-")
        self._dispatch(t.expr)

    def _With(self, t):
        self._fill('with ')
        self._dispatch(t.expr)
        if t.vars:
            self._write(' as ')
            self._dispatch(t.vars.name)
        self._enter()
        self._dispatch(t.body)
        self._leave()
        self._write('\n')

    def _int(self, t):
        self._write(repr(t))

    def __binary_op(self, t, symbol):
        # Check if parenthesis are needed on left side and then dispatch
        has_paren = False
        left_class = str(t.left.__class__)
        if (left_class in op_precedence.keys() and
            op_precedence[left_class] < op_precedence[str(t.__class__)]):
            has_paren = True
        if has_paren:
            self._write('(')
        self._dispatch(t.left)
        if has_paren:
            self._write(')')
        # Write the appropriate symbol for operator
        self._write(symbol)
        # Check if parenthesis are needed on the right side and then dispatch
        has_paren = False
        right_class = str(t.right.__class__)
        if (right_class in op_precedence.keys() and
            op_precedence[right_class] < op_precedence[str(t.__class__)]):
            has_paren = True
        if has_paren:
            self._write('(')
        self._dispatch(t.right)
        if has_paren:
            self._write(')')

    def _float(self, t):
        # if t is 0.1, str(t)->'0.1' while repr(t)->'0.1000000000001'
        # We prefer str here.
        self._write(str(t))

    def _str(self, t):
        self._write(repr(t))

    def _tuple(self, t):
        self._write(str(t))

    #########################################################################
    # These are the methods from the _ast modules unparse.
    #
    # As our needs to handle more advanced code increase, we may want to
    # modify some of the methods below so that they work for compiler.ast.
    #########################################################################

#    # stmt
#    def _Expr(self, tree):
#        self._fill()
#        self._dispatch(tree.value)
#
#    def _Import(self, t):
#        self._fill("import ")
#        first = True
#        for a in t.names:
#            if first:
#                first = False
#            else:
#                self._write(", ")
#            self._write(a.name)
#            if a.asname:
#                self._write(" as "+a.asname)
#
##    def _ImportFrom(self, t):
##        self._fill("from ")
##        self._write(t.module)
##        self._write(" import ")
##        for i, a in enumerate(t.names):
##            if i == 0:
##                self._write(", ")
##            self._write(a.name)
##            if a.asname:
##                self._write(" as "+a.asname)
##        # XXX(jpe) what is level for?
##
#
#    def _Break(self, t):
#        self._fill("break")
#
#    def _Continue(self, t):
#        self._fill("continue")
#
#    def _Delete(self, t):
#        self._fill("del ")
#        self._dispatch(t.targets)
#
#    def _Assert(self, t):
#        self._fill("assert ")
#        self._dispatch(t.test)
#        if t.msg:
#            self._write(", ")
#            self._dispatch(t.msg)
#
#    def _Exec(self, t):
#        self._fill("exec ")
#        self._dispatch(t.body)
#        if t.globals:
#            self._write(" in ")
#            self._dispatch(t.globals)
#        if t.locals:
#            self._write(", ")
#            self._dispatch(t.locals)
#
#    def _Print(self, t):
#        self._fill("print ")
#        do_comma = False
#        if t.dest:
#            self._write(">>")
#            self._dispatch(t.dest)
#            do_comma = True
#        for e in t.values:
#            if do_comma:self._write(", ")
#            else:do_comma=True
#            self._dispatch(e)
#        if not t.nl:
#            self._write(",")
#
#    def _Global(self, t):
#        self._fill("global")
#        for i, n in enumerate(t.names):
#            if i != 0:
#                self._write(",")
#            self._write(" " + n)
#
#    def _Yield(self, t):
#        self._fill("yield")
#        if t.value:
#            self._write(" (")
#            self._dispatch(t.value)
#            self._write(")")
#
#    def _Raise(self, t):
#        self._fill('raise ')
#        if t.type:
#            self._dispatch(t.type)
#        if t.inst:
#            self._write(", ")
#            self._dispatch(t.inst)
#        if t.tback:
#            self._write(", ")
#            self._dispatch(t.tback)
#
#
#    def _TryFinally(self, t):
#        self._fill("try")
#        self._enter()
#        self._dispatch(t.body)
#        self._leave()
#
#        self._fill("finally")
#        self._enter()
#        self._dispatch(t.finalbody)
#        self._leave()
#
#    def _excepthandler(self, t):
#        self._fill("except ")
#        if t.type:
#            self._dispatch(t.type)
#        if t.name:
#            self._write(", ")
#            self._dispatch(t.name)
#        self._enter()
#        self._dispatch(t.body)
#        self._leave()
#
#    def _ClassDef(self, t):
#        self._write("\n")
#        self._fill("class "+t.name)
#        if t.bases:
#            self._write("(")
#            for a in t.bases:
#                self._dispatch(a)
#                self._write(", ")
#            self._write(")")
#        self._enter()
#        self._dispatch(t.body)
#        self._leave()
#
#    def _FunctionDef(self, t):
#        self._write("\n")
#        for deco in t.decorators:
#            self._fill("@")
#            self._dispatch(deco)
#        self._fill("def "+t.name + "(")
#        self._dispatch(t.args)
#        self._write(")")
#        self._enter()
#        self._dispatch(t.body)
#        self._leave()
#
#    def _For(self, t):
#        self._fill("for ")
#        self._dispatch(t.target)
#        self._write(" in ")
#        self._dispatch(t.iter)
#        self._enter()
#        self._dispatch(t.body)
#        self._leave()
#        if t.orelse:
#            self._fill("else")
#            self._enter()
#            self._dispatch(t.orelse)
#            self._leave
#
#    def _While(self, t):
#        self._fill("while ")
#        self._dispatch(t.test)
#        self._enter()
#        self._dispatch(t.body)
#        self._leave()
#        if t.orelse:
#            self._fill("else")
#            self._enter()
#            self._dispatch(t.orelse)
#            self._leave
#
#    # expr
#    def _Str(self, tree):
#        self._write(repr(tree.s))
##
#    def _Repr(self, t):
#        self._write("`")
#        self._dispatch(t.value)
#        self._write("`")
#
#    def _Num(self, t):
#        self._write(repr(t.n))
#
#    def _ListComp(self, t):
#        self._write("[")
#        self._dispatch(t.elt)
#        for gen in t.generators:
#            self._dispatch(gen)
#        self._write("]")
#
#    def _GeneratorExp(self, t):
#        self._write("(")
#        self._dispatch(t.elt)
#        for gen in t.generators:
#            self._dispatch(gen)
#        self._write(")")
#
#    def _comprehension(self, t):
#        self._write(" for ")
#        self._dispatch(t.target)
#        self._write(" in ")
#        self._dispatch(t.iter)
#        for if_clause in t.ifs:
#            self._write(" if ")
#            self._dispatch(if_clause)
#
#    def _IfExp(self, t):
#        self._dispatch(t.body)
#        self._write(" if ")
#        self._dispatch(t.test)
#        if t.orelse:
#            self._write(" else ")
#            self._dispatch(t.orelse)
#
#    unop = {"Invert":"~", "Not": "not", "UAdd":"+", "USub":"-"}
#    def _UnaryOp(self, t):
#        self._write(self.unop[t.op.__class__.__name__])
#        self._write("(")
#        self._dispatch(t.operand)
#        self._write(")")
#
#    binop = { "Add":"+", "Sub":"-", "Mult":"*", "Div":"/", "Mod":"%",
#                    "LShift":">>", "RShift":"<<", "BitOr":"|", "BitXor":"^", "BitAnd":"&",
#                    "FloorDiv":"//", "Pow": "**"}
#    def _BinOp(self, t):
#        self._write("(")
#        self._dispatch(t.left)
#        self._write(")" + self.binop[t.op.__class__.__name__] + "(")
#        self._dispatch(t.right)
#        self._write(")")
#
#    boolops = {_ast.And: 'and', _ast.Or: 'or'}
#    def _BoolOp(self, t):
#        self._write("(")
#        self._dispatch(t.values[0])
#        for v in t.values[1:]:
#            self._write(" %s " % self.boolops[t.op.__class__])
#            self._dispatch(v)
#        self._write(")")
#
#    def _Attribute(self,t):
#        self._dispatch(t.value)
#        self._write(".")
#        self._write(t.attr)
#
##    def _Call(self, t):
##        self._dispatch(t.func)
##        self._write("(")
##        comma = False
##        for e in t.args:
##            if comma: self._write(", ")
##            else: comma = True
##            self._dispatch(e)
##        for e in t.keywords:
##            if comma: self._write(", ")
##            else: comma = True
##            self._dispatch(e)
##        if t.starargs:
##            if comma: self._write(", ")
##            else: comma = True
##            self._write("*")
##            self._dispatch(t.starargs)
##        if t.kwargs:
##            if comma: self._write(", ")
##            else: comma = True
##            self._write("**")
##            self._dispatch(t.kwargs)
##        self._write(")")
#
#    # slice
#    def _Index(self, t):
#        self._dispatch(t.value)
#
#    def _ExtSlice(self, t):
#        for i, d in enumerate(t.dims):
#            if i != 0:
#                self._write(': ')
#            self._dispatch(d)
#
#    # others
#    def _arguments(self, t):
#        first = True
#        nonDef = len(t.args)-len(t.defaults)
#        for a in t.args[0:nonDef]:
#            if first:first = False
#            else: self._write(", ")
#            self._dispatch(a)
#        for a,d in zip(t.args[nonDef:], t.defaults):
#            if first:first = False
#            else: self._write(", ")
#            self._dispatch(a),
#            self._write("=")
#            self._dispatch(d)
#        if t.vararg:
#            if first:first = False
#            else: self._write(", ")
#            self._write("*"+t.vararg)
#        if t.kwarg:
#            if first:first = False
#            else: self._write(", ")
#            self._write("**"+t.kwarg)
#
##    def _keyword(self, t):
##        self._write(t.arg)
##        self._write("=")
##        self._dispatch(t.value)
#
#    def _Lambda(self, t):
#        self._write("lambda ")
#        self._dispatch(t.args)
#        self._write(": ")
#        self._dispatch(t.body)




########NEW FILE########
__FILENAME__ = docscrape
"""Extract reference documentation from the NumPy source tree.

"""

import inspect
import textwrap
import re
import pydoc
from StringIO import StringIO
from warnings import warn

class Reader(object):
    """A line-based string reader.

    """
    def __init__(self, data):
        """
        Parameters
        ----------
        data : str
           String with lines separated by '\n'.

        """
        if isinstance(data,list):
            self._str = data
        else:
            self._str = data.split('\n') # store string as list of lines

        self.reset()

    def __getitem__(self, n):
        return self._str[n]

    def reset(self):
        self._l = 0 # current line nr

    def read(self):
        if not self.eof():
            out = self[self._l]
            self._l += 1
            return out
        else:
            return ''

    def seek_next_non_empty_line(self):
        for l in self[self._l:]:
            if l.strip():
                break
            else:
                self._l += 1

    def eof(self):
        return self._l >= len(self._str)

    def read_to_condition(self, condition_func):
        start = self._l
        for line in self[start:]:
            if condition_func(line):
                return self[start:self._l]
            self._l += 1
            if self.eof():
                return self[start:self._l+1]
        return []

    def read_to_next_empty_line(self):
        self.seek_next_non_empty_line()
        def is_empty(line):
            return not line.strip()
        return self.read_to_condition(is_empty)

    def read_to_next_unindented_line(self):
        def is_unindented(line):
            return (line.strip() and (len(line.lstrip()) == len(line)))
        return self.read_to_condition(is_unindented)

    def peek(self,n=0):
        if self._l + n < len(self._str):
            return self[self._l + n]
        else:
            return ''

    def is_empty(self):
        return not ''.join(self._str).strip()


class NumpyDocString(object):
    def __init__(self,docstring):
        docstring = docstring.split('\n')

        # De-indent paragraph
        try:
            indent = min(len(s) - len(s.lstrip()) for s in docstring
                         if s.strip())
        except ValueError:
            indent = 0

        for n,line in enumerate(docstring):
            docstring[n] = docstring[n][indent:]

        self._doc = Reader(docstring)
        self._parsed_data = {
            'Signature': '',
            'Summary': '',
            'Extended Summary': [],
            'Parameters': [],
            'Returns': [],
            'Raises': [],
            'Warns': [],
            'Other Parameters': [],
            'Attributes': [],
            'Methods': [],
            'See Also': [],
            'Notes': [],
            'References': '',
            'Examples': '',
            'index': {}
            }

        self._parse()

    def __getitem__(self,key):
        return self._parsed_data[key]

    def __setitem__(self,key,val):
        if not self._parsed_data.has_key(key):
            warn("Unknown section %s" % key)
        else:
            self._parsed_data[key] = val

    def _is_at_section(self):
        self._doc.seek_next_non_empty_line()

        if self._doc.eof():
            return False

        l1 = self._doc.peek().strip()  # e.g. Parameters

        if l1.startswith('.. index::'):
            return True

        l2 = self._doc.peek(1).strip() #    ----------
        return l2.startswith('-'*len(l1))

    def _strip(self,doc):
        i = 0
        j = 0
        for i,line in enumerate(doc):
            if line.strip(): break

        for j,line in enumerate(doc[::-1]):
            if line.strip(): break

        return doc[i:len(doc)-j]

    def _read_to_next_section(self):
        section = self._doc.read_to_next_empty_line()

        while not self._is_at_section() and not self._doc.eof():
            if not self._doc.peek(-1).strip(): # previous line was empty
                section += ['']

            section += self._doc.read_to_next_empty_line()

        return section

    def _read_sections(self):
        while not self._doc.eof():
            data = self._read_to_next_section()
            name = data[0].strip()

            if name.startswith('..'): # index section
                yield name, data[1:]
            elif len(data) < 2:
                yield StopIteration
            else:
                yield name, self._strip(data[2:])

    def _parse_param_list(self,content):
        r = Reader(content)
        params = []
        while not r.eof():
            header = r.read().strip()
            if ' : ' in header:
                arg_name, arg_type = header.split(' : ')[:2]
            else:
                arg_name, arg_type = header, ''

            desc = r.read_to_next_unindented_line()
            for n,line in enumerate(desc):
                desc[n] = line.strip()
            desc = desc #'\n'.join(desc)

            params.append((arg_name,arg_type,desc))

        return params

    def _parse_see_also(self, content):
        """
        func_name : Descriptive text
            continued text
        another_func_name : Descriptive text
        func_name1, func_name2, func_name3

        """
        functions = []
        current_func = None
        rest = []
        for line in content:
            if not line.strip(): continue
            if ':' in line:
                if current_func:
                    functions.append((current_func, rest))
                r = line.split(':', 1)
                current_func = r[0].strip()
                r[1] = r[1].strip()
                if r[1]:
                    rest = [r[1]]
                else:
                    rest = []
            elif not line.startswith(' '):
                if current_func:
                    functions.append((current_func, rest))
                    current_func = None
                    rest = []
                if ',' in line:
                    for func in line.split(','):
                        func = func.strip()
                        if func:
                            functions.append((func, []))
                elif line.strip():
                    current_func = line.strip()
            elif current_func is not None:
                rest.append(line.strip())
        if current_func:
            functions.append((current_func, rest))
        return functions

    def _parse_index(self, section, content):
        """
        .. index: default
           :refguide: something, else, and more

        """
        def strip_each_in(lst):
            return [s.strip() for s in lst]

        out = {}
        section = section.split('::')
        if len(section) > 1:
            out['default'] = strip_each_in(section[1].split(','))[0]
        for line in content:
            line = line.split(':')
            if len(line) > 2:
                out[line[1]] = strip_each_in(line[2].split(','))
        return out

    def _parse_summary(self):
        """Grab signature (if given) and summary"""
        if self._is_at_section():
            return

        summary = self._doc.read_to_next_empty_line()
        summary_str = " ".join([s.strip() for s in summary]).strip()
        if re.compile('^([\w., ]+=)?\s*[\w\.]+\(.*\)$').match(summary_str):
            self['Signature'] = summary_str
            if not self._is_at_section():
                self['Summary'] = self._doc.read_to_next_empty_line()
        else:
            self['Summary'] = summary

        if not self._is_at_section():
            self['Extended Summary'] = self._read_to_next_section()

    def _parse(self):
        self._doc.reset()
        self._parse_summary()

        for (section,content) in self._read_sections():
            if not section.startswith('..'):
                section = ' '.join([s.capitalize() for s in section.split(' ')])
            if section in ('Parameters', 'Attributes', 'Methods',
                           'Returns', 'Raises', 'Warns'):
                self[section] = self._parse_param_list(content)
            elif section.startswith('.. index::'):
                self['index'] = self._parse_index(section, content)
            elif section == 'See Also':
                self['See Also'] = self._parse_see_also(content)
            else:
                self[section] = content

    # string conversion routines

    def _str_header(self, name, symbol='-'):
        return [name, len(name)*symbol]

    def _str_indent(self, doc, indent=4):
        out = []
        for line in doc:
            out += [' '*indent + line]
        return out

    def _str_signature(self):
        if self['Signature']:
            return [self['Signature'].replace('*','\*')] + ['']
        else:
            return ['']

    def _str_summary(self):
        if self['Summary']:
            return self['Summary'] + ['']
        else:
            return []

    def _str_extended_summary(self):
        if self['Extended Summary']:
            return self['Extended Summary'] + ['']
        else:
            return []

    def _str_param_list(self, name):
        out = []
        if self[name]:
            out += self._str_header(name)
            for param,param_type,desc in self[name]:
                out += ['%s : %s' % (param, param_type)]
                out += self._str_indent(desc)
            out += ['']
        return out

    def _str_section(self, name):
        out = []
        if self[name]:
            out += self._str_header(name)
            out += self[name]
            out += ['']
        return out

    def _str_see_also(self, func_role):
        if not self['See Also']: return []
        out = []
        out += self._str_header("See Also")
        last_had_desc = True
        for func, desc in self['See Also']:
            if func_role:
                link = ':%s:`%s`' % (func_role, func)
            else:
                link = "`%s`_" % func
            if desc or last_had_desc:
                out += ['']
                out += [link]
            else:
                out[-1] += ", %s" % link
            if desc:
                out += self._str_indent(desc)
                last_had_desc = True
            else:
                last_had_desc = False
        out += ['']
        return out

    def _str_index(self):
        idx = self['index']
        out = []
        out += ['.. index:: %s' % idx.get('default','')]
        for section, references in idx.iteritems():
            if section == 'default':
                continue
            out += ['   :%s: %s' % (section, ', '.join(references))]
        return out

    def __str__(self, func_role=''):
        out = []
        out += self._str_signature()
        out += self._str_summary()
        out += self._str_extended_summary()
        for param_list in ('Parameters','Returns','Raises'):
            out += self._str_param_list(param_list)
        out += self._str_see_also(func_role)
        for s in ('Notes','References','Examples'):
            out += self._str_section(s)
        out += self._str_index()
        return '\n'.join(out)


def indent(str,indent=4):
    indent_str = ' '*indent
    if str is None:
        return indent_str
    lines = str.split('\n')
    return '\n'.join(indent_str + l for l in lines)

def header(text, style='-'):
    return text + '\n' + style*len(text) + '\n'


class FunctionDoc(NumpyDocString):
    def __init__(self, func, role='func'):
        self._f = func
        self._role = role # e.g. "func" or "meth"
        try:
            NumpyDocString.__init__(self,inspect.getdoc(func) or '')
        except ValueError, e:
            print '*'*78
            print "ERROR: '%s' while parsing `%s`" % (e, self._f)
            print '*'*78
            #print "Docstring follows:"
            #print doclines
            #print '='*78

        if not self['Signature']:
            func, func_name = self.get_func()
            try:
                # try to read signature
                argspec = inspect.getargspec(func)
                argspec = inspect.formatargspec(*argspec)
                argspec = argspec.replace('*','\*')
                signature = '%s%s' % (func_name, argspec)
            except TypeError, e:
                signature = '%s()' % func_name
            self['Signature'] = signature

    def get_func(self):
        func_name = getattr(self._f, '__name__', self.__class__.__name__)
        if hasattr(self._f, '__class__') or inspect.isclass(self._f):
            func = getattr(self._f, '__call__', self._f.__init__)
        else:
            func = self._f
        return func, func_name

    def __str__(self):
        out = ''

        func, func_name = self.get_func()
        signature = self['Signature'].replace('*', '\*')

        roles = {'func': 'function',
                 'meth': 'method'}

        if self._role:
            if not roles.has_key(self._role):
                print "Warning: invalid role %s" % self._role
            out += '.. %s:: %s\n    \n\n' % (roles.get(self._role,''),
                                             func_name)

        out += super(FunctionDoc, self).__str__(func_role=self._role)
        return out


class ClassDoc(NumpyDocString):
    def __init__(self,cls,modulename='',func_doc=FunctionDoc):
        if not inspect.isclass(cls):
            raise ValueError("Initialise using a class. Got %r" % cls)
        self._cls = cls

        if modulename and not modulename.endswith('.'):
            modulename += '.'
        self._mod = modulename
        self._name = cls.__name__
        self._func_doc = func_doc

        NumpyDocString.__init__(self, pydoc.getdoc(cls))

    @property
    def methods(self):
        return [name for name,func in inspect.getmembers(self._cls)
                if not name.startswith('_') and callable(func)]

    def __str__(self):
        out = ''
        out += super(ClassDoc, self).__str__()
        out += "\n\n"

        #for m in self.methods:
        #    print "Parsing `%s`" % m
        #    out += str(self._func_doc(getattr(self._cls,m), 'meth')) + '\n\n'
        #    out += '.. index::\n   single: %s; %s\n\n' % (self._name, m)

        return out



########NEW FILE########
__FILENAME__ = docscrape_sphinx
import re, textwrap
from docscrape import NumpyDocString, FunctionDoc, ClassDoc

class SphinxDocString(NumpyDocString):
    # string conversion routines
    def _str_header(self, name, symbol='`'):
        return ['.. rubric:: ' + name, '']

    def _str_field_list(self, name):
        return [':' + name + ':']

    def _str_indent(self, doc, indent=4):
        out = []
        for line in doc:
            out += [' '*indent + line]
        return out

    def _str_signature(self):
        return ['']
        if self['Signature']:
            return ['``%s``' % self['Signature']] + ['']
        else:
            return ['']

    def _str_summary(self):
        return self['Summary'] + ['']

    def _str_extended_summary(self):
        return self['Extended Summary'] + ['']

    def _str_param_list(self, name):
        out = []
        if self[name]:
            out += self._str_field_list(name)
            out += ['']
            for param,param_type,desc in self[name]:
                out += self._str_indent(['**%s** : %s' % (param.strip(),
                                                          param_type)])
                out += ['']
                out += self._str_indent(desc,8)
                out += ['']
        return out

    def _str_section(self, name):
        out = []
        if self[name]:
            out += self._str_header(name)
            out += ['']
            content = textwrap.dedent("\n".join(self[name])).split("\n")
            out += content
            out += ['']
        return out

    def _str_see_also(self, func_role):
        out = []
        if self['See Also']:
            see_also = super(SphinxDocString, self)._str_see_also(func_role)
            out = ['.. seealso::', '']
            out += self._str_indent(see_also[2:])
        return out

    def _str_index(self):
        idx = self['index']
        out = []
        if len(idx) == 0:
            return out

        out += ['.. index:: %s' % idx.get('default','')]
        for section, references in idx.iteritems():
            if section == 'default':
                continue
            elif section == 'refguide':
                out += ['   single: %s' % (', '.join(references))]
            else:
                out += ['   %s: %s' % (section, ','.join(references))]
        return out

    def _str_references(self):
        out = []
        if self['References']:
            out += self._str_header('References')
            if isinstance(self['References'], str):
                self['References'] = [self['References']]
            out.extend(self['References'])
            out += ['']
        return out

    def __str__(self, indent=0, func_role="func"):
        out = []
        out += self._str_signature()
        out += self._str_index() + ['']
        out += self._str_summary()
        out += self._str_extended_summary()
        for param_list in ('Parameters', 'Attributes', 'Methods',
                           'Returns','Raises'):
            out += self._str_param_list(param_list)
        out += self._str_see_also("obj")
        out += self._str_section('Notes')
        out += self._str_references()
        out += self._str_section('Examples')
        out = self._str_indent(out,indent)
        return '\n'.join(out)

class SphinxFunctionDoc(SphinxDocString, FunctionDoc):
    pass

class SphinxClassDoc(SphinxDocString, ClassDoc):
    pass

########NEW FILE########
__FILENAME__ = numpydoc
import os, re, pydoc
from docscrape_sphinx import SphinxDocString, SphinxClassDoc, SphinxFunctionDoc
import inspect

def mangle_docstrings(app, what, name, obj, options, lines,
                      reference_offset=[0]):
    if what == 'module':
        # Strip top title
        title_re = re.compile(r'^\s*[#*=]{4,}\n[a-z0-9 -]+\n[#*=]{4,}\s*',
                              re.I|re.S)
        lines[:] = title_re.sub('', "\n".join(lines)).split("\n")
    else:
        doc = get_doc_object(obj, what)
        lines[:] = str(doc).split("\n")

    if app.config.numpydoc_edit_link and hasattr(obj, '__name__') and \
           obj.__name__:
        v = dict(full_name=obj.__name__)
        lines += [''] + (app.config.numpydoc_edit_link % v).split("\n")

    # replace reference numbers so that there are no duplicates
    references = []
    for l in lines:
        l = l.strip()
        if l.startswith('.. ['):
            try:
                references.append(int(l[len('.. ['):l.index(']')]))
            except ValueError:
                print "WARNING: invalid reference in %s docstring" % name

    # Start renaming from the biggest number, otherwise we may
    # overwrite references.
    references.sort()
    if references:
        for i, line in enumerate(lines):
            for r in references:
                new_r = reference_offset[0] + r
                lines[i] = lines[i].replace('[%d]_' % r,
                                            '[%d]_' % new_r)
                lines[i] = lines[i].replace('.. [%d]' % r,
                                            '.. [%d]' % new_r)

    reference_offset[0] += len(references)

def get_doc_object(obj, what=None):
    if what is None:
        if inspect.isclass(obj):
            what = 'class'
        elif inspect.ismodule(obj):
            what = 'module'
        elif callable(obj):
            what = 'function'
        else:
            what = 'object'
    if what == 'class':
        return SphinxClassDoc(obj, '', func_doc=SphinxFunctionDoc)
    elif what in ('function', 'method'):
        return SphinxFunctionDoc(obj, '')
    else:
        return SphinxDocString(pydoc.getdoc(obj))

def mangle_signature(app, what, name, obj, options, sig, retann):
    # Do not try to inspect classes that don't define `__init__`
    if (inspect.isclass(obj) and
        'initializes x; see ' in pydoc.getdoc(obj.__init__)):
        return '', ''

    if not (callable(obj) or hasattr(obj, '__argspec_is_invalid_')): return
    if not hasattr(obj, '__doc__'): return

    doc = SphinxDocString(pydoc.getdoc(obj))
    if doc['Signature']:
        sig = re.sub("^[^(]*", "", doc['Signature'])
        return sig, ''

def initialize(app):
    try:
        app.connect('autodoc-process-signature', mangle_signature)
    except:
        monkeypatch_sphinx_ext_autodoc()

    fn = app.config.numpydoc_phantom_import_file
    if (fn and os.path.isfile(fn)):
        print "[numpydoc] Phantom importing modules from", fn, "..."
        import_phantom_module(fn)

def setup(app):
    app.connect('autodoc-process-docstring', mangle_docstrings)
    app.connect('builder-inited', initialize)
    app.add_config_value('numpydoc_phantom_import_file', None, True)
    app.add_config_value('numpydoc_edit_link', None, True)

    app.add_directive('autosummary', autosummary_directive, 1, (0, 0, False))
    app.add_role('autolink', autolink_role)

#------------------------------------------------------------------------------
# .. autosummary::
#------------------------------------------------------------------------------
from docutils.statemachine import ViewList
from docutils import nodes

import sphinx.addnodes, sphinx.roles
from sphinx.util import patfilter
import posixpath

def autosummary_directive(dirname, arguments, options, content, lineno,
                          content_offset, block_text, state, state_machine):
    """
    Pretty table containing short signatures and summaries of functions etc.

    autosummary also generates a (hidden) toctree:: node.

    """

    # XXX: make the signatures and signature abbreviations optional

    names = []
    names += [x for x in content if x.strip()]

    result, warnings, titles = get_autosummary(names, state.document)

    node = nodes.paragraph()
    state.nested_parse(result, 0, node)

    env = state.document.settings.env
    suffix = env.config.source_suffix
    all_docnames = env.found_docs.copy()
    dirname = posixpath.dirname(env.docname)

    docnames = []
    doctitles = {}
    for name in titles.keys():
        docname = 'generated/' + name
        doctitles[docname] = ""
        doctitles[docname + '.xhtml'] = ""
        if docname.endswith(suffix):
            docname = docname[:-len(suffix)]
        docname = posixpath.normpath(posixpath.join(dirname, docname))
        if docname not in env.found_docs:
            warnings.append(state.document.reporter.warning(
                'toctree references unknown document %r' % docname,
                line=lineno))
        docnames.append(docname)

    tocnode = sphinx.addnodes.toctree()
    tocnode['includefiles'] = docnames
    tocnode['includetitles'] = doctitles
    tocnode['maxdepth'] = -1
    tocnode['glob'] = None

    return warnings + node.children + [tocnode]

def get_autosummary(names, document):
    """
    Generate a proper table node for autosummary:: directive.

    Parameters
    ----------
    names : list of str
        Names of Python objects to be imported and added to the table.
    document : document
        Docutils document object

    """
    result = ViewList()
    warnings = []
    titles = {}

    prefixes = ['']
    prefixes.insert(0, document.settings.env.currmodule)

    rows = []

    for name in names:
        try:
            obj, real_name = import_by_name(name, prefixes=prefixes)
        except ImportError:
            warnings.append(document.reporter.warning(
                'failed to import %s' % name))
            rows.append((":obj:`%s`" % name, ""))
            continue

        doc = get_doc_object(obj)

        if doc['Summary']:
            titles[real_name] = " ".join(doc['Summary'])
        else:
            titles[real_name] = ""

        col1 = ":obj:`%s`" % name
        if doc['Signature']:
            sig = re.sub('^[a-zA-Z_0-9.-]*', '',
                         doc['Signature'].replace('*', r'\*'))
            if '=' in sig:
                # abbreviate optional arguments
                sig = re.sub(r', ([a-zA-Z0-9_]+)=', r'[, \1=', sig, count=1)
                sig = re.sub(r'\(([a-zA-Z0-9_]+)=', r'([\1=', sig, count=1)
                sig = re.sub(r'=[^,)]+,', ',', sig)
                sig = re.sub(r'=[^,)]+\)$', '])', sig)
                # shorten long strings
                sig = re.sub(r'(\[.{16,16}[^,)]*?),.*?\]\)', r'\1, ...])', sig)
            else:
                sig = re.sub(r'(\(.{16,16}[^,)]*?),.*?\)', r'\1, ...)', sig)
            col1 += " " + sig
        col2 = titles[real_name]

        rows.append((col1, col2))

    if not rows:
        return result, warnings, titles

    max_name_len = max([len(x[0]) for x in rows])
    row_fmt = "%%-%ds  %%s" % max_name_len
    table_banner = ('='*max_name_len) + '  ' + '==============='

    result.append(table_banner, '<autosummary>')
    for row in rows:
        result.append(row_fmt % row, '<autosummary>')
    result.append(table_banner, '<autosummary>')
    result.append('', '<autosummary>')

    return result, warnings, titles

def import_by_name(name, prefixes=[None]):
    """
    Import a Python object that has the given name, under one of the prefixes.

    Parameters
    ----------
    name : str
        Name of a Python object, eg. 'numpy.ndarray.view'
    prefixes : list of (str or None), optional
        Prefixes to prepend to the name (None implies no prefix).
        The first prefixed name that results to successful import is used.

    Returns
    -------
    obj
        The imported object
    name
        Name of the imported object (useful if `prefixes` was used)

    """
    for prefix in prefixes:
        try:
            if prefix:
                prefixed_name = '.'.join([prefix, name])
            else:
                prefixed_name = name
            return _import_by_name(prefixed_name), prefixed_name
        except ImportError:
            pass
    raise ImportError

def _import_by_name(name):
    """Import a Python object given its full name"""
    try:
        name_parts = name.split('.')
        last_j = 0
        modname = None
        for j in reversed(range(1, len(name_parts)+1)):
            last_j = j
            modname = '.'.join(name_parts[:j])
            try:
                __import__(modname)
            except ImportError:
                continue
            if modname in sys.modules:
                break

        if last_j < len(name_parts):
            obj = sys.modules[modname]
            for obj_name in name_parts[last_j:]:
                obj = getattr(obj, obj_name)
            return obj
        else:
            return sys.modules[modname]
    except (ValueError, ImportError, AttributeError, KeyError), e:
        raise ImportError(e)

#------------------------------------------------------------------------------
# :autolink: (smart default role)
#------------------------------------------------------------------------------

def autolink_role(typ, rawtext, etext, lineno, inliner,
                  options={}, content=[]):
    """
    Smart linking role.

    Expands to ":obj:`text`" if `text` is an object that can be imported;
    otherwise expands to "*text*".
    """
    r = sphinx.roles.xfileref_role('obj', rawtext, etext, lineno, inliner,
                                   options, content)
    pnode = r[0][0]

    prefixes = [None]
    #prefixes.insert(0, inliner.document.settings.env.currmodule)
    try:
        obj, name = import_by_name(pnode['reftarget'], prefixes)
    except ImportError:
        content = pnode[0]
        r[0][0] = nodes.emphasis(rawtext, content[0].astext(),
                                 classes=content['classes'])
    return r

#------------------------------------------------------------------------------
# Monkeypatch sphinx.ext.autodoc to accept argspecless autodocs (Sphinx < 0.5)
#------------------------------------------------------------------------------

def monkeypatch_sphinx_ext_autodoc():
    global _original_format_signature
    import sphinx.ext.autodoc

    if sphinx.ext.autodoc.format_signature is our_format_signature:
        return

    print "[numpydoc] Monkeypatching sphinx.ext.autodoc ..."
    _original_format_signature = sphinx.ext.autodoc.format_signature
    sphinx.ext.autodoc.format_signature = our_format_signature

def our_format_signature(what, obj):
    r = mangle_signature(None, what, None, obj, None, None, None)
    if r is not None:
        return r[0]
    else:
        return _original_format_signature(what, obj)

#------------------------------------------------------------------------------
# Creating 'phantom' modules from an XML description
#------------------------------------------------------------------------------
import imp, sys, compiler, types

def import_phantom_module(xml_file):
    """
    Insert a fake Python module to sys.modules, based on a XML file.

    The XML file is expected to conform to Pydocweb DTD. The fake
    module will contain dummy objects, which guarantee the following:

    - Docstrings are correct.
    - Class inheritance relationships are correct (if present in XML).
    - Function argspec is *NOT* correct (even if present in XML).
      Instead, the function signature is prepended to the function docstring.
    - Class attributes are *NOT* correct; instead, they are dummy objects.

    Parameters
    ----------
    xml_file : str
        Name of an XML file to read

    """
    import lxml.etree as etree

    object_cache = {}

    tree = etree.parse(xml_file)
    root = tree.getroot()

    # Sort items so that
    # - Base classes come before classes inherited from them
    # - Modules come before their contents
    all_nodes = dict([(n.attrib['id'], n) for n in root])

    def _get_bases(node, recurse=False):
        bases = [x.attrib['ref'] for x in node.findall('base')]
        if recurse:
            j = 0
            while True:
                try:
                    b = bases[j]
                except IndexError: break
                if b in all_nodes:
                    bases.extend(_get_bases(all_nodes[b]))
                j += 1
        return bases

    type_index = ['module', 'class', 'callable', 'object']

    def base_cmp(a, b):
        x = cmp(type_index.index(a.tag), type_index.index(b.tag))
        if x != 0: return x

        if a.tag == 'class' and b.tag == 'class':
            a_bases = _get_bases(a, recurse=True)
            b_bases = _get_bases(b, recurse=True)
            x = cmp(len(a_bases), len(b_bases))
            if x != 0: return x
            if a.attrib['id'] in b_bases: return -1
            if b.attrib['id'] in a_bases: return 1

        return cmp(a.attrib['id'].count('.'), b.attrib['id'].count('.'))

    nodes = root.getchildren()
    nodes.sort(base_cmp)

    # Create phantom items
    for node in nodes:
        name = node.attrib['id']
        doc = (node.text or '').decode('string-escape') + "\n"
        if doc == "\n": doc = ""

        # create parent, if missing
        parent = name
        while True:
            parent = '.'.join(parent.split('.')[:-1])
            if not parent: break
            if parent in object_cache: break
            obj = imp.new_module(parent)
            object_cache[parent] = obj
            sys.modules[parent] = obj

        # create object
        if node.tag == 'module':
            obj = imp.new_module(name)
            obj.__doc__ = doc
            sys.modules[name] = obj
        elif node.tag == 'class':
            bases = [object_cache[b] for b in _get_bases(node)
                     if b in object_cache]
            bases.append(object)
            init = lambda self: None
            init.__doc__ = doc
            obj = type(name, tuple(bases), {'__doc__': doc, '__init__': init})
            obj.__name__ = name.split('.')[-1]
        elif node.tag == 'callable':
            funcname = node.attrib['id'].split('.')[-1]
            argspec = node.attrib.get('argspec')
            if argspec:
                argspec = re.sub('^[^(]*', '', argspec)
                doc = "%s%s\n\n%s" % (funcname, argspec, doc)
            obj = lambda: 0
            obj.__argspec_is_invalid_ = True
            obj.func_name = funcname
            obj.__name__ = name
            obj.__doc__ = doc
            if inspect.isclass(object_cache[parent]):
                obj.__objclass__ = object_cache[parent]
        else:
            class Dummy(object): pass
            obj = Dummy()
            obj.__name__ = name
            obj.__doc__ = doc
            if inspect.isclass(object_cache[parent]):
                obj.__get__ = lambda: None
        object_cache[name] = obj

        if parent:
            if inspect.ismodule(object_cache[parent]):
                obj.__module__ = parent
                setattr(object_cache[parent], name.split('.')[-1], obj)

    # Populate items
    for node in root:
        obj = object_cache.get(node.attrib['id'])
        if obj is None: continue
        for ref in node.findall('ref'):
            if node.tag == 'class':
                if ref.attrib['ref'].startswith(node.attrib['id'] + '.'):
                    setattr(obj, ref.attrib['name'],
                            object_cache.get(ref.attrib['ref']))
            else:
                setattr(obj, ref.attrib['name'],
                        object_cache.get(ref.attrib['ref']))

########NEW FILE########
__FILENAME__ = traitsdoc
import inspect
import os
import pydoc

import docscrape
from docscrape_sphinx import SphinxClassDoc, SphinxFunctionDoc
import numpydoc
import comment_eater

class SphinxTraitsDoc(SphinxClassDoc):
    def __init__(self, cls, modulename='', func_doc=SphinxFunctionDoc):
        if not inspect.isclass(cls):
            raise ValueError("Initialise using a class. Got %r" % cls)
        self._cls = cls

        if modulename and not modulename.endswith('.'):
            modulename += '.'
        self._mod = modulename
        self._name = cls.__name__
        self._func_doc = func_doc

        docstring = pydoc.getdoc(cls)
        docstring = docstring.split('\n')

        # De-indent paragraph
        try:
            indent = min(len(s) - len(s.lstrip()) for s in docstring
                         if s.strip())
        except ValueError:
            indent = 0

        for n,line in enumerate(docstring):
            docstring[n] = docstring[n][indent:]

        self._doc = docscrape.Reader(docstring)
        self._parsed_data = {
            'Signature': '',
            'Summary': '',
            'Description': [],
            'Extended Summary': [],
            'Parameters': [],
            'Returns': [],
            'Raises': [],
            'Warns': [],
            'Other Parameters': [],
            'Traits': [],
            'Methods': [],
            'See Also': [],
            'Notes': [],
            'References': '',
            'Example': '',
            'Examples': '',
            'index': {}
            }

        self._parse()

    def _str_summary(self):
        return self['Summary'] + ['']

    def _str_extended_summary(self):
        return self['Description'] + self['Extended Summary'] + ['']

    def __str__(self, indent=0, func_role="func"):
        out = []
        out += self._str_signature()
        out += self._str_index() + ['']
        out += self._str_summary()
        out += self._str_extended_summary()
        for param_list in ('Parameters', 'Traits', 'Methods',
                           'Returns','Raises'):
            out += self._str_param_list(param_list)
        out += self._str_see_also("obj")
        out += self._str_section('Notes')
        out += self._str_references()
        out += self._str_section('Example')
        out += self._str_section('Examples')
        out = self._str_indent(out,indent)
        return '\n'.join(out)

def looks_like_issubclass(obj, classname):
    """ Return True if the object has a class or superclass with the given class
    name.

    Ignores old-style classes.
    """
    t = obj
    if t.__name__ == classname:
        return True
    for klass in t.__mro__:
        if klass.__name__ == classname:
            return True
    return False

def get_doc_object(obj, what=None):
    if what is None:
        if inspect.isclass(obj):
            what = 'class'
        elif inspect.ismodule(obj):
            what = 'module'
        elif callable(obj):
            what = 'function'
        else:
            what = 'object'
    if what == 'class':
        doc = SphinxTraitsDoc(obj, '', func_doc=numpydoc.SphinxFunctionDoc)
        if looks_like_issubclass(obj, 'HasTraits'):
            for name, trait, comment in comment_eater.get_class_traits(obj):
                # Exclude private traits.
                if not name.startswith('_'):
                    doc['Traits'].append((name, trait, comment.splitlines()))
        return doc
    elif what in ('function', 'method'):
        return numpydoc.SphinxFunctionDoc(obj, '')
    else:
        return numpydoc.SphinxDocString(pydoc.getdoc(obj))

def initialize(app):
    try:
        app.connect('autodoc-process-signature', numpydoc.mangle_signature)
    except:
        numpydoc.monkeypatch_sphinx_ext_autodoc()

    # Monkeypatch numpydoc
    numpydoc.get_doc_object = get_doc_object

    fn = app.config.numpydoc_phantom_import_file
    if (fn and os.path.isfile(fn)):
        print "[numpydoc] Phantom importing modules from", fn, "..."
        numpydoc.import_phantom_module(fn)

def setup(app):
    app.connect('autodoc-process-docstring', numpydoc.mangle_docstrings)
    app.connect('builder-inited', initialize)
    app.add_config_value('numpydoc_phantom_import_file', None, True)
    app.add_config_value('numpydoc_edit_link', None, True)

    app.add_directive('autosummary', numpydoc.autosummary_directive, 1, (0, 0, False))
    app.add_role('autolink', numpydoc.autolink_role)



########NEW FILE########
__FILENAME__ = render_examples
"""
Render the examples to images and adds them to the documentation.
"""

# Standard library imports
import glob
import os
import shutil
import token, tokenize
import textwrap
import itertools

# Enthought imports
from mayavi import mlab

# A global counter, for subsitutions.
global_counter = itertools.count()

EXAMPLE_DIR = '../../examples/mayavi'

def is_mlab_example(filename):
    tokens = tokenize.generate_tokens(file(filename).readline)
    code_only = ''.join([tok_content
                            for tok_type, tok_content, _, _, _  in tokens
                            if not token.tok_name[tok_type] in ('COMMENT',
                                                                'STRING')])
    return ('mlab.show()' in code_only)


def run_mlab_file(filename, image_file):
    ## XXX: Monkey-patch mlab.show, so that we keep control of the
    ## the mainloop
    old_show = mlab.show
    def my_show(func=None):
        pass
    mlab.show = my_show
    mlab.clf()
    e = mlab.get_engine()
    e.close_scene(mlab.gcf())
    execfile(filename, {'__name__': '__main__'})
    mlab.savefig(image_file)
    size = mlab.gcf().scene.get_size()
    for scene in e.scenes:
        e.close_scene(scene)
    mlab.show = old_show


def extract_docstring(filename):
    # Extract a module-level docstring, if any
    lines = file(filename).readlines()
    start_row = 0
    if lines[0].startswith('#!'):
        lines.pop(0)
        start_row = 1

    docstring = ''
    first_par = ''
    tokens = tokenize.generate_tokens(lines.__iter__().next)
    for tok_type, tok_content, _, (erow, _), _ in tokens:
        tok_type = token.tok_name[tok_type]
        if tok_type in ('NEWLINE', 'COMMENT', 'NL', 'INDENT', 'DEDENT'):
            continue
        elif tok_type == 'STRING':
            docstring = eval(tok_content)
            # If the docstring is formatted with several paragraphs, extract
            # the first one:
            paragraphs = '\n'.join(line.rstrip()
                                for line in docstring.split('\n')).split('\n\n')
            if len(paragraphs) > 0:
                first_par = paragraphs[0]
        break
    return docstring, first_par, erow+1+start_row


################################################################################
# class `ExampleLister`
################################################################################
class ExampleLister(object):
    """ Builds a rst-formatted list of examples from a list of files.
    """
    # Header template, for the example gallery.
    header_tpl = """
%(title)s
--------------------------------------------------

%(intro)s

.. toctree::
   :hidden:

%(toctree)s

.. A comment to split paragraphs

"""

    # Template used to create the example rst file
    example_rst_file_tpl = """

.. _example_%(short_file_name)s:

%(title)s example
--------------------------------------------

%(docstring)s

**Python source code:** :download:`%(short_file_name)s.py`

.. literalinclude:: %(short_file_name)s.py
    :lines: %(end_row)s-


    """

    # The title of the corresponding section in the example gallery.
    title = ''

    # The introductory text of the subsection
    intro =''

    def __init__(self, **kwargs):
        # Cheap unique hash for substitutions
        self._unique_hash = global_counter.next()
        for name, value in kwargs.iteritems():
            setattr(self, name, value)


    def render_all(self, stream, file_list):
        """ Render the example list to the given
            stream (file-like object).
        """
        self._stream = stream
        files_details = self.render_header(file_list)
        for index, file_details in enumerate(files_details):
            filename, short_file_name, short_desc, title, docstring, \
                                                    end_row = file_details
            self.render_example_page(file(os.path.join(self.out_dir,
                                            'example_%s.rst') %
                                     short_file_name, 'w'), index, file_details)
            self.gallery_entry(index, file_details)

        del self._stream


    def render_header(self, filenames):
        files_details = list()
        toctree = list()

        for filename in filenames:
            docstring, short_desc, end_row = extract_docstring(filename)
            short_file_name = os.path.basename(filename)[:-3]
            title = short_file_name.replace('_', ' ')
            title = title[0].upper() + title[1:]
            shutil.copy(filename,
                        os.path.join(self.out_dir, os.path.basename(filename)))


            toctree.append("""   example_%s.rst""" % short_file_name)
            files_details.append((filename, short_file_name, short_desc,
                                        title, docstring, end_row))

        toctree = '\n'.join(toctree)

        title = self.title
        intro = self.intro
        self._stream.write(self.header_tpl % locals())
        return files_details


    def render_example_page(self, stream, index, file_details):
        """ Render an individual example page.
        """
        filename, short_file_name, short_desc, title, docstring, end_row \
                                                                = file_details
        stream.write(self.example_rst_file_tpl % locals())


    def gallery_entry(self, index, file_details):
        """ Write the entry in the main example gallery file
            corresponding to the given file details.
        """
        filename, short_file_name, short_desc, title, docstring, \
                                end_row = file_details
        self._stream.write(
                "\n* :ref:`example_%(short_file_name)s`\n" % locals()
            )
        short_desc = short_desc.lstrip().rstrip()
        for line in short_desc.split('\n'):
            self._stream.write(4*" " + line.lstrip() + "\n")


################################################################################
# class `ImagesExampleLister`
################################################################################
class ImagesExampleLister(ExampleLister):
    """ ExampleLister that looks for thumbnails.
    """

    # Relative directory to images
    images_dir = 'mayavi/images/'

    def render_all(self, stream, file_list):
        self._stream = stream
        files_details = self.render_header(file_list)
        unique_hash = self._unique_hash
        for index, (filename, short_file_name, _, _, _, _) in \
                                        enumerate(files_details):
            image_file = os.path.join(self.images_dir,
                        'example_%(short_file_name)s.jpg' % locals())
            if os.path.exists(image_file):
                short_image_file = os.path.join(*(
                                    image_file.split(os.sep)[1:]))
                self._stream.write("""
.. |%(unique_hash)02i%(index)02i| image:: ../%(short_image_file)s
    :width: 150

            """ % locals())
            else:
                self._stream.write("""
.. |%(unique_hash)02i%(index)02i| raw:: html

    <br/>

            """ % locals())

        self._stream.write(2*('\n' + 7*"=" + " " + 45*"="))

        for index, file_details in enumerate(files_details):
            filename, short_file_name, short_desc, title, docstring, end_row = \
                                                                file_details
            self.render_example_page(file(os.path.join(self.out_dir,
                                        'example_%s.rst') %
                                     short_file_name, 'w'), index, file_details)
            self.gallery_entry(index, file_details)

        self._stream.write("\n"+7*"=" + " " + 45*"=" + '\n')

        del self._stream


    def render_example_page(self, stream, index, file_details):
        """ Hijack this method to, optionally, render images.
        """
        # Jump one step up, and do not call ImagesExampleLister
        filename, short_file_name, short_desc, title, docstring, end_row = \
                                                                file_details
        image_file = os.path.join(self.images_dir,
                        'example_%(short_file_name)s.jpg' % locals())
        if os.path.exists(image_file):
            docstring += """

.. image:: ../%s
    :align: center

""" % os.path.join(*(image_file.split(os.sep)[1:]))

        file_details = \
            filename, short_file_name, short_desc, title, docstring, end_row

        stream.write(self.example_rst_file_tpl % locals())



    def gallery_entry(self, index, file_details):
        filename, short_file_name, short_desc, title, docstring, end_row = \
                                                                file_details
        short_desc = textwrap.wrap(short_desc, width=40)
        unique_hash = self._unique_hash
        self._stream.write(
                ("\n|%(unique_hash)02i%(index)02i|" % locals()).ljust(9) +
                ":ref:`example_%(short_file_name)s`\n" % locals()
            )
        for line in short_desc:
            self._stream.write(9*" " + line.lstrip() + "\n")

################################################################################
# class `MlabExampleLister`
################################################################################
class MlabExampleLister(ImagesExampleLister):

    header_tpl = """
Mlab functions gallery
----------------------

These are the examples of the mlab plotting functions. They are
copied out here for convenience. Please refer to the corresponding
section of the user guide for more information (
:ref:`mlab_plotting_functions`).

.. currentmodule:: mayavi.mlab

+------------------+-------------------------+---------------------+
| :func:`plot3d`   | :func:`points3d`        | :func:`imshow`      |
|                  |                         |                     |
| |plot3d.jpg|     | |points3d.jpg|          | |imshow.jpg|        |
+------------------+-------------------------+---------------------+
| :func:`surf`     | :func:`contour_surf`    | :func:`mesh`        |
|                  |                         |                     |
| |surf.jpg|       | |contour_surf.jpg|      | |mesh.jpg|          |
+------------------+-------------------------+---------------------+
| :func:`barchart` | :func:`triangular_mesh` | :func:`contour3d`   |
|                  |                         |                     |
| |barchart.jpg|   | |triangular_mesh.jpg|   | |contour3d.jpg|     |
+------------------+-------------------------+---------------------+
| :func:`quiver3d` | :func:`flow`            |                     |
|                  |                         |                     |
| |quiver3d.jpg|   |  |flow.jpg|             |                     |
+------------------+-------------------------+---------------------+

.. |plot3d.jpg| image:: ../generated_images/enthought_mayavi_mlab_plot3d.jpg
     :width: 150

.. |points3d.jpg| image:: ../generated_images/enthought_mayavi_mlab_points3d.jpg
     :width: 150

.. |imshow.jpg| image:: ../generated_images/enthought_mayavi_mlab_imshow.jpg
     :width: 150

.. |contour_surf.jpg| image:: ../generated_images/enthought_mayavi_mlab_contour_surf.jpg
     :width: 150

.. |triangular_mesh.jpg| image:: ../generated_images/enthought_mayavi_mlab_triangular_mesh.jpg
     :width: 150

.. |surf.jpg| image:: ../generated_images/enthought_mayavi_mlab_surf.jpg
     :width: 150

.. |mesh.jpg| image:: ../generated_images/enthought_mayavi_mlab_mesh.jpg
     :width: 150

.. |barchart.jpg| image:: ../generated_images/enthought_mayavi_mlab_barchart.jpg
     :width: 150

.. |contour3d.jpg| image:: ../generated_images/enthought_mayavi_mlab_contour3d.jpg
     :width: 150

.. |quiver3d.jpg| image:: ../generated_images/enthought_mayavi_mlab_quiver3d.jpg
     :width: 150

.. |flow.jpg| image:: ../generated_images/enthought_mayavi_mlab_flow.jpg
     :width: 150



Advanced mlab examples
-----------------------

.. toctree::
   :hidden:

%(toctree)s

"""

    example_rst_file_tpl = """

.. _example_%(short_file_name)s:

%(title)s example
--------------------------------------------------------------------

%(docstring)s

**Python source code:** :download:`%(short_file_name)s.py`

.. literalinclude:: %(short_file_name)s.py
    :lines: %(end_row)s-


    """

    render_images = False

    images_dir = 'mayavi/generated_images'

    def render_example_page(self, stream, index, file_details):
        """ Hijack this method to, optionally, render images.
        """
        filename, short_file_name, short_desc, title, docstring, end_row = \
                                                            file_details
        if self.render_images:
            print "Generating images for %s" % filename
            image_file = os.path.join(self.images_dir, 'example_%s.jpg' \
                                    % short_file_name)
            run_mlab_file(filename, image_file=image_file)
        ImagesExampleLister.render_example_page(self, stream,
                                                index, file_details)



################################################################################
# Main entry point
def render_examples(render_images=False, out_dir='mayavi/auto'):
    if not os.path.exists(out_dir):
        os.makedirs(out_dir)
    example_gallery_file = file(os.path.join(out_dir, 'examples.rst'), 'w')

    example_gallery_file.write("""

.. _example_gallery:

Example gallery
=================

""")

    ##########################################################################
    # Mlab examples
    example_files = [ filename
                    for filename in glob.glob(os.path.join(EXAMPLE_DIR,
                        'mlab', '*.py'))
                    if is_mlab_example(filename)]
    # Sort by file length (gives a measure of the complexity of the
    # example)
    example_files.sort(key=lambda name: len(file(name, 'r').readlines()))

    mlab_example_lister = MlabExampleLister(render_images=render_images,
                                        out_dir=out_dir,
                                        images_dir='mayavi/generated_images')
    if render_images:
        pass
        # XXX: Add logics to deal with rerendering examples cleverly

    mlab_example_lister.render_all(example_gallery_file, example_files)

    ##########################################################################
    # Interactive application examples
    example_files = [ filename
                    for filename in glob.glob(os.path.join(EXAMPLE_DIR,
                        'interactive', '*.py'))]
    # Sort by file length (gives a measure of the complexity of the
    # example)
    example_files.sort(key=lambda name: len(file(name, 'r').readlines()))
    example_lister = ImagesExampleLister(
            title="Interactive examples",
            out_dir=out_dir,
            intro="""

Examples showing how to use the interactive features of Mayavi, either
via the mayavi2 application, or via specially-crafted dialogs and
applications.
    """)
    example_lister.render_all(example_gallery_file, example_files)

    ##########################################################################
    # Advanced visualization examples
    example_files = [ filename
                    for filename in glob.glob(os.path.join(EXAMPLE_DIR,
                        'advanced_visualization', '*.py'))]
    # Sort by file length (gives a measure of the complexity of the
    # example)
    example_files.sort(key=lambda name: len(file(name, 'r').readlines()))
    example_lister = ExampleLister(
            title="Advanced visualization examples",
            out_dir=out_dir,
            intro="""
Data visualization using the core Mayavi API, object-oriented, and with
more fine control than mlab.

    """)
    example_lister.render_all(example_gallery_file, example_files)

    ##########################################################################
    # Data interaction examples
    example_files = [ filename
                    for filename in glob.glob(os.path.join(EXAMPLE_DIR,
                        'data_interaction', '*.py'))]
    # Sort by file length (gives a measure of the complexity of the
    # example)
    example_files.sort(key=lambda name: len(file(name, 'r').readlines()))
    example_lister = ExampleLister(
            title="Data interaction examples",
            out_dir=out_dir,
            intro="""
Examples showing how you can query and interact with the data.

    """)
    example_lister.render_all(example_gallery_file, example_files)

    ##########################################################################
    # The remaining files
    example_files = [ filename
                    for filename in glob.glob(os.path.join(EXAMPLE_DIR,
                        '*.py'))]
    # Sort by file length (gives a measure of the complexity of the
    # example)
    example_files.sort(key=lambda name: len(file(name, 'r').readlines()))
    example_lister = ExampleLister(title="Misc examples",
                                   out_dir=out_dir)
    example_lister.render_all(example_gallery_file, example_files)



if __name__ == '__main__':
    render_examples()
    import shutil
    shutil.copyfile('../CHANGES.txt', './mayavi/auto/changes.rst')

########NEW FILE########
__FILENAME__ = render_images
"""
Script to render the images for the Mayavi user guide.

This scipts requires image magic to be installed.

"""
# Author: Gael Varoquaux <gael dot varoquaux at normalesup dot org>
# Copyright (c) 2007, Enthought, Inc.
# License: BSD Style.


import os
from mayavi import mlab
from mayavi.scripts import mayavi2

from inspect import getmembers

IMAGE_DIR = os.path.join(os.path.dirname(os.path.abspath(__file__)),
                                    'mayavi', 'generated_images')

#############################################################################
def capture_image(func, filename):
    """ Runs a function doing some mayavi drawing and save the resulting
        scene to a file.
    """
    mlab.clf()
    func()
    if not filename[-4:] in ('.jpg', '.png'):
        filename = '%s.jpg' % filename
    mlab.savefig(filename , size=(400, 400) )
    os.system('convert %s -trim %s' % (filename, filename))


def illustrate_module(module, directory=IMAGE_DIR):
    """ Uses the test functions of the modules (discovery ala nose) to
        create images for each function tested.
    """
    for name, func in getmembers(module):
        if not callable(func) or not name.lower().startswith('test'):
            continue
        if name.lower().endswith('anim'):
            continue
        # LaTeX doesn't like '.' in filename (sucks), so we replace them.
        filename = directory + os.sep + module.__name__.replace('.', '_') \
                        + '_' + name[5:]
        capture_image(func, filename=filename)

#############################################################################
# Entry point
@mlab.show
def main():
    mlab.figure(bgcolor=(1, 1, 1), fgcolor=(0, 0, 0), size=(400, 400))
    print "Generating the mlab images..."
    illustrate_module(mlab)
    mayavi2.close()
    print "Done generating the mlab images"
    print "Generating the example pages"
    from render_examples import render_examples
    render_examples(render_images=True)
    print "Done generating the example pages"

if __name__ == '__main__':
    main()


########NEW FILE########
__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# tvtk documentation build configuration file, created by
# sphinx-quickstart on Wed Jul 23 12:38:58 2008.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# The contents of this file are pickled, so don't put values in the namespace
# that aren't pickleable (module imports are okay, they're removed automatically).
#
# All configuration values have a default value; values that are commented out
# serve to show the default value.

import sys, os

# If your extensions are in another directory, add it here. If the directory
# is relative to the documentation root, use os.path.abspath to make it
# absolute, like shown here.
#sys.path.append(os.path.abspath('some/directory'))

# General configuration
# ---------------------

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = []

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.txt'

# The master toctree document.
master_doc = 'index'

# General substitutions.
project = 'tvtk'
copyright = '2008-2014, Enthought Inc.'

# The default replacements for |version| and |release|, also used in various
# other places throughout the built documents.
d = {}
execfile(os.path.join('..', '..', '..', 'mayavi', '__init__.py'), d)
version = release = d['__version__']

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
today_fmt = '%B %d, %Y'

# List of documents that shouldn't be included in the build.
#unused_docs = []

# List of directories, relative to source directories, that shouldn't be searched
# for source files.
#exclude_dirs = []

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'


# Options for HTML output
# -----------------------

# The style sheet to use for HTML and HTML Help pages. A file of that name
# must exist either in Sphinx' static/ path, or in one of the custom paths
# given in html_static_path.
html_style = 'default.css'

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (within the static path) to place at the top of
# the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_use_modindex = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, the reST sources are included in the HTML build as _sources/<name>.
#html_copy_source = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# If nonempty, this is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = ''

# Output file base name for HTML help builder.
htmlhelp_basename = 'tvtkdoc'


# Options for LaTeX output
# ------------------------

# The paper size ('letter' or 'a4').
#latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
#latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, document class [howto/manual]).
latex_documents = [
  ('index', 'tvtk.tex', 'tvtk Documentation', 'tvtk', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# Additional stuff for the LaTeX preamble.
#latex_preamble = ''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_use_modindex = True

########NEW FILE########
__FILENAME__ = contour
#!/usr/bin/env python
"""
This script demonstrates how one can script Mayavi and use its
contour related modules.

"""
# Author: Prabhu Ramachandran <prabhu_r@users.sf.net>
# Copyright (c) 2005-2008, Enthought, Inc.
# License: BSD Style.

# Standard library imports
from os.path import join, abspath, dirname

# Enthought library imports
from mayavi.scripts import mayavi2
from mayavi.sources.vtk_file_reader import VTKFileReader
from mayavi.modules.outline import Outline
from mayavi.modules.grid_plane import GridPlane
from mayavi.modules.contour_grid_plane import ContourGridPlane
from mayavi.modules.iso_surface import IsoSurface
from mayavi.modules.scalar_cut_plane import ScalarCutPlane

@mayavi2.standalone
def contour():
    """The script itself.  We needn't have defined a function but
    having a function makes this more reusable.
    """
    # 'mayavi' is always defined on the interpreter.
    # Create a new scene.
    mayavi.new_scene()

    # Read a VTK (old style) data file.
    r = VTKFileReader()
    filename = join(mayavi2.get_data_dir(dirname(abspath(__file__))),
                    'heart.vtk')
    r.initialize(filename)
    mayavi.add_source(r)

    # Create an outline for the data.
    o = Outline()
    mayavi.add_module(o)

    # Create three simple grid plane modules.
    # First normal to 'x' axis.
    gp = GridPlane()
    mayavi.add_module(gp)
    # Second normal to 'y' axis.
    gp = GridPlane()
    mayavi.add_module(gp)
    gp.grid_plane.axis = 'y'
    # Third normal to 'z' axis.
    gp = GridPlane()
    mayavi.add_module(gp)
    gp.grid_plane.axis = 'z'

    # Create one ContourGridPlane normal to the 'x' axis.
    cgp = ContourGridPlane()
    mayavi.add_module(cgp)
    # Set the position to the middle of the data.
    cgp.grid_plane.position = 15

    # Another with filled contours normal to 'y' axis.
    cgp = ContourGridPlane()
    mayavi.add_module(cgp)
    # Set the axis and position to the middle of the data.
    cgp.grid_plane.axis = 'y'
    cgp.grid_plane.position = 15
    cgp.contour.filled_contours = True

    # An isosurface module.
    iso = IsoSurface(compute_normals=True)
    mayavi.add_module(iso)
    iso.contour.contours = [220.0]

    # An interactive scalar cut plane.
    cp = ScalarCutPlane()
    mayavi.add_module(cp)
    cp.implicit_plane.normal = 0,0,1


if __name__ == '__main__':
    contour()

########NEW FILE########
__FILENAME__ = contour_contour
#!/usr/bin/env python
"""This example shows how you can produce contours on an IsoSurface.
"""
# Author: Prabhu Ramachandran <prabhu [at] aero . iitb . ac . in>
# Copyright (c) 2008,  Enthought, Inc.
# License: BSD Style.

# Standard library imports
from os.path import join, abspath, dirname

# Mayavi imports.
from mayavi.scripts import mayavi2
from mayavi.sources.api import VTKXMLFileReader
from mayavi.filters.contour import Contour
from mayavi.filters.api import PolyDataNormals
from mayavi.filters.set_active_attribute import SetActiveAttribute
from mayavi.modules.api import Surface, Outline

@mayavi2.standalone
def main():
    mayavi.new_scene()

    # Read the example data: fire_ug.vtu.
    r = VTKXMLFileReader()
    filename = join(mayavi2.get_data_dir(dirname(abspath(__file__))),
                    'fire_ug.vtu')
    r.initialize(filename)
    mayavi.add_source(r)
    # Set the active point scalars to 'u'.
    r.point_scalars_name = 'u'

    # Simple outline for the data.
    o = Outline()
    mayavi.add_module(o)

    # Branch the pipeline with a contour -- the outline above is
    # directly attached to the source whereas the contour below is a
    # filter and will branch the flow of data.   An isosurface in the
    # 'u' data attribute is generated and normals generated for it.

    c = Contour()
    mayavi.add_filter(c)
    n = PolyDataNormals()
    mayavi.add_filter(n)

    # Now we want to show the temperature 't' on the surface of the 'u'
    # iso-contour.  This is easily done by using the SetActiveAttribute
    # filter below.

    aa = SetActiveAttribute()
    mayavi.add_filter(aa)
    aa.point_scalars_name = 't'

    # Now view the iso-contours of 't' with a Surface filter.
    s = Surface(enable_contours=True)
    mayavi.add_module(s)


if __name__ == "__main__":
    main()


########NEW FILE########
__FILENAME__ = datasets
"""
A Mayavi example to show the different data sets. See
:ref:`data-structures-used-by-mayavi` for a discussion.

The following images are created:

.. hlist::

    * **ImageData**

      .. image:: ../image_data.jpg
            :scale: 50

    * **RectilinearGrid**

      .. image:: ../rectilinear_grid.jpg
            :scale: 50

    * **StructuredGrid**

      .. image:: ../structured_grid.jpg
            :scale: 50

    * **UnstructuredGrid**

      .. image:: ../unstructured_grid.jpg
            :scale: 50

"""
# Author: Gael Varoquaux <gael dot varoquaux at normalesup.org>
# Copyright (c) 2008, Enthought, Inc.
# License: BSD style.

from numpy import array, random, linspace, pi, ravel, cos, sin, empty
from tvtk.api import tvtk

from mayavi.sources.vtk_data_source import VTKDataSource

from mayavi import mlab


def image_data():
    data = random.random((3, 3, 3))
    i = tvtk.ImageData(spacing=(1, 1, 1), origin=(0, 0, 0))
    i.point_data.scalars = data.ravel()
    i.point_data.scalars.name = 'scalars'
    i.dimensions = data.shape
    return i


def rectilinear_grid():
    data = random.random((3, 3, 3))
    r = tvtk.RectilinearGrid()
    r.point_data.scalars = data.ravel()
    r.point_data.scalars.name = 'scalars'
    r.dimensions = data.shape
    r.x_coordinates = array((0, 0.7, 1.4))
    r.y_coordinates = array((0, 1, 3))
    r.z_coordinates = array((0, .5, 2))
    return r


def generate_annulus(r, theta, z):
    """ Generate points for structured grid for a cylindrical annular
        volume.  This method is useful for generating a unstructured
        cylindrical mesh for VTK (and perhaps other tools).
    """
    # Find the x values and y values for each plane.
    x_plane = (cos(theta)*r[:,None]).ravel()
    y_plane = (sin(theta)*r[:,None]).ravel()

    # Allocate an array for all the points.  We'll have len(x_plane)
    # points on each plane, and we have a plane for each z value, so
    # we need len(x_plane)*len(z) points.
    points = empty([len(x_plane)*len(z),3])

    # Loop through the points for each plane and fill them with the
    # correct x,y,z values.
    start = 0
    for z_plane in z:
        end = start+len(x_plane)
        # slice out a plane of the output points and fill it
        # with the x,y, and z values for this plane.  The x,y
        # values are the same for every plane.  The z value
        # is set to the current z
        plane_points = points[start:end]
        plane_points[:,0] = x_plane
        plane_points[:,1] = y_plane
        plane_points[:,2] = z_plane
        start = end

    return points


def structured_grid():
    # Make the data.
    dims = (3, 4, 3)
    r = linspace(5, 15, dims[0])
    theta = linspace(0, 0.5*pi, dims[1])
    z = linspace(0, 10, dims[2])
    pts = generate_annulus(r, theta, z)
    sgrid = tvtk.StructuredGrid(dimensions=(dims[1], dims[0], dims[2]))
    sgrid.points = pts
    s = random.random((dims[0]*dims[1]*dims[2]))
    sgrid.point_data.scalars = ravel(s.copy())
    sgrid.point_data.scalars.name = 'scalars'
    return sgrid


def unstructured_grid():
    points = array([[0,1.2,0.6], [1,0,0], [0,1,0], [1,1,1], # tetra
                    [1,0,-0.5], [2,0,0], [2,1.5,0], [0,1,0],
                    [1,0,0], [1.5,-0.2,1], [1.6,1,1.5], [1,1,1], # Hex
                    ], 'f')
    # The cells
    cells = array([4, 0, 1, 2, 3, # tetra
                   8, 4, 5, 6, 7, 8, 9, 10, 11 # hex
                   ])
    # The offsets for the cells, i.e. the indices where the cells
    # start.
    offset = array([0, 5])
    tetra_type = tvtk.Tetra().cell_type # VTK_TETRA == 10
    hex_type = tvtk.Hexahedron().cell_type # VTK_HEXAHEDRON == 12
    cell_types = array([tetra_type, hex_type])
    # Create the array of cells unambiguously.
    cell_array = tvtk.CellArray()
    cell_array.set_cells(2, cells)
    # Now create the UG.
    ug = tvtk.UnstructuredGrid(points=points)
    # Now just set the cell types and reuse the ug locations and cells.
    ug.set_cells(cell_types, offset, cell_array)
    scalars = random.random(points.shape[0])
    ug.point_data.scalars = scalars
    ug.point_data.scalars.name = 'scalars'
    return ug


def polydata():
    # The numpy array data.
    points = array([[0,-0.5,0], [1.5,0,0], [0,1,0], [0,0,0.5],
                    [-1,-1.5,0.1], [0,-1, 0.5], [-1, -0.5, 0],
                    [1,0.8,0]], 'f')
    triangles = array([[0,1,3], [1,2,3], [1,0,5],
                       [2,3,4], [3,0,4], [0,5,4], [2, 4, 6],
                        [2, 1, 7]])
    scalars = random.random(points.shape)

    # The TVTK dataset.
    mesh = tvtk.PolyData(points=points, polys=triangles)
    mesh.point_data.scalars = scalars
    mesh.point_data.scalars.name = 'scalars'
    return mesh


def view(dataset):
    """ Open up a mayavi scene and display the dataset in it.
    """
    fig = mlab.figure(bgcolor=(1, 1, 1), fgcolor=(0, 0, 0),
                      figure=dataset.class_name[3:])
    surf = mlab.pipeline.surface(dataset, opacity=0.1)
    mlab.pipeline.surface(mlab.pipeline.extract_edges(surf),
                            color=(0, 0, 0), )


@mlab.show
def main():
    view(image_data())
    view(rectilinear_grid())
    view(structured_grid())
    view(unstructured_grid())
    view(polydata())

if __name__ == '__main__':
    main()


########NEW FILE########
__FILENAME__ = delaunay_graph
"""
An example illustrating graph manipulation and display with Mayavi
and NetworkX.

This example shows how to use Mayavi in a purely algorithmic way, to
compute a Delaunay from data points, extract it and pass it to networkx.
It also shows how to plot a graph using quiver.

Starting from points positioned regularly on a sphere, we first use VTK
to create the Delaunay graph, and also to plot it. We then create a
matching NetworkX graph, calling it's minimum spanning tree function. We
display it using Mayavi.

The visualization clearly shows that the minimum spanning tree of the
points, considering all possible connections, is included in the Delaunay
graph.

_____

The function `compute_delaunay_edges` uses VTK to retrieve the Delaunay
graph of a set of points. First a structure of unconnected points is
created using `mlab.points3d`. The Delaunay filter applied to it builds
an unstructured grid (see :ref:`data-structures-used-by-mayavi`). We
apply an ExtractEdges filter to it, which returns a structure of points
connected by edges: the :ref:`PolyData structure <poly_data>`. The
dataset structure can be retrieved as the first item of the `outputs`
list of the ExtractEdges filter object, returned by the
`mlab.pipeline.extract_edges` factory function. Once we have this object,
we extract the points and edge list from it. This graph-plotting
technique differs from the technique used in the examples
:ref:`example_protein` and :ref:`example_flight_graph` where points are
created and connected by lines. Unlike these techniques, it enables
storing scalar data on each line.

_____

To visualize the graph (function `graph_plot`), we build a list of
vectors giving the edges, and use `mlab.quiver3d` to display them. To
display an unoriented graph, it is best to use the `2ddash` mode of
`quiver3d`.

"""
# Author: Gary Ruben
#         Gael Varoquaux <gael dot varoquaux at normalesup dot org>
# Copyright (c) 2009, Enthought, Inc.
# License: BSD style.

from mayavi import mlab
import numpy as np
import networkx as nx

def compute_delaunay_edges(x, y, z, visualize=False):
    """ Given 3-D points, returns the edges of their
        Delaunay triangulation.

        Parameters
        -----------
        x: ndarray
            x coordinates of the points
        y: ndarray
            y coordinates of the points
        z: ndarray
            z coordinates of the points

        Returns
        ---------
        new_x: ndarray
            new x coordinates of the points (same coords but different
            assignment of points)
        new_y: ndarray
            new y coordinates of the points (same coords but different
            assignment of points)
        new_z: ndarray
            new z coordinates of the points (same coords but different
            assignment of points)
        edges: 2D ndarray.
            The indices of the edges of the Delaunay triangulation as a
            (N, 2) array [[pair1_index1, pair1_index2],
                          [pair2_index1, pair2_index2],
                          ...                         ]
    """
    if visualize:
        vtk_source = mlab.points3d(x, y, z, opacity=0.3, mode='2dvertex')
        vtk_source.actor.property.point_size = 3
    else:
        vtk_source =  mlab.pipeline.scalar_scatter(x, y, z, figure=False)
    delaunay =  mlab.pipeline.delaunay3d(vtk_source)
    delaunay.filter.offset = 999    # seems more reliable than the default
    edges = mlab.pipeline.extract_edges(delaunay)
    if visualize:
        mlab.pipeline.surface(edges, opacity=0.3, line_width=3)

    # We extract the output array. the 'points' attribute itself
    # is a TVTK array, that we convert to a numpy array using
    # its 'to_array' method.
    new_x, new_y, new_z = edges.outputs[0].points.to_array().T
    lines = edges.outputs[0].lines.to_array()
    return new_x, new_y, new_z, np.array([lines[1::3], lines[2::3]]).T


def graph_plot(x, y, z, start_idx, end_idx, edge_scalars=None, **kwargs):
    """ Show the graph edges using Mayavi

        Parameters
        -----------
        x: ndarray
            x coordinates of the points
        y: ndarray
            y coordinates of the points
        z: ndarray
            z coordinates of the points
        edge_scalars: ndarray, optional
            optional data to give the color of the edges.
        kwargs:
            extra keyword arguments are passed to quiver3d.
    """
    vec = mlab.quiver3d(x[start_idx],
                        y[start_idx],
                        z[start_idx],
                        x[end_idx] - x[start_idx],
                        y[end_idx] - y[start_idx],
                        z[end_idx] - z[start_idx],
                        scalars=edge_scalars,
                        mode='2ddash',
                        scale_factor=1,
                        **kwargs)
    if edge_scalars is not None:
        vec.glyph.color_mode = 'color_by_scalar'
    return vec


def build_geometric_graph(x, y, z, edges):
    """ Build a NetworkX graph with xyz node coordinates and the node indices
        of the end nodes.

        Parameters
        -----------
        x: ndarray
            x coordinates of the points
        y: ndarray
            y coordinates of the points
        z: ndarray
            z coordinates of the points
        edges: the (2, N) array returned by compute_delaunay_edges()
            containing node indices of the end nodes. Weights are applied to
            the edges based on their euclidean length for use by the MST
            algorithm.

        Returns
        ---------
        g: A NetworkX undirected graph

        Notes
        ------
        We don't bother putting the coordinates into the NX graph.
        Instead the graph node is an index to the column.
    """
    xyz = np.array((x, y, z))
    def euclidean_dist(i, j):
        d = xyz[:,i] - xyz[:,j]
        return np.sqrt(np.dot(d, d))

    g = nx.Graph()
    for i, j in edges:
        if nx.__version__.split('.')[0] > '0':
            g.add_edge(i, j, weight=euclidean_dist(i, j))
        else:
            g.add_edge(i, j, euclidean_dist(i, j))
    return g


def points_on_sphere(N):
    """ Generate N evenly distributed points on the unit sphere centered at
        the origin. Uses the 'Golden Spiral'.
        Code by Chris Colbert from the numpy-discussion list.
    """
    phi = (1 + np.sqrt(5)) / 2  # the golden ratio
    long_incr = 2*np.pi / phi   # how much to increment the longitude

    dz = 2.0 / float(N)         # a unit sphere has diameter 2
    bands = np.arange(N)        # each band will have one point placed on it
    z = bands * dz - 1 + (dz/2) # the height z of each band/point
    r = np.sqrt(1 - z*z)        # project onto xy-plane
    az = bands * long_incr      # azimuthal angle of point modulo 2 pi
    x = r * np.cos(az)
    y = r * np.sin(az)
    return x, y, z


################################################################################
if __name__ == '__main__':
    # generate some points
    x, y, z = points_on_sphere(50)
    # Avoid triangulation problems on the sphere
    z *= 1.01

    mlab.figure(1, bgcolor=(0,0,0))
    mlab.clf()

    # Now get the Delaunay Triangulation from vtk via mayavi mlab. Vtk stores
    # its points in a different order so overwrite ours to match the edges
    new_x, new_y, new_z, edges = compute_delaunay_edges(x, y, z, visualize=True)
    assert(x.shape == new_x.shape)   # check triangulation got everything
    x, y, z = new_x, new_y, new_z

    if nx.__version__ < '0.99':
        raise ImportError('The version of NetworkX must be at least '
                    '0.99 to run this example')

    # Make a NetworkX graph out of our point and edge data
    g = build_geometric_graph(x, y, z, edges)

    # Compute minimum spanning tree using networkx
    # nx.mst returns an edge generator
    edges = nx.minimum_spanning_tree(g).edges(data=True)
    start_idx, end_idx, _ = np.array(list(edges)).T
    start_idx = start_idx.astype(np.int)
    end_idx   = end_idx.astype(np.int)

    # Plot this with Mayavi
    graph_plot(x, y, z, start_idx, end_idx,
                edge_scalars=z[start_idx],
                opacity=0.8,
                colormap='summer',
                line_width=4,
                )

    mlab.view(60, 46, 4)
    mlab.show()

########NEW FILE########
__FILENAME__ = glyph
#!/usr/bin/env python
"""
This script demonstrates using the Mayavi core API to add a VectorCutPlane,
split the pipeline using a MaskPoints filter and then view the filtered data
with the Glyph module.
"""
# Author: Prabhu Ramachandran <prabhu_r@users.sf.net>
# Copyright (c) 2005-2008, Enthought, Inc.
# License: BSD Style.

# Standard library imports
from os.path import join, abspath, dirname

# Enthought library imports
from mayavi.scripts import mayavi2
from mayavi.sources.vtk_xml_file_reader import VTKXMLFileReader
from mayavi.modules.outline import Outline
from mayavi.modules.glyph import Glyph
from mayavi.modules.vector_cut_plane import VectorCutPlane
from mayavi.filters.mask_points import MaskPoints

@mayavi2.standalone
def glyph():
    """The script itself.  We needn't have defined a function but
    having a function makes this more reusable.
    """
    # 'mayavi' is always defined on the interpreter.
    # Create a new VTK scene.
    mayavi.new_scene()

    # Read a VTK (old style) data file.
    r = VTKXMLFileReader()
    r.initialize(join(mayavi2.get_data_dir(dirname(abspath(__file__))),
                      'fire_ug.vtu'))
    mayavi.add_source(r)

    # Create an outline and a vector cut plane.
    mayavi.add_module(Outline())

    v = VectorCutPlane()
    mayavi.add_module(v)
    v.glyph.color_mode = 'color_by_scalar'

    # Now mask the points and show glyphs (we could also use
    # Vectors but glyphs are a bit more generic)
    m = MaskPoints()
    m.filter.set(on_ratio=10, random_mode=True)
    mayavi.add_filter(m)

    g = Glyph()
    mayavi.add_module(g)
    # Note that this adds the module to the filtered output.
    g.glyph.scale_mode = 'scale_by_vector'
    # Use arrows to view the scalars.
    gs = g.glyph.glyph_source
    gs.glyph_source = gs.glyph_dict['arrow_source']


if __name__ == '__main__':
    glyph()

########NEW FILE########
__FILENAME__ = image_cursor_filter
"""
Excample using the UserDefined filter to paint a cross-shaped cursor on data,
in order to point out a special position.

We use the UserDefined filter `ImageCursor3D` to create the cursor. A Gaussian
data field is painted with the cursor, and then visualized using the
ImagePlaneWIdget module.

ImageCursor3D is one example among many of the use of the UserDefined, which
allows to use TVTK filters that are not. See :ref:`using_userdefined_filter`
for more details. Also, other examples using the UserDefined filter are
provided in :ref:`example_mri` and :ref:`example_tvtk_segmentation`.

Selecting the UserDefined filter in the Mayavi pipeline is a convenient
way to look for additional filters. This pops up a dialog called `TVTK
class chooser`, with a `Search` field that allows to search for desired
actions or properties. For example, searching for `cursor` returns
several filters, among which Cursor3D and ImageCursor3D. As a rule of
thumb, the name of TVTK filters acting on TVTK ImageData dataset starts
with `Image` (ImageData is the type of VTK data set created by e.g.
mlab.pipeline.scalar_field. See :ref:`data-structures-used-by-mayavi` for
more details about VTK datasets). In the dialog used to interactively
add the UserDefined filet, we can therefore select `ImageCursor3D`.
The documentation of the filter is displayed when selecting its name
within the `Class name` field of the dialog.
"""

# Authors: Emmanuelle Gouillart <emmanuelle.gouillart@normalesup.org>
# and Gael Varoquaux <gael.varoquaux@normalesup.org>
# Copyright (c) 2009, Enthought, Inc.
# License: BSD Style.


from mayavi import mlab
import numpy as np

# Define Gaussian data field
x, y, z = np.ogrid[0:1:40j, 0:1:40j, 0:1:40j]
sig = 0.5
center = 0.5
g = np.exp(-((x-center)**2 + (y-center)**2 + (z-center)**2)/(2*sig**2))

################################################################################

mlab.figure(fgcolor=(0, 0, 0), bgcolor=(1, 1, 1))

# Define the cursor
s = mlab.pipeline.scalar_field(g)
cursor = mlab.pipeline.user_defined(s, filter='ImageCursor3D')

# The TVTK filter used by Mayavi is accessible as the '.filter'
# attribute of the Mayavi filtered returned by user_defined.
# We can set the graphical properties of the cross via attributes of
# cursor.filter, and not of cursor itself. Here cursor is a Mayavi filter,
# that is an object that inserts in the Mayavi pipeline, whereas
# cursor.filter is the TVTK filter that actually does the work.

# Put the cursor at the center of the field volume (default is (0, 0, 0))
cursor.filter.cursor_position = np.array([20, 20, 20])
# Define the value of the cursor (default is 255) so that there is
# enough contrast between the cursor and the data values in the neighbourhood
# of the cursor. The cursor value is within the data value range so that
# the contrast of the data is not altered.
cursor.filter.cursor_value = 0
# Define the radius of the cross (the extent of the cross is 2xcursor_radius)
cursor.filter.cursor_radius = 10


# Display data and cursor using an image_plane_widget that intersects the
# cursor.
ipw = mlab.pipeline.image_plane_widget(cursor, plane_orientation='x_axes',
            slice_index=20)

# View
mlab.colorbar()
mlab.view(15, 70, 100, [20, 20, 20])
mlab.show()

########NEW FILE########
__FILENAME__ = magnetic_field
"""
An example mixing numerical caculation and 3D visualization of the
magnetic field created by an arbitrary number of current loops.

The goal of this example is to show how Mayavi can be used with scipy to
debug and understand physics and electromagnetics computation.

The field is caculated for an arbitrary number of current loops using the
corresponding exact formula. The coils are plotted in 3D with a synthetic
view of the magnetic_field. A VectorCutPlane is used as it enables good
inspection of the magnetic field.

This example originated from a real-life case of coil design in Python (
Atomic sources for long-time-of-flight interferometric inertial sensors,
G. Varoquaux, http://tel.archives-ouvertes.fr/tel-00265714/, page 148).

For another visualization of magnetic field, see the
:ref:`example_magnetic_field_lines`.
"""
# Author: Gael Varoquaux <gael.varoquaux@normalesup.org>
# Copyright (c) 2009, Enthought, Inc.
# License: BSD Style.


import numpy as np
from scipy import special
from mayavi import mlab

##############################################################################
# Function to caculate the Magnetic field generated by a current loop

def base_vectors(n):
    """ Returns 3 orthognal base vectors, the first one colinear to n.

        Parameters
        -----------
        n: ndarray, shape (3, )
            A vector giving direction of the basis

        Returns
        -----------
        n: ndarray, shape (3, )
            The first vector of the basis
        l: ndarray, shape (3, )
            The second vector of the basis
        m: ndarray, shape (3, )
            The first vector of the basis

    """
    # normalize n
    n = n / (n**2).sum(axis=-1)

    # choose two vectors perpendicular to n
    # choice is arbitrary since the coil is symetric about n
    if  np.abs(n[0])==1 :
        l = np.r_[n[2], 0, -n[0]]
    else:
        l = np.r_[0, n[2], -n[1]]

    l = l / (l**2).sum(axis=-1)
    m = np.cross(n, l)
    return n, l, m


def magnetic_field(r, n, r0, R):
    """
    Returns the magnetic field from an arbitrary current loop calculated from
    eqns (1) and (2) in Phys Rev A Vol. 35, N 4, pp. 1535-1546; 1987.

    Arguments
    ----------
        n: ndarray, shape (3, )
            The normal vector to the plane of the loop at the center,
            current is oriented by the right-hand-rule.
        r: ndarray, shape (m, 3)
            A position vector where the magnetic field is evaluated:
            [x1 y2 z3 ; x2 y2 z2 ; ... ]
            r is in units of d
        r0: ndarray, shape (3, )
            The location of the center of the loop in units of d: [x y z]
        R: float
            The radius of the current loop

    Returns
    --------
    B: ndarray, shape (m, 3)
        a vector for the B field at each position specified in r
        in inverse units of (mu I) / (2 pi d)
        for I in amps and d in meters and mu = 4 pi * 10^-7 we get Tesla
    """
    ### Translate the coordinates in the coil's frame
    n, l, m = base_vectors(n)

    # transformation matrix coil frame to lab frame
    trans = np.vstack((l, m, n))
    # transformation matrix to lab frame to coil frame
    inv_trans = np.linalg.inv(trans)

    # point location from center of coil
    r = r - r0
    # transform vector to coil frame
    r = np.dot(r, inv_trans)

    #### calculate field

    # express the coordinates in polar form
    x = r[:, 0]
    y = r[:, 1]
    z = r[:, 2]
    rho = np.sqrt(x**2 + y**2)
    theta = np.arctan(x/y)
    theta[y==0] = 0

    E = special.ellipe((4 * R * rho)/( (R + rho)**2 + z**2))
    K = special.ellipk((4 * R * rho)/( (R + rho)**2 + z**2))
    Bz =  1/np.sqrt((R + rho)**2 + z**2) * (
                K
              + E * (R**2 - rho**2 - z**2)/((R - rho)**2 + z**2)
              )
    Brho = z/(rho*np.sqrt((R + rho)**2 + z**2)) * (
               -K
              + E * (R**2 + rho**2 + z**2)/((R - rho)**2 + z**2)
              )
    # On the axis of the coil we get a divided by zero here. This returns a
    # NaN, where the field is actually zero :
    Brho[np.isnan(Brho)] = 0
    Brho[np.isinf(Brho)] = 0
    Bz[np.isnan(Bz)]     = 0
    Bz[np.isinf(Bz)]     = 0

    B = np.c_[np.cos(theta)*Brho, np.sin(theta)*Brho, Bz ]

    # Rotate the field back in the lab's frame
    B = np.dot(B, trans)
    return B


def display_coil(n, r0, R, half=False):
    """
    Display a coils in the 3D view.
    If half is True, display only one half of the coil.
    """
    n, l, m = base_vectors(n)
    theta = np.linspace(0, (2-half)*np.pi, 30)
    theta = theta[..., np.newaxis]
    coil = np.atleast_1d(R)*(np.sin(theta)*l + np.cos(theta)*m)
    coil += r0
    coil_x = coil[:, 0]
    coil_y = coil[:, 1]
    coil_z = coil[:, 2]
    mlab.plot3d(coil_x, coil_y, coil_z,
            tube_radius=0.01,
            name='Coil %i' % display_coil.num,
            color=(0, 0, 0))
    display_coil.num += 1
    return coil_x, coil_y, coil_z

display_coil.num = 0

##############################################################################
# The grid of points on which we want to evaluate the field
X, Y, Z = np.mgrid[-0.15:0.15:31j, -0.15:0.15:31j, -0.15:0.15:31j]
# Avoid rounding issues :
f = 1e4  # this gives the precision we are interested by :
X = np.round(X * f) / f
Y = np.round(Y * f) / f
Z = np.round(Z * f) / f

r = np.c_[X.ravel(), Y.ravel(), Z.ravel()]

##############################################################################
# The coil positions

# The center of the coil
r0 = np.r_[0, 0, 0.1]
# The normal to the coils
n  = np.r_[0, 0, 1]
# The radius
R  = 0.1

# Add the mirror image of this coils relatively to the xy plane :
r0 = np.vstack((r0, -r0 ))
R  = np.r_[R, R]
n  = np.vstack((n, n))      # Helmoltz like configuration

##############################################################################
# Calculate field
# First initialize a container matrix for the field vector :
B = np.empty_like(r)
# Then loop through the different coils and sum the fields :
for this_n, this_r0, this_R in zip(n, r0, R):
  this_n    = np.array(this_n)
  this_r0   = np.array(this_r0)
  this_R    = np.array(this_R)
  B += magnetic_field(r, this_n, this_r0, this_R)


Bx = B[:, 0]
By = B[:, 1]
Bz = B[:, 2]
Bx.shape = X.shape
By.shape = Y.shape
Bz.shape = Z.shape

Bnorm = np.sqrt(Bx**2 + By**2 + Bz**2)

##############################################################################
# Visualization

# We threshold the data ourselves, as the threshold filter produce a
# data structure inefficient with IsoSurface
Bmax = 100

Bx[Bnorm > Bmax] = 0
By[Bnorm > Bmax] = 0
Bz[Bnorm > Bmax] = 0
Bnorm[Bnorm > Bmax] = Bmax

mlab.figure(1, bgcolor=(1, 1, 1), fgcolor=(0.5, 0.5, 0.5),
               size=(480, 480))
mlab.clf()

for this_n, this_r0, this_R in zip(n, r0, R):
  display_coil(this_n, this_r0, this_R)

field = mlab.pipeline.vector_field(X, Y, Z, Bx, By, Bz,
                                  scalars=Bnorm, name='B field')
vectors = mlab.pipeline.vectors(field,
                      scale_factor=(X[1, 0, 0] - X[0, 0, 0]),
                      )
# Mask random points, to have a lighter visualization.
vectors.glyph.mask_input_points = True
vectors.glyph.mask_points.on_ratio = 6

vcp = mlab.pipeline.vector_cut_plane(field)
vcp.glyph.glyph.scale_factor=5*(X[1, 0, 0] - X[0, 0, 0])
# For prettier picture:
#vcp.implicit_plane.widget.enabled = False

iso = mlab.pipeline.iso_surface(field,
                                contours=[0.1*Bmax, 0.4*Bmax],
                                opacity=0.6,
                                colormap='YlOrRd')

# A trick to make transparency look better: cull the front face
iso.actor.property.frontface_culling = True

mlab.view(39, 74, 0.59, [.008, .0007, -.005])

mlab.show()

########NEW FILE########
__FILENAME__ = mlab_3D_to_2D
"""
A script to calculate the projection of 3D world coordinates to
2D display coordinates (pixel coordinates) for a given scene.

The 2D pixel locations of objects in the image plane are related to their
3D world coordinates by a series of linear transformations. The specific
transformations fall under the group known as projective transformations.
This set includes pure projectivities, affine transformations,
perspective transformations, and euclidean transformations. In the case
of mlab (and most other computer visualization software), we deal with
only the perspective and euclidean cases. An overview of Projective space
can be found here: http://en.wikipedia.org/wiki/Projective_space and a
thorough treatment of projective geometry can be had in the book
"Multiple View Geometry in Computer Vision" by Richard Hartley.

The essential thing to know for this example is that points in 3-space
are related to points in 2-space through a series of multiplications of
4x4 matrices which are the perspective and euclidean transformations. The
4x4 matrices predicate the use of length 4 vectors to represent points.
This representation is known as homogeneous coordinates, and while they
appear foriegn at first, they truly simplify all the mathematics
involved. In short, homogeneous coordinates are your friend, and you
should read about them here:
http://en.wikipedia.org/wiki/Homogeneous_coordinates

In the normal pinhole camera model (the ideal real world model), 3D world
points are related to 2D image points by the matrix termed the
'essential' matrix which is a combination of a perspective transformation
and a euclidean transformation. The perspective transformation is defined
by the camera intrinsics (focal length, imaging sensor offset, etc...)
and the euclidean transformation is defined by the cameras position and
orientation. In computer graphics, things are not so simple. This is
because computer graphics have the benefit of being able to do things
which are not possible in the real world: adding clipping planes, offset
projection centers, arbitrary distortions, etc... Thus, a slightly
different model is used.

What follows is the camera/view model for OpenGL and thus, VTK. I can not
guarantee that other packages follow this model.

There are 4 different transformations that are applied 3D world
coordinates to map them to 2D pixel coordinates. They are: the model
transform, the view transform, the perspective transform, and the
viewport or display transform.

In OpenGL the first two transformations are concatenated to yield the
modelview transform (called simply the view transform in VTK). The
modelview transformation applies arbitrary scaling and distortions to the
model (if they are specified) and transforms them so that the orientation
is the equivalent of looking down the negative Z axis. Imagine its as if
you relocate your camera to look down the negative Z axis, and then move
everything in the world so that you see it now as you did before you
moved the camera. The resulting coordinates are termed "eye" coordinates
in OpenGL (I don't know that they have a name in VTK).

The perspective transformation applies the camera perspective to the eye
coordinates. This transform is what makes objects in the foreground look
bigger than equivalent objects in the background. In the pinhole camera
model, this transform is determined uniquely by the focal length of the
camera and its position in 3-space. In Vtk/OpenGL it is determined by the
frustum. A frustum is simply a pyramid with the top lopped off. The top
of the pyramid (a point) is the camera location, the base of the pyramid
is a plane (the far clipping plane) defined as normal to principle camera
ray at distance termed the far clipping distance, the top of the frustum
(where it's lopped off) is the near clipping plane, with a definition
similar to that of the far clipping plane. The sides of the frustum are
determined by the aspect ratio of the camera (width/height) and its
field-of-view. Any points not lying within the frustum are not mapped to
the screen (as they would lie outside the viewable area). The
perpspective transformation has the effect of scaling everything within
the frustum to fit within a cube defined in the range (-1,1)(-1,1)(-1,1)
as represented by homogeneous coordinates. The last phrase there is
important, the first 3 coordinates will not, in general, be within the
unity range until we divide through by the last coordinate (See the
wikipedia on homogeneous coordinates if this is confusing). The resulting
coordinates are termed (appropriately enough) normalized view
coordinates.

The last transformation (the viewport transformation) takes us from
normalized view coordinates to display coordinates. At this point, you
may be asking yourself 'why not just go directly to display coordinates,
why need normalized view coordinates at all?', the answer is that we may
want to embed more than one view in a particular window, there will
therefore be different transformations to take each view to an
appropriate position an size in the window. The normalized view
coordinates provide a nice common ground so-to-speak. At any rate, the
viewport transformation simply scales and translates the X and Y
coordinates of the normalized view coordinates to the appropriate pixel
coordinates. We don't use the Z value in our example because we don't
care about it. It is used for other various things however.

That's all there is to it, pretty simple right? Right. Here is an overview:

Given a set of 3D world coordinates:
 - Apply the modelview transformation (view transform in VTK) to get eye
   coordinates
 - Apply the perspective transformation to get normalized view coordinates
 - Apply the viewport transformation to get display coordinates

VTK provides a nice method to retrieve a 4x4 matrix that combines the
first two operations. As far as I can tell, VTK does not export a method
to retrieve the 4x4 matrix representing the viewport transformation, so
we are on our there to create one (no worries though, its not hard, as
you will see).

Now that the prelimenaries are out of the way, lets get started.

"""

# Author: S. Chris Colbert <sccolbert@gmail.com>
# Copyright (c) 2009, S. Chris Colbert
# License: BSD Style

# this import is here because we need to ensure that matplotlib uses the
# wx backend and having regular code outside the main block is PyTaboo.
# It needs to be imported first, so that matplotlib can impose the
# version of Wx it requires.
import matplotlib
matplotlib.use('WXAgg')
import pylab as pl


import numpy as np
from mayavi import mlab
from mayavi.core.ui.mayavi_scene import MayaviScene

def get_world_to_view_matrix(mlab_scene):
    """returns the 4x4 matrix that is a concatenation of the modelview transform and
    perspective transform. Takes as input an mlab scene object."""

    if not isinstance(mlab_scene, MayaviScene):
        raise TypeError('argument must be an instance of MayaviScene')


    # The VTK method needs the aspect ratio and near and far clipping planes
    # in order to return the proper transform. So we query the current scene
    # object to get the parameters we need.
    scene_size = tuple(mlab_scene.get_size())
    clip_range = mlab_scene.camera.clipping_range
    aspect_ratio = float(scene_size[0])/float(scene_size[1])

    # this actually just gets a vtk matrix object, we can't really do anything with it yet
    vtk_comb_trans_mat = mlab_scene.camera.get_composite_projection_transform_matrix(
                                aspect_ratio, clip_range[0], clip_range[1])

     # get the vtk mat as a numpy array
    np_comb_trans_mat = vtk_comb_trans_mat.to_array()

    return np_comb_trans_mat


def get_view_to_display_matrix(mlab_scene):
    """ this function returns a 4x4 matrix that will convert normalized
        view coordinates to display coordinates. It's assumed that the view should
        take up the entire window and that the origin of the window is in the
        upper left corner"""

    if not (isinstance(mlab_scene, MayaviScene)):
        raise TypeError('argument must be an instance of MayaviScene')

    # this gets the client size of the window
    x, y = tuple(mlab_scene.get_size())

    # normalized view coordinates have the origin in the middle of the space
    # so we need to scale by width and height of the display window and shift
    # by half width and half height. The matrix accomplishes that.
    view_to_disp_mat = np.array([[x/2.0,      0.,   0.,   x/2.0],
                                 [   0.,  -y/2.0,   0.,   y/2.0],
                                 [   0.,      0.,   1.,      0.],
                                 [   0.,      0.,   0.,      1.]])

    return view_to_disp_mat


def apply_transform_to_points(points, trans_mat):
    """a function that applies a 4x4 transformation matrix to an of
        homogeneous points. The array of points should have shape Nx4"""

    if not trans_mat.shape == (4, 4):
        raise ValueError('transform matrix must be 4x4')

    if not points.shape[1] == 4:
        raise ValueError('point array must have shape Nx4')

    return np.dot(trans_mat, points.T).T


if __name__ == '__main__':
    f = mlab.figure()

    N = 4

    # create a few points in 3-space
    X = np.random.random_integers(-3, 3, N)
    Y = np.random.random_integers(-3, 3, N)
    Z = np.random.random_integers(-3, 3, N)

    # plot the points with mlab
    pts = mlab.points3d(X, Y, Z)

    # now were going to create a single N x 4 array of our points
    # adding a fourth column of ones expresses the world points in
    # homogenous coordinates
    W = np.ones(X.shape)
    hmgns_world_coords = np.column_stack((X, Y, Z, W))

    # applying the first transform will give us 'unnormalized' view
    # coordinates we also have to get the transform matrix for the
    # current scene view
    comb_trans_mat = get_world_to_view_matrix(f.scene)
    view_coords = \
            apply_transform_to_points(hmgns_world_coords, comb_trans_mat)

    # to get normalized view coordinates, we divide through by the fourth
    # element
    norm_view_coords = view_coords / (view_coords[:, 3].reshape(-1, 1))

    # the last step is to transform from normalized view coordinates to
    # display coordinates.
    view_to_disp_mat = get_view_to_display_matrix(f.scene)
    disp_coords = apply_transform_to_points(norm_view_coords, view_to_disp_mat)

    # at this point disp_coords is an Nx4 array of homogenous coordinates
    # where X and Y are the pixel coordinates of the X and Y 3D world
    # coordinates, so lets take a screenshot of mlab view and open it
    # with matplotlib so we can check the accuracy
    img = mlab.screenshot()
    pl.imshow(img)

    for i in range(N):
        print  'Point %d:  (x, y) ' % i, disp_coords[:, 0:2][i]
        pl.plot([disp_coords[:, 0][i]], [disp_coords[:, 1][i]], 'ro')

    pl.show()

    # you should check that the printed coordinates correspond to the
    # proper points on the screen

    mlab.show()

#EOF

########NEW FILE########
__FILENAME__ = numeric_source
#!/usr/bin/env python

"""This script demonstrates how to create a numpy array data and
visualize it as image data using a few modules.

"""
# Author: Prabhu Ramachandran <prabhu_r@users.sf.net>
# Copyright (c) 2005-2008, Enthought, Inc.
# License: BSD Style.

# Standard library imports
import numpy

# Enthought library imports
from mayavi.scripts import mayavi2
from mayavi.sources.array_source import ArraySource
from mayavi.modules.outline import Outline
from mayavi.modules.image_plane_widget import ImagePlaneWidget


def make_data(dims=(128, 128, 128)):
    """Creates some simple array data of the given dimensions to test
    with."""
    np = dims[0]*dims[1]*dims[2]

    # Create some scalars to render.
    x, y, z = numpy.ogrid[-5:5:dims[0]*1j,-5:5:dims[1]*1j,-5:5:dims[2]*1j]
    x = x.astype('f')
    y = y.astype('f')
    z = z.astype('f')

    scalars = (numpy.sin(x*y*z)/(x*y*z))
    # The copy makes the data contiguous and the transpose makes it
    # suitable for display via tvtk.  Please note that we assume here
    # that the ArraySource is configured to not transpose the data.
    s = numpy.transpose(scalars).copy()
    # Reshaping the array is needed since the transpose messes up the
    # dimensions of the data.  The scalars themselves are ravel'd and
    # used internally by VTK so the dimension does not matter for the
    # scalars.
    s.shape = s.shape[::-1]

    return s


@mayavi2.standalone
def view_numpy():
    """Example showing how to view a 3D numpy array in mayavi2.
    """
    # 'mayavi' is always defined on the interpreter.
    mayavi.new_scene()
    # Make the data and add it to the pipeline.
    data = make_data()
    src = ArraySource(transpose_input_array=False)
    src.scalar_data = data
    mayavi.add_source(src)
    # Visualize the data.
    o = Outline()
    mayavi.add_module(o)
    ipw = ImagePlaneWidget()
    mayavi.add_module(ipw)
    ipw.module_manager.scalar_lut_manager.show_scalar_bar = True

    ipw_y = ImagePlaneWidget()
    mayavi.add_module(ipw_y)
    ipw_y.ipw.plane_orientation = 'y_axes'


if __name__ == '__main__':
    view_numpy()


########NEW FILE########
__FILENAME__ = offscreen
#!/usr/bin/env python
"""A simple example of how you can use Mayavi without using Envisage
or the Mayavi Envisage application and do off screen rendering.

On Linux/Mac, with VTK < 5.2, you should see a small black window popup
and disappear, see the section :ref:`offscreen_rendering` to avoid this.
On Win32 you will not see any windows popping up at all. In the end you
should have an offscreen.png image in the same directory with the
rendered visualization.

It can be run as::

    $ python offscreen.py
"""

# Author: Prabhu Ramachandran <prabhu@aero.iitb.ac.in>
# Copyright (c) 2007, Enthought, Inc.
# License: BSD Style.

from os.path import join, abspath, dirname

# The offscreen Engine.
from mayavi.api import OffScreenEngine

# Usual MayaVi imports
from mayavi.scripts.util import get_data_dir
from mayavi.sources.api import VTKXMLFileReader
from mayavi.modules.api import Outline, ScalarCutPlane, Streamline


def main():
    # Create the MayaVi offscreen engine and start it.
    e = OffScreenEngine()
    # Starting the engine registers the engine with the registry and
    # notifies others that the engine is ready.
    e.start()

    # Create a new scene.
    win = e.new_scene()

    # Now setup a normal MayaVi pipeline.
    src = VTKXMLFileReader()
    src.initialize(join(get_data_dir(dirname(abspath(__file__))),
                        'fire_ug.vtu'))
    e.add_source(src)
    e.add_module(Outline())
    e.add_module(ScalarCutPlane())
    e.add_module(Streamline())
    win.scene.isometric_view()
    # Change the size argument to anything you want.
    win.scene.save('offscreen.png', size=(800, 800))


if __name__ == '__main__':
    main()

########NEW FILE########
__FILENAME__ = polydata
"""
An example of how to generate a polydata dataset using numpy arrays.

The example is similar to tvtk/examples/tiny_mesh.py.  Also shown is a
way to visualize this data with mayavi2.  The script can be run like so::

  $ mayavi2 -x polydata.py

It can be alternatively run as::

  $ python polydata.py

"""

# Author: Prabhu Ramachandran <prabhu at aero dot iitb dot ac dot in>
# Copyright (c) 2007, Enthought, Inc.
# License: BSD style.

from numpy import array
from tvtk.api import tvtk
from mayavi.scripts import mayavi2

# The numpy array data.
points = array([[0,0,0], [1,0,0], [0,1,0], [0,0,1]], 'f')
triangles = array([[0,1,3], [0,3,2], [1,2,3], [0,2,1]])
temperature = array([10., 20., 30., 40.])

# The TVTK dataset.
mesh = tvtk.PolyData(points=points, polys=triangles)
mesh.point_data.scalars = temperature
mesh.point_data.scalars.name = 'Temperature'

# Uncomment the next two lines to save the dataset to a VTK XML file.
#w = tvtk.XMLPolyDataWriter(input=mesh, file_name='polydata.vtp')
#w.write()

# Now view the data.
@mayavi2.standalone
def view():
    from mayavi.sources.vtk_data_source import VTKDataSource
    from mayavi.modules.surface import Surface

    mayavi.new_scene()
    src = VTKDataSource(data = mesh)
    mayavi.add_source(src)
    s = Surface()
    mayavi.add_module(s)

if __name__ == '__main__':
    view()


########NEW FILE########
__FILENAME__ = probe_filter
"""
Using the probe filter to visualize a scalar field along an arbitrary
surface.

This example shows how a data set can be 'projected' (or interpolated) on
another given source using the probe filter. It is also an example of a
complex VTK pipeline and shows how to inspect it with the
PipelineBrowser.

In this example, a function is sampled on a regular grid and can be
visualized using an ImagePlaneWidget. The function we are interested is
independent of the distance to the origin and a function only of the
angle. This is why it may be interesting to visualize its value sampled
on a sphere center at the origin, but we have the data sampled throughout
the volume on a regular grid.

We create a sphere with the BuiltinSurface source and use the VTK
ProbeFilter to sample the data on this surface. The ProbeFilter takes one
input, which is the data structure to project the data on, and a
'source', which is where the data values come from.

We need to use the UserDefined filter to insert this VTK filter in the
Mayavi pipeline (see :ref:`using_userdefined_filter` as well as
:ref:`example_image_cursor_filter` and :ref:`example_tvtk_segmentation`).
Specifying its input is done automatical when it is inserted on the
pipeline, be its source needs to be specified explicitely. As it is a VTK
filter, the source is the VTK dataset output by the Mayavi object: we can
find it in `.outputs[0]`.

Note that this filter violates slightly the simple pipeline model that
Mayavi tries to expose to the users: it has two entries. As a result,
the Mayavi pipeline is not longer really a tree. However, if you open up
the Mayavi :ref:`pipeline view <mlab-changing-objects-interactively>`,
you can see that the ProbeFilter has only one parent in the view. To
inspect the actually VTK pipeline underlying this visualization, we
use the TVTK PipelineBrowser at the end of the example. You can see that
the VTK pipeline is much more complex that the pipeline represented
in Mayavi: actors, data mappers, and other elements of the VTK pipeline
are collapsed in the Mayavi filters and modules.

Note that, as we know the expression of the function, it would be simpler
and more efficient to directly sample it on the sphere.
"""
import numpy as np

from mayavi import mlab
from tvtk.api import tvtk
from tvtk.common import configure_source_data

# The angular par of the spherical harmonic (3, 2)
x, y, z = np.mgrid[-.5:.5:100j, -.5:.5:100j, -.5:.5:100j]
Phi = np.angle((x+y*1j)**2*z)

field = mlab.pipeline.scalar_field(x, y, z, Phi)
ipw = mlab.pipeline.image_plane_widget(field)
mlab.outline(field)

surface = mlab.pipeline.builtin_surface()
surface.source = 'sphere'
surface.data_source.radius = .4
surface.data_source.phi_resolution = 200
surface.data_source.theta_resolution = 200
probe_filter = tvtk.ProbeFilter()
configure_source_data(probe_filter, field.outputs[0])
probe = mlab.pipeline.user_defined(surface, filter=probe_filter)

surf = mlab.pipeline.surface(probe)

fig = mlab.gcf()

################################################################################
# Finally, to inspect the VTK Pipeline (and not the Mayavi one, we
# use the TVTK pipeline browser)
# Note that for Mayavi version < 3.4.1, there is a bug in the
# PipelineBrowser preventing a good display of this pipeline.
from tvtk.pipeline.browser import PipelineBrowser
browser = PipelineBrowser(fig.scene)
browser.show()

mlab.show()


########NEW FILE########
__FILENAME__ = scatter_plot
"""
An example of plotting scatter points with Mayavi's core API.

This script creates a bunch of random points with random scalar data
and then shows these as a "scatter" plot of points.  The script
illustrates how to

 1. create a dataset easily using tvtk and numpy,

 2. use a created dataset in Mayavi and visualize it.

This example achieve the same functionnality as mlab's points3d
function ( :func:`mayavi.mlab.points3d`), but explicitely
creating the objects and adding them to the pipeline engine via the Mayavi
core API. Compared to using mlab, this method has the advantage of giving
more control on which objects are created, and there life cycle.

Run this script like so::

  $ mayavi2 -x scatter_plot.py

Alternatively it can be run as::

  $ python scatter_plot.py
"""

# Author: Prabhu Ramachandran <prabhu@aero.iitb.ac.in>
# Copyright (c) 2007 Prabhu Ramachandran.
# License: BSD Style.

import numpy as np
from tvtk.api import tvtk
from mayavi.scripts import mayavi2


@mayavi2.standalone
def main():
    # Create some random points to view.
    pd = tvtk.PolyData()
    pd.points = np.random.random((1000, 3))
    verts = np.arange(0, 1000, 1)
    verts.shape = (1000, 1)
    pd.verts = verts
    pd.point_data.scalars = np.random.random(1000)
    pd.point_data.scalars.name = 'scalars'

    # Now visualize it using mayavi2.
    from mayavi.sources.vtk_data_source import VTKDataSource
    from mayavi.modules.outline import Outline
    from mayavi.modules.surface import Surface

    mayavi.new_scene()
    d = VTKDataSource()
    d.data = pd
    mayavi.add_source(d)
    mayavi.add_module(Outline())
    s = Surface()
    mayavi.add_module(s)
    s.actor.property.set(representation='p', point_size=2)
    # You could also use glyphs to render the points via the Glyph module.

if __name__ == '__main__':
    main()

########NEW FILE########
__FILENAME__ = streamline
#!/usr/bin/env mayavi2
"""This script demonstrates how one can script Mayavi's core API to display
streamlines and an iso surface.
"""
# Author: Prabhu Ramachandran <prabhu_r@users.sf.net>
# Copyright (c) 2005-2007, Enthought, Inc.
# License: BSD Style.

# Standard library imports
from os.path import join, abspath, dirname

# Enthought library imports
from mayavi.scripts import mayavi2
from mayavi.sources.vtk_xml_file_reader import VTKXMLFileReader
from mayavi.sources.vrml_importer import VRMLImporter
from mayavi.modules.outline import Outline
from mayavi.modules.streamline import Streamline
from mayavi.modules.iso_surface import IsoSurface

def setup_data(fname):
    """Given a VTK XML file name `fname`, this creates a mayavi2
    reader for it and adds it to the pipeline.  It returns the reader
    created.
    """
    r = VTKXMLFileReader()
    r.initialize(fname)
    mayavi.add_source(r)
    return r

def show_vrml(fname):
    """Given a VRML file name it imports it into the scene.
    """
    r = VRMLImporter()
    r.initialize(fname)
    mayavi.add_source(r)
    return r

def streamline():
    """Sets up the mayavi pipeline for the visualization.
    """
    # Create an outline for the data.
    o = Outline()
    mayavi.add_module(o)

    s = Streamline(streamline_type='tube')
    mayavi.add_module(s)
    s.stream_tracer.integration_direction = 'both'
    s.seed.widget.center = 3.5, 0.625, 1.25
    s.module_manager.scalar_lut_manager.show_scalar_bar = True

    i = IsoSurface()
    mayavi.add_module(i)
    i.contour.contours[0] = 550
    i.actor.property.opacity = 0.5

@mayavi2.standalone
def main():
    mayavi.new_scene()

    data_dir = mayavi2.get_data_dir(dirname(abspath(__file__)))
    vrml_fname = join(data_dir, 'room_vis.wrl')
    r = show_vrml(vrml_fname)

    fname = join(data_dir, 'fire_ug.vtu')
    r = setup_data(fname)
    streamline()


if __name__ == '__main__':
    main()

########NEW FILE########
__FILENAME__ = structured_grid
"""An example of how to generate a structured grid dataset using
numpy arrays.  Also shown is a way to visualize this data with
the mayavi2 application.

The script can be run like so::

  $ mayavi2 -x structured_grid.py

Alternatively, it can be run as::

  $ python structured_grid.py


"""

# Authors: Eric Jones <eric at enthought dot com>
#          Prabhu Ramachandran <prabhu at aero dot iitb dot ac dot in>
# Copyright (c) 2007, Enthought, Inc.
# License: BSD style.

import numpy as np
from numpy import cos, sin, pi
from tvtk.api import tvtk
from mayavi.scripts import mayavi2

def generate_annulus(r=None, theta=None, z=None):
    """ Generate points for structured grid for a cylindrical annular
        volume.  This method is useful for generating a structured
        cylindrical mesh for VTK (and perhaps other tools).

        Parameters
        ----------
        r : array : The radial values of the grid points.
                    It defaults to linspace(1.0, 2.0, 11).

        theta : array : The angular values of the x axis for the grid
                        points. It defaults to linspace(0,2*pi,11).

        z: array : The values along the z axis of the grid points.
                   It defaults to linspace(0,0,1.0, 11).

        Return
        ------
        points : array
            Nx3 array of points that make up the volume of the annulus.
            They are organized in planes starting with the first value
            of z and with the inside "ring" of the plane as the first
            set of points.  The default point array will be 1331x3.
    """
    # Default values for the annular grid.
    if r is None: r = np.linspace(1.0, 2.0, 11)
    if theta is None: theta = np.linspace(0, 2*pi, 11)
    if z is None: z = np.linspace(0.0, 1.0, 11)

    # Find the x values and y values for each plane.
    x_plane = (cos(theta)*r[:,None]).ravel()
    y_plane = (sin(theta)*r[:,None]).ravel()

    # Allocate an array for all the points.  We'll have len(x_plane)
    # points on each plane, and we have a plane for each z value, so
    # we need len(x_plane)*len(z) points.
    points = np.empty([len(x_plane)*len(z),3])

    # Loop through the points for each plane and fill them with the
    # correct x,y,z values.
    start = 0
    for z_plane in z:
        end = start + len(x_plane)
        # slice out a plane of the output points and fill it
        # with the x,y, and z values for this plane.  The x,y
        # values are the same for every plane.  The z value
        # is set to the current z
        plane_points = points[start:end]
        plane_points[:,0] = x_plane
        plane_points[:,1] = y_plane
        plane_points[:,2] = z_plane
        start = end

    return points

# Make the data.
dims = (51, 25, 25)
# Note here that the 'x' axis corresponds to 'theta'
theta = np.linspace(0, 2*np.pi, dims[0])
# 'y' corresponds to varying 'r'
r = np.linspace(1, 10, dims[1])
z = np.linspace(0, 5, dims[2])
pts = generate_annulus(r, theta, z)
# Uncomment the following if you want to add some noise to the data.
#pts += np.random.randn(dims[0]*dims[1]*dims[2], 3)*0.04
sgrid = tvtk.StructuredGrid(dimensions=dims)
sgrid.points = pts
s = np.sqrt(pts[:,0]**2 + pts[:,1]**2 + pts[:,2]**2)
sgrid.point_data.scalars = np.ravel(s.copy())
sgrid.point_data.scalars.name = 'scalars'

# Uncomment the next two lines to save the dataset to a VTK XML file.
#w = tvtk.XMLStructuredGridWriter(input=sgrid, file_name='sgrid.vts')
#w.write()

# View the data.
@mayavi2.standalone
def view():
    from mayavi.sources.vtk_data_source import VTKDataSource
    from mayavi.modules.api import Outline, GridPlane

    mayavi.new_scene()
    src = VTKDataSource(data=sgrid)
    mayavi.add_source(src)
    mayavi.add_module(Outline())
    g = GridPlane()
    g.grid_plane.axis = 'x'
    mayavi.add_module(g)
    g = GridPlane()
    g.grid_plane.axis = 'y'
    mayavi.add_module(g)
    g = GridPlane()
    g.grid_plane.axis = 'z'
    mayavi.add_module(g)

if __name__ == '__main__':
    view()

########NEW FILE########
__FILENAME__ = structured_points2d
"""An example of how to generate a 2D structured points dataset
using numpy arrays.  Also shown is a way to visualize this data with
the mayavi2 application.

The script can be run like so::

  $ mayavi2 -x structured_points2d.py

Alternatively, it can be run as::

  $ python structured_points2d.py

"""
# Author: Prabhu Ramachandran <prabhu at aero dot iitb dot ac dot in>
# Copyright (c) 2007, Enthought, Inc.
# License: BSD style.

from numpy import arange, sqrt, sin
from tvtk.api import tvtk
from mayavi.scripts import mayavi2

# Generate the scalar values.
x = (arange(0.1, 50.0)-25)/2.0
y = (arange(0.1, 50.0)-25)/2.0
r = sqrt(x[:,None]**2+y**2)
z = 5.0*sin(r)/r  #

# Make the tvtk dataset.
# tvtk.ImageData is identical and could also be used here.
spoints = tvtk.StructuredPoints(origin=(-12.5,-12.5,0),
                                spacing=(0.5,0.5,1),
                                dimensions=(50,50,1))
# Transpose the array data due to VTK's implicit ordering. VTK assumes
# an implicit ordering of the points: X co-ordinate increases first, Y
# next and Z last.  We flatten it so the number of components is 1.
spoints.point_data.scalars = z.T.flatten()
spoints.point_data.scalars.name = 'scalar'

# Uncomment the next two lines to save the dataset to a VTK XML file.
#w = tvtk.XMLImageDataWriter(input=spoints, file_name='spoints2d.vti')
#w.write()

# Now view the data.
@mayavi2.standalone
def view():
    from mayavi.sources.vtk_data_source import VTKDataSource
    from mayavi.filters.warp_scalar import WarpScalar
    from mayavi.filters.poly_data_normals import PolyDataNormals
    from mayavi.modules.surface import Surface

    mayavi.new_scene()
    src = VTKDataSource(data = spoints)
    mayavi.add_source(src)
    mayavi.add_filter(WarpScalar())
    mayavi.add_filter(PolyDataNormals())
    s = Surface()
    mayavi.add_module(s)

if __name__ == '__main__':
    view()

########NEW FILE########
__FILENAME__ = structured_points3d
"""An example of how to generate a 3D structured points dataset
using numpy arrays.  Also shown is a way to visualize this data with
the mayavi2 application.

The script can be run like so::

  $ mayavi2 -x structured_points3d.py

Alternatively, it can be run as::

  $ python structured_points3d.py

"""
# Author: Prabhu Ramachandran <prabhu at aero dot iitb dot ac dot in>
# Copyright (c) 2007, Enthought, Inc.
# License: BSD style.

from tvtk.api import tvtk
from tvtk.array_handler import get_vtk_array_type
from tvtk.common import is_old_pipeline
from numpy import array, ogrid, sin, ravel
from mayavi.scripts import mayavi2

# Make the data.
dims = array((128, 128, 128))
vol = array((-5., 5, -5, 5, -5, 5))
origin = vol[::2]
spacing = (vol[1::2] - origin)/(dims -1)
xmin, xmax, ymin, ymax, zmin, zmax = vol
x, y, z = ogrid[xmin:xmax:dims[0]*1j,
                ymin:ymax:dims[1]*1j,
                zmin:zmax:dims[2]*1j]
x, y, z = [t.astype('f') for t in (x, y, z)]
scalars = sin(x*y*z)/(x*y*z)

# Make the tvtk dataset.
spoints = tvtk.StructuredPoints(origin=origin, spacing=spacing,
                                dimensions=dims)
# The copy makes the data contiguous and the transpose makes it
# suitable for display via tvtk.  Note that it is not necessary to
# make the data contiguous since in that case the array is copied
# internally.
s = scalars.transpose().copy()
spoints.point_data.scalars = ravel(s)
spoints.point_data.scalars.name = 'scalars'

# This is needed in slightly older versions of VTK (like the 5.0.2
# release) to prevent a segfault.  VTK does not detect the correct
# data type.
if is_old_pipeline():
    spoints.scalar_type = get_vtk_array_type(s.dtype)

# Uncomment the next two lines to save the dataset to a VTK XML file.
#w = tvtk.XMLImageDataWriter(input=spoints, file_name='spoints3d.vti')
#w.write()

# Now view the data.
@mayavi2.standalone
def view():
    from mayavi.sources.vtk_data_source import VTKDataSource
    from mayavi.modules.outline import Outline
    from mayavi.modules.image_plane_widget import ImagePlaneWidget

    mayavi.new_scene()
    src = VTKDataSource(data = spoints)
    mayavi.add_source(src)
    mayavi.add_module(Outline())
    mayavi.add_module(ImagePlaneWidget())

if __name__ == '__main__':
    view()

########NEW FILE########
__FILENAME__ = surf_regular_mlab
#!/usr/bin/env python
"""Shows how to view data created by `tvtk.tools.mlab` with
mayavi2.
"""

# Author: Prabhu Ramachandran <prabhu@aero.iitb.ac.in>
# Copyright (c) 2006-2007, Enthought Inc.
# License: BSD Style.

import numpy

from mayavi.scripts import mayavi2
from tvtk.tools import mlab
from mayavi.sources.vtk_data_source import VTKDataSource
from mayavi.filters.warp_scalar import WarpScalar
from mayavi.modules.outline import Outline
from mayavi.modules.surface import Surface


def make_data():
    """Make some test numpy data and create a TVTK data object from it
    that we will visualize.
    """
    def f(x, y):
        """Some test function.
        """
        return numpy.sin(x*y)/(x*y)

    x = numpy.arange(-7., 7.05, 0.1)
    y = numpy.arange(-5., 5.05, 0.05)
    s = mlab.SurfRegular(x, y, f)
    return s.data

def add_data(tvtk_data):
    """Add a TVTK data object `tvtk_data` to the mayavi pipleine.
    """
    d = VTKDataSource()
    d.data = tvtk_data
    mayavi.add_source(d)

def surf_regular():
    """Now visualize the data as done in mlab.
    """
    w = WarpScalar()
    mayavi.add_filter(w)
    o = Outline()
    s = Surface()
    mayavi.add_module(o)
    mayavi.add_module(s)

@mayavi2.standalone
def main():
    mayavi.new_scene()
    d = make_data()
    add_data(d)
    surf_regular()

if __name__ == '__main__':
    main()

########NEW FILE########
__FILENAME__ = tvtk_segmentation
"""
Using VTK to assemble a pipeline for segmenting MRI images. This example
shows how to insert well-controled custom VTK filters in Mayavi.

This example downloads an MRI scan, turns it into a 3D numpy array,
applies a segmentation procedure made of VTK filters to extract the
gray-matter/white-matter boundary.

The segmentation algorithm used here is very naive and should, of course,
not be used as an example of segmentation.

"""

### Download the data, if not already on disk ##################################
import os
if not os.path.exists('mri_data.tar.gz'):
    # Download the data
    import urllib
    print "Downloading data, Please Wait (7.8MB)"
    opener = urllib.urlopen(
                'http://www-graphics.stanford.edu/data/voldata/MRbrain.tar.gz')
    open('mri_data.tar.gz', 'wb').write(opener.read())

# Extract the data
import tarfile
tar_file = tarfile.open('mri_data.tar.gz')
try:
    os.mkdir('mri_data')
except:
    pass
tar_file.extractall('mri_data')
tar_file.close()


### Read the data in a numpy 3D array ##########################################
import numpy as np
data = np.array([np.fromfile(os.path.join('mri_data', 'MRbrain.%i' % i),
                                        dtype='>u2') for i in range(1, 110)])
data.shape = (109, 256, 256)
data = data.T

################################################################################
# Heuristic for finding the threshold for the brain

# Exctract the percentile 20 and 80 (without using
# scipy.stats.scoreatpercentile)
sorted_data = np.sort(data.ravel())
l = len(sorted_data)
lower_thr = sorted_data[0.2*l]
upper_thr = sorted_data[0.8*l]

# The white matter boundary: find the densest part of the upper half
# of histogram, and take a value 10% higher, to cut _in_ the white matter
hist, bins = np.histogram(data[data > np.mean(data)], bins=50)
brain_thr_idx = np.argmax(hist)
brain_thr =  bins[brain_thr_idx + 4]

del hist, bins, brain_thr_idx

# Display the data #############################################################
from mayavi import mlab
from tvtk.api import tvtk

fig = mlab.figure(bgcolor=(0, 0, 0), size=(400, 500))
# to speed things up
fig.scene.disable_render = True

src = mlab.pipeline.scalar_field(data)
# Our data is not equally spaced in all directions:
src.spacing = [1, 1, 1.5]
src.update_image_data = True

#----------------------------------------------------------------------
# Brain extraction pipeline

# In the following, we create a Mayavi pipeline that strongly
# relies on VTK filters. For this, we make heavy use of the
# mlab.pipeline.user_defined function, to include VTK filters in
# the Mayavi pipeline.

# Apply image-based filters to clean up noise
thresh_filter = tvtk.ImageThreshold()
thresh_filter.threshold_between(lower_thr, upper_thr)
thresh = mlab.pipeline.user_defined(src, filter=thresh_filter)

median_filter = tvtk.ImageMedian3D()
median_filter.set_kernel_size(3, 3, 3)
median = mlab.pipeline.user_defined(thresh, filter=median_filter)

diffuse_filter = tvtk.ImageAnisotropicDiffusion3D(
                                    diffusion_factor=1.0,
                                    diffusion_threshold=100.0,
                                    number_of_iterations=5, )

diffuse = mlab.pipeline.user_defined(median, filter=diffuse_filter)

# Extract brain surface
contour = mlab.pipeline.contour(diffuse, )
contour.filter.contours = [brain_thr, ]

# Apply mesh filter to clean up the mesh (decimation and smoothing)
dec = mlab.pipeline.decimate_pro(contour)
dec.filter.feature_angle = 60.
dec.filter.target_reduction = 0.7

smooth_ = tvtk.SmoothPolyDataFilter(
                    number_of_iterations=10,
                    relaxation_factor=0.1,
                    feature_angle=60,
                    feature_edge_smoothing=False,
                    boundary_smoothing=False,
                    convergence=0.,
                )
smooth = mlab.pipeline.user_defined(dec, filter=smooth_)

# Get the largest connected region
connect_ = tvtk.PolyDataConnectivityFilter(extraction_mode=4)
connect = mlab.pipeline.user_defined(smooth, filter=connect_)

# Compute normals for shading the surface
compute_normals = mlab.pipeline.poly_data_normals(connect)
compute_normals.filter.feature_angle = 80

surf = mlab.pipeline.surface(compute_normals,
                                        color=(0.9, 0.72, 0.62))

#----------------------------------------------------------------------
# Display a cut plane of the raw data
ipw = mlab.pipeline.image_plane_widget(src, colormap='bone',
                plane_orientation='z_axes',
                slice_index=55)

mlab.view(-165, 32, 350, [143, 133, 73])
mlab.roll(180)

fig.scene.disable_render = False

#----------------------------------------------------------------------
# To make the link between the Mayavi pipeline and the much more
# complex VTK pipeline, we display both:
mlab.show_pipeline(rich_view=False)
from tvtk.pipeline.browser import PipelineBrowser
browser = PipelineBrowser(fig.scene)
browser.show()

mlab.show()

########NEW FILE########
__FILENAME__ = unstructured_grid
"""A MayaVi example of how to generate an unstructured grid dataset
using numpy arrays.  Also shown is a way to visualize this data with
mayavi2.  The script can be run like so:

  $ mayavi2 -x unstructured_grid.py

Alternatively, it can be run as:

  $ python unstructured_grid.py

Author: Prabhu Ramachandran <prabhu at aero dot iitb dot ac dot in>

Copyright (c) 2007, Enthought, Inc.
License: BSD style.
"""

from numpy import array, arange, random
from tvtk.api import tvtk
from mayavi.scripts import mayavi2

def single_type_ug():
    """Simple example showing how to create an unstructured grid
    consisting of cells of a single type.
    """
    points = array([[0,0,0], [1,0,0], [0,1,0], [0,0,1], # tets
                    [1,0,0], [2,0,0], [1,1,0], [1,0,1],
                    [2,0,0], [3,0,0], [2,1,0], [2,0,1],
                    ], 'f')
    tets = array([[0, 1, 2, 3], [4, 5, 6, 7], [8, 9, 10, 11]])
    tet_type = tvtk.Tetra().cell_type
    ug = tvtk.UnstructuredGrid(points=points)
    ug.set_cells(tet_type, tets)
    return ug

def mixed_type_ug():
    """A slightly more complex example of how to generate an
    unstructured grid with different cell types.  Returns a created
    unstructured grid.
    """
    points = array([[0,0,0], [1,0,0], [0,1,0], [0,0,1], # tetra
                    [2,0,0], [3,0,0], [3,1,0], [2,1,0],
                    [2,0,1], [3,0,1], [3,1,1], [2,1,1], # Hex
                    ], 'f')
    # shift the points so we can show both.
    points[:,1] += 2.0
    # The cells
    cells = array([4, 0, 1, 2, 3, # tetra
                   8, 4, 5, 6, 7, 8, 9, 10, 11 # hex
                   ])
    # The offsets for the cells, i.e. the indices where the cells
    # start.
    offset = array([0, 5])
    tetra_type = tvtk.Tetra().cell_type # VTK_TETRA == 10
    hex_type = tvtk.Hexahedron().cell_type # VTK_HEXAHEDRON == 12
    cell_types = array([tetra_type, hex_type])
    # Create the array of cells unambiguously.
    cell_array = tvtk.CellArray()
    cell_array.set_cells(2, cells)
    # Now create the UG.
    ug = tvtk.UnstructuredGrid(points=points)
    # Now just set the cell types and reuse the ug locations and cells.
    ug.set_cells(cell_types, offset, cell_array)
    return ug

def save_xml(ug, file_name):
    """Shows how you can save the unstructured grid dataset to a VTK
    XML file."""
    w = tvtk.XMLUnstructuredGridWriter(input=ug, file_name=file_name)
    w.write()

# ----------------------------------------------------------------------
# Create the unstructured grids and assign scalars and vectors.
ug1 = single_type_ug()
ug2 = mixed_type_ug()
temperature = arange(0, 120, 10, 'd')
velocity = random.randn(12, 3)
for ug in ug1, ug2:
    ug.point_data.scalars = temperature
    ug.point_data.scalars.name = 'temperature'
    # Some vectors.
    ug.point_data.vectors = velocity
    ug.point_data.vectors.name = 'velocity'

# Uncomment this to save the file to a VTK XML file.
#save_xml(ug2, 'file.vtu')

# Now view the data.
@mayavi2.standalone
def view():
    from mayavi.sources.vtk_data_source import VTKDataSource
    from mayavi.modules.outline import Outline
    from mayavi.modules.surface import Surface
    from mayavi.modules.vectors import Vectors

    mayavi.new_scene()
    # The single type one
    src = VTKDataSource(data = ug1)
    mayavi.add_source(src)
    mayavi.add_module(Outline())
    mayavi.add_module(Surface())
    mayavi.add_module(Vectors())

    # Mixed types.
    src = VTKDataSource(data = ug2)
    mayavi.add_source(src)
    mayavi.add_module(Outline())
    mayavi.add_module(Surface())
    mayavi.add_module(Vectors())

if __name__ == '__main__':
    view()

########NEW FILE########
__FILENAME__ = pick_on_surface
""" Example showing how to pick data on a surface, going all the way back
to the index in the numpy arrays.

In this example, two views of the same data are shown. One with the data
on a sphere, the other with the data flat.

We use the 'on_mouse_pick' method of the scene to register a callback on
clicking on the sphere. The callback is called with a picker object as
andan argument. We use the point_id of the point that has been picked,
andand  go back to the 2D index on the data matrix to find its position.
"""

################################################################################
# Create some data
import numpy as np
pi  = np.pi
cos = np.cos
sin = np.sin

phi, theta = np.mgrid[0:pi:180j,0:2*pi:180j]
m0 = 4; m1 = 3; m2 = 2; m3 = 3; m4 = 1; m5 = 2; m6 = 2; m7 = 4;
s = sin(m0*phi)**m1 + cos(m2*phi)**m3 + sin(m4*theta)**m5 + cos(m6*theta)**m7
x = sin(phi)*cos(theta)
y = cos(phi)
z = sin(phi)*sin(theta)

################################################################################
# Plot the data
from mayavi import mlab

# A first plot in 3D
fig = mlab.figure(1)
mlab.clf()
mesh = mlab.mesh(x, y, z, scalars=s)
cursor3d = mlab.points3d(0., 0., 0., mode='axes',
                                color=(0, 0, 0),
                                scale_factor=0.5)
mlab.title('Click on the ball')

# A second plot, flat
fig2d = mlab.figure(2)
mlab.clf()
im = mlab.imshow(s)
cursor = mlab.points3d(0, 0, 0, mode='2dthick_cross',
                                color=(0, 0, 0),
                                scale_factor=10)
mlab.view(90, 0)

################################################################################
# Some logic to select 'mesh' and the data index when picking.

def picker_callback(picker_obj):
    picked = picker_obj.actors
    if mesh.actor.actor._vtk_obj in [o._vtk_obj for o in picked]:
        # m.mlab_source.points is the points array underlying the vtk
        # dataset. GetPointId return the index in this array.
        x_, y_ = np.lib.index_tricks.unravel_index(picker_obj.point_id,
                                                                s.shape)
        print "Data indices: %i, %i" % (x_, y_)
        n_x, n_y = s.shape
        cursor.mlab_source.set(x=x_ - n_x/2.,
                               y=y_ - n_y/2.)
        cursor3d.mlab_source.set(x=x[x_, y_],
                                 y=y[x_, y_],
                                 z=z[x_, y_])

fig.on_mouse_pick(picker_callback)

mlab.show()


########NEW FILE########
__FILENAME__ = select_red_balls
"""
This example shows how to use a callback to select a red ball amongst white
balls.

The example uses the figure method 'on_mouse_pick', added in Mayavi
3.4, to register a callback when the left mouse is pressed. The callback
is called with a picker, enabling to identify the object selected.
Specificaly, actors are selected, each object is represented on the scene
via actors. The selected actors can be found in 'picker.actors'. In this
example, we have plotted red balls and white ball. We want to select the
red balls, and thus test if any actor in picker.actors corresponds to an
actor of red balls.

To identify which ball has been selected, we use the point id. However,
each ball is represented by several points. Thus we need to retrieve the
number of points per ball, and divide the point id by this number.

We use an outline to display which ball was selected by positioning it on
the corresponding ball.
"""

# Author: Gael Varoquaux <gael dot varoquaux at normalesup.org>
# Copyright (c) 2009, Enthought, Inc.
# License: BSD style.

import numpy as np
from mayavi import mlab

################################################################################
# Disable the rendering, to get bring up the figure quicker:
figure = mlab.gcf()
mlab.clf()
figure.scene.disable_render = True

# Creates two set of points using mlab.points3d: red point and
# white points
x1, y1, z1 = np.random.random((3, 10))
red_glyphs = mlab.points3d(x1, y1, z1, color=(1, 0, 0),
                resolution=20)

x2, y2, z2 = np.random.random((3, 10))
white_glyphs = mlab.points3d(x2, y2, z2, color=(0.9, 0.9, 0.9),
                resolution=20)

# Add an outline to show the selected point and center it on the first
# data point.
outline = mlab.outline(line_width=3)
outline.outline_mode = 'cornered'
outline.bounds = (x1[0]-0.1, x1[0]+0.1,
                  y1[0]-0.1, y1[0]+0.1,
                  z1[0]-0.1, z1[0]+0.1)

# Every object has been created, we can reenable the rendering.
figure.scene.disable_render = False
################################################################################


# Here, we grab the points describing the individual glyph, to figure
# out how many points are in an individual glyph.
glyph_points = red_glyphs.glyph.glyph_source.glyph_source.output.points.to_array()


def picker_callback(picker):
    """ Picker callback: this get called when on pick events.
    """
    if picker.actor in red_glyphs.actor.actors:
        # Find which data point corresponds to the point picked:
        # we have to account for the fact that each data point is
        # represented by a glyph with several points
        point_id = picker.point_id/glyph_points.shape[0]
        # If the no points have been selected, we have '-1'
        if point_id != -1:
            # Retrieve the coordinnates coorresponding to that data
            # point
            x, y, z = x1[point_id], y1[point_id], z1[point_id]
            # Move the outline to the data point.
            outline.bounds = (x-0.1, x+0.1,
                              y-0.1, y+0.1,
                              z-0.1, z+0.1)


picker = figure.on_mouse_pick(picker_callback)

# Decrease the tolerance, so that we can more easily select a precise
# point.
picker.tolerance = 0.01

mlab.title('Click on red balls')

mlab.show()

########NEW FILE########
__FILENAME__ = explorer3d
#!/usr/bin/env python
""" The entry point for an Envisage application. """

# Standard library imports.
import sys
import os.path
import logging

# Enthought library imports.
from mayavi.plugins.app import get_plugins, setup_logger
from traits.api import List
from envisage.api import Plugin, ServiceOffer
from envisage.ui.workbench.api import WorkbenchApplication
from pyface.workbench.api import Perspective, PerspectiveItem

logger = logging.getLogger()

###############################################################################
# `ExplorerPerspective` class.
###############################################################################
class ExplorerPerspective(Perspective):
    """ An default perspective for the app. """

    # The perspective's name.
    name = 'Explorer3D'

    # Should this perspective be enabled or not?
    enabled = True

    # Should the editor area be shown in this perspective?
    show_editor_area = True

    # View IDs.
    EXPLORER_VIEW = 'explorer3d.Explorer3D'

    # The contents of the perspective.
    contents = [
        PerspectiveItem(id=EXPLORER_VIEW, position='left'),
    ]

###############################################################################
# `ExplorerPlugin` class.
###############################################################################
class ExplorerPlugin(Plugin):

    # Extension points we contribute to.
    PERSPECTIVES = 'envisage.ui.workbench.perspectives'
    VIEWS             = 'envisage.ui.workbench.views'
    SERVICE_OFFERS = 'envisage.ui.workbench.service_offers'

    # The plugin's unique identifier.
    id = 'explorer3d.Explorer3D'

    # The plugin's name (suitable for displaying to the user).
    name = '3D function explorer'

    # Perspectives.
    perspectives = List(contributes_to=PERSPECTIVES)

    # Services we contribute.
    service_offers = List(contributes_to=SERVICE_OFFERS)

    # Views.
    views = List(contributes_to=VIEWS)


    ######################################################################
    # Private methods.
    def _perspectives_default(self):
        """ Trait initializer. """
        return [ExplorerPerspective]

    def _service_offers_default(self):
        """ Trait initializer. """
        explorer_service_offer = ServiceOffer(
            protocol = 'explorer_app.Explorer3D',
            factory  = 'explorer_app.Explorer3D'
        )

        return [explorer_service_offer]

    def _views_default(self):
        """ Trait initializer. """
        return [self._explorer_view_factory]

    def _explorer_view_factory(self, window, **traits):
        """ Factory method for explorer views. """
        from pyface.workbench.traits_ui_view import \
                TraitsUIView

        explorer = self._get_explorer(window)
        tui_engine_view = TraitsUIView(obj=explorer,
                                       id='explorer3d.Explorer3D',
                                       name='Explorer3D',
                                       window=window,
                                       position='left',
                                       **traits
                                       )
        return tui_engine_view

    def _get_explorer(self, window):
        """Return the explorer service."""
        return window.get_service('explorer_app.Explorer3D')


######################################################################
def main():

    # Get the default mayavi plugins.
    plugins = get_plugins()
    # Inject our plugin up front so our perspective becomes the default.
    plugins.insert(0, ExplorerPlugin())

    # Create an Envisage application.
    id = 'explorer3d.Explorer3D'
    application = WorkbenchApplication(id=id,
                                       plugins = plugins
                                       )
    # This needs to be done here since the ETSConfig.application_home is
    # not set correctly up to this point.
    setup_logger(logger, 'explorer3d.log', mode=logging.ERROR)

    # Start the application.
    application.run()

# Application entry point.
if __name__ == '__main__':
    main()


########NEW FILE########
__FILENAME__ = explorer_app
# This code simulates something the user would like to do.  In this
# case the code allows a user to create a 3D cube of data (a numpy
# array), specify an equation for the scalars and view it using the
# mayavi plugin.  The only "envisage bits" are the code that let one
# grab the running mayavi instance and script it.  The application
# trait is set by Envisage and we use the application to get hold of
# the mayavi engine.  Then we show the data once the mayavi engine has
# started.

# Standard library imports.
import numpy

# Enthought library imports
from traits.api import HasTraits, Button, Instance, \
     Any, Str, Array
from traitsui.api import Item, View, TextEditor


######################################################################
# `Explorer3D` class.
######################################################################
class Explorer3D(HasTraits):
    """This class basically allows you to create a 3D cube of data (a
    numpy array), specify an equation for the scalars and view it
    using the mayavi plugin.
    """

    ########################################
    # Traits.

    # Set by envisage when this is offered as a service offer.
    window = Instance('pyface.workbench.api.WorkbenchWindow')

    # The equation that generates the scalar field.
    equation = Str('sin(x*y*z)/(x*y*z)',
                   desc='equation to evaluate (enter to set)',
                   auto_set=False,
                   enter_set=True)

    # Dimensions of the cube of data.
    dimensions = Array(value=(128, 128, 128),
                       dtype=int,
                       shape=(3,),
                       cols=1,
                       labels=['nx', 'ny', 'nz'],
                       desc='the array dimensions')

    # The volume of interest (VOI).
    volume = Array(dtype=float,
                   value=(-5,5,-5,5,-5,5),
                   shape=(6,),
                   cols=2,
                   labels=['xmin','xmax','ymin','ymax','zmin','zmax'],
                   desc='the volume of interest')

    # Clicking this button resets the data with the new dimensions and
    # VOI.
    update_data = Button('Update data')

    ########################################
    # Private traits.
    # Our data source.
    _x = Array
    _y = Array
    _z = Array
    data = Array
    source = Any
    _ipw1 = Any
    _ipw2 = Any
    _ipw3 = Any

    ########################################
    # Our UI view.
    view = View(Item('equation', editor=TextEditor(auto_set=False,
                                                   enter_set=True)),
                Item('dimensions'),
                Item('volume'),
                Item('update_data', show_label=False),
                resizable=True,
                scrollable=True,
                )

    ######################################################################
    # `object` interface.
    ######################################################################
    def __init__(self, **traits):
        super(Explorer3D, self).__init__(**traits)
        # Make some default data.
        if len(self.data) == 0:
            self._make_data()
        # Note: to show the visualization by default we must wait till
        # the mayavi engine has started.  To do this we hook into the
        # mayavi engine's started event and setup our visualization.
        # Now, when this object is constructed (i.e. when this method
        # is invoked), the services are not running yet and our own
        # application instance has not been set.  So we can't even
        # get hold of the mayavi instance.  So, we do the hooking up
        # when our application instance is set by listening for
        # changes to our application trait.

    def get_mayavi(self):
        from mayavi.plugins.script import Script
        return self.window.get_service(Script)

    ######################################################################
    # Non-public methods.
    ######################################################################
    def _make_data(self):
        dims = self.dimensions.tolist()
        np = dims[0]*dims[1]*dims[2]
        xmin, xmax, ymin, ymax, zmin, zmax = self.volume
        x, y, z = numpy.ogrid[xmin:xmax:dims[0]*1j,
                              ymin:ymax:dims[1]*1j,
                              zmin:zmax:dims[2]*1j]
        self._x = x.astype('f')
        self._y = y.astype('f')
        self._z = z.astype('f')
        self._equation_changed('', self.equation)

    def _show_data(self):
        if self.source is not None:
            return
        mayavi = self.get_mayavi()
        if mayavi.engine.current_scene is None:
            mayavi.new_scene()
        from mayavi.sources.array_source import ArraySource
        vol = self.volume
        origin = vol[::2]
        spacing = (vol[1::2] - origin)/(self.dimensions -1)
        src = ArraySource(transpose_input_array=False,
                          scalar_data=self.data,
                          origin=origin,
                          spacing=spacing)
        self.source = src
        mayavi.add_source(src)

        from mayavi.modules.outline import Outline
        from mayavi.modules.image_plane_widget import ImagePlaneWidget
        from mayavi.modules.axes import Axes
        # Visualize the data.
        o = Outline()
        mayavi.add_module(o)
        a = Axes()
        mayavi.add_module(a)
        self._ipw1 = ipw = ImagePlaneWidget()
        mayavi.add_module(ipw)
        ipw.module_manager.scalar_lut_manager.show_scalar_bar = True

        self._ipw2 = ipw_y = ImagePlaneWidget()
        mayavi.add_module(ipw_y)
        ipw_y.ipw.plane_orientation = 'y_axes'

        self._ipw3 = ipw_z = ImagePlaneWidget()
        mayavi.add_module(ipw_z)
        ipw_z.ipw.plane_orientation = 'z_axes'

    ######################################################################
    # Traits static event handlers.
    ######################################################################
    def _equation_changed(self, old, new):
        try:
            g = numpy.__dict__
            s = eval(new, g, {'x':self._x,
                              'y':self._y,
                              'z':self._z})
            # The copy makes the data contiguous and the transpose
            # makes it suitable for display via tvtk.
            s = s.transpose().copy()
            # Reshaping the array is needed since the transpose
            # messes up the dimensions of the data.  The scalars
            # themselves are ravel'd and used internally by VTK so the
            # dimension does not matter for the scalars.
            s.shape = s.shape[::-1]
            self.data = s
        except:
            pass

    def _dimensions_changed(self):
        """This does nothing and only changes to update_data do
        anything.
        """
        return

    def _volume_changed(self):
        return

    def _update_data_fired(self):
        self._make_data()
        src = self.source
        if src is not None:
            vol = self.volume
            origin = vol[::2]
            spacing = (vol[1::2] - origin)/(self.dimensions -1)
            # Set the source spacing and origin.
            src.set(spacing=spacing, origin=origin)
            # Update the sources data.
            src.update_image_data = True
            self._reset_ipw()

    def _reset_ipw(self):
        ipw1, ipw2, ipw3 = self._ipw1, self._ipw2, self._ipw3
        if ipw1.running:
            ipw1.ipw.place_widget()
        if ipw2.running:
            ipw2.ipw.place_widget()
            ipw2.ipw.plane_orientation = 'y_axes'
        if ipw3.running:
            ipw3.ipw.place_widget()
            ipw3.ipw.plane_orientation = 'z_axes'
        self.source.render()

    def _data_changed(self, value):
        if self.source is None:
            return
        self.source.scalar_data = value

    def _window_changed(self):
        m = self.get_mayavi()
        if m.engine.running:
            if len(self.data) == 0:
                # Happens since the window may be set on __init__ at
                # which time the data is not created.
                self._make_data()
            self._show_data()
        else:
            # Show the data once the mayavi engine has started.
            m.engine.on_trait_change(self._show_data, 'started')


########NEW FILE########
__FILENAME__ = adjust_cropping_extents
"""
A custom dialog to adjust the parameters of a GeometryFilter to crop
data points.

This example shows how to use a GeometryFilter to crop data points, but
also how to build a custom dialog to easily set interactively parameters
of a filter, or any other Mayavi object.

The GeometryFilter crops all data within a bounding box specified by
'extents'. In this example, we want to be able to tweak these extents
interactively. For this, we build a Traits object that has 'x_min',
'x_max', 'y_min', ... attributes. Traits enables us to represent this
object as a dialog box. We use a callback called when these attributes
are modified to propagate them to the filter. For more information
on creating GUIs with Traits:

    http://code.enthought.com/projects/traits/docs/html/tutorials/traits_ui_scientific_app.html

    http://code.enthought.com/projects/traits/documentation.php

"""
# Author: Gael Varoquaux <gael.varoquaux@normalesup.org>
# Copyright (c) 2010, Enthought, Inc.
# License: BSD Style.


################################################################################
# Create a set of points, with given density
import numpy as np
x, y, z, s = np.random.random((4, 500))

################################################################################
# A dialog to edit a range interactively and propagate it to the filter
from traits.api import HasTraits, Range, Float, Instance, \
    on_trait_change
from traitsui.api import View

class ExtentDialog(HasTraits):
    """ A dialog to graphical adjust the extents of a filter.
    """

    # Data extents
    data_x_min = Float
    data_x_max = Float
    data_y_min = Float
    data_y_max = Float
    data_z_min = Float
    data_z_max = Float

    x_min = Range('data_x_min', 'data_x_max', 'data_x_min')
    x_max = Range('data_x_min', 'data_x_max', 'data_x_max')
    y_min = Range('data_y_min', 'data_y_max', 'data_y_min')
    y_max = Range('data_y_min', 'data_y_max', 'data_y_max')
    z_min = Range('data_z_min', 'data_z_max', 'data_z_min')
    z_max = Range('data_z_min', 'data_z_max', 'data_z_max')

    filter = Instance(HasTraits, allow_none=False)

    @on_trait_change('x_min,x_max,y_min,y_max,z_min,z_max')
    def update_extent(self):
        if (self.filter is not None
                    and self.x_min < self.x_max
                    and self.y_min < self.y_max
                    and self.z_min < self.z_max
                            ):
            self.filter.extent = (self.x_min, self.x_max,
                                  self.y_min, self.y_max,
                                  self.z_min, self.z_max)

    view = View('x_min', 'x_max', 'y_min', 'y_max', 'z_min', 'z_max',
                title='Edit extent', resizable=True)


################################################################################
# Now build the visualization using mlab
from mayavi import mlab
fig = mlab.figure(1, bgcolor=(1, 1, 1))

# Create unconnected points
pts = mlab.pipeline.scalar_scatter(x, y, z, s)
mlab.outline(pts)

# Use a geometry_filter to filter with a bounding box
geometry_filter = mlab.pipeline.user_defined(pts,
                                   filter='GeometryFilter')
geometry_filter.filter.extent_clipping = True
# Connect our dialog to the filter
extent_dialog = ExtentDialog(
            data_x_min=0, data_x_max=1,
            data_y_min=0, data_y_max=1,
            data_z_min=0, data_z_max=1,
            filter=geometry_filter.filter)
# We need to use 'edit_traits' and not 'configure_traits()' as we do
# not want to start the GUI event loop (the call to mlab.show())
# at the end of the script will do it.
extent_dialog.edit_traits()

# The geometry_filter leaves hanging points, we need to add a
# CleanPolyData filter to get rid of these.
clip = mlab.pipeline.user_defined(geometry_filter,
                                    filter='CleanPolyData')

# Finally, visualize the remaining points with spheres using a glyph
# module
spheres = mlab.pipeline.glyph(clip, scale_factor=.1)

mlab.show()

########NEW FILE########
__FILENAME__ = coil_design_application
"""
An full-blown application demoing a domain-specific usecase with Mayavi:
interactive design of coils.

This is example of electromagnetic coils design, an application is built to
enable a user to interactively position current loops while visualizing the
resulting magnetic field. For this purpose, it is best to use object-oriented
programming. Each current loop is written as an object (the `Loop` class), with
position, radius and direction attributes, and that knows how to calculate the
magnetic field it generates: its `Bnorm` is a property, that is recomputed when
the loop characteristic changes. These loop objects are available to the main
application class as a list. The total magnetic field created is the sum of
each individual magnetic field. It can be visualized via a Mayavi scene
embedded in the application class. As we use Traited objects for the current
loops, a dialog enabling modification of their attributes can be generated by
Traits and embedded in our application.

The full power of Mayavi is available to the application. Via the pipeline tree
view, the user can modify the visualization. Familiar interaction and movements
are possible in the figure. So is saving the visualization, or loading data. In
addition, as the visualization model, described by the pipeline, is separated
from the data that is visualized, contained in the data source, any
visualization module added by the user will update when coils are added or
changed.

Simpler examples of magnetic field visualization can be found on
:ref:`example_magnetic_field_lines` and :ref:`example_magnetic_field`.
The material required to understand this example is covered in section
:ref:`builing_applications`.

"""
# Author: Gael Varoquaux <gael.varoquaux@normalesup.org>
# Copyright (c) 2009, Enthought, Inc.
# License: BSD Style.

# Major scientific library imports
import numpy as np
from scipy import linalg, special

# Enthought library imports:
from traits.api import HasTraits, Array, CFloat, List, \
   Instance, on_trait_change, Property
from traitsui.api import Item, View, ListEditor, \
        HSplit, VSplit
from mayavi.core.ui.api import EngineView, MlabSceneModel, \
        SceneEditor

##############################################################################
# Module-level variables

# The grid of points on which we want to evaluate the field
X, Y, Z = np.mgrid[-0.15:0.15:20j, -0.15:0.15:20j, -0.15:0.15:20j]
# Avoid rounding issues :
f = 1e4  # this gives the precision we are interested by :
X = np.round(X * f) / f
Y = np.round(Y * f) / f
Z = np.round(Z * f) / f

##############################################################################
# A current loop class
class Loop(HasTraits):
    """ A current loop class.
    """

    #-------------------------------------------------------------------------
    # Public traits
    #-------------------------------------------------------------------------
    direction = Array(float, value=(0, 0, 1), cols=3,
                    shape=(3,), desc='directing vector of the loop',
                    enter_set=True, auto_set=False)

    radius    = CFloat(0.1, desc='radius of the loop',
                    enter_set=True, auto_set=False)

    position  = Array(float, value=(0, 0, 0), cols=3,
                    shape=(3,), desc='position of the center of the loop',
                    enter_set=True, auto_set=False)

    _plot      = None

    Bnorm   = Property(depends_on='direction,position,radius')

    view = View('position', 'direction', 'radius', '_')


    #-------------------------------------------------------------------------
    # Loop interface
    #-------------------------------------------------------------------------
    def base_vectors(self):
        """ Returns 3 orthognal base vectors, the first one colinear to
            the axis of the loop.
        """
        # normalize n
        n = self.direction / (self.direction**2).sum(axis=-1)

        # choose two vectors perpendicular to n
        # choice is arbitrary since the coil is symetric about n
        if  np.abs(n[0])==1 :
            l = np.r_[n[2], 0, -n[0]]
        else:
            l = np.r_[0, n[2], -n[1]]

        l /= (l**2).sum(axis=-1)
        m = np.cross(n, l)
        return n, l, m


    @on_trait_change('Bnorm')
    def redraw(self):
        if hasattr(self, 'app') and self.app.scene._renderer is not None:
            self.display()
            self.app.visualize_field()


    def display(self):
        """
        Display the coil in the 3D view.
        """
        n, l, m = self.base_vectors()
        theta = np.linspace(0, 2*np.pi, 30)[..., np.newaxis]
        coil = self.radius*(np.sin(theta)*l + np.cos(theta)*m)
        coil += self.position
        coil_x, coil_y, coil_z = coil.T
        if self._plot is None:
            self._plot = self.app.scene.mlab.plot3d(coil_x, coil_y, coil_z,
                                    tube_radius=0.007, color=(0, 0, 1),
                                    name='Coil')
        else:
            self._plot.mlab_source.set(x=coil_x, y=coil_y, z=coil_z)


    def _get_Bnorm(self):
        """
        returns the magnetic field for the current loop calculated
        from eqns (1) and (2) in Phys Rev A Vol. 35, N 4, pp. 1535-1546; 1987.
        """
        ### Translate the coordinates in the coil's frame
        n, l, m = self.base_vectors()
        R       = self.radius
        r0      = self.position
        r       = np.c_[np.ravel(X), np.ravel(Y), np.ravel(Z)]

        # transformation matrix coil frame to lab frame
        trans = np.vstack((l, m, n))

        r -= r0   #point location from center of coil
        r = np.dot(r, linalg.inv(trans) )           #transform vector to coil frame

        #### calculate field

        # express the coordinates in polar form
        x = r[:, 0]
        y = r[:, 1]
        z = r[:, 2]
        rho = np.sqrt(x**2 + y**2)
        theta = np.arctan2(x, y)

        E = special.ellipe((4 * R * rho)/( (R + rho)**2 + z**2))
        K = special.ellipk((4 * R * rho)/( (R + rho)**2 + z**2))
        Bz =  1/np.sqrt((R + rho)**2 + z**2) * (
                    K
                  + E * (R**2 - rho**2 - z**2)/((R - rho)**2 + z**2)
                )
        Brho = z/(rho*np.sqrt((R + rho)**2 + z**2)) * (
                -K
                + E * (R**2 + rho**2 + z**2)/((R - rho)**2 + z**2)
                )
        # On the axis of the coil we get a divided by zero here. This returns a
        # NaN, where the field is actually zero :
        Brho[np.isnan(Brho)] = 0

        B = np.c_[np.cos(theta)*Brho, np.sin(theta)*Brho, Bz ]

        # Rotate the field back in the lab's frame
        B = np.dot(B, trans)

        Bx, By, Bz = B.T
        Bx = np.reshape(Bx, X.shape)
        By = np.reshape(By, X.shape)
        Bz = np.reshape(Bz, X.shape)

        Bnorm = np.sqrt(Bx**2 + By**2 + Bz**2)

        # We need to threshold ourselves, rather than with VTK, to be able
        # to use an ImageData
        Bmax = 10 * np.median(Bnorm)

        Bx[Bnorm > Bmax] = np.NAN
        By[Bnorm > Bmax] = np.NAN
        Bz[Bnorm > Bmax] = np.NAN
        Bnorm[Bnorm > Bmax] = np.NAN

        self.Bx = Bx
        self.By = By
        self.Bz = Bz
        return Bnorm


##############################################################################
# The application object
class Application(HasTraits):

    scene = Instance(MlabSceneModel, (), editor=SceneEditor())

    # The mayavi engine view.
    engine_view = Instance(EngineView)

    coils = List(Instance(Loop, (), allow_none=False),
                        editor=ListEditor(style='custom'),
                        value=[ Loop(position=(0, 0, -0.05), ),
                                 Loop(position=(0, 0,  0.05), ), ])


    Bx    = Array(value=np.zeros_like(X))
    By    = Array(value=np.zeros_like(X))
    Bz    = Array(value=np.zeros_like(X))
    Bnorm = Array(value=np.zeros_like(X))

    vector_field = None

    def __init__(self, **traits):
        HasTraits.__init__(self, **traits)
        self.engine_view = EngineView(engine=self.scene.engine)


    @on_trait_change('scene.activated,coils')
    def init_view(self):
        if self.scene._renderer is not None:
            self.scene.scene_editor.background = (0, 0, 0)
            for coil in self.coils:
                coil.app = self
                coil.display()

            self.visualize_field()

    def visualize_field(self):
        self.Bx    = np.zeros_like(X)
        self.By    = np.zeros_like(X)
        self.Bz    = np.zeros_like(X)
        self.Bnorm = np.zeros_like(X)
        self.scene.scene.disable_render = True
        for coil in self.coils:
            self.Bx += coil.Bx
            self.By += coil.By
            self.Bz += coil.Bz

        self.Bnorm = np.sqrt(self.Bx**2 + self.By**2 + self.Bz**2)

        if self.vector_field is None:
            self.vector_field = self.scene.mlab.pipeline.vector_field(
                                    X, Y, Z, self.Bx, self.By, self.Bz,
                                    scalars=self.Bnorm,
                                    name='B field')
            vectors = self.scene.mlab.pipeline.vectors(self.vector_field,
                                    mode='arrow', resolution=10,
                                    mask_points=6, colormap='YlOrRd',
                                    scale_factor=2*np.abs(X[0,0,0]
                                                          -X[1,1,1]) )
            vectors.module_manager.vector_lut_manager.reverse_lut = True
            vectors.glyph.mask_points.random_mode = False
            self.scene.mlab.axes()
            self.scp = self.scene.mlab.pipeline.scalar_cut_plane(
                                                      self.vector_field,
                                                      colormap='hot')
        else:
            # Modify in place the data source. The visualization will
            # update automaticaly
            self.vector_field.mlab_source.set(u=self.Bx, v=self.By, w=self.Bz,
                                              scalars=self.Bnorm)
        self.scene.scene.disable_render = False


    view = View(HSplit(
                    VSplit(Item(name='engine_view',
                                   style='custom',
                                   resizable=True),
                            Item('coils', springy=True),
                        show_labels=False),
                        'scene',
                        show_labels=False),
                    resizable=True,
                    title='Coils...',
                    height=0.8,
                    width=0.8,
                )


##############################################################################
if __name__ == '__main__':
    app = Application()
    app.configure_traits()


########NEW FILE########
__FILENAME__ = compute_in_thread
#!/usr/bin/env python
"""
This script demonstrates how one can do a computation in another thread
and update the mayavi pipeline. It also shows how to create a numpy array
data and visualize it as image data using a few modules.
"""
# Author: Prabhu Ramachandran <prabhu_r@users.sf.net>
# Copyright (c) 2007-2008, Enthought, Inc.
# License: BSD Style.

# Standard library imports
import numpy
from threading import Thread
from time import sleep

# Enthought library imports
from mayavi.scripts import mayavi2
from traits.api import HasTraits, Button, Instance
from traitsui.api import View, Item
from mayavi.sources.array_source import ArraySource
from mayavi.modules.outline import Outline
from mayavi.modules.image_plane_widget import ImagePlaneWidget
from pyface.api import GUI


def make_data(dims=(128, 128, 128)):
    """Creates some simple array data of the given dimensions to test
    with."""
    np = dims[0]*dims[1]*dims[2]

    # Create some scalars to render.
    x, y, z = numpy.ogrid[-5:5:dims[0]*1j,-5:5:dims[1]*1j,-5:5:dims[2]*1j]
    x = x.astype('f')
    y = y.astype('f')
    z = z.astype('f')

    scalars = (numpy.sin(x*y*z)/(x*y*z))
    # The copy makes the data contiguous and the transpose makes it
    # suitable for display via tvtk.  Please note that we assume here
    # that the ArraySource is configured to not transpose the data.
    s = numpy.transpose(scalars).copy()
    # Reshaping the array is needed since the transpose messes up the
    # dimensions of the data.  The scalars themselves are ravel'd and
    # used internally by VTK so the dimension does not matter for the
    # scalars.
    s.shape = s.shape[::-1]
    return s


class ThreadedAction(Thread):
    def __init__(self, data, **kwargs):
        Thread.__init__(self, **kwargs)
        self.data = data

    def run(self):
        print "Performing expensive calculation in %s..."%self.getName(),
        sleep(3)
        sd = self.data.scalar_data
        sd += numpy.sin(numpy.random.rand(*sd.shape)*2.0*numpy.pi)
        GUI.invoke_later(self.data.update)
        print 'done.'


class Controller(HasTraits):
    run_calculation = Button('Run calculation')
    data = Instance(ArraySource)

    view = View(Item(name='run_calculation'))

    def _run_calculation_changed(self, value):
        action = ThreadedAction(self.data)
        action.start()


@mayavi2.standalone
def view_numpy():
    """Example showing how to view a 3D numpy array in mayavi2.
    """
    # 'mayavi' is always defined on the interpreter.
    mayavi.new_scene()
    # Make the data and add it to the pipeline.
    data = make_data()
    src = ArraySource(transpose_input_array=False)
    src.scalar_data = data
    mayavi.add_source(src)
    # Visualize the data.
    o = Outline()
    mayavi.add_module(o)
    ipw = ImagePlaneWidget()
    mayavi.add_module(ipw)
    ipw.module_manager.scalar_lut_manager.show_scalar_bar = True

    ipw_y = ImagePlaneWidget()
    mayavi.add_module(ipw_y)
    ipw_y.ipw.plane_orientation = 'y_axes'

    computation = Controller(data=src)
    computation.edit_traits()


if __name__ == '__main__':
    view_numpy()


########NEW FILE########
__FILENAME__ = lorenz_ui
"""
This example displays the trajectories for the Lorenz system of
equations using mlab along with the z-nullcline.  It provides a simple
UI where a user can change the parameters and the system of equations on
the fly.  This primarily demonstrates how one can build powerful tools
with a UI using Traits and Mayavi.

For explanations and more examples of interactive application building
with Mayavi, please refer to section :ref:`builing_applications`.
"""
# Author: Prabhu Ramachandran <prabhu@aero.iitb.ac.in>
# Copyright (c) 2008-2009, Enthought, Inc.
# License: BSD Style.

import numpy as np
import scipy

from traits.api import HasTraits, Range, Instance, \
        on_trait_change, Array, Tuple, Str
from traitsui.api import View, Item, HSplit, Group

from mayavi import mlab
from mayavi.core.ui.api import MayaviScene, MlabSceneModel, \
    SceneEditor

################################################################################
# `Lorenz` class.
################################################################################
class Lorenz(HasTraits):

    # The parameters for the Lorenz system, defaults to the standard ones.
    s = Range(0.0, 20.0, 10.0, desc='the parameter s', enter_set=True,
              auto_set=False)
    r = Range(0.0, 50.0, 28.0, desc='the parameter r', enter_set=True,
              auto_set=False)
    b = Range(0.0, 10.0, 8./3., desc='the parameter b', enter_set=True,
              auto_set=False)

    # These expressions are evaluated to compute the right hand sides of
    # the ODE.  Defaults to the Lorenz system.
    u = Str('s*(y-x)', desc='the x component of the velocity',
            auto_set=False, enter_set=True)
    v = Str('r*x - y - x*z', desc='the y component of the velocity',
            auto_set=False, enter_set=True)
    w = Str('x*y - b*z', desc='the z component of the velocity',
            auto_set=False, enter_set=True)

    # Tuple of x, y, z arrays where the field is sampled.
    points = Tuple(Array, Array, Array)

    # The mayavi(mlab) scene.
    scene = Instance(MlabSceneModel, args=())

    # The "flow" which is a Mayavi streamline module.
    flow = Instance(HasTraits)

    ########################################
    # The UI view to show the user.
    view = View(HSplit(
                    Group(
                        Item('scene', editor=SceneEditor(scene_class=MayaviScene),
                             height=500, width=500, show_label=False)),
                    Group(
                        Item('s'),
                        Item('r'),
                        Item('b'),
                        Item('u'), Item('v'), Item('w')),
                    ),
                resizable=True
                )

    ######################################################################
    # Trait handlers.
    ######################################################################

    # Note that in the `on_trait_change` call below we listen for the
    # `scene.activated` trait.  This conveniently ensures that the flow
    # is generated as soon as the mlab `scene` is activated (which
    # happens when the configure/edit_traits method is called).  This
    # eliminates the need to manually call the `update_flow` method etc.
    @on_trait_change('s, r, b, scene.activated')
    def update_flow(self):
        x, y, z = self.points
        u, v, w = self.get_uvw()
        self.flow.mlab_source.set(u=u, v=v, w=w)

    @on_trait_change('u')
    def update_u(self):
        self.flow.mlab_source.set(u=self.get_vel('u'))

    @on_trait_change('v')
    def update_v(self):
        self.flow.mlab_source.set(v=self.get_vel('v'))

    @on_trait_change('w')
    def update_w(self):
        self.flow.mlab_source.set(w=self.get_vel('w'))

    def get_uvw(self):
        return self.get_vel('u'), self.get_vel('v'), self.get_vel('w')

    def get_vel(self, comp):
        """This function basically evaluates the user specified system
        of equations using scipy.
        """
        func_str = getattr(self, comp)
        try:
            g = scipy.__dict__
            x, y, z = self.points
            s, r, b = self.s, self.r, self.b
            val = eval(func_str, g,
                        {'x': x, 'y': y, 'z': z,
                         's':s, 'r':r, 'b': b})
        except:
            # Mistake, so return the original value.
            val = getattr(self.flow.mlab_source, comp)
        return val

    ######################################################################
    # Private interface.
    ######################################################################
    def _points_default(self):
        x, y, z = np.mgrid[-50:50:100j,-50:50:100j,-10:60:70j]
        return x, y, z

    def _flow_default(self):
        x, y, z = self.points
        u, v, w = self.get_uvw()
        f = self.scene.mlab.flow(x, y, z, u, v, w)
        f.stream_tracer.integration_direction = 'both'
        f.stream_tracer.maximum_propagation = 200
        src = f.mlab_source.m_data
        o = mlab.outline()
        mlab.view(120, 60, 150)
        return f


if __name__ == '__main__':
    # Instantiate the class and configure its traits.
    lor = Lorenz()
    lor.configure_traits()


########NEW FILE########
__FILENAME__ = mayavi_traits_ui
#!/usr/bin/env python
"""
An example of how to create a UI similar to the complete Mayavi application
inside a Traits UI view.

This does not use Envisage and provides a similar UI as seen in the full
Mayavi application.

This example uses `traitsUI <http://code.enthought.com/projects/traits/>`_
to create a dialog mimicking the mayavi2 application: a scene on the
right, and on the left a pipeline tree view, and below it a panel to
edit the currently-selected object.
"""

# Authors: Prabhu Ramachandran <prabhu [at] aero.iitb.ac.in>
# Copyright (c) 2007, Enthought, Inc.
# License: BSD Style.

# Standard imports.
from numpy import sqrt, sin, mgrid

# Enthought imports.
from traits.api import HasTraits, Instance, Property, Enum
from traitsui.api import View, Item, HSplit, VSplit, InstanceEditor
from tvtk.pyface.scene_editor import SceneEditor
from mayavi.core.ui.engine_view import EngineView
from mayavi.tools.mlab_scene_model import MlabSceneModel


######################################################################
class Mayavi(HasTraits):

    # The scene model.
    scene = Instance(MlabSceneModel, ())

    # The mayavi engine view.
    engine_view = Instance(EngineView)

    # The current selection in the engine tree view.
    current_selection = Property


    ######################
    view = View(HSplit(VSplit(Item(name='engine_view',
                                   style='custom',
                                   resizable=True,
                                   show_label=False
                                   ),
                              Item(name='current_selection',
                                   editor=InstanceEditor(),
                                   enabled_when='current_selection is not None',
                                   style='custom',
                                   springy=True,
                                   show_label=False),
                                   ),
                               Item(name='scene',
                                    editor=SceneEditor(),
                                    show_label=False,
                                    resizable=True,
                                    height=500,
                                    width=500),
                        ),
                resizable=True,
                scrollable=True
                )

    def __init__(self, **traits):
        HasTraits.__init__(self, **traits)
        self.engine_view = EngineView(engine=self.scene.engine)

        # Hook up the current_selection to change when the one in the engine
        # changes.  This is probably unnecessary in Traits3 since you can show
        # the UI of a sub-object in T3.
        self.scene.engine.on_trait_change(self._selection_change,
                                          'current_selection')

        self.generate_data_mayavi()

    def generate_data_mayavi(self):
        """Shows how you can generate data using mayavi instead of mlab."""
        from mayavi.sources.api import ParametricSurface
        from mayavi.modules.api import Outline, Surface
        e = self.scene.engine
        s = ParametricSurface()
        e.add_source(s)
        e.add_module(Outline())
        e.add_module(Surface())

    def _selection_change(self, old, new):
        self.trait_property_changed('current_selection', old, new)

    def _get_current_selection(self):
        return self.scene.engine.current_selection


if __name__ == '__main__':
    m = Mayavi()
    m.configure_traits()

########NEW FILE########
__FILENAME__ = mlab_interactive_dialog
#!/usr/bin/env python
"""
An example of how to modify the data visualized  via an interactive dialog.

A dialog is created via `TraitsUI
<http://code.enthought.com/projects/traits/>`_ from an object (MyModel).
Some attributes of the objects are represented on the dialog: first a
Mayavi scene, that will host our visualization, and two parameters that
control the data plotted.

A curve is plotted in the embedded scene using the associated
mlab.points3d function. The visualization object created is stored
as an attribute on the main MyModel object, to modify it inplace later.

When the `n_meridional` and `n_longitudinal` attributes are modified, eg via
the slide bars on the dialog, the curve is recomputed, and the
visualization is updated by modifying inplace the stored plot
object (see :ref:`mlab-animating-data`).

This example is discussed in details in the section
:ref:`embedding_mayavi_traits`.
"""
# Author: Gael Varoquaux <gael.varoquaux@normalesup.org>
# Copyright (c) 2008, Enthought, Inc.
# License: BSD Style.


from numpy import arange, pi, cos, sin

from traits.api import HasTraits, Range, Instance, \
        on_trait_change
from traitsui.api import View, Item, Group

from mayavi.core.api import PipelineBase
from mayavi.core.ui.api import MayaviScene, SceneEditor, \
                MlabSceneModel


dphi = pi/1000.
phi = arange(0.0, 2*pi + 0.5*dphi, dphi, 'd')

def curve(n_mer, n_long):
    mu = phi*n_mer
    x = cos(mu) * (1 + cos(n_long * mu/n_mer)*0.5)
    y = sin(mu) * (1 + cos(n_long * mu/n_mer)*0.5)
    z = 0.5 * sin(n_long*mu/n_mer)
    t = sin(mu)
    return x, y, z, t


class MyModel(HasTraits):
    n_meridional    = Range(0, 30, 6, )#mode='spinner')
    n_longitudinal  = Range(0, 30, 11, )#mode='spinner')

    scene = Instance(MlabSceneModel, ())

    plot = Instance(PipelineBase)


    # When the scene is activated, or when the parameters are changed, we
    # update the plot.
    @on_trait_change('n_meridional,n_longitudinal,scene.activated')
    def update_plot(self):
        x, y, z, t = curve(self.n_meridional, self.n_longitudinal)
        if self.plot is None:
            self.plot = self.scene.mlab.plot3d(x, y, z, t,
                                tube_radius=0.025, colormap='Spectral')
        else:
            self.plot.mlab_source.set(x=x, y=y, z=z, scalars=t)


    # The layout of the dialog created
    view = View(Item('scene', editor=SceneEditor(scene_class=MayaviScene),
                     height=250, width=300, show_label=False),
                Group(
                        '_', 'n_meridional', 'n_longitudinal',
                     ),
                resizable=True,
                )

my_model = MyModel()
my_model.configure_traits()

########NEW FILE########
__FILENAME__ = mlab_traits_ui
#!/usr/bin/env python
"""A simple example of how to use mayavi.mlab inside a traits UI dialog.

This example uses traitsUI (
`traitsUI <http://code.enthought.com/projects/traits/>`_ ) to create a
the simplest possible dialog: a single Mayavi scene in a window.
"""

# Authors: Prabhu Ramachandran <prabhu [at] aero.iitb.ac.in>
#          Gael Varoquaux
# Copyright (c) 2007, Enthought, Inc.
# License: BSD Style.

# Standard imports.
from numpy import sqrt, sin, mgrid

# Enthought imports.
from traits.api import HasTraits, Instance
from traitsui.api import View, Item
from tvtk.pyface.scene_editor import SceneEditor

from mayavi.tools.mlab_scene_model import MlabSceneModel
from mayavi.core.ui.mayavi_scene import MayaviScene


######################################################################
class ActorViewer(HasTraits):

    # The scene model.
    scene = Instance(MlabSceneModel, ())

    ######################
    # Using 'scene_class=MayaviScene' adds a Mayavi icon to the toolbar,
    # to pop up a dialog editing the pipeline.
    view = View(Item(name='scene',
                     editor=SceneEditor(scene_class=MayaviScene),
                     show_label=False,
                     resizable=True,
                     height=500,
                     width=500),
                resizable=True
                )

    def __init__(self, **traits):
        HasTraits.__init__(self, **traits)
        self.generate_data()

    def generate_data(self):
        # Create some data
        X, Y = mgrid[-2:2:100j, -2:2:100j]
        R = 10*sqrt(X**2 + Y**2)
        Z = sin(R)/R

        self.scene.mlab.surf(X, Y, Z, colormap='gist_earth')


if __name__ == '__main__':
    a = ActorViewer()
    a.configure_traits()

########NEW FILE########
__FILENAME__ = mlab_visual
#!/usr/bin/env python
"""
A very simple example to show how you can use TVTK's visual module
with mlab and create simple animations.

In the example, the grey box bounces back and forth between the two red
ones.

The `tvtk.tools.visual` module exposes an API similar to
`VPython <http://vpython.org/>`_ and is useful to create animation based
on rigid object movement.

The `@animate` decorator ( :func:`mayavi.mlab.animate` ) is
detailed on section :ref:`animating_a_visualization`.

If you want to modify the data plotted by the mlab (as in the
`mlab.test_plot3d()` call) to create an animation, please see section
:ref:`mlab-animating-data`.

"""
# Author: Prabhu Ramachandran <prabhu [at] aero.iitb.ac.in>
# Copyright (c) 2009, Enthought, Inc.
# License: BSD Style.

from mayavi import mlab
from tvtk.tools import visual
# Create a figure
f = mlab.figure(size=(500,500))
# Tell visual to use this as the viewer.
visual.set_viewer(f)

# A silly visualization.
mlab.test_plot3d()

# Even sillier animation.
b1 = visual.box()
b2 = visual.box(x=4., color=visual.color.red)
b3 = visual.box(x=-4, color=visual.color.red)
b1.v = 5.0

@mlab.show
@mlab.animate(delay=250)
def anim():
    """Animate the b1 box."""
    while 1:
        b1.x = b1.x + b1.v*0.1
        if b1.x > 2.5 or b1.x < -2.5:
            b1.v = -b1.v
        yield

# Run the animation.
anim()

########NEW FILE########
__FILENAME__ = multiple_engines
"""
An example to show how you can have multiple engines in one application.

Mutliple engines can be useful for more separation, eg to script each
engine separately, or to avoid side effects between scenes.

This example shows how to explicitely set the engine for an embedded
scene.

To define default arguments, it makes use of the Traits initialization
style, rather than overridding the __init__.
"""
# Author:  Gael Varoquaux <gael _dot_ varoquaux _at_ normalesup _dot_ org>
# Copyright (c) 2009, Enthought, Inc.
# License: BSD Style.

from traits.api import HasTraits, Instance, on_trait_change
from traitsui.api import View, Group, Item

from mayavi.core.api import Engine
from mayavi.core.ui.api import MayaviScene, MlabSceneModel, \
            SceneEditor

################################################################################
class MyApp(HasTraits):

    # The first engine. As default arguments (an empty tuple) are given,
    # traits initializes it.
    engine1 = Instance(Engine, args=())

    scene1 = Instance(MlabSceneModel)

    def _scene1_default(self):
        " The default initializer for 'scene1' "
        self.engine1.start()
        scene1 = MlabSceneModel(engine=self.engine1)
        return scene1

    engine2 = Instance(Engine, ())

    scene2 = Instance(MlabSceneModel)

    def _scene2_default(self):
        " The default initializer for 'scene2' "
        self.engine2.start()
        scene2 = MlabSceneModel(engine=self.engine2)
        return scene2

    # We populate the scenes only when it is activated, to avoid problems
    # with VTK objects that expect an active scene
    @on_trait_change('scene1.activated')
    def populate_scene1(self):
        self.scene1.mlab.test_surf()

    @on_trait_change('scene2.activated')
    def populate_scene2(self):
        self.scene2.mlab.test_mesh()

    # The layout of the view
    view = View(Group(Item('scene1',
                        editor=SceneEditor(scene_class=MayaviScene),
                        width=480, height=480)),
                Group(Item('scene2',
                        editor=SceneEditor(scene_class=MayaviScene),
                        width=480, height=480)),
                resizable=True)


if __name__ == '__main__':
    MyApp().configure_traits()


########NEW FILE########
__FILENAME__ = multiple_mlab_scene_models
""" Example showing a dialog with multiple embedded scenes.

When using several embedded scenes with mlab, you should be very careful
always to pass the scene you want to use for plotting to the mlab
function used, elsewhere it uses the current scene. In this example,
failing to do so would result in only one scene being used, the last
one created.

The trick is to use the 'mayavi_scene' attribute of the MlabSceneModel,
and pass it as a keyword argument to the mlab functions.

For more examples on embedding mlab scenes in dialog, see also:
the examples :ref:`example_mlab_interactive_dialog`, and
:ref:`example_lorenz_ui`, as well as the section of the user manual
:ref:`embedding_mayavi_traits`.
"""
import numpy as np

from traits.api import HasTraits, Instance, Button, \
    on_trait_change
from traitsui.api import View, Item, HSplit, Group

from mayavi import mlab
from mayavi.core.ui.api import MlabSceneModel, SceneEditor


class MyDialog(HasTraits):

    scene1 = Instance(MlabSceneModel, ())
    scene2 = Instance(MlabSceneModel, ())

    button1 = Button('Redraw')
    button2 = Button('Redraw')

    @on_trait_change('button1')
    def redraw_scene1(self):
        self.redraw_scene(self.scene1)

    @on_trait_change('button2')
    def redraw_scene2(self):
        self.redraw_scene(self.scene2)

    def redraw_scene(self, scene):
        # Notice how each mlab call points explicitely to the figure it
        # applies to.
        mlab.clf(figure=scene.mayavi_scene)
        x, y, z, s = np.random.random((4, 100))
        mlab.points3d(x, y, z, s, figure=scene.mayavi_scene)

    # The layout of the dialog created
    view = View(HSplit(
                  Group(
                       Item('scene1',
                            editor=SceneEditor(), height=250,
                            width=300),
                       'button1',
                       show_labels=False,
                  ),
                  Group(
                       Item('scene2',
                            editor=SceneEditor(), height=250,
                            width=300, show_label=False),
                       'button2',
                       show_labels=False,
                  ),
                ),
                resizable=True,
                )


m = MyDialog()
m.configure_traits()

########NEW FILE########
__FILENAME__ = poll_file
#!/usr/bin/env python
"""A simple script that polls a data file for changes and then updates
the mayavi pipeline automatically.

This script is to be run like so::

 $ mayavi2 -x poll_file.py

Or::

 $ python poll_file.py

The script currently defaults to using the example data in
examples/data/heart.vtk.  You can try editing that data file or change
this script to point to other data which you can edit.
"""

# Author: Prabhu Ramachandran <prabhu@aero.iitb.ac.in>
# Copyright (c) 2006-2007, Enthought Inc.
# License: BSD Style.

# Standard imports.
import os
from os.path import join, abspath, dirname

# Enthought library imports
from mayavi.scripts import mayavi2
from mayavi.sources.vtk_file_reader import VTKFileReader
from mayavi.modules.outline import Outline
from mayavi.modules.contour_grid_plane import ContourGridPlane
from pyface.timer.api import Timer


######################################################################
# `Pollster` class.
class Pollster(object):
    """Given a file name and a mayavi2 data reader object, this class
    polls the file for any changes and automatically updates the
    mayavi pipeline.
    """
    def __init__(self, fname, data):
        """Initialize the object.

        Parameters:
        -----------
        fname -- filename to poll.
        data -- the MayaVi source object to update.
        """
        self.fname = fname
        self.data = data
        self.last_stat = os.stat(fname)

    def poll_file(self):
        # Check the file's time stamp.
        s = os.stat(self.fname)
        if s[-2] == self.last_stat[-2]:
            return
        else:
            self.last_stat = s
            self.update_pipeline()

    def update_pipeline(self):
        """Override this to do something else if needed.
        """
        print "file changed"
        # Force the reader to re-read the file.
        d = self.data
        d.reader.modified()
        d.update()
        # Propagate the changes in the pipeline.
        d.data_changed = True



def setup_data(fname):
    """Given a VTK file name `fname`, this creates a mayavi2 reader
    for it and adds it to the pipeline.  It returns the reader
    created.
    """
    # 'mayavi' is always defined on the interpreter.
    mayavi.new_scene()
    d = VTKFileReader()
    d.initialize(fname)
    mayavi.add_source(d)
    return d

def view_data():
    """Sets up the mayavi pipeline for the visualization.
    """
    # 'mayavi' is always defined on the interpreter.
    o = Outline()
    mayavi.add_module(o)

    c = ContourGridPlane()
    mayavi.add_module(c)
    c.grid_plane.position = 16
    c.module_manager.scalar_lut_manager.show_scalar_bar = True

@mayavi2.standalone
def main():
    # Change this to suit your needs.  Edit the file after running this
    # script and the pipeline should be updated automatically.

    fname = join(mayavi2.get_data_dir(abspath(dirname(__file__))),
                 'heart.vtk')

    data = setup_data(fname)
    view_data()

    # Poll the file.
    p = Pollster(fname, data)
    timer = Timer(1000, p.poll_file)
    # Keep a reference on the timer
    mayavi2.savedtimerbug = timer

    # To stop polling the file do:
    #timer.Stop()

if __name__ == '__main__':
    main()


########NEW FILE########
__FILENAME__ = qt_embedding
"""
This example demonstrates using Mayavi as a component of a large Qt
application.

For this use, Mayavi is embedded in a QWidget. To understand this
example, please read section :ref:`builing-applications`.
"""

# First, and before importing any Enthought packages, set the ETS_TOOLKIT
# environment variable to qt4, to tell Traits that we will use Qt.
import os
os.environ['ETS_TOOLKIT'] = 'qt4'
# By default, the PySide binding will be used. If you want the PyQt bindings
# to be used, you need to set the QT_API environment variable to 'pyqt'
#os.environ['QT_API'] = 'pyqt'

# To be able to use PySide or PyQt4 and not run in conflicts with traits,
# we need to import QtGui and QtCore from pyface.qt
from pyface.qt import QtGui, QtCore
# Alternatively, you can bypass this line, but you need to make sure that
# the following lines are executed before the import of PyQT:
#   import sip
#   sip.setapi('QString', 2)

from traits.api import HasTraits, Instance, on_trait_change
from traitsui.api import View, Item
from mayavi.core.ui.api import MayaviScene, MlabSceneModel, \
        SceneEditor


################################################################################
#The actual visualization
class Visualization(HasTraits):
    scene = Instance(MlabSceneModel, ())

    @on_trait_change('scene.activated')
    def update_plot(self):
        # This function is called when the view is opened. We don't
        # populate the scene when the view is not yet open, as some
        # VTK features require a GLContext.

        # We can do normal mlab calls on the embedded scene.
        self.scene.mlab.test_points3d()

    # the layout of the dialog screated
    view = View(Item('scene', editor=SceneEditor(scene_class=MayaviScene),
                     height=250, width=300, show_label=False),
                resizable=True # We need this to resize with the parent widget
                )


################################################################################
# The QWidget containing the visualization, this is pure PyQt4 code.
class MayaviQWidget(QtGui.QWidget):
    def __init__(self, parent=None):
        QtGui.QWidget.__init__(self, parent)
        layout = QtGui.QVBoxLayout(self)
        layout.setContentsMargins(0,0,0,0)
        layout.setSpacing(0)
        self.visualization = Visualization()

        # If you want to debug, beware that you need to remove the Qt
        # input hook.
        #QtCore.pyqtRemoveInputHook()
        #import pdb ; pdb.set_trace()
        #QtCore.pyqtRestoreInputHook()

        # The edit_traits call will generate the widget to embed.
        self.ui = self.visualization.edit_traits(parent=self,
                                                 kind='subpanel').control
        layout.addWidget(self.ui)
        self.ui.setParent(self)


if __name__ == "__main__":
    # Don't create a new QApplication, it would unhook the Events
    # set by Traits on the existing QApplication. Simply use the
    # '.instance()' method to retrieve the existing one.
    app = QtGui.QApplication.instance()
    container = QtGui.QWidget()
    container.setWindowTitle("Embedding Mayavi in a PyQt4 Application")
    # define a "complex" layout to test the behaviour
    layout = QtGui.QGridLayout(container)

    # put some stuff around mayavi
    label_list = []
    for i in range(3):
        for j in range(3):
            if (i==1) and (j==1):continue
            label = QtGui.QLabel(container)
            label.setText("Your QWidget at (%d, %d)" % (i,j))
            label.setAlignment(QtCore.Qt.AlignHCenter|QtCore.Qt.AlignVCenter)
            layout.addWidget(label, i, j)
            label_list.append(label)
    mayavi_widget = MayaviQWidget(container)

    layout.addWidget(mayavi_widget, 1, 1)
    container.show()
    window = QtGui.QMainWindow()
    window.setCentralWidget(container)
    window.show()

    # Start the main event loop.
    app.exec_()



########NEW FILE########
__FILENAME__ = subclassing_mayavi_application
#!/usr/bin/env python
"""
This script demonstrates how one can script the Mayavi application by
subclassing the application, create a new scene and create a few
simple modules.

This should be run as::

   $ python test.py

"""
# Author: Prabhu Ramachandran <prabhu_r@users.sf.net>
# Copyright (c) 2005-2007, Enthought, Inc.
# License: BSD Style.

# Standard library imports
from os.path import join, abspath, dirname

# Enthought library imports
from mayavi.plugins.app import Mayavi
from mayavi.scripts.util import get_data_dir

class MyApp(Mayavi):
    def run(self):
        """This is executed once the application GUI has started.
        *Make sure all other MayaVi specific imports are made here!*
        """
        # Various imports to do different things.
        from mayavi.sources.vtk_file_reader import VTKFileReader
        from mayavi.modules.outline import Outline
        from mayavi.modules.axes import Axes
        from mayavi.modules.grid_plane import GridPlane
        from mayavi.modules.image_plane_widget import ImagePlaneWidget
        from mayavi.modules.text import Text

        script = self.script
        # Create a new scene.
        script.new_scene()

        # Read a VTK (old style) data file.
        r = VTKFileReader()
        r.initialize(join(get_data_dir(dirname(abspath(__file__))), 'heart.vtk'))
        script.add_source(r)

        # Put up some text.
        t = Text(text='MayaVi rules!', x_position=0.2,
                 y_position=0.9, width=0.8)
        t.property.color = 1, 1, 0  # Bright yellow, yeah!
        script.add_module(t)

        # Create an outline for the data.
        o = Outline()
        script.add_module(o)

        # Create an axes for the data.
        a = Axes()
        script.add_module(a)

        # Create an orientation axes for the scene.  This only works with
        # VTK-4.5 and above which is why we have the try block.
        try:
            from mayavi.modules.orientation_axes import OrientationAxes
        except ImportError:
            pass
        else:
            a = OrientationAxes()
            a.marker.set_viewport(0.0, 0.8, 0.2, 1.0)
            script.add_module(a)

        # Create three simple grid plane modules.
        # First normal to 'x' axis.
        gp = GridPlane()
        script.add_module(gp)
        # Second normal to 'y' axis.
        gp = GridPlane()
        gp.grid_plane.axis = 'y'
        script.add_module(gp)
        # Third normal to 'z' axis.
        gp = GridPlane()
        script.add_module(gp)
        gp.grid_plane.axis = 'z'

        # Create one ImagePlaneWidget.
        ipw = ImagePlaneWidget()
        script.add_module(ipw)
        # Set the position to the middle of the data.
        ipw.ipw.slice_position = 16



if __name__ == '__main__':
    a = MyApp()
    a.main()

########NEW FILE########
__FILENAME__ = superquad_with_gui
"""
This example uses MayaVi to show the evolution of a superquadric
(http://en.wikipedia.org/wiki/Superquadrics), which are ellipsoidal surfaces parametrised
by two parameters,\alpha and \beta. The equations that are used to determine the superquadric are 
(in spherical-polar coordinates):

  \(x = A(\sin^{\alpha}(\phi)*\cos^{\beta}(\theta))\)
  \(y = B(\sin^{\alpha}(\phi)*\sin^{\beta}(\theta))\)
  \(z = C(\cos^{\alpha}(\phi))\)

Note that when we set A=B=C=r, and \alpha =  \beta = 1, we get the 
equation for a sphere in spherical polar coordinate.

Use the controls at the bottom of the plot to adjust \alpha and \beta,
and watch as the figure transforms accordingly!

"""

# Author: Pratik Mallya <pmallya@enthought.com>
# Copyright (c) 2008-2013, Enthought, Inc.
# License: BSD Style.

import numpy as np
from enthought.traits.api import HasTraits, Range, Instance, \
                    on_trait_change
from enthought.traits.ui.api import View, Item, HGroup
from enthought.tvtk.pyface.scene_editor import SceneEditor
from enthought.mayavi.tools.mlab_scene_model import \
                    MlabSceneModel
from enthought.mayavi.core.ui.mayavi_scene import MayaviScene


def fexp(x,p):
    """a different kind of exponentiation"""
    return (np.sign(x) * (np.abs(x)**p))

def tens_fld(A,B,C,P,Q):
    """this module plots superquadratic surfaces with the given parameters"""
    phi, theta = np.mgrid[0:np.pi:80j, 0:2*np.pi:80j]
    x = A * (fexp(np.sin(phi),P)) * (fexp(np.cos(theta),Q))
    y = B * (fexp(np.sin(phi),P)) * (fexp(np.sin(theta),Q))
    z = C * (fexp(np.cos(phi),P))
    return x , y , z 


class Visualization(HasTraits):
    alpha = Range(0.0, 4.0, 1.0/4)
    beta  = Range(0.0, 4.0, 1.0/4)
    scene = Instance(MlabSceneModel, ())

    def __init__(self):
        # Do not forget to call the parent's __init__
        HasTraits.__init__(self)
        x, y, z, = tens_fld(1, 1, 1, self.beta, self.alpha)
        self.plot = self.scene.mlab.mesh(x, y, z, colormap='copper', representation='surface')

    @on_trait_change('beta,alpha')
    def update_plot(self):
        x, y, z, = tens_fld(1, 1, 1, self.beta, self.alpha)
        self.plot.mlab_source.set(x = x, y = y, z = z)


    # the layout of the dialog created
    view = View(Item('scene', editor = SceneEditor(scene_class=MayaviScene),
                    height = 750, width=750, show_label=False),
                HGroup(
                        '_', 'beta', 'alpha',
                    ),
                )

visualization = Visualization()
visualization.configure_traits()



########NEW FILE########
__FILENAME__ = volume_slicer
"""
Example of an elaborate dialog showing a multiple views on the same data, with
3 cuts synchronized.

This example shows how to have multiple views on the same data, how to
embedded multiple scenes in a dialog, and the caveat in populating them
with data, as well as how to add some interaction logic on an
ImagePlaneWidget.

The order in which things happen in this example is important, and it is
easy to get it wrong. First of all, many properties of the visualization
objects cannot be changed if there is not a scene created to view them.
This is why we put a lot of the visualization logic in the callback of
scene.activated, which is called after creation of the scene.
Second, default values created via the '_xxx_default' callback are created
lazyly, that is, when the attributes are accessed. As the establishement
of the VTK pipeline can depend on the order in which it is built, we
trigger these access by explicitely calling the attributes.
In particular, properties like scene background color, or interaction
properties cannot be set before the scene is activated.

The same data is exposed in the different scenes by sharing the VTK
dataset between different Mayavi data sources. See
the :ref:`sharing_data_between_scenes` tip for more details.

In this example, the interaction with the scene and the various elements
on it is strongly simplified by turning off interaction, and choosing
specific scene interactor styles. Indeed, non-technical users can be
confused with too rich interaction.
"""
# Author: Gael Varoquaux <gael.varoquaux@normalesup.org>
# Copyright (c) 2009, Enthought, Inc.
# License: BSD Style.

import numpy as np

from traits.api import HasTraits, Instance, Array, \
    on_trait_change
from traitsui.api import View, Item, HGroup, Group

from tvtk.api import tvtk
from tvtk.pyface.scene import Scene

from mayavi import mlab
from mayavi.core.api import PipelineBase, Source
from mayavi.core.ui.api import SceneEditor, MayaviScene, \
                                MlabSceneModel

################################################################################
# Create some data
x, y, z = np.ogrid[-5:5:64j, -5:5:64j, -5:5:64j]
data = np.sin(3*x)/x + 0.05*z**2 + np.cos(3*y)

################################################################################
# The object implementing the dialog
class VolumeSlicer(HasTraits):
    # The data to plot
    data = Array()

    # The 4 views displayed
    scene3d = Instance(MlabSceneModel, ())
    scene_x = Instance(MlabSceneModel, ())
    scene_y = Instance(MlabSceneModel, ())
    scene_z = Instance(MlabSceneModel, ())

    # The data source
    data_src3d = Instance(Source)

    # The image plane widgets of the 3D scene
    ipw_3d_x = Instance(PipelineBase)
    ipw_3d_y = Instance(PipelineBase)
    ipw_3d_z = Instance(PipelineBase)

    _axis_names = dict(x=0, y=1, z=2)


    #---------------------------------------------------------------------------
    def __init__(self, **traits):
        super(VolumeSlicer, self).__init__(**traits)
        # Force the creation of the image_plane_widgets:
        self.ipw_3d_x
        self.ipw_3d_y
        self.ipw_3d_z


    #---------------------------------------------------------------------------
    # Default values
    #---------------------------------------------------------------------------
    def _data_src3d_default(self):
        return mlab.pipeline.scalar_field(self.data,
                            figure=self.scene3d.mayavi_scene)

    def make_ipw_3d(self, axis_name):
        ipw = mlab.pipeline.image_plane_widget(self.data_src3d,
                        figure=self.scene3d.mayavi_scene,
                        plane_orientation='%s_axes' % axis_name)
        return ipw

    def _ipw_3d_x_default(self):
        return self.make_ipw_3d('x')

    def _ipw_3d_y_default(self):
        return self.make_ipw_3d('y')

    def _ipw_3d_z_default(self):
        return self.make_ipw_3d('z')


    #---------------------------------------------------------------------------
    # Scene activation callbaks
    #---------------------------------------------------------------------------
    @on_trait_change('scene3d.activated')
    def display_scene3d(self):
        outline = mlab.pipeline.outline(self.data_src3d,
                        figure=self.scene3d.mayavi_scene,
                        )
        self.scene3d.mlab.view(40, 50)
        # Interaction properties can only be changed after the scene
        # has been created, and thus the interactor exists
        for ipw in (self.ipw_3d_x, self.ipw_3d_y, self.ipw_3d_z):
            # Turn the interaction off
            ipw.ipw.interaction = 0
        self.scene3d.scene.background = (0, 0, 0)
        # Keep the view always pointing up
        self.scene3d.scene.interactor.interactor_style = \
                                 tvtk.InteractorStyleTerrain()


    def make_side_view(self, axis_name):
        scene = getattr(self, 'scene_%s' % axis_name)

        # To avoid copying the data, we take a reference to the
        # raw VTK dataset, and pass it on to mlab. Mlab will create
        # a Mayavi source from the VTK without copying it.
        # We have to specify the figure so that the data gets
        # added on the figure we are interested in.
        outline = mlab.pipeline.outline(
                            self.data_src3d.mlab_source.dataset,
                            figure=scene.mayavi_scene,
                            )
        ipw = mlab.pipeline.image_plane_widget(
                            outline,
                            plane_orientation='%s_axes' % axis_name)
        setattr(self, 'ipw_%s' % axis_name, ipw)

        # Synchronize positions between the corresponding image plane
        # widgets on different views.
        ipw.ipw.sync_trait('slice_position',
                            getattr(self, 'ipw_3d_%s'% axis_name).ipw)

        # Make left-clicking create a crosshair
        ipw.ipw.left_button_action = 0
        # Add a callback on the image plane widget interaction to
        # move the others
        def move_view(obj, evt):
            position = obj.GetCurrentCursorPosition()
            for other_axis, axis_number in self._axis_names.iteritems():
                if other_axis == axis_name:
                    continue
                ipw3d = getattr(self, 'ipw_3d_%s' % other_axis)
                ipw3d.ipw.slice_position = position[axis_number]

        ipw.ipw.add_observer('InteractionEvent', move_view)
        ipw.ipw.add_observer('StartInteractionEvent', move_view)

        # Center the image plane widget
        ipw.ipw.slice_position = 0.5*self.data.shape[
                    self._axis_names[axis_name]]

        # Position the view for the scene
        views = dict(x=( 0, 90),
                     y=(90, 90),
                     z=( 0,  0),
                     )
        scene.mlab.view(*views[axis_name])
        # 2D interaction: only pan and zoom
        scene.scene.interactor.interactor_style = \
                                 tvtk.InteractorStyleImage()
        scene.scene.background = (0, 0, 0)


    @on_trait_change('scene_x.activated')
    def display_scene_x(self):
        return self.make_side_view('x')

    @on_trait_change('scene_y.activated')
    def display_scene_y(self):
        return self.make_side_view('y')

    @on_trait_change('scene_z.activated')
    def display_scene_z(self):
        return self.make_side_view('z')


    #---------------------------------------------------------------------------
    # The layout of the dialog created
    #---------------------------------------------------------------------------
    view = View(HGroup(
                  Group(
                       Item('scene_y',
                            editor=SceneEditor(scene_class=Scene),
                            height=250, width=300),
                       Item('scene_z',
                            editor=SceneEditor(scene_class=Scene),
                            height=250, width=300),
                       show_labels=False,
                  ),
                  Group(
                       Item('scene_x',
                            editor=SceneEditor(scene_class=Scene),
                            height=250, width=300),
                       Item('scene3d',
                            editor=SceneEditor(scene_class=MayaviScene),
                            height=250, width=300),
                       show_labels=False,
                  ),
                ),
                resizable=True,
                title='Volume Slicer',
                )


m = VolumeSlicer(data=data)
m.configure_traits()

########NEW FILE########
__FILENAME__ = volume_slicer_advanced
"""
An efficient implementation of the triple-plane view showing 3 cut planes
on volumetric data, and side views showing each cut, with a cursor to
move the other cuts.

This is an example of complex callback interaction. It builds on the
:ref:`example_volume_slicer` but has more complex logic. You should try
to understand the :ref:`example_volume_slicer` first.

In this example, the VolumeSlicer object displays a position attribute
giving the position of the cut in data coordinates. Traits callbacks are
used to move the cut planes when this position attribute is modifed.

In the 3D window, the 3D cuts are displayed using ImagePlaneWidgets
cutting the 3D volumetric data. The data extracted by the
ImagePlaneWidgets for plotting is captured using the TVTK
ImagePlaneWidget's `_get_reslice_output` method. The resulting dataset is
plotted in each side view using another ImagePlaneWidget. As a result the
data is not copied (at the VTK level, there is only one pipeline), and
modifications of the data plotted on the planes in the 3D view (for
instance when these planes are moved) are propagated to the 2D side views
by the VTK pipeline.

A cursor is displayed in each side view using a glyph. The cursor
indicates the position of the cut.

In the side view, when the mouse button is pressed on the planes, it
creates a VTK `InteractionEvent`. When this happens, VTK calls an
callback (observer, it VTK terms), that we use to move the position of
the cut. The Traits callbacks do the rest for the updating.
"""
import numpy as np

from traits.api import HasTraits, Instance, Array, \
    Bool, Dict, on_trait_change
from traitsui.api import View, Item, HGroup, Group

from tvtk.api import tvtk
from tvtk.pyface.scene import Scene

from mayavi import mlab
from mayavi.core.api import PipelineBase, Source
from mayavi.core.ui.api import SceneEditor, MlabSceneModel


################################################################################
# The object implementing the dialog
class VolumeSlicer(HasTraits):
    # The data to plot
    data = Array

    # The position of the view
    position = Array(shape=(3,))

    # The 4 views displayed
    scene3d = Instance(MlabSceneModel, ())
    scene_x = Instance(MlabSceneModel, ())
    scene_y = Instance(MlabSceneModel, ())
    scene_z = Instance(MlabSceneModel, ())

    # The data source
    data_src = Instance(Source)

    # The image plane widgets of the 3D scene
    ipw_3d_x = Instance(PipelineBase)
    ipw_3d_y = Instance(PipelineBase)
    ipw_3d_z = Instance(PipelineBase)

    # The cursors on each view:
    cursors = Dict()

    disable_render = Bool

    _axis_names = dict(x=0, y=1, z=2)

    #---------------------------------------------------------------------------
    # Object interface
    #---------------------------------------------------------------------------
    def __init__(self, **traits):
        super(VolumeSlicer, self).__init__(**traits)
        # Force the creation of the image_plane_widgets:
        self.ipw_3d_x
        self.ipw_3d_y
        self.ipw_3d_z


    #---------------------------------------------------------------------------
    # Default values
    #---------------------------------------------------------------------------
    def _position_default(self):
        return 0.5*np.array(self.data.shape)

    def _data_src_default(self):
        return mlab.pipeline.scalar_field(self.data,
                            figure=self.scene3d.mayavi_scene,
                            name='Data',)

    def make_ipw_3d(self, axis_name):
        ipw = mlab.pipeline.image_plane_widget(self.data_src,
                        figure=self.scene3d.mayavi_scene,
                        plane_orientation='%s_axes' % axis_name,
                        name='Cut %s' % axis_name)
        return ipw

    def _ipw_3d_x_default(self):
        return self.make_ipw_3d('x')

    def _ipw_3d_y_default(self):
        return self.make_ipw_3d('y')

    def _ipw_3d_z_default(self):
        return self.make_ipw_3d('z')


    #---------------------------------------------------------------------------
    # Scene activation callbacks
    #---------------------------------------------------------------------------
    @on_trait_change('scene3d.activated')
    def display_scene3d(self):
        outline = mlab.pipeline.outline(self.data_src,
                        figure=self.scene3d.mayavi_scene,
                        )
        self.scene3d.mlab.view(40, 50)
        # Interaction properties can only be changed after the scene
        # has been created, and thus the interactor exists
        for ipw in (self.ipw_3d_x, self.ipw_3d_y, self.ipw_3d_z):
            ipw.ipw.interaction = 0
        self.scene3d.scene.background = (0, 0, 0)
        # Keep the view always pointing up
        self.scene3d.scene.interactor.interactor_style = \
                                 tvtk.InteractorStyleTerrain()
        self.update_position()


    def make_side_view(self, axis_name):
        scene = getattr(self, 'scene_%s' % axis_name)
        scene.scene.parallel_projection = True
        ipw_3d   = getattr(self, 'ipw_3d_%s' % axis_name)

        # We create the image_plane_widgets in the side view using a
        # VTK dataset pointing to the data on the corresponding
        # image_plane_widget in the 3D view (it is returned by
        # ipw_3d._get_reslice_output())
        side_src = ipw_3d.ipw._get_reslice_output()
        ipw = mlab.pipeline.image_plane_widget(
                            side_src,
                            plane_orientation='z_axes',
                            vmin=self.data.min(),
                            vmax=self.data.max(),
                            figure=scene.mayavi_scene,
                            name='Cut view %s' % axis_name,
                            )
        setattr(self, 'ipw_%s' % axis_name, ipw)

        # Extract the spacing of the side_src to convert coordinates
        # into indices
        spacing = side_src.spacing

        # Make left-clicking create a crosshair
        ipw.ipw.left_button_action = 0

        x, y, z = self.position
        cursor = mlab.points3d(x, y, z,
                            mode='axes',
                            color=(0, 0, 0),
                            scale_factor=2*max(self.data.shape),
                            figure=scene.mayavi_scene,
                            name='Cursor view %s' % axis_name,
                        )
        self.cursors[axis_name] = cursor

        # Add a callback on the image plane widget interaction to
        # move the others
        this_axis_number = self._axis_names[axis_name]
        def move_view(obj, evt):
            # Disable rendering on all scene
            position = list(obj.GetCurrentCursorPosition()*spacing)[:2]
            position.insert(this_axis_number, self.position[this_axis_number])
            # We need to special case y, as the view has been rotated.
            if axis_name is 'y':
                position = position[::-1]
            self.position = position

        ipw.ipw.add_observer('InteractionEvent', move_view)
        ipw.ipw.add_observer('StartInteractionEvent', move_view)

        # Center the image plane widget
        ipw.ipw.slice_position = 0.5*self.data.shape[
                                        self._axis_names[axis_name]]

        # 2D interaction: only pan and zoom
        scene.scene.interactor.interactor_style = \
                                 tvtk.InteractorStyleImage()
        scene.scene.background = (0, 0, 0)

        # Some text:
        mlab.text(0.01, 0.8, axis_name, width=0.08)

        # Choose a view that makes sens
        views = dict(x=(0, 0), y=(90, 180), z=(0, 0))
        mlab.view(views[axis_name][0],
                  views[axis_name][1],
                  focalpoint=0.5*np.array(self.data.shape),
                  figure=scene.mayavi_scene)
        scene.scene.camera.parallel_scale = 0.52*np.mean(self.data.shape)

    @on_trait_change('scene_x.activated')
    def display_scene_x(self):
        return self.make_side_view('x')

    @on_trait_change('scene_y.activated')
    def display_scene_y(self):
        return self.make_side_view('y')

    @on_trait_change('scene_z.activated')
    def display_scene_z(self):
        return self.make_side_view('z')


    #---------------------------------------------------------------------------
    # Traits callback
    #---------------------------------------------------------------------------
    @on_trait_change('position')
    def update_position(self):
        """ Update the position of the cursors on each side view, as well
            as the image_plane_widgets in the 3D view.
        """
        # First disable rendering in all scenes to avoid unecessary
        # renderings
        self.disable_render = True

        # For each axis, move image_plane_widget and the cursor in the
        # side view
        for axis_name, axis_number in self._axis_names.iteritems():
            ipw3d = getattr(self, 'ipw_3d_%s' % axis_name)
            ipw3d.ipw.slice_position = self.position[axis_number]

            # Go from the 3D position, to the 2D coordinates in the
            # side view
            position2d = list(self.position)
            position2d.pop(axis_number)
            if axis_name is 'y':
                position2d = position2d[::-1]
            # Move the cursor
            # For the following to work, you need Mayavi 3.4.0, if you
            # have a less recent version, use 'x=[position2d[0]]'
            self.cursors[axis_name].mlab_source.set(
                                                x=position2d[0],
                                                y=position2d[1],
                                                z=0)

        # Finally re-enable rendering
        self.disable_render = False

    @on_trait_change('disable_render')
    def _render_enable(self):
        for scene in (self.scene3d, self.scene_x, self.scene_y,
                                                  self.scene_z):
            scene.scene.disable_render = self.disable_render


    #---------------------------------------------------------------------------
    # The layout of the dialog created
    #---------------------------------------------------------------------------
    view = View(HGroup(
                  Group(
                       Item('scene_y',
                            editor=SceneEditor(scene_class=Scene),
                            height=250, width=300),
                       Item('scene_z',
                            editor=SceneEditor(scene_class=Scene),
                            height=250, width=300),
                       show_labels=False,
                  ),
                  Group(
                       Item('scene_x',
                            editor=SceneEditor(scene_class=Scene),
                            height=250, width=300),
                       Item('scene3d',
                            editor=SceneEditor(scene_class=Scene),
                            height=250, width=300),
                       show_labels=False,
                  ),
                ),
                resizable=True,
                title='Volume Slicer',
                )


################################################################################
if __name__ == '__main__':
    # Create some data
    x, y, z = np.ogrid[-5:5:100j, -5:5:100j, -5:5:100j]
    data = np.sin(3*x)/x + 0.05*z**2 + np.cos(3*y)

    m = VolumeSlicer(data=data)
    m.configure_traits()

########NEW FILE########
__FILENAME__ = wx_embedding
"""
This example shows to embed a Mayavi view in a wx frame.

The trick is to create a `HasTraits` object, as in the
mlab_traits_ui.py, mayavi_traits_ui.py, or the modifying_mlab_source.py
examples (:ref:`example_mlab_traits_ui`, :ref:`example_mayavi_traits_ui`,
:ref:`example_mlab_interactive_dialog`).

Calling the `edit_traits` method returns a `ui` object whose
`control` attribute is the wx widget. It can thus be embedded in a
standard wx application.

In this example, the wx part is very simple. See
:ref:`example_wx_mayavi_embed_in_notebook` for an example of more complex
embedding of Mayavi scenes in Wx applications.
"""

from numpy import ogrid, sin

from traits.api import HasTraits, Instance
from traitsui.api import View, Item

from mayavi.sources.api import ArraySource
from mayavi.modules.api import IsoSurface

from mayavi.core.ui.api import SceneEditor, MlabSceneModel


class MayaviView(HasTraits):

    scene = Instance(MlabSceneModel, ())

    # The layout of the panel created by Traits
    view = View(Item('scene', editor=SceneEditor(), resizable=True,
                    show_label=False),
                    resizable=True)

    def __init__(self):
        HasTraits.__init__(self)
        # Create some data, and plot it using the embedded scene's engine
        x, y, z = ogrid[-10:10:100j, -10:10:100j, -10:10:100j]
        scalars = sin(x*y*z)/(x*y*z)
        src = ArraySource(scalar_data=scalars)
        self.scene.engine.add_source(src)
        src.add_module(IsoSurface())

#-----------------------------------------------------------------------------
# Wx Code
import wx

class MainWindow(wx.Frame):

    def __init__(self, parent, id):
        wx.Frame.__init__(self, parent, id, 'Mayavi in Wx')
        self.mayavi_view = MayaviView()
        # Use traits to create a panel, and use it as the content of this
        # wx frame.
        self.control = self.mayavi_view.edit_traits(
                        parent=self,
                        kind='subpanel').control
        self.Show(True)

app = wx.PySimpleApp()
frame = MainWindow(None, wx.ID_ANY)
app.MainLoop()


########NEW FILE########
__FILENAME__ = wx_mayavi_embed_in_notebook
"""
This example show how to embedded Mayavi in a wx notebook.

This is a slightly more complex example than the `wx_embedding` example (
:ref:`example_wx_embedding`), and can be used to see how a large wx
application can use different Mayavi views.

In this example, we embed one single Mayavi scene in a Wx notebook, with
2 tabs, each one of them hosting a different view of the scene.
"""

# First thing, we need to make sure that we are importing a
# recent-enough version of wx
import wxversion
wxversion.ensureMinimal('2.8')

from numpy import ogrid, sin

from traits.api import HasTraits, Instance
from traitsui.api import View, Item

from mayavi.sources.api import ArraySource
from mayavi.modules.api import IsoSurface

from mayavi.core.ui.api import MlabSceneModel, SceneEditor

#-------------------------------------------------------------------------------
class MayaviView(HasTraits):

    scene = Instance(MlabSceneModel, ())

    # The layout of the panel created by traits.
    view = View(Item('scene', editor=SceneEditor(),
                    resizable=True,
                    show_label=False),
                resizable=True)

    def __init__(self):
        HasTraits.__init__(self)
        x, y, z = ogrid[-10:10:100j, -10:10:100j, -10:10:100j]
        scalars = sin(x*y*z)/(x*y*z)
        src = ArraySource(scalar_data=scalars)
        self.scene.mayavi_scene.add_child(src)
        src.add_module(IsoSurface())


#-------------------------------------------------------------------------------
# Wx Code
import wx

class MainWindow(wx.Frame):

    def __init__(self, parent, id):
        wx.Frame.__init__(self, parent, id, 'Mayavi in a Wx notebook')
        self.notebook = wx.aui.AuiNotebook(self, id=-1,
                style=wx.aui.AUI_NB_TAB_SPLIT | wx.aui.AUI_NB_CLOSE_ON_ALL_TABS
                        | wx.aui.AUI_NB_LEFT)

        self.mayavi_view = MayaviView()

        # The edit_traits method opens a first view of our 'MayaviView'
        # object
        self.control = self.mayavi_view.edit_traits(
                        parent=self,
                        kind='subpanel').control
        self.notebook.AddPage(page=self.control, caption='Display 1')

        self.mayavi_view2 = MayaviView()

        # The second call to edit_traits opens a second view
        self.control2 = self.mayavi_view2.edit_traits(
                        parent=self,
                        kind='subpanel').control
        self.notebook.AddPage(page=self.control2, caption='Display 2')

        sizer = wx.BoxSizer()
        sizer.Add(self.notebook,1, wx.EXPAND)
        self.SetSizer(sizer)

        self.Show(True)

if __name__ == '__main__':
    app = wx.PySimpleApp()
    frame = MainWindow(None, wx.ID_ANY)
    app.MainLoop()

########NEW FILE########
__FILENAME__ = atomic_orbital
"""
An example showing the norm and phase of an atomic orbital: isosurfaces of
the norm, with colors  displaying the phase.

This example shows how you can apply a filter on one data set, and dislay
a second data set on the output of the filter. Here we use the contour
filter to extract isosurfaces of the norm of a complex field, and we
display the phase of the field with the colormap.

The field we choose to plot is a simplified version of the 3P_y atomic
orbital for hydrogen-like atoms.

The first step is to create a data source with two scalar datasets. The
second step is to apply filters and modules, using the
'set_active_attribute' filter to select on which data these apply.

Creating a data source with two scalar datasets is actually slighlty
tricky, as it requires some understanding of the layout of the datasets
in TVTK. The reader is referred to :ref:`data-structures-used-by-mayavi`
for more details.
"""
# Author: Gael Varoquaux <gael.varoquaux@normalesup.org>
# Copyright (c) 2008, Enthought, Inc.
# License: BSD Style.

# Create the data ############################################################
import numpy as np

x, y, z = np.ogrid[- .5:.5:200j, - .5:.5:200j, - .5:.5:200j]
r = np.sqrt(x ** 2 + y ** 2 + z ** 2)


# Generalized Laguerre polynomial (3, 2)
L = - r ** 3 / 6 + 5. / 2 * r ** 2 - 10 * r + 6

# Spherical harmonic (3, 2)
Y = (x + y * 1j) ** 2 * z / r ** 3

Phi = L * Y * np.exp(- r) * r ** 2

# Plot it ####################################################################
from mayavi import mlab
mlab.figure(1, fgcolor=(1, 1, 1), bgcolor=(0, 0, 0))
# We create a scalar field with the module of Phi as the scalar
src = mlab.pipeline.scalar_field(np.abs(Phi))

# And we add the phase of Phi as an additional array
# This is a tricky part: the layout of the new array needs to be the same
# as the existing dataset, and no checks are performed. The shape needs
# to be the same, and so should the data. Failure to do so can result in
# segfaults.
src.image_data.point_data.add_array(np.angle(Phi).T.ravel())
# We need to give a name to our new dataset.
src.image_data.point_data.get_array(1).name = 'angle'
# Make sure that the dataset is up to date with the different arrays:
src.update()

# We select the 'scalar' attribute, ie the norm of Phi
src2 = mlab.pipeline.set_active_attribute(src,
                                    point_scalars='scalar')

# Cut isosurfaces of the norm
contour = mlab.pipeline.contour(src2)

# Now we select the 'angle' attribute, ie the phase of Phi
contour2 = mlab.pipeline.set_active_attribute(contour,
                                    point_scalars='angle')

# And we display the surface. The colormap is the current attribute: the phase.
mlab.pipeline.surface(contour2, colormap='hsv')

mlab.colorbar(title='Phase', orientation='vertical', nb_labels=3)

mlab.show()

########NEW FILE########
__FILENAME__ = boy
"""
A script to generate the Mayavi logo: a Boy surface.

The boy surface is a mathematical parametric surface, see
http://en.wikipedia.org/wiki/Boy%27s_surface . We display it by sampling
the two parameters of the surface on a grid and using the mlab's mesh
function: :func:`mayavi.mlab.mesh`.
"""

# Author: Gael Varoquaux <gael.varoquaux@normalesup.org>
# Copyright (c) 2007, Enthought, Inc.
# License: BSD Style.


from numpy import sin, cos, mgrid, pi, sqrt
from mayavi import mlab

mlab.figure(fgcolor=(0, 0, 0), bgcolor=(1, 1, 1))
u, v = mgrid[- 0.035:pi:0.01, - 0.035:pi:0.01]

X = 2 / 3. * (cos(u) * cos(2 * v)
        + sqrt(2) * sin(u) * cos(v)) * cos(u) / (sqrt(2) -
                                                 sin(2 * u) * sin(3 * v))
Y = 2 / 3. * (cos(u) * sin(2 * v) -
        sqrt(2) * sin(u) * sin(v)) * cos(u) / (sqrt(2)
        - sin(2 * u) * sin(3 * v))
Z = -sqrt(2) * cos(u) * cos(u) / (sqrt(2) - sin(2 * u) * sin(3 * v))
S = sin(u)

mlab.mesh(X, Y, Z, scalars=S, colormap='YlGnBu', )

# Nice view from the front
mlab.view(.0, - 5.0, 4)
mlab.show()

########NEW FILE########
__FILENAME__ = canyon
"""
Retrieve radar data from the NASA and plot a view of the Grand Canyon
landscape.

We cannot display the whole data, as it would be too big. To display
more, see the canyon decimation example.

This example is interesting as it shows how numpy can be used to load
and crop data completly foreign to Mayavi.
"""
# Author: Gael Varoquaux <gael.varoquaux@normalesup.org>
# Copyright (c) 2008, Enthought, Inc.
# License: BSD Style.

# Retrieve the grand Canyon topological data ##################################
import os
# Original file:
#'ftp://e0srp01u.ecs.nasa.gov/srtm/version2/SRTM1/Region_04/N36W113.hgt.zip'
if not os.path.exists('N36W113.hgt.zip'):
    # Download the data
    import urllib
    print 'Downloading data, please wait (10M)'
    opener = urllib.urlopen(
    'https://s3.amazonaws.com/storage.enthought.com/www/sample_data/N36W113.hgt.zip'
        )
    open('N36W113.hgt.zip', 'wb').write(opener.read())

# Load the data (signed 2 byte integers, big endian) ##########################
import zipfile
import numpy as np

data = np.fromstring(zipfile.ZipFile('N36W113.hgt.zip').read('N36W113.hgt'),
                    '>i2')
data.shape = (3601, 3601)
data = data.astype(np.float32)

# Plot an interesting section #################################################
from mayavi import mlab
data = data[:1000, 900:1900]
# Convert missing values into something more sensible.
data[data == -32768] = data[data > 0].min()

mlab.figure(size=(400, 320), bgcolor=(0.16, 0.28, 0.46))
mlab.surf(data, colormap='gist_earth', warp_scale=0.2,
            vmin=1200, vmax=1610)
# The data takes a lot of memory, and the surf command has created a
# copy. We free the inital memory.
del data

# A view of the canyon
mlab.view(-5.9, 83, 570, [5.3, 20, 238])
mlab.show()

########NEW FILE########
__FILENAME__ = canyon_decimation
"""
Use the greedy-terrain-decimator to display a decimated terrain view.

This example illustrates decimating a terrain. We use the
greedy-terrain-decimator to create a reduced mesh with an optimized grid that
approximates the initial regular grid.

The initial grid is displayed in white, and the optimized grid is displayed in
black, with the surface it creates. The initial grid can be seen
disappearing as it goes under the surface of the approximated grid:
although the decimated mesh follows closely the orginal, it is not
exactly the same.

One can see that the reduction in number of polygons is huge: the white
grid is much finer than the black grid. It is interesting to note that
the decimated mesh follows closely the original mesh, including in number
of polygons, in spots where the terrain changes most quickly.

This example uses the Grand Canyon topological radar data, from NASA.

The greedy-terrain-decimator is only useful to decimate a surface
warped from 2D data. To decimated more general meshes, you can use the
less-efficient decimate-pro filter (see :ref:`example_julia_set_decimation`).
"""
# Author: Gael Varoquaux <gael.varoquaux@normalesup.org>
# Copyright (c) 2008, Enthought, Inc.
# License: BSD Style.

# Retrieve the grand Canyon topological data ###################################
# Original file:
#'ftp://e0srp01u.ecs.nasa.gov/srtm/version2/SRTM1/Region_04/N36W113.hgt.zip'
import os
if not os.path.exists('N36W113.hgt.zip'):
    # Download the data
    import urllib
    print 'Downloading data, please wait (10M)'
    opener = urllib.urlopen(
    'https://s3.amazonaws.com/storage.enthought.com/www/sample_data/N36W113.hgt.zip'
        )
    open('N36W113.hgt.zip', 'wb').write(opener.read())

# Load the data (signed 2 byte integers, big endian) ###########################
import zipfile
import numpy as np

data = np.fromstring(zipfile.ZipFile('N36W113.hgt.zip').read('N36W113.hgt'),
                    '>i2')
data.shape = (3601, 3601)
data = data[200:400, 1200:1400]
data = data.astype(np.float32)

# Plot an interecting section ##################################################
from mayavi import mlab
mlab.figure(1, size=(450, 390))
mlab.clf()
data = mlab.pipeline.array2d_source(data)

# Use a greedy_terrain_decimation to created a decimated mesh
terrain = mlab.pipeline.greedy_terrain_decimation(data)
terrain.filter.error_measure = 'number_of_triangles'
terrain.filter.number_of_triangles = 5000
terrain.filter.compute_normals = True

# Plot it black the lines of the mesh
lines = mlab.pipeline.surface(terrain, color=(0, 0, 0),
                                      representation='wireframe')
# The terrain decimator has done the warping. We control the warping
# scale via the actor's scale.
lines.actor.actor.scale = [1, 1, 0.2]

# Display the surface itself.
surf = mlab.pipeline.surface(terrain, colormap='gist_earth',
                                      vmin=1450, vmax=1650)
surf.actor.actor.scale = [1, 1, 0.2]

# Display the original regular grid. This time we have to use a
# warp_scalar filter.
warp = mlab.pipeline.warp_scalar(data, warp_scale=0.2)
grid = mlab.pipeline.surface(warp, color=(1, 1, 1),
                                      representation='wireframe')

mlab.view(-17, 46, 143, [1.46, 8.46, 269.4])

mlab.show()

########NEW FILE########
__FILENAME__ = chemistry
"""
In this example, we display the H2O molecule, and use volume rendering to
display the electron localization function.

The atoms and the bounds are displayed using mlab.points3d and
mlab.plot3d, with scalar information to control the color.

The electron localization function is displayed using volume rendering.
Good use of the `vmin` and `vmax` argument to
`mlab.pipeline.volume` is critical to achieve a good visualization: the
`vmin` threshold should placed high-enough for features to stand out.

The original is an electron localization function from Axel Kohlmeyer.
"""
# Author: Gael Varoquaux <gael.varoquaux@normalesup.org>
# Copyright (c) 2008, Enthought, Inc.
# License: BSD Style.

# Retrieve the electron localization data for H2O #############################
import os
if not os.path.exists('h2o-elf.cube'):
    # Download the data
    import urllib
    print 'Downloading data, please wait'
    opener = urllib.urlopen(
        'http://code.enthought.com/projects/mayavi/data/h2o-elf.cube'
        )
    open('h2o-elf.cube', 'wb').write(opener.read())


# Plot the atoms and the bonds ################################################
import numpy as np
from mayavi import mlab
mlab.figure(1, bgcolor=(0, 0, 0), size=(350, 350))
mlab.clf()

# The position of the atoms
atoms_x = np.array([2.9, 2.9, 3.8]) * 40 / 5.5
atoms_y = np.array([3.0, 3.0, 3.0]) * 40 / 5.5
atoms_z = np.array([3.8, 2.9, 2.7]) * 40 / 5.5

O = mlab.points3d(atoms_x[1:-1], atoms_y[1:-1], atoms_z[1:-1],
                  scale_factor=3,
                  resolution=20,
                  color=(1, 0, 0),
                  scale_mode='none')

H1 = mlab.points3d(atoms_x[:1], atoms_y[:1], atoms_z[:1],
                   scale_factor=2,
                   resolution=20,
                   color=(1, 1, 1),
                   scale_mode='none')

H2 = mlab.points3d(atoms_x[-1:], atoms_y[-1:], atoms_z[-1:],
                   scale_factor=2,
                   resolution=20,
                   color=(1, 1, 1),
                   scale_mode='none')

# The bounds between the atoms, we use the scalar information to give
# color
mlab.plot3d(atoms_x, atoms_y, atoms_z, [1, 2, 1],
            tube_radius=0.4, colormap='Reds')

# Display the electron localization function ##################################

# Load the data, we need to remove the first 8 lines and the '\n'
str = ' '.join(file('h2o-elf.cube').readlines()[9:])
data = np.fromstring(str, sep=' ')
data.shape = (40, 40, 40)

source = mlab.pipeline.scalar_field(data)
min = data.min()
max = data.max()
vol = mlab.pipeline.volume(source, vmin=min + 0.65 * (max - min),
                                   vmax=min + 0.9 * (max - min))

mlab.view(132, 54, 45, [21, 20, 21.5])

mlab.show()

########NEW FILE########
__FILENAME__ = custom_colormap
"""
An example showing how a custom colormap (or look up table) can be used
for a given object.

Although the end user specifies colormaps by giving the name of a set of
predefined colormaps, Mayavi (and VTK) deal with color internally using
'Look Up Tables' (LUT): a table that associate a scalar value to a
color defined by its RGBA components.

In this example, we show how the LUT of an object can be retrieved and
modified. Specificaly, we start by giving a surf object the 'cool'
colormap, but we modify add to add a transparency effect.

Notice in the resulting image how the surface becomes more transparent
for its lower points.

Note that if you want to use a different number of colors, you can
change the 'number_of_colors' attribute of the lut object and assign a
new array of the right shape to its 'table' attribute.
"""

# Create some data
import numpy as np

x, y = np.mgrid[-10:10:200j, -10:10:200j]
z = 100 * np.sin(x * y) / (x * y)

# Visualize it with mlab.surf
from mayavi import mlab
mlab.figure(bgcolor=(1, 1, 1))
surf = mlab.surf(z, colormap='cool')

# Retrieve the LUT of the surf object.
lut = surf.module_manager.scalar_lut_manager.lut.table.to_array()

# The lut is a 255x4 array, with the columns representing RGBA
# (red, green, blue, alpha) coded with integers going from 0 to 255.

# We modify the alpha channel to add a transparency gradient
lut[:, -1] = np.linspace(0, 255, 256)
# and finally we put this LUT back in the surface object. We could have
# added any 255*4 array rather than modifying an existing LUT.
surf.module_manager.scalar_lut_manager.lut.table = lut

# We need to force update of the figure now that we have changed the LUT.
mlab.draw()
mlab.view(40, 85)

mlab.show()

########NEW FILE########
__FILENAME__ = flight_graph
"""
An example showing a graph display between cities positionned on the
Earth surface.

This graph displays the longest fligh routes operated by Boing
777. The two main interests of this example are that it shows how to
build a graph of arbitrary connectivity, and that it shows how to
position data on the surface of the Earth.

The graph is created by first building a scalar scatter dataset with the
mlab.points3d command, and adding line information to it. One of the
difficulties is that the lines are specified using the indexing number of
the points, so we must 'massage' our data when loading it. A similar
technique to plot the graph is done in the :ref:`example_protein`.
Another example of graph plotting, showing a different technique to plot
the graph, can be seen on :ref:`example_delaunay_graph`.

To simplify things we do not plot the connection on the surface of the
Earth, but as straight lines going throught the Earth. As a result
must use transparency to show the connection.

Data source: http://www.777fleetpage.com/777fleetpage3.htm
"""

###############################################################################
# The data. This could be loaded from a file, or scraped from a website

routes_data = """
Bombay,Atlanta
Johannesburg,Atlanta
Dubai,Los Angeles
Dubai,Houston
Dubai,San Francisco
New York,Hong Kong
Newark,Hong Kong
Doha,Houston
Toronto,Hong Kong
Bombay,Newark
Bombay,New York
Vancouver,Hong Kong
Dubai,Sao Paulo
Los Angeles,Sydney
Chicago,Delhi
"""

cities_data = """
Toronto,-79.38,43.65
Chicago,-87.68,41.84
Houston,-95.39,29.77
New York,-73.94,40.67
Vancouver,-123.13,49.28
Los Angeles,-118.41,34.11
San Francisco,-122.45,37.77
Atlanta,-84.42,33.76
Dubai,55.33,25.27
Sydney,151.21,-33.87
Hong Kong,114.19,22.38
Bombay,72.82,18.96
Delhi,77.21,28.67
Newark,-82.43,40.04
Johannesburg,28.04,-26.19
Doha,51.53,25.29
Sao Paulo,-46.63,-23.53
"""

###############################################################################
# Load the data, and put it in data structures we can use
import csv
routes_table = [i for i in csv.reader(routes_data.split('\n')[1:-1])]

# Build a dictionnary returning GPS coordinates for each city
cities_coord = dict()
for line in list(csv.reader(cities_data.split('\n')))[1:-1]:
    name, long, lat = line
    cities_coord[name] = (float(long), float(lat))

# Store all the coordinates of connected cities in a list also keep
# track of which city corresponds to a given index in the list. The
# connectivity information is specified as connecting the i-th point
# with the j-th.
cities = dict()
coords = list()
connections = list()
for city1, city2 in routes_table[1:-1]:
    if not city1 in cities:
        cities[city1] = len(coords)
        coords.append(cities_coord[city1])
    if not city2 in cities:
        cities[city2] = len(coords)
        coords.append(cities_coord[city2])
    connections.append((cities[city1], cities[city2]))


###############################################################################
from mayavi import mlab
mlab.figure(1, bgcolor=(0.48, 0.48, 0.48), fgcolor=(0, 0, 0),
               size=(400, 400))
mlab.clf()

###############################################################################
# Display points at city positions
import numpy as np
coords = np.array(coords)
# First we have to convert latitude/longitude information to 3D
# positioning.
lat, long = coords.T * np.pi / 180
x = np.cos(long) * np.cos(lat)
y = np.cos(long) * np.sin(lat)
z = np.sin(long)

points = mlab.points3d(x, y, z,
                     scale_mode='none',
                     scale_factor=0.03,
                     color=(0, 0, 1))

###############################################################################
# Display connections between cities
connections = np.array(connections)
# We add lines between the points that we have previously created by
# directly modifying the VTK dataset.
points.mlab_source.dataset.lines = connections
points.mlab_source.update()
# To represent the lines, we use the surface module. Using a wireframe
# representation allows to control the line-width.
mlab.pipeline.surface(points, color=(1, 1, 1),
                              representation='wireframe',
                              line_width=4,
                              name='Connections')

###############################################################################
# Display city names
for city, index in cities.iteritems():
    label = mlab.text(x[index], y[index], city, z=z[index],
                      width=0.016 * len(city), name=city)
    label.property.shadow = True

###############################################################################
# Display continents outline, using the VTK Builtin surface 'Earth'
from mayavi.sources.builtin_surface import BuiltinSurface
continents_src = BuiltinSurface(source='earth', name='Continents')
# The on_ratio of the Earth source controls the level of detail of the
# continents outline.
continents_src.data_source.on_ratio = 2
continents = mlab.pipeline.surface(continents_src, color=(0, 0, 0))

###############################################################################
# Display a semi-transparent sphere, for the surface of the Earth

# We use a sphere Glyph, throught the points3d mlab function, rather than
# building the mesh ourselves, because it gives a better transparent
# rendering.
sphere = mlab.points3d(0, 0, 0, scale_mode='none',
                                scale_factor=2,
                                color=(0.67, 0.77, 0.93),
                                resolution=50,
                                opacity=0.7,
                                name='Earth')

# These parameters, as well as the color, where tweaked through the GUI,
# with the record mode to produce lines of code usable in a script.
sphere.actor.property.specular = 0.45
sphere.actor.property.specular_power = 5
# Backface culling is necessary for more a beautiful transparent
# rendering.
sphere.actor.property.backface_culling = True

###############################################################################
# Plot the equator and the tropiques
theta = np.linspace(0, 2 * np.pi, 100)
for angle in (- np.pi / 6, 0, np.pi / 6):
    x = np.cos(theta) * np.cos(angle)
    y = np.sin(theta) * np.cos(angle)
    z = np.ones_like(theta) * np.sin(angle)

    mlab.plot3d(x, y, z, color=(1, 1, 1),
                        opacity=0.2, tube_radius=None)

mlab.view(63.4, 73.8, 4, [-0.05, 0, 0])
mlab.show()

########NEW FILE########
__FILENAME__ = julia_set
"""
An example showing the Julia set displayed as a z-warped surface.

The Julia set is a fractal (see http://en.wikipedia.org/wiki/Julia_set
). We display it here in a canyon-like view using mlab's surf function:
:func:`mayavi.mlab.surf`.
"""

# Author: Gael Varoquaux <gael.varoquaux@normalesup.org>
# Copyright (c) 2008, Enthought, Inc.
# License: BSD Style.


from mayavi import mlab
import numpy as np

# Calculate the Julia set on a grid
x, y = np.ogrid[-1.5:0.5:500j, -1:1:500j]
z = x + 1j * y

julia = np.zeros(z.shape)

for i in range(50):
    z = z ** 2 - 0.70176 - 0.3842j
    julia += 1 / float(2 + i) * (z * np.conj(z) > 4)

# Display it
mlab.figure(size=(400, 300))
mlab.surf(julia, colormap='gist_earth', warp_scale='auto', vmax=1.5)

# A view into the "Canyon"
mlab.view(65, 27, 322, [30., -13.7,  136])
mlab.show()

########NEW FILE########
__FILENAME__ = julia_set_decimation
"""
The Julia set, but with a decimated mesh: unecessary triangles due to the
initial grid and not matching the geometry of the Julia set
are removed.

We first build the mesh, applying a warp_scalar filter to a
array2d_source, to warp the Julia set along the z direction.

Then when have to convert the rectangles in the mesh to triangles, in
order to apply the decimate_pro filter. This filter does the decimation,
and we can represent the result using surface modules.

The triangle-generation filter generates warnings: some polygons
are degenerate, as the grid has subdivided flat parts of the Julia
set.

We have shown in white the decimated mesh, and in black the non-decimated
one. The view is zoom to the center of the Julia set. If you turn of the
wireframes and zoom out, you can appreciate the quality of the
decimation.

In the specific case of decimating a surface warped from 2D data, it is
more efficient to use the greedy-terrain-decimator, see the
:ref:`example_canyon_decimation`.
"""

# Author: Gael Varoquaux <gael.varoquaux@normalesup.org>
# Copyright (c) 2008, Enthought, Inc.
# License: BSD Style.


from mayavi import mlab
import numpy as np

# Calculate the Julia set on a grid
x, y = np.ogrid[-1.5:0.5:500j, -1:1:500j]
z = x + 1j * y

julia = np.zeros(z.shape)

for i in range(50):
    z = z ** 2 - 0.70176 - 0.3842j
    julia += 1 / float(2 + i) * (z * np.conj(z) > 4)


mlab.figure(size=(400, 300))

# Create the mesh
mesh = mlab.pipeline.warp_scalar(mlab.pipeline.array2d_source(julia),
                                 warp_scale=100)

# The decimate_pro filter works only on triangles. We need to apply the
# triangle_filter before applying decimate_pro.
dec = mlab.pipeline.decimate_pro(mlab.pipeline.triangle_filter(mesh))
# Set a very low feature_angle, so that the decimate_pro detects
dec.filter.feature_angle = 1
dec.filter.target_reduction = 0.5

# We display the lines of decimated mesh in white
mlab.pipeline.surface(dec, representation='wireframe', line_width=3,
                           color=(1, 1, 1))
# The decimated mesh itself.
mlab.pipeline.surface(dec, colormap='gist_earth', vmin=-0.1, vmax=0.4)

# The lines of the non-decimated mesh, in black, for comparisation.
mlab.pipeline.surface(mesh, representation='wireframe',  color=(0, 0, 0))

mlab.view(-66, 25, 9.7, [-5.8, -54.5,  18.4])

mlab.show()

########NEW FILE########
__FILENAME__ = lorenz
"""
An example displaying the trajectories for the Lorenz system of
equations along with the z-nullcline.

The vector field of the Lorenz system flow is integrated to display
trajectories using mlab's flow function:
:func:`mayavi.mlab.flow`.

The z-nullcline is plotted by extracting the z component of the vector
field data source with the ExtractVectorComponent filter, and applying
an IsoSurface module on this scalar component.
"""
# Author: Prabhu Ramachandran <prabhu@aero.iitb.ac.in>
# Copyright (c) 2008-2009, Enthought, Inc.
# License: BSD Style.

import numpy
from mayavi import mlab


def lorenz(x, y, z, s=10., r=28., b=8. / 3.):
    """The Lorenz system."""
    u = s * (y - x)
    v = r * x - y - x * z
    w = x * y - b * z
    return u, v, w

# Sample the space in an interesting region.
x, y, z = numpy.mgrid[-50:50:100j, -50:50:100j, -10:60:70j]
u, v, w = lorenz(x, y, z)
fig = mlab.figure(size=(400, 300), bgcolor=(0, 0, 0))

# Plot the flow of trajectories with suitable parameters.
f = mlab.flow(x, y, z, u, v, w, line_width=3, colormap='Paired')
f.module_manager.scalar_lut_manager.reverse_lut = True
f.stream_tracer.integration_direction = 'both'
f.stream_tracer.maximum_propagation = 200
# Uncomment the following line if you want to hide the seed:
#f.seed.widget.enabled = False

# Extract the z-velocity from the vectors and plot the 0 level set
# hence producing the z-nullcline.
src = f.mlab_source.m_data
e = mlab.pipeline.extract_vector_components(src)
e.component = 'z-component'
zc = mlab.pipeline.iso_surface(e, opacity=0.5, contours=[0, ],
            color=(0.6, 1, 0.2))
# When using transparency, hiding 'backface' triangles often gives better
# results
zc.actor.property.backface_culling = True

# A nice view of the plot.
mlab.view(140, 120, 113, [0.65, 1.5, 27])
mlab.show()

########NEW FILE########
__FILENAME__ = magnetic_field_lines
"""
This example uses the streamline module to display field lines of a
magnetic dipole (a current loop).

This example requires scipy.

The magnetic field from an arbitrary current loop is calculated from
eqns (1) and (2) in Phys Rev A Vol. 35, N 4, pp. 1535-1546; 1987.

To get a prettier result, we use a fairly large grid to sample the
field. As a consequence, we need to clear temporary arrays as soon as
possible.

For a more thorough example of magnetic field calculation and
visualization with Mayavi and scipy, see
:ref:`example_magnetic_field`.
"""
# Author: Gael Varoquaux <gael.varoquaux@normalesup.org>
# Copyright (c) 2007, Enthought, Inc.
# License: BSD Style.

import numpy as np
from scipy import special

#### Calculate the field ####################################################
radius = 1  # Radius of the coils

x, y, z = [e.astype(np.float32) for e in
            np.ogrid[-10:10:150j, -10:10:150j, -10:10:150j]]

# express the coordinates in polar form
rho = np.sqrt(x ** 2 + y ** 2)
x_proj = x / rho
y_proj = y / rho
# Free memory early
del x, y

E = special.ellipe((4 * radius * rho) / ((radius + rho) ** 2 + z ** 2))
K = special.ellipk((4 * radius * rho) / ((radius + rho) ** 2 + z ** 2))
Bz = 1 / np.sqrt((radius + rho) ** 2 + z ** 2) * (
                K
                + E * (radius ** 2 - rho ** 2 - z ** 2) /
                    ((radius - rho) ** 2 + z ** 2)
            )
Brho = z / (rho * np.sqrt((radius + rho) ** 2 + z ** 2)) * (
                - K
                + E * (radius ** 2 + rho ** 2 + z ** 2) /
                    ((radius - rho) ** 2 + z ** 2)
            )
del E, K, z, rho
# On the axis of the coil we get a divided by zero. This returns a
# NaN, where the field is actually zero :
Brho[np.isnan(Brho)] = 0

Bx, By = x_proj * Brho, y_proj * Brho

del x_proj, y_proj, Brho

#### Visualize the field ####################################################
from mayavi import mlab
fig = mlab.figure(1, size=(400, 400), bgcolor=(1, 1, 1), fgcolor=(0, 0, 0))

field = mlab.pipeline.vector_field(Bx, By, Bz)
# Unfortunately, the above call makes a copy of the arrays, so we delete
# this copy to free memory.
del Bx, By, Bz

magnitude = mlab.pipeline.extract_vector_norm(field)
contours = mlab.pipeline.iso_surface(magnitude,
                                        contours=[0.01, 0.8, 3.8, ],
                                        transparent=True,
                                        opacity=0.4,
                                        colormap='YlGnBu',
                                        vmin=0, vmax=2)


field_lines = mlab.pipeline.streamline(magnitude, seedtype='line',
                                        integration_direction='both',
                                        colormap='bone',
                                        vmin=0, vmax=1)

# Tweak a bit the streamline.
field_lines.stream_tracer.maximum_propagation = 100.
field_lines.seed.widget.point1 = [69, 75.5, 75.5]
field_lines.seed.widget.point2 = [82, 75.5, 75.5]
field_lines.seed.widget.resolution = 50
field_lines.seed.widget.enabled = False

mlab.view(42, 73, 104, [79,  75,  76])

mlab.show()

########NEW FILE########
__FILENAME__ = mri
"""
Viewing MRI data with cut plane and iso surface.

This example downloads an MRI scan, turns it into a 3D numpy array and
visualizes it.

First we extract some internal structures of the brain by defining a
volume of interest around them, and using iso surfaces.

Then we display two cut planes to show the raw MRI data itself.

Finally we display the outer surface, but we restrict it to volume of
interest to leave a cut for the cut planes.

For an example of feature extraction from MRI data using Mayavi and vtk,
see :ref:`example_tvtk_segmentation`.
"""

### Download the data, if not already on disk #################################
import os
if not os.path.exists('mri_data.tar.gz'):
    # Download the data
    import urllib
    print "Downloading data, Please Wait (7.8MB)"
    opener = urllib.urlopen(
                'http://www-graphics.stanford.edu/data/voldata/MRbrain.tar.gz')
    open('mri_data.tar.gz', 'wb').write(opener.read())

# Extract the data
import tarfile
tar_file = tarfile.open('mri_data.tar.gz')
try:
    os.mkdir('mri_data')
except:
    pass
tar_file.extractall('mri_data')
tar_file.close()


### Read the data in a numpy 3D array #########################################
import numpy as np
data = np.array([np.fromfile(os.path.join('mri_data', 'MRbrain.%i' % i),
                                        dtype='>u2') for i in range(1, 110)])
data.shape = (109, 256, 256)
data = data.T

# Display the data ############################################################
from mayavi import mlab

mlab.figure(bgcolor=(0, 0, 0), size=(400, 400))

src = mlab.pipeline.scalar_field(data)
# Our data is not equally spaced in all directions:
src.spacing = [1, 1, 1.5]
src.update_image_data = True


# Extract some inner structures: the ventricles and the inter-hemisphere
# fibers. We define a volume of interest (VOI) that restricts the
# iso-surfaces to the inner of the brain. We do this with the ExtractGrid
# filter.
blur = mlab.pipeline.user_defined(src, filter='ImageGaussianSmooth')
voi = mlab.pipeline.extract_grid(blur)
voi.set(x_min=125, x_max=193, y_min=92, y_max=125, z_min=34, z_max=75)

mlab.pipeline.iso_surface(voi, contours=[1610, 2480], colormap='Spectral')

# Add two cut planes to show the raw MRI data. We use a threshold filter
# to remove cut the planes outside the brain.
thr = mlab.pipeline.threshold(src, low=1120)
cut_plane = mlab.pipeline.scalar_cut_plane(thr,
                                plane_orientation='y_axes',
                                colormap='black-white',
                                vmin=1400,
                                vmax=2600)
cut_plane.implicit_plane.origin = (136, 111.5, 82)
cut_plane.implicit_plane.widget.enabled = False

cut_plane2 = mlab.pipeline.scalar_cut_plane(thr,
                                plane_orientation='z_axes',
                                colormap='black-white',
                                vmin=1400,
                                vmax=2600)
cut_plane2.implicit_plane.origin = (136, 111.5, 82)
cut_plane2.implicit_plane.widget.enabled = False

# Extract two views of the outside surface. We need to define VOIs in
# order to leave out a cut in the head.
voi2 = mlab.pipeline.extract_grid(src)
voi2.set(y_min=112)
outer = mlab.pipeline.iso_surface(voi2, contours=[1776, ],
                                        color=(0.8, 0.7, 0.6))

voi3 = mlab.pipeline.extract_grid(src)
voi3.set(y_max=112, z_max=53)
outer3 = mlab.pipeline.iso_surface(voi3, contours=[1776, ],
                                         color=(0.8, 0.7, 0.6))


mlab.view(-125, 54, 326, (145.5, 138, 66.5))
mlab.roll(-175)

mlab.show()

import shutil
shutil.rmtree('mri_data')

########NEW FILE########
__FILENAME__ = plotting_many_lines
"""
This examples shows how many lines can be grouped together in a single
object, for convenience and efficiency.

We want to plot a large number of lines. We could use mlab.plot3d for
this, but it will create an object for each line, this will be
inefficient. This example shows how to create one object comprised of
many lines.

The underlying idea is the same as that used to plot graphes (see for
instance :ref:`example_flight_graph`): create a set of points, and
specify explicitely the connectivity between them. First we create the
set of unconnected point (the underlying data structure is a
:ref:`poly_data`) using `mlab.pipeline.scalar_scatter`. To add the
connections, we need to keep track of which point is connected to which.
As we only have lines, this is fairly easy: in a line, each point is
connected to the following one.

"""

# Author: Gael Varoquaux <gael dot varoquaux at normalesup dot org>
# Copyright (c) 2010, Enthought
# License: BSD style

import numpy as np

# The number of points per line
N = 300

# The scalar parameter for each line
t = np.linspace(-2 * np.pi, 2 * np.pi, N)

from mayavi import mlab
mlab.figure(1, size=(400, 400), bgcolor=(0, 0, 0))
mlab.clf()

# We create a list of positions and connections, each describing a line.
# We will collapse them in one array before plotting.
x = list()
y = list()
z = list()
s = list()
connections = list()

# The index of the current point in the total amount of points
index = 0

# Create each line one after the other in a loop
for i in range(50):
    x.append(np.sin(t))
    y.append(np.cos((2 + .02 * i) * t))
    z.append(np.cos((3 + .02 * i) * t))
    s.append(t)
    # This is the tricky part: in a line, each point is connected
    # to the one following it. We have to express this with the indices
    # of the final set of points once all lines have been combined
    # together, this is why we need to keep track of the total number of
    # points already created (index)
    connections.append(np.vstack(
                       [np.arange(index,   index + N - 1.5),
                        np.arange(index + 1, index + N - .5)]
                            ).T)
    index += N

# Now collapse all positions, scalars and connections in big arrays
x = np.hstack(x)
y = np.hstack(y)
z = np.hstack(z)
s = np.hstack(s)
connections = np.vstack(connections)

# Create the points
src = mlab.pipeline.scalar_scatter(x, y, z, s)

# Connect them
src.mlab_source.dataset.lines = connections
src.update()

# The stripper filter cleans up connected lines
lines = mlab.pipeline.stripper(src)

# Finally, display the set of lines
mlab.pipeline.surface(lines, colormap='Accent', line_width=1, opacity=.4)

# And choose a nice view
mlab.view(33.6, 106, 5.5, [0, 0, .05])
mlab.roll(125)
mlab.show()

########NEW FILE########
__FILENAME__ = protein
"""
Visualize a protein graph structure downloaded from the protein database in
standard pdb format.

We parse the pdb file, but extract only a very small amount of
information: the type of atoms, their positions, and the links between them.

Most of the complexity of this example comes from the code turning the
PDB information into a list of 3D positions, with associated scalar
and connection information.

We assign a scalar value for the atoms to differenciate the different
types of atoms, but it does not correspond to the atomic mass. The size
and the color of the atom on the visualization is therefore not
chemicaly-significant.

The atoms are plotted using mlab.points3d, and connections between atoms
are added to the dataset, and visualized using a surface module.

The graph is created by adding connection information to points. For this, each
point is designated by its number (in the order of the array passed to
mlab.points3d), and the connection array, made of pairs of these numbers, is
constructed. There is some slightly tedious data manipulation to go from the
named-node graph representation as stored in the pdb file, to the index-based
connection pairs. A similar technique to plot the graph is done in the
:ref:`example_flight_graph`. Another example of graph plotting, showing a
different technique to plot the graph, can be seen on
:ref:`example_delaunay_graph`.

To visualize the local atomic density, we use a gaussian splatter filter
that builds a kernel density estimation of the continuous density field:
each point is convoluted by a Gaussian kernel, and the sum of these
Gaussians form the resulting density field. We visualize this field using
volume rendering.

Reference for the pdb file standard:
http://mmcif.pdb.org/dictionaries/pdb-correspondence/pdb2mmcif.html
"""

# Author: Gael Varoquaux <gael.varoquaux@normalesup.org>
# Copyright (c) 2008, Enthought, Inc.
# License: BSD Style.

# The pdb code for the protein.
protein_code = '2q09'

# Retrieve the file from the protein database #################################
import os
if not os.path.exists('pdb%s.ent.gz' % protein_code):
    # Download the data
    import urllib
    print 'Downloading protein data, please wait'
    opener = urllib.urlopen(
      'ftp://ftp.wwpdb.org/pub/pdb/data/structures/divided/pdb/q0/pdb%s.ent.gz'
      % protein_code)
    open('pdb%s.ent.gz' % protein_code, 'wb').write(opener.read())

# Parse the pdb file ##########################################################
import gzip
infile = gzip.GzipFile('pdb%s.ent.gz' % protein_code, 'rb')

# A graph represented by a dictionary associating nodes with keys
# (numbers), and edges (pairs of node keys).
nodes = dict()
edges = list()
atoms = set()

# Build the graph from the PDB information
last_atom_label = None
last_chain_label = None
for line in infile:
    line = line.split()
    if line[0] in ('ATOM', 'HETATM'):
        nodes[line[1]] = (line[2], line[6], line[7], line[8])
        atoms.add(line[2])
        chain_label = line[5]
        if chain_label == last_chain_label:
            edges.append((line[1], last_atom_label))
        last_atom_label = line[1]
        last_chain_label = chain_label
    elif line[0] == 'CONECT':
        for start, stop in zip(line[1:-1], line[2:]):
            edges.append((start, stop))

atoms = list(atoms)
atoms.sort()
atoms = dict(zip(atoms, range(len(atoms))))

# Turn the graph into 3D positions, and a connection list.
labels = dict()

x = list()
y = list()
z = list()
scalars = list()

for index, label in enumerate(nodes):
    labels[label] = index
    this_scalar, this_x, this_y, this_z = nodes[label]
    scalars.append(atoms[this_scalar])
    x.append(float(this_x))
    y.append(float(this_y))
    z.append(float(this_z))

connections = list()

for start, stop in edges:
    connections.append((labels[start], labels[stop]))

import numpy as np
x = np.array(x)
y = np.array(y)
z = np.array(z)
scalars = np.array(scalars)

# Visualize the data ##########################################################
from mayavi import mlab
mlab.figure(1, bgcolor=(0, 0, 0))
mlab.clf()

pts = mlab.points3d(x, y, z, 1.5 * scalars.max() - scalars,
                                    scale_factor=0.015, resolution=10)
pts.mlab_source.dataset.lines = np.array(connections)

# Use a tube fiter to plot tubes on the link, varying the radius with the
# scalar value
tube = mlab.pipeline.tube(pts, tube_radius=0.15)
tube.filter.radius_factor = 1.
tube.filter.vary_radius = 'vary_radius_by_scalar'
mlab.pipeline.surface(tube, color=(0.8, 0.8, 0))

# Visualize the local atomic density
mlab.pipeline.volume(mlab.pipeline.gaussian_splatter(pts))

mlab.view(49, 31.5, 52.8, (4.2, 37.3, 20.6))

mlab.show()

########NEW FILE########
__FILENAME__ = simple_structured_grid
"""
An example creating a structured grid data set from numpy arrays using TVTK
and visualizing it using mlab.

In this example, we create a structured-grid data set: we describe
data, both scalar and vector, lying on a structured-grid, ie a grid where
each vertex has 6 neighboors. For this we directly create a
StructuredGrid tvtk object, rather than using the mlab.pipeline source
functions, as it gives us more control.

To visualize the resulting dataset, we apply several modules, using the
mlab.pipeline interface (see :ref:`controlling-the-pipeline-with-mlab-scripts`)
"""
# Author: Prabhu Ramachandran <prabhu@aero.iitb.ac.in>
# Copyright (c) 2008, Prabhu Ramachandran.
# License: BSD Style.

from numpy import mgrid, empty, sin, pi
from tvtk.api import tvtk
from mayavi import mlab

# Generate some points.
x, y, z = mgrid[1:6:11j, 0:4:13j, 0:3:6j]
base = x[..., 0] + y[..., 0]
# Some interesting z values.
for i in range(z.shape[2]):
    z[..., i] = base * 0.25 * i

# The actual points.
pts = empty(z.shape + (3,), dtype=float)
pts[..., 0] = x
pts[..., 1] = y
pts[..., 2] = z

# Simple scalars.
scalars = x * x + y * y + z * z
# Some vectors
vectors = empty(z.shape + (3,), dtype=float)
vectors[..., 0] = (4 - y * 2)
vectors[..., 1] = (x * 3 - 12)
vectors[..., 2] = sin(z * pi)

# We reorder the points, scalars and vectors so this is as per VTK's
# requirement of x first, y next and z last.
pts = pts.transpose(2, 1, 0, 3).copy()
pts.shape = pts.size / 3, 3
scalars = scalars.T.copy()
vectors = vectors.transpose(2, 1, 0, 3).copy()
vectors.shape = vectors.size / 3, 3

# Create the dataset.
sg = tvtk.StructuredGrid(dimensions=x.shape, points=pts)
sg.point_data.scalars = scalars.ravel()
sg.point_data.scalars.name = 'temperature'
sg.point_data.vectors = vectors
sg.point_data.vectors.name = 'velocity'

# Thats it!

# Now visualize the data.
d = mlab.pipeline.add_dataset(sg)
gx = mlab.pipeline.grid_plane(d)
gy = mlab.pipeline.grid_plane(d)
gy.grid_plane.axis = 'y'
gz = mlab.pipeline.grid_plane(d)
gz.grid_plane.axis = 'z'
iso = mlab.pipeline.iso_surface(d)
iso.contour.maximum_contour = 75.0
vec = mlab.pipeline.vectors(d)
vec.glyph.mask_input_points = True
vec.glyph.glyph.scale_factor = 1.5

mlab.show()

########NEW FILE########
__FILENAME__ = spherical_harmonics
"""
Plot spherical harmonics on the surface of the sphere, as well as a 3D
polar plot.

This example requires scipy.

In this example we use the mlab's mesh function:
:func:`mayavi.mlab.mesh`.
For plotting surfaces this is a very versatile function. The surfaces can
be defined as functions of a 2D grid.

For each spherical harmonic, we plot its value on the surface of a
sphere, and then in polar. The polar plot is simply obtained by varying
the radius of the previous sphere.
"""

# Author: Gael Varoquaux <gael.varoquaux@normalesup.org>
# Copyright (c) 2008, Enthought, Inc.
# License: BSD Style.

from mayavi import mlab
import numpy as np
from scipy.special import sph_harm

# Create a sphere
r = 0.3
pi = np.pi
cos = np.cos
sin = np.sin
phi, theta = np.mgrid[0:pi:101j, 0:2 * pi:101j]

x = r * sin(phi) * cos(theta)
y = r * sin(phi) * sin(theta)
z = r * cos(phi)

mlab.figure(1, bgcolor=(1, 1, 1), fgcolor=(0, 0, 0), size=(400, 300))
mlab.clf()
# Represent spherical harmonics on the surface of the sphere
for n in range(1, 6):
    for m in range(n):
        s = sph_harm(m, n, theta, phi).real

        mlab.mesh(x - m, y - n, z, scalars=s, colormap='jet')

        s[s < 0] *= 0.97

        s /= s.max()
        mlab.mesh(s * x - m, s * y - n, s * z + 1.3,
                  scalars=s, colormap='Spectral')

mlab.view(90, 70, 6.2, (-1.3, -2.9, 0.25))
mlab.show()

########NEW FILE########
__FILENAME__ = surface_from_irregular_data
"""
An example which shows how to plot a surface from data acquired
irregularly.

Data giving the variation of a parameter 'z' as a function of two others
('x' and 'y') is often plotted as a `carpet plot`, using a surface to
visualize the underlying function. when the data has been acquired on a
regular grid for parameters 'x' and 'y', it can simply be view with the
mlab.surf function. However, when there are some missing points, or the
data has been acquired at random, the surf function cannot be used.

The difficulty stems from the fact that points positionned in 3D do
not define a surface if no connectivity information is given. With the
surf function, this information is implicite from the shape of the input
arrays.

In this example, randomly-positionned points in the (x, y) plane are
embedded in a surface in the z axis. We first visualize the points using
mlab.points3d. We then use the delaunay2d filter to extract the mesh by
nearest-neighboor matching, and visualize it using the surface module.
"""
# Author: Gael Varoquaux <gael.varoquaux@normalesup.org>
# Copyright (c) 2009, Enthought, Inc.
# License: BSD Style.

import numpy as np

# Create data with x and y random in the [-2, 2] segment, and z a
# Gaussian function of x and y.
np.random.seed(12345)
x = 4 * (np.random.random(500) - 0.5)
y = 4 * (np.random.random(500) - 0.5)


def f(x, y):
    return np.exp(-(x ** 2 + y ** 2))

z = f(x, y)

from mayavi import mlab
mlab.figure(1, fgcolor=(0, 0, 0), bgcolor=(1, 1, 1))

# Visualize the points
pts = mlab.points3d(x, y, z, z, scale_mode='none', scale_factor=0.2)

# Create and visualize the mesh
mesh = mlab.pipeline.delaunay2d(pts)
surf = mlab.pipeline.surface(mesh)

mlab.view(47, 57, 8.2, (0.1, 0.15, 0.14))
mlab.show()

########NEW FILE########
__FILENAME__ = tvtk_in_mayavi
"""
An example of pure TVTK programming to build TVTK objects, which are then
added to a Mayavi scene.

This example show how pure TVTK objects can be added to a Mayavi scene.

This programming style does not allow to benefit from the data-management
facilities of Mayavi (the pipeline, the data-oriented mlab functions),
but it allows to easily reuse VTK code together with Mayavi or mlab code.

If you want to use arbritrary VTK filters with Mayavi, it is best to use
the UserDefined Mayavi filter, which enables the user to insert any VTK
filter in the Mayavi pipeline. See, for instance, the :ref:`example_mri`
for example of the UserDefined filter. For a full-blown example of a
complex VTK pipeline built with Mayavi, see
:ref:`example_tvtk_segmentation`.
"""

# Author: Gael Varoquaux <gael.varoquaux@normalesup.org>
# Copyright (c) 2008, Enthought, Inc.
# License: BSD Style.

from mayavi import mlab

# To access any VTK object, we use 'tvtk', which is a Python wrapping of
# VTK replacing C++ setters and getters by Python properties and
# converting numpy arrays to VTK arrays when setting data.
from tvtk.api import tvtk
from tvtk.common import configure_input_data

v = mlab.figure()

# Create a first sphere
# The source generates data points
sphere = tvtk.SphereSource(center=(0, 0, 0), radius=0.5)
# The mapper converts them into position in, 3D with optionally color (if
# scalar information is available).
sphere_mapper = tvtk.PolyDataMapper()
configure_input_data(sphere_mapper, sphere.output)
sphere.update()

# The Property will give the parameters of the material.
p = tvtk.Property(opacity=0.2, color=(1, 0, 0))
# The actor is the actually object in the scene.
sphere_actor = tvtk.Actor(mapper=sphere_mapper, property=p)
v.scene.add_actor(sphere_actor)

# Create a second sphere
sphere2 = tvtk.SphereSource(center=(7, 0, 1), radius=0.2)
sphere_mapper2 = tvtk.PolyDataMapper()
configure_input_data(sphere_mapper2, sphere2.output)
sphere2.update()
p = tvtk.Property(opacity=0.3, color=(1, 0, 0))
sphere_actor2 = tvtk.Actor(mapper=sphere_mapper2, property=p)
v.scene.add_actor(sphere_actor2)

# Create a line between the two spheres
line = tvtk.LineSource(point1=(0, 0, 0), point2=(7, 0, 1))
line_mapper = tvtk.PolyDataMapper()
configure_input_data(line_mapper, line.output)
line.update()
line_actor = tvtk.Actor(mapper=line_mapper)
v.scene.add_actor(line_actor)

# And display text
vtext = tvtk.VectorText()
vtext.text = 'Mayavi'
text_mapper = tvtk.PolyDataMapper()
configure_input_data(text_mapper, vtext.get_output())
vtext.update()
p2 = tvtk.Property(color=(0, 0.3, 0.3))
text_actor = tvtk.Follower(mapper=text_mapper, property=p2)
text_actor.position = (0, 0, 0)
v.scene.add_actor(text_actor)

# Choose a view angle, and display the figure
mlab.view(85, -17, 15, [3.5, -0.3, -0.8])
mlab.show()

########NEW FILE########
__FILENAME__ = wigner
"""
An example in which 3 functions of x and y  are displayed with a surf plot,
while the z scaling is kept constant, to allow comparison between them.

The important aspect of this example is that the 3 functions should not
be displayed on top of each other, but side by side. For this we use the
extent keyword argument.

In addition, the relative scale between the different plots is important.
This is why we also use the `warp_scale` keyword argument, to have the same
scale on all plots.

Finally, we have to adjust the data bounds: as we want the "horizon" of
the wigner function in the middle of our extents, we put this to zero.

We add a set of axes and outlines to the plot. We have to play we extents
and ranges in order to make them fit with the data.
"""
# Author: Gael Varoquaux <gael.varoquaux@normalesup.org>
# Copyright (c) 2007, Enthought, Inc.
# License: BSD Style.


import numpy
from mayavi import mlab


def cat(x, y, alpha, eta=1, purity=1):
    """ Multiphoton shrodinger cat. eta is the fidelity, alpha the number
        of photons"""
    cos = numpy.cos
    exp = numpy.exp
    return (1 + eta * (exp(-x ** 2 - (y - alpha) ** 2) + exp(-x ** 2 -
    (y + alpha) ** 2) + 2 * purity * exp(-x ** 2 - y ** 2) * cos(2 * \
    alpha * x)) / (2 * (1 + exp(- alpha ** 2)))) / 2

x, y = numpy.mgrid[-4:4.15:0.1, -4:4.15:0.1]

mlab.figure(1, size=(500, 250), fgcolor=(1, 1, 1),
                                    bgcolor=(0.5, 0.5, 0.5))
mlab.clf()

cat1 = cat(x, y, 1)
cat2 = cat(x, y, 2)
cat3 = cat(x, y, 3)

# The cats lie in a [0, 1] interval, with .5 being the assymptotique
# value. We want to reposition this value to 0, so as to put it in the
# center of our extents.
cat1 -= 0.5
cat2 -= 0.5
cat3 -= 0.5

cat1_extent = (-14, -6, -4, 4, 0, 5)
surf_cat1 = mlab.surf(x - 10, y, cat1, colormap='Spectral', warp_scale=5,
            extent=cat1_extent, vmin=-0.5, vmax=0.5)
mlab.outline(surf_cat1, color=(.7, .7, .7), extent=cat1_extent)
mlab.axes(surf_cat1, color=(.7, .7, .7), extent=cat1_extent,
            ranges=(0, 1, 0, 1, 0, 1), xlabel='', ylabel='',
            zlabel='Probability',
            x_axis_visibility=False, z_axis_visibility=False)

mlab.text(-18, -4, '1 photon', z=-4, width=0.13)

cat2_extent = (-4, 4, -4, 4, 0, 5)
surf_cat2 = mlab.surf(x, y, cat2, colormap='Spectral', warp_scale=5,
            extent=cat2_extent, vmin=-0.5, vmax=0.5)
mlab.outline(surf_cat2, color=(0.7, .7, .7), extent=cat2_extent)

mlab.text(-4, -3, '2 photons', z=-4, width=0.14)

cat3_extent = (6, 14, -4, 4, 0, 5)
surf_cat3 = mlab.surf(x + 10, y, cat3, colormap='Spectral', warp_scale=5,
            extent=cat3_extent, vmin=-0.5, vmax=0.5)
mlab.outline(surf_cat3, color=(.7, .7, .7), extent=cat3_extent)

mlab.text(6, -2.5, '3 photons', z=-4, width=0.14)

mlab.title('Multi-photons cats Wigner function')

mlab.view(142, -72, 32)

mlab.show()

########NEW FILE########
__FILENAME__ = nongui
#!/usr/bin/env python
"""
This script demonstrates how one can use the Mayavi application framework
without displaying Mayavi's UI.

Note: look at the end of this file to see how the non gui plugin is
chosen instead of the default gui mayavi plugin.

This should be run as::

  $ python nongui.py

Or::

  $ mayavi2 script.py

"""
# Author: Prabhu Ramachandran <prabhu_r@users.sf.net>
# Copyright (c) 2005, Enthought, Inc.
# License: BSD Style.

# Standard library imports
from os.path import join, abspath

# Enthought library imports
from mayavi.scripts.util import get_data_dir
from mayavi.plugins.app import Mayavi, get_non_gui_plugins

class MyApp(Mayavi):
    def run(self):
        """This is executed once the application GUI has started.
        *Make sure all other MayaVi specific imports are made here!*
        """

        # Various imports to do different things.
        from mayavi.sources.vtk_file_reader import VTKFileReader
        from mayavi.modules.outline import Outline
        from mayavi.modules.axes import Axes
        from mayavi.modules.grid_plane import GridPlane
        from mayavi.modules.image_plane_widget import ImagePlaneWidget
        from mayavi.modules.text import Text
        from mayavi.modules.contour_grid_plane import ContourGridPlane
        from mayavi.modules.iso_surface import IsoSurface

        script = self.script

        # Create a new scene.
        script.new_scene()

        # Read a VTK (old style) data file.
        r = VTKFileReader()
        r.initialize(join(get_data_dir(abspath(__file__)),
                          'heart.vtk'))
        script.add_source(r)

        # Put up some text.
        t = Text(text='MayaVi rules!', x_position=0.2, y_position=0.9, width=0.8)
        t.property.color = 1, 1, 0  # Bright yellow, yeah!
        script.add_module(t)

        # Create an outline for the data.
        o = Outline()
        script.add_module(o)

        # Create an axes for the data.
        a = Axes()
        script.add_module(a)

        # Create three simple grid plane modules.
        # First normal to 'x' axis.
        gp = GridPlane()
        script.add_module(gp)
        # Second normal to 'y' axis.
        gp = GridPlane()
        gp.grid_plane.axis = 'y'
        script.add_module(gp)
        # Third normal to 'z' axis.
        gp = GridPlane()
        script.add_module(gp)
        gp.grid_plane.axis = 'z'

        # Create one ImagePlaneWidget.
        ipw = ImagePlaneWidget()
        script.add_module(ipw)
        # Set the position to the middle of the data.
        ipw.ipw.slice_position = 16

        # Create one ContourGridPlane normal to the 'x' axis.
        cgp = ContourGridPlane()
        script.add_module(cgp)
        # Set the position to the middle of the data.
        cgp.grid_plane.axis = 'y'
        cgp.grid_plane.position = 15

        # An isosurface module.
        iso = IsoSurface(compute_normals=True)
        script.add_module(iso)
        iso.contour.contours = [200.0]

        # Set the view.
        s = script.engine.current_scene
        cam = s.scene.camera
        cam.azimuth(45)
        cam.elevation(15)
        s.render()


if __name__ == '__main__':
    m = MyApp()
    # Get the default non GUI plugins.
    plugins = get_non_gui_plugins()
    # Start the app with these plugins.
    m.main(plugins=plugins)

########NEW FILE########
__FILENAME__ = standalone
#!/usr/bin/env python
"""A simple example of how you can use Mayavi without
using Envisage or the Mayavi Envisage application.

"""
# Author: Prabhu Ramachandran <prabhu@aero.iitb.ac.in>
# Copyright (c) 2007, Enthought, Inc.
# License: BSD Style.

from os.path import join, abspath

from pyface.api import GUI
# The core Engine.
from mayavi.core.api import Engine
from mayavi.core.ui.engine_view import EngineView
# Usual MayaVi imports
from mayavi.scripts.util import get_data_dir
from mayavi.sources.api import VTKXMLFileReader
from mayavi.modules.api import Outline, ScalarCutPlane, Streamline


def main():
    # Create the MayaVi engine and start it.
    e = Engine()
    # Starting the engine registers the engine with the registry and
    # notifies others that the engine is ready.
    e.start()

    # Do this if you need to see the MayaVi tree view UI.
    ev = EngineView(engine=e)
    ui = ev.edit_traits()

    # Create a new scene.
    scene = e.new_scene()
    # Now create a new scene just for kicks.
    scene1 = e.new_scene()

    # Now setup a normal MayaVi pipeline.
    src = VTKXMLFileReader()
    src.initialize(join(get_data_dir(abspath(__file__)),
                        'fire_ug.vtu'))
    e.add_source(src)
    e.add_module(Outline())
    e.add_module(ScalarCutPlane())
    e.add_module(Streamline())
    return e, ui

if __name__ == '__main__':
    # When main returns the ui to go out of scope and be gc'd causing the view
    # to disappear with qt4.
    e, ui = main()
    # Create a GUI instance and start the event loop.  We do this here so that
    # main can be run from IPython -wthread if needed.
    gui = GUI()
    gui.start_event_loop()


########NEW FILE########
__FILENAME__ = user_mayavi
"""
Sample Mayavi customization file.

This code is not to be executed as `mayavi2 -x user_mayavi.py` or
`python user_mayavi.py`.

Put this file in ~/.mayavi2/user_mayavi.py and rerun mayavi2 to see what
it does -- the worker view may not show up by default so you will have
to go to View->Other and in the Show View dialog, activate the "Custom
Mayavi2 View".

The added modules should show up in the menus (Look for UserOutline in
the Modules)

____

This module demonstrates how to extend Mayavi.  It extends the  modules
provided by mayavi by adding these to the Mayavi registry.  Note that
the registry imports customize which in turn imports this file.

It also defines an Envisage plugin that is added to the default list of
plugins to extend the running mayavi application.  This plugin is
returned by the `get_plugins()` function.

This file must be placed inside the `~/.mayavi2` directory and called
`user_mayavi.py`.  Please note that `~/.mayavi2` is placed in `sys.path`
(if the directory exists) so make sure that you choose your module names
carefully (so as not to override any common module names).

The file may also be placed anywhere on sys.path and called
`site_mayavi.py` for global system level customizations.

"""
# Author: Prabhu Ramachandran <prabhu@aero.iitb.ac.in>
# Copyright (c) 2006-2008, Enthought, Inc.
# License: BSD Style.

from mayavi.core.registry import registry
from mayavi.core.pipeline_info import PipelineInfo
from mayavi.core.metadata import ModuleMetadata

# Metadata for the new module we want to add -- notice that we use a
# factory function here for convenience, we could also use a class but
# the reasons for doing this are documented below.
user_outline = ModuleMetadata(
    id            = "UserOutlineModule",
    menu_name          = "&UserOutline",
    factory = 'user_mayavi.user_outline',
    desc   = "Draw a cornered outline for given input",
    tooltip       = "Draw a cornered outline for given input",
    help       = "Draw a cornered outline for given input",
    input_info = PipelineInfo(datasets=['any'],
                              attribute_types=['any'],
                              attributes=['any'])
)

# Register the module with the mayavi registry.
registry.modules.append(user_outline)

#######
# The all important function that returns the plugin we wish to add to
# the default mayavi application.
def get_plugins():
    # We simply return a list containing the WorkerPlugin defined below.
    return [WorkerPlugin()]

######################################################################
# Thats it, basically.  The rest of the code should really be in another
# module but is in the same module for convenience here.  There are
# problems with doing any significant non-core module imports in this
# module as documented below.
######################################################################


######################################################################
# THE CODE BELOW SHOULD REALLY BE IN SEPARATE MODULES.
#
# The following can very well be in a separate module but I've kept it
# here to make this a compact demo of how to customize things.
######################################################################


######################################################################
# A new module to expose to mayavi.
#
# WARNING: Do not do other mayavi imports right here like for example:
# 'from mayavi.modules.outline import Outline' etc.  This is
# because the user_mayavi is imported at a time when many of the imports
# are not complete and this will cause hard-to-debug circular import
# problems.  The registry is given only metadata mostly in the form of
# strings and this will cause no problem.  Therefore to define new
# modules, we strongly recommend that the modules be defined in another
# module or be defined in a factory function as done below.

def user_outline():
    """A Factory function that creates a new module to add to the
    pipeline.  Note that the method safely does any mayavi imports
    inside avoiding any circular imports.
    """
    print "User Outline"
    from mayavi.modules.outline import Outline
    o = Outline(outline_mode='cornered', name='UserOutline')
    return o


######################################################################
# This code simulates something the user would like to do.  In this case
# we just want to create some data, view it with mayavi and modify the
# data.  We want to add this as a view to the standard mayavi.  The code
# below is simply traits code with a few extra things to be able to grab
# the running mayavi instance and script it.  The object we create we
# offer as an envisage service offer -- this instantiates the worker.
# The WorkerPlugin exposes the service offer and shows the view of this
# worker.

import numpy

from traits.api import HasTraits, Range, Button, Instance, List
from traitsui.api import Item, View

######################################################################
# `Worker` class
######################################################################
class Worker(HasTraits):
    """This class basically allows you to create a data set, view it
    and modify the dataset.  This is a rather crude example but
    demonstrates how things can be done.
    """

    # Set by envisage when this is contributed as a ServiceOffer.
    window = Instance('pyface.workbench.api.WorkbenchWindow')

    create_data = Button('Create data')
    reset_data = Button('Reset data')
    view_data = Button('View data')
    scale = Range(0.0, 1.0)
    source = Instance('mayavi.core.source.Source')

    # Our UI view.
    view = View(Item('create_data', show_label=False),
                Item('view_data', show_label=False),
                Item('reset_data', show_label=False),
                Item('scale'),
                resizable=True
                )

    def get_mayavi(self):
        from mayavi.plugins.script import Script
        return self.window.get_service(Script)

    def _make_data(self):
        dims = [64, 64, 64]
        np = dims[0]*dims[1]*dims[2]
        x, y, z = numpy.ogrid[-5:5:dims[0]*1j,-5:5:dims[1]*1j,-5:5:dims[2]*1j]
        x = x.astype('f')
        y = y.astype('f')
        z = z.astype('f')
        s = (numpy.sin(x*y*z)/(x*y*z))
        s = s.transpose().copy() # This makes the data contiguous.
        return s

    def _create_data_fired(self):
        mayavi = self.get_mayavi()
        from mayavi.sources.array_source import ArraySource
        s = self._make_data()
        src = ArraySource(transpose_input_array=False, scalar_data=s)
        self.source = src
        mayavi.add_source(src)

    def _reset_data_fired(self):
        self.source.scalar_data = self._make_data()

    def _view_data_fired(self):
        mayavi = self.get_mayavi()
        from mayavi.modules.outline import Outline
        from mayavi.modules.image_plane_widget import ImagePlaneWidget
        # Visualize the data.
        o = Outline()
        mayavi.add_module(o)
        ipw = ImagePlaneWidget()
        mayavi.add_module(ipw)
        ipw.module_manager.scalar_lut_manager.show_scalar_bar = True

        ipw_y = ImagePlaneWidget()
        mayavi.add_module(ipw_y)
        ipw_y.ipw.plane_orientation = 'y_axes'

    def _scale_changed(self, value):
        src = self.source
        data = src.scalar_data
        data += value*0.01
        numpy.mod(data, 1.0, data)
        src.update()

######################################################################
# The following code is the small amount of envisage code that brings
# the users code (above) and Envisage/Mayavi UI together.
from envisage.api import Plugin, ServiceOffer

######################################################################
# `WorkerPlugin` class
######################################################################
class WorkerPlugin(Plugin):

    # Extension point Ids.
    SERVICE_OFFERS = 'envisage.ui.workbench.service_offers'
    VIEWS          = 'envisage.ui.workbench.views'

    # Services we contribute.
    service_offers = List(contributes_to=SERVICE_OFFERS)
    # Views.
    views = List(contributes_to=VIEWS)

    ######################################################################
    # Private methods.
    def _service_offers_default(self):
        """ Trait initializer. """
        worker_service_offer = ServiceOffer(
            protocol = 'user_mayavi.Worker',
            factory  = 'user_mayavi.Worker'
        )
        return [worker_service_offer]

    def _views_default(self):
        """ Trait initializer. """
        return [self._worker_view_factory]

    def _worker_view_factory(self, window, **traits):
        """ Factory method for the current selection of the engine. """

        from pyface.workbench.traits_ui_view import \
                TraitsUIView

        worker = window.get_service(Worker)
        tui_worker_view = TraitsUIView(obj=worker,
                                       view='view',
                                       id='user_mayavi.Worker.view',
                                       name='Custom Mayavi2 View',
                                       window=window,
                                       position='left',
                                       **traits
                                       )
        return tui_worker_view

# END OF CODE THAT SHOULD REALLY BE IN SEPARATE MODULES.
######################################################################

if __name__ == '__main__':
    import sys
    print "*"*80
    print "ERROR: This script isn't supposed to be executed."
    print __doc__
    print "*"*80

    from traits.util.home_directory import get_home_directory
    print "Your .mayavi2 directory should be in %s"%get_home_directory()
    print "*"*80
    sys.exit(1)

########NEW FILE########
__FILENAME__ = zzz_reader
"""This is a simple example that shows how to create a reader factory
and register that reader with mayavi.

To use this:

    - put this in ~/.mayavi2/
    - then import this module in your ~/.mayavi2/user_mayavi.py.

that's it.

What you should get:

    - Options to open .zzz files from the file->open menu.
    - Open .zzz files via right click.
    - Open .zzz files from the engine or mlab (via open)
    - do mayavi2 -d foo.zzz.

"""

from mayavi.core.api import registry, SourceMetadata, PipelineInfo

def zzz_reader(fname, engine):
    """Reader for .zzz files.

    Parameters:
    -----------

    fname -- Filename to be read.

    engine -- The engine the source will be associated with.
    """
    from tvtk.api import tvtk
    from mayavi.sources.vtk_data_source import VTKDataSource
    # Do your own reader stuff here, I'm just reading a VTK file with a
    # different extension here.
    r = tvtk.StructuredPointsReader(file_name=fname)
    r.update()

    src = VTKDataSource(data=r.output)
    return src

zzz_reader_info = SourceMetadata(
    id            = "ZZZReader",
    factory = 'zzz_reader.zzz_reader',
    tooltip       = "Load a ZZZ file",
    desc   = "Load a ZZZ file",
    help   = "Load a ZZZ file",
    menu_name        = "&ZZZ file",
    extensions = ['zzz'],
    wildcard = 'ZZZ files (*.zzz)|*.zzz',
    output_info = PipelineInfo(datasets=['unstructured_grid'],
                               attribute_types=['any'],
                               attributes=['any'])
)
# Inject this information in the mayavi registry
registry.sources.append(zzz_reader_info)

if __name__ == '__main__':
    import sys
    print "*"*80
    print "ERROR: This script isn't supposed to be executed."
    print __doc__
    print "*"*80
    sys.exit(1)


########NEW FILE########
__FILENAME__ = actor_editor
from traits.api import HasTraits, Instance, Enum, Dict
from traitsui.api import View, Item
from tvtk.pyface.actor_model import ITVTKActorModel
from tvtk.pyface.actor_editor import ActorEditor
from tvtk.pyface import actors
from tvtk.api import tvtk


######################################################################
class ActorModel(ITVTKActorModel):

    # A simple trait to change the actors/widgets.
    actor_type = Enum('cone', 'sphere', 'plane_widget', 'box_widget')

    #########################
    # ITVTKView Model traits.

    # This maintains a dictionary mapping objects (by identity) to lists (or
    # single items) of TVTK Actors or 3D Widgets that represent them in the
    # scene. Adding and removing objects from this dictionary adds and removes
    # them from the scene. This is the trait that will be edited by a
    # ActorEditor.
    actor_map = Dict()

    ######################
    view = View(Item(name='actor_type'),
                Item(name='actor_map',
                     editor=ActorEditor(scene_kwds={'background':(0.2,0.2,0.2)}),
                     show_label=False,
                     resizable=True,
                     height=500,
                     width=500)
                )

    def __init__(self, **traits):
        super(ActorModel, self).__init__(**traits)
        self._actor_type_changed(self.actor_type)

    ####################################
    # Private traits.
    def _actor_type_changed(self, value):
        if value == 'cone':
            a = actors.cone_actor()
            self.actor_map = {'cone': a}
        elif value == 'sphere':
            a = actors.sphere_actor()
            self.actor_map = {'sphere': a}
        elif value == 'plane_widget':
            w = tvtk.PlaneWidget()
            self.actor_map = {'plane_widget': w}
        elif value == 'box_widget':
            w = tvtk.BoxWidget()
            self.actor_map = {'box_widget': w}


if __name__ == '__main__':
    a = ActorModel()
    a.configure_traits()

########NEW FILE########
__FILENAME__ = animated_texture
#!/usr/bin/env python

""" Illustrates texturing on a glyph and also illustrates how easy it
is to change that texture when you treat it as a numpy array.  You can
change the numpy array in-place and have TVTK re-render the scene.
TVTK sees a view of this array without doing any data transfers.

"""
# Authors: Prabhu Ramachandran, Eric Jones
# Copyright (c) 2006, Enthought, Inc.
# License: BSD Style.

from numpy import arange, zeros, float32, float64, uint8, \
                  atleast_3d, exp, sqrt, pi

from tvtk.api import tvtk
from tvtk.common import configure_input_data, configure_source_data, \
                        is_old_pipeline

# Source for glyph.  Note that you need to pick a source that has
# texture co-ords already set.  If not you'll have to generate them.
# This is easily done -- its just a 2d array of (u,v) coords each
# between [0, 1] that you can set via something like
# point_data.t_coords = <array>.
#
# In this case CubeSource already defines texture coords for us (as of
# VTK-4.4).
cs = tvtk.CubeSource(x_length=2, y_length=1.0, z_length=0.5)

# Create input for the glyph -- the sources are placed at these input
# points.
pts = [[1,1,1],[0,0,0], [-1,-1,-1]]
pd = tvtk.PolyData(points=pts, polys=[[0],[1],[2]])
# Orientation/scaling is as per the vector attribute.
vecs = [[1,0,0], [0,1,0], [0,0,1]]
pd.point_data.vectors = vecs

# Create the glyph3d and set up the pipeline.
g = tvtk.Glyph3D(scale_mode='data_scaling_off', vector_mode = 'use_vector')
configure_input_data(g, pd)

# Note that VTK's vtkGlyph.SetSource is special because it has two
# call signatures: SetSource(src) and SetSource(int N, src) (which
# sets the N'th source).  In tvtk it is represented as both a property
# and as a method.  Using the `source` property will work fine if all
# you want is the first `source`.  OTOH if you want the N'th `source`
# use get_source(N).
# g.source = cs.output
configure_source_data(g, cs.output)
cs.update()
g.update()

m = tvtk.PolyDataMapper()
configure_input_data(m, g.output)
a = tvtk.Actor(mapper=m)

# Read the texture from image and set the texture on the actor.  If
# you don't like this image, replace with your favorite -- any image
# will do (you must use a suitable reader though).

def image_from_array(ary):
    """ Create a VTK image object that references the data in ary.
        The array is either 2D or 3D with.  The last dimension
        is always the number of channels.  It is only tested
        with 3 (RGB) or 4 (RGBA) channel images.

        Note: This works no matter what the ary type is (accept
        probably complex...).  uint8 gives results that make since
        to me.  Int32 and Float types give colors that I am not
        so sure about.  Need to look into this...
    """

    sz = ary.shape
    dims = len(sz)
    # create the vtk image data
    img = tvtk.ImageData()

    if dims == 2:
        # 1D array of pixels.
        img.whole_extent = (0, sz[0]-1, 0, 0, 0, 0)
        img.dimensions = sz[0], 1, 1
        img.point_data.scalars = ary

    elif dims == 3:
        # 2D array of pixels.
        if is_old_pipeline():
            img.whole_extent = (0, sz[0]-1, 0, sz[1]-1, 0, 0)
        else:
            img.extent = (0, sz[0]-1, 0, sz[1]-1, 0, 0)
        img.dimensions = sz[0], sz[1], 1

        # create a 2d view of the array
        ary_2d = ary[:]
        ary_2d.shape = sz[0]*sz[1],sz[2]
        img.point_data.scalars = ary_2d

    else:
        raise ValueError, "ary must be 3 dimensional."

    return img

sz = (256, 256, 3)
array_3d = zeros(sz, uint8)
img = image_from_array(array_3d)

t = tvtk.Texture(interpolate = 1)
configure_input_data(t, img)
a.texture = t

# Renderwindow stuff and add actor.
rw = tvtk.RenderWindow(size=(600, 600))
ren = tvtk.Renderer(background=(0.1, 0.2, 0.4))
rw.add_renderer(ren)
rwi = tvtk.RenderWindowInteractor(render_window=rw)
ren.add_actor(a)
rwi.initialize()

# create a little wave to slide across the image.
wave = 1/sqrt(2*pi)*exp(-arange(-2, 2, .05)**2/2)*255
# have to use += here because = doesn't respect broadcasting correctly.
array_3d[:len(wave)] += wave.astype(uint8)[:,None,None]

import time
t1 = time.time()
N = 256
for i in range(N):
    array_3d[1:] = array_3d[:-1]
    img.modified()
    rwi.render()
    #print i
t2 = time.time()
print 'texture size:', array_3d.shape
print 'fps:', N/(t2-t1)

rwi.start()

########NEW FILE########
__FILENAME__ = array_animation
#!/usr/bin/env python
"""A simple example showing an animation.  The example illustrates a
few things.

 1. You can pass a numpy array of scalars and use it directly with
    tvtk.

 2. The tvtk arrays are views of numpy arrays.  Thus changing the
    array in-place will also change the underlying VTK data.

 3. When changing the numpy data you must call `modified` on a
    relevant tvtk object.

The example is a little contrived since there are better ways of
achieving the same effect but the present form nicely illustrates item
2 mentioned above.

"""
# Author: Prabhu Ramachandran <prabhu_r@users.sf.net>
# Copyright (c) 2004-2007, Enthought, Inc.
# License: BSD Style.

from tvtk.api import tvtk
from tvtk.common import configure_input
import numpy
import time

# First create a structured points data set.
sp = tvtk.StructuredPoints(origin=(-10., -10., 0.0),
                           dimensions=(80, 80, 1),
                           spacing=(0.25, 0.25, 0.0))

# Create some nice data at these points.
x = numpy.arange(-10., 10., 0.25)
y = x
r = numpy.sqrt(x[:,None]**2+y**2)
# We need the transpose so the data is as per VTK's expected format
# where X coords vary fastest, Y next and then Z.
try:
    import scipy.special
    z = numpy.reshape(numpy.transpose(5.0*scipy.special.j0(r)), (-1,) )
except ImportError:
    z = numpy.reshape(numpy.transpose(5.0*numpy.sin(r)/r), (-1,) )

# Now set the scalar data for the StructuredPoints object.  The
# scalars of the structured points object will be a view into our
# Numeric array.  Thus, if we change `z` in-place, the changes will
# automatically affect the VTK arrays.
sp.point_data.scalars = z

# Convert this to a PolyData object.
geom_filter = tvtk.ImageDataGeometryFilter()
configure_input(geom_filter, sp)

# Now warp this using the scalar value to generate a carpet plot.
warp = tvtk.WarpScalar()
configure_input(warp, geom_filter)

# Smooth the resulting data so it looks good.
normals = tvtk.PolyDataNormals()
configure_input(normals, warp)

# The rest of the VTK pipeline.
m = tvtk.PolyDataMapper(scalar_range=(min(z), max(z)))
configure_input(m, normals)

a = tvtk.Actor(mapper=m)

ren = tvtk.Renderer(background=(0.5, 0.5, 0.5))
ren.add_actor(a)

# Get a nice view.
cam = ren.active_camera
cam.azimuth(-60)
cam.roll(90)

# Create a RenderWindow, add the renderer and set its size.
rw = tvtk.RenderWindow(size=(600, 600))
rw.add_renderer(ren)

# Create the RenderWindowInteractor
rwi = tvtk.RenderWindowInteractor(render_window=rw)

rwi.initialize()
ren.reset_camera()
rwi.render()

# The following is a crude approach but illustrates the point.
scale = old_scale = 1.0
pi = numpy.pi
for i in numpy.arange(pi*0.5, 2.5*pi, 0.2):
    if abs(i) < 1.0e-10:
        continue
    scale = numpy.sin(i)
    # We change 'z' in-place
    z *= scale/old_scale
    # Reset the scalar range.
    m.scalar_range = min(z), max(z)
    # Now explicitly notify `sp` that its data has changed.  If this
    # is not done, VTK has no way of knowing the data changed in order
    # to flush the pipeline.
    sp.modified()
    # Re-render the scene to actually flush the VTK pipeline.
    rwi.render()
    old_scale = scale
    time.sleep(0.1) # Just in case your hardware is really fast.

# Start the VTK event loop.
rwi.start()

########NEW FILE########
__FILENAME__ = dscene
#------------------------------------------------------------------------------
# Copyright (c) 2005, Enthought, Inc.
# All rights reserved.
#
# This software is provided without warranty under the terms of the BSD
# license included in enthought/LICENSE.txt and may be redistributed only
# under the conditions described in the aforementioned license.  The license
# is also available online at http://www.enthought.com/licenses/BSD.txt
# Thanks for using Enthought open source!
#
# Author: Enthought, Inc.
# Description: <Enthought pyface package component>
#------------------------------------------------------------------------------
""" An example of using a TVTK scene. """


# Standard library imports.
import random

# Enthought library imports.
from pyface.api import FileDialog
from pyface.api import GUI
from pyface.api import OK
from pyface.api import PythonShell
from pyface.api import SplitApplicationWindow
from tvtk.pyface.api import DecoratedScene
from tvtk.pyface.actors import sphere_actor, cylinder_actor, \
                                         arrow_actor, axes_actor, cone_actor, \
                                         cube_actor, earth_actor
from pyface.action.api import Action, Group, MenuBarManager, \
                                        MenuManager, Separator

from traits.api import Float, Str, Instance


class ExitAction(Action):
    """ Exits the application. """
    def __init__(self, window):
        """ Creates a new action. """
        self._window = window
        self.name = "E&xit"

    def perform(self):
        """ Performs the action. """
        self._window.close()


class SaveImageAction(Action):
    """Saves the rendered scene to an image."""
    def __init__(self, window):
        self._window = window
        self.name = "S&ave Scene"

    def perform(self):
        """Pops up a dialog used to save the scene to an image."""
        extns = ['*.png', '*.jpg', '*.jpeg', '*.tiff', '*.bmp', '*.ps',
                 '*.eps', '*.tex', '*.rib', '*.wrl', '*.oogl', '*.pdf',
                 '*.vrml', '*.obj', '*.iv']
        dlg = FileDialog(parent=self._window.control, action='save as',
                wildcard='|'.join(extns), title="Save scene to image")
        if dlg.open() == OK:
            self._window.scene.save(dlg.path)


class SaveToClipboardAction(Action):
    """ Saves rendered scene to the Clipboard. """
    def __init__(self, window):
        """ Creates a new action. """
        self._window = window
        self.name = "&Copy"

    def perform(self):
        """ Performs the action. """
        self._window.scene.save_to_clipboard()


class SpecialViewAction(Action):
    """Sets the scene to a particular view."""
    def __init__(self, window, name, view):
        """ Creates a new action. """
        self._window = window
        self.name = name
        self.view = view

    def perform(self):
        """ Performs the action. """
        # Hack!  Works tho.
        try:
            meth = getattr(self._window.scene, self.view)
            meth()
        except AttributeError:
            pass


class ExampleWindow(SplitApplicationWindow):
    """ An example application window. """

    # The actors we can create.
    ACTORS = [
        arrow_actor, axes_actor, cone_actor, cube_actor, cylinder_actor,
        earth_actor, sphere_actor
    ]

    # The ratio of the size of the left/top pane to the right/bottom pane.
    ratio = Float(0.75)

    # The direction in which the panel is split.
    direction = Str('horizontal')

    # The `Scene` instance into which VTK renders.
    scene = Instance(DecoratedScene)

    # The `PythonShell` instance.
    python_shell = Instance(PythonShell)

    ###########################################################################
    # 'object' interface.
    ###########################################################################
    def __init__(self, **traits):
        """ Creates a new window. """

        # Base class constructor.
        super(ExampleWindow, self).__init__(**traits)

        # Create the window's menu bar.
        self._create_my_menu_bar()


    ###########################################################################
    # Protected 'SplitApplicationWindow' interface.
    ###########################################################################

    def _create_lhs(self, parent):
        """ Creates the left hand side or top depending on the style. """

        self.scene = DecoratedScene(parent)
        self.scene.renderer.background = 0.1, 0.2, 0.4

        # Add some actors.
        for i in range(10):
            func = random.choice(ExampleWindow.ACTORS)
            actor = func()

            # Place the actor randomly.
            x = random.uniform(-3, 3)
            y = random.uniform(-3, 3)
            z = random.uniform(-3, 3)

            actor.position = x, y, z

            # Add the actor to the scene.
            self.scene.add_actors(actor)

        # Render it all!
        self.scene.render()

        # Reset the zoom nicely.
        self.scene.reset_zoom()

        return self.scene.control

    def _create_rhs(self, parent):
        """ Creates the right hand side or bottom depending on the style. """

        self.python_shell = PythonShell(parent)
        self.python_shell.bind('scene', self.scene)
        self.python_shell.bind('s', self.scene)

        return self.python_shell.control


    ###########################################################################
    # Private interface.
    ###########################################################################

    def _create_my_menu_bar(self):
        """ Creates the window's menu bar. """

        self.menu_bar_manager = MenuBarManager(
            MenuManager(
                SaveImageAction(self),
                Separator(),
                ExitAction(self),
                name = '&File',
            ),
            MenuManager(
                SaveToClipboardAction(self),
                name = '&Edit',
            ),
            MenuManager(
                SpecialViewAction(self, "&Reset Zoom", 'reset_zoom'),
                Separator(),
                SpecialViewAction(self, "&Isometric", 'isometric_view'),
                SpecialViewAction(self, "&X positive", 'x_plus_view'),
                SpecialViewAction(self, "X negative", 'x_minus_view'),
                SpecialViewAction(self, "&Y positive", 'y_plus_view'),
                SpecialViewAction(self, "Y negative", 'y_minus_view'),
                SpecialViewAction(self, "&Z positive", 'z_plus_view'),
                SpecialViewAction(self, "Z negative", 'z_minus_view'),
                name = '&View',
            )
        )



# Application entry point.
if __name__ == '__main__':
    # Create the GUI.
    gui = GUI()

    # Create and open an application window.
    window = ExampleWindow(size=(600,600))
    window.open()

    # Start the GUI event loop!
    gui.start_event_loop()

##### EOF #####################################################################

########NEW FILE########
__FILENAME__ = ivtk_example
#!/usr/bin/env python

"""A simple demonstration of how one can use the ivtk module with
PyFace to create a standalone VTK window with an embedded TVTK
pipeline browser and a Python shell!

"""
# Author: Prabhu Ramachandran <prabhu_r@users.sf.net>
# Copyright (c) 2005-2006, Enthought, Inc.
# License: BSD Style.

# We use this just for the demo.
import random

# The GUI class lets us start a PyFace GUI.
from pyface.api import GUI
from traits.api import HasTraits, Tuple

# The IVTK module.
from tvtk.tools import ivtk

# The actors module has a few helper functions that allow one to
# create simple shapes easily.  These functions return TVTK Actor
# instances.  We use it here for convenience.
from tvtk.pyface import actors

# Create a GUI instance.
gui = GUI()

# Create and open an IVTK application window that has an embedded TVTK
# pipeline browser and an interactive Python interpreter shell via
# PyCrust.  If you don't want all these you can choose between the
# following classes in ivtk -- IVTK, IVTKWithCrust, IVTKWithBrowser
# and IVTKWithCrustAndBrowser.
window = ivtk.IVTKWithCrustAndBrowser(size=(800,600))  # Size is optional.

# Open the window.
window.open()

class EarthActor(HasTraits):
    position = Tuple
    def __init__(self):
        earth = actors.earth_actor()
        earth.property.color = actors.colors.green
        sphere = actors.sphere_actor(color=actors.colors.blue, opacity=0.65)
        self.earth, self.sphere = earth, sphere

    def _position_changed(self, val):
        for actor in (self.earth, self.sphere):
            actor.position = val


# Now create your TVTK actors.  Here we simply use the actors module
# and generate actors randomly.

# Get all the functions in the actors module that end with '_actors'.
ACTORS = [getattr(actors, x) for x in dir(actors)
        if x.endswith('_actor') and not x.startswith('earth')]
ACTORS.append(EarthActor)

# Now create the actors with these functions.
for i in range(len(ACTORS)):
    # Create the actor.
    func = random.choice(ACTORS)
    actor = func()

    # Set its position randomly.
    x = random.uniform(-3, 3)
    y = random.uniform(-3, 3)
    z = random.uniform(-3, 3)
    actor.position = x, y, z

    # Add the actor to the scene.
    if isinstance(actor, EarthActor):
        window.scene.add_actors((actor.earth, actor.sphere))
    else:
        window.scene.add_actor(actor)

# Now reset the view so all the actors.
window.scene.reset_zoom()

# Start the GUI event loop!
gui.start_event_loop()

########NEW FILE########
__FILENAME__ = off_screen
#!/usr/bin/env python
""" A simple example demonstrating TVTK for rendering to an off screen
    buffer.  This is useful when you are rendering images to files
    and do not wish to display a graphics window at all.

    Note: Tested to work on win32, Mac OS X and Linux.  Mac OS X and
    Linux require a VTK version released after Oct. 2005 (and ideally
    after March 2006).
"""
# Author: Eric Jones, Prabhu Ramachandran
# Copyright (c) 2004-2006, Enthought, Inc.
# License: BSD Style.

from tvtk.api import tvtk
from tvtk.common import configure_input_data

# Create a cone source and configure it.
cs = tvtk.ConeSource(height=3.0, radius=1.0, resolution=36)

# Print the traits of the cone.
#cs.print_traits()

# Setup the rest of the pipeline.
m = tvtk.PolyDataMapper()

# Note that VTK's GetOutput method is special because it has two call
# signatures: GetOutput() and GetOutput(int N) (which gets the N'th
# output).  In tvtk it is represented as both a property and as a
# method.  Using the output property will work fine if all you want is
# the default output.  OTOH if you want the N'th output use
# get_output(N).
# m.input = cs.output # or m.input = cs.get_output()
configure_input_data(m, cs.output)

# Create the actor and set its mapper.
a = tvtk.Actor(mapper=m)
cs.update()

# Create a Renderer, add the actor and set its background color.
ren = tvtk.Renderer(background=(0.1, 0.2, 0.4))
ren.add_actor(a)
ren.reset_camera()

# Create a RenderWindow, add the renderer and set its size.
rw = tvtk.RenderWindow(size=(300,300))
rw.off_screen_rendering=1
rw.add_renderer(ren)

w2if = tvtk.WindowToImageFilter()
w2if.magnification = 2
w2if.input = rw
ex = tvtk.PNGWriter()
ex.file_name = "example.png"
configure_input_data(ex, w2if.output)
w2if.update()
ex.write()

########NEW FILE########
__FILENAME__ = test
#!/usr/bin/env python

""" This is a simple test envisage3 application to demonstrate how one
can use TVTK's scene and browser plugins to create a simple application.
"""

# Author: Prabhu Ramachandran <prabhu_r@users.sf.net>
# Copyright (c) 2008, Enthought, Inc.
# License: BSD Style.

# Standard library imports.
import os.path
import logging

# Enthought library imports.
from apptools.logger.api import LogFileHandler, FORMATTER
from traits.etsconfig.api import ETSConfig
from traits.api import List
from envisage.api import Plugin
from envisage.ui.workbench.api import WorkbenchApplication
from envisage.core_plugin import CorePlugin
from envisage.ui.workbench.workbench_plugin import WorkbenchPlugin
from envisage.plugins.python_shell.python_shell_plugin import PythonShellPlugin
from tvtk.plugins.scene.scene_plugin import ScenePlugin
from tvtk.plugins.scene.ui.scene_ui_plugin import SceneUIPlugin
from tvtk.plugins.browser.browser_plugin import BrowserPlugin
from pyface.workbench.api import Perspective, PerspectiveItem


logger = logging.getLogger()

###############################################################################
# `TestPerspective` class.
###############################################################################
class TestPerspective(Perspective):
    """ An default perspective for the app. """

    # The perspective's name.
    name = 'Test'

    # Should this perspective be enabled or not?
    enabled = True

    # Should the editor area be shown in this perspective?
    show_editor_area = True

    # View IDs.
    BROWSER_VIEW = 'tvtk.plugins.browser.browser_view.BrowserView'
    SHELL_VIEW = 'envisage.plugins.python_shell.view.python_shell_view.PythonShellView'

    # The contents of the perspective.
    contents = [
        PerspectiveItem(id=BROWSER_VIEW, position='left'),
        PerspectiveItem(id=SHELL_VIEW, position='bottom')
    ]

###############################################################################
# `MyPlugin` class.
###############################################################################
class MyPlugin(Plugin):

    # Extension points we contribute to.
    PERSPECTIVES = 'envisage.ui.workbench.perspectives'

    # The plugin's unique identifier.
    id = 'tvtk_example_plugin'

    # The plugin's name (suitable for displaying to the user).
    name = 'TVTK example plugin'

    # Perspectives.
    perspectives = List(contributes_to=PERSPECTIVES)

    def _perspectives_default(self):
        """ Trait initializer. """
        return [TestPerspective]


###############################################################################
# Useful functions.
###############################################################################
def setup_logger(logger, fname, stream=True, mode=logging.ERROR):
    """Setup a log file and the logger in `ETSConfig.application_home`.

    Parameters:
    -----------

    fname -- file name the logger should use.

    stream -- Add a stream handler.

    mode -- the logging mode.

    """
    path = os.path.join(ETSConfig.application_home, fname)
    handler = LogFileHandler(path)
    logger.addHandler(handler)
    if stream:
        s = logging.StreamHandler()
        s.setFormatter(FORMATTER)
        s.setLevel(mode)
        logger.addHandler(s)
    logger.info("*"*80)
    logger.info("logfile is: '%s'", os.path.abspath(path))
    logger.info("*"*80)


def bind_object(value, app):
    """Binds the scene manager service to the Python shell."""
    if not value:
        # value is False when the GUI is stopped.
        return
    id = 'envisage.plugins.python_shell.view.python_shell_view.PythonShellView'
    py = app.workbench.active_window.get_view_by_id(id)

    id = 'tvtk.plugins.scene.i_scene_manager.ISceneManager'
    sm = app.workbench.active_window.get_service(id)
    if py is not None:
        py.bind('scene_manager', sm)


def main():
    """The main application is created and launched here."""
    # Setup the logger.

    plugins = [CorePlugin(),
               WorkbenchPlugin(),
               MyPlugin(),
               ScenePlugin(),
               SceneUIPlugin(),
               BrowserPlugin(),
               PythonShellPlugin(),
               ]
    # Create an Envisage application.
    id = 'tvtk.examples.plugins.test'
    application = WorkbenchApplication(id=id,
                                       plugins = plugins
                                       )
    # This needs to be done here since the ETSConfig.application_home is
    # not set correctly up to this point.
    setup_logger(logger, 'test.log', mode=logging.DEBUG)

    application.gui.on_trait_change(lambda value: bind_object(value, application),
                                    'started')
    # Start the application.
    application.run()


if __name__ == '__main__':
    main()


########NEW FILE########
__FILENAME__ = scene
#------------------------------------------------------------------------------
# Copyright (c) 2005, Enthought, Inc.
# All rights reserved.
#
# This software is provided without warranty under the terms of the BSD
# license included in enthought/LICENSE.txt and may be redistributed only
# under the conditions described in the aforementioned license.  The license
# is also available online at http://www.enthought.com/licenses/BSD.txt
# Thanks for using Enthought open source!
#
# Author: Enthought, Inc.
# Description: <Enthought pyface package component>
#------------------------------------------------------------------------------
""" An example of using a TVTK scene. """


# Standard library imports.
import random

# Enthought library imports.
from pyface.api import FileDialog
from pyface.api import GUI
from pyface.api import OK
from pyface.api import PythonShell
from pyface.api import SplitApplicationWindow
from tvtk.pyface.api import Scene
from tvtk.pyface.actors import arrow_actor, axes_actor, cone_actor, \
                                         cube_actor, cylinder_actor, \
                                         earth_actor, sphere_actor
from pyface.action.api import Action, Group, MenuBarManager, \
                                        MenuManager, Separator

from traits.api import Float, Str, Instance


class ExitAction(Action):
    """ Exits the application. """
    def __init__(self, window):
        """ Creates a new action. """
        self._window = window
        self.name = "E&xit"

    def perform(self):
        """ Performs the action. """
        self._window.close()


class SaveImageAction(Action):
    """Saves the rendered scene to an image."""
    def __init__(self, window):
        self._window = window
        self.name = "S&ave Scene"

    def perform(self):
        """Pops up a dialog used to save the scene to an image."""
        extns = ['*.png', '*.jpg', '*.jpeg', '*.tiff', '*.bmp', '*.ps',
                 '*.eps', '*.tex', '*.rib', '*.wrl', '*.oogl', '*.pdf',
                 '*.vrml', '*.obj', '*.iv']
        dlg = FileDialog(parent=self._window.control, action='save as',
                wildcard='|'.join(extns), title="Save scene to image")
        if dlg.open() == OK:
            self._window.scene.save(dlg.path)


class SaveToClipboardAction(Action):
    """ Saves rendered scene to the Clipboard. """
    def __init__(self, window):
        """ Creates a new action. """
        self._window = window
        self.name = "&Copy"

    def perform(self):
        """ Performs the action. """
        self._window.scene.save_to_clipboard()


class SpecialViewAction(Action):
    """Sets the scene to a particular view."""
    def __init__(self, window, name, view):
        """ Creates a new action. """
        self._window = window
        self.name = name
        self.view = view

    def perform(self):
        """ Performs the action. """
        # Hack!  Works tho.
        try:
            meth = getattr(self._window.scene, self.view)
            meth()
        except AttributeError:
            pass


class ExampleWindow(SplitApplicationWindow):
    """ An example application window. """

    # The actors we can create.
    ACTORS = [
        arrow_actor, axes_actor, cone_actor, cube_actor, cylinder_actor,
        earth_actor, sphere_actor
    ]

    # The ratio of the size of the left/top pane to the right/bottom pane.
    ratio = Float(0.75)

    # The direction in which the panel is split.
    direction = Str('horizontal')

    # The `Scene` instance into which VTK renders.
    scene = Instance(Scene)

    # The `PythonShell` instance.
    python_shell = Instance(PythonShell)

    ###########################################################################
    # 'object' interface.
    ###########################################################################
    def __init__(self, **traits):
        """ Creates a new window. """

        # Base class constructor.
        super(ExampleWindow, self).__init__(**traits)

        # Create the window's menu bar.
        self._create_my_menu_bar()


    ###########################################################################
    # Protected 'SplitApplicationWindow' interface.
    ###########################################################################

    def _create_lhs(self, parent):
        """ Creates the left hand side or top depending on the style. """

        self.scene = Scene(parent)
        self.scene.renderer.background = 0.1, 0.2, 0.4

        # Add some actors.
        for i in range(10):
            func = random.choice(ExampleWindow.ACTORS)
            actor = func()

            # Place the actor randomly.
            x = random.uniform(-3, 3)
            y = random.uniform(-3, 3)
            z = random.uniform(-3, 3)

            actor.position = x, y, z

            # Add the actor to the scene.
            self.scene.add_actors(actor)

        # Render it all!
        self.scene.render()

        # Reset the zoom nicely.
        self.scene.reset_zoom()

        return self.scene.control

    def _create_rhs(self, parent):
        """ Creates the right hand side or bottom depending on the style. """

        self.python_shell = PythonShell(parent)
        self.python_shell.bind('scene', self.scene)
        self.python_shell.bind('s', self.scene)

        return self.python_shell.control


    ###########################################################################
    # Private interface.
    ###########################################################################

    def _create_my_menu_bar(self):
        """ Creates the window's menu bar. """

        self.menu_bar_manager = MenuBarManager(
            MenuManager(
                SaveImageAction(self),
                Separator(),
                ExitAction(self),
                name = '&File',
            ),
            MenuManager(
                SaveToClipboardAction(self),
                name = '&Edit',
            ),
            MenuManager(
                SpecialViewAction(self, "&Reset Zoom", 'reset_zoom'),
                Separator(),
                SpecialViewAction(self, "&Isometric", 'isometric_view'),
                SpecialViewAction(self, "&X positive", 'x_plus_view'),
                SpecialViewAction(self, "X negative", 'x_minus_view'),
                SpecialViewAction(self, "&Y positive", 'y_plus_view'),
                SpecialViewAction(self, "Y negative", 'y_minus_view'),
                SpecialViewAction(self, "&Z positive", 'z_plus_view'),
                SpecialViewAction(self, "Z negative", 'z_minus_view'),
                name = '&View',
            )
        )



# Application entry point.
if __name__ == '__main__':
    # Create the GUI.
    gui = GUI()

    # Create and open an application window.
    window = ExampleWindow(size=(600,600))
    window.open()

    # Start the GUI event loop!
    gui.start_event_loop()

##### EOF #####################################################################

########NEW FILE########
__FILENAME__ = scene_editor
"""A very silly example of using a scene editor.  More complex examples are
available in mayavi.  """

# Author: Prabhu Ramachandran <prabhu [at] aero.iitb.ac.in>
# Copyright (c) 2007, Enthought, Inc.
# License: BSD Style.

from traits.api import HasTraits, Enum, Instance, Any
from traitsui.api import View, Item
from tvtk.pyface.scene_model import SceneModel
from tvtk.pyface.scene_editor import SceneEditor
from tvtk.pyface import actors
from tvtk.api import tvtk


######################################################################
class ActorViewer(HasTraits):

    # A simple trait to change the actors/widgets.
    actor_type = Enum('cone', 'sphere', 'plane_widget', 'box_widget')

    # The scene model.
    scene = Instance(SceneModel, ())

    _current_actor = Any

    ######################
    view = View(Item(name='actor_type'),
                Item(name='scene',
                     editor=SceneEditor(),
                     show_label=False,
                     resizable=True,
                     height=500,
                     width=500)
                )

    def __init__(self, **traits):
        super(ActorViewer, self).__init__(**traits)
        self._actor_type_changed(self.actor_type)

    ####################################
    # Private traits.
    def _actor_type_changed(self, value):
        scene = self.scene
        if self._current_actor is not None:
            scene.remove_actors(self._current_actor)
        if value == 'cone':
            a = actors.cone_actor()
            scene.add_actors(a)
        elif value == 'sphere':
            a = actors.sphere_actor()
            scene.add_actors(a)
        elif value == 'plane_widget':
            a = tvtk.PlaneWidget()
            scene.add_actors(a)
        elif value == 'box_widget':
            a = tvtk.BoxWidget()
            scene.add_actors(a)
        self._current_actor = a


if __name__ == '__main__':
    a = ActorViewer()
    a.configure_traits()

########NEW FILE########
__FILENAME__ = simple
#!/usr/bin/env python
"""A simple example demonstrating TVTK.  This example is basically a
translation of the VTK tutorial demo available in
VTK/Examples/Tutorial/Step6/Python/Cone6.py.

"""
# Author: Prabhu Ramachandran <prabhu_r@users.sf.net>
# Copyright (c) 2004-2006, Enthought, Inc.
# License: BSD Style.

from tvtk.api import tvtk
from tvtk.common import configure_input_data

# Create a cone source and configure it.
cs = tvtk.ConeSource(height=3.0, radius=1.0, resolution=36)

# Print the traits of the cone.
#cs.print_traits()

# Setup the rest of the pipeline.
m = tvtk.PolyDataMapper()

# Note that VTK's GetOutput method is special because it has two call
# signatures: GetOutput() and GetOutput(int N) (which gets the N'th
# output).  In tvtk it is represented as both a property and as a
# method.  Using the output property will work fine if all you want is
# the default output.  OTOH if you want the N'th output use
# get_output(N).
# m.input = cs.output # or m.input = cs.get_output()
configure_input_data(m, cs.output)
cs.update()

# Create the actor and set its mapper.
a = tvtk.Actor(mapper=m)

# Create a Renderer, add the actor and set its background color.
ren = tvtk.Renderer(background=(0.1, 0.2, 0.4))
ren.add_actor(a)

# Create a RenderWindow, add the renderer and set its size.
rw = tvtk.RenderWindow(size=(300,300))
rw.add_renderer(ren)

# Create the RenderWindowInteractor
rwi = tvtk.RenderWindowInteractor(render_window=rw)

# Setup a box widget.
bw = tvtk.BoxWidget(interactor=rwi, place_factor=1.25,
                    prop3d=a)
bw.place_widget()

def callback(widget, event):
    """This callback sets the transformation of the cone using that
    setup by the the box."""
    t = tvtk.Transform()
    bw.get_transform(t)
    bw.prop3d.user_transform = t

# Add an observer
bw.add_observer("InteractionEvent", callback)

# Turn on the box interaction.  The default is off and can be toggled
# by pressing 'i' on the RenderWindowInteractor.
bw.on()

# Start the VTK event loop.
rwi.initialize()
rwi.start()

########NEW FILE########
__FILENAME__ = texture_glyph
#!/usr/bin/env python

""" Illustrates the Glyph3D class and some basic texturing of the
glyph.  Notice how easy it is to create a simple PolyData object as
the input of the Glyph using Python lists.

"""
# Author: Prabhu Ramachandran <prabhu_r@users.sf.net>
# Copyright (c) 2004-2006, Enthought, Inc.
# License: BSD Style.

from tvtk.api import tvtk
from tvtk.common import is_old_pipeline, configure_input_data, configure_source_data

# Source for glyph.  Note that you need to pick a source that has
# texture co-ords already set.  If not you'll have to generate them.
# This is easily done -- its just a 2d array of (u,v) coords each
# between [0, 1] that you can set via something like
# point_data.t_coords = <array>.
#
# In this case CubeSource already defines texture coords for us (as of
# VTK-4.4).
cs = tvtk.CubeSource(x_length=2, y_length=1.0, z_length=0.5)

# Create input for the glyph -- the sources are placed at these input
# points.
pts = [[1,1,1],[0,0,0], [-1,-1,-1]]
pd = tvtk.PolyData(points=pts, polys=[[0],[1],[2]])
# Orientation/scaling is as per the vector attribute.
vecs = [[1,0,0], [0,1,0], [0,0,1]]
pd.point_data.vectors = vecs

# Create the glyph3d and set up the pipeline.
g = tvtk.Glyph3D(scale_mode='data_scaling_off', vector_mode = 'use_vector')
configure_input_data(g, pd)

# Note that VTK's vtkGlyph.SetSource is special because it has two
# call signatures: SetSource(src) and SetSource(int N, src) (which
# sets the N'th source).  In tvtk it is represented as both a property
# and as a method.  Using the `source` property will work fine if all
# you want is the first `source`.  OTOH if you want the N'th `source`
# use get_source(N).
# g.source = cs.output
configure_source_data(g, cs.output)
cs.update()
g.update()

m = tvtk.PolyDataMapper()
configure_input_data(m, g.output)
a = tvtk.Actor(mapper=m)

# Read the texture from image and set the texture on the actor.  If
# you don't like this image, replace with your favorite -- any image
# will do (you must use a suitable reader though).
img = tvtk.JPEGReader(file_name='images/masonry.jpg')
t = tvtk.Texture(interpolate = 1)
if is_old_pipeline():
    t.input = img.output
else:
    t.input_connection = img.output_port
a.texture = t

# Renderwindow stuff and add actor.
rw = tvtk.RenderWindow(size=(600, 600))
ren = tvtk.Renderer(background=(0.5, 0.5, 0.5))
rw.add_renderer(ren)
rwi = tvtk.RenderWindowInteractor(render_window=rw)
ren.add_actor(a)
rwi.initialize()
rwi.start()

########NEW FILE########
__FILENAME__ = tiny_mesh
#!/usr/bin/env python

"""A simple example demonstrating how one can use numpy arrays
transparently with TVTK.

"""

# Author: Prabhu Ramachandran and Eric Jones
# Copyright (c) 2004-2007, Enthought, Inc.
# License: BSD Style.

from tvtk.api import tvtk
from tvtk.common import configure_input_data
from numpy import array

### DATA
data = array([[0,0,0,10],
              [1,0,0,20],
              [0,1,0,20],
              [0,0,1,30]], 'f')

triangles = array([[0,1,3],
                   [0,3,2],
                   [1,2,3],
                   [0,2,1]])

points = data[:,:3]
temperature = data[:,-1]

### TVTK PIPELINE
# create a renderer
renderer = tvtk.Renderer()

# create a render window and hand it the renderer
render_window = tvtk.RenderWindow(size=(400,400))
render_window.add_renderer(renderer)

# create interactor and hand it the render window
# This handles mouse interaction with window.
interactor = tvtk.RenderWindowInteractor(render_window=render_window)

# Create a mesh from the data created above.
mesh = tvtk.PolyData(points=points, polys=triangles)
mesh.point_data.scalars = temperature

# Set the mapper to scale temperature range
# across the entire range of colors
mapper = tvtk.PolyDataMapper()
configure_input_data(mapper, mesh)
mapper.scalar_range = min(temperature), max(temperature)

# Create mesh actor for display
actor = tvtk.Actor(mapper=mapper)

# Create a scalar bar
scalar_bar = tvtk.ScalarBarActor(title="Temperature",
                                 orientation='horizontal',
                                 width=0.8, height=0.17,
                                 lookup_table = mapper.lookup_table)
scalar_bar.position_coordinate.coordinate_system = 'normalized_viewport'
scalar_bar.position_coordinate.value = 0.1, 0.01, 0.0

# Use the ScalarBarWidget so we can drag the scalar bar around.
sc_bar_widget = tvtk.ScalarBarWidget(interactor=interactor,
                                     scalar_bar_actor=scalar_bar)

# Now add the actors to the renderer and start the interaction.
renderer.add_actor(actor)
interactor.initialize()
# Enable the widget so the scalar bar can be seen.  Press 'i' to
# disable the widget.
sc_bar_widget.enabled = True
interactor.start()

########NEW FILE########
__FILENAME__ = bounce
#!/usr/bin/env python
"""A simple example demonstrating the creation of actors and animating
the in a scene using visual modeule."""
# Author: Raashid Baig <raashid@aero.iitb.ac.in>
# License: BSD Style.

from tvtk.tools.visual import box, sphere, vector, iterate, show

def main():
    # Creating parameters for box size
    side = 4.0
    thk = 0.3
    s2 = 2*side - thk
    s3 = 2*side + thk
    # Creating the 6 walls
    wallR = box( pos = (side, 0, 0), size = (thk, s3, s2), color = (1, 0, 0))
    wallL = box( pos = (-side, 0, 0), size = (thk, s3, s2), color = (1, 0, 0))
    wallB = box( pos = (0, -side, 0), size = (s3, thk, s3), color = (0, 0, 1))
    wallT = box( pos = (0, side, 0), size = (s3, thk, s3), color = (0, 0, 1))
    wallBK = box( pos = (0, 0, -side), size = (s2, s2, thk), color = (0.7,0.7,0.7))
    # Creating the ball
    ball = sphere(radius = 0.4, color = (0, 1, 0))
    ball.vector = vector(-0.15, -0.23, 0.27)

    side = side -thk*0.5 - ball.radius

    ball.t = 0.0
    ball.dt = 0.5

    def anim():
        #Creating the animation function which will be called at
        #uniform timeperiod through the iterate function
        ball.t = ball.t + ball.dt
        ball.pos = ball.pos + ball.vector*ball.dt
        if not (side > ball.x > -side):
            ball.vector.x = -ball.vector.x
        if not (side > ball.y > -side):
            ball.vector.y = -ball.vector.y
        if not (side > ball.z > -side):
            ball.vector.z =  -ball.vector.z

    a = iterate(20, anim)
    show()
    return a

if __name__ == '__main__':
    main()

########NEW FILE########
__FILENAME__ = doublependulum
#!/usr/bin/env python

"""A simple example demonstrating the creation of actors and animating
the in a scene using visual modeule."""

# Author: Raashid Baig <raashid@aero.iitb.ac.in>
# License: BSD Style.

# Double pendulum

#The analysis is in terms of Lagrangian mechanics. The Lagrangian
#variables are angle of upper bar, angle of lower bar,measured from
#the vertical.

from tvtk.tools.visual import box, vector, frame, iterate, show
from math import pi, sin

g = 9.8
M1 = 2.0
M2 = 1.0
d = 0.05 # thickness of each bar
gap = 2.*d # distance between two parts of upper, U-shaped assembly
L1 = 0.5 # physical length of upper assembly; distance between axles
L1display = L1+d # show upper assembly a bit longer than physical, to overlap axle
L2 = 1.0 # physical length of lower bar
L2display = L2+d/2. # show lower bar a bit longer than physical, to overlap axle
# Coefficients used in Lagrangian calculation
A = (1./4.)*M1*L1**2+(1./12.)*M1*L1**2+M2*L1**2
B = (1./2.)*M2*L1*L2
C = g*L1*(M1/2.+M2)
D = M2*L1*L2/2.
E = (1./12.)*M2*L2**2+(1./4.)*M2*L2**2
F = g*L2*M2/2.

hpedestal = 1.3*(L1+L2) # height of pedestal
wpedestal = 0.1 # width of pedestal
tbase = 0.05 # thickness of base
wbase = 8.*gap # width of base
offset = 2.*gap # from center of pedestal to center of U-shaped upper assembly
top = vector(0,0,0) # top of inner bar of U-shaped upper assembly

theta1 = 1.3*pi/2. # initial upper angle (from vertical)
theta1dot = 0 # initial rate of change of theta1
theta2 = 0 # initial lower angle (from vertical)
theta2dot = 0 # initial rate of change of theta2

pedestal = box(pos = (top - vector(0, hpedestal/2.0, offset)),size = (wpedestal, 1.1*hpedestal, wpedestal), color = (0.4,0.4,0.5))

base = box(pos = (top - vector(0,hpedestal + tbase/2.0, offset)),size=(wbase, tbase, wbase),color = (0.4,0.4,0.5))

bar1 = box(pos=(L1display/2.0 - d/2.0, 0, -(gap+d)/2.0), size=(L1display, d, d), color=(1,0,0))
bar1b = box(pos=(L1display/2.0 - d/2.0, 0, (gap+d)/2.0), size=(L1display, d, d), color=(1,0,0))

frame1 = frame(bar1, bar1b)
frame1.pos = (0.0, 0.0, 0.0)
frame1.axis = (0.0, -1.0, 0.0)
frame1.rotate(axis=(0,0,1), angle = 180.0*theta1/pi)

bar2 = box(pos = (L2display/2.0 - d/2.0, 0, 0), size = (L2display, d, d), color = (0,1,0))

frame2 = frame(bar2)
frame2.pos = (0.0, -1.0*L1, 0.0)
frame2.axis = (0.0, -1.0, 0.0)
frame2.rotate(axis = (0,0,1), angle = 180.0*theta2/pi)

dt = 0.001

def anim():
    global theta1, theta2, theta1dot, theta2dot
    atheta1 = ((E*C/B)*sin(theta1)-F*sin(theta2))/(D-E*A/B)
    atheta2 = -(A*atheta1+C*sin(theta1))/B

    theta1dot = theta1dot + atheta1*dt
    theta2dot = theta2dot + atheta2*dt

    dtheta1 = theta1dot*dt
    dtheta2 = theta2dot*dt
    theta1 = theta1 + dtheta1
    theta2 = theta2 + dtheta2

    frame1.rotate(axis = (0,0,1), angle = 180.0*dtheta1/pi)

    frame2.pos = top + frame1.axis*L1
    frame2.rotate(axis = (0,0,1), angle = 180*dtheta2/pi)

a = iterate(20, anim)
a.edit_traits()
show()

########NEW FILE########
__FILENAME__ = gyro
#!/usr/bin/env python

# Author: Raashid Baig <raashid@aero.iitb.ac.in>
# License: BSD Style.

# Gyroscope hanging from a spring
from math import atan, cos, sin, pi

from tvtk.tools.visual import vector, MVector, Box, Helix, Frame, \
    Cylinder, curve, color, iterate, show


top = vector(0,1.,0) # where top of spring is held
ks = 100. # spring stiffness
Lspring = 1. # unstretched length of spring
Rspring = 0.03 # radius of spring
Dspring = 0.03 # thickness of spring wire
Lshaft = 1. # length of gyroscope shaft
Rshaft = 0.03 # radius of gyroscope shaft
M = 1. # mass of gyroscope (massless shaft)
Rrotor = 0.4 # radius of gyroscope rotor
Drotor = 0.1 # thickness of gyroscope rotor
Dsquare = 1.4*Drotor # thickness of square that turns with rotor
I = 0.5*M*Rrotor**2. # moment of inertia of gyroscope
omega = 40.0 # angular velocity of rotor along axis
g = 9.8
Fgrav = MVector(0,-M*g,0)
precession = M*g*(Lshaft/2.)/(I*abs(omega)) # exact precession angular velocity
phi = atan(precession**2*(Lshaft/2.)/g) # approximate angle of spring to vertical
s = M*g/(ks*cos(phi)) # approximate stretch of spring
# Refine estimate of angle of spring to vertical:
phi = 1./(((I*abs(omega))/(M*Lshaft/2.))**2/(g*Lshaft/2.)-(Lspring+s)/(Lshaft/2.))
# Refine again:
s = M*g/(ks*cos(phi))
phi = 1./( ((I*abs(omega))/(M*Lshaft/2.))**2/(g*Lshaft/2.)-(Lspring+s)/(Lshaft/2.) )
# Momentum required for completely smooth precession:
pprecess = vector(0,0,M*precession*(Lshaft/2.+(Lspring+s)*sin(phi)))
if omega < 0:
    pprecess = -pprecess

support = Box(pos = top+MVector(0,0.01,0), size = (0.2,0.02,0.2), color = (0,1,0))
spring = Helix(pos = top, axis = vector(-0.161579, -0.98686, 0), radius = Rspring, color = (1,0.7,0.2))

gyro1 = Frame(pos = top+spring.axis) # gyro.pos at end of spring
gyro1.axis = MVector(1,0,0)

shaft = Cylinder(pos = gyro1.pos, axis = Lshaft*gyro1.axis, radius =
                 Rshaft, color = (0.85,0.85,0.85), length = 1.0)

rotor = Cylinder(pos = 0.5*gyro1.axis*(Lshaft-Drotor), axis =
                 gyro1.axis*Drotor, radius = Rrotor, color = (0.5,0.5,0.5), length = 0.1)

stripe1 = curve(color = color.green,
                points = [rotor.pos+1.03*rotor.axis+vector(0,Rrotor,0),
                rotor.pos+1.03*rotor.axis-vector(0,Rrotor,0)])
stripe2 = curve(color = color.green,
                points = [rotor.pos-0.03*rotor.axis+vector(0,Rrotor,0),
                rotor.pos-0.03*rotor.axis-vector(0,Rrotor,0)])

gyro = Frame(stripe1, stripe2) # gyro.pos at end of spring
gyro.pos = top+spring.axis # gyro.pos at end of spring
gyro.axis = vector(1,0,0)

gyro.rotate(axis=(0,1,0), angle = 180.0, origin = gyro.pos)

cm = gyro.pos+0.5*Lshaft*gyro.axis # center of mass of shaft
Lrot = I*omega*gyro.axis
p = pprecess
dt = 0.01
t = 0.

c = 0

def anim():
    global Lrot, p, cm, t
    Fspring = -ks*vector.norm(spring.axis)*(vector.mag(spring.axis)-Lspring)
    # Calculate torque about center of mass:
    torque = vector.cross(-0.5*Lshaft*gyro.axis,Fspring)
    Lrot = Lrot+torque*dt
    p = p+(Fgrav+Fspring)*dt
    cm = cm+(p/M)*dt

    # Update positions of shaft, rotor, spring, stripes
    if omega > 0:
        gyro.axis = vector.norm(Lrot)
    else:
        gyro.axis = -vector.norm(Lrot)

    gyro.pos = cm-0.5*Lshaft*gyro.axis # shaft rotated, adjust connection to spring
    spring.axis = gyro.pos - top
    spring.length = vector.mag(spring.axis)
    gyro.rotate(180*omega*dt/(4.0*pi), gyro.axis, gyro.pos) # spin easier to see if slower than actual omega
    shaft.pos = gyro.pos
    shaft.axis = Lshaft*gyro.axis
    rotor.pos = gyro.pos + 0.5*gyro.axis*(Lshaft-Drotor)
    rotor.axis = gyro.axis*Drotor

    t = t+dt

a = iterate(40, anim)
a.edit_traits()
show()

########NEW FILE########
__FILENAME__ = gyro2
#!/usr/bin/env python

"""A simple example demonstrating the creation of actors and animating
the in a scene using visual modeule."""

# Author: Raashid Baig <raashid@aero.iitb.ac.in>
# License: BSD Style.
from math import pi, cos, sin

from tvtk.tools.visual import vector, box, cylinder, frame, curve, \
    iterate, show

# Gyroscope sitting on a pedestal

# The analysis is in terms of Lagrangian mechanics.
# The Lagrangian variables are polar angle theta,
# azimuthal angle phi, and spin angle alpha.

Lshaft = 1. # length of gyroscope shaft
Rshaft = 0.03 # radius of gyroscope shaft
M = 1. # mass of gyroscope (massless shaft)
Rrotor = 0.4 # radius of gyroscope rotor
Drotor = 0.1 # thickness of gyroscope rotor
Dsquare = 1.4*Drotor # thickness of square that turns with rotor
I = 0.5*M*Rrotor**2. # moment of inertia of gyroscope
hpedestal = Lshaft # height of pedestal
wpedestal = 0.1 # width of pedestal
tbase = 0.05 # thickness of base
wbase = 3.*wpedestal # width of base
g = 9.8
Fgrav = vector(0,-M*g,0)
top = vector(0,0,0) # top of pedestal

theta = pi/3. # initial polar angle of shaft (from vertical)
thetadot = 0 # initial rate of change of polar angle
alpha = 0 # initial spin angle
alphadot = 15 # initial rate of change of spin angle (spin ang. velocity)
phi = -pi/2. # initial azimuthal angle
phidot = 0 # initial rate of change of azimuthal angle
# Comment in following line to get pure precession
##phidot = (-alphadot+sqrt(alphadot**2+2*M*g*r*cos(theta)/I))/cos(theta)

pedestal = box(pos=top-vector(0,hpedestal/2.,0),
                 height=hpedestal, length=wpedestal, width=wpedestal,
                 color=(0.4,0.4,0.5))
base = box(pos=top-vector(0,hpedestal+tbase/2.,0),
                 height=tbase, length=wbase, width=wbase,
                 color=pedestal.color)

shaft = cylinder(axis=(Lshaft,0,0), length = Lshaft,
                 radius=Rshaft, color=(0,1,0))
rotor = cylinder(pos=(Lshaft/2 - Drotor/2, 0, 0),
                 axis=(Drotor, 0, 0), length = Drotor,
                 radius=Rrotor, color=(1,0,0))

gyro = frame(shaft, rotor)
gyro.axis = (sin(theta)*sin(phi),cos(theta),sin(theta)*cos(phi))

trail = curve(radius=Rshaft/8., color=(1,1,0))

r = Lshaft/2.
dt = 0.0001
t = 0.
Nsteps = 20 # number of calculational steps between graphics updates

def anim():
    global theta, phidot, alphadot, M, g, r, thetadot, phi, alpha, t
    for step in range(Nsteps): # multiple calculation steps for accuracy
        # Calculate accelerations of the Lagrangian coordinates:
        atheta = (phidot**2*sin(theta)*cos(theta)
                  -2.*(alphadot+phidot*cos(theta))*phidot*sin(theta)
                  +2.*M*g*r*sin(theta)/I)
        aphi = 2.*thetadot*(alphadot-phidot*cos(theta))/sin(theta)
        aalpha = phidot*thetadot*sin(theta)-aphi*cos(theta)
        # Update velocities of the Lagrangian coordinates:
        thetadot = thetadot+atheta*dt
        phidot = phidot+aphi*dt
        alphadot = alphadot+aalpha*dt
        # Update Lagrangian coordinates:
        theta = theta+thetadot*dt
        phi = phi+phidot*dt
        alpha = alpha+alphadot*dt

    gyro.axis = vector(sin(theta)*sin(phi),cos(theta),sin(theta)*cos(phi))
    # Display approximate rotation of rotor and shaft:
    gyro.rotate(axis = gyro.axis, angle=alphadot*dt*Nsteps, origin = gyro.pos)
    trail.append(gyro.pos + gyro.axis * Lshaft)
    t = t+dt*Nsteps

a = iterate(40, anim)
a.edit_traits()
show()

########NEW FILE########
__FILENAME__ = lorenz
#!/usr/bin/env python

# Author: Raashid Baig <raashid@aero.iitb.ac.in>
# License: BSD Style.

from tvtk.tools.visual import curve, box, vector, show
from numpy import arange, array

lorenz = curve( color = (1,1,1), radius=0.3 )

# Draw grid
for x in xrange(0,51,10):
    curve(points = [[x,0,-25],[x,0,25]], color = (0,0.5,0), radius = 0.3 )
    box(pos=(x,0,0), axis=(0,0,50), height=0.4, width=0.4, length = 50)

for z in xrange(-25,26,10):
    curve(points = [[0,0,z], [50,0,z]] , color = (0,0.5,0), radius = 0.3 )
    box(pos=(25,0,z), axis=(50,0,0), height=0.4, width=0.4, length = 50)

dt = 0.01
y = vector(35.0, -10.0, -7.0)

pts = []
for i in xrange(2000):
    # Integrate a funny differential equation
    dydt = vector(      -8.0/3*y[0] + y[1]*y[2],
                          - 10*y[1] +   10*y[2],
                   - y[1]*y[0] + 28*y[1] - y[2])
    y = y + dydt * dt

    pts.append(y)
    if len(pts) > 20:
        lorenz.extend(pts)
        pts[:] = []

show()

########NEW FILE########
__FILENAME__ = orbit
#!/usr/bin/env python
"""A simple example demonstrating the creation of actors and animating
the in a scene using visual modeule."""
# Author: Raashid Baig <raashid@aero.iitb.ac.in>
# License: BSD Style.

from math import sqrt

from tvtk.tools.visual import sphere, iterate, show, vector, curve

#Creating the actors for the scene
giant = sphere(pos=(-1.0e11, 0, 0),
               radius=2e10,
               color=(1, 0, 0),
               mass=2e30)

dwarf = sphere(pos=(1.5e11, 0, 0),
               radius=1e10,
               color=(1, 1, 0),
               mass=1e30)

giant.p = vector(0, 0, -1e4) * giant.mass
dwarf.p = -1*giant.p

# creating the curve which will trace the paths of actors
for a in [giant, dwarf]:
    a.orbit = curve(radius=2e9, color=a.color)

dt = 86400

def anim():
    #Creating the animation function which will be called at
    #uniform timeperiod through the iterate function
    dist = dwarf.pos - giant.pos
    force = 6.7e-11 * giant.mass * dwarf.mass * \
        dist/(sqrt(dist[0]**2 + dist[1]**2 + dist[2]**2))**3
    giant.p = giant.p + force*dt
    dwarf.p = dwarf.p - force*dt

    for a in [giant, dwarf]:
        a.pos = a.pos + (a.p/a.mass)*dt
        a.orbit.append(a.pos)
        p = a.orbit.points
        if len(p) > 1000:
            a.orbit.points = p[200:]

a = iterate(50, anim)
a.edit_traits()
show()

########NEW FILE########
__FILENAME__ = randombox
#!/usr/bin/env python

# Author: Raashid Baig <raashid@aero.iitb.ac.in>
# License: BSD Style.

from random import random, randrange
from numpy import arange
from math import pi, cos, sin

from tvtk.tools.visual import curve, box, arrow, \
                                        sphere, cylinder, show

def random_box():
    xx = randrange(-55,54)
    yy = randrange(-55,54)
    zz = randrange(-55,54)
    x = randrange(0,21)
    y = randrange(0,21)
    z = randrange(0,21)
    red = random()
    green = random()
    blue = random()
    box (pos = (xx,yy,zz), length=x, height=y, width=z,
         color=(red,green,blue))

def wirecube(s):
    c = curve(color = (1,1,1), radius=1)
    pts = [(-s, -s, -s),(-s, -s, s), (-s, s, s),
           (-s, s, -s), (-s, -s, -s), (s, -s, -s),
           (s, s, -s), (-s, s, -s), (s, s, -s),
           (s, s, s), (-s, s, s), (s, s, s),
           (s, -s, s), (-s, -s, s), (s, -s, s),(s, -s, -s)]
    for pt in pts:
        c.append(pt)

side = 150.0
cube = box(size = (side,side,side), representation = 'w' )
i = 0
while i < 100:
    random_box()
    i = i + 1

arrow(axis=(0,12,0), radius_shaft=3.5, color = (1,0,0))

ball = sphere(pos=(-side/2.,-side/2.,-side/2.),color=(1,1,0),radius=3)
disk = cylinder(pos=(side/2.,side/2.,-side/2.),color=(.3,.3,1),axis=(1,1,0),radius=5)
xx = arange(0,4*pi,pi/10.)
spring=curve(color=(1,.7,.1), radius=0.4)
for y in xx:
    spring.append([20+cos(2*y), y/2.-30, -20+sin(2*y)+30])

show()

########NEW FILE########
__FILENAME__ = wave
#!/usr/bin/env python

# Author: Raashid Baig <raashid@aero.iitb.ac.in>
# License: BSD Style.

from math import sin, pi

from numpy import zeros, float, arange

from tvtk.tools.visual import show, Curve, iterate, MVector


def main():
    dt = 0.1

    x = arange(-50,50)
    wpoints1 = zeros((100,3), float)
    wpoints2 = zeros((100,3), float)
    wpoints3 = zeros((100,3), float)
    wpoints4 = zeros((100,3), float)

    for i in range (0,100,1):
        wpoints1[i] = [x[i], -30, 0]
        wpoints2[i] = [x[i], -15, 0]
        wpoints3[i] = [x[i], 0, 0]
        wpoints4[i] = [x[i], 15, 0]

    band1 = Curve(points = wpoints1, k = 6.0, color = (1,0,0),
                  mass = 2.0, radius = 0.5, momentum = zeros((100, 3), float))

    band2 = Curve(points = wpoints2, k = 6.0, color = (1,1,0),
                  mass = 2.0, radius = 0.5, momentum = zeros((100, 3), float))

    band3 = Curve(points = wpoints3, k = 6.0, color = (0,1,0),
                  mass = 2.0, radius = 0.5, momentum = zeros((100, 3), float))

    band4 = Curve(points = wpoints4, k = 6.0, color = (0,0,1),
                  mass = 2.0, radius = 0.5, momentum = zeros((100, 3), float))

    for i in range(0,25,1):
        band1.momentum[i,1] = sin(x[i]*pi/25.0)*3   # half-wave pulse

    for i in range(0,25,1):
        band2.momentum[i,1] = sin(x[i]*2*pi/25.0)*5   # full-wave pulse

    for i in range(0,25,1):
        band3.momentum[i,0] = sin(x[i]*pi/25.0)*5   # compresion pulse

    for i in range(0,100,1):
        band4.momentum[i,1] = sin(x[i]*4*pi/100.0)*2   # standing wave

    def anim():
        band1.momentum[0] = band1.momentum[-1] = MVector(0,0,0)
        band2.momentum[0] = band2.momentum[-1] = MVector(0,0,0)
        band3.momentum[0] = band3.momentum[-1] = MVector(0,0,0)
        band4.momentum[0] = band4.momentum[-1] = MVector(0,0,0)

        band1.points = band1.points + (band1.momentum/band1.mass*dt)
        band2.points = band2.points + (band2.momentum/band2.mass*dt)
        band3.points = band3.points + (band3.momentum/band3.mass*dt)
        band4.points = band4.points + (band4.momentum/band4.mass*dt)

        force1 = band1.k * (band1.points[1:] - band1.points[:-1])
        force2 = band2.k * (band2.points[1:] - band2.points[:-1])
        force3 = band3.k * (band3.points[1:] - band3.points[:-1])
        force4 = band4.k * (band4.points[1:] - band4.points[:-1])

        band1.momentum[:-1] = band1.momentum[:-1] + force1 * dt
        band2.momentum[:-1] = band2.momentum[:-1] + force2 * dt
        band3.momentum[:-1] = band3.momentum[:-1] + force3 * dt
        band4.momentum[:-1] = band4.momentum[:-1] + force4 * dt

        band1.momentum[1:] = band1.momentum[1:] - force1 * dt
        band2.momentum[1:] = band2.momentum[1:] - force2 * dt
        band3.momentum[1:] = band3.momentum[1:] - force3 * dt
        band4.momentum[1:] = band4.momentum[1:] - force4 * dt

    a = iterate(20, anim)
    show()
    return a

if __name__ == '__main__':
    main()

########NEW FILE########
__FILENAME__ = common
"""MayaVi test related utilities.
"""
# Author: Prabhu Ramachandran <prabhu_r@users.sf.net>
# Copyright (c) 2005-2008, Enthought, Inc.
# License: BSD Style.

# Standard library imports
import os
import os.path
import sys
import logging
import traceback
from optparse import OptionParser

# Enthought library imports
from traits.etsconfig.api import ETSConfig
from traits.api import  Any, Bool, Instance
from pyface.api import GUI
from tvtk.api import tvtk
from mayavi.plugins.app import Mayavi, setup_logger

# The TVTK window.
from tvtk.pyface.tvtk_scene import TVTKWindow

# Global variables.
VERBOSE = False
logger = logging.getLogger()


def off_screen_viewer():
    """A factory that creates an offscreen viewer."""
    win = TVTKWindow(off_screen_rendering=True)
    # Need to set some non-zero size for the off screen window.  If
    # not we get VTK errors on Linux.
    win.scene.set_size((300,300))
    return win


class MayaviTestError(Exception):
    pass

######################################################################
# Image comparison utility functions.
######################################################################

# Much of this code is translated from `vtk.test.Testing`.
def _print_image_error(img_err, err_index, img_base):
    """Prints out image related error information."""
    msg = """Failed image test with error: %(img_err)f
             Baseline image, error index: %(img_base)s, %(err_index)s
             Test image:  %(img_base)s.test.small.jpg
             Difference image: %(img_base)s.diff.small.jpg
             Valid image: %(img_base)s.small.jpg"""%locals()
    logger.error(msg)
    if VERBOSE:
        print msg


def _print_image_success(img_err, err_index):
    "Prints XML data for Dart when image test succeeded."
    msg = "Image Error, image_index: %s, %s"%(img_err, err_index)
    logger.debug(msg)
    if VERBOSE:
        print msg


def _handle_failed_image(idiff, src_img, pngr, img_fname):
    """Writes all the necessary images when an image comparison
    failed."""
    f_base, f_ext = os.path.splitext(img_fname)

    # write out the difference file in full.
    pngw = tvtk.PNGWriter(file_name=f_base + ".diff.png",
                          input=idiff.output)
    pngw.write()

    # write the difference image scaled and gamma adjusted for the
    # dashboard.
    sz = pngr.output.dimensions
    if sz[1] <= 250.0:
        mag = 1.0
    else:
        mag = 250.0/sz[1]

    shrink = tvtk.ImageResample(input=idiff.output, interpolate=1)
    shrink.set_axis_magnification_factor(0, mag)
    shrink.set_axis_magnification_factor(1, mag)

    gamma = tvtk.ImageShiftScale(input=shrink.output, shift=0, scale=10)

    jpegw = tvtk.JPEGWriter(file_name=f_base + ".diff.small.jpg",
                            input=gamma.output, quality=85)
    jpegw.write()

    # write out the image that was generated.
    pngw.set(input=src_img, file_name=f_base + ".test.png")
    pngw.write()

    # write out a smaller version of the image that was generated.
    shrink.input = idiff.input
    jpegw.set(input=shrink.output, file_name=f_base + ".test.small.jpg")
    jpegw.write()

    # write out the valid image that matched.
    shrink.input = idiff.image
    jpegw.set(input=shrink.output, file_name=f_base + ".small.jpg")
    jpegw.write()

def _set_scale(r1, r2):
    """Given two instances of tvtk.ImageResample, this sets the scale
    of the two such that their outputs are of the same.  The final
    size is chosen as the minumum of the height and width of each
    image.
    """
    img1, img2 = r1.input, r2.input
    ex1 = img1.whole_extent
    w1, h1 = ex1[1] + 1, ex1[3] + 1
    ex2 = img2.whole_extent
    w2, h2 = ex2[1] + 1, ex2[3] + 1
    w = min(w1, w2)
    h = min(h1, h2)
    r1.set_axis_magnification_factor(0, float(w)/w1)
    r1.set_axis_magnification_factor(1, float(h)/h1)
    r1.update()
    r2.set_axis_magnification_factor(0, float(w)/w2)
    r2.set_axis_magnification_factor(1, float(h)/h2)
    r2.update()


def compare_image_with_saved_image(src_img, img_fname, threshold=10,
                                   allow_resize=True):
    """Compares a source image (src_img, which is a tvtk.ImageData)
    with the saved image file whose name is given in the second
    argument.  If the image file does not exist the image is generated
    and stored.  If not the source image is compared to that of the
    figure.  This function also handles multiple images and finds the
    best matching image.  If `allow_resize` is True then the images
    are rescaled if they are not of the same size.
    """
    f_base, f_ext = os.path.splitext(os.path.abspath(img_fname))

    if not os.path.isfile(img_fname):
        # generate the image
        pngw = tvtk.PNGWriter(file_name=img_fname, input=src_img)
        pngw.write()
        if VERBOSE:
            print "Creating baseline image '%s'."%img_fname
        return

    pngr = tvtk.PNGReader(file_name=img_fname)
    pngr.update()

    if allow_resize:
        src_resample = tvtk.ImageResample(input=src_img, interpolate=1,
                                          interpolation_mode='cubic')
        img_resample = tvtk.ImageResample(input=pngr.output, interpolate=1,
                                          interpolation_mode='cubic')
        _set_scale(src_resample, img_resample)
        idiff = tvtk.ImageDifference(input=src_resample.output,
                                     image=img_resample.output)
    else:
        idiff = tvtk.ImageDifference(input=src_img,
                                     image=pngr.output)
    idiff.update()

    min_err = idiff.thresholded_error
    img_err = min_err
    best_img = img_fname

    err_index = 0
    count = 0
    if min_err > threshold:
        count = 1
        test_failed = 1
        err_index = -1
        while 1: # keep trying images till we get the best match.
            new_fname = f_base + "_%d.png"%count
            if not os.path.exists(new_fname):
                # no other image exists.
                break
            # since file exists check if it matches.
            pngr.file_name = new_fname
            pngr.update()
            if allow_resize:
                _set_scale(src_resample, img_resample)
            idiff.update()
            alt_err = idiff.thresholded_error
            if alt_err < threshold:
                # matched,
                err_index = count
                test_failed = 0
                min_err = alt_err
                img_err = alt_err
                best_img = new_fname
                break
            else:
                if alt_err < min_err:
                    # image is a better match.
                    err_index = count
                    min_err = alt_err
                    img_err = alt_err
                    best_img = new_fname

            count = count + 1
        # closes while loop.

        if test_failed:
            _handle_failed_image(idiff, src_img, pngr, best_img)
            _print_image_error(img_err, err_index, f_base)
            msg = "Failed image test: %f\n"%idiff.thresholded_error
            raise AssertionError, msg
    # output the image error even if a test passed
    _print_image_success(img_err, err_index)


def compare_image_raw(renwin, img_fname, threshold=10, allow_resize=True):
    """Compares renwin's (a tvtk.RenderWindow) contents with the image
    file whose name is given in the second argument.  If the image
    file does not exist the image is generated and stored.  If not the
    image in the render window is compared to that of the figure.
    This function also handles multiple images and finds the best
    matching image.  If `allow_resize` is True then the images are
    rescaled if they are not of the same size.
    """
    # If this is not done the window may not be parented correctly.
    GUI.process_events()

    w2if = tvtk.WindowToImageFilter(read_front_buffer=False, input=renwin)
    w2if.update()
    return compare_image_with_saved_image(w2if.output, img_fname,
                                          threshold, allow_resize)


def compare_image_offscreen(scene, img_path):
    """Given a MayaVi scene and a path to a valid image, this
    compares the image rendered on the scene to that saved as the
    image.

    This functionality relies on the off screen rendering
    capabilities of VTK.  Under Linux and Mac OS X this only works
    with VTK from CVS (i.e. VTK-5.1.x).  It definitely works with
    a CVS checkout later than March 2006.
    """
    abs_img_path = img_path
    if not os.path.isabs(img_path):
        abs_img_path = fixpath(img_path)

    s = scene.scene
    saved = s.off_screen_rendering
    s.off_screen_rendering = True
    s.render_window.size = (300, 300)
    s.reset_zoom()
    s.render()
    try:
        compare_image_raw(s.render_window, abs_img_path)
    finally:
        s.off_screen_rendering = saved
        s.render()


def compare_image(scene, img_path):
    """Given a MayaVi scene and a path to a valid image, this
    compares the image rendered on the scene to that saved as the
    image.

    This will pop up a new tvtk render window and use that to
    perform the image comparison.
    """
    abs_img_path = img_path
    if not os.path.isabs(img_path):
        abs_img_path = fixpath(img_path)

    s = scene.scene
    s.disable_render = True
    ren = s.renderer
    s.render_window.remove_renderer(ren)
    rw = tvtk.RenderWindow(size=(300,300))
    rw.add_renderer(ren)
    ren.reset_camera()
    rw.render()
    try:
        compare_image_raw(rw, abs_img_path)
    finally:
        rw.remove_renderer(ren)
        s.render_window.add_renderer(ren)
        s.disable_render = False
        ren.reset_camera()
        s.render()

def is_running_with_nose():
    """Returns True if we are being run via nosetests.

    This tests if `nosetests` is used or if we are invoked via
    `python -m nose.core`.
    """
    argv0 = sys.argv[0]
    nose_core = os.path.join('nose', 'core.py')
    if argv0.endswith('nosetests') or argv0.endswith(nose_core):
        return True
    return False


###########################################################################
# `TestCase` class.
###########################################################################
class TestCase(Mayavi):
    """
    This class is to be subclassed when you write a test.
    """

    # Interact with the user after test is done?  Normally tests just
    # exit after completion, this prevents that.
    interact = Bool(False)

    # Always use offscreen rendering to generate images -- even if
    # `self.compare_image` was called in the test..
    offscreen = Bool(False)

    # Use the standalone mode. This mode does not use the envisage Mayavi
    # application.
    standalone = Bool(True)

    app_window = Instance('pyface.api.ApplicationWindow')

    gui = Instance('pyface.gui.GUI')

    # An exception info if an exception was raised by a test.
    exception_info = Any

    ######################################################################
    # `Mayavi` interface.
    ######################################################################
    def main(self, argv=None, plugins=None):
        """Overridden main method that sets the argv to sys.argv[1:] by
        default.  Call this to run the test.
        """
        if argv is None:
            argv = sys.argv[1:]

        if not is_running_with_nose():
            self.parse_command_line(argv)

        if self.standalone:
            self.run_standalone()
        else:
            # Call the superclass main method.
            super(TestCase, self).main(argv, plugins)

    def setup_logger(self):
        """Overridden logger setup."""
        if self.standalone:
            path = os.path.join(ETSConfig.application_data,
                                'mayavi_e3', 'mayavi-test.log')
            path = os.path.abspath(path)
            log_path = os.path.dirname(path)
            if not os.path.exists(log_path):
                os.makedirs(log_path)
        else:
            path = 'mayavi-test.log'
        setup_logger(logger, path, mode=self.log_mode)

    def run_standalone(self):
        from mayavi.core.engine import Engine
        from mayavi.plugins.script import Script
        from pyface.api import ApplicationWindow, GUI

        self.setup_logger()
        if self.offscreen:
            engine = Engine(scene_factory=off_screen_viewer)
        else:
            engine = Engine()
        engine.start()

        self.exception_info = None
        self.script = Script(engine=engine)
        self.gui = g = GUI()
        self.app_window = a = ApplicationWindow()
        a.open()
        a.show(False)
        g.invoke_later(self.run)
        g.start_event_loop()
        if self.exception_info is not None:
            type, value, tb = self.exception_info
            raise type, value, tb

    def run(self):
        """This starts everything up and runs the test.  Call main to
        run the test."""
        # Calls the users test code.
        try:
            self.do()
        except Exception, e:
            type, value, tb = sys.exc_info()
            if is_running_with_nose():
                self.exception_info = type, value, tb
            else:
                # To mimic behavior of unittest.
                sys.stderr.write('\nfailures=1\n')
                info = traceback.extract_tb(tb)
                filename, lineno, function, text = info[-1] # last line only
                exc_msg = "%s\nIn %s:%d\n%s: %s (in %s)" %\
                        ('Exception', filename, lineno, type.__name__, str(value),
                        function)
                sys.stderr.write(exc_msg + '\n')
                # Log the message.
                logger.exception(exc_msg)
                if not self.interact:
                    sys.exit(1)
        finally:
            if not self.interact:
                if self.standalone:
                    # Close all existing viewers.
                    e = self.script.engine
                    for scene in e.scenes:
                        viewer = e.get_viewer(scene)
                        if viewer is not None:
                            if self.offscreen:
                                viewer.scene.close()
                            else:
                                viewer.close()
                    GUI.process_events()
                    # Shut down the app and the event loop.
                    self.app_window.close()
                    self.gui.stop_event_loop()
                else:
                    self.application.gui.invoke_later(self.application.exit)

    def parse_command_line(self, argv):
        """Parse command line options."""
        usage = "usage: %prog [options]"
        parser = OptionParser(usage)
        parser.add_option("-v", "--verbose", action="store_true",
                          dest="verbose", help="Print verbose output")
        parser.add_option("-i", "--interact", action="store_true",
                          dest="interact", default=False,
                          help="Allow interaction after test (default: False)")
        parser.add_option("-s", "--nostandalone", action="store_true",
                          dest="standalone", default=False,
                          help="Run test using envisage without standalone "\
                          "(default: False)")
        parser.add_option("-o", "--offscreen", action="store_true",
                          dest="offscreen", default=False,
                          help="Always use offscreen rendering when "\
                               "generating images (default: False)")

        (options, args) = parser.parse_args(argv)
        global VERBOSE
        if options.verbose:
            VERBOSE = True
            self.log_mode = logging.DEBUG
        self.offscreen = options.offscreen
        self.interact = options.interact
        self.standalone = not options.standalone

    ######################################################################
    # `TestCase` interface.
    ######################################################################
    def do(self):
        """Override this to do whatever you want to do as your test
        code.

        *Make sure all other MayaVi specific imports are made here!*

        If you import MayaVi related code earlier you will run into
        difficulties.
        """
        raise NotImplementedError

    def new_scene(self):
        """Creates a new TVTK scene, sets its size to that prescribed
        and returns the scene.
        """
        script = self.script
        # Create a new VTK scene.
        script.new_scene()
        # Set its background.
        if self.standalone:
            GUI.process_events()
        s = script.engine.current_scene
        s.scene.background = (0.5, 0.5, 0.5)
        return s

    def compare_image_offscreen(self, scene, img_path):
        """Given a MayaVi scene and a path to a valid image, this
        compares the image rendered on the scene to that saved as the
        image.

        This functionality relies on the off screen rendering
        capabilities of VTK.  Under Linux and Mac OS X this only works
        with VTK from CVS (i.e. VTK-5.1.x).  It definitely works with
        a CVS checkout later than March 2006.
        """
        return compare_image_offscreen(scene, img_path)

    def compare_image(self, scene, img_path):
        """Given a MayaVi scene and a path to a valid image, this
        compares the image rendered on the scene to that saved as the
        image.

        This will pop up a new tvtk render window and use that to
        perform the image comparison.
        """
        if self.offscreen:
            return self.compare_image_offscreen(scene, img_path)
        else:
            return compare_image(scene, img_path)

    def failUnlessRaises(self, excClass, callableObj, *args, **kwargs):
        """Fail unless an exception of class excClass is thrown by
        callableObj when invoked with arguments args and keyword
        arguments kwargs. If a different type of exception is thrown,
        it will not be caught, and the test case will be deemed to
        have suffered an error, exactly as for an unexpected
        exception.
        """
        try:
            callableObj(*args, **kwargs)
        except excClass:
            return
        else:
            if hasattr(excClass,'__name__'):
                excName = excClass.__name__
            else:
                excName = str(excClass)
            raise MayaviTestError, excName
    assertRaises = failUnlessRaises


def fixpath(filename):
    """Given a relative file path it sets the path relative to this
    directory.  This allows us to run the tests from other directories
    as well.
    """
    return os.path.join(os.path.dirname(__file__), filename)

def get_example_data(fname):
    """Given a relative path to data inside the examples directory,
    obtains the full path to the file.
    """
    p = os.path.join(os.pardir, os.pardir,
                     'examples', 'mayavi', 'data', fname)
    return os.path.abspath(fixpath(p))

def test(function):
    """A decorator to make a simple mayavi2 script function into a
    test case.  Note that this will not work with nosetests.
    """
    class MyTest(TestCase):
        def do(self):
            g = sys.modules['__main__'].__dict__
            if 'mayavi' not in g:
                g['mayavi'] = self.script
            if 'application' not in g:
                g['application'] = self.application
            # Call the test.
            function()
        def __call__(self):
           self.main()

    test = MyTest()
    return test

########NEW FILE########
__FILENAME__ = run
#!/usr/bin/env python
"""Script to run all the tests.
"""
# Author: Prabhu Ramachandran <prabhu [at] aero . iitb . ac . in>
# Copyright (c) 2008,  Prabhu Ramachandran
# License: BSD Style.

import sys
import os
from os.path import splitext
import glob
from common import TestCase

def get_tests():
    """Get all the tests to run.
    """
    files = glob.glob('test_*.py')
    return files

def run_all(tests):
    """Run the given tests.
    """
    args = ' '.join(sys.argv[1:])
    success = []
    fail = []
    for test in tests:
        cmd = 'python %s %s'%(test, args)
        print cmd
        status = os.system(cmd)
        if status == 0:
            print "OK"
            success.append(test)
        else:
            print "FAIL: %s"%test
            fail.append(test)

    print '-'*70
    print "%d successful tests, %d failures"%(len(success), len(fail))
    for test in fail:
        print test
    print '-'*70
    return len(fail) != 0


class RunAllTests(TestCase):
    """Runs all the tests in one go, instead of running each test
    separately.  This speeds up the testing.
    """
    def get_tests(self):
        tests = get_tests()
        tests = [splitext(t)[0] for t in tests]
        klasses = []
        for test in tests:
            # Find test.
            m = __import__(test)
            m.mayavi = self.script
            m.application = self.application
            for name in dir(m):
                klass = getattr(m, name)
                try:
                    if issubclass(klass, TestCase) and klass is not TestCase:
                        mod_name = '%s.%s'%(test, name)
                        klasses.append((mod_name, klass))
                        break
                except TypeError:
                    continue
        return klasses

    def do(self):
        klasses = self.get_tests()
        for name, klass in klasses:
            # Close existing scenes.
            e = self.script.engine
            for scene in e.scenes:
                e.close_scene(scene)
            print '*'*80
            print name
            obj = klass()
            obj.set(script=self.script)
            obj.test()


def main():
    argv = ' '.join(sys.argv)

    if '--one-shot' in argv:
        argv = argv.replace('--one-shot', '')
        sys.argv = argv.split()
        t = RunAllTests()
        t.main()
    else:
        tests = get_tests()
        status = run_all(tests)
        sys.exit(status)

if __name__ == "__main__":
    main()

########NEW FILE########
__FILENAME__ = test_array_source
"""Tests for the ArraySource data source for MayaVi.
"""
# Author: Prabhu Ramachandran <prabhu_r@users.sf.net>
# Copyright (c) 2005,  Enthought, Inc.
# License: BSD Style.

# Standard library imports.
from os.path import abspath
from StringIO import StringIO
import copy
import numpy

# Enthought library imports.
from traits.api import TraitError

# Local imports.
from common import TestCase


class TestArraySource(TestCase):
    def check_input_validation(self, obj):
        """Tests if only the correct forms of input arrays are supported."""
        # These should work.
        obj.scalar_data = numpy.zeros((2,2), 'd')
        obj.scalar_data = numpy.zeros((2,2,2), 'd')
        obj.scalar_data = None
        obj.vector_data = numpy.zeros((2,2,3), 'd')
        obj.vector_data = numpy.zeros((2,2,2,3), 'd')
        obj.vector_data = None

        # These should not.
        self.assertRaises(TraitError, setattr, obj, 'scalar_data', [1,2,3])
        self.assertRaises(TraitError, setattr, obj, 'scalar_data',
                          numpy.zeros((2,2,2,3), 'd'))
        obj.scalar_data = None
        self.assertRaises(TraitError, setattr, obj, 'vector_data', [[1,2,3]])
        self.assertRaises(TraitError, setattr, obj, 'vector_data',
                          numpy.zeros((2,2,2,1), 'd'))
        obj.vector_data = None

        obj.scalar_data = numpy.zeros((2,2), 'd')
        self.assertRaises(TraitError, setattr, obj, 'vector_data',
                          numpy.zeros((4,4,3), 'd'))
        obj.vector_data = numpy.zeros((2,2,3), 'd')
        self.assertRaises(TraitError, setattr, obj, 'scalar_data',
                          numpy.zeros((4,3), 'i'))
        self.assertRaises(TraitError, setattr, obj, 'scalar_data',
                          numpy.zeros((2,2,2), 'i'))
        obj.scalar_data = numpy.zeros((2,2), 'f')

        # Clean up the object so it can be used for further testing.
        obj.scalar_data = obj.vector_data = None

    def make_2d_data(self):
        s = numpy.array([[0, 1],[2, 3]], 'd')
        v = numpy.array([[[1,1,1], [1,0,0]],[[0,1,0], [0,0,1]]], 'd')
        tps = numpy.transpose
        s, v = tps(s), tps(v, (1, 0, 2))
        return s, v

    def make_3d_data(self):
        s = numpy.array([[[0, 1],[2, 3]],
                           [[4, 5],[6, 7]]], 'd')
        v = numpy.array([[[[0,0,0],
                             [1,0,0]],
                            [[0,1,0],
                             [1,1,0]]],
                           [[[0,0,1],
                             [1,0,1]],
                            [[0,1,1],
                             [1,1,1]]]], 'd')
        tps = numpy.transpose
        s, v = tps(s), tps(v, (2, 1, 0, 3))
        return s, v

    def check(self):
        script = self.script
        s = script.engine.current_scene
        d1, d2 = s.children
        s1, v1 = d1.children[0].children[1:]
        expect = list(self.make_2d_data())
        tps = numpy.transpose
        expect[0] = tps(expect[0])
        expect[1] = tps(expect[1], (1, 0, 2))
        sc1 = s1.actor.mapper.input.point_data.scalars.to_array()
        assert numpy.allclose(sc1.flatten(), expect[0].flatten())
        vec1 = s1.actor.mapper.input.point_data.vectors.to_array()
        assert numpy.allclose(vec1.flatten(), expect[1].flatten())

        s2, v2 = d2.children[0].children[1:]
        expect = list(self.make_3d_data())
        tps = numpy.transpose
        expect[0] = tps(expect[0])
        expect[1] = tps(expect[1], (2, 1, 0, 3))
        sc2 = s2.actor.mapper.input.point_data.scalars.to_array()
        assert numpy.allclose(sc2.flatten(), expect[0].flatten())
        vec2 = s2.actor.mapper.input.point_data.vectors.to_array()
        assert numpy.allclose(vec2.flatten(), expect[1].flatten())

    def test(self):
        self.main()

    def do(self):
        ############################################################
        # Imports.
        script = self.script
        from mayavi.sources.array_source import ArraySource
        from mayavi.modules.outline import Outline
        from mayavi.modules.surface import Surface
        from mayavi.modules.vectors import Vectors

        ############################################################
        # Create a new scene and set up the visualization.
        s = self.new_scene()

        d = ArraySource()
        self.check_input_validation(d)
        sc, vec = self.make_2d_data()
        d.origin = (-1, -1, 0)
        d.scalar_data = sc
        d.vector_data = vec

        script.add_source(d)

        # Create an outline for the data.
        o = Outline()
        script.add_module(o)
        # View the data.
        s = Surface()
        script.add_module(s)
        v = Vectors()
        script.add_module(v)

        # Add a 3D data source
        d = ArraySource()
        sc, vec = self.make_3d_data()
        d.scalar_data = sc
        d.vector_data = vec
        script.add_source(d)
        # Create an outline for the data.
        o = Outline()
        script.add_module(o)
        # View a slice.
        s = Surface()
        script.add_module(s)
        v = Vectors()
        script.add_module(v)

        # Set the scene to a suitable view.
        s.scene.z_plus_view()
        c = s.scene.camera
        c.azimuth(-30)
        c.elevation(30)

        self.check()

        ############################################################
        # Test if saving a visualization and restoring it works.

        bg = s.scene.background
        # Save visualization.
        f = StringIO()
        f.name = abspath('test.mv2') # We simulate a file.
        script.save_visualization(f)
        f.seek(0) # So we can read this saved data.

        # Remove existing scene.
        engine = script.engine
        engine.close_scene(s)

        # Load visualization
        script.load_visualization(f)
        s = engine.current_scene

        # Set the scene to a suitable view.
        s.scene.z_plus_view()
        c = s.scene.camera
        c.azimuth(-30)
        c.elevation(30)
        s.scene.background = bg

        self.check()

        ############################################################
        # Test if the MayaVi2 visualization can be deepcopied.

        # Pop the source object.
        sources = s.children
        s.children = []
        # Add it back to see if that works without error.
        s.children.extend(sources)

        s.scene.reset_zoom()

        self.check()

        # Now deepcopy the source and replace the existing one with
        # the copy.  This basically simulates cutting/copying the
        # object from the UI via the right-click menu on the tree
        # view, and pasting the copy back.
        sources1 = copy.deepcopy(sources)
        s.children[:] = sources
        s.scene.reset_zoom()
        self.check()

        # If we have come this far, we are golden!


if __name__ == "__main__":
    t = TestArraySource()
    t.test()

########NEW FILE########
__FILENAME__ = test_close_scene
#!/usr/bin/env mayavi2
# Author: Prabhu Ramachandran <prabhu [at] aero . iitb . ac . in>
# Copyright (c) 2008,  Prabhu Ramachandran
# License: BSD Style.

"""This tests that closing a hidden TVTK scene window does not crash or
raise PyDeadObjectErrors.
"""

from common import TestCase

class TestCloseScene(TestCase):
    def test(self):
        self.main()

    def do(self):
        mayavi = self.script
        engine = mayavi.engine
        s1 = mayavi.new_scene()
        s2 = mayavi.new_scene()
        # This should not crash or throw any errors (PyDeadObjects etc.)
        engine.close_scene(s1)
        # Neither should this.
        engine.close_scene(s2)

if __name__ == "__main__":
    t = TestCloseScene()
    t.test()

########NEW FILE########
__FILENAME__ = test_contour
"""Simple test for the contour related modules.
"""
# Author: Prabhu Ramachandran <prabhu_r@users.sf.net>
# Copyright (c) 2005-2008,  Enthought, Inc.
# License: BSD Style.

# Standard library imports.
from os.path import abspath
from StringIO import StringIO
import copy
import numpy

# Local imports.
from common import TestCase, get_example_data


class TestContour(TestCase):
    def check(self):
        """Do the actual testing."""
        script = self.script
        e = script.engine
        scene = e.current_scene
        src = scene.children[0]
        mm = src.children[0]
        cgp1 = mm.children[1]
        assert cgp1.grid_plane.position == 15

        cgp2 = mm.children[2]
        assert cgp2.contour.filled_contours == True
        assert cgp2.grid_plane.axis == 'y'
        assert cgp2.grid_plane.position == 15

        iso = mm.children[3]
        ctr = iso.contour.contours
        assert iso.compute_normals == True
        assert ctr == [200.0]
        rng = iso.actor.mapper.input.point_data.scalars.range
        assert rng[0] == 200.0
        assert rng[1] == 200.0

        cp = mm.children[4]
        ip = cp.implicit_plane
        assert abs(numpy.sum(ip.normal - (0,0,1))) < 1e-16
        assert abs(numpy.sum(ip.origin - (0,0,5))) < 1e-16
        assert ip.widget.enabled == False

    def test(self):
        self.main()

    def do(self):
        ############################################################
        # Imports.
        script = self.script
        from mayavi.sources.vtk_file_reader import VTKFileReader
        from mayavi.modules.outline import Outline
        from mayavi.modules.iso_surface import IsoSurface
        from mayavi.modules.contour_grid_plane \
             import ContourGridPlane
        from mayavi.modules.scalar_cut_plane import ScalarCutPlane

        ############################################################
        # Create a new scene and set up the visualization.
        s = self.new_scene()

        # Read a VTK (old style) data file.
        r = VTKFileReader()
        r.initialize(get_example_data('heart.vtk'))

        script.add_source(r)

        # Create an outline for the data.
        o = Outline()
        script.add_module(o)

        # Create one ContourGridPlane normal to the 'x' axis.
        cgp1 = ContourGridPlane()
        script.add_module(cgp1)
        # Set the position to the middle of the data.
        cgp1.grid_plane.position = 15

        # Another with filled contours normal to 'y' axis.
        cgp2 = ContourGridPlane()
        cgp2.contour.filled_contours = True
        # Set the axis and position to the middle of the data.
        cgp2.grid_plane.axis = 'y'
        cgp2.grid_plane.position = 15
        script.add_module(cgp2)

        # An isosurface module.
        iso = IsoSurface(compute_normals=True)
        script.add_module(iso)
        iso.contour.contours = [200.0]

        # An interactive scalar cut plane.
        cp = ScalarCutPlane()
        script.add_module(cp)
        ip = cp.implicit_plane
        ip.normal = 0,0,1
        ip.origin = 0,0,5
        ip.widget.enabled = False

        # Set the scene to an isometric view.
        s.scene.isometric_view()

        # Now test.
        self.check()

        ############################################################
        # Test if the modules respond correctly when the components
        # are changed.
        ctr = cgp2.contour
        cgp2.contour = ctr.__class__()
        cgp2.contour = ctr
        cgp2.actor = cgp2.actor.__class__()

        iso.contour = iso.contour.__class__()
        iso.contour.contours = [200.0]
        iso.actor = iso.actor.__class__()
        iso.normals = iso.normals.__class__()

        ip = cp.implicit_plane
        cp.implicit_plane = cp.implicit_plane.__class__()
        cp.implicit_plane = ip
        ip.widget.enabled = False
        cp.contour = cp.contour.__class__()
        cp.cutter = cp.cutter.__class__()
        cp.actor = cp.actor.__class__()

        s.render()

        # Now check.
        self.check()


        ############################################################
        # Test if saving a visualization and restoring it works.

        # Save visualization.
        f = StringIO()
        f.name = abspath('test.mv2') # We simulate a file.
        script.save_visualization(f)
        f.seek(0) # So we can read this saved data.

        # Remove existing scene.
        engine = script.engine
        engine.close_scene(s)

        # Load visualization
        script.load_visualization(f)
        s = engine.current_scene

        self.check()

        ############################################################
        # Test if the MayaVi2 visualization can be deep-copied.

        # Pop the source object.
        source = s.children.pop()
        # Add it back to see if that works without error.
        s.children.append(source)
        # Now set the enabled status of the widget, this is impossible
        # to get correctly.
        cp = source.children[0].children[-1]
        cp.implicit_plane.widget.enabled = False

        self.check()

        # Now deepcopy the source and replace the existing one with
        # the copy.  This basically simulates cutting/copying the
        # object from the UI via the right-click menu on the tree
        # view, and pasting the copy back.
        source1 = copy.deepcopy(source)
        s.children[0] = source1
        cp = source1.children[0].children[-1]
        cp.implicit_plane.widget.enabled = False
        self.check()

        # If we have come this far, we are golden!


if __name__ == "__main__":
    t = TestContour()
    t.test()

########NEW FILE########
__FILENAME__ = test_generic_module
"""Simple test for the GenericModule.
"""
# Author: Prabhu Ramachandran <prabhu [at] aero . iitb . ac . in>
# Copyright (c) 2008,  Prabhu Ramachandran
# License: BSD Style.

# Standard library imports.
from os.path import abspath
from StringIO import StringIO
import copy

# Local imports.
from common import TestCase, get_example_data


class TestGenericModule(TestCase):

    def test(self):
        self.main()

    def do(self):
        ############################################################
        # Imports.
        script = self.script
        from mayavi.filters.optional import Optional
        from mayavi.filters.warp_scalar import WarpScalar
        from mayavi.filters.cut_plane import CutPlane
        from mayavi.components.poly_data_normals import PolyDataNormals
        from mayavi.components.contour import Contour
        from mayavi.components.actor import Actor
        from mayavi.modules.generic_module import GenericModule
        from mayavi.sources.vtk_xml_file_reader import VTKXMLFileReader

        ############################################################
        # Create a new scene and set up the visualization.
        s = self.new_scene()

        # Read a VTK (old style) data file.
        r = VTKXMLFileReader()
        r.initialize(get_example_data('fire_ug.vtu'))
        script.add_source(r)

        # We now create the complete equivalent of a ScalarCutPlane in
        # the next block!
        cp = CutPlane()
        w = WarpScalar()
        warper = Optional(filter=w, label_text='Enable warping', enabled=False)
        c = Contour()
        ctr = Optional(filter=c, label_text='Enable contours', enabled=False)
        p = PolyDataNormals(name='Normals')
        normals = Optional(filter=p, label_text='Compute normals', enabled=False)
        a = Actor()
        components = [cp, warper, ctr, normals, a]
        m = GenericModule(name='ScalarCutPlane',
                          components=components,
                          contour=c, actor=a)

        script.add_module(m)
        s.scene.isometric_view()

        ########################################
        # do the testing.
        def check(mod):
            """Check if test status is OK for the given module."""
            cut, warper, ctr, normals, a = mod.components
            c = ctr.filter
            # The intermediate ones are disabled.
            assert normals.outputs[0] is cut.outputs[0]
            # Enable the contours.
            ctr.enabled = True
            assert ctr.outputs[0] is c.outputs[0]
            assert ctr.outputs[0] is normals.outputs[0]
            rng = normals.outputs[0].point_data.scalars.range
            assert (rng[1] - rng[0]) < 1e-4
            # Turn on auto-contours
            c.auto_contours = True
            # Increase number of contours and the range should change.
            c.number_of_contours = 10
            assert len(normals.outputs[0].points) != 0
            rng = normals.outputs[0].point_data.scalars.range
            assert rng[0] < rng[1]
            # Check if pipeline_changed is correctly propagated.
            old = normals.outputs[0]
            assert a.mapper.scalar_mode == 'default'
            c.filled_contours = True
            assert normals.outputs[0] != old
            assert normals.outputs[0] is c.outputs[0]
            # Check if the actor responds correctly to the
            # filled_contour change.
            assert a.mapper.scalar_mode == 'use_cell_data'

            # Set back everything to original state.
            c.filled_contours = False
            assert a.mapper.scalar_mode == 'default'
            c.number_of_contours = 1
            c.auto_contours = False
            ctr.enabled = False
            assert normals.outputs[0] is cut.outputs[0]

        check(m)

        ############################################################
        # Test if saving a visualization and restoring it works.

        # Save visualization.
        f = StringIO()
        f.name = abspath('test.mv2') # We simulate a file.
        script.save_visualization(f)
        f.seek(0) # So we can read this saved data.

        # Remove existing scene.
        engine = script.engine
        engine.close_scene(s)

        # Load visualization
        script.load_visualization(f)
        s = engine.current_scene
        s.scene.isometric_view()

        # Now do the check.
        m = s.children[0].children[0].children[0]
        check(m)

        ############################################################
        # Test if the Mayavi2 visualization can be deep-copied.

        # Pop the source object.
        source = s.children.pop()
        # Add it back to see if that works without error.
        s.children.append(source)
        # Now do the check.
        m = s.children[0].children[0].children[0]
        s.scene.isometric_view()
        check(m)

        # Now deepcopy the source and replace the existing one with
        # the copy.  This basically simulates cutting/copying the
        # object from the UI via the right-click menu on the tree
        # view, and pasting the copy back.
        source1 = copy.deepcopy(source)
        s.children[0] = source1
        # Now do the check.
        m = s.children[0].children[0].children[0]
        s.scene.isometric_view()
        check(m)

        # If we have come this far, we are golden!

if __name__ == "__main__":
    t = TestGenericModule()
    t.test()

########NEW FILE########
__FILENAME__ = test_glyph
"""Tests for the Glyph module.
"""
# Author: Prabhu Ramachandran <prabhu_r@users.sf.net>
# Copyright (c) 2005,  Enthought, Inc.
# License: BSD Style.

# Standard library imports.
from os.path import abspath
from StringIO import StringIO
import copy
import numpy

# Enthought library imports.
from traits.api import TraitError

# Local imports.
from common import TestCase


class TestGlyph(TestCase):
    def make_data(self):
        """Trivial data -- creates an elementatry scalar field and a
        constant vector field along the 'x' axis."""
        s = numpy.arange(0.0, 10.0, 0.01)
        s = numpy.reshape(s, (10,10,10))
        s = numpy.transpose(s)

        v = numpy.zeros(3000, 'd')
        v[1::3] = 1.0
        v = numpy.reshape(v, (10,10,10,3))
        return s, v

    def set_view(self, s):
        """Sets the view correctly."""
        #s.scene.reset_zoom()
        s.scene.z_plus_view()
        c = s.scene.camera
        c.azimuth(-30)
        c.elevation(20)
        s.render()

    def check(self):
        script = self.script
        s = script.engine.current_scene
        src = s.children[0]
        g = src.children[0].children[1]
        assert g.glyph.glyph_source.glyph_position == 'center'
        assert g.glyph.glyph.vector_mode == 'use_normal'
        assert g.glyph.glyph.scale_factor == 0.5
        assert g.actor.property.line_width == 1.0

        v = src.children[0].children[2]
        glyph = v.glyph
        gs = glyph.glyph_source
        assert gs.glyph_position == 'tail'
        assert gs.glyph_source == gs.glyph_list[1]
        assert numpy.allclose(v.implicit_plane.normal,  (0., 1., 0.))

        v = src.children[0].children[3]
        glyph = v.glyph
        gs = glyph.glyph_source
        assert gs.glyph_source == gs.glyph_list[2]
        assert gs.glyph_position == 'head'
        assert numpy.allclose(v.implicit_plane.normal,  (0., 1., 0.))

    def test(self):
        self.main()

    def do(self):
        ############################################################
        # Imports.
        script = self.script
        from mayavi.sources.array_source import ArraySource
        from mayavi.modules.outline import Outline
        from mayavi.modules.glyph import Glyph
        from mayavi.modules.vector_cut_plane import VectorCutPlane

        ############################################################
        # Create a new scene and set up the visualization.
        s = self.new_scene()

        d = ArraySource()
        sc, vec = self.make_data()
        d.origin = (-5, -5, -5)
        d.scalar_data = sc
        d.vector_data = vec

        script.add_source(d)

        # Create an outline for the data.
        o = Outline()
        script.add_module(o)
        # Glyphs for the scalars
        g = Glyph()
        script.add_module(g)
        g.glyph.glyph_source.glyph_position = 'center'
        g.glyph.glyph.vector_mode = 'use_normal'
        g.glyph.glyph.scale_factor = 0.5
        g.actor.property.line_width = 1.0

        v = VectorCutPlane()
        glyph = v.glyph
        gs = glyph.glyph_source
        gs.glyph_position = 'tail'
        gs.glyph_source = gs.glyph_list[1]
        script.add_module(v)
        v.implicit_plane.set(normal=(0, 1, 0), origin=(0, 3, 0))

        v = VectorCutPlane()
        glyph = v.glyph
        gs = glyph.glyph_source
        gs.glyph_source = gs.glyph_list[2]
        gs.glyph_position = 'head'
        script.add_module(v)
        v.implicit_plane.set(normal=(0, 1, 0), origin=(0, -2, 0))

        # Set the scene to a suitable view.
        self.set_view(s)

        self.check()

        ############################################################
        # Test if the modules respond correctly when the components
        # are changed.

        g.actor = g.actor.__class__()
        glyph = g.glyph
        g.glyph = glyph.__class__()
        g.glyph = glyph

        glyph = v.glyph
        v.glyph = glyph.__class__()
        v.glyph = glyph
        v.actor = v.actor.__class__()
        v.cutter = v.cutter.__class__()
        ip = v.implicit_plane
        v.implicit_plane = ip.__class__()
        v.implicit_plane = ip

        s.render()

        self.check()

        ############################################################
        # Test if saving a visualization and restoring it works.

        # Save visualization.
        f = StringIO()
        f.name = abspath('test.mv2') # We simulate a file.
        script.save_visualization(f)
        f.seek(0) # So we can read this saved data.

        # Remove existing scene.
        engine = script.engine
        engine.close_scene(s)

        # Load visualization
        script.load_visualization(f)
        s = engine.current_scene
        # Set the scene to a suitable view.
        self.set_view(s)

        self.check()

        ############################################################
        # Test if the MayaVi2 visualization can be deepcopied.

        # Pop the source object.
        sources = s.children
        s.children = []
        # Add it back to see if that works without error.
        s.children.extend(sources)

        self.set_view(s)

        self.check()

        # Now deepcopy the source and replace the existing one with
        # the copy.  This basically simulates cutting/copying the
        # object from the UI via the right-click menu on the tree
        # view, and pasting the copy back.
        sources1 = copy.deepcopy(sources)
        s.children[:] = sources

        self.set_view(s)
        self.check()

        # If we have come this far, we are golden!


if __name__ == "__main__":
    t = TestGlyph()
    t.test()

########NEW FILE########
__FILENAME__ = test_grid_plane
"""Simple test for the grid plane and outline module.
"""
# Author: Prabhu Ramachandran <prabhu_r@users.sf.net>
# Copyright (c) 2005,  Enthought, Inc.
# License: BSD Style.

# Standard library imports.
from os.path import abspath
from StringIO import StringIO
import copy

# Local imports.
from common import TestCase, get_example_data


class TestGridPlane(TestCase):
    def check(self):
        script = self.script
        s = script.engine.current_scene
        mm = s.children[0].children[0]
        gp1, gp2, gp3 = mm.children[1:]
        assert gp1.grid_plane.axis == 'x'
        assert gp1.grid_plane.position == 0
        assert gp1.actor.property.ambient == 1.0

        assert gp2.grid_plane.axis == 'y'
        assert gp2.grid_plane.position == 16
        assert gp2.actor.property.ambient == 1.0

        assert gp3.grid_plane.axis == 'z'
        assert gp3.grid_plane.position == 6
        assert gp3.actor.property.ambient == 1.0

    def test(self):
        self.main()

    def do(self):
        ############################################################
        # Imports.
        script = self.script
        from mayavi.sources.vtk_file_reader import VTKFileReader
        from mayavi.modules.outline import Outline
        from mayavi.modules.grid_plane import GridPlane

        ############################################################
        # Create a new scene and set up the visualization.
        s = self.new_scene()

        # Read a VTK (old style) data file.
        r = VTKFileReader()
        r.initialize(get_example_data('heart.vtk'))
        script.add_source(r)

        # Create an outline for the data.
        o = Outline()
        script.add_module(o)

        # Create three simple grid plane modules.
        # First normal to 'x' axis.
        gp1 = GridPlane()
        script.add_module(gp1)
        # Second normal to 'y' axis.
        gp2 = GridPlane()
        # We'll test how robust things are by setting attributes
        # *before* we add it to the scene.
        gp2.grid_plane.axis = 'y'
        gp2.grid_plane.position = 16
        script.add_module(gp2)
        # Third normal to 'z' axis.
        gp3 = GridPlane()
        script.add_module(gp3)
        gp3.grid_plane.axis = 'z'
        gp3.grid_plane.position = 6

        for gp in (gp1, gp2, gp3):
            gp.actor.property.set(ambient=1.0)

        # Set the scene to an isometric view.
        s.scene.isometric_view()

        self.check()

        ############################################################
        # Test if saving a visualization and restoring it works.

        # Save visualization.
        f = StringIO()
        f.name = abspath('test.mv2') # We simulate a file.
        script.save_visualization(f)
        f.seek(0) # So we can read this saved data.

        # Remove existing scene.
        engine = script.engine
        engine.close_scene(s)

        # Load visualization
        script.load_visualization(f)
        s = engine.current_scene

        self.check()

        ############################################################
        # Test if the MayaVi2 visualization can be deepcopied.

        # Pop the source object.
        source = s.children.pop()
        # Add it back to see if that works without error.
        s.children.append(source)

        self.check()

        # Now deepcopy the source and replace the existing one with
        # the copy.  This basically simulates cutting/copying the
        # object from the UI via the right-click menu on the tree
        # view, and pasting the copy back.
        source1 = copy.deepcopy(source)
        s.children[0] = source1

        self.check()

        # If we have come this far, we are golden!


if __name__ == "__main__":
    t = TestGridPlane()
    t.test()

########NEW FILE########
__FILENAME__ = test_hide_show
"""Test for the hide-show feature.
"""
# Author: Prabhu Ramachandran <prabhu [at] aero . iitb . ac . in>
# Copyright (c) 2008,  Enthought, Inc.
# License: BSD Style.

# Standard library imports.
from os.path import abspath
from StringIO import StringIO
import copy

# Local imports.
from common import TestCase, get_example_data


class TestHideShow(TestCase):

    def check(self, saved=False):
        """Does the checking, if saved is True it does not change the
        properties at first to see how those behave and only tests the
        final unpickled state."""
        script = self.script
        e = script.engine
        scene = e.current_scene
        wrl = scene.children[0]
        src = scene.children[1]
        mm = src.children[0]
        scp = mm.children[0]
        iso = mm.children[1]
        if not saved:
            assert scp.actor.actor.visibility == True
            assert scp.implicit_plane.widget.enabled == True
            for a in wrl.actors:
                assert a.visibility == True

            assert iso.actor.actor.visibility == True

            # Check if widget state is remembered.
            scp.implicit_plane.widget.enabled = False
            scp.visible = False
            assert scp.actor.actor.visibility == False
            assert scp.implicit_plane.widget.enabled == False
            assert scp.name == 'ScalarCutPlane [Hidden]'
            # Reenable it and check widget state.
            scp.visible = True
            assert scp.actor.actor.visibility == True
            assert scp.implicit_plane.widget.enabled == False

            # Reset the visible state.
            wrl.visible = False
            scp.visible = False
            iso.visible = False

        # Check final state.
        for a in wrl.actors:
            assert a.visibility == False
        assert wrl.name.find('[Hidden]') > -1

        assert scp.actor.actor.visibility == False
        assert scp.implicit_plane.widget.enabled == False
        assert scp.name == 'ScalarCutPlane [Hidden]'
        assert iso.name == 'IsoSurface [Hidden]'
        assert iso.actor.actor.visibility == False


    def test(self):
        self.main()

    def do(self):
        ############################################################
        # Imports.
        from mayavi.sources.api import VTKXMLFileReader,\
                VRMLImporter
        from mayavi.modules.api import ScalarCutPlane,\
                IsoSurface

        ############################################################
        # Create a new scene and set up the visualization.
        s = self.new_scene()
        script = mayavi = self.script

        # Read a VRML file.
        w = VRMLImporter()
        w.initialize(get_example_data('room_vis.wrl'))
        script.add_source(w)

        # Read a VTK data file.
        r = VTKXMLFileReader()
        r.initialize(get_example_data('fire_ug.vtu'))
        script.add_source(r)

        # Create the modules.
        scp = ScalarCutPlane()
        script.add_module(scp)

        iso = IsoSurface()
        script.add_module(iso)

        # Check.
        self.check(saved=False)

        ############################################################
        # Test if saving a visualization and restoring it works.

        # Save visualization.
        f = StringIO()
        f.name = abspath('test.mv2') # We simulate a file.
        script.save_visualization(f)
        f.seek(0) # So we can read this saved data.

        # Remove existing scene.
        engine = script.engine
        engine.close_scene(s)

        # Load visualization
        script.load_visualization(f)
        s = engine.current_scene
        s.scene.isometric_view()

        # Now do the check.
        self.check(saved=True)

        ############################################################
        # Test if the Mayavi2 visualization can be deep-copied.

        # Pop the source object.
        sources = s.children
        s.children = []
        # Add it back to see if that works without error.
        s.children.extend(sources)
        # Now do the check.
        s.scene.isometric_view()
        self.check(saved=True)

        # Now deepcopy the source and replace the existing one with
        # the copy.  This basically simulates cutting/copying the
        # object from the UI via the right-click menu on the tree
        # view, and pasting the copy back.
        sources1 = copy.deepcopy(sources)
        s.children[:] = sources1
        # Now do the check.
        s.scene.isometric_view()
        self.check(saved=True)

        # If we have come this far, we are golden!

if __name__ == "__main__":
    t = TestHideShow()
    t.test()


########NEW FILE########
__FILENAME__ = test_image_data_probe
"""Simple test for the ImageDataProbe filter.
"""
# Author: Prabhu Ramachandran <prabhu [at] aero . iitb . ac . in>
# Copyright (c) 2008,  Enthought, Inc.
# License: BSD Style.

# Standard library imports.
from os.path import abspath
from StringIO import StringIO
import copy

# Local imports.
from common import TestCase, get_example_data


class TestImageDataProbe(TestCase):

    def check(self, saved=False):
        """Does the checking, if saved is True it does not change the
        properties at first to see how those behave and only tests the
        final unpickled state."""
        script = self.script
        e = script.engine
        scene = e.current_scene
        src = scene.children[0]
        idp = src.children[0]
        mm = idp.children[0]
        if not saved:
            assert src.outputs[0].is_a('vtkUnstructuredGrid')
            assert idp.outputs[0].is_a('vtkImageData')
            sc = idp.outputs[0].point_data.scalars
            assert sc.name == 't'
            assert mm.scalar_lut_manager.data_name == 't'
            assert abs(sc.range[0]) < 1.0
            assert abs(sc.range[1] - 626.0) < 1.0

            idp.rescale_scalars = True
            idp.dimensions = (41, 19, 19)

        sc = idp.outputs[0].point_data.scalars
        assert sc.name == idp.rescaled_scalar_name
        assert mm.scalar_lut_manager.data_name == idp.rescaled_scalar_name
        assert abs(sc.range[0]) < 1e-2
        assert abs(sc.range[1] - 65535.0) < 1.e-2
        assert (idp.outputs[0].dimensions == (41, 19, 19)).all()

    def test(self):
        self.main()

    def do(self):
        ############################################################
        # Imports.
        from mayavi.filters.image_data_probe import ImageDataProbe
        from mayavi.modules.api import ContourGridPlane
        from mayavi.sources.vtk_xml_file_reader import VTKXMLFileReader

        ############################################################
        # Create a new scene and set up the visualization.
        s = self.new_scene()
        script = mayavi = self.script

        # Read a VTK (old style) data file.
        r = VTKXMLFileReader()
        r.initialize(get_example_data('fire_ug.vtu'))
        script.add_source(r)

        # Create the filters.
        idp = ImageDataProbe()
        script.add_filter(idp)
        cgp = ContourGridPlane(enable_contours=False)
        script.add_module(cgp)
        cgp.grid_plane.axis = 'z'
        cgp.grid_plane.position = 2
        s.scene.isometric_view()

        # Check.
        self.check(saved=False)
        ############################################################
        # Test if saving a visualization and restoring it works.

        # Save visualization.
        f = StringIO()
        f.name = abspath('test.mv2') # We simulate a file.
        script.save_visualization(f)
        f.seek(0) # So we can read this saved data.

        # Remove existing scene.
        engine = script.engine
        engine.close_scene(s)

        # Load visualization
        script.load_visualization(f)
        s = engine.current_scene
        s.scene.isometric_view()

        # Now do the check.
        self.check(saved=True)

        ############################################################
        # Test if the Mayavi2 visualization can be deep-copied.

        # Pop the source object.
        source = s.children.pop()
        # Add it back to see if that works without error.
        s.children.append(source)
        # Now do the check.
        s.scene.isometric_view()
        self.check(saved=True)

        # Now deepcopy the source and replace the existing one with
        # the copy.  This basically simulates cutting/copying the
        # object from the UI via the right-click menu on the tree
        # view, and pasting the copy back.
        source1 = copy.deepcopy(source)
        s.children[0] = source1
        # Now do the check.
        s.scene.isometric_view()
        self.check(saved=True)

        # If we have come this far, we are golden!

if __name__ == "__main__":
    t = TestImageDataProbe()
    t.test()


########NEW FILE########
__FILENAME__ = test_image_plane_widget
"""Tests for the ImagePlaneWidget module.
"""
# Author: Prabhu Ramachandran <prabhu_r@users.sf.net>
# Copyright (c) 2005,  Enthought, Inc.
# License: BSD Style.

# Standard library imports.
from os.path import abspath
from StringIO import StringIO
import copy
import numpy

# Enthought library imports.
from traits.api import TraitError

# Local imports.
from common import TestCase


class TestImagePlaneWidget(TestCase):
    def make_data(self):
        """Creates suitable data for the test."""
        dims = numpy.array((64, 64, 64), 'i')

        # Create some scalars to render.
        dx, dy, dz = 10.0/(dims - 1)
        x = numpy.reshape(numpy.arange(-5.0, 5.0+dx*0.5, dx, 'f'),
                          (dims[0], 1, 1))
        y = numpy.reshape(numpy.arange(-5.0, 5.0+dy*0.5, dy, 'f'),
                          (1, dims[1], 1))
        z = numpy.reshape(numpy.arange(-5.0, 5.0+dz*0.5, dz, 'f'),
                          (1, 1, dims[0]))
        scalars = numpy.sin(x*y*z)/(x*y*z)
        return scalars

    def set_view(self, s):
        """Sets the view correctly."""
        #s.scene.reset_zoom()
        s.scene.z_plus_view()
        c = s.scene.camera
        c.azimuth(30)
        c.elevation(30)
        s.render()

    def check(self):
        script = self.script
        src = script.engine.current_scene.children[0]
        i1, i2, i3 = src.children[0].children[1:]
        assert i1.ipw.plane_orientation == 'x_axes'
        assert numpy.allclose(i1.ipw.center, (0, 31.5, 31.5))
        rng = i1.ipw.reslice_output.point_data.scalars.range
        assert numpy.allclose(rng, (-0.2, 1.0), atol=0.1)
        assert i2.ipw.plane_orientation == 'y_axes'
        assert numpy.allclose(i2.ipw.center, (31.5, 0, 31.5))
        rng = i2.ipw.reslice_output.point_data.scalars.range
        assert numpy.allclose(rng, (-0.2, 1.0), atol=0.1)
        assert i3.ipw.plane_orientation == 'z_axes'
        assert numpy.allclose(i3.ipw.center, (31.5, 31.5, 0))
        rng = i3.ipw.reslice_output.point_data.scalars.range
        assert numpy.allclose(rng, (-0.2, 1.0), atol=0.1)

    def test(self):
        self.main()

    def do(self):
        ############################################################
        # Imports.
        script = self.script
        from mayavi.sources.array_source import ArraySource
        from mayavi.modules.outline import Outline
        from mayavi.modules.image_plane_widget import ImagePlaneWidget

        ############################################################
        # Create a new scene and set up the visualization.
        s = self.new_scene()

        d = ArraySource()
        sc = self.make_data()
        d.scalar_data = sc

        script.add_source(d)

        # Create an outline for the data.
        o = Outline()
        script.add_module(o)
        # ImagePlaneWidgets for the scalars
        ipw = ImagePlaneWidget()
        script.add_module(ipw)

        ipw_y = ImagePlaneWidget()
        script.add_module(ipw_y)
        ipw_y.ipw.plane_orientation = 'y_axes'

        ipw_z = ImagePlaneWidget()
        script.add_module(ipw_z)
        ipw_z.ipw.plane_orientation = 'z_axes'

        # Set the scene to a suitable view.
        self.set_view(s)

        self.check()

        ############################################################
        # Test if saving a visualization and restoring it works.

        # Save visualization.
        f = StringIO()
        f.name = abspath('test.mv2') # We simulate a file.
        script.save_visualization(f)
        f.seek(0) # So we can read this saved data.

        # Remove existing scene.
        engine = script.engine
        engine.close_scene(s)

        # Load visualization
        script.load_visualization(f)
        s = engine.current_scene
        # Set the scene to a suitable view.
        self.set_view(s)

        self.check()

        ############################################################
        # Test if the MayaVi2 visualization can be deepcopied.

        # Pop the source object.
        sources = s.children
        s.children = []
        # Add it back to see if that works without error.
        s.children.extend(sources)

        self.set_view(s)

        self.check()

        # Now deepcopy the source and replace the existing one with
        # the copy.  This basically simulates cutting/copying the
        # object from the UI via the right-click menu on the tree
        # view, and pasting the copy back.
        sources1 = copy.deepcopy(sources)
        s.children[:] = sources

        self.set_view(s)

        self.check()

        # If we have come this far, we are golden!


if __name__ == "__main__":
    t = TestImagePlaneWidget()
    t.test()

########NEW FILE########
__FILENAME__ = test_ipw_multiple_scalars

# Author: Prabhu Ramachandran <prabhu [at] aero . iitb . ac . in>
# Copyright (c) 2009,  Prabhu Ramachandran
# License: BSD Style.

# Local imports.
from common import TestCase
from numpy import zeros, random
from tvtk.api import tvtk
from tvtk.common import is_old_pipeline

class TestIPWMultipleScalars(TestCase):

    """Tests the IPW with multiple scalars.  We have this in addition to
    the unittests since some of these errors only show up when the view
    is active."""

    def test(self):
        self.main()

    def do(self):
        ############################################################
        # Imports.
        script = self.script
        from mayavi.sources.vtk_data_source import VTKDataSource
        from mayavi.modules.api import ImagePlaneWidget

        # Create dataset with multiple scalars.
        arr1 = zeros(27, 'f')
        for n in range(27):
            arr1[n] = (1+float(n))/10.0
        arr2 = (arr1 + 1).astype('d')
        arr3 = arr1 + 2.0*(0.5 - random.random(27))
        arr3 = arr3.astype('f')

        p = tvtk.ImageData(dimensions=[3,3,3], spacing=[1,1,1])
        if is_old_pipeline():
            p.scalar_type = 'int'

        p.point_data.scalars = arr1
        p.point_data.scalars.name = 'first'
        j2 = p.point_data.add_array(arr2)
        p.point_data.get_array(j2).name='second'
        j3 = p.point_data.add_array(arr3)
        p.point_data.get_array(j3).name='third'
        if is_old_pipeline():
            p.update()

        # Make the pipeline.
        self.new_scene()
        src = VTKDataSource(data=p)
        script.add_source(src)
        ipw = ImagePlaneWidget()
        script.add_module(ipw)

        # Test.
        ipw = ipw.ipw
        scalars = ipw.input.point_data.scalars
        r = scalars.range
        expect = min(arr1), max(arr1)
        assert r == expect
        o = src.outputs[0]
        o.update_traits()
        if is_old_pipeline():
            st = ipw.input.scalar_type
            assert scalars.data_type == 10
            assert st == 'float'

        src.point_scalars_name = 'second'
        scalars = ipw.input.point_data.scalars
        r = scalars.range
        expect = min(arr2), max(arr2)
        assert r == expect
        o.update_traits()
        if is_old_pipeline():
            st = ipw.input.scalar_type
            assert scalars.data_type == 11
            assert st == 'double'

        src.point_scalars_name = 'third'
        scalars = ipw.input.point_data.scalars
        r = scalars.range
        expect = min(arr3), max(arr3)
        assert r == expect
        o.update_traits()
        if is_old_pipeline():
            st = ipw.input.scalar_type
            assert scalars.data_type == 10
            assert st == 'float'


if __name__ == '__main__':
    t = TestIPWMultipleScalars()
    t.test()

########NEW FILE########
__FILENAME__ = test_labels
"""Simple test for the ImageDataProbe filter.
"""
# Author: Prabhu Ramachandran <prabhu [at] aero . iitb . ac . in>
# Copyright (c) 2008,  Enthought, Inc.
# License: BSD Style.

# Standard library imports.
from os.path import abspath
from StringIO import StringIO
import copy

# Local imports.
from common import TestCase, get_example_data


class TestLabels(TestCase):

    def check(self, saved=False):
        """Does the checking, if saved is True it does not change the
        properties at first to see how those behave and only tests the
        final unpickled state."""
        script = self.script
        e = script.engine
        scene = e.current_scene
        src = scene.children[0]
        mm = src.children[0]
        l = mm.children[1]
        if not saved:
            np = l.visible_points.outputs[0].number_of_points
            assert np < 35 and np > 20
            l.visible_points.enabled = True
            l.mapper.label_mode = 'label_scalars'
            l.label_format = '%.1f'
            l.number_of_labels = 45
            l.property.color = (0,0,0)
            l.property.italic = False

        np = l.visible_points.outputs[0].number_of_points
        assert np < 60  and np > 35
        assert l.visible_points.enabled == True
        assert l.visible_points.outputs[0] == \
            l.visible_points.filter.filter.output
        assert l.property.color == (0,0,0)
        assert l.property.italic == False
        assert l.mapper.label_mode == 'label_scalars'
        assert l.label_format == '%.1f'


    def test(self):
        self.main()

    def do(self):
        ############################################################
        # Imports.
        from mayavi.modules.api import ScalarCutPlane
        from mayavi.modules.labels import Labels
        from mayavi.sources.vtk_xml_file_reader import VTKXMLFileReader

        ############################################################
        # Create a new scene and set up the visualization.
        s = self.new_scene()
        script = mayavi = self.script

        # Read a VTK (old style) data file.
        r = VTKXMLFileReader()
        r.initialize(get_example_data('fire_ug.vtu'))
        script.add_source(r)

        # Create the filters.
        cp = ScalarCutPlane()
        script.add_module(cp)
        l = Labels(object=cp)
        script.add_module(l)

        s.scene.isometric_view()
        self.check(saved=False)
        ############################################################
        # Test if saving a visualization and restoring it works.

        # Save visualization.
        f = StringIO()
        f.name = abspath('test.mv2') # We simulate a file.
        script.save_visualization(f)
        f.seek(0) # So we can read this saved data.

        # Remove existing scene.
        engine = script.engine
        engine.close_scene(s)

        # Load visualization
        script.load_visualization(f)
        s = engine.current_scene
        s.scene.isometric_view()

        # Seems to be needed for the test to pass. :(  Just flushes the
        # pipeline.
        s.children[0].pipeline_changed = True

        # Check.
        # Now do the check.
        self.check(saved=True)

        ############################################################
        # Test if the Mayavi2 visualization can be deep-copied.

        # Pop the source object.
        source = s.children.pop()
        # Add it back to see if that works without error.
        s.children.append(source)
        # Now do the check.
        s.scene.isometric_view()
        self.check(saved=True)

        # Now deepcopy the source and replace the existing one with
        # the copy.  This basically simulates cutting/copying the
        # object from the UI via the right-click menu on the tree
        # view, and pasting the copy back.
        source1 = copy.deepcopy(source)
        s.children[0] = source1
        # Now do the check.
        s.scene.isometric_view()
        self.check(saved=True)

        # If we have come this far, we are golden!

if __name__ == "__main__":
    t = TestLabels()
    t.test()

########NEW FILE########
__FILENAME__ = test_mlab
"""Tests for the mlab interface to Mayavi
"""
# Author: Gael Varoquaux
# Copyright (c) 2008,  Enthought, Inc.
# License: BSD Style.

# Standard library imports.
from inspect import getmembers
import sys
from time import sleep

# Enthought library imports
from pyface.api import GUI

# Local imports.
from common import TestCase

def is_timer_running(timer):
    """Written to work around a pyface bug.
    """
    if hasattr(timer, 'isActive'):
        # The Qt backend's IsRunning does not work correctly.
        return timer.isActive()
    else:
        return timer.IsRunning()


def run_mlab_examples():
    from mayavi import mlab
    from mayavi.tools.animator import Animator

    ############################################################
    # run all the "test_foobar" functions in the mlab module.
    for name, func in getmembers(mlab):
        if not callable(func) or not name[:4] in ('test', 'Test'):
            continue

        if sys.platform == 'win32' and name == 'test_mesh_mask_custom_colors':
            # fixme: This test does not seem to work on win32, disabling for now.
            continue

        mlab.clf()
        GUI.process_events()
        obj = func()

        if isinstance(obj, Animator):
            obj.delay = 10
            # Close the animation window.
            obj.close()
            while is_timer_running(obj.timer):
                GUI.process_events()
                sleep(0.05)

        # Mayavi has become too fast: the operator cannot see if the
        # Test function was succesful.
        GUI.process_events()
        sleep(0.1)


class TestMlab(TestCase):

    def test(self):
        self.main()

    def do(self):
        ############################################################
        # Imports.
        from mayavi import mlab

        ############################################################
        # Create a new scene and set up the visualization.
        s = self.new_scene()
        s.scene.isometric_view()

        ############################################################
        # run all the "test_foobar" functions in the mlab module.
        run_mlab_examples()

        ############################################################
        # Test some specific corner-cases
        import numpy
        x, y, z = numpy.mgrid[1:10, 1:10, 1:10]
        u, v, w = numpy.mgrid[1:10, 1:10, 1:10]
        s = numpy.sqrt(u**2 + v**2)

        mlab.clf()
        # Test the extra argument "scalars"
        mlab.quiver3d(x, y, z, u, v, w, scalars=s)

        # Test surf with strange-shaped inputs
        X, Y = numpy.ogrid[-10:10, -10:10]
        Z = X**2 + Y**2
        mlab.surf(X, Y, Z)
        mlab.surf(X.ravel(), Y.ravel(), Z)

        x, y, z = numpy.mgrid[-10:10, -10:10, -3:2]
        mlab.flow(x, y, z)

        # Test glyphs with number-only coordinnates
        mlab.points3d(0, 0, 0, resolution=50)

if __name__ == "__main__":
    t = TestMlab()
    t.test()

########NEW FILE########
__FILENAME__ = test_mlab_envisage
from mayavi import mlab
from pyface.api import GUI

def close():
    """Close the scene."""
    f = mlab.gcf()
    e = mlab.get_engine()
    e.window.workbench.prompt_on_exit = False
    e.window.close()
    mlab.options.backend = 'auto'
    # Hack: on Linux the splash screen does not go away so we force it.
    GUI.invoke_after(500, e.window.workbench.application.gui.stop_event_loop)

def test_mlab_envisage():
    "Test if mlab runs correctly when the backend is set to 'envisage'."
    @mlab.show
    def f():
        from mayavi.preferences.api import preference_manager
        preference_manager.root.show_splash_screen = False
        mlab.options.backend = 'envisage'
        mlab.test_contour3d()
        GUI.invoke_after(3000, close)

    f()

if __name__ == '__main__':
    test_mlab_envisage()

########NEW FILE########
__FILENAME__ = test_mlab_show
"""Test for the mlab.show function/decorator."""

from mayavi import mlab
from pyface.api import GUI

from test_mlab import run_mlab_examples

def close():
    """Close the scene."""
    f = mlab.gcf()
    e = mlab.get_engine()
    v = e.get_viewer(f)
    v.close()

def test_mlab_show():
    """Test mlab.show()"""
    run_mlab_examples()
    # Automatically close window in 100 msecs.
    GUI.invoke_after(100, close)
    mlab.show()

def test_show_decorator():
    """Test the @mlab.show decorator"""
    @mlab.show
    def f():
        run_mlab_examples()
        # Automatically close window in 100 msecs.
        GUI.invoke_after(100, close)
    f()

if __name__ == '__main__':
    test_mlab_show()
    test_show_decorator()

########NEW FILE########
__FILENAME__ = test_optional_collection
"""Simple test for the Optional and Collection filters.
"""
# Author: Prabhu Ramachandran <prabhu [at] aero . iitb . ac . in>
# Copyright (c) 2008,  Prabhu Ramachandran
# License: BSD Style.

# Standard library imports.
from os.path import abspath
from StringIO import StringIO
import copy

# Local imports.
from common import TestCase, get_example_data


class TestOptionalCollection(TestCase):

    def test(self):
        self.main()

    def do(self):
        ############################################################
        # Imports.
        script = self.script
        from mayavi.sources.vtk_file_reader import VTKFileReader
        from mayavi.filters.contour import Contour
        from mayavi.filters.optional import Optional
        from mayavi.filters.collection import Collection
        from mayavi.filters.api import PolyDataNormals
        from mayavi.modules.api import Surface

        ############################################################
        # Create a new scene and set up the visualization.
        s = self.new_scene()

        # Read a VTK (old style) data file.
        r = VTKFileReader()
        r.initialize(get_example_data('heart.vtk'))
        script.add_source(r)

        c = Contour()
        # `name` is used for the notebook tabs.
        n = PolyDataNormals(name='Normals')
        o = Optional(filter=n, label_text='Compute normals')
        coll = Collection(filters=[c, o], name='IsoSurface')
        script.add_filter(coll)
        s = Surface()
        script.add_module(s)

        ########################################
        # do the testing.
        def check(coll):
            """Check if test status is OK given the collection."""
            c, o = coll.filters
            c = c.filter
            n = o.filter
            assert coll.outputs[0].point_data.scalars.range == (127.5, 127.5)
            # Adding a contour should create the appropriate output in
            # the collection.
            c.contours.append(200)
            assert coll.outputs[0].point_data.scalars.range == (127.5, 200.0)
            # the collection's output should be that of the normals.
            assert coll.outputs[0] is n.outputs[0]
            # disable the optional filter and check.
            o.enabled = False
            assert 'disabled' in o.name
            assert coll.outputs[0] is c.outputs[0]
            # Set back everything to original state.
            c.contours.pop()
            o.enabled = True
            assert coll.outputs[0].point_data.scalars.range == (127.5, 127.5)
            assert coll.outputs[0] is n.outputs[0]
            assert 'disabled' not in o.name

        check(coll)

        ############################################################
        # Test if saving a visualization and restoring it works.

        # Save visualization.
        f = StringIO()
        f.name = abspath('test.mv2') # We simulate a file.
        script.save_visualization(f)
        f.seek(0) # So we can read this saved data.

        # Remove existing scene.
        engine = script.engine
        engine.close_scene(s)

        # Load visualization
        script.load_visualization(f)
        s = engine.current_scene

        # Now do the check.
        coll = s.children[0].children[0]
        check(coll)

        ############################################################
        # Test if the Mayavi2 visualization can be deep-copied.

        # Pop the source object.
        source = s.children.pop()
        # Add it back to see if that works without error.
        s.children.append(source)
        # Now do the check.
        coll = s.children[0].children[0]
        check(coll)

        # Now deepcopy the source and replace the existing one with
        # the copy.  This basically simulates cutting/copying the
        # object from the UI via the right-click menu on the tree
        # view, and pasting the copy back.
        source1 = copy.deepcopy(source)
        s.children[0] = source1
        # Now do the check.
        coll = s.children[0].children[0]
        check(coll)

        # If we have come this far, we are golden!

if __name__ == "__main__":
    t = TestOptionalCollection()
    t.test()


########NEW FILE########
__FILENAME__ = test_plot3d_mb_reader
"""Test for the PLOT3D reader and its multiblock capabilities.  This
also tests the SelectOutput filter.
"""

# Author: Prabhu Ramachandran <prabhu [at] aero . iitb . ac . in>
# Copyright (c) 2008,  Prabhu Ramachandran
# License: BSD Style.

# Standard library imports.
from os.path import abspath
from StringIO import StringIO
import copy

# Local imports.
from common import TestCase, get_example_data


class TestPLOT3DReader(TestCase):
    def test(self):
        self.main()

    def do(self):
        ############################################################
        # Imports.
        script = self.script
        from mayavi.sources.plot3d_reader import PLOT3DReader
        from mayavi.filters.select_output import SelectOutput
        from mayavi.modules.outline import Outline

        ############################################################
        # Create a new scene and set up the visualization.
        s = self.new_scene()

        # Read the multi-block plot3d file.
        r = PLOT3DReader()
        r.reader.set(has_byte_count=True, multi_grid=True,
                     byte_order='little_endian')
        r.initialize(get_example_data('tiny.xyz'),
                     get_example_data('tiny.q'),
                     configure=False)

        script.add_source(r)

        # Add the filter.
        f = SelectOutput()
        script.add_filter(f)

        # Create an outline for the data.
        o = Outline()
        script.add_module(o)

        # Check the bounds of the outline.
        assert o.outline_filter.output.bounds == (1.0, 2.0, 1.0, 2.0, 1.0, 2.0)

        # Copy the reader to see if it does not pop up the UI.
        r1 = copy.deepcopy(r)
        script.add_source(r1)
        s.render()

        o1 = r1.children[0].children[0].children[0]
        assert o1.outline_filter.output.bounds == (1.0, 2.0, 1.0, 2.0, 1.0, 2.0)
        r1.children[0].output_index = 1
        assert o1.outline_filter.output.bounds == (2.0, 3.0, 1.0, 2.0, 1.0, 2.0)

        ############################################################
        # Test if saving a visualization and restoring it works.

        # Save visualization.
        f = StringIO()
        f.name = abspath('test.mv2') # We simulate a file.
        script.save_visualization(f)
        f.seek(0) # So we can read this saved data.

        # Remove existing scene.
        engine = script.engine
        engine.close_scene(s)

        # Load visualization
        script.load_visualization(f)
        s = engine.current_scene

        o = s.children[0].children[0].children[0].children[0]
        o1 = s.children[1].children[0].children[0].children[0]

        assert o.outline_filter.output.bounds == (1.0, 2.0, 1.0, 2.0, 1.0, 2.0)
        assert o1.outline_filter.output.bounds == (2.0, 3.0, 1.0, 2.0, 1.0, 2.0)

        # If we have come this far, we are golden!
        return


if __name__ == "__main__":
    t = TestPLOT3DReader()
    t.test()



########NEW FILE########
__FILENAME__ = test_set_active_attribute
# Author: Prabhu Ramachandran <prabhu [at] aero . iitb . ac . in>
# Copyright (c) 2008,  Enthought, Inc.
# License: BSD Style.

# Standard library imports.
from os.path import abspath
from StringIO import StringIO
import copy

# Local imports.
from common import TestCase, get_example_data


class TestSetActiveAttribute(TestCase):
    def check(self):
        """Check if the visualization is OK.  Note that this is not an
        image based check, which is very convenient.
        """
        e = self.script.engine
        scene = e.current_scene
        src = scene.children[0]
        assert src.point_scalars_name == 'u'
        c = src.children[1]
        sc = c.outputs[0].point_data.scalars
        assert sc.name == 'u'
        # It is an iso-contour!
        assert sc.range[0] == sc.range[1]
        aa = c.children[0].children[0]
        assert aa.point_scalars_name == 't'
        sc = aa.outputs[0].point_data.scalars
        assert sc.name == 't'
        assert abs(sc.range[0] - 308) < 1.0
        assert abs(sc.range[1] - 631) < 1.0
        s = aa.children[0].children[0]

    def test(self):
        self.main()

    def do(self):
        """Test for the SetActiveAttribute filter.
        """
        from mayavi.sources.api import VTKXMLFileReader
        from mayavi.filters.contour import Contour
        from mayavi.filters.api import PolyDataNormals
        from mayavi.filters.set_active_attribute import SetActiveAttribute
        from mayavi.modules.api import Surface, Outline

        mayavi = script = self.script

        scene = self.new_scene()
        r = VTKXMLFileReader()
        r.initialize(get_example_data('fire_ug.vtu'))
        mayavi.add_source(r)
        r.point_scalars_name = 'u'
        o = Outline()
        mayavi.add_module(o)
        c = Contour()
        mayavi.add_filter(c)
        n = PolyDataNormals()
        mayavi.add_filter(n)
        aa = SetActiveAttribute()
        mayavi.add_filter(aa)
        aa.point_scalars_name = 't'
        s = Surface()
        mayavi.add_module(s)

        scene.scene.isometric_view()
        # Check if things are OK.
        self.check()

        ############################################################
        # Test if saving a visualization and restoring it works.

        # Save visualization.
        f = StringIO()
        f.name = abspath('test.mv2') # We simulate a file.
        mayavi.save_visualization(f)
        f.seek(0) # So we can read this saved data.

        # Remove existing scene.
        engine = mayavi.engine
        engine.close_scene(s)

        # Load visualization
        mayavi.load_visualization(f)
        s = engine.current_scene

        # Now do the check.
        s.scene.isometric_view()
        self.check()

        ############################################################
        # Test if the Mayavi2 visualization can be deep-copied.

        # Pop the source object.
        source = s.children.pop()
        # Add it back to see if that works without error.
        s.children.append(source)
        # Now do the check.
        self.check()

        # Now deepcopy the source and replace the existing one with
        # the copy.  This basically simulates cutting/copying the
        # object from the UI via the right-click menu on the tree
        # view, and pasting the copy back.
        source1 = copy.deepcopy(source)
        s.children[0] = source1
        # Now do the check.
        s.scene.isometric_view()
        self.check()

        # If we have come this far, we are golden!

if __name__ == '__main__':
    t = TestSetActiveAttribute()
    t.test()

########NEW FILE########
__FILENAME__ = test_streamline
"""Tests for the Streamline module.

This module uses the compare_image function to perform image based
testing.  This is so just to illustrate how you could use image based
tests.  However, we recommend that one does not use image based tests
since they are not always reliable and a pain.
"""
# Author: Prabhu Ramachandran <prabhu_r@users.sf.net>
# Copyright (c) 2005-2008,  Enthought, Inc.
# License: BSD Style.

# Standard library imports.
from os.path import abspath
from StringIO import StringIO
import copy
import numpy
import sys


# Local imports.
from common import TestCase, is_running_with_nose


class TestStreamline(TestCase):
    def make_data(self):
        """Trivial data -- creates an elementatry scalar field and a
        constant vector field along the 'x' axis."""
        s = numpy.arange(0.0, 10.0, 0.01)
        s = numpy.reshape(s, (10,10,10))
        s = numpy.transpose(s)

        v = numpy.zeros(3000, 'd')
        v[::3] = 1.0
        v = numpy.reshape(v, (10,10,10,3))
        return s, v


    def test(self):
        if is_running_with_nose():
            import unittest
            raise unittest.SkipTest('This test Segfaults after passing or fails.')
        self.main()

    def do(self):
        ############################################################
        # Imports.
        script = self.script
        from mayavi.sources.array_source import ArraySource
        from mayavi.modules.outline import Outline
        from mayavi.modules.streamline import Streamline

        ############################################################
        # Create a new scene and set up the visualization.
        s = self.new_scene()

        d = ArraySource()
        sc, vec = self.make_data()
        d.origin = (-5, -5, -5)
        d.scalar_data = sc
        d.vector_data = vec

        script.add_source(d)

        # Create an outline for the data.
        o = Outline()
        script.add_module(o)
        # View the data.
        st = Streamline()
        script.add_module(st)
        widget = st.seed.widget
        widget.set(radius=1.0, center=(-4.0, -4.0, -4.0),
                   theta_resolution=4, phi_resolution=4)

        st = Streamline(streamline_type='ribbon')
        seed = st.seed
        seed.widget = seed.widget_list[1]
        script.add_module(st)
        seed.widget.set(point1=(-5.0, -4.5, -4.0), point2=(-5.0, -4.5, 4.0))
        st.ribbon_filter.width = 0.25

        st = Streamline(streamline_type='tube')
        seed = st.seed
        seed.widget = seed.widget_list[2]
        script.add_module(st)
        seed.widget.set(center=(-5.0, 1.5, -2.5))
        st.tube_filter.radius = 0.15

        st = Streamline(streamline_type='tube')
        seed = st.seed
        seed.widget = seed.widget_list[3]
        script.add_module(st)
        seed.widget.position=(-5.0, 3.75, 3.75)
        st.tube_filter.radius = 0.2

        # Set the scene to a suitable view.
        s.scene.z_plus_view()
        c = s.scene.camera
        c.azimuth(-30)
        c.elevation(30)
        s.render()

        # Update the streamlines.
        mm = o.module_manager
        for child in mm.children[1:]:
            child.update_streamlines = True

        # Now compare the image.
        self.compare_image(s, 'images/test_streamline.png')

        ############################################################
        # Test if the modules respond correctly when the components
        # are changed.

        tf = st.tube_filter
        st.tube_filter = tf.__class__()
        st.tube_filter = tf
        st.ribbon_filter = st.ribbon_filter.__class__()
        seed = st.seed
        st.seed = seed.__class__()
        st.seed = seed
        st.actor = st.actor.__class__()
        tracer = st.stream_tracer
        st.stream_tracer = tracer.__class__()
        st.stream_tracer = tracer

        s.render()
        # Now compare the image.
        self.compare_image(s, 'images/test_streamline.png')
        s.render()

        ############################################################
        # Test if saving a visualization and restoring it works.

        bg = s.scene.background
        # Save visualization.
        f = StringIO()
        f.name = abspath('test.mv2') # We simulate a file.
        script.save_visualization(f)
        f.seek(0) # So we can read this saved data.

        # Remove existing scene.
        engine = script.engine
        engine.close_scene(s)

        # Load visualization
        script.load_visualization(f)
        s = engine.current_scene

        # Set the scene to a suitable view.
        s.scene.z_plus_view()
        c = s.scene.camera
        c.azimuth(-30)
        c.elevation(30)
        s.render()
        s.scene.background = bg

        # Now compare the image.
        self.compare_image(s, 'images/test_streamline.png')

        ############################################################
        # Test if the MayaVi2 visualization can be deepcopied.

        # Pop the source object.
        sources = s.children
        s.children = []
        # Add it back to see if that works without error.
        s.children.extend(sources)

        s.scene.reset_zoom()
        # Now compare the image.
        self.compare_image(s, 'images/test_streamline.png')

        # Now deepcopy the source and replace the existing one with
        # the copy.  This basically simulates cutting/copying the
        # object from the UI via the right-click menu on the tree
        # view, and pasting the copy back.
        sources1 = copy.deepcopy(sources)
        s.children[:] = sources
        s.scene.reset_zoom()
        self.compare_image(s, 'images/test_streamline.png')

        # If we have come this far, we are golden!


if __name__ == "__main__":
    t = TestStreamline()
    t.test()

########NEW FILE########
__FILENAME__ = test_user_defined
"""Simple test for the UsedDefined filter.
"""
# Author: Prabhu Ramachandran <prabhu [at] aero . iitb . ac . in>
# Copyright (c) 2008,  Enthought, Inc.
# License: BSD Style.

# Standard library imports.
from os.path import abspath
from StringIO import StringIO
import copy

# Enthought library imports.
from tvtk.api import tvtk

# Local imports.
from common import TestCase, get_example_data


class TestUserDefined(TestCase):

    def check(self, saved=False):
        """Does the checking, if saved is True it does not change the
        properties at first to see how those behave and only tests the
        final unpickled state."""
        script = self.script
        e = script.engine
        scene = e.current_scene
        src = scene.children[0]
        ud = src.children[0]
        o = ud.children[0].children[0].children[0]
        mm = o.children[0]
        if not saved:
            assert ud.filter.vector_mode == 'compute_gradient'
            assert src.outputs[0].point_data.scalars.name == 't'
            assert src.outputs[0].point_data.vectors.name == 'uvw'
            expect = ['ScalarGradient', 'Vorticity']
            expect1 = [x +'-y' for x in expect]
            expect2 = [x + ' magnitude' for x in expect]
            # FIXME: This is really a bug in VTK, the name of the scalar
            # should really be ScalarGradient-y.  This is fixed in
            # 5.2 but earlier versions fail.
            assert o.outputs[0].point_data.scalars.name in expect1
            assert o.outputs[0].point_data.vectors.name in expect
            assert mm.scalar_lut_manager.data_name in expect1
            # Turn of extraction.
            o.enabled = False
            assert o.outputs[0].point_data.scalars.name in expect2
            assert o.outputs[0].point_data.vectors.name in expect
            assert mm.scalar_lut_manager.data_name in expect2

            # Compute the vorticity
            ud.filter.vector_mode = 'compute_vorticity'
        assert o.outputs[0].point_data.scalars.name == 'Vorticity magnitude'
        assert o.outputs[0].point_data.vectors.name == 'Vorticity'
        assert mm.scalar_lut_manager.data_name == 'Vorticity magnitude'
        # Turn on extraction.
        o.enabled = True
        assert o.outputs[0].point_data.scalars.name == 'Vorticity-y'
        assert o.outputs[0].point_data.vectors.name == 'Vorticity'
        assert mm.scalar_lut_manager.data_name == 'Vorticity-y'
        # Turn off extraction.
        o.enabled = False


    def test(self):
        self.main()

    def do(self):
        ############################################################
        # Imports.
        from mayavi.filters.optional import Optional
        from mayavi.filters.user_defined import UserDefined
        from mayavi.filters.api import (CellToPointData,
                ExtractVectorNorm, ExtractVectorComponents)
        from mayavi.modules.api import ScalarCutPlane
        from mayavi.sources.vtk_xml_file_reader import VTKXMLFileReader

        ############################################################
        # Create a new scene and set up the visualization.
        s = self.new_scene()
        script = mayavi = self.script

        # Read a VTK (old style) data file.
        r = VTKXMLFileReader()
        r.initialize(get_example_data('fire_ug.vtu'))
        script.add_source(r)

        # Create the filters.
        # CellDerivatives
        cd = tvtk.CellDerivatives()
        ud = UserDefined(filter=cd)
        script.add_filter(ud)
        ctp = CellToPointData()
        ctp.filter.pass_cell_data = False
        script.add_filter(ctp)
        evn = ExtractVectorNorm()
        script.add_filter(evn)
        evc = ExtractVectorComponents(component='y-component')
        o = Optional(filter=evc)
        script.add_filter(o)

        script.add_module(ScalarCutPlane())
        s.scene.isometric_view()

        # Check.
        self.check(saved=False)
        ############################################################
        # Test if saving a visualization and restoring it works.

        # Save visualization.
        f = StringIO()
        f.name = abspath('test.mv2') # We simulate a file.
        script.save_visualization(f)
        f.seek(0) # So we can read this saved data.

        # Remove existing scene.
        engine = script.engine
        engine.close_scene(s)

        # Load visualization
        script.load_visualization(f)
        s = engine.current_scene
        s.scene.isometric_view()

        # Now do the check.
        self.check(saved=True)

        ############################################################
        # Test if the Mayavi2 visualization can be deep-copied.

        # Pop the source object.
        source = s.children.pop()
        # Add it back to see if that works without error.
        s.children.append(source)
        # Now do the check.
        s.scene.isometric_view()
        self.check(saved=True)

        # Now deepcopy the source and replace the existing one with
        # the copy.  This basically simulates cutting/copying the
        # object from the UI via the right-click menu on the tree
        # view, and pasting the copy back.
        source1 = copy.deepcopy(source)
        s.children[0] = source1
        # Now do the check.
        s.scene.isometric_view()
        self.check(saved=True)

        # If we have come this far, we are golden!

if __name__ == "__main__":
    t = TestUserDefined()
    t.test()


########NEW FILE########
__FILENAME__ = test_vtk_data_source
"""Simple test for the VTKDataSource source.  This is basically a copy
of test_contour.py with the data source alone modified.
"""
# Author: Prabhu Ramachandran <prabhu_r@users.sf.net>
# Copyright (c) 2005,  Enthought, Inc.
# License: BSD Style.

# Standard library imports.
from os.path import abspath
from StringIO import StringIO
import copy

# Local imports.
from common import get_example_data
from test_contour import TestContour


class TestVTKDataSource(TestContour):
    def make_data(self):
        script = self.script
        from mayavi.sources.vtk_data_source import VTKDataSource
        from tvtk.api import tvtk

        ############################################################
        # Create a new scene and set up the visualization.
        s = self.new_scene()

        # Read a VTK (old style) data file.
        r = tvtk.StructuredPointsReader()
        r.file_name = get_example_data('heart.vtk')
        r.update()
        d = VTKDataSource(data=r.output)
        script.add_source(d)

    def test(self):
        self.main()

    def do(self):
        # Setup the source.
        self.make_data()

        from mayavi.modules.outline import Outline
        from mayavi.modules.iso_surface import IsoSurface
        from mayavi.modules.contour_grid_plane \
             import ContourGridPlane
        from mayavi.modules.scalar_cut_plane import ScalarCutPlane
        script = self.script
        s = script.engine.current_scene
        # Create an outline for the data.
        o = Outline()
        script.add_module(o)

        # Create one ContourGridPlane normal to the 'x' axis.
        cgp = ContourGridPlane()
        script.add_module(cgp)
        # Set the position to the middle of the data.
        cgp.grid_plane.position = 15

        # Another with filled contours normal to 'y' axis.
        cgp = ContourGridPlane()
        cgp.contour.filled_contours = True
        # Set the axis and position to the middle of the data.
        cgp.grid_plane.axis = 'y'
        cgp.grid_plane.position = 15
        script.add_module(cgp)

        # An isosurface module.
        iso = IsoSurface(compute_normals=True)
        script.add_module(iso)
        iso.contour.contours = [200.0]

        # An interactive scalar cut plane.
        cp = ScalarCutPlane()
        script.add_module(cp)
        ip = cp.implicit_plane
        ip.normal = 0,0,1
        ip.origin = 0,0,5
        ip.widget.enabled = False

        # Set the scene to an isometric view.
        s.scene.isometric_view()

        self.check()

        ############################################################
        # Test if saving a visualization and restoring it works.

        # Save visualization.
        f = StringIO()
        f.name = abspath('test.mv2') # We simulate a file.
        script.save_visualization(f)
        f.seek(0) # So we can read this saved data.

        # Remove existing scene.
        engine = script.engine
        engine.close_scene(s)

        # Load visualization
        script.load_visualization(f)
        s = engine.current_scene

        self.check()

        ############################################################
        # Test if the MayaVi2 visualization can be deep-copied.

        # Pop the source object.
        source = s.children.pop()
        # Add it back to see if that works without error.
        s.children.append(source)
        # Now set the enabled status of the widget, this is impossible
        # to get correctly.
        cp = source.children[0].children[-1]
        cp.implicit_plane.widget.enabled = False
        self.check()

        # Now deepcopy the source and replace the existing one with
        # the copy.  This basically simulates cutting/copying the
        # object from the UI via the right-click menu on the tree
        # view, and pasting the copy back.
        source1 = copy.deepcopy(source)
        s.children[0] = source1
        cp = source1.children[0].children[-1]
        cp.implicit_plane.widget.enabled = False
        self.check()

        # If we have come this far, we are golden!


if __name__ == "__main__":
    t = TestVTKDataSource()
    t.test()

########NEW FILE########
__FILENAME__ = test_vtk_xml_reader
"""Simple test to check the VTK XML reader -- this is basically a copy
of test_contour.py with just the reader changed.
"""
# Author: Prabhu Ramachandran <prabhu_r@users.sf.net>
# Copyright (c) 2005-2008,  Enthought, Inc.
# License: BSD Style.

# Standard library imports.
from os.path import abspath
from StringIO import StringIO
import copy

# Local imports.
from common import TestCase, get_example_data
from test_vtk_data_source import TestVTKDataSource

class TestVTKXMLReader(TestVTKDataSource):
    def make_data(self):
        script = self.script
        from mayavi.sources.vtk_xml_file_reader import VTKXMLFileReader

        ############################################################
        # Create a new scene and set up the visualization.
        s = self.new_scene()

        # Read a VTK XML data file.
        r = VTKXMLFileReader()
        r.initialize(get_example_data('heart.vti'))
        script.add_source(r)

    def test(self):
        self.main()

if __name__ == "__main__":
    t = TestVTKXMLReader()
    t.test()

########NEW FILE########
__FILENAME__ = filters
"""Actions to start various filters.
"""
# Author: Prabhu Ramachandran <prabhu_r@users.sf.net>
# Copyright (c) 2005-2008, Enthought, Inc.
# License: BSD Style.

import new

from pyface.action.api import Action
from traits.api import Instance

from mayavi.plugins.script import get_imayavi
from mayavi.core.registry import registry
from mayavi.core.metadata import Metadata
from mayavi.core.pipeline_base import PipelineBase


######################################################################
# `FilterAction` class.
######################################################################
class FilterAction(Action):

    # The Metadata associated with this particular action.
    metadata = Instance(Metadata)

    mayavi = Instance('mayavi.plugins.script.Script')

    # We disable the actions by default since these are dynamically
    # enabled depending on the current selection or object.
    enabled = False

    def __init__(self, **traits):
        super(FilterAction, self).__init__(**traits)
        self.mayavi.engine.on_trait_change(self._update_enabled,
                                           ['current_selection',
                                            'current_object'])

    ###########################################################################
    # 'Action' interface.
    ###########################################################################
    def perform(self, event):
        """ Performs the action. """
        callable = self.metadata.get_callable()
        obj = callable()
        mv = self.mayavi
        mv.add_filter(obj)
        mv.engine.current_selection = obj

    def _update_enabled(self, obj):
        if isinstance(obj, PipelineBase):
            e = obj.menu_helper.check_active(self.metadata)
            self.enabled = e
        else:
            self.enabled = False

    def _mayavi_default(self):
        return get_imayavi(self.window)


######################################################################
# Creating the filter actions automatically.
for filter in registry.filters:
    d = {'tooltip': filter.tooltip,
         'description': filter.desc,
         'metadata': filter}
    action = new.classobj(filter.id, (FilterAction,), d)
    globals()[filter.id] = action


########NEW FILE########
__FILENAME__ = help
"""Actions for the help menu.

"""
# Authors: Gael Varoquaux <gael.varoquaux[at]normalesup.org>
#          Prabhu Ramachandran
# Copyright (c) 2007-2008, Enthought, Inc.
# License: BSD Style.

# Standard library imports.
from os import path
import os
import sys
from os.path import join, dirname

# Enthought library imports.
from pyface.action.api import Action
from traitsui.api import auto_close_message

# Local imports
import mayavi.api
from mayavi.core.common import error
from mayavi.preferences.api import preference_manager

# To find the html documentation directory, first look under the
# standard place.  If that directory doesn't exist, assume you
# are running from the source.
local_dir = dirname(mayavi.api.__file__)
HTML_DIR = join(local_dir, 'html')
if not path.exists(HTML_DIR):
    HTML_DIR = join(dirname(dirname(local_dir)),
                                    'build', 'docs', 'html', 'mayavi')
    if not path.exists(HTML_DIR):
        HTML_DIR = None

def browser_open(url):
    if sys.platform == 'darwin':
            os.system('open %s &' % url)
    else:
        import webbrowser
        if webbrowser._iscommand('firefox') and \
                        preference_manager.root.open_help_in_light_browser:
            # Firefox is installed, let's use it, we know how to make it
            # chromeless.
            firefox = webbrowser.get('firefox')
            firefox._invoke(['-chrome', url], remote=False, autoraise=True)
        else:
            webbrowser.open(url, autoraise=1)


def open_help_index():
    """ Open the mayavi user manual index in a browser.
    """
    # If the HTML_DIR was found, bring up the documentation in a
    # web browser.  Otherwise, bring up an error message.
    if HTML_DIR:
        auto_close_message("Opening help in web browser...")
        browser_open(join(HTML_DIR, 'index.html'))
    else:
        error("Could not find the user guide in your installation " \
            "or the source tree.")


def open_tvtk_docs():
    """ Open the TVTK class browser.
    """
    from tvtk.tools.tvtk_doc import TVTKClassChooser
    TVTKClassChooser().edit_traits()

######################################################################
# `HelpIndex` class.
######################################################################
class HelpIndex(Action):
    """ An action that pop up the help in a browser. """

    tooltip       = "The Mayavi2 user guide"

    description   = "The Mayavi2 user guide"

    ###########################################################################
    # 'Action' interface.
    ###########################################################################

    def perform(self, event):
        """ Performs the action. """
        open_help_index()


######################################################################
# `TVTKClassBrowser` class.
######################################################################
class TVTKClassBrowser(Action):
    """ An action that opens the tvtk interactive class browser. """

    tooltip       = "The TVTK interactive class browser"

    description   = "The TVTK interactive class browser"

    ###########################################################################
    # 'Action' interface.
    ###########################################################################

    def perform(self, event):
        """ Performs the action. """
        open_tvtk_docs()


########NEW FILE########
__FILENAME__ = modules
"""Actions to start various modules.

"""
# Author: Prabhu Ramachandran <prabhu_r@users.sf.net>
# Copyright (c) 2005-2008, Enthought, Inc.
# License: BSD Style.

import new

# Local imports.
from mayavi.core.registry import registry
from mayavi.core.metadata import ModuleMetadata
from mayavi.core.pipeline_info import PipelineInfo
from mayavi.action.filters import FilterAction

######################################################################
# `ModuleAction` class.
######################################################################
class ModuleAction(FilterAction):

    ###########################################################################
    # 'Action' interface.
    ###########################################################################
    def perform(self, event):
        """ Performs the action. """
        callable = self.metadata.get_callable()
        obj = callable()
        mv = self.mayavi
        mv.add_module(obj)
        mv.engine.current_selection = obj


######################################################################
# `AddModuleManager` class.
######################################################################
class AddModuleManager(ModuleAction):
    """ An action that adds a ModuleManager to the tree. """

    tooltip       = "Add a ModuleManager to the current source/filter"

    description   = "Add a ModuleManager to the current source/filter"

    metadata = ModuleMetadata(id="AddModuleManager",
                class_name="mayavi.core.module_manager.ModuleManager",
                menu_name="&Add ModuleManager",
                tooltip="Add a ModuleManager to the current source/filter",
                description="Add a ModuleManager to the current source/filter",
                input_info = PipelineInfo(datasets=['any'],
                                  attribute_types=['any'],
                                  attributes=['any'])
                )

    def perform(self, event):
        """ Performs the action. """
        from mayavi.core.module_manager import ModuleManager
        mm = ModuleManager()
        mv = self.mayavi
        mv.add_module(mm)
        mv.engine.current_selection = mm


######################################################################
# Creating the module actions automatically.
for module in registry.modules:
    d = {'tooltip': module.tooltip,
         'description': module.desc,
         'metadata': module}
    action = new.classobj(module.id, (ModuleAction,), d)
    globals()[module.id] = action


########NEW FILE########
__FILENAME__ = save_load
"""Actions to save and load a MayaVi2 visualization file.

"""
# Author: Prabhu Ramachandran <prabhu_r@users.sf.net>
# Copyright (c) 2005, Enthought, Inc.
# License: BSD Style.

# Standard library imports.
import sys
from os.path import isfile

# Enthought library imports.
from pyface.api import FileDialog, OK
from pyface.action.api import Action

# Local imports
from mayavi.plugins.script import get_imayavi
from mayavi.core.common import error, exception


######################################################################
# `SaveVisualization` class.
######################################################################
class SaveVisualization(Action):
    """ An action that saves the current visualization. """

    tooltip       = "Save current visualization"

    description   = "Save current visualization to a MayaVi2 file"

    ###########################################################################
    # 'Action' interface.
    ###########################################################################

    def perform(self, event):
        """ Performs the action. """
        wildcard = 'MayaVi2 files (*.mv2)|*.mv2|' + FileDialog.WILDCARD_ALL
        dialog = FileDialog(parent=self.window.control,
                            title='Save MayaVi2 file',
                            action='save as', wildcard=wildcard
                            )
        if dialog.open() == OK:
            mv = get_imayavi(self.window)
            mv.save_visualization(dialog.path)

######################################################################
# `LoadVisualization` class.
######################################################################
class LoadVisualization(Action):
    """ An action that loads a visualization from file. """

    tooltip       = "Load saved visualization"

    description   = "Load saved visualization from a MayaVi2 file"

    ###########################################################################
    # 'Action' interface.
    ###########################################################################

    def perform(self, event):
        """ Performs the action. """
        wildcard = 'MayaVi2 files (*.mv2)|*.mv2|' + FileDialog.WILDCARD_ALL
        parent = self.window.control
        dialog = FileDialog(parent=parent,
                            title='Open MayaVi2 file',
                            action='open', wildcard=wildcard
                            )
        if dialog.open() == OK:
            if not isfile(dialog.path):
                error("File '%s' does not exist"%dialog.path, parent)
                return

            mv = get_imayavi(self.window)
            mv.load_visualization(dialog.path)

######################################################################
# `RunScript` class.
######################################################################
class RunScript(Action):
    """ An action that runs a mayavi script.

    WARNING: this can be dangerous since the file runs execfile! """

    tooltip       = "Execute a Python script (typically a Mayavi script)"

    description   = "Execute a Python script (typically a Mayavi script)"

    ###########################################################################
    # 'Action' interface.
    ###########################################################################

    def perform(self, event):
        """ Performs the action. """
        wildcard = 'Python files (*.py)|*.py'
        parent = self.window.control
        dialog = FileDialog(parent=parent,
                            title='Open Python file',
                            action='open', wildcard=wildcard
                            )
        if dialog.open() == OK:
            if not isfile(dialog.path):
                error("File '%s' does not exist"%dialog.path, parent)
                return

            # Get the globals.
            # The following code is taken from scripts/mayavi2.py.
            g = sys.modules['__main__'].__dict__
            if 'mayavi' not in g:
                mv = get_imayavi(self.window)
                g['mayavi'] = mv
                g['engine'] = mv.engine
            # Do execfile
            try:
                # If we don't pass globals twice we get NameErrors and nope,
                # using exec open(script_name).read() does not fix it.
                execfile(dialog.path, g, g)
            except Exception, msg:
                exception(str(msg))


########NEW FILE########
__FILENAME__ = sources
"""An action to open various source files.

"""
# Author: Prabhu Ramachandran <prabhu_r@users.sf.net>
# Copyright (c) 2005-2008, Enthought, Inc.
# License: BSD Style.

# Standard library imports.
from os.path import isfile
import new

# Enthought library imports.
from traits.api import Instance, Str
from pyface.api import FileDialog, OK
from pyface.action.api import Action

# Local imports
from mayavi.plugins.script import get_imayavi
from mayavi.core.common import error
from mayavi.core.metadata import Metadata
from mayavi.core.registry import registry


######################################################################
# Utility functions
######################################################################
def get_scene(mayavi):
    """Given a mayavi script instance, get the current scene.  If none
    is available create a new one.
    """
    s = mayavi.engine.current_scene
    if s is None:
        mayavi.engine.new_scene()
        s = mayavi.engine.current_scene
    return s


######################################################################
# `OpenFile` class.
######################################################################
class OpenFile(Action):
    """ An action that opens a data file depending on the supported
    extensions.  """

    tooltip       = "Open a supported data file"

    description   = "Open any supported data file"

    path        =  Str("MenuBar/File/LoadDataMenu")

    ###########################################################################
    # 'Action' interface.
    ###########################################################################

    def perform(self, event):
        """ Performs the action. """
        mv = get_imayavi(self.window)
        s = get_scene(mv)
        if s is None:
            return

        wildcard = 'All files (*.*)|*.*'
        for src in registry.sources:
            if len(src.extensions) > 0:
                if wildcard.endswith('|') or \
                   src.wildcard.startswith('|'):
                       wildcard += src.wildcard
                else:
                    wildcard += '|' + src.wildcard

        parent = self.window.control
        dialog = FileDialog(parent=parent,
                            title='Open supported data file',
                            action='open', wildcard=wildcard
                            )
        if dialog.open() == OK:
            if not isfile(dialog.path):
                error("File '%s' does not exist!"%dialog.path, parent)
                return
            # FIXME: Ask for user input if a filetype is unknown and
            # choose appropriate reader.
            src = mv.open(dialog.path)
            if src is not None:
                mv.engine.current_selection = src


######################################################################
# `SourceAction` class.
######################################################################
class SourceAction(Action):

    # The Metadata associated with this particular action.
    metadata = Instance(Metadata)

    def perform(self, event):
        mv = get_imayavi(self.window)
        s = get_scene(mv)
        if s is None:
            return
        callable = self.metadata.get_callable()
        obj = callable()
        mv.add_source(obj)
        mv.engine.current_selection = obj


######################################################################
# Creating the source actions automatically.
for src in registry.sources:
    if len(src.extensions) == 0:
        d = {'tooltip': src.tooltip,
             'description': src.desc,
             'metadata': src}
        action = new.classobj(src.id, (SourceAction,), d)
        globals()[src.id] = action


########NEW FILE########
__FILENAME__ = api
from mayavi.version import version, version as __version__
from mayavi.core.engine import Engine
from mayavi.core.off_screen_engine import OffScreenEngine
from mayavi.tests.runtests import m2_tests as test

########NEW FILE########
__FILENAME__ = actor
"""A simple actor component.

"""
# Author: Prabhu Ramachandran <prabhu_r@users.sf.net>
# Copyright (c) 2005, Enthought, Inc.
# License: BSD Style.

# Enthought library imports.
from traits.api import Instance, Bool, Enum
from tvtk.api import tvtk
from traits.api import DelegatesTo
from tvtk.common import is_old_pipeline

# Local imports.
from mayavi.core.component import Component
from mayavi.core.source import Source

######################################################################
# `Actor` class.
######################################################################
class Actor(Component):
    # The version of this class.  Used for persistence.
    __version__ = 0

    # The mapper.
    mapper = Instance(tvtk.Mapper, record=True)

    # The actor.
    actor = Instance(tvtk.Actor, record=True)

    # The actor's property.
    property = Instance(tvtk.Property, record=True)

    # FIXME: None of the texture stuff is picklable.  This will NOT be
    # supported till the pickling infrastructure is cleaned up and
    # fixed.

    # If texturing is enabled for the actor or not
    enable_texture = Bool(False, desc='if texturing is enabled')

    # The source of the texture's image
    texture_source_object = Instance(Source)

    # The actors texture
    texture = Instance(tvtk.Texture, record=True)

    # The texture coord generation mode.
    tcoord_generator_mode = Enum('none', 'cylinder', 'sphere', 'plane',
                                 desc='the mode for texture coord generation')

    # Texture coord generator.
    tcoord_generator = Instance(tvtk.Object, allow_none=True)

    ######################################################################
    # `object` interface
    ######################################################################
    def __get_pure_state__(self):
        d = super(Actor, self).__get_pure_state__()
        for attr in ('texture', 'texture_source_object',
                     'enable_texture', 'tcoord_generator_mode',
                     'tcoord_generator'):
            d.pop(attr,None)
        return d


    ######################################################################
    # `Component` interface
    ######################################################################
    def setup_pipeline(self):
        """Override this method so that it *creates* its tvtk
        pipeline.

        This method is invoked when the object is initialized via
        `__init__`.  Note that at the time this method is called, the
        tvtk data pipeline will *not* yet be setup.  So upstream data
        will not be available.  The idea is that you simply create the
        basic objects and setup those parts of the pipeline not
        dependent on upstream sources and filters.
        """
        self.mapper = tvtk.PolyDataMapper(use_lookup_table_scalar_range=1)
        self.actor = tvtk.Actor()
        self.property = self.actor.property
        self.texture = tvtk.Texture()

    def update_pipeline(self):
        """Override this method so that it *updates* the tvtk pipeline
        when data upstream is known to have changed.

        This method is invoked (automatically) when the input fires a
        `pipeline_changed` event.
        """
        if (len(self.inputs) == 0) or \
               (len(self.inputs[0].outputs) == 0):
            return

        self._tcoord_generator_mode_changed(self.tcoord_generator_mode)
        self.render()

    def update_data(self):
        """Override this method to do what is necessary when upstream
        data changes.

        This method is invoked (automatically) when any of the inputs
        sends a `data_changed` event.
        """
        # Invoke render to update any changes.
        if not is_old_pipeline():
            from mayavi.modules.outline import Outline
            from mayavi.components.glyph import Glyph
            #FIXME: A bad hack, but without these checks results in seg fault
            input = self.inputs[0]
            if isinstance(input, Outline) or isinstance(input, Glyph):
                self.mapper.update(0)
            else:
                self.mapper.update()
        self.render()

    ######################################################################
    # `Actor` interface
    ######################################################################
    def set_lut(self, lut):
        """Set the Lookup table to use."""
        self.mapper.lookup_table = lut
        # A hack to avoid a problem with the VRML output that seems to
        # ignore the use_lookup_table_scalar_range setting
        # on the mapping
        self.mapper.scalar_range = lut.table_range

    ######################################################################
    # Non-public interface.
    ######################################################################
    def _setup_handlers(self, old, new):
        if old is not None:
            old.on_trait_change(self.render, remove=True)
        new.on_trait_change(self.render)

    def _mapper_changed(self, old, new):
        # Setup the handlers.
        self._setup_handlers(old, new)
        # Setup the LUT.
        if old is not None:
            self.set_lut(old.lookup_table)
        # Setup the inputs to the mapper.
        if (len(self.inputs) > 0) and (len(self.inputs[0].outputs) > 0):
            self.configure_connection(new, self.inputs[0])
        # Setup the actor's mapper.
        actor = self.actor
        if actor is not None:
            actor.mapper = new
        self.render()

    def _actor_changed(self, old, new):
        # Setup the handlers.
        self._setup_handlers(old, new)
        # Set the mapper.
        mapper = self.mapper
        if mapper is not None:
            new.mapper = mapper
        # Set the property.
        prop = self.property
        if prop is not None:
            new.property = prop
        # Setup the `actors` trait.
        self.actors = [new]

    def _property_changed(self, old, new):
        # Setup the handlers.
        self._setup_handlers(old, new)
        # Setup the actor.
        actor = self.actor
        if new is not actor.property:
            actor.property = new

    def _foreground_changed_for_scene(self, old, new):
        # Change the default color for the actor.
        self.property.color = new
        self.render()

    def _scene_changed(self, old, new):
        super(Actor, self)._scene_changed(old, new)
        self._foreground_changed_for_scene(None, new.foreground)

    def _enable_texture_changed(self, value):
        if self.texture_source_object is None :
            self.actor.texture = None
            return
        if value:
            self.actor.texture = self.texture
        else:
            self.actor.texture = None

    def _can_object_give_image_data(self, source):
        if source is None:
            return False
        if not isinstance(source, Source):
            return False
        if source.outputs[0].is_a('vtkImageData'):
            return True
        return False

    def _change_texture_input(self):
        if self._can_object_give_image_data(self.texture_source_object):
            self.configure_connection(self.texture,
                                      self.texture_source_object)
            self.actor.texture = self.texture
        else:
            self.texture_source_object = None

    def _texture_source_object_changed(self,old,new):
        if old is not None :
            old.on_trait_change(self._change_texture_input,
                                'pipeline_changed',
                                remove=True)
        if new is not None :
            new.on_trait_change(self._change_texture_input,
                                'pipeline_changed' )

        if new is not None:
            self._change_texture_input()
        else:
            self.actor.texture = None
            self.texture.input = None
            self.texture.input_connection = None

    def _texture_changed(self,value):
        # Setup the actor's texture.
        actor = self.actor
        if actor is not None and (value.input is not None
                                  or value.input_connection is not None):
            actor.texture = value
            self.texture.on_trait_change(self.render)

        self.render()

    def _tcoord_generator_mode_changed(self, value):
        inp = self.inputs
        if (len(inp) == 0) or \
               (len(inp[0].outputs) == 0):
            return
        old_tg = self.tcoord_generator
        if old_tg is not None:
            old_tg.on_trait_change(self.render, remove=True)
        if value == 'none':
            self.tcoord_generator = None
            self.configure_connection(self.mapper, inp[0])
        else:
            tg_dict = {'cylinder': tvtk.TextureMapToCylinder,
                       'sphere': tvtk.TextureMapToSphere,
                       'plane': tvtk.TextureMapToPlane}
            tg = tg_dict[value]()
            self.tcoord_generator = tg
            self.configure_connection(tg, inp[0])
            self.configure_connection(self.mapper, inp[0])
        tg = self.tcoord_generator
        if tg is not None:
            tg.on_trait_change(self.render)
        self.render()


########NEW FILE########
__FILENAME__ = actor2d
"""A simple actor component.

"""
# Author: Prabhu Ramachandran <prabhu_r@users.sf.net>
# Copyright (c) 2005, Enthought, Inc.
# License: BSD Style.

# Enthought library imports.
from traits.api import Instance
from traitsui.api import View, Group, Item, InstanceEditor
from tvtk.api import tvtk

# Local imports.
from mayavi.core.component import Component


######################################################################
# `Actor2D` class.
######################################################################
class Actor2D(Component):
    # The version of this class.  Used for persistence.
    __version__ = 0

    # The mapper.
    mapper = Instance(tvtk.AbstractMapper, record=True)

    # The actor.
    actor = Instance(tvtk.Prop, record=True)

    # The actor's property.
    property = Instance(tvtk.Property2D, record=True)


    ########################################
    # View related traits.

    # The Actor's view group.
    _actor_group = Group(Item(name='visibility'),
                         Item(name='height'),
                         Item(name='width'),
                         show_border=True, label='Actor')

    # The View for this object.
    view = View(Group(Item(name='actor', style='custom',
                           editor=InstanceEditor(view=View(_actor_group))),
                      show_labels=False,
                      label='Actor'
                      ),
                Group(Item(name='mapper',
                           style='custom',
                           resizable=True),
                      show_labels=False,
                      label='Mapper'),
                Group(Item(name='property',
                           style='custom',
                           resizable=True),
                      show_labels=False,
                      label='Property'),
                resizable=True,
                )

    ######################################################################
    # `Component` interface
    ######################################################################
    def setup_pipeline(self):
        """Override this method so that it *creates* its tvtk
        pipeline.

        This method is invoked when the object is initialized via
        `__init__`.  Note that at the time this method is called, the
        tvtk data pipeline will *not* yet be setup.  So upstream data
        will not be available.  The idea is that you simply create the
        basic objects and setup those parts of the pipeline not
        dependent on upstream sources and filters.
        """
        if self.mapper is None:
            self.mapper = tvtk.TextMapper()
        self.actor = tvtk.Actor2D()
        self.property = self.actor.property

    def update_pipeline(self):
        """Override this method so that it *updates* the tvtk pipeline
        when data upstream is known to have changed.

        This method is invoked (automatically) when the input fires a
        `pipeline_changed` event.
        """
        if (len(self.inputs) == 0) or \
               (len(self.inputs[0].outputs) == 0):
            return
        self.configure_connection(self.mapper, self.inputs[0])
        self.render()

    def update_data(self):
        """Override this method to do what is necessary when upstream
        data changes.

        This method is invoked (automatically) when any of the inputs
        sends a `data_changed` event.
        """
        # Invoke render to update any changes.
        self.render()

    ######################################################################
    # Non-public interface.
    ######################################################################
    def _setup_handlers(self, old, new):
        if old is not None:
            old.on_trait_change(self.render, remove=True)
        new.on_trait_change(self.render)

    def _mapper_changed(self, old, new):
        # Setup the handlers.
        self._setup_handlers(old, new)
        # Setup the inputs to the mapper.
        if (len(self.inputs) > 0) and (len(self.inputs[0].outputs) > 0):
            self.configure_connection(new, self.inputs[0])
        # Setup the actor's mapper.
        actor = self.actor
        if actor is not None:
            actor.mapper = new
        self.render()

    def _actor_changed(self, old, new):
        # Setup the handlers.
        self._setup_handlers(old, new)
        # Set the mapper.
        mapper = self.mapper
        if mapper is not None:
            new.mapper = mapper
        # Set the property.
        prop = self.property
        if prop is not None:
            new.property = prop
        # Setup the `actors` trait.
        self.actors = [new]

    def _property_changed(self, old, new):
        # Setup the handlers.
        self._setup_handlers(old, new)
        # Setup the actor.
        actor = self.actor
        if new is not actor.property:
            actor.property = new

    def _foreground_changed_for_scene(self, old, new):
        # Change the default color for the actor.
        self.property.color = new
        self.render()

    def _scene_changed(self, old, new):
        super(Actor2D, self)._scene_changed(old, new)
        self._foreground_changed_for_scene(None, new.foreground)

########NEW FILE########
__FILENAME__ = common
"""Common code used by different components.
"""
# Author: Prabhu Ramachandran <prabhu_r@users.sf.net>
# Copyright (c) 2005, Enthought, Inc.
# License: BSD Style.

# Enthought library imports.
from tvtk.api import tvtk

# Local imports.
from tvtk.common import configure_input_data
from mayavi.core.component import Component
from mayavi.core.common import error


def get_module_source(obj):
    """Given an object (either a component or a module), return the
    ModuleManager managing the module that contains this component.
    """
    o = obj
    while isinstance(o, Component):
        o = o.inputs[0]
    return o


def convert_to_poly_data(data):
    """Given a VTK dataset object, this returns the data as PolyData.
    This is primarily used to convert the data suitably for filters
    that only work for PolyData.
    """
    if data.is_a('vtkPolyData'):
        return data

    conv = {'vtkStructuredPoints': tvtk.ImageDataGeometryFilter,
            'vtkImageData': tvtk.ImageDataGeometryFilter,
            'vtkRectilinearGrid': tvtk.RectilinearGridGeometryFilter,
            'vtkStructuredGrid': tvtk.StructuredGridGeometryFilter,
            'vtkUnstructuredGrid':tvtk.GeometryFilter}

    fil = None
    for name, fil_class in conv.items():
        if data.is_a(name):
            fil = fil_class()
            break

    if fil is not None:
        configure_input_data(fil, data)
        fil.update()
        return fil.output
    else:
        error('Given object is not a VTK dataset: %s'%data.__class__.__name__)


########NEW FILE########
__FILENAME__ = contour
"""A contour component.  This component wraps around the
tvtk.ContourFilter and provides convenient options to either
automatically generate a specified number of contours between a given
minimum and maximum value or explicitly specify the contours.  This
component may be used for any input data.  The component also provides
a convenient option to create "filled contours".

"""
# Author: Prabhu Ramachandran <prabhu_r@users.sf.net>
# Copyright (c) 2005, Enthought, Inc.
# License: BSD Style.

# Standard library imports.
import numpy

# Enthought library imports.
from traits.api import Instance, List, Tuple, Bool, Range, \
                                 Float, Property
from tvtk.api import tvtk

# Local imports.
from mayavi.core.component import Component
from mayavi.core.common import error
from mayavi.components.common \
     import get_module_source, convert_to_poly_data


######################################################################
# `Contour` class.
######################################################################
class Contour(Component):
    # The version of this class.  Used for persistence.
    __version__ = 0

    # The contour filter being currently used.
    contour_filter = Property

    # Specify if filled contours are generated.
    filled_contours = Bool(False, desc='if filled contours are '\
                           'to be generated')

    # Specify if contours are generated explicitly or automatically.
    auto_contours = Bool(False, desc='if contours are '\
                         'given explicitly or automatically computed')

    # Number of contours, used when `auto_contours` are chosen.
    number_of_contours = Range(1, 100000, enter_set=True, auto_set=False,
                               desc='number of contours to generate')

    # Minimum contour, this is the starting value when `auto_contours`
    # is turned on.
    minimum_contour = Range(value=0.0,
                            low='_data_min',
                            high='_data_max',
                            enter_set=True,
                            auto_set=False,
                            desc='the starting contour value')

    # Maximum contour, this is the last contour when `auto_contours`
    # is turned on.
    maximum_contour = Range(value=0.0,
                            low='_data_min',
                            high='_data_max',
                            enter_set=True,
                            auto_set=False,
                            desc='the ending contour value')

    # The explicit contours to create.  These specify the contours
    # explicitly and are used when `auto_contours` is turned off.  The
    # traits of the items in the list are dynamically generated based
    # on input data.
    contours = List(Range(value='_default_contour',
                          low='_data_min',
                          high='_data_max',
                          enter_set=True,
                          auto_set=False,
                          ),
                    rows=3,
                    desc='explicitly the contours to be generated')

    # Specify if the filled contour option should be shown in the view
    # or not.  This is useful in situations like the iso_surface
    # module where it does not make sense to use filled contours at
    # all.
    show_filled_contours = Bool(True)

    # Specify if the lower and upper bound for the data is to be
    # automatically reset or not.
    auto_update_range = Bool(True,
                             desc='if the contour range is updated automatically')

    ########################################
    # The component's view

    #view = View(Group(Item(name='filled_contours',
    #                       defined_when='show_filled_contours'),
    #                  Item(name='auto_contours'), '_',
    #                  Item(name='contours',
    #                       style='custom',
    #                       visible_when='not auto_contours'),
    #                  Item(name='number_of_contours',
    #                       visible_when='auto_contours'),
    #                  Item(name='minimum_contour',
    #                       visible_when='auto_contours'),
    #                  Item(name='maximum_contour',
    #                       visible_when='auto_contours'),
    #                  Item(name='auto_update_range'),
    #                  Item(name='_data_min',
    #                       label='Data minimum',
    #                       visible_when='not auto_update_range'),
    #                  Item(name='_data_max',
    #                       label='Data maximum',
    #                       visible_when='not auto_update_range'),
    #                 )
    #            )

    ########################################
    # Private traits.

    _current_range = Tuple

    # The minimum value of the input data.  Set to a very large negative value
    # to avoid errors prior to the object being added to the mayavi
    # tree.
    _data_min = Float(-1e20, enter_set=True, auto_set=False)

    # The maximum value of the input data.  Set to a very large value
    # to avoid errors prior to the object being added to the mayavi
    # tree.
    _data_max = Float(1e20, enter_set=True, auto_set=False)

    # The default value of the contour to add, this property is computed
    # from the _data_min and _data_max traits and used when the user
    # adds a contour manually from the UI when auto_contours are turned
    # off.
    _default_contour = Property(Float)

    # The contour filter.
    _cont_filt = Instance(tvtk.ContourFilter, args=())

    # The filled contour filter.  This filter generates the filled contours.
    _fill_cont_filt = Instance(tvtk.BandedPolyDataContourFilter, args=(),
                               kw={'clipping': 1, 'scalar_mode':'value'})

    ######################################################################
    # `object` interface
    ######################################################################
    def __get_pure_state__(self):
        d = super(Contour, self).__get_pure_state__()
        # These traits are dynamically created.
        for name in ('_data_min', '_data_max', '_default_contour'):
            d.pop(name, None)

        return d

    ######################################################################
    # `Component` interface
    ######################################################################
    def update_pipeline(self):
        """Override this method so that it *updates* the tvtk pipeline
        when data upstream is known to have changed.

        This method is invoked (automatically) when the input fires a
        `pipeline_changed` event.
        """
        if not self._has_input():
            return
        cf = self._set_contour_input()
        first = False
        if len(self._current_range) == 0:
            first = True
        self._update_ranges()
        # If this is the first time, create a default contour
        if first:
            cr = self._current_range
            self.contours = [(cr[0] + cr[1])/2]
            self.minimum_contour = cr[0]
            self.maximum_contour = cr[1]
        self.outputs = [cf.output]

    def update_data(self):
        """Override this method to do what is necessary when upstream
        data changes.

        This method is invoked (automatically) when any of the inputs
        sends a `data_changed` event.
        """
        self._update_ranges()
        # Propagage the data changed event.
        self.data_changed = True

    def has_output_port(self):
        """ The contour filter has an output port."""
        return True

    def get_output_object(self):
        """ Returns the output port."""
        return self.contour_filter.output_port

    ######################################################################
    # Non-public methods.
    ######################################################################
    def _contours_items_changed(self, list_event):
        if self.auto_contours or not self._has_input():
            return
        cf = self.contour_filter
        added, removed, index = (list_event.added, list_event.removed,
                                 list_event.index)
        if len(added) == len(removed):
            cf.set_value(index, added[0])
            cf.update()
            self.data_changed = True
        else:
            self._contours_changed(self.contours)

    def _contours_changed(self, values):
        if self.auto_contours or not self._has_input():
            return
        cf = self.contour_filter
        cf.number_of_contours = len(values)
        for i, x in enumerate(values):
            cf.set_value(i, x)
        cf.update()
        self.data_changed = True

    def _update_ranges(self):
        # Here we get the module's source since the input of this
        # component may not in general represent the entire object.
        if not self.auto_update_range:
            return
        src = get_module_source(self.inputs[0])
        sc = src.outputs[0].point_data.scalars
        if sc is not None:
            sc_array = sc.to_array()
            has_nan = numpy.isnan(sc_array).any()
            if has_nan:
                rng = (float(numpy.nanmin(sc_array)),
                       float(numpy.nanmax(sc_array)))
            else:
                rng = sc.range
        else:
            error('Cannot contour: No scalars in input data!')
            rng = (0.0, 1.0)
        if rng != self._current_range:
            self.set(_data_min=rng[0], _data_max=rng[1],
                     trait_change_notify=False)
            self._clip_contours(rng)
            self._current_range = rng

    def _minimum_contour_changed(self, value):
        self._do_auto_contours()

    def _maximum_contour_changed(self, value):
        self._do_auto_contours()

    def _number_of_contours_changed(self, value):
        self._do_auto_contours()

    def _auto_contours_changed(self, value):
        if value:
            self._do_auto_contours()
        else:
            self._contours_changed(self.contours)

    def _auto_update_range_changed(self, value):
        if value:
            rng = self._data_min, self._data_max
            self._current_range = rng
            self._update_ranges()
            self.trait_property_changed('_data_min', rng[0],
                                        self._data_min)
            self.trait_property_changed('_data_max', rng[1],
                                        self._data_max)


    def _do_auto_contours(self):
        if not self._has_input():
            return
        if self.auto_contours:
            minc, maxc = self.minimum_contour, self.maximum_contour
            self.contour_filter.generate_values(self.number_of_contours,
                                                min(minc, maxc),
                                                max(minc, maxc))
            self.data_changed = True

    def _filled_contours_changed(self, val):
        if not self._has_input():
            return
        cf = self._set_contour_input()
        # This will trigger a change.
        self._auto_contours_changed(self.auto_contours)
        self.outputs = [cf.output]

    def _get_contour_filter(self):
        if self.filled_contours:
            return self._fill_cont_filt
        else:
            return self._cont_filt

    def _set_contour_input(self):
        """Sets the input to the appropriate contour filter and
        returns the currently used contour filter.
        """
        inp = self.inputs[0].outputs[0]
        cf = self.contour_filter
        if self.filled_contours:
            inp = convert_to_poly_data(inp)
            self.configure_input_data(cf, inp)
        else:
            self.configure_connection(cf, self.inputs[0])
        cf.update()
        return cf

    def _has_input(self):
        """Returns if this component has a valid input."""
        if (len(self.inputs) > 0)  and \
               (len(self.inputs[0].outputs) > 0):
            return True
        else:
            return False

    def _clip_contours(self, rng):
        """Clips the contour related values when the data range has
        changed.  The new range is given as the argument.
        """
        ctr = []
        dmin, dmax = rng
        ctr = [min(max(x, dmin), dmax) for x in self.contours]
        if self.auto_contours or ctr != self.contours:
            self.contours = ctr
            self.set(minimum_contour=self._data_min,
                     maximum_contour=self._data_max,
                     trait_change_notify=False)
            self._do_auto_contours()

    def _get__default_contour(self):
        return (self._data_min + self._data_max)*0.5


########NEW FILE########
__FILENAME__ = custom_grid_plane
"""A grid plane component.

"""
# Author: Prabhu Ramachandran <prabhu_r@users.sf.net>
# Copyright (c) 2005-2006, Enthought, Inc.
# License: BSD Style.

# Enthought library imports.
from traits.api import Instance, Int, Range
from traitsui.api import View, Group, Item
from tvtk.api import tvtk

# Local imports.
from mayavi.core.component import Component
from mayavi.core.common import error



######################################################################
# `CustomGridPlane` class.
######################################################################
class CustomGridPlane(Component):
    # The version of this class.  Used for persistence.
    __version__ = 0

    # The TVTK object that extracts the grid plane.  This is created
    # dynamically based on the input data type.
    plane = Instance(tvtk.Object)

    # Minimum x value.
    x_min = Range(value=0, low='_x_low', high='_x_high',
                  enter_set=True, auto_set=False,
                  desc='minimum x value of the domain')

    # Maximum x value.
    x_max = Range(value=10000, low='_x_low', high='_x_high',
                  enter_set=True, auto_set=False,
                  desc='maximum x value of the domain')

    # Minimum y value.
    y_min = Range(value=0, low='_y_low', high='_y_high',
                  enter_set=True, auto_set=False,
                  desc='minimum y value of the domain')

    # Maximum y value.
    y_max = Range(value=10000, low='_y_low', high='_y_high',
                  enter_set=True, auto_set=False,
                  desc='maximum y value of the domain')

    # Minimum z value.
    z_min = Range(value=0, low='_z_low', high='_z_high',
                  enter_set=True, auto_set=False,
                  desc='minimum z value of the domain')

    # Maximum z value.
    z_max = Range(value=10000, low='_z_low', high='_z_high',
                  enter_set=True, auto_set=False,
                  desc='maximum z value of the domain')


    ########################################
    # Private traits.

    # Determines the lower/upper limit of the axes for the sliders.
    _x_low = Int(0)
    _x_high = Int(10000)
    _y_low = Int(0)
    _y_high = Int(10000)
    _z_low = Int(0)
    _z_high = Int(10000)

    ########################################
    # View related traits.

    # The View for this object.
    view = View(Group(Item(name='x_min'),
                      Item(name='x_max'),
                      Item(name='y_min'),
                      Item(name='y_max'),
                      Item(name='z_min'),
                      Item(name='z_max'),
                      ),
                      resizable=True
                )

    ######################################################################
    # `object` interface
    ######################################################################
    def __get_pure_state__(self):
        d = super(CustomGridPlane, self).__get_pure_state__()
        # These traits are dynamically created.
        for axis in ('x', 'y', 'z'):
            for name in ('_min', '_max'):
                d.pop(axis + name, None)
            d.pop('_' + axis + '_low', None)
            d.pop('_' + axis + '_high', None)

        d.pop('plane', None)

        return d

    ######################################################################
    # `Component` interface
    ######################################################################
    def update_pipeline(self):
        """Override this method so that it *updates* the tvtk pipeline
        when data upstream is known to have changed.

        This method is invoked (automatically) when the input fires a
        `pipeline_changed` event.
        """
        if len(self.inputs) == 0:
            return
        input = self.inputs[0].outputs[0]
        plane = None
        if input.is_a('vtkStructuredGrid'):
            plane = tvtk.StructuredGridGeometryFilter()
        elif input.is_a('vtkStructuredPoints') or input.is_a('vtkImageData'):
            plane = tvtk.ImageDataGeometryFilter ()
        elif input.is_a('vtkRectilinearGrid'):
            plane = tvtk.RectilinearGridGeometryFilter ()
        else:
            msg = "The GridPlane component does not support the %s dataset."\
                  %(input.class_name)
            error(msg)
            raise TypeError, msg

        self.configure_connection(plane, self.inputs[0])
        self.plane = plane
        self._update_limits()
        self._update_voi()
        self.outputs = [plane.output]

    def update_data(self):
        """Override this method to do what is necessary when upstream
        data changes.

        This method is invoked (automatically) when any of the inputs
        sends a `data_changed` event.
        """
        self._update_limits()
        self._update_voi()
        # Propagate the data_changed event.
        self.data_changed = True

    def has_output_port(self):
        """ The contour filter has an output port."""
        return True

    def get_output_object(self):
        """ Returns the output port."""
        return self.plane.output_port

    ######################################################################
    # Non-public methods.
    ######################################################################
    def _update_limits(self):
        extents = self.plane.input.whole_extent
        self._x_low, self._x_high = extents[:2]
        self._y_low, self._y_high = extents[2:4]
        self._z_low, self._z_high = extents[4:]

    def _x_min_changed(self, val):
        if val > self.x_max:
            self.x_max = val
        else:
            self._update_voi()

    def _x_max_changed(self, val):
        if val < self.x_min:
            self.x_min = val
        else:
            self._update_voi()

    def _y_min_changed(self, val):
        if val > self.y_max:
            self.y_max = val
        else:
            self._update_voi()

    def _y_max_changed(self, val):
        if val < self.y_min:
            self.y_min = val
        else:
            self._update_voi()

    def _z_min_changed(self, val):
        if val > self.z_max:
            self.z_max = val
        else:
            self._update_voi()

    def _z_max_changed(self, val):
        if val < self.z_min:
            self.z_min = val
        else:
            self._update_voi()

    def _update_voi(self):
        if len(self.inputs) == 0:
            return
        plane = self.plane
        extents = (self.x_min, self.x_max,
                   self.y_min, self.y_max,
                   self.z_min, self.z_max)
        try:
            plane.set_extent(extents)
        except AttributeError:
            plane.extent = tuple(extents)

        plane.update_whole_extent()
        plane.update()
        self.data_changed = True

########NEW FILE########
__FILENAME__ = cutter
"""A simple wrapper for `tvtk.Cutter`.
"""
# Author: Prabhu Ramachandran <prabhu_r@users.sf.net>
# Copyright (c) 2005-2008, Enthought, Inc.
# License: BSD Style.


# Enthought library imports.
from traits.api import Instance, Property
from traitsui.api import View, Group, Item
from tvtk.api import tvtk

# Local imports.
from mayavi.core.component import Component

######################################################################
# `Cutter` class.
######################################################################
class Cutter(Component):
    # The version of this class.  Used for persistence.
    __version__ = 0

    # The mapper.
    cutter = Instance(tvtk.Cutter, args=())

    # The cut function.  This should be a delegate but due to a bug in
    # traits that does not work.
    cut_function = Property

    ########################################
    # View related traits.

    view = View(Group(Item(name='cutter',
                           style='custom',
                           resizable=True),
                      show_labels=False),
                resizable=True)

    ######################################################################
    # `Component` interface
    ######################################################################
    def update_pipeline(self):
        """Override this method so that it *updates* the tvtk pipeline
        when data upstream is known to have changed.

        This method is invoked (automatically) when the input fires a
        `pipeline_changed` event.
        """
        if (len(self.inputs) == 0) or (len(self.inputs[0].outputs) == 0):
            return
        c = self.cutter
        self.configure_connection(c, self.inputs[0])
        c.update()
        self.outputs = [c.output]

    def update_data(self):
        """Override this method to do what is necessary when upstream
        data changes.

        This method is invoked (automatically) when any of the inputs
        sends a `data_changed` event.
        """
        self.data_changed = True

    def has_output_port(self):
        """ The contour filter has an output port."""
        return True

    def get_output_object(self):
        """ Returns the output port."""
        return self.cutter.output_port

    ######################################################################
    # `Cutter` interface
    ######################################################################
    def _get_cut_function(self):
        return self.cutter.cut_function

    def _set_cut_function(self, val):
        old = self.cutter.cut_function
        self.cutter.cut_function = val
        self.trait_property_changed('cut_function', old, val)


########NEW FILE########
__FILENAME__ = glyph
"""A component that allows one to place colored and scaled glyphs at
input point data.
"""
# Author: Prabhu Ramachandran <prabhu_r@users.sf.net>
#         KK Rai (kk.rai [at] iitb.ac.in)
#         R. Ambareesha (ambareesha [at] iitb.ac.in)
# Copyright (c) 2005-2007, Enthought, Inc.
# License: BSD Style.

# Enthought library imports.
from traits.api import Instance, Trait, Bool
from traits.api import Enum
from traitsui.api import View, Group, Item
from tvtk.api import tvtk
from tvtk.tvtk_base import TraitRevPrefixMap
import tvtk.common as tvtk_common

# Local imports.
from mayavi.core.component import Component
from mayavi.core.module import Module
from mayavi.components import glyph_source


######################################################################
# `Glyph` class.
######################################################################
class Glyph(Component):

    # The version of this class.  Used for persistence.
    __version__ = 0

    # Type of Glyph: 'tensor' or 'vector'
    glyph_type = Enum('vector', 'tensor',
                      desc = 'if the glyph is vector or tensor')

    # The scaling mode to use when scaling the glyphs.  We could have
    # used the glyph's own scale mode but it allows users to set the
    # mode to use vector components for the scaling which I'd like to
    # disallow.
    scale_mode = Trait('scale_by_scalar',
                       TraitRevPrefixMap({'scale_by_vector': 1,
                                          'scale_by_vector_components': 2,
                                          'data_scaling_off': 3,
                                          'scale_by_scalar': 0}),
                       desc="if scaling is done using scalar or vector/normal magnitude"
                       )

    # The color mode to use when coloring the glyphs.  We could have
    # used the glyph's own color_mode trait but it allows users to set
    # the mode to use vector components for the scaling which I'd
    # like to disallow.
    color_mode = Trait('color_by_scalar',
                       TraitRevPrefixMap({'color_by_vector': 2,
                                          'color_by_scalar': 1,
                                          'no_coloring': 0}),
                       desc="if coloring is done by scalar or vector/normal magnitude"
                       )
    color_mode_tensor = Trait('scalar',
                              TraitRevPrefixMap({'scalars': 1,
                                                 'eigenvalues':2,
                                                 'no_coloring': 0}),
                              desc="if coloring is done by scalar or eigenvalues"
                             )

    # Specify if the input points must be masked.  By mask we mean
    # that only a subset of the input points must be displayed.
    mask_input_points = Bool(False, desc="if input points are masked")

    # The MaskPoints filter.
    mask_points = Instance(tvtk.MaskPoints, args=(),
                           kw={'random_mode': True}, record=True)

    # The Glyph3D instance.
    glyph = Instance(tvtk.Object, allow_none=False, record=True)

    # The Source to use for the glyph.  This is chosen from
    # `self._glyph_list` or `self.glyph_dict`.
    glyph_source = Instance(glyph_source.GlyphSource,
                            allow_none=False, record=True)

    # The module associated with this component.  This is used to get
    # the data range of the glyph when the scale mode changes.  This
    # *must* be set if this module is to work correctly.
    module = Instance(Module)

    # Should we show the GUI option for changing the scalar mode or
    # not?  This is useful for vector glyphing modules where there it
    # does not make sense to scale the data based on scalars.
    show_scale_mode = Bool(True)

    ########################################
    # Private traits.

    # Used for optimization.
    _updating = Bool(False)

    ########################################
    # View related traits.

    view = View(Group(Item(name='mask_input_points'),
                      Group(Item(name='mask_points',
                                 enabled_when='object.mask_input_points',
                                 style='custom', resizable=True),
                            show_labels=False,
                            ),
                      label='Masking',
                      ),
                Group(Group(Item(name='scale_mode',
                                 enabled_when='show_scale_mode',
                                 visible_when='show_scale_mode'),
                            Item(name='color_mode',
                                 enabled_when= 'glyph_type == "vector"',
                                 visible_when= 'glyph_type == "vector"'),
                            Item(name='color_mode_tensor',
                                 enabled_when= 'glyph_type == "tensor"',
                                 visible_when= 'glyph_type == "tensor"'),
                            ),
                      Group(Item(name='glyph', style='custom',
                                 resizable=True),
                            show_labels=False),
                      label='Glyph',
                      selected=True,
                      ),
                Group(Item(name='glyph_source',
                                 style='custom', resizable=True),
                      show_labels=False,
                      label='Glyph Source',
                      ),
                resizable=True
                )

    ######################################################################
    # `object` interface
    ######################################################################
    def __get_pure_state__(self):
        d = super(Glyph, self).__get_pure_state__()
        for attr in ('module', '_updating'):
            d.pop(attr, None)
        return d


    ######################################################################
    # `Module` interface
    ######################################################################
    def setup_pipeline(self):
        """Override this method so that it *creates* the tvtk
        pipeline.

        This method is invoked when the object is initialized via
        `__init__`.  Note that at the time this method is called, the
        tvtk data pipeline will *not* yet be setup.  So upstream data
        will not be available.  The idea is that you simply create the
        basic objects and setup those parts of the pipeline not
        dependent on upstream sources and filters.  You should also
        set the `actors` attribute up at this point.
        """
        self._glyph_type_changed(self.glyph_type)
        self.glyph_source = glyph_source.GlyphSource()

        # Handlers to setup our source when the sources pipeline changes.
        self.glyph_source.on_trait_change(self._update_source, 'pipeline_changed')
        self.mask_points.on_trait_change(self.render)

    def update_pipeline(self):
        """Override this method so that it *updates* the tvtk pipeline
        when data upstream is known to have changed.

        This method is invoked (automatically) when any of the inputs
        sends a `pipeline_changed` event.
        """
        if ((len(self.inputs) == 0) or (len(self.inputs[0].outputs) == 0)):
            return

        self._mask_input_points_changed(self.mask_input_points)
        if self.glyph_type == 'vector':
            self._color_mode_changed(self.color_mode)
        else:
            self._color_mode_tensor_changed(self.color_mode_tensor)
        self._scale_mode_changed(self.scale_mode)

        # Set our output.
        tvtk_common.configure_outputs(self, self.glyph)
        self.pipeline_changed = True

    def update_data(self):
        """Override this method so that it flushes the vtk pipeline if
        that is necessary.

        This method is invoked (automatically) when any of the inputs
        sends a `data_changed` event.
        """
        self._scale_mode_changed(self.scale_mode)
        self.data_changed = True

    def render(self):
        if not self._updating:
            super(Glyph, self).render()

    def start(self):
        """Overridden method.
        """
        if self.running:
            return
        self.glyph_source.start()
        super(Glyph, self).start()

    def stop(self):
        if not self.running:
            return
        self.glyph_source.stop()
        super(Glyph, self).stop()

    def has_output_port(self):
        """ The filter has an output port."""
        return True

    def get_output_object(self):
        """ Returns the output port."""
        return self.glyph.output_port

    ######################################################################
    # Non-public methods.
    ######################################################################
    def _update_source(self):
        self.configure_source_data(self.glyph, self.glyph_source.outputs[0])

    def _glyph_source_changed(self, value):
        self.configure_source_data(self.glyph, value.outputs[0])

    def _color_mode_changed(self, value):
        if len(self.inputs) == 0:
            return
        if value != 'no_coloring':
            self.glyph.color_mode = value

    def _color_mode_tensor_changed(self, value):
        if len(self.inputs) == 0:
            return
        self._updating = True
        if value != 'no_coloring':
            self.glyph.color_mode = value
            self.glyph.color_glyphs = True
        else:
            self.glyph.color_glyphs = False
        self._updating = False
        self.render()

    def _scale_mode_changed(self, value):
        if (self.module is None) or (len(self.inputs) == 0)\
                                 or self.glyph_type == 'tensor':
            return

        self._updating = True
        try:
            glyph = self.glyph
            glyph.scale_mode = value

            mm = self.module.module_manager
            if glyph.scale_mode == 'scale_by_scalar':
                glyph.range = tuple(mm.scalar_lut_manager.data_range)
            else:
                glyph.range = tuple(mm.vector_lut_manager.data_range)
        finally:
            self._updating = False
            self.render()

    def _mask_input_points_changed(self, value):
        inputs = self.inputs
        if len(inputs) == 0:
            return
        if value:
            mask = self.mask_points
            tvtk_common.configure_input(mask, inputs[0].outputs[0])
        else:
            self.configure_connection(self.glyph, inputs[0])

    def _glyph_type_changed(self, value):
        if self.glyph_type == 'vector':
            self.glyph = tvtk.Glyph3D(clamping=True)
        else:
            self.glyph = tvtk.TensorGlyph(scale_factor=0.1)
            self.show_scale_mode = False
        self.glyph.on_trait_change(self.render)

    def _scene_changed(self, old, new):
        super(Glyph, self)._scene_changed(old, new)
        self.glyph_source.scene = new

########NEW FILE########
__FILENAME__ = glyph_source
"""A component that allows creates the source for the glyphs and
handle transformation.
"""
# Author: KK Rai (kk.rai [at] iitb.ac.in)
#         R. Ambareesha (ambareesha [at] iitb.ac.in)
#         Prabhu Ramachandran <prabhu_r@users.sf.net>

# Enthought library imports.
from traits.api import (Instance, List, Trait, Bool,
    TraitPrefixList, Property, Dict)
from traitsui.api import View, Group, Item, InstanceEditor
from tvtk.api import tvtk
from tvtk.common import camel2enthought, configure_outputs
from apptools.persistence.state_pickler import set_state

# Local imports.
from mayavi.core.common import handle_children_state
from mayavi.core.component import Component


######################################################################
# `GlyphSource` class.
######################################################################
class GlyphSource(Component):

    # The version of this class.  Used for persistence.
    __version__ = 1

    # Glyph position.  This can be one of ['head', 'tail', 'center'],
    # and indicates the position of the glyph with respect to the
    # input point data.  Please note that this will work correctly
    # only if you do not mess with the source glyph's basic size.  For
    # example if you use a ConeSource and set its height != 1, then the
    # 'head' and 'tail' options will not work correctly.
    glyph_position = Trait('center', TraitPrefixList(['head', 'tail',
                                                      'center']),
                           desc='position of glyph w.r.t. data point')

    # The Source to use for the glyph.  This is chosen from
    # `self._glyph_list` or `self.glyph_dict`.
    glyph_source = Instance(tvtk.Object, allow_none=False, record=True)

    # A dict of glyphs to use.
    glyph_dict = Dict(desc='the glyph sources to select from',
                      record=False)

    # A list of predefined glyph sources that can be used.
    glyph_list = Property(List(tvtk.Object), record=False)

    ########################################
    # Private traits.

    # The transformation to use to place glyph appropriately.
    _trfm = Instance(tvtk.TransformFilter, args=())

    # Used for optimization.
    _updating = Bool(False)

    ########################################
    # View related traits.

    view = View(Group(Group(Item(name='glyph_position')),
                      Group(Item(name='glyph_source',
                                 style='custom',
                                 resizable=True,
                                 editor=InstanceEditor(name='glyph_list'),
                               ),
                            label='Glyph Source',
                            show_labels=False)
                     ),
                resizable=True)

    ######################################################################
    # `Base` interface
    ######################################################################
    def __get_pure_state__(self):
        d = super(GlyphSource, self).__get_pure_state__()
        for attr in ('_updating', 'glyph_list'):
            d.pop(attr, None)
        return d

    def __set_pure_state__(self, state):
        if 'glyph_dict' in state:
            # Set their state.
            set_state(self, state, first=['glyph_dict'], ignore=['*'])
            ignore = ['glyph_dict']
        else:
            # Set the dict state using the persisted list.
            gd = self.glyph_dict
            gl = self.glyph_list
            handle_children_state(gl, state.glyph_list)
            for g, gs in zip(gl, state.glyph_list):
                name = camel2enthought(g.__class__.__name__)
                if name not in gd:
                    gd[name] = g
                # Set the glyph source's state.
                set_state(g, gs)
            ignore = ['glyph_list']
        g_name = state.glyph_source.__metadata__['class_name']
        name = camel2enthought(g_name)
        # Set the correct glyph_source.
        self.glyph_source = self.glyph_dict[name]
        set_state(self, state, ignore=ignore)

    ######################################################################
    # `Component` interface
    ######################################################################
    def setup_pipeline(self):
        """Override this method so that it *creates* the tvtk
        pipeline.

        This method is invoked when the object is initialized via
        `__init__`.  Note that at the time this method is called, the
        tvtk data pipeline will *not* yet be setup.  So upstream data
        will not be available.  The idea is that you simply create the
        basic objects and setup those parts of the pipeline not
        dependent on upstream sources and filters.  You should also
        set the `actors` attribute up at this point.
        """

        self._trfm.transform = tvtk.Transform()
        # Setup the glyphs.
        self.glyph_source = self.glyph_dict['glyph_source2d']

    def update_pipeline(self):
        """Override this method so that it *updates* the tvtk pipeline
        when data upstream is known to have changed.

        This method is invoked (automatically) when any of the inputs
        sends a `pipeline_changed` event.
        """
        self._glyph_position_changed(self.glyph_position)
        self.pipeline_changed = True

    def update_data(self):
        """Override this method so that it flushes the vtk pipeline if
        that is necessary.

        This method is invoked (automatically) when any of the inputs
        sends a `data_changed` event.
        """
        self.data_changed = True

    def render(self):
        if not self._updating:
            super(GlyphSource, self).render()

    ######################################################################
    # Non-public methods.
    ######################################################################
    def _glyph_source_changed(self, value):
        if self._updating == True:
            return

        gd = self.glyph_dict
        value_cls = camel2enthought(value.__class__.__name__)
        if value not in gd.values():
            gd[value_cls] = value

        # Now change the glyph's source trait.
        self._updating = True
        recorder = self.recorder
        if recorder is not None:
            name = recorder.get_script_id(self)
            lhs = '%s.glyph_source'%name
            rhs = '%s.glyph_dict[%r]'%(name, value_cls)
            recorder.record('%s = %s'%(lhs, rhs))

        name = value.__class__.__name__
        if name == 'GlyphSource2D':
            configure_outputs(self, value)
        else:
            self.configure_input(self._trfm, value)
            configure_outputs(self, self._trfm)
        value.on_trait_change(self.render)
        self._updating = False

        # Now update the glyph position since the transformation might
        # be different.
        self._glyph_position_changed(self.glyph_position)

    def _glyph_position_changed(self, value):
        if self._updating == True:
            return

        self._updating = True
        tr = self._trfm.transform
        tr.identity()

        g = self.glyph_source
        name = g.__class__.__name__
        # Compute transformation factor
        if name == 'CubeSource':
            tr_factor = g.x_length/2.0
        elif name == 'CylinderSource':
            tr_factor = -g.height/2.0
        elif name == 'ConeSource':
            tr_factor = g.height/2.0
        elif name == 'SphereSource':
            tr_factor = g.radius
        else:
            tr_factor = 1.
        # Translate the glyph
        if value == 'tail':
            if name == 'GlyphSource2D':
                g.center = 0.5, 0.0, 0.0
            elif name == 'ArrowSource':
                pass
            elif name == 'CylinderSource':
                g.center = 0, tr_factor, 0.0
            elif hasattr(g, 'center'):
                g.center = tr_factor, 0.0, 0.0
        elif value == 'head':
            if name == 'GlyphSource2D':
                g.center = -0.5, 0.0, 0.0
            elif name == 'ArrowSource':
                tr.translate(-1, 0, 0)
            elif name == 'CylinderSource':
                g.center = 0,-tr_factor, 0.0
            else:
                g.center = -tr_factor, 0.0, 0.0
        else:
            if name == 'ArrowSource':
                tr.translate(-0.5, 0, 0)
            elif name != 'Axes':
                g.center = 0.0, 0.0, 0.0

        if name == 'CylinderSource':
            tr.rotate_z(90)

        self._updating = False
        self.render()

    def _get_glyph_list(self):
        # Return the glyph list as per the original order in earlier
        # implementation.
        order = ['glyph_source2d', 'arrow_source', 'cone_source',
                 'cylinder_source', 'sphere_source', 'cube_source',
                 'axes']
        gd = self.glyph_dict
        for key in gd:
            if key not in order:
                order.append(key)
        return [gd[key] for key in order]

    def _glyph_dict_default(self):
        g = {'glyph_source2d': tvtk.GlyphSource2D(glyph_type='arrow', filled=False),
             'arrow_source': tvtk.ArrowSource(),
             'cone_source': tvtk.ConeSource(height=1.0, radius=0.2, resolution=15),
             'cylinder_source': tvtk.CylinderSource(height=1.0, radius=0.15,
                                                    resolution=10),
             'sphere_source': tvtk.SphereSource(),
             'cube_source': tvtk.CubeSource(),
             'axes': tvtk.Axes(symmetric=1)}
        return g

########NEW FILE########
__FILENAME__ = grid_plane
"""A grid plane component.

"""
# Author: Prabhu Ramachandran <prabhu_r@users.sf.net>
# Copyright (c) 2005-2006, Enthought, Inc.
# License: BSD Style.

# Enthought library imports.
from traits.api import Instance, Enum, Int, Range
from traitsui.api import View, Group, Item
from tvtk.api import tvtk
from apptools.persistence import state_pickler

# Local imports.
from mayavi.core.component import Component
from mayavi.core.common import error 


def _get_extent(inp):
    """Get the extents from the given input.
    """
    d = inp.dimensions
    return [0, d[0]-1, 0, d[1]-1, 0, d[2]-1]


######################################################################
# `GridPlane` class.
######################################################################
class GridPlane(Component):
    # The version of this class.  Used for persistence.
    __version__ = 0

    # The TVTK object that extracts the grid plane.  This is created
    # dynamically based on the input data type.
    plane = Instance(tvtk.Object)

    # The axis which is normal to the plane chosen.
    axis = Enum('x', 'y', 'z',
                desc='specifies the axis normal to the grid plane')

    # The position of the grid plane.
    position = Range(value=0, low='_low', high='_high',
                     enter_set=True, auto_set=False)

    ########################################
    # Private traits.

    # Determines the lower limit of the position trait and is always 0.
    _low = Int(0)

    # Determines the upper limit of the position trait.  The value is
    # dynamically set depending on the input data and state of the
    # axis trait.  The default is some large value to avoid errors in
    # cases where the user may set the position before adding the
    # object to the mayavi tree.
    _high = Int(10000)

    ########################################
    # View related traits.

    # The View for this object.
    view = View(Group(Item(name='axis'),
                      Item(name='position', enabled_when='_high > 0'))
                )

    ######################################################################
    # `object` interface
    ######################################################################
    def __get_pure_state__(self):
        d = super(GridPlane, self).__get_pure_state__()
        # These traits are dynamically created.
        for name in ('plane', '_low', '_high'):
            d.pop(name, None)

        return d

    def __set_pure_state__(self, state):
        state_pickler.set_state(self, state)
        self._position_changed(self.position)

    ######################################################################
    # `Component` interface
    ######################################################################
    def setup_pipeline(self):
        """Override this method so that it *creates* its tvtk
        pipeline.

        This method is invoked when the object is initialized via
        `__init__`.  Note that at the time this method is called, the
        tvtk data pipeline will *not* yet be setup.  So upstream data
        will not be available.  The idea is that you simply create the
        basic objects and setup those parts of the pipeline not
        dependent on upstream sources and filters.
        """
        pass

    def update_pipeline(self):
        """Override this method so that it *updates* the tvtk pipeline
        when data upstream is known to have changed.

        This method is invoked (automatically) when the input fires a
        `pipeline_changed` event.
        """
        if len(self.inputs) == 0:
            return
        input = self.inputs[0].outputs[0]
        plane = None
        if input.is_a('vtkStructuredGrid'):
            plane = tvtk.StructuredGridGeometryFilter()
        elif input.is_a('vtkStructuredPoints') or input.is_a('vtkImageData'):
            plane = tvtk.ImageDataGeometryFilter ()
        elif input.is_a('vtkRectilinearGrid'):
            plane = tvtk.RectilinearGridGeometryFilter ()
        else:
            msg = "The GridPlane component does not support the %s dataset."\
                  %(input.class_name)
            error(msg)
            raise TypeError, msg

        self.configure_connection(plane, self.inputs[0])
        self.plane = plane
        self.plane.update()
        self.outputs = [plane.output]
        self._update_limits()
        self._update_extents()
        # If the data is 2D make sure that we default to the
        # appropriate axis.
        extents = list(_get_extent(input))
        diff = [y-x for x, y in zip(extents[::2], extents[1::2])]
        if diff.count(0) > 0:
            self.axis = ['x', 'y', 'z'][diff.index(0)]


    def update_data(self):
        """Override this method to do what is necessary when upstream
        data changes.

        This method is invoked (automatically) when any of the inputs
        sends a `data_changed` event.
        """
        self._update_limits()
        self._update_extents()
        # Propagate the data_changed event.
        self.data_changed = True

    def has_output_port(self):
        """ The filter has an output port."""
        return True

    def get_output_object(self):
        """ Returns the output port."""
        return self.plane.output_port

    ######################################################################
    # Non-public methods.
    ######################################################################
    def _get_axis_index(self):
        return {'x':0, 'y':1, 'z':2}[self.axis]

    def _update_extents(self):
        inp = self.plane.input
        extents = list(_get_extent(inp))
        pos = self.position
        axis = self._get_axis_index()
        extents[2*axis] = pos
        extents[2*axis+1] = pos
        try:
            self.plane.set_extent(extents)
        except AttributeError:
            self.plane.extent = extents

    def _update_limits(self):
        extents = _get_extent(self.plane.input)
        axis = self._get_axis_index()
        pos = min(self.position, extents[2*axis+1])
        self._high = extents[2*axis+1]
        return pos

    def _axis_changed(self, val):
        if len(self.inputs) == 0:
            return
        pos = self._update_limits()
        if self.position == pos:
            self._update_extents()
            self.data_changed = True
        else:
            self.position = pos

    def _position_changed(self, val):
        if len(self.inputs) == 0:
            return
        self._update_extents()
        self.data_changed = True

########NEW FILE########
__FILENAME__ = implicit_plane
"""A component to manage an implicit plane widget.
"""
# Author: Prabhu Ramachandran <prabhu_r@users.sf.net>
# Copyright (c) 2005, Enthought, Inc.
# License: BSD Style.

# Enthought library imports.
from traits.api import Instance, Bool, Property
from traitsui.api import View, Group, Item, InstanceEditor
from tvtk.api import tvtk

# Local imports.
from mayavi.core.component import Component

VTK_VER = tvtk.Version().vtk_version


######################################################################
# `ImplicitPlane` class.
######################################################################
class ImplicitPlane(Component):
    # The version of this class.  Used for persistence.
    __version__ = 0

    # The widget that controls the plane.
    widget = Instance(tvtk.ImplicitPlaneWidget, args=(),
                      kw={'key_press_activation': False,
                          'place_factor':1.2,
                          'draw_plane':False,
                          'outline_translation':False},
                      record=True)

    # The plane that the widget controls.  Do not change the
    # attributes of the plane, do it via the widget.
    plane = Instance(tvtk.Plane, args=(),
                     kw={'origin':(0.0, 0.0, 0.0),
                         'normal':(0,0,1)},
                     record=True)

    # Convenience property for the normal delegated to the widget.
    normal = Property

    # Convenience property for the origin delegated to the widget.
    origin = Property

    ########################################
    # Private traits

    _first = Bool(True)
    _busy = Bool(False)

    ########################################
    # View related traits.

    if VTK_VER[:3] in ['4.2', '4.4']:
        _widget_group = Group(Item(name='enabled'),
                              Item(name='normal_to_x_axis'),
                              Item(name='normal_to_y_axis'),
                              Item(name='normal_to_z_axis'),
                              Item(name='outline_translation'),
                              Item(name='tubing'),
                              Item(name='draw_plane'),
                              Item(name='normal'),
                              Item(name='origin')
                              )
    else:
        _widget_group = Group(Item(name='enabled'),
                              Item(name='normal_to_x_axis'),
                              Item(name='normal_to_y_axis'),
                              Item(name='normal_to_z_axis'),
                              Item(name='outline_translation'),
                              Item(name='scale_enabled'),
                              Item(name='tubing'),
                              Item(name='draw_plane'),
                              Item(name='normal'),
                              Item(name='origin')
                              )

    view = View(Group(Item(name='widget', style='custom',
                           editor=InstanceEditor(view=View(_widget_group))),
                      show_labels=False)
                )

    ######################################################################
    # `Component` interface
    ######################################################################
    def setup_pipeline(self):
        """Override this method so that it *creates* its tvtk
        pipeline.

        This method is invoked when the object is initialized via
        `__init__`.  Note that at the time this method is called, the
        tvtk data pipeline will *not* yet be setup.  So upstream data
        will not be available.  The idea is that you simply create the
        basic objects and setup those parts of the pipeline not
        dependent on upstream sources and filters.
        """
        # Setup our widgets and hook up all handlers.
        self.widgets = [self.widget]
        self._connect()

    def update_pipeline(self):
        """Override this method so that it *updates* the tvtk pipeline
        when data upstream is known to have changed.

        This method is invoked (automatically) when the input fires a
        `pipeline_changed` event.
        """
        if len(self.inputs) == 0:
            return
        inp = self.inputs[0].outputs[0]
        w = self.widget
        self.configure_input_data(w, inp)
        if self._first:
            w.place_widget()
            self.origin = inp.center
            self._first = False
        else:
            n = self.normal
            # A hack to update the widget when data changes upstream.
            # This is perhaps a VTK bug, not sure.
            self.normal = n[0], n[1], n[2] + 0.001
            self.normal = n

        # Just pass the inputs back out.  This may trigger a pipeline
        # changed downstream if it does not then fire a data_changed.
        if self.outputs != [inp]:
            self.outputs = [inp]
        else:
            self.data_changed = True

    def update_data(self):
        """Override this method to do what is necessary when upstream
        data changes.

        This method is invoked (automatically) when any of the inputs
        sends a `data_changed` event.
        """
        self.data_changed = True

    def update_plane(self):
        """Convenience method to update the plane once the widget is
        changed.
        """
        self.widget.get_plane(self.plane)

    ######################################################################
    # Non-public interface.
    ######################################################################
    def _get_normal(self):
        return self.widget.normal
    def _set_normal(self, value):
        w = self.widget
        old = w.normal
        w.normal = value
        self.trait_property_changed('normal', old, value)
        self.update_plane()

    def _get_origin(self):
        return self.widget.origin
    def _set_origin(self, value):
        # Ugly, but needed.
        w = tvtk.to_vtk(self.widget)
        old = w.GetOrigin()
        w.SetOrigin(list(value))
        self.trait_property_changed('origin', old, value)
        self.update_plane()

    def _on_interaction_event(self, obj, event):
        if not self._busy:
            self._busy = True
            self.update_plane()
            self._busy = False

    def _on_normal_set(self):
        w = self.widget
        w.place_widget()
        w.update_traits()

    def _connect(self):
        """Wires up all the event handlers."""
        w = self.widget
        w.add_observer('InteractionEvent',
                       self._on_interaction_event)
        w.on_trait_change(self._on_normal_set, 'normal_to_x_axis')
        w.on_trait_change(self._on_normal_set, 'normal_to_y_axis')
        w.on_trait_change(self._on_normal_set, 'normal_to_z_axis')
        w.on_trait_change(self._on_interaction_event)

        for obj in (self.plane, w):
            obj.on_trait_change(self.render)


########NEW FILE########
__FILENAME__ = implicit_widgets
"""A component that provides a selection of implicit widgets
to be used by various modules.
"""
# Author: Suyog Dutt Jain <suyog.jain@aero.iitb.ac.in>
#         Prabhu Ramachandran <prabhu at aero.iitb.ac.in>
# Copyright (c) 2009, Enthought, Inc.
# License: BSD Style.

import cPickle

from traits.api import (Instance, Trait, Bool, TraitMap, Enum, Dict,
                                  Str, Int)
from traitsui.api import View, Group, Item
from tvtk.api import tvtk
from apptools.persistence.state_pickler import set_state

from mayavi.core.component import Component

######################################################################
# `ImplicitWidgets` class.
######################################################################
class ImplicitWidgets(Component):

    # The version of this class.  Used for persistence.
    __version__ = 0

    # The widget type to use.
    widget_mode = Enum('Box', 'Sphere', 'Plane','ImplicitPlane',
                       desc='the implicit widget to use')

    # The actual poly data source widget.
    widget = Instance(tvtk.ThreeDWidget, record=True)

    update_mode = Trait('semi-interactive',
                        TraitMap({'interactive':'InteractionEvent',
                                  'semi-interactive': 'EndInteractionEvent'}),
                        desc='speed at which the data should be updated')

    implicit_function = Instance(tvtk.ImplicitFunction, allow_none=False)

    ########################################
    # Private traits.

    _first = Bool(True)
    _busy = Bool(False)
    _observer_id = Int(-1)

    # The actual widgets.
    _widget_dict = Dict(Str, Instance(tvtk.ThreeDWidget,
                        allow_none=False))

    # The actual implicit functions.
    _implicit_function_dict = Dict(Str, Instance(tvtk.ImplicitFunction,
                                   allow_none=False))

    ########################################
    # View related traits.
    ########################################
     # Create the UI for the traits.
    view = View(Group(Item(name='widget_mode'), Item(name='widget',
                            style='custom', resizable=True),
                            label='Widget Source', show_labels=False),
                            resizable=True)

    #####################################################################
    # `object` interface
    ######################################################################
    def __init__(self, **traits):
        # Call parent class' init.
        super(ImplicitWidgets, self).__init__(**traits)

        # Initialize the source to the default widget's instance from
        # the dictionary if needed.
        if 'widget_mode' not in traits:
            self._widget_mode_changed(self.widget_mode)

    ######################################################################
    # `Base` interface
    ######################################################################
    def __get_pure_state__(self):
        d = super(ImplicitWidgets, self).__get_pure_state__()
        for attr in ('_first', '_busy', '_observer_id', 'widget',
                     'implicit_function'):
            d.pop(attr, None)
        # The box widget requires a transformation matrix to be pickled.
        tfm = tvtk.Transform()
        w = self._widget_dict['Box']
        w.get_transform(tfm)
        d['matrix'] = cPickle.dumps(tfm.matrix)
        return d

    def __set_pure_state__(self, state):
        # Pop the transformation matrix for the box widget.
        mat = state.pop('matrix')
        # Now set their state.
        set_state(self, state, first=['widget_mode'], ignore=['*'])
        # Set state of rest of the attributes ignoring the widget_mode.
        set_state(self, state, ignore=['widget_mode'])

        # Set the transformation for Box widget.
        tfm = tvtk.Transform()
        tfm.set_matrix(cPickle.loads(mat))
        w = self._widget_dict['Box']
        w.set_transform(tfm)

        # Some widgets need some cajoling to get their setup right.
        w = self.widget
        # Set the input.
        if len(self.inputs) > 0:
            w.input = self.inputs[0].outputs[0]
        w.update_traits()
        mode = self.widget_mode
        if mode == 'Plane':
            wd = state._widget_dict[mode]
            w.origin = wd.origin
            w.normal = wd.normal
            w.update_placement()
        self.update_implicit_function()
        # Set the widgets trait so that the widget is rendered if needed.
        self.widgets = [w]

    ######################################################################
    # `Component` interface
    ######################################################################
    def setup_pipeline(self):
        """Override this method so that it *creates* the tvtk
        pipeline.
        """
        # Setup the widgets.
        self.widgets = [self.widget]

    def update_pipeline(self):
        """Override this method so that it *updates* the tvtk pipeline
        when data upstream is known to have changed.

        This method is invoked (automatically) when any of the inputs
        sends a `pipeline_changed` event.
        """
        if len(self.inputs) == 0:
            return
        inp = self.inputs[0].outputs[0]
        w = self.widget
        w.input = inp

        if self._first:
            w.place_widget()
            self._first = False

        # Set our output.
        if self.outputs != [inp]:
            self.outputs = [inp]
        else:
            self.data_changed = True

        self.pipeline_changed = True

    def update_data(self):
        """Override this method so that it flushes the vtk pipeline if
        that is necessary.

        This method is invoked (automatically) when any of the inputs
        sends a `data_changed` event.
        """
        self.data_changed = True

    ######################################################################
    # `SourceWidget` interface
    ######################################################################
    def update_implicit_function(self):
        """Update the implicit_function from the widget data.
        """
        dispatch = {'Sphere': 'get_sphere', 'Box': 'get_planes',
                    'Plane': 'get_plane', 'ImplicitPlane': 'get_plane'}
        method = getattr(self.widget, dispatch[self.widget_mode])
        method(self.implicit_function)

    ######################################################################
    # Non-public traits.
    ######################################################################
    def _widget_changed(self, old, value):
        if len(self.inputs) > 0:
            value.input = self.inputs[0].outputs[0]
            value.place_widget()
        self.implicit_function = self._implicit_function_dict[self.widget_mode]

        if old is not None:
            self._connect(old, remove=True)
        self._connect(value, remove=False)
        self.widgets = [value]

    def _connect(self, value, remove=False):
        """Wire up event handlers or tear them down given a widget
        `value`.  If `remove` is True, then tear them down."""
        if remove and self._observer_id > 0:
                value.remove_observer(self._observer_id)
        else:
            self._observer_id = value.add_observer(self.update_mode_,
                                                   self._on_interaction_event)
        if isinstance(value, tvtk.PlaneWidget) or \
            isinstance(value, tvtk.ImplicitPlaneWidget):
            value.on_trait_change(self._on_alignment_set,
                                  'normal_to_x_axis', remove=remove)
            value.on_trait_change(self._on_alignment_set,
                                  'normal_to_y_axis', remove=remove)
            value.on_trait_change(self._on_alignment_set,
                                  'normal_to_z_axis', remove=remove)

        value.on_trait_change(self._on_widget_trait_changed,
                              remove=remove)
        value.on_trait_change(self.render, remove=remove)

    def _on_interaction_event(self, obj, event):
        self.update_implicit_function()

    def _update_mode_changed(self, old, new):
        w = self.widget
        if w is not None:
            w.remove_observer(self._observer_id)
            self._observer_id = w.add_observer(self.update_mode_,
                    self._on_interaction_event)

            w.on_trait_change(self.render)
            self.render()

    def _on_widget_trait_changed(self):
        if (not self._busy) and (self.update_mode != 'non-interactive'):
            self._busy = True
            self.implicit_function = self._implicit_function_dict[self.widget_mode]
            self.update_implicit_function()
            self.render()
            self._busy = False

    def _on_alignment_set(self):
        """Event handler when the widget's normal is reset (if
        applicable)."""
        w = self.widget
        w.place_widget()
        w.update_traits()
        self.render()

    def _scene_changed(self, old, new):
        super(ImplicitWidgets, self)._scene_changed(old, new)
        self._foreground_changed_for_scene(None, new.foreground)

    def _widget_mode_changed(self, value):
        """This method is invoked (automatically) when the `source`
        trait is changed.
        """
        self.widget = self._widget_dict[self.widget_mode]

    def __widget_dict_default(self):
        """Default value for source dict."""
        w = {'Box':tvtk.BoxWidget(place_factor = 0.9),
             'Sphere':tvtk.SphereWidget(place_factor = 0.9),
             'Plane':tvtk.PlaneWidget(place_factor = 0.9),
             'ImplicitPlane':
                tvtk.ImplicitPlaneWidget(place_factor=0.9,
                                         draw_plane=False)}
        return w

    def __implicit_function_dict_default(self):
        """Default value for source dict."""
        ip = {'Box':tvtk.Planes(),
              'Sphere':tvtk.Sphere(),
              'Plane':tvtk.Plane(),
              'ImplicitPlane': tvtk.Plane()}
        return ip

########NEW FILE########
__FILENAME__ = optional
"""A meta-component that allows a component to be optionally enabled
or disabled.  This component is mostly for illustration and is not
used anywhere.  This is because it is usually much easier to simply
add a trait in the module to enable/disable a particular component.

"""
# Author: Prabhu Ramachandran <prabhu_r@users.sf.net>
# Copyright (c) 2005, Enthought, Inc.
# License: BSD Style.

# Enthought library imports.
from traits.api import Instance, Bool, Str, Property
from traitsui.api import View, Group, Item

# Local imports.
from mayavi.core.component import Component


######################################################################
# `Optional` class.
######################################################################
class Optional(Component):
    # The version of this class.  Used for persistence.
    __version__ = 0

    # The outputs of this component is a property and not a list.
    outputs = Property

    # The component that is enabled or disabled.
    component = Instance(Component)

    # Is the component enabled or not.
    enabled = Bool(True, desc='if the component is enabled')

    # The label of the checkbox to use in the view.
    label = Str

    ########################################
    # The component's view

    # This is defined outside the view so that the label may be easily
    # changed.
    enabled_item = Item(name='enabled')
    view = View(Group(Group(enabled_item),
                      Group(Item(name='component', style='custom',
                                 visible_when='object.enabled'),
                            show_labels=False)
                      )
                )

    ######################################################################
    # `Component` interface
    ######################################################################
    def update_pipeline(self):
        """Override this method so that it *updates* the tvtk pipeline
        when data upstream is known to have changed.

        This method is invoked (automatically) when the input fires a
        `pipeline_changed` event.
        """
        comp = self.component
        if self.inputs != comp.inputs:
            comp.inputs = self.inputs
        self.pipeline_changed = True

    def update_data(self):
        """Override this method to do what is necessary when upstream
        data changes.

        This method is invoked (automatically) when any of the inputs
        sends a `data_changed` event.
        """
        self.data_changed = True

    ######################################################################
    # `Base` interface
    ######################################################################
    def start(self):
        """This is invoked when this object is added to the mayavi
        pipeline.  Note that when start is invoked, all the other
        information for the pipeline should be already set.
        """
        # Do nothing if we are already running.
        if self.running:
            return

        super(Optional, self).start()
        self.component.start()

    def stop(self):
        """Invoked when this object is removed from the mayavi
        pipeline.
        """
        if not self.running:
            return

        self.component.stop()
        super(Optional, self).stop()

    ######################################################################
    # Non-public methods.
    ######################################################################
    def _get_outputs(self):
        if self.enabled:
            return self.component.outputs
        else:
            return self.inputs[0].get_output_object()

    def _enabled_changed(self, value):
        # Force downstream modules to update.
        self.pipeline_changed = True

    def _label_changed(self, value):
        # Change the displayed label for the enable trait in the view.
        item = self.trait_view_elements().content['enabled_item']
        item.label = value

    def _component_changed(self, old, new):
        if old is not None:
            old.on_trait_change(self._fire_pipeline_changed,
                                 'pipeline_changed', remove=True)
            old.on_trait_change(self._fire_data_changed,
                                 'data_changed', remove=True)

        new.on_trait_change(self._fire_pipeline_changed, 'pipeline_changed')
        new.on_trait_change(self._fire_data_changed, 'data_changed')

    def _fire_pipeline_changed(self):
        self.pipeline_changed = True

    def _fire_data_changed(self):
        self.data_changed = True



########NEW FILE########
__FILENAME__ = poly_data_normals
"""This component computes normals for input poly data.
"""
# Author: Prabhu Ramachandran <prabhu_r@users.sf.net>
# Copyright (c) 2005,  Enthought, Inc.
# License: BSD Style.

# Enthought library imports.
from traits.api import Instance
from traitsui.api import View, Group, Item, InstanceEditor
from tvtk.api import tvtk

# Local imports.
from mayavi.core.component import Component
from mayavi.components.common import convert_to_poly_data


######################################################################
# `PolyDataNormals` class.
######################################################################
class PolyDataNormals(Component):
    # The version of this class.  Used for persistence.
    __version__ = 0

    # The filter that generates the normals.
    filter = Instance(tvtk.PolyDataNormals, args=(),
                      kw={'feature_angle': 45.0}, record=True)

    ########################################
    # The component's view

    _filter_group = Group(Item(name='feature_angle'))

    view = View(Group(Item(name='filter', style='custom',
                           editor=InstanceEditor(view=View(_filter_group))),
                      show_labels=False
                      )
                )

    ######################################################################
    # `Component` interface
    ######################################################################
    def setup_pipeline(self):
        """Override this method so that it *creates* its tvtk
        pipeline.

        This method is invoked when the object is initialized via
        `__init__`.  Note that at the time this method is called, the
        tvtk data pipeline will *not* yet be setup.  So upstream data
        will not be available.  The idea is that you simply create the
        basic objects and setup those parts of the pipeline not
        dependent on upstream sources and filters.
        """
        self.filter.on_trait_change(self.update_data)

    def update_pipeline(self):
        """Override this method so that it *updates* the tvtk pipeline
        when data upstream is known to have changed.

        This method is invoked (automatically) when the input fires a
        `pipeline_changed` event.
        """
        if (len(self.inputs) == 0) or \
               (len(self.inputs[0].outputs) == 0):
            return
        f = self.filter
        input = self.inputs[0].outputs[0]
        self.configure_input_data(f, convert_to_poly_data(input))
        f.update()
        self.outputs = [f.output]

    def update_data(self):
        """Override this method to do what is necessary when upstream
        data changes.

        This method is invoked (automatically) when any of the inputs
        sends a `data_changed` event.
        """
        self.data_changed = True

    def has_output_port(self):
        """ The filter has an output port."""
        return True

    def get_output_object(self):
        """ Returns the output port."""
        return self.filter.output_port


########NEW FILE########
__FILENAME__ = source_widget
"""A component that provides a selection of poly data source widgets
to be used by various modules.

"""
# Author: Prabhu Ramachandran <prabhu_r@users.sf.net>
# Copyright (c) 2005, Enthought, Inc.
# License: BSD Style.

# Enthought library imports.
from traits.api import Event, Instance, List, Trait, Bool, TraitPrefixList
from traitsui.api import View, Group, Item, InstanceEditor
from tvtk.api import tvtk
from tvtk.common import configure_input_data
from apptools.persistence.state_pickler import set_state

# Local imports.
from mayavi.core.common import handle_children_state
from mayavi.core.component import Component

######################################################################
# `SourceWidget` class.
######################################################################
class SourceWidget(Component):

    # The version of this class.  Used for persistence.
    __version__ = 0

    # The actual poly data source widget.
    widget = Instance(tvtk.ThreeDWidget, record=True)

    # Specifies the updation mode of the poly_data attribute.  There
    # are three modes: 1) 'interactive' -- the poly_data attribute is
    # updated as the widget is interacted with, 2) 'semi-interactive'
    # -- poly_data attribute is updated when the traits of the widget
    # change and when the widget interaction is complete, 3)
    # 'non-interactive' -- poly_data is updated only explicitly at
    # users request by calling `object.update_poly_data`.
    update_mode = Trait('interactive', TraitPrefixList(['interactive',
                                                        'semi-interactive',
                                                        'non-interactive']),
                        desc='the speed at which the poly data is updated')

    # A list of predefined glyph sources that can be used.
    widget_list = List(tvtk.Object, record=False)

    # The poly data that the widget manages.
    poly_data = Instance(tvtk.PolyData, args=())

    ########################################
    # Private traits.

    _first = Bool(True)
    _busy = Bool(False)
    _unpickling = Bool(False)

    ########################################
    # View related traits.

    view = View(Group(Item(name='widget', style='custom', resizable=True,
                           editor=InstanceEditor(name='widget_list')),
                      label='Source Widget',
                      show_labels=False,
                      ),
                resizable=True,
                )

    ######################################################################
    # `Base` interface
    ######################################################################
    def __get_pure_state__(self):
        d = super(SourceWidget, self).__get_pure_state__()
        for attr in ('poly_data', '_unpickling', '_first', '_busy'):
            d.pop(attr, None)
        return d

    def __set_pure_state__(self, state):
        self._unpickling = True
        # First create all the allowed widgets in the widget_list attr.
        handle_children_state(self.widget_list, state.widget_list)
        # Now set their state.
        set_state(self, state, first=['widget_list'], ignore=['*'])
        # Set the widget attr depending on value saved.
        m = [x.__class__.__name__ for x in self.widget_list]
        w_c_name = state.widget.__metadata__['class_name']
        w = self.widget = self.widget_list[m.index(w_c_name)]
        # Set the input.
        if len(self.inputs) > 0:
            self.configure_input_data(w, self.inputs[0].outputs[0])
        # Fix for the point widget.
        if w_c_name == 'PointWidget':
            w.place_widget()
        # Set state of rest of the attributes ignoring the widget_list.
        set_state(self, state, ignore=['widget_list'])
        # Some widgets need some cajoling to get their setup right.
        w.update_traits()
        if w_c_name == 'PlaneWidget':
            w.origin = state.widget.origin
            w.normal = state.widget.normal
            w.update_placement()
            w.get_poly_data(self.poly_data)
        elif w_c_name == 'SphereWidget':
            # XXX: This hack is necessary because the sphere widget
            # does not update its poly data even when its ivars are
            # set (plus it does not have an update_placement method
            # which is a bug).  So we force this by creating a similar
            # sphere source and copy its output.
            s = tvtk.SphereSource(center=w.center, radius=w.radius,
                                  theta_resolution=w.theta_resolution,
                                  phi_resolution=w.phi_resolution,
                                  lat_long_tessellation=True)
            s.update()
            self.poly_data.shallow_copy(s.output)
        else:
            w.get_poly_data(self.poly_data)
        self._unpickling = False
        # Set the widgets trait so that the widget is rendered if needed.
        self.widgets = [w]

    ######################################################################
    # `Component` interface
    ######################################################################
    def setup_pipeline(self):
        """Override this method so that it *creates* the tvtk
        pipeline.

        This method is invoked when the object is initialized via
        `__init__`.  Note that at the time this method is called, the
        tvtk data pipeline will *not* yet be setup.  So upstream data
        will not be available.  The idea is that you simply create the
        basic objects and setup those parts of the pipeline not
        dependent on upstream sources and filters.  You should also
        set the `actors` attribute up at this point.
        """
        # Setup the glyphs.
        sources = [tvtk.SphereWidget(theta_resolution=8, phi_resolution=6),
                   tvtk.LineWidget(clamp_to_bounds=False),
                   tvtk.PlaneWidget(),
                   tvtk.PointWidget(outline=False, x_shadows=False,
                                    y_shadows=False, z_shadows=False),
                   ]
        self.widget_list = sources
        # The 'widgets' trait is set in the '_widget_changed' handler.
        self.widget = sources[0]

        for s in sources:
            self._connect(s)

    def update_pipeline(self):
        """Override this method so that it *updates* the tvtk pipeline
        when data upstream is known to have changed.

        This method is invoked (automatically) when any of the inputs
        sends a `pipeline_changed` event.
        """
        if len(self.inputs) == 0:
            return
        inp = self.inputs[0].outputs[0]
        w = self.widget
        self.configure_input(w, inp)
        if self._first:
            w.place_widget()
            self._first = False

        # If the dataset is effectively 2D switch to using the line
        # widget since that works best.
        b = inp.bounds
        l = [(b[1]-b[0]), (b[3]-b[2]), (b[5]-b[4])]
        max_l = max(l)
        for i, x in enumerate(l):
            if x/max_l < 1.0e-6:
                w = self.widget = self.widget_list[1]
                w.clamp_to_bounds = True
                w.align = ['z_axis', 'z_axis', 'y_axis'][i]
                break

        # Set our output.
        w.get_poly_data(self.poly_data)
        self.outputs = [self.poly_data]

        self.pipeline_changed = True

    def update_data(self):
        """Override this method so that it flushes the vtk pipeline if
        that is necessary.

        This method is invoked (automatically) when any of the inputs
        sends a `data_changed` event.
        """
        self.data_changed = True

    ######################################################################
    # `SourceWidget` interface
    ######################################################################
    def update_poly_data(self):
        self.widget.get_poly_data(self.poly_data)

    ######################################################################
    # Non-public traits.
    ######################################################################
    def _widget_changed(self, value):
        # If we are being unpickled do nothing.
        if self._unpickling:
            return
        if value not in self.widget_list:
            classes = [o.__class__ for o in self.widget_list]
            vc = value.__class__
            self._connect(value)
            if vc in classes:
                self.widget_list[classes.index(vc)] = value
            else:
                self.widget_list.append(value)

        recorder = self.recorder
        if recorder is not None:
            idx = self.widget_list.index(value)
            name = recorder.get_script_id(self)
            lhs = '%s.widget'%name
            rhs = '%s.widget_list[%d]'%(name, idx)
            recorder.record('%s = %s'%(lhs, rhs))

        if len(self.inputs) > 0:
            configure_input_data(value, self.inputs[0].outputs[0])
            value.place_widget()

        value.on_trait_change(self.render)
        self.widgets = [value]

    def _update_mode_changed(self, value):
        if value in ['interactive', 'semi-interactive']:
            self.update_poly_data()
            self.render()

    def _on_interaction_event(self, obj, event):
        if (not self._busy) and (self.update_mode == 'interactive'):
            self._busy = True
            self.update_poly_data()
            self._busy = False

    def _on_widget_trait_changed(self):
        if (not self._busy) and (self.update_mode != 'non-interactive'):
            self._busy = True
            # This render call forces any changes to the trait to be
            # rendered only then will updating the poly data make
            # sense.
            self.render()
            self.update_poly_data()
            self._busy = False

    def _on_alignment_set(self):
        w = self.widget
        w.place_widget()
        w.update_traits()

    def _connect(self, obj):
        """Wires up all the event handlers."""
        obj.add_observer('InteractionEvent',
                         self._on_interaction_event)
        if isinstance(obj, tvtk.PlaneWidget):
            obj.on_trait_change(self._on_alignment_set, 'normal_to_x_axis')
            obj.on_trait_change(self._on_alignment_set, 'normal_to_y_axis')
            obj.on_trait_change(self._on_alignment_set, 'normal_to_z_axis')
        elif isinstance(obj, tvtk.LineWidget):
            obj.on_trait_change(self._on_alignment_set, 'align')

        # Setup the widgets colors.
        fg = (1,1,1)
        if self.scene is not None:
            fg = self.scene.foreground
        self._setup_widget_colors(obj, fg)

        obj.on_trait_change(self._on_widget_trait_changed)
        obj.on_trait_change(self.render)

    def _setup_widget_colors(self, widget, color):
        trait_names = widget.trait_names()
        props = [x for x in trait_names
                 if 'property' in x and 'selected' not in x]
        sel_props = [x for x in trait_names
                     if 'property' in x and 'selected' in x]
        for p in props:
            setattr(getattr(widget, p), 'color', color)
            setattr(getattr(widget, p), 'line_width', 2)
        for p in sel_props:
            # Set the selected color to 'red'.
            setattr(getattr(widget, p), 'color', (1,0,0))
            setattr(getattr(widget, p), 'line_width', 2)
        self.render()

    def _foreground_changed_for_scene(self, old, new):
        # Change the default color for the actor.
        for w in self.widget_list:
            self._setup_widget_colors(w, new)
        self.render()

    def _scene_changed(self, old, new):
        super(SourceWidget, self)._scene_changed(old, new)
        self._foreground_changed_for_scene(None, new.foreground)

########NEW FILE########
__FILENAME__ = actor
"""
Traits View definition file.

The view trait of the parent class is extracted from the model definition
file.  This file can either be exec()ed or imported.  See
core/base.py:Base.trait_view() for what is currently used.  Using exec()
allows view changes without needing to restart Mayavi, but is slower than
importing.
"""
# Authors: Prabhu Ramachandran <prabhu_r@users.sf.net>
#          Judah De Paula <judah@enthought.com>
# Copyright (c) 2005-2008, Enthought, Inc.
# License: BSD Style.

from traitsui.api import (View, Group, Item, InstanceEditor,
        DropEditor, Tabbed)
from tvtk.api import tvtk

VTK_VER = tvtk.Version().vtk_version

# The properties view group.
_prop_base_group = Group(Item(name='representation'),
                    Item(name='color'),
                    Item(name='line_width'),
                    Item(name='point_size'),
                    Item(name='opacity'),
                    )

_prop_group = Group(Item(name='property', style='custom', show_label=False,
                         editor=InstanceEditor(view=View(_prop_base_group))),
                     Item(name='property',
                          show_label=False,
                          editor=InstanceEditor(label='More options ...')),
                     show_border=True, label='Property')


# The mapper's view group.
if VTK_VER[:3] in ['4.2', '4.4']:
    _mapper_base_group = Group(Item(name='scalar_visibility'))
else:
    _mapper_base_group = Group(Item(name='scalar_visibility'),
                            Item(name='interpolate_scalars_before_mapping'),
                          )

_mapper_group = Group(Item(name='mapper', style='custom', show_label=False,
                         editor=InstanceEditor(view=View(_mapper_base_group))),
                     Item(name='mapper',
                          show_label=False,
                          editor=InstanceEditor(label='More options ...')),
                     show_border=True, label='Mapper')

# The Texture's view group
_texture_group = Group(Item(name='interpolate'),
                       Item(name='map_color_scalars_through_lookup_table'),
                       Item(name='repeat'),
                       show_border=True,
                       #label='Texture',
                       )

# The Actor's view group.
_actor_base_group = Group(Item(name='visibility'))#,
_actor_group = Group(Item(name='actor', style='custom', show_label=False,
                         editor=InstanceEditor(view=View(_actor_base_group))),
                     Item(name='actor',
                          show_label=False,
                          editor=InstanceEditor(label='More options ...')),
                     show_border=True, label='Actor')



actor_group = Group(_actor_group,
                    _mapper_group,
                    _prop_group,
                    label='Actor',
                    show_labels=False,
                    )

texture_group = Group(Item(name='enable_texture'),
                  Group(Item(name='texture_source_object',
                             editor=DropEditor()),
                        Item(name='tcoord_generator_mode'),
                    Tabbed(Item(name='texture',
                                style='custom',
                                show_label=False,
                                editor=InstanceEditor(view=View(_texture_group))),
                           Item(name='tcoord_generator',
                                style='custom',
                                show_label=False,
                                resizable=True,
                                visible_when='texture_mode != "none"'),
                           ),
                        show_labels=True,
                        label='Texture Properties',
                        enabled_when='object.enable_texture',
                        show_border=True),
                    label='Texture',
                )


# The Views for this object.  Pick the one that you need.
actor_view = View(actor_group, resizable=True)
texture_view = View(texture_group, resizable=True)
view = View(actor_group, texture_group, resizable=True)

########NEW FILE########
__FILENAME__ = contour
"""
Traits View definition file.

The view trait of the parent class has been extracted from the model
definition file.  This file can either be exec()ed or imported.  See
core/base.py:Base.trait_view() for what is currently used.  Using exec()
allows view changes without needing to restart Mayavi, but is slower than
importing.
"""
# Authors: Prabhu Ramachandran <prabhu_r@users.sf.net>
#          Judah De Paula <judah@enthought.com>
# Copyright (c) 2005-2008, Enthought, Inc.
# License: BSD Style.

from traitsui.api import Item, Group, View

view = View(Group(Item(name='filled_contours',
                       defined_when='show_filled_contours'),
                  Item(name='auto_contours'),

                  # One group or the other, but not both.
                  Group(
                       Item(name='contours',
                            style='custom',
                            visible_when='not auto_contours',
                            show_label=False),
                  ),
                  Group(
                      Item(name='number_of_contours'),
                      Item(name='minimum_contour'),
                      Item(name='maximum_contour'),
                      visible_when='auto_contours',
                  ),

                  Item(name='auto_update_range'),
                  Group(
                        Item(name='_data_min',
                             label='Data minimum'),
                        Item(name='_data_max',
                             label='Data maximum'),
                             visible_when='not auto_update_range',
                  )
               )
           )

########NEW FILE########
__FILENAME__ = adder_node
"""
Custom nodes for a Tree Editor that provide views for adding various nodes
to the tree.
"""
# Authors: Judah De Paula <judah@enthought.com>
#          Prabhu Ramachandran <prabhu_r@users.sf.net>
# Copyright (c) 2008, Enthought, Inc.
# License: BSD Style.

# Enthought library imports.
from traits.api import (HasTraits, Str, Property, Any, Button,
                                  List, Instance, implements,
                                  ToolbarButton)
from traitsui.api import View, Item, Group,\
        TextEditor, TreeEditor, TreeNode, ListEditor, ITreeNode
from pyface.api import ImageResource
from pyface.resource.api import resource_path

# Local imports.
from .registry import registry

###############################################################################
# AdderNode class
###############################################################################
class AdderNode(TreeNode):
    """ Base class that will display a TreeNode to add items to the tree.
    """
    implements(ITreeNode)

    # String to be shown in the TreeEditor.
    label = Str('Base AdderNode')

    # Default tooltip for this class.
    tooltip = Str('Add an item')

    # The parent object that should be manipulated for adding children.
    object =  Any

    # Duck-typing is necessary since Mayavi assumes nodes always have scenes.
    scene = Property

    # Trait view to show in the Mayavi current object panel.
    view = View(Group(label='AdderNode'))

    def dialog_view(self):
        """ View shown by double-clicking on the node.  Same as in Base().
        """
        view = self.trait_view()
        view.buttons = [ ]
        view.title = self.label
        view.icon = ImageResource('add.ico')
        view.resizable = True
        view.width = 350
        view.height = 650
        return view

    def _get_scene(self):
        """ Trait Property getter for 'scene'.
        """
        object = self.object
        if isinstance(object, AdderNode):
            return None
        if object is not None:
            return object.scene
        else:
            return None

    #------------------------------------------------------------------------
    # The ITreeNode interface needed by the Qt tree_editor
    #------------------------------------------------------------------------

    def get_label(self):
        return self.label

    def get_icon(self, obj, is_expanded=False):
        return self.icon_name

    def get_icon_path(self):
        return resource_path()

    def get_tooltip(self):
        return self.tooltip

    def allows_children(self):
        return False

    def get_children_id(self, node=None):
        return []

    def when_label_changed(self, label_updated, remove):
        return

    def when_column_labels_change(self, listener, remove):
        return

###############################################################################
# SceneAdderNode class
###############################################################################
class SceneAdderNode(AdderNode):
    """ Subclass for adding Scene nodes to a Mayavi Engine node.
    """

    # String to be shown in the TreeEditor.
    label = Str('Add a new scene')

    # The name of the icon
    icon_name = Str('add_scene.png')

    # Button for the View.
    add_scene = Button('Add a new scene',
                      image=ImageResource('add_scene.png'))

    # Trait view to show in the Mayavi current object panel.
    view = View(Group(Item('add_scene', show_label=False, style='custom'),
                      label='Add a scene'))


    def _add_scene_fired(self):
        """ Trait handler for when the add_scene button is clicked.
        """
        self.object.new_scene()


###############################################################################
# DocumentedItem class
###############################################################################
class DocumentedItem(HasTraits):
    """ Container to hold a name and a documentation for an action.
    """

    # Name of the action
    name = Str

    # Button to trigger the action
    add = ToolbarButton('Add', orientation='horizontal',
                    image=ImageResource('add.ico'))

    # Object the action will apply on
    object = Any

    # Two lines documentation for the action
    documentation = Str

    view = View('_',
                Item('add', style='custom', show_label=False),
                Item('documentation', style='readonly',
                    editor=TextEditor(multi_line=True),
                    resizable=True,
                    show_label=False),
                )

    def _add_fired(self):
        """ Trait handler for when the add_source button is clicked in
            one of the sub objects in the list.
        """
        action = getattr(self.object.menu_helper, self.id)
        action()


def documented_item_factory(name='', documentation='',
                id='', object=None):
    """ Factory for creating a DocumentedItem with the right button
        label.
    """
    documentation = documentation.replace('\n', '')
    documentation = documentation.replace('  ', '')

    class MyDocumentedItem(DocumentedItem):
        add = ToolbarButton('%s' % name, orientation='horizontal',
                        image=ImageResource('add.ico'))

    return MyDocumentedItem(
                        name=name,
                        documentation=documentation,
                        id=id,
                        object=object)


###############################################################################
# ListAdderNode class
###############################################################################
class ListAdderNode(AdderNode):
    """ A node for adding object, with a list of objects to add generated
        from the registry.
    """

    # The list of items to display to the user.
    items_list = List(DocumentedItem)

    # A reference to the registry, to generate this list.
    items_list_source = List()

    # Selected item
    selected_item = Instance(DocumentedItem)

    # A reference to self, to allow to build the tree view.
    self = Instance(AdderNode)

    # The icon of the displayed objects
    icon_name = Str('add.ico')

    def _self_default(self):
        return self

    def default_traits_view(self):
        nodes = [TreeNode(node_for=[AdderNode],
                          label='name',
                          copy=False,
                          delete=False,
                          rename=False,
                          children='items_list',
                          ),
                 TreeNode(node_for=[DocumentedItem],
                          label='name',
                          copy=False,
                          delete=False,
                          rename=False,
                          icon_item=self.icon_name,
                          ),
                 ]

        tree_editor = TreeEditor(editable=False,
                                 hide_root=True,
                                 orientation='vertical',
                                 selected='object.selected_item',
                                 nodes=nodes,
                                 on_dclick='object._on_tree_dclick',
                                 )

        view = View(Item('self',
                            show_label=False,
                            editor=tree_editor,
                            resizable=True,
                            springy=True,
                            height=0.5),
                    Item('selected_item', style='custom', show_label=False,
                            height=0.5),
                    resizable=True)
        return view


    def _object_changed(self, value):
        """ Trait handler for when the self.object trait changes.
        """
        result = []
        if value is not None:
            # Don't need 'x', but do need to generate the actions.
            x = value.menu_helper.actions
            for src in self.items_list_source:
                if not self._is_action_suitable(value, src):
                    continue
                name = src.menu_name.replace('&','')
                result.append(
                        documented_item_factory(
                                name=name,
                                documentation=src.help,
                                id=src.id,
                                object=value)
                        )
        self.items_list = result


    def _is_action_suitable(self, object, src):
        """ Check that the action described by src can be applied on the
            given object.
        """
        if  hasattr(object.menu_helper, 'check_%s' % src.id) \
                and getattr(object.menu_helper, 'check_%s' % src.id)():
            return True
        else:
            return False

    def _on_tree_dclick(self, object):
        """ Called when an user double clicks on an item in the tree
            view.
        """
        object._add_fired()


###############################################################################
# SourceAdderNode class
###############################################################################
class SourceAdderNode(ListAdderNode):
    """ Tree node that presents a view to the user to add a scene source.
    """

    # Button for adding a data file, with automatic format checking.
    open_file = ToolbarButton('Load data from file',
                                orientation='horizontal',
                                image=ImageResource('file.png'))

    # A reference to the registry, to generate this list.
    items_list_source = [source for source in registry.sources
                         if len(source.extensions) == 0]

    # The string to display on the icon in the TreeEditor.
    label = 'Add Data Source'

    # The icon of the displayed objects
    icon_name = Str('source.ico')

    # Trait view to show in the Mayavi current object panel.
    def default_traits_view(self):
        return View(Group(Group(Item('open_file', style='custom'),
                      show_labels=False, show_border=False),
                      Item('items_list', style='readonly',
                            editor=ListEditor(style='custom')),
                      show_labels=False,
                      label='Add a data source'))

    def _open_file_fired(self):
        """ Trait handler for when the open_file button is clicked.
        """
        self.object.menu_helper.open_file_action()

    def _is_action_suitable(self, object, src):
        return True


###############################################################################
# ModuleAdderNode class
###############################################################################
class ModuleAdderNode(ListAdderNode):
    """ Tree node that presents a view to the user to add modules.
    """
    # String to be shown in the TreeEditor.
    label = Str('Add a visualization module')

    # The icon of the displayed objects
    icon_name = Str('module.ico')

    # A reference to the registry, to generate this list.
    items_list_source = registry.modules

    def _object_changed(self, value):
        if value is not None:
            value.menu_helper._build_filter_actions()
        ListAdderNode._object_changed(self, value)


###############################################################################
# FilterAdderNode class
###############################################################################
class FilterAdderNode(ListAdderNode):
    """ Tree node that presents a view to the user to add filters.
    """
    # String to be shown in the TreeEditor.
    label = Str('Add a processing filter')

    # The icon of the displayed objects
    icon_name = Str('filter.ico')

    # A reference to the registry, to generate this list.
    items_list_source = registry.filters


###############################################################################
# ModuleFilterAdderNode class
###############################################################################
class ModuleFilterAdderNode(AdderNode):
    """ Tree node that presents a view to the user to add filter and
        modules.
    """

    # The string to display on the icon in the TreeEditor.
    label = 'Add module or filter'

    # An adder node for modules
    modules = Instance(ModuleAdderNode, ())

    # An adder node for filters
    filters = Instance(FilterAdderNode, ())

    def _object_changed(self):
        """ Propagate the object to the sub nodes.
        """
        self.filters.object = self.object
        self.modules.object = self.object

    # Trait view to show in the Mayavi current object panel.
    view = View(
                Group(Item('modules', style='custom', springy=True,
                            resizable=True,
                            height=1.,
                            ),
                    show_labels=False,
                    label='Visualization modules'),
                Group(Item('filters', style='custom', springy=True,
                            resizable=True,
                            height=1.,
                            ),
                    show_labels=False,
                    label='Processing filters'),
                )


### EOF #######################################################################

########NEW FILE########
__FILENAME__ = api

from .registry import registry
from .metadata import SourceMetadata
from .pipeline_info import PipelineInfo
from .pipeline_base import PipelineBase
from .engine import Engine
from .null_engine import NullEngine
from .off_screen_engine import OffScreenEngine
from .module_manager import ModuleManager
from .source import Source
from .scene import Scene
from .filter import Filter
from .module import Module


########NEW FILE########
__FILENAME__ = base
"""The base object from which all MayaVi pipeline objects derive.

"""
# Author: Prabhu Ramachandran <prabhu_r@users.sf.net>
# Copyright (c) 2005, Enthought, Inc.
# License: BSD Style.

# Standard library imports.
import cPickle
from copy import deepcopy
import os
import logging
import imp

# Enthought library imports.
from traits.api import (Instance, Property, Bool, Str, Python,
    HasTraits, WeakRef, on_trait_change)
from traitsui.api import TreeNodeObject
from tvtk.pyface.tvtk_scene import TVTKScene
from apptools.persistence import state_pickler
from pyface.resource.api import resource_path
from pyface.image_resource import ImageResource
from traitsui.menu import Menu, Action, Separator
from traitsui.api import View
from apptools.scripting.api import Recorder

# Local imports.
from tvtk.common import is_old_pipeline
from mayavi.preferences.api import preference_manager
from mayavi.core.common import get_engine

# Setup a logger for this module.
logger = logging.getLogger(__name__)

# Subdirectory that the Base class will check for possible external views.
UI_DIR_NAME = ['ui']

#-------------------------------------------------------------------------------
#  The core tree node menu actions:
#-------------------------------------------------------------------------------

NewAction    = 'NewAction'
CopyAction   = Action(name         = 'Copy',
                      action       = 'editor._menu_copy_node',
                      enabled_when = 'editor._is_copyable(object)' )
CutAction    = Action(name         = 'Cut',
                      action       = 'editor._menu_cut_node',
                      enabled_when = 'editor._is_cutable(object)' )
PasteAction  = Action(name         = 'Paste',
                      action       = 'editor._menu_paste_node',
                      enabled_when = 'editor._is_pasteable(object)' )
DeleteAction = Action(name         = 'Delete',
                      action       = 'editor._menu_delete_node',
                      enabled_when = 'editor._is_deletable(object)' )
RenameAction = Action(name         = 'Rename',
                      action       = 'editor._menu_rename_node',
                      enabled_when = 'editor._is_renameable(object)' )
standard_menu_actions = [Separator(), CutAction, CopyAction, PasteAction,
                         Separator(),
                         RenameAction, DeleteAction, Separator(),
                        ]


######################################################################
# `Base` class.
######################################################################
class Base(TreeNodeObject):
    # The version of this class.  Used for persistence.
    __version__ = 0

    ########################################
    # Traits

    # The scene (RenderWindow) associated with this component.
    scene = Instance(TVTKScene, record=False)

    # Is this object running as part of the mayavi pipeline.
    running = Property(Bool, record=False)

    # The object's name.
    name = Str('')

    # The default icon.
    icon = 'module.ico'

    # The human readable type for this object
    type = Str('', record=False)

    # Is this object visible or not.
    visible = Bool(True, desc='if the object is visible')

    # Extend the children list with an AdderNode when a TreeEditor needs it.
    children_ui_list = Property(depends_on=['children'], record=False)

    # The parent of this object, i.e. self is an element of the parents
    # children.  If there is no notion of a parent/child relationship
    # this trait is None.
    parent = WeakRef(record=False)

    # A helper for the right click menus, context sensitivity etc.
    menu_helper = Instance(HasTraits, record=False)

    # Our recorder.
    recorder = Instance(Recorder, record=False)

    ##################################################
    # Private traits
    _is_running = Bool(False)

    # This is used to save the state of the object when it is not
    # running.  When the object "starts", the state is loaded.  This
    # is done because a stopped object will not have a meaningful VTK
    # pipeline setup, so setting its state will lead to all kinds of
    # errors.
    _saved_state = Str('')

    # Hide and show actions
    _HideShowAction = Instance(Action,
                               kw={'name': 'Hide/Show',
                                   'action': 'object._hideshow'}, )

    # The menu shown on right-click for this.
    _menu = Instance(Menu, transient=True)

    # Path to the icon for this object.
    _icon_path = Str()

    # Adder node: a dialog to add children to this object
    _adder_node_class = None

    # Name of the file that may host the hand-crafted view
    _view_filename = Str(transient=True)

    # Hand crafted view.
    _module_view = Instance(View, transient=True)

    # Work around problem with HasPrivateTraits.
    __ = Python
    ##################################################

    ######################################################################
    # `object` interface
    ######################################################################
    def __get_pure_state__(self):
        """Method used by the state_pickler.
        """
        d = self.__dict__.copy()
        for attr in ('scene', '_is_running', '__sync_trait__',
                     '__traits_listener__', '_icon_path',
                     '_menu', '_HideShowAction', 'menu_helper',
                     'parent', 'parent_', '_module_view',
                     '_view_filename', 'mlab_source'):
            d.pop(attr, None)
        return d

    def __getstate__(self):
        """Allows standard pickle to work via the state_pickler.
        """
        return state_pickler.dumps(self)

    def __setstate__(self, str_state):
        """Allows standard pickle to work via the state_pickler.
        """
        self.__init__()
        # Get the state from the string and update it.
        state = state_pickler.loads_state(str_state)
        state_pickler.update_state(state)
        # Save the state and load it if we are running.
        self._saved_state = cPickle.dumps(state)
        if self.running:
            self._load_saved_state()

    def __deepcopy__(self, memo):
        """Method used by copy.deepcopy().  This also uses the
        state_pickler to work correctly.
        """
        # Create a new instance.
        new = self.__class__()
        # If we have a saved state, use it for the new instance.  If
        # not, get our state and save that.
        saved_state = self._saved_state
        if len(saved_state) == 0:
            state = state_pickler.get_state(self)
            #FIXME: This is for streamline seed point widget position which 
            #does not get serialized correctly
            if not is_old_pipeline():
                try:
                    st = state.children[0].children[4]
                    l_pos = st.seed.widget.position
                    st.seed.widget.position = [pos.item() for pos in l_pos]
                except (IndexError, AttributeError):
                    pass
            saved_state = cPickle.dumps(state)
        new._saved_state = saved_state
        # In the unlikely case that a new instance is running, load
        # the saved state.
        if new.running:
            new._load_saved_state()
        return new

    ######################################################################
    # `Base` interface
    ######################################################################
    def start(self):
        """Invoked when this object is added to the mayavi pipeline.
        """
        self.running = True
        self._load_saved_state()

    def stop(self):
        """Invoked when this object is removed from the mayavi
        pipeline.
        """
        self.running = False

    def add_child(self, child):
        """This method intelligently adds a child to this object in
        the MayaVi pipeline.
        """
        raise NotImplementedError

    def remove_child(self, child):
        """Remove specified child from our children.
        """
        raise NotImplementedError()

    def remove(self):
        """Remove ourselves from the mayavi pipeline.
        """
        if self.parent is not None:
            e = get_engine(self)
            self.parent.remove_child(self)
            if e.current_object is self:
                e.current_object = self.parent

    def render(self):
        """Invokes render on the scene, this in turn invokes Render on
        the VTK pipeline.
        """
        s = self.scene
        if s is not None:
            s.render()

    def dialog_view(self):
        """ Returns a view with an icon and a title.
        """
        view = self.trait_view()
        icon = self._icon_path + os.sep + 'images' + os.sep \
                            + self.icon
        view.icon = ImageResource(icon)
        view.title = "Edit%s: %s" % (self.type, self.name)
        view.buttons = ['OK', 'Cancel']
        return view

    def trait_view(self, name = None, view_element = None ):
        """ Gets or sets a ViewElement associated with an object's class.

        Overridden here to search for a separate file in the same directory
        for the view to use for this object. The view should be declared in
        the file named <class name>_view. If a file with this name is not
        found, the trait_view method on the base class will be called.
        """

        # If a name is specified, then call the HasTraits trait_view method
        # which will return (or assign) the *view_element* associated with
        # *name*.
        if name:
            return super(Base, self).trait_view(name, view_element)

        view = self._load_view_cached(name, view_element)
        # Uncomment this when developping views.
        #view = self._load_view_non_cached(name, view_element)
        return view

    ######################################################################
    # `TreeNodeObject` interface
    ######################################################################
    def tno_get_label(self, node):
        """Gets the label to display for a specified object.
        """
        if self.name == '':
            self.name = self.__class__.__name__
        return self.name

    def tno_get_view(self, node):
        """Gets the View to use when editing an object.
        """
        view = self.trait_view()
        view.kind = 'subpanel'
        return view

    def tno_confirm_delete(self, node):
        """Confirms that a specified object can be deleted or not.
        """
        if preference_manager.root.confirm_delete:
            return None
        else:
            return True

    def tno_get_menu ( self, node ):
        """ Returns the contextual pop-up menu.
        """
        if self._menu is None:
            return super(Base, self).tno_get_menu(node)
        return self._menu

    def tno_get_icon(self, node, is_expanded):
        return self.icon

    def tno_get_icon_path(self, node):
        return self._icon_path

    def tno_delete_child(self, node, index):
        if len(self.children_ui_list) > len(self.children):
            del self.children[index - 1]
        else:
            del self.children[index]

    def tno_append_child(self, node, child):
        """ Appends a child to the object's children.
        """
        self.children.append(child)

    def tno_insert_child(self, node, index, child):
        """ Inserts a child into the object's children.
        """
        if len(self.children_ui_list) > len(self.children):
            idx = index -1
        else:
            idx = index
        self.children[idx:idx] = [child]

    ######################################################################
    # Non-public interface
    ######################################################################
    def _get_running(self):
        return self._is_running

    def _set_running(self, new):
        if self._is_running == new:
            return
        else:
            old = self._is_running
            self._is_running = new
            self.trait_property_changed('running', old, new)

    def _get_children_ui_list(self):
        """ Getter for Traits Property children_ui_list.

        For the base class, do not add anything to the children list.
        """
        if ((not preference_manager.root.show_helper_nodes or
                        len(self.children) > 0)
                or self._adder_node_class is None
                or (not self.type == ' scene' and
                    'none' in self.output_info.datasets)
                    # We can't use isinstance, as we would have circular
                    # imports
                ):
            return self.children
        else:
            return [self._adder_node_class(object=self),]

    @on_trait_change('children[]')
    def _trigger_children_ui_list(self, old, new):
        """ Trigger a children_ui_list change when scenes changed.
        """
        self.trait_property_changed('children_ui_list', old, new)

    def _visible_changed(self , value):
        # A hack to set the name when the tree view is not active.
        # `self.name` is set only when tno_get_label is called and this
        # is never called when the tree view is not shown leading to an
        # empty name.
        if len(self.name) == 0:
            self.tno_get_label(None)
        if value:
            #self._HideShowAction.name = "Hide"
            self.name = self.name.replace(' [Hidden]', '')
        else:
            #self._HideShowAction.name = "Show"
            n = self.name
            if ' [Hidden]' not in n:
                self.name = "%s [Hidden]" % n

    def _load_view_cached(self, name, view_element):
        """ Use a cached view for the object, for faster refresh.
        """
        if self._module_view is not None:
            view = self._module_view
        else:
            logger.debug("No view found for [%s] in [%s]. "
                         "Using the base class trait_view instead.",
                             self, self._view_filename)
            view = super(Base, self).trait_view(name, view_element)
        return view

    def _load_view_non_cached(self, name, view_element):
        """ Loads the view by execing a file. Useful when tweaking
            views.
        """
        result = {}
        view_filename = self._view_filename
        try:
            execfile(view_filename, {}, result)
            view = result['view']
        except IOError:
            logger.debug("No view found for [%s] in [%s]. "
                            "Using the base class trait_view instead.",
                            self, view_filename)
            view = super(Base, self).trait_view(name, view_element)
        return view

    def _hideshow(self):
        if self.visible:
            self.visible = False
        else:
            self.visible = True

    def _load_saved_state(self):
        """Load the saved state (if any) of this object.
        """
        saved_state = self._saved_state
        if len(saved_state) > 0:
            state = cPickle.loads(saved_state)
            if hasattr(self, '__set_pure_state__'):
                self.__set_pure_state__(state)
            else:
                state_pickler.set_state(self, state)
            self._saved_state = ''

    def __view_filename_default(self):
        """ The name of the file that will host the view.
        """
        module = self.__module__.split('.')
        class_filename = module[-1] + '.py'
        module_dir_name = module[1:-1]
        base_dir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
        view_filename = reduce(os.path.join,
                               [base_dir] + module_dir_name \
                               + UI_DIR_NAME + [class_filename])
        return view_filename


    def __module_view_default(self):
        """ Try to load a view for this object.
        """
        view_filename = self._view_filename
        try:
            result = imp.load_module('view', file(view_filename),
                            view_filename, ('.py', 'U', 1))
            view = result.view
        except:
            view = None
        return view


    def __menu_default(self):
        extras = []
        if self.menu_helper is not None:
            extras = self.menu_helper.actions + self._extra_menu_items()
        menu_actions = [Separator()] + extras + \
                       [Separator(), self._HideShowAction, Separator()] + \
                       deepcopy(standard_menu_actions)
        return Menu( *menu_actions)

    def __icon_path_default(self):
        return resource_path()

    def _extra_menu_items(self):
        """Override this to generate any new menu actions you want on
        the right click menu."""
        return []

########NEW FILE########
__FILENAME__ = common
"""Common utility functions and classes.  This includes error/warning
messages etc.

"""
# Author: Prabhu Ramachandran <prabhu_r@users.sf.net>
# Copyright (c) 2005-2008, Enthought, Inc.
# License: BSD Style.

# Standard library imports.
import sys
import traceback
import logging
import vtk

# Enthought library imports.
from apptools.persistence.state_pickler import create_instance
from traits.etsconfig.api import ETSConfig
if ETSConfig.toolkit in ('null', ''):
    pyface = None
else:
    from pyface import api as pyface

# Setup a logger for this module.
logger = logging.getLogger(__name__)

######################################################################
# Utility functions.
######################################################################
def debug(msg):
    """Handle a debug message.
    """
    logger.debug(msg)

def warning(msg, parent=None):
    """Handle a warning message.
    """
    logger.warn(msg)
    if pyface is not None:
        pyface.warning(parent, msg)

def error(msg, parent=None):
    """Handle an error message.
    """
    logger.error(msg)
    if pyface is not None:
        pyface.error(parent, msg)

def exception(msg='Exception', parent=None):
    """This function handles any exception derived from Exception and
    prints out an error.  The optional `parent` argument is passed
    along to the dialog box.  The optional `msg` is printed and sent
    to the logger.  So you could send extra information here.
    """
    try:
        type, value, tb = sys.exc_info()
        info = traceback.extract_tb(tb)
        filename, lineno, function, text = info[-1] # last line only
        exc_msg = "%s\nIn %s:%d\n%s: %s (in %s)" %\
                  (msg, filename, lineno, type.__name__, str(value),
                   function)
        # Log and display the message.
        logger.exception(msg)
        if pyface is not None:
            pyface.error(parent, exc_msg, title='Exception')
    finally:
        type = value = tb = None # clean up

def process_ui_events():
    """Process GUI events.

    This function merely abstracts the function so nothing is done when
    no UI is running.
    """
    if pyface is not None:
        pyface.GUI.process_events()

def get_engine(obj):
    """Try and return the engine given an object in the mayavi
    pipeline.  This basically walks up the parent's of the object till
    the engine is found.
    """
    from mayavi.core.engine import Engine
    while obj is not None:
        if isinstance(obj, Engine):
            return obj
        else:
            obj = obj.parent
    return None


def get_object_path(object, parent, path='engine'):
    """Given a mayavi object on the tree view, this should find its
    "path" with respect to the parent object that contains it.
    """
    def _get_child_trait(obj):
        if hasattr(obj, 'scenes'):
            return 'scenes'
        elif hasattr(obj, 'children'):
            return 'children'
        return ''

    def _finder(obj, to_find, path):
        if obj is to_find:
            return path
        else:
            child_t = _get_child_trait(obj)
            if child_t == '':
                return ''
            for i, o in enumerate(getattr(obj, child_t)):
                pth = _finder(o, to_find, '%s.%s[%d]'%(path, child_t, i))
                if len(pth) > 0:
                    return pth
        return ''

    return _finder(parent, object, path)


def handle_children_state(children, kids):
    """Given a list of children (as `children`) of a particular object
    and their states in the `kids` argument, this function sets up the
    children by removing unnecessary ones, fixing existing ones and
    adding new children if necessary (depending on the state).
    """
    # Make a copy of the list so adding/removing does not trigger events
    # each time.
    m_children = list(children)

    n_child, n_kid = len(m_children),  len(kids)
    # Remove extra children we have.
    for i in range(n_child - n_kid):
        m_children.pop()
    # Now check existing children deleting existing ones and
    # creating new ones if needed.
    for i in range(n_child):
        child, kid = m_children[i], kids[i]
        md = kid.__metadata__
        if (child.__module__ != md['module']) \
               or (child.__class__.__name__ != md['class_name']):
            m_children[i] = create_instance(kid)
    # Add any extra kids.
    for i in range(n_kid - n_child):
        child = create_instance(kids[n_child + i])
        m_children.append(child)

    # Now set the children in one shot.
    children[:] = m_children

########NEW FILE########
__FILENAME__ = component
"""The base class for all MayaVi components.

"""
# Author: Prabhu Ramachandran <prabhu_r@users.sf.net>
# Copyright (c) 2005, Enthought, Inc.
# License: BSD Style.

# Enthought library imports.
from traits.api import List

# Local imports.
from mayavi.core.pipeline_base import PipelineBase


######################################################################
# `Component` class.
######################################################################
class Component(PipelineBase):
    # The version of this class.  Used for persistence.
    __version__ = 0

    # A list of inputs for this component.
    inputs = List(record=False)

    # A list of sources for this component.
    sources = List(record=False)


    ######################################################################
    # `object` interface
    ######################################################################
    def __init__(self, **traits):
        super(Component, self).__init__(**traits)

        # Let the filter setup its pipeline.
        self.setup_pipeline()

    def __get_pure_state__(self):
        d = super(Component, self).__get_pure_state__()
        # Remove dynamically set things.
        for x in ['inputs', 'sources']:
            d.pop(x, None)
        return d

    ######################################################################
    # `Component` interface
    ######################################################################
    def setup_pipeline(self):
        """Override this method so that it *creates* its tvtk
        pipeline.

        This method is invoked when the object is initialized via
        `__init__`.  Note that at the time this method is called, the
        tvtk data pipeline will *not* yet be setup.  So upstream data
        will not be available.  The idea is that you simply create the
        basic objects and setup those parts of the pipeline not
        dependent on upstream sources and filters.
        """
        pass

    def update_pipeline(self):
        """Override this method so that it *updates* the tvtk pipeline
        when data upstream is known to have changed.

        This method is invoked (automatically) when the input fires a
        `pipeline_changed` event.
        """
        raise NotImplementedError

    def update_data(self):
        """Override this method to do what is necessary when upstream
        data changes.

        This method is invoked (automatically) when any of the inputs
        sends a `data_changed` event.
        """
        # Invoke render to update any changes.
        self.render()
        # Propagate the data_changed event.
        self.data_changed = True

    ######################################################################
    # `Base` interface
    ######################################################################
    def start(self):
        """This is invoked when this object is added to the mayavi
        pipeline.  Note that when start is invoked, all the other
        information for the pipeline should be already set.
        """
        # Do nothing if we are already running.
        if self.running:
            return

        # Setup event handlers.
        self._setup_event_handlers()

        # Update the pipeline.
        self.update_pipeline()

        # Call parent method to set the state.
        super(Component, self).start()

    def stop(self):
        """Invoked when this object is removed from the mayavi
        pipeline.
        """
        if not self.running:
            return

        # Teardown event handlers.
        self._teardown_event_handlers()

        # Call parent method to set the state.
        super(Component, self).stop()

    ######################################################################
    # Non-public interface
    ######################################################################
    def _inputs_changed(self, old, new):
        if self.running:
            self.update_pipeline()
            self._setup_events(old, new)

    def _inputs_items_changed(self, list_event):
        if self.running:
            self.update_pipeline()
            self._setup_events(list_event.removed, list_event.added)

    def _sources_changed(self, old, new):
        if self.running:
            self.update_pipeline()
            self._setup_events(old, new)

    def _sources_items_changed(self, list_event):
        if self.running:
            self.update_pipeline()
            self._setup_events(list_event.removed, list_event.added)

    def _setup_event_handlers(self):
        self._setup_events([], self.inputs)
        self._setup_events([], self.sources)

    def _teardown_event_handlers(self):
        self._setup_events(self.inputs, [])
        self._setup_events(self.sources, [])

    def _setup_events(self, removed, added):
        for object in removed:
            object.on_trait_event(self.update_pipeline, 'pipeline_changed',
                                  remove=True)
            object.on_trait_event(self.update_data, 'data_changed',
                                  remove=True)
        for object in added:
            object.on_trait_event(self.update_pipeline, 'pipeline_changed')
            object.on_trait_event(self.update_data, 'data_changed')

########NEW FILE########
__FILENAME__ = customize
""" This module helps customize the mayavi install.  It tries to import
any `site_mayavi.py` (anywhere on `sys.path`) or `user_mayavi.py`.  The
`user_mayavi.py` script is found in the users `~/.mayavi2` directory
and this directory is also injected into the path.

It is the users responsibility to import the mayavi registry
(mayavi.registry:registry) and register any new modules or
filters into mayavi using suitable metadata.

If the user desires to contribute any plugins then they may expose a
function called `get_plugins()` which returns a list of plugins that they
wish to add to the default mayavi envisage app.  The user may expose one
set of global plugins in the `site_mayavi` module and another in the
`user_mayavi` module without any problems.

The function `get_custom_plugins` returns a list of all the available
custom plugins.

"""
# Author: Prabhu Ramachandran <prabhu@aero.iitb.ac.in>
# Copyright (c) 2008, Prabhu Ramachandran, Enthought, Inc.
# License: BSD Style.

# Standard library imports.
import sys
import traceback
from os.path import join, exists

# Enthought library imports.
from traits.util.home_directory import get_home_directory
from mayavi.preferences.api import preference_manager

# The functions that return the plugins.
_get_global_plugins = lambda: []
_get_user_plugins = lambda: []

# First try the global mayavi customizations.
try:
    # This will import site_mayavi, so any plugin registrations done
    # there will be run.
    from site_mayavi import get_plugins as _get_global_plugins
except ImportError:
    pass


# Now do any local user level customizations.
#
# The following code obtains any customizations and that are imported
# from a `user_mayavi.py` provided by the user in their  `~/.mayavi2`
# directory.
#
# Note that `~/.mayavi2` is placed in `sys.path` so make sure that you
# choose your module names carefully (so as not to override any common
# module names).

home = get_home_directory()
m2dir = join(home, '.mayavi2')
user_module = join(m2dir, 'user_mayavi.py')
if exists(user_module):
    # Add ~/.mayavi2 to sys.path.
    sys.path.append(m2dir)
    # Doing an import gives user information on any errors.
    import user_mayavi
    try:
        # Now try and import the user defined plugin extension.
        from user_mayavi import get_plugins as _get_user_plugins
    except ImportError:
        # user_mayavi may not be adding any new plugins.
        pass

#  Now handle any contributions that the user has chosen via the
#  preferences.

def _import_contrib(pkg):
    mod = None
    try:
        components = pkg.split('.')
        if len(components) > 1:
            mod_name = '.'.join(components[:-1])
            sym_name = components[-1]
            mod = __import__(mod_name, globals(), locals(), [sym_name], level=0)
            mod = getattr(mod, sym_name)
        else:
            mod_name = components[0]
            mod = __import__(mod_name, globals(), locals(), [mod_name], level=0)
    except Exception:
        print "*"*80
        traceback.print_exc(file=sys.stdout)
        print "*"*80
    return mod

def add_contributions():
    """Import any contributions that the user has selected via
    preferences."""
    for pkg in preference_manager.root.contrib_packages:
        _import_contrib(pkg + '.user_mayavi')

def get_contrib_plugins():
    """Get plugins requested by different contributions."""
    plugins = []
    for pkg in preference_manager.root.contrib_packages:
        mod = _import_contrib(pkg + '.user_mayavi')
        if mod is not None and hasattr(mod, 'get_plugins'):
            plugins.extend(mod.get_plugins())
    return plugins

# Import the contributions.
add_contributions()

def get_custom_plugins():
    """Convenience function that returns all customization plugins as a
    list.
    """
    return _get_global_plugins() + _get_user_plugins() + \
           get_contrib_plugins()


########NEW FILE########
__FILENAME__ = dataset_manager
"""
Code to help with managing a TVTK data set in Pythonic ways.
"""

# Author: Prabhu Ramachandran <prabhu@aero.iitb.ac.in>
# Copyright (c) 2008, Enthought, Inc.
# License: BSD Style.

from traits.api import (HasTraits, Instance, Array, Str,
                        Property, Dict)
from tvtk.api import tvtk
from tvtk.array_handler import array2vtk
import tvtk.common as tvtk_common

######################################################################
# Utility functions.
######################################################################
def get_array_type(arr):
    """Returns if the array is a scalar ('scalars'), vector
    ('vectors') or tensor ('tensors').  It looks at the number of
    components to decide.  If it has a wierd number of components it
    returns the empty string.
    """
    n = arr.number_of_components
    ret = {1: 'scalars', 3: 'vectors', 4: 'scalars', 9:'tensors'}
    return ret.get(n) or ''


def get_attribute_list(data):
    """ Gets scalar, vector and tensor information from the given data
    (either cell or point data).
    """
    attr = {'scalars':[], 'vectors':[], 'tensors':[]}
    if data is not None:
        n = data.number_of_arrays
        for i in range(n):
            name = data.get_array_name(i)
            t = get_array_type(data.get_array(i))
            if len(t) > 0 and name is not None:
                attr[t].extend([name])

    def _mk_first(lst, value):
        """Makes the specified `value` the first item in `lst`."""
        lst.remove(value)
        lst.insert(0, value)

    attr1 = attr.copy()
    for a in attr:
        v = getattr(data, a)
        if v is not None:
            name = v.name
            if name is not None:
                try:
                    _mk_first(attr[a], v.name)
                except ValueError:
                    # Sometimes we have a multi-component scalar.
                    attr1[a].insert(0, name)
    return attr1


def get_all_attributes(obj):
    """Gets the scalar, vector and tensor attributes that are
    available in the given VTK data object.
    """
    point_attr = get_attribute_list(obj.point_data)
    cell_attr = get_attribute_list(obj.cell_data)
    return point_attr, cell_attr


################################################################################
# `DatasetManager` class.
################################################################################
class DatasetManager(HasTraits):

    # The TVTK dataset we manage.
    dataset = Instance(tvtk.DataSet)

    # Our output, this is the dataset modified by us with different
    # active arrays.
    output = Property(Instance(tvtk.DataSet))

    # The point scalars for the dataset.  You may manipulate the arrays
    # in-place.  However adding new keys in this dict will not set the
    # data in the `dataset` for that you must explicitly call
    # `add_array`.
    point_scalars = Dict(Str, Array)
    # Point vectors.
    point_vectors = Dict(Str, Array)
    # Point tensors.
    point_tensors = Dict(Str, Array)

    # The cell scalars for the dataset.
    cell_scalars = Dict(Str, Array)
    cell_vectors = Dict(Str, Array)
    cell_tensors = Dict(Str, Array)

    # This filter allows us to change the attributes of the data
    # object and will ensure that the pipeline is properly taken care
    # of.  Directly setting the array in the VTK object will not do
    # this.
    _assign_attribute = Instance(tvtk.AssignAttribute, args=(),
                                 allow_none=False)


    ######################################################################
    # Public interface.
    ######################################################################
    def add_array(self, array, name, category='point'):
        """
        Add an array to the dataset to specified category ('point' or
        'cell').
        """
        assert len(array.shape) <= 2, "Only 2D arrays can be added."
        data = getattr(self.dataset, '%s_data'%category)
        if len(array.shape) == 2:
            assert array.shape[1] in [1, 3, 4, 9], \
                    "Only Nxm arrays where (m in [1,3,4,9]) are supported"
            va = tvtk.to_tvtk(array2vtk(array))
            va.name = name
            data.add_array(va)
            mapping = {1:'scalars', 3: 'vectors', 4: 'scalars',
                       9: 'tensors'}
            dict = getattr(self, '%s_%s'%(category,
                                          mapping[array.shape[1]]))
            dict[name] = array
        else:
            va = tvtk.to_tvtk(array2vtk(array))
            va.name = name
            data.add_array(va)
            dict = getattr(self, '%s_scalars'%(category))
            dict[name] = array

    def remove_array(self, name, category='point'):
        """Remove an array by its name and optional category (point and
        cell).  Returns the removed array.
        """
        type = self._find_array(name, category)
        data = getattr(self.dataset, '%s_data'%category)
        data.remove_array(name)
        d = getattr(self, '%s_%s'%(category, type))
        return d.pop(name)

    def rename_array(self, name1, name2, category='point'):
        """Rename a particular array from `name1` to `name2`.
        """
        type = self._find_array(name1, category)
        data = getattr(self.dataset, '%s_data'%category)
        arr = data.get_array(name1)
        arr.name = name2
        d = getattr(self, '%s_%s'%(category, type))
        d[name2] = d.pop(name1)

    def activate(self, name, category='point'):
        """Make the specified array the active one.
        """
        type = self._find_array(name, category)
        self._activate_data_array(type, category, name)

    def update(self):
        """Update the dataset when the arrays are changed.
        """
        self.dataset.modified()
        self._assign_attribute.update()

    ######################################################################
    # Non-public interface.
    ######################################################################
    def _dataset_changed(self, value):
        self._setup_data()
        tvtk_common.configure_input_data(self._assign_attribute, value)

    def _get_output(self):
        return self._assign_attribute.output

    def _setup_data(self):
        """Updates the arrays from what is available in the input data.
        """
        input = self.dataset
        pnt_attr, cell_attr = get_all_attributes(input)

        self._setup_data_arrays(cell_attr, 'cell')
        self._setup_data_arrays(pnt_attr, 'point')

    def _setup_data_arrays(self, attributes, d_type):
        """Given the dict of the attributes from the
        `get_all_attributes` function and the data type (point/cell)
        data this will setup the object and the data.
        """
        attrs = ['scalars', 'vectors', 'tensors']
        aa = self._assign_attribute
        input = self.dataset
        data = getattr(input, '%s_data'%d_type)
        for attr in attrs:
            values = attributes[attr]
            # Get the arrays from VTK, create numpy arrays and setup our
            # traits.
            arrays = {}
            for name in values:
                va = data.get_array(name)
                npa = va.to_array()
                # Now test if changes to the numpy array are reflected
                # in the VTK array, if they are we are set, else we
                # have to set the VTK array back to the numpy array.
                if len(npa.shape) > 1:
                    old = npa[0,0]
                    npa[0][0] = old - 1
                    if abs(va[0][0] - npa[0,0]) > 1e-8:
                        va.from_array(npa)
                    npa[0][0] = old
                else:
                    old = npa[0]
                    npa[0] = old - 1
                    if abs(va[0] - npa[0]) > 1e-8:
                        va.from_array(npa)
                    npa[0] = old
                arrays[name] = npa

            setattr(self, '%s_%s'%(d_type, attr), arrays)

    def _activate_data_array(self, data_type, category, name):
        """Activate (or deactivate) a particular array.

        Given the nature of the data (scalars, vectors etc.) and the
        type of data (cell or points) it activates the array given by
        its name.

        Parameters:
        -----------

        data_type: one of 'scalars', 'vectors', 'tensors'
        category: one of 'cell', 'point'.
        name: string of array name to activate.
        """
        input = self.dataset
        data = None
        data = getattr(input, category + '_data')
        method = getattr(data, 'set_active_%s'%data_type)
        if len(name) == 0:
            # If the value is empty then we deactivate that attribute.
            method(None)
        else:
            aa = self._assign_attribute
            method(name)
            aa.assign(name, data_type.upper(), category.upper() +'_DATA')
            aa.update()

    def _find_array(self, name, category='point'):
        """Return information on which kind of attribute contains the
        specified named array in a particular category."""
        types = ['scalars', 'vectors', 'tensors']
        for type in types:
            attr = '%s_%s'%(category, type)
            d = getattr(self, attr)
            if name in d.keys():
                return type
        raise KeyError('No %s array named %s available in dataset'
                        %(category, name))


########NEW FILE########
__FILENAME__ = engine
"""The Mayavi engine.  This class manages the Mayavi objects at the
highest level.

"""
# Author: Prabhu Ramachandran <prabhu_r@users.sf.net>
# Copyright (c) 2005-2008, Enthought, Inc.
# License: BSD Style.

# Standard library imports.
# VTK is used to just shut off the warnings temporarily.
try:
    import vtk
except ImportError, m:
    m.args = ('%s\n%s\nDo you have vtk and its Python bindings installed properly?' %
                    (m.args[0], '_'*80),)
    raise

# Enthought library imports.
from traits.api import (HasStrictTraits, List, Str,
        Property, Instance, Event, HasTraits, Callable, Dict,
        Bool, on_trait_change, WeakRef)
from traitsui.api import View, Item
from apptools.persistence import state_pickler
from apptools.scripting.api import Recorder, recordable

# Local imports.
from tvtk.common import is_old_pipeline
from mayavi.core.base import Base
from mayavi.core.scene import Scene
from mayavi.core.common import error, process_ui_events
from mayavi.core.registry import registry
from mayavi.core.adder_node import AdderNode, SceneAdderNode
from mayavi.preferences.api import preference_manager
from mayavi.core.ui.mayavi_scene import viewer_factory


######################################################################
# Utility functions.
######################################################################
def _id_generator():
    """Returns a sequence of numbers for the title of the scene
    window."""
    n = 1
    while True:
        yield(n)
        n += 1
scene_id_generator = _id_generator()

def get_args(function):
    """ Simple inspect-like function to inspect the arguments a function
        takes.
    """
    return function.func_code.co_varnames[:function.func_code.co_argcount]

######################################################################
# `Engine` class
######################################################################
class Engine(HasStrictTraits):
    """ The Mayavi engine base class.
    """

    # The version of this class.  Used for persistence.
    __version__ = 0

    # The scenes associated with this project.
    scenes = List(Scene, record=True)

    # The list to provide to a TreeEditor.  Always add on a AdderNode.
    # TODO: It makes more sense to put the modification of the list
    # in some other UI module, and not here.
    children_ui_list = Property(record=False)

    # Our name.
    name = Str('Mayavi Engine')

    # Current scene.
    current_scene = Property(Instance(Scene), record=False)

    # Current object.
    current_object = Property(record=False)

    # Current selection -- the currently selected object on the tree.
    current_selection = Property(record=False)

    # Has the Engine started?  Use this event to do something after
    # the engine has been started.
    started = Event(record=False)

    # An optional callable that will generate a usable new viewer
    # containing a `tvtk.pyface.TVTKScene` instance. Ideally
    # the viewer should have an interface like
    # `tvtk.pyface.TVTKWindow` -- basically it must
    # implement the `closing` and `activated` events, however, this is
    # not necessary.  The created viewer is used by the `new_scene`
    # method to create a new Viewer.  This is a mechanism to use a
    # user specified scene with the Engine and have the ability to
    # load saved visualizations using the new scene.  Handy for things
    # like off-screen rendering.
    scene_factory = Callable(viewer_factory)

    # Are we running?
    running = Bool(False, record=False)

    # The recorder for script recording.
    recorder = Instance(Recorder, record=False)

    ########################################
    # Private traits.

    _current_scene = WeakRef(Scene, allow_none=True)
    _current_object = WeakRef(HasTraits, allow_none=True)
    _current_selection = WeakRef(HasTraits, allow_none=True)
    _viewer_ref = Dict

    # View related traits.
    current_selection_view = View(Item(name='_current_selection',
                                       enabled_when='_current_selection is not None',
                                       style='custom', springy=True,
                                       show_label=False,),
                                  resizable=True,
                                  scrollable=True
                                  )

    ######################################################################
    # `object` interface
    ######################################################################
    def __init__(self, **traits):
        super(Engine, self).__init__(**traits)

        # FIXME: This is tied to preferences.  It really should not be
        # we need to use bind_preferences here.
        cbk = lambda : self.trait_property_changed('children_ui_list', [],
                                                   self.children_ui_list)
        preference_manager.root.on_trait_change(cbk,
                                                'show_helper_nodes')

    def __get_pure_state__(self):
        d = self.__dict__.copy()
        for x in ['_current_scene', '_current_object',
                  '__sync_trait__', '_viewer_ref',
                  '__traits_listener__']:
            d.pop(x, None)
        return d

    def __set_pure_state__(self, state):
        # Current number of scenes.
        n_scene = len(self.scenes)
        # Number of scenes in saved state.
        n_saved_scene = len(state.scenes)
        # Remove extra ones.
        for i in range(n_scene - n_saved_scene):
            self.close_scene(self.scenes[-1])
        # Add new ones.
        for i in range(n_saved_scene - n_scene):
            self.new_scene()
        # Set the state.
        state_pickler.set_state(self, state)

    def __getstate__(self):
        return state_pickler.dumps(self)

    def __setstate__(self, str_state):
        self.__init__()
        state = state_pickler.loads_state(str_state)
        state_pickler.update_state(state)
        self.__set_pure_state__(state)

    ######################################################################
    # `Engine` interface
    ######################################################################
    def start(self):
        """This is called by the plugin when the plugin actually
        starts."""
        registry.register_engine(self)
        # Notify any listeners that the engine is started.
        self.started = self
        self.running = True

    def stop(self):
        registry.unregister_engine(self)
        self.running = False

    @recordable
    def add_source(self, src, scene=None):
        """Adds a source to the pipeline. Uses the current scene unless a
        scene is given in the scene keyword argument."""
        passed_scene = scene
        if scene is not None:
            tvtk_scene = scene.scene
            for sc in self.scenes:
                if sc.scene == tvtk_scene:
                    scene = sc
                    break
            else:
                error('This scene is not managed by mayavi')
                return
        else:
            scene = self.current_scene

        # Create a new scene if none is available.
        if scene is None:
            self.new_scene()
            scene = self.current_scene
        scene.add_child(src)
        self.current_object = src

    @recordable
    def add_filter(self, fil, obj=None):
        """Adds a filter to the pipeline at an appropriate point. Adds it
        to the selected object, or to an object passed as the
        kwarg `obj`.
        """
        passed_obj = obj
        if obj is None:
            obj = self.current_object
        if not isinstance(obj, Base):
            msg = 'No valid current object, '\
                  'please select an active object.'
            error(msg)
            return
        if (obj is not None) and (not isinstance(obj, Scene)):
            if obj.running:
                obj.add_child(fil)
                self.current_object = fil
            else:
                msg = 'Current object is not active, '\
                      'please select an active object.'
                error(msg)
        else:
            if obj is None:
                error('Please create a VTK scene and open some data first.')
            else:
                error('No data: cannot use a Filter/Module/ModuleManager.')

    @recordable
    def add_module(self, mod, obj=None):
        """Adds a module to the pipeline at an appropriate point. Adds it
        to the selected object, or to an object passed through the
        kwarg `obj`.
        """
        self.add_filter(mod, obj=obj)

    @recordable
    def save_visualization(self, file_or_fname):
        """Given a file or a file name, this saves the current
        visualization to the file.
        """
        # Save the state of VTK's global warning display.
        o = vtk.vtkObject
        w = o.GetGlobalWarningDisplay()
        o.SetGlobalWarningDisplay(0) # Turn it off.
        try:
            #FIXME: This is for streamline seed point widget position which 
            #does not get serialized correctly
            if is_old_pipeline():
                state_pickler.dump(self, file_or_fname)
            else:
                state = state_pickler.get_state(self)
                st = state.scenes[0].children[0].children[0].children[4]
                l_pos = st.seed.widget.position
                st.seed.widget.position = [pos.item() for pos in l_pos]
                saved_state = state_pickler.dumps(state)
                file_or_fname.write(saved_state)
        except (IndexError, AttributeError):
            state_pickler.dump(self, file_or_fname)
        finally:
            # Reset the warning state.
            o.SetGlobalWarningDisplay(w)

    @recordable
    def load_visualization(self, file_or_fname):
        """Given a file/file name this loads the visualization."""
        # Save the state of VTK's global warning display.
        o = vtk.vtkObject
        w = o.GetGlobalWarningDisplay()
        o.SetGlobalWarningDisplay(0) # Turn it off.
        try:
            # Get the state from the file.
            state = state_pickler.load_state(file_or_fname)
            state_pickler.update_state(state)
            # Add the new scenes.
            for scene_state in state.scenes:
                self.new_scene()
                scene = self.scenes[-1]
                # Disable rendering initially.
                if scene.scene is not None:
                    scene.scene.disable_render = True
                # Update the state.
                state_pickler.update_state(scene_state)
                scene.__set_pure_state__(scene_state)
                # Setting the state will automatically reset the
                # disable_render.
                scene.render()
        finally:
            # Reset the warning state.
            o.SetGlobalWarningDisplay(w)

    @recordable
    def open(self, filename, scene=None):
        """Open a file given a filename if possible in either the
        current scene or the passed `scene`.
        """
        passed_scene = scene
        reader = registry.get_file_reader(filename)
        if reader is None:
            msg = 'No suitable reader found for the file %s'%filename
            error(msg)
        else:
            src = None
            if scene is None:
                scene = self.current_scene
            if scene is None:
                scene = self.new_scene()
            try:
                sc = scene.scene
                if sc is not None:
                    sc.busy = True
                callable = reader.get_callable()
                if reader.factory is None:
                    src = callable()
                    src.initialize(filename)
                else:
                    # Factory functions are passed the filename and a
                    # reference to the engine.
                    src = callable(filename, self)
                if src is not None:
                    self.add_source(src, passed_scene)
            finally:
                if sc is not None:
                    sc.busy = False
            if src is not None:
                return src

    def record(self, msg):
        """This is merely a convenience method to record messages to the
        script recorder.
        """
        r = self.recorder
        if r is not None:
            r.record(msg)

    ######################################################################
    # Scene creation/deletion related methods.
    ######################################################################
    def add_scene(self, scene, name=None):
        """Add given `scene` (a `pyface.tvtk.scene.Scene` instance) to
        the mayavi engine so that mayavi can manage the scene.  This
        is used when the user creates a scene.  Note that for the
        `EnvisageEngine` this is automatically taken care of when you
        create a new scene using the TVTK scene plugin.

        Parameters:
        -----------

         scene - `pyface.tvtk.scene.Scene`

          The scene that needs to be managed from mayavi.

         name - `str`
          The name assigned to the scene.  It tries to determine the
          name of the scene from the passed scene instance.  If this
          is not possible it defaults to 'Mayavi Scene'.

        """
        if name is None:
            if hasattr(scene, 'name'):
                name = scene.name
            else:
                name = 'Mayavi Scene %d'%scene_id_generator.next()

        s = Scene(scene=scene, name=name, parent=self)
        s.start()
        # We don't want the startup setup to be recorded.
        recorder = self.recorder
        self.scenes.append(s)
        self.current_scene = s
        if recorder is not None:
            recorder.register(s)

    @recordable
    def remove_scene(self, scene, **kwargs):
        """Remove a given `scene` (a `pyface.tvtk.scene.Scene`
        instance) from the mayavi engine if it is already being
        managed by mayavi.  Note that for the `EnvisageEngine` this is
        automatically taken care of when you close a scene started
        using the TVTK scene plugin.

        Parameters:
        -----------

         scene - `pyface.tvtk.scene.Scene`

          The scene that needs to be removed from mayavi.
        """
        s = None
        for index, x in enumerate(self.scenes):
            if x.scene is scene:
                s = x
                break
        if s is not None:
            s.stop()
            self.scenes.remove(s)
            # Don't record it shutting down.  To do this we must
            # unregister it here so we don't record unnecessary calls.
            recorder = self.recorder
            if recorder is not None:
                recorder.unregister(s)

        # Remove the reference to the viewer if any.
        if scene in self._viewer_ref:
            del self._viewer_ref[scene]

        # Clear the current scene if it has been removed.
        if scene is self._current_scene:
            self._current_scene = None

    @recordable
    def new_scene(self, viewer=None, name=None, **kwargs):
        """Create or manage a new VTK scene window.  If no `viewer`
        argument is provided, the method creates a new viewer using
        `self.scene_factory`.  If `self.scene_factory` is `None` then
        it creates an `ivtk` viewer.  This code requires that the
        `viewer` has a `scene` attribute/trait that is a
        `pyface.tvtk.scene.Scene`.  It also works best if the viewer
        supports `closing` and `activated` events.

        The method returns the created viewer.

        Parameters:
        -----------

         viewer - The viewer object, if None, one is created for you.

         name - The name attribute of the viewer

         ``**kwargs`` - The extra keyword arguments are passed along to
         the scene factory.

        """
        if viewer is None:
            factory_kwargs = {}
            factory_kwargs_names = get_args(self.scene_factory)
            for arg, value in kwargs.iteritems():
                if arg in factory_kwargs_names:
                    factory_kwargs[arg] = value

            viewer = self.scene_factory(**factory_kwargs)
            process_ui_events()

        if name is not None:
            viewer.name = name
        # Hang on to a reference to this viewer, if not done this will cause a
        # crash with Qt4.  This because the viewer will be closed and gc'd if
        # there isn't a reference to it.  When the viewer is gc'd the scene is
        # also closed and the engine will have a dead scene causing a crash.
        self._viewer_ref[viewer.scene] = viewer

        self.add_scene(viewer.scene)
        if hasattr(viewer, 'on_trait_change'):
            viewer.on_trait_change(self._on_scene_closed, 'closing')
            viewer.on_trait_change(self._on_scene_activated, 'activated')
            if hasattr(viewer, 'title'):
                self.current_scene.sync_trait('name', viewer, 'title')
        return viewer


    @recordable
    def close_scene(self, scene):
        """Given a scene created from new_scene, this method closes it
        and removes the scene from the list of scenes we manage.

        Parameters:
        -----------

         scene - `pyface.tvtk.scene.Scene` or an object that holds a
         reference to a `pyface.tvtk.scene.Scene` in a `scene`
         attribute.
        """
        viewer = self.get_viewer(scene)
        self.remove_scene(scene.scene)
        if hasattr(scene, 'close'):
            scene.close()
        elif scene.scene is not None:
            scene.scene.close()
        if viewer is not None and hasattr(viewer, 'close'):
            viewer.close()

    def get_viewer(self, scene):
        """Return the viewer associated with a given scene.

        Parameters:
        -----------
         scene - An `mayavi.core.scene.Scene` instance.
        """
        return self._viewer_ref.get(scene.scene)

    def dialog_view(self):
        """ Default dialog view for Engine objects.
        """
        return None

    ######################################################################
    # Non-public interface
    ######################################################################
    def _on_select(self, object):
        """Called by the EngineTree when an object on the view is
        selected.  This basically sets the current object and current
        scene."""
        self.current_selection = object
        self._current_object = object
        try:
            scene = object.scene
            for s in self.scenes:
                if s.scene == scene:
                    self._current_scene = s
                    break
        except AttributeError:
            pass

    def _get_current_scene(self):
        n_scene = len(self.scenes)
        if n_scene == 0:
            return None
        elif n_scene == 1:
            return self.scenes[0]
        elif self._current_scene is not None:
            return self._current_scene
        elif n_scene > 1:
            return self.scenes[-1]
        else:
            return None

    def _set_current_scene(self, scene):
        old = self._current_scene
        self._current_scene = scene
        self.trait_property_changed('current_scene', old, scene)

    def _get_current_object(self):
        if self._current_object is not None:
            return self._current_object
        elif self.current_scene is not None:
            return self.current_scene
        else:
            return None

    def _set_current_object(self, object):
        old = self._current_object
        self._current_object = object
        self.trait_property_changed('current_object', old, object)

    def _get_current_selection(self):
        return self._current_selection

    def _set_current_selection(self, object):
        old = self._current_selection
        if not isinstance(object, (Base, AdderNode)):
            object = None
        self._current_selection = object
        self.trait_property_changed('current_selection', old, object)

    def _on_scene_closed(self, obj, name, old, new):
        self.remove_scene(obj.scene)

    def _on_scene_activated(self, obj, name, old, new):
        for scene in self.scenes:
            if scene.scene is obj.scene:
                self.current_scene = scene
                break

    def _get_children_ui_list(self):
        """ Trait getter for children_ui_list Property.
        """
        if preference_manager.root.show_helper_nodes \
                    and len(self.scenes) == 0:
            return [SceneAdderNode(object=self)]
        else:
            return self.scenes

    @on_trait_change('scenes[]')
    def _trigger_children_ui_list(self, old, new):
        """ Trigger a children_ui_list change when scenes changed.
        """
        self.trait_property_changed('children_ui_list', old, new)

    def _recorder_changed(self, old, new):
        if new is not None:
            new.record('# Recorded script from Mayavi2')
            new.record('from numpy import array')
            new.record('try:')
            new.record('    engine = mayavi.engine')
            new.record('except NameError:')
            new.record('    from mayavi.api import Engine')
            new.record('    engine = Engine()')
            new.record('    engine.start()')
            new.record('if len(engine.scenes) == 0:')
            new.record('    engine.new_scene()')
            new.record('# ------------------------------------------- ')
        elif old is not None:
            old.record('# ------------------------------------------- ')
            old.record('from mayavi.tools.show import show')
            old.record('show()')


########NEW FILE########
__FILENAME__ = file_data_source
"""The base file related data source object from which all MayaVi data
sources derive.

"""
# Author: Prabhu Ramachandran <prabhu_r@users.sf.net>
# Copyright (c) 2005, Enthought, Inc.
# License: BSD Style.

# Standard library imports.
import re
from os.path import split, join, isfile
from glob import glob

# Enthought library imports.
from traits.api import List, Str, Instance, Int, Range
from traitsui.api import Group, Item, FileEditor
from apptools.persistence.state_pickler import set_state
from apptools.persistence.file_path import FilePath

# Local imports
from mayavi.core.source import Source
from mayavi.core.common import handle_children_state


######################################################################
# Utility functions.
######################################################################
def get_file_list(file_name):
    """ Given a file name, this function treats the file as a part of
    a series of files based on the index of the file and tries to
    determine the list of files in the series.  The file name of a
    file in a time series must be of the form 'some_name[0-9]*.ext'.
    That is the integers at the end of the file determine what part of
    the time series the file belongs to.  The files are then sorted as
    per this index."""

    # The matching is done only for the basename of the file.
    f_dir, f_base = split(file_name)
    # Find the head and tail of the file pattern.
    head = re.sub("[0-9]+[^0-9]*$", "", f_base)
    tail = re.sub("^.*[0-9]+", "", f_base)
    pattern = head+"[0-9]*"+tail
    # Glob the files for the pattern.
    _files = glob(join(f_dir, pattern))

    # A simple function to get the index from the file.
    def _get_index(f, head=head, tail=tail):
        base = split(f)[1]
        result = base.replace(head, '')
        return float(result.replace(tail, ''))

    # Before sorting make sure the files in the globbed series are
    # really part of a timeseries.  This can happen in cases like so:
    # 5_2_1.vtk and 5_2_1s.vtk will be globbed but 5_2_1s.vtk is
    # obviously not a valid time series file.
    files = []
    for x in _files:
        try:
            _get_index(x)
        except ValueError:
            pass
        else:
            files.append(x)

    # Sort the globbed files based on the index value.
    def file_sort(x, y):
        x1 = _get_index(x)
        y1 = _get_index(y)
        if x1 > y1:
            return 1
        elif y1 > x1:
            return -1
        else:
            return 0

    files.sort(file_sort)
    return files


######################################################################
# `FileDataSource` class.
######################################################################
class FileDataSource(Source):

    # The version of this class.  Used for persistence.
    __version__ = 0

    # The list of file names for the timeseries.
    file_list = List(Str, desc='a list of files belonging to a time series')

    # The current time step (starts with 0).  This trait is a dummy
    # and is dynamically changed when the `file_list` trait changes.
    # This is done so the timestep bounds are linked to the number of
    # the files in the file list.
    timestep = Range(value=0,
                     low='_min_timestep',
                     high='_max_timestep',
                     enter_set=True, auto_set=False,
                     desc='the current time step')

    base_file_name=Str('', desc="the base name of the file",
                       enter_set=True, auto_set=False,
                       editor=FileEditor())

    # A timestep view group that may be included by subclasses.
    time_step_group = Group(Item(name='file_path', style='readonly'),
                            Item(name='timestep',
                                 defined_when='len(object.file_list) > 1')
                            )

    ##################################################
    # Private traits.
    ##################################################

    # The current file name.  This is not meant to be touched by the
    # user.
    file_path = Instance(FilePath, (), desc='the current file name')

    _min_timestep = Int(0)
    _max_timestep = Int(0)

    ######################################################################
    # `object` interface
    ######################################################################
    def __get_pure_state__(self):
        d = super(FileDataSource, self).__get_pure_state__()
        # These are obtained dynamically, so don't pickle them.
        for x in ['file_list', 'timestep']:
            d.pop(x, None)
        return d

    def __set_pure_state__(self, state):
        # Use the saved path to initialize the file_list and timestep.
        fname = state.file_path.abs_pth
        if not isfile(fname):
            msg = 'Could not find file at %s\n'%fname
            msg += 'Please move the file there and try again.'
            raise IOError, msg

        self.initialize(fname)
        # Now set the remaining state without touching the children.
        set_state(self, state, ignore=['children', 'file_path'])
        # Setup the children.
        handle_children_state(self.children, state.children)
        # Setup the children's state.
        set_state(self, state, first=['children'], ignore=['*'])

    ######################################################################
    # `FileDataSource` interface
    ######################################################################
    def initialize(self, base_file_name):
        """Given a single filename which may or may not be part of a
        time series, this initializes the list of files.  This method
        need not be called to initialize the data.
        """
        self.base_file_name = base_file_name

    ######################################################################
    # Non-public interface
    ######################################################################
    def _file_list_changed(self, value):
        # Change the range of the timestep suitably to reflect new list.
        n_files = len(self.file_list)
        timestep = min(self.timestep, n_files)
        self._max_timestep = max(n_files -1, 0)
        if self.timestep == timestep:
            self._timestep_changed(timestep)
        else:
            self.timestep = timestep

    def _file_list_items_changed(self, list_event):
        self._file_list_changed(self.file_list)

    def _timestep_changed(self, value):
        file_list = self.file_list
        if len(file_list) > 0:
            self.file_path = FilePath(file_list[value])
        else:
            self.file_path = FilePath('')

    def _base_file_name_changed(self,value):
        self.file_list = get_file_list(value)
        if len(self.file_list) == 0:
            self.file_list = [value]
        try:
            self.timestep = self.file_list.index(value)
        except ValueError:
            self.timestep = 0


########NEW FILE########
__FILENAME__ = filter
"""The base filter class from which all MayaVi filters derive.

"""
# Author: Prabhu Ramachandran <prabhu_r@users.sf.net>
# Copyright (c) 2005, Enthought, Inc.
# License: BSD Style.

# Enthought library imports.
from traits.api import List, Str

# Local imports
from mayavi.core.source import Source
from mayavi.core.pipeline_base import PipelineBase
from mayavi.core.pipeline_info import (PipelineInfo,
        get_tvtk_dataset_name)


######################################################################
# `Filter` class.
######################################################################
class Filter(Source):
    """ Base class for all the Mayavi filters.
    """

    # The version of this class.  Used for persistence.
    __version__ = 0

    # The inputs for this filter.
    inputs = List(PipelineBase, record=False)

    # The icon
    icon = Str('filter.ico')

    # The human-readable type for this object
    type = Str(' filter')

    # Information about what this object can consume.
    input_info = PipelineInfo(datasets=['any'])

    ######################################################################
    # `object` interface.
    ######################################################################
    def __init__(self, **traits):
        super(Filter, self).__init__(**traits)

        # Let the filter setup its pipeline.
        self.setup_pipeline()

    def __get_pure_state__(self):
        d = super(Filter, self).__get_pure_state__()
        # Inputs are setup dynamically, don't pickle them.
        d.pop('inputs', None)
        return d

    ######################################################################
    # `Filter` interface.
    ######################################################################
    def setup_pipeline(self):
        """Override this method so that it *creates* its tvtk
        pipeline.

        This method is invoked when the object is initialized via
        `__init__`.  Note that at the time this method is called, the
        tvtk data pipeline will *not* yet be setup.  So upstream data
        will not be available.  The idea is that you simply create the
        basic objects and setup those parts of the pipeline not
        dependent on upstream sources and filters.
        """
        pass

    def update_pipeline(self):
        """Override this method so that it *updates* the tvtk pipeline
        when data upstream is known to have changed.

        This method is invoked (automatically) when the input fires a
        `pipeline_changed` event.
        """
        raise NotImplementedError

    def update_data(self):
        """Override this method to do what is necessary when upstream
        data changes.

        This method is invoked (automatically) when any of the inputs
        sends a `data_changed` event.
        """
        # Invoke render to update any changes.
        self.render()
        # Propagate the data_changed event.
        self.data_changed = True

    ######################################################################
    # `Base` interface
    ######################################################################
    def start(self):
        """This is invoked when this object is added to the mayavi
        pipeline.  Note that when start is invoked, all the other
        information for the pipeline should be already set.
        """
        # Do nothing if we are already running.
        if self.running:
            return

        # Setup event handlers.
        self._setup_event_handlers()

        # Update the pipeline.
        self.update_pipeline()

        # Call parent method to start the children and set the state.
        super(Filter, self).start()

    def stop(self):
        """Invoked when this object is removed from the mayavi
        pipeline.  This is where you remove your actors from the
        scene.
        """
        if not self.running:
            return

        # Teardown event handlers.
        self._teardown_event_handlers()

        # Call parent method to stop the children and set the state.
        super(Filter, self).stop()

    ######################################################################
    # Non-public interface
    ######################################################################
    def _set_outputs(self, new_outputs):
        """Set `self.outputs` to the given list of `new_outputs`.  You
        should always use this method to set `self.outputs`.
        """
        old_outputs = self.outputs
        self.outputs = new_outputs
        if len(new_outputs) > 0:
            self.output_info.datasets = \
                [get_tvtk_dataset_name(new_outputs[0])]
        if old_outputs == self.outputs:
            # Even if the outputs don't change we want to propagate a
            # data_changed event since the data could have changed.
            self.data_changed = True

    def _inputs_changed(self, old, new):
        if self.running:
            self.update_pipeline()
            self._setup_input_events(old, new)

    def _inputs_items_changed(self, list_event):
        if self.running:
            self.update_pipeline()
            self._setup_input_events(list_event.removed, list_event.added)

    def _setup_event_handlers(self):
        self._setup_input_events([], self.inputs)

    def _teardown_event_handlers(self):
        self._setup_input_events(self.inputs, [])

    def _setup_input_events(self, removed, added):
        for input in removed:
            input.on_trait_event(self.update_pipeline, 'pipeline_changed',
                                 remove=True)
            input.on_trait_event(self.update_data, 'data_changed',
                                 remove=True)
        for input in added:
            input.on_trait_event(self.update_pipeline, 'pipeline_changed')
            input.on_trait_event(self.update_data, 'data_changed')


########NEW FILE########
__FILENAME__ = lut_manager
"""This manages the lookup table used to map values to colors.

"""
# Author: Prabhu Ramachandran <prabhu_r@users.sf.net>
# Copyright (c) 2005-2008, Enthought, Inc.
# License: BSD Style.

import os.path
import sys
import subprocess


# Enthought library imports.
from traits.api import Instance, Range, Bool, Array, \
     Str, Property, Enum, Button
from traitsui.api import FileEditor, auto_close_message
from apptools.persistence import state_pickler
from tvtk.api import tvtk

# Local imports.
from mayavi.core.base import Base
from mayavi.core.common import error

from mayavi.core import lut
lut_image_dir = os.path.dirname(lut.__file__)
pylab_luts = state_pickler.load_state(os.path.join(lut_image_dir,
                                                'pylab_luts.pkl'))

#################################################################
# Utility functions.
#################################################################
def set_lut(vtk_lut, lut_lst):
    """Setup the tvtk.LookupTable (`vtk_lut`) using the passed list of
    lut values."""
    n_col = len(lut_lst)
    vtk_lut.number_of_colors = n_col
    vtk_lut.build()
    for i in range(0, n_col):
        lt = lut_lst[i]
        vtk_lut.set_table_value(i, lt[0], lt[1], lt[2], lt[3])

    return vtk_lut

def check_lut_first_line(line, file_name=''):
    """Check the line to see if this is a valid LUT file."""
    first = line.split()
    if first[0] != "LOOKUP_TABLE":
        errmsg = "Error: The input data file \"%s\"\n"%(file_name)
        errmsg = errmsg+ "is not a proper lookup table file."\
                 " No LOOKUP_TABLE tag in first line. Try again."
        raise IOError, errmsg
    try:
        n_color = first[2]
    except:

        raise IOError, "Error: No size for LookupTable specified."
    else:
        return n_color

def parse_lut_file(file_name):
    """Parse the file specified by its name `file_name` for a LUT and
    return the list of parsed values."""

    input = open(file_name, "r")

    line = input.readline()
    n_color = check_lut_first_line(line, file_name)

    lut = []
    for line in input.readlines():
        entr = line.split()
        if len(entr) != 4:
            errmsg="Error: insufficient or too much data in line "\
                    "-- \"%s\""%(entr)
            raise IOError, errmsg

        tmp = []
        for color in entr:
            try:
                tmp.append(float(color))
            except:
                raise IOError, \
                      "Unknown entry '%s'in lookup table input."%color
        lut.append(tmp)

    return lut


def lut_mode_list():
    """ Function to generate the list of acceptable lut_mode values.
    """
    lut_mode_list = ( ['blue-red', 'black-white', 'file', ]
                            + pylab_luts.keys() )
    lut_mode_list.sort()
    return lut_mode_list


######################################################################
# `LUTManager` class.
######################################################################
class LUTManager(Base):

    # The version of this class.  Used for persistence.
    __version__ = 0

    # The lookup table.
    lut = Instance(tvtk.LookupTable, (), record=False)
    # The scalar bar.
    scalar_bar = Instance(tvtk.ScalarBarActor, (), record=True)
    # The scalar_bar_widget
    scalar_bar_widget = Instance(tvtk.ScalarBarWidget, ())

    # The representation associated with the scalar_bar_widget.  This
    # only exists in VTK versions about around 5.2.
    scalar_bar_representation = Instance(tvtk.Object, allow_none=True,
                                         record=True)

    # The title text property of the axes.
    title_text_property = Property(record=True)

    # The label text property of the axes.
    label_text_property = Property(record=True)

    # The current mode of the LUT.
    lut_mode = Enum('blue-red', lut_mode_list(),
                     desc='the type of the lookup table')

    # File name of the LUT file to use.
    file_name = Str('', editor=FileEditor,
                    desc='the filename containing the LUT')

    # Reverse the colors of the LUT.
    reverse_lut = Bool(False, desc='if the lut is to be reversed')

    # Turn on/off the visibility of the scalar bar.
    show_scalar_bar = Bool(False,
                           desc='if scalar bar is shown or not')

    # This is an alias for show_scalar_bar.
    show_legend = Property(Bool, desc='if legend is shown or not')

    # The number of labels to use for the scalar bar.
    number_of_labels = Range(0, 64, 8, enter_set=True, auto_set=False,
                             desc='the number of labels to display')

    # Number of colors for the LUT.
    number_of_colors = Range(2, 2147483647, 256, enter_set=True,
                             auto_set=False,
                             desc='the number of colors for the LUT')

    # Enable shadowing of the labels and text.
    shadow = Bool(False, desc='if the labels and text have shadows')

    # Use the default data name or the user specified one.
    use_default_name = Bool(True,
                            desc='if the default data name is to be used')

    # The default data name -- set by the module manager.
    default_data_name = Str('data', enter_set=True, auto_set=False,
                            desc='the default data name')

    # The optionally user specified name of the data.
    data_name = Str('', enter_set=True, auto_set=False,
                    desc='the title of the legend')

    # Use the default range or user specified one.
    use_default_range = Bool(True,
                             desc='if the default data range is to be used')
    # The default data range -- this is computed and set by the
    # module manager.
    default_data_range = Array(shape=(2,), value=[0.0, 1.0],
                               dtype=float, enter_set=True, auto_set=False,
                               desc='the default range of the data mapped')

    # The optionally user defined range of the data.
    data_range = Array(shape=(2,), value=[0.0, 1.0],
                       dtype=float, enter_set=True, auto_set=False,
                       desc='the range of the data mapped')

    # Create a new LUT.
    create_lut = Button('Launch LUT editor',
                        desc='if we launch a Lookup table editor in'
                             ' a separate process')

    ########################################
    ## Private traits.
    # The original range of the data.
    _orig_data_range = Array(shape=(2,), value=[0.0, 1.0], dtype=float)
    _title_text_property = Instance(tvtk.TextProperty)
    _label_text_property = Instance(tvtk.TextProperty)

    ######################################################################
    # `object` interface
    ######################################################################
    def __init__(self, **traits):
        super(LUTManager, self).__init__(**traits)

        # Initialize the scalar bar.
        sc_bar = self.scalar_bar
        sc_bar.set(lookup_table=self.lut,
                   title=self.data_name,
                   number_of_labels=self.number_of_labels,
                   orientation='horizontal',
                   width=0.8, height=0.17)
        pc = sc_bar.position_coordinate
        pc.set(coordinate_system='normalized_viewport',
               value=(0.1, 0.01, 0.0))
        self._shadow_changed(self.shadow)

        # Initialize the lut.
        self._lut_mode_changed(self.lut_mode)

        # Set the private traits.
        ttp = self._title_text_property = sc_bar.title_text_property
        ltp = self._label_text_property = sc_bar.label_text_property

        # Call render when the text properties are changed.
        ttp.on_trait_change(self.render)
        ltp.on_trait_change(self.render)

        # Initialize the scalar_bar_widget
        self.scalar_bar_widget.set(scalar_bar_actor=self.scalar_bar,
                                   key_press_activation=False)
        self._number_of_colors_changed(self.number_of_colors)


    ######################################################################
    # `Base` interface
    ######################################################################
    def start(self):
        """This is invoked when this object is added to the mayavi
        pipeline.
        """
        # Do nothing if we are already running.
        if self.running:
            return

        # Show the legend if necessary.
        self._show_scalar_bar_changed(self.show_scalar_bar)

        # Call parent method to set the running state.
        super(LUTManager, self).start()

    def stop(self):
        """Invoked when this object is removed from the mayavi
        pipeline.
        """
        if not self.running:
            return

        # Hide the scalar bar.
        sbw = self.scalar_bar_widget
        if sbw.interactor is not None:
            sbw.off()

        # Call parent method to set the running state.
        super(LUTManager, self).stop()

    ######################################################################
    # Non-public interface
    ######################################################################
    def _lut_mode_changed(self, value):

        if value == 'file':
            if self.file_name:
                self.load_lut_from_file(self.file_name)
            #self.lut.force_build()
            return

        reverse = self.reverse_lut
        if value in pylab_luts:
            lut = pylab_luts[value]
            if reverse:
                lut = lut[::-1, :]
            n_total = len(lut)
            n_color = self.number_of_colors
            if not n_color >= n_total:
                lut = lut[::round(n_total/float(n_color))]
            self.load_lut_from_list(lut.tolist())
            #self.lut.force_build()
            return
        elif value == 'blue-red':
            if reverse:
                hue_range = 0.0, 0.6667
                saturation_range = 1.0, 1.0
                value_range = 1.0, 1.0
            else:
                hue_range = 0.6667, 0.0
                saturation_range = 1.0, 1.0
                value_range = 1.0, 1.0
        elif value == 'black-white':
            if reverse:
                hue_range = 0.0, 0.0
                saturation_range = 0.0, 0.0
                value_range = 1.0, 0.0
            else:
                hue_range = 0.0, 0.0
                saturation_range = 0.0, 0.0
                value_range = 0.0, 1.0
        lut = self.lut
        lut.set(hue_range=hue_range, saturation_range=saturation_range,
                value_range=value_range,
                number_of_table_values=self.number_of_colors,
                ramp='sqrt')
        lut.modified()
        lut.force_build()

        self.render()

    def _scene_changed(self, value):
        sbw = self.scalar_bar_widget
        if value is None:
            return
        if sbw.interactor is not None:
            sbw.off()
        value.add_widgets(sbw, enabled=False)
        if self.show_scalar_bar:
            sbw.on()
        self._foreground_changed_for_scene(None, value.foreground)

    def _foreground_changed_for_scene(self, old, new):
        # Change the default color for the text.
        self.title_text_property.color = new
        self.label_text_property.color = new
        self.render()

    def _number_of_colors_changed(self, value):
        if self.lut_mode == 'file':
            return
        elif self.lut_mode in pylab_luts:
            # We can't interpolate these LUTs, as they are defined from a
            # table. We hack around this limitation
            reverse = self.reverse_lut
            lut = pylab_luts[self.lut_mode]
            if reverse:
                lut = lut[::-1, :]
            n_total = len(lut)
            if value > n_total:
                return
            lut = lut[::round(n_total/float(value))]
            self.load_lut_from_list(lut.tolist())
        else:
            lut = self.lut
            lut.number_of_table_values = value
            lut.modified()
            lut.build()
            self.render() # necessary to flush.
        sc_bar = self.scalar_bar
        sc_bar.maximum_number_of_colors = value
        sc_bar.modified()
        self.render()

    def _number_of_labels_changed(self, value):
        sc_bar = self.scalar_bar
        sc_bar.number_of_labels = value
        sc_bar.modified()
        self.render()

    def _file_name_changed(self, value):
        if self.lut_mode == 'file':
            self.load_lut_from_file(value)
        else:
            # This will automagically load the LUT from the file.
            self.lut_mode = 'file'

    def _reverse_lut_changed(self, value):
        # This will do the needful.
        self._lut_mode_changed(self.lut_mode)

    def _show_scalar_bar_changed(self, value):
        if self.scene is not None:
            self.scalar_bar_widget.enabled = value
            self.render()

    def _get_show_legend(self):
        return self.show_scalar_bar

    def _set_show_legend(self, value):
        old = self.show_scalar_bar
        if value != old:
            self.show_scalar_bar = value
            self.trait_property_changed('show_legend', old, value)

    def _shadow_changed(self, value):
        sc_bar = self.scalar_bar
        sc_bar.title_text_property.shadow = self.shadow
        sc_bar.label_text_property.shadow = self.shadow
        self.render()

    def _use_default_name_changed(self, value):
        self._default_data_name_changed(self.default_data_name)

    def _data_name_changed(self, value):
        sc_bar = self.scalar_bar
        sc_bar.title = value
        sc_bar.modified()
        self.render()

    def _default_data_name_changed(self, value):
        if self.use_default_name:
            self.data_name = value

    def _use_default_range_changed(self, value):
        self._default_data_range_changed(self.default_data_range)

    def _data_range_changed(self, value):
        try:
            self.lut.set_range(value[0], value[1])
        except TypeError:
            self.lut.set_range((value[0], value[1]))
        except AttributeError:
            self.lut.range = value
        self.scalar_bar.modified()
        self.render()

    def _default_data_range_changed(self, value):
        if self.use_default_range:
            self.data_range = value

    def _visible_changed(self, value):
        state = self.show_scalar_bar and value
        self._show_scalar_bar_changed(state)
        super(LUTManager, self)._visible_changed(value)

    def load_lut_from_file(self, file_name):
        lut_list = []
        if len(file_name) > 0:
            try:
                f = open(file_name, 'r')
            except IOError:
                msg = "Cannot open Lookup Table file: %s\n"%file_name
                error(msg)
            else:
                f.close()
                try:
                    lut_list = parse_lut_file(file_name)
                except IOError, err_msg:
                    msg = "Sorry could not parse LUT file: %s\n"%file_name
                    msg += err_msg
                    error(msg)
                else:
                    if self.reverse_lut:
                        lut_list.reverse()
                    self.lut = set_lut(self.lut, lut_list)
                    self.render()

    def load_lut_from_list(self, list):
        self.lut = set_lut(self.lut, list)
        self.render()

    def _get_title_text_property(self):
        return self._title_text_property

    def _get_label_text_property(self):
        return self._label_text_property

    def _create_lut_fired(self):
        from tvtk import util
        script = os.path.join(os.path.dirname(util.__file__),
                              'wx_gradient_editor.py')
        subprocess.Popen([sys.executable, script])
        auto_close_message('Launching LUT editor in separate process ...')

    def _scalar_bar_representation_default(self):
        w = self.scalar_bar_widget
        if hasattr(w, 'representation'):
            r = w.representation
            r.on_trait_change(self.render)
            return r
        else:
            return None

########NEW FILE########
__FILENAME__ = metadata
"""
The definition of different kinds of metadata that is put into the
mayavi registry
"""
# Author: Prabhu Ramachandran <prabhu@aero.iitb.ac.in>
# Copyright (c) 2008, Enthought, Inc.
# License: BSD Style.

# Enthought library imports.
from traits.api import HasTraits, Str, Callable, Either, List, Instance
from mayavi.core.pipeline_info import PipelineInfo


################################################################################
# Utility functions.
################################################################################
def import_symbol(symbol_path):

    """ Import the symbol defined by the specified symbol path.
    Copied from envisage's import manager.
    """

    if ':' in symbol_path:
        module_name, symbol_name = symbol_path.split(':')

        module = import_module(module_name)
        symbol = eval(symbol_name, module.__dict__)

    else:
        components = symbol_path.split('.')

        module_name = '.'.join(components[:-1])
        symbol_name = components[-1]

        module = __import__(
            module_name, globals(), locals(), [symbol_name]
        )

        symbol = getattr(module, symbol_name)

    return symbol

def import_module(module_name):

    """This imports the given module name.  This code is copied from
    envisage's import manager!

    """

    module = __import__(module_name)

    components = module_name.split('.')
    for component in components[1:]:
        module = getattr(module, component)

    return module



################################################################################
# `Metadata` class.
################################################################################
class Metadata(HasTraits):
    """
    This class allows us to define metadata related to mayavi's sources,
    filters and modules.
    """

    # Our ID.
    id = Str

    # The class that implements the module/filter/source.
    class_name = Str

    # The factory that implements the object overrides the class_name if
    # not the empty string.  The callable will be given the filename to
    # open along with the engine (for sources).
    factory = Either(Str, Callable, allow_none=False)

    # Description of the object being described.
    desc = Str

    # Help string for the object.
    help = Str

    # The name of this object in a menu.
    menu_name = Str

    # The optional tooltip to display for this object.
    tooltip = Str

    # Information about what this object can consume.
    input_info = Instance(PipelineInfo)

    # Information about what this object can produce.
    output_info = Instance(PipelineInfo)

    ######################################################################
    # Metadata interface.
    ######################################################################
    def get_callable(self):
        """Return the callable that will create a new instance of the
        object implementing this metadata.
        """
        factory = self.factory
        if factory is not None:
            if callable(factory):
                symbol = factory
            elif isinstance(factory, str) and len(factory) > 0:
                symbol = import_symbol(factory)
            else:
                symbol = import_symbol(self.class_name)
        else:
            symbol = import_symbol(self.class_name)

        return symbol


################################################################################
# `ModuleMetadata` class.
################################################################################
class ModuleMetadata(Metadata):
    pass

################################################################################
# `FilterMetadata` class.
################################################################################
class FilterMetadata(Metadata):
    pass

################################################################################
# `SourceMetadata` class.
################################################################################
class SourceMetadata(Metadata):

    # The file name extension that this reader/source handles.  Empty if
    # it does not read a file.
    extensions = List(Str)

    # Wildcard for the file dialog.
    wildcard = Str

    # `Callable` to check if the reader can actually read the file
    # `Callable` must accept the filename to be read and it should
    # return `True` if its possible to read the file else 'False'
    can_read_test = Str

########NEW FILE########
__FILENAME__ = module
"""The base class for all MayaVi modules.

"""
# Author: Prabhu Ramachandran <prabhu_r@users.sf.net>
# Copyright (c) 2005-2008, Enthought, Inc.
# License: BSD Style.

# Enthought library imports.
from traits.api import List, Instance, Str

# Local imports
from mayavi.core.pipeline_base import PipelineBase
from mayavi.core.pipeline_info import PipelineInfo
from mayavi.core.common import exception


######################################################################
# `Module` class.
######################################################################
class Module(PipelineBase):
    """ Base class for the Mayavi modules.
    """

    # The version of this class.  Used for persistence.
    __version__ = 0

    # The ModuleManager associated with this module.  A Module is
    # always a child of a ModuleManager.  When the module is added to
    # the mayavi pipeline (as a child of the module manager), the
    # module manager automatically sets this trait.
    module_manager = Instance('mayavi.core.module_manager.ModuleManager',
                               record=False)

    # The (optional) components used by this module.  NOTE: This is
    # not pickled.  It is the developers responsibility to setup the
    # components when the component traits are set in the handler.
    components = List(record=False)

    # The icon
    icon = Str('module.ico')

    # The human-readable type for this object
    type = Str(' module')

    # Information about what this object can consume.
    input_info = PipelineInfo(datasets=['any'])

    # Information about what this object can produce.
    output_info = PipelineInfo(datasets=['none'])

    ######################################################################
    # `object` interface.
    ######################################################################
    def __init__(self, **traits):
        super(Module, self).__init__(**traits)

        # Let the module setup its pipeline.
        self.setup_pipeline()

    def __get_pure_state__(self):
        d = super(Module, self).__get_pure_state__()
        for x in ('module_manager', 'components'):
            d.pop(x, None)
        return d


    ######################################################################
    # `Module` interface.
    ######################################################################
    def setup_pipeline(self):
        """Override this method so that it *creates* the tvtk
        pipeline.

        This method is invoked when the object is initialized via
        `__init__`.  Note that at the time this method is called, the
        tvtk data pipeline will *not* yet be setup.  So upstream data
        will not be available.  The idea is that you simply create the
        basic objects and setup those parts of the pipeline not
        dependent on upstream sources and filters.  You should also
        set the `actors` attribute up at this point.
        """
        pass

    def update_pipeline(self):
        """Override this method so that it *updates* the tvtk pipeline
        when data upstream is known to have changed.

        This method is invoked (automatically) when the input fires a
        `pipeline_changed` event.
        """
        raise NotImplementedError

    def update_data(self):
        """Override this method so that it flushes the vtk pipeline if
        that is necessary.

        This method is invoked (automatically) when any of the inputs
        sends a `data_changed` event.
        """
        # By default, just invoke render and set data_changed.
        self.data_changed = True
        self.render()


    ######################################################################
    # `Base` interface
    ######################################################################
    def start(self):
        """This is invoked when this object is added to the mayavi
        pipeline.  Note that when start is invoked, all the other
        information for the pipeline should be already set.
        """
        if self.running:
            return

        # Setup event handlers.
        self._setup_event_handlers()

        # Setup the pipeline.
        self.update_pipeline()

        # Start the components.
        try:
            for component in self.components:
                component.start()
        except:
            exception()

        # Call parent method to set the running state.
        super(Module, self).start()

    def stop(self):
        """Invoked when this object is removed from the mayavi
        pipeline.
        """
        if not self.running:
            return

        # Teardown event handlers.
        self._teardown_event_handlers()

        # Stop the components.
        for component in self.components:
            component.stop()

        # Call parent method to set the running state.
        super(Module, self).stop()

    def add_child(self, child):
        """This method intelligently adds a child to this object in
        the MayaVi pipeline.
        """
        # Pass on the buck to our module_manager.
        self.module_manager.add_child(child)

    ######################################################################
    # `TreeNodeObject` interface
    ######################################################################
    def tno_has_children(self, node):
        """ Returns whether or not the object has children.
        """
        return False

    def tno_allows_children(self, node):
        """ Returns whether chidren of this object are allowed or not.
        """
        return False

    def tno_get_children(self, node):
        """ Gets the object's children.
        """
        return None

    ######################################################################
    # Non-public interface
    ######################################################################
    def _change_components(self, old, new):
        """This method sets up the `components` trait and is typically
        called from a handler for a particular component.

        For example lets say you are using a `Actor` component and
        have a `actor` trait on the module.  The `_actor_changed`
        method should setup the pipeline.  Typically inside this
        handler, you also want to change the module's `components`
        trait.  This method merely does that by removing the older
        component and adding the new one and then updating the
        pipeline just in case.
        """
        comp = self.components
        if old is not None:
            comp.remove(old)
        comp.append(new)
        if old is not None:
            self.update_pipeline()

    def _setup_event_handlers(self):
        mm = self.module_manager
        src = mm.source
        mm.on_trait_change(self.update_pipeline, 'source')
        src.on_trait_event(self.update_pipeline, 'pipeline_changed')
        src.on_trait_event(self.update_data, 'data_changed')

    def _teardown_event_handlers(self):
        mm = self.module_manager
        src = mm.source
        mm.on_trait_change(self.update_pipeline, 'source',
                           remove=True)
        src.on_trait_event(self.update_pipeline, 'pipeline_changed',
                           remove=True)
        src.on_trait_event(self.update_data, 'data_changed',
                           remove=True)

    def _scene_changed(self, old_scene, new_scene):
        for component in self.components:
            component.scene = new_scene
        super(Module, self)._scene_changed(old_scene, new_scene)

    def _components_changed(self, old, new):
        self._handle_components(old, new)

    def _components_items_changed(self, list_event):
        self._handle_components(list_event.removed, list_event.added)

    def _handle_components(self, removed, added):
        for component in removed:
            if self.running:
                component.stop()
        scene = self.scene
        for component in added:
            if scene is not None:
                component.scene = scene
            if self.running:
                component.start()

    def _visible_changed(self,value):
        for c in self.components:
            c.visible = value

        super(Module,self)._visible_changed(value)

    def _menu_helper_default(self):
        from mayavi.core.traits_menu import ModuleMenuHelper
        return ModuleMenuHelper(object=self.module_manager)

########NEW FILE########
__FILENAME__ = module_manager
"""Manages a collection of module objects.  Also manages the lookup
tables.

"""
# Author: Prabhu Ramachandran <prabhu_r@users.sf.net>
# Copyright (c) 2005-2008,  Enthought, Inc.
# License: BSD Style.

import numpy

# Enthought library imports.
from traits.api import List, Instance, Trait, TraitPrefixList, \
                                 HasTraits, Str
from apptools.persistence.state_pickler import set_state

# Local imports
from mayavi.core.base import Base
from mayavi.core.module import Module
from mayavi.core.lut_manager import LUTManager
from mayavi.core.common import handle_children_state, exception
from mayavi.core.pipeline_info import PipelineInfo


######################################################################
# `DataAttributes` class.
######################################################################
class DataAttributes(HasTraits):
    """A simple helper class used to store some attributes of an input
    data object."""

    # The version of this class.  Used for persistence.
    __version__ = 0

    # The name of the input data array.
    name = Str('')

    # The range of the data array.
    range = List

    def _get_np_arr(self, arr):
        data_array = arr.to_array()
        data_has_nan = numpy.isnan(data_array).any()
        return data_array, data_has_nan

    def compute_scalar(self, data, mode='point'):
        """Compute the scalar range from given VTK data array.  Mode
        can be 'point' or 'cell'."""
        if data is not None:
            if data.name is None or len(data.name) == 0:
                data.name = mode + '_scalars'
            self.name = data.name
            data_array, data_has_nan = self._get_np_arr(data)
            if data_has_nan:
                self.range = [float(numpy.nanmin(data_array)),
                              float(numpy.nanmax(data_array))]
            else:
                self.range = list(data.range)

    def compute_vector(self, data, mode='point'):
        """Compute the vector range from given VTK data array.  Mode
        can be 'point' or 'cell'."""
        if data is not None:
            if data.name is None or len(data.name) == 0:
                data.name = mode + '_vectors'
            self.name = data.name
            data_array, data_has_nan = self._get_np_arr(data)
            if data_has_nan:
                d_mag = numpy.sqrt((data_array*data_array).sum(axis=1))
                self.range = [float(numpy.nanmin(d_mag)),
                              float(numpy.nanmax(d_mag))]
            else:
                self.range = [0.0, data.max_norm]

    def config_lut(self, lut_mgr):
        """Set the attributes of the LUTManager."""
        rng = [0.0, 1.0]
        if len(self.range) > 0:
            rng = self.range

        lut_mgr.default_data_range = list(rng)
        lut_mgr.default_data_name = self.name


# Constant for a ModuleManager class and it's View.
LUT_DATA_MODE_TYPES = ['auto', 'point data', 'cell data']

######################################################################
# `ModuleManager` class.
######################################################################
class ModuleManager(Base):
    """ The module manager node (represented as 'Colors and Legends').
    """

    # The source object this is connected to.
    source = Instance(Base)

    # The modules contained by this manager.
    children = List(Module, record=True)

    # The data type to use for the LUTs.  Changing this setting will
    # change the data range and name of the lookup table/legend bar.
    # If set to 'auto', it automatically looks for cell and point data
    # with point data being preferred over cell data and chooses the
    # one available.  If set to 'point data' it uses the input point
    # data for the LUT and if set to 'cell data' it uses the input
    # cell data.
    lut_data_mode = Trait('auto',
                          TraitPrefixList(LUT_DATA_MODE_TYPES),
                          desc='specify the data type used by the lookup tables',
                          )

    # The scalar lookup table manager.
    scalar_lut_manager = Instance(LUTManager, args=(), record=True)

    # The vector lookup table manager.
    vector_lut_manager = Instance(LUTManager, args=(), record=True)

    # The name of the ModuleManager.
    name = Str('Colors and legends')

    # The icon
    icon = Str('modulemanager.ico')

    # The human-readable type for this object
    type = Str(' colors and legends')


    # Information about what this object can consume.
    input_info = PipelineInfo(datasets=['any'])

    # Information about what this object can produce.
    output_info = PipelineInfo(datasets=['any'])

    ######################################################################
    # `object` interface
    ######################################################################
    def __get_pure_state__(self):
        d = super(ModuleManager, self).__get_pure_state__()
        # Source is setup dynamically, don't pickle it.
        d.pop('source', None)
        return d

    def __set_pure_state__(self, state):
        # Do everything but our kids.
        set_state(self, state, ignore=['children'])
        # Setup children.
        handle_children_state(self.children, state.children)
        # Now setup the children.
        set_state(self, state, first=['children'], ignore=['*'])
        self.update()

    ######################################################################
    # `ModuleManager` interface
    ######################################################################
    def update(self):
        """Update any internal data.

        This is invoked when the source changes or when there are
        pipeline/data changes upstream.
        """
        self._setup_scalar_data()
        self._setup_vector_data()


    ######################################################################
    # `Base` interface
    ######################################################################
    def start(self):
        """This is invoked when this object is added to the mayavi
        pipeline.
        """
        # Do nothing if we are already running.
        if self.running:
            return

        # Setup event handlers.
        self._setup_event_handlers()

        # Start all our children.
        for obj in self.children:
            obj.start()
        for obj in (self.scalar_lut_manager, self.vector_lut_manager):
            obj.start()

        # Call parent method to set the running state.
        super(ModuleManager, self).start()

    def stop(self):
        """Invoked when this object is removed from the mayavi
        pipeline.
        """
        if not self.running:
            return

        # Teardown event handlers.
        self._teardown_event_handlers()

        # Stop all our children.
        for obj in self.children:
            obj.stop()
        for obj in (self.scalar_lut_manager, self.vector_lut_manager):
            obj.stop()

        # Call parent method to set the running state.
        super(ModuleManager, self).stop()

    def add_child(self, child):
        """This method intelligently adds a child to this object in
        the MayaVi pipeline.
        """
        if isinstance(child, Module):
            self.children.append(child)
        else:
            # Ask our source to deal with it.
            self.source.add_child(child)

    def remove_child(self, child):
        """Remove specified child from our children.
        """
        self.children.remove(child)

    ######################################################################
    # `TreeNodeObject` interface
    ######################################################################
    def tno_can_add(self, node, add_object):
        """ Returns whether a given object is droppable on the node.
        """
        try:
            if issubclass(add_object, Module):
                return True
        except TypeError:
            if isinstance(add_object, Module):
                return True
        return False

    def tno_drop_object(self, node, dropped_object):
        """ Returns a droppable version of a specified object.
        """
        if isinstance(dropped_object, Module):
            return dropped_object

    ######################################################################
    # Non-public interface
    ######################################################################
    def _children_changed(self, old, new):
        self._handle_children(old, new)

    def _children_items_changed(self, list_event):
        self._handle_children(list_event.removed, list_event.added)

    def _handle_children(self, removed, added):
        # Stop all the old children.
        for obj in removed:
            obj.stop()
        # Setup and start the new ones.
        for obj in added:
            obj.set(module_manager=self, scene=self.scene, parent=self)
            if self.running:
                # It makes sense to start children only if we are running.
                # If not, the children will be started when we start.
                try:
                    obj.start()
                except:
                    exception()

    def _source_changed(self):
        self.output_info.copy_traits(self.source.output_info)
        self.update()

    def _setup_event_handlers(self):
        src = self.source
        src.on_trait_event(self.update, 'pipeline_changed')
        src.on_trait_event(self.update, 'data_changed')

    def _teardown_event_handlers(self):
        src = self.source
        src.on_trait_event(self.update, 'pipeline_changed', remove=True)
        src.on_trait_event(self.update, 'data_changed', remove=True)

    def _scene_changed(self, value):
        for obj in self.children:
            obj.scene = value
        for obj in (self.scalar_lut_manager, self.vector_lut_manager):
            obj.scene = value

    def _lut_data_mode_changed(self, value):
        self.update()

    def _setup_scalar_data(self):
        """Computes the scalar range and an appropriate name for the
        lookup table."""
        input = self.source.outputs[0]
        ps = input.point_data.scalars
        cs = input.cell_data.scalars

        data_attr = DataAttributes(name='No scalars')
        point_data_attr = DataAttributes(name='No scalars')
        point_data_attr.compute_scalar(ps, 'point')
        cell_data_attr = DataAttributes(name='No scalars')
        cell_data_attr.compute_scalar(cs, 'cell')

        if self.lut_data_mode == 'auto':
            if len(point_data_attr.range) > 0:
                data_attr.copy_traits(point_data_attr)
            elif len(cell_data_attr.range) > 0:
                data_attr.copy_traits(cell_data_attr)
        elif self.lut_data_mode == 'point data':
            data_attr.copy_traits(point_data_attr)
        elif self.lut_data_mode == 'cell data':
            data_attr.copy_traits(cell_data_attr)

        data_attr.config_lut(self.scalar_lut_manager)

    def _setup_vector_data(self):
        input = self.source.outputs[0]
        pv = input.point_data.vectors
        cv = input.cell_data.vectors

        data_attr = DataAttributes(name='No vectors')
        point_data_attr = DataAttributes(name='No vectors')
        point_data_attr.compute_vector(pv, 'point')
        cell_data_attr = DataAttributes(name='No vectors')
        cell_data_attr.compute_vector(cv, 'cell')

        if self.lut_data_mode == 'auto':
            if len(point_data_attr.range) > 0:
                data_attr.copy_traits(point_data_attr)
            elif len(cell_data_attr.range) > 0:
                data_attr.copy_traits(cell_data_attr)
        elif self.lut_data_mode == 'point data':
            data_attr.copy_traits(point_data_attr)
        elif self.lut_data_mode == 'cell data':
            data_attr.copy_traits(cell_data_attr)

        data_attr.config_lut(self.vector_lut_manager)

    def _visible_changed(self,value):
        for c in self.children:
            c.visible = value
        self.scalar_lut_manager.visible = value
        self.vector_lut_manager.visible = value

        super(ModuleManager,self)._visible_changed(value)

    def _menu_helper_default(self):
        from mayavi.core.traits_menu import ModuleMenuHelper
        return ModuleMenuHelper(object=self)

########NEW FILE########
__FILENAME__ = mouse_pick_dispatcher
"""
An object to register callbacks and dispatch event wiring mouse clicks
on a scene to picking.
"""

# ETS imports
from traits.api import HasTraits, Dict, Instance, \
        Enum, Int, Callable, on_trait_change, List, Tuple

from mayavi.core.scene import Scene
from tvtk.api import tvtk

VTK_VERSION =        tvtk.Version().vtk_major_version \
                + .1*tvtk.Version().vtk_minor_version

################################################################################
# class `MousePickDispatcher`
################################################################################
class MousePickDispatcher(HasTraits):
    """ An event dispatcher to send pick event on mouse clicks.

        This objects wires VTK observers so that picking callbacks
        can be bound to mouse click without movement.

        The object deals with adding and removing the VTK-level
        callbacks.
    """

    # The scene events are wired to.
    scene = Instance(Scene)

    # The list of callbacks, with the picker type they should be using,
    # and the mouse button that triggers them.
    callbacks = List(Tuple(
                        Callable,
                        Enum('cell', 'point', 'world'),
                        Enum('Left', 'Middle', 'Right'),
                        ),
                    help="The list of callbacks, with the picker type they "
                         "should be using, and the mouse button that "
                         "triggers them. The callback is passed "
                         "as an argument the tvtk picker."
                    )

    #--------------------------------------------------------------------------
    # Private traits
    #--------------------------------------------------------------------------

    # Whether the mouse has moved after the button press
    _mouse_no_mvt = Int

    # The button that has been pressed
    _current_button = Enum('Left', 'Middle', 'Right')

    # The various picker that are used when the mouse is pressed
    _active_pickers = Dict

    # The VTK callback numbers corresponding to our callbacks
    _picker_callback_nbs = Dict(value_trait=Int)

    # The VTK callback numbers corresponding to mouse movement
    _mouse_mvt_callback_nb = Int

    # The VTK callback numbers corresponding to mouse press
    _mouse_press_callback_nbs = Dict

    # The VTK callback numbers corresponding to mouse release
    _mouse_release_callback_nbs = Dict

    #--------------------------------------------------------------------------
    # Callbacks management
    #--------------------------------------------------------------------------

    @on_trait_change('callbacks_items')
    def dispatch_callbacks_change(self, name, trait_list_event):
        for item in trait_list_event.added:
            self.callback_added(item)
        for item in trait_list_event.removed:
            self.callback_removed(item)


    def callback_added(self, item):
        """ Wire up the different VTK callbacks.
        """
        callback, type, button = item
        picker = getattr(self.scene.scene.picker, '%spicker' % type)
        self._active_pickers[type] = picker

        # Register the pick callback
        if not type in self._picker_callback_nbs:
            self._picker_callback_nbs[type] = \
                            picker.add_observer("EndPickEvent",
                                                self.on_pick)

        # Register the callbacks on the scene interactor
        if VTK_VERSION>5:
            move_event = "RenderEvent"
        else:
            move_event = 'MouseMoveEvent'
        if not self._mouse_mvt_callback_nb:
            self._mouse_mvt_callback_nb = \
                self.scene.scene.interactor.add_observer(move_event,
                                                self.on_mouse_move)
        if not button in self._mouse_press_callback_nbs:
            self._mouse_press_callback_nbs[button] = \
                self.scene.scene.interactor.add_observer(
                                    '%sButtonPressEvent' % button,
                                    self.on_button_press)
        if VTK_VERSION>5:
            release_event = "EndInteractionEvent"
        else:
            release_event = '%sButtonReleaseEvent' % button
        if not button in self._mouse_release_callback_nbs:
            self._mouse_release_callback_nbs[button] = \
                self.scene.scene.interactor.add_observer(
                                    release_event,
                                    self.on_button_release)


    def callback_removed(self, item):
        """ Clean up the unecessary VTK callbacks.
        """
        callback, type, button = item

        # If the picker is no longer needed, clean up its observers.
        if not [t for c, t, b in self.callbacks if t == type]:
            picker = self._active_pickers[type]
            picker.remove_observer(self._picker_callback_nbs[type])
            del self._active_pickers[type]

        # If there are no longer callbacks on the button, clean up
        # the corresponding observers.
        if not [b for c, t, b in self.callbacks if b == button]:
            self.scene.scene.interactor.remove_observer(
                    self._mouse_press_callback_nbs[button])
            self.scene.scene.interactor.remove_observer(
                    self._mouse_release_callback_nbs[button])
        if len(self.callbacks) == 0 and self._mouse_mvt_callback_nb:
            self.scene.scene.interactor.remove_observer(
                            self._mouse_mvt_callback_nb)
            self._mouse_mvt_callback_nb = 0


    def clear_callbacks(self):
        while self.callbacks:
            self.callbacks.pop()

    #--------------------------------------------------------------------------
    # Mouse movement dispatch mechanism
    #--------------------------------------------------------------------------

    def on_button_press(self, vtk_picker, event):
        self._current_button = event[:-len('ButtonPressEvent')]
        self._mouse_no_mvt = 2


    def on_mouse_move(self, vtk_picker, event):
        if self._mouse_no_mvt:
            self._mouse_no_mvt -= 1


    def on_button_release(self, vtk_picker, event):
        """ If the mouse has not moved, pick with our pickers.
        """
        if self._mouse_no_mvt:
            x, y = vtk_picker.GetEventPosition()
            for picker in self._active_pickers.values():
                try:
                    picker.pick((x, y, 0), self.scene.scene.renderer)
                except TypeError:
                    picker.pick(x, y, 0, self.scene.scene.renderer)
        self._mouse_no_mvt = 0


    def on_pick(self, vtk_picker, event):
        """ Dispatch the pick to the callback associated with the
            corresponding mouse button.
        """
        picker = tvtk.to_tvtk(vtk_picker)
        for event_type, event_picker in self._active_pickers.iteritems():
            if picker is event_picker:
                for callback, type, button in self.callbacks:
                    if ( type == event_type
                                    and button == self._current_button):
                        callback(picker)
            break

    #--------------------------------------------------------------------------
    # Private methods
    #--------------------------------------------------------------------------

    def __del__(self):
        self.clear_callbacks()


########NEW FILE########
__FILENAME__ = null_engine
"""
A Null engine for Mayavi.

The `NullEngine` class lets you create a full-fledged (almost) Mayavi
engine without the need for it poping up a window.

It is useful for testing or for using VTK as numerical engine. It does
not allow for rendering.

"""
# Author: Prabhu Ramachandran <prabhu@aero.iitb.ac.in>
# Copyright (c) 2008, Enthought, Inc.
# License: BSD Style.

from traits.api import HasTraits, Any, Event, Callable

from mayavi.core.engine import Engine

def dummy_viewer_factory():
    """Factory function for the dummy viewer."""
    return DummyViewer()

################################################################################
# `NullEngine` class.
################################################################################
class NullEngine(Engine):
    """
    This class represents a NullEngine which creates a DummyViewer with
    a scene set to None.  This allows us to write full mayavi scripts
    without the need for a UI and this is perfect for testing, or to
    use Mayavi (and VTK) as a numerical engine.

    This engine does not allow for rendring.
    """
    scene_factory = Callable(dummy_viewer_factory)


################################################################################
# `DummyViewer` class.
################################################################################
class DummyViewer(HasTraits):
    """Mimics the API of a viewer."""

    scene = Any
    closing = Event
    activated = Event


########NEW FILE########
__FILENAME__ = off_screen_engine
"""
An off-screen mayavi engine.
"""
# Author: Prabhu Ramachandran <prabhu@aero.iitb.ac.in>
# Copyright (c) 2008, Enthought, Inc.
# License: BSD Style.

from traits.api import Callable, Str
from tvtk.pyface.tvtk_scene import TVTKWindow
from mayavi.core.engine import Engine
from mayavi.preferences.api import set_scene_preferences


def off_screen_viewer_factory(size=(400, 350)):
    """A factory that creates an offscreen viewer."""
    win = TVTKWindow(off_screen_rendering=True)
    # Set all preferences.
    set_scene_preferences(win.scene)
    # Set the size.
    win.scene.set_size(size)
    return win

################################################################################
# `OffScreenEngine` class.
################################################################################
class OffScreenEngine(Engine):
    # Overriding the scene factory trait of Engine.
    scene_factory = Callable(off_screen_viewer_factory)

    # Our name.
    name = Str('Mayavi offscreen Engine')

########NEW FILE########
__FILENAME__ = pipeline_base
"""The base class for all objects in the MayaVi pipeline.  This class
basically abstracts out the common parts of the pipeline interface.

"""
# Author: Prabhu Ramachandran <prabhu_r@users.sf.net>
# Copyright (c) 2005-2008, Enthought, Inc.
# License: BSD Style.

# Enthought library imports.
from traits.api import List, Event, Bool, Instance

# Local imports.
from mayavi.core.base import Base
from mayavi.core.pipeline_info import PipelineInfo
import tvtk.common as tvtk_common

######################################################################
# `PipelineBase` class.
######################################################################
class PipelineBase(Base):
    """ Base class for all the Source, Filters and Modules in the
        pipeline.
    """

    # The version of this class.  Used for persistence.
    __version__ = 0

    # A list of outputs for this object.
    outputs = List(record=False)

    # The actors generated by this object that will be rendered on the
    # scene.  Changing this list while the actors are renderered *is*
    # safe and will do the right thing.
    actors = List(record=False)

    # The optional list of actors belonging to this object.  These
    # will be added to the scene at an appropriate time.  Changing
    # this list while the widgets are renderered *is* safe and will do
    # the right thing.
    widgets = List(record=False)

    # Information about what this object can consume.
    input_info = Instance(PipelineInfo)

    # Information about what this object can produce.
    output_info = Instance(PipelineInfo)

    ########################################
    # Events.

    # This event is fired when the pipeline has changed.
    pipeline_changed = Event(record=False)

    # This event is fired when the data alone changes but the pipeline
    # outputs are the same.
    data_changed = Event(record=False)

    ##################################################
    # Private traits.
    ##################################################
    # Identifies if `actors` and `widgets` are added to the `scene` or
    # not.
    _actors_added = Bool(False)

    # Stores the state of the widgets prior to disabling them.
    _widget_state = List

    ######################################################################
    # `object` interface.
    ######################################################################
    def __get_pure_state__(self):
        d = super(PipelineBase, self).__get_pure_state__()
        # These are setup dynamically so we should not pickle them.
        for x in ('outputs', 'actors', 'widgets', '_actors_added', ):
            d.pop(x, None)
        return d


    ######################################################################
    # `Base` interface
    ######################################################################
    def start(self):
        """This is invoked when this object is added to the mayavi
        pipeline.  Note that when start is invoked, all the other
        information for the pipeline should be already set.
        """
        if self.running:
            return

        # Add any actors.
        self.add_actors()

        # Call parent method to set the running state.
        super(PipelineBase, self).start()

    def stop(self):
        """Invoked when this object is removed from the mayavi
        pipeline.
        """
        if not self.running:
            return

        # Remove any of our actors from the scene.
        self.remove_actors()

        # Call parent method to set the running state.
        super(PipelineBase, self).stop()

    def render(self):
        """Invokes render on the scene, this in turn invokes Render on
        the VTK pipeline.
        """
        s = self.scene
        if s is not None:
            s.render()
        elif self.running:
            # If there is no scene and we are running, we flush the
            # pipeline manually by calling update.
            for actor in self.actors:
                if hasattr(actor, 'mapper'):
                    m = actor.mapper
                    if m is not None:
                        if tvtk_common.is_old_pipeline():
                            m.update()
                        else:
                            m.update(0)
            if tvtk_common.is_old_pipeline():
                for widget in self.widgets:
                    if hasattr(widget, 'input'):
                        input = widget.input
                        if input is not None:
                            input.update()
        if hasattr(self, 'components'):
            for component in self.components:
                    component.render()

    ######################################################################
    # `PipelineBase` interface.
    ######################################################################
    # Normally, you will not need to override the following methods
    # but you can if you really need to for whatever reason.
    def add_actors(self):
        """Adds `self.actors` to the scene.

        This is typically called when start is invoked.  You should
        avoid calling this unless you know what you are doing.
        """
        scene = self.scene
        if scene is not None:
            scene.add_actors(self.actors)
            scene.add_widgets(self.widgets)
            self._set_widget_visibility(self.widgets)
            self._actors_added = True

    def remove_actors(self):
        """Removes `self.actors` from the scene.

        This is typically called when stop is invoked.  You should
        avoid calling this unless you know what you are doing.
        """
        scene = self.scene
        if scene is not None:
            scene.remove_actors(self.actors)
            scene.remove_widgets(self.widgets)
            self._actors_added = False

    def has_output_port(self):
        """ We assume the old pipeline topology.
        As such we assume no output_port exists."""
        return False

    def get_output_object(self):
        """ We assume the old pipeline topology.
        As such we return the first output."""
        return self.outputs[0]

    def configure_connection(self, obj, inp):
        """ Configure topology for vtk pipeline obj."""
        tvtk_common.configure_connection(obj, inp)

    def configure_input_data(self, obj, data):
        """ Configure the input data for vtk pipeline object obj."""
        tvtk_common.configure_input_data(obj, data)

    def configure_input(self, inp, op):
        """ Configure the inp using op."""
        tvtk_common.configure_input(inp, op)

    def configure_source_data(self, obj, data):
        """ Configure the source data for vtk pipeline object obj."""
        tvtk_common.configure_source_data(obj, data)

    ######################################################################
    # Non-public interface
    ######################################################################
    def _outputs_changed(self, new):
        self.pipeline_changed = True

    def _outputs_items_changed(self, list_event):
        self.pipeline_changed = True

    def _actors_changed(self, old, new):
        if self._actors_added:
            self.scene.remove_actors(old)
            self.scene.add_actors(new)
            self.scene.render()

    def _actors_items_changed(self, list_event):
        if self._actors_added:
            self.scene.remove_actors(list_event.removed)
            self.scene.add_actors(list_event.added)
            self.scene.render()

    def _widgets_changed(self, old, new):
        self._handle_widgets_changed(old, new)

    def _widgets_items_changed(self, list_event):
        self._handle_widgets_changed(list_event.removed, list_event.added)

    def _handle_widgets_changed(self, removed, added):
        if self._actors_added:
            scene = self.scene
            scene.remove_widgets(removed)
            scene.add_widgets(added)
            self._set_widget_visibility(added)

    def _scene_changed(self, old_scene, new_scene):
        if self._actors_added:
            old_scene.remove_actors(self.actors)
            old_scene.remove_widgets(self.widgets)
            new_scene.add_actors(self.actors)
            new_scene.add_widgets(self.widgets)
            self._set_widget_visibility(self.widgets)

    def _backup_widget_state(self):
        # store the enabled trait of the widgets
        # in the _widget_state list
        state = []
        for w in self.widgets:
            state.append(w.enabled)
            self._widget_state[:] = state

    def _restore_widget_state(self):
        if len(self._widget_state) != len(self.widgets):
            # someone has played with the widgets
            # we just enable all of them
            for w in self.widgets:
                w.enabled = True
        else:
            for i in range(len(self.widgets)):
                self.widgets[i].enabled = self._widget_state[i]

    def _visible_changed(self,value):
        if value:
            # restore the state of the widgets from the
            # backed up values.
            self._restore_widget_state()
        else:
            self._backup_widget_state()
            # disable all the widgets
            self._set_widget_visibility(self.widgets)

        # hide all actors
        for a in self.actors:
            a.visibility = value

        self.render()
        super(PipelineBase , self)._visible_changed(value)

    def _set_widget_visibility(self, widgets):
        if not self.visible:
            for widget in widgets:
                widget.enabled = False

########NEW FILE########
__FILENAME__ = pipeline_info
"""
 Defines the class that describes the information on the inputs and
 outputs of an object in the pipeline.
"""
# Author: Prabhu Ramachandran <prabhu@aero.iitb.ac.in>
# Copyright (c) 2008, Prabhu Ramachandran Enthought, Inc.
# License: BSD Style.

# Enthought library imports.
from traits.api import HasTraits, Enum, List

# The list of datasets supported.
DataSet = Enum('none', 'any', 'image_data', 'rectilinear_grid',
               'poly_data', 'structured_grid', 'unstructured_grid')

# Attribute type.
AttributeType = Enum('any', 'cell', 'point', 'none')

# Attribute.
Attribute = Enum('any', 'none', 'scalars', 'vectors', 'tensors')


################################################################################
# Utility functions.
################################################################################
def get_tvtk_dataset_name(dataset):
    """Given a TVTK dataset `dataset` return the string dataset type of
    the dataset.
    """
    result = 'none'
    if hasattr(dataset, 'is_a'):
        if dataset.is_a('vtkStructuredPoints') or \
           dataset.is_a('vtkImageData'):
               result = 'image_data'
        elif dataset.is_a('vtkRectilinearGrid'):
            result = 'rectilinear_grid'
        elif dataset.is_a('vtkPolyData'):
            result = 'poly_data'
        elif dataset.is_a('vtkStructuredGrid'):
            result = 'structured_grid'
        elif dataset.is_a('vtkUnstructuredGrid'):
            result = 'unstructured_grid'
        else:
            result = 'none'
    else:
        result = 'none'
    return result


################################################################################
# `PipelineInfo` class.
################################################################################
class PipelineInfo(HasTraits):

    """
    This class represents the information that a particular input or
    output of an object should contain.
    """

    # The datasets supported by the object.
    datasets = List(DataSet)

    # The attribute types the object works on.
    attribute_types = List(AttributeType)

    # The attributes the object can use/produce.
    attributes = List(Attribute)


########NEW FILE########
__FILENAME__ = registry
"""
 A registry for engines, sources, filters and modules.
"""
# Author: Prabhu Ramachandran <prabhu@aero.iitb.ac.in>
# Copyright (c) 2008, Enthought, Inc.
# License: BSD Style.

# Standard library imports.
from os.path import splitext
import logging

# Enthought library imports.
from traits.api import HasTraits, List, Instance, Dict, Str

# Local imports.
from mayavi.core.metadata import Metadata, import_symbol

# A logger for this module.
logger = logging.getLogger(__name__)


################################################################################
# `Registry` class.
################################################################################
class Registry(HasTraits):

    """
    This class is a registry for various engines, and metadata from
    sources, filters and modules
    """

    # The mayavi engines used.
    engines = Dict(Str, Instance('mayavi.core.engine.Engine'))

    # The metadata for the sources.
    sources = List(Metadata)

    # The metadata for the modules.
    modules = List(Metadata)

    # The metadata for the filters.
    filters = List(Metadata)

    ######################################################################
    # `Registry` interface.
    ######################################################################
    def register_engine(self, engine, name=''):

        """Registers a mayavi engine with an optional name.   Note that
        we allow registering an engine with the same name as another
        already registered.  """

        engines = self.engines
        if len(name) == 0:
            name = '%s%d'%(engine.__class__.__name__,
                           len(engines) + 1)

        logger.debug('Engine [%s] named %s registered', engine, name)
        engines[name] = engine

    def unregister_engine(self, engine_or_name):

        """Unregisters a mayavi engine specified either as a name or an
        engine instance."""

        engines = self.engines
        if isinstance(engine_or_name, str):
            name = engine_or_name
        else:
            for key, engine in engines.iteritems():
                if engine_or_name == engine:
                    name = key
                    break

        del engines[name]
        logger.debug('Engine named %s unregistered', name)

    def get_file_reader(self, filename):

        """Given a filename, find a suitable source metadata that will
        read the file.

        Returns a suitable source metadata object that will
        handle this.
        """
        base, ext = splitext(filename)
        result = []
        if len(ext) > 0:
            ext = ext[1:]
            result = [src for src in self.sources \
                      if ext in src.extensions]

        # 'result' contains list of all source metadata that can handle
        # the file.

        # If there is only single source metadata available to handle
        # the file, we simply return it.

        # If there is a conflict i.e. more then one source metadata objects
        # capable of handling the file then we check if they are capable of
        # actually reading it using 'can_read_function' which may be a class
        # method or a simple function which returns whether the object is
        # capable of reading the file or not.

        # Finally returns the most suitable source metadata object to the engine. If
        # multiple objects are still present we return the last one in the list.

        if len(result) > 1:
            for res in result[:]:
                if len(res.can_read_test) > 0:
                    can_read = import_symbol(res.can_read_test)(filename)
                    if can_read:
                        return res
                    else:
                        result.remove(res)

        if len(result) == 0:
            return None

        return result[-1]

    def find_scene_engine(self, scene):
        """ Find the engine corresponding to a given tvtk scene.
        """
        for engine in self.engines.values():
            for s in engine.scenes:
                if scene is s:
                    return engine
                sc = s.scene
                if scene is sc:
                    return engine
                elif hasattr(sc, 'scene_editor') and \
                     scene is sc.scene_editor:
                    # This check is needed for scene model objects.
                    return engine
        else:
            raise TypeError, "Scene not attached to a mayavi engine."



# The global registry instance.
registry = Registry()

# Import the metadata from the sources, modules and filters so they are
# all registered.
from mayavi.sources.metadata import sources
registry.sources.extend(sources)

from mayavi.filters.metadata import filters
registry.filters.extend(filters)

from mayavi.modules.metadata import modules
registry.modules.extend(modules)

# Do any customizations from either the `site_mayavi.py` or the
# `user_mayavi.py` files.  This is done by importing the customize.py
# module here which in turn imports the necessary code from the users's
# customization.
from mayavi.core import customize


########NEW FILE########
__FILENAME__ = scene
"""A scene object manages a TVTK scene and objects in it.
"""
# Author: Prabhu Ramachandran <prabhu_r@users.sf.net>
# Copyright (c) 2005,  Enthought, Inc.
# License: BSD Style.

# Enthought library imports.
from traits.api import List, Str, Instance
from traitsui.api import View, Group, Item
from apptools.persistence.state_pickler import set_state

# Local imports.
from tvtk.pyface.tvtk_scene import TVTKScene
from mayavi.core.base import Base
from mayavi.core.source import Source
from mayavi.core.common import handle_children_state, exception
from mayavi.core.adder_node import SourceAdderNode

######################################################################
# `Scene` class.
######################################################################
class Scene(Base):
    """ The Mayavi scene class.
    """

    # The version of this class.  Used for persistence.
    __version__ = 0

    # The scene (RenderWindow) associated with this component -- we
    # redeclare it here just to be able to record this scene, we don't
    # want it recorded on all objects since the scene is shared
    # (although it isn't an error to register an object twice with the
    # recorder).
    scene = Instance(TVTKScene, record=True)

    # The source objects associated with this object.
    children = List(Source, record=True)

    # The name of this scene.
    name = Str('TVTK Scene')

    # The icon
    icon = Str('scene.ico')

    # The human-readable type for this object
    type = Str(' scene')

    # The objects view.
    view = View(Group(Item(name='scene', style='custom'),
                           show_labels=False)
               )

    # The adder node dialog class
    _adder_node_class = SourceAdderNode

    # The dispatch, to register callbacks on mouse pick
    _mouse_pick_dispatcher = Instance(
        'mayavi.core.mouse_pick_dispatcher.MousePickDispatcher',
        record=False)

    ######################################################################
    # `object` interface
    ######################################################################
    def __get_pure_state__(self):
        # Base removes the scene, but we need to save it!
        d = super(Scene, self).__get_pure_state__()
        d['scene'] = self.scene
        d.pop('_mouse_pick_dispatcher', None)
        return d

    def __set_pure_state__(self, state):
        handle_children_state(self.children, state.children)
        # Now set our complete state.  Doing the scene last ensures
        # that the camera view is set right.
        set_state(self, state, last=['scene'])

    ######################################################################
    # `Scene` interface
    ######################################################################

    def on_mouse_pick(self, callback, type='point', button='Left',
                            remove=False):
        """ Add a picking callback on mouse click.

            When the mouse button is press, object picking is called, and
            the given callback is invoked with the resulting pick
            as an argument.

            **Keyword arguments**

            :type: 'point', 'cell', or 'world'
                The picker type used for picking.
            :button: 'Left', 'Middle', or 'Right'
                The mouse button triggering the picking event.
            :remove: boolean
                If remove is True, the callback is removed from the
                list of callbacks.

            **Returns**
            picker: a tvtk picker
                The picker that will be used to do the picking.

            **Notes**

            The callback must accept one argument: the TVTK picker.

            The same callback can be added multiple times.
        """
        key = (callback, type, button)
        if remove:
            self._mouse_pick_dispatcher.callbacks.remove(key)
        else:
            self._mouse_pick_dispatcher.callbacks.append(key)
        return self._mouse_pick_dispatcher._active_pickers[type]


    ######################################################################
    # `Base` interface
    ######################################################################
    def start(self):
        """This is invoked when this object is added to the mayavi
        pipeline.
        """
        # Do nothing if we are already running.
        if self.running:
            return

        # Start all our children.
        for obj in self.children:
            obj.start()

        # Disallow the hide action in the context menu
        self._HideShowAction.enabled = False

        super(Scene, self).start()

    def stop(self):
        """Invoked when this object is removed from the mayavi
        pipeline.
        """
        if not self.running:
            return

        # Disable rendering to accelerate shutting down.
        scene = self.scene
        if scene is not None:
            status = scene.disable_render
            scene.disable_render = True
        try:
            # Stop all our children.
            for obj in self.children:
                obj.stop()
        finally:
            # Re-enable rendering.
            if scene is not None:
                scene.disable_render = status

        super(Scene, self).stop()

    def add_child(self, child):
        """This method intelligently adds a child to this object in
        the MayaVi pipeline.
        """
        self.children.append(child)

    def remove_child(self, child):
        """Remove specified child from our children.
        """
        self.children.remove(child)

    def remove(self):
        """Remove ourselves from the mayavi pipeline.
        """
        if self.parent is not None:
            self.stop()
            self.parent.close_scene(self)

    ######################################################################
    # `TreeNodeObject` interface
    ######################################################################
    def tno_can_add(self, node, add_object):
        """ Returns whether a given object is droppable on the node.
        """
        try:
            if issubclass(add_object, Source):
                return True
        except TypeError:
            if isinstance(add_object, Source):
                return True
        return False

    def tno_drop_object(self, node, dropped_object):
        """ Returns a droppable version of a specified object.
        """
        if isinstance(dropped_object, Source):
            return dropped_object

    ######################################################################
    # Non-public interface
    ######################################################################
    def _children_changed(self, old, new):
        self._handle_children(old, new)

    def _children_items_changed(self, list_event):
        self._handle_children(list_event.removed, list_event.added)

    def _handle_children(self, removed, added):
        for obj in removed:
            obj.stop()
        for obj in added:
            obj.set(scene=self.scene, parent=self)
            if self.running:
                # It makes sense to start children only if we are running.
                # If not, the children will be started when we start.
                try:
                    obj.start()
                except:
                    exception()

    def _menu_helper_default(self):
        from mayavi.core.traits_menu import SourceMenuHelper
        return SourceMenuHelper(object=self)

    def __mouse_pick_dispatcher_default(self):
        from mayavi.core.mouse_pick_dispatcher import \
                        MousePickDispatcher
        return MousePickDispatcher(scene=self)

########NEW FILE########
__FILENAME__ = source
"""The base source object from which all MayaVi sources derive.

"""
# Author: Prabhu Ramachandran <prabhu_r@users.sf.net>
# Copyright (c) 2005-2008, Enthought, Inc.
# License: BSD Style.

# Enthought library imports.
from traits.api import List, Str
from apptools.persistence.state_pickler import set_state
from traitsui.menu import Action
from tvtk.api import write_data
from apptools.scripting.api import recordable

# Local imports
from mayavi.core.base import Base
from mayavi.core.pipeline_base import PipelineBase
from mayavi.core.module import Module
from mayavi.core.module_manager import ModuleManager
from mayavi.core.common import handle_children_state, \
                                         exception, error
from mayavi.core.pipeline_info import PipelineInfo
from mayavi.core.adder_node import ModuleFilterAdderNode

######################################################################
# Utility functions.
######################################################################
def is_filter(object):
    from mayavi.core.filter import Filter
    return isinstance(object, Filter)


######################################################################
# `Source` class.
######################################################################
class Source(PipelineBase):
    """ Base class for the sources objects in the pipeline.
    """

    # The version of this class.  Used for persistence.
    __version__ = 0

    # The children of this source in the tree view.  These objects all
    # get the output of this source.
    children = List(Base, record=True)

    # The icon
    icon = 'source.ico'

    # The human-readable type for this object
    type = Str(' data source')

    # Information about what this object can consume.
    input_info = PipelineInfo(datasets=['none'])

    # Information about what this object can produce.
    output_info = PipelineInfo(datasets=['any'])

    # The adder node dialog class
    _adder_node_class = ModuleFilterAdderNode

    ######################################################################
    # `object` interface
    ######################################################################
    def __set_pure_state__(self, state):
        # Do everything but our kids.
        set_state(self, state, ignore=['children'])
        # Setup children.
        handle_children_state(self.children, state.children)
        # Now setup the children.
        set_state(self, state, first=['children'], ignore=['*'])


    ######################################################################
    # `Source` interface
    ######################################################################
    def add_module(self, module):
        """ Adds a module smartly.  If no ModuleManager instances are
        children, it first creates a new ModuleManager and then adds
        the module to it.  If not it adds the module to the first
        available ModuleManager instance."""

        mm = None
        for child in self.children:
            if isinstance(child, ModuleManager):
                mm = child
        if mm is None:
            mm = ModuleManager(source=self, scene=self.scene)
            if self.running:
                mm.start()
            self.children.append(mm)
            if self.recorder is not None:
                index = len(self.children) - 1
                self.recorder.register(mm, parent=self,
                                       trait_name_on_parent='children[%d]'%index)
        mm.children.append(module)

    @recordable
    def save_output(self, fname):
        """Save our output (by default the first of our outputs) to the
        specified filename as a VTK file.  Both old style and new style
        XML files are supported.
        """
        if len(self.outputs) > 0:
            write_data(self.outputs[0], fname)
        else:
            error('Object has no outputs to save!')

    ######################################################################
    # `Base` interface
    ######################################################################
    def start(self):
        """This is invoked when this object is added to the mayavi
        pipeline.
        """
        # Do nothing if we are already running.
        if self.running:
            return

        # Start all our children.
        for obj in self.children:
            try:
                obj.start()
            except:
                exception()

        # Call parent method to set the running state.
        super(Source, self).start()

    def stop(self):
        """Invoked when this object is removed from the mayavi
        pipeline.
        """
        if not self.running:
            return

        # Stop all our children.
        for obj in self.children:
            obj.stop()

        # Call parent method to set the running state.
        super(Source, self).stop()

    def add_child(self, child):
        """This method intelligently adds a child to this object in
        the MayaVi pipeline.
        """
        if is_filter(child):
            # It is a Filter, so append to children.
            self.children.append(child)
        elif isinstance(child, Source):
            # A non-filter source object.  This should be added to the
            # scene.
            self.parent.add_child(child)
        elif isinstance(child, Module):
            # Modules should be added carefully via add_module.
            self.add_module(child)
        elif isinstance(child, ModuleManager):
            self.children.append(child)
        else:
            self.children.append(child)

    def remove_child(self, child):
        """Remove specified child from our children.
        """
        self.children.remove(child)

    ######################################################################
    # `TreeNodeObject` interface
    ######################################################################
    def tno_can_add(self, node, add_object):
        """ Returns whether a given object is droppable on the node.
        """
        from mayavi.core.filter import Filter
        try:
            if issubclass(add_object, Filter) or \
                   issubclass(add_object, ModuleManager):
                return True
        except TypeError:
            if isinstance(add_object, Filter) or \
                   isinstance(add_object, ModuleManager):
                return True
        return False

    def tno_drop_object(self, node, dropped_object):
        """ Returns a droppable version of a specified object.
        """
        if is_filter(dropped_object) or \
               isinstance(dropped_object, ModuleManager):
            return dropped_object


    ######################################################################
    # Non-public interface
    ######################################################################
    def _children_changed(self, old, new):
        self._handle_children(old, new)

    def _children_items_changed(self, list_event):
        self._handle_children(list_event.removed, list_event.added)

    def _handle_children(self, removed, added):
        # Stop all the removed children.
        for obj in removed:
            obj.stop()

        # Process the new objects.
        for obj in added:
            obj.set(scene=self.scene, parent=self)
            if isinstance(obj, ModuleManager):
                obj.source = self
            elif is_filter(obj):
                obj.inputs.append(self)
            if self.running:
                try:
                    obj.start()
                except:
                    exception()

    def _scene_changed(self, old, new):
        super(Source, self)._scene_changed(old, new)
        for obj in self.children:
            obj.scene = new

    def _visible_changed(self,value):
        for c in self.children:
            c.visible = value

        super(Source,self)._visible_changed(value)

    def _menu_helper_default(self):
        from mayavi.core.traits_menu import FilterMenuHelper
        return FilterMenuHelper(object=self)

    def _extra_menu_items(self):
        """Return a save output menu action."""
        save_output = Action(name='Save output to file',
                             action='object._save_output_action',
                             enabled_when='len(object.outputs) > 0')
        return [save_output]

    def _save_output_action(self):
        """Pops up a dialog box for the action to ask for a file."""
        # FIXME: in a refactor this should all go in a separate view
        # related object.
        from pyface.api import FileDialog, OK
        wildcard = 'All files (*.*)|*.*|'\
                   'VTK XML files (*.xml)|*.xml|'\
                   'Image Data (*.vti)|*.vti|'\
                   'Poly Data (*.vtp)|*.vtp|'\
                   'Rectilinear Grid (*.vtr)|*.vtr|'\
                   'Structured Grid (*.vts)|*.vts|'\
                   'Unstructured Grid (*.vtu)|*.vtu|'\
                   'Old-style VTK files (*.vtk)|*.vtk'

        dialog = FileDialog(title='Save output to file',
                            action='save as', wildcard=wildcard
                            )
        if dialog.open() == OK:
            self.save_output(dialog.path)

########NEW FILE########
__FILENAME__ = traits_menu
"""
 Code related to traits UI menu items for the tree view of mayavi.
"""
# Author: Prabhu Ramachandran <prabhu@aero.iitb.ac.in>
# Copyright (c) 2008, Prabhu Ramachandran Enthought, Inc.
# License: BSD Style.

# Standard library imports.
from os.path import splitext, isfile

# Enthought library imports.
from traits.api import HasTraits, Any, List
from traitsui.menu import Action, Menu
from pyface.api import FileDialog, OK, GUI

# Local imports.
from mayavi.core.registry import registry
from mayavi.core.common import error, get_engine


################################################################################
# `MenuHelper` class.
################################################################################
class MenuHelper(HasTraits):

    # The object this menu generates the menus for.
    object = Any

    # The actions this helper generates.
    actions = List()

    ######################################################################
    # Public interface.
    ######################################################################
    def check_active(self, metadata):
        """Check if the `metadata` passed can be added to `self.object`.
        """
        # FIXME: This should also have logic for checking the attributes
        # and attribute_types.
        output_info = self.object.output_info
        input_info = metadata.input_info
        if output_info is None:
            return True
        elif input_info is None:
            return True
        output_datasets = output_info.datasets
        input_datasets = input_info.datasets
        if 'none' in output_datasets:
            return False
        if 'any' in input_datasets:
            return True
        for d in input_datasets:
            if d in output_datasets:
                return True
        return False

    def open_file_action(self):
        wildcard = 'All files (*.*)|*.*'
        for src in registry.sources:
            if len(src.extensions) > 0:
                if wildcard.endswith('|') or \
                   src.wildcard.startswith('|'):
                       wildcard += src.wildcard
                else:
                    wildcard += '|' + src.wildcard

        dialog = FileDialog(parent=None,
                            title='Open supported data file',
                            action='open', wildcard=wildcard
                            )
        if dialog.open() == OK:
            if not isfile(dialog.path):
                error("File '%s' does not exist!"%dialog.path)
                return
            # FIXME: Ask for user input if a filetype is unknown and
            # choose appropriate reader.
            object = self.object
            engine = get_engine(object)
            engine.open(dialog.path, object)

    ######################################################################
    # Non-public interface.
    ######################################################################
    def _create_source(self, metadata, select=True):
        """Create source object given its metadata.  If `select` is
        `True` make the created object the active selection.
        """
        callable = metadata.get_callable()
        obj = callable()
        parent = self.object
        engine = get_engine(parent)
        engine.add_source(obj, parent)
        if select:
            self._make_active(obj)

    def _create_object(self, metadata, select=True):
        """Create mayavi pipeline object given its metadata.  If
        `select` is `True` make the created object the active selection.
        """
        callable = metadata.get_callable()
        obj = callable()
        parent = self.object
        engine = get_engine(parent)
        engine.add_filter(obj, parent)
        if select:
            self._make_active(obj)

    def _make_active(self, obj):
        """Make the object given, `obj`, the current selection of the
        engine."""
        engine = get_engine(obj)
        if engine is not None:
            # This is required when running mayavi in envisage.
            GUI.set_trait_later(engine, 'current_selection', obj)
        else:
            print "No engine"

    def _build_source_actions(self):
        actions = []
        a = Action(name='Open File ...',
                   action='object.menu_helper.open_file_action',
                   tooltip='Open a supported data file')
        actions.append(a)

        for src in registry.sources:
            if len(src.extensions) == 0:
                # The method that creates the source.
                setattr(self, src.id,
                        lambda self=self, md=src, select=True:
                        self._create_source(md, select))
                a = Action(name=src.menu_name,
                           action='object.menu_helper.'+src.id,
                           tooltip=src.tooltip)
                actions.append(a)
        return actions

    def _build_filter_actions(self):
        actions = []
        for fil in registry.filters:
            # The method that creates the object.
            setattr(self, fil.id,
                    lambda self=self, md=fil, select=True:
                    self._create_object(md, select))
            # The method that checks if the menu can be activated or
            # not.
            setattr(self, 'check_' + fil.id,
                    lambda self=self, md=fil: self.check_active(md))
            a = Action(name=fil.menu_name,
                       action='object.menu_helper.' + fil.id,
                       enabled_when='object.menu_helper.check_%s()'%fil.id,
                       tooltip=fil.tooltip)
            actions.append(a)
        return actions

    def _build_module_actions(self):
        actions = []
        for mod in registry.modules:
            # The method that creates the module.
            setattr(self, mod.id,
                    lambda self=self, md=mod, select=True:
                    self._create_object(md, select))
            # The method that checks if the menu can be activated or
            # not.
            setattr(self, 'check_' + mod.id,
                    lambda self=self, md=mod: self.check_active(md))
            a = Action(name=mod.menu_name,
                       action='object.menu_helper.' + mod.id,
                       enabled_when='object.menu_helper.check_%s()'%mod.id,
                       tooltip=mod.tooltip)
            actions.append(a)
        return actions


################################################################################
# `SourceMenuHelper` class.
################################################################################
class SourceMenuHelper(MenuHelper):

    def _actions_default(self):
        actions = self._build_source_actions()
        return [Menu(name='Add Source', *actions)]


################################################################################
# `FilterMenuHelper` class.
################################################################################
class FilterMenuHelper(MenuHelper):

    def _actions_default(self):
        filter_actions = self._build_filter_actions()
        module_actions = self._build_module_actions()
        return [Menu(name='Add Filter', *filter_actions),
                Menu(name='Add Module', *module_actions)]

################################################################################
# `ModuleMenuHelper` class.
################################################################################
class ModuleMenuHelper(MenuHelper):

    def _actions_default(self):
        module_actions = self._build_module_actions()
        return [Menu(name='Add Module', *module_actions)]

########NEW FILE########
__FILENAME__ = trait_defs
#---------------------------------------------------------------------------
#
#  DEnum: is a 'dynamic enum' trait whose values are obtained from
#  another trait on the object.
#
#  Caveat:
#   The problem with this trait is that the listeners (for changes to
#   the valid values) are added only when the attribute is read or
#   set.  Thus if the acceptable list of values are changed before the
#   listeners are activated then the value will be set correctly only
#   when it is accessed and not when the values are set.
#
#  Written by: David C. Morrill and Prabhu Ramachandran
#
#  (c) Copyright 2006-2008 by Enthought, Inc.
#
#---------------------------------------------------------------------------

from traits.api import Property, TraitFactory, TraitError, TraitType, Int
from traitsui.api import EnumEditor
from traits.traits import trait_cast


#---------------------------------------------------------------------------
#  Utility functions:
#---------------------------------------------------------------------------

def super_getattr(object, name, *args):
    """Works the same way as getattr, except that name can be of the
    form 'a.b.c' (as many levels as you like).  For example:

    >>> class A:
    ... pass
    ...
    >>> a = A()
    >>> a.b = A()
    >>> a.b.c = 1
    >>> super_getattr(a, 'b.c')
    1
    >>> super_getattr(a.b, 'c')
    1
    """
    if '.' in name:
        attrs = name.split('.')
        last = attrs.pop()
        obj = object
        for attr in attrs:
            obj = getattr(obj, attr)
        return getattr(obj, last, *args)
    else:
        return getattr(object, name, *args)

def super_setattr(object, name, value):
    """Works the same way as setattr, except that name can be of the
    form 'a.b.c' (as many levels as you like).  For example:

    >>> class A:
    ... pass
    ...
    >>> a = A()
    >>> a.b = A()
    >>> super_setattr(a, 'b.c', 1)
    >>> a.b.c
    1
    """
    if '.' in name:
        attrs = name.split('.')
        last = attrs.pop()
        obj = object
        for attr in attrs:
            obj = getattr(obj, attr)
        setattr(obj, last, value)
    else:
        setattr(object, name, value)


#--------------------------------------------------------------------------------
# Helper class for DEnum trait.
#--------------------------------------------------------------------------------
class DEnumHelper(object):
    """Defines a bunch of staticmethods that collect all the helper
    functions needed for the DEnum trait.
    """

    ######################################################################
    # Get/Set functions for the property.
    def get_value ( object, name ):
        return super_getattr(object, DEnumHelper._init_listeners(object, name))
    get_value = staticmethod(get_value)

    def set_value ( object, name, value ):
        _name = DEnumHelper._init_listeners( object, name )
        trait = object.trait( name )
        values = super_getattr(object, trait.values_name)
        if value not in values:
            raise TraitError, (object, name,
                               "one of %s"%values,
                               value )
        old = super_getattr(object, _name)
        super_setattr( object, _name, value )
        object.trait_property_changed(name, old, value)
    set_value = staticmethod(set_value)

    ######################################################################
    #  Makes a default EnumEditor for the trait:
    def make_editor ( trait = None ):
        return EnumEditor( name=trait.values_name )
    make_editor = staticmethod(make_editor)

    ######################################################################
    # Ensures that the listeners are initialized.
    def _init_listeners ( object, name ):
        _name = '_' + name
        if not hasattr( object, _name ):
            trait = object.trait( name )
            DEnumHelper._add_listeners( object, name, trait.values_name)
            default = trait.default or ''
            values = super_getattr( object, trait.values_name )
            if values:
                if default is None or default not in values:
                    default = values[0]
            super_setattr( object, _name, default )

        return _name
    _init_listeners = staticmethod(_init_listeners)

    def _add_listeners ( object, name, values_name ):
        def check_values(object, values_name, old, new):
            cur_choice = super_getattr(object, name)
            if cur_choice not in new:
                if new:
                    super_setattr(object, name, new[0])
                else:
                    super_setattr(object, name, '')

        def check_values_items(object, values_name, list_event):
            cur_choice = super_getattr(object, name)
            values = super_getattr(object, values_name[:-6])
            if cur_choice not in values:
                if values:
                    super_setattr(object, name, values[0])
                else:
                    super_setattr(object, name, '')

        object.on_trait_change( check_values,  values_name )
        object.on_trait_change( check_values_items, values_name + '_items' )
    _add_listeners = staticmethod(_add_listeners)


#-------------------------------------------------------------------------------
#  Defines the DEnum property:
#-------------------------------------------------------------------------------
DEnum = Property(DEnumHelper.get_value, DEnumHelper.set_value,
                 values_name = 'values',
                 editor  = (DEnumHelper.make_editor, {'trait': None})
                 )

DEnum = TraitFactory(DEnum)


##########################################################################
# `ShadowProperty` trait type.
##########################################################################
class ShadowProperty(TraitType):

    # Not really necessary but specifies the attribute up front.
    trait_type = None

    # Call the notifiers smartly only when the value has really changed.
    # If this is set to False, the notification will always occur.
    smart_notify = True

    def __init__(self, trait_type, smart_notify=True, **metadata):
        """Defines a shadow property trait that is best explained by
        example::

            class Thing(HasTraits):
                x = ShadowProperty(Float, smart_notify=False)
                def _x_changed(self, value):
                    print value

        In this example, the actual value of the property (`x`) will be
        stored in `_x` and `_x_changed` will be called regardless
        whether the value actually changed or not.  If `smart_notify` is
        set to `True` then the handler is called only if the value has
        actually changed.

        Note that the validation uses the validation of the specified
        `trait_type` parameter.
        """
        self.trait_type = trait_cast(trait_type)
        self.smart_notify = smart_notify
        super(ShadowProperty, self).__init__(**metadata)

    def validate(self, object, name, value):
        """Validates that a specified value is valid for this trait.
        """
        trt = self.trait_type
        if trt is not None and hasattr(trt, 'validate'):
            value = trt.validate(object, name, value)
        return value

    def get(self, object, name):
        """Get the value of the trait."""
        shadow = self._get_shadow(name)
        d = object.__dict__
        if shadow in d:
            return d[shadow]
        else:
            return None

    def set(self, object, name, value):
        """Set the value of the trait."""
        old = self.get(object, name)
        shadow = self._get_shadow(name)
        object.__dict__[shadow] = value
        # Fire a trait property changed.
        fire = True
        if self.smart_notify:
            if old is value:
                fire = False
        if fire and self._check_notification(object):
            object.trait_property_changed(name, old, value)

    def _get_shadow(self, name):
        """Get the shadow attribute name to use."""
        return '_' + name

    def _check_notification(self, object):
        """Checks to see if notifications are allowed or not i.e. has
        the trait been set via:
         object.set(name=value, trait_change_notify=False)
        """
        if hasattr(object, '_get_trait_change_notify'):
            return object._get_trait_change_notify()
        else:
            # Traits won't tell us so we find out by adding a dynamic
            # trait, changing it and then seeing if the callback was
            # called, sigh!
            attr = '_testing_Notification_handlers_tmp_dont_touch'

            def callback(value):
                callback.value = value
            callback.value = -1
            object.add_trait(attr, Int)
            object.on_trait_change(callback, attr)
            setattr(object, attr, 1)
            status = False
            if callback.value == 1:
                status = True
            object.on_trait_change(callback, attr, remove=True)
            object.remove_trait(attr)
            return status


########NEW FILE########
__FILENAME__ = api
from mayavi.tools.mlab_scene_model import MlabSceneModel
from mayavi.core.ui.mayavi_scene import MayaviScene, \
                    DecoratedScene
from tvtk.pyface.scene_editor import SceneEditor
from mayavi.core.ui.engine_view import EngineView
from mayavi.core.ui.engine_rich_view import EngineRichView


########NEW FILE########
__FILENAME__ = engine_rich_view
"""A view of the pipeline with a panel to edit objects.

"""
# Author: Gael Varoquaux <gael dot varoquaux at normalesup dot org>
# Copyright (c) 2009, Enthought, Inc.
# License: BSD Style.

# Enthought library imports.
from traitsui.api import Item, View, HSplit, InstanceEditor
from traitsui.menu import Action, Separator
from pyface.image_resource import ImageResource
from pyface.api import GUI
from mayavi.core.adder_node import SceneAdderNode

# Local imports.
from mayavi.core.scene import Scene
from mayavi.preferences.preference_manager_view import \
    preference_manager_view
from mayavi.core.ui.engine_view import EngineView, \
            EngineViewHandler


class EngineRichViewHandler(EngineViewHandler):
    """ A handler for the EngineRichView object.
    """

    def init_info(self, info):
        """ Informs the handler what the UIInfo object for a View will be.
        Overridden here to add a callback on the creation of the view.

        """
        super(EngineRichViewHandler, self).init_info(info)
        info.on_trait_change(self.select_selected, 'initialized')
        return


    def select_selected(self, initialized):
        """ Force the tree editor to select the current engine selection,
            and eventually collapse other scenes.
        """
        # We need to explore the editors to find the one we are
        # interested in, and to switch its selection to None, and then
        # back to what we are interested in.
        editors = self.info.ui._editors
        if editors is not None:
            for editor in editors:
                if editor.factory is self.info.object.tree_editor:
                    tree_editor = editor
                    break
            else:
                return
        else:
            return

        # We switch the selection to None, but we avoid
        # trait callback, to avoid changing the engine's
        # current_selection.
        tree_editor.set(selected=None, trait_change_notify=False)
        current_selection = self.info.object.engine.current_selection
        GUI.set_trait_later(tree_editor, 'selected', current_selection)

        # If we are selecting a scene, collapse the others
        if isinstance(current_selection, Scene) and \
                                    hasattr(tree_editor._tree, 'Collapse'):
            # The wx editor can collapse, dunno for the Qt
            for scene in self.info.object.engine.scenes:
                if scene is not current_selection:
                    tree_editor._tree.Collapse(
                                            tree_editor._get_object_nid(scene))


    def _on_dclick(self, object):
        """ Called when a node in the tree editor is double-clicked.
        """
        if isinstance(object, SceneAdderNode):
            self.info.object._perform_new_scene()
        else:
            # In this view, we want the dialogs not to be modals, so that
            # the EngineRichView window can be closed while leaving
            # objects dialogs open.
            object.edit_traits(view=object.dialog_view())


##############################################################################
# EngineRichView class.
##############################################################################
class EngineRichView(EngineView):
    """ A view displaying the engine's object tree, alongside with a
        panel to edit the objects.
    """

    ###########################################################################
    # `HasTraits` interface.
    ###########################################################################
    def default_traits_view(self):
        """The default traits view of the Engine View.
        """
        view = View(HSplit(
                        Item('engine',
                            id='mayavi.engine_rich_view.pipeline_view',
                            springy=True,
                            resizable=True,
                            editor=self.tree_editor,
                            dock='tab',
                            label='Pipeline'),
                        Item('engine',
                            id='mayavi.engine_rich_view.current_selection',
                            editor=InstanceEditor(
                                        view='current_selection_view'),
                            springy=True,
                            resizable=True,
                            style='custom'),
                    show_labels=False,
                    id='mayavi.engine_rich_view_group',
                    ),
                    id='mayavi.engine_rich_view',
                    help=False,
                    resizable=True,
                    undo=False,
                    revert=False,
                    ok=False,
                    cancel=False,
                    title='Mayavi pipeline',
                    icon=self.icon,
                    toolbar=self.toolbar,
                    handler=EngineRichViewHandler)
        return view


    def _actions_default(self):
        """ Append a preferences action to the toolbar: this view of the
            engine is meant to be a powerful view giving access to
            all of Mayavi's functionality.
        """
        preferences_action = \
            Action(
                image=ImageResource('preferences.png',
                                     search_path=self._image_path),
                tooltip="Modify Mayavi's preferences",
                checked=False,
                defined_when='True',
                perform=preference_manager_view.dialog_view,
            )

        actions = super(EngineRichView, self)._actions_default()
        actions.extend((Separator(), preferences_action))
        return actions

    ###########################################################################
    # EngineRichView interface.
    ###########################################################################

    def scene_editing_view(self, scene):
        # Selecting an object if good, because it forces the HSplit to
        # choose a sensible split ratio
        for mayavi_scene in self.engine.scenes:
            sc = mayavi_scene.scene
            # Support for the `MlabSceneModel` where the `scene_editor`
            # trait contains the scene.
            s = getattr(sc, 'scene_editor', sc)
            if s is scene:
                self.engine.current_selection = mayavi_scene

        return self.edit_traits()


### EOF ######################################################################

########NEW FILE########
__FILENAME__ = engine_view
"""The MayaVi view in Envisage.

"""
# Author: Prabhu Ramachandran <prabhu_r@users.sf.net>
# Copyright (c) 2005-2009, Enthought, Inc.
# License: BSD Style.

# Standard library imports.
from os.path import join

# Enthought library imports.
from traits.api import Instance, HasTraits, Any, Delegate, \
        List, Either
from traitsui.api import (Item, TreeEditor, TreeNode,
        ObjectTreeNode, View, Handler, UIInfo)
from traitsui.menu import ToolBar, Action, Separator
from pyface.resource.resource_path import resource_path
from pyface.image_resource import ImageResource
from apptools.scripting.api import start_recording, stop_recording

# Local imports.
from mayavi.core.engine import Engine
from mayavi.core.base import Base
from mayavi.core.adder_node import ModuleFilterAdderNode, \
        SourceAdderNode, ModuleAdderNode, FilterAdderNode, \
        SceneAdderNode, AdderNode
from mayavi.action.help import open_help_index, open_tvtk_docs

class EngineViewHandler(Handler):
    """ A handler for the EngineView object.
    """

    info = Instance(UIInfo)

    def init_info(self, info):
        """ Informs the handler what the UIInfo object for a View will be.
        Overridden here to save a reference to the info object.
        """
        self.info = info
        return


    def _on_dclick(self, object):
        """ Called when a node in the tree editor is double-clicked.
        """
        if isinstance(object, SceneAdderNode):
            self.info.object._perform_new_scene()
        else:
            object.edit_traits(view=object.dialog_view(),
                               parent=self.info.ui.control)

    def _on_select(self, object):
        """ Called when a node in the tree editor is selected.
        """
        self.info.object.engine._on_select(object)


class AdderTreeNode(TreeNode):
    """ TreeNode for the adder nodes.
    """

    children=''
    label='label'
    auto_open=True
    copy=False
    delete_me=False
    rename_me=False
    tooltip='tooltip'
    icon_path=resource_path()
    icon_item='add.ico'


##############################################################################
# EngineView class.
##############################################################################
class EngineView(HasTraits):
    """ A view displaying the engine's object tree. """

    # The MayaVi engine we are a view of.
    engine = Instance(Engine, allow_none=True)

    # Path used to search for images
    _image_path = [join(resource_path(), 'images'), ]

    # The icon of the dialog
    icon = ImageResource('mv2.ico', search_path=_image_path)

    # Nodes on the tree.
    nodes = Any

    # TreeEditor
    tree_editor = Instance(TreeEditor)

    # Toolbar
    toolbar = Instance(ToolBar)

    # Toolbar actions.
    actions = List(Either(Action, Separator))

    # Some delegates, for the toolbar to update
    scenes = Delegate('engine')
    current_selection = Delegate('engine')

    ###########################################################################
    # `object` interface.
    ###########################################################################
    def __init__(self, **traits):
        super(EngineView, self).__init__(**traits)


    ###########################################################################
    # `HasTraits` interface.
    ###########################################################################
    def default_traits_view(self):
        """The default traits view of the Engine View.
        """

        view = View(Item(name='engine',
                               id='engine',
                               editor=self.tree_editor,
                               resizable=True,
                               show_label=False),
                    id='mayavi.engine',
                    help=False,
                    resizable=True,
                    scrollable=True,
                    undo=False,
                    revert=False,
                    ok=False,
                    cancel=False,
                    icon=self.icon,
                    title = 'Mayavi pipeline',
                    toolbar=self.toolbar,
                    handler=EngineViewHandler)
        return view


    def _nodes_default(self):
        """ The default value of the cached nodes list.
        """
        # Now setup the view.
        nodes = [TreeNode(node_for=[Engine],
                          children='children_ui_list',
                          label='=Mayavi',
                          auto_open=False,
                          copy=False,
                          delete=False,
                          rename=True,
                          ),
                 ObjectTreeNode(node_for=[Base],
                                children='children_ui_list',
                                label='name',
                                auto_open=True,
                                copy=True,
                                delete=True,
                                rename=True,
                                tooltip='=Right click for more options',
                                ),
                 AdderTreeNode(node_for=[SceneAdderNode],
                               icon_item='add_scene.png',
                               ),
                 AdderTreeNode(node_for=[SourceAdderNode],
                               icon_item='add_source.png',
                               ),
                 AdderTreeNode(node_for=[ModuleFilterAdderNode],
                               icon_item='add_module.png',
                               ),
                 ]
        return nodes


    def _tree_editor_default(self):
        return TreeEditor(editable=False,
                                 hide_root=True,
                                 on_dclick='handler._on_dclick',
                                 on_select='handler._on_select',
                                 orientation='vertical',
                                 selected='object.engine.current_selection',
                                 nodes=self.nodes
                        )

    def _toolbar_default(self):
        toolbar = ToolBar(*self.actions)
        toolbar.image_size = (16, 16)
        toolbar.show_tool_names = False
        toolbar.show_divider = False
        return toolbar

    def _actions_default(self):
        add_scene = \
            Action(
                image=ImageResource('add_scene.png',
                                            search_path=self._image_path),
                tooltip="Create a new scene",
                defined_when='True',
                enabled_when='True',
                perform=self._perform_new_scene,
            )

        add_source = \
            Action(
                image=ImageResource('add_source.png',
                                            search_path=self._image_path),
                tooltip="Add a data source",
                defined_when='True',
                enabled_when='len(scenes) > 0',
                perform=self._perform_add_source,
            )

        add_module = \
            Action(
                image=ImageResource('add_module.png',
                                            search_path=self._image_path),
                tooltip="Add a visualization module",
                defined_when='True',
                # isinstance doesn't work in enabled_when
                enabled_when=\
                    'current_selection is not None and'
                    '( hasattr(current_selection, "output_info")'
                    'or current_selection.__class__.__name__ =='
                    '"ModuleFilterAdderNode")',
                perform=self._perform_add_module,
            )

        add_filter = \
            Action(
                image=ImageResource('add_filter.png',
                                            search_path=self._image_path),
                tooltip="Add a processing filter",
                defined_when='True',
                enabled_when=\
                    'current_selection is not None and'
                    '( ( hasattr(current_selection, "output_info")'
                    ' and not current_selection.type in (" module", '
                    ' " module manager"))'
                    'or current_selection.__class__.__name__ =='
                    '"ModuleFilterAdderNode")',
                perform=self._perform_add_filter,
             )

        help = \
            Action(
                image=ImageResource('help-action.png',
                                            search_path=self._image_path),
                tooltip="Help on the Mayavi pipeline",
                defined_when='True',
                enabled_when='True',
                perform=open_help_index,
            )

        tvtk_docs = \
            Action(
                image=ImageResource('reader.png',
                                            search_path=self._image_path),
                tooltip="Search the VTK class browser",
                defined_when='True',
                enabled_when='True',
                perform=open_tvtk_docs,
            )

        record = \
            Action(
                image=ImageResource('record.png',
                                     search_path=self._image_path),
                tooltip="Start/Stop script recording",
                style='toggle',
                checked=False,
                defined_when='True',
                enabled_when='engine is not None',
                perform=self._perform_record,
            )

        # Check the record icon if the engine already has a recorder
        # set.
        if self.engine is not None and self.engine.recorder is not None:
            record.checked = True

        return [tvtk_docs, Separator(), add_scene, add_source, add_module,
                add_filter, Separator(), help, record]


    ###########################################################################
    # Private interface.
    ###########################################################################
    def _perform_new_scene(self):
        self.engine.new_scene()
        self.engine.current_selection = self.engine.current_scene

    def _perform_add_source(self):
        adder = SourceAdderNode(object=self.engine.current_scene)
        adder.edit_traits(view=adder.dialog_view())


    def _perform_add_module(self):
        object = self.engine.current_selection
        if isinstance(object, AdderNode):
            object = object.object
        adder = ModuleAdderNode(object=object)
        adder.edit_traits(view=adder.dialog_view())

    def _perform_add_filter(self):
        object = self.engine.current_selection
        if isinstance(object, AdderNode):
            object = object.object
        adder = FilterAdderNode(object=object)
        adder.edit_traits(view=adder.dialog_view())

    def _perform_record(self):
        e = self.engine
        if e.recorder is None:
            start_recording(e, known=True, script_id='engine')
        else:
            stop_recording(e, save=False)

    def _recorder_changed_for_engine(self, recorder):
        """Called when the recorder trait on the engine trait of this
        object changes.

        This basically toggles the recording action when someone
        attaches a recorder to the engine.
        """
        record_action = None
        for action in self.actions:
            if hasattr(action, 'tooltip') and \
               action.tooltip.endswith('recording'):
                record_action = action
                break

        if record_action is not None:
            if recorder is not None:
                record_action.checked = True
            else:
                record_action.checked = False


### EOF ######################################################################

########NEW FILE########
__FILENAME__ = lut_manager
"""
Traits View definition file.

The view trait of the parent class is extracted from the model definition
file.  This file can either be exec()ed or imported.  See
core/base.py:Base.trait_view() for what is currently used.  Using exec()
allows view changes without needing to restart Mayavi, but is slower than
importing.
"""
# Authors: Prabhu Ramachandran <prabhu_r@users.sf.net>
#          Judah De Paula <judah@enthought.com>
# Copyright (c) 2005-2008, Enthought, Inc.
# License: BSD Style.

from traitsui.api \
    import Item, Group, View, ImageEnumEditor, InstanceEditor, HGroup
from mayavi.core.lut_manager import lut_mode_list, \
            lut_image_dir


# The view of the LUT Manager object.
view = View(Group(Item(name='lut_mode',
                       editor=ImageEnumEditor(values=lut_mode_list(),
                                              cols=6,
                                              path=lut_image_dir)),
                  Item(name='file_name', visible_when="lut_mode=='file'"),
                  Item(name='number_of_colors'),
                  Item(name='reverse_lut'),
                  Item(name='lut',
                       show_label=False,
                       editor=InstanceEditor(label='Edit LUT properties',
                                             id='mayavi.core.lut_manager.edit_lut')),
                  Item(name='scalar_bar_representation',
                       show_label=False,
                       visible_when='scalar_bar_representation is not None',
                       editor=InstanceEditor(label='Edit Legend representation',
                                             id='mayavi.core.lut_manager.edit_represetation')),
                  Item(name='create_lut', show_label=False),

                  Group(Item(name='show_legend'),
                      Group(
                          Item(name='number_of_labels'),
                          enabled_when='show_scalar_bar==True',
                      ),
                      Group(
                          Item(name='shadow'),
                          Item(name='use_default_name'),
                          Item(name='data_name',
                               enabled_when='not object.use_default_name'),
                          HGroup(
                              Item(name='_title_text_property',
                                   show_label=False,
                                   editor=InstanceEditor(label='Edit bar Title',
                                        id='mayavi.core.lut_manager.bar_title_text')),
                              Item(name='_label_text_property',
                                   show_label=False,
                                   editor=InstanceEditor(label='Edit bar Text',
                                        id='mayavi.core.lut_manager.bar_label_text'),
                                   label='Edit bar Text'),
                          ),
                          HGroup(
                              Item(name='scalar_bar',
                                   show_label=False,
                                   editor=InstanceEditor(label='Edit bar Actor',
                                       id='mayavi.core.lut_manager.bar_actor'),
                                   ),
                              Item(name='scalar_bar_widget',
                                   show_label=False,
                                   editor=InstanceEditor(label='Edit bar Widget',
                                        id='mayavi.core.lut_manager.bar_widget'),
                                  ),
                          ),
                          enabled_when='show_scalar_bar==True',
                      ),
                      show_border=True,
                  ),
                  Group(
                      Item(name='use_default_range'),
                      Item(name='data_range',
                          enabled_when='not object.use_default_range'),
                      show_border=True,
                  ),
                  label='LUT (Look Up Table) Manager',
             ),

# Delete this once we're sure we want to keep the new integrated format.
#            Group(Item(name='_title_text_property',
#                       style='custom',
#                       resizable=True),
#                  show_labels=False,
#                  defined_when='show_scalar_bar==True',
#                  label='Title'),
#            Group(Item(name='_label_text_property',
#                       style='custom',
#                       resizable=True),
#                  enabled_when='show_scalar_bar==True',
#                  show_labels=False,
#                  label='Labels'),

            resizable=True,
        )

########NEW FILE########
__FILENAME__ = mayavi_scene
""" A viewer for mlab scene. Adds a button to open up the engine.
"""

# Author: Gael Varoquaux <gael dot varoquaux at normalesup dot org>
# Copyright (c) 2008, Enthought, Inc.
# License: BSD Style.

# Standard library imports
from os.path import join

# Enthought library imports
from tvtk.tools.ivtk import IVTK
from tvtk.pyface.api import DecoratedScene
from traits.api import Callable
from pyface.api import ImageResource
from pyface.action.api import Action, Group
from pyface.resource.api import resource_path

# Local imports
from mayavi.core.common import error
from mayavi.preferences.api import set_scene_preferences, \
        get_scene_preferences

###############################################################################
# A decorated scene with an additional button.
###############################################################################
class MayaviScene(DecoratedScene):
    """ A scene UI, similar to a decorated scene, but with more buttons.
    """

    image_search_path = [join(resource_path(), 'images'), ]

    ##########################################################################
    # Non-public interface.
    ##########################################################################
    def show_engine(self):
        """ Open the engine view corresponding to the engine of the
            scene.
        """
        from mayavi.core.registry import registry
        from mayavi.core.ui.engine_rich_view import EngineRichView
        try:
            engine = registry.find_scene_engine(self)
        except TypeError:
            error('This scene is not managed by Mayavi')
        return EngineRichView(engine=engine).scene_editing_view(scene=self)

    ######################################################################
    # Trait handlers.
    ######################################################################
    def _actions_default(self):
        actions = [ Group(
                    Action(tooltip="View the Mayavi pipeline",
                        image=ImageResource('m2',
                                search_path=self.image_search_path),
                        on_perform=self.show_engine,
                        ),
                        ),
                        ]
        actions.extend(DecoratedScene._actions_default(self))
        return actions


def mayavi_scene_factory(parent):
    """A mayavi scene factory that creates a scene with preferences
    appropriately set."""
    p = get_scene_preferences()
    s = MayaviScene(parent, stereo=p['stereo'])
    set_scene_preferences(s, p)
    return s

###############################################################################
# A viewer making use of the MayaviScene
###############################################################################
class MayaviViewer(IVTK):
    """ A viewer window for mlab.
    """

    _scene_factory = Callable(mayavi_scene_factory)

    def _size_default(self):
        return (400, 300)


def viewer_factory(size=(400, 350)):
    viewer = MayaviViewer()
    viewer.menu_bar_manager = None
    viewer.size=size
    viewer.open()
    return viewer

if __name__ == '__main__':
    from mayavi.tools.show import show
    viewer_factory()
    show()


########NEW FILE########
__FILENAME__ = module_manager
"""
Traits View definition file.

The view trait of the parent class is extracted from the model definition
file.  This file can either be exec()ed or imported.  See
core/base.py:Base.trait_view() for what is currently used.  Using exec()
allows view changes without needing to restart Mayavi, but is slower than
importing.
"""
# Authors: Prabhu Ramachandran <prabhu_r@users.sf.net>
#          Judah De Paula <judah@enthought.com>
# Copyright (c) 2005-2008, Enthought, Inc.
# License: BSD Style.

from traitsui.api import Item, Group, View, EnumEditor
from mayavi.core.module_manager import LUT_DATA_MODE_TYPES

view = View(Group(Item('scalar_lut_manager', style='custom'),
                  label='Scalar LUT', show_labels=False,
                  selected=True),
            Group(Item('vector_lut_manager', style='custom'),
                  label='Vector LUT', show_labels=False),
            Group(Item('lut_data_mode',
                       style='custom',
                       editor = EnumEditor(values=LUT_DATA_MODE_TYPES)),
                  label='ModuleManager',
                  selected=False),
            )

########NEW FILE########
__FILENAME__ = api
""" Defines the publicly accessible MayaVi2 filters.
"""

# Authors: Frederic Petit, Prabhu Ramachandran and Gael Varoquaux
# Copyright (c) 2007-2009, Enthought, Inc.
# License: BSD Style.

from cell_derivatives import CellDerivatives
from cell_to_point_data import CellToPointData
from collection import Collection
from data_set_clipper import DataSetClipper
from contour import Contour
from cut_plane import CutPlane
from decimatepro import DecimatePro
from delaunay2d import Delaunay2D
from delaunay3d import Delaunay3D
from elevation_filter import ElevationFilter
from extract_edges import ExtractEdges
from extract_grid import ExtractGrid
from extract_tensor_components import ExtractTensorComponents
from extract_unstructured_grid import ExtractUnstructuredGrid
from extract_vector_components import ExtractVectorComponents
from extract_vector_norm import ExtractVectorNorm
from gaussian_splatter import GaussianSplatter
from greedy_terrain_decimation import GreedyTerrainDecimation
from image_change_information import ImageChangeInformation
from image_data_probe import ImageDataProbe
from mask_points import MaskPoints
from optional import Optional
from point_to_cell_data import PointToCellData
from poly_data_normals import PolyDataNormals
from quadric_decimation import QuadricDecimation
from select_output import SelectOutput
from set_active_attribute import SetActiveAttribute
from stripper import Stripper
from threshold import Threshold
from transform_data import TransformData
from triangle_filter import TriangleFilter
from tube import Tube
from user_defined import UserDefined
from vorticity import Vorticity
from warp_scalar import WarpScalar
from warp_vector import WarpVector
from wrapper import Wrapper


########NEW FILE########
__FILENAME__ = cell_derivatives
# Author: Prabhu Ramachandran <prabhu [at] aero . iitb . ac . in>
# Copyright (c) 2008,  Enthought, Inc.
# License: BSD Style.

# Enthought library imports.
from traits.api import Instance
from tvtk.api import tvtk

# Local imports
from mayavi.filters.filter_base import FilterBase
from mayavi.core.pipeline_info import PipelineInfo


######################################################################
# `CellDerivatives` class.
######################################################################
class CellDerivatives(FilterBase):

    """Computes derivatives from input point scalar and vector data and
    produces cell data on the gradients.  Can be used to approximately
    calcuate the vorticity for example.
    """

    # The version of this class.  Used for persistence.
    __version__ = 0

    # The actual TVTK filter that this class manages.
    filter = Instance(tvtk.CellDerivatives, args=(),
                      allow_none=False, record=True)

    # Information about what this object can consume.
    input_info = PipelineInfo(datasets=['any'],
                              attribute_types=['any'],
                              attributes=['any'])

    # Information about what this object can produce.
    output_info = PipelineInfo(datasets=['any'],
                               attribute_types=['any'],
                               attributes=['any'])

    def has_output_port(self):
        """ The filter has an output port."""
        return True

    def get_output_object(self):
        """ Return the output port."""
        return self.filter.output_port

########NEW FILE########
__FILENAME__ = cell_to_point_data
# Author: Prabhu Ramachandran <prabhu_r at users dot sf dot net>
# Copyright (c) 2006, Enthought, Inc.
# License: BSD Style.

# Enthought library imports.
from traits.api import Instance
from tvtk.api import tvtk

# Local imports
from mayavi.filters.filter_base import FilterBase
from mayavi.core.pipeline_info import PipelineInfo

######################################################################
# `CellToPointData` class.
######################################################################
class CellToPointData(FilterBase):

    """Transforms cell attribute data to point data by averaging the
    cell data from the cells at the point.
    """

    # The version of this class.  Used for persistence.
    __version__ = 0

    # The actual TVTK filter that this class manages.
    filter = Instance(tvtk.CellDataToPointData,
                            args=(), kw={'pass_cell_data':1},
                            allow_none=False, record=True)

    # Information about what this object can consume/produce.
    input_info = PipelineInfo(datasets=['any'],
                              attribute_types=['cell'],
                              attributes=['any'])

    output_info = PipelineInfo(datasets=['any'],
                               attribute_types=['any'],
                               attributes=['any'])

    def update_pipeline(self):
        # Do nothing if there is no input.
        inputs = self.inputs
        if len(inputs) == 0:
            return

        fil = self.filter
        input = inputs[0].outputs[0]
        self.configure_connection(fil, inputs[0])
        fil.update()
        # This filter creates different outputs depending on the
        # input.
        out_map = {'vtkStructuredGrid': 'structured_grid_output',
                   'vtkRectilinearGrid': 'rectilinear_grid_output',
                   'vtkStructuredPoints': 'structured_points_output',
                   'vtkUnstructuredGrid': 'unstructured_grid_output',
                   'vtkPolyData': 'poly_data_output',
                   'vtkImageData': 'image_data_output'}
        # Find the input data type and pass that to our output..
        for type in out_map:
            if input.is_a(type):
                self._set_outputs([getattr(fil, out_map[type])])
                break


########NEW FILE########
__FILENAME__ = collection
"""Defines a Collection filter which is a collection of mayavi
filters/components bundled into one.
"""
# Author: Prabhu Ramachandran <prabhu [at] aero . iitb . ac . in>
# Copyright (c) 2008,  Enthought, Inc.
# License: BSD Style.

# Enthought library imports.
from traits.api import Instance, Bool, List
from traitsui.api import Item, Group, View, ListEditor

# Local imports.
from mayavi.core.pipeline_base import PipelineBase
from mayavi.core.filter import Filter
from mayavi.core.common import handle_children_state


################################################################################
# `Collection` class.
################################################################################
class Collection(Filter):
    """
    Defines a Collection filter which is a collection of mayavi
    filters/components bundled into one.
    """

    # The filters we manage.
    filters = List(Instance(PipelineBase), record=True)

    ########################################
    # Private traits.

    # Is the pipeline ready?  Used internally.
    _pipeline_ready = Bool(False)

    ######################################################################
    # `object` interface.
    ######################################################################
    def __set_pure_state__(self, state):
        # Create and set the filters.
        handle_children_state(self.filters, state.filters)
        # Restore our state using the super class method.
        super(Collection, self).__set_pure_state__(state)

    ######################################################################
    # HasTraits interface.
    ######################################################################
    def default_traits_view(self):
        """Returns the default traits view for this object."""
        le = ListEditor(use_notebook=True,
                        deletable=False,
                        export='DockWindowShell',
                        page_name='.name')
        view = View(Group(Item(name='filters',
                               style='custom',
                               show_label=False,
                               editor=le,
                               resizable=True),
                              show_labels=False),
                    resizable=True)
        return view

    ######################################################################
    # `Filter` interface.
    ######################################################################
    def setup_pipeline(self):
        """Setup the pipeline."""
        # Needed because a user may have defined the filters by setting
        # the default value of the trait in the subclass in which case
        # the filters_changed handler will never be called leading to
        # problems.
        if len(self.filters) > 0 and not self._pipeline_ready:
            self._filters_changed([], self.filters)

    def stop(self):
        # There is no need to override start since the wrapped filters
        # are always started automatically in the filters_changed
        # handler.
        super(Collection, self).stop()
        for filter in self.filters:
            filter.stop()

    def update_pipeline(self):
        """This method *updates* the tvtk pipeline when data upstream is
        known to have changed.

        This method is invoked (automatically) when the input fires a
        `pipeline_changed` event.
        """
        self._setup_pipeline()
        # Propagate the event.
        self.pipeline_changed = True

    def update_data(self):
        """This method does what is necessary when upstream data
        changes.

        This method is invoked (automatically) when any of the inputs
        sends a `data_changed` event.
        """
        # Propagate the data_changed event.
        self.data_changed = True

    ######################################################################
    # Private interface.
    ######################################################################
    def _setup_pipeline(self):
        """Sets up the objects in the pipeline."""
        if len(self.inputs) == 0 or len(self.filters) == 0:
            return
        # Our input.
        my_input = self.inputs[0]
        filters = self.filters
        if not self._pipeline_ready:
            # Hook up our first filter.
            first = self.filters[0]
            first.inputs = [my_input]
            # Hook up the others to each other.
            for i in range(1, len(filters)):
                filter = filters[i]
                filter.inputs = [filters[i-1]]
            self._pipeline_ready = True
        # Start filters.
        for filter in filters:
            filter.start()
        # Set our outputs
        last = filters[-1]
        self._set_outputs(last.outputs)

    def _filters_changed(self, old, new):
        """Static traits handler."""
        self._handle_filters_changed(old, new)

    def _filters_items_changed(self, list_event):
        """Static traits handler."""
        self._handle_filters_changed(list_event.removed,
                                     list_event.added)

    def _scene_changed(self, old, new):
        """Static traits handler."""
        for filter in self.filters:
            filter.scene = new
        super(Collection, self)._scene_changed(old, new)

    def _handle_filters_changed(self, removed, added):
        for filter in removed:
            self._setup_events(filter, remove=True)
            filter.stop()
        for filter in added:
            if self.scene is not None:
                filter.scene = self.scene
            if len(filter.name) == 0:
                filter.name = filter.__class__.__name__
            if filter is self.filters[-1]:
                self._setup_events(filter)
        self._pipeline_ready = False
        self._setup_pipeline()

    def _fire_pipeline_changed(self):
        # When the last filter fires a pipeline changed we should reset
        # our outputs to that of its outputs.  Calling _setup_pipeline
        # is expensive and will cause a recursion error.
        self._set_outputs(self.filters[-1].outputs)

    def _setup_events(self, obj, remove=False):
        obj.on_trait_change(self.update_data, 'data_changed',
                            remove=remove)
        obj.on_trait_change(self._fire_pipeline_changed,
                            'pipeline_changed', remove=remove)

    def _visible_changed(self, value):
        for filter in self.filters:
            filter.visible = value
        super(Collection, self)._visible_changed(value)

    def _recorder_changed(self, old, new):
        super(Collection, self)._recorder_changed(old, new)
        for filter in self.filters:
            filter.recorder = new

########NEW FILE########
__FILENAME__ = contour
# Author: Prabhu Ramachandran <prabhu [at] aero . iitb . ac . in>
# Copyright (c) 2008,  Prabhu Ramachandran
# License: BSD Style.

# Enthought library imports.
from traits.api import Instance

# Local imports.
from mayavi.components.contour import Contour as ContourComponent
from mayavi.core.pipeline_info import PipelineInfo
from mayavi.filters.wrapper import Wrapper

################################################################################
# `Contour` class.
################################################################################
class Contour(Wrapper):
    """
    A contour filter that wraps around the Contour component to generate
    iso-surfaces on any input dataset.
    """
    # The version of this class.  Used for persistence.
    __version__ = 0

    # The contour component this wraps.
    filter = Instance(ContourComponent, args=(), record=True)

    input_info = PipelineInfo(datasets=['any'],
                              attribute_types=['point'],
                              attributes=['any'])

    output_info = PipelineInfo(datasets=['any'],
                               attribute_types=['any'],
                               attributes=['any'])

########NEW FILE########
__FILENAME__ = cut_plane
# Author: Prabhu Ramachandran <prabhu [at] aero . iitb . ac . in>
# Copyright (c) 2008,  Prabhu Ramachandran
# License: BSD Style.

# Local imports.
from mayavi.components.cutter import Cutter
from mayavi.components.implicit_plane import ImplicitPlane
from mayavi.filters.collection import Collection
from mayavi.core.pipeline_info import PipelineInfo

################################################################################
# `CutPlane` class.
################################################################################
class CutPlane(Collection):
    """
    This class represents a cut plane that can be used to slice through
    any dataset.  It also provides a 3D widget interface to position and
    move the slice interactively.
    """
    # The version of this class.  Used for persistence.
    __version__ = 0

    input_info = PipelineInfo(datasets=['any'],
                              attribute_types=['any'],
                              attributes=['any'])
    output_info = PipelineInfo(datasets=['poly_data'],
                               attribute_types=['any'],
                               attributes=['any'])

    ######################################################################
    # `Filter` interface.
    ######################################################################
    def setup_pipeline(self):
        """Creates the pipeline."""
        ip = ImplicitPlane()
        cut = Cutter(cut_function=ip.plane)
        self.filters = [ip, cut]


########NEW FILE########
__FILENAME__ = data_set_clipper
"""This filter enables one to clip a selection from an input dataset
using various Implicit Widgets.
"""
# Author: Suyog Dutt Jain <suyog.jain@aero.iitb.ac.in>
#         Prabhu Ramachandran <prabhu at aero.iitb.ac.in>
# Copyright (c) 2009, Enthought, Inc.
# License: BSD Style.

# Standard library imports.
import cPickle

# Enthought library imports.
from traits.api import Instance, Button, Delegate
from traitsui.api import View, Group, Item
from apptools.persistence import state_pickler

from tvtk.api import tvtk

# Local imports
from mayavi.core.filter import Filter
from mayavi.core.pipeline_info import PipelineInfo
from mayavi.components.implicit_widgets import ImplicitWidgets


######################################################################
# `DataSetClipper` class.
######################################################################
class DataSetClipper(Filter):

    # The version of this class.  Used for persistence.
    __version__ = 0

    # The widgets to be used for the Clipping Filter.
    widget = Instance(ImplicitWidgets, allow_none=False, record=True)

    # The clipping filter.
    filter = Instance(tvtk.Object, allow_none=False, record=True)

    # The update mode of the widget-- this is delegated to the
    # ImplicitWidgets.
    update_mode = Delegate('widget', modify=True)

    input_info = PipelineInfo(datasets=['any'],
                              attribute_types=['any'],
                              attributes=['any'])

    output_info = PipelineInfo(datasets=['any'],
                               attributes=['any'])

    ########################################
    # View related traits.

    # Button to reset the boundaries of the implicit_widget.
    reset_button = Button('Reset Boundaries')

    view = View(Group(Group(Item('update_mode'),
                            ),
                      Group(Item('reset_button'),
                            Item(name='widget', style='custom', resizable=True),
                            show_labels=False
                            ),
                      label='ImplicitWidget'
                      ),
                Group(Group(Item('filter', style='custom'),
                            show_labels=False),
                      label='Clipper'
                     ),
                resizable=True
                )

    ########################################
    # Private traits.
    _transform = Instance(tvtk.Transform, allow_none=False)


    ######################################################################
    # `object` interface.
    ######################################################################
    def __get_pure_state__(self):
        d = super(DataSetClipper, self).__get_pure_state__()
        for name in ('_first', '_observer_id'):
            d.pop(name, None)
        d['matrix'] = cPickle.dumps(self._transform.matrix)
        return d

    def __set_pure_state__(self, state):
        mat = state.pop('matrix')
        super(DataSetClipper, self).__set_pure_state__(state)
        state_pickler.set_state(self, state)
        self._transform.set_matrix(cPickle.loads(mat))
        self.widget.set_transform(self._transform)


    ######################################################################
    # `Filter` interface
    ######################################################################
    def setup_pipeline(self):
        self.widget = ImplicitWidgets()
        self._transform = tvtk.Transform()
        self.filter = tvtk.ClipDataSet()
        self.widget.on_trait_change(self._handle_widget, 'widget')
        super(DataSetClipper, self).setup_pipeline()

    def update_pipeline(self):
        inputs = self.inputs
        if len(inputs) == 0:
            return

        widget = self.widget
        widget.inputs = inputs
        widget.update_pipeline()

        filter = self.filter
        self.configure_connection(filter, inputs[0])
        widget.update_implicit_function()
        filter.clip_function = widget.implicit_function
        filter.update()
        self._set_outputs([filter.output])

        self.pipeline_changed = True

    def update_data(self):
        # Do nothing if there is no input.
        if len(self.inputs) == 0:
            return

        self.filter.update()
        # Propagate the data_changed event.
        self.data_changed = True

    ######################################################################
    # Non-public methods.
    ######################################################################
    def _on_interaction_event(self, obj, event):
        tfm = self._transform
        self.widget.widget.get_transform(tfm)
        recorder = self.recorder
        if recorder is not None:
            state = {}
            state['elements'] = tfm.matrix.__getstate__()['elements']
            name = recorder.get_script_id(self)
            recorder.record('%s._transform.matrix.__setstate__(%s)'\
                            %(name, state))
            recorder.record('%s.widget.widget.set_transform(%s._transform)'\
                            %(name, name))
            recorder.record('%s.widget.update_implicit_function()' % name)
            recorder.record('%s.render()' % name)

    def _widget_changed(self, old, new):
        self.widgets = self.widget.widgets

        if len(self.inputs) > 0:
            new.inputs = self.inputs
            new.update_pipeline()
        self._observer_id = new.widget.add_observer(self.update_mode_,
                                             self._on_interaction_event)


    def _filter_changed(self, old, new):
        if old is not None:
                old.on_trait_change(self.render, remove=True)
        new.on_trait_change(self.render)
        if len(self.inputs) > 0:
            self.configure_connection(new, self.inputs[0])
            self.outputs = [new.output]

    def _reset_button_fired(self):
        self.widget.widget.place_widget()
        self.widget.update_implicit_function()
        self.filter.update()
        self.render()

    def _handle_widget(self, value):
        self.widgets = self.widget.widgets
        f = self.filter
        f.clip_function = self.widget.implicit_function
        f.update()
        self.update_pipeline()


########NEW FILE########
__FILENAME__ = decimatepro
# Author: Gael Varoquaux <gael _dot_ varoquaux _at_ normalesup _dot_ org>
# Copyright (c) 2008, Enthought, Inc.
# License: BSD Style.

# Enthought library imports.
from traits.api import Instance
from tvtk.api import tvtk

# Local imports
from mayavi.filters.filter_base import FilterBase
from mayavi.core.pipeline_info import PipelineInfo


######################################################################
# `DecimatePro` class.
######################################################################
class DecimatePro(FilterBase):

    """ Reduces the number of triangles in a mesh using the
        tvtk.DecimatePro class. """

    # The version of this class.  Used for persistence.
    __version__ = 0

    # The actual TVTK filter that this class manages.
    filter = Instance(tvtk.DecimatePro, args=(), allow_none=False, record=True)

    input_info = PipelineInfo(datasets=['poly_data'],
                              attribute_types=['any'],
                              attributes=['any'])

    output_info = PipelineInfo(datasets=['poly_data'],
                               attribute_types=['any'],
                               attributes=['any'])


########NEW FILE########
__FILENAME__ = delaunay2d
# Author: Prabhu Ramachandran <prabhu_r at users dot sf dot net>
# Copyright (c) 2006, Enthought, Inc.
# License: BSD Style.

# Enthought library imports.
from traits.api import Instance
from tvtk.api import tvtk

# Local imports
from mayavi.filters.filter_base import FilterBase
from mayavi.core.pipeline_info import PipelineInfo


######################################################################
# `Delaunay2D` class.
######################################################################
class Delaunay2D(FilterBase):

    """Performs a 2D Delaunay triangulation using the tvtk.Delaunay2D
    class.
    """

    # The version of this class.  Used for persistence.
    __version__ = 0

    # The actual TVTK filter that this class manages.
    filter = Instance(tvtk.Delaunay2D, args=(), allow_none=False, record=True)

    input_info = PipelineInfo(datasets=['structured_grid', 'poly_data',
                                        'unstructured_grid'],
                              attribute_types=['any'],
                              attributes=['any'])

    output_info = PipelineInfo(datasets=['poly_data'],
                               attribute_types=['any'],
                               attributes=['any'])


########NEW FILE########
__FILENAME__ = delaunay3d
# Author: Prabhu Ramachandran <prabhu_r at users dot sf dot net>
# Copyright (c) 2006, Enthought, Inc.
# License: BSD Style.

# Enthought library imports.
from traits.api import Instance
from tvtk.api import tvtk

# Local imports
from mayavi.filters.filter_base import FilterBase
from mayavi.core.pipeline_info import PipelineInfo


######################################################################
# `Delaunay3D` class.
######################################################################
class Delaunay3D(FilterBase):

    """Performs a 3D Delaunay triangulation using the tvtk.Delaunay3D
    class.
    """

    # The version of this class.  Used for persistence.
    __version__ = 0

    # The actual TVTK filter that this class manages.
    filter = Instance(tvtk.Delaunay3D, args=(), allow_none=False, record=True)

    input_info = PipelineInfo(datasets=['structured_grid', 'poly_data',
                                        'unstructured_grid'],
                              attribute_types=['any'],
                              attributes=['any'])

    output_info = PipelineInfo(datasets=['unstructured_grid'],
                               attribute_types=['any'],
                               attributes=['any'])


########NEW FILE########
__FILENAME__ = elevation_filter
# Author: Gael Varoquaux <gael _dot_ varoquaux _at_ normalesup _dot_ org>
# Copyright (c) 2008, Enthought, Inc.
# License: BSD Style.

# Enthought library imports.
from traits.api import Instance
from tvtk.api import tvtk

# Local imports
from mayavi.filters.filter_base import FilterBase
from mayavi.core.pipeline_info import PipelineInfo


######################################################################
# `ElevationFilter` class.
######################################################################
class ElevationFilter(FilterBase):

    """ Generate scalar data from the elevation in a given direction """

    # The version of this class.  Used for persistence.
    __version__ = 0

    # The actual TVTK filter that this class manages.
    filter = Instance(tvtk.ElevationFilter, args=(), allow_none=False, record=True)

    input_info = PipelineInfo(datasets=['any'],
                              attribute_types=['any'],
                              attributes=['any'])

    output_info = PipelineInfo(datasets=['any'],
                               attribute_types=['any'],
                               attributes=['any'])


########NEW FILE########
__FILENAME__ = extract_edges
# Author: Gael Varoquaux <gael.varoquaux@normalesup.org>
# Copyright (c) 2007, Enthought, Inc.
# License: BSD Style.

# Enthought library imports.
from traits.api import Instance
from tvtk.api import tvtk

# Local imports
from mayavi.filters.filter_base import FilterBase
from mayavi.core.pipeline_info import PipelineInfo


######################################################################
# `ExtractEdges` class.
######################################################################
class ExtractEdges(FilterBase):

    """Turns edges into lines.
    """

    # The version of this class.  Used for persistence.
    __version__ = 0

    # The actual TVTK filter that this class manages.
    filter = Instance(tvtk.ExtractEdges, args=(), allow_none=False, record=True)

    input_info = PipelineInfo(datasets=['any'],
                              attribute_types=['any'],
                              attributes=['any'])

    output_info = PipelineInfo(datasets=['poly_data'],
                               attribute_types=['any'],
                               attributes=['any'])


########NEW FILE########
__FILENAME__ = extract_grid
"""This filter enables one to select a portion of, or subsample an
input dataset which may be a StructuredPoints, StructuredGrid or
Rectilinear.

"""
# Author: Prabhu Ramachandran <prabhu@aero.iitb.ac.in>
# Copyright (c) 2007, Enthought, Inc.
# License: BSD Style.

# Enthought library imports.
from traits.api import Instance, Int, Range
from traitsui.api import View, Group, Item

from tvtk.api import tvtk

# Local imports
from mayavi.core.common import error
from mayavi.filters.filter_base import FilterBase
from mayavi.core.pipeline_info import PipelineInfo
from tvtk.common import is_old_pipeline

######################################################################
# `ExtractGrid` class.
######################################################################
class ExtractGrid(FilterBase):
    """This filter enables one to select a portion of, or subsample an
    input dataset which may be a StructuredPoints, StructuredGrid or
    Rectilinear.
    """
    # The version of this class.  Used for persistence.
    __version__ = 0

    # Minimum x value.
    x_min = Range(value=0, low='_x_low', high='_x_high',
                  enter_set=True, auto_set=False,
                  desc='minimum x value of the domain')

    # Maximum x value.
    x_max = Range(value=10000, low='_x_low', high='_x_high',
                  enter_set=True, auto_set=False,
                  desc='maximum x value of the domain')

    # Minimum y value.
    y_min = Range(value=0, low='_y_low', high='_y_high',
                  enter_set=True, auto_set=False,
                  desc='minimum y value of the domain')

    # Maximum y value.
    y_max = Range(value=10000, low='_y_low', high='_y_high',
                  enter_set=True, auto_set=False,
                  desc='maximum y value of the domain')

    # Minimum z value.
    z_min = Range(value=0, low='_z_low', high='_z_high',
                  enter_set=True, auto_set=False,
                  desc='minimum z value of the domain')

    # Maximum z value.
    z_max = Range(value=10000, low='_z_low', high='_z_high',
                  enter_set=True, auto_set=False,
                  desc='maximum z value of the domain')

    # Sample rate in x.
    x_ratio = Range(value=1, low='_min_sample', high='_x_s_high',
                    enter_set=True, auto_set=False,
                    desc='sample rate along x')

    # Sample rate in y.
    y_ratio = Range(value=1, low='_min_sample', high='_y_s_high',
                    enter_set=True, auto_set=False,
                    desc='sample rate along y')

    # Sample rate in z.
    z_ratio = Range(value=1, low='_min_sample', high='_z_s_high',
                    enter_set=True, auto_set=False,
                    desc='sample rate along z')

    # The actual TVTK filter that this class manages.
    filter = Instance(tvtk.Object, tvtk.ExtractVOI(), allow_none=False)

    input_info = PipelineInfo(datasets=['image_data',
                                        'rectilinear_grid',
                                        'structured_grid'],
                              attribute_types=['any'],
                              attributes=['any'])

    output_info = PipelineInfo(datasets=['image_data',
                                         'rectilinear_grid',
                                         'structured_grid'],
                               attribute_types=['any'],
                               attributes=['any'])

    ########################################
    # Private traits.

    # Determines the lower/upper limit of the axes for the sliders.
    _min_sample = Int(1)
    _x_low = Int(0)
    _x_high = Int(10000)
    _x_s_high = Int(100)
    _y_low = Int(0)
    _y_high = Int(10000)
    _y_s_high = Int(100)
    _z_low = Int(0)
    _z_high = Int(10000)
    _z_s_high = Int(100)

    ########################################
    # View related traits.

    # The View for this object.
    view = View(Group(Item(label='Select Volume Of Interest'),
                      Item(name='x_min'),
                      Item(name='x_max'),
                      Item(name='y_min'),
                      Item(name='y_max'),
                      Item(name='z_min'),
                      Item(name='z_max'),
                      Item('_'),
                      Item(label='Select Sample Ratio'),
                      Item(name='x_ratio'),
                      Item(name='y_ratio'),
                      Item(name='z_ratio'),
                      label='VOI'
                      ),
                Group(Item(name='filter', style='custom',
                           resizable=True),
                      show_labels=False,
                      label='Filter'),
                resizable=True,
                )

    ######################################################################
    # `object` interface
    ######################################################################
    def __get_pure_state__(self):
        d = super(ExtractGrid, self).__get_pure_state__()
        for axis in ('x', 'y', 'z'):
            for name in ('_min', '_max'):
                d.pop(axis + name, None)
            d.pop('_' + axis + '_low', None)
            d.pop('_' + axis + '_high', None)
            d.pop('_' + axis + '_s_high', None)
            d.pop(axis + '_ratio', None)
        return d

    ######################################################################
    # `Filter` interface
    ######################################################################
    def update_pipeline(self):
        inputs = self.inputs
        if len(inputs) == 0:
            return

        input = inputs[0].outputs[0]
        mapping = {'vtkStructuredGrid': tvtk.ExtractGrid,
                   'vtkRectilinearGrid': tvtk.ExtractRectilinearGrid,
                   'vtkImageData': tvtk.ExtractVOI}

        for key, klass in mapping.iteritems():
            if input.is_a(key):
                self.filter = klass()
                break
        else:
            error('This filter does not support %s objects'%\
                  (input.__class__.__name__))
            return

        fil = self.filter
        self.configure_connection(fil, inputs[0])
        fil.update_whole_extent()
        fil.update()
        self._set_outputs([fil.output])
        self._update_limits()
        self._update_voi()
        self._update_sample_rate()

    def update_data(self):
        """This method is invoked (automatically) when any of the
        inputs sends a `data_changed` event.
        """
        self._update_limits()
        fil = self.filter
        fil.update_whole_extent()
        fil.update()
        # Propagate the data_changed event.
        self.data_changed = True

    ######################################################################
    # Non-public methods.
    ######################################################################
    def _update_limits(self):
        if is_old_pipeline():
            extents = self.filter.input.whole_extent
        else:
            extents = self.filter.get_update_extent()
        self._x_low, self._x_high = extents[:2]
        self._y_low, self._y_high = extents[2:4]
        self._z_low, self._z_high = extents[4:]
        self._x_s_high = max(1, self._x_high)
        self._y_s_high = max(1, self._y_high)
        self._z_s_high = max(1, self._z_high)

    def _x_min_changed(self, val):
        if val > self.x_max:
            self.x_max = val
        else:
            self._update_voi()

    def _x_max_changed(self, val):
        if val < self.x_min:
            self.x_min = val
        else:
            self._update_voi()

    def _y_min_changed(self, val):
        if val > self.y_max:
            self.y_max = val
        else:
            self._update_voi()

    def _y_max_changed(self, val):
        if val < self.y_min:
            self.y_min = val
        else:
            self._update_voi()

    def _z_min_changed(self, val):
        if val > self.z_max:
            self.z_max = val
        else:
            self._update_voi()

    def _z_max_changed(self, val):
        if val < self.z_min:
            self.z_min = val
        else:
            self._update_voi()

    def _x_ratio_changed(self):
        self._update_sample_rate()

    def _y_ratio_changed(self):
        self._update_sample_rate()

    def _z_ratio_changed(self):
        self._update_sample_rate()

    def _update_voi(self):
        f = self.filter
        f.voi = (self.x_min, self.x_max,
                 self.y_min, self.y_max,
                 self.z_min, self.z_max)
        f.update_whole_extent()
        f.update()
        self.data_changed = True

    def _update_sample_rate(self):
        f = self.filter
        f.sample_rate = (self.x_ratio, self.y_ratio, self.z_ratio)
        f.update_whole_extent()
        f.update()
        self.data_changed = True

    def _filter_changed(self, old, new):
        if old is not None:
            old.on_trait_change(self.render, remove=True)
        new.on_trait_change(self.render)

########NEW FILE########
__FILENAME__ = extract_tensor_components
# Author: Prabhu Ramachandran <prabhu_r at users dot sf dot net>
# Copyright (c) 2007, Enthought, Inc.
# License: BSD Style.

# Enthought library imports.
from traits.api import Instance
from tvtk.api import tvtk

# Local imports
from mayavi.filters.filter_base import FilterBase
from mayavi.core.pipeline_info import PipelineInfo


######################################################################
# `ExtractTensorComponents` class.
######################################################################
class ExtractTensorComponents(FilterBase):
    """Wraps the TVTK ExtractTensorComponents filter to extract components from
    a tensor field.    """

    # The version of this class.  Used for persistence.
    __version__ = 0

    # The actual TVTK filter that this class manages.
    filter = Instance(tvtk.ExtractTensorComponents, args=(),
                      kw={'pass_tensors_to_output':True,
                          'scalar_mode': 'effective_stress',
                          'extract_scalars': True},
                      allow_none=False, record=True)

    input_info = PipelineInfo(datasets=['any'],
                              attribute_types=['any'],
                              attributes=['tensors'])

    output_info = PipelineInfo(datasets=['any'],
                               attribute_types=['any'],
                               attributes=['any'])


########NEW FILE########
__FILENAME__ = extract_unstructured_grid
# Author: Prabhu Ramachandran <prabhu_r at users dot sf dot net>
# Copyright (c) 2006, Enthought, Inc.
# License: BSD Style.

# Enthought library imports.
from traits.api import Instance
from tvtk.api import tvtk

# Local imports
from mayavi.filters.filter_base import FilterBase
from mayavi.core.pipeline_info import PipelineInfo


######################################################################
# `ExtractUnstructuredGrid` class.
######################################################################
class ExtractUnstructuredGrid(FilterBase):
    """Allows a user to select a part of an unstructured grid.
    """
    # The version of this class.  Used for persistence.
    __version__ = 0

    # The actual TVTK filter that this class manages.
    filter = Instance(tvtk.ExtractUnstructuredGrid, args=(),
                      allow_none=False, record=True)

    input_info = PipelineInfo(datasets=['unstructured_grid'],
                              attribute_types=['any'],
                              attributes=['any'])

    output_info = PipelineInfo(datasets=['unstructured_grid'],
                               attribute_types=['any'],
                               attributes=['any'])


########NEW FILE########
__FILENAME__ = extract_vector_components
# Author: Varun Hiremath <varun@debian.org>

# Enthought library imports.
from traits.api import Instance, Enum
from traitsui.api import View, Group, Item
from tvtk.api import tvtk

# Local imports
from mayavi.filters.filter_base import FilterBase
from mayavi.core.pipeline_info import PipelineInfo


######################################################################
# `ExtractVectorComponents` class.
######################################################################
class ExtractVectorComponents(FilterBase):
    """ This wraps the TVTK ExtractVectorComponents filter and allows
    one to select any of the three components of an input vector data
    attribute."""

    # The version of this class.  Used for persistence.
    __version__ = 0

    # The actual TVTK filter that this class manages.
    filter = Instance(tvtk.ExtractVectorComponents, args=(), allow_none=False)

    # The Vector Component to be extracted
    component = Enum('x-component', 'y-component', 'z-component',
                     desc='component of the vector to be extracted')

    input_info = PipelineInfo(datasets=['any'],
                              attribute_types=['any'],
                              attributes=['vectors'])

    output_info = PipelineInfo(datasets=['any'],
                               attribute_types=['any'],
                               attributes=['any'])

    view = View(Group(Item(name='component')),
                resizable=True
                )

    ######################################################################
    # `Filter` interface.
    ######################################################################
    def update_pipeline(self):
        # Do nothing if there is no input.
        inputs = self.inputs
        if len(inputs) == 0:
            return

        fil = self.filter
        self.configure_connection(fil, inputs[0])
        fil.update()
        self._component_changed(self.component)

    ######################################################################
    # Non-public interface.
    ######################################################################
    def _component_changed(self, value):
        # Obtain output from the TVTK ExtractVectorComponents filter
        # corresponding to the selected vector component

        if len(self.inputs) == 0:
            return

        if value == 'x-component':
            self._set_outputs([self.filter.vx_component])
        elif value == 'y-component':
            self._set_outputs([self.filter.vy_component])
        elif value == 'z-component':
            self._set_outputs([self.filter.vz_component])
        self.render()

########NEW FILE########
__FILENAME__ = extract_vector_norm
# Author: Prabhu Ramachandran <prabhu_r at users dot sf dot net>
# Copyright (c) 2006, Enthought, Inc.
# License: BSD Style.

# Enthought library imports.
from traits.api import Instance
from tvtk.api import tvtk

# Local imports
from mayavi.filters.filter_base import FilterBase
from mayavi.core.pipeline_info import PipelineInfo

######################################################################
# `ExtractVectorNorm` class.
######################################################################
class ExtractVectorNorm(FilterBase):
    """Computes the norm (Eucliedean) of the input vector data (with
    optional scaling between [0, 1]).  This is useful when the input
    data has vector input but no scalar data for the magnitude of the
    vectors.
    """

    # The version of this class.  Used for persistence.
    __version__ = 0

    # The actual TVTK filter that this class manages.
    filter = Instance(tvtk.VectorNorm, args=(), allow_none=False, record=True)

    input_info = PipelineInfo(datasets=['any'],
                              attribute_types=['any'],
                              attributes=['vectors'])

    output_info = PipelineInfo(datasets=['any'],
                               attribute_types=['any'],
                               attributes=['any'])

    ######################################################################
    # `Filter` interface.
    ######################################################################
    def update_pipeline(self):
        # Do nothing if there is no input.
        inputs = self.inputs
        if len(inputs) == 0:
            return

        # By default we set the input to the first output of the first
        # input.
        fil = self.filter
        self.configure_connection(fil, inputs[0])
        fil.update()
        self._set_array_name(fil)
        self._set_outputs([fil.output])

    def update_data(self):
        """Override this method to do what is necessary when upstream
        data changes.

        This method is invoked (automatically) when any of the inputs
        sends a `data_changed` event.
        """
        # Do nothing if there is no input.
        inputs = self.inputs
        if len(inputs) == 0:
            return

        self.filter.update()
        self._set_array_name(self.filter)
        # Propagate the data_changed event.
        self.data_changed = True

    ######################################################################
    # Non-public interface.
    ######################################################################
    def _set_array_name(self, filter):
        # Do nothing if there is no input.
        if len(self.inputs) == 0:
            return

        o = filter.output
        pd = o.point_data
        ps = pd.scalars
        cd = o.cell_data
        cs = cd.scalars
        if (ps is not None) and (not ps.name):
            ps.name = pd.vectors.name + ' magnitude'
        elif (cs is not None) and (not cs.name):
            cs.name = cd.vectors.name + ' magnitude'


########NEW FILE########
__FILENAME__ = filter_base
"""The base class for many filters.
"""
# Author: Prabhu Ramachandran <prabhu_r at users dot sf dot net>
# Copyright (c) 2006, Enthought, Inc.
# License: BSD Style.


# Enthought library imports.
from traits.api import Instance
from traitsui.api import View, Group, Item
from tvtk.api import tvtk

# Local imports
from mayavi.core.filter import Filter

######################################################################
# `FilterBase` class.
######################################################################
class FilterBase(Filter):
    """The base class for many of the filters.
    """

    # The version of this class.  Used for persistence.
    __version__ = 0

    # The actual TVTK filter that this class manages.
    filter = Instance(tvtk.Object, allow_none=False, record=True)

    # The view of these filters.

    view = View(Group(Item(name='filter', style='custom', resizable=True,
                      show_label=False), springy=True),
                scrollable=True,
                resizable=True
                )

    ######################################################################
    # `Filter` interface.
    ######################################################################
    def setup_pipeline(self):
        """Override this method so that it *creates* its tvtk
        pipeline.

        This method is invoked when the object is initialized via
        `__init__`.  Note that at the time this method is called, the
        tvtk data pipeline will *not* yet be setup.  So upstream data
        will not be available.  The idea is that you simply create the
        basic objects and setup those parts of the pipeline not
        dependent on upstream sources and filters.
        """
        f = self.filter
        if f is not None:
            # Just hook up the filter so the update_data method is
            # called when the traits change.
            f.on_trait_change(self.update_data)

    def update_pipeline(self):
        """Override this method so that it *updates* the tvtk pipeline
        when data upstream is known to have changed.

        This method is invoked (automatically) when the input fires a
        `pipeline_changed` event.
        """
        # Do nothing if there is no input.
        inputs = self.inputs
        fil = self.filter
        if len(inputs) == 0 or fil is None:
            return

        # By default we set the input to the first output of the first
        # input.
        self.configure_connection(fil, inputs[0])
        fil.update()
        self._set_outputs([fil.output])

    def update_data(self):
        """Override this method to do what is necessary when upstream
        data changes.

        This method is invoked (automatically) when any of the inputs
        sends a `data_changed` event.
        """
        # Do nothing if there is no input and we aren't running.
        if len(self.inputs) == 0 or not self.running:
            return

        self.filter.update()
        # Propagate the data_changed event.
        self.data_changed = True

    def _filter_changed(self, old, new):
        if old is not None:
            old.on_trait_change(self.update_data, remove=True)

        new.on_trait_change(self.update_data)

        if old is not None:
            self.update_pipeline()




########NEW FILE########
__FILENAME__ = gaussian_splatter
# Author: Gael Varoquaux <gael.varoquaux@normalesup.org>
# Copyright (c) 2007, Enthought, Inc.
# License: BSD Style.

# Enthought library imports.
from traits.api import Instance
from tvtk.api import tvtk

# Local imports
from mayavi.filters.filter_base import FilterBase
from mayavi.core.pipeline_info import PipelineInfo


######################################################################
# `GaussianSplatter` class.
######################################################################
class GaussianSplatter(FilterBase):


    # The version of this class.  Used for persistence.
    __version__ = 0

    # The actual TVTK filter that this class manages.
    filter = Instance(tvtk.GaussianSplatter, args=(),
                      allow_none=False, record=True)

    input_info = PipelineInfo(datasets=['any'],
                              attribute_types=['any'],
                              attributes=['any'])

    output_info = PipelineInfo(datasets=['image_data'],
                               attribute_types=['any'],
                               attributes=['any'])


########NEW FILE########
__FILENAME__ = greedy_terrain_decimation
# Author: Gael Varoquaux <gael _dot_ varoquaux _at_ normalesup _dot_ org>
# Copyright (c) 2008, Enthought, Inc.
# License: BSD Style.

# Enthought library imports.
from traits.api import Instance
from tvtk.api import tvtk

# Local imports
from mayavi.filters.filter_base import FilterBase
from mayavi.core.pipeline_info import PipelineInfo


######################################################################
# `GreedyTerrainDecimation` class.
######################################################################
class GreedyTerrainDecimation(FilterBase):

    """ Performs a triangulation of image data after simplifying it. """

    # The version of this class.  Used for persistence.
    __version__ = 0

    # The actual TVTK filter that this class manages.
    filter = Instance(tvtk.GreedyTerrainDecimation, args=(),
                      allow_none=False, record=True)

    input_info = PipelineInfo(datasets=['any'],
                              attribute_types=['any'],
                              attributes=['any'])

    output_info = PipelineInfo(datasets=['poly_data'],
                               attribute_types=['any'],
                               attributes=['any'])


########NEW FILE########
__FILENAME__ = image_change_information
"""
A filter that lets you change the spacing and origin of an input
ImageData dataset.
"""
# Author: Prabhu Ramachandran <prabhu@aero.iitb.ac.in>
# Copyright (c) 2008,  Enthought, Inc.
# License: BSD Style.

# Enthought library imports.
from traits.api import Instance
from tvtk.api import tvtk

# Local imports
from mayavi.filters.filter_base import FilterBase
from mayavi.core.pipeline_info import PipelineInfo


######################################################################
# `ImageChangeInformation` class.
######################################################################
class ImageChangeInformation(FilterBase):

    """
    A filter that lets you change the spacing and origin of an input
    ImageData dataset.
    """

    # The version of this class.  Used for persistence.
    __version__ = 0

    # The actual TVTK filter that this class manages.
    filter = Instance(tvtk.ImageChangeInformation, args=(),
                      allow_none=False, record=True)

    input_info = PipelineInfo(datasets=['image_data'],
                              attribute_types=['any'],
                              attributes=['any'])

    output_info = PipelineInfo(datasets=['image_data'],
                               attribute_types=['any'],
                               attributes=['any'])


########NEW FILE########
__FILENAME__ = image_data_probe
# Author: Prabhu Ramachandran <prabhu [at] aero . iitb . ac . in>
# Copyright (c) 2008,  Enthought, Inc.
# License: BSD Style.

# Standard library imports.
import numpy

# Enthought library imports.
from traits.api import Instance, Bool, Array, Button, Str
from traitsui.api import View, Group, Item
from tvtk.api import tvtk
import tvtk.common as tvtk_common

# Local imports.
from mayavi.core.filter import Filter
from mayavi.core.pipeline_info import PipelineInfo

################################################################################
# `ImageDataProbe` class.
################################################################################
class ImageDataProbe(Filter):
    """
    A filter that can be used to probe any dataset using a Structured
    Points dataset.  The filter also allows one to convert the scalar
    data to an unsigned short array so that the scalars can be used for
    volume visualization.
    """

    # The image data onto which the data is probed.
    probe_data = Instance(tvtk.ImageData, args=())

    # The probe filter.
    filter = Instance(tvtk.ProbeFilter, args=())

    rescale_scalars = Bool(False, desc='if the input scalars are '\
                                       'rescaled to an unsigned short '\
                                       'array')

    # Specifies if we can change the spacing/dimensions -- not allowed
    # for imagedata/structured points data.
    allow_changes = Bool(True)

    # Spacing of points in the image data.
    spacing = Array(value=(0.0, 0.0, 0.0),
                    shape=(3,),
                    cols=1,
                    dtype=float,
                    enter_set=True,
                    auto_set=False,
                    labels=['sx', 'sy', 'sz'],
                    desc='the spacing of points')

    # Dimensions of the image data.
    dimensions = Array(value=(0,0,0),
                       shape=(3,),
                       cols=1,
                       dtype=int,
                       enter_set=True,
                       auto_set=False,
                       labels=['nx', 'ny', 'nz'],
                       desc='the dimensions of the image data')

    # Reset settings to defaults.
    reset_defaults = Button(desc='if probe data is reset to defaults')

    # Name of rescaled scalar to generate.
    rescaled_scalar_name = Str('probe_us_array')

    input_info = PipelineInfo(datasets=['image_data'],
                              attribute_types=['any'],
                              attributes=['any'])

    output_info = PipelineInfo(datasets=['image_data'],
                               attribute_types=['any'],
                               attributes=['any'])

    ########################################
    # Private traits.

    # A trait to prevent static handlers from firing unnecessarily.
    _event_handled = Bool(False)

    ########################################
    # View related traits.

    view = View(Group(Item(name='dimensions',
                           enabled_when='allow_changes'
                           ),
                      Item(name='spacing',
                           enabled_when='allow_changes'),
                      Item(name='rescale_scalars'),
                      Item(name='reset_defaults',
                           show_label=False),
                      ),
                resizable=True
                      )


    ######################################################################
    # `Filter` interface.
    ######################################################################
    def setup_pipeline(self):
        """Creates the pipeline."""
        self.configure_input_data(self.filter, self.probe_data)

    def update_pipeline(self):
        """Connect and update the pipeline."""
        inputs = self.inputs
        if len(inputs) == 0:
            return

        fil = self.filter
        self.configure_source_data(fil, inputs[0].outputs[0])
        reset = False
        if self.dimensions.sum() == 0:
            reset = True
        self._setup_probe_data(reset)
        fil.update()
        self._rescale_scalars_changed(self.rescale_scalars)
        self._set_outputs([fil.output])

    ######################################################################
    # Non-public interface.
    ######################################################################
    def _setup_probe_data(self, reset=False):
        pd = self.probe_data
        input = self.inputs[0].outputs[0]
        if input.is_a('vtkImageData'):
            self.allow_changes = False
            self.set(spacing=input.spacing,
                     dimensions=input.dimensions)
            pd.set(origin=input.origin,
                   dimensions=input.dimensions,
                   spacing=input.spacing)
            pd.update()
        elif reset:
            self.allow_changes = True
            b = numpy.array(input.bounds)
            pd.origin = b[::2]
            l = b[1::2] - b[::2]
            tot_len = sum(l)
            npnt = pow(input.number_of_points, 1./3.) + 0.5
            fac = 3.0*npnt/tot_len
            dims = (l*fac).astype(int) + 1
            extent = (0, dims[0] -1, 0, dims[1] -1, 0, dims[2] -1)
            if tvtk_common.is_old_pipeline():
                pd.set(extent=extent,
                       update_extent=extent,
                       whole_extent=extent,
                       dimensions=dims)
            else:
                pd.set(extent=extent,
                       dimensions=dims)

            max_dim = dims.max()
            dims = (dims-1).clip(min=1, max=max_dim+1)
            l = l.clip(min=1e-3, max=l.max()+1.0)
            pd.spacing = l/dims
            self._event_handled = True
            self.set(spacing = pd.spacing,
                     dimensions=pd.dimensions)
            self._event_handled = False


    def _rescale_scalars_changed(self, value):
        out = self.filter.output
        pd = out.point_data
        sc = pd.scalars
        if sc is None:
            # no input scalars
            return

        if not value:
            orig_sc = self.inputs[0].outputs[0].point_data.scalars
            if sc.is_a('vtkUnsignedShortArray') and \
               sc.name == self.rescaled_scalar_name:
                pd.set_active_scalars(orig_sc.name)
                pd.update()
                self.pipeline_changed = True
                self.render()

            return

        s_min, s_max = sc.range
        # checking to see if input array is constant.
        avg = (s_max + s_min)*0.5
        diff = 1
        if (s_max > avg) and (avg > s_min):
            diff = s_max - s_min

        arr = (sc.to_array() - s_min)*65535.0/diff
        uc = tvtk.UnsignedShortArray(name=self.rescaled_scalar_name)
        uc.from_array(arr)
        pd.add_array(uc)
        pd.set_active_scalars(self.rescaled_scalar_name)
        pd.update()
        self.pipeline_changed = True
        self.render()

    def _dimensions_changed(self, value):
        if not self.allow_changes or self._event_handled:
            return

        max_d = value.max()
        dims = (value-1).clip(min=1, max=max_d)
        b = numpy.array(self.inputs[0].outputs[0].bounds)
        l = b[1::2] - b[::2]
        self.spacing = l/dims
        self._update_probe()

    def _spacing_changed(self, value):
        if not self.allow_changes or self._event_handled:
            return
        b = numpy.array(self.inputs[0].outputs[0].bounds)
        l = b[1::2] - b[::2]
        dims = (l/value + 0.5).astype(int) + 1
        # Recalculate space because of rounding.
        maxd = dims.max()
        dims1 = (dims -1).clip(min=1, max=maxd)
        sp = l/dims1
        self._event_handled = True
        self.set(spacing = sp, dimensions=dims)
        self._event_handled = False
        self._update_probe ()

    def _update_probe(self):
        pd = self.probe_data
        dims = self.dimensions
        spacing = self.spacing
        extent = (0, dims[0] -1, 0, dims[1] -1, 0, dims[2] -1)
        if tvtk_common.is_old_pipeline():
            pd.set(extent=extent,
                   update_extent=extent,
                   whole_extent=extent,
                   dimensions=dims,
                   spacing=spacing)
        else:
            pd.set(extent=extent,
                   dimensions=dims,
                   spacing=spacing)
        pd.modified()
        fil = self.filter
        w = fil.global_warning_display
        fil.global_warning_display = False
        fil.remove_all_inputs()
        self.configure_input_data(fil, pd)
        fil.update_whole_extent()
        fil.update()
        self._rescale_scalars_changed(self.rescale_scalars)
        fil.global_warning_display = w
        self.data_changed = True

    def _reset_defaults_fired(self):
        self._setup_probe_data(reset=True)
        self._rescale_scalars_changed(self.rescale_scalars)


########NEW FILE########
__FILENAME__ = mask_points
# Author: Prabhu Ramachandran <prabhu_r at users dot sf dot net>
# Copyright (c) 2006, Enthought, Inc.
# License: BSD Style.

# Enthought library imports.
from traits.api import Instance
from tvtk.api import tvtk

# Local imports
from mayavi.filters.filter_base import FilterBase
from mayavi.core.pipeline_info import PipelineInfo


######################################################################
# `MaskPoints` class.
######################################################################
class MaskPoints(FilterBase):

    """Selectively passes the input points downstream.  This can be
    used to subsample the input points.  Note that this does not pass
    geometry data, this means all grid information is lost.
    """

    # The version of this class.  Used for persistence.
    __version__ = 0

    # The actual TVTK filter that this class manages.
    filter = Instance(tvtk.MaskPoints, args=(), allow_none=False, record=True)

    input_info = PipelineInfo(datasets=['any'],
                              attribute_types=['any'],
                              attributes=['any'])

    output_info = PipelineInfo(datasets=['poly_data'],
                               attribute_types=['any'],
                               attributes=['any'])

    ######################################################################
    # `Filter` interface.
    ######################################################################
    def update_pipeline(self):
        # FIXME: This is needed, for with VTK-5.10 (for sure), the filter
        # allocates memory for maximum_number_of_points which is impossibly
        # large,  so we set it to the number of points in the input
        # for safety.
        self.filter.maximum_number_of_points = \
            self._find_number_of_points_in_input()
        super(MaskPoints, self).update_pipeline()

    ######################################################################
    # Non-public interface.
    ######################################################################
    def _find_number_of_points_in_input(self):
        inp = self.inputs[0].outputs[0]
        if hasattr(inp, 'update'):
            inp.update()
        return inp.number_of_points

########NEW FILE########
__FILENAME__ = metadata
"""
Metadata for all filters.
"""
# Author: Prabhu Ramachandran <prabhu@aero.iitb.ac.in>
# Copyright (c) 2008, Prabhu Ramachandran Enthought, Inc.
# License: BSD Style.

# Local imports.
from mayavi.core.metadata import FilterMetadata
from mayavi.core.pipeline_info import PipelineInfo

BASE = 'mayavi.filters'

################################################################################
# Factory functions.
################################################################################
def make_user_defined_filter():
    from mayavi.filters.user_defined import UserDefined
    f = UserDefined()
    f.setup_filter()
    return f


################################################################################
# Metadata.

cell_derivatives_filter = FilterMetadata(
    id            = "CellDerivativesFilter",
    menu_name          = "&CellDerivatives",
    class_name = BASE + '.cell_derivatives.CellDerivatives',
    tooltip = "Calculate derivatives of input point/vector data and output these as cell data",
    desc = "Calculate derivatives of input point/vector data and output these as cell data",
    help = "Calculate derivatives of input point/vector data and output these as cell data",
    input_info = PipelineInfo(datasets=['any'],
                              attribute_types=['any'],
                              attributes=['any']),
    output_info = PipelineInfo(datasets=['any'],
                               attribute_types=['any'],
                               attributes=['any'])
)

cell_to_point_data_filter = FilterMetadata(
    id            = "CellToPointDataFilter",
    menu_name          = "&CellToPointData",
    class_name = BASE + '.cell_to_point_data.CellToPointData',
    tooltip = "Convert cell data to point data for the active data",
    desc = "Convert cell data to point data for the active data",
    help = "Convert cell data to point data for the active data",
    input_info = PipelineInfo(datasets=['any'],
                              attribute_types=['cell'],
                              attributes=['any']),
    output_info = PipelineInfo(datasets=['any'],
                               attribute_types=['any'],
                               attributes=['any'])
)

clip_filter = FilterMetadata(
    id            = "DataSetClipperFilter",
    menu_name          = "&DataSet Clipper",
    class_name = BASE + '.data_set_clipper.DataSetClipper',
    tooltip = "Clip the input dataset",
    desc = "Clip the input dataset",
    help = "Clip the input dataset",
    input_info = PipelineInfo(datasets=['any'],
                              attribute_types=['any'],
                              attributes=['any']),
    output_info = PipelineInfo(datasets=['unstructured_grid'],
                               attribute_types=['any'],
                               attributes=['any'])
)


contour_filter = FilterMetadata(
    id            = "ContourFilter",
    menu_name          = "&Contour",
    class_name = BASE + '.contour.Contour',
    tooltip = "Compute contours of the input dataset",
    desc = "Compute contours of the input dataset",
    help = "Compute contours of the input dataset",
    input_info = PipelineInfo(datasets=['any'],
                              attribute_types=['point'],
                              attributes=['any']),
    output_info = PipelineInfo(datasets=['any'],
                               attribute_types=['any'],
                               attributes=['any'])
)


cut_plane_filter = FilterMetadata(
    id            = "CutPlaneFilter",
    menu_name          = "&CutPlane",
    class_name = BASE + '.cut_plane.CutPlane',
    tooltip = "Slice the input dataset with a cut plane",
    desc = "Slice the input dataset with a cut plane",
    help = "Slice the input dataset with a cut plane",
    input_info = PipelineInfo(datasets=['any'],
                              attribute_types=['any'],
                              attributes=['any']),
    output_info = PipelineInfo(datasets=['poly_data'],
                               attribute_types=['any'],
                               attributes=['any'])
)

decimatepro_filter = FilterMetadata(
    id            = "DecimateProFilter",
    menu_name          = "&DecimatePro",
    class_name = BASE + '.decimatepro.DecimatePro',
    tooltip = "Simpilies a mesh using the DecimatePro filter",
    desc = "Simpilies a mesh using the DecimatePro filter",
    help = "Simpilies a mesh using the DecimatePro filter",
    input_info = PipelineInfo(datasets=['poly_data'],
                              attribute_types=['any'],
                              attributes=['any']),
    output_info = PipelineInfo(datasets=['poly_data'],
                               attribute_types=['any'],
                               attributes=['any'])
)

delaunay2d_filter = FilterMetadata(
    id            = "Delaunay2DFilter",
    menu_name          = "&Delaunay2D",
    class_name = BASE + '.delaunay2d.Delaunay2D',
    tooltip = "Perform a 2D Delaunay triangulation for the given data",
    desc = "Perform a 2D Delaunay triangulation for the given data",
    help = "Perform a 2D Delaunay triangulation for the given data",
    input_info = PipelineInfo(datasets=['structured_grid', 'poly_data',
                                        'unstructured_grid'],
                              attribute_types=['any'],
                              attributes=['any']),
    output_info = PipelineInfo(datasets=['poly_data'],
                               attribute_types=['any'],
                               attributes=['any'])
)

delaunay3d_filter = FilterMetadata(
    id            = "Delaunay3DFilter",
    menu_name          = "Delaunay&3D",
    class_name = BASE + '.delaunay3d.Delaunay3D',
    tooltip = "Perform a 3D Delaunay triangulation for the given data",
    desc = "Perform a 3D Delaunay triangulation for the given data",
    help = "Perform a 3D Delaunay triangulation for the given data",
    input_info = PipelineInfo(datasets=['structured_grid', 'poly_data',
                                        'unstructured_grid'],
                              attribute_types=['any'],
                              attributes=['any']),
    output_info = PipelineInfo(datasets=['unstructured_grid'],
                               attribute_types=['any'],
                               attributes=['any'])
)

elevation_filter = FilterMetadata(
    id            = "ElevationFilter",
    menu_name          = "Elevation Filter",
    class_name = BASE + '.elevation_filter.ElevationFilter',
    tooltip = "Creates scalar data from the elevation along a direction",
    desc = "Creates scalar data from the elevation along a direction",
    help = "Creates scalar data from the elevation along a direction",
    input_info = PipelineInfo(datasets=['any'],
                              attribute_types=['any'],
                              attributes=['any']),
    output_info = PipelineInfo(datasets=['any'],
                               attribute_types=['any'],
                               attributes=['any'])
)

extract_edges_filter = FilterMetadata(
    id            = "ExtractEdgesFilter",
    menu_name          = "Extract Edges",
    class_name = BASE + '.extract_edges.ExtractEdges',
    tooltip = "Turns edges into lines.",
    desc = "Turns edges into lines.",
    help = "Turns edges into lines.",
    input_info = PipelineInfo(datasets=['any'],
                              attribute_types=['any'],
                              attributes=['any']),
    output_info = PipelineInfo(datasets=['poly_data'],
                               attribute_types=['any'],
                               attributes=['any'])
)

extract_grid_filter = FilterMetadata(
    id            = "ExtractGridFilter",
    menu_name          = "Extract &Grid",
    class_name = BASE + '.extract_grid.ExtractGrid',
    tooltip = "Extract/subsample part of any structured grid",
    desc = "Extract/subsample part of any structured grid",
    help = "Extract/subsample part of any structured grid",
    input_info = PipelineInfo(datasets=['image_data',
                                        'rectilinear_grid',
                                        'structured_grid'],
                              attribute_types=['any'],
                              attributes=['any']),
    output_info = PipelineInfo(datasets=['image_data',
                                         'rectilinear_grid',
                                         'structured_grid'],
                               attribute_types=['any'],
                               attributes=['any'])
)

extract_tensor_components_filter = FilterMetadata(
    id            = "ExtractTensorComponentsFilter",
    menu_name          = "Extract &Tensor Components",
    class_name = BASE + '.extract_tensor_components.ExtractTensorComponents',
    tooltip = "Extract tensor components from tensor data",
    desc = "Extract tensor components from tensor data",
    help = "Extract tensor components from tensor data",
    input_info = PipelineInfo(datasets=['any'],
                              attribute_types=['any'],
                              attributes=['tensors']),
    output_info = PipelineInfo(datasets=['any'],
                               attribute_types=['any'],
                               attributes=['any'])
)

extract_unstructured_grid_filter = FilterMetadata(
    id            = "ExtractUnstructuredGridFilter",
    menu_name          = "Extract &Unstructured Grid",
    class_name = BASE + '.extract_unstructured_grid.ExtractUnstructuredGrid',
    tooltip = "Extract part of an unstructured grid",
    desc = "Extract part of an unstructured grid",
    help = "Extract part of an unstructured grid",
    input_info = PipelineInfo(datasets=['unstructured_grid'],
                              attribute_types=['any'],
                              attributes=['any']),
    output_info = PipelineInfo(datasets=['unstructured_grid'],
                               attribute_types=['any'],
                               attributes=['any'])
)

extract_vector_norm_filter = FilterMetadata(
    id            = "ExtractVectorNormFilter",
    menu_name          = "Extract Vector &Norm",
    class_name = BASE + '.extract_vector_norm.ExtractVectorNorm',
    tooltip = "Compute the vector norm for the current vector data",
    desc = "Compute the vector norm for the current vector data",
    help = "Compute the vector norm for the current vector data",
    input_info = PipelineInfo(datasets=['any'],
                              attribute_types=['any'],
                              attributes=['vectors']),
    output_info = PipelineInfo(datasets=['any'],
                               attribute_types=['any'],
                               attributes=['any'])
)

extract_vector_components_filter = FilterMetadata(
    id            = "ExtractVectorComponentsFilter",
    menu_name          = "Extract &Vector Components",
    class_name = BASE + '.extract_vector_components.ExtractVectorComponents',
    tooltip = "Extract vector components from vector data",
    desc = "Extract vector components from vector data",
    help = "Extract vector components from vector data",
    input_info = PipelineInfo(datasets=['any'],
                              attribute_types=['any'],
                              attributes=['vectors']),
    output_info = PipelineInfo(datasets=['any'],
                               attribute_types=['any'],
                               attributes=['any'])
)

gaussian_splatter_filter = FilterMetadata(
    id            = "GaussianSplatterFilter",
    menu_name          = "Gaussian Splatter",
    class_name = BASE + '.gaussian_splatter.GaussianSplatter',
    tooltip = "Builds a structured set of points from a cloud of points, the local density defining the scalar",
    desc = "Builds a structured set of points from a cloud of points, the local density defining the scalar",
    help = """Builds a structured set of points from a cloud of points,
    the local density defining the scalar.  It is essentially equivalent
    to a 3D Gaussian kernel density estimate.""",
    input_info = PipelineInfo(datasets=['any'],
                              attribute_types=['any'],
                              attributes=['any']),
    output_info = PipelineInfo(datasets=['image_data'],
                               attribute_types=['any'],
                               attributes=['any'])
)

greedy_terrain_decimation_filter = FilterMetadata(
    id            = "GreedyTerrainDecimationFilter",
    menu_name          = "Greedy Terrain Decimation",
    class_name = BASE + '.greedy_terrain_decimation.GreedyTerrainDecimation',
    tooltip = "Simplifies image data and performs a triangulation",
    desc = "Simplifies image data and performs a triangulation",
    help = "Simplifies image data and performs a triangulation",
    input_info = PipelineInfo(datasets=['any'],
                              attribute_types=['any'],
                              attributes=['any']),
    output_info = PipelineInfo(datasets=['poly_data'],
                               attribute_types=['any'],
                               attributes=['any'])
)

image_change_information_filter = FilterMetadata(
    id            = "ImageChangeInformationFilter",
    menu_name          = "Change &ImageData information",
    class_name = BASE + '.image_change_information.ImageChangeInformation',
    tooltip = "Change the origin, spacing and extents of an image dataset",
    desc = "Change the origin, spacing and extents of an image dataset",
    help = "Change the origin, spacing and extents of an image dataset",
    input_info = PipelineInfo(datasets=['image_data'],
                              attribute_types=['any'],
                              attributes=['any']),
    output_info = PipelineInfo(datasets=['image_data'],
                               attribute_types=['any'],
                               attributes=['any'])
)

image_data_probe_filter = FilterMetadata(
    id            = "ImageDataProbeFilter",
    menu_name          = "&Probe data onto image data",
    class_name = BASE + '.image_data_probe.ImageDataProbe',
    tooltip = "Samples arbitrary datasets onto an image dataset (cube of data)",
    desc = "Samples arbitrary datasets onto an image dataset (cube of data)",
    help = "Samples arbitrary datasets onto an image dataset (cube of data)",
    input_info = PipelineInfo(datasets=['any'],
                              attribute_types=['any'],
                              attributes=['any']),
    output_info = PipelineInfo(datasets=['image_data'],
                               attribute_types=['any'],
                               attributes=['any'])
)

mask_points_filter = FilterMetadata(
    id            = "MaskPointsFilter",
    menu_name          = "&Mask Points",
    class_name = BASE + '.mask_points.MaskPoints',
    tooltip = "Mask the input points in the data",
    desc = "Mask the input points in the data",
    help = "Mask the input points in the data",
    input_info = PipelineInfo(datasets=['any'],
                              attribute_types=['any'],
                              attributes=['any']),
    output_info = PipelineInfo(datasets=['poly_data'],
                               attribute_types=['any'],
                               attributes=['any'])
)

point_to_cell_data_filter = FilterMetadata(
    id            = "PointToCellDataFilter",
    menu_name          = "&PointToCellData",
    class_name = BASE + '.point_to_cell_data.PointToCellData',
    tooltip = "Convert point data to cell data for the active data",
    desc = "Convert point data to cell data for the active data",
    help = "Convert point data to cell data for the active data",
    input_info = PipelineInfo(datasets=['any'],
                              attribute_types=['point'],
                              attributes=['any']),
    output_info = PipelineInfo(datasets=['any'],
                               attribute_types=['cell'],
                               attributes=['any'])
)

poly_data_normals_filter = FilterMetadata(
    id            = "PolyDataNormalsFilter",
    menu_name          = "Compute &Normals",
    class_name = BASE + '.poly_data_normals.PolyDataNormals',
    tooltip = "Compute normals and smooth the appearance",
    desc = "Compute normals and smooth the appearance",
    help = "Compute normals and smooth the appearance",
    input_info = PipelineInfo(datasets=['poly_data'],
                              attribute_types=['any'],
                              attributes=['any']),
    output_info = PipelineInfo(datasets=['poly_data'],
                               attribute_types=['any'],
                               attributes=['any'])
)

quadric_decimation_filter = FilterMetadata(
    id            = "QuadricDecimationFilter",
    menu_name          = "Quadric Decimation",
    class_name = BASE + '.quadric_decimation.QuadricDecimation',
    tooltip = "Simplifies a triangular mesh",
    desc = "Simplifies a triangular mesh",
    help = "Simplifies a triangular mesh",
    input_info = PipelineInfo(datasets=['poly_data'],
                              attribute_types=['any'],
                              attributes=['any']),
    output_info = PipelineInfo(datasets=['poly_data'],
                               attribute_types=['any'],
                               attributes=['any'])
)

select_output_filter = FilterMetadata(
    id            = "SelectOutputFilter",
    menu_name          = "&Select Output",
    class_name = BASE + '.select_output.SelectOutput',
    tooltip = "Choose the output of the source that should be used",
    desc = "Choose the output of the source that should be used",
    help = "Choose the output of the source that should be used",
    input_info = PipelineInfo(datasets=['any'],
                              attribute_types=['any'],
                              attributes=['any']),
    output_info = PipelineInfo(datasets=['any'],
                               attribute_types=['any'],
                               attributes=['any'])
)

set_active_attribute_filter = FilterMetadata(
    id            = "SetActiveAttributeFilter",
    menu_name          = "&SetActiveAttribute",
    class_name = BASE + '.set_active_attribute.SetActiveAttribute',
    tooltip = "Set the active attribute (scalar/vector/tensor) to use",
    desc = "Set the active attribute (scalar/vector/tensor) to use",
    help = "Set the active attribute (scalar/vector/tensor) to use",
    input_info = PipelineInfo(datasets=['any'],
                              attribute_types=['any'],
                              attributes=['any']),
    output_info = PipelineInfo(datasets=['any'],
                               attribute_types=['any'],
                               attributes=['any'])
)

stripper = FilterMetadata(
    id            = "Stripper",
    menu_name          = "Stripper",
    class_name = BASE + '.stripper.Stripper',
    tooltip = "Regularizes surfaces by creating triangle strips",
    desc =    "Regularizes surfaces by creating triangle strips",
    help =    "Regularizes surfaces by creating triangle strips",
    input_info = PipelineInfo(datasets=['poly_data'],
                              attribute_types=['any'],
                              attributes=['any']),
    output_info = PipelineInfo(datasets=['poly_data'],
                               attribute_types=['any'],
                               attributes=['any'])
)

transform_data_filter = FilterMetadata(
    id            = "TransformDataFilter",
    menu_name          = "T&ransform Data",
    class_name = BASE + '.transform_data.TransformData',
    tooltip = "Transform (rotate/translate/scale) non ImageData datasets",
    desc = "Transform (rotate/translate/scale) non ImageData datasets",
    help = "Transform (rotate/translate/scale) non ImageData datasets",
    input_info = PipelineInfo(datasets=['poly_data',
                                        'structured_grid',
                                        'unstructured_grid'],
                              attribute_types=['any'],
                              attributes=['any']),
    output_info = PipelineInfo(datasets=['poly_data',
                                         'structured_grid',
                                         'unstructured_grid'],
                               attribute_types=['any'],
                               attributes=['any'])
)

threshold_filter = FilterMetadata(
    id            = "ThresholdFilter",
    menu_name          = "&Threshold",
    class_name = BASE + '.threshold.Threshold',
    tooltip = "Threshold input data based on scalar values",
    desc = "Threshold input data based on scalar values",
    help = "Threshold input data based on scalar values",
    input_info = PipelineInfo(datasets=['any'],
                              attribute_types=['any'],
                              attributes=['any']),
    output_info = PipelineInfo(datasets=['poly_data',
                                         'unstructured_grid'],
                               attribute_types=['any'],
                               attributes=['any'])
)

triangle_filter = FilterMetadata(
    id            = "TriangleFilterFilter",
    menu_name          = "TriangleFilter",
    class_name = BASE + '.triangle_filter.TriangleFilter',
    tooltip = "Convert input polygons and triangle strips to triangles",
    desc = "Convert input polygons and triangle strips to triangles",
    help = "Convert input polygons and triangle strips to triangles",
    input_info = PipelineInfo(datasets=['poly_data'],
                              attribute_types=['any'],
                              attributes=['any']),
    output_info = PipelineInfo(datasets=['poly_data'],
                               attribute_types=['any'],
                               attributes=['any'])
)

tube_filter = FilterMetadata(
    id            = "TubeFilter",
    menu_name          = "Tu&be",
    class_name = BASE + '.tube.Tube',
    tooltip = "Turns lines into tubes",
    desc = "Turns lines into tubes",
    help = "Turns lines into tubes",
    input_info = PipelineInfo(datasets=['poly_data'],
                              attribute_types=['any'],
                              attributes=['any']),
    output_info = PipelineInfo(datasets=['poly_data'],
                               attribute_types=['any'],
                               attributes=['any'])
)

user_defined_filter = FilterMetadata(
    id            = "UserDefinedFilter",
    menu_name          = "&UserDefined",
    factory = make_user_defined_filter,
    tooltip = "Create a UserDefined filter (will popup a selection dialog)",
    desc = "Create a UserDefined filter (will popup a selection dialog)",
    help = "Create a UserDefined filter (will popup a selection dialog)",
    input_info = PipelineInfo(datasets=['any'],
                              attribute_types=['any'],
                              attributes=['any']),
    output_info = PipelineInfo(datasets=['any'],
                               attribute_types=['any'],
                               attributes=['any'])
)

vorticity_filter = FilterMetadata(
    id            = "VorticityFilter",
    menu_name          = "&Vorticity",
    class_name = BASE + '.vorticity.Vorticity',
    tooltip = "Calculate the vorticity (curl) of input vector field",
    desc = "Calculate the vorticity (curl) of input vector field",
    help = "Calculate the vorticity (curl) of input vector field",
    input_info = PipelineInfo(datasets=['any'],
                              attribute_types=['any'],
                              attributes=['vectors']),
    output_info = PipelineInfo(datasets=['any'],
                               attribute_types=['any'],
                               attributes=['any'])
)

warp_scalar_filter = FilterMetadata(
    id            = "WarpScalarFilter",
    menu_name          = "Warp S&calar",
    class_name = BASE + '.warp_scalar.WarpScalar',
    tooltip = "Move points of data along normals by the scalar data",
    desc = "Move points of data along normals by the scalar data",
    help = "Move points of data along normals by the scalar data",
    input_info = PipelineInfo(datasets=['any'],
                              attribute_types=['any'],
                              attributes=['scalars']),
    output_info = PipelineInfo(datasets=['any'],
                               attribute_types=['any'],
                               attributes=['any'])
)

warp_vector_filter = FilterMetadata(
    id            = "WarpVectorFilter",
    menu_name          = "Warp &Vector",
    class_name = BASE + '.warp_vector.WarpVector',
    tooltip = "Move points of data along the vector data at point",
    desc = "Move points of data along the vector data at point",
    help = "Move points of data along the vector data at point",
    input_info = PipelineInfo(datasets=['any'],
                              attribute_types=['any'],
                              attributes=['vectors']),
    output_info = PipelineInfo(datasets=['any'],
                               attribute_types=['any'],
                               attributes=['any'])
)

# Now collect all the filters for the mayavi registry.
filters = [cell_derivatives_filter,
           cell_to_point_data_filter,
           clip_filter,
           contour_filter,
           cut_plane_filter,
           decimatepro_filter,
           delaunay2d_filter,
           delaunay3d_filter,
           elevation_filter,
           extract_edges_filter,
           extract_grid_filter,
           extract_tensor_components_filter,
           extract_unstructured_grid_filter,
           extract_vector_norm_filter,
           extract_vector_components_filter,
           gaussian_splatter_filter,
           greedy_terrain_decimation_filter,
           image_change_information_filter,
           image_data_probe_filter,
           mask_points_filter,
           point_to_cell_data_filter,
           poly_data_normals_filter,
           quadric_decimation_filter,
           select_output_filter,
           set_active_attribute_filter,
           stripper,
           transform_data_filter,
           threshold_filter,
           triangle_filter,
           tube_filter,
           user_defined_filter,
           vorticity_filter,
           warp_scalar_filter,
           warp_vector_filter,
        ]

########NEW FILE########
__FILENAME__ = optional
"""The  Optional filter is one which may be turned on and off and wraps
around any mayavi filter or component.
"""
# Author: Prabhu Ramachandran <prabhu [at] aero . iitb . ac . in>
# Copyright (c) 2008,  Prabhu Ramachandran
# License: BSD Style.

from mayavi.filters.wrapper import Wrapper

################################################################################
# `Optional` class.
################################################################################
class Optional(Wrapper):
    """
    This class wraps around any mayavi filter or component and allows a
    user to turn it on or off.
    """

    # This filter should allow us to turn on/off the filter.
    _show_enabled = True


########NEW FILE########
__FILENAME__ = point_to_cell_data
# Author: Prabhu Ramachandran <prabhu_r at users dot sf dot net>
# Copyright (c) 2006, Enthought, Inc.
# License: BSD Style.

# Enthought library imports.
from traits.api import Instance
from tvtk.api import tvtk

# Local imports
from mayavi.filters.cell_to_point_data import CellToPointData
from mayavi.core.pipeline_info import PipelineInfo


######################################################################
# `PointToCellData` class.
######################################################################
class PointToCellData(CellToPointData):
    # The version of this class.  Used for persistence.
    __version__ = 0

    # The actual TVTK filter that this class manages.
    filter = Instance(tvtk.PointDataToCellData,
                            args=(), kw={'pass_point_data':1},
                            allow_none=False, record=True)

    input_info = PipelineInfo(datasets=['any'],
                              attribute_types=['point'],
                              attributes=['any'])

    output_info = PipelineInfo(datasets=['any'],
                               attribute_types=['cell'],
                               attributes=['any'])


########NEW FILE########
__FILENAME__ = poly_data_filter_base
# Author: Gael Varoquaux <gael _dot_ varoquaux _at_ normalesup _dot_ org>
# Copyright (c) 2008, Enthought, Inc.
# License: BSD Style.

# Local imports
from mayavi.filters.filter_base import FilterBase
from mayavi.components.common import convert_to_poly_data


######################################################################
# `PolyDataFilterBase` class.
######################################################################
class PolyDataFilterBase(FilterBase):

    """ Base class for a filter requiring polydata input. Converts the
        source to polydata.
    """

    ######################################################################
    # `Filter` interface.
    ######################################################################
    def update_pipeline(self):
        # Do nothing if there is no input.
        inputs = self.inputs
        if len(inputs) == 0:
            return

        # By default we set the input to the first output of the first
        # input.
        fil = self.filter
        self.configure_input_data(fil, 
                                  convert_to_poly_data(inputs[0].outputs[0]))
        fil.update()
        self._set_outputs([fil.output])

########NEW FILE########
__FILENAME__ = poly_data_normals
# Author: Prabhu Ramachandran <prabhu_r at users dot sf dot net>
# Copyright (c) 2006, Enthought, Inc.
# License: BSD Style.

# Enthought library imports.
from traits.api import Instance
from tvtk.api import tvtk

# Local imports
from mayavi.filters.poly_data_filter_base import \
        PolyDataFilterBase
from mayavi.core.pipeline_info import PipelineInfo


######################################################################
# `PolyDataNormals` class.
######################################################################
class PolyDataNormals(PolyDataFilterBase):

    """Computes normals from input data.  This gives meshes a smoother
    appearance.  This should work for any input dataset.
    """

    # The version of this class.  Used for persistence.
    __version__ = 0

    # The actual TVTK filter that this class manages.
    filter = Instance(tvtk.PolyDataNormals, args=(), allow_none=False, record=True)

    input_info = PipelineInfo(datasets=['poly_data'],
                              attribute_types=['any'],
                              attributes=['any'])

    output_info = PipelineInfo(datasets=['poly_data'],
                               attribute_types=['any'],
                               attributes=['any'])


########NEW FILE########
__FILENAME__ = quadric_decimation
# Author: Gael Varoquaux <gael _dot_ varoquaux _at_ normalesup _dot_ org>
# Copyright (c) 2008, Enthought, Inc.
# License: BSD Style.

# Enthought library imports.
from traits.api import Instance
from tvtk.api import tvtk

# Local imports
from mayavi.filters.poly_data_filter_base import \
        PolyDataFilterBase
from mayavi.core.pipeline_info import PipelineInfo


######################################################################
# `QuadricDecimation` class.
######################################################################
class QuadricDecimation(PolyDataFilterBase):

    """ Simplifies triangles of a mesh """

    # The version of this class.  Used for persistence.
    __version__ = 0

    # The actual TVTK filter that this class manages.
    filter = Instance(tvtk.QuadricDecimation, args=(), allow_none=False, record=True)

    input_info = PipelineInfo(datasets=['poly_data'],
                              attribute_types=['any'],
                              attributes=['any'])

    output_info = PipelineInfo(datasets=['poly_data'],
                               attribute_types=['any'],
                               attributes=['any'])


########NEW FILE########
__FILENAME__ = select_output
"""Filter that allows a user to select one among several of the outputs
of a given input.  This is typically very useful for a multi-block data
source.  """

# Author: Prabhu Ramachandran <prabhu [at] aero . iitb . ac . in>
# Copyright (c) 2008,  Prabhu Ramachandran
# License: BSD Style.

# Enthought library imports.
from traits.api import Int, Range
from traitsui.api import View, Group, Item

from mayavi.core.filter import Filter
from mayavi.core.pipeline_info import PipelineInfo


################################################################################
# `SelectOutput` class.
################################################################################
class SelectOutput(Filter):
    """
    This filter lets a user select one among several of the outputs of a
    given input.  This is typically very useful for a multi-block data
    source.
    """

    # The output index in the input to choose from.
    output_index = Range(value=0,
                         enter_set=True,
                         auto_set=False,
                         low='_min_index',
                         high='_max_index')

    input_info = PipelineInfo(datasets=['any'],
                              attribute_types=['any'],
                              attributes=['any'])

    output_info = PipelineInfo(datasets=['any'],
                               attribute_types=['any'],
                               attributes=['any'])

    # The minimum output index of our input.
    _min_index = Int(0, desc='the minimum output index')
    # The maximum output index of our input.
    _max_index = Int(0, desc='the maximum output index')

    ########################################
    # Traits View.

    view = View(Group(Item('output_index',
                           enabled_when='_max_index > 0')),
                resizable=True)

    ######################################################################
    # `object` interface.
    def __get_pure_state__(self):
        d = super(SelectOutput, self).__get_pure_state__()
        d['output_index'] = self.output_index
        return d

    def __set_pure_state__(self, state):
        super(SelectOutput, self).__set_pure_state__(state)
        # Force an update of the output index -- if not this doesn't
        # change.
        self._output_index_changed(state.output_index)

    ######################################################################
    # `Filter` interface.
    def update_pipeline(self):
        # Do nothing if there is no input.
        inputs = self.inputs
        if len(inputs) == 0:
            return

        # Set the maximum index.
        self._max_index = len(inputs[0].outputs) - 1
        self._output_index_changed(self.output_index)

    def update_data(self):
        # Propagate the event.
        self.data_changed = True

    ######################################################################
    # Trait handlers.
    def _output_index_changed(self, value):
        """Static trait handler."""
        if value > self._max_index:
            self.output_index = self._max_index
        elif value < self._min_index:
            self.output_index = self._min_index
        else:
            self._set_outputs([self.inputs[0].outputs[value]])
            s = self.scene
            if s is not None:
                s.renderer.reset_camera_clipping_range()
                s.render()


########NEW FILE########
__FILENAME__ = set_active_attribute
# Author: Prabhu Ramachandran <prabhu [at] aero . iitb . ac . in>
# Copyright (c) 2008,  Enthought, Inc.
# License: BSD Style.

# Enthought library imports.
from traits.api import Instance, List, Str, Bool
from traitsui.api import View, Group, Item
from tvtk.api import tvtk
from tvtk.common import is_old_pipeline

# Local imports.
from mayavi.core.pipeline_info import PipelineInfo
from mayavi.core.filter import Filter
from mayavi.core.trait_defs import DEnum
from mayavi.sources.vtk_xml_file_reader import get_all_attributes

################################################################################
# `SetActiveAttribute` class.
################################################################################
class SetActiveAttribute(Filter):
    """
    This filter lets a user set the active data attribute (scalars,
    vectors and tensors) on a VTK dataset.  This is particularly useful
    if you need to do something like compute contours of one scalar on
    the contour of another scalar.
    """

    # Note: most of this code is from the XMLFileDataReader.

    # The version of this class.  Used for persistence.
    __version__ = 0

    input_info = PipelineInfo(datasets=['any'],
                              attribute_types=['any'],
                              attributes=['any'])

    output_info = PipelineInfo(datasets=['any'],
                               attribute_types=['any'],
                               attributes=['any'])

    ########################################
    # Dynamic traits: These traits are dynamic and are automatically
    # updated depending on the contents of the file.

    # The active point scalar name.  An empty string indicates that
    # the attribute is "deactivated".  This is useful when you have
    # both point and cell attributes and want to use cell data by
    # default.
    point_scalars_name = DEnum(values_name='_point_scalars_list',
                               desc='scalar point data attribute to use')
    # The active point vector name.
    point_vectors_name = DEnum(values_name='_point_vectors_list',
                               desc='vectors point data attribute to use')
    # The active point tensor name.
    point_tensors_name = DEnum(values_name='_point_tensors_list',
                               desc='tensor point data attribute to use')

    # The active cell scalar name.
    cell_scalars_name = DEnum(values_name='_cell_scalars_list',
                               desc='scalar cell data attribute to use')
    # The active cell vector name.
    cell_vectors_name = DEnum(values_name='_cell_vectors_list',
                               desc='vectors cell data attribute to use')
    # The active cell tensor name.
    cell_tensors_name = DEnum(values_name='_cell_tensors_list',
                               desc='tensor cell data attribute to use')
    ########################################

    # Our view.
    view = View(Group(Item(name='point_scalars_name'),
                      Item(name='point_vectors_name'),
                      Item(name='point_tensors_name'),
                      Item(name='cell_scalars_name'),
                      Item(name='cell_vectors_name'),
                      Item(name='cell_tensors_name'),
                      ))

    ########################################
    # Private traits.

    # These private traits store the list of available data
    # attributes.  The non-private traits use these lists internally.
    _point_scalars_list = List(Str)
    _point_vectors_list = List(Str)
    _point_tensors_list = List(Str)
    _cell_scalars_list = List(Str)
    _cell_vectors_list = List(Str)
    _cell_tensors_list = List(Str)

    # This filter allows us to change the attributes of the data
    # object and will ensure that the pipeline is properly taken care
    # of.  Directly setting the array in the VTK object will not do
    # this.
    _assign_attribute = Instance(tvtk.AssignAttribute, args=(),
                                 allow_none=False)

    # Toggles if this is the first time this object has been used.
    _first = Bool(True)

    ######################################################################
    # `object` interface
    ######################################################################
    def __get_pure_state__(self):
        d = super(SetActiveAttribute, self).__get_pure_state__()
        for name in ('_assign_attribute', '_first'):
            d.pop(name, None)
        # Pickle the 'point_scalars_name' etc. since these are
        # properties and not in __dict__.
        attr = {}
        for name in ('point_scalars', 'point_vectors',
                     'point_tensors', 'cell_scalars',
                     'cell_vectors', 'cell_tensors'):
            d.pop('_' + name + '_list', None)
            d.pop('_' + name + '_name', None)
            x = name + '_name'
            attr[x] = getattr(self, x)
        d.update(attr)

        return d

    ######################################################################
    # `Filter` interface.
    ######################################################################
    def update_data(self):
        self.data_changed = True

    def update_pipeline(self):
        if len(self.inputs) == 0 or len(self.inputs[0].outputs) == 0:
            return

        aa = self._assign_attribute
        self.configure_connection(aa, self.inputs[0])
        self._update()
        self._set_outputs([aa.output])

    ######################################################################
    # Non-public interface.
    ######################################################################
    def _update(self):
        """Updates the traits for the fields that are available in the
        input data.
        """
        if len(self.inputs) == 0 or len(self.inputs[0].outputs) == 0:
            return

        input = self.inputs[0].get_output_object()
        if self._first and is_old_pipeline():
            # Force all attributes to be defined and computed
            input.update()
        pnt_attr, cell_attr = get_all_attributes(input)

        self._setup_data_traits(cell_attr, 'cell')
        self._setup_data_traits(pnt_attr, 'point')
        if self._first:
            self._first = False

    def _setup_data_traits(self, attributes, d_type):
        """Given the dict of the attributes from the
        `get_all_attributes` function and the data type (point/cell)
        data this will setup the object and the data.
        """
        attrs = ['scalars', 'vectors', 'tensors']
        aa = self._assign_attribute
        input = self.inputs[0].outputs[0]
        data = getattr(input, '%s_data'%d_type)
        for attr in attrs:
            values = attributes[attr]
            values.append('')
            setattr(self, '_%s_%s_list'%(d_type, attr), values)
            if len(values) > 1:
                default = getattr(self, '%s_%s_name'%(d_type, attr))
                if self._first and len(default) == 0:
                    default = values[0]
                getattr(data, 'set_active_%s'%attr)(default)
                aa.assign(default, attr.upper(),
                          d_type.upper() +'_DATA')
                aa.update()
                kw = {'%s_%s_name'%(d_type, attr): default,
                      'trait_change_notify': False}
                self.set(**kw)

    def _set_data_name(self, data_type, attr_type, value):
        if value is None or len(self.inputs) == 0:
            return

        input = self.inputs[0].outputs[0]
        if len(value) == 0:
            # If the value is empty then we deactivate that attribute.
            d = getattr(input, attr_type + '_data')
            method = getattr(d, 'set_active_%s'%data_type)
            method(None)
            self.data_changed = True
            return

        aa = self._assign_attribute
        data = None
        if attr_type == 'point':
            data = input.point_data
        elif attr_type == 'cell':
            data = input.cell_data

        method = getattr(data, 'set_active_%s'%data_type)
        method(value)
        aa.assign(value, data_type.upper(), attr_type.upper() +'_DATA')
        aa.update()
        # Fire an event, so the changes propagate.
        self.data_changed = True

    def _point_scalars_name_changed(self, value):
        self._set_data_name('scalars', 'point', value)

    def _point_vectors_name_changed(self, value):
        self._set_data_name('vectors', 'point', value)

    def _point_tensors_name_changed(self, value):
        self._set_data_name('tensors', 'point', value)

    def _cell_scalars_name_changed(self, value):
        self._set_data_name('scalars', 'cell', value)

    def _cell_vectors_name_changed(self, value):
        self._set_data_name('vectors', 'cell', value)

    def _cell_tensors_name_changed(self, value):
        self._set_data_name('tensors', 'cell', value)


########NEW FILE########
__FILENAME__ = stripper
# Author: Gael Varoquaux <gael.varoquaux@normalesup.org>
# Copyright (c) 2008, Enthought, Inc.
# License: BSD Style.

# Enthought library imports.
from traits.api import Instance
from tvtk.api import tvtk

# Local imports
from mayavi.filters.filter_base import FilterBase
from mayavi.core.pipeline_info import PipelineInfo


######################################################################
# `Stripper` class.
######################################################################
class Stripper(FilterBase):

    """ Create triangle strips and/or poly-lines. Useful for regularizing
        broken up surfaces, such as those created by the Tube
        filter.
    """

    # The version of this class.  Used for persistence.
    __version__ = 0

    # The actual TVTK filter that this class manages.
    filter = Instance(tvtk.Stripper, args=(), allow_none=False, record=True)

    input_info = PipelineInfo(datasets=['poly_data'],
                              attribute_types=['any'],
                              attributes=['any'])

    output_info = PipelineInfo(datasets=['poly_data'],
                               attribute_types=['any'],
                               attributes=['any'])


########NEW FILE########
__FILENAME__ = threshold
"""A simple filter that thresholds on input data.

"""
# Author: Prabhu Ramachandran <prabhu_r@users.sf.net>
# Copyright (c) 2005, Enthought, Inc.
# Author: Gael Varoquaux <gael.varoquaux@normalesup.org>
# Copyright (c) 2010, Enthought, Inc.
# License: BSD Style.

import numpy as np

# Enthought library imports.
from traits.api import Instance, Range, Float, Bool, \
                                 Property, Enum
from traitsui.api import View, Group, Item
from tvtk.api import tvtk

# Local imports
from mayavi.core.filter import Filter
from mayavi.core.pipeline_info import PipelineInfo


######################################################################
# `Threshold` class.
######################################################################
class Threshold(Filter):

    # The version of this class.  Used for persistence.
    __version__ = 0

    # The threshold filter used.
    threshold_filter = Property(Instance(tvtk.Object, allow_none=False), record=True)

    # The filter type to use, specifies if the cells or the points are
    # cells filtered via a threshold.
    filter_type = Enum('cells', 'points',
                       desc='if thresholding is done on cells or points')

    # Lower threshold (this is a dynamic trait that is changed when
    # input data changes).
    lower_threshold = Range(value=-1.0e20,
                            low='_data_min',
                            high='_data_max',
                            enter_set=True,
                            auto_set=False,
                            desc='the lower threshold of the filter')

    # Upper threshold (this is a dynamic trait that is changed when
    # input data changes).
    upper_threshold = Range(value=1.0e20,
                            low='_data_min',
                            high='_data_max',
                            enter_set=True,
                            auto_set=False,
                            desc='the upper threshold of the filter')

    # Automatically reset the lower threshold when the upstream data
    # changes.
    auto_reset_lower = Bool(True, desc='if the lower threshold is '
                            'automatically reset when upstream '
                            'data changes')

    # Automatically reset the upper threshold when the upstream data
    # changes.
    auto_reset_upper = Bool(True, desc='if the upper threshold is '
                            'automatically reset when upstream '
                            'data changes')

    input_info = PipelineInfo(datasets=['any'],
                              attribute_types=['any'],
                              attributes=['any'])

    output_info = PipelineInfo(datasets=['poly_data',
                                         'unstructured_grid'],
                               attribute_types=['any'],
                               attributes=['any'])

    # Our view.
    view = View(Group(Group(Item(name='filter_type'),
                            Item(name='lower_threshold'),
                            Item(name='auto_reset_lower'),
                            Item(name='upper_threshold'),
                            Item(name='auto_reset_upper')),
                      Item(name='_'),
                      Group(Item(name='threshold_filter',
                                 show_label=False,
                                 visible_when='object.filter_type == "cells"',
                                 style='custom', resizable=True)),
                      ),
                resizable=True
                )

    ########################################
    # Private traits.

    # These traits are used to set the limits for the thresholding.
    # They store the minimum and maximum values of the input data.
    _data_min = Float(-1e20)
    _data_max = Float(1e20)

    # The threshold filter for cell based filtering
    _threshold = Instance(tvtk.Threshold, args=(), allow_none=False)

    # The threshold filter for points based filtering.
    _threshold_points = Instance(tvtk.ThresholdPoints, args=(), allow_none=False)

    # Internal data to
    _first = Bool(True)

    ######################################################################
    # `object` interface.
    ######################################################################
    def __get_pure_state__(self):
        d = super(Threshold, self).__get_pure_state__()
        # These traits are dynamically created.
        for name in ('_first', '_data_min', '_data_max'):
            d.pop(name, None)

        return d

    ######################################################################
    # `Filter` interface.
    ######################################################################
    def setup_pipeline(self):
        attrs = ['all_scalars', 'attribute_mode',
                 'component_mode', 'selected_component']
        self._threshold.on_trait_change(self._threshold_filter_edited,
                                        attrs)

    def update_pipeline(self):
        """Override this method so that it *updates* the tvtk pipeline
        when data upstream is known to have changed.

        This method is invoked (automatically) when the input fires a
        `pipeline_changed` event.
        """
        if len(self.inputs) == 0:
            return

        # By default we set the input to the first output of the first
        # input.
        fil = self.threshold_filter
        self.configure_connection(fil, self.inputs[0])
        self._update_ranges()
        self._set_outputs([self.threshold_filter.output])

    def update_data(self):
        """Override this method to do what is necessary when upstream
        data changes.

        This method is invoked (automatically) when any of the inputs
        sends a `data_changed` event.
        """
        if len(self.inputs) == 0:
            return

        self._update_ranges()

        # Propagate the data_changed event.
        self.data_changed = True

    ######################################################################
    # Non-public interface
    ######################################################################
    def _lower_threshold_changed(self, new_value):
        fil = self.threshold_filter
        fil.threshold_between(new_value, self.upper_threshold)
        fil.update()
        self.data_changed = True

    def _upper_threshold_changed(self, new_value):
        fil = self.threshold_filter
        fil.threshold_between(self.lower_threshold, new_value)
        fil.update()
        self.data_changed = True

    def _update_ranges(self):
        """Updates the ranges of the input.
        """
        data_range = self._get_data_range()
        if len(data_range) > 0:
            dr = data_range
            if self._first:
                self._data_min, self._data_max = dr
                self.set(lower_threshold = dr[0], trait_change_notify=False)
                self.upper_threshold = dr[1]
                self._first = False
            else:
                if self.auto_reset_lower:
                    self._data_min = dr[0]
                    notify = not self.auto_reset_upper
                    self.set(lower_threshold = dr[0],
                             trait_change_notify=notify)
                if self.auto_reset_upper:
                    self._data_max = dr[1]
                    self.upper_threshold = dr[1]

    def _get_data_range(self):
        """Returns the range of the input scalar data."""
        input = self.inputs[0].outputs[0]
        data_range = []
        ps = input.point_data.scalars
        cs = input.cell_data.scalars

        # FIXME: need to be able to handle cell and point data
        # together.
        if ps is not None:
            data_range = list(ps.range)
            if np.isnan(data_range[0]):
                data_range[0] = float(np.nanmin(ps.to_array()))
            if np.isnan(data_range[1]):
                data_range[1] = float(np.nanmax(ps.to_array()))
        elif cs is not None:
            data_range = cs.range
            if np.isnan(data_range[0]):
                data_range[0] = float(np.nanmin(cs.to_array()))
            if np.isnan(data_range[1]):
                data_range[1] = float(np.nanmax(cs.to_array()))
        return data_range

    def _auto_reset_lower_changed(self, value):
        if len(self.inputs) == 0:
            return
        if value:
            dr = self._get_data_range()
            self._data_min = dr[0]
            self.lower_threshold = dr[0]

    def _auto_reset_upper_changed(self, value):
        if len(self.inputs) == 0:
            return
        if value:
            dr = self._get_data_range()
            self._data_max = dr[1]
            self.upper_threshold = dr[1]

    def _get_threshold_filter(self):
        if self.filter_type == 'cells':
            return self._threshold
        else:
            return self._threshold_points

    def _filter_type_changed(self, value):
        if value == 'cells':
            old = self._threshold_points
            new = self._threshold
        else:
            old = self._threshold
            new = self._threshold_points
        self.trait_property_changed('threshold_filter', old, new)

    def _threshold_filter_changed(self, old, new):
        if len(self.inputs) == 0:
            return
        fil = new
        self.configure_connection(fil, self.inputs[0])
        fil.threshold_between(self.lower_threshold,
                              self.upper_threshold)
        fil.update()
        self._set_outputs([fil.output])

    def _threshold_filter_edited(self):
        self.threshold_filter.update()
        self.data_changed = True

########NEW FILE########
__FILENAME__ = transform_data
"""Performs a linear transformation to input data using a
tvtk.BoxWidget.  This does not work with
ImageData/StructuredPoints/RectilinearGrid.

"""
# Author: Prabhu Ramachandran <prabhu@aero.iitb.ac.in>
# Copyright (c) 2006,  Enthought, Inc.
# License: BSD Style.

# Standard library imports.
import cPickle

# Enthought library imports.
from traits.api import Instance, Property, Bool, Int, \
     Trait, TraitMap, Button
from traitsui.api import View, Group, Item
from tvtk.api import tvtk
from apptools.persistence import state_pickler

# Local imports
from mayavi.core.filter import Filter
from mayavi.core.common import error
from mayavi.core.pipeline_info import PipelineInfo


######################################################################
# `TransformData` class.
######################################################################
class TransformData(Filter):
    """Performs a linear transformation to input data using a
    tvtk.BoxWidget.  This does not work with
    ImageData/StructuredPoints/RectilinearGrid.
    """

    # The version of this class.  Used for persistence.
    __version__ = 0

    # The widget that we use to perform the transformation.
    widget = Instance(tvtk.ThreeDWidget, allow_none=False, record=True)

    # The filter we manage.
    filter = Instance(tvtk.Object, allow_none=False)

    # The transform.
    transform = Property

    # Update the data immediately or at the end of the interaction.
    update_mode = Trait('semi-interactive',
                        TraitMap({'interactive':'InteractionEvent',
                                  'semi-interactive': 'EndInteractionEvent'}),
                        desc='speed at which the data should be updated')

    input_info = PipelineInfo(datasets=['poly_data',
                                        'structured_grid',
                                        'unstructured_grid'],
                              attribute_types=['any'],
                              attributes=['any'])

    output_info = PipelineInfo(datasets=['poly_data',
                                         'structured_grid',
                                         'unstructured_grid'],
                               attribute_types=['any'],
                               attributes=['any'])

    ########################################
    # View related code.

    # Reset the transformation.
    reset = Button("Reset Transformation")

    view = View(Group(Group(Item('update_mode'),
                            ),
                      Group(Item('reset'),
                            Item(name='widget', style='custom', resizable=True),
                            show_labels=False
                            )
                      ),
                resizable=True
                )

    ########################################
    # Private traits.
    _transform = Instance(tvtk.Transform, allow_none=False)

    _first = Bool(True)

    _observer_id = Int(-1)

    ######################################################################
    # `object` interface.
    ######################################################################
    def __get_pure_state__(self):
        d = super(TransformData, self).__get_pure_state__()
        for name in ('_first', '_observer_id'):
            d.pop(name, None)
        d['matrix'] = cPickle.dumps(self._transform.matrix)
        return d

    def __set_pure_state__(self, state):
        mat = state.pop('matrix')
        super(TransformData, self).__set_pure_state__(state)
        state_pickler.set_state(self, state)
        self._transform.set_matrix(cPickle.loads(mat))
        self.widget.set_transform(self._transform)

    ######################################################################
    # `Filter` interface.
    ######################################################################
    def setup_pipeline(self):
        self._transform = tvtk.Transform()
        self.widget = tvtk.BoxWidget(place_factor=1.1)
        self.filter = tvtk.TransformFilter()
        super(TransformData, self).setup_pipeline()

    def update_pipeline(self):
        # Do nothing if there is no input.
        inputs = self.inputs
        if len(inputs) == 0:
            return

        inp = inputs[0].outputs[0]
        if inp.is_a('vtkImageData') or inp.is_a('vtkRectilinearGrid'):
            error('Transformation not supported for '\
                  'ImageData/StructuredPoints/RectilinearGrid')
            return

        # Set the input for the widget and place it if this hasn't
        # been done before.
        w = self.widget
        self.configure_input_data(w, inp)
        if self._first:
            w.place_widget()
            self._first = False

        # By default we set the input to the first output of the first
        # input.
        fil = self.filter
        self.configure_connection(fil, inputs[0])
        fil.transform = self._transform
        fil.update()
        self._set_outputs([fil.output])

    def update_data(self):
        # Do nothing if there is no input.
        if len(self.inputs) == 0:
            return

        self.filter.update()
        # Propagate the data_changed event.
        self.data_changed = True

    ######################################################################
    # Non-public interface.
    ######################################################################
    def _get_transform(self):
        return self._transform

    def _on_interaction_event(self, obj, event):
        tfm = self._transform
        self.widget.get_transform(tfm)
        f = self.filter
        f.transform = tfm
        f.update()
        self.render()
        recorder = self.recorder
        if recorder is not None:
            state = {}
            state['elements'] = tfm.matrix.__getstate__()['elements']
            name = recorder.get_script_id(self)
            recorder.record('%s.transform.matrix.__setstate__(%s)'\
                            %(name, state))
            recorder.record('%s.widget.set_transform(%s.transform)'\
                            %(name, name))
            recorder.record('%s.filter.update()'%name)

    def _widget_changed(self, old, new):
        if old is not None:
            old.on_trait_change(self.render, remove=True)
            old.remove_observer(self._observer_id)
            self.widgets.remove(old)
        new.on_trait_change(self.render)
        self._observer_id = new.add_observer(self.update_mode_,
                                             self._on_interaction_event)
        self.widgets.append(new)
        if len(self.inputs) > 0:
            self.configure_input_data(new, self.inputs[0].outputs[0])

    def _filter_changed(self, old, new):
        if old is not None:
            old.on_trait_change(self.render, remove=True)
        new.on_trait_change(self.render)
        transform = self.transform
        if transform is not None:
            new.transform = transform
        if len(self.inputs) > 0:
            self.configure_connection(new, self.inputs[0])
            self.outputs = [new.output]

    def _reset_fired(self):
        self._transform.identity()
        self.widget.place_widget()
        self.filter.update()
        self.render()

    def _update_mode_changed(self, old, new):
        w = self.widget
        if w is not None:
            w.remove_observer(self._observer_id)
            self._observer_id = w.add_observer(self.update_mode_,
                                               self._on_interaction_event)
            self.render()

########NEW FILE########
__FILENAME__ = triangle_filter
# Author: Robert Kern <robert.kern@enthought.com>
# Copyright (c) 2008, Enthought, Inc.
# License: BSD Style.

# Enthought library imports.
from traits.api import Instance
from tvtk.api import tvtk

# Local imports
from mayavi.filters.filter_base import FilterBase
from mayavi.core.pipeline_info import PipelineInfo


######################################################################
# `TriangleFilter` class.
######################################################################
class TriangleFilter(FilterBase):

    """ Converts input polygons and triangle strips to triangles using
    the tvtk.TriangleFilter class.  This is useful when you have a
    downstream filter that only processes triangles."""

    # The version of this class.  Used for persistence.
    __version__ = 0

    # The actual TVTK filter that this class manages.
    filter = Instance(tvtk.TriangleFilter, args=(), allow_none=False, record=True)

    input_info = PipelineInfo(datasets=['any'],
                              attribute_types=['any'],
                              attributes=['any'])

    output_info = PipelineInfo(datasets=['poly_data',
                                         'unstructured_grid'],
                               attribute_types=['any'],
                               attributes=['any'])


########NEW FILE########
__FILENAME__ = tube
# Author: Gael Varoquaux <gael.varoquaux@normalesup.org>
# Copyright (c) 2007, Enthought, Inc.
# License: BSD Style.

# Enthought library imports.
from traits.api import Instance
from tvtk.api import tvtk

# Local imports
from mayavi.filters.filter_base import FilterBase
from mayavi.core.pipeline_info import PipelineInfo


######################################################################
# `Tube` class.
######################################################################
class Tube(FilterBase):

    """Turns lines into tubes.
    """

    # The version of this class.  Used for persistence.
    __version__ = 0

    # The actual TVTK filter that this class manages.
    filter = Instance(tvtk.TubeFilter, args=(), allow_none=False, record=True)

    input_info = PipelineInfo(datasets=['poly_data'],
                              attribute_types=['any'],
                              attributes=['any'])

    output_info = PipelineInfo(datasets=['poly_data'],
                               attribute_types=['any'],
                               attributes=['any'])


########NEW FILE########
__FILENAME__ = user_defined
# Author: Prabhu Ramachandran <prabhu [at] aero . iitb . ac . in>
# Copyright (c) 2008,  Enthought, Inc.
# License: BSD Style.

# Enthought library imports.
from tvtk.tools.tvtk_doc import TVTKFilterChooser, TVTK_FILTERS

# Local imports.
from mayavi.filters.filter_base import FilterBase
from mayavi.core.common import handle_children_state, error
from mayavi.core.pipeline_info import PipelineInfo


################################################################################
# `UserDefined` class.
################################################################################
class UserDefined(FilterBase):

    """
    This filter lets the user define their own filter
    dynamically/interactively.  It is like `FilterBase` but allows a
    user to specify the class without writing any code.
    """

    # The version of this class.  Used for persistence.
    __version__ = 0

    input_info = PipelineInfo(datasets=['any'],
                              attribute_types=['any'],
                              attributes=['any'])

    output_info = PipelineInfo(datasets=['any'],
                               attribute_types=['any'],
                               attributes=['any'])

    ######################################################################
    # `object` interface.
    ######################################################################
    def __set_pure_state__(self, state):
        # Create and set the filter.
        children = [f for f in [self.filter] if f is not None]
        handle_children_state(children, [state.filter])
        self.filter = children[0]
        self.update_pipeline()
        # Restore our state.
        super(UserDefined, self).__set_pure_state__(state)

    ######################################################################
    # `UserDefined` interface.
    ######################################################################
    def setup_filter(self):
        """Setup the filter if none has been set or check it if it
        already has been."""
        obj = self.filter
        if not self._check_object(obj):
            if obj is not None:
                cname = obj.__class__.__name__
                error('Invalid filter %s chosen!  Try again!'%cname)
            obj = self._choose_filter()
            self.filter = obj

    ######################################################################
    # Non-public interface.
    ######################################################################
    def _choose_filter(self):
        chooser = TVTKFilterChooser()
        chooser.edit_traits(kind='livemodal')
        obj = chooser.object
        if obj is None:
            error('Invalid filter chosen!  Try again!')
        return obj

    def _check_object(self, obj):
        if obj is None:
            return False
        if obj.__class__.__name__ in TVTK_FILTERS:
            return True
        return False

    def _filter_changed(self, old, new):
        self.name = 'UserDefined:%s'%new.__class__.__name__
        super(UserDefined, self)._filter_changed(old, new)


########NEW FILE########
__FILENAME__ = vorticity
# Author: Prabhu Ramachandran <prabhu [at] aero . iitb . ac . in>
# Copyright (c) 2008, Enthought, Inc.
# License: BSD Style.

# Standard library imports.

# Enthought library imports.
from traits.api import Instance
from traitsui.api import View, Group, Item

# Local imports.
from mayavi.core.pipeline_info import PipelineInfo
from mayavi.filters.optional import Optional
from mayavi.filters.collection import Collection
from mayavi.filters.cell_derivatives import CellDerivatives
from mayavi.filters.cell_to_point_data import CellToPointData
from mayavi.filters.extract_vector_norm import ExtractVectorNorm
from mayavi.filters.extract_vector_components import ExtractVectorComponents


################################################################################
# `Vorticity` class.
################################################################################
class Vorticity(Optional):
    """
    This filter computes the vorticity of an input vector field.  For
    convenience, the filter allows one to optionally pass-through the
    given input vector field.  The filter also allows the user to show
    the component of the vorticity along a particular cartesian
    co-ordinate axes.  It produces point data on output which is ready
    to visualize.
    """

    # This is used just for the UI.
    vorticity_component = Instance(Optional, record=True)

    input_info = PipelineInfo(datasets=['any'],
                              attribute_types=['any'],
                              attributes=['vectors'])

    output_info = PipelineInfo(datasets=['any'],
                               attribute_types=['any'],
                               attributes=['any'])

    ######################################################################
    # `object` interface.
    ######################################################################
    def __get_pure_state__(self):
        d = super(Vorticity, self).__get_pure_state__()
        for name in ('vorticity_component'):
            d.pop(name, None)
        return d

    ######################################################################
    # `HasTraits` interface.
    ######################################################################
    def default_traits_view(self):
        view = View(Group(Group(Item(name='enabled',
                               label='Compute Vorticity',
                               )),
                          Group(Item(name='vorticity_component',
                                   style='custom',
                                   resizable=True,
                                   show_label=False),
                              ))
                        )
        return view


    ######################################################################
    # `Filter` interface.
    ######################################################################
    def setup_pipeline(self):
        """Setup our pipeline"""
        cd = CellDerivatives()
        cd.filter.vector_mode = 'compute_vorticity'
        c2d = CellToPointData()
        evn = ExtractVectorNorm()
        evc = ExtractVectorComponents()
        o = Optional(filter=evc, label_text='Extract Component of Vorticity',
                     enabled=False)
        self.vorticity_component = o
        c = Collection(filters=[cd, c2d, evn, o], name='Vorticity')
        self.filter = c


########NEW FILE########
__FILENAME__ = warp_scalar
# Author: Prabhu Ramachandran <prabhu_r at users dot sf dot net>
# Copyright (c) 2006, Enthought, Inc.
# License: BSD Style.

# Enthought library imports.
from traits.api import Instance
from tvtk.api import tvtk

# Local imports
from mayavi.filters.poly_data_normals import PolyDataNormals
from mayavi.core.pipeline_info import PipelineInfo


######################################################################
# `WarpScalar` class.
######################################################################
class WarpScalar(PolyDataNormals):

    """Warps the input data along a particular direction (either the
    normals or a specified direction) with a scale specified by the
    local scalar value.  Useful for making carpet plots.
    """

    # The version of this class.  Used for persistence.
    __version__ = 0

    # The actual TVTK filter that this class manages.
    filter = Instance(tvtk.WarpScalar, args=(), allow_none=False, record=True)

    input_info = PipelineInfo(datasets=['any'],
                              attribute_types=['any'],
                              attributes=['scalars'])

    output_info = PipelineInfo(datasets=['any'],
                               attribute_types=['any'],
                               attributes=['any'])


########NEW FILE########
__FILENAME__ = warp_vector
# Author: Prabhu Ramachandran <prabhu_r at users dot sf dot net>
# Copyright (c) 2006, Enthought, Inc.
# License: BSD Style.

# Enthought library imports.
from traits.api import Instance
from tvtk.api import tvtk

# Local imports
from mayavi.filters.poly_data_normals import PolyDataNormals
from mayavi.core.pipeline_info import PipelineInfo


######################################################################
# `WarpVector` class.
######################################################################
class WarpVector(PolyDataNormals):

    """Warps the input data along a the point vector attribute scaled
    as per a scale factor.  Useful for showing flow profiles or
    displacements.
    """

    # The version of this class.  Used for persistence.
    __version__ = 0

    # The actual TVTK filter that this class manages.
    filter = Instance(tvtk.WarpVector, args=(), allow_none=False, record=True)

    input_info = PipelineInfo(datasets=['any'],
                              attribute_types=['any'],
                              attributes=['vectors'])

    output_info = PipelineInfo(datasets=['any'],
                               attribute_types=['any'],
                               attributes=['any'])


########NEW FILE########
__FILENAME__ = wrapper
"""The `Wrapper` filter is one which wraps around any mayavi filter or
component.  By default it does not allow the user to set it on and off
from the UI, for that see the `Optional` filter.
"""

# Author: Prabhu Ramachandran <prabhu [at] aero . iitb . ac . in>
# Copyright (c) 2008,  Enthought, Inc.
# License: BSD Style.

# Enthought library imports.
from traits.api import Instance, Bool, Str
from traitsui.api import Item, Group, View
from apptools.persistence import state_pickler

# Local imports.
from mayavi.core.pipeline_base import PipelineBase
from mayavi.core.filter import Filter
from mayavi.core.common import handle_children_state

################################################################################
# `Wrapper` class.
################################################################################
class Wrapper(Filter):
    """
    The `Wrapper` filter is one which wraps around any mayavi filter or
    component.  By default it does not allow the user to set it on and
    off from the UI, for that see the `Optional` filter.
    """

    # The filter we wrap.
    filter = Instance(PipelineBase, allow_none=False, record=True)

    # The text to show in the UI of form "Enable SomeFilter"
    label_text = Str('Enable Filter')

    # Are we enabled or not.
    enabled = Bool(True, desc='if the filter is enabled or not')

    ########################################
    # Private traits.

    # Should we show enabled in the UI or not.  This defaults to False,
    # the `Optional` filter merely changes this to True.  This trait is
    # not meant for interactive changing.
    _show_enabled = Bool(False)

    ######################################################################
    # `object` interface.
    ######################################################################
    def __set_pure_state__(self, state):
        # Create and set the filter.
        children = [f for f in [self.filter] if f is not None]
        handle_children_state(children, [state.filter])
        self.filter = children[0]
        # Restore our state.
        super(Wrapper, self).__set_pure_state__(state)

    ######################################################################
    # HasTraits interface.
    ######################################################################
    def default_traits_view(self):
        """Returns the default traits view for this object."""
        if self._show_enabled:
            view = View(Group(Group(Item(name='enabled',
                                         label=self.label_text)),
                            Group(Item(name='filter',
                                       style='custom',
                                       enabled_when='enabled',
                                       resizable=True),
                                  show_labels=False)),
                        resizable=True)
        else:
            view = View(Group(Item(name='filter',
                                   style='custom',
                                   enabled_when='enabled',
                                   resizable=True),
                              show_labels=False),
                        resizable=True)

        return view

    ######################################################################
    # `Filter` interface.
    ######################################################################
    def setup_pipeline(self):
        """Setup the pipeline."""
        # Needed because a user may have defined a filter by setting the
        # default value of the trait in the subclass in which case the
        # filter changed handler will never be called leading to
        # problems.
        if self.filter is not None:
            self._setup_events(self.filter)

    def stop(self):
        # There is no need to override start since the wrapped filter is
        # always started automatically in the _enabled_changed handler.
        super(Wrapper, self).stop()
        if self.filter is not None:
            self.filter.stop()

    def update_pipeline(self):
        """This method *updates* the tvtk pipeline when data upstream is
        known to have changed.

        This method is invoked (automatically) when the input fires a
        `pipeline_changed` event.
        """
        self._enabled_changed(self.enabled)
        self.pipeline_changed = True

    def update_data(self):
        """This method does what is necessary when upstream data
        changes.

        This method is invoked (automatically) when any of the inputs
        sends a `data_changed` event.
        """
        # Propagate the data_changed event.
        self.data_changed = True

    ######################################################################
    # Private interface.
    ######################################################################
    def _enabled_changed(self, value):
        """Static traits handler."""
        if len(self.inputs) == 0 or self.filter is None:
            return
        my_input = self.inputs[0]
        filter = self.filter
        if len(filter.name) == 0:
            name = filter.__class__.__name__
        else:
            name = filter.name
        if value and filter is not None:
            filter.inputs = [my_input]
            if not filter.running:
                filter.start()
            self._set_outputs(self.filter.outputs)
        else:
            self._set_outputs(my_input.outputs)
            name += ' (disabled)'
        self.name = name
        self.render()

    def _filter_changed(self, old, new):
        """Static traits handler."""
        if old is not None:
            self._setup_events(old, remove=True)
            old.stop()
        if self.scene is not None:
            new.scene = self.scene
        self._setup_events(new, remove=False)
        self._enabled_changed(self.enabled)

    def _scene_changed(self, old, new):
        """Static traits handler."""
        if self.filter is not None:
            self.filter.scene = new
        super(Wrapper, self)._scene_changed(old, new)

    def _filter_pipeline_changed(self):
        if self.enabled:
            self._set_outputs(self.filter.outputs)

    def _setup_events(self, obj, remove=False):
        obj.on_trait_change(self._filter_pipeline_changed,
                            'pipeline_changed',
                            remove=remove)
        obj.on_trait_change(self.update_data,
                            'data_changed',
                            remove=remove)

    def _visible_changed(self, value):
        self.filter.visible = value
        super(Wrapper, self)._visible_changed(value)


########NEW FILE########
__FILENAME__ = mlab
"""
mlab: a simple scripting interface to Mayavi2 for 3D plotting.

Can be used inside Mayavi2 itself, in "ipython -wthread", or in any
application with the WxWidget mainloop running.
"""

# Author: Prabhu Ramachandran <prabhu_r@users.sf.net>
#         Gael Varoquaux <gael dot varoquaux at normalesup dot org>
# Copyright (c) 2007-2010, Enthought, Inc.
# License: BSD Style.


# Try forcing the use of wx 2.8 before any other import.
import sys
if not 'wx' in sys.modules:
    try:
        from traits.etsconfig.api import ETSConfig
        if ETSConfig.toolkit in ('wx', ''):
            import wxversion
            wxversion.ensureMinimal('2.8')
    except ImportError:
        """ wxversion not installed """


# Mayavi imports
from mayavi.tools.camera import view, roll, yaw, pitch, move
from mayavi.tools.figure import figure, clf, gcf, savefig, \
    draw, sync_camera, close, screenshot
from mayavi.tools.engine_manager import get_engine, show_pipeline, \
        options, set_engine
from mayavi.tools.show import show
from mayavi.tools.animator import animate

def show_engine():
    """ This function is deprecated, please use show_pipeline.
    """
    import warnings
    warnings.warn('The show_engine function is deprecated, please use'
                    'show_pipeline', stacklevel=2)
    return show_pipeline()

from tools.helper_functions import contour3d, test_contour3d, \
    quiver3d, test_quiver3d, test_quiver3d_2d_data, \
    points3d, test_points3d, test_molecule, \
    flow, test_flow, \
    imshow, test_imshow, \
    surf, test_surf, mesh, test_mesh, test_simple_surf, \
    test_mesh_sphere, test_fancy_mesh,\
    contour_surf, test_contour_surf, \
    plot3d, test_plot3d, \
    test_plot3d_anim, test_points3d_anim, test_contour3d_anim,\
    test_simple_surf_anim, test_flow_anim, test_mesh_sphere_anim, \
    triangular_mesh, test_triangular_mesh, barchart, \
    test_barchart, test_mesh_mask_custom_colors


from tools.decorations import colorbar, scalarbar, vectorbar, \
    outline, axes, xlabel, ylabel, zlabel, text, title, \
    orientation_axes, text3d

import tools.pipeline as pipeline

from tools.tools import start_recording, stop_recording

if __name__ == "__main__":
    import numpy

    n_mer, n_long = 6, 11
    pi = numpy.pi
    dphi = pi/1000.0
    phi = numpy.arange(0.0, 2*pi + 0.5*dphi, dphi, 'd')
    mu = phi*n_mer
    x = numpy.cos(mu)*(1+numpy.cos(n_long*mu/n_mer)*0.5)
    y = numpy.sin(mu)*(1+numpy.cos(n_long*mu/n_mer)*0.5)
    z = numpy.sin(n_long*mu/n_mer)*0.5

    pl = plot3d(x, y, z, numpy.sin(mu), tube_radius=0.05, colormap='Spectral')

    colorbar(orientation='vertical')

    t = numpy.linspace(0, 4*numpy.pi, 100)
    cos = numpy.cos
    sin = numpy.sin

    x = sin(2*t)
    y = cos(t)
    z = sin(2*t)
    s = sin(t)

    pts = points3d(x, y, z, s, colormap="YlGnBu", scale_factor=0.1,
            extent=(-0.3,0.3, -0.3, 0.3, -0.2,0.2))

    axes(xlabel='X', ylabel='Y', zlabel='Z')
    outline(pl)

    title('Mayavi rocks', height=0.85)

########NEW FILE########
__FILENAME__ = api
""" Defines the publicly accessible MayaVi2 modules.
"""

# Author: Frederic Petit
# Copyright (c) 2007, Enthought, Inc.
# License: BSD Style.



from axes import Axes
from contour_grid_plane import ContourGridPlane
from custom_grid_plane import CustomGridPlane
from generic_module import GenericModule
from glyph import Glyph
from grid_plane import GridPlane
from hyper_streamline import HyperStreamline
from image_actor import ImageActor
from image_plane_widget import ImagePlaneWidget
from iso_surface import IsoSurface
from labels import Labels
from orientation_axes import OrientationAxes
from outline import Outline
from scalar_cut_plane import ScalarCutPlane
from slice_unstructured_grid import SliceUnstructuredGrid
from streamline import Streamline
from structured_grid_outline import StructuredGridOutline
from surface import Surface
from text import Text
from text3d import Text3D
from tensor_glyph import TensorGlyph
from vector_cut_plane import VectorCutPlane
from vectors import Vectors
from volume import Volume
from warp_vector_cut_plane import WarpVectorCutPlane


########NEW FILE########
__FILENAME__ = axes
"""Draws a simple axes using tvtk.CubeAxesActor2D.
"""
# Author: Prabhu Ramachandran <prabhu_r@users.sf.net>
# Copyright (c) 2005-2006, Enthought, Inc.
# License: BSD Style.

# Enthought library imports.
from traits.api import Instance, Property, true
from traitsui.api import View, Group, HGroup, \
        Item, BooleanEditor
from tvtk.api import tvtk
from apptools.persistence import state_pickler

# Local imports
from mayavi.core.module import Module
from mayavi.core.pipeline_info import PipelineInfo

######################################################################
# `CubeAxesActor2D` class.
######################################################################
class CubeAxesActor2D(tvtk.CubeAxesActor2D):
    """ Just has a different view than the tvtk.CubesAxesActor2D, with an
        additional tick box.
    """

    # Automaticaly fit the bounds of the axes to the data
    use_data_bounds = true

    input_info = PipelineInfo(datasets=['any'],
                              attribute_types=['any'],
                              attributes=['any'])

    ########################################
    # The view of this object.

    traits_view = View(Group(
                        Group(
                            Item('visibility'),
                            HGroup(
                                 Item('x_axis_visibility', label='X axis'),
                                 Item('y_axis_visibility', label='Y axis'),
                                 Item('z_axis_visibility', label='Z axis'),
                                ),
                            show_border=True, label='Visibity'),
                        Group(
                            Item('use_ranges'),
                            HGroup(
                                 Item('ranges', enabled_when='use_ranges'),
                                ),
                            show_border=True),
                        Group(
                            Item('use_data_bounds'),
                            HGroup(
                                 Item('bounds',
                                    enabled_when='not use_data_bounds'),
                                ),
                            show_border=True),
                        Group(
                            Item('x_label'),
                            Item('y_label'),
                            Item('z_label'),
                            Item('label_format'),
                            Item('number_of_labels'),
                            Item('font_factor'),
                            show_border=True),
                        HGroup(Item('show_actual_bounds',
                                label='Use size bigger than screen',
                                editor=BooleanEditor())),
                        Item('fly_mode'),
                        Item('corner_offset'),
                        Item('layer_number'),
                       springy=True,
                      ),
                     scrollable=True,
                     resizable=True,
                     )


######################################################################
# `Axes` class.
######################################################################
class Axes(Module):
    # The version of this class.  Used for persistence.
    __version__ = 0

    # The tvtk axes actor.
    axes = Instance(CubeAxesActor2D, allow_none=False, record=True)

    # The property of the axes (color etc.).
    property = Property(record=True)

    # The title text property of the axes.
    title_text_property = Property(record=True)

    # The label text property of the axes.
    label_text_property = Property(record=True)

    ########################################
    # Private traits.
    _property = Instance(tvtk.Property2D)
    _title_text_property = Instance(tvtk.TextProperty)
    _label_text_property = Instance(tvtk.TextProperty)

    ########################################
    # The view of this object.

    view = View(Group(Item(name='axes', style='custom', resizable=True),
                      label='Axes',
                      show_labels=False),
                Group(Item(name='_property', style='custom',
                           resizable=True),
                      label='Property',
                      show_labels=False),
                Group(Item(name='_title_text_property', style='custom',
                           resizable=True),
                      label='Title Text',
                      show_labels=False),
                Group(Item(name='_label_text_property', style='custom',
                           resizable=True),
                      label='Label Text',
                      show_labels=False),
                scrollable=True, resizable=True,
                width=500, height=600
                )

    ######################################################################
    # `object` interface
    ######################################################################
    def __set_pure_state__(self, state):
        for prop in ['axes', '_property', '_title_text_property',
                     '_label_text_property']:
            obj = getattr(self, prop)
            state_pickler.set_state(obj, state[prop])

    ######################################################################
    # `Module` interface
    ######################################################################
    def setup_pipeline(self):
        """Override this method so that it *creates* the tvtk
        pipeline.

        This method is invoked when the object is initialized via
        `__init__`.  Note that at the time this method is called, the
        tvtk data pipeline will *not* yet be setup.  So upstream data
        will not be available.  The idea is that you simply create the
        basic objects and setup those parts of the pipeline not
        dependent on upstream sources and filters.  You should also
        set the `actors` attribute up at this point.
        """
        # Create the axes and set things up.
        axes = CubeAxesActor2D(number_of_labels= 2,
                                    font_factor=1.5,
                                    fly_mode='outer_edges',
                                    corner_offset=0.0,
                                    scaling=False)
        axes.axis_title_text_property.shadow = False
        axes.axis_label_text_property.shadow = False

        # Set the axes.
        self.axes = axes

    def update_pipeline(self):
        """Override this method so that it *updates* the tvtk pipeline
        when data upstream is known to have changed.

        This method is invoked (automatically) when any of the inputs
        sends a `pipeline_changed` event.
        """
        mm = self.module_manager
        if mm is None or not self.axes.use_data_bounds:
            self.configure_input_data(self.axes, None)
            return
        src = mm.source
        self.configure_input_data(self.axes, src.outputs[0])
        self.pipeline_changed = True

    def update_data(self):
        """Override this method so that it flushes the vtk pipeline if
        that is necessary.

        This method is invoked (automatically) when any of the inputs
        sends a `data_changed` event.
        """
        # Just set data_changed, the component should do the rest.
        self.data_changed = True

    ######################################################################
    # Non-public interface
    ######################################################################
    def _scene_changed(self, old, new):
        super(Axes, self)._scene_changed(old, new)
        self.axes.camera = new.camera
        self._foreground_changed_for_scene(None, new.foreground)

    def _foreground_changed_for_scene(self, old, new):
        # Change the default color for the actor.
        self.property.color = new
        self.label_text_property.color = new
        self.title_text_property.color = new
        self.render()

    def _axes_changed(self, old, new):
        if old is not None:
            for obj in (old, self._property, self._title_text_property,
                        self._label_text_property):
                obj.on_trait_change(self.render, remove=True)
            self.actors.remove(old)
        # Setup the axes.
        scene = self.scene
        if scene is not None:
            new.camera = scene.camera

        # Setup the private traits.
        self._property = new.property
        for prop in ['_title_text_property',
                     '_label_text_property']:
            setattr(self,  prop, getattr(new, 'axis' + prop))
        # The handlers.
        for obj in (new, self._property, self._title_text_property,
                    self._label_text_property):
            obj.on_trait_change(self.render)
        self.actors.append(new)
        if old is not None:
            self.update_pipeline()

    def _get_property(self):
        return self._property

    def _get_title_text_property(self):
        return self._title_text_property

    def _get_label_text_property(self):
        return self._label_text_property

    def _use_data_bounds_changed_for_axes(self):
        """ Updating the pipeline for this module is inexpensive and fits
            the actor to the source (if any). We are using it here.
        """
        self.update_pipeline()


########NEW FILE########
__FILENAME__ = contour_grid_plane
"""A contour grid plane module.  This module lets one take a slice of
input grid data and view contours of the data.  The module only works
for structured points, rectilinear grid and structured grid input.

"""
# Author: Prabhu Ramachandran <prabhu_r@users.sf.net>
# Copyright (c) 2005-2006, Enthought, Inc.
# License: BSD Style.

# Enthought library imports.
from traits.api import Instance, Bool
from traitsui.api import View, Group, Item

# Local imports
from mayavi.core.module import Module
from mayavi.components.grid_plane import GridPlane
from mayavi.components.contour import Contour
from mayavi.components.actor import Actor
from mayavi.core.pipeline_info import PipelineInfo


######################################################################
# `ContourGridPlane` class.
######################################################################
class ContourGridPlane(Module):

    # The version of this class.  Used for persistence.
    __version__ = 0

    # The grid plane component.
    grid_plane = Instance(GridPlane, allow_none=False, record=True)

    # Specifies if contouring is to be done or not.
    enable_contours = Bool(True, desc='if contours are generated')

    # The contour component that contours the data.
    contour = Instance(Contour, allow_none=False, record=True)

    # The actor component that represents the visualization.
    actor = Instance(Actor, allow_none=False, record=True)

    input_info = PipelineInfo(datasets=['image_data',
                                        'structured_grid',
                                        'rectilinear_grid'],
                              attribute_types=['any'],
                              attributes=['any'])

    view = View([Group(Item(name='grid_plane', style='custom'),
                       show_labels=False),
                 Group(Item(name='enable_contours')),
                 Group(Item(name='contour', style='custom',
                            enabled_when='object.enable_contours'),
                       Item(name='actor', style='custom'),
                       show_labels=False)
                 ]
                )

    ######################################################################
    # `Module` interface
    ######################################################################
    def setup_pipeline(self):
        """Override this method so that it *creates* the tvtk
        pipeline.

        This method is invoked when the object is initialized via
        `__init__`.  Note that at the time this method is called, the
        tvtk data pipeline will *not* yet be setup.  So upstream data
        will not be available.  The idea is that you simply create the
        basic objects and setup those parts of the pipeline not
        dependent on upstream sources and filters.  You should also
        set the `actors` attribute up at this point.
        """
        # Create the components
        self.grid_plane = GridPlane()
        self.contour = Contour(auto_contours=True, number_of_contours=10)
        self.actor = Actor()

    def update_pipeline(self):
        """Override this method so that it *updates* the tvtk pipeline
        when data upstream is known to have changed.

        This method is invoked (automatically) when any of the inputs
        sends a `pipeline_changed` event.
        """
        mm = self.module_manager
        if mm is None:
            return

        # Data is available, so set the input for the grid plane.
        self.grid_plane.inputs = [mm.source]

        # This makes sure that any changes made to enable_contours
        # when the module is not running are updated when it is
        # started.
        self._enable_contours_changed(self.enable_contours)
        # Set the LUT for the mapper.
        self.actor.set_lut(mm.scalar_lut_manager.lut)

        self.pipeline_changed = True

    def update_data(self):
        """Override this method so that it flushes the vtk pipeline if
        that is necessary.

        This method is invoked (automatically) when any of the inputs
        sends a `data_changed` event.
        """
        # Just set data_changed, the components should do the rest if
        # they are connected.
        self.data_changed = True

    ######################################################################
    # Non-public methods.
    ######################################################################
    def _filled_contours_changed(self, value):
        """When filled contours are enabled, the mapper should use the
        the cell data, otherwise it should use the default scalar
        mode.
        """
        if value:
            self.actor.mapper.scalar_mode = 'use_cell_data'
        else:
            self.actor.mapper.scalar_mode = 'default'
        self.render()

    def _enable_contours_changed(self, value):
        """Turns on and off the contours."""
        if self.module_manager is None:
            return
        if value:
            self.actor.inputs = [self.contour]
            if self.contour.filled_contours:
                self.actor.mapper.scalar_mode = 'use_cell_data'
        else:
            self.actor.inputs = [self.grid_plane]
            self.actor.mapper.scalar_mode = 'default'
        self.render()

    def _grid_plane_changed(self, old, new):
        cont = self.contour
        if cont is not None:
            cont.inputs = [new]
        self._change_components(old, new)

    def _contour_changed(self, old, new):
        if old is not None:
            old.on_trait_change(self._filled_contours_changed,
                                'filled_contours',
                                remove=True)
        new.on_trait_change(self._filled_contours_changed,
                            'filled_contours')
        # Setup the contours input.
        gp = self.grid_plane
        if gp is not None:
            new.inputs = [gp]

        # Setup the actor.
        actor = self.actor
        if actor is not None:
            actor.inputs = [new]
        self._change_components(old, new)

    def _actor_changed(self, old, new):
        if old is None:
            # First time this is set.
            new.property.set(line_width=2.0)

        # Set the actors scene and input.
        new.scene = self.scene
        cont = self.contour
        if cont is not None:
            new.inputs = [cont]
        self._change_components(old, new)

########NEW FILE########
__FILENAME__ = custom_grid_plane
"""A custom grid plane with a lot more flexibility than
GridPlane.  This also only works for non-unstructured/non-polygonal
datasets.

"""
# Author: Prabhu Ramachandran <prabhu@aero.iitb.ac.in>
# Copyright (c) 2007,  Enthought, Inc.
# License: BSD Style.


# Enthought library imports.
from traits.api import Instance
from traitsui.api import View, Group, Item

# Local imports
from mayavi.components import custom_grid_plane
from mayavi.modules.contour_grid_plane import \
     ContourGridPlane, Contour, Actor


######################################################################
# `CustomGridPlane` class.
######################################################################
class CustomGridPlane(ContourGridPlane):

    grid_plane = Instance(custom_grid_plane.Component,
                          allow_none=False, record=True)

    # Overriding the ContourGridPlane's default view.
    view = View(Group(Item(name='grid_plane', style='custom'),
                      show_labels=False,
                      label='GridPlane'),
                Group(Group(Item(name='enable_contours')),
                      Group(Item(name='contour', style='custom',
                                 enabled_when='object.enable_contours'),
                            show_labels=False,
                            ),
                      label='Contour',
                      ),
                Group(Item(name='actor', style='custom'),
                      label='Actor',
                      show_labels=False)
                )
    ######################################################################
    # `Module` interface
    ######################################################################
    def setup_pipeline(self):
        # Note that we don't call the parent class method here.  This
        # is intentional to avoid problems with the execution of the
        # VTK pipeline.

        # Create the components.
        self.grid_plane = custom_grid_plane.CustomGridPlane()
        self.contour = Contour(auto_contours=True, number_of_contours=10)
        self.actor = Actor()
        self.enable_contours = False
        self.actor.property.point_size = 2

########NEW FILE########
__FILENAME__ = generic_module
"""
Defines a GenericModule which is a collection of mayavi
filters/components put together.  This is very convenient and useful to
create new modules.
"""

# Author: Prabhu Ramachandran <prabhu [at] aero . iitb . ac . in>
# Copyright (c) 2008,  Enthought, Inc.
# License: BSD Style.

# Enthought library imports.
from traits.api import Bool, Enum, Instance
from traitsui.api import Item, Group, View, ListEditor
from apptools.persistence import state_pickler

# Local imports.
from mayavi.core.module import Module
from mayavi.core.common import handle_children_state
from mayavi.components.actor import Actor

################################################################################
# Utility function.
################################################################################
def find_object_given_state(needle, haystack, object):
    """
    Find the object which corrsponds to given state instance (`needle`)
    in the given state (`haystack`) and object representing that
    haystack.

    Parameters
    ----------

    `needle` -- The `State` instance to find
    haystack -- The source State in which we are to find the state
    `object` -- the object corresponding to the `haystack`
    """
    if needle is haystack:
        return object
    if hasattr(object, 'filter'):
        return find_object_given_state(needle,
                                       haystack.filter,
                                       object.filter)
    elif hasattr(object, 'filters'):
        for h, obj in zip(haystack.filters, object.filters):
            r = find_object_given_state(needle, h, obj)
            if r is not None:
                return r
    return None


################################################################################
# `GenericModule` class.
################################################################################
class GenericModule(Module):
    """
    Defines a GenericModule which is a collection of mayavi
    filters/components put together.  This is very convenient and useful
    to create new modules.

    Note that all components including the actor must be passed as a
    list to set the components trait.
    """

    # The *optional* Contour component to which we must listen to if
    # any.  This is needed for modules that use a contour component
    # because when we turn on filled contours the mapper must switch to
    # use cell data.
    contour = Instance('mayavi.components.contour.Contour',
                       allow_none=True)

    # The *optional* Actor component for which the LUT must be set.  If
    # None is specified here, we will attempt to automatically determine
    # it.
    actor = Instance(Actor, allow_none=True)

    # Should we use the scalar LUT or the vector LUT?
    lut_mode = Enum('scalar', 'vector')

    ########################################
    # Private traits.

    # Is the pipeline ready?  Used internally.
    _pipeline_ready = Bool(False)

    ######################################################################
    # `object` interface.
    ######################################################################
    def __get_pure_state__(self):
        # Need to pickle the components.
        d = super(GenericModule, self).__get_pure_state__()
        d['components'] = self.components
        d.pop('_pipeline_ready', None)
        return d

    def __set_pure_state__(self, state):
        # If we are already running, there is a problem since the
        # components will be started automatically in the module's
        # handle_components even though their state is not yet set call
        # so we disable it here and restart it later.
        running = self.running
        self.running = False

        # Remove the actor states since we don't want these unpickled.
        actor_st = state.pop('actor', None)
        contour_st = state.pop('contour', None)
        # Create and set the components.
        handle_children_state(self.components, state.components)
        components = self.components

        # Restore our state using set_state.
        state_pickler.set_state(self, state)

        # Now set our actor and component by finding the right one to get from
        # the state.
        if actor_st is not None:
            for cst, c in zip(state.components, components):
                actor = find_object_given_state(actor_st, cst, c)
                if actor is not None:
                    self.actor = actor
                    break
        if contour_st is not None:
            for cst, c in zip(state.components, components):
                contour = find_object_given_state(contour_st, cst, c)
                if contour is not None:
                    self.contour = contour
                    break
        # Now start all components if needed.
        self._start_components()
        self.running = running

    ######################################################################
    # `HasTraits` interface.
    ######################################################################
    def default_traits_view(self):
        """Returns the default traits view for this object."""
        le = ListEditor(use_notebook=True,
                        deletable=False,
                        export='DockWindowShell',
                        page_name='.name')
        view = View(Group(Item(name='components',
                               style='custom',
                               show_label=False,
                               editor=le,
                               resizable=True),
                              show_labels=False),
                    resizable=True)
        return view

    ######################################################################
    # `Module` interface.
    ######################################################################
    def setup_pipeline(self):
        """Setup the pipeline."""
        # Needed because a user may have setup the components by setting
        # the default value of the trait in the subclass in which case
        # the components_changed handler will never be called leading to
        # problems.
        if len(self.components) > 0 and not self._pipeline_ready:
            self._components_changed([], self.components)

    def update_pipeline(self):
        """This method *updates* the tvtk pipeline when data upstream is
        known to have changed.

        This method is invoked (automatically) when the input fires a
        `pipeline_changed` event.
        """
        mm = self.module_manager
        if mm is None:
            return

        self._setup_pipeline()
        # Propagate the event.
        self.pipeline_changed = True

    def update_data(self):
        """This method does what is necessary when upstream data
        changes.

        This method is invoked (automatically) when any of the inputs
        sends a `data_changed` event.
        """
        # Propagate the data_changed event.
        self.data_changed = True

    ######################################################################
    # Private interface.
    ######################################################################
    def _setup_pipeline(self):
        """Sets up the objects in the pipeline."""
        mm = self.module_manager
        if mm is None or len(self.components) == 0:
            return
        # Our input.
        my_input = mm.source
        components = self.components
        if not self._pipeline_ready:
            # Hook up our first component.
            first = self.components[0]
            first.inputs = [my_input]
            # Hook up the others to each other.
            for i in range(1, len(components)):
                component = components[i]
                component.inputs = [components[i-1]]
            self._pipeline_ready = True
        # Start components.
        self._start_components()
        # Setup the LUT of any actors.
        self._lut_mode_changed(self.lut_mode)

    def _handle_components(self, removed, added):
        super(GenericModule, self)._handle_components(removed, added)
        for component in added:
            if len(component.name) == 0:
                component.name = component.__class__.__name__
            if self.actor is None:
                if isinstance(component, Actor):
                    self.actor = component

        if len(self.components) == 0:
            self.input_info.datasets = ['none']
        else:
            self.input_info.copy_traits(self.components[0].input_info)

        self._pipeline_ready = False
        self._setup_pipeline()

    def _lut_mode_changed(self, value):
        """Static traits listener."""
        mm = self.module_manager
        if mm is None:
            return
        lm = mm.scalar_lut_manager
        if value == 'vector':
            lm = mm.vector_lut_manager

        if self.actor is not None:
            self.actor.set_lut(lm.lut)

    def _actor_changed(self, old, new):
        self._lut_mode_changed(self.lut_mode)

    def _filled_contours_changed_for_contour(self, value):
        """When filled contours are enabled, the mapper should use the
        the cell data, otherwise it should use the default scalar
        mode.
        """
        if self.actor is None:
            return
        if value:
            self.actor.mapper.scalar_mode = 'use_cell_data'
        else:
            self.actor.mapper.scalar_mode = 'default'
        self.render()

    def _start_components(self):
        for component in self.components:
            if len(component.inputs) > 0 and \
               len(component.inputs[0].outputs) > 0:
                component.start()


########NEW FILE########
__FILENAME__ = glyph
"""Displays different types of glyphs oriented and colored as per scalar or vector data at the input points.

"""
# Author: Prabhu Ramachandran <prabhu_r@users.sf.net>
# Copyright (c) 2005, Enthought, Inc.
# License: BSD Style.


# Enthought library imports.
from traits.api import Instance
from traitsui.api import View, Group, Item

# Local imports
from mayavi.core.module import Module
from mayavi.components import glyph
from mayavi.components.actor import Actor
from mayavi.core.pipeline_info import PipelineInfo


######################################################################
# `Glyph` class.
######################################################################
class Glyph(Module):

    # The version of this class.  Used for persistence.
    __version__ = 0

    # The Glyph component.
    glyph = Instance(glyph.Glyph, allow_none=False, record=True)

    # The Glyph component.
    actor = Instance(Actor, allow_none=False, record=True)

    input_info = PipelineInfo(datasets=['any'],
                              attribute_types=['any'],
                              attributes=['any'])

    ########################################
    # View related traits.

    view = View(Group(Item(name='glyph', style='custom',
                           resizable=True),
                      label='Glyph',
                      show_labels=False),
                Group(Item(name='actor', style='custom'),
                      label='Actor',
                      show_labels=False),
                )

    ######################################################################
    # `Module` interface
    ######################################################################
    def setup_pipeline(self):
        """Override this method so that it *creates* the tvtk
        pipeline.

        This method is invoked when the object is initialized via
        `__init__`.  Note that at the time this method is called, the
        tvtk data pipeline will *not* yet be setup.  So upstream data
        will not be available.  The idea is that you simply create the
        basic objects and setup those parts of the pipeline not
        dependent on upstream sources and filters.  You should also
        set the `actors` attribute up at this point.
        """
        # Setup the glyphs.
        self.glyph = glyph.Glyph(scale_mode='scale_by_scalar',
                                 color_mode='color_by_scalar',
                                 show_scale_mode=True)

        # Create the components
        actor = self.actor = Actor()
        actor.mapper.scalar_visibility = 1
        actor.property.set(line_width=2,
                           backface_culling=False,
                           frontface_culling=False)

    def update_pipeline(self):
        """Override this method so that it *updates* the tvtk pipeline
        when data upstream is known to have changed.

        This method is invoked (automatically) when any of the inputs
        sends a `pipeline_changed` event.
        """
        mm = self.module_manager
        if mm is None:
            return

        self.glyph.inputs = [mm.source]

        # Set the LUT for the mapper.
        self._color_mode_changed(self.glyph.color_mode)

        self.pipeline_changed = True

    def update_data(self):
        """Override this method so that it flushes the vtk pipeline if
        that is necessary.

        This method is invoked (automatically) when any of the inputs
        sends a `data_changed` event.
        """
        # Just set data_changed, the other components should do the rest.
        self.data_changed = True

    ######################################################################
    # Non-public traits.
    ######################################################################
    def _color_mode_changed(self, value):
        # This is a listner for the glyph component's color_mode trait
        # so that the the lut can be changed when the a different
        # color mode is requested.
        if self.module_manager is None:
            return
        actor = self.actor
        if value == 'color_by_scalar':
            actor.mapper.scalar_visibility = 1
            lut_mgr = self.module_manager.scalar_lut_manager
            actor.set_lut(lut_mgr.lut)
        elif value == 'color_by_vector':
            lut_mgr = self.module_manager.vector_lut_manager
            actor.set_lut(lut_mgr.lut)
        else:
            actor.mapper.scalar_visibility = 0

        self.render()

    def _glyph_changed(self, old, new):
        # Hookup a callback to set the lut appropriately.
        if old is not None:
            old.on_trait_change(self._color_mode_changed,
                                'color_mode',
                                remove=True)
        new.on_trait_change(self._color_mode_changed, 'color_mode')

        # Set the glyph's module attribute -- this is important!
        new.module = self

        # Setup actors inputs.
        actor = self.actor
        if actor is not None:
            actor.inputs = [new]
        self._change_components(old, new)

    def _actor_changed(self, old, new):
        # Setup the actors scene and inputs.
        new.scene = self.scene
        g = self.glyph
        if g is not None:
            new.inputs = [g]
        self._change_components(old, new)



########NEW FILE########
__FILENAME__ = grid_plane
"""A simple grid plane module.

"""
# Author: Prabhu Ramachandran <prabhu_r@users.sf.net>
# Copyright (c) 2005, Enthought, Inc.
# License: BSD Style.

# Enthought library imports.
from traits.api import Instance
from traitsui.api import View, Group, Item

# Local imports
from mayavi.core.module import Module
from mayavi.components import grid_plane
from mayavi.components.actor import Actor
from mayavi.core.pipeline_info import PipelineInfo


######################################################################
# `GridPlane` class.
######################################################################
class GridPlane(Module):

    # The version of this class.  Used for persistence.
    __version__ = 0

    grid_plane = Instance(grid_plane.GridPlane, allow_none=False,
                          record=True)

    actor = Instance(Actor, allow_non=False, record=True)

    input_info = PipelineInfo(datasets=['image_data',
                                        'structured_grid',
                                        'rectilinear_grid'],
                              attribute_types=['any'],
                              attributes=['any'])


    view = View(Group(Item(name='grid_plane', style='custom'),
                      Item(name='actor', style='custom'),
                      show_labels=False))

    ######################################################################
    # `Module` interface
    ######################################################################
    def setup_pipeline(self):
        """Override this method so that it *creates* the tvtk
        pipeline.

        This method is invoked when the object is initialized via
        `__init__`.  Note that at the time this method is called, the
        tvtk data pipeline will *not* yet be setup.  So upstream data
        will not be available.  The idea is that you simply create the
        basic objects and setup those parts of the pipeline not
        dependent on upstream sources and filters.  You should also
        set the `actors` attribute up at this point.
        """
        # Create the components
        self.grid_plane = grid_plane.GridPlane()
        self.actor = Actor()

        # Setup the actor suitably for this module.
        prop = self.actor.property
        prop.set(backface_culling=0, frontface_culling=0,
                 representation='w')
        self.actor.mapper.scalar_visibility = 0

    def update_pipeline(self):
        """Override this method so that it *updates* the tvtk pipeline
        when data upstream is known to have changed.

        This method is invoked (automatically) when any of the inputs
        sends a `pipeline_changed` event.
        """
        mm = self.module_manager
        if mm is None:
            return

        # Data is available, so set the input for the grid plane.
        self.grid_plane.inputs = [mm.source]
        # Set the LUT for the mapper.
        self.actor.set_lut(mm.scalar_lut_manager.lut)

        self.pipeline_changed = True

    def update_data(self):
        """Override this method so that it flushes the vtk pipeline if
        that is necessary.

        This method is invoked (automatically) when any of the inputs
        sends a `data_changed` event.
        """
        # Just set data_changed, the component should do the rest.
        self.data_changed = True

    ######################################################################
    # Non-public methods.
    ######################################################################
    def _grid_plane_changed(self, old, new):
        actor = self.actor
        if actor is not None:
            actor.inputs = [new]
        self._change_components(old, new)

    def _actor_changed(self, old, new):
        new.scene = self.scene
        gp = self.grid_plane
        if gp is not None:
            new.inputs = [gp]
        self._change_components(old, new)


########NEW FILE########
__FILENAME__ = hyper_streamline
""" A module that integrates through a tensor field to generate a
     hyperstreamline. The integration is along the maximum
     eigenvector and the cross section of the hyperstreamline is
     defined by the two other eigenvectors. Thus the shape of the
     hyperstreamline is "tube-like", with the cross section being
     elliptical. Hyperstreamlines are used to visualize tensor fields.
"""
# Authors: KK Rai (kk.rai [at] iitb.ac.in)
#          R. Ambareesha (ambareesha [at] iitb.ac.in)
#          Prabhu Ramachandran <prabhu_r@users.sf.net>

# Enthought library imports.
from traits.api import Instance
from traitsui.api import View, Group, Item
from tvtk.api import tvtk

# Local imports
from mayavi.core.module import Module
from mayavi.core.pipeline_info import PipelineInfo
from mayavi.components.actor import Actor

######################################################################
# `HyperStreamline` class.
######################################################################
class HyperStreamline(Module):
    # The version of this class.  Used for persistence.
    __version__ = 0

    # The hyper streamline object.
    streamline = Instance(tvtk.HyperStreamline, allow_none=False,
                          record=True)

    # The actor for the streamlines.
    actor = Instance(Actor, allow_none=False, record=True)

    # A point widget
    widget = Instance(tvtk.PointWidget, args=(),
                      kw={'outline': False, 'x_shadows': False,
                      'y_shadows': False, 'z_shadows': False},
                      allow_none=False)

    input_info = PipelineInfo(datasets=['any'],
                              attribute_types=['any'],
                              attributes=['tensors'])

    # Create the UI for the traits.
    view = View(Group(Item(name='actor', style='custom'),
                      show_labels=False,
                      label='Actor'),
                Group(Item(name='widget', style='custom', resizable=True),
                      show_labels=False,
                      label='PointWidget'),
                Group(Item(name='streamline', style='custom',
                           resizable=True),
                      label='Streamline',
                      show_labels=False),
               resizable=True
               )

    ######################################################################
    # `Module` interface
    ######################################################################
    def setup_pipeline(self):
        """Override this method so that it *creates* the tvtk
        pipeline.

        This method is invoked when the object is initialized via
        `__init__`. Note that at the time this method is called, the
        tvtk data pipeline will *not* yet be setup.  So upstream data
        will not be available.  The idea is that you simply create the
        basic objects and setup those parts of the pipeline not
        dependent on upstream sources and filters.  You should also
        set the `actors` attribute up at this point.
        """
        self.widget.on_trait_change(self._start_position_changed)

        self.streamline = tvtk.HyperStreamline()
        self.streamline.start_position = self.widget.position
        self.streamline.integrate_minor_eigenvector()
        self.streamline.maximum_propagation_distance = 10.0
        self.streamline.integration_step_length =0.1
        self.streamline.step_length = 0.01
        self.streamline.radius = 0.25
        self.streamline.number_of_sides = 18
        self.streamline.integration_direction = 2 #integrate both direction

        self.streamline.on_trait_change(self.render)
        self.actor = Actor()
        self.widgets.append(self.widget)

    def update_pipeline(self):
        """Override this method so that it *updates* the tvtk pipeline
        when data upstream is known to have changed.

        This method is invoked (automatically) when any of the inputs
        sends a `pipeline_changed` event.
        """
        mm = self.module_manager
        if mm is None:
            return
        src = mm.source.outputs[0]
        self.configure_connection(self.streamline, mm.source)
        w = self.widget
        old_inp = w.input
        self.configure_input_data(w, src)
        if old_inp is None or src != old_inp:
            w.place_widget()
        self.streamline.update()
        self.outputs = [self.streamline.output]
        self.pipeline_changed = True

    def update_data(self):
        """Override this method so that it flushes the vtk pipeline if
        that is necessary.

        This method is invoked (automatically) when any of the inputs
        sends a `data_changed` event.
        """
        # Just set data_changed, the component should do the rest.
        self.data_changed = True

    ######################################################################
    # Non-public methods.
    ######################################################################
    def _streamline_changed(self, old, new):
        if old is not None:
            old.on_trait_change(self.render, remove=True)
        new.on_trait_change(self.render)
        mm = self.module_manager
        if mm is not None:
            self.configure_connection(new, mm.source)
        # A default output so there are no pipeline errors.  The
        # update_pipeline call corrects this if needed.
        self.outputs = [new.output]
        self.update_pipeline()

    def _start_position_changed(self, value):
        self.streamline.start_position = self.widget.position

    def _actor_changed(self, old, new):
        new.scene = self.scene
        new.inputs = [self]
        self._change_components(old, new)

########NEW FILE########
__FILENAME__ = image_actor
"""Displays ImageData efficiently.
"""
# Author: Prabhu Ramachandran <prabhu_r@users.sf.net>
# Copyright (c) 2007, Enthought, Inc.
# License: BSD Style.


# Enthought library imports.
from traits.api import Instance, Bool, on_trait_change, \
        Property
from traitsui.api import View, Group, Item
from tvtk.api import tvtk

# Local imports
from mayavi.core.module import Module
from mayavi.core.pipeline_info import PipelineInfo

######################################################################
# `ImageActor` class
######################################################################
class ImageActor(Module):

    # An image actor.
    actor = Instance(tvtk.ImageActor, allow_none=False, record=True)

    input_info = PipelineInfo(datasets=['image_data'],
                              attribute_types=['any'],
                              attributes=['any'])

    # An ImageMapToColors TVTK filter to adapt datasets without color
    # information
    image_map_to_color = Instance(tvtk.ImageMapToColors, (),
                                            allow_none=False, record=True)

    map_scalars_to_color = Bool

    _force_map_scalars_to_color = Property(depends_on='module_manager.source')

    ########################################
    # The view of this module.

    view = View(Group(Item(name='actor', style='custom',
                           resizable=True),
                      show_labels=False, label='Actor'),
                Group(
                      Group(Item('map_scalars_to_color',
                            enabled_when='not _force_map_scalars_to_color')),
                      Item('image_map_to_color', style='custom',
                            enabled_when='map_scalars_to_color',
                            show_label=False),
                      label='Map Scalars',
                     ),
                width=500,
                height=600,
                resizable=True)

    ######################################################################
    # `Module` interface
    ######################################################################
    def setup_pipeline(self):
        self.actor = tvtk.ImageActor()

    @on_trait_change('map_scalars_to_color,image_map_to_color.[output_format,pass_alpha_to_output]')
    def update_pipeline(self):
        """Override this method so that it *updates* the tvtk pipeline
        when data upstream is known to have changed.
        """
        mm = self.module_manager
        if mm is None:
            return
        src = mm.source
        if self._force_map_scalars_to_color:
            self.set(map_scalars_to_color=True, trait_change_notify=False)
        if self.map_scalars_to_color:
            self.configure_connection(self.image_map_to_color, src)
            self.image_map_to_color.lookup_table = mm.scalar_lut_manager.lut
            self.image_map_to_color.update()
            self.configure_input_data(self.actor,
                                      self.image_map_to_color.output)
        else:
            self.configure_input_data(self.actor, src.outputs[0])
        self.pipeline_changed = True

    def update_data(self):
        """Override this method so that it flushes the vtk pipeline if
        that is necessary.
        """
        # Just set data_changed, the component should do the rest.
        self.data_changed = True

    ######################################################################
    # Non-public methods.
    ######################################################################
    def _actor_changed(self, old, new):
        if old is not None:
            self.actors.remove(old)
            old.on_trait_change(self.render, remove=True)
        self.actors.append(new)
        new.on_trait_change(self.render)

    def _get__force_map_scalars_to_color(self):
        mm = self.module_manager
        if mm is None:
            return False
        src = mm.source
        return not isinstance(src.outputs[0].point_data.scalars,
                                                    tvtk.UnsignedCharArray)

########NEW FILE########
__FILENAME__ = image_plane_widget
"""A simple ImagePlaneWidget module to view image data.

"""
# Author: Prabhu Ramachandran <prabhu_r@users.sf.net>
# Copyright (c) 2005, Enthought, Inc.
# License: BSD Style.

# Enthought library imports.
from traits.api import Instance, Bool, on_trait_change
from traitsui.api import View, Group, Item
from tvtk.api import tvtk

# Local imports
from mayavi.core.module import Module
from mayavi.core.common import error
from mayavi.core.pipeline_info import PipelineInfo


######################################################################
# `ImagePlaneWidget` class.
######################################################################
class ImagePlaneWidget(Module):

    # The version of this class.  Used for persistence.
    __version__ = 0

    ipw = Instance(tvtk.ImagePlaneWidget, allow_none=False, record=True)

    use_lookup_table = Bool(True,
            help='Use a lookup table to map input scalars to colors')

    input_info = PipelineInfo(datasets=['image_data'],
                              attribute_types=['any'],
                              attributes=['scalars'])

    view = View(Group(Item(name='ipw', style='custom', resizable=True),
                      show_labels=False
                      ),
                width=600,
                height=600,
                resizable=True,
                scrollable=True
                )

    ######################################################################
    # `Module` interface
    ######################################################################
    def setup_pipeline(self):
        """Override this method so that it *creates* the tvtk
        pipeline.

        This method is invoked when the object is initialized via
        `__init__`.  Note that at the time this method is called, the
        tvtk data pipeline will *not* yet be setup.  So upstream data
        will not be available.  The idea is that you simply create the
        basic objects and setup those parts of the pipeline not
        dependent on upstream sources and filters.  You should also
        set the `actors` attribute up at this point.
        """
        # Create the various objects for this module.
        self.ipw = tvtk.ImagePlaneWidget(display_text=1,
                                         key_press_activation=0,
                                         left_button_action=1,
                                         middle_button_action=0,
                                         user_controlled_lookup_table=True)
        self.setup_lut()


    def update_pipeline(self):
        """Override this method so that it *updates* the tvtk pipeline
        when data upstream is known to have changed.

        This method is invoked (automatically) when any of the inputs
        sends a `pipeline_changed` event.
        """
        mod_mgr = self.module_manager
        if mod_mgr is None:
            return

        # Data is available, so set the input for the IPW.
        input = mod_mgr.source.outputs[0]
        if not (input.is_a('vtkStructuredPoints') \
                or input.is_a('vtkImageData')):
            msg = 'ImagePlaneWidget only supports structured points or '\
                  'image data.'
            error(msg)
            raise TypeError, msg

        self.configure_input_data(self.ipw, input)
        self.setup_lut()

    def update_data(self):
        """Override this method so that it flushes the vtk pipeline if
        that is necessary.

        This method is invoked (automatically) when any of the inputs
        sends a `data_changed` event.
        """
        # Just set data_changed, the component should do the rest.
        self.data_changed = True


    @on_trait_change('use_lookup_table')
    def setup_lut(self):
        # Set the LUT for the IPW.
        if self.use_lookup_table:
            if self.module_manager is not None:
                self.ipw.lookup_table = \
                                self.module_manager.scalar_lut_manager.lut
        else:
            self.ipw.color_map.lookup_table = None
        self.render()

    ######################################################################
    # Non-public methods.
    ######################################################################
    def _ipw_changed(self, old, new):
        if old is not None:
            old.on_trait_change(self.render, remove=True)
            self.widgets.remove(old)
        new.on_trait_change(self.render)
        self.widgets.append(new)
        if old is not None:
            self.update_pipeline()
        self.pipeline_changed = True




########NEW FILE########
__FILENAME__ = iso_surface
"""An IsoSurface module that allows the user to make contours of input
point data.
"""
# Author: Prabhu Ramachandran <prabhu_r@users.sf.net>
# Copyright (c) 2005, Enthought, Inc.
# License: BSD Style.


# Enthought library imports.
from traits.api import Instance, Bool

# Local imports
from mayavi.core.module import Module
from mayavi.components.contour import Contour
from mayavi.components.poly_data_normals import PolyDataNormals
from mayavi.components.actor import Actor
from mayavi.core.pipeline_info import PipelineInfo


######################################################################
# `IsoSurface` class.
######################################################################
class IsoSurface(Module):

    # The version of this class.  Used for persistence.
    __version__ = 0

    # The contour component.
    contour = Instance(Contour, record=True)

    # Specify if normals are to be computed to make a smoother surface.
    compute_normals = Bool(True, desc='if normals are to be computed '\
                           'to make the iso-surface smoother')

    # The component that computes the normals.
    normals = Instance(PolyDataNormals, record=True)

    # The actor component that represents the iso-surface.
    actor = Instance(Actor, record=True)

    input_info = PipelineInfo(datasets=['any'],
                              attribute_types=['any'],
                              attributes=['scalars'])

    ########################################
    # The view of this object.
    # Commented out, since we are now using the iso_surface_view.py version.
    #view = View([Group(
    #                 Item( name  = 'contour',
    #                       style = 'custom' ),
    #                 show_labels = False,
    #                 show_border = True,
    #                 label       = 'Contours' ),
    #             Group(
    #                 Item( name = 'compute_normals' ),
    #                 '_',
    #                 Item( name         = 'normals',
    #                       style        = 'custom',
    #                       show_label   = False,
    #                       enabled_when = 'compute_normals' ),
    #                 show_border = True,
    #                 label       = 'Normals' ),
    #             Group(
    #                 Item( name  = 'actor',
    #                       style = 'custom' ),
    #                 show_labels = False )
    #             ]
    #            )

    ######################################################################
    # `Module` interface
    ######################################################################
    def setup_pipeline(self):
        """Override this method so that it *creates* the tvtk
        pipeline.

        This method is invoked when the object is initialized via
        `__init__`.  Note that at the time this method is called, the
        tvtk data pipeline will *not* yet be setup.  So upstream data
        will not be available.  The idea is that you simply create the
        basic objects and setup those parts of the pipeline not
        dependent on upstream sources and filters.  You should also
        set the `actors` attribute up at this point.
        """
        # Create the components
        self.contour = Contour(show_filled_contours=False)
        self.normals = PolyDataNormals()
        self.actor = Actor()

        # Setup the actor suitably for this module.
        self.actor.mapper.scalar_visibility = 1

    def update_pipeline(self):
        """Override this method so that it *updates* the tvtk pipeline
        when data upstream is known to have changed.

        This method is invoked (automatically) when any of the inputs
        sends a `pipeline_changed` event.
        """
        mm = self.module_manager
        if mm is None:
            return

        # Data is available, so set the input for the grid plane.
        self.contour.inputs = [mm.source]
        # Force the normals setting to be noted.
        self._compute_normals_changed(self.compute_normals)
        # Set the LUT for the mapper.
        self.actor.set_lut(mm.scalar_lut_manager.lut)

        self.pipeline_changed = True

    def update_data(self):
        """Override this method so that it flushes the vtk pipeline if
        that is necessary.

        This method is invoked (automatically) when any of the inputs
        sends a `data_changed` event.
        """
        # Just set data_changed, the component should do the rest.
        self.data_changed = True

    ######################################################################
    # Non-public interface.
    ######################################################################
    def _compute_normals_changed(self, value):
        if self.module_manager is None:
            return
        actor = self.actor
        if value:
            if actor:
                actor.inputs = [self.normals]
        else:
            if actor:
                actor.inputs = [self.contour]
        self.render()

    def _contour_changed(self, old, new):
        normals = self.normals
        if normals is not None:
            normals.inputs = [new]
        self._change_components(old, new)

    def _normals_changed(self, old, new):
        contour = self.contour
        if contour is not None:
            new.inputs = [contour]
        self._change_components(old, new)

    def _actor_changed(self, old, new):
        # Here we set the inputs in any case to avoid VTK pipeline
        # errors.  The pipeline is corrected when update_pipeline is
        # called anyway.
        contour = self.contour
        if contour is not None:
            new.inputs = [contour]
        self._change_components(old, new)


########NEW FILE########
__FILENAME__ = labels
# Author: Prabhu Ramachandran <prabhu [at] aero . iitb . ac . in>
# Copyright (c) 2008, Enthought, Inc.
# License: BSD Style.

# Standard library imports.

# Enthought library imports.
from traits.api import Int, Instance, Str, TraitError
from traitsui.api import View, Group, Item
from tvtk.api import tvtk
from apptools.persistence import state_pickler

# Local imports.
from mayavi.core.common import error
from mayavi.core.pipeline_base import PipelineBase
from mayavi.core.pipeline_info import PipelineInfo
from mayavi.core.module import Module
from mayavi.filters.optional import Optional
from mayavi.filters.mask_points import MaskPoints
from mayavi.filters.user_defined import UserDefined
from mayavi.components.actor2d import Actor2D
from mayavi.core.common import handle_children_state


################################################################################
# `Labels` class.
################################################################################
class Labels(Module):

    """
    Allows a user to label the current dataset or the current actor of
    the active module.
    """

    # Used for persistence.
    __version__ = 0

    # The object which we are labeling.
    object = Instance(PipelineBase, record=False)

    # The label format string.
    label_format = Str('', enter_set=True, auto_set=False,
                       desc='the label format string')

    # Number of points to label.
    number_of_labels = Int(25, enter_set=True, auto_set=False,
                           desc='the number of points to label')

    # The filter used for masking of the points.
    mask = Instance(MaskPoints, record=True)

    # Filter to select visible points.
    visible_points = Instance(Optional, record=True)

    # The 2D actor for the labels.
    actor = Instance(Actor2D, record=True)

    # The text property of the labels.
    property = Instance(tvtk.TextProperty, record=True)

    # The mapper for the labels.
    mapper = Instance(tvtk.LabeledDataMapper, args=(), record=True)

    input_info = PipelineInfo(datasets=['any'],
                              attribute_types=['any'],
                              attributes=['any'])

    ########################################
    # Private traits.

    # The input used for the labeling.
    input = Instance(PipelineBase)

    # The id of the object in the modulemanager only used for
    # persistence.
    object_id = Int(-2)


    ########################################
    # View related traits.


    view = View(Group(Item(name='number_of_labels'),
                      Item(name='label_format'),
                      Item(name='mapper',
                           style='custom',
                           show_label=False,
                           resizable=True),
                      Item(name='mask',
                           style='custom',
                           resizable=True,
                           show_label=False),
                      label='Labels'
                      ),
                Group(
                      Item(name='visible_points',
                           style='custom',
                           resizable=True,
                           show_label=False),
                      label='VisiblePoints'
                      ),
                Group(Item(name='property',
                           style='custom',
                           show_label=False,
                           resizable=True),
                      label='TextProperty'
                     ),
                 resizable=True
                )

    ######################################################################
    # `object` interface.
    ######################################################################
    def __get_pure_state__(self):
        self._compute_object_id()
        d = super(Labels, self).__get_pure_state__()
        for name in ('object', 'mapper', 'input'):
            d.pop(name, None)
        # Must pickle the components.
        d['components'] = self.components
        return d

    def __set_pure_state__(self, state):
        handle_children_state(self.components, state.components)
        state_pickler.set_state(self, state)
        self.update_pipeline()

    ######################################################################
    # `Module` interface.
    ######################################################################
    def setup_pipeline(self):
        mask = MaskPoints()
        mask.filter.set(generate_vertices=True, random_mode=True)
        self.mask = mask
        v = UserDefined(filter=tvtk.SelectVisiblePoints(),
                        name='VisiblePoints')
        self.visible_points = Optional(filter=v, enabled=False)
        mapper = tvtk.LabeledDataMapper()
        self.mapper = mapper
        self.actor = Actor2D(mapper=mapper)
        self.property = mapper.label_text_property
        self.property.on_trait_change(self.render)
        self.components = [self.mask, self.visible_points, self.actor]

    def update_pipeline(self):
        mm = self.module_manager
        if mm is None:
            return

        self._find_input() # Calculates self.input
        self.mask.inputs = [self.input]
        self.visible_points.inputs = [self.mask]
        self.actor.inputs = [self.visible_points]
        self._number_of_labels_changed(self.number_of_labels)
        self._label_format_changed(self.label_format)

    ######################################################################
    # Non-public interface.
    ######################################################################
    def _find_input(self):
        mm = self.module_manager
        if self.object is None:
            if self.object_id == -1:
                self.input = mm.source
            elif self.object_id > -1:
                obj = mm.children[self.object_id]
                if hasattr(obj, 'actor'):
                    self.set(object=obj, trait_change_notify=False)
                    self.input = obj.actor.inputs[0]
                else:
                    self.input = mm.source
        else:
            o = self.object
            if hasattr(o, 'module_manager'):
                # A module.
                if hasattr(o, 'actor'):
                    self.input = o.actor.inputs[0]
                else:
                    self.input = o.module_manager.source

        if self.input is None:
            if self.object_id == -2:
                self.input = mm.source
            else:
                error('No object to label!')
                return

    def _number_of_labels_changed(self, value):
        if self.input is None:
            return
        f = self.mask.filter
        inp = self.input.outputs[0]
        if hasattr(inp, 'update'):
            inp.update()
        npts = inp.number_of_points
        typ = type(f.on_ratio)
        f.on_ratio = typ(max(npts/value, 1))
        if self.mask.running:
            f.update()
            self.mask.data_changed = True

    def _label_format_changed(self, value):
        if len(value) > 0:
            self.mapper.label_format = value
            self.render()
        else:
            try:
                self.mapper.label_format = None
            except TraitError:
                self.mapper.label_format = '%g'
            self.render()

    def _object_changed(self, value):
        self.update_pipeline()

    def _compute_object_id(self):
        mm = self.module_manager
        input = self.input
        self.object_id = -2
        if input is mm.source:
            self.object_id = -1
            return
        for id, child in enumerate(mm.children):
            if child is self.object:
                self.object_id = id
                return

    def _scene_changed(self, old, new):
        self.visible_points.filter.filter.renderer = new.renderer
        super(Labels, self)._scene_changed(old, new)

########NEW FILE########
__FILENAME__ = metadata
"""
Metadata for all modules.
"""
# Author: Prabhu Ramachandran <prabhu@aero.iitb.ac.in>
# Copyright (c) 2008, Prabhu Ramachandran Enthought, Inc.
# License: BSD Style.

# Local imports.
from mayavi.core.metadata import ModuleMetadata
from mayavi.core.pipeline_info import PipelineInfo

BASE = 'mayavi.modules'


################################################################################
# Metadata.

axes_module = ModuleMetadata(
    id            = "AxesModule",
    menu_name          = "&Axes",
    class_name = BASE + '.axes.Axes',
    desc   = "Draw cubical axes on the outline for given input",
    tooltip       = "Draw axes on the outline of input data",
    help       = "Draw axes on the outline of input data",
    input_info = PipelineInfo(datasets=['any'],
                              attribute_types=['any'],
                              attributes=['any'])
)

contour_grid_plane_module = ModuleMetadata(
    id            = "ContourGridPlaneModule",
    menu_name          = "&ContourGridPlane",
    class_name = BASE + '.contour_grid_plane.ContourGridPlane',
    desc   = "Shows a contour grid plane for the given input",
    tooltip       = "Shows a contour grid plane for the given input",
    help       = "Shows a contour grid plane for the given input",
    input_info = PipelineInfo(datasets=['image_data',
                                        'structured_grid',
                                        'rectilinear_grid'],
                              attribute_types=['any'],
                              attributes=['any'])
)

custom_grid_plane_module = ModuleMetadata(
    id            = "CustomGridPlaneModule",
    menu_name          = "CustomGridPlane",
    class_name = BASE + '.custom_grid_plane.CustomGridPlane',
    desc   = "Creates a highly customizable grid plane for given input",
    tooltip       = "Creates a highly customizable grid plane for given input",
    help       = "Creates a highly customizable grid plane for given input",
    input_info = PipelineInfo(datasets=['image_data',
                                        'structured_grid',
                                        'rectilinear_grid'],
                              attribute_types=['any'],
                              attributes=['any'])
)

glyph_module = ModuleMetadata(
    id            = "GlyphModule",
    menu_name          = "Gl&yph",
    class_name = BASE + '.glyph.Glyph',
    desc   = "Creates colored and scaled glyphs at at input points",
    tooltip       = "Creates colored and scaled glyphs at at input points",
    help       = "Creates colored and scaled glyphs at at input points",
    input_info = PipelineInfo(datasets=['any'],
                              attribute_types=['any'],
                              attributes=['any'])
)

grid_plane_module = ModuleMetadata(
    id            = "GridPlaneModule",
    menu_name          = "&GridPlane",
    class_name = BASE + '.grid_plane.GridPlane',
    desc   = "Shows a grid plane for the given input",
    tooltip       = "Shows a grid plane for the given input",
    help       = "Shows a grid plane for the given input",
    input_info = PipelineInfo(datasets=['image_data',
                                        'structured_grid',
                                        'rectilinear_grid'],
                              attribute_types=['any'],
                              attributes=['any'])
)

hyper_streamline_module = ModuleMetadata(
    id            = "HyperStreamlineModule",
    menu_name          = "&HyperStreamline",
    class_name = BASE + '.hyper_streamline.HyperStreamline',
    desc   = "Shows hyper streamlines for tensor data",
    tooltip       = "Shows hyper streamlines for tensor data",
    help       = "Shows hyper streamlines for tensor data",
    input_info = PipelineInfo(datasets=['any'],
                              attribute_types=['any'],
                              attributes=['tensors'])
)

image_actor_module = ModuleMetadata(
    id            = "ImageActorModule",
    menu_name          = "&ImageActor",
    class_name = BASE + '.image_actor.ImageActor',
    desc   = "Shows an image actor for image data",
    tooltip       = "Shows an image actor for image data",
    help       = "Shows an image actor for image data",
    input_info = PipelineInfo(datasets=['image_data'],
                              attribute_types=['any'],
                              attributes=['any'])
)

image_plane_widget_module = ModuleMetadata(
    id            = "ImagePlaneWidgetModule",
    menu_name          = "I&magePlaneWidget",
    class_name = BASE + '.image_plane_widget.ImagePlaneWidget',
    desc   = "Shows an image plane widget for image data",
    tooltip       = "Shows an image plane widget for image data",
    help       = "Shows an image plane widget for image data",
    input_info = PipelineInfo(datasets=['image_data'],
                              attribute_types=['any'],
                              attributes=['scalars'])
)

isosurface_module = ModuleMetadata(
    id            = "IsoSurfaceModule",
    menu_name          = "&IsoSurface",
    class_name = BASE + '.iso_surface.IsoSurface',
    desc   = "Creates an iso-surface for the given input",
    tooltip       = "Creates an iso-surface for the given input",
    help       = "Creates an iso-surface for the given input",
    input_info = PipelineInfo(datasets=['any'],
                              attribute_types=['any'],
                              attributes=['scalars'])
)

labels_module = ModuleMetadata(
    id            = "LabelsModule",
    menu_name          = "&Labels",
    class_name = BASE + '.labels.Labels',
    desc   = "Display labels for active dataset or active module",
    tooltip       = "Display labels for active dataset or active module",
    help       = "Display labels for active dataset or active module",
    input_info = PipelineInfo(datasets=['any'],
                              attribute_types=['any'],
                              attributes=['any'])
)

orientation_axes_module = ModuleMetadata(
    id            = "OrientationAxesModule",
    menu_name          = "Orientation A&xes",
    class_name = BASE + '.orientation_axes.OrientationAxes',
    desc   = "Show an axes indicating the current orientation",
    tooltip       = "Show an axes indicating the current orientation",
    help       = "Show an axes indicating the current orientation",
    input_info = PipelineInfo(datasets=['any'],
                              attribute_types=['any'],
                              attributes=['any'])
)

outline_module = ModuleMetadata(
    id            = "OutlineModule",
    menu_name          = "&Outline",
    class_name = BASE + '.outline.Outline',
    desc   = "Draw an outline for given input",
    tooltip       = "Draw an outline for given input",
    help       = "Draw an outline for given input",
    input_info = PipelineInfo(datasets=['any'],
                              attribute_types=['any'],
                              attributes=['any'])
)

scalar_cut_plane_module = ModuleMetadata(
    id            = "ScalarCutPlaneModule",
    menu_name          = "Scalar Cut &Plane",
    class_name = BASE + '.scalar_cut_plane.ScalarCutPlane',
    desc   = "Slice through the data with optional contours",
    tooltip       = "Slice through the data with optional contours",
    help       = "Slice through the data with optional contours",
    input_info = PipelineInfo(datasets=['any'],
                              attribute_types=['any'],
                              attributes=['scalars'])
)

slice_ug_module = ModuleMetadata(
    id            = "SliceUnstructuredGridModule",
    menu_name          = "Slice &Unstructured Grid",
    class_name = BASE + '.slice_unstructured_grid.SliceUnstructuredGrid',
    desc   = "Slice an unstructured grid to show cells",
    tooltip       = "Slice an unstructured grid to show cells",
    help       = "Slice an unstructured grid to show cells",
    input_info = PipelineInfo(datasets=['unstructured_grid'],
                              attribute_types=['any'],
                              attributes=['any'])
)

sgrid_outline_module = ModuleMetadata(
    id            = "StructuredGridOutlineModule",
    menu_name          = "StructuredGridOutline",
    class_name = BASE + '.structured_grid_outline.StructuredGridOutline',
    desc   = "Draw a grid-conforming outline for structured grids",
    tooltip       = "Draw a grid-conforming outline for structured grids",
    help       = "Draw a grid-conforming outline for structured grids",
    input_info = PipelineInfo(datasets=['any'],
                              attribute_types=['any'],
                              attributes=['any'])
)

streamline_module = ModuleMetadata(
    id            = "StreamlineModule",
    menu_name          = "Stream&line",
    class_name = BASE + '.streamline.Streamline',
    desc   = "Generate streamlines for the vectors",
    tooltip       = "Generate streamlines for the vectors",
    help       = "Generate streamlines for the vectors",
    input_info = PipelineInfo(datasets=['any'],
                              attribute_types=['any'],
                              attributes=['vectors'])
)

surface_module = ModuleMetadata(
    id            = "SurfaceModule",
    menu_name          = "&Surface",
    class_name = BASE + '.surface.Surface',
    desc   = "Creates a surface for the given input",
    tooltip       = "Creates a surface for the given input",
    help       = "Creates a surface for the given input",
    input_info = PipelineInfo(datasets=['any'],
                              attribute_types=['any'],
                              attributes=['any'])
)

tensor_glyph_module = ModuleMetadata(
    id            = "TensorGlyphModule",
    menu_name          = "Te&nsorGlyph",
    class_name = BASE + '.tensor_glyph.TensorGlyph',
    desc   = "Displays glyphs scaled and oriented as per tensor data",
    tooltip       = "Displays glyphs scaled and oriented as per tensor data",
    help       = "Displays glyphs scaled and oriented as per tensor data",
    input_info = PipelineInfo(datasets=['any'],
                              attribute_types=['any'],
                              attributes=['tensors'])
)

text_module = ModuleMetadata(
    id            = "TextModule",
    menu_name          = "&Text",
    class_name = BASE + '.text.Text',
    desc   = "Displays user specified text on screen",
    tooltip       = "Displays text on screen",
    help       = "Displays text on screen",
    input_info = PipelineInfo(datasets=['any'],
                              attribute_types=['any'],
                              attributes=['any'])
)

text3d_module = ModuleMetadata(
    id            = "Text3DModule",
    menu_name          = "&Text3D",
    class_name = BASE + '.text3d.Text3D',
    desc   = "Displays user-specified text at a 3D location in the scene",
    tooltip    = "Displays user-specified text at a 3D location in the scene",
    help       = "Displays user-specified text at a 3D location in the scene",
    input_info = PipelineInfo(datasets=['any'],
                              attribute_types=['any'],
                              attributes=['any'])
)

vector_cut_plane_module = ModuleMetadata(
    id            = "VectorCutPlaneModule",
    menu_name          = "&VectorCutPlane",
    class_name = BASE + '.vector_cut_plane.VectorCutPlane',
    desc   = "Display vectors along a cut plane",
    tooltip       = "Display vectors along a cut plane",
    help       = "Display vectors along a cut plane",
    input_info = PipelineInfo(datasets=['any'],
                              attribute_types=['any'],
                              attributes=['vectors'])
)

vectors_module = ModuleMetadata(
    id            = "VectorsModule",
    menu_name          = "Vecto&rs",
    class_name = BASE + '.vectors.Vectors',
    desc   = "Display input vectors using arrows or other glyphs",
    tooltip       = "Display input vectors using arrows or other glyphs",
    help       = "Display input vectors using arrows or other glyphs",
    input_info = PipelineInfo(datasets=['any'],
                              attribute_types=['any'],
                              attributes=['any'])
)

volume_module = ModuleMetadata(
    id            = "VolumeModule",
    menu_name          = "Volum&e",
    class_name = BASE + '.volume.Volume',
    desc   = "Use volume rendering to view the scalar field",
    tooltip       = "Use volume rendering to view the scalar field",
    help       = "Use volume rendering to view the scalar field",
    input_info = PipelineInfo(datasets=['image_data',
                                        'unstructured_grid'],
                              attribute_types=['any'],
                              attributes=['scalars'])
)

warp_vector_cut_plane_module = ModuleMetadata(
    id            = "WarpVectorCutPlaneModule",
    menu_name          = "&WarpVectorCutPlane",
    class_name = BASE + '.warp_vector_cut_plane.WarpVectorCutPlane',
    desc   = "Warp cut plane along scaled input vectors",
    tooltip       = "Warp cut plane along scaled input vectors",
    help       = "Warp cut plane along scaled input vectors",
    input_info = PipelineInfo(datasets=['any'],
                              attribute_types=['any'],
                              attributes=['vectors'])
)


# Now collect all the modules for the mayavi registry.
modules = [axes_module,
           contour_grid_plane_module,
           custom_grid_plane_module,
           glyph_module,
           grid_plane_module,
           hyper_streamline_module,
           image_actor_module,
           image_plane_widget_module,
           isosurface_module,
           labels_module,
           orientation_axes_module,
           outline_module,
           scalar_cut_plane_module,
           slice_ug_module,
           sgrid_outline_module,
           streamline_module,
           surface_module,
           tensor_glyph_module,
           text_module,
           text3d_module,
           vector_cut_plane_module,
           vectors_module,
           volume_module,
           warp_vector_cut_plane_module,
          ]


########NEW FILE########
__FILENAME__ = orientation_axes
"""Creates a small axes on the side that indicates the position of the
co-ordinate axes and thereby marks the orientation of the scene.  It
uses the OrientationMarkerWidget which requires VTK-4.5 and above.
"""
# Author: Prabhu Ramachandran <prabhu_r@users.sf.net>
# Copyright (c) 2005, Prabhu Ramachandran,  Enthought, Inc.
# License: BSD Style.


# Enthought library imports.
from traits.api import Instance, Property
from traitsui.api import View, Group, Item, InstanceEditor
from tvtk.api import tvtk
from apptools.persistence import state_pickler

# Local imports
from mayavi.core.module import Module
from mayavi.core.common import error
from mayavi.core.pipeline_info import PipelineInfo

if not hasattr(tvtk, 'OrientationMarkerWidget'):
    msg = 'The OrientationAxes module requires VTK version >= 4.5'
    error(msg)
    raise ImportError, msg

######################################################################
# `OrientationAxes` class.
######################################################################
class OrientationAxes(Module):
    # The version of this class.  Used for persistence.
    __version__ = 0

    # The tvtk orientation marker widget.
    marker = Instance(tvtk.OrientationMarkerWidget, allow_none=False)

    # The tvtk axes that will be shown.
    axes = Instance(tvtk.AxesActor, allow_none=False, record=True)

    # The property of the axes (color etc.).
    text_property = Property(record=True)

    input_info = PipelineInfo(datasets=['any'],
                              attribute_types=['any'],
                              attributes=['any'])

    ########################################
    # Private traits.
    _text_property = Instance(tvtk.TextProperty)

    ########################################
    # The view of this object.

    _marker_group = Group(Item(name='enabled'),
                          Item(name='interactive'),
                          show_border=True,
                          label='Widget')
    _axes_group = Group(Item(name='axis_labels'),
                        Item(name='visibility'),
                        Item(name='x_axis_label_text'),
                        Item(name='y_axis_label_text'),
                        Item(name='z_axis_label_text'),
                        Item(name='cone_radius'),
                        Item(name='cone_resolution'),
                        Item(name='cylinder_radius'),
                        Item(name='cylinder_resolution'),
                        Item(name='normalized_label_position'),
                        Item(name='normalized_shaft_length'),
                        Item(name='normalized_tip_length'),
                        Item(name='total_length'),
                        show_border=True,
                        label='Axes')

    view = View(Group(Item(name='marker', style='custom',
                           editor=InstanceEditor(view=View(_marker_group))),
                      Item(name='axes', style='custom',
                           editor=InstanceEditor(view=View(_axes_group))),
                      label='Widget/Axes',
                      show_labels=False),
                Group(Item(name='_text_property', style='custom',
                           resizable=True),
                      label='Text Property',
                      show_labels=False),
                )

    ######################################################################
    # `object` interface
    ######################################################################
    def __set_pure_state__(self, state):
        for prop in ['axes', 'marker', '_text_property']:
            obj = getattr(self, prop)
            state_pickler.set_state(obj, state[prop])


    ######################################################################
    # `Module` interface
    ######################################################################
    def setup_pipeline(self):
        """Override this method so that it *creates* the tvtk
        pipeline.

        This method is invoked when the object is initialized via
        `__init__`.  Note that at the time this method is called, the
        tvtk data pipeline will *not* yet be setup.  So upstream data
        will not be available.  The idea is that you simply create the
        basic objects and setup those parts of the pipeline not
        dependent on upstream sources and filters.  You should also
        set the `actors` attribute up at this point.
        """
        # Setup the default objects.
        self.axes = tvtk.AxesActor(normalized_tip_length=(0.4, 0.4, 0.4),
                                   normalized_shaft_length=(0.6, 0.6, 0.6),
                                   shaft_type='cylinder')
        self.text_property.set(color=(1,1,1), shadow=False, italic=False)

        self.marker = tvtk.OrientationMarkerWidget(key_press_activation=False)

    def update_pipeline(self):
        """Override this method so that it *updates* the tvtk pipeline
        when data upstream is known to have changed.

        This method is invoked (automatically) when any of the inputs
        sends a `pipeline_changed` event.
        """
        self.pipeline_changed = True

    def update_data(self):
        """Override this method so that it flushes the vtk pipeline if
        that is necessary.

        This method is invoked (automatically) when any of the inputs
        sends a `data_changed` event.
        """
        # Just set data_changed, the component should do the rest.
        self.data_changed = True

    ######################################################################
    # Non-public interface
    ######################################################################
    def _marker_changed(self, old, new):
        if old is not None:
            old.on_trait_change(self.render, remove=True)
            self.widgets.remove(old)
        axes = self.axes
        if axes is not None:
            new.orientation_marker = axes
        new.on_trait_change(self.render)

        self.widgets.append(new)
        self.render()

    def _axes_changed(self, old, new):
        if old is not None:
            old.on_trait_change(self.render, remove=True)
            self._text_property.on_trait_change(self.render, remove=True)
        marker = self.marker
        if marker is not None:
            marker.orientation_marker = new

        p = new.x_axis_caption_actor2d.caption_text_property
        new.y_axis_caption_actor2d.caption_text_property = p
        new.z_axis_caption_actor2d.caption_text_property = p
        self._text_property = p

        # XXX: The line of code below is a stop-gap solution. Without it,
        # Some observers in the AxesActor trigger a modification of the
        # font_size each time the mouse is moved over the OrientationAxes
        # (this can be seen when running the record mode, for instance),
        # and thus a render, which is very slow. On the other hand, font
        # size does not work for the AxesActor, with or without the
        # line of code below. So we probably haven't found the true
        # cause of the problem.
        p.teardown_observers()

        new.on_trait_change(self.render)
        p.on_trait_change(self.render)

        self.render()

    def _get_text_property(self):
        return self._text_property

    def _foreground_changed_for_scene(self, old, new):
        # Change the default color for the actor.
        self.text_property.color = new
        self.render()

    def _scene_changed(self, old, new):
        super(OrientationAxes, self)._scene_changed(old, new)
        self._foreground_changed_for_scene(None, new.foreground)
        self._visible_changed(self.visible)

    def _visible_changed(self, value):
        if self.scene is not None and self.marker.interactor:
            # Enabling an OrientationAxes without an interactor will
            # lead to a segfault
            super(OrientationAxes, self)._visible_changed(value)

########NEW FILE########
__FILENAME__ = outline
""" A module that displays the outline for the given data, either as a
    box, or the corners of the bounding box.
"""

# Authors: Prabhu Ramachandran <prabhu_r [at] users.sf.net>
#          KK Rai (kk.rai [at] iitb.ac.in)
#          R. Ambareesha (ambareesha [at] iitb.ac.in)
# Copyright (c) 2005-2007, Enthought, Inc.
# License: BSD Style.

# Enthought library imports.
from traits.api import Instance, Enum, Property, Bool, \
    DelegatesTo
from traitsui.api import View, Group, Item
from tvtk.api import tvtk
from tvtk.common import is_old_pipeline

# Local imports
from mayavi.core.module import Module
from mayavi.components.actor import Actor
from mayavi.core.pipeline_info import PipelineInfo


######################################################################
# `Outline` class.
######################################################################
class Outline(Module):
    # The version of this class.  Used for persistence.
    __version__ = 0

    # The `Outline` filter which can either be an instance of
    # `OutlineFilter` or `OutlineCornerFilter`. The `ObjectBase` class
    # is the superclass of both the `OutlineFilter` and the
    # `OutlineCornerFilter`.
    outline_filter = Property(Instance(tvtk.ObjectBase,
                                        allow_none=False), record=True)

    # Enum to set the outline type.
    outline_mode = Enum('full', 'cornered',
                        desc='if outline mode is "full" or "cornered"')

    actor = Instance(Actor, allow_none=False, record=True)

    input_info = PipelineInfo(datasets=['any'],
                              attribute_types=['any'],
                              attributes=['any'])

    # An outline source, optionally used to choose the bounds of the
    # outline.
    outline_source = Instance(tvtk.OutlineSource, ())

    bounds = DelegatesTo('outline_source',
                desc="the bounds of the outline: xmin, xmax, ymin, ymax")

    manual_bounds = Bool(
                desc="whether the bounds are automatically inferred from "
                     "the data source")

    # Create the UI for the traits.

    # The controls for the outline_filter should be enabled only when the
    # Cornered Outline Filter is selected.
    view = View(Group(
                    Group(
                        Item(name='outline_mode'),
                        Item(name='outline_filter',
                                style='custom',
                                enabled_when='outline_mode == "cornered"',
                                visible_when='outline_mode == "cornered"',
                                resizable=True,
                                show_label=False),
                    label='Outline',
                    show_labels=False),
                    Group('manual_bounds',
                            Item('bounds', enabled_when='manual_bounds'),
                            label='Bounds',
                            ),
                    Item(name='actor', style='custom'),
                    layout='tabbed',
                    show_labels=False),
                resizable=True)

    ########################################
    # Private traits.

    # We make these private traits and cache them because if we create
    # these anew each time the `outline_mode` changes, then we loose
    # any settings the user changed on the previous mode.
    _full_outline = Instance(tvtk.OutlineFilter, args=(),
                             allow_none=False)
    _cornered_outline = Instance(tvtk.OutlineCornerFilter, args=(),
                                 allow_none=False)

    ######################################################################
    # `Module` interface
    ######################################################################
    def setup_pipeline(self):
        """Override this method so that it *creates* the tvtk
        pipeline.

        This method is invoked when the object is initialized via
        `__init__`.  Note that at the time this method is called, the
        tvtk data pipeline will *not* yet be setup.  So upstream data
        will not be available.  The idea is that you simply create the
        basic objects and setup those parts of the pipeline not
        dependent on upstream sources and filters.  You should also
        set the `actors` attribute up at this point.
        """
        # When any trait on the outline filters change call the render
        # method.
        self._full_outline.on_trait_change(self.render)
        self._cornered_outline.on_trait_change(self.render)

        self.actor = Actor()

    def update_pipeline(self):
        """Override this method so that it *updates* the tvtk pipeline
        when data upstream is known to have changed.

        This method is invoked (automatically) when any of the inputs
        sends a `pipeline_changed` event.
        """
        mm = self.module_manager
        if mm is None:
            return

        self._outline_mode_changed(self.outline_mode)
        self.pipeline_changed = True

    def update_data(self):
        """Override this method so that it flushes the vtk pipeline if
        that is necessary.

        This method is invoked (automatically) when any of the inputs
        sends a `data_changed` event.
        """
        # Just set data_changed, the component should do the rest.
        self.data_changed = True

    def render(self):
        if not is_old_pipeline():
            self.outline_filter.update()
        super(Outline, self).render()

    ######################################################################
    # Non-public methods.
    ######################################################################
    def _outline_mode_changed(self, value):
        """This method is invoked (automatically) when the 'outline_mode'
        attribute is changed.
        """
        # Properties don't fire events, so we fire an event here so UI
        # elements and any listners can update due to the changed mode.
        new = self.outline_filter
        old = self._cornered_outline
        if new is self._full_outline:
            old = self._cornered_outline
        self.trait_property_changed('outline_filter', old, new)

        mm = self.module_manager
        if mm is None:
            return

        # Set the input of the filter.
        self._manual_bounds_changed()

        # The module has a list of outputs, but at this stage,
        # the output of the newly instantiated filter will be its only output.
        self.outputs = [self.outline_filter.output]

    def _get_outline_filter(self):
        if self.outline_mode == 'full':
            return self._full_outline
        else:
            return self._cornered_outline

    def _actor_changed(self, old, new):
        new.scene = self.scene
        new.inputs = [self]
        self._change_components(old, new)

    def _manual_bounds_changed(self):
        if self.manual_bounds:
            if is_old_pipeline():
                self.outline_filter.input = self.outline_source.output
            else:
                self.outline_filter.input_connection = self.outline_source.output_port
        else:
            # Set the input of the filter.
            mm = self.module_manager
            self.configure_connection(self.outline_filter, mm.source)
        self.render()

    def _bounds_changed(self):
        self.outline_filter.update()
        self.pipeline_changed = True

########NEW FILE########
__FILENAME__ = scalar_cut_plane
"""Takes a cut plane of any input data set using an implicit plane and
plots the data with optional contouring and scalar warping.

"""
# Author: Prabhu Ramachandran <prabhu_r@users.sf.net>
# Copyright (c) 2005, Enthought, Inc.
# License: BSD Style.

# Enthought library imports.
from traits.api import Instance, Bool
from traitsui.api import View, Group, Item, InstanceEditor

# Local imports
from mayavi.core.module import Module
from mayavi.core.pipeline_info import PipelineInfo
from mayavi.components.implicit_plane import ImplicitPlane
from mayavi.components.cutter import Cutter
from mayavi.filters.warp_scalar import WarpScalar
from mayavi.components.poly_data_normals import PolyDataNormals
from mayavi.components.contour import Contour
from mayavi.components.actor import Actor


######################################################################
# `ScalarCutPlane` class.
######################################################################
class ScalarCutPlane(Module):

    # The version of this class.  Used for persistence.
    __version__ = 0

    # The implicit plane widget used to place the implicit function.
    implicit_plane = Instance(ImplicitPlane, allow_none=False,
                              record=True)

    # The cutter.  Takes a cut of the data on the implicit plane.
    cutter = Instance(Cutter, allow_none=False, record=True)

    # Specifies if contouring is to be done or not.
    enable_contours = Bool(False, desc='if contours are generated')

    # The Contour component that contours the data.
    contour = Instance(Contour, allow_none=False, record=True)

    # Specifies if scalar warping is to be done or not.
    enable_warp_scalar = Bool(False, desc='if scalar warping is enabled')

    # The WarpScalarCutPlane component that warps the data.
    warp_scalar = Instance(WarpScalar, allow_none=False, record=True)

    # Specify if scalar normals are to be computed to make a smoother surface.
    compute_normals = Bool(False, desc='if normals are to be computed '\
                           'to make the warped scalar surface smoother')

    # The component that computes the scalar normals.
    normals = Instance(PolyDataNormals, allow_none=False, record=True)

    # The actor component that represents the visualization.
    actor = Instance(Actor, allow_none=False, record=True)

    input_info = PipelineInfo(datasets=['any'],
                              attribute_types=['any'],
                              attributes=['scalars'])

    ########################################
    # View related code.

    _warp_group = Group(Item(name='filter',
                             style='custom',
                             editor=\
                             InstanceEditor(view=
                                            View(Item('scale_factor')))),
                        show_labels=False)

    view = View(Group(Item(name='implicit_plane',
                           style='custom'),
                      label='ImplicitPlane',
                      show_labels=False),
                Group(Group(Item(name='enable_contours')),
                      Group(Item(name='contour',
                                 style='custom',
                                 enabled_when='object.enable_contours'),
                            show_labels=False),
                      label='Contours',
                      show_labels=False),
                Group(Item(name='enable_warp_scalar'),
                      Group(Item(name='warp_scalar',
                                 enabled_when='enable_warp_scalar',
                                 style='custom',
                                 editor=InstanceEditor(view=
                                                       View(_warp_group))
                                 ),
                            show_labels=False,
                            ),
                      Item(name='_'),
                      Item(name='compute_normals',
                           enabled_when='enable_warp_scalar'),
                      Item(name='normals',
                           style='custom',
                           show_label=False,
                           enabled_when='compute_normals and enable_warp_scalar'),
                      label='WarpScalar',
                      show_labels=True),
                Group(Item(name='actor',
                           style='custom'),
                      label='Actor',
                      show_labels=False)
                )

    ######################################################################
    # `Module` interface
    ######################################################################
    def setup_pipeline(self):
        """Override this method so that it *creates* the tvtk
        pipeline.

        This method is invoked when the object is initialized via
        `__init__`.  Note that at the time this method is called, the
        tvtk data pipeline will *not* yet be setup.  So upstream data
        will not be available.  The idea is that you simply create the
        basic objects and setup those parts of the pipeline not
        dependent on upstream sources and filters.  You should also
        set the `actors` attribute up at this point.
        """
        # Create the objects.
        self.implicit_plane = ImplicitPlane()
        self.cutter = Cutter()
        self.contour = Contour(auto_contours=True, number_of_contours=10)
        self.warp_scalar = WarpScalar()
        self.normals = PolyDataNormals()
        self.actor = Actor()

        # Setup the actor suitably for this module.
        prop = self.actor.property
        prop.line_width = 2.0

    def update_pipeline(self):
        """Override this method so that it *updates* the tvtk pipeline
        when data upstream is known to have changed.

        This method is invoked (automatically) when any of the inputs
        sends a `pipeline_changed` event.
        """
        mm = self.module_manager
        if mm is None:
            return

        # Data is available, so set the input for the grid plane.
        self.implicit_plane.inputs = [mm.source]

        # Ensure that the warped scalar surface's normal is setup right.
        self.warp_scalar.filter.normal = self.implicit_plane.normal

        # This makes sure that any changes made to enable_warp when
        # the module is not running are updated when it is started --
        # this in turn calls the other functions (normals and
        # contours) internally.
        self._enable_warp_scalar_changed(self.enable_warp_scalar)

        # Set the LUT for the mapper.
        self.actor.set_lut(mm.scalar_lut_manager.lut)

        self.pipeline_changed = True

    def update_data(self):
        """Override this method so that it flushes the vtk pipeline if
        that is necessary.

        This method is invoked (automatically) when any of the inputs
        sends a `data_changed` event.
        """
        # Just set data_changed, the components should do the rest if
        # they are connected.
        self.data_changed = True

    ######################################################################
    # Non-public methods.
    ######################################################################
    def _get_warp_output(self):
        """Helper function to return the warped (or not) output
        depending on settings.
        """
        if self.enable_warp_scalar:
            if self.compute_normals:
                return self.normals
            else:
                return self.warp_scalar
        else:
            return self.cutter

    def _get_contour_output(self):
        """Helper function to return the contoured (and warped (or
        not)) output depending on settings.
        """
        if self.enable_contours:
            return self.contour
        else:
            return self._get_warp_output()

    def _filled_contours_changed_for_contour(self, value):
        """When filled contours are enabled, the mapper should use the
        the cell data, otherwise it should use the default scalar
        mode.
        """
        if value:
            self.actor.mapper.scalar_mode = 'use_cell_data'
        else:
            self.actor.mapper.scalar_mode = 'default'
        self.render()

    def _enable_warp_scalar_changed(self, value):
        """Turns on and off the scalar warping."""
        if self.module_manager is None:
            return

        if value:
            self.warp_scalar.inputs = [self.cutter]
        else:
            self.warp_scalar.inputs = []
        self._compute_normals_changed(self.compute_normals)
        self.render()

    def _compute_normals_changed(self, value):
        if self.module_manager is None:
            return

        if self.enable_warp_scalar:
            normals = self.normals
            if value:
                normals.inputs = [self.warp_scalar]
            else:
                normals.inputs = []
        self._enable_contours_changed(self.enable_contours)
        self.render()

    def _enable_contours_changed(self, value):
        """Turns on and off the contours."""
        if self.module_manager is None:
            return

        actor = self.actor
        if value:
            self.contour.inputs = [self._get_warp_output()]
            actor.inputs = [self._get_contour_output()]
            if self.contour.filled_contours:
                actor.mapper.scalar_mode = 'use_cell_data'
        else:
            self.contour.inputs = []
            actor.inputs = [self._get_warp_output()]
            actor.mapper.scalar_mode = 'default'
        self.render()

    def _normals_changed(self, old, new):
        warp_scalar = self.warp_scalar
        if warp_scalar is not None:
            new.inputs = [warp_scalar]
            self._compute_normals_changed(self.compute_normals)
        self._change_components(old, new)

    def _implicit_plane_changed(self, old, new):
        cutter = self.cutter
        if cutter is not None:
            cutter.cut_function = new.plane
            cutter.inputs = [new]
            # Update the pipeline.
            self._enable_warp_scalar_changed(self.enable_warp_scalar)
        # Hook up events to set the normals of the warp filter.
        if old is not None:
            old.widget.on_trait_change(self._update_normal, 'normal', remove=True)
        new.widget.on_trait_change(self._update_normal, 'normal')
        self._change_components(old, new)

    def _cutter_changed(self, old, new):
        ip = self.implicit_plane
        if ip is not None:
            new.cut_function = ip.plane
            new.inputs = [ip]
            # Update the pipeline.
            self._enable_warp_scalar_changed(self.enable_warp_scalar)
        self._change_components(old, new)

    def _contour_changed(self, old, new):
        # Update the pipeline.
        self._enable_contours_changed(self.enable_contours)
        self._change_components(old, new)

    def _warp_scalar_changed(self, old, new):
        # Update the pipeline.
        self._enable_warp_scalar_changed(self.enable_warp_scalar)
        self._change_components(old, new)

    def _actor_changed(self, old, new):
        # Update the pipeline.
        self._enable_contours_changed(self.enable_contours)
        self._change_components(old, new)

    def _update_normal(self):
        """Invoked when the orientation of the implicit plane changes.
        """
        ws = self.warp_scalar
        if ws is not None:
            ws.filter.normal = self.implicit_plane.widget.normal


########NEW FILE########
__FILENAME__ = skeleton_module
"""Module documentation goes here."""

# Enthought library imports.
from traits.api import Instance
from traitsui.api import View, Group, Item
from tvtk.api import tvtk

# Local imports
from mayavi.core.module import Module
from mayavi.components.actor import Actor


######################################################################
# `MyModule` class.
######################################################################
class MyModule(Module):

    # The version of this class.  Used for persistence.
    __version__ = 0

    # The actor component that represents the visualization.
    actor = Instance(Actor)

    ########################################
    # View related code.


    ######################################################################
    # `Module` interface
    ######################################################################
    def setup_pipeline(self):
        """Override this method so that it *creates* the tvtk
        pipeline.

        This method is invoked when the object is initialized via
        `__init__`.  Note that at the time this method is called, the
        tvtk data pipeline will *not* yet be setup.  So upstream data
        will not be available.  The idea is that you simply create the
        basic objects and setup those parts of the pipeline not
        dependent on upstream sources and filters.  You should also
        set the `actors` attribute up at this point.
        """
        # Create the components and set them up.

        # Setup the actor suitably for this module.

        # Setup the components, actors and widgets. (sample code)
        #self.components.extend([your_components, ...])
        #self.actors.append(your_actor)
        # Note that self.actor.actor need not be added.
        #self.widgets.append(your_widget)

    def update_pipeline(self):
        """Override this method so that it *updates* the tvtk pipeline
        when data upstream is known to have changed.

        This method is invoked (automatically) when any of the inputs
        sends a `pipeline_changed` event.
        """
        # Data is available, so set the input for the grid plane.
        # Do your stuff here!

        # Now flush the pipeline
        self.pipeline_changed = True

    def update_data(self):
        """Override this method so that it flushes the vtk pipeline if
        that is necessary.

        This method is invoked (automatically) when any of the inputs
        sends a `data_changed` event.
        """
        # Just set data_changed, the components should do the rest if
        # they are connected.
        self.data_changed = True

    ######################################################################
    # Non-public methods.
    ######################################################################

########NEW FILE########
__FILENAME__ = slice_unstructured_grid
"""This module takes a slice of the unstructured grid data and shows
the cells that intersect or touch the slice."""

# Enthought library imports.
from traits.api import Instance
from traitsui.api import View, Group, Item
from tvtk.api import tvtk

# Local imports
from mayavi.core.module import Module
from mayavi.core.pipeline_info import PipelineInfo
from mayavi.components.implicit_plane import ImplicitPlane
from mayavi.components.actor import Actor
from mayavi.core.common import error


######################################################################
# `MyModule` class.
######################################################################
class SliceUnstructuredGrid(Module):
    """This module takes a slice of the unstructured grid data and
    shows the cells that intersect or touch the slice."""

    # The version of this class.  Used for persistence.
    __version__ = 0

    # The implicit plane widget.
    implicit_plane = Instance(ImplicitPlane, allow_none=False,
                              record=True)

    # Extract the cells to display.
    extract_geometry = Instance(tvtk.ExtractGeometry, allow_none=False,
                                record=True)

    # The geometry filter.
    geom_filter = Instance(tvtk.GeometryFilter, allow_none=False,
                           record=True)

    # The actor component that represents the visualization.
    actor = Instance(Actor, allow_none=False, record=True)

    input_info = PipelineInfo(datasets=['unstructured_grid'],
                              attribute_types=['any'],
                              attributes=['any'])

    ########################################
    # View related code.

    view = View(Group(Item(name='implicit_plane', style='custom'),
                      label='ImplicitPlane',
                      show_labels=False),
                Group(Item(name='extract_geometry', style='custom',
                           resizable=True),
                      label='Extract Geometry',
                      show_labels=False),
                Group(Item(name='geom_filter', style='custom',
                           resizable=True),
                      label='Geometry Filter',
                      show_labels=False),
                Group(Item(name='actor', style='custom'),
                      label='Actor',
                      show_labels=False)
                )

    ######################################################################
    # `Module` interface
    ######################################################################
    def setup_pipeline(self):
        """Override this method so that it *creates* the tvtk
        pipeline.

        This method is invoked when the object is initialized via
        `__init__`.  Note that at the time this method is called, the
        tvtk data pipeline will *not* yet be setup.  So upstream data
        will not be available.  The idea is that you simply create the
        basic objects and setup those parts of the pipeline not
        dependent on upstream sources and filters.  You should also
        set the `actors` attribute up at this point.
        """
        # Create the components and set them up.
        self.implicit_plane = ImplicitPlane()
        ex = tvtk.ExtractGeometry(extract_only_boundary_cells=1,
                                  extract_boundary_cells=1)
        self.extract_geometry = ex
        self.geom_filter = tvtk.GeometryFilter()

        # Setup the actor suitably for this module.
        self.actor = Actor()
        self.actor.property.representation = 'w'

    def update_pipeline(self):
        """Override this method so that it *updates* the tvtk pipeline
        when data upstream is known to have changed.

        This method is invoked (automatically) when any of the inputs
        sends a `pipeline_changed` event.
        """
        mod_mgr = self.module_manager
        if mod_mgr is None:
            return

        # Data is available, so set the input for the grid plane.
        input = mod_mgr.source.outputs[0]
        if not input.is_a('vtkUnstructuredGrid'):
            error('SliceUnstructuredGrid only works with input '\
                  'unstructured grids')
        self.implicit_plane.inputs = [mod_mgr.source]
        src = self.module_manager.source
        self.configure_connection(self.extract_geometry, src)

        # Set the LUT for the mapper.
        self.actor.set_lut(self.module_manager.scalar_lut_manager.lut)

        # Now flush the pipeline
        self.pipeline_changed = True

    def update_data(self):
        """Override this method so that it flushes the vtk pipeline if
        that is necessary.

        This method is invoked (automatically) when any of the inputs
        sends a `data_changed` event.
        """
        # Just set data_changed, the components should do the rest if
        # they are connected.
        self.data_changed = True

    ######################################################################
    # Non-public methods.
    ######################################################################
    def _implicit_plane_changed(self, old, new):
        ex = self.extract_geometry
        if ex is not None:
            ex.implicit_function = new.plane
        self._change_components(old, new)

    def _extract_geometry_changed(self, old, new):
        if old is not None:
            old.on_trait_change(self.render, remove=True)

        mm = self.module_manager
        if mm is not None:
            src = mm.source
            self.configure_connection(new, src)
        ip = self.implicit_plane
        if ip is not None:
            new.implicit_function = ip.plane
        gf = self.geom_filter
        if gf is not None:
            gf.input_connection = new.output_port

        new.on_trait_change(self.render)
        self.update_pipeline()

    def _geom_filter_changed(self, old, new):
        if old is not None:
            old.on_trait_change(self.render, remove=True)

        ex = self.extract_geometry
        if ex is not None:
            new.input_connection = ex.output_port

        new.on_trait_change(self.render)
        self.outputs = [new.output]

    def _actor_changed(self, old, new):
        new.scene = self.scene
        new.inputs = [self]
        self._change_components(old, new)


########NEW FILE########
__FILENAME__ = streamline
"""Allows the user to draw streamlines for given vector data.  This
supports various types of seed objects (line, sphere, plane and point
seeds).  It also allows the user to draw ribbons or tubes and further
supports different types of interactive modes of calculating the
streamlines.
"""
# Author: Prabhu Ramachandran <prabhu_r@users.sf.net>
# Copyright (c) 2005, Enthought, Inc.
# License: BSD Style.

# Standard library imports.
from math import sqrt

# Enthought library imports.
from traits.api import Instance, Bool, TraitPrefixList, Trait, \
                             Delegate, Button
from traitsui.api import View, Group, Item, InstanceEditor
from tvtk.api import tvtk
from tvtk.common import configure_outputs

# Local imports
from mayavi.core.module import Module
from mayavi.core.pipeline_info import PipelineInfo
from mayavi.components.actor import Actor
from mayavi.components.source_widget import SourceWidget


######################################################################
# `Streamline` class.
######################################################################
class Streamline(Module):

    # The version of this class.  Used for persistence.
    __version__ = 0

    # The streamline generator.
    stream_tracer = Instance(tvtk.StreamTracer, allow_none=False,
                             record=True)

    # The seed for the streamlines.
    seed = Instance(SourceWidget, allow_none=False, record=True)

    # The update mode of the seed -- this is delegated to the
    # SourceWidget.
    update_mode = Delegate('seed', modify=True)

    # Determines if the streamlines are shown as lines or ribbons or
    # tubes.
    streamline_type = Trait('line', TraitPrefixList(['line', 'ribbon',
                                                      'tube']),
                            desc='draw streamlines as lines/ribbons/tubes')

    # The ribbon filter.
    ribbon_filter = Instance(tvtk.RibbonFilter, allow_none=False,
                             record=True)

    # The tube filter.
    tube_filter = Instance(tvtk.TubeFilter, allow_none=False,
                           record=True)

    # The actor component that represents the visualization.
    actor = Instance(Actor, allow_none=False, record=True)

    input_info = PipelineInfo(datasets=['any'],
                              attribute_types=['any'],
                              attributes=['vectors'])

    ########################################
    # Private traits.

    _first = Bool(True)

    ########################################
    # View related code.

    # A button to update the streamlines.
    update_streamlines = Button('Update Streamlines')

    _tube_group = Group(Item(name='capping'),
                        Item(name='sides_share_vertices'),
                        Item(name='vary_radius'),
                        Item(name='number_of_sides'),
                        Item(name='radius'),
                        Item(name='radius_factor'),
                        Item(name='offset'),
                        Item(name='on_ratio')
                        )

    _ribbon_group = Group(Item(name='vary_width'),
                          Item(name='width'),
                          Item(name='width_factor'),
                          Item(name='angle')
                          )

    view = View(Group(Group(Item(name='update_mode'),
                            ),
                      Group(Item(name='update_streamlines'),
                            show_labels=False,
                            ),
                      Group(Item(name='streamline_type'),
                            Item(name='ribbon_filter', style='custom',
                                 visible_when='object.streamline_type == "ribbon"',
                                 editor=InstanceEditor(view=View(_ribbon_group))),
                            Item(name='tube_filter', style='custom',
                                 visible_when='object.streamline_type == "tube"',
                                 editor=InstanceEditor(view=View(_tube_group))),
                            show_labels=False,
                            label='Streamline'
                            ),
                      label='Streamline'
                      ),
                Group(Item(name='seed', style='custom', resizable=True),
                      label='Seed',
                      show_labels=False),
                Group(Item(name='stream_tracer', style='custom', resizable=True),
                      label='StreamTracer',
                      show_labels=False),
                Group(Item(name='actor', style='custom'),
                      label='Actor',
                      show_labels=False),
                resizable=True
                )

    ######################################################################
    # `Module` interface
    ######################################################################
    def setup_pipeline(self):
        """Override this method so that it *creates* the tvtk
        pipeline.

        This method is invoked when the object is initialized via
        `__init__`.  Note that at the time this method is called, the
        tvtk data pipeline will *not* yet be setup.  So upstream data
        will not be available.  The idea is that you simply create the
        basic objects and setup those parts of the pipeline not
        dependent on upstream sources and filters.  You should also
        set the `actors` attribute up at this point.
        """
        # Create and setup the default objects.
        self.seed = SourceWidget()
        self.stream_tracer = tvtk.StreamTracer(maximum_propagation=50,
                                               integration_direction='forward',
                                               compute_vorticity=True,
                                               integrator_type='runge_kutta4',
                                               )
        self.ribbon_filter = tvtk.RibbonFilter()
        self.tube_filter = tvtk.TubeFilter()

        self.actor = Actor()
        # Setup the actor suitably for this module.
        self.actor.property.line_width = 2.0

    def update_pipeline(self):
        """Override this method so that it *updates* the tvtk pipeline
        when data upstream is known to have changed.

        This method is invoked (automatically) when any of the inputs
        sends a `pipeline_changed` event.
        """
        mm = self.module_manager
        if mm is None:
            return

        src = mm.source
        self.configure_connection(self.stream_tracer, src)
        self.seed.inputs = [src]

        # Setup the radius/width of the tube/ribbon filters based on
        # given input.
        if self._first:
            b = src.outputs[0].bounds
            l = [(b[1]-b[0]), (b[3]-b[2]), (b[5]-b[4])]
            length = sqrt(l[0]*l[0] + l[1]*l[1] + l[2]*l[2])
            self.ribbon_filter.width = length*0.0075
            self.tube_filter.radius = length*0.0075
            self._first = False

        self._streamline_type_changed(self.streamline_type)
        # Set the LUT for the mapper.
        self.actor.set_lut(mm.scalar_lut_manager.lut)

        self.pipeline_changed = True

    def update_data(self):
        """Override this method so that it flushes the vtk pipeline if
        that is necessary.

        This method is invoked (automatically) when any of the inputs
        sends a `data_changed` event.
        """
        # Just set data_changed, the components should do the rest if
        # they are connected.
        self.data_changed = True

    ######################################################################
    # Non-public methods.
    ######################################################################
    def _streamline_type_changed(self, value):
        if self.module_manager is None:
            return
        st = self.stream_tracer
        rf = self.ribbon_filter
        tf = self.tube_filter
        if value == 'line':
            configure_outputs(self, st)
        elif value == 'ribbon':
            self.configure_connection(rf, st)
            configure_outputs(self, rf)
        elif value == 'tube':
            self.configure_connection(tf, st)
            configure_outputs(self, tf)
        self.render()

    def _update_streamlines_fired(self):
        self.seed.update_poly_data()
        self.stream_tracer.update()
        self.render()

    def _stream_tracer_changed(self, old, new):
        if old is not None:
            old.on_trait_change(self.render, remove=True)
        seed = self.seed
        if seed is not None:
            self.configure_source_data(new, seed.poly_data)
        new.on_trait_change(self.render)
        mm = self.module_manager
        if mm is not None:
            src = mm.source
            self.configure_connection(new, src)

        # A default output so there are no pipeline errors.  The
        # update_pipeline call corrects this if needed.
        self.outputs = [new.output]

        self.update_pipeline()

    def _seed_changed(self, old, new):
        st = self.stream_tracer
        if st is not None:
            self.configure_source_data(st, new.poly_data)
        self._change_components(old, new)

    def _ribbon_filter_changed(self, old, new):
        if old is not None:
            old.on_trait_change(self.render, remove=True)
        new.on_trait_change(self.render)
        self._streamline_type_changed(self.streamline_type)

    def _tube_filter_changed(self, old, new):
        if old is not None:
            old.on_trait_change(self.render, remove=True)
        new.on_trait_change(self.render)
        self._streamline_type_changed(self.streamline_type)

    def _actor_changed(self, old, new):
        new.scene = self.scene
        new.inputs = [self]
        self._change_components(old, new)

########NEW FILE########
__FILENAME__ = structured_grid_outline
"""Draws a grid-conforming outline for structured grids.
"""
# Author: Prabhu Ramachandran <prabhu@aero.iitb.ac.in>
# Copyright (c) 2007,  Enthought, Inc.
# License: BSD Style.


# Enthought library imports.
from traits.api import Instance
from tvtk.api import tvtk

# Local imports.
from mayavi.components.actor import Actor
from mayavi.modules.outline import Outline


######################################################################
# `StructuredGridOutline` class.
######################################################################
class StructuredGridOutline(Outline):
    """Draws a grid-conforming outline for structured grids.
    """

    # The outline filter.
    outline_filter = Instance(tvtk.StructuredGridOutlineFilter,
                              allow_none = False, record=True)

    def setup_pipeline(self):
        self.outline_filter = tvtk.StructuredGridOutlineFilter()
        self.actor = Actor()


########NEW FILE########
__FILENAME__ = surface
"""Draws a surface for any input dataset with optional contouring.
"""
# Author: Prabhu Ramachandran <prabhu_r@users.sf.net>
# Copyright (c) 2005, Enthought, Inc.
# License: BSD Style.


# Enthought library imports.
from traits.api import Instance, Bool
from tvtk.api import tvtk

# Local imports
from mayavi.core.pipeline_info import PipelineInfo
from mayavi.core.module import Module
from mayavi.components.contour import Contour
from mayavi.components.actor import Actor


######################################################################
# `Surface` class.
######################################################################
class Surface(Module):
    # The version of this class.  Used for persistence.
    __version__ = 0

    # Specifies if contouring is to be done or not.
    enable_contours = Bool(False, desc='if contours are generated')

    # The contour component that contours the data.
    contour = Instance(Contour, allow_none=False, record=True)

    # The actor component that represents the visualization.
    actor = Instance(Actor, allow_none=False, record=True)

    input_info = PipelineInfo(datasets=['any'],
                              attribute_types=['any'],
                              attributes=['any'])

    ######################################################################
    # `Module` interface
    ######################################################################
    def setup_pipeline(self):
        """Override this method so that it *creates* the tvtk
        pipeline.

        This method is invoked when the object is initialized via
        `__init__`.  Note that at the time this method is called, the
        tvtk data pipeline will *not* yet be setup.  So upstream data
        will not be available.  The idea is that you simply create the
        basic objects and setup those parts of the pipeline not
        dependent on upstream sources and filters.  You should also
        set the `actors` attribute up at this point.
        """
        # Setup the objects.
        self.contour = Contour(auto_contours=True, number_of_contours=10)
        self.actor = Actor()
        # Setup the actor suitably for this module.
        self.actor.property.line_width = 2.0

    def update_pipeline(self):
        """Override this method so that it *updates* the tvtk pipeline
        when data upstream is known to have changed.

        This method is invoked (automatically) when any of the inputs
        sends a `pipeline_changed` event.
        """
        mm = self.module_manager
        if mm is None:
            return

        # This makes sure that any changes made to enable_contours
        # when the module is not running are updated when it is
        # started.  Also sets up the pipeline and inputs correctly.
        self._enable_contours_changed(self.enable_contours)
        # Set the LUT for the mapper.
        self.actor.set_lut(mm.scalar_lut_manager.lut)

        self.pipeline_changed = True

    def update_data(self):
        """Override this method so that it flushes the vtk pipeline if
        that is necessary.

        This method is invoked (automatically) when any of the inputs
        sends a `data_changed` event.
        """
        # Just set data_changed, the components should do the rest if
        # they are connected.
        self.data_changed = True

    ######################################################################
    # Non-public methods.
    ######################################################################
    def _filled_contours_changed(self, value):
        """When filled contours are enabled, the mapper should use the
        the cell data, otherwise it should use the default scalar
        mode.
        """
        if value:
            self.actor.mapper.scalar_mode = 'use_cell_data'
        else:
            self.actor.mapper.scalar_mode = 'default'
        self.render()

    def _enable_contours_changed(self, value):
        """Turns on and off the contours."""
        if self.module_manager is None:
            return
        if value:
            self.contour.inputs = [self.module_manager.source]
            self.actor.inputs = [self.contour]
            if self.contour.filled_contours:
                self.actor.mapper.scalar_mode = 'use_cell_data'
        else:
            old_inputs = self.actor.inputs
            self.actor.inputs = [self.module_manager.source]
            self.actor.mapper.scalar_mode = 'default'
        self.render()

    def _contour_changed(self, old, new):
        if old is not None:
            old.on_trait_change(self._filled_contours_changed,
                                'filled_contours',
                                remove=True)
        new.on_trait_change(self._filled_contours_changed,
                            'filled_contours')
        self._change_components(old, new)

    def _actor_changed(self, old, new):
        if old is None:
            # First time the actor is set.
            new.mapper = tvtk.DataSetMapper(use_lookup_table_scalar_range=1)
        new.scene = self.scene
        mm = self.module_manager
        if mm is not None:
            new.inputs = [mm.source]
        self._change_components(old, new)


########NEW FILE########
__FILENAME__ = tensor_glyph
""" Displays tensor glyphs oriented and colored as per scalar or vector data at
the input points.

"""
# Authors: KK Rai (kk.rai [at] iitb.ac.in)
#          R. Ambareesha (ambareesha [at] iitb.ac.in)
#          Prabhu Ramachandran <prabhu_r@users.sf.net>

# Enthought library imports.
from traits.api import Instance
from traitsui.api import View, Group, Item

# Local imports
from mayavi.core.pipeline_info import PipelineInfo
from mayavi.core.module import Module
from mayavi.components.actor import Actor
from mayavi.components import glyph

######################################################################
# `TensorGlyph` class.
######################################################################
class TensorGlyph(Module):
    # The version of this class.  Used for persistence.
    __version__ = 0

    # The glyph component we use to do the actual glyphing.
    glyph = Instance(glyph.Glyph, allow_none=False, record=True)

    # The actor.
    actor = Instance(Actor, allow_none=False, record=True)

    input_info = PipelineInfo(datasets=['any'],
                              attribute_types=['any'],
                              attributes=['tensors'])

    # Create the UI for the traits.
    view = View(Group(Item(name='actor', style='custom'),
                      show_labels=False,
                      label='Actor'),
                Group(Item(name='glyph', style='custom',
                           resizable=True),
                      label='Tensor Glyph',
                      selected=True,
                      show_labels=False
                      ))

    ######################################################################
    # `Module` interface
    ######################################################################
    def setup_pipeline(self):
        """Override this method so that it *creates* the tvtk
        pipeline.

        This method is invoked when the object is initialized via
        `__init__`. Note that at the time this method is called, the
        tvtk data pipeline will *not* yet be setup.  So upstream data
        will not be available.  The idea is that you simply create the
        basic objects and setup those parts of the pipeline not
        dependent on upstream sources and filters.  You should also
        set the `actors` attribute up at this point.
        """
        # Setup the glyphs.
        self.glyph = glyph.Glyph(glyph_type='tensor')
        self.glyph.glyph_source.glyph_source = self.glyph.glyph_source.glyph_list[4]
        self.actor = Actor()

    def update_pipeline(self):
        """Override this method so that it *updates* the tvtk pipeline
        when data upstream is known to have changed.

        This method is invoked (automatically) when any of the inputs
        sends a `pipeline_changed` event.
        """
        mm = self.module_manager
        if mm is None:
            return
        self.glyph.inputs = [mm.source]
        self.pipeline_changed = True

    def update_data(self):
        """Override this method so that it flushes the vtk pipeline if
        that is necessary.

        This method is invoked (automatically) when any of the inputs
        sends a `data_changed` event.
        """
        # Just set data_changed, the component should do the rest.
        self.data_changed = True

    ######################################################################
    # Non-public methods.
    ######################################################################

    def _glyph_changed(self, old, new):
        # Set the glyph's module attribute -- this is important!
        new.module = self
        # Setup actors inputs.
        actor = self.actor
        if actor is not None:
            actor.inputs = [new]
        self._change_components(old, new)


    def _actor_changed(self, old, new):
        new.scene = self.scene
        #new.inputs = [self]
        g = self.glyph
        if g is not None:
            new.inputs = [g]
        self._change_components(old, new)

########NEW FILE########
__FILENAME__ = text
"""This module allows the user to place text on the screen.

"""
# Author: Prabhu Ramachandran <prabhu_r@users.sf.net>
# Copyright (c) 2005, Enthought, Inc.
# License: BSD Style.

from distutils.version import StrictVersion

# Enthought library imports.
from traits.api import Instance, Range, Str, Bool, Property, \
                                    Float
from traitsui.api import View, Group, Item, InstanceEditor
from tvtk.api import tvtk
from apptools.persistence import state_pickler

# Local imports
from mayavi.core.module import Module
from mayavi.core.pipeline_info import PipelineInfo

VTK_VER = StrictVersion(tvtk.Version().vtk_version)


######################################################################
# `Text` class.
######################################################################
class Text(Module):
    # The version of this class.  Used for persistence.
    __version__ = 0

    # The tvtk TextActor.
    actor = Instance(tvtk.TextActor, allow_none=False, record=True)

    # The property of the axes (color etc.).
    property = Property(record=True)

    # The text to be displayed.  Note that this should really be `Str`
    # but wxGTK only returns unicode.
    text = Str('Text', desc='the text to be displayed')

    # The x-position of this actor.
    x_position = Float(0.0, desc='the x-coordinate of the text')

    # The y-position of this actor.
    y_position = Float(0.0, desc='the y-coordinate of the text')

    # The z-position of this actor.
    z_position = Float(0.0, desc='the z-coordinate of the text')

    # Shadow the positions as ranges for 2D. Simply using a RangeEditor
    # does not work as it resets the 3D positions to 1 when the dialog is
    # loaded.
    _x_position_2d = Range(0., 1., 0., enter_set=True, auto_set=False,
                           desc='the x-coordinate of the text')
    _y_position_2d = Range(0., 1., 0., enter_set=True, auto_set=False,
                           desc='the y-coordinate of the text')

    # 3D position
    position_in_3d = Bool(False,
                    desc='whether the position of the object is given in 2D or in 3D')

    # The width of the text.
    width = Range(0.0, 1.0, 0.4, enter_set=True, auto_set=False,
                  desc='the width of the text as a fraction of the viewport')

    input_info = PipelineInfo(datasets=['any'],
                              attribute_types=['any'],
                              attributes=['any'])

    ########################################
    # The view of this object.

    if VTK_VER > '5.1':
        _text_actor_group = Group(Item(name='visibility'),
                                  Item(name='text_scale_mode'),
                                  Item(name='alignment_point'),
                                  Item(name='minimum_size'),
                                  Item(name='maximum_line_height'),
                                  show_border=True,
                                  label='Text Actor')
    else:
        _text_actor_group = Group(Item(name='visibility'),
                                  Item(name='scaled_text'),
                                  Item(name='alignment_point'),
                                  Item(name='minimum_size'),
                                  Item(name='maximum_line_height'),
                                  show_border=True,
                                  label='Text Actor')

    _position_group_2d = Group(Item(name='_x_position_2d',
                                    label='X position'),
                               Item(name='_y_position_2d',
                                    label='Y position'),
                               visible_when='not position_in_3d')

    _position_group_3d = Group(Item(name='x_position', label='X',
                                            springy=True),
                               Item(name='y_position', label='Y',
                                            springy=True),
                               Item(name='z_position', label='Z',
                                            springy=True),
                               show_border=True,
                               label='Position',
                               orientation='horizontal',
                               visible_when='position_in_3d')

    view = View(Group(Group(Item(name='text'),
                            Item(name='position_in_3d'),
                            _position_group_2d,
                            _position_group_3d,
                            Item(name='width',
                                 enabled_when='object.actor.scaled_text'),
                            ),
                      Group(Item(name='actor', style='custom',
                                 editor=\
                                 InstanceEditor(view=View(_text_actor_group))
                                 ),
                            show_labels=False),
                      label='TextActor',
                      show_labels=False
                      ),
                Group(Item(name='_property', style='custom', resizable=True),
                      label='TextProperty',
                      show_labels=False),
                )

    ########################################
    # Private traits.
    _updating = Bool(False)
    _property = Instance(tvtk.TextProperty)

    ######################################################################
    # `object` interface
    ######################################################################
    def __set_pure_state__(self, state):
        self._updating = True
        state_pickler.set_state(self, state, first=['actor'],
                                ignore=['_updating'])
        self._updating = False

    ######################################################################
    # `Module` interface
    ######################################################################
    def setup_pipeline(self):
        """Override this method so that it *creates* the tvtk
        pipeline.

        This method is invoked when the object is initialized via
        `__init__`.  Note that at the time this method is called, the
        tvtk data pipeline will *not* yet be setup.  So upstream data
        will not be available.  The idea is that you simply create the
        basic objects and setup those parts of the pipeline not
        dependent on upstream sources and filters.  You should also
        set the `actors` attribute up at this point.
        """
        actor = self.actor = tvtk.TextActor(input=str(self.text))
        if VTK_VER > '5.1':
            actor.set(text_scale_mode='prop', width=0.4, height=1.0)
        else:
            actor.set(scaled_text=True, width=0.4, height=1.0)

        c = actor.position_coordinate
        c.set(coordinate_system='normalized_viewport',
              value=(self.x_position, self.y_position, 0.0))
        c = actor.position2_coordinate
        c.set(coordinate_system='normalized_viewport')

        self._property.opacity = 1.0

        self._text_changed(self.text)
        self._width_changed(self.width)
        self._shadow_positions(True)

    def update_pipeline(self):
        """Override this method so that it *updates* the tvtk pipeline
        when data upstream is known to have changed.

        This method is invoked (automatically) when any of the inputs
        sends a `pipeline_changed` event.
        """
        self.pipeline_changed = True

    def update_data(self):
        """Override this method so that it flushes the vtk pipeline if
        that is necessary.

        This method is invoked (automatically) when any of the inputs
        sends a `data_changed` event.
        """
        # Just set data_changed, the component should do the rest.
        self.data_changed = True

    ######################################################################
    # Non-public interface
    ######################################################################
    def _text_changed(self, value):
        actor = self.actor
        if actor is None:
            return
        if self._updating:
            return
        actor.input = str(value)
        self.render()

    def _shadow_positions(self, value):
        self.sync_trait('x_position', self, '_x_position_2d',
                            remove=(not value))
        self.sync_trait('y_position', self, '_y_position_2d',
                            remove=(not value))
        if not value:
            self._x_position_2d = self.x_position
            self._y_position_2d = self.y_position

    def _position_in_3d_changed(self, value):
        if value:
            self.actor.position_coordinate.coordinate_system='world'
            self.actor.position2_coordinate.coordinate_system='world'
        else:
            self.actor.position2_coordinate.coordinate_system=\
                                            'normalized_viewport'
            self.actor.position_coordinate.coordinate_system=\
                                            'normalized_viewport'
            x = self.x_position
            y = self.y_position
            if x < 0:
                x = 0
            elif x > 1:
                x = 1
            if y < 0:
                y = 0
            elif y > 1:
                y = 1
            self.set(x_position=x, y_position=y,
                                                    trait_change_notify=False)
        self._shadow_positions(not value)
        self._change_position()
        self.actor._width_changed(self.width, self.width)
        self.pipeline_changed = True

    def _change_position(self):
        """ Callback for _x_position, _y_position, and z_position.
        """
        actor = self.actor
        if actor is None:
            return
        if self._updating:
            return
        x = self.x_position
        y = self.y_position
        z = self.z_position
        if self.position_in_3d:
            actor.position_coordinate.value = x, y, z
        else:
            actor.position = x, y
        self.render()

    _x_position_changed = _change_position

    _y_position_changed = _change_position

    _z_position_changed = _change_position

    def _width_changed(self, value):
        actor = self.actor
        if actor is None:
            return
        if self._updating:
            return
        actor.width = value
        self.render()

    def _update_traits(self):
        self._updating = True
        try:
            actor = self.actor
            self.text = actor.input
            pos = actor.position
            self.x_position, self.y_position = pos
            self.width = actor.width
        finally:
            self._updating = False

    def _get_property(self):
        return self._property

    def _actor_changed(self, old, new):
        if old is not None:
            for obj in (old, self._property):
                obj.on_trait_change(self.render, remove=True)
            old.on_trait_change(self._update_traits, remove=True)

        self._property = new.text_property
        for obj in (new, self._property):
            obj.on_trait_change(self.render)
        new.on_trait_change(self._update_traits)

        self.actors = [new]
        self.render()

    def _foreground_changed_for_scene(self, old, new):
        # Change the default color for the actor.
        self.property.color = new
        self.render()

    def _scene_changed(self, old, new):
        super(Text, self)._scene_changed(old, new)
        self._foreground_changed_for_scene(None, new.foreground)

########NEW FILE########
__FILENAME__ = text3d
""" This module allows the user to place text in 3D at a location on the
scene.

Unlike the 'Text' module, this module positions text in 3D in the scene,
and in 2D on the screen. As a result the text resizes with the figure,
and can be masked by objects in the foreground.
"""
# Author: Gael Varoquaux <gael dot varoquaux at normalesup dot org>
# Copyright (c) 2009, Enthought, Inc.
# License: BSD Style.

# Enthought library imports.
from traits.api import Instance, Str, CArray, Bool
from traitsui.api import View, Group, Item

# Local imports
from tvtk.api import tvtk
from mayavi.core.module import Module
from mayavi.core.pipeline_info import PipelineInfo
from mayavi.components.actor import Actor

######################################################################
# `Text3D` class.
######################################################################

class Text3D(Module):
    # The version of this class.  Used for persistence.
    __version__ = 0

    # The Mayavi Actor.
    actor = Instance(Actor, allow_none=False, record=True)

    # And the text source
    vector_text = Instance(tvtk.VectorText, allow_none=False, record=True)

    # The text to be displayed.
    text = Str('Text', desc='the text to be displayed',
                       enter_set=True, auto_set=False)

    # The position of the actor
    position = CArray(value=(0., 0., 0.), cols=3,
                      desc='the world coordinates of the text',
                      enter_set=True, auto_set=False)

    # The scale of the actor
    scale = CArray(value=(1., 1., 1.), cols=3,
                      desc='the scale of the text',
                      enter_set=True, auto_set=False)

    # The orientation of the actor
    orientation = CArray(value=(0., 0., 0.), cols=3,
                      desc='the orientation angles of the text',
                      enter_set=True, auto_set=False)

    # Orient actor to camera
    orient_to_camera = Bool(True,
                      desc='if the text is kept facing the camera')

    input_info = PipelineInfo(datasets=['any'],
                              attribute_types=['any'],
                              attributes=['any'])

    ########################################
    # The view of this object.

    view = View(Group(Item(name='text'),
                      Group(Item(name='position'),
                        show_labels=False, show_border=True,
                        label='Position'),
                      Group(Item(name='scale'),
                        show_labels=False, show_border=True,
                        label='Scale'),
                      Group(
                           Item(name='orient_to_camera'),
                           Item(name='orientation',
                                 label='Angles'),
                        show_border=True,
                        label='Orientation'),
                      label='Text',
                      ),
                  Group(Item(name='actor', style='custom',
                             show_label=False),
                      label='Actor'),
                )

    ######################################################################
    # `Module` interface
    ######################################################################
    def setup_pipeline(self):
        """Override this method so that it *creates* the tvtk
        pipeline.

        This method is invoked when the object is initialized via
        `__init__`.  Note that at the time this method is called, the
        tvtk data pipeline will *not* yet be setup.  So upstream data
        will not be available.  The idea is that you simply create the
        basic objects and setup those parts of the pipeline not
        dependent on upstream sources and filters.  You should also
        set the `actors` attribute up at this point.
        """
        self.vector_text = tvtk.VectorText(text=self.text)
        self.outputs = [self.vector_text.output]
        self.actor = Actor()
        self._text_changed(self.text)


    def update_pipeline(self):
        """Override this method so that it *updates* the tvtk pipeline
        when data upstream is known to have changed.

        This method is invoked (automatically) when any of the inputs
        sends a `pipeline_changed` event.
        """
        self.pipeline_changed = True


    ######################################################################
    # Non-public interface
    ######################################################################
    def _text_changed(self, value):
        vector_text = self.vector_text
        if vector_text is None:
            return
        vector_text.text = str(value)
        self.render()


    def _actor_changed(self, old, new):
        new.scene = self.scene
        new.inputs = [self]
        self._change_components(old, new)
        old_actor = None
        if old is not None:
            old_actor = old.actor
        new.actor = self._get_actor_or_follower(old=old_actor)
        self.actors = new.actors
        self.render()


    def _orient_to_camera_changed(self):
        self.actor.actor = \
                    self._get_actor_or_follower(old=self.actor.actor)


    def _get_actor_or_follower(self, old=None):
        """ Get a tvtk.Actor or a tvtk.Follower for the actor of the
            object and wire the callbacks to it.
            If old is given, it is the old actor, to remove its
            callbacks.
        """
        if self.orient_to_camera:
            new = tvtk.Follower()
            if self.scene is not None:
                new.camera = self.scene.camera
        else:
            new = tvtk.Actor()
        if old is not None:
            self.sync_trait('position', old, 'position', remove=True)
            self.sync_trait('scale', old, 'scale', remove=True)
            self.sync_trait('orientation', old, 'orientation', remove=True)

        self.sync_trait('position', new, 'position')
        self.sync_trait('scale', new, 'scale')
        self.sync_trait('orientation', new, 'orientation')
        return new


    def _scene_changed(self, old, new):
        super(Text3D, self)._scene_changed(old, new)
        if new is not None and self.orient_to_camera:
            self.actor.actor.camera = new.camera



########NEW FILE########
__FILENAME__ = iso_surface
"""
Traits View definition file.

The view trait of the parent class has been extracted from the model
definition file.  This file can either be exec()ed or imported.  See
core/base.py:Base.trait_view() for what is currently used.  Using exec()
allows view changes without needing to restart Mayavi, but is slower than
importing.
"""
# Authors: Prabhu Ramachandran <prabhu_r@users.sf.net>
#          Judah De Paula <judah@enthought.com>
# Copyright (c) 2005-2008, Enthought, Inc.
# License: BSD Style.

from traitsui.api import Item, Group, View, InstanceEditor
from mayavi.components.ui.actor import actor_view, texture_view

view = View(Group(
                Group(
                     Item( name  = 'contour',
                           style = 'custom' ),
                     show_labels = False,
                     show_border = True,
                     label       = 'Contours' ),
                 Group(
                     Item( name = 'compute_normals' ),
                     Item( name         = 'normals',
                           style        = 'custom',
                           show_label   = False,
                           enabled_when = 'compute_normals' ),
                     show_border = True,
                     label       = 'Normals' ),
                 label='Contours',
             ),
             Group(Item('actor',
                        resizable=True,
                        style='custom',
                        editor=InstanceEditor(view=actor_view)
                        ),
                   label='Actor',
                   show_labels=False,
             ),
             Group(Item('actor',
                        resizable=True,
                        style='custom',
                        editor=InstanceEditor(view=texture_view)
                    ),
                    label='Texturing',
                    show_labels=False,
                ),
            resizable=True
            )


########NEW FILE########
__FILENAME__ = surface
"""
Traits View definition file.

The view trait of the parent class is extracted from the model definition
file.  This file can either be exec()ed or imported.  See
core/base.py:Base.trait_view() for what is currently used.  Using exec()
allows view changes without needing to restart Mayavi, but is slower than
importing.
"""
# Authors: Prabhu Ramachandran <prabhu_r@users.sf.net>
#          Judah De Paula <judah@enthought.com>
# Copyright (c) 2005-2008, Enthought, Inc.
# License: BSD Style.


from traitsui.api import Item, Group, View, InstanceEditor
from mayavi.components.ui.actor import actor_view, texture_view

view = View(
            Group(Item(name='enable_contours', label='Enable Contours'),
                  Group(Item(name='contour',
                             style='custom',
                             enabled_when='object.enable_contours'
                             ),
                        show_labels=False,
                  ),
                  show_labels=True,
                  label='Contours'
            ),

            Group(Item('actor',
                       resizable=True,
                       style='custom',
                       editor=InstanceEditor(view=actor_view)
                       ),
                  label='Actor',
                  show_labels=False,
            ),

            Group(Item('actor',
                       resizable=True,
                       style='custom',
                       editor=InstanceEditor(view=texture_view)
                       ),
                  label='Texturing',
                  show_labels=False,
            ),
        )

########NEW FILE########
__FILENAME__ = vectors
"""Displays different types of glyphs oriented and colored as per
vector data at the input points.  This is merely a convenience module
that is entirely based on the Glyph module.

"""
# Author: Prabhu Ramachandran <prabhu_r@users.sf.net>
# Copyright (c) 2005, Enthought, Inc.
# License: BSD Style.


# Local imports
from mayavi.modules.glyph import Glyph

######################################################################
# `Vectors` class.
######################################################################
class Vectors(Glyph):

    ######################################################################
    # `Module` interface
    ######################################################################
    def setup_pipeline(self):
        super(Vectors, self).setup_pipeline()
        self.glyph.set(scale_mode='scale_by_vector',
                       color_mode='color_by_vector',
                       show_scale_mode=False)
        self.glyph.glyph_source.glyph_position='tail'

########NEW FILE########
__FILENAME__ = vector_cut_plane
"""Takes an arbitrary slice of the input data using an implicit cut
plane and places glyphs according to the vector field data.  The
glyphs may be colored using either the vector magnitude or the scalar
attributes.

"""
# Author: Prabhu Ramachandran <prabhu_r@users.sf.net>
# Copyright (c) 2005, Enthought, Inc.
# License: BSD Style.


# Enthought library imports.
from traits.api import Instance
from traitsui.api import View, Group, Item

# Local imports
from mayavi.core.pipeline_info import PipelineInfo
from mayavi.core.module import Module
from mayavi.components.implicit_plane import ImplicitPlane
from mayavi.components.cutter import Cutter
from mayavi.components.glyph import Glyph
from mayavi.components.actor import Actor


######################################################################
# `VectorCutPlane` class.
######################################################################
class VectorCutPlane(Module):

    # The version of this class.  Used for persistence.
    __version__ = 0

    # The implicit plane widget used to place the implicit function.
    implicit_plane = Instance(ImplicitPlane, allow_none=False,
                              record=True)

    # The cutter.  Takes a cut of the data on the implicit plane.
    cutter = Instance(Cutter, allow_none=False, record=True)

    # The Glyph component.
    glyph = Instance(Glyph, allow_none=False, record=True)

    # The Glyph component.
    actor = Instance(Actor, allow_none=False, record=True)

    input_info = PipelineInfo(datasets=['any'],
                              attribute_types=['any'],
                              attributes=['vectors'])

    ########################################
    # View related traits.

    view = View(Group(Item(name='implicit_plane', style='custom'),
                      label='ImplicitPlane',
                      show_labels=False),
                Group(Item(name='glyph', style='custom', resizable=True),
                      label='Glyph',
                      show_labels=False),
                Group(Item(name='actor', style='custom'),
                      label='Actor',
                      show_labels=False),
                )

    ######################################################################
    # `Module` interface
    ######################################################################
    def setup_pipeline(self):
        """Override this method so that it *creates* the tvtk
        pipeline.

        This method is invoked when the object is initialized via
        `__init__`.  Note that at the time this method is called, the
        tvtk data pipeline will *not* yet be setup.  So upstream data
        will not be available.  The idea is that you simply create the
        basic objects and setup those parts of the pipeline not
        dependent on upstream sources and filters.  You should also
        set the `actors` attribute up at this point.
        """
        # Create the objects and set them up.
        self.implicit_plane = ImplicitPlane()
        self.cutter = Cutter()
        self.glyph = Glyph(module=self,
                           scale_mode='scale_by_vector',
                           color_mode='color_by_vector',
                           show_scale_mode=False)
        self.glyph.glyph_source.glyph_position='tail'
        actor = self.actor = Actor()
        actor.mapper.scalar_visibility = 1
        actor.property.set(line_width=2, backface_culling=False,
                           frontface_culling=False)

    def update_pipeline(self):
        """Override this method so that it *updates* the tvtk pipeline
        when data upstream is known to have changed.

        This method is invoked (automatically) when any of the inputs
        sends a `pipeline_changed` event.
        """
        mm = self.module_manager
        if mm is None:
            return

        self.implicit_plane.inputs = [mm.source]

        # Set the LUT for the mapper.
        self._color_mode_changed(self.glyph.color_mode)

        self.pipeline_changed = True

    def update_data(self):
        """Override this method so that it flushes the vtk pipeline if
        that is necessary.

        This method is invoked (automatically) when any of the inputs
        sends a `data_changed` event.
        """
        # Just set data_changed, the other components should do the rest.
        self.data_changed = True

    ######################################################################
    # Non-public traits.
    ######################################################################
    def _color_mode_changed(self, value):
        # This is a listner for the glyph component's color_mode trait
        # so that the the lut can be changed when the a different
        # color mode is requested.
        actor = self.actor
        if value == 'color_by_scalar':
            actor.mapper.scalar_visibility = 1
            lut_mgr = self.module_manager.scalar_lut_manager
            actor.set_lut(lut_mgr.lut)
        elif value == 'color_by_vector':
            lut_mgr = self.module_manager.vector_lut_manager
            actor.set_lut(lut_mgr.lut)
        else:
            actor.mapper.scalar_visibility = 0

        self.render()

    def _implicit_plane_changed(self, old, new):
        cutter = self.cutter
        if cutter is not None:
            cutter.cut_function = new.plane
            cutter.inputs = [new]
        self._change_components(old, new)

    def _cutter_changed(self, old, new):
        ip = self.implicit_plane
        if ip is not None:
            new.cut_function = ip.plane
            new.inputs = [ip]
        g = self.glyph
        if g is not None:
            g.inputs = [new]
        self._change_components(old, new)

    def _glyph_changed(self, old, new):
        if old is not None:
            old.on_trait_change(self._color_mode_changed,
                                'color_mode',
                                remove=True)
        new.module = self
        cutter = self.cutter
        if cutter:
            new.inputs = [cutter]
        new.on_trait_change(self._color_mode_changed,
                            'color_mode')
        self._change_components(old, new)

    def _actor_changed(self, old, new):
        new.scene = self.scene
        glyph = self.glyph
        if glyph is not None:
            new.inputs = [glyph]
        self._change_components(old, new)


########NEW FILE########
__FILENAME__ = volume
"""The Volume module visualizes scalar fields using volumetric
visualization techniques.  This supports ImageData and
UnstructuredGrid data.  It also supports the FixedPointRenderer for
ImageData.  However, the performance is slow so your best bet is
probably with the ImageData based renderers.

"""
# Author: Prabhu Ramachandran <prabhu@aero.iitb.ac.in>
# Copyright (c) 2006, Enthought, Inc.
# License: BSD Style.

# Standard imports
from math import cos, sqrt, pi
from vtk.util import vtkConstants

# Enthought library imports.
from traits.api import Instance, Property, List, ReadOnly, \
     Str, Button, Tuple
from traitsui.api import View, Group, Item, InstanceEditor
from tvtk.api import tvtk
from tvtk.util.gradient_editor import hsva_to_rgba, GradientTable
from tvtk.util.traitsui_gradient_editor import VolumePropertyEditor
from tvtk.util.ctf import save_ctfs, load_ctfs, \
     rescale_ctfs, set_lut, PiecewiseFunction, ColorTransferFunction
from apptools.persistence import state_pickler

# Local imports
from mayavi.core.pipeline_info import PipelineInfo
from mayavi.core.module import Module
from mayavi.core.common import error
from mayavi.core.trait_defs import DEnum
from mayavi.core.lut_manager import LUTManager

######################################################################
# Utility functions.
######################################################################
def is_volume_pro_available():
    """Returns `True` if there is a volume pro card available.
    """
    try:
        map = tvtk.VolumeProMapper()
    except AttributeError:
        return False
    else:
        return map.number_of_boards > 0

def find_volume_mappers():
    res = []
    for name in dir(tvtk):
        if 'Volume' in name and 'Mapper' in name and 'OpenGL' not in name:
            try:
                klass = getattr(tvtk, name)
                inst = klass()
            except TypeError:
                pass
            else:
                res.append(name)
    ignores = ['VolumeTextureMapper3D', 'VolumeProMapper']
    for name in ignores:
        if name in res:
            res.remove(name)
    return res

def default_OTF(x1, x2):
    """Creates a default opacity transfer function.
    """
    maxs = max(x1, x2)
    mins = min(x1, x2)
    otf = PiecewiseFunction()
    otf.add_point(mins, 0.0)
    otf.add_point(maxs, 0.2)
    return otf

def make_CTF(x1, x2, hue_range=(2.0/3.0, 0.0),
             sat_range=(1.0, 1.0), val_range=(1.0, 1.0),
             n=10, mode='sqrt'):
    """Creates a CTF as per given arguments.  Lets one set a hue,
    saturation and value range.  The mode can be one of 'sqrt', or
    'linear'.  The idea of this function is to create a CTF that is
    similar to the LUT being used.  's_curve' is not implemented.
    Patches welcome.
    """
    maxs = max(x1, x2)
    mins = min(x1, x2)
    ds = maxs - mins
    dhue = hue_range[1] - hue_range[0]
    dsat = sat_range[1] - sat_range[0]
    dval = val_range[1] - val_range[0]
    ctf = ColorTransferFunction()
    try:
        ctf.range = (mins, maxs)
    except Exception:
        # VTK versions < 5.2 don't seem to need this.
        pass
    if mode == 'sqrt':
        for i in range(n+1):
            # Generate x in [0, 1]
            x = 0.5*(1.0  + cos((n-i)*pi/n)) # Chebyshev nodes.
            h = hue_range[0] + dhue*x
            s = sat_range[0] + dsat*x
            v = val_range[0] + dval*x
            r, g, b, a = [sqrt(c) for c in hsva_to_rgba(h, s, v, 1.0)]
            ctf.add_rgb_point(mins+x*ds, r, g, b)
    elif mode == 'linear':
        for i in range(n+1):
            # Generate x in [0, 1]
            x = float(i)/n # Uniform nodes.
            h = hue_range[0] + dhue*x
            s = sat_range[0] + dsat*x
            v = val_range[0] + dval*x
            r, g, b, a = hsva_to_rgba(h, s, v, 1.0)
            ctf.add_rgb_point(mins+x*ds, r, g, b)
    return ctf


def default_CTF(x1, x2):
    """Creates a default RGB color transfer function.  In this case we
    default to a red-blue one with the 'sqrt' mode.
    """
    return make_CTF(x1, x2,
                    hue_range=(2.0/3.0, 0.0),
                    sat_range=(1.0, 1.0),
                    val_range=(1.0, 1.0),
                    n=10,
                    mode='sqrt')


def load_volume_prop_from_grad(grad_file_name, volume_prop,
                               scalar_range=(0, 255)):
    """Load a ``*.grad`` file (*grad_file_name*) and set the given volume
    property (*volume_prop*) given the *scalar_range*.
    """
    gt = GradientTable(300)
    gt.load(grad_file_name)
    gt.store_to_vtk_volume_prop(volume_prop, scalar_range)


def save_volume_prop_to_grad(volume_prop, grad_file_name):
    """Save the given volume property (*volume_prop*) to a ``*.grad`` file
    given as *grad_file_name*.
    """
    gt = GradientTable(300)
    gt.load_from_vtk_volume_prop(volume_prop)
    gt.save(grad_file_name)


######################################################################
# `VolumeLutManager` class.
######################################################################
class VolumeLUTManager(LUTManager):
    """Just has a different view than the LUTManager.
    """
    view = View(Group(Item(name='show_scalar_bar'),
                      Item(name='number_of_labels'),
                      Item(name='shadow'),
                      Item(name='use_default_name'),
                      Item(name='data_name'),
                      label='Scalar Bar',
                      ),
                Group(Item(name='_title_text_property',
                           style='custom',
                           resizable=True),
                      show_labels=False,
                      label='Title'),
                Group(Item(name='_label_text_property',
                           style='custom',
                           resizable=True),
                      show_labels=False,
                      label='Labels'),
                resizable=True
                )


######################################################################
# `Volume` class.
######################################################################
class Volume(Module):
    """The Volume module visualizes scalar fields using volumetric
    visualization techniques.  This supports ImageData and
    UnstructuredGrid data.  It also supports the FixedPointRenderer
    for ImageData.  However, the performance is slow so your best bet
    is probably with the ImageData based renderers.
    """

    # The version of this class.  Used for persistence.
    __version__ = 0

    volume_mapper_type = DEnum(values_name='_mapper_types',
                               desc='volume mapper to use')

    ray_cast_function_type = DEnum(values_name='_ray_cast_functions',
                                   desc='Ray cast function to use')

    volume = ReadOnly

    volume_mapper = Property(record=True)

    volume_property = Property(record=True)

    ray_cast_function = Property(record=True)

    lut_manager = Instance(VolumeLUTManager, args=(), allow_none=False,
                           record=True)

    input_info = PipelineInfo(datasets=['image_data',
                                        'unstructured_grid'],
                              attribute_types=['any'],
                              attributes=['scalars'])

    ########################################
    # View related code.

    update_ctf = Button('Update CTF')

    view = View(Group(Item(name='_volume_property', style='custom',
                           editor=VolumePropertyEditor,
                           resizable=True),
                      Item(name='update_ctf'),
                      label='CTF',
                      show_labels=False),
                Group(Item(name='volume_mapper_type'),
                      Group(Item(name='_volume_mapper',
                                 style='custom',
                                 resizable=True),
                            show_labels=False
                            ),
                      Item(name='ray_cast_function_type'),
                      Group(Item(name='_ray_cast_function',
                                 enabled_when='len(_ray_cast_functions) > 0',
                                 style='custom',
                                 resizable=True),
                            show_labels=False),
                      label='Mapper',
                      ),
                Group(Item(name='_volume_property', style='custom',
                           resizable=True),
                      label='Property',
                      show_labels=False),
                Group(Item(name='volume', style='custom',
                           editor=InstanceEditor(),
                           resizable=True),
                      label='Volume',
                      show_labels=False),
                Group(Item(name='lut_manager', style='custom',
                           resizable=True),
                      label='Legend',
                      show_labels=False),
                resizable=True
                )

    ########################################
    # Private traits
    _volume_mapper = Instance(tvtk.AbstractVolumeMapper)
    _volume_property = Instance(tvtk.VolumeProperty)
    _ray_cast_function = Instance(tvtk.Object)

    _mapper_types = List(Str, ['TextureMapper2D', 'RayCastMapper', ])

    _available_mapper_types = List(Str)

    _ray_cast_functions = List(Str)

    current_range = Tuple

    # The color transfer function.
    _ctf = Instance(ColorTransferFunction)
    # The opacity values.
    _otf = Instance(PiecewiseFunction)

    ######################################################################
    # `object` interface
    ######################################################################
    def __get_pure_state__(self):
        d = super(Volume, self).__get_pure_state__()
        d['ctf_state'] = save_ctfs(self._volume_property)
        for name in ('current_range', '_ctf', '_otf'):
            d.pop(name, None)
        return d

    def __set_pure_state__(self, state):
        self.volume_mapper_type = state['_volume_mapper_type']
        state_pickler.set_state(self, state, ignore=['ctf_state'])
        ctf_state = state['ctf_state']
        ctf, otf = load_ctfs(ctf_state, self._volume_property)
        self._ctf = ctf
        self._otf = otf
        self._update_ctf_fired()

    ######################################################################
    # `Module` interface
    ######################################################################
    def start(self):
        super(Volume, self).start()
        self.lut_manager.start()

    def stop(self):
        super(Volume, self).stop()
        self.lut_manager.stop()

    def setup_pipeline(self):
        """Override this method so that it *creates* the tvtk
        pipeline.
        """
        v = self.volume = tvtk.Volume()
        vp = self._volume_property = tvtk.VolumeProperty()

        self._ctf = ctf = default_CTF(0, 255)
        self._otf = otf = default_OTF(0, 255)
        vp.set_color(ctf)
        vp.set_scalar_opacity(otf)
        vp.shade = True
        vp.interpolation_type = 'linear'
        v.property = vp

        v.on_trait_change(self.render)
        vp.on_trait_change(self.render)

        available_mappers = find_volume_mappers()
        if is_volume_pro_available():
            self._mapper_types.append('VolumeProMapper')
            available_mappers.append('VolumeProMapper')

        self._available_mapper_types = available_mappers
        if 'FixedPointVolumeRayCastMapper' in available_mappers:
            self._mapper_types.append('FixedPointVolumeRayCastMapper')

        self.actors.append(v)

    def update_pipeline(self):
        """Override this method so that it *updates* the tvtk pipeline
        when data upstream is known to have changed.

        This method is invoked (automatically) when any of the inputs
        sends a `pipeline_changed` event.
        """
        mm = self.module_manager
        if mm is None:
            return

        input = mm.source.outputs[0]

        ug = hasattr(tvtk, 'UnstructuredGridVolumeMapper')
        if ug:
            if not input.is_a('vtkImageData') \
                   and not input.is_a('vtkUnstructuredGrid'):
                error('Volume rendering only works with '\
                      'StructuredPoints/ImageData/UnstructuredGrid datasets')
                return
        elif not input.is_a('vtkImageData'):
            error('Volume rendering only works with '\
                  'StructuredPoints/ImageData datasets')
            return

        self._setup_mapper_types()
        self._setup_current_range()
        self._volume_mapper_type_changed(self.volume_mapper_type)
        self._update_ctf_fired()
        self.pipeline_changed = True

    def update_data(self):
        """Override this method so that it flushes the vtk pipeline if
        that is necessary.

        This method is invoked (automatically) when any of the inputs
        sends a `data_changed` event.
        """
        self._setup_mapper_types()
        self._setup_current_range()
        self._update_ctf_fired()
        self.data_changed = True

    ######################################################################
    # Non-public methods.
    ######################################################################
    def _setup_mapper_types(self):
        """Sets up the mapper based on input data types.
        """
        input = self.module_manager.source.outputs[0]
        if input.is_a('vtkUnstructuredGrid'):
            if hasattr(tvtk, 'UnstructuredGridVolumeMapper'):
                check = ['UnstructuredGridVolumeZSweepMapper',
                         'UnstructuredGridVolumeRayCastMapper',
                         ]
                mapper_types = []
                for mapper in check:
                    if mapper in self._available_mapper_types:
                        mapper_types.append(mapper)
                if len(mapper_types) == 0:
                    mapper_types = ['']
                self._mapper_types = mapper_types
                return
        else:
            if input.point_data.scalars.data_type not in \
               [vtkConstants.VTK_UNSIGNED_CHAR,
                vtkConstants.VTK_UNSIGNED_SHORT]:
                if 'FixedPointVolumeRayCastMapper' \
                       in self._available_mapper_types:
                    self._mapper_types = ['FixedPointVolumeRayCastMapper']
                else:
                    error('Available volume mappers only work with \
                    unsigned_char or unsigned_short datatypes')
            else:
                mapper_types = ['TextureMapper2D', 'RayCastMapper']
                check = ['FixedPointVolumeRayCastMapper',
                         'VolumeProMapper'
                         ]
                for mapper in check:
                    if mapper in self._available_mapper_types:
                        mapper_types.append(mapper)
                self._mapper_types = mapper_types

    def _setup_current_range(self):
        mm = self.module_manager
        # Set the default name and range for our lut.
        lm = self.lut_manager
        slm = mm.scalar_lut_manager
        lm.set(default_data_name=slm.default_data_name,
               default_data_range=slm.default_data_range)

        # Set the current range.
        input = mm.source.outputs[0]
        sc = input.point_data.scalars
        if sc is not None:
            rng = sc.range
        else:
            error('No scalars in input data!')
            rng = (0, 255)

        if self.current_range != rng:
            self.current_range = rng

    def _get_volume_mapper(self):
        return self._volume_mapper

    def _get_volume_property(self):
        return self._volume_property

    def _get_ray_cast_function(self):
        return self._ray_cast_function

    def _volume_mapper_type_changed(self, value):
        mm = self.module_manager
        if mm is None:
            return

        old_vm = self._volume_mapper
        if old_vm is not None:
            old_vm.on_trait_change(self.render, remove=True)

        if value == 'RayCastMapper':
            new_vm = tvtk.VolumeRayCastMapper()
            self._volume_mapper = new_vm
            self._ray_cast_functions = ['RayCastCompositeFunction',
                                        'RayCastMIPFunction',
                                        'RayCastIsosurfaceFunction']
            new_vm.volume_ray_cast_function = tvtk.VolumeRayCastCompositeFunction()
        elif value == 'TextureMapper2D':
            new_vm = tvtk.VolumeTextureMapper2D()
            self._volume_mapper = new_vm
            self._ray_cast_functions = ['']
        elif value == 'VolumeProMapper':
            new_vm = tvtk.VolumeProMapper()
            self._volume_mapper = new_vm
            self._ray_cast_functions = ['']
        elif value == 'FixedPointVolumeRayCastMapper':
            new_vm = tvtk.FixedPointVolumeRayCastMapper()
            self._volume_mapper = new_vm
            self._ray_cast_functions = ['']
        elif value == 'UnstructuredGridVolumeRayCastMapper':
            new_vm = tvtk.UnstructuredGridVolumeRayCastMapper()
            self._volume_mapper = new_vm
            self._ray_cast_functions = ['']
        elif value == 'UnstructuredGridVolumeZSweepMapper':
            new_vm = tvtk.UnstructuredGridVolumeZSweepMapper()
            self._volume_mapper = new_vm
            self._ray_cast_functions = ['']

        src = mm.source
        self.configure_connection(new_vm, src)
        self.volume.mapper = new_vm
        new_vm.on_trait_change(self.render)

    def _update_ctf_fired(self):
        set_lut(self.lut_manager.lut, self._volume_property)
        self.render()

    def _current_range_changed(self, old, new):
        rescale_ctfs(self._volume_property, new)
        self.render()

    def _ray_cast_function_type_changed(self, old, new):
        rcf = self.ray_cast_function
        if len(old) > 0:
            rcf.on_trait_change(self.render, remove=True)

        if len(new) > 0:
            new_rcf = getattr(tvtk, 'Volume%s'%new)()
            new_rcf.on_trait_change(self.render)
            self._volume_mapper.volume_ray_cast_function = new_rcf
            self._ray_cast_function = new_rcf
        else:
            self._ray_cast_function = None

        self.render()

    def _scene_changed(self, old, new):
        super(Volume, self)._scene_changed(old, new)
        self.lut_manager.scene = new

########NEW FILE########
__FILENAME__ = warp_vector_cut_plane
# -*- coding: UTF-8 -*-
"""Takes an arbitrary slice of the input data using an implicit cut
plane and warps it according to the vector field data.  The scalars
are displayed on the warped surface as colors.

"""
# Authors: Fr�d�ric Petit and Prabhu Ramachandran
# Copyright (c) 2006, Enthought, Inc.
# License: BSD Style.


# Enthought library imports.
from traits.api import Instance, Bool
from traitsui.api import View, Group, Item, InstanceEditor
from tvtk.api import tvtk

# Local imports
from mayavi.core.pipeline_info import PipelineInfo
from mayavi.core.module import Module
from mayavi.components.implicit_plane import ImplicitPlane
from mayavi.components.cutter import Cutter
from mayavi.filters.warp_vector import WarpVector
from mayavi.components.poly_data_normals import PolyDataNormals
from mayavi.components.actor import Actor


######################################################################
# `VectorCutPlane` class.
######################################################################
class WarpVectorCutPlane(Module):

    # The version of this class.  Used for persistence.
    __version__ = 0

    # The implicit plane widget used to place the implicit function.
    implicit_plane = Instance(ImplicitPlane, allow_none=False,
                              record=True)

    # The cutter.  Takes a cut of the data on the implicit plane.
    cutter = Instance(Cutter, allow_none=False, record=True)

    # The WarpVectorCutPlane component that warps the data.
    warp_vector = Instance(WarpVector, allow_none=False, record=True)

    # Specify if vector normals are to be computed to make a smoother surface.
    compute_normals = Bool(False, desc='if normals are to be computed '\
                           'to make the warped surface smoother')

    # The component that computes the normals.
    normals = Instance(PolyDataNormals, record=True)

    # The Actor component.
    actor = Instance(Actor, allow_none=False, record=True)

    input_info = PipelineInfo(datasets=['any'],
                              attribute_types=['any'],
                              attributes=['vectors'])

    ########################################
    # View related traits.

    _warp_group = Group(Item(name='filter',
                             style='custom',
                             editor=\
                             InstanceEditor(view=
                                            View(Item('scale_factor')))),
                        show_labels=False)

    view = View(Group(Item(name='implicit_plane', style='custom'),
                      label='ImplicitPlane',
                      show_labels=False),
                Group(Group(Item(name='warp_vector',
                                 style='custom',
                                 resizable=True,
                                 show_label=False,
                                 editor=InstanceEditor(view=View(_warp_group))
                                 ),
                            ),
                      Item(name='_'),
                      Item(name='compute_normals'),
                      Group(Item(name='normals',
                                 style='custom',
                                 show_label=False,
                                 enabled_when = 'compute_normals'),
                            ),
                      label='WarpVector',
                      show_labels=True),
                Group(Item(name='actor', style='custom'),
                      label='Actor',
                      show_labels=False),
                resizable=True,
                )

    ######################################################################
    # `Module` interface
    ######################################################################
    def setup_pipeline(self):
        """Override this method so that it *creates* the tvtk
        pipeline.

        This method is invoked when the object is initialized via
        `__init__`.  Note that at the time this method is called, the
        tvtk data pipeline will *not* yet be setup.  So upstream data
        will not be available.  The idea is that you simply create the
        basic objects and setup those parts of the pipeline not
        dependent on upstream sources and filters.  You should also
        set the `actors` attribute up at this point.
        """
        # Create the objects and set them up.
        self.implicit_plane = ImplicitPlane()
        self.cutter = Cutter()
        self.warp_vector = WarpVector()
        self.normals = PolyDataNormals()
        actor = self.actor = Actor()
        actor.mapper.scalar_visibility = 1

    def update_pipeline(self):
        """Override this method so that it *updates* the tvtk pipeline
        when data upstream is known to have changed.

        This method is invoked (automatically) when any of the inputs
        sends a `pipeline_changed` event.
        """
        mm = self.module_manager
        if mm is None:
            return

        self.implicit_plane.inputs = [mm.source]

        # Force the vector normals setting to be noted.
        self._compute_normals_changed(self.compute_normals)

        # Set the LUT for the mapper.
        self.actor.set_lut(mm.scalar_lut_manager.lut)

        self.pipeline_changed = True

    def update_data(self):
        """Override this method so that it flushes the vtk pipeline if
        that is necessary.

        This method is invoked (automatically) when any of the inputs
        sends a `data_changed` event.
        """
        # Just set data_changed, the other components should do the rest.
        self.data_changed = True

    ######################################################################
    # Non-public traits.
    ######################################################################
    def _compute_normals_changed(self, value):
        if self.module_manager is None:
            return
        actor = self.actor
        if actor is not None:
            if value:
                actor.inputs = [self.normals]
            else:
                actor.inputs = [self.warp_vector]
        self.render()

    def _normals_changed(self, old, new):
        warp_vector = self.warp_vector
        compute_normals = self.compute_normals
        if compute_normals is not None:
            new.inputs = [warp_vector]
        self._compute_normals_changed(self.compute_normals)
        self._change_components(old, new)

    def _implicit_plane_changed(self, old, new):
        cutter = self.cutter
        if cutter is not None:
            cutter.cut_function = new.plane
            cutter.inputs = [new]
        self._change_components(old, new)

    def _warp_vector_changed(self, old, new):
        cutter = self.cutter
        if cutter is not None:
            new.inputs = [cutter]
        self._compute_normals_changed(self.compute_normals)
        self._change_components(old, new)

    def _cutter_changed(self, old, new):
        ip = self.implicit_plane
        if ip is not None:
            new.cut_function = ip.plane
            new.inputs = [ip]
        w = self.warp_vector
        if w is not None:
            w.inputs = [new]
        self._change_components(old, new)

    def _actor_changed(self, old, new):
        self._compute_normals_changed(self.compute_normals)
        self._change_components(old, new)


########NEW FILE########
__FILENAME__ = app
"""The Mayavi Envisage application.
"""
# Author: Prabhu Ramachandran <prabhu_r@users.sf.net>
# Copyright (c) 2008, Enthought, Inc.
# License: BSD Style.

# Standard library imports.
import sys
import os.path
import logging

# Enthought library imports.
from apptools.logger.api import LogFileHandler, FORMATTER
from traits.etsconfig.api import ETSConfig
from traits.api import (HasTraits, Instance, Int,
    on_trait_change, Bool)

# Local imports.
from mayavi_workbench_application import MayaviWorkbenchApplication
from mayavi.preferences.api import preference_manager
from mayavi.core.customize import get_custom_plugins

# GLOBALS
logger = logging.getLogger()

######################################################################
# Useful functions.
######################################################################
def setup_logger(logger, fname, stream=True, mode=logging.ERROR):
    """Setup a log file and the logger.  If the given file name is not
    absolute, put the log file in `ETSConfig.application_home`, if not
    it will create it where desired.

    Parameters:
    -----------

    fname -- file name the logger should use.  If this is an absolute
    path it will create the log file as specified, if not it will put it
    in `ETSConfig.application_home`.

    stream -- Add a stream handler.

    mode -- the logging mode of the stream handler.

    """
    if not os.path.isabs(fname):
        path = os.path.join(ETSConfig.application_home, fname)
    else:
        path = fname

    # Check if we have already added a logger (can happen when the app
    # is started multiple number of times from ipython say).
    handlers = logger.handlers
    if len(handlers) > 1:
        h = handlers[0]
        if isinstance(h, LogFileHandler) and h.baseFilename == path:
            logger.info('Logging handlers already set!  Not duplicating.')
            return

    logger.setLevel(logging.DEBUG)
    handler = LogFileHandler(path)
    handler.setLevel(logging.DEBUG)
    logger.addHandler(handler)
    if stream:
        s = logging.StreamHandler()
        s.setFormatter(FORMATTER)
        s.setLevel(mode)
        logger.addHandler(s)
    logger.info("*"*80)
    logger.info("logfile is: '%s'", os.path.abspath(path))
    logger.info("*"*80)

def get_non_gui_plugin_classes():
    """Get list of basic mayavi plugin classes that do not add any views or
    actions."""
    from envisage.core_plugin import CorePlugin
    from envisage.ui.workbench.workbench_plugin import WorkbenchPlugin
    from tvtk.plugins.scene.scene_plugin import ScenePlugin
    from mayavi.plugins.mayavi_plugin import MayaviPlugin
    plugins = [CorePlugin,
               WorkbenchPlugin,
               MayaviPlugin,
               ScenePlugin,
               ]
    return plugins

def get_non_gui_plugins():
    """Get list of basic mayavi plugins that do not add any views or
    actions."""
    return [cls() for cls in get_non_gui_plugin_classes()]

def get_plugin_classes():
    """Get list of default plugin classes to use for Mayavi."""

    # Force the selection of a toolkit:
    from traitsui.api import toolkit
    toolkit()
    from traits.etsconfig.api import ETSConfig
    try_use_ipython = preference_manager.root.use_ipython
    use_ipython = False
    if ETSConfig.toolkit == 'wx' and try_use_ipython:
        try:
            # If the right versions of IPython, EnvisagePlugins and
            # Pyface are not installed, this import will fail.
            from envisage.plugins.ipython_shell.view.ipython_shell_view \
                    import IPythonShellView
            use_ipython = True
        except: pass

    if use_ipython:
        from envisage.plugins.ipython_shell.ipython_shell_plugin import \
                IPythonShellPlugin
        PythonShellPlugin = IPythonShellPlugin
    else:
        from envisage.plugins.python_shell.python_shell_plugin import PythonShellPlugin
    from envisage.plugins.text_editor.text_editor_plugin import TextEditorPlugin
    from apptools.logger.plugin.logger_plugin import LoggerPlugin
    from tvtk.plugins.scene.ui.scene_ui_plugin import SceneUIPlugin
    from mayavi.plugins.mayavi_ui_plugin import MayaviUIPlugin
    plugins = get_non_gui_plugin_classes()
    plugins.extend([
                LoggerPlugin,
                MayaviUIPlugin,
                SceneUIPlugin,
                PythonShellPlugin,
                TextEditorPlugin,
                ])
    return plugins

def get_plugins():
    """Get list of default plugins to use for Mayavi."""
    return [cls() for cls in get_plugin_classes()]

###########################################################################
# `Mayavi` class.
###########################################################################
class Mayavi(HasTraits):
    """The Mayavi application class.

    This class may be easily subclassed to do something different.
    For example, one way to script MayaVi (as a standalone application
    and not interactively) is to subclass this and do the needful.
    """

    # The main envisage application.
    application = Instance('envisage.ui.workbench.api.WorkbenchApplication')

    # Turn this off if you don't want the workbench to start the GUI
    # event loop.
    start_gui_event_loop = Bool(True, desc='start a GUI event loop')

    # The MayaVi Script instance.
    script = Instance('mayavi.plugins.script.Script')

    # The logging mode.
    log_mode = Int(logging.ERROR, desc='the logging mode to use')

    def main(self, argv=None, plugins=None):
        """The main application is created and launched here.

        Parameters
        ----------
        argv : list of strings
            The list of command line arguments.  The default is `None`
            where no command line arguments are parsed.  To support
            command line arguments you can pass `sys.argv[1:]`.
        plugins : list of Plugin objects
            List of plugins to start.  If none is provided it defaults to
            something meaningful.
        log_mode :
            The logging mode to use.

        """
        # Parse any cmd line args.
        if argv is None:
            argv = []
        self.parse_command_line(argv)

        if plugins is None:
            plugins = get_plugins()

        plugins += get_custom_plugins()

        # Create the application
        prefs = preference_manager.preferences
        app = MayaviWorkbenchApplication(plugins=plugins,
                                         preferences=prefs,
                                         start_gui_event_loop=self.start_gui_event_loop)
        self.application = app

        # Setup the logger.
        self.setup_logger()

        # Start the application.
        app.run()

    def setup_logger(self):
        """Setup logging for the application."""
        setup_logger(logger, 'mayavi.log', mode=self.log_mode)

    def parse_command_line(self, argv):
        """Parse command line options.

        Parameters
        ----------

        - argv : `list` of `strings`

          The list of command line arguments.
        """
        from optparse import OptionParser
        usage = "usage: %prog [options]"
        parser = OptionParser(usage)

        (options, args) = parser.parse_args(argv)

    def run(self):
        """This function is called after the GUI has started.
        Override this to do whatever you want to do as a MayaVi
        script.  If this is not overridden then an empty MayaVi
        application will be started.

        *Make sure all other MayaVi specific imports are made here!*
        If you import MayaVi related code earlier you will run into
        difficulties.  Use 'self.script' to script the mayavi engine.
        """
        pass

    ######################################################################
    # Non-public interface.
    ######################################################################
    @on_trait_change('application.gui:started')
    def _on_application_gui_started(self, obj, trait_name, old, new):
        """This is called as soon as  the Envisage GUI starts up.  The
        method is responsible for setting our script instance.
        """
        if trait_name != 'started' or not new:
            return
        app = self.application
        from mayavi.plugins.script import Script
        window = app.workbench.active_window
        # Set our script instance.
        self.script = window.get_service(Script)
        # Call self.run from the GUI thread.
        app.gui.invoke_later(self.run)


def main(argv=None):
    """Simple helper to start up the mayavi application.  This returns
    the running application."""
    m = Mayavi()
    m.main(argv)
    return m

if __name__ == '__main__':
    main(sys.argv[1:])

########NEW FILE########
__FILENAME__ = envisage_engine
"""The MayaVi Engine meant to be used with Envisage.
"""
# Author: Prabhu Ramachandran <prabhu_r@users.sf.net>
# Copyright (c) 2005-2007, Enthought, Inc.
# License: BSD Style.

# Standard library imports.
import logging

# Enthought library imports.
from traits.api import Instance, on_trait_change, Str
from tvtk.plugins.scene.i_scene_manager import \
            ISceneManager
from tvtk.plugins.scene.ui.actions import NewScene
from tvtk.plugins.scene import scene_editor
from pyface.api import GUI
from pyface.workbench.api import WorkbenchWindow
from apptools.scripting.api import recordable

# Local imports.
from mayavi.core.engine import Engine

logger = logging.getLogger()

######################################################################
# `EnvisageEngine` class
######################################################################
class EnvisageEngine(Engine):

    # The version of this class.  Used for persistence.
    __version__ = 0

    # The envisage application.
    window = Instance(WorkbenchWindow)

    # Our name.
    name = Str('Mayavi Envisage Engine')

    ######################################################################
    # `object` interface
    ######################################################################
    def __get_pure_state__(self):
        d = super(EnvisageEngine, self).__get_pure_state__()
        for x in ['window',]:
            d.pop(x, None)
        return d

    ######################################################################
    # `Engine` interface
    ######################################################################
    def start(self):
        """This starts the engine.  Only after the engine starts is it
        possible to use mayavi.  This particular method is called
        automatically when the window is opened."""

        if self.running:
            return

        # Add all the existing scenes from the scene plugin.
        scene_manager = self.window.get_service(ISceneManager)
        for scene in scene_manager.scenes:
            self.add_scene(scene)

        # Setup a handler that is invoked when a new Scene is
        # added/removed.
        scene_manager.on_trait_change(self._scene_editors_changed,
                                      'scenes_items')

        # Call the parent start method.
        super(EnvisageEngine, self).start()

        logger.debug ('--------- EnvisageEngine started ----------')

    def stop(self):
        # Call the parent stop method.
        super(EnvisageEngine, self).stop()

    @recordable
    def new_scene(self, name=None, **kwargs):
        """ Creates a new VTK scene window.

            For the time being the extra kwargs are ignored with the
            envisage engine.
        """
        action = NewScene(window=self.window)
        editor = action.perform(None)
        if name is not None:
            editor.name = name

        # Flush the UI.
        GUI.process_events()
        return self.scenes[-1]

    @recordable
    def close_scene(self, scene):
        """Given a VTK scene instance, this method closes it.
        """
        active_window = self.window
        s = scene.scene
        for editor in active_window.editors[:]:
            if isinstance(editor, scene_editor.SceneEditor):
                if id(editor.scene) == id(s):
                    editor.close()
                    break
        # Flush the UI.
        GUI.process_events()

    ######################################################################
    # Non-public interface
    ######################################################################
    def _scene_editors_changed(self, list_event):
        """This is called when the items of the editors trait of the
        SceneManager change.  This is used to update `self.scenes`."""
        # Remove any removed scenes.
        for scene in list_event.removed:
            self.remove_scene(scene)
        # Add any new scenes.
        for scene in list_event.added:
            self.add_scene(scene)

    @on_trait_change('window:opened')
    def _on_window_opened(self, obj, trait_name, old, new):
        """We start the engine when the window is opened."""
        if trait_name == 'opened':
            self.start()

    @on_trait_change('window:closed')
    def _on_window_closed(self, obj, trait_name, old, new):
        """We stop the engine when the window is closed."""
        if trait_name == 'closed':
            self.stop()

    def _window_changed(self, old, new):
        """Static trait handler."""
        # This is needed since the service may be offered *after* the
        # window is opened in which case the _on_window_opened will do
        # nothing.
        sm = new.get_service(ISceneManager)
        if sm is not None:
            self.start()

    @on_trait_change('window:editors[]')
    def _sync_scene_editor_name(self, obj, trait_name, old, new):
        """Synchronize the Mayavi scene's name trait with that of the
        editor's name."""
        if trait_name.startswith('editors'):
            scenes = list(self.scenes)
            scenes.reverse()
            for editor in new:
                if not hasattr(editor, 'scene'):
                    continue
                for scene in scenes:
                    if id(editor.scene) == id(scene.scene):
                        editor.name = scene.name
                        scene.sync_trait('name', editor, 'name')
                        break


########NEW FILE########
__FILENAME__ = mayavi_plugin
"""The Mayavi plugin.
"""
# Author: Prabhu Ramachandran <prabhu [at] aero . iitb . ac . in>
# Copyright (c) 2008,  Enthought, Inc.
# License: BSD Style.

from traits.api import List
from envisage.api import Plugin, ServiceOffer

# This module's package.
PKG = '.'.join(__name__.split('.')[:-1])
# The mayavi package ID.
ID = 'mayavi'

###############################################################################
# `MayaviPlugin` class.
###############################################################################
class MayaviPlugin(Plugin):

    # Extension point Ids.
    SERVICE_OFFERS = 'envisage.ui.workbench.service_offers'
    PREFERENCES       = 'envisage.preferences'

    # The plugins name.
    name = 'Mayavi plugin'

    # Our ID.
    id = ID

    ###### Contributions to extension points made by this plugin ######

    # Services we contribute.
    service_offers = List(contributes_to=SERVICE_OFFERS)

    # Preferences.
    preferences = List(contributes_to=PREFERENCES)

    def _preferences_default(self):
        """ Trait initializer. """
        return ['pkgfile://%s/preferences/preferences.ini' % ID]


    ######################################################################
    # Private methods.
    def _service_offers_default(self):
        """ Trait initializer. """
        engine_service_offer = ServiceOffer(
            protocol = 'mayavi.core.engine.Engine',
            factory  = PKG + '.envisage_engine.EnvisageEngine'
        )

        script_service_offer = ServiceOffer(
            protocol = 'mayavi.plugins.script.Script',
            factory  = PKG + '.script.Script'
        )
        return [engine_service_offer, script_service_offer]


########NEW FILE########
__FILENAME__ = mayavi_ui_action_set
"""Mayavi action set for menus and actions etc.
"""
# Author: Prabhu Ramachandran <prabhu [at] aero . iitb . ac . in>
# Copyright (c) 2008, Enthought, Inc.
# License: BSD Style.

# Enthought library imports.
from envisage.ui.action.api import Action, ActionSet, Group, Menu
from mayavi.core.registry import registry

########################################
# Groups

file_group = Group(
    id='MayaviFileGroup',
    path='MenuBar/File',
    before='ExitGroup'
)

visualize_group = Group(
    id='VisualizeGroup',
    path='MenuBar/VisualizeMenu',
)

modules_group = Group(
    id='ModulesGroup',
    path='MenuBar/VisualizeMenu/ModulesMenu',
)

filters_group = Group(
    id='FiltersGroup',
    path='MenuBar/VisualizeMenu/FiltersMenu',
)
########################################
# Menus

open_menu = Menu(
    id     = "LoadDataMenu",
    name   = "&Load data",
    path = 'MenuBar/File',
    group='MayaviFileGroup'
)

visualize_menu = Menu(
    id     = "VisualizeMenu",
    name   = "Visuali&ze",
    path = "MenuBar",
    before = "View"
)

modules_menu = Menu(
    id     = "ModulesMenu",
    name   = "&Modules",
    path="MenuBar/VisualizeMenu",
)

filters_menu = Menu(
    id     = "FiltersMenu",
    name   = "&Filters",
    path="MenuBar/VisualizeMenu",
    after="ModulesMenu",
)

########################################
# File menu items.

ID = 'mayavi'

####################
# Source actions.

open_file = Action(
    id            = "OpenFile",
    class_name    = ID + ".action.sources.OpenFile",
    name          = "&Open file ...",
    path        =  "MenuBar/File/LoadDataMenu"
)

# Automatic source generation for non-open file related sources.
SOURCE_ACTIONS = [open_file]

for src in registry.sources:
    if len(src.extensions) == 0:
        action = Action(id=src.id,
                        class_name=ID + ".action.sources." + src.id,
                        name= src.menu_name,
                        path="MenuBar/File/LoadDataMenu"
                        )
        SOURCE_ACTIONS.append(action)

####################
# Save/load actions.

save_viz = Action(
    id            = "SaveVisualization",
    class_name    = ID + ".action.save_load.SaveVisualization",
    name          = "&Save Visualization",
    group = "MayaviFileGroup",
    path="MenuBar/File",
)

load_viz = Action(
    id            = "LoadVisualization",
    class_name    = ID + ".action.save_load.LoadVisualization",
    name          = "&Load Visualization",
    group = "MayaviFileGroup",
    path="MenuBar/File",
)

run_script = Action(
    id            = "RunScript",
    class_name    = ID + ".action.save_load.RunScript",
    name          = "&Run Python Script",
    group = "MayaviFileGroup",
    path="MenuBar/File",
)

########################################
# Visualize menu items.

add_mm = Action(
    id            = "AddModuleManager",
    class_name    = ID + ".action.modules.AddModuleManager",
    name          = "&Add ModuleManager",
    path="MenuBar/VisualizeMenu",
    after="FiltersMenu"
)

########################################
# Modules.

MODULE_ACTIONS = []
for module in registry.modules:
    action = Action(id=module.id,
                    class_name=ID + ".action.modules." + module.id,
                    name= module.menu_name,
                    group = "ModulesGroup",
                    path="MenuBar/VisualizeMenu/ModulesMenu"
                    )
    MODULE_ACTIONS.append(action)

########################################
# Filter items.
########################################
FILTER_ACTIONS = []
for filter in registry.filters:
    action = Action(id=filter.id,
                    class_name=ID + ".action.filters." + filter.id,
                    name= filter.menu_name,
                    group = "FiltersGroup",
                    path="MenuBar/VisualizeMenu/FiltersMenu"
                    )
    FILTER_ACTIONS.append(action)

########################################
# Help menu items.

help_index = Action(
    id            = "HelpIndex",
    class_name    = ID + ".action.help.HelpIndex",
    name          = "&User Guide",
    path="MenuBar/Help"
)


tvtk_class_browser = Action(
    id            = "TVTKClassBrowser",
    class_name    = ID + ".action.help.TVTKClassBrowser",
    name          = "&VTK Class Browser",
    path          = "MenuBar/Help",
)


################################################################################
# `MayaviUIActionSet` class.
################################################################################
class MayaviUIActionSet(ActionSet):
    """ The default action set for the mayavi UI plugin. """

    groups  = [file_group,
               visualize_group,
               modules_group,
               filters_group,
               ]
    menus = [open_menu,
             visualize_menu,
             modules_menu,
             filters_menu
             ]
    actions = SOURCE_ACTIONS + \
              [save_viz, # Save load actions.
               load_viz,
               run_script,
               # Add module manager.
               add_mm,
              ] + \
              MODULE_ACTIONS + \
              FILTER_ACTIONS + \
              [help_index,
               tvtk_class_browser,
              ]

########NEW FILE########
__FILENAME__ = mayavi_ui_plugin
"""The Mayavi UI plugin
"""
# Author: Prabhu Ramachandran <prabhu [at] aero . iitb . ac . in>
# Copyright (c) 2008, Enthought, Inc.
# License: BSD Style.

# Standard library imports.
import logging

# Enthought library imports.
from traits.api import List, on_trait_change
from envisage.api import Plugin
from pyface.workbench.api import Perspective, PerspectiveItem
from traits.etsconfig.api import ETSConfig

logger = logging.getLogger()

# View IDs.
ENGINE_VIEW = 'mayavi.core.ui.engine_view.EngineView'
CURRENT_SELECTION_VIEW = 'mayavi.core.engine.Engine.current_selection'
SHELL_VIEW = 'envisage.plugins.python_shell_view'
LOGGER_VIEW = 'apptools.logger.plugin.view.logger_view.LoggerView'

###############################################################################
# `MayaviPerspective` class.
###############################################################################
class MayaviPerspective(Perspective):
    """ A default perspective for Mayavi. """

    # The perspective's name.
    name = 'Mayavi'

    # Should this perspective be enabled or not?
    enabled = True

    # Should the editor area be shown in this perspective?
    show_editor_area = True

    # The contents of the perspective.
    contents = List()

    def _contents_default(self):
        contents = [
            PerspectiveItem(id=ENGINE_VIEW, position='left'),
            PerspectiveItem(id=CURRENT_SELECTION_VIEW, position='bottom',
                            relative_to=ENGINE_VIEW),
            PerspectiveItem(id=SHELL_VIEW, position='bottom'),
        ]
        show_logger = True
        if ETSConfig.toolkit == 'wx':
            # XXX: Bugware: avoid a crash in Wx with the logger
            import wx
            if wx.__version__.split('.')[:2] == ['2', '6']:
                show_logger = False

        if show_logger:
            contents.append(PerspectiveItem(id=LOGGER_VIEW, position='with',
                                            relative_to=SHELL_VIEW))
        return contents


###############################################################################
# `MayaviUIPlugin` class.
###############################################################################
class MayaviUIPlugin(Plugin):

    # Extension point Ids.
    VIEWS             = 'envisage.ui.workbench.views'
    PERSPECTIVES      = 'envisage.ui.workbench.perspectives'
    PREFERENCES_PAGES = 'envisage.ui.workbench.preferences_pages'
    ACTION_SETS       = 'envisage.ui.workbench.action_sets'
    BANNER            = 'envisage.plugins.ipython_shell.banner'


    # The plugins name.
    name = 'Mayavi UI plugin'

    # Our ID.
    id = 'mayavi_ui'

    ###### Contributions to extension points made by this plugin ######

    # Views.
    views = List(contributes_to=VIEWS)

    # Perspectives.
    perspectives = List(contributes_to=PERSPECTIVES)

    # Preferences pages.
    preferences_pages = List(contributes_to=PREFERENCES_PAGES)

    # Our action sets.
    action_sets = List(contributes_to=ACTION_SETS)

    # IPython banner
    banner = List(contributes_to=BANNER)

    def _views_default(self):
        """ Trait initializer. """
        return [self._engine_view_factory,
                self._current_selection_view_factory]

    def _perspectives_default(self):
        """ Trait initializer. """
        return [MayaviPerspective]

    def _preferences_pages_default(self):
        """ Trait initializer. """
        from mayavi.preferences.mayavi_preferences_page import (
            MayaviRootPreferencesPage, MayaviMlabPreferencesPage)
        return [MayaviRootPreferencesPage, MayaviMlabPreferencesPage]

    def _action_sets_default(self):
        """ Trait initializer. """
        from mayavi.plugins.mayavi_ui_action_set import (
            MayaviUIActionSet
        )
        return [MayaviUIActionSet]

    def _banner_default(self):
        """Trait initializer """
        return ["""Welcome to Mayavi, this is the interactive IPython shell.

If this is your first time using Mayavi, take a quick look at the tutorial examples section of the user guide, accessible via the help menu.
To use Mayavi, you need to load your data in "data sources" and apply "visualization modules" to it.
"""]

    ######################################################################
    # Private methods.
    def _engine_view_factory(self, window, **traits):
        """ Factory method for engine views. """
        from pyface.workbench.traits_ui_view import \
                TraitsUIView
        from mayavi.core.ui.engine_view import \
                            EngineView

        engine_view = EngineView(engine=self._get_engine(window))
        tui_engine_view = TraitsUIView(obj=engine_view,
                                       id=ENGINE_VIEW,
                                       name='Mayavi',
                                       window=window,
                                       position='left',
                                       **traits
                                       )
        return tui_engine_view

    def _current_selection_view_factory(self, window, **traits):
        """ Factory method for the current selection of the engine. """

        from pyface.workbench.traits_ui_view import \
                TraitsUIView

        engine = self._get_engine(window)
        tui_engine_view = TraitsUIView(obj=engine,
                                       view='current_selection_view',
                                       id=CURRENT_SELECTION_VIEW,
                                       name='Mayavi object editor',
                                       window=window,
                                       position='bottom',
                                       relative_to=ENGINE_VIEW,
                                       **traits
                                       )
        return tui_engine_view

    def _get_engine(self, window):
        """Return the Mayavi engine of the particular window."""
        from mayavi.core.engine import Engine
        return window.get_service(Engine)

    def _get_script(self, window):
        """Return the `mayavi.plugins.script.Script` instance
        of the window."""
        from mayavi.plugins.script import Script
        return window.get_service(Script)

    ######################################################################
    # Trait handlers.
    @on_trait_change('application.gui:started')
    def _on_application_gui_started(self, obj, trait_name, old, new):
        """This is called when the application's GUI is started.  The
        method binds the `Script` and `Engine` instance on the
        interpreter.
        """
        # This is called when the application trait is set but we don't
        # want to do anything at that point.
        if trait_name != 'started' or not new:
            return

        # Get the script service.
        app = self.application
        window = app.workbench.active_window
        script = self._get_script(window)

        # Get a hold of the Python shell view.
        id = SHELL_VIEW
        py = window.get_view_by_id(id)
        if py is None:
            logger.warn('*'*80)
            logger.warn("Can't find the Python shell view to bind variables")
            return

        # Bind the script and engine instances to names on the
        # interpreter.
        try:
            py.bind('mayavi', script)
            py.bind('engine', script.engine)
            # The following will fail under Qt, as it needs the Pyface
            # Tree that has not been ported from Wx yet.
            from apptools.naming.ui.api import explore
            py.bind('explore', explore)
        except AttributeError, msg:
            # This can happen when the shell is not visible.
            # FIXME: fix this when the shell plugin is improved.
            logger.warn(msg)
            logger.warn("Can't find the Python shell to bind variables")


########NEW FILE########
__FILENAME__ = mayavi_workbench_application
"""Mayavi specific workbench application.
"""
# Author: Prabhu Ramachandran <prabhu [at] aero . iitb . ac . in>
# Copyright (c) 2008, Enthought, Inc.
# License: BSD Style.

# Standard library imports.
from os.path import dirname
import logging

# Enthought library imports.
from traits.api import Bool
from envisage.ui.workbench.api import WorkbenchApplication
from pyface.api import AboutDialog, ImageResource, SplashScreen

# Local imports.
import mayavi.api
from mayavi.preferences.api import preference_manager

IMG_DIR = dirname(mayavi.api.__file__)
logger = logging.getLogger(__name__)


class MayaviWorkbenchApplication(WorkbenchApplication):
    """ The mayavi application. """

    #### MayaviWorkbenchApplication interface #################################

    # Turn this off if you don't want the workbench to start a GUI
    # event loop.
    start_gui_event_loop = Bool(True, desc='start a GUI event loop')

    #### 'IApplication' interface #############################################

    # The application's globally unique Id.
    id = 'mayavi_e3'

    #### 'WorkbenchApplication' interface #####################################

    # Branding information.
    #
    # The icon used on window title bars etc.
    icon = ImageResource('m2.ico', search_path=[IMG_DIR])

    # The name of the application (also used on window title bars etc).
    name = 'Mayavi2 - The 3D data visualizer'

    ###########################################################################
    # 'WorkbenchApplication' interface.
    ###########################################################################
    def run(self):
        """ Run the application.

        This does the following:

        1) Starts the application
        2) Creates and opens a workbench window
        3) Starts the GUI event loop (only if start_gui_event_loop is
           True)
        4) When the event loop terminates, stops the application

        This particular method is overridden from the parent class to
        allow the user to not run the gui event loop as would be
        necessary when the loop is started elsewhere or when run fron
        IPython.

        """

        logger.debug('---------- workbench application ----------')

        # Make sure the GUI has been created (so that, if required, the splash
        # screen is shown).
        gui = self.gui

        # Start the application.
        if self.start():
            # Create and open the first workbench window.
            window = self.workbench.create_window(
                position=self.window_position, size=self.window_size
            )
            window.open()

            # We stop the application when the workbench has exited.
            self.workbench.on_trait_change(self._on_workbench_exited, 'exited')

            # Start the GUI event loop if needed.
            if self.start_gui_event_loop:
                # THIS CALL DOES NOT RETURN UNTIL THE GUI IS CLOSED.
                gui.start_event_loop()

        return


    ######################################################################
    # Non-public interface.
    ######################################################################
    def _about_dialog_default(self):
        """ Trait initializer. """
        from mayavi import api
        from vtk import vtkVersion
        vtk_version = vtkVersion().GetVTKVersion()
        about_dialog = AboutDialog(
            parent = self.workbench.active_window.control,
            image  = ImageResource('m2_about.jpg',
                                   search_path=[IMG_DIR]),
            additions = ['Authors: Prabhu Ramachandran',
                            'and Gael Varoquaux',
                            '',
                            'Mayavi version %s \t - \t VTK version %s' %
                            (api.__version__, vtk_version)],
        )

        return about_dialog

    def _splash_screen_default(self):
        """ Trait initializer. """
        if preference_manager.root.show_splash_screen:
            splash_screen = SplashScreen(
                image             = ImageResource('m2_about.jpg',
                                                  search_path=[IMG_DIR]),
                show_log_messages = True,
            )
        else:
            splash_screen = None

        return splash_screen


########NEW FILE########
__FILENAME__ = script
"""This represents the scripting API for MayaVi.

The Script class provides a scriptable view of the MayaVi Engine.  It is
safe to instantiate as many Script instances as desired.

"""

# Author: Prabhu Ramachandran <prabhu_r@users.sf.net>
# Copyright (c) 2005-2008, Enthought, Inc.
# License: BSD Style.

# Enthought imports
from traits.api import HasTraits, Instance

# Local imports
from mayavi.core.engine import Engine
from mayavi.core.common import exception


##############################################################################
# Utility functions.
##############################################################################
def get_imayavi_engine(window):
    """Returns the MayaVi Engine given the Envisage worbench window.
    """
    return window.get_service(Engine)

def get_imayavi(window):
    """Given the Envisage workbench window, returns the
    mayavi.script.Script instance (registered as
    `mayavi.services.IMAYAVI`).
    """
    return window.get_service(Script)


##############################################################################
# `Script` class.
##############################################################################
class Script(HasTraits):
    """This class basically presents a scriptable 'view' of the MayaVi
    Engine.  It is registered as the IMayaVi service (via an
    ApplicationObject) because this is the interface users should be
    using when they script.
    """

    # The workbench window we are associated with.
    window = Instance('pyface.workbench.api.WorkbenchWindow')

    # The MayaVi engine that we are managing.
    engine = Instance(Engine)

    ######################################################################
    # `Script` interface
    ######################################################################
    def add_source(self, src, scene=None):
        """Adds a given source to the MayaVi pipeline.
        """
        try:
            self.engine.add_source(src, scene=scene)
        except:
            exception()

    def add_module(self, mod, obj=None):
        """Adds a given module to the MayaVi pipeline. Adds it to the selected
        object, or to an object passed thought the kwarg `obj`.
        """
        try:
            self.engine.add_module(mod, obj=obj)
        except:
            exception()

    def add_filter(self, fil, obj=None):
        """Adds a given filter to the MayaVi pipeline. Adds it to the selected
        object, or to an object passed thought the kwarg `obj`.
        """
        try:
            self.engine.add_filter(fil, obj=obj)
        except:
            exception()

    def new_scene(self):
        """Creates a new VTK scene window.
        """
        return self.engine.new_scene()

    def load_visualization(self, fname):
        """Given a file/file name this loads the visualization.
        """
        try:
            self.engine.load_visualization(fname)
        except:
            exception()

    def save_visualization(self, fname):
        """Given a file or a file name, this saves the current
        visualization to the file.
        """
        try:
            self.engine.save_visualization(fname)
        except:
            exception()

    def get_active_window(self):
        """Get the currently active window."""
        return self.window

    def open(self, filename):
        """Open a data file if possible.
        """
        try:
            return self.engine.open(filename)
        except:
            exception()

    ######################################################################
    # Non-public interface
    ######################################################################
    def _window_changed(self, window):
        """Traits handler for changes to application.
        """
        self.engine = get_imayavi_engine(window)


########NEW FILE########
__FILENAME__ = api
"""The public API for the preferences."""

# The global PreferenceManager instance
from preference_manager import preference_manager
from bindings import set_scene_preferences, get_scene_preferences

########NEW FILE########
__FILENAME__ = bindings
"""
Code to setup the preferences for common objects.
"""
# Author: Prabhu Ramachandran <prabhu@aero.iitb.ac.in>
# Copyright (c) 2008, Prabhu Ramachandran
# License: BSD Style.

from preference_manager import preference_manager


def get_scene_preferences():
    """Return a dictionary of the scene's default preferences."""
    pref = preference_manager.preferences
    res = {}
    res['stereo'] = eval(pref.get('tvtk.scene.stereo'))
    res['magnification'] = \
            eval(pref.get('tvtk.scene.magnification'))
    res['foreground'] = eval(pref.get('tvtk.scene.foreground_color'))
    res['background'] = eval(pref.get('tvtk.scene.background_color'))
    return res

def set_scene_preferences(scene, prefs_dict=None):
    """Setup the preferences for a scene given a scene and an optional
    dictionary with the preferences.
    """
    if prefs_dict is None:
        prefs_dict = get_scene_preferences()
    # Set the preferences.
    scene.set(**prefs_dict)
    # If this isn't done the background isn't set.
    scene.renderer.background = scene.background


########NEW FILE########
__FILENAME__ = contrib_finder
""" Code that looks for mayavi contributions on sys.path or other
standard places, making it easy for users to add contributions to load
on startup.
"""

# Author: Prabhu Ramachandran <prabhu@aero.iitb.ac.in>
# Copyright (c) 2008, Prabhu Ramachandran
# License: BSD Style.

import sys
from os.path import isdir, exists, join, basename
from os import listdir

from traits.api import (HasTraits, List, Str, Instance,
    DelegatesTo, Button)
from traitsui.api import View, Item, SetEditor


################################################################################
# `ContribFinder` class.
################################################################################
class ContribFinder(HasTraits):
    """
    This class helps find installed mayavi contributions.
    """

    # The preference helper whose contrib_packages trait we contribute
    # to.
    preference_helper = Instance(HasTraits)

    # The selected contributions.
    contrib_packages = DelegatesTo('preference_helper')

    # The found contrib packages.
    found_contrib = List(Str, desc='the mayavi contribution '
                                   'packages on the system')

    # Search for contributions.
    search = Button('Search for packages',
                    desc='search again for contributions')

    ########################################
    # View related code.

    view = View(Item('contrib_packages',
                     show_label=False,
                     editor=SetEditor(name='found_contrib',
                                      left_column_title='Available '\
                                                        'contributions',
                                      right_column_title='Selected '\
                                                        'contributions',
                                      can_move_all=False),
                     resizable=True,
                     ),
                 Item('search', show_label=False),
                 resizable=True
                )

    ######################################################################
    # `object` interface.
    ######################################################################
    def __init__(self, **traits):
        super(ContribFinder, self).__init__(**traits)
        # Find the contributions by default.
        self.find()

    ######################################################################
    # `ContribFinder` interface.
    ######################################################################
    def find(self):
        """Find the contrib directories from sys.path."""
        found = []
        for d in sys.path:
            if isdir(d):
                for s in listdir(d):
                    if exists(join(d, s, 'user_mayavi.py')):
                        found.append(s)
        self.found_contrib = found

    ######################################################################
    # Non-public interface.
    ######################################################################
    def _preference_helper_default(self):
        from preference_manager import preference_manager
        return preference_manager.root

    def _search_fired(self):
        self.find()


########NEW FILE########
__FILENAME__ = mayavi_preferences_page
"""Preferences for Mayavi
"""
# Author: Prabhu Ramachandran <prabhu [at] aero . iitb . ac . in>
# Copyright (c) 2008,  Enthought, Inc.
# License: BSD Style.

# Enthought library imports.
from traits.api import (Bool, Enum, Tuple, Range, List,
        Str, Instance, HasTraits)
from traitsui.api import View, Group, Item, RGBColorEditor
from apptools.preferences.ui.api import PreferencesPage

################################################################################
# `MayaviRootPreferencesPage` class
################################################################################
class MayaviRootPreferencesPage(PreferencesPage):
    """ Preferences page for Mayavi. """

    #### 'PreferencesPage' interface ##########################################

    # The page's category (e.g. 'General/Appearance'). The empty string means
    # that this is a top-level page.
    category = ''

    # The page's help identifier (optional). If a help Id *is* provided then
    # there will be a 'Help' button shown on the preference page.
    help_id = ''

    # The page name (this is what is shown in the preferences dialog.
    name = 'Mayavi'

    # The path to the preferences node that contains the preferences.
    preferences_path = 'mayavi'

    #### Preferences ##########################################################

    # Specifies if the nodes on the tree may be deleted without a
    # confirmation or not.  If True the user will be prompted before
    # the object is deleted.  If it is False then the user will not be
    # prompted.
    confirm_delete = Bool(desc='if the user is prompted before'
                          ' a node on the MayaVi tree is deleted')

    # Specifies if the splash screen is shown when mayavi starts.
    show_splash_screen = Bool(desc='if the splash screen is shown at'
                              ' startup')

    # Specifies if the adder nodes are shown on the mayavi tree view.
    show_helper_nodes = Bool(desc='if the helper (adder) nodes are shown'
                             ' on the tree view')

    # Specifies if the adder nodes are shown on the mayavi tree view.
    open_help_in_light_browser = Bool(
                    desc='if the help pages are opened in a chromeless'
                             'browser window (only works with Firefox')

    # Contrib directories to load on startup.
    contrib_packages = List(Str, desc='contrib packages to load on startup')

    # Whether or not to use IPython for the Shell.
    use_ipython = Bool(desc='use IPython for the embedded shell '
                            '(if available)')

    ########################################
    # Private traits.
    _contrib_finder = Instance(HasTraits)

    #### Traits UI views ######################################################

    traits_view = View(
                    Group(
                        Group(
                            Item(name='confirm_delete'),
                            Item(name='show_splash_screen'),
                            Item(name='show_helper_nodes'),
                            Item(name='open_help_in_light_browser'),
                            Item(name='use_ipython'),
                            label='General settings',
                            show_border=True,
                            ),
                        Group(
                            Group(
                                Item('_contrib_finder',
                                     style='custom',
                                     show_label=False,
                                     resizable=True,
                                     ),
                                ),
                            label='Contribution settings',
                            show_border=True,
                            ),
                        ),
                    resizable=True
                    )

    ######################################################################
    # Non-public interface.
    ######################################################################
    def __contrib_finder_default(self):
        from contrib_finder import ContribFinder
        return ContribFinder()


################################################################################
# `MayaviMlabPreferencesPage` class
################################################################################
class MayaviMlabPreferencesPage(PreferencesPage):
    """ Preferences page for Mayavi. """

    #### 'PreferencesPage' interface ##########################################

    # The page's category (e.g. 'General/Appearance'). The empty string means
    # that this is a top-level page.
    category = 'Mayavi'

    # The page's help identifier (optional). If a help Id *is* provided then
    # there will be a 'Help' button shown on the preference page.
    help_id = ''

    # The page name (this is what is shown in the preferences dialog.
    name = 'Mlab'

    # The path to the preferences node that contains the preferences.
    preferences_path = 'mayavi.mlab'

    #### Preferences ##########################################################

    # The mlab backend to use.
    backend = Enum('auto', 'envisage', 'simple', 'test',
                   desc='the mlab backend to use')

    # The background color of the renderer.
    background_color = Tuple(Range(0., 1., 1.), 
                             Range(0., 1., 1.), 
                             Range(0., 1., 1.),
                             editor=RGBColorEditor,
                             desc='the background color of the scene')

    # The foreground color of the renderer.
    foreground_color = Tuple(Range(0., 1., 0.), 
                             Range(0., 1., 0.), 
                             Range(0., 1., 0.),
                             editor=RGBColorEditor,
                             desc='the foreground color of the scene')

    # Offscreen rendering.
    offscreen = Bool(desc='if mlab should use offscreen rendering'
                          ' (no window will show up in this case)')


    ######################################################################
    # Traits UI view.

    traits_view = View(Group(
                             Item('backend'),
                             Item('background_color'),
                             Item('foreground_color'),
                             Item('offscreen'),
                             ),
                       resizable=True
                      )


########NEW FILE########
__FILENAME__ = preferences_helpers
"""Various preference helpers for the mayavi preferences.
"""
# Author: Prabhu Ramachandran <prabhu [at] aero . iitb . ac . in>
# Copyright (c) 2008,  Enthought, Inc.
# License: BSD Style.

# Enthought library imports
from traits.api import (Bool, Enum, Tuple, Range, List,
        Str, Instance, HasTraits)
from traitsui.api import (View, Group, Item, RGBColorEditor,
        InstanceEditor)
from apptools.preferences.api import PreferencesHelper

################################################################################
# `RootPreferencesHelper` class
################################################################################
class RootPreferencesHelper(PreferencesHelper):

    # The preferences path for which we use.
    preferences_path = 'mayavi'

    ######################################################################
    # Our preferences.

    # Specifies if the nodes on the tree may be deleted without a
    # confirmation or not.  If True the user will be prompted before
    # the object is deleted.  If it is False then the user will not be
    # prompted.
    confirm_delete = Bool(desc='if the user is prompted before'
                          ' a node on the MayaVi tree is deleted')

    # Specifies if the splash screen is shown when mayavi starts.
    show_splash_screen = Bool(desc='if the splash screen is shown at'
                              ' startup')

    # Specifies if the adder nodes are shown on the mayavi tree view.
    show_helper_nodes = Bool(desc='if the helper (adder) nodes are shown'
                             ' on the tree view')

    # Specifies if the adder nodes are shown on the mayavi tree view.
    open_help_in_light_browser = Bool(
                    desc='if the help pages are opened in a chromeless'
                         ' browser window (only works with Firefox)')

    # Contrib directories to load on startup.
    contrib_packages = List(Str, desc='contrib packages to load on startup')


    # Whether or not to use IPython for the Shell.
    use_ipython = Bool(desc='use IPython for the embedded shell '
                            '(if available)')

    ########################################
    # Private traits.
    _contrib_finder = Instance(HasTraits)

    ######################################################################
    # Traits UI view.

    traits_view = View(
                    Group(
                        Item(name='confirm_delete'),
                        Item(name='show_splash_screen'),
                        Item(name='show_helper_nodes'),
                        Item(name='open_help_in_light_browser'),
                        Item('_contrib_finder',
                             show_label=False,
                             editor=InstanceEditor(label='Find contributions'),
                             )
                         ),
                    resizable=True
                    )

    ######################################################################
    # Non-public interface.
    ######################################################################
    def __contrib_finder_default(self):
        from contrib_finder import ContribFinder
        return ContribFinder()

################################################################################
# `MlabPreferencesHelper` class
################################################################################
class MlabPreferencesHelper(PreferencesHelper):

    # The preferences path for which we use.
    preferences_path = 'mayavi.mlab'

    ######################################################################
    # Our preferences.

    # The mlab backend to use.
    backend = Enum('auto', 'envisage', 'simple', 'test',
                   desc='the mlab backend to use')

    # The background color of the renderer.
    background_color = Tuple(Range(0., 1.), Range(0., 1.), Range(0., 1.),
                             editor=RGBColorEditor,
                             desc='the background color of the scene')

    # The foreground color of the renderer.
    foreground_color = Tuple(Range(0., 1.), Range(0., 1.), Range(0., 1.),
                             editor=RGBColorEditor,
                             desc='the foreground color of the scene')

    # Offscreen rendering.
    offscreen = Bool(desc='if mlab should use offscreen rendering'
                          ' (no window will show up in this case)')

    ######################################################################
    # Traits UI view.

    traits_view = View(Group(
                             Item('backend'),
                             Item('background_color'),
                             Item('foreground_color'),
                             Item('offscreen')
                             ),
                       resizable=True
                      )


########NEW FILE########
__FILENAME__ = preference_manager
"""A preference manager for all mayavi related preferences.

The idea behind this module is that it lets the mayavi
library/application use the same preferences by managing them no matter
if mayavi is used as an application (via envisage3) or as a library.

The preferences helpers are divided into different categories for
different kinds of preferences.  Currently the following are available.

  - root: for global mayavi preferences of the form
    'mayavi.preference'.

For more details on the general preferences support in enthought, please
read the documentation for apptools.preferences (part of the AppTools
package).

"""
# Author: Prabhu Ramachandran <prabhu [at] aero . iitb . ac . in>
# Copyright (c) 2008,  Enthought, Inc.
# License: BSD Style.

# Standard library imports
from os.path import join
import pkg_resources

# Enthought library imports.
from traits.etsconfig.api import ETSConfig
from traits.api import HasTraits, Instance
from traitsui.api import View, Group, Item
from apptools.preferences.api import (ScopedPreferences, IPreferences,
        PreferencesHelper)

# Local imports.
from mayavi.preferences.preferences_helpers import (
        RootPreferencesHelper, MlabPreferencesHelper )

# The application ID where the preferences are stored.
ID = 'mayavi_e3'


################################################################################
# `PreferenceManager` class
################################################################################
class PreferenceManager(HasTraits):

    # The root preferences helper for preferences of the form
    # 'mayavi.preference'.
    root = Instance(PreferencesHelper)

    # The mlab preferences helper for preferences of the form
    # 'mayavi.mlab.preference'.
    mlab = Instance(PreferencesHelper)

    # The preferences.
    preferences = Instance(IPreferences)

    ######################################################################
    # Traits UI view.

    traits_view = View(Group(
                           Group(Item(name='root', style='custom'),
                                 show_labels=False, label='Root',
                                 show_border=True
                                ),
                           Group(Item(name='mlab', style='custom'),
                                 show_labels=False, label='Mlab',
                                 show_border=True,
                                ),
                           ),
                       buttons=['OK', 'Cancel'],
                       resizable=True
                      )

    ######################################################################
    # `HasTraits` interface.
    ######################################################################
    def __init__(self, **traits):
        super(PreferenceManager, self).__init__(**traits)

        if 'preferences' not in traits:
            self._load_preferences()

    def _preferences_default(self):
        """Trait initializer."""
        return ScopedPreferences()

    def _root_default(self):
        """Trait initializer."""
        return RootPreferencesHelper(preferences=self.preferences)

    def _mlab_default(self):
        """Trait initializer."""
        return MlabPreferencesHelper(preferences=self.preferences)

    ######################################################################
    # Private interface.
    ######################################################################
    def _load_preferences(self):
        """Load the default preferences."""
        # Save current application_home.
        app_home = ETSConfig.get_application_home()
        # Set it to where the mayavi preferences are temporarily.
        path = join(ETSConfig.get_application_data(), ID)
        ETSConfig.application_home = path
        try:
            for pkg in ('mayavi.preferences',
                        'tvtk.plugins.scene'):
                pref = 'preferences.ini'
                pref_file = pkg_resources.resource_stream(pkg, pref)

                preferences = self.preferences
                default = preferences.node('default/')
                default.load(pref_file)
                pref_file.close()
        finally:
            # Set back the application home.
            ETSConfig.application_home = app_home

    def _preferences_changed(self, preferences):
        """Setup the helpers if the preferences trait changes."""
        for helper in (self.root, ):
            helper.preferences = preferences


##########################################################
# A Global preference manager that all other modules can use.

preference_manager = PreferenceManager()


########NEW FILE########
__FILENAME__ = preference_manager_view
"""
A view for the Mayavi preferences outside of Envisage.
"""
# Author: Gael Varoquaux <gael dot varoquaux at normalesup dot org>
# Copyright (c) 2008,  Enthought, Inc.
# License: BSD Style.

# Standard library imports
from os.path import join

# Enthought library imports.
from traits.api import List
from apptools.preferences.ui.api import PreferencesManager, \
    PreferencesPage
from pyface.api import ImageResource
from pyface.resource.api import resource_path
from apptools.preferences.ui.preferences_node import PreferencesNode

# Local imports.
from mayavi.preferences.mayavi_preferences_page import \
    MayaviRootPreferencesPage, MayaviMlabPreferencesPage

from mayavi.preferences.preference_manager import \
    preference_manager

################################################################################
# `PreferenceManagerView` class
################################################################################
class PreferenceManagerView(PreferencesManager):
    """ A preference manager UI for Mayavi, to be used outside of
        Envisage.
    """

    # Path used to search for images
    _image_path = [join(resource_path(), 'images'), ]

    # The icon of the dialog
    icon = ImageResource('preferences.ico', search_path=_image_path)

    # The preference pages displayed
    pages = List(PreferencesPage)

    def _pages_default(self):
        return [
                MayaviRootPreferencesPage(
                    preferences=preference_manager.root.preferences),
                MayaviMlabPreferencesPage(
                    preferences=preference_manager.mlab.preferences),
                ]

    def dialog_view(self):
        """ Poor-man's subclassing of view to overload size.
        """
        view = self.trait_view()
        view.width = 0.7
        view.height = 0.5
        view.title = 'Mayavi preferences'
        view.icon = self.icon
        ui = self.edit_traits(
                view=view,
                scrollable=True,
                id='mayavi.preferences.preference_view')
        return ui

    def _get_root(self):
        """ Subclass the root getter, to work outside of envisage, with
            no well-defined root.
        """
        root = PreferencesNode(page=self.pages[0])
        for page in self.pages:
            root.append(PreferencesNode(page=page))
        return root

    def apply(self):
        super(PreferenceManagerView, self).apply()
        for page in self.pages:
            page.preferences.save()


preference_manager_view = PreferenceManagerView()



########NEW FILE########
__FILENAME__ = mayavi2
#!/usr/bin/env python
"""The Mayavi application standalone script.

This script parses the command line arguments and launches Mayavi2
suitably.  It is meant to be used by those using Mayavi2 as a
standalone application.

Mayavi2 wiki page: http://svn.enthought.com/enthought/wiki/MayaVi

Author: Prabhu Ramachandran <prabhu_r@users.sf.net>

"""
# Author: Prabhu Ramachandran <prabhu_r@users.sf.net>
# Copyright (c) 2005-2008, Enthought, Inc.
# License: BSD Style.

# Standard library imports.
import sys
import types
import getopt
import logging
from os.path import splitext, exists, join, abspath

# Local imports.
from mayavi.__version__ import __version__
from mayavi.scripts.util import get_data_dir

# Globals.
OFFSCREEN = False

# A global mayavi instance so we can close it correctly.
mayavi = None


###########################################################################
# Utility functions.
###########################################################################
def usage ():
    msg="""Usage:\n\nmayavi2 [options] ... [arg1] [arg2] ...

Where arg1, arg2 ... are optional file names that correspond to saved
Mayavi2 visualizations (file.mv2) or Mayavi2 scripts (file.py) or any
data files supported by Mayavi.  Valid options are one or more of the
following:

-d datafile.ext
--data datafile.ext

     datafile.ext can be any of the supported data file formats.  This
     includes VTK file formats (*.vtk, *.xml, *.vt[i,p,r,s,u],
     *.pvt[i,p,r,s,u]), VRML2 (*.wrl), 3D Studio (*.3ds), PLOT3D
     (*.xyz), STL, BYU, RAW, PLY,  PDB,  SLC,  FACET,  OBJ,  AVSUCD
     (*.inp),  GAMBIT (*.neu),  Exodus  (*.exii),  PNG,  JPEG,  BMP,
     PNM, DCM, DEM, MHA, MHD, MINC, XIMG, TIFF, and various others that
     are supported.  datafile.ext can also be a source object not
     associated with a file, for example ParametricSurface or PointLoad
     will load the corresponding data sources into Mayavi.

--filter filter-name
-f filter-name

     The passed filter name is loaded with respect to the current
     source/filter object.  The filter name must be a valid one if not
     you will get an error message.

     If the filter is specified as 'package.sub.filter.SomeFilter'
     then the filter (`SomeFilter`) is imported from
     'package.sub.filter'.  Standard modules provided with mayavi2 do
     not need the full path specification.

     Example::
         mayavi2 -d data.vtk -f ExtractVectorNorm -f m2_user_filters.TestFilter

     In this example 'ExtractVectorNorm' is a standard filter and
     'm2_user_filters.TestFilter' is some user defined filter.

-m module-name
--module module-name

     The passed module name is loaded in the current ModuleManager.
     The module name must be a valid one if not you will get an error
     message.

     If a module is specified as 'package.sub.module.SomeModule' then
     the module (`SomeModule`) is imported from 'package.sub.module'.
     Standard modules provided with mayavi2 do not need the full path
     specification.

     Example::
         mayavi2 -d data.vtk -m Outline -m m2_user_modules.TestModule

     In this example 'Outline' is a standard module and
     'm2_user_modules.TestModule' is some user defined module.

-M
--module-mgr

     Starts up a new module manager on the Mayavi pipeline.

-n
--new-scene

     Creates a new TVTK scene.  Any options passed after this will
     apply to this newly created scene.

-o
--offscreen

     Run Mayavi in offscreen mode without any graphical user interface.
     This is most useful for scripts that need to render images
     offscreen.

-x script-file
--exec script-file

     This executes the given script in a namespace where we guarantee
     that the name 'mayavi' is Mayavi's script instance -- just like
     in the embedded Python interpreter.

     **WARNING**: Note that this uses `execfile`, so please note that
                  this can be dangerous if the script does something
                  nasty!

-s python-expression
--set python-expression

     Execute the expression on the last created object.  For example,
     lets say the previous object was a module.  If you want to set the
     color of that object and save the scene you may do::

      $ mayavi2 [...] -m Outline -s"actor.property.color = (1,0,0)" \
        -s "scene.save('test.png', size=(800, 800))"

     You should use quotes for the expression.

     **WARNING**: Note that this uses `exec`, so please note that
                  this can be dangerous!

-z saved-visualization-file
--viz saved-visualization-file
--visualization saved-visualization-file

     Loads a previously saved Mayavi2 visualization file passed as the
     argument.

-t
--test

     Runs the mayavi2 test suite and exits.  If run as such, this runs
     both the TVTK and Mayavi2 unittests.  If any additional arguments
     are passed they are passed along to the test runner.  So this may
     be used to run other tests as well.  For example::

        mayavi2 -t apptools.persistence

     This will run just the tests inside the apptools.persistence
     package.  You can also specify a directory with test files to run
     with this, for example::

        mayavi2 -t relative_path_to/integrationtests/mayavi

     will run the integration tests from the mayavi sources.

-v
--verbose

     Prints verbose logs on the console.

-V
--version

     Prints the Mayavi version.

-h
--help

     Prints this help message.

Examples::

     mayavi2 test.mv2 (or mayavi2 -z test.mv2)

     mayavi2 test.py (or mayavi2 -x test.py)

     mayavi2 test.mv2 other.mv2 (or mayavi2 -z test.mv2 -z other.mv2)

     mayavi2 -d test.vtk -m Axes -m GridPlane \\
     -f Threshold -m IsoSurface \\
     -n -d heart.vtk -m Outline -m ContourGridPlane
"""
    return msg


def parse_cmd_line(arguments):
    """Returns the options and arguments parsed via getopts.

    Due to the special needs (order of args is important and repeated
    options will be supplied) of this command line parser we must use
    getopts and not optparse.

    Input Arguments:
      arguments -- This can be either a list of arguments as in
                   sys.argv[1:] or a string that is similar to the one
                   passed on the command line.  If it is a string the
                   string is split to create a list of arguments.
    """
    if type(arguments) in types.StringTypes:
        arguments = arguments.split()

    options = "d:m:f:z:x:s:nMvo"

    long_opts = ['data=',
                 'module=', 'filter=',
                 'visualization=', 'viz=',
                 'exec=',
                 'set=',
                 'verbose',
                 'module-mgr', 'new-scene', 'offscreen']

    try:
        opts, args = getopt.getopt (arguments, options, long_opts)
    except getopt.error, msg:
        print msg
        print usage ()
        print '-'*70
        print msg
        sys.exit (1)

    return opts, args


def _get_non_file_sources():
    """Returns a dict indexed on the name of non-file related sources
    ids with the value being the corresponding metadata object.
    """
    from mayavi.core.registry import registry
    data = {}
    for src in registry.sources:
        if len(src.extensions) == 0:
            name = src.id[:-6]
            data[name] = src
    return data


def process_cmd_line(app, opts, args):
    """ Processes the passed command line arguments.

    Input Arguments:
      app -- A Mayavi application instance.

      opts -- The list of options returned by getopt.

      args -- The remaining arguments returned by getopt.
    """

    from mayavi.core.common import error, exception
    from tvtk.common import camel2enthought

    sources = _get_non_file_sources()
    script = app.script
    last_obj = None

    # Start a new scene by default if there is none currently and none
    # was specified at the start of the command line arguments.
    if script.engine.current_scene is None:
        new_scene = False
        if len(opts) == 0:
            if len(args) == 0:
                new_scene = True
        elif (opts[0][0] not in ('-n', '--new-scene', '-z',
                                 '--visualization', '--viz',
                                 '-x', '--exec')):
            new_scene = True
        if new_scene:
            last_obj = script.new_scene()

    for o, a in opts:
        if o in ('-d', '--data'):
            base, ext = splitext(a)
            if exists(a):
                last_obj = script.open(a)
            elif a in sources:
                md = sources[a]
                src = md.get_callable()()
                script.add_source(src)
                last_obj = src
            else:
                error("File/Source %s does not exist!"%a)
                return

        if o in ('-m', '--module'):
            if '.' in a:
                idx = a.rfind('.')
                modname = a[:idx]
                classname = a[idx+1:]
            else:
                modname = 'mayavi.modules.%s'%camel2enthought(a)
                classname = a
            try:
                mod = __import__(modname, globals(), locals(), [classname])
            except ImportError, msg:
                exception(str(msg))
                return
            else:
                m = getattr(mod, classname)()
                if classname == 'Labels':
                    m.object = script.engine.current_object
                script.add_module(m)
                last_obj = m

        if o in ('-f', '--filter'):
            if '.' in a:
                idx = a.rfind('.')
                modname = a[:idx]
                classname = a[idx+1:]
            else:
                if a[:12] == 'UserDefined:':
                    modname = 'mayavi.filters.user_defined'
                    classname = 'UserDefined'
                    # Create the wrapped filter.
                    fname = a[12:]
                    from tvtk.api import tvtk
                    try:
                        extra = getattr(tvtk, fname)()
                    except (AttributeError, TypeError):
                        # Don't worry about errors.
                        extra = None
                else:
                    modname = 'mayavi.filters.%s'%camel2enthought(a)
                    classname = a
                    extra = None
            try:
                mod = __import__(modname, globals(), locals(), [classname])
            except ImportError, msg:
                exception(str(msg))
                return
            else:
                klass = getattr(mod, classname)
                if classname != 'UserDefined':
                    f = klass()
                else:
                    if extra is not None:
                        f = klass(filter=extra)
                    else:
                        f = klass()
                    f.setup_filter()
                script.add_filter(f)
                last_obj = f

        if o in ('-M', '--module-mgr'):
            from mayavi.core.module_manager \
                 import ModuleManager
            mm = ModuleManager()
            script.add_filter(mm)
            last_obj = mm

        if o in ('-n', '--new-scene'):
            script.new_scene()
            e = script.engine
            s = e.scenes[-1]
            e.set(current_scene=s, current_object=s)
            last_obj = s

        if o in ('-x', '--exec' ):
            err = run_script(script, a)
            if err: # stop processing options.
                return

        if o in ('-s', '--set'):
            try:
                stmt = 'last_obj.' + a
                exec stmt in locals(), globals()
            except Exception, msg:
                exception(str(msg))

        if o in ('-z', '--visualization', '--viz'):
            script.load_visualization(a)

    # for remaining arguments simply load saved visualizations.
    for arg in args:
        base, ext = splitext (arg)
        if ext == '.mv2':
            script.load_visualization(arg)
        elif ext == '.py':
            err = run_script(script, arg)
            if err: # stop processing arguments.
                return
        else:
            script.open(arg)


def run_script(mayavi, script_name):
    """Execfiles a given script.  The name `mayavi` is bound to the
    mayavi script instance just like in the embedded interpreter.
    `script_name` is the name of the script to execute.

    Note that this function uses `execfile`. You should be careful
    when using this.

    It returns `False` if everything was OK and `True` if not.
    """
    from mayavi.core.common import exception

    g = sys.modules['__main__'].__dict__
    if 'mayavi' not in g:
        g['mayavi'] = mayavi
        g['engine'] = mayavi.engine
    error = False
    # Do execfile
    try:
        # If we don't pass globals twice we get NameErrors and nope,
        # using exec open(script_name).read() does not fix it.
        execfile(script_name, g, g)
    except Exception, msg:
        exception(str(msg))
        error = True

    return error

# This runs the runtests script and sends any args to it.
if ('-t' in sys.argv[1:]) or ('--test' in sys.argv[1:]):
    from mayavi.tests import runtests
    for arg in ('-t', '--test'):
        if arg in sys.argv[1:]:
            sys.argv.remove(arg)
    runtests.main()

# If the user just wants help messages.  Print them before importing
# any of the big modules.
if ('-h' in sys.argv[1:]) or ('--help' in sys.argv[1:]):
    print usage()
    sys.exit(0)

if ('-V' in sys.argv[1:]) or ('--version' in sys.argv[1:]):
    print 'Mayavi %s'%__version__
    sys.exit(0)

for opt, arg in parse_cmd_line(sys.argv[1:])[0]:
    if opt in ('-o', '--offscreen'):
        OFFSCREEN = True
        break
# Create opt and arg to be able to delete them even if the previous loop
# is empty.
opt, arg = None, None
del opt, arg


# The vtk module is imported by the engine, so mayavi is never going to
# start without it. Let us capture the error early, and give a meaningful
# error message
try:
    import vtk
except ImportError, m:
    msg = '%s\n%s\nDo you have vtk installed properly?\n' \
        'VTK (and build instructions) can be obtained from http://www.vtk.org\n' \
        % (m, '_'*80)
    raise ImportError(msg)

# Try forcing the use of wx 2.8 before any other import.
import sys
if not 'wx' in sys.modules:
    try:
        # Try forcing the use of wx 2.8
        from traits.etsconfig.api import ETSConfig
        if ETSConfig.toolkit in ('wx', ''):
            import wxversion
            wxversion.ensureMinimal('2.8')
    except ImportError:
        """ wxversion not installed """


# Importing here to avoid time-consuming import when user only wanted
# version/help information.
try:
    from mayavi.plugins.app import Mayavi, setup_logger
except ImportError, m:
    msg = '''%s
%s
Could not load envisage. You might have a missing dependency.
Do you have the EnvisageCore and EnvisagePlugins installed?

If you installed Mayavi with easy_install, try 'easy_install <pkg_name>'.
'easy_install Mayavi[app]' will also work.

If you performed a source checkout and installed via 'python setup.py develop',
be sure to run the same command in the EnvisageCore and EnvisagePlugins folders.

If these packages appear to be installed, check that your numpy and
configobj are installed and working. If you need numpy, 'easy_install numpy'
will install numpy. Similarly, 'easy_install configobj' will install
configobj.
        ''' % (m, '_'*80)
    raise ImportError(msg)



##########################################################################
# `MayaviApp` class
##########################################################################
class MayaviApp(Mayavi):
    def parse_command_line(self, argv):
        """Parse command line options."""
        # Parse and store command line options to process once app has
        # started in `run`.
        options, args = parse_cmd_line(argv)
        self.cmd_line_opts = (options, args)
        # If the verbose option is set, change the log mode.
        for opts, args in options:
            if opts in ('-v', '--verbose'):
                self.log_mode = logging.DEBUG
                break

    def run(self):
        """Process the command line options and setup mayavi as per
        the users needs.
        """
        options, args = self.cmd_line_opts
        # Process the options.
        process_cmd_line(self, options, args)


################################################################################
# `MayaviOffscreen` class.
################################################################################
class MayaviOffscreen(MayaviApp):
    """
    The mayavi application used for offscreen rendering.
    """

    def _script_default(self):
        from mayavi.plugins.script import Script
        from mayavi.core.off_screen_engine import OffScreenEngine
        engine = OffScreenEngine()
        engine.start()
        s = Script(engine=engine)
        return s

    def setup_logger(self):
        from traits.etsconfig.api import ETSConfig
        path = join(ETSConfig.application_data,
                    'mayavi_e3', 'mayavi.log')
        path = abspath(path)
        logger = logging.getLogger()
        setup_logger(logger, path, mode=self.log_mode)

    def main(self, argv=None):
        if argv is None:
            argv = []

        self.parse_command_line(argv)
        self.setup_logger()
        self.run()


##########################################################################
# Helper functions
##########################################################################
def get_mayavi_script_instance():
    """Return the mayavi Script instance from the first available set of
    envisage engines registered in the registry.
    """
    from mayavi.core.registry import registry
    from mayavi.plugins.envisage_engine import EnvisageEngine
    from mayavi.plugins.script import Script
    for name, engine in registry.engines.iteritems():
        if isinstance(engine, EnvisageEngine):
            return engine.window.get_service(Script)
    return

def contains_mayavi(namespace):
    """Returns if the given namespace contains a 'mayavi' name bound to
    a mayavi script instance.
    """
    from mayavi.plugins.script import Script
    if 'mayavi' in namespace:
        if isinstance(namespace.get('mayavi'), Script):
            return True
    return False

def standalone(func):
    """A decorator to run a function from within mayavi.  This lets
    users write a normal Python function and have that run from within
    mayavi.  It implicitly assumes that the name 'mayavi' refers the the
    Script instance and will overwrite it if not.
    """
    def wrapper(*args, **kw):
        script = get_mayavi_script_instance()
        if script is None and mayavi is not None:
            script = mayavi.script
        if script is None:
            def caller(script):
                """Callback that runs the function inside the mayavi
                app."""
                # Bind the 'mayavi' name to the script instance
                func.func_globals['mayavi'] = script
                # Run the function in the event loop.
                g = script.window.application.gui
                g.invoke_later(func, *args, **kw)

            # Start up mayavi and invoke caller when the script instance
            # is available.
            m = Mayavi()
            m.on_trait_change(caller, 'script')
            # Run the mayavi app.
            m.main()
        else:
            ns = func.func_globals
            if not contains_mayavi(ns):
                # Bind the 'mayavi' name to the script instance
                ns['mayavi'] = script
            # Now run the function.
            func(*args, **kw)

    return wrapper


def main():
    """This starts up the mayavi2 application.
    """
    global mayavi

    # Make sure '.' is in sys.path
    if '' not in sys.path:
        sys.path.insert(0, '')
    # Start the app.
    if OFFSCREEN:
        mayavi = MayaviOffscreen()
    else:
        from traits.etsconfig.api import ETSConfig
        # Check that we have a traits backend installed
        from traitsui.toolkit import toolkit
        toolkit() # This forces the selection of a toolkit.
        if ETSConfig.toolkit in ('null', ''):
            raise ImportError, '''Could not import backend for traits
________________________________________________________________________________
Make sure that you have either the TraitsBackendWx or the TraitsBackendQt
projects installed. If you installed Mayavi with easy_install, try easy_install
<pkg_name>. easy_install Mayavi[app] will also work.

If you performed a source checkout, be sure to run 'python setup.py install'
in Traits, TraitsGUI, and the Traits backend of your choice.

Also make sure that either wxPython or PyQT is installed.
wxPython: http://www.wxpython.org/
PyQT: http://www.riverbankcomputing.co.uk/software/pyqt/intro
'''

        mayavi = MayaviApp()
    mayavi.main(sys.argv[1:])

def close():
    """ This closes the mayavi2 application.
    """
    if mayavi is not None and not OFFSCREEN:
        mayavi.window.close()

if __name__ == '__main__':
    main()

########NEW FILE########
__FILENAME__ = util
""" This module collects utility code that does not import any
significant envisage/mayavi code but is useful for scripts that use
mayavi.
"""
# Author: Prabhu Ramachandran <prabhu@aero.iitb.ac.in>
# Copyright (c) 2008, Enthought, Inc.
# License: BSD Style.

import sys
from os.path import join, abspath, dirname, isdir

def get_data_dir( example_filename ):
    """ Get the data directory while running an example script.

        Parameters:
        -----------
        example_filename: Path
            absolute path of the example script

    """

    if 'mayavi2' in sys.argv[0]:
        if isdir('data'):
            return 'data'
        filename = sys.argv[-1]
        dir_name = join(dirname(abspath(filename)), 'data')
        if isdir(dir_name):
            return dir_name

        raise Exception('Run example from the example directory')

    else:
        return join(dirname(example_filename), 'data')



########NEW FILE########
__FILENAME__ = api
""" Defines the publicly accessible MayaVi2 sources.
"""

# Author: Frederic Petit, Prabhu Ramachandran
# Copyright (c) 2007-2008, Enthought, Inc.
# License: BSD Style.


from array_source import ArraySource
from builtin_image import BuiltinImage
from builtin_surface import BuiltinSurface
from chaco_reader import ChacoReader
from image_reader import ImageReader
from parametric_surface import ParametricSurface
from plot3d_reader import PLOT3DReader
from point_load import PointLoad
from poly_data_reader import PolyDataReader
from three_ds_importer import ThreeDSImporter
from vrml_importer import VRMLImporter
from volume_reader import VolumeReader
from vtk_data_source import VTKDataSource
from vtk_file_reader import VTKFileReader
from vtk_xml_file_reader import VTKXMLFileReader
from unstructured_grid_reader import UnstructuredGridReader


########NEW FILE########
__FILENAME__ = array_source
"""A simple source that allows one to view a suitably shaped numpy
array as ImageData.  This supports both scalar and vector data.
"""
# Author: Prabhu Ramachandran <prabhu_r@users.sf.net>
# Copyright (c) 2005, Enthought, Inc.
# License: BSD Style.

# Standard library imports.
import numpy
from vtk.util import vtkConstants

# Enthought library imports
from traits.api import Instance, Trait, Str, Bool, Button, DelegatesTo
from traitsui.api import View, Group, Item
from tvtk.api import tvtk
from tvtk import array_handler
from tvtk.common import is_old_pipeline

# Local imports
from mayavi.core.source import Source
from mayavi.core.pipeline_info import PipelineInfo

def _check_scalar_array(obj, name, value):
    """Validates a scalar array passed to the object."""
    if value is None:
        return None
    arr = numpy.asarray(value)
    assert len(arr.shape) in [2,3], "Scalar array must be 2 or 3 dimensional"
    vd = obj.vector_data
    if vd is not None:
        assert vd.shape[:-1] == arr.shape, \
               "Scalar array must match already set vector data.\n"\
               "vector_data.shape = %s, given array shape = %s"%(vd.shape,
                                                                 arr.shape)
    return arr

_check_scalar_array.info = 'a 2D or 3D numpy array'

def _check_vector_array(obj, name, value):
    """Validates a vector array passed to the object."""
    if value is None:
        return None
    arr = numpy.asarray(value)
    assert len(arr.shape) in [3,4], "Vector array must be 3 or 4 dimensional"
    assert arr.shape[-1] == 3, \
           "The vectors must be three dimensional with `array.shape[-1] == 3`"
    sd = obj.scalar_data
    if sd is not None:
        assert arr.shape[:-1] == sd.shape, \
               "Vector array must match already set scalar data.\n"\
               "scalar_data.shape = %s, given array shape = %s"%(sd.shape,
                                                                 arr.shape)
    return arr

_check_vector_array.info = 'a 3D or 4D numpy array with shape[-1] = 3'


######################################################################
# 'ArraySource' class.
######################################################################
class ArraySource(Source):

    """A simple source that allows one to view a suitably shaped numpy
    array as ImageData.  This supports both scalar and vector data.
    """

    # The scalar array data we manage.
    scalar_data = Trait(None, _check_scalar_array, rich_compare=False)

    # The name of our scalar array.
    scalar_name = Str('scalar')

    # The vector array data we manage.
    vector_data = Trait(None, _check_vector_array, rich_compare=False)

    # The name of our vector array.
    vector_name = Str('vector')

    # The spacing of the points in the array.
    spacing = DelegatesTo('change_information_filter', 'output_spacing',
                          desc='the spacing between points in array')

    # The origin of the points in the array.
    origin = DelegatesTo('change_information_filter', 'output_origin',
                         desc='the origin of the points in array')

    # Fire an event to update the spacing and origin. This
    # is here for backwards compatability. Firing this is no
    # longer needed.
    update_image_data = Button('Update spacing and origin')

    # The image data stored by this instance.
    image_data = Instance(tvtk.ImageData, (), allow_none=False)

    # Use an ImageChangeInformation filter to reliably set the
    # spacing and origin on the output
    change_information_filter = Instance(tvtk.ImageChangeInformation, args=(),
                                         kw={'output_spacing' : (1.0, 1.0, 1.0),
                                             'output_origin' : (0.0, 0.0, 0.0)})

    # Should we transpose the input data or not.  Transposing is
    # necessary to make the numpy array compatible with the way VTK
    # needs it.  However, transposing numpy arrays makes them
    # non-contiguous where the data is copied by VTK.  Thus, when the
    # user explicitly requests that transpose_input_array is false
    # then we assume that the array has already been suitably
    # formatted by the user.
    transpose_input_array = Bool(True, desc='if input array should be transposed (if on VTK will copy the input data)')

    # Information about what this object can produce.
    output_info = PipelineInfo(datasets=['image_data'])

    # Our view.
    view = View(Group(Item(name='transpose_input_array'),
                      Item(name='scalar_name'),
                      Item(name='vector_name'),
                      Item(name='spacing'),
                      Item(name='origin'),
                      show_labels=True)
                )

    ######################################################################
    # `object` interface.
    ######################################################################
    def __init__(self, **traits):
        # Set the scalar and vector data at the end so we pop it here.
        sd = traits.pop('scalar_data', None)
        vd = traits.pop('vector_data', None)
        # Now set the other traits.
        super(ArraySource, self).__init__(**traits)
        self.configure_input_data(self.change_information_filter,
                                  self.image_data)

        # And finally set the scalar and vector data.
        if sd is not None:
            self.scalar_data = sd
        if vd is not None:
            self.vector_data = vd

        self.outputs = [ self.change_information_filter.output ]
        self.on_trait_change(self._information_changed, 'spacing,origin')

    def __get_pure_state__(self):
        d = super(ArraySource, self).__get_pure_state__()
        d.pop('image_data', None)
        return d

    ######################################################################
    # ArraySource interface.
    ######################################################################
    def update(self):
        """Call this function when you change the array data
        in-place."""
        d = self.image_data
        d.modified()
        pd = d.point_data
        if self.scalar_data is not None:
            pd.scalars.modified()
        if self.vector_data is not None:
            pd.vectors.modified()
        self.change_information_filter.update()
        self.data_changed = True

    ######################################################################
    # Non-public interface.
    ######################################################################

    def _image_data_changed(self, value):
        self.configure_input_data(self.change_information_filter, value)

    def _scalar_data_changed(self, data):
        img_data = self.image_data
        if data is None:
            img_data.point_data.scalars = None
            self.data_changed = True
            return
        dims = list(data.shape)
        if len(dims) == 2:
            dims.append(1)

        img_data.origin = tuple(self.origin)
        img_data.dimensions = tuple(dims)
        img_data.extent = 0, dims[0]-1, 0, dims[1]-1, 0, dims[2]-1
        if is_old_pipeline():
            img_data.update_extent = 0, dims[0]-1, 0, dims[1]-1, 0, dims[2]-1
        else:
            update_extent = [0, dims[0]-1, 0, dims[1]-1, 0, dims[2]-1]
            self.change_information_filter.set_update_extent(update_extent)
        if self.transpose_input_array:
            img_data.point_data.scalars = numpy.ravel(numpy.transpose(data))
        else:
            img_data.point_data.scalars = numpy.ravel(data)
        img_data.point_data.scalars.name = self.scalar_name
        # This is very important and if not done can lead to a segfault!
        typecode = data.dtype
        if is_old_pipeline():
            img_data.scalar_type = array_handler.get_vtk_array_type(typecode)
            img_data.update() # This sets up the extents correctly.
        else:
            filter_out_info = self.change_information_filter.get_output_information(0)
            img_data.set_point_data_active_scalar_info(filter_out_info,
                    array_handler.get_vtk_array_type(typecode), -1)
            img_data.modified()
        img_data.update_traits()
        self.change_information_filter.update()

        # Now flush the mayavi pipeline.
        self.data_changed = True

    def _vector_data_changed(self, data):
        img_data = self.image_data
        if data is None:
            img_data.point_data.vectors = None
            self.data_changed = True
            return
        dims = list(data.shape)
        if len(dims) == 3:
            dims.insert(2, 1)
            data = numpy.reshape(data, dims)

        img_data.origin = tuple(self.origin)
        img_data.dimensions = tuple(dims[:-1])
        img_data.extent = 0, dims[0]-1, 0, dims[1]-1, 0, dims[2]-1
        if is_old_pipeline():
            img_data.update_extent = 0, dims[0]-1, 0, dims[1]-1, 0, dims[2]-1
        else:
            self.change_information_filter.update_information()
            update_extent = [0, dims[0]-1, 0, dims[1]-1, 0, dims[2]-1]
            self.change_information_filter.set_update_extent(update_extent)
        sz = numpy.size(data)
        if self.transpose_input_array:
            data_t = numpy.transpose(data, (2, 1, 0, 3))
        else:
            data_t = data
        img_data.point_data.vectors = numpy.reshape(data_t, (sz/3, 3))
        img_data.point_data.vectors.name = self.vector_name
        if is_old_pipeline():
            img_data.update() # This sets up the extents correctly.
        else:
            img_data.modified()
        img_data.update_traits()
        self.change_information_filter.update()

        # Now flush the mayavi pipeline.
        self.data_changed = True

    def _scalar_name_changed(self, value):
        if self.scalar_data is not None:
            self.image_data.point_data.scalars.name = value
            self.data_changed = True

    def _vector_name_changed(self, value):
        if self.vector_data is not None:
            self.image_data.point_data.vectors.name = value
            self.data_changed = True

    def _transpose_input_array_changed(self, value):
        if self.scalar_data is not None:
            self._scalar_data_changed(self.scalar_data)
        if self.vector_data is not None:
            self._vector_data_changed(self.vector_data)

    def _information_changed(self):
        self.change_information_filter.update()
        self.data_changed = True

########NEW FILE########
__FILENAME__ = builtin_image
"""
A module that offers lots of VTK image data sources
"""
#Author: Suyog Dutt Jain <suyog.jain@aero.iitb.ac.in>
#        Prabhu Ramachandran <prabhu_r@users.sf.net>
# Copyright (c) 2008,  Enthought, Inc.
# License: BSD Style.

# Enthought library imports.
from traits.api import Instance, Enum, Dict, Str
from traitsui.api import View, Item, Group
from tvtk.api import tvtk

# Local imports
from mayavi.core.source import Source
from mayavi.core.pipeline_info import PipelineInfo


######################################################################
# `BuiltinImage` class.
######################################################################
class BuiltinImage(Source):
    # The version of this class.  Used for persistence.
    __version__ = 0

    # Flag to set the image data type.
    source = Enum('ellipsoid','gaussian','grid','mandelbrot','noise',
                  'sinusoid','rt_analytic',
                  desc='which image data source to be used')

    # Define the trait 'data_source' whose value must be an instance of
    # type ImageAlgorithm
    data_source = Instance(tvtk.ImageAlgorithm, allow_none=False,
                                     record=True)


    # Information about what this object can produce.
    output_info = PipelineInfo(datasets=['image_data'],
                               attribute_types=['any'],
                               attributes=['any'])

    # Create the UI for the traits.
    view = View(Group(Item(name='source'),
                  Item(name='data_source',
                       style='custom',
                       resizable=True),
                   label='Image Source',
                    show_labels=False),
             resizable=True)

    ########################################
    # Private traits.

    # A dictionary that maps the source names to instances of the
    # image data objects.
    _source_dict = Dict(Str,
                          Instance(tvtk.ImageAlgorithm,
                                   allow_none=False))

    ######################################################################
    # `object` interface
    ######################################################################
    def __init__(self, **traits):
        # Call parent class' init.
        super(BuiltinImage, self).__init__(**traits)

        # Initialize the source to the default mode's instance from
        # the dictionary if needed.
        if 'source' not in traits:
            self._source_changed(self.source)

    def __set_pure_state__(self, state):
        self.source = state.source
        super(BuiltinImage, self).__set_pure_state__(state)

    def has_output_port(self):
        """ Return True as the data source has output port."""
        return True

    def get_output_object(self):
        """ Return the data source output port."""
        return self.data_source.output_port

    ######################################################################
    # Non-public methods.
    ######################################################################
    def _source_changed(self, value):
        """This method is invoked (automatically) when the `function`
        trait is changed.
        """
        self.data_source = self._source_dict[self.source]


    def _data_source_changed(self, old, new):
        """This method is invoked (automatically) when the
        image data source is changed ."""

        self.outputs = [self.data_source.output]

        if old is not None:
            old.on_trait_change(self.render, remove=True)
        new.on_trait_change(self.render)

    def __source_dict_default(self):
        """The default _source_dict trait."""
        sd = {
              'ellipsoid':tvtk.ImageEllipsoidSource(),
              'gaussian':tvtk.ImageGaussianSource(),
              'grid':tvtk.ImageGridSource(),
              'mandelbrot':tvtk.ImageMandelbrotSource(),
              'noise':tvtk.ImageNoiseSource(),
              'sinusoid':tvtk.ImageSinusoidSource(),
             }
        if hasattr(tvtk, 'RTAnalyticSource'):
            sd['rt_analytic'] = tvtk.RTAnalyticSource()
        else:
            sd['rt_analytic'] = tvtk.ImageNoiseSource()
        return sd




########NEW FILE########
__FILENAME__ = builtin_surface
""" A module that allows a user to create one of several standard VTK
poly data sources.
"""

#Author: Suyog Dutt Jain <suyog.jain@aero.iitb.ac.in>
#        Prabhu Ramachandran <prabhu_r@users.sf.net>
# Copyright (c) 2008,  Enthought, Inc.
# License: BSD Style.

# Enthought library imports.
from traits.api import Instance, Enum, Dict, Str
from traitsui.api import View, Item, Group
from tvtk.api import tvtk

# Local imports
from mayavi.core.source import Source
from mayavi.core.pipeline_info import PipelineInfo


######################################################################
# `BuiltinSurface` class.
######################################################################
class BuiltinSurface(Source):
    # The version of this class.  Used for persistence.
    __version__ = 0

    # Flag to set the poly data type.
    source = Enum('arrow','cone','cube','cylinder','disk','earth','line',
                  'outline','plane','point', 'polygon','sphere',
                  'superquadric','textured sphere', 'glyph2d',
                  desc='which poly data source to be used')

    # Define the trait 'data_source' whose value must be an instance of
    # type PolyData
    data_source = Instance(tvtk.PolyDataAlgorithm, allow_none=False,
                                    record=True)

    # Information about what this object can produce.
    output_info = PipelineInfo(datasets=['poly_data'],
                               attribute_types=['any'],
                               attributes=['any'])

    # Create the UI for the traits.
    view = View(Group(Item(name='source'),
                  Item(name='data_source',
                       style='custom',
                       resizable=True),
                   label='Surface Source',
                    show_labels=False),
             resizable=True)


    ########################################
    # Private traits.

    # A dictionary that maps the source names to instances of the
    # poly data sources.
    _source_dict = Dict(Str,
                          Instance(tvtk.PolyDataAlgorithm,
                                   allow_none=False))

    ######################################################################
    # `object` interface
    ######################################################################
    def __init__(self, **traits):
        # Call parent class' init.
        super(BuiltinSurface, self).__init__(**traits)

        # Initialize the source to the default mode's instance from
        # the dictionary if needed.
        if 'source' not in traits:
            self._source_changed(self.source)

    def __set_pure_state__(self, state):
        self.source = state.source
        super(BuiltinSurface, self).__set_pure_state__(state)

    def has_output_port(self):
        """ Return True as the data source has output port."""
        return True

    def get_output_object(self):
        """ Return the data source output port."""
        return self.data_source.output_port

    ######################################################################
    # Non-public methods.
    ######################################################################
    def _source_changed(self, value):
        """This method is invoked (automatically) when the `source`
        trait is changed.
        """
        self.data_source = self._source_dict[self.source]


    def _data_source_changed(self, old, new):
        """This method is invoked (automatically) when the
        poly data source is changed ."""

        self.outputs = [self.data_source.output]

        if old is not None:
            old.on_trait_change(self.render, remove=True)
        new.on_trait_change(self.render)

    def __source_dict_default(self):
        """Default value for source dict."""
        sd = {'arrow':tvtk.ArrowSource(),
              'cone':tvtk.ConeSource(),
              'cube':tvtk.CubeSource(),
              'cylinder':tvtk.CylinderSource(),
              'disk':tvtk.DiskSource(),
              'earth':tvtk.EarthSource(),
              'line':tvtk.LineSource(),
              'outline':tvtk.OutlineSource(),
              'plane':tvtk.PlaneSource(),
              'point':tvtk.PointSource(),
              'polygon':tvtk.RegularPolygonSource(),
              'sphere':tvtk.SphereSource(),
              'superquadric':tvtk.SuperquadricSource(),
              'textured sphere':tvtk.TexturedSphereSource(),
              'glyph2d': tvtk.GlyphSource2D()}
        return sd


########NEW FILE########
__FILENAME__ = chaco_reader
"""A Chaco file reader.
"""
# Author: Suyog Dutt Jain <suyog.jain@aero.iitb.ac.in>
# Copyright (c) 2009, Enthought, Inc.
# License: BSD Style.

# Enthought library imports.
from traits.api import Instance, Str
from traitsui.api import View, Group, Item
from tvtk.api import tvtk

# Local imports.
from mayavi.core.source import Source
from mayavi.core.pipeline_info import PipelineInfo

########################################################################
# `ChacoReader` class
########################################################################
class ChacoReader(Source):

    """A Chaco reader.
    """

    # The version of this class.  Used for persistence.
    __version__ = 0

    base_name = Str('', desc='basename of the Chaco files')

    # The VTK data file reader.
    reader = Instance(tvtk.ChacoReader, args=(), allow_none=False,
                      record=True)

    # Information about what this object can produce.
    output_info = PipelineInfo(datasets=['unstructured_grid'])

    ########################################
    # View related code.
    # Our view.
    view = View(Group(Item(name='reader', style='custom',
                           resizable=True),
                      show_labels=False),
                resizable=True)

    ######################################################################
    # `FileDataSource` interface
    ######################################################################
    def __init__(self, base_name='', configure=True, **traits):
        super(ChacoReader, self).__init__(**traits)
        if configure:
            self.reader.edit_traits(kind='livemodal')
        self.base_name = self.reader.base_name

    def update(self):
        if len(self.base_name) == 0:
            return
        self.reader.update()
        self.render()

    def has_output_port(self):
        """ Return True as the reader has output port."""
        return True

    def get_output_object(self):
        """ Return the reader output port."""
        return self.reader.output_port

    ######################################################################
    # Non-public interface
    ######################################################################
    def _base_name_changed(self, value):
        if len(value) == 0:
            return
        else:
            self.reader.base_name = value
            self._update_reader_output()

    def _update_reader_output(self):
        self.reader.update()
        self.reader.update_information()
        self.reader.on_trait_change(self.render)
        self.outputs = [self.reader.output]
        self.data_changed = True

########NEW FILE########
__FILENAME__ = image_reader
"""An Image file reader object.

"""
# Author:  KK Rai (kk.rai [at] iitb.ac.in)
#          R. Ambareesha (ambareesha [at] iitb.ac.in)
#          Chandrashekhar Kaushik
#          Suyog Dutt Jain <suyog.jain [at] aero.iitb.ac.in>
#          Prabhu Ramachandran <prabhu [at] aero.iitb.ac.in>
# Copyright (c) 2007, Enthought, Inc.
# License: BSD Style.

from os.path import basename

# Enthought library imports.
from traits.api import Instance, Str, Dict
from traitsui.api import View, Group, Item, Include
from tvtk.api import tvtk

# Local imports.
from mayavi.core.file_data_source import FileDataSource
from mayavi.core.pipeline_info import PipelineInfo


########################################################################
# `ImageReader` class
########################################################################
class ImageReader(FileDataSource):

    """A Image file reader. The reader supports all the
    different types of Image files.
    """

    # The version of this class.  Used for persistence.
    __version__ = 0

    # The Image data file reader.
    reader = Instance(tvtk.Object, allow_none=False, record=True)

    # Information about what this object can produce.
    output_info = PipelineInfo(datasets=['image_data'])

    # Our view.
    view = View(Group(Include('time_step_group'),
                      Item(name='base_file_name'),
                      Item(name='reader',
                           style='custom',
                           resizable=True),
                      show_labels=False),
                resizable=True)

    ######################################################################
    # Private Traits
    _image_reader_dict = Dict(Str, Instance(tvtk.Object))

    ######################################################################
    # `object` interface
    ######################################################################
    def __init__(self, **traits):
        d = {'bmp':tvtk.BMPReader(),
             'jpg':tvtk.JPEGReader(),
             'png':tvtk.PNGReader(),
             'pnm':tvtk.PNMReader(),
             'dcm':tvtk.DICOMImageReader(),
             'tiff':tvtk.TIFFReader(),
             'ximg':tvtk.GESignaReader(),
             'dem':tvtk.DEMReader(),
             'mha':tvtk.MetaImageReader(),
             'mhd':tvtk.MetaImageReader(),
            }
        # Account for pre 5.2 VTk versions, without MINC reader
        if hasattr(tvtk, 'MINCImageReader'):
            d['mnc'] = tvtk.MINCImageReader()
        d['jpeg'] = d['jpg']
        self._image_reader_dict = d
        # Call parent class' init.
        super(ImageReader, self).__init__(**traits)

    def __set_pure_state__(self, state):
        # The reader has its own file_name which needs to be fixed.
        state.reader.file_name = state.file_path.abs_pth
        # Now call the parent class to setup everything.
        super(ImageReader, self).__set_pure_state__(state)

    ######################################################################
    # `FileDataSource` interface
    ######################################################################
    def update(self):
        self.reader.update()
        if len(self.file_path.get()) == 0:
            return
        self.render()

    def has_output_port(self):
        """ Return True as the reader has output port."""
        return True

    def get_output_object(self):
        """ Return the reader output port."""
        return self.reader.output_port

    ######################################################################
    # Non-public interface
    ######################################################################
    def _file_path_changed(self, fpath):
        value = fpath.get()
        if len(value) == 0:
            return
        # Extract the file extension
        splitname = value.strip().split('.')
        extension = splitname[-1].lower()
        # Select image reader based on file type
        old_reader = self.reader
        if self._image_reader_dict.has_key(extension):
            self.reader = self._image_reader_dict[extension]
        else:
            self.reader = tvtk.ImageReader()

        self.reader.file_name = value.strip()
        self.reader.update()
        self.reader.update_information()

        if old_reader is not None:
            old_reader.on_trait_change(self.render, remove=True)
        self.reader.on_trait_change(self.render)

        self.outputs = [self.reader.output]

        # Change our name on the tree view
        self.name = self._get_name()

    def _get_name(self):
        """ Returns the name to display on the tree view.  Note that
        this is not a property getter.
        """
        fname = basename(self.file_path.get())
        ret = "%s"%fname
        if len(self.file_list) > 1:
            ret += " (timeseries)"
        if '[Hidden]' in self.name:
            ret += ' [Hidden]'

        return ret


########NEW FILE########
__FILENAME__ = metadata
"""
Metadata for all sources.
"""
# Author: Prabhu Ramachandran <prabhu@aero.iitb.ac.in>
# Copyright (c) 2008, Prabhu Ramachandran Enthought, Inc.
# License: BSD Style.

# Local imports.
from mayavi.core.metadata import SourceMetadata
from mayavi.core.pipeline_info import PipelineInfo

BASE = 'mayavi.sources'

open_3ds = SourceMetadata(
    id            = "3DSFile",
    class_name    = BASE + ".three_ds_importer.ThreeDSImporter",
    tooltip       = "Import a 3D Studio file",
    desc   = "Import a 3D Studio file",
    help   = "Import a 3D Studio file",
    menu_name        = "&3D Studio file",
    extensions = ['3ds'],
    wildcard = '3D Studio files (*.3ds)|*.3ds',
    output_info = PipelineInfo(datasets=['none'],
                               attribute_types=['any'],
                               attributes=['any'])
)

open_image = SourceMetadata(
    id            = "ImageFile",
    class_name    = BASE + ".image_reader.ImageReader",
    menu_name     = "&Image file (PNG/JPG/BMP/PNM/TIFF/DEM/DCM/XIMG/MHA/MHD/MINC)",
    tooltip       = "Import a PNG/JPG/BMP/PNM/TIFF/DCM/DEM/XIMG/MHA/MHD/MINC image",
    desc   = "Import a PNG/JPG/BMP/PNM/TIFF/DCM/DEM/XIMG/MHA/MHD/MINC image",
    extensions = ['png', 'jpg', 'jpeg', 'bmp', 'pnm', 'tiff', 'dcm', 'dem',
                  'ximg', 'mha', 'mhd', 'mnc'],
    wildcard = 'PNG files (*.png)|*.png|'\
               'JPEG files (*.jpg)|*.jpg|'\
               'JPEG files (*.jpeg)|*.jpeg|'\
               'BMP files (*.bmp)|*.bmp|'\
               'PNM files (*.pnm)|*.pnm|'\
               'DCM files (*.dcm)|*.dcm|'\
               'DEM files (*.dem)|*.dem|'\
               'Meta mha files (*.mha)|*.mha|'\
               'Meta mhd files (*.mhd)|*.mhd|'\
               'MINC files (*.mnc)|*.mnc|'\
               'XIMG files (*.ximg)|*.ximg|'\
               'TIFF files (*.tiff)|*.tiff',
    output_info = PipelineInfo(datasets=['image_data'],
                               attribute_types=['any'],
                               attributes=['any'])
)
open_poly_data = SourceMetadata(
    id            = "PolyDataFile",
    class_name    = BASE + ".poly_data_reader.PolyDataReader",
    menu_name     = "&PolyData file (STL/STLA/STLB/TXT/RAW/PLY/PDB/SLC/FACET\
                     /OBJ/BYU/XYZ/CUBE)",
    tooltip       = "Import a STL/STLA/STLB/TXT/RAW/PLY/PDB/SLC/FACET/OBJ/\
                     BYU/XYZ/CUBE Poly Data",
    desc   = "Import a STL/STLA/STLB/TXT/RAWPLY/PDB/SLC/FACET/OBJ/BYU/XYZ/\
              CUBE Poly Data",
    extensions = ['stl', 'stla', 'stlb', 'txt', 'raw', 'ply', 'pdb', 'slc',
                  'facet', 'xyz', 'cube', 'obj', 'g'],
    wildcard = 'STL files (*.stl)|*.stl|'\
               'STLA files (*.stla)|*.stla|'\
               'STLB files (*.stlb)|*.stlb|'\
               'BYU files (*.g)|*.g|'\
               'TXT files (*.txt)|*.txt|'\
               'RAW files (*.raw)|*.raw|'\
               'PLY files (*.ply)|*.ply|'\
               'PDB files (*.pdb)|*.pdb|'\
               'SLC files (*.slc)|*.slc|'\
               'XYZ files (*.xyz)|*.xyz|'\
               'CUBE files (*.cube)|*.cube|'\
               'FACET files (*.facet)|*.facet|'\
               'OBJ files (*.obj)|*.obj',
    can_read_test = 'mayavi.sources.poly_data_reader:PolyDataReader.can_read',
    output_info = PipelineInfo(datasets=['poly_data'],
                               attribute_types=['any'],
                               attributes=['any'])
)

open_ugrid_data = SourceMetadata(

    id            = "VTKUnstructuredFile",
    class_name    = BASE + ".unstructured_grid_reader.UnstructuredGridReader",
    menu_name     = "&Unstrucured Grid fil  (INP/NEU/EXII)",
    tooltip = "Open a Unstrucured Grid file",
    desc    = "Open a Unstrucured Grid file",
    help    = "Open a Unstrucured Grid file",
    extensions = ['inp', 'neu', 'exii'],
    wildcard = 'AVSUCD INP files (*.inp)|*.inp|'\
               'GAMBIT NEU (*.neu)|*.neu|'\
               'EXODUS EXII (*.exii)|*.exii',
    output_info = PipelineInfo(datasets=['any'],
                               attribute_types=['any'],
                               attributes=['any'])
)


open_plot3d = SourceMetadata(
    id            = "PLOT3DFile",
    class_name    = BASE + ".plot3d_reader.PLOT3DReader",
    menu_name     = "&PLOT3D file",
    tooltip       = "Open a PLOT3D data data",
    desc        = "Open a PLOT3D data data",
    help        = "Open a PLOT3D data data",
    extensions = ['xyz'],
    wildcard = 'PLOT3D files (*.xyz)|*.xyz',
    output_info = PipelineInfo(datasets=['structured_grid'],
                               attribute_types=['any'],
                               attributes=['any'])
)

open_vrml = SourceMetadata(
    id            = "VRMLFile",
    class_name    = BASE + ".vrml_importer.VRMLImporter",
    menu_name     = "V&RML2 file",
    tooltip = "Import a VRML2 data file",
    desc    = "Import a VRML2 data file",
    help    = "Import a VRML2 data file",
    extensions = ['wrl'],
    wildcard = 'VRML2 files (*.wrl)|*.wrl',
    output_info = PipelineInfo(datasets=['none'],
                               attribute_types=['any'],
                               attributes=['any'])
)

open_vtk = SourceMetadata(
    id            = "VTKFile",
    class_name    = BASE + ".vtk_file_reader.VTKFileReader",
    menu_name     = "&VTK file",
    tooltip = "Open a VTK data file",
    desc    = "Open a VTK data file",
    help    = "Open a VTK data file",
    extensions = ['vtk'],
    wildcard = 'VTK files (*.vtk)|*.vtk',
    output_info = PipelineInfo(datasets=['any'],
                               attribute_types=['any'],
                               attributes=['any'])
)

open_vtk_xml = SourceMetadata(
    id            = "VTKXMLFile",
    class_name    = BASE + ".vtk_xml_file_reader.VTKXMLFileReader",
    menu_name     = "VTK &XML file",
    tooltip = "Open a VTK XML data file",
    desc    = "Open a VTK XML data file",
    help    = "Open a VTK XML data file",
    extensions = ['xml', 'vti', 'vtp', 'vtr', 'vts', 'vtu',
                  'pvti', 'pvtp', 'pvtr', 'pvts', 'pvtu'],
    wildcard = 'VTK XML files (*.xml)|*.xml|'\
               'Image Data (*.vti)|*.vti|'\
               'Poly Data (*.vtp)|*.vtp|'\
               'Rectilinear Grid (*.vtr)|*.vtr|'\
               'Structured Grid (*.vts)|*.vts|'\
               'Unstructured Grid (*.vtu)|*.vtu|'\
               'Parallel Image Data (*.pvti)|*.pvti|'\
               'Parallel Poly Data (*.pvtp)|*.pvtp|'\
               'Parallel Rectilinear Grid (*.pvtr)|*.pvtr|'\
               'Parallel Structured Grid (*.pvts)|*.pvts|'\
               'Parallel Unstructured Grid (*.pvtu)|*.pvtu',
    output_info = PipelineInfo(datasets=['any'],
                               attribute_types=['any'],
                               attributes=['any'])
)

parametric_surface = SourceMetadata(
    id            = "ParametricSurfaceSource",
    class_name    = BASE + ".parametric_surface.ParametricSurface",
    menu_name     = "&Create Parametric surface source",
    tooltip = "Create a parametric surface source",
    desc    = "Create a parametric surface source",
    help    = "Create a parametric surface source",
    extensions = [],
    wildcard = '',
    output_info = PipelineInfo(datasets=['poly_data'],
                               attribute_types=['any'],
                               attributes=['any'])
)

point_load = SourceMetadata(
    id            = "PointLoadSource",
    class_name    = BASE + ".point_load.PointLoad",
    menu_name     = "Create Point &load source",
    tooltip = "Simulates a point load on a cube of data (for tensors)",
    desc    = "Simulates a point load on a cube of data (for tensors)",
    help    = "Simulates a point load on a cube of data (for tensors)",
    extensions = [],
    wildcard = '',
    output_info = PipelineInfo(datasets=['image_data'],
                               attribute_types=['any'],
                               attributes=['any'])
)

builtin_surface = SourceMetadata(
    id            = "BuiltinSurfaceSource",
    class_name    = BASE + ".builtin_surface.BuiltinSurface",
    menu_name     = "Create built-in &surface",
    tooltip = "Create a vtk poly data source",
    desc    = "Create a vtk poly data source",
    help    = "Create a vtk poly data source",
    extensions = [],
    wildcard = '',
    output_info = PipelineInfo(datasets=['poly_data'],
                               attribute_types=['any'],
                               attributes=['any'])
)

builtin_image = SourceMetadata(
    id            = "BuiltinImageSource",
    class_name    = BASE + ".builtin_image.BuiltinImage",
    menu_name     = "Create built-in &image",
    tooltip = "Create a vtk image data source",
    desc    = "Create a vtk image data source",
    help    = "Create a vtk image data source",
    extensions = [],
    wildcard = '',
    output_info = PipelineInfo(datasets=['image_data'],
                               attribute_types=['any'],
                               attributes=['any'])
)

open_volume = SourceMetadata(
    id            = "VolumeFile",
    class_name    = BASE + ".volume_reader.VolumeReader",
    menu_name     = "&Volume file",
    tooltip       = "Open a Volume file",
    desc        = "Open a Volume file",
    help        = "Open a Volume file",
    extensions = [],
    wildcard = '',
    output_info = PipelineInfo(datasets=['image_data'],
                               attribute_types=['any'],
                               attributes=['any'])
)

open_chaco = SourceMetadata(
    id            = "ChacoFile",
    class_name    = BASE + ".chaco_reader.ChacoReader",
    menu_name     = "&Chaco file",
    tooltip       = "Open a Chaco file",
    desc        = "Open a Chaco file",
    help        = "Open a Chaco file",
    extensions = [],
    wildcard = '',
    output_info = PipelineInfo(datasets=['unstructured_grid'],
                               attribute_types=['any'],
                               attributes=['any'])
)



# Now collect all the sources for the mayavi registry.
sources = [open_3ds,
           open_image,
           open_plot3d,
           open_vrml,
           open_vtk,
           open_vtk_xml,
           parametric_surface,
           point_load,
           builtin_surface,
           builtin_image,
           open_poly_data,
           open_ugrid_data,
           open_volume,
           open_chaco,
           ]


########NEW FILE########
__FILENAME__ = parametric_surface
"""A module that displays Parametric Surfaces, which are generated by
sets of equations describing the deformation of the real plane into
the surface.
"""
# Authors: KK Rai (kk.rai [at] iitb.ac.in)
#          R. Ambareesha (ambareesha [at] iitb.ac.in)
#          Prabhu Ramachandran (prabhu [at] aero.iitb.ac.in)

# Enthought library imports.
from traits.api import Instance, Enum, Dict, Str
from tvtk.api import tvtk

# Local imports
from mayavi.core.source import Source
from mayavi.core.pipeline_info import PipelineInfo


######################################################################
# `ParametricSurface` class.
######################################################################
class ParametricSurface(Source):
    # The version of this class.  Used for persistence.
    __version__ = 0

    # Flag to set the parametric function type.
    function = Enum('boy','conic_spiral','cap','dini',
                    'ellipsoid','enneper','figure8klein','klein',
                    'mobius','random_hills','roman','spline',
                    'super_ellipsoid','super_toroid','torus',
                    desc='which parametric function to be used')

    # Define the trait 'parametric_function' whose value must be an instance of
    # type ParametricFunction
    parametric_function = Instance(tvtk.ParametricFunction,
                                   allow_none=False, record=True)

    # The Parametric function source which generates the data.
    source = Instance(tvtk.ParametricFunctionSource, args=(),
                      kw={'scalar_mode': 'distance'},
                      allow_none=False, record=True)

    # Information about what this object can produce.
    output_info = PipelineInfo(datasets=['poly_data'],
                               attribute_types=['any'],
                               attributes=['any'])

    ########################################
    # Private traits.

    # A dictionary that maps the function names to instances of the
    # parametric surfaces
    _function_dict = Dict(Str,
                          Instance(tvtk.ParametricFunction,
                                   allow_none=False))


    ######################################################################
    # `object` interface
    ######################################################################
    def __init__(self, **traits):
        # Setup the function dict.
        fd = {'boy':tvtk.ParametricBoy(),
              'conic_spiral':tvtk.ParametricConicSpiral(),
              'cap':tvtk.ParametricCrossCap(),
              'dini':tvtk.ParametricDini(),
              'ellipsoid':tvtk.ParametricEllipsoid(),
              'enneper':tvtk.ParametricEnneper(),
              'figure8klein':tvtk.ParametricFigure8Klein(),
              'klein':tvtk.ParametricKlein(),
              'mobius':tvtk.ParametricMobius(),
              'random_hills':tvtk.ParametricRandomHills(),
              'roman':tvtk.ParametricRoman(),
              'spline':tvtk.ParametricSpline(),
              'super_ellipsoid':tvtk.ParametricSuperEllipsoid(),
              'super_toroid':tvtk.ParametricSuperToroid(),
              'torus':tvtk.ParametricTorus()}
        self._function_dict = fd

        # Call parent class' init.
        super(ParametricSurface, self).__init__(**traits)

        # Initialize the function to the default mode's instance from
        # the dictionary
        self.parametric_function = self._function_dict[self.function]

        # Call render everytime source traits change.
        self.source.on_trait_change(self.render)
        # Setup the outputs.
        self.outputs = [self.source.output]

    ######################################################################
    # Non-public methods.
    ######################################################################
    def _function_changed(self, value):
        """This method is invoked (automatically) when the `function`
        trait is changed.
        """
        self.parametric_function = self._function_dict[self.function]

    def _parametric_function_changed(self, old, new):
        """This method is invoked (automatically) when the
        `parametric_function` attribute is changed.
        """
        self.source.parametric_function = self.parametric_function

        # Setup the handlers so that
        if old is not None:
            old.on_trait_change(self.render, remove=True)
        new.on_trait_change(self.render)
        self.source.update()
        self.data_changed = True

########NEW FILE########
__FILENAME__ = plot3d_reader
"""A PLOT3D file reader.  This reader does not support a timeseries of
files.

"""
# Author: Prabhu Ramachandran <prabhu@aero.iitb.ac.in>
# Copyright (c) 2007, Enthought, Inc.
# License: BSD Style.


# Standard library imports.
from os.path import basename, isfile, exists, splitext

# Enthought library imports.
from traits.api import Trait, Instance, Str, TraitPrefixMap, Button
from traitsui.api import View, Group, Item, FileEditor
from tvtk.api import tvtk
from apptools.persistence.state_pickler import set_state
from apptools.persistence.file_path import FilePath

# Local imports.
from mayavi.core.source import Source
from mayavi.core.common import handle_children_state, error
from mayavi.core.pipeline_info import PipelineInfo


########################################################################
# `PLOT3DReader` class
########################################################################
class PLOT3DReader(Source):

    """A PLOT3D file reader.  This reader does not support a
    timeseries of files.
    """

    # The version of this class.  Used for persistence.
    __version__ = 0

    # XYZ file name
    xyz_file_name = Str('', desc='the XYZ file')

    # The (optional) Q file.
    q_file_name = Str('', desc='the Q file')

    # The active scalar name.
    scalars_name = Trait('density',
                         TraitPrefixMap({'density': 100,
                                          'pressure':110,
                                          'temperature': 120,
                                          'enthalpy': 130,
                                          'internal energy': 140,
                                          'kinetic energy': 144,
                                          'velocity magnitude': 153,
                                          'stagnation energy': 163,
                                          'entropy': 170,
                                          'swirl': 184}),
                         desc='scalar data attribute to show')
    # The active vector name.
    vectors_name = Trait('momentum',
                         TraitPrefixMap({'velocity': 200,
                                          'vorticity': 201,
                                          'momentum': 202,
                                          'pressure gradient': 210}),
                         desc='vector data attribute to show')

    # The VTK data file reader.
    reader = Instance(tvtk.MultiBlockPLOT3DReader, args=(), allow_none=False,
                      record=True)

    # Information about what this object can produce.
    output_info = PipelineInfo(datasets=['structured_grid'])

    ########################################
    # View related code.

    update_reader = Button('Update Reader')

    # Our view.
    view = View(Group(Item('xyz_file_name', editor=FileEditor()),
                      Item('q_file_name', editor=FileEditor()),
                      Item(name='scalars_name',
                           enabled_when='len(object.q_file_name) > 0'),
                      Item(name='vectors_name',
                           enabled_when='len(object.q_file_name)>0'),
                      Item(name='update_reader'),
                      label='Reader',
                      ),
                Group(Item(name='reader', style='custom',
                           resizable=True),
                      show_labels=False,
                      label='PLOT3DReader'
                      ),
                resizable=True)

    ########################################
    # Private traits.

    # The current file paths.  This is not meant to be touched by the
    # user.
    xyz_file_path = Instance(FilePath, args=(), desc='the current XYZ file path')
    q_file_path = Instance(FilePath, args=(), desc='the current Q file path')

    ######################################################################
    # `object` interface
    ######################################################################
    def __get_pure_state__(self):
        d = super(PLOT3DReader, self).__get_pure_state__()
        # These traits are dynamically created.
        for name in ('scalars_name', 'vectors_name', 'xyz_file_name',
                     'q_file_name'):
            d.pop(name, None)

        return d

    def __set_pure_state__(self, state):
        xyz_fn = state.xyz_file_path.abs_pth
        q_fn = state.q_file_path.abs_pth
        if not isfile(xyz_fn):
            msg = 'Could not find file at %s\n'%xyz_fn
            msg += 'Please move the file there and try again.'
            raise IOError, msg

        # Setup the reader state.
        set_state(self, state, first=['reader'], ignore=['*'])
        # Initialize the files.
        self.initialize(xyz_fn, q_fn, configure=False)
        # Now set the remaining state without touching the children.
        set_state(self, state, ignore=['children', 'xyz_file_path', 'q_file_path'])
        # Setup the children.
        handle_children_state(self.children, state.children)
        # Setup the children's state.
        set_state(self, state, first=['children'], ignore=['*'])


    ######################################################################
    # `FileDataSource` interface
    ######################################################################
    def initialize(self, xyz_file_name, q_file_name='', configure=True):
        """Given an xyz filename and a Q filename which may or may not
        be part of a time series, this initializes the list of files.
        This method need not be called to initialize the data.

        If configure is True, it pops up a UI to configure the
        PLOT3DReader.
        """
        if len(q_file_name) == 0:
            base = splitext(xyz_file_name)[0]
            qf = base + '.q'
            if exists(qf):
                q_file_name = qf

        if configure:
            # First set properties of the reader.  This is useful when
            # the data format has atypical defaults.  Automatic
            # detection can be disastrous sometimes due to VTK related
            # problems.
            self.reader.edit_traits(kind='livemodal')
        self.xyz_file_name = xyz_file_name
        if len(q_file_name) > 0:
            self.q_file_name = q_file_name

    def update(self):
        if len(self.xyz_file_path.get()) == 0:
            return
        self.reader.update()
        self.render()

    def has_output_port(self):
        """ Return True as the reader has output port."""
        return True

    def get_output_object(self):
        """ Return the reader output port."""
        return self.reader.output_port

    ######################################################################
    # Non-public interface
    ######################################################################
    def _xyz_file_name_changed(self, value):
        if len(value) == 0:
            return
        else:
            self.reader.xyz_file_name = value
            self.xyz_file_path.set(value)
            self._update_reader_output()

    def _q_file_name_changed(self, value):
        if len(value) == 0:
            return
        else:
            self.reader.q_file_name = value
            self.q_file_path.set(value)
            self._update_reader_output()

    def _update_reader_output(self):
        r = self.reader
        r.update()

        if r.error_code != 0:
            try:
                self.reader.i_blanking = True
            except AttributeError:
                pass
            else:
                r.update()

        # Try reading file.
        if r.error_code != 0:
            # No output so the file might be an ASCII file.
            try:
                # Turn off IBlanking.
                r.set(i_blanking = False, binary_file = False)
            except AttributeError:
                pass
            else:
                r.update()

        # Try again this time as ascii and with blanking.
        if r.error_code != 0:
            # No output so the file might be an ASCII file.
            try:
                # Turn on IBlanking.
                r.i_blanking = True
            except AttributeError:
                pass
            else:
                r.update()

        # If there still is an error, ask the user.
        if r.error_code != 0:
            r.edit_traits(kind='livemodal')
            r.update()

        # If there still is an error, ask the user to retry.
        if r.error_code != 0:
            msg = 'Unable to read file properly. '\
                  'Please check the settings of the reader '\
                  'on the UI and press the "Update Reader" button '\
                  'when done and try again!'
            error(msg)
            return

        # Now setup the outputs by resetting self.outputs.  Changing
        # the outputs automatically fires a pipeline_changed event.
        try:
            n = r.get_output().number_of_blocks
        except AttributeError: # for VTK >= 4.5
            n = r.number_of_outputs
        outputs = []
        for i in range(n):
            outputs.append(r.get_output().get_block(i))

        self.outputs = outputs

        # Fire data_changed just in case the outputs are not
        # really changed.  This can happen if the dataset is of
        # the same type as before.
        self.data_changed = True

        # Change our name on the tree view
        self.name = self._get_name()

    def _scalars_name_changed(self, value):
        self.reader.scalar_function_number = self.scalars_name_
        self.reader.modified()
        self.update()
        self.data_changed = True

    def _vectors_name_changed(self, value):
        self.reader.vector_function_number = self.vectors_name_
        self.reader.modified()
        self.update()
        self.data_changed = True

    def _update_reader_fired(self):
        self.reader.modified()
        self._update_reader_output()
        self.pipeline_changed = True

    def _get_name(self):
        """ Gets the name to display on the tree view.
        """
        xyz_fname = basename(self.xyz_file_path.get())
        q_fname = basename(self.q_file_path.get())
        if len(self.q_file_name) > 0:
            ret = "PLOT3D:%s, %s"%(xyz_fname, q_fname)
        else:
            ret = "PLOT3D:%s"%(xyz_fname)
        if '[Hidden]' in self.name:
            ret += ' [Hidden]'
        return ret


########NEW FILE########
__FILENAME__ = point_load
"""A source object that computes stress tensors on a volume.
     The tensors are computed from the application of a point load on a
     semi-infinite domain.
"""
# Authors: KK Rai (kk.rai [at] iitb.ac.in)
#          R. Ambareesha (ambareesha [at] iitb.ac.in)
#          Prabhu Ramachandran (prabhu [at] aero.iitb.ac.in)

# Enthought library imports.
from traits.api import Instance
from traitsui.api import View, Group, Item
from tvtk.api import tvtk

# Local imports
from mayavi.core.source import Source
from mayavi.core.pipeline_info import PipelineInfo


######################################################################
# `PointLoad` class.
######################################################################
class PointLoad(Source):
    # The version of this class.  Used for persistence.
    __version__ = 0

    point_load = Instance(tvtk.PointLoad, args=(), allow_none=False,
                          record=True)


    # Information about what this object can produce.
    output_info = PipelineInfo(datasets=['image_data'],
                               attribute_types=['any'],
                               attributes=['any'])

    # Create the UI for the traits.
    view = View(Group(Item(name='point_load',
                           style='custom',
                           resizable=True),
                      label='PointLoad',
                      show_labels=False),
                resizable=True)

    ######################################################################
    # `object` interface
    ######################################################################
    def __init__(self, **traits):
        # Call parent class' init.
        super(PointLoad, self).__init__(**traits)

        # Call render everytime source traits change.
        self.point_load.on_trait_change(self.render)

        # Setup the outputs.
        self.outputs = [self.point_load.output]

    def has_output_port(self):
        """ Return True as the point load has output port."""
        return True

    def get_output_object(self):
        """ Return the point load output port."""
        return self.point_load.output_port

########NEW FILE########
__FILENAME__ = poly_data_reader
"""A PolyData file reader object.
"""
# Author:   R.Sreekanth <sreekanth [at] aero.iitb.ac.in>
#               Suyog Dutt Jain <suyog.jain [at] aero.iitb.ac.in>
# Copyright (c) 2009, Enthought, Inc.
# License: BSD Style.

# Standard library imports.
from os.path import basename

# Enthought imports.
from traits.api import Instance, Str,Dict
from traitsui.api import View, Item, Group, Include
from tvtk.api import tvtk

# Local imports
from mayavi.core.file_data_source import FileDataSource
from mayavi.core.pipeline_info import PipelineInfo
from mayavi.core.common import error

########################################################################
# `PolyDataReader` class
########################################################################
class PolyDataReader(FileDataSource):

    """A PolyData file reader. The reader supports all the
    different types of poly data files.
    """

    # The version of this class.  Used for persistence.
    __version__ = 0

    # The PolyData file reader
    reader = Instance(tvtk.Object, allow_none=False,
                      record=True)

    ######################################################################
    # Private Traits
    _reader_dict = Dict(Str, Instance(tvtk.Object))

    # Our View.
    view = View(Group(Include('time_step_group'),
                      Item(name='base_file_name'),
                      Item(name='reader',
                           style='custom',
                           resizable=True),
                      show_labels=False),
                resizable=True)

    #output_info = PipelineInfo(datasets=['none'])
    output_info = PipelineInfo(datasets=['poly_data'],
                               attribute_types=['any'],
                               attributes=['any'])


    ######################################################################
    # `object` interface
    ######################################################################
    def __set_pure_state__(self, state):
        # The reader has its own file_name which needs to be fixed.
        state.reader.file_name = state.file_path.abs_pth
        # Now call the parent class to setup everything.
        super(PolyDataReader, self).__set_pure_state__(state)

    ######################################################################
    # `FileDataSource` interface
    ######################################################################
    def update(self):
        self.reader.update()
        if len(self.file_path.get()) == 0:
            return
        self.render()

    def has_output_port(self):
        """ Return True as the reader has output port."""
        return True

    def get_output_object(self):
        """ Return the reader output port."""
        return self.reader.output_port
    
    ######################################################################
    # Non-public interface
    ######################################################################
    def _file_path_changed(self, fpath):
        value = fpath.get()
        if len(value) == 0:
            return

        # Extract the file extension
        splitname = value.strip().split('.')
        extension = splitname[-1].lower()
        # Select polydata reader based on file type
        old_reader = self.reader
        if self._reader_dict.has_key(extension):
            self.reader = self._reader_dict[extension]
        else:
            error('Invalid extension for file: %s'%value)
            return

        self.reader.file_name = value.strip()
        self.reader.update()
        self.reader.update_information()

        if old_reader is not None:
            old_reader.on_trait_change(self.render, remove=True)
        self.reader.on_trait_change(self.render)

        old_outputs = self.outputs
        self.outputs = [self.reader.output]
        if self.outputs == old_outputs:
            self.data_changed = True

        # Change our name on the tree view
        self.name = self._get_name()

    def _get_name(self):
        """ Returns the name to display on the tree view.  Note that
        this is not a property getter.
        """
        fname = basename(self.file_path.get())
        ret = "%s"%fname
        if len(self.file_list) > 1:
            ret += " (timeseries)"
        if '[Hidden]' in self.name:
            ret += ' [Hidden]'

        return ret

    def __reader_dict_default(self):
        """Default value for reader dict."""
        rd = {'stl':tvtk.STLReader(),
             'stla':tvtk.STLReader(),
             'stlb':tvtk.STLReader(),
             'txt':tvtk.SimplePointsReader(),
             'raw':tvtk.ParticleReader(),
             'ply':tvtk.PLYReader(),
             'pdb':tvtk.PDBReader(),
             'slc':tvtk.SLCReader(),
             'xyz':tvtk.XYZMolReader(),
             'obj':tvtk.OBJReader(),
             'facet':tvtk.FacetReader(),
             'cube':tvtk.GaussianCubeReader(),
             'g':tvtk.BYUReader(),
            }
        return rd

    # Callable to check if the reader can actually read the file
    def can_read(cls,filename):
        """ Class method to check if the reader can actually
        read the file. Returns 'True' if it can read it succesfully
        else 'False'
        """
        # Extract the file extension
        splitname = filename.strip().split('.')
        extension = splitname[-1].lower()

        if extension == 'xyz':
            from vtk import vtkObject
            o = vtkObject
            w = o.GetGlobalWarningDisplay()
            o.SetGlobalWarningDisplay(0) # Turn it off.

            r = tvtk.XYZMolReader()
            r.file_name = filename
            r.update()
            o.SetGlobalWarningDisplay(w)

            if len(r.output.points) != 0:
                return True
            return False

        return None

    can_read = classmethod(can_read)

########NEW FILE########
__FILENAME__ = three_ds_importer
"""An importer for 3D Studio files.

"""
# Author: Prabhu Ramachandran <prabhu at aero dot iitb dot ac dot in>
# Copyright (c) 2007, Enthought, Inc.
# License: BSD Style.

# Standard library imports.
from os.path import basename

# Enthought imports.
from tvtk.api import tvtk
from traits.api import Instance

# Local imports
from mayavi.sources.vrml_importer import VRMLImporter


######################################################################
# `ThreeDSImporter` class.
######################################################################
class ThreeDSImporter(VRMLImporter):

    # The 3DS importer.
    reader = Instance(tvtk.ThreeDSImporter, args=(),
                      kw={'compute_normals':True},
                      allow_none=False, record=True)

    ######################################################################
    # `FileDataSource` interface
    ######################################################################

    def has_output_port(self):
        """ Return True as the reader has output port."""
        return True

    def get_output_object(self):
        """ Return the reader output port."""
        return self.reader.output_port
    
    ######################################################################
    # Non-public interface
    ######################################################################
    def _file_name_changed(self, value):
        # This hack is necessary since for some reason the importer
        # does not clear out the earlier actors.
        self.reader = reader = tvtk.ThreeDSImporter(compute_normals=True)
        reader.file_name = value
        if self.scene is not None:
            self.reader.render_window = self.scene.render_window

        name = "3DStudio file (%s)"%basename(self.file_name)
        if '[Hidden]' in self.name:
            name += ' [Hidden]'
        self.name = name

        self._file_path.set(value)
        self._update_reader()
        self.render()

########NEW FILE########
__FILENAME__ = parametric_surface
"""
Traits View definition file.

The view trait of the parent class is extracted from the model definition
file.  This file can either be exec()ed or imported.  See
core/base.py:Base.trait_view() for what is currently used.  Using exec()
allows view changes without needing to restart Mayavi, but is slower than
importing.
"""
# Authors: Prabhu Ramachandran <prabhu_r@users.sf.net>
#          Vibha Srinivasan <vibha@enthought.com>
#          Judah De Paula <judah@enthought.com>
# Copyright (c) 2005-2008, Enthought, Inc.
# License: BSD Style.
from traitsui.api import Item, Group, View

view = View(Group(Item(name='function'),
                  Item(name='parametric_function',
                       style='custom',
                       resizable=True),
                   label='Function',
                    show_labels=False
                   ),
             Group(Item(name='source',
                        style='custom',
                        resizable=True),
                    label='Source',
                    show_labels=False),
             resizable=True)

########NEW FILE########
__FILENAME__ = unstructured_grid_reader
"""A Unstructred Grid file reader object.
"""
# Author:   R.Sreekanth <sreekanth [at] aero.iitb.ac.in>
#               Suyog Dutt Jain <suyog.jain [at] aero.iitb.ac.in>
# Copyright (c) 2009, Enthought, Inc.
# License: BSD Style.

from os.path import basename

# Enthought library imports.
from traits.api import Instance, Str, Dict
from traitsui.api import View, Group, Item, Include
from tvtk.api import tvtk

# Local imports.
from tvtk.common import is_old_pipeline
from mayavi.core.file_data_source import FileDataSource
from mayavi.core.pipeline_info import PipelineInfo
from mayavi.core.common import error

########################################################################
# `UnstructuredGridReader` class
########################################################################
class UnstructuredGridReader(FileDataSource):

    # The version of this class.  Used for persistence.
    __version__ = 0

    # The UnstructuredGridAlgorithm data file reader.
    reader = Instance(tvtk.Object, allow_none=False, record=True)

    # Information about what this object can produce.
    output_info = PipelineInfo(datasets=['unstructured_grid'])

    ######################################################################
    # Private Traits
    _reader_dict = Dict(Str, Instance(tvtk.Object))

    # Our view.
    view = View(Group(Include('time_step_group'),
                      Item(name='base_file_name'),
                      Item(name='reader',
                           style='custom',
                           resizable=True),
                      show_labels=False),
                resizable=True)


    ######################################################################
    # `object` interface
    ######################################################################
    def __set_pure_state__(self, state):
        # The reader has its own file_name which needs to be fixed.
        state.reader.file_name = state.file_path.abs_pth
        # Now call the parent class to setup everything.
        super(UnstructuredGridReader, self).__set_pure_state__(state)

    ######################################################################
    # `FileDataSource` interface
    ######################################################################
    def update(self):
        self.reader.update()
        if len(self.file_path.get()) == 0:
            return
        self.render()

    def has_output_port(self):
        """ Return True as the reader has output port."""
        return True

    def get_output_object(self):
        """ Return the reader output port."""
        return self.reader.output_port
    
    ######################################################################
    # Non-public interface
    ######################################################################
    def _file_path_changed(self, fpath):
        value = fpath.get()
        if len(value) == 0:
            return
        # Extract the file extension
        splitname = value.strip().split('.')
        extension = splitname[-1].lower()
        # Select UnstructuredGridreader based on file type
        old_reader = self.reader
        if self._reader_dict.has_key(extension):
            self.reader = self._reader_dict[extension]
        else:
            error('Invalid file extension for file: %s'%value)
            return

        self.reader.file_name = value.strip()
        self.reader.update_information()
        if isinstance(self.reader, tvtk.ExodusIIReader):
            # Make sure the point fields are read during Update().
            for k in xrange(self.reader.number_of_point_result_arrays ):
                arr_name = self.reader.get_point_result_array_name( k )
                self.reader.set_point_result_array_status( arr_name, 1 )
        self.reader.update()

        if old_reader is not None:
            old_reader.on_trait_change(self.render, remove=True)
        self.reader.on_trait_change(self.render)

        old_outputs = self.outputs
        if isinstance(self.reader, tvtk.ExodusIIReader):
            self.outputs = [self.reader.output.get_block(0).get_block(0)]
        else:
            self.outputs = [self.reader.output]

        if self.outputs == old_outputs:
            self.data_changed = True

        # Change our name on the tree view
        self.name = self._get_name()

    def _get_name(self):
        """ Returns the name to display on the tree view.  Note that
        this is not a property getter.
        """
        fname = basename(self.file_path.get())
        ret = "%s"%fname
        if len(self.file_list) > 1:
            ret += " (timeseries)"
        if '[Hidden]' in self.name:
            ret += ' [Hidden]'

        return ret

    def __reader_dict_default(self):
        """Default value for reader dict."""
        if is_old_pipeline():
            rd = {'inp':tvtk.AVSucdReader(),
                 'neu':tvtk.GAMBITReader(),
                 'exii':tvtk.ExodusReader()
                }
        else:
            rd = {'inp':tvtk.AVSucdReader(),
                 'neu':tvtk.GAMBITReader(),
                 'ex2':tvtk.ExodusIIReader()
                }

        return rd

########NEW FILE########
__FILENAME__ = volume_reader
"""A Volume file reader"""
# Author: Suyog Dutt Jain <suyog.jain@aero.iitb.ac.in>
# Copyright (c) 2009, Enthought, Inc.
# License: BSD Style.

# Enthought library imports.
from traits.api import Instance, Str
from traitsui.api import View, Group, Item
from tvtk.api import tvtk

# Local imports.
from mayavi.core.source import Source
from mayavi.core.pipeline_info import PipelineInfo


########################################################################
# `VolumeReader` class
########################################################################
class VolumeReader(Source):

    """A Volume reader.
    """

    # The version of this class.  Used for persistence.
    __version__ = 0

    file_prefix = Str('', desc='File prefix for the volume files')

    # The VTK data file reader.
    reader = Instance(tvtk.Volume16Reader, args=(), allow_none=False,
                      record=True)

    # Information about what this object can produce.
    output_info = PipelineInfo(datasets=['image_data'])

    ########################################
    # View related code.
    # Our view.
    view = View(Group(Item(name='reader', style='custom',
                            resizable=True),
                      show_labels=False),
                resizable=True)

    ######################################################################
    # `Source` interface
    ######################################################################

    def __init__(self, file_prefix='', configure=True, **traits):
        super(VolumeReader, self).__init__(**traits)
        if configure:
            self.reader.edit_traits(kind='livemodal')

        self.file_prefix = self.reader.file_prefix

    def update(self):
        if len(self.file_prefix) == 0:
            return
        self.reader.update()
        self.render()

    def has_output_port(self):
        """ Return True as the reader has output port."""
        return True

    def get_output_object(self):
        """ Return the reader output port."""
        return self.reader.output_port
    
    ######################################################################
    # Non-public interface
    ######################################################################
    def _file_prefix_changed(self, value):
        if len(value) == 0:
            return
        else:
            self.reader.file_prefix = value
            self._update_reader_output()

    def _update_reader_output(self):
        self.reader.update()
        self.reader.update_information()
        self.reader.on_trait_change(self.render)
        self.outputs = [self.reader.output]
        self.data_changed = True

########NEW FILE########
__FILENAME__ = vrml_importer
"""An importer for VRML files.

"""
# Author: Prabhu Ramachandran <prabhu at aero dot iitb dot ac dot in>
# Copyright (c) 2007, Enthought, Inc.
# License: BSD Style.

# Standard library imports.
from os.path import basename

# Enthought imports.
from tvtk.api import tvtk
from traits.api import Instance, Str
from traitsui.api import View, Item, FileEditor
from apptools.persistence.file_path import FilePath
from apptools.persistence.state_pickler import set_state

# Local imports
from mayavi.core.source import Source
from mayavi.core.pipeline_info import PipelineInfo

######################################################################
# `VRMLImporter` class.
######################################################################
class VRMLImporter(Source):

    __version__ = 0

    # The file name.
    file_name = Str('', enter_set=True, auto_set=False,
                    desc='the VRML file name')

    # The VRML importer.
    reader = Instance(tvtk.VRMLImporter, args=(), allow_none=False,
                      record=True)

    output_info = PipelineInfo(datasets=['none'])

    ###############
    # Private traits.

    # Our file path used for persistence
    _file_path = Instance(FilePath, args=())

    # Our View.
    view = View(Item(name='file_name', editor=FileEditor()))

    ######################################################################
    # `object` interface
    ######################################################################
    def __get_pure_state__(self):
        d = super(VRMLImporter, self).__get_pure_state__()
        # These traits are dynamically created.
        for name in ('reader', 'file_name'):
            d.pop(name)
        return d

    def __set_pure_state__(self, state):
        # The reader has its own file_name which needs to be fixed.
        fname = state._file_path.abs_pth
        # Now call the parent class to setup everything.
        self.initialize(fname)
        # Setup the rest of the state.
        set_state(self, state, ignore=['_file_path'])

    def initialize(self, file_name):
        self.file_name = file_name

    ######################################################################
    # `PipelineBase` interface.
    ######################################################################
    def add_actors(self):
        """Adds `self.actors` to the scene.
        """
        if not self._actors_added:
            self.reader.render_window = self.scene.render_window
            self._update_reader()
            self._actors_added = True
            if not self.visible:
                self._visible_changed(self.visible)
            self.scene.render()

    def remove_actors(self):
        """Removes `self.actors` from the scene.
        """
        if self._actors_added:
            self.scene.remove_actors(self.actors)
            self._actors_added = False
            self.scene.render()

    def has_output_port(self):
        """ Return True as the reader has output port."""
        return True

    def get_output_object(self):
        """ Return the reader output port."""
        return self.reader.output_port
    
    ######################################################################
    # Non-public interface
    ######################################################################
    def _file_name_changed(self, value):
        reader = self.reader
        reader.file_name = value
        self._file_path.set(value)
        self._update_reader()
        self.render()
        name = "VRML file (%s)"%basename(self.file_name)
        if '[Hidden]' in self.name:
            name += ' [Hidden]'
        self.name = name

    def _update_reader(self):
        reader = self.reader
        if self.scene is None or reader.file_name is None \
               or len(reader.file_name) == 0:
            return
        actors1 = [x for x in self.scene.renderer.actors]
        reader.read()
        self.scene.render()
        actors2 = [x for x in self.scene.renderer.actors]
        self.actors = [x for x in actors2 if x not in actors1]
        # If these are the first actors on scene reset the view.
        if len(actors1) == 0:
            self.scene.reset_zoom()

    def _scene_changed(self, old, new):
        if self._actors_added:
            old.remove_actors(self.actors)
            reader = self.reader
            reader.render_window = new.render_window
            self._update_reader()

    def _actors_changed(self, old, new):
        if self._actors_added:
            self.scene.remove_actors(old)
            # The actors are added automatically when the importer
            # does a read.
            self.scene.render()

    def _actors_items_changed(self, list_event):
        if self._actors_added:
            self.scene.remove_actors(list_event.removed)
            # The actors are added automatically when the importer
            # does a read.
            self.scene.render()

    def _visible_changed(self, value):
        if value:
            if not self._actors_added:
                self.scene.add_actors(self.actors)
                self._actors_added = True
        super(VRMLImporter, self)._visible_changed(value)


########NEW FILE########
__FILENAME__ = vtk_data_source
"""This source manages a VTK dataset given to it.  When this source is
pickled or persisted, it saves the data given to it in the form of a
gzipped string.
"""
# Author: Prabhu Ramachandran <prabhu_r@users.sf.net>
# Copyright (c) 2005-2008, Enthought, Inc.
# License: BSD Style.

import os
import tempfile

# Enthought library imports.
from traits.api import Instance, List, Str, Bool, Int
from traitsui.api import View, Group, Item
from apptools.persistence.state_pickler \
     import gzip_string, gunzip_string, set_state
from tvtk.api import tvtk
from tvtk import messenger

# Local imports.
from tvtk.common import is_old_pipeline, configure_input_data
from mayavi.core.source import Source
from mayavi.core.common import handle_children_state
from mayavi.core.trait_defs import DEnum
from mayavi.core.pipeline_info import (PipelineInfo,
        get_tvtk_dataset_name)
from vtk_xml_file_reader import get_all_attributes


######################################################################
# Utility functions.
######################################################################
def write_dataset_to_string(data):
    """Given a dataset, convert the dataset to an ASCII string that can
    be stored for persistence.
    """
    w = tvtk.DataSetWriter(write_to_output_string=1)
    warn = w.global_warning_display
    configure_input_data(w, data)
    w.global_warning_display = 0
    w.update()
    if w.output_string_length == 0:
        # Some VTK versions (5.2) have a bug when writing structured
        # grid datasets and produce empty output.  We work around this
        # by writing to a file and then reading that output.
        w.write_to_output_string = 0
        fh, fname = tempfile.mkstemp('.vtk')
        os.close(fh); os.remove(fname)
        w.file_name = fname
        w.write()
        # Read the data and delete the file.
        sdata = open(fname).read()
        os.remove(fname)
    else:
        sdata = w.output_string
    w.global_warning_display = warn
    return sdata

def has_attributes(dataset):
    """Returns `True` when the given TVTK `dataset` has any attribute
    arrays in point and cell data and `False` otherwise.
    """
    pd = dataset.point_data
    if pd is not None and pd.number_of_arrays > 0:
        return True
    cd = dataset.cell_data
    if cd is not None and cd.number_of_arrays > 0:
        return True
    return False


######################################################################
# `VTKDataSource` class
######################################################################
class VTKDataSource(Source):

    """This source manages a VTK dataset given to it.  When this
    source is pickled or persisted, it saves the data given to it in
    the form of a gzipped string.

    Note that if the VTK dataset has changed internally and you need
    to notify the mayavi pipeline to flush the data just call the
    `modified` method of the VTK dataset and the mayavi pipeline will
    update automatically.
    """

    # The version of this class.  Used for persistence.
    __version__ = 0

    # The VTK dataset to manage.
    data = Instance(tvtk.DataSet, allow_none=False)

    # Information about what this object can produce.
    output_info = PipelineInfo(datasets=['any'],
                               attribute_types=['any'],
                               attributes=['any'])

    ########################################
    # Dynamic traits: These traits are dynamic and are updated on the
    # _update_data method.

    # The active point scalar name.
    point_scalars_name = DEnum(values_name='_point_scalars_list',
                               desc='scalar point data attribute to use')
    # The active point vector name.
    point_vectors_name = DEnum(values_name='_point_vectors_list',
                               desc='vectors point data attribute to use')
    # The active point tensor name.
    point_tensors_name = DEnum(values_name='_point_tensors_list',
                               desc='tensor point data attribute to use')

    # The active cell scalar name.
    cell_scalars_name = DEnum(values_name='_cell_scalars_list',
                               desc='scalar cell data attribute to use')
    # The active cell vector name.
    cell_vectors_name = DEnum(values_name='_cell_vectors_list',
                               desc='vectors cell data attribute to use')
    # The active cell tensor name.
    cell_tensors_name = DEnum(values_name='_cell_tensors_list',
                               desc='tensor cell data attribute to use')

    ########################################
    # Our view.

    view = View(Group(Item(name='point_scalars_name'),
                      Item(name='point_vectors_name'),
                      Item(name='point_tensors_name'),
                      Item(name='cell_scalars_name'),
                      Item(name='cell_vectors_name'),
                      Item(name='cell_tensors_name'),
                      Item(name='data'),
                      ))

    ########################################
    # Private traits.

    # These private traits store the list of available data
    # attributes.  The non-private traits use these lists internally.
    _point_scalars_list = List(Str)
    _point_vectors_list = List(Str)
    _point_tensors_list = List(Str)
    _cell_scalars_list = List(Str)
    _cell_vectors_list = List(Str)
    _cell_tensors_list = List(Str)

    # This filter allows us to change the attributes of the data
    # object and will ensure that the pipeline is properly taken care
    # of.  Directly setting the array in the VTK object will not do
    # this.
    _assign_attribute = Instance(tvtk.AssignAttribute, args=(),
                                 allow_none=False)

    # Toggles if this is the first time this object has been used.
    _first = Bool(True)

    # The ID of the observer for the data.
    _observer_id = Int(-1)

    ######################################################################
    # `object` interface
    ######################################################################
    def __get_pure_state__(self):
        d = super(VTKDataSource, self).__get_pure_state__()
        for name in ('_assign_attribute', '_first', '_observer'):
            d.pop(name, None)
        for name in ('point_scalars', 'point_vectors',
                     'point_tensors', 'cell_scalars',
                     'cell_vectors', 'cell_tensors'):
            d.pop('_' + name + '_list', None)
            d.pop('_' + name + '_name', None)
        data = self.data
        if data is not None:
            sdata = write_dataset_to_string(data)
            z = gzip_string(sdata)
            d['data'] = z
        return d

    def __set_pure_state__(self, state):
        z = state.data
        if z is not None:
            d = gunzip_string(z)
            r = tvtk.DataSetReader(read_from_input_string=1,
                                   input_string=d)
            warn = r.global_warning_display
            r.global_warning_display = 0
            r.update()
            r.global_warning_display = warn
            self.data = r.output
        # Now set the remaining state without touching the children.
        set_state(self, state, ignore=['children', 'data'])
        # Setup the children.
        handle_children_state(self.children, state.children)
        # Setup the children's state.
        set_state(self, state, first=['children'], ignore=['*'])

    ######################################################################
    # `Base` interface
    ######################################################################
    def start(self):
        """This is invoked when this object is added to the mayavi
        pipeline.
        """
        # Do nothing if we are already running.
        if self.running:
            return

        # Update the data just in case.
        self._update_data()

        # Call the parent method to do its thing.  This will typically
        # start all our children.
        super(VTKDataSource, self).start()

    def update(self):
        """Invoke this to flush data changes downstream.  This is
        typically used when you change the data object and want the
        mayavi pipeline to refresh.
        """
        # This tells the VTK pipeline that the data has changed.  This
        # will fire the data_changed event automatically.
        self.data.modified()
        self._assign_attribute.update()

    ######################################################################
    # Non-public interface
    ######################################################################
    def _data_changed(self, old, new):
        if has_attributes(self.data):
            aa = self._assign_attribute
            self.configure_input_data(aa, new)
            self._update_data()
            aa.update()
            self.outputs = [aa.output]
        else:
            self.outputs = [self.data]
        self.data_changed = True

        self.output_info.datasets = \
                [get_tvtk_dataset_name(self.outputs[0])]

        # Add an observer to the VTK dataset after removing the one
        # for the old dataset.  We use the messenger to avoid an
        # uncollectable reference cycle.  See the
        # tvtk.messenger module documentation for details.
        if old is not None:
            old.remove_observer(self._observer_id)
        self._observer_id = new.add_observer('ModifiedEvent',
                                             messenger.send)
        new_vtk = tvtk.to_vtk(new)
        messenger.connect(new_vtk, 'ModifiedEvent',
                          self._fire_data_changed)

        # Change our name so that our label on the tree is updated.
        self.name = self._get_name()

    def _fire_data_changed(self, *args):
        """Simply fire the `data_changed` event."""
        self.data_changed = True

    def _set_data_name(self, data_type, attr_type, value):
        if value is None:
            return

        dataset = self.data
        if len(value) == 0:
            # If the value is empty then we deactivate that attribute.
            d = getattr(dataset, attr_type + '_data')
            method = getattr(d, 'set_active_%s'%data_type)
            method(None)
            self.data_changed = True
            return

        aa = self._assign_attribute
        data = None
        if attr_type == 'point':
            data = dataset.point_data
        elif attr_type == 'cell':
            data = dataset.cell_data
        method = getattr(data, 'set_active_%s'%data_type)
        method(value)
        aa.assign(value, data_type.upper(), attr_type.upper() +'_DATA')
        if data_type == 'scalars' and dataset.is_a('vtkImageData'):
            # Set the scalar_type for image data, if not you can either
            # get garbage rendered or worse.
            s = getattr(dataset, attr_type + '_data').scalars
            r = s.range
            if is_old_pipeline():
                dataset.scalar_type = s.data_type
                aa.output.scalar_type = s.data_type
        aa.update()
        # Fire an event, so the changes propagate.
        self.data_changed = True

    def _point_scalars_name_changed(self, value):
        self._set_data_name('scalars', 'point', value)

    def _point_vectors_name_changed(self, value):
        self._set_data_name('vectors', 'point', value)

    def _point_tensors_name_changed(self, value):
        self._set_data_name('tensors', 'point', value)

    def _cell_scalars_name_changed(self, value):
        self._set_data_name('scalars', 'cell', value)

    def _cell_vectors_name_changed(self, value):
        self._set_data_name('vectors', 'cell', value)

    def _cell_tensors_name_changed(self, value):
        self._set_data_name('tensors', 'cell', value)

    def _update_data(self):
        if self.data is None:
            return
        pnt_attr, cell_attr = get_all_attributes(self.data)

        pd = self.data.point_data
        scalars = pd.scalars
        if self.data.is_a('vtkImageData') and scalars is not None:
            # For some reason getting the range of the scalars flushes
            # the data through to prevent some really strange errors
            # when using an ImagePlaneWidget.
            r = scalars.range
            if is_old_pipeline():
                self._assign_attribute.output.scalar_type = scalars.data_type
                self.data.scalar_type = scalars.data_type

        def _setup_data_traits(obj, attributes, d_type):
            """Given the object, the dict of the attributes from the
            `get_all_attributes` function and the data type
            (point/cell) data this will setup the object and the data.
            """
            attrs = ['scalars', 'vectors', 'tensors']
            aa = obj._assign_attribute
            data = getattr(obj.data, '%s_data'%d_type)
            for attr in attrs:
                values = attributes[attr]
                values.append('')
                setattr(obj, '_%s_%s_list'%(d_type, attr), values)
                if len(values) > 1:
                    default = getattr(obj, '%s_%s_name'%(d_type, attr))
                    if obj._first and len(default) == 0:
                        default = values[0]
                    getattr(data, 'set_active_%s'%attr)(default)
                    aa.assign(default, attr.upper(),
                              d_type.upper() +'_DATA')
                    aa.update()
                    kw = {'%s_%s_name'%(d_type, attr): default,
                          'trait_change_notify': False}
                    obj.set(**kw)

        _setup_data_traits(self, pnt_attr, 'point')
        _setup_data_traits(self, cell_attr, 'cell')
        if self._first:
            self._first = False
        # Propagate the data changed event.
        self.data_changed = True

    def _get_name(self):
        """ Gets the name to display on the tree.
        """
        ret = "VTK Data (uninitialized)"
        if self.data is not None:
            typ = self.data.__class__.__name__
            ret = "VTK Data (%s)"%typ
        if '[Hidden]' in self.name:
            ret += ' [Hidden]'
        return ret

########NEW FILE########
__FILENAME__ = vtk_file_reader
"""A VTK file reader object.

"""
# Author: Prabhu Ramachandran <prabhu_r@users.sf.net>
# Copyright (c) 2005-2008, Enthought, Inc.
# License: BSD Style.

# Standard library imports.
from os.path import basename

# Enthought library imports.
from traits.api import Instance
from tvtk.api import tvtk

# Local imports.
from mayavi.core.pipeline_info import (PipelineInfo,
        get_tvtk_dataset_name)
from vtk_xml_file_reader import VTKXMLFileReader


########################################################################
# `VTKFileReader` class
########################################################################
class VTKFileReader(VTKXMLFileReader):

    """A VTK file reader.  This does not handle the new XML file
    format but only the older format.  The reader supports all the
    different types of data sets.  This reader also supports a time
    series.
    """

    # The version of this class.  Used for persistence.
    __version__ = 0

    # The VTK data file reader.
    reader = Instance(tvtk.DataSetReader, args=(),
                      kw={'read_all_scalars':True,
                          'read_all_vectors': True,
                          'read_all_tensors': True,
                          'read_all_fields': True} )

    # Information about what this object can produce.
    output_info = PipelineInfo(datasets=['any'],
                               attribute_types=['any'],
                               attributes=['any'])

    ######################################################################
    # `FileDataSource` interface
    ######################################################################

    def has_output_port(self):
        """ Return True as the reader has output port."""
        return True

    def get_output_object(self):
        """ Return the reader output port."""
        return self.reader.output_port
    
    ######################################################################
    # Non-public interface
    ######################################################################
    def _file_path_changed(self, fpath):
        value = fpath.get()
        if len(value) == 0:
            self.name = 'No VTK file'
            return
        else:
            self.reader.file_name = value
            self.update()

            # Setup the outputs by resetting self.outputs.  Changing
            # the outputs automatically fires a pipeline_changed
            # event.
            try:
                n = self.reader.number_of_outputs
            except AttributeError: # for VTK >= 4.5
                n = self.reader.number_of_output_ports
            outputs = []
            for i in range(n):
                outputs.append(self.reader.get_output(i))
            self.outputs = outputs

            # FIXME: Only the first output goes through the assign
            # attribute filter.
            aa = self._assign_attribute
            self.configure_input_data(aa, outputs[0])
            outputs[0] = aa.output
            self.update_data()

            self.outputs = outputs

            # FIXME: The output info is only based on the first output.
            self.output_info.datasets = [get_tvtk_dataset_name(outputs[0])]

            # Change our name on the tree view
            self.name = self._get_name()

    def _get_name(self):
        """ Gets the name to display on the tree view.
        """
        fname = basename(self.file_path.get())
        ret = "VTK file (%s)"%fname
        if len(self.file_list) > 1:
            ret += " (timeseries)"
        if '[Hidden]' in self.name:
            ret += ' [Hidden]'

        return ret


########NEW FILE########
__FILENAME__ = vtk_xml_file_reader
"""A VTK XML file reader object.
"""
# Author: Prabhu Ramachandran <prabhu_r@users.sf.net>
# Copyright (c) 2005, Enthought, Inc.
# License: BSD Style.

# Standard library imports.
from os.path import basename

# Enthought library imports.
from traits.api import Instance, List, Str, Bool
from traitsui.api import View, Group, Item, Include
from tvtk.api import tvtk

# Local imports.
from mayavi.core.file_data_source import FileDataSource
from mayavi.core.trait_defs import DEnum
from mayavi.core.pipeline_info import (PipelineInfo,
        get_tvtk_dataset_name)


######################################################################
# Utility functions.
######################################################################
def find_file_data_type(file_name):
    "Parses the named file to see what type of data there is."
    r = tvtk.XMLFileReadTester(file_name=file_name)
    if r.test_read_file():
        return r.file_data_type
    else:
        error("File %s is not a valid VTK XML file!"%(file_name))


def get_array_type(arr):
    """Returns if the array is a scalar ('scalars'), vector
    ('vectors') or tensor ('tensors').  It looks at the number of
    components to decide.  If it has a wierd number of components it
    returns the empty string.
    """
    n = arr.number_of_components
    ret = {1: 'scalars', 3: 'vectors', 4: 'scalars', 9:'tensors'}
    return ret.get(n) or ''


def get_attribute_list(data):
    """ Gets scalar, vector and tensor information from the given data
    (either cell or point data).
    """
    attr = {'scalars':[], 'vectors':[], 'tensors':[]}
    if data is not None:
        n = data.number_of_arrays
        for i in range(n):
            name = data.get_array_name(i)
            arr = data.get_array(i)
            if arr is not None:
                # Some VTK datasets claim they have n arrays, but
                # actually some of these are None (eg the output of a
                # tvtk.GraphToPolyData())
                t = get_array_type(arr)
                if len(t) > 0 and name is not None:
                    attr[t].extend([name])

    def _mk_first(lst, value):
        """Makes the specified `value` the first item in `lst`."""
        lst.remove(value)
        lst.insert(0, value)

    attr1 = attr.copy()
    for a in attr:
        v = getattr(data, a)
        if v is not None:
            name = v.name
            if name is not None:
                try:
                    _mk_first(attr[a], v.name)
                except ValueError:
                    # Sometimes we have a multi-component scalar.
                    attr1[a].insert(0, name)
    return attr1


def get_all_attributes(obj):
    """Gets the scalar, vector and tensor attributes that are
    available in the given VTK data object.
    """
    point_attr = get_attribute_list(obj.point_data)
    cell_attr = get_attribute_list(obj.cell_data)
    return point_attr, cell_attr


######################################################################
# `VTKXMLFileReader` class
######################################################################
class VTKXMLFileReader(FileDataSource):

    """A VTK XML file reader.  The reader supports all the different
    types of data sets.  This reader also supports a time series.
    Currently, this reader assumes that there is only one output that
    has configurable attributes.
    """

    # The version of this class.  Used for persistence.
    __version__ = 0

    ########################################
    # Dynamic traits: These traits are dynamic and are automatically
    # updated depending on the contents of the file.

    # The active point scalar name.  An empty string indicates that
    # the attribute is "deactivated".  This is useful when you have
    # both point and cell attributes and want to use cell data by
    # default.
    point_scalars_name = DEnum(values_name='_point_scalars_list',
                               desc='scalar point data attribute to use')
    # The active point vector name.
    point_vectors_name = DEnum(values_name='_point_vectors_list',
                               desc='vectors point data attribute to use')
    # The active point tensor name.
    point_tensors_name = DEnum(values_name='_point_tensors_list',
                               desc='tensor point data attribute to use')

    # The active cell scalar name.
    cell_scalars_name = DEnum(values_name='_cell_scalars_list',
                               desc='scalar cell data attribute to use')
    # The active cell vector name.
    cell_vectors_name = DEnum(values_name='_cell_vectors_list',
                               desc='vectors cell data attribute to use')
    # The active cell tensor name.
    cell_tensors_name = DEnum(values_name='_cell_tensors_list',
                               desc='tensor cell data attribute to use')
    ########################################

    # The VTK data file reader.
    reader = Instance(tvtk.XMLReader)

    # Information about what this object can produce.
    output_info = PipelineInfo(datasets=['any'],
                               attribute_types=['any'],
                               attributes=['any'])

    # Our view.
    view = View(Group(Include('time_step_group'),
                      Item(name='point_scalars_name'),
                      Item(name='point_vectors_name'),
                      Item(name='point_tensors_name'),
                      Item(name='cell_scalars_name'),
                      Item(name='cell_vectors_name'),
                      Item(name='cell_tensors_name'),
                      Item(name='reader'),
                      ))

    ########################################
    # Private traits.

    # These private traits store the list of available data
    # attributes.  The non-private traits use these lists internally.
    _point_scalars_list = List(Str)
    _point_vectors_list = List(Str)
    _point_tensors_list = List(Str)
    _cell_scalars_list = List(Str)
    _cell_vectors_list = List(Str)
    _cell_tensors_list = List(Str)

    # This filter allows us to change the attributes of the data
    # object and will ensure that the pipeline is properly taken care
    # of.  Directly setting the array in the VTK object will not do
    # this.
    _assign_attribute = Instance(tvtk.AssignAttribute, args=(),
                                 allow_none=False)

    # Toggles if this is the first time this object has been used.
    _first = Bool(True)

    ######################################################################
    # `object` interface
    ######################################################################
    def __get_pure_state__(self):
        d = super(VTKXMLFileReader, self).__get_pure_state__()
        for name in ('_assign_attribute', '_first'):
            d.pop(name, None)
        # Pickle the 'point_scalars_name' etc. since these are
        # properties and not in __dict__.
        attr = {}
        for name in ('point_scalars', 'point_vectors',
                     'point_tensors', 'cell_scalars',
                     'cell_vectors', 'cell_tensors'):
            d.pop('_' + name + '_list', None)
            d.pop('_' + name + '_name', None)
            x = name + '_name'
            attr[x] = getattr(self, x)
        d.update(attr)
        return d

    def __set_pure_state__(self, state):
        # The reader has its own file_name which needs to be fixed.
        state.reader.file_name = state.file_path.abs_pth
        # Now call the parent class to setup everything.
        super(VTKXMLFileReader, self).__set_pure_state__(state)

    ######################################################################
    # `Base` interface
    ######################################################################
    def start(self):
        """This is invoked when this object is added to the mayavi
        pipeline.
        """
        # Do nothing if we are already running.
        if self.running:
            return

        # Call the parent method to do its thing.  This will typically
        # start all our children.
        super(VTKXMLFileReader, self).start()

    def stop(self):
        """Invoked when this object is removed from the mayavi
        pipeline.
        """
        if not self.running:
            return

        # Call the parent method to do its thing.
        super(VTKXMLFileReader, self).stop()


    ######################################################################
    # `FileDataSource` interface
    ######################################################################
    def update(self):
        if len(self.file_path.get()) == 0:
            return
        reader = self.reader
        reader.update()
        self.render()

    def update_data(self):
        if len(self.file_path.get()) == 0:
            return
        self.reader.update()
        pnt_attr, cell_attr = get_all_attributes(self.reader.output)

        def _setup_data_traits(obj, attributes, d_type):
            """Given the object, the dict of the attributes from the
            `get_all_attributes` function and the data type
            (point/cell) data this will setup the object and the data.
            """
            attrs = ['scalars', 'vectors', 'tensors']
            aa = obj._assign_attribute
            data = getattr(obj.reader.output, '%s_data'%d_type)
            for attr in attrs:
                values = attributes[attr]
                values.append('')
                setattr(obj, '_%s_%s_list'%(d_type, attr), values)
                if len(values) > 1:
                    default = getattr(obj, '%s_%s_name'%(d_type, attr))
                    if obj._first and len(default) == 0:
                        default = values[0]
                    getattr(data, 'set_active_%s'%attr)(default)
                    aa.assign(default, attr.upper(),
                              d_type.upper() +'_DATA')
                    aa.update()
                    kw = {'%s_%s_name'%(d_type, attr): default,
                          'trait_change_notify': False}
                    obj.set(**kw)


        _setup_data_traits(self, cell_attr, 'cell')
        _setup_data_traits(self, pnt_attr, 'point')
        if self._first:
            self._first = False
        # Propagate the data changed event.
        self.data_changed = True

    def has_output_port(self):
        """ Return True as the reader has output port."""
        return True

    def get_output_object(self):
        """ Return the reader output port."""
        return self.reader.output_port

    ######################################################################
    # Non-public interface
    ######################################################################
    def _file_path_changed(self, fpath):
        value = fpath.get()
        if len(value) == 0:
            return
        else:
            if self.reader is None:
                d_type = find_file_data_type(fpath.get())
                self.reader = eval('tvtk.XML%sReader()'%d_type)
            reader = self.reader
            reader.file_name = value
            reader.update()

            # Setup the outputs by resetting self.outputs.  Changing
            # the outputs automatically fires a pipeline_changed
            # event.
            try:
                n = reader.number_of_outputs
            except AttributeError: # for VTK >= 4.5
                n = reader.number_of_output_ports
            outputs = []
            for i in range(n):
                outputs.append(reader.get_output(i))

            # FIXME: Only the first output goes through the assign
            # attribute filter.
            aa = self._assign_attribute
            self.configure_input_data(aa, outputs[0])
            outputs[0] = aa.output
            self.update_data()

            self.outputs = outputs

            # FIXME: The output info is only based on the first output.
            self.output_info.datasets = [get_tvtk_dataset_name(outputs[0])]

            # Change our name on the tree view
            self.name = self._get_name()

    def _set_data_name(self, data_type, attr_type, value):
        if value is None:
            return

        reader_output = self.reader.output
        if len(value) == 0:
            # If the value is empty then we deactivate that attribute.
            d = getattr(reader_output, attr_type + '_data')
            method = getattr(d, 'set_active_%s'%data_type)
            method(None)
            self.data_changed = True
            return

        aa = self._assign_attribute
        data = None
        if attr_type == 'point':
            data = reader_output.point_data
        elif attr_type == 'cell':
            data = reader_output.cell_data

        method = getattr(data, 'set_active_%s'%data_type)
        method(value)
        aa.assign(value, data_type.upper(), attr_type.upper() +'_DATA')
        aa.update()
        # Fire an event, so the changes propagate.
        self.data_changed = True

    def _point_scalars_name_changed(self, value):
        self._set_data_name('scalars', 'point', value)

    def _point_vectors_name_changed(self, value):
        self._set_data_name('vectors', 'point', value)

    def _point_tensors_name_changed(self, value):
        self._set_data_name('tensors', 'point', value)

    def _cell_scalars_name_changed(self, value):
        self._set_data_name('scalars', 'cell', value)

    def _cell_vectors_name_changed(self, value):
        self._set_data_name('vectors', 'cell', value)

    def _cell_tensors_name_changed(self, value):
        self._set_data_name('tensors', 'cell', value)

    def _get_name(self):
        """ Gets the name to display on the tree view.
        """
        fname = basename(self.file_path.get())
        ret = "VTK XML file (%s)"%fname
        if len(self.file_list) > 1:
            ret += " (timeseries)"
        if '[Hidden]' in self.name:
            ret += ' [Hidden]'

        return ret


########NEW FILE########
__FILENAME__ = common
"""
Common code for mayavi tests.

"""
# Author: Prabhu Ramachandran <prabhu@aero.iitb.ac.in>
# Copyright (c) 2008, Enthought, Inc.
# License: BSD Style.
import os.path

from traits.api import HasTraits, Any, Event, Callable

def fixpath(filename):
    """Given a relative file path it sets the path relative to this
    directory.  This allows us to run the tests from other directories
    as well.
    """
    return os.path.join(os.path.dirname(__file__), filename)


def get_example_data(fname):
    """Given a relative path to data inside the examples directory,
    obtains the full path to the file.
    """
    p = os.path.join('data', fname)
    return os.path.abspath(fixpath(p))


########NEW FILE########
__FILENAME__ = 11
{ 'array':

array([ (8.0, 2.0, 22.0, 97.0, 38.0, 15.0, 0.0, 40.0, 0.0, 75.0, 4.0, 5.0, 7.0, 78.0, 52.0, 12.0, 50.0, 77.0, 91.0, 8.0),
       (49.0, 49.0, 99.0, 40.0, 17.0, 81.0, 18.0, 57.0, 60.0, 87.0, 17.0, 40.0, 98.0, 43.0, 69.0, 48.0, 4.0, 56.0, 62.0, 0.0),
       (81.0, 49.0, 31.0, 73.0, 55.0, 79.0, 14.0, 29.0, 93.0, 71.0, 40.0, 67.0, 53.0, 88.0, 30.0, 3.0, 49.0, 13.0, 36.0, 65.0),
       (52.0, 70.0, 95.0, 23.0, 4.0, 60.0, 11.0, 42.0, 69.0, 24.0, 68.0, 56.0, 1.0, 32.0, 56.0, 71.0, 37.0, 2.0, 36.0, 91.0),
       (22.0, 31.0, 16.0, 71.0, 51.0, 67.0, 63.0, 89.0, 41.0, 92.0, 36.0, 54.0, 22.0, 40.0, 40.0, 28.0, 66.0, 33.0, 13.0, 80.0),
       (24.0, 47.0, 32.0, 60.0, 99.0, 3.0, 45.0, 2.0, 44.0, 75.0, 33.0, 53.0, 78.0, 36.0, 84.0, 20.0, 35.0, 17.0, 12.0, 50.0),
       (32.0, 98.0, 81.0, 28.0, 64.0, 23.0, 67.0, 10.0, 26.0, 38.0, 40.0, 67.0, 59.0, 54.0, 70.0, 66.0, 18.0, 38.0, 64.0, 70.0),
       (67.0, 26.0, 20.0, 68.0, 2.0, 62.0, 12.0, 20.0, 95.0, 63.0, 94.0, 39.0, 63.0, 8.0, 40.0, 91.0, 66.0, 49.0, 94.0, 21.0),
       (24.0, 55.0, 58.0, 5.0, 66.0, 73.0, 99.0, 26.0, 97.0, 17.0, 78.0, 78.0, 96.0, 83.0, 14.0, 88.0, 34.0, 89.0, 63.0, 72.0),
       (21.0, 36.0, 23.0, 9.0, 75.0, 0.0, 76.0, 44.0, 20.0, 45.0, 35.0, 14.0, 0.0, 61.0, 33.0, 97.0, 34.0, 31.0, 33.0, 95.0),
       (78.0, 17.0, 53.0, 28.0, 22.0, 75.0, 31.0, 67.0, 15.0, 94.0, 3.0, 80.0, 4.0, 62.0, 16.0, 14.0, 9.0, 53.0, 56.0, 92.0),
       (16.0, 39.0, 5.0, 42.0, 96.0, 35.0, 31.0, 47.0, 55.0, 58.0, 88.0, 24.0, 0.0, 17.0, 54.0, 24.0, 36.0, 29.0, 85.0, 57.0),
       (86.0, 56.0, 0.0, 48.0, 35.0, 71.0, 89.0, 7.0, 5.0, 44.0, 44.0, 37.0, 44.0, 60.0, 21.0, 58.0, 51.0, 54.0, 17.0, 58.0),
       (19.0, 80.0, 81.0, 68.0, 5.0, 94.0, 47.0, 69.0, 28.0, 73.0, 92.0, 13.0, 86.0, 52.0, 17.0, 77.0, 4.0, 89.0, 55.0, 40.0),
       (4.0, 52.0, 8.0, 83.0, 97.0, 35.0, 99.0, 16.0, 7.0, 97.0, 57.0, 32.0, 16.0, 26.0, 26.0, 79.0, 33.0, 27.0, 98.0, 66.0),
       (88.0, 36.0, 68.0, 87.0, 57.0, 62.0, 20.0, 72.0, 3.0, 46.0, 33.0, 67.0, 46.0, 55.0, 12.0, 32.0, 63.0, 93.0, 53.0, 69.0),
       (4.0, 42.0, 16.0, 73.0, 38.0, 25.0, 39.0, 11.0, 24.0, 94.0, 72.0, 18.0, 8.0, 46.0, 29.0, 32.0, 40.0, 62.0, 76.0, 36.0),
       (20.0, 69.0, 36.0, 41.0, 72.0, 30.0, 23.0, 88.0, 34.0, 62.0, 99.0, 69.0, 82.0, 67.0, 59.0, 85.0, 74.0, 4.0, 36.0, 16.0),
       (20.0, 73.0, 35.0, 29.0, 78.0, 31.0, 90.0, 1.0, 74.0, 31.0, 49.0, 71.0, 48.0, 86.0, 81.0, 16.0, 23.0, 57.0, 5.0, 54.0),
       (1.0, 70.0, 54.0, 71.0, 83.0, 51.0, 54.0, 69.0, 16.0, 92.0, 33.0, 48.0, 61.0, 43.0, 52.0, 1.0, 89.0, 19.0, 67.0, 48.0)],
      dtype=[('Column 1', float), ('Column 2', float), ('Column 3', float), ('Column 4', float), ('Column 5', float), ('Column 6', float), ('Column 7', float), ('Column 8', float), ('Column 9', float), ('Column 10', float), ('Column 11', float), ('Column 12', float), ('Column 13', float), ('Column 14', float), ('Column 15', float), ('Column 16', float), ('Column 17', float), ('Column 18', float), ('Column 19', float), ('Column 20', float)]),

  'kwds': { 'comments': '#',
            'delimiter': None,
            'dtype': { 'formats': 20 * (float,),
                       'names': ( 'Column 1',
                                  'Column 2',
                                  'Column 3',
                                  'Column 4',
                                  'Column 5',
                                  'Column 6',
                                  'Column 7',
                                  'Column 8',
                                  'Column 9',
                                  'Column 10',
                                  'Column 11',
                                  'Column 12',
                                  'Column 13',
                                  'Column 14',
                                  'Column 15',
                                  'Column 16',
                                  'Column 17',
                                  'Column 18',
                                  'Column 19',
                                  'Column 20')},
            'skiprows': 0
            }
  }

########NEW FILE########
__FILENAME__ = 1col
{ 'array': array([(5.552,),
                  (5.963,),
                  (6.135,),
                  (6.313,),
                  (6.713,)],
                 dtype=[('x-values', '<f8')]),

  'kwds': { 'comments': '#',
            'delimiter': None,
            'dtype': {'formats': (float,),
                      'names': ('x-values',)},
            'skiprows': 5
            }
  }

########NEW FILE########
__FILENAME__ = 54
{ 'array':

array([('8C', 'TS', 'KC', '9H', '4S', '7D', '2S', '5D', '3S', 'AC'),
       ('5C', 'AD', '5D', 'AC', '9C', '7C', '5H', '8D', 'TD', 'KS'),
       ('3H', '7H', '6S', 'KC', 'JS', 'QH', 'TD', 'JC', '2D', '8S'),
       ('TH', '8H', '5C', 'QS', 'TC', '9H', '4D', 'JC', 'KS', 'JS'),
       ('7C', '5H', 'KC', 'QH', 'JD', 'AS', 'KH', '4C', 'AD', '4S'),
       ('5H', 'KS', '9C', '7D', '9H', '8D', '3S', '5D', '5C', 'AH'),
       ('6H', '4H', '5C', '3H', '2H', '3S', 'QH', '5S', '6S', 'AS'),
       ('TD', '8C', '4H', '7C', 'TC', 'KC', '4C', '3H', '7S', 'KS'),
       ('7C', '9C', '6D', 'KD', '3H', '4C', 'QS', 'QC', 'AC', 'KH'),
       ('JC', '6S', '5H', '2H', '2D', 'KD', '9D', '7C', 'AS', 'JS'),
       ('AD', 'QH', 'TH', '9D', '8H', 'TS', '6D', '3S', 'AS', 'AC'),
       ('2H', '4S', '5C', '5S', 'TC', 'KC', 'JD', '6C', 'TS', '3C'),
       ('QD', 'AS', '6H', 'JS', '2C', '3D', '9H', 'KC', '4H', '8S'),
       ('KD', '8S', '9S', '7C', '2S', '3S', '6D', '6S', '4H', 'KC'),
       ('3C', '8C', '2D', '7D', '4D', '9S', '4S', 'QH', '4H', 'JD'),
       ('8C', 'KC', '7S', 'TC', '2D', 'TS', '8H', 'QD', 'AC', '5C'),
       ('3D', 'KH', 'QD', '6C', '6S', 'AD', 'AS', '8H', '2H', 'QS'),
       ('6S', '8D', '4C', '8S', '6C', 'QH', 'TC', '6D', '7D', '9D'),
       ('2S', '8D', '8C', '4C', 'TS', '9S', '9D', '9C', 'AC', '3D'),
       ('3C', 'QS', '2S', '4H', 'JH', '3D', '2D', 'TD', '8S', '9H'),
       ('5H', 'QS', '8S', '6D', '3C', '8C', 'JD', 'AS', '7H', '7D'),
       ('6H', 'TD', '9D', 'AS', 'JH', '6C', 'QC', '9S', 'KD', 'JC'),
       ('AH', '8S', 'QS', '4D', 'TH', 'AC', 'TS', '3C', '3D', '5C'),
       ('5S', '4D', 'JS', '3D', '8H', '6C', 'TS', '3S', 'AD', '8C'),
       ('6D', '7C', '5D', '5H', '3S', '5C', 'JC', '2H', '5S', '3D'),
       ('5H', '6H', '2S', 'KS', '3D', '5D', 'JD', '7H', 'JS', '8H'),
       ('KH', '4H', 'AS', 'JS', 'QS', 'QC', 'TC', '6D', '7C', 'KS'),
       ('3D', 'QS', 'TS', '2H', 'JS', '4D', 'AS', '9S', 'JC', 'KD'),
       ('QD', '5H', '4D', '5D', 'KH', '7H', '3D', 'JS', 'KD', '4H'),
       ('2C', '9H', '6H', '5C', '9D', '6C', 'JC', '2D', 'TH', '9S'),
       ('7D', '6D', 'AS', 'QD', 'JH', '4D', 'JS', '7C', 'QS', '5C'),
       ('3H', 'KH', 'QD', 'AD', '8C', '8H', '3S', 'TH', '9D', '5S'),
       ('AH', '9S', '4D', '9D', '8S', '4H', 'JS', '3C', 'TC', '8D'),
       ('2C', 'KS', '5H', 'QD', '3S', 'TS', '9H', 'AH', 'AD', '8S'),
       ('5C', '7H', '5D', 'KD', '9H', '4D', '3D', '2D', 'KS', 'AD'),
       ('KS', 'KC', '9S', '6D', '2C', 'QH', '9D', '9H', 'TS', 'TC'),
       ('9C', '6H', '5D', 'QH', '4D', 'AD', '6D', 'QC', 'JS', 'KH'),
       ('9S', '3H', '9D', 'JD', '5C', '4D', '9H', 'AS', 'TC', 'QH'),
       ('2C', '6D', 'JC', '9C', '3C', 'AD', '9S', 'KH', '9D', '7D'),
       ('KC', '9C', '7C', 'JC', 'JS', 'KD', '3H', 'AS', '3C', '7D')],
      dtype=[('Column 1', 'S2'), ('Column 2', 'S2'), ('Column 3', 'S2'),
             ('Column 4', 'S2'), ('Column 5', 'S2'), ('Column 6', 'S2'),
             ('Column 7', 'S2'), ('Column 8', 'S2'), ('Column 9', 'S2'),
             ('Column 10', 'S2')]),

  'kwds': { 'comments': '#',
            'delimiter': None,
            'dtype': { 'formats': 10 * ('S2',),
                       'names': ( 'Column 1',
                                  'Column 2',
                                  'Column 3',
                                  'Column 4',
                                  'Column 5',
                                  'Column 6',
                                  'Column 7',
                                  'Column 8',
                                  'Column 9',
                                  'Column 10')},
            'skiprows': 0
            }
  }

########NEW FILE########
__FILENAME__ = 79
{ 'array':

array([(319.0,), (680.0,), (180.0,), (690.0,), (129.0,), (620.0,),
       (762.0,), (689.0,), (762.0,), (318.0,), (368.0,), (710.0,),
       (720.0,), (710.0,), (629.0,), (168.0,), (160.0,), (689.0,),
       (716.0,), (731.0,), (736.0,), (729.0,), (316.0,), (729.0,),
       (729.0,), (710.0,), (769.0,), (290.0,), (719.0,), (680.0,),
       (318.0,), (389.0,), (162.0,), (289.0,), (162.0,), (718.0,),
       (729.0,), (319.0,), (790.0,), (680.0,), (890.0,), (362.0,),
       (319.0,), (760.0,), (316.0,), (729.0,), (380.0,), (319.0,),
       (728.0,), (716.0,)],
      dtype=[('Column 1', float)]),

  'kwds': { 'comments': '#',
            'delimiter': None,
            'dtype': { 'formats': (float,),
                       'names': ('Column 1',)},
            'skiprows': 0
            }
  }

########NEW FILE########
__FILENAME__ = 82
{ 'array':

array([ (4445.0, 2697.0, 5115.0, 718.0, 2209.0, 2212.0, 654.0, 4348.0, 3079.0, 6821.0, 7668.0, 3276.0, 8874.0, 4190.0, 3785.0, 2752.0, 9473.0, 7817.0, 9137.0, 496.0, 7338.0, 3434.0, 7152.0, 4355.0, 4552.0, 7917.0, 7827.0, 2460.0, 2350.0, 691.0, 3514.0, 5880.0, 3145.0, 7633.0, 7199.0, 3783.0, 5066.0, 7487.0, 3285.0, 1084.0, 8985.0, 760.0, 872.0, 8609.0, 8051.0, 1134.0, 9536.0, 5750.0, 9716.0, 9371.0, 7619.0, 5617.0, 275.0, 9721.0, 2997.0, 2698.0, 1887.0, 8825.0, 6372.0, 3014.0, 2113.0, 7122.0, 7050.0, 6775.0, 5948.0, 2758.0, 1219.0, 3539.0, 348.0, 7989.0, 2735.0, 9862.0, 1263.0, 8089.0, 6401.0, 9462.0, 3168.0, 2758.0, 3748.0, 5870.0),
       (1096.0, 20.0, 1318.0, 7586.0, 5167.0, 2642.0, 1443.0, 5741.0, 7621.0, 7030.0, 5526.0, 4244.0, 2348.0, 4641.0, 9827.0, 2448.0, 6918.0, 5883.0, 3737.0, 300.0, 7116.0, 6531.0, 567.0, 5997.0, 3971.0, 6623.0, 820.0, 6148.0, 3287.0, 1874.0, 7981.0, 8424.0, 7672.0, 7575.0, 6797.0, 6717.0, 1078.0, 5008.0, 4051.0, 8795.0, 5820.0, 346.0, 1851.0, 6463.0, 2117.0, 6058.0, 3407.0, 8211.0, 117.0, 4822.0, 1317.0, 4377.0, 4434.0, 5925.0, 8341.0, 4800.0, 1175.0, 4173.0, 690.0, 8978.0, 7470.0, 1295.0, 3799.0, 8724.0, 3509.0, 9849.0, 618.0, 3320.0, 7068.0, 9633.0, 2384.0, 7175.0, 544.0, 6583.0, 1908.0, 9983.0, 481.0, 4187.0, 9353.0, 9377.0),
       (9607.0, 7385.0, 521.0, 6084.0, 1364.0, 8983.0, 7623.0, 1585.0, 6935.0, 8551.0, 2574.0, 8267.0, 4781.0, 3834.0, 2764.0, 2084.0, 2669.0, 4656.0, 9343.0, 7709.0, 2203.0, 9328.0, 8004.0, 6192.0, 5856.0, 3555.0, 2260.0, 5118.0, 6504.0, 1839.0, 9227.0, 1259.0, 9451.0, 1388.0, 7909.0, 5733.0, 6968.0, 8519.0, 9973.0, 1663.0, 5315.0, 7571.0, 3035.0, 4325.0, 4283.0, 2304.0, 6438.0, 3815.0, 9213.0, 9806.0, 9536.0, 196.0, 5542.0, 6907.0, 2475.0, 1159.0, 5820.0, 9075.0, 9470.0, 2179.0, 9248.0, 1828.0, 4592.0, 9167.0, 3713.0, 4640.0, 47.0, 3637.0, 309.0, 7344.0, 6955.0, 346.0, 378.0, 9044.0, 8635.0, 7466.0, 5036.0, 9515.0, 6385.0, 9230.0),
       (7206.0, 3114.0, 7760.0, 1094.0, 6150.0, 5182.0, 7358.0, 7387.0, 4497.0, 955.0, 101.0, 1478.0, 7777.0, 6966.0, 7010.0, 8417.0, 6453.0, 4955.0, 3496.0, 107.0, 449.0, 8271.0, 131.0, 2948.0, 6185.0, 784.0, 5937.0, 8001.0, 6104.0, 8282.0, 4165.0, 3642.0, 710.0, 2390.0, 575.0, 715.0, 3089.0, 6964.0, 4217.0, 192.0, 5949.0, 7006.0, 715.0, 3328.0, 1152.0, 66.0, 8044.0, 4319.0, 1735.0, 146.0, 4818.0, 5456.0, 6451.0, 4113.0, 1063.0, 4781.0, 6799.0, 602.0, 1504.0, 6245.0, 6550.0, 1417.0, 1343.0, 2363.0, 3785.0, 5448.0, 4545.0, 9371.0, 5420.0, 5068.0, 4613.0, 4882.0, 4241.0, 5043.0, 7873.0, 8042.0, 8434.0, 3939.0, 9256.0, 2187.0),
       (3620.0, 8024.0, 577.0, 9997.0, 7377.0, 7682.0, 1314.0, 1158.0, 6282.0, 6310.0, 1896.0, 2509.0, 5436.0, 1732.0, 9480.0, 706.0, 496.0, 101.0, 6232.0, 7375.0, 2207.0, 2306.0, 110.0, 6772.0, 3433.0, 2878.0, 8140.0, 5933.0, 8688.0, 1399.0, 2210.0, 7332.0, 6172.0, 6403.0, 7333.0, 4044.0, 2291.0, 1790.0, 2446.0, 7390.0, 8698.0, 5723.0, 3678.0, 7104.0, 1825.0, 2040.0, 140.0, 3982.0, 4905.0, 4160.0, 2200.0, 5041.0, 2512.0, 1488.0, 2268.0, 1175.0, 7588.0, 8321.0, 8078.0, 7312.0, 977.0, 5257.0, 8465.0, 5068.0, 3453.0, 3096.0, 1651.0, 7906.0, 253.0, 9250.0, 6021.0, 8791.0, 8109.0, 6651.0, 3412.0, 345.0, 4778.0, 5152.0, 4883.0, 7505.0),
       (1074.0, 5438.0, 9008.0, 2679.0, 5397.0, 5429.0, 2652.0, 3403.0, 770.0, 9188.0, 4248.0, 2493.0, 4361.0, 8327.0, 9587.0, 707.0, 9525.0, 5913.0, 93.0, 1899.0, 328.0, 2876.0, 3604.0, 673.0, 8576.0, 6908.0, 7659.0, 2544.0, 3359.0, 3883.0, 5273.0, 6587.0, 3065.0, 1749.0, 3223.0, 604.0, 9925.0, 6941.0, 2823.0, 8767.0, 7039.0, 3290.0, 3214.0, 1787.0, 7904.0, 3421.0, 7137.0, 9560.0, 8451.0, 2669.0, 9219.0, 6332.0, 1576.0, 5477.0, 6755.0, 8348.0, 4164.0, 4307.0, 2984.0, 4012.0, 6629.0, 1044.0, 2874.0, 6541.0, 4942.0, 903.0, 1404.0, 9125.0, 5160.0, 8836.0, 4345.0, 2581.0, 460.0, 8438.0, 1538.0, 5507.0, 668.0, 3352.0, 2678.0, 6942.0),
       (4295.0, 1176.0, 5596.0, 1521.0, 3061.0, 9868.0, 7037.0, 7129.0, 8933.0, 6659.0, 5947.0, 5063.0, 3653.0, 9447.0, 9245.0, 2679.0, 767.0, 714.0, 116.0, 8558.0, 163.0, 3927.0, 8779.0, 158.0, 5093.0, 2447.0, 5782.0, 3967.0, 1716.0, 931.0, 7772.0, 8164.0, 1117.0, 9244.0, 5783.0, 7776.0, 3846.0, 8862.0, 6014.0, 2330.0, 6947.0, 1777.0, 3112.0, 6008.0, 3491.0, 1906.0, 5952.0, 314.0, 4602.0, 8994.0, 5919.0, 9214.0, 3995.0, 5026.0, 7688.0, 6809.0, 5003.0, 3128.0, 2509.0, 7477.0, 110.0, 8971.0, 3982.0, 8539.0, 2980.0, 4689.0, 6343.0, 5411.0, 2992.0, 5270.0, 5247.0, 9260.0, 2269.0, 7474.0, 1042.0, 7162.0, 5206.0, 1232.0, 4556.0, 4757.0),
       (510.0, 3556.0, 5377.0, 1406.0, 5721.0, 4946.0, 2635.0, 7847.0, 4251.0, 8293.0, 8281.0, 6351.0, 4912.0, 287.0, 2870.0, 3380.0, 3948.0, 5322.0, 3840.0, 4738.0, 9563.0, 1906.0, 6298.0, 3234.0, 8959.0, 1562.0, 6297.0, 8835.0, 7861.0, 239.0, 6618.0, 1322.0, 2553.0, 2213.0, 5053.0, 5446.0, 4402.0, 6500.0, 5182.0, 8585.0, 6900.0, 5756.0, 9661.0, 903.0, 5186.0, 7687.0, 5998.0, 7997.0, 8081.0, 8955.0, 4835.0, 6069.0, 2621.0, 1581.0, 732.0, 9564.0, 1082.0, 1853.0, 5442.0, 1342.0, 520.0, 1737.0, 3703.0, 5321.0, 4793.0, 2776.0, 1508.0, 1647.0, 9101.0, 2499.0, 6891.0, 4336.0, 7012.0, 3329.0, 3212.0, 1442.0, 9993.0, 3988.0, 4930.0, 7706.0),
       (9444.0, 3401.0, 5891.0, 9716.0, 1228.0, 7107.0, 109.0, 3563.0, 2700.0, 6161.0, 5039.0, 4992.0, 2242.0, 8541.0, 7372.0, 2067.0, 1294.0, 3058.0, 1306.0, 320.0, 8881.0, 5756.0, 9326.0, 411.0, 8650.0, 8824.0, 5495.0, 8282.0, 8397.0, 2000.0, 1228.0, 7817.0, 2099.0, 6473.0, 3571.0, 5994.0, 4447.0, 1299.0, 5991.0, 543.0, 7874.0, 2297.0, 1651.0, 101.0, 2093.0, 3463.0, 9189.0, 6872.0, 6118.0, 872.0, 1008.0, 1779.0, 2805.0, 9084.0, 4048.0, 2123.0, 5877.0, 55.0, 3075.0, 1737.0, 9459.0, 4535.0, 6453.0, 3644.0, 108.0, 5982.0, 4437.0, 5213.0, 1340.0, 6967.0, 9943.0, 5815.0, 669.0, 8074.0, 1838.0, 6979.0, 9132.0, 9315.0, 715.0, 5048.0),
       (3327.0, 4030.0, 7177.0, 6336.0, 9933.0, 5296.0, 2621.0, 4785.0, 2755.0, 4832.0, 2512.0, 2118.0, 2244.0, 4407.0, 2170.0, 499.0, 7532.0, 9742.0, 5051.0, 7687.0, 970.0, 6924.0, 3527.0, 4694.0, 5145.0, 1306.0, 2165.0, 5940.0, 2425.0, 8910.0, 3513.0, 1909.0, 6983.0, 346.0, 6377.0, 4304.0, 9330.0, 7203.0, 6605.0, 3709.0, 3346.0, 970.0, 369.0, 9737.0, 5811.0, 4427.0, 9939.0, 3693.0, 8436.0, 5566.0, 1977.0, 3728.0, 2399.0, 3985.0, 8303.0, 2492.0, 5366.0, 9802.0, 9193.0, 7296.0, 1033.0, 5060.0, 9144.0, 2766.0, 1151.0, 7629.0, 5169.0, 5995.0, 58.0, 7619.0, 7565.0, 4208.0, 1713.0, 6279.0, 3209.0, 4908.0, 9224.0, 7409.0, 1325.0, 8540.0),
       (6882.0, 1265.0, 1775.0, 3648.0, 4690.0, 959.0, 5837.0, 4520.0, 5394.0, 1378.0, 9485.0, 1360.0, 4018.0, 578.0, 9174.0, 2932.0, 9890.0, 3696.0, 116.0, 1723.0, 1178.0, 9355.0, 7063.0, 1594.0, 1918.0, 8574.0, 7594.0, 7942.0, 1547.0, 6166.0, 7888.0, 354.0, 6932.0, 4651.0, 1010.0, 7759.0, 6905.0, 661.0, 7689.0, 6092.0, 9292.0, 3845.0, 9605.0, 8443.0, 443.0, 8275.0, 5163.0, 7720.0, 7265.0, 6356.0, 7779.0, 1798.0, 1754.0, 5225.0, 6661.0, 1180.0, 8024.0, 5666.0, 88.0, 9153.0, 1840.0, 3508.0, 1193.0, 4445.0, 2648.0, 3538.0, 6243.0, 6375.0, 8107.0, 5902.0, 5423.0, 2520.0, 1122.0, 5015.0, 6113.0, 8859.0, 9370.0, 966.0, 8673.0, 2442.0),
       (7338.0, 3423.0, 4723.0, 6533.0, 848.0, 8041.0, 7921.0, 8277.0, 4094.0, 5368.0, 7252.0, 8852.0, 9166.0, 2250.0, 2801.0, 6125.0, 8093.0, 5738.0, 4038.0, 9808.0, 7359.0, 9494.0, 601.0, 9116.0, 4946.0, 2702.0, 5573.0, 2921.0, 9862.0, 1462.0, 1269.0, 2410.0, 4171.0, 2709.0, 7508.0, 6241.0, 7522.0, 615.0, 2407.0, 8200.0, 4189.0, 5492.0, 5649.0, 7353.0, 2590.0, 5203.0, 4274.0, 710.0, 7329.0, 9063.0, 956.0, 8371.0, 3722.0, 4253.0, 4785.0, 1194.0, 4828.0, 4717.0, 4548.0, 940.0, 983.0, 2575.0, 4511.0, 2938.0, 1827.0, 2027.0, 2700.0, 1236.0, 841.0, 5760.0, 1680.0, 6260.0, 2373.0, 3851.0, 1841.0, 4968.0, 1172.0, 5179.0, 7175.0, 3509.0),
       (4420.0, 1327.0, 3560.0, 2376.0, 6260.0, 2988.0, 9537.0, 4064.0, 4829.0, 8872.0, 9598.0, 3228.0, 1792.0, 7118.0, 9962.0, 9336.0, 4368.0, 9189.0, 6857.0, 1829.0, 9863.0, 6287.0, 7303.0, 7769.0, 2707.0, 8257.0, 2391.0, 2009.0, 3975.0, 4993.0, 3068.0, 9835.0, 3427.0, 341.0, 8412.0, 2134.0, 4034.0, 8511.0, 6421.0, 3041.0, 9012.0, 2983.0, 7289.0, 100.0, 1355.0, 7904.0, 9186.0, 6920.0, 5856.0, 2008.0, 6545.0, 8331.0, 3655.0, 5011.0, 839.0, 8041.0, 9255.0, 6524.0, 3862.0, 8788.0, 62.0, 7455.0, 3513.0, 5003.0, 8413.0, 3918.0, 2076.0, 7960.0, 6108.0, 3638.0, 6999.0, 3436.0, 1441.0, 4858.0, 4181.0, 1866.0, 8731.0, 7745.0, 3744.0, 1000.0),
       (356.0, 8296.0, 8325.0, 1058.0, 1277.0, 4743.0, 3850.0, 2388.0, 6079.0, 6462.0, 2815.0, 5620.0, 8495.0, 5378.0, 75.0, 4324.0, 3441.0, 9870.0, 1113.0, 165.0, 1544.0, 1179.0, 2834.0, 562.0, 6176.0, 2313.0, 6836.0, 8839.0, 2986.0, 9454.0, 5199.0, 6888.0, 1927.0, 5866.0, 8760.0, 320.0, 1792.0, 8296.0, 7898.0, 6121.0, 7241.0, 5886.0, 5814.0, 2815.0, 8336.0, 1576.0, 4314.0, 3109.0, 2572.0, 6011.0, 2086.0, 9061.0, 9403.0, 3947.0, 5487.0, 9731.0, 7281.0, 3159.0, 1819.0, 1334.0, 3181.0, 5844.0, 5114.0, 9898.0, 4634.0, 2531.0, 4412.0, 6430.0, 4262.0, 8482.0, 4546.0, 4555.0, 6804.0, 2607.0, 9421.0, 686.0, 8649.0, 8860.0, 7794.0, 6672.0),
       (9870.0, 152.0, 1558.0, 4963.0, 8750.0, 4754.0, 6521.0, 6256.0, 8818.0, 5208.0, 5691.0, 9659.0, 8377.0, 9725.0, 5050.0, 5343.0, 2539.0, 6101.0, 1844.0, 9700.0, 7750.0, 8114.0, 5357.0, 3001.0, 8830.0, 4438.0, 199.0, 9545.0, 8496.0, 43.0, 2078.0, 327.0, 9397.0, 106.0, 6090.0, 8181.0, 8646.0, 6414.0, 7499.0, 5450.0, 4850.0, 6273.0, 5014.0, 4131.0, 7639.0, 3913.0, 6571.0, 8534.0, 9703.0, 4391.0, 7618.0, 445.0, 1320.0, 5.0, 1894.0, 6771.0, 7383.0, 9191.0, 4708.0, 9706.0, 6939.0, 7937.0, 8726.0, 9382.0, 5216.0, 3685.0, 2247.0, 9029.0, 8154.0, 1738.0, 9984.0, 2626.0, 9438.0, 4167.0, 6351.0, 5060.0, 29.0, 1218.0, 1239.0, 4785.0),
       (192.0, 5213.0, 8297.0, 8974.0, 4032.0, 6966.0, 5717.0, 1179.0, 6523.0, 4679.0, 9513.0, 1481.0, 3041.0, 5355.0, 9303.0, 9154.0, 1389.0, 8702.0, 6589.0, 7818.0, 6336.0, 3539.0, 5538.0, 3094.0, 6646.0, 6702.0, 6266.0, 2759.0, 4608.0, 4452.0, 617.0, 9406.0, 8064.0, 6379.0, 444.0, 5602.0, 4950.0, 1810.0, 8391.0, 1536.0, 316.0, 8714.0, 1178.0, 5182.0, 5863.0, 5110.0, 5372.0, 4954.0, 1978.0, 2971.0, 5680.0, 4863.0, 2255.0, 4630.0, 5723.0, 2168.0, 538.0, 1692.0, 1319.0, 7540.0, 440.0, 6430.0, 6266.0, 7712.0, 7385.0, 5702.0, 620.0, 641.0, 3136.0, 7350.0, 1478.0, 3155.0, 2820.0, 9109.0, 6261.0, 1122.0, 4470.0, 14.0, 8493.0, 2095.0),
       (1046.0, 4301.0, 6082.0, 474.0, 4974.0, 7822.0, 2102.0, 5161.0, 5172.0, 6946.0, 8074.0, 9716.0, 6586.0, 9962.0, 9749.0, 5015.0, 2217.0, 995.0, 5388.0, 4402.0, 7652.0, 6399.0, 6539.0, 1349.0, 8101.0, 3677.0, 1328.0, 9612.0, 7922.0, 2879.0, 231.0, 5887.0, 2655.0, 508.0, 4357.0, 4964.0, 3554.0, 5930.0, 6236.0, 7384.0, 4614.0, 280.0, 3093.0, 9600.0, 2110.0, 7863.0, 2631.0, 6626.0, 6620.0, 68.0, 1311.0, 7198.0, 7561.0, 1768.0, 5139.0, 1431.0, 221.0, 230.0, 2940.0, 968.0, 5283.0, 6517.0, 2146.0, 1646.0, 869.0, 9402.0, 7068.0, 8645.0, 7058.0, 1765.0, 9690.0, 4152.0, 2926.0, 9504.0, 2939.0, 7504.0, 6074.0, 2944.0, 6470.0, 7859.0),
       (4659.0, 736.0, 4951.0, 9344.0, 1927.0, 6271.0, 8837.0, 8711.0, 3241.0, 6579.0, 7660.0, 5499.0, 5616.0, 3743.0, 5801.0, 4682.0, 9748.0, 8796.0, 779.0, 1833.0, 4549.0, 8138.0, 4026.0, 775.0, 4170.0, 2432.0, 4174.0, 3741.0, 7540.0, 8017.0, 2833.0, 4027.0, 396.0, 811.0, 2871.0, 1150.0, 9809.0, 2719.0, 9199.0, 8504.0, 1224.0, 540.0, 2051.0, 3519.0, 7982.0, 7367.0, 2761.0, 308.0, 3358.0, 6505.0, 2050.0, 4836.0, 5090.0, 7864.0, 805.0, 2566.0, 2409.0, 6876.0, 3361.0, 8622.0, 5572.0, 5895.0, 3280.0, 441.0, 7893.0, 8105.0, 1634.0, 2929.0, 274.0, 3926.0, 7786.0, 6123.0, 8233.0, 9921.0, 2674.0, 5340.0, 1445.0, 203.0, 4585.0, 3837.0),
       (5759.0, 338.0, 7444.0, 7968.0, 7742.0, 3755.0, 1591.0, 4839.0, 1705.0, 650.0, 7061.0, 2461.0, 9230.0, 9391.0, 9373.0, 2413.0, 1213.0, 431.0, 7801.0, 4994.0, 2380.0, 2703.0, 6161.0, 6878.0, 8331.0, 2538.0, 6093.0, 1275.0, 5065.0, 5062.0, 2839.0, 582.0, 1014.0, 8109.0, 3525.0, 1544.0, 1569.0, 8622.0, 7944.0, 2905.0, 6120.0, 1564.0, 1839.0, 5570.0, 7579.0, 1318.0, 2677.0, 5257.0, 4418.0, 5601.0, 7935.0, 7656.0, 5192.0, 1864.0, 5886.0, 6083.0, 5580.0, 6202.0, 8869.0, 1636.0, 7907.0, 4759.0, 9082.0, 5854.0, 3185.0, 7631.0, 6854.0, 5872.0, 5632.0, 5280.0, 1431.0, 2077.0, 9717.0, 7431.0, 4256.0, 8261.0, 9680.0, 4487.0, 4752.0, 4286.0),
       (1571.0, 1428.0, 8599.0, 1230.0, 7772.0, 4221.0, 8523.0, 9049.0, 4042.0, 8726.0, 7567.0, 6736.0, 9033.0, 2104.0, 4879.0, 4967.0, 6334.0, 6716.0, 3994.0, 1269.0, 8995.0, 6539.0, 3610.0, 7667.0, 6560.0, 6065.0, 874.0, 848.0, 4597.0, 1711.0, 7161.0, 4811.0, 6734.0, 5723.0, 6356.0, 6026.0, 9183.0, 2586.0, 5636.0, 1092.0, 7779.0, 7923.0, 8747.0, 6887.0, 7505.0, 9909.0, 1792.0, 3233.0, 4526.0, 3176.0, 1508.0, 8043.0, 720.0, 5212.0, 6046.0, 4988.0, 709.0, 5277.0, 8256.0, 3642.0, 1391.0, 5803.0, 1468.0, 2145.0, 3970.0, 6301.0, 7767.0, 2359.0, 8487.0, 9771.0, 8785.0, 7520.0, 856.0, 1605.0, 8972.0, 2402.0, 2386.0, 991.0, 1383.0, 5963.0)],
      dtype=[('Column 1', float), ('Column 2', float), ('Column 3', float), ('Column 4', float), ('Column 5', float), ('Column 6', float), ('Column 7', float), ('Column 8', float), ('Column 9', float), ('Column 10', float), ('Column 11', float), ('Column 12', float), ('Column 13', float), ('Column 14', float), ('Column 15', float), ('Column 16', float), ('Column 17', float), ('Column 18', float), ('Column 19', float), ('Column 20', float), ('Column 21', float), ('Column 22', float), ('Column 23', float), ('Column 24', float), ('Column 25', float), ('Column 26', float), ('Column 27', float), ('Column 28', float), ('Column 29', float), ('Column 30', float), ('Column 31', float), ('Column 32', float), ('Column 33', float), ('Column 34', float), ('Column 35', float), ('Column 36', float), ('Column 37', float), ('Column 38', float), ('Column 39', float), ('Column 40', float), ('Column 41', float), ('Column 42', float), ('Column 43', float), ('Column 44', float), ('Column 45', float), ('Column 46', float), ('Column 47', float), ('Column 48', float), ('Column 49', float), ('Column 50', float), ('Column 51', float), ('Column 52', float), ('Column 53', float), ('Column 54', float), ('Column 55', float), ('Column 56', float), ('Column 57', float), ('Column 58', float), ('Column 59', float), ('Column 60', float), ('Column 61', float), ('Column 62', float), ('Column 63', float), ('Column 64', float), ('Column 65', float), ('Column 66', float), ('Column 67', float), ('Column 68', float), ('Column 69', float), ('Column 70', float), ('Column 71', float), ('Column 72', float), ('Column 73', float), ('Column 74', float), ('Column 75', float), ('Column 76', float), ('Column 77', float), ('Column 78', float), ('Column 79', float), ('Column 80', float)]),
  'kwds': { 'comments': '#',
            'delimiter': ',',
            'dtype': { 'formats': 80 * (float,),
                       'names': ( 'Column 1',
                                  'Column 2',
                                  'Column 3',
                                  'Column 4',
                                  'Column 5',
                                  'Column 6',
                                  'Column 7',
                                  'Column 8',
                                  'Column 9',
                                  'Column 10',
                                  'Column 11',
                                  'Column 12',
                                  'Column 13',
                                  'Column 14',
                                  'Column 15',
                                  'Column 16',
                                  'Column 17',
                                  'Column 18',
                                  'Column 19',
                                  'Column 20',
                                  'Column 21',
                                  'Column 22',
                                  'Column 23',
                                  'Column 24',
                                  'Column 25',
                                  'Column 26',
                                  'Column 27',
                                  'Column 28',
                                  'Column 29',
                                  'Column 30',
                                  'Column 31',
                                  'Column 32',
                                  'Column 33',
                                  'Column 34',
                                  'Column 35',
                                  'Column 36',
                                  'Column 37',
                                  'Column 38',
                                  'Column 39',
                                  'Column 40',
                                  'Column 41',
                                  'Column 42',
                                  'Column 43',
                                  'Column 44',
                                  'Column 45',
                                  'Column 46',
                                  'Column 47',
                                  'Column 48',
                                  'Column 49',
                                  'Column 50',
                                  'Column 51',
                                  'Column 52',
                                  'Column 53',
                                  'Column 54',
                                  'Column 55',
                                  'Column 56',
                                  'Column 57',
                                  'Column 58',
                                  'Column 59',
                                  'Column 60',
                                  'Column 61',
                                  'Column 62',
                                  'Column 63',
                                  'Column 64',
                                  'Column 65',
                                  'Column 66',
                                  'Column 67',
                                  'Column 68',
                                  'Column 69',
                                  'Column 70',
                                  'Column 71',
                                  'Column 72',
                                  'Column 73',
                                  'Column 74',
                                  'Column 75',
                                  'Column 76',
                                  'Column 77',
                                  'Column 78',
                                  'Column 79',
                                  'Column 80')},
            'skiprows': 0
            }
  }

########NEW FILE########
__FILENAME__ = 89
{ 'array':

array([('MMMMDCLXXII',), ('MMDCCCLXXXIII',), ('MMMDLXVIIII',),
       ('MMMMDXCV',), ('DCCCLXXII',), ('MMCCCVI',), ('MMMCDLXXXVII',),
       ('MMMMCCXXI',), ('MMMCCXX',), ('MMMMDCCCLXXIII',), ('MMMCCXXXVII',),
       ('MMCCCLXXXXIX',), ('MDCCCXXIIII',), ('MMCXCVI',), ('CCXCVIII',),
       ('MMMCCCXXXII',), ('MDCCXXX',), ('MMMDCCCL',), ('MMMMCCLXXXVI',),
       ('MMDCCCXCVI',), ('MMMDCII',), ('MMMCCXII',), ('MMMMDCCCCI',),
       ('MMDCCCXCII',), ('MDCXX',)],
      dtype=[('Column 1', 'S14')]),

  'kwds': { 'comments': '#',
            'delimiter': None,
            'dtype': { 'formats': ('S14',),
                       'names': ('Column 1',)},
            'skiprows': 0
            }
  }

########NEW FILE########
__FILENAME__ = 99
{ 'array':

array([(519432.0, 525806.0), (632382.0, 518061.0), (78864.0, 613712.0),
       (466580.0, 530130.0), (780495.0, 510032.0), (525895.0, 525320.0),
       (15991.0, 714883.0), (960290.0, 502358.0), (760018.0, 511029.0),
       (166800.0, 575487.0), (210884.0, 564478.0), (555151.0, 523163.0),
       (681146.0, 515199.0), (563395.0, 522587.0), (738250.0, 512126.0),
       (923525.0, 503780.0), (595148.0, 520429.0), (177108.0, 572629.0),
       (750923.0, 511482.0), (440902.0, 532446.0), (881418.0, 505504.0),
       (422489.0, 534197.0), (979858.0, 501616.0), (685893.0, 514935.0),
       (747477.0, 511661.0), (167214.0, 575367.0), (234140.0, 559696.0),
       (940238.0, 503122.0), (728969.0, 512609.0), (232083.0, 560102.0),
       (900971.0, 504694.0), (688801.0, 514772.0), (189664.0, 569402.0),
       (891022.0, 505104.0), (445689.0, 531996.0), (119570.0, 591871.0),
       (821453.0, 508118.0), (371084.0, 539600.0), (911745.0, 504251.0),
       (623655.0, 518600.0), (144361.0, 582486.0), (352442.0, 541775.0),
       (420726.0, 534367.0), (295298.0, 549387.0), (6530.0, 787777.0),
       (468397.0, 529976.0), (672336.0, 515696.0), (431861.0, 533289.0),
       (84228.0, 610150.0), (805376.0, 508857.0), (444409.0, 532117.0),
       (33833.0, 663511.0), (381850.0, 538396.0), (402931.0, 536157.0),
       (92901.0, 604930.0), (304825.0, 548004.0), (731917.0, 512452.0),
       (753734.0, 511344.0), (51894.0, 637373.0), (151578.0, 580103.0),
       (295075.0, 549421.0), (303590.0, 548183.0), (333594.0, 544123.0),
       (683952.0, 515042.0), (60090.0, 628880.0), (951420.0, 502692.0),
       (28335.0, 674991.0), (714940.0, 513349.0), (343858.0, 542826.0),
       (549279.0, 523586.0), (804571.0, 508887.0), (260653.0, 554881.0),
       (291399.0, 549966.0), (402342.0, 536213.0), (408889.0, 535550.0),
       (40328.0, 652524.0), (375856.0, 539061.0), (768907.0, 510590.0),
       (165993.0, 575715.0), (976327.0, 501755.0), (898500.0, 504795.0),
       (360404.0, 540830.0), (478714.0, 529095.0), (694144.0, 514472.0),
       (488726.0, 528258.0), (841380.0, 507226.0), (328012.0, 544839.0),
       (22389.0, 690868.0), (604053.0, 519852.0), (329514.0, 544641.0),
       (772965.0, 510390.0), (492798.0, 527927.0), (30125.0, 670983.0),
       (895603.0, 504906.0), (450785.0, 531539.0), (840237.0, 507276.0),
       (380711.0, 538522.0), (63577.0, 625673.0), (76801.0, 615157.0),
       (502694.0, 527123.0), (597706.0, 520257.0), (310484.0, 547206.0),
       (944468.0, 502959.0), (121283.0, 591152.0), (451131.0, 531507.0),
       (566499.0, 522367.0), (425373.0, 533918.0), (40240.0, 652665.0),
       (39130.0, 654392.0), (714926.0, 513355.0), (469219.0, 529903.0),
       (806929.0, 508783.0), (287970.0, 550487.0), (92189.0, 605332.0),
       (103841.0, 599094.0), (671839.0, 515725.0), (452048.0, 531421.0),
       (987837.0, 501323.0), (935192.0, 503321.0), (88585.0, 607450.0),
       (613883.0, 519216.0), (144551.0, 582413.0), (647359.0, 517155.0),
       (213902.0, 563816.0), (184120.0, 570789.0), (258126.0, 555322.0),
       (502546.0, 527130.0), (407655.0, 535678.0), (401528.0, 536306.0),
       (477490.0, 529193.0), (841085.0, 507237.0), (732831.0, 512408.0),
       (833000.0, 507595.0), (904694.0, 504542.0), (581435.0, 521348.0),
       (455545.0, 531110.0), (873558.0, 505829.0), (94916.0, 603796.0),
       (720176.0, 513068.0), (545034.0, 523891.0), (246348.0, 557409.0),
       (556452.0, 523079.0), (832015.0, 507634.0), (173663.0, 573564.0),
       (502634.0, 527125.0), (250732.0, 556611.0), (569786.0, 522139.0),
       (216919.0, 563178.0), (521815.0, 525623.0), (92304.0, 605270.0),
       (164446.0, 576167.0), (753413.0, 511364.0), (11410.0, 740712.0),
       (448845.0, 531712.0), (925072.0, 503725.0), (564888.0, 522477.0),
       (7062.0, 780812.0), (641155.0, 517535.0), (738878.0, 512100.0),
       (636204.0, 517828.0), (372540.0, 539436.0), (443162.0, 532237.0),
       (571192.0, 522042.0), (655350.0, 516680.0), (299741.0, 548735.0),
       (581914.0, 521307.0), (965471.0, 502156.0), (513441.0, 526277.0),
       (808682.0, 508700.0), (237589.0, 559034.0), (543300.0, 524025.0),
       (804712.0, 508889.0), (247511.0, 557192.0), (543486.0, 524008.0),
       (504383.0, 526992.0), (326529.0, 545039.0), (792493.0, 509458.0),
       (86033.0, 609017.0), (126554.0, 589005.0), (579379.0, 521481.0),
       (948026.0, 502823.0), (404777.0, 535969.0), (265767.0, 554022.0),
       (266876.0, 553840.0), (46631.0, 643714.0), (492397.0, 527958.0),
       (856106.0, 506581.0), (795757.0, 509305.0), (748946.0, 511584.0),
       (294694.0, 549480.0), (409781.0, 535463.0), (775887.0, 510253.0),
       (543747.0, 523991.0), (210592.0, 564536.0), (517119.0, 525990.0),
       (520253.0, 525751.0), (247926.0, 557124.0), (592141.0, 520626.0),
       (346580.0, 542492.0), (61083.0, 627945.0)],
      dtype=[('Column 1', float), ('Column 2', float)]),

  'kwds': { 'comments': '#',
            'delimiter': ':',
            'dtype': { 'formats': (float, float),
                       'names': ('Column 1', 'Column 2')},
            'skiprows': 0
            }
  }

########NEW FILE########
__FILENAME__ = colors
{ 'array': array([('Red', 1.0, 0.0, 0.0),
                  ('Green', 0.0, 1.0, 0.0),
                  ('Blue', 0.0, 0.0, 1.0),
                  ('Orange', 1.0, 0.5, 0.0),
                  ('Yellow', 1.0, 1.0, 0.0)],
                 dtype=[('Name', 'S6'),
                        ('r', float),
                        ('g', float),
                        ('b', float)]),

  'kwds': { 'comments': '#',
            'delimiter': None,
            'dtype': { 'formats': ( 'S6',
                                    float,
                                    float,
                                    float),
                       'names': ( 'Name',
                                  'r',
                                  'g',
                                  'b')},
            'skiprows': 2
            }
  }

########NEW FILE########
__FILENAME__ = example1
{ 'array':

array([(860.0, 118.42, nan, 48.45, 0.826, 0.833, 0.37, 5.315, 2.31),
       (866.0, 113.095, 164.402, 56.001, 0.889, 0.887, 0.389, 4.56, 2.31),
       (866.401, 115.246, 167.797, 51.79, 0.894, 0.892, 0.399, 4.759, 2.311),
       (866.706, 113.4, 168.372, 52.785, 0.896, 0.894, 0.371, 5.126, 2.303),
       (868.0, 110.46, 156.958, 51.303, 0.874, 0.869, 0.387, 4.152, 2.304),
       (868.839, 108.602, 154.821, 51.899, 0.87, 0.868, 0.348, 3.982, 2.304),
       (869.0, 108.23, 153.518, 54.071, 0.872, 0.866, 0.353, 4.466, 2.309),
       (877.0, 113.778, 165.418, 50.192, 0.893, 0.876, 0.45, 4.448, 2.288),
       (877.678, 112.76, 163.119, 50.058, 0.886, 0.874, 0.379, 4.227, 2.331),
       (877.983, 113.192, 161.2, 51.314, 0.878, 0.872, 0.366, 4.418, 2.322),
       (878.0, 113.552, nan, 53.095, 0.873, 0.87, 0.337, 5.949, 2.275),
       (881.0, 111.854, 164.076, 49.643, 0.896, 0.869, 0.369, 6.319, 2.344),
       (892.0, 118.383, 168.926, 49.079, 0.874, 0.856, 0.415, 7.561, 2.174),
       (893.0, 117.862, 168.477, 50.563, 0.9, 0.883, 0.38, 6.46, 2.231),
       (895.0, 116.43, 167.802, 53.935, 1.02, 0.954, 0.447, 10.483, 2.184),
       (896.0, 111.619, 165.115, 49.258, 0.928, 0.913, 0.41, 6.377, 2.324),
       (896.576, 108.127, 160.44, 54.145, 0.724, 0.764, 0.352, 10.669, 2.289),
       (896.881, 107.312, 156.969, 57.37, 0.545, 0.622, 0.333, 19.721, 2.207),
       (897.0, 109.566, nan, 49.631, 0.518, 0.604, 0.31, 10.997, 2.232),
       (898.0, 112.73, nan, 46.016, 0.479, 0.546, 0.314, 9.892, 2.157)],
      dtype=[('depth', float),
             ('DT4P', float),
             ('DT4S', float),
             ('GR', float),
             ('ILD', float),
             ('ILM', float),
             ('NPHI', float),
             ('PEF', float),
             ('RHOB', float)]),

  'kwds': { 'comments': '#',
            'delimiter': ',',
            'dtype': { 'formats': 9 * (float,),
                       'names': ( 'depth',
                                  'DT4P',
                                  'DT4S',
                                  'GR',
                                  'ILD',
                                  'ILM',
                                  'NPHI',
                                  'PEF',
                                  'RHOB')},
            'skiprows': 4
            }
  }

########NEW FILE########
__FILENAME__ = hp11c
{ 'array': array([(5.552, 1.761),
                  (5.963, 1.775),
                  (6.135, 1.792),
                  (6.313, 1.884),
                  (6.713, 1.943)],
                 dtype=[('x', float), ('y', float)]),

  'kwds': { 'comments': '#',
            'delimiter': None,
            'dtype': { 'formats': (float, float),
                       'names': ('x', 'y')},
            'skiprows': 10
            }
  }

########NEW FILE########
__FILENAME__ = loc
{ 'array':

array([('2003-02-19', 1436.0, 0.0), ('2003-02-20', 1603.0, 114.0),
       ('2003-02-21', 2637.0, 401.0), ('2003-02-22', 2921.0, 121.0),
       ('2003-02-23', 3674.0, 969.0), ('2003-02-24', 3674.0, 969.0),
       ('2003-02-25', 3808.0, 998.0), ('2003-02-26', 3808.0, 998.0),
       ('2003-02-27', 3808.0, 998.0), ('2003-02-28', 3847.0, 1054.0),
       ('2003-03-01', 3854.0, 1056.0), ('2003-03-03', 3865.0, 1114.0),
       ('2003-03-04', 3865.0, 1116.0), ('2003-03-18', 3865.0, 1116.0),
       ('2003-04-06', 3865.0, 1116.0), ('2003-04-11', 3865.0, 1116.0),
       ('2003-04-18', 3892.0, 1221.0), ('2003-04-19', 3943.0, 1273.0),
       ('2003-05-22', 3943.0, 1273.0), ('2003-05-25', 3943.0, 1273.0),
       ('2003-05-26', 4239.0, 1414.0), ('2003-05-27', 4714.0, 1668.0),
       ('2003-05-28', 5603.0, 1847.0), ('2003-05-29', 5735.0, 1883.0),
       ('2003-05-30', 6515.0, 2380.0), ('2003-05-31', 6927.0, 2393.0),
       ('2003-06-01', 7144.0, 2396.0), ('2003-06-02', 7152.0, 2400.0),
       ('2003-06-05', 7195.0, 2400.0), ('2003-06-06', 7212.0, 2400.0),
       ('2003-06-07', 7215.0, 2400.0), ('2003-06-08', 7228.0, 2390.0),
       ('2003-06-09', 7230.0, 2390.0), ('2003-06-13', 7356.0, 2387.0),
       ('2003-06-14', 7436.0, 2387.0), ('2003-06-15', 7436.0, 2387.0),
       ('2003-06-16', 7558.0, 2411.0), ('2003-06-17', 7568.0, 2411.0),
       ('2003-06-18', 7708.0, 2465.0), ('2003-06-19', 7796.0, 2460.0),
       ('2003-06-20', 7794.0, 2467.0), ('2003-06-21', 7823.0, 2479.0),
       ('2003-06-22', 9536.0, 2608.0), ('2003-06-23', 10196.0, 3153.0),
       ('2003-06-24', 10675.0, 3428.0), ('2003-06-28', 11165.0, 3571.0),
       ('2003-06-29', 11173.0, 3579.0), ('2003-06-30', 11173.0, 3579.0),
       ('2003-07-01', 11336.0, 3597.0), ('2003-07-02', 11344.0, 3597.0),
       ('2003-07-03', 11344.0, 3597.0), ('2003-07-04', 11344.0, 3597.0),
       ('2003-07-06', 11354.0, 3597.0), ('2003-07-07', 11354.0, 3597.0),
       ('2003-07-08', 11544.0, 3621.0), ('2003-07-10', 11544.0, 3621.0),
       ('2003-07-12', 11544.0, 3621.0), ('2003-07-13', 11544.0, 3621.0),
       ('2003-07-14', 11617.0, 3625.0), ('2003-07-15', 11617.0, 3625.0),
       ('2003-07-16', 11617.0, 3625.0), ('2003-07-17', 11617.0, 3625.0),
       ('2003-07-18', 11617.0, 3625.0), ('2003-07-19', 11617.0, 3625.0),
       ('2003-07-24', 11617.0, 3625.0), ('2003-07-26', 11617.0, 3625.0),
       ('2003-07-27', 11617.0, 3625.0), ('2003-07-28', 11617.0, 3625.0),
       ('2003-07-29', 11617.0, 3625.0), ('2003-07-30', 11617.0, 3625.0),
       ('2003-07-31', 11617.0, 3625.0), ('2003-08-01', 11617.0, 3625.0),
       ('2003-08-02', 11617.0, 3625.0), ('2003-08-06', 11617.0, 3625.0),
       ('2003-08-07', 11617.0, 3625.0), ('2003-08-09', 11617.0, 3625.0),
       ('2003-08-10', 11617.0, 3625.0), ('2003-08-17', 11617.0, 3625.0),
       ('2003-08-24', 11617.0, 3625.0), ('2003-08-25', 11617.0, 3625.0),
       ('2003-09-02', 11617.0, 3625.0), ('2003-09-07', 11617.0, 3625.0),
       ('2003-09-08', 11617.0, 3625.0), ('2003-09-09', 11617.0, 3625.0),
       ('2003-09-10', 11617.0, 3625.0), ('2003-09-12', 11617.0, 3625.0),
       ('2003-09-13', 11617.0, 3625.0), ('2003-09-14', 11617.0, 3625.0),
       ('2003-09-15', 11617.0, 3625.0), ('2003-09-16', 11617.0, 3625.0),
       ('2003-09-17', 11617.0, 3625.0), ('2003-09-18', 11954.0, 3536.0),
       ('2003-09-19', 11976.0, 3541.0), ('2003-09-20', 11976.0, 3541.0),
       ('2003-09-21', 11976.0, 3541.0), ('2003-09-22', 11976.0, 3541.0),
       ('2003-09-23', 12024.0, 3671.0), ('2003-09-25', 12024.0, 3671.0),
       ('2003-09-26', 12024.0, 3671.0), ('2003-09-28', 12024.0, 3671.0),
       ('2003-09-29', 12024.0, 3677.0), ('2003-09-30', 12393.0, 3760.0),
       ('2003-10-01', 12900.0, 3965.0), ('2003-10-02', 13241.0, 4310.0),
       ('2003-10-03', 13241.0, 4310.0), ('2003-10-04', 13310.0, 4356.0),
       ('2003-10-05', 12443.0, 4223.0), ('2003-10-06', 12415.0, 4223.0),
       ('2003-10-07', 12415.0, 4223.0), ('2003-10-08', 12417.0, 4223.0),
       ('2003-10-09', 12417.0, 4223.0), ('2003-10-10', 12875.0, 4431.0),
       ('2003-10-11', 12884.0, 4452.0), ('2003-10-12', 12970.0, 4492.0),
       ('2003-10-13', 12984.0, 4492.0), ('2003-10-14', 12984.0, 4492.0),
       ('2003-10-15', 12974.0, 4492.0), ('2003-10-16', 13051.0, 4492.0),
       ('2003-10-17', 13094.0, 4521.0), ('2003-10-18', 13131.0, 4561.0),
       ('2003-10-20', 13131.0, 4561.0), ('2003-10-21', 13131.0, 4561.0),
       ('2003-10-23', 13147.0, 4570.0), ('2003-10-24', 13268.0, 4413.0),
       ('2003-10-25', 13276.0, 4416.0), ('2003-10-26', 13372.0, 4409.0),
       ('2003-10-27', 13641.0, 4403.0), ('2003-10-28', 13699.0, 4409.0),
       ('2003-10-29', 13850.0, 4419.0), ('2003-10-30', 13848.0, 4431.0),
       ('2003-10-31', 13854.0, 4431.0), ('2003-11-03', 13704.0, 4437.0),
       ('2003-11-04', 13704.0, 4437.0), ('2003-11-05', 13711.0, 4437.0),
       ('2003-11-10', 13711.0, 4437.0), ('2003-11-11', 13872.0, 4634.0),
       ('2003-11-13', 13872.0, 4634.0), ('2003-11-14', 13872.0, 4634.0),
       ('2003-11-17', 13872.0, 4634.0), ('2003-11-18', 13850.0, 4682.0),
       ('2003-11-19', 13954.0, 4508.0), ('2003-11-20', 14086.0, 4555.0),
       ('2003-11-21', 14226.0, 4565.0), ('2003-11-22', 14231.0, 4565.0),
       ('2003-11-24', 14170.0, 4620.0), ('2003-11-25', 14170.0, 4620.0),
       ('2003-11-26', 14120.0, 4624.0), ('2003-11-27', 14543.0, 4673.0),
       ('2003-11-28', 14546.0, 4673.0), ('2003-11-29', 14546.0, 4673.0),
       ('2003-11-30', 15350.0, 4695.0), ('2003-12-01', 15350.0, 4695.0),
       ('2003-12-02', 15350.0, 4695.0), ('2003-12-03', 15350.0, 4695.0),
       ('2003-12-04', 15350.0, 4695.0), ('2003-12-08', 15350.0, 4695.0),
       ('2003-12-09', 15352.0, 4695.0), ('2003-12-10', 15352.0, 4695.0),
       ('2003-12-11', 15352.0, 4695.0), ('2003-12-12', 15352.0, 4695.0),
       ('2003-12-13', 15352.0, 4695.0), ('2003-12-15', 15474.0, 4695.0),
       ('2003-12-16', 16321.0, 4701.0), ('2003-12-17', 17469.0, 4878.0),
       ('2003-12-18', 17793.0, 5121.0), ('2003-12-19', 19327.0, 5002.0),
       ('2003-12-20', 19795.0, 5058.0), ('2003-12-21', 20048.0, 5121.0)],
      dtype=[('date', 'S10'),
             ('lines of code', float),
             ('lines of testcode', float)]),

  'kwds': { 'comments': '#',
            'delimiter': ',',
            'dtype': { 'formats': ( 'S10',
                                    float,
                                    float),
                       'names': ( 'date',
                                  'lines of code',
                                  'lines of testcode')},
            'skiprows': 2
            }
  }

########NEW FILE########
__FILENAME__ = multi-col
{ 'array': array([ (5.552, 1.942, 1.761, 2.6, 6.8),
                   (5.963, 1.885, 1.775, 2.7, 6.9),
                   (6.135, 1.791, 1.792, 2.5, 6.6),
                   (6.313, 1.774, 1.884, 2.6, 6.6),
                   (6.713, 1.762, 1.943, 2.5, 6.7)],
                 dtype=[('Column 1', float),
                        ('Column 2', float),
                        ('Column 3', float),
                        ('Column 4', float),
                        ('Column 5', float)]),

  'kwds': { 'comments': '#',
            'delimiter': None,
            'dtype': { 'formats': ( float,
                                    float,
                                    float,
                                    float,
                                    float),
                       'names': ( 'Column 1',
                                  'Column 2',
                                  'Column 3',
                                  'Column 4',
                                  'Column 5')},
            'skiprows': 0
            }
  }

########NEW FILE########
__FILENAME__ = mydata
{ 'array':

array([('Foo', 12.5, 85.4),
       ('Bar', 14.1, 87.6),
       ('Baz', 14.3, 89.0)],
      dtype=[('Sample Name', 'S3'), ('Radius', float), ('Speed', float)]),

  'kwds': { 'comments': '%',
            'delimiter': ':',
            'dtype': { 'formats': ('S3', float, float),
                       'names': ('Sample Name', 'Radius', 'Speed')},
            'skiprows': 3
            }
  }

########NEW FILE########
__FILENAME__ = OObeta3
{ 'array': array([('05/23/93', 25.0, 12.43),
                  ('04/19/08', 18.0, 13.49)],
                 dtype=[('Date', 'S8'),
                        ('Temp.', float),
                        ('p (Gpa)', float)]),

  'kwds': { 'comments': '#',
            'delimiter': ',',
            'dtype': { 'formats': ( 'S8',
                                    float,
                                    float),
                       'names': ( 'Date',
                                  'Temp.',
                                  'p (Gpa)')},
            'skiprows': 1
            }
  }

########NEW FILE########
__FILENAME__ = post
{ 'array':

array([('2003-1', 371.0, 0.0), ('2003-2', 187.0, 0.0),
       ('2003-3', 76.0, 0.0), ('2003-4', 36.0, 0.0),
       ('2003-5', 32.0, 304.0), ('2003-6', 115.0, 301.0),
       ('2003-7', 101.0, 46.0), ('2003-8', 24.0, 7.0),
       ('2003-9', 115.0, 200.0), ('2003-10', 112.0, 579.0),
       ('2003-11', 49.0, 52.0), ('2003-12', 62.0, 380.0),
       ('2004-1', 49.0, 18.0), ('2004-2', 29.0, 5.0),
       ('2004-3', 13.0, 68.0), ('2004-4', 55.0, 200.0),
       ('2004-5', 24.0, 82.0), ('2004-6', 52.0, 332.0),
       ('2004-7', 80.0, 107.0), ('2004-8', 38.0, 23.0),
       ('2004-9', 23.0, 44.0), ('2004-10', 11.0, 14.0),
       ('2004-11', 79.0, 400.0), ('2004-12', 58.0, 77.0),
       ('2005-1', 71.0, 371.0), ('2005-2', 95.0, 358.0),
       ('2005-3', 54.0, 342.0), ('2005-4', 66.0, 472.0),
       ('2005-5', 108.0, 731.0), ('2005-6', 54.0, 732.0),
       ('2005-7', 71.0, 922.0), ('2005-8', 68.0, 1038.0),
       ('2005-9', 162.0, 559.0), ('2005-10', 109.0, 737.0),
       ('2005-11', 48.0, 451.0), ('2005-12', 66.0, 515.0),
       ('2006-1', 55.0, 514.0), ('2006-2', 33.0, 486.0),
       ('2006-3', 154.0, 540.0), ('2006-4', 138.0, 961.0),
       ('2006-5', 67.0, 609.0), ('2006-6', 38.0, 757.0),
       ('2006-7', 111.0, 687.0), ('2006-8', 60.0, 506.0),
       ('2006-9', 11.0, 436.0), ('2006-10', 27.0, 521.0),
       ('2006-11', 32.0, 659.0), ('2006-12', 57.0, 514.0),
       ('2007-1', 37.0, 742.0), ('2007-2', 58.0, 837.0),
       ('2007-3', 76.0, 1175.0)],
      dtype=[('number of posts', 'S7'),
             ('pypy-dev', float),
             ('pypy-svn', float)]),

  'kwds': { 'comments': '#',
            'delimiter': ',',
            'dtype': { 'formats': ( 'S7',
                                    float,
                                    float),
                       'names': ( 'number of posts',
                                  'pypy-dev',
                                  'pypy-svn')},
            'skiprows': 2
            }
  }

########NEW FILE########
__FILENAME__ = webaccess
{ 'array':

array([('2003-09-15', 10713.0), ('2003-10-15', 23482.0),
       ('2003-11-15', 8522.0), ('2003-12-15', 11776.0),
       ('2004-01-15', 6048.0), ('2004-02-15', 4196.0),
       ('2004-03-15', 3406.0), ('2004-04-15', 4475.0),
       ('2004-05-15', 5304.0), ('2004-06-15', 7551.0),
       ('2004-07-15', 4898.0), ('2004-08-15', 11499.0),
       ('2004-09-15', 7922.0), ('2004-10-15', 10261.0),
       ('2004-11-15', 11866.0), ('2004-12-15', 22312.0),
       ('2005-01-15', 10421.0), ('2005-02-15', 10564.0),
       ('2005-03-15', 13774.0), ('2005-04-15', 20336.0),
       ('2005-05-15', 26889.0), ('2005-06-15', 10080.0),
       ('2005-07-15', 13330.0), ('2005-08-15', 26420.0),
       ('2005-09-15', 27044.0), ('2005-10-15', 34789.0),
       ('2005-11-15', 34332.0), ('2005-12-15', 39317.0),
       ('2006-01-15', 41423.0), ('2006-02-15', 26403.0),
       ('2006-03-15', 34117.0), ('2006-04-15', 30342.0),
       ('2006-05-15', 36894.0), ('2006-06-15', 49460.0),
       ('2006-07-15', 31944.0)],
      dtype=[('data', 'S10'), ('number of visits', float)]),

  'kwds': { 'comments': '#',
            'delimiter': ',',
            'dtype': { 'formats': ('S10', float),
                       'names': ('data', 'number of visits')},
            'skiprows': 2
            }
  }

########NEW FILE########
__FILENAME__ = datasets
# Author: Suyog Dutt Jain <suyog.jain@aero.iitb.ac.in>
#         Prabhu Ramachandran <prabhu_r@users.sf.net>
# Copyright (c) 2008,  Enthought, Inc.
# License: BSD Style.

# Standard library imports.

import numpy
from numpy import linspace, cos, sin, pi, empty, sqrt,array,arange,random

# Enthought library imports
from tvtk.api import tvtk


def generate_annulus(r=None, theta=None, z=None):
    """ Generate points for structured grid for a cylindrical annular
        volume.  This method is useful for generating a unstructured
        cylindrical mesh for VTK (and perhaps other tools).

        Parameters
        ----------
        r : array : The radial values of the grid points.
                    It defaults to linspace(1.0, 2.0, 11).

        theta : array : The angular values of the x axis for the grid
                        points. It defaults to linspace(0,2*pi,11).

        z: array : The values along the z axis of the grid points.
                   It defaults to linspace(0,0,1.0, 11).

        Return
        ------
        points : array
            Nx3 array of points that make up the volume of the annulus.
            They are organized in planes starting with the first value
            of z and with the inside "ring" of the plane as the first
            set of points.  The default point array will be 1331x3.
    """
    # Default values for the annular grid.
    if r is None: r = linspace(1.0,2.0, 11)
    if theta is None: theta = linspace(0,2*pi,11)
    if z is None: z = linspace(0.0,1.0, 11)

    # Find the x values and y values for each plane.
    x_plane = (cos(theta)*r[:,None]).ravel()
    y_plane = (sin(theta)*r[:,None]).ravel()

    # Allocate an array for all the points.  We'll have len(x_plane)
    # points on each plane, and we have a plane for each z value, so
    # we need len(x_plane)*len(z) points.
    points = empty([len(x_plane)*len(z),3])

    # Loop through the points for each plane and fill them with the
    # correct x,y,z values.
    start = 0
    for z_plane in z:
        end = start+len(x_plane)
        # slice out a plane of the output points and fill it
        # with the x,y, and z values for this plane.  The x,y
        # values are the same for every plane.  The z value
        # is set to the current z
        plane_points = points[start:end]
        plane_points[:,0] = x_plane
        plane_points[:,1] = y_plane
        plane_points[:,2] = z_plane
        start = end

    return points


def single_type_ug():
    """Simple example showing how to create an unstructured grid
    consisting of cells of a single type.
    """
    points = array([[0,0,0], [1,0,0], [0,1,0], [0,0,1], # tets
                    [1,0,0], [2,0,0], [1,1,0], [1,0,1],
                    [2,0,0], [3,0,0], [2,1,0], [2,0,1],
                    ], 'f')
    tets = array([[0, 1, 2, 3], [4, 5, 6, 7], [8, 9, 10, 11]])
    tet_type = tvtk.Tetra().cell_type
    ug = tvtk.UnstructuredGrid(points=points)
    ug.set_cells(tet_type, tets)
    return ug

def mixed_type_ug():
    """A slightly more complex example of how to generate an
    unstructured grid with different cell types.  Returns a created
    unstructured grid.
    """
    points = array([[0,0,0], [1,0,0], [0,1,0], [0,0,1], # tetra
                    [2,0,0], [3,0,0], [3,1,0], [2,1,0],
                    [2,0,1], [3,0,1], [3,1,1], [2,1,1], # Hex
                    ], 'f')
    # shift the points so we can show both.
    points[:,1] += 2.0
    # The cells
    cells = array([4, 0, 1, 2, 3, # tetra
                   8, 4, 5, 6, 7, 8, 9, 10, 11 # hex
                   ])
    # The offsets for the cells, i.e. the indices where the cells
    # start.
    offset = array([0, 5])
    tetra_type = tvtk.Tetra().cell_type # VTK_TETRA == 10
    hex_type = tvtk.Hexahedron().cell_type # VTK_HEXAHEDRON == 12
    cell_types = array([tetra_type, hex_type])
    # Create the array of cells unambiguously.
    cell_array = tvtk.CellArray()
    cell_array.set_cells(2, cells)
    # Now create the UG.
    ug = tvtk.UnstructuredGrid(points=points)
    # Now just set the cell types and reuse the ug locations and cells.
    ug.set_cells(cell_types, offset, cell_array)
    return ug

def generateStructuredGrid():
    """Generates Structured Grid"""
    dims = (32, 32, 12)
    sgrid = tvtk.StructuredGrid(dimensions=(dims[1], dims[0], dims[2]))
    r = linspace(1, 10, dims[0])
    theta = linspace(0, 2*numpy.pi, dims[1])
    z = linspace(0, 5, dims[2])
    pts = generate_annulus(r, theta, z)
    sgrid.points = pts
    s = sqrt(pts[:,0]**2 + pts[:,1]**2 + pts[:,2]**2)
    sgrid.point_data.scalars = numpy.ravel(s.copy())
    sgrid.point_data.scalars.name = 'scalars'

    return sgrid

def generateUnstructuredGrid_single():
    """Generates Untructured Grid"""
    ug = single_type_ug()
    temperature = arange(0, 120, 10, 'd')
    velocity = random.randn(12, 3)
    ug.point_data.scalars = temperature
    ug.point_data.scalars.name = 'temperature'
    # Some vectors.
    ug.point_data.vectors = velocity
    ug.point_data.vectors.name = 'velocity'
    return ug

def generateUnstructuredGrid_mixed():
    """Generates Untructured Grid"""
    ug = mixed_type_ug()
    temperature = arange(0, 120, 10, 'd')
    velocity = random.randn(12, 3)
    ug.point_data.scalars = temperature
    ug.point_data.scalars.name = 'temperature'
    # Some vectors.
    ug.point_data.vectors = velocity
    ug.point_data.vectors.name = 'velocity'
    return ug


########NEW FILE########
__FILENAME__ = data_reader_test_base
# Author: Suyog Dutt Jain <suyog.jain@aero.iitb.ac.in>
# Copyright (c) 2009,  Enthought, Inc.
# License: BSD Style.

# Standard library imports.
from os.path import abspath
from StringIO import StringIO
import copy
import unittest
import numpy
from mayavi.core.null_engine import NullEngine
from mayavi.modules.outline import Outline

class DataReaderTestBase(unittest.TestCase):

    def setup_reader(self):

        """"Setup the reader in here.  This is called after the engine
        has been created and started.  The engine is available as
        self.e.  This method is called by setUp().
        """
        raise NotImplementedError()

    def setup_viz(self):
        """Setup the visualization."""
        # Create an outline for the data.
        o = Outline()
        self.e.add_module(o)

    def setUp(self):

        e = NullEngine()
        # Uncomment to see visualization for debugging etc.
        #e = Engine()
        e.start()
        self.e = e
        s = e.new_scene()
        self.scene = e.current_scene

        self.setup_reader()
        self.setup_viz()
        return

    def tearDown(self):
        """For necessary clean up, automatically called by TestCase after the test methods have been invoked"""
        self.e.stop()
        return

    def check(self, scene, bounds, error = 1.01e-02):
        """Do the actual testing."""

        src = scene.children[0]
        ot = src.children[0].children[0]
        ot.render() # Flush the pipeline.

        # Check the outline bounds
        got = ot.outline_filter.output.bounds
        msg = "Got: %s; expected: %s"%(got, bounds)
        self.assertEqual(numpy.allclose(got, bounds, atol=error), True, msg)

    def check_saving(self, engine, scene, bounds, error = 1.01e-02):

        # Save visualization.
        f = StringIO()
        f.name = abspath('test.mv2') # We simulate a file.
        engine.save_visualization(f)
        f.seek(0) # So we can read this saved data.

        # Remove existing scene.
        engine.close_scene(scene)

        # Load visualization
        engine.load_visualization(f)
        self.scene = engine.current_scene
        self.check(scene,bounds,error)

    def check_deepcopying(self, scene, bounds, error = 1.01e-02):
        """Test if the MayaVi2 visualization can be deep-copied."""
        ############################################################

        # Test if the MayaVi2 visualization can be deep-copied.

        # Pop the source object.
        source = scene.children.pop()
        # Add it back to see if that works without error.
        scene.children.append(source)
        self.check(scene, bounds, error)

        # Now deepcopy the source and replace the existing one with
        # the copy.  This basically simulates cutting/copying the
        # object from the UI via the right-click menu on the tree
        # view, and pasting the copy back.
        source1 = copy.deepcopy(source)
        scene.children[0] = source1
        self.check(scene, bounds, error)

########NEW FILE########
__FILENAME__ = runtests
#!/usr/bin/env python

"""Script to run all the tests each in its own subprocess to ensure
maximal correctness and minimal pain.  This does make running the tests
quite slow but the tests will be run correctly -- which is the important
thing.
"""

# Author: Prabhu Ramachandran <prabhu [at] aero . iitb . ac . in>
# Copyright (c) 2009,  Enthought Inc.
# License: BSD Style.

import sys
from os.path import dirname, join, isfile, isdir
from glob import glob
import subprocess
import time
import re
import optparse

# Use nosetests when it is available
USE_NOSE = False

def get_test_runner():
    """Get a test runner for the tests.  Uses nose if available."""
    result = [sys.executable]
    if USE_NOSE:
        try:
            import nose
        except ImportError:
            result = [sys.executable]
        else:
            result = ['nosetests']
    return result

def get_tests_in_dir(pth):
    """Get all tests in given directory `pth`."""
    files = []
    files.extend(glob(join(pth, 'test*.py')))
    files.extend(glob(join(pth, '*_test_case.py')))
    files.extend(glob(join(pth, 'test', 'test*.py')))
    files.extend(glob(join(pth, 'test', '*_test_case.py')))
    files.extend(glob(join(pth, 'tests', 'test*.py')))
    files.extend(glob(join(pth, 'tests', '*_test_case.py')))
    return files

def find_tests(tests):
    """Find test files given list of arguments which may be files,
    directories or modules."""
    files = []
    for test in tests:
        if isfile(test):
            files.append(test)
        elif isdir(test):
            files.extend(get_tests_in_dir(test))
        else:
            # A module.
            try:
                # Import the module
                components = test.split('.')
                modname = '.'.join(components[:-1])
                symbol = components[-1]
                mod = __import__(modname, globals(), locals(), [symbol])
                s = getattr(mod, symbol)
                d = dirname(s.__file__)
                files.extend(get_tests_in_dir(d))
            except ImportError:
                msg = 'Warning: %s is neither a file/directory or '\
                      'module. Ignoring.'%test
                print msg
    return files

def run(tests, verbose=1):
    """Run the given tests.  Each test file is run as a unittest in a
    subprocess.

    **Parameters**

     :tests: List of test file paths to run as tests.  These tests are
             best written as unittests.

     :verbose: An integer in (0, 1, 2).  0 specifies no output.  1
               specifies moderate output and 2 very verbose output.

    **Returns**

    The error code is returned.  If there are errors this is 1 if
    everything ran fine it returns 0.

    """
    PIPE = subprocess.PIPE
    errors = []
    total = 0
    tot_err = 0
    tot_fail = 0
    total_time = 0.0
    cmd_base = get_test_runner()
    has_nose = 'nosetests' in cmd_base
    for test in tests:
        if verbose > 1 and has_nose:
            cmd = cmd_base + ['-v', test]
        else:
            cmd = cmd_base + [test]

        # Run the test in a subprocess.
        if verbose > 1:
            print 'Running:', ' '.join(cmd)
        t1 = time.time()
        pipe = subprocess.Popen(cmd, stdout=PIPE, stderr=PIPE, close_fds=True)
        # Get the status, stdout and stderr.
        st = pipe.wait()
        t2 = time.time()
        out, err = pipe.communicate()

        # Calculate number of tests run, errors and failures based on output.
        res = re.search('Ran\s*(\d*)\s*test', err)
        nt = 1
        if res:
            nt = int(res.group(1))
        total += nt
        res = re.search('failures=(\d*)', err)
        nfail = 0
        if res:
            nfail = int(res.group(1))
        nerr = 0
        res = re.search('errors=(\d*)', err)
        if res:
            nerr = int(res.group(1))

        tot_err += nerr
        tot_fail += nfail

        # Print output catching any errors.
        if verbose > 0:
            nsuccess = nt - nerr - nfail
            res = '.'*nsuccess + 'F'*nfail + 'E'*nerr
            sys.stdout.write(res)
        if st != 0:
            errors.append([test, st, out, err, t2 - t1])

        if verbose > 1:
            print out
            print err
        sys.stdout.flush()
        total_time += t2 - t1

    print '\n' + '-'*70
    print "Ran %d tests in %.4g seconds\n"%(total, total_time)

    errorcode = 0
    if len(errors) > 0:
        print 'FAILED: there were %d failures and %d errors'\
                %(tot_fail, tot_err)
        for err in errors:
            test, st, out, err, t = err
            print 'File:', test
            print out
            print err
        errorcode = 1
    else:
        print 'OK'
    return errorcode

def m2_tests(verbose=1):
    """Run all the TVTK and mayavi tests.
    """
    if verbose > 0:
        print "-"*70
        print "Running TVTK tests."
    tests = find_tests(['tvtk'])
    err = run(tests, verbose)
    if verbose > 0:
        print "-"*70
        print "Running Mayavi tests."
    tests = find_tests(['mayavi'])
    err += run(tests, verbose)
    return err

def main():
    usage = """%prog [options] directories/files/modules

    This program runs any tests in the given files and directories and
    also scans a module's directory for directories called 'tests' or
    'test' which contain 'test_*.py' files and runs them each in a
    separate subprocess.

    """
    parser = optparse.OptionParser(usage)
    parser.add_option("-v", "--verbose",
                      action="store_true",
                      default=False,
                      dest="verbose",
                      help="run tests in verbose mode")
    parser.add_option("-q", "--quiet",
                      action="store_true",
                      default=False,
                      dest="quiet",
                      help="run tests in quiet mode")
    parser.add_option("-n", "--nose",
                      action="store_true",
                      default=False,
                      dest="nose",
                      help="run tests using nose if it is available")

    options, args = parser.parse_args()
    verbose = 1
    global USE_NOSE
    if options.nose:
        USE_NOSE = True
    if options.verbose:
        verbose = 2
    if options.quiet:
        verbose = 0

    status = 0
    if len(args) == 0:
        status = m2_tests(verbose)
    else:
        tests = find_tests(args)
        if len(tests) > 0:
            status = run(tests, verbose=verbose)
    sys.exit(status)

if __name__ == "__main__":
    main()

########NEW FILE########
__FILENAME__ = test_array_source
"""
Tests for the ArraySource class.
"""
# Author: Prabhu Ramachandran <prabhu@aero.iitb.ac.in>
# Copyright (c) 2008, Prabhu Ramachandran Enthought, Inc.
# License: BSD Style.

import unittest
import pickle
import numpy

# Enthought library imports.
from traits.api import TraitError
from mayavi.sources.array_source import ArraySource
from mayavi.modules.outline import Outline
from mayavi.modules.surface import Surface


class TestArraySource(unittest.TestCase):
    def setUp(self):
        """Initial setting up of test fixture, automatically called by TestCase before any other test method is invoked"""
        d = ArraySource()
        self.data = d

    def tearDown(self):
        """For necessary clean up, automatically called by TestCase after the test methods have been invoked"""
        return

    def make_2d_data(self):
        s = numpy.array([[0, 1],[2, 3]], 'd')
        v = numpy.array([[[1,1,1], [1,0,0]],[[0,1,0], [0,0,1]]], 'd')
        tps = numpy.transpose
        s, v = tps(s), tps(v, (1, 0, 2))
        return s, v

    def make_3d_data(self):
        s = numpy.array([[[0, 1],[2, 3]],
                           [[4, 5],[6, 7]]], 'd')
        v = numpy.array([[[[0,0,0],
                             [1,0,0]],
                            [[0,1,0],
                             [1,1,0]]],
                           [[[0,0,1],
                             [1,0,1]],
                            [[0,1,1],
                             [1,1,1]]]], 'd')
        tps = numpy.transpose
        s, v = tps(s), tps(v, (2, 1, 0, 3))
        return s, v

    def test_input_validation(self):
        """Tests if only the correct forms of input arrays are supported."""
        obj = self.data
        # These should work.
        obj.scalar_data = numpy.zeros((2,2), 'd')
        obj.scalar_data = numpy.zeros((2,2,2), 'd')
        obj.scalar_data = None
        obj.vector_data = numpy.zeros((2,2,3), 'd')
        obj.vector_data = numpy.zeros((2,2,2,3), 'd')
        obj.vector_data = None

        # These should not.
        self.assertRaises(TraitError, setattr, obj, 'scalar_data', [1,2,3])
        self.assertRaises(TraitError, setattr, obj, 'scalar_data',
                          numpy.zeros((2,2,2,3), 'd'))
        obj.scalar_data = None
        self.assertRaises(TraitError, setattr, obj, 'vector_data', [[1,2,3]])
        self.assertRaises(TraitError, setattr, obj, 'vector_data',
                          numpy.zeros((2,2,2,1), 'd'))
        obj.vector_data = None

        obj.scalar_data = numpy.zeros((2,2), 'd')
        self.assertRaises(TraitError, setattr, obj, 'vector_data',
                          numpy.zeros((4,4,3), 'd'))
        obj.vector_data = numpy.zeros((2,2,3), 'd')
        self.assertRaises(TraitError, setattr, obj, 'scalar_data',
                          numpy.zeros((4,3), 'i'))
        self.assertRaises(TraitError, setattr, obj, 'scalar_data',
                          numpy.zeros((2,2,2), 'i'))
        obj.scalar_data = numpy.zeros((2,2), 'f')

        # Clean up the object so it can be used for further testing.
        obj.scalar_data = obj.vector_data = None

    def test_2d_data(self):
        """Generic tests for 2D data arrays."""
        d = self.data
        sc, vec = self.make_2d_data()
        d.origin = (-1, -1, 0)
        d.scalar_data = sc
        d.vector_data = vec
        d.start()  # Start the object so it flushes the pipeline etc.

        # Create an outline for the data.
        o = Outline()
        d.add_child(o)
        o.start()
        self.assertEqual(tuple(o.actor.actor.bounds),
                         (-1., 0., -1., 0., 0., 0.))
        # Create a surface module.
        surf = Surface()
        d.add_child(surf)
        self.assertEqual(surf.running, True)

        tps = numpy.transpose
        expect = [tps(sc), tps(vec, (1, 0, 2))]
        sc1 = surf.actor.mapper.input.point_data.scalars.to_array()
        self.assertEqual(numpy.allclose(sc1.flatten(),
                         expect[0].flatten()), True)
        vec1 = surf.actor.mapper.input.point_data.vectors.to_array()
        self.assertEqual(numpy.allclose(vec1.flatten(),
                         expect[1].flatten()), True)

    def test_3d_data(self):
        "Test for 3D data arrays."
        # Add a 3D data source
        d = self.data
        sc, vec = self.make_3d_data()
        d.scalar_data = sc
        d.vector_data = vec
        d.start()  # Start the object so it flushes the pipeline etc.

        # Create an outline for the data.
        o = Outline()
        d.add_child(o)
        o.start()
        self.assertEqual(tuple(o.actor.actor.bounds),
                         (0, 1., 0., 1., 0., 1.))
        # Create a surface module.
        surf = Surface()
        d.add_child(surf)
        self.assertEqual(surf.running, True)

        tps = numpy.transpose
        expect = [tps(sc),  tps(vec, (2,1,0,3))]
        sc2 = surf.actor.mapper.input.point_data.scalars.to_array()
        self.assertEqual(numpy.allclose(sc2.flatten(),
                         expect[0].flatten()), True)
        vec2 = surf.actor.mapper.input.point_data.vectors.to_array()
        self.assertEqual(numpy.allclose(vec2.flatten(),
                         expect[1].flatten()), True)

    def test_pickle(self):
        "Test if pickling works."

        # Test if saving a visualization and restoring it works.
        d = self.data
        sc, vec = self.make_3d_data()
        d.scalar_data = sc
        d.vector_data = vec
        d.spacing = [1, 2, 3]
        d.origin  = [4, 5, 6]
        d.start()  # Start the object so it flushes the pipeline etc.

        # Create an outline for the data.
        o = Outline()
        d.add_child(o)
        o.start()
        # Create a surface module.
        surf = Surface()
        d.add_child(surf)

        data = pickle.dumps(d)
        del d, surf, o
        d = pickle.loads(data)
        # We must explicitly start the object.
        d.start()
        mm = d.children[0]
        o, surf = mm.children

        # Test the unpciked state.
        self.assertEqual(tuple(o.actor.actor.bounds),
                         (4., 5., 5., 7., 6., 9.))
        self.assertEqual(surf.running, True)
        self.assertEqual(o.running, True)
        self.assertEqual(d.running, True)
        self.assertEqual(numpy.allclose(d.spacing, [1, 2, 3]), True)
        self.assertEqual(numpy.allclose(d.origin,  [4, 5, 6]), True)

        tps = numpy.transpose
        expect = [tps(sc),  tps(vec, (2,1,0,3))]
        sc2 = surf.actor.mapper.input.point_data.scalars.to_array()
        self.assertEqual(numpy.allclose(sc2.flatten(),
                         expect[0].flatten()), True)
        vec2 = surf.actor.mapper.input.point_data.vectors.to_array()
        self.assertEqual(numpy.allclose(vec2.flatten(),
                         expect[1].flatten()), True)



if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_builtin_image
# Author: Suyog Dutt Jain <suyog.jain@aero.iitb.ac.in>
#         Prabhu Ramachandran <prabhu_r@users.sf.net>
# Copyright (c) 2008,  Enthought, Inc.
# License: BSD Style.

# Standard library imports.
from os.path import abspath
from StringIO import StringIO
import numpy
import unittest
from numpy import array

# Enthought library imports.
from tvtk.common import is_old_pipeline
from mayavi.core.null_engine import NullEngine
from mayavi.sources.builtin_image import BuiltinImage
from mayavi.modules.surface import Surface
from mayavi.modules.outline import Outline

class TestBuiltinImageSource(unittest.TestCase):

    def setUp(self):

        e = NullEngine()
        # Uncomment to see visualization for debugging etc.
        #e = Engine()
        e.start()
        s=e.new_scene()

        image_data = BuiltinImage()
        e.add_source(image_data)

        outline = Outline()
        e.add_module(outline)

        surface = Surface()
        e.add_module(surface)

        image_data.data_source.radius = array([ 80.,  80.,  80.])
        image_data.data_source.center = array([ 150.,  150.,    0.])
        image_data.data_source.whole_extent = array([ 10, 245,  10, 245,   0,   0])
        if is_old_pipeline():
            image_data.data_source.update_whole_extent()
        else:
            image_data.data_source.set_update_extent_to_whole_extent()

        self.e=e
        self.scene = e.current_scene

        return

    def tearDown(self):
        self.e.stop()
        return

    def test_data_source(self):
        s = self.scene
        src = s.children[0]
        self.assertEqual(src.source,'ellipsoid')
        self.assertEqual(numpy.allclose(src.data_source.center,(150., 150., 0.)),True)
        self.assertEqual(numpy.allclose(src.data_source.radius,(80., 80., 80.)),True)
        self.assertEqual(numpy.allclose(src.data_source.whole_extent,(10, 245,  10, 245,   0,   0)),True)

    def check(self):
        s = self.scene
        src = s.children[0]
        ot = src.children[0].children[0]
        ot.render()

        # Check with the default properties of gaussian image to verify
        # that the source has actually changed
        self.assertEqual(src.source,'gaussian')
        self.assertEqual(numpy.allclose(src.data_source.center,(0., 0., 0.)),True)
        self.assertEqual(src.data_source.maximum,2.0)
        self.assertEqual(src.data_source.standard_deviation,15)

        # Check the scalar ranges
        sc = src.outputs[0].point_data.scalars
        self.assertEqual(numpy.allclose(sc.range, (0, 2.0), atol=1.01e-03), True)

    def test_change(self):
        s = self.scene
        src = s.children[0]
        ot = src.children[0].children[0]
        src.source = 'gaussian'

        # Check with the default properties of gaussian image to verify
        # that the source has actually changed
        self.assertEqual(src.source,'gaussian')
        self.assertEqual(numpy.allclose(src.data_source.center,(0., 0., 0.)),True)
        self.assertEqual(src.data_source.maximum,1.0)
        self.assertEqual(src.data_source.standard_deviation,100)

        #Check the scalar ranges
        self.assertEqual(numpy.allclose(src.outputs[0].point_data.scalars.range,(0.00149, 1.0),atol=1.01e-03),True)

        src.data_source.maximum = 2.0
        src.data_source.standard_deviation = 15
        if not is_old_pipeline():
            src.data_source.update()
        self.check()

    def test_save_and_restore(self):
        """Test if saving a visualization and restoring it works."""
        engine = self.e
        scene = self.scene
        src = scene.children[0]
        src.source = 'gaussian'
        src.data_source.maximum = 2.0
        src.data_source.standard_deviation = 15

        # Save visualization.
        f = StringIO()
        f.name = abspath('test.mv2') # We simulate a file.
        engine.save_visualization(f)
        f.seek(0) # So we can read this saved data.

        # Remove existing scene.
        engine.close_scene(scene)

        # Load visualization
        engine.load_visualization(f)
        self.scene = engine.current_scene

        self.check()


if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_builtin_surface
# Author: Suyog Dutt Jain <suyog.jain@aero.iitb.ac.in>
#         Prabhu Ramachandran <prabhu_r@users.sf.net>
# Copyright (c) 2008,  Enthought, Inc.
# License: BSD Style.

# Standard library imports.
from os.path import abspath
from StringIO import StringIO
import numpy
import unittest

# Enthought library imports.
from mayavi.core.null_engine import NullEngine
from mayavi.sources.builtin_surface import BuiltinSurface
from mayavi.modules.surface import Surface
from mayavi.modules.outline import Outline


class TestBuiltinSurfaceSource(unittest.TestCase):

    def setUp(self):
        """Initial setting up of test fixture, automatically called by
        TestCase before any other test method is invoked"""

        e = NullEngine()
        # Uncomment to see visualization for debugging etc.
        #e = Engine()
        e.start()
        s=e.new_scene()

        poly_data = BuiltinSurface()
        e.add_source(poly_data)

        outline = Outline()
        e.add_module(outline)

        surface = Surface()
        e.add_module(surface)

        poly_data.data_source.shaft_radius = 0.05
        poly_data.data_source.shaft_resolution = 7
        poly_data.data_source.tip_radius = 0.1

        self.e=e
        self.scene = e.current_scene

        return

    def tearDown(self):
        """For necessary clean up, automatically called by TestCase
        after the test methods have been invoked"""
        self.e.stop()
        return

    def test_poly_data_source(self):
        """Do the basic testing"""
        s = self.scene
        src = s.children[0]

        #Check the properties of the default source
        self.assertEqual(src.source,'arrow')
        self.assertEqual(src.data_source.shaft_radius,0.05)
        self.assertEqual(src.data_source.shaft_resolution,7)
        self.assertEqual(src.data_source.tip_radius,0.1)

    def check(self):
        """Do the actual testing."""
        s = self.scene
        src = s.children[0]
        ot = src.children[0].children[0]
        ot.render() # Flush the pipeline.

        # Check the outline bounds
        self.assertEqual(numpy.allclose(ot.outline_filter.output.bounds,
                                        (-0.5, 0.5, -0.5, 0.5, -0.475, 0.475),
                                        atol=1.01e-03), True)

        self.assertEqual(numpy.allclose(src.data_source.angle, 26.565,
                                        atol=1.01e-03),True)
        self.assertEqual(numpy.allclose(src.data_source.direction,(1., 0., 0.)),True)
        self.assertEqual(src.data_source.radius,0.5)
        self.assertEqual(src.data_source.height,1.0)
        self.assertEqual(numpy.allclose(src.data_source.center,(0., 0., 0.)),True)
        self.assertEqual(src.data_source.resolution, 10)

        #Modify Properties and check again
        src.data_source.height = 1.5
        src.data_source.angle = 30
        src.data_source.modified()
        self.assertEqual(numpy.allclose(src.data_source.radius,0.866,atol=1.01e-03),True)

    def test_change(self):
        """Test if it works fine on changing the source"""
        s = self.scene
        src = s.children[0]
        ot = src.children[0].children[0]
        src.source = 'cone'
        src.data_source.resolution = 10

        # Check with the default properties of cone to verify that the
        # source has actually changed
        self.assertEqual(src.source,'cone')
        self.check()

    def test_save_and_restore(self):
        """Test if saving a visualization and restoring it works."""
        engine = self.e
        scene = self.scene
        src = scene.children[0]
        src.source = 'cone'
        src.data_source.resolution = 10

        # Save visualization.
        f = StringIO()
        f.name = abspath('test.mv2') # We simulate a file.
        engine.save_visualization(f)
        f.seek(0) # So we can read this saved data.

        # Remove existing scene.
        engine.close_scene(scene)

        # Load visualization
        engine.load_visualization(f)
        self.scene = engine.current_scene

        self.check()

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_contour
# Author: Suyog Dutt Jain <suyog.jain@aero.iitb.ac.in>
#         Prabhu Ramachandran <prabhu_r@users.sf.net>
# Copyright (c) 2008,  Enthought, Inc.
# License: BSD Style.

# Standard library imports.
from os.path import abspath
from StringIO import StringIO
import copy
import numpy
import unittest
import datasets

# Local imports.
from mayavi.core.null_engine import NullEngine

# Enthought library imports
from mayavi.sources.vtk_data_source import VTKDataSource
from mayavi.modules.outline import Outline
from mayavi.modules.iso_surface import IsoSurface
from mayavi.modules.contour_grid_plane import ContourGridPlane
from mayavi.modules.scalar_cut_plane import ScalarCutPlane


class TestContour(unittest.TestCase):

    def setUp(self):
        """Initial setting up of test fixture, automatically called by TestCase before any other test method is invoked"""

        e = NullEngine()
        # Uncomment to see visualization for debugging etc.
        #e = Engine()
        e.start()
        e.new_scene()
        self.e=e

        sgrid=datasets.generateStructuredGrid()
        src = VTKDataSource(data = sgrid)
        e.add_source(src)

        # Create an outline for the data.
        o = Outline()
        e.add_module(o)

        # Create one ContourGridPlane normal to the 'x' axis.
        cgp1 = ContourGridPlane()
        e.add_module(cgp1)
        # Set the position to the middle of the data.
        cgp1.grid_plane.position = 15

        # Another with filled contours normal to 'y' axis.
        cgp2 = ContourGridPlane()
        cgp2.contour.filled_contours = True
        # Set the axis and position to the middle of the data.
        cgp2.grid_plane.axis = 'y'
        cgp2.grid_plane.position = 15
        e.add_module(cgp2)

        # An isosurface module.
        iso = IsoSurface(compute_normals=True)
        e.add_module(iso)
        iso.contour.contours = [5]

        # An interactive scalar cut plane.
        cp = ScalarCutPlane()
        e.add_module(cp)
        ip = cp.implicit_plane
        ip.normal = 0,0,1
        ip.origin = 0.5, 0.5, 1.0
        # Since this is running offscreen this seems necessary.
        ip.widget.origin = 0.5, 0.5, 1.0
        ip.widget.enabled = False
        self.scene = e.current_scene
        self.cgp2=cgp2
        self.iso=iso
        self.cp=cp
        return

    def tearDown(self):
        """For necessary clean up, automatically called by TestCase after the test methods have been invoked"""
        self.e.stop()
        return

    def check(self):
        """Do the actual testing."""
        scene = self.scene
        src = scene.children[0]
        mm = src.children[0]
        cgp1 = mm.children[1]
        self.assertEqual(cgp1.grid_plane.position,15)

        cgp2 = mm.children[2]
        self.assertEqual(cgp2.contour.filled_contours,True)
        self.assertEqual(cgp2.grid_plane.axis, 'y')
        self.assertEqual(cgp2.grid_plane.position,15)

        iso = mm.children[3]
        ctr = iso.contour.contours
        self.assertEqual(iso.compute_normals,True)
        self.assertEqual(ctr, [5.0])
        rng = iso.actor.mapper.input.point_data.scalars.range
        self.assertEqual(rng[0],5.0)
        self.assertEqual(rng[1],5.0)

        cp = mm.children[4]
        ip = cp.implicit_plane
        self.assertAlmostEqual(numpy.sum(ip.normal - (0,0,1)) , 1e-16)
        self.assertAlmostEqual(numpy.sum(ip.origin - (0.5, 0.5, 1.0)), 0.0)
        self.assertEqual(ip.widget.enabled,False)



    def test_contour(self):
        "Test if the test fixture works"
        #Now test.
        self.check()

        #from mayavi.tools.show import show
        #show()

    def test_components_changed(self):
        """Test if the modules respond correctly when the components
           are changed."""
        cgp2=self.cgp2
        cp  =self.cp
        iso =self.iso
        ctr = cgp2.contour
        cgp2.contour = ctr.__class__()
        cgp2.contour = ctr
        cgp2.actor = cgp2.actor.__class__()

        iso.contour = iso.contour.__class__()
        iso.contour.contours = [5.0]
        iso.actor = iso.actor.__class__()
        iso.normals = iso.normals.__class__()

        ip = cp.implicit_plane
        cp.implicit_plane = cp.implicit_plane.__class__()
        cp.implicit_plane = ip
        ip.widget.enabled = False
        cp.contour = cp.contour.__class__()
        cp.cutter = cp.cutter.__class__()
        cp.actor = cp.actor.__class__()
        # Now check.
        self.check()


    def test_save_and_restore(self):
        """Test if saving a visualization and restoring it works."""
        engine = self.e
        scene = self.scene

        # Save visualization.
        f = StringIO()
        f.name = abspath('test.mv2') # We simulate a file.
        engine.save_visualization(f)
        f.seek(0) # So we can read this saved data.

        # Remove existing scene.

        engine.close_scene(scene)

        # Load visualization
        engine.load_visualization(f)
        self.scene = engine.current_scene

        self.check()


    def test_deepcopied(self):
        """Test if the MayaVi2 visualization can be deep-copied."""
        ############################################################
        # Test if the MayaVi2 visualization can be deep-copied.

        # Pop the source object.
        s =  self.scene
        source = s.children.pop()
        # Add it back to see if that works without error.
        s.children.append(source)
        cp = source.children[0].children[-1]
        cp.implicit_plane.widget.enabled = False

        self.check()

        # Now deepcopy the source and replace the existing one with
        # the copy.  This basically simulates cutting/copying the
        # object from the UI via the right-click menu on the tree
        # view, and pasting the copy back.
        source1 = copy.deepcopy(source)
        s.children[0] = source1
        cp = source1.children[0].children[-1]
        cp.implicit_plane.widget.enabled = False
        self.check()

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_core_common
"""
Tests for the mayavi.core.common module.
"""
# Author: Prabhu Ramachandran <prabhu@aero.iitb.ac.in>
# Copyright (c) 2008, Enthought, Inc.
# License: BSD Style.

import unittest

from mayavi.core.common import get_object_path, get_engine
from mayavi.sources.parametric_surface import \
    ParametricSurface
from mayavi.modules.outline import Outline

from mayavi.core.null_engine import NullEngine


class TestCoreCommon(unittest.TestCase):
    def setUp(self):
        e = NullEngine()
        e.start()
        e.new_scene()
        scene = e.scenes[-1]
        s = ParametricSurface()
        e.add_source(s)
        o = Outline()
        s.add_child(o)
        o1 = Outline()
        s.add_child(o1)
        self.scene = scene
        self.e = e
        self.s = s
        self.o = o
        self.o1 = o1
        return

    def test_get_object_path(self):
        "Check if the get_object_path method works correctly."
        e, scene, s, o, o1 = self.e, self.scene, self.s, self.o, self.o1

        value = get_object_path(scene, e)
        self.assertEqual(value, 'engine.scenes[0]')
        value = get_object_path(s, e)
        self.assertEqual(value, 'engine.scenes[0].children[0]')
        value = get_object_path(o.module_manager, e)
        self.assertEqual(value,
                        'engine.scenes[0].children[0].children[0]')
        value = get_object_path(o, e)
        self.assertEqual(value,
                        'engine.scenes[0].children[0].children[0].children[0]')
        value = get_object_path(o1, e)
        self.assertEqual(value,
                        'engine.scenes[0].children[0].children[0].children[1]')
        # With respect to the scene.
        value = get_object_path(o, scene, 'scene')
        self.assertEqual(value,
                         'scene.children[0].children[0].children[0]')
        # With respect to the source.
        value = get_object_path(o, s, 's')
        self.assertEqual(value, 's.children[0].children[0]')
        value = get_object_path(o1, s, 's')
        self.assertEqual(value, 's.children[0].children[1]')

    def test_get_engine(self):
        e, scene, s, o, o1 = self.e, self.scene, self.s, self.o, self.o1
        self.assertEqual(e, get_engine(scene))
        self.assertEqual(e, get_engine(s))
        self.assertEqual(e, get_engine(o))
        self.assertEqual(e, get_engine(o1))
        self.assertEqual(e, get_engine(o.module_manager))
        self.assertEqual(e, get_engine(o1.module_manager))

    def test_remove(self):
        "Does obj.remove() work correctly"
        # Fails only when the current object is the one that is removed.
        self.e.current_object = self.o1
        mm = self.o1.module_manager
        # Remove the object.
        self.o1.remove()
        # Now add another object.
        o1 = Outline()
        self.e.add_module(o1)
        # Is it really added?
        self.assertEqual(o1.module_manager, mm)
        self.assertEqual(o1.parent, mm)


if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_csv_sniff
"""
Tests for the CSV file sniffer
"""
# Author: Ilan Schnell <ischnell@enthought.com>
# Copyright (c) 2008, Enthought, Inc.
# License: BSD Style.
import glob
import os
import os.path
import sys
import unittest
import tempfile

import nose
from numpy import array, ndarray

from mayavi.tools.data_wizards.csv_sniff import \
     Sniff, loadtxt, loadtxt_unknown, array2dict


class Util(unittest.TestCase):

    def assertNamedClose(self, x, y):
        self.assertEqual(x.shape, y.shape)
        self.assertEqual(x.dtype.names, y.dtype.names)
        for name in x.dtype.names:
            self.assertAllClose(x[name], y[name])

    def assertAllClose(self, x, y):
        self.assertEqual(len(x), len(y))
        for a, b in zip(x, y):
            self.assertClose(a, b)

    def assertClose(self, a, b):
        if isinstance(a, (int, float)):
            if repr(a) == 'nan':
                self.assert_(repr(b) == 'nan')
            else:
                self.assert_(abs(a - b) < 1e-6 * max(1, abs(a)),
                             '%r != %r  %r' % (a, b, abs(a - b)))

        elif isinstance(a, str):
            self.assertEqual(a, b)

        else:
            self.assertFalse("Hmm, did not expect: %s" % a)

class Test(Util):

    def test_API(self):
        fo = tempfile.mktemp()
        with open(fo, 'wb') as f:
            f.write(''' "A", "B", "C"
                         1, 2, 3.2
                         7, 4, 1.87''')
        
        s = Sniff(fo)
        self.assertEqual(s.comments(), '#')
        self.assertEqual(s.delimiter(), ',')
        self.assertEqual(s.skiprows(), 1)
        self.assertEqual(s.dtype(), {'names': ('A', 'B', 'C'),
                                     'formats': (float, float, float)})
        x = s.loadtxt()
        y = array([(1.0, 2.0, 3.20),
                   (7.0, 4.0, 1.87)],
                  dtype=[('A', float), ('B', float), ('C', float)])
        self.assertNamedClose(x, y)

        y = loadtxt(fo, **s.kwds())
        self.assertNamedClose(x, y)

        y = loadtxt_unknown(fo)
        self.assertNamedClose(x, y)

        d = array2dict(y)
        self.assertEqual(type(d), type({}))
        self.assertAllClose(x['A'], [1, 7])
        self.assertAllClose(x['B'], [2, 4])
        self.assertAllClose(x['C'], [3.2, 1.87])


    def test_comment(self):
        fo = tempfile.mktemp()
        with open(fo, 'wb') as f:
            f.write('''
            % "A"  "B"  "C"
               1    2   4.2   % comment''')

        s = Sniff(fo)
        self.assertEqual(s.kwds(),
          {'dtype': {'names': ('A', 'B', 'C'),
                     'formats': (float, float, float)},
           'delimiter': None,
           'skiprows': 0,   # FIXME
           'comments': '%'})


    def test_tabs(self):
        fo = tempfile.mktemp()
        with open(fo, 'wb') as f:
            f.write('''54\t87\n21\t32''')

        s = Sniff(fo)
        self.assertEqual(s.delimiter(), None)
        self.assertEqual(s.skiprows(), 0)


    def test_nohead(self):
        fo = tempfile.mktemp()
        with open(fo, 'wb') as f:
            f.write('''Hello;54;87\nWorld;42;86.5''')

        s = Sniff(fo)
        self.assertEqual(s.kwds(),
          {'comments': '#',
           'delimiter': ';',
           'skiprows': 0,
           'dtype': {'names': ('Column 1', 'Column 2', 'Column 3'),
                     'formats': ('S5', float, float)}})


    def test_empty_file(self):
        fo = tempfile.mktemp()
        with open(fo, 'wb') as f:
            f.write('')
        self.assertRaises(IndexError, Sniff, fo)

class Test_csv_py_files(Util):
    """
        These tests require files in csv_files/
    """
    def check(self, name, skip_if_win=False):
        """
            Check if the output array from csv_files/<name>.csv
            (which is of unkown format)
            is the same as the array in csv_files/<name>.py
        """
        if skip_if_win and sys.platform.startswith('win'):
            raise nose.SkipTest

        # Note: The files needed for the test are currently accessed directly.
        #       This assumes that the files are present, and not in a zipped
        #       egg.  traits.util.resource as supposed to always work, but
        #       when it ran the striped the tests in the EPD installer tests,
        #       it was broken.  Since we define zip_safe = False in setup.py
        #       it is safe to assume the files are always present.

        s = Sniff(os.path.join(os.path.dirname(__file__),
                               'csv_files', name + '.csv'))

        f_py = os.path.join(os.path.dirname(__file__),
                            'csv_files', name + '.py')

        if not sys.platform.startswith('win'):
            nan = float('nan') # must be in namespace for some .py files

        d = eval(open(f_py).read())

        self.assertEqual(d['kwds'], s.kwds())
        self.assertNamedClose(d['array'], s.loadtxt())

    def test_11(self):
        self.check('11')

    def test_1col(self):
        self.check('1col')

    def test_54(self):
        self.check('54')

    def test_79(self):
        self.check('79')

    def test_82(self):
        self.check('82')

    def test_89(self):
        self.check('89')

    def test_99(self):
        self.check('99')

    def test_colors(self):
        self.check('colors')

    def test_example1(self):
        # this test need to be skipped on Windows because the data file
        # has some floats nan, and float('nan') fails on on Windows.
        self.check('example1', skip_if_win=True)

    def test_hp11c(self):
        self.check('hp11c')

    def test_loc(self):
        self.check('loc')

    def test_multi_col(self):
        self.check('multi-col')

    def test_mydata(self):
        self.check('mydata')

    def test_OObeta3(self):
        self.check('OObeta3')

    def test_post(self):
        self.check('post')

    def test_webaccess(self):
        self.check('webaccess')


if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_customize
"""Tests for mayavi.core.customize."""

import unittest

# We need this import of NullEngine since importing customize first can
# result in circular imports.
from mayavi.core.null_engine import NullEngine

from mayavi.core import customize


class TestCustomize(unittest.TestCase):
    def test_import_contrib(self):
        """Test the import_contrib function."""
        for mname in ('mayavi.api',
                      'mayavi',
                      'mayavi.core',
                      'mayavi.core.base'):
            mod = customize._import_contrib(mname)
            self.assertEqual(mod.__name__, mname)


if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_dataset_manager
"""
Test for the dataset_manager.py module.
"""
# Author: Prabhu Ramachandran <prabhu@aero.iitb.ac.in>
# Copyright (c) 2008, Enthought, Inc.
# License: BSD Style.

import unittest
import numpy as N

from tvtk.api import tvtk
from mayavi.core.dataset_manager import DatasetManager


def make_data():
    points = N.array([[0,0,0], [1,0,0], [0,1,0], [0,0,1], # tets
                    [1,0,0], [2,0,0], [1,1,0], [1,0,1],
                    [2,0,0], [3,0,0], [2,1,0], [2,0,1],
                    ], 'f')
    tets = N.array([[0, 1, 2, 3], [4, 5, 6, 7], [8, 9, 10, 11]])
    tet_type = tvtk.Tetra().cell_type
    ug = tvtk.UnstructuredGrid(points=points)
    ug.set_cells(tet_type, tets)
    # Setup the point attributes.
    temp = N.random.random(12)
    v = N.random.randn(12, 3)
    ten = N.random.randn(12, 9)
    a = tvtk.FloatArray(name='p')
    a.from_array(N.random.randn(12))
    ug.point_data.add_array(a)
    ug.point_data.scalars = temp
    ug.point_data.scalars.name = 't'
    ug.point_data.vectors = v
    ug.point_data.vectors.name = 'v'
    ug.point_data.tensors = ten
    ug.point_data.tensors.name = 'ten'
    # Setup the cell attributes.
    temp = N.random.random(3)
    v = N.random.randn(3, 3)
    ten = N.random.randn(3, 9)
    ug.cell_data.scalars = temp
    ug.cell_data.scalars.name = 't'
    ug.cell_data.vectors = v
    ug.cell_data.vectors.name = 'v'
    ug.cell_data.tensors = ten
    ug.cell_data.tensors.name = 'ten'
    return ug


class TestDataSetManager(unittest.TestCase):
    def setUp(self):
        self.data = make_data()
        self.dm = DatasetManager(dataset=self.data)
        return

    def tearDown(self):
        return

    def test_point_arrays(self):
        "Are the point data arrays of the manager setup right?"
        dm = self.dm
        sc = dm.point_scalars.keys()
        sc.sort()
        self.assertEqual(sc, ['p', 't'])
        vec = dm.point_vectors.keys()
        self.assertEqual(vec, ['v'])
        ten = dm.point_tensors.keys()
        self.assertEqual(ten, ['ten'])

    def test_point_array_view(self):
        "Are the manager's point arrays views of the VTK data?"
        # Check that the array we have is really a view of the VTK data.
        dm = self.dm
        data = self.data
        t = dm.point_scalars['t']
        t[0] += 1.0
        self.assertEqual(t[0], data.point_data.scalars[0])

        v = dm.point_vectors['v']
        v[0][0] += 1.0
        self.assertEqual(v[0][0], data.point_data.vectors[0][0])

        ten = dm.point_tensors['ten']
        ten[0][0] += 1.0
        self.assertEqual(ten[0][0], data.point_data.tensors[0][0])

    def test_cell_arrays(self):
        "Are the cell arrays of the manager setup right?"
        dm = self.dm
        sc = dm.cell_scalars.keys()
        self.assertEqual(sc, ['t'])
        vec = dm.cell_vectors.keys()
        self.assertEqual(vec, ['v'])
        ten = dm.cell_tensors.keys()
        self.assertEqual(ten, ['ten'])

    def test_cell_array_view(self):
        "Are the manager's cell arrays views of the VTK data?"
        # Check that the array we have is really a view of the VTK data.
        dm = self.dm
        data = self.data
        t = dm.cell_scalars['t']
        t[0] += 1.0
        self.assertEqual(t[0], data.cell_data.scalars[0])

        v = dm.cell_vectors['v']
        v[0][0] += 1.0
        self.assertEqual(v[0][0], data.cell_data.vectors[0][0])

        ten = dm.cell_tensors['ten']
        ten[0][0] += 1.0
        self.assertEqual(ten[0][0], data.cell_data.tensors[0][0])

    def test_remove_array(self):
        "Does the remove_array method work correctly."
        dm = self.dm
        data = self.data
        dm.remove_array('t', 'point')
        self.assertEqual(len(dm.point_scalars), 1)
        self.assertEqual(dm.point_scalars.keys(), ['p'])
        dm.remove_array('ten', 'point')
        self.assertEqual(len(dm.point_tensors), 0)
        # Make sure the default category is point.
        dm.remove_array('v')
        self.assertEqual(len(dm.point_vectors), 0)

        # Cell arrays.
        dm.remove_array('t', 'cell')
        self.assertEqual(len(dm.cell_scalars), 0)
        dm.remove_array('ten', 'cell')
        self.assertEqual(len(dm.cell_tensors), 0)
        dm.remove_array('v', 'cell')
        self.assertEqual(len(dm.cell_vectors), 0)

    def test_rename_array(self):
        "Does array renaming work."
        dm = self.dm
        data = self.data

        dm.rename_array('ten', 'ten1', 'point')
        self.assertEqual(dm.point_tensors.keys(), ['ten1'])
        pd = data.point_data
        arrs = [pd.get_array_name(x) for x in
                range(pd.number_of_arrays)]
        arrs.sort()
        self.assertEqual(arrs, ['p', 't', 'ten1', 'v'])

        dm.rename_array('t', 'temp', 'cell')
        self.assertEqual(dm.cell_scalars.keys(), ['temp'])
        cd = data.cell_data
        arrs = [cd.get_array_name(x) for x in
                range(cd.number_of_arrays)]
        arrs.sort()
        self.assertEqual(arrs, ['temp', 'ten', 'v'])

    def test_add_array(self):
        "Does the add_array method work."
        dm = self.dm
        data = self.data
        pd = data.point_data
        cd = data.cell_data

        # Point data.
        s = N.random.randn(12)
        v = N.random.randn(12,3)
        t = N.random.randn(12, 9)
        dm.add_array(s, 'scalar')
        sc = self.dm.point_scalars.keys()
        sc.sort()
        self.assertEqual(sc, ['p', 'scalar', 't'])
        x = pd.get_array('scalar')
        self.assertNotEqual(x, None)
        dm.add_array(v, 'vector')
        vc = self.dm.point_vectors.keys()
        vc.sort()
        self.assertEqual(vc, ['v', 'vector'])
        x = pd.get_array('vector')
        self.assertNotEqual(x, None)
        dm.add_array(t, 'tensor')
        vc = self.dm.point_tensors.keys()
        vc.sort()
        self.assertEqual(vc, ['ten', 'tensor'])
        x = pd.get_array('tensor')
        self.assertNotEqual(x, None)

        # cell data.
        s = N.random.randn(3)
        v = N.random.randn(3, 3)
        t = N.random.randn(3, 9)
        dm.add_array(s, 'scalar', 'cell')
        sc = self.dm.cell_scalars.keys()
        sc.sort()
        self.assertEqual(sc, ['scalar', 't'])
        x = cd.get_array('scalar')
        self.assertNotEqual(x, None)
        dm.add_array(v, 'vector', 'cell')
        vc = self.dm.cell_vectors.keys()
        vc.sort()
        self.assertEqual(vc, ['v', 'vector'])
        x = cd.get_array('vector')
        self.assertNotEqual(x, None)
        dm.add_array(t, 'tensor', 'cell')
        vc = self.dm.cell_tensors.keys()
        vc.sort()
        self.assertEqual(vc, ['ten', 'tensor'])
        x = cd.get_array('tensor')
        self.assertNotEqual(x, None)

    def test_activate(self):
        "Does activating a particular array work."
        dm = self.dm
        data = self.dm.output

        dm.activate('p')
        self.assertEqual(data.point_data.scalars.name, 'p')
        dm.activate('t')
        self.assertEqual(data.point_data.scalars.name, 't')

        s = N.random.randn(3)
        dm.add_array(s, 'foo', 'cell')
        dm.activate('foo', 'cell')
        self.assertEqual(data.cell_data.scalars.name, 'foo')
        dm.activate('t', 'cell')
        self.assertEqual(data.cell_data.scalars.name, 't')


if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_extract_grid_filter
# Author: Suyog Dutt Jain <suyog.jain@aero.iitb.ac.in>
#         Prabhu Ramachandran
# Copyright (c) 2009,  Enthought, Inc.
# License: BSD Style.

# Standard library imports.
import unittest
from numpy import random, allclose, arange

# Local imports.
from mayavi.core.null_engine import NullEngine

# Enthought library imports
from mayavi.sources.vtk_data_source import VTKDataSource
from mayavi.modules.grid_plane import GridPlane
from mayavi.modules.axes import Axes
from mayavi.filters.extract_grid import ExtractGrid
from tvtk.api import tvtk
from tvtk.common import is_old_pipeline

class TestExtractGridFilter(unittest.TestCase):

    def make_scatter(self):
        pd = tvtk.PolyData()
        pd.points = 100 + 100*random.random((1000, 3))
        verts = arange(0, 1000, 1)
        verts.shape = (1000, 1)
        pd.verts = verts
        pd.point_data.scalars = random.random(1000)
        pd.point_data.scalars.name = 'scalars'
        return pd

    def make_grid4scatter(self):
        src = VTKDataSource()
        xmin, xmax, dx = 100, 200, 2
        nx = int((xmax-xmin)/dx)+1
        ymin, ymax, dy = 100, 200, 2
        ny = int((ymax-ymin)/dy)+1
        zmin, zmax, dz = 100, 200, 2
        nz  = int((zmax-zmin)/dz)+1
        image_data = tvtk.ImageData(origin=(xmin, ymin, zmin),
                                    spacing=(dx, dy, dz),
                                    extent=(0, nx-1, 0, ny-1, 0, nz-1))
        if is_old_pipeline():
            image_data.whole_extent = image_data.extent
        src.data = image_data
        return src

    def setUp(self):
        """Initial setting up of test fixture, automatically called by
        TestCase before any other test method is invoked"""
        e = NullEngine()
        # Uncomment to see visualization for debugging etc.
        #e = Engine()
        e.start()
        s=e.new_scene()
        self.e=e
        self.s=s

        ############################################################
        # Create a new scene and set up the visualization.

        #Make the grid
        grid = self.make_grid4scatter()
        e.add_source(grid)

        eg = ExtractGrid()
        e.add_filter(eg)

        nb_ticks = 6

        eg.x_ratio = eg.y_ratio = eg.z_ratio = 100/(nb_ticks-1)/2

        gpx = GridPlane()
        e.add_module(gpx)
        gpx.grid_plane.axis = 'x'

        gpy = GridPlane()
        e.add_module(gpy)
        gpy.grid_plane.axis = 'y'

        gpz = GridPlane()
        e.add_module(gpz)
        gpz.grid_plane.axis = 'z'

        #Add the scatter
        d = VTKDataSource()
        d.data = self.make_scatter()
        e.add_source(d)
        if is_old_pipeline():
            a = Axes()
            e.add_module(a)
            a.axes.number_of_labels = nb_ticks

        self.eg = eg
        self.gpx = gpx
        self.gpy = gpy
        self.gpz = gpz
        self.scene = e.current_scene
        return

    def tearDown(self):
        """For necessary clean up, automatically called by TestCase
        after the test methods have been invoked"""
        self.e.stop()
        return

    def test_extract_grid_filter_sample(self):
        import sys
        if sys.platform != "darwin":
            from nose import SkipTest
            raise SkipTest("actor.bounds returns incorrect values")
        "Test if the sample rate works."
        eg = self.eg
        gpx = self.gpx
        gpy = self.gpy
        gpz = self.gpz

        self.assertEqual(allclose(gpx.actor.actor.bounds,
                        (100.0, 100.0, 100.0, 200.0, 100.0, 200.0)), True)
        self.assertEqual(allclose(gpy.actor.actor.bounds,
                         (100.0, 200.0, 100.0, 100.0, 100.0, 200.0)), True)
        self.assertEqual(allclose(gpz.actor.actor.bounds,
                         (100.0, 200.0, 100.0, 200.0, 100.0, 100.0)), True)

        eg.x_ratio = eg.y_ratio = eg.z_ratio = 25

        self.assertEqual(allclose(gpx.actor.actor.bounds,
                         (100.0, 100.0, 100.0, 200.0, 100.0, 200.0)), True)
        self.assertEqual(allclose(gpy.actor.actor.bounds,
                         (100.0, 200.0, 100.0, 100.0, 100.0, 200.0)), True)
        self.assertEqual(allclose(gpz.actor.actor.bounds,
                         (100.0, 200.0, 100.0, 200.0, 100.0, 100.0)), True)

        eg.x_ratio = eg.y_ratio = eg.z_ratio = 5

        self.assertEqual(allclose(gpx.actor.actor.bounds,
                         (100.0, 100.0, 100.0, 200.0, 100.0, 200.0)), True)
        self.assertEqual(allclose(gpy.actor.actor.bounds,
                         (100.0, 200.0, 100.0, 100.0, 100.0, 200.0)), True)
        self.assertEqual(allclose(gpz.actor.actor.bounds,
                         (100.0, 200.0, 100.0, 200.0, 100.0, 100.0)), True)
        return

    def test_voi(self):
        import sys
        if sys.platform != "darwin":
            from nose import SkipTest
            raise SkipTest("actor.bounds returns incorrect values")
        "Test if setting the VOI works correctly."
        eg = self.eg
        gpx = self.gpx
        gpy = self.gpy
        gpz = self.gpz

        self.assertEqual(allclose(gpx.actor.actor.bounds,
                        (100.0, 100.0, 100.0, 200.0, 100.0, 200.0)), True)
        self.assertEqual(allclose(gpy.actor.actor.bounds,
                         (100.0, 200.0, 100.0, 100.0, 100.0, 200.0)), True)
        self.assertEqual(allclose(gpz.actor.actor.bounds,
                         (100.0, 200.0, 100.0, 200.0, 100.0, 100.0)), True)

        eg.x_ratio = eg.y_ratio = eg.z_ratio = 10

        # Now changing the VOI and then setting the ratio used to
        # show a stupid bug in the grid plane so we test that here.
        eg.set(x_min=10, x_max=40)
        eg.x_ratio = 5

        self.assertEqual(allclose(gpx.actor.actor.bounds,
                         (120.0, 120.0, 100.0, 200.0, 100.0, 200.0)), True)
        self.assertEqual(allclose(gpy.actor.actor.bounds,
                         (120.0, 180.0, 100.0, 100.0, 100.0, 200.0)), True)
        self.assertEqual(allclose(gpz.actor.actor.bounds,
                         (120.0, 180.0, 100.0, 200.0, 100.0, 100.0)), True)

        # Set some smaller VOI.
        eg.set(y_min=20, y_max=40, z_min=10, z_max=30)
        eg.set(x_ratio = 1, y_ratio=1, z_ratio=1)

        # Reset it and it should go right back.
        eg.set(x_min=0, x_max=50, y_min=0, y_max=50, z_min=0, z_max=50)
        self.assertEqual(allclose(gpx.actor.actor.bounds,
                        (100.0, 100.0, 100.0, 200.0, 100.0, 200.0)), True)
        self.assertEqual(allclose(gpy.actor.actor.bounds,
                         (100.0, 200.0, 100.0, 100.0, 100.0, 200.0)), True)
        self.assertEqual(allclose(gpz.actor.actor.bounds,
                         (100.0, 200.0, 100.0, 200.0, 100.0, 100.0)), True)

        #from mayavi.tools.show import show
        #show()



if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_glyph
# Author: Suyog Dutt Jain <suyog.jain@aero.iitb.ac.in>
#         Prabhu Ramachandran <prabhu_r@users.sf.net>
# Copyright (c) 2008,  Enthought, Inc.
# License: BSD Style.

# Standard library imports.
from os.path import abspath
from StringIO import StringIO
import copy
import numpy
import unittest

# Local imports.
from mayavi.core.null_engine import NullEngine

# Enthought library imports
from mayavi.sources.array_source import ArraySource
from mayavi.modules.outline import Outline
from mayavi.modules.glyph import Glyph
from mayavi.modules.vector_cut_plane import VectorCutPlane

class TestGlyph(unittest.TestCase):


    def make_data(self):
        """Trivial data -- creates an elementatry scalar field and a
        constant vector field along the 'x' axis."""
        s = numpy.arange(0.0, 10.0, 0.01)
        s = numpy.reshape(s, (10,10,10))
        s = numpy.transpose(s)

        v = numpy.zeros(3000, 'd')
        v[1::3] = 1.0
        v = numpy.reshape(v, (10,10,10,3))
        return s, v

    def setUp(self):
        """Initial setting up of test fixture, automatically called by TestCase before any other test method is invoked"""
        e = NullEngine()
        # Uncomment to see visualization for debugging etc.
        #e = Engine()
        e.start()
        s=e.new_scene()
        self.e=e
        self.s=s

        ############################################################
        # Create a new scene and set up the visualization.

        d = ArraySource()
        sc, vec = self.make_data()
        d.origin = (-5, -5, -5)
        d.scalar_data = sc
        d.vector_data = vec

        e.add_source(d)

        # Create an outline for the data.
        o = Outline()
        e.add_module(o)
        # Glyphs for the scalars
        g = Glyph()
        e.add_module(g)
        g.glyph.glyph_source.glyph_position = 'center'
        g.glyph.glyph.vector_mode = 'use_normal'
        g.glyph.glyph.scale_factor = 0.5
        g.actor.property.line_width = 1.0

        v = VectorCutPlane()
        glyph = v.glyph
        gs = glyph.glyph_source
        gs.glyph_position = 'tail'
        gs.glyph_source = gs.glyph_list[1]
        e.add_module(v)
        v.implicit_plane.set(normal=(0, 1, 0), origin=(0, 3, 0))

        v = VectorCutPlane()
        glyph = v.glyph
        gs = glyph.glyph_source
        gs.glyph_source = gs.glyph_list[2]
        gs.glyph_position = 'head'
        e.add_module(v)
        v.implicit_plane.set(normal=(0, 1, 0), origin=(0, -2, 0))
        self.g=g
        self.v=v
        self.scene = e.current_scene
        return

    def tearDown(self):
        """For necessary clean up, automatically called by TestCase after the test methods have been invoked"""
        self.e.stop()
        return

    def check(self):
        """Do the actual testing."""

        s=self.scene
        src = s.children[0]
        g = src.children[0].children[1]
        self.assertEqual(g.glyph.glyph_source.glyph_position,'center')
        self.assertEqual(g.glyph.glyph.vector_mode,'use_normal')
        self.assertEqual(g.glyph.glyph.scale_factor,0.5)
        self.assertEqual(g.actor.property.line_width,1.0)

        v = src.children[0].children[2]
        glyph = v.glyph
        gs = glyph.glyph_source
        self.assertEqual(gs.glyph_position,'tail')
        self.assertEqual(gs.glyph_source,gs.glyph_list[1])
        self.assertEqual(numpy.allclose(v.implicit_plane.normal,
                                                    (0., 1., 0.)),True)

        v = src.children[0].children[3]
        glyph = v.glyph
        gs = glyph.glyph_source
        self.assertEqual(gs.glyph_source,gs.glyph_list[2])
        self.assertEqual(gs.glyph_position,'head')
        self.assertEqual(numpy.allclose(v.implicit_plane.normal,
                         (0., 1., 0.)),True)


    def test_glyph(self):
        "Test if the test fixture works"
        self.check()


    def test_components_changed(self):
        """"Test if the modules respond correctly when the components
            are changed."""

        g=self.g
        v=self.v
        g.actor = g.actor.__class__()
        glyph = g.glyph
        g.glyph = glyph.__class__()
        g.glyph = glyph

        glyph = v.glyph
        v.glyph = glyph.__class__()
        v.glyph = glyph
        v.actor = v.actor.__class__()
        v.cutter = v.cutter.__class__()
        ip = v.implicit_plane
        v.implicit_plane = ip.__class__()
        v.implicit_plane = ip
        self.check()



    def test_save_and_restore(self):
        """Test if saving a visualization and restoring it works."""
        engine = self.e
        scene = self.scene
        # Save visualization.
        f = StringIO()
        f.name = abspath('test.mv2') # We simulate a file.
        engine.save_visualization(f)
        f.seek(0) # So we can read this saved data.

        # Remove existing scene.

        engine.close_scene(scene)

        # Load visualization
        engine.load_visualization(f)
        self.scene = engine.current_scene

        self.check()

    def test_deepcopied(self):
        """Test if the MayaVi2 visualization can be deep-copied."""
        ############################################################
        # Test if the MayaVi2 visualization can be deep-copied.

        # Pop the source object.
        s =  self.scene
        sources = s.children
        s.children = []
        # Add it back to see if that works without error.
        s.children.extend(sources)

        self.check()

        # Now deepcopy the source and replace the existing one with
        # the copy.  This basically simulates cutting/copying the
        # object from the UI via the right-click menu on the tree
        # view, and pasting the copy back.
        sources1 = copy.deepcopy(sources)
        s.children[:] = sources1
        self.check()

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_grid_plane
# Author: Suyog Dutt Jain <suyog.jain@aero.iitb.ac.in>
#         Prabhu Ramachandran <prabhu_r@users.sf.net>
# Copyright (c) 2008,  Enthought, Inc.
# License: BSD Style.

# Standard library imports.
from os.path import abspath
from StringIO import StringIO
import copy
import unittest
import datasets

# Local imports.
from mayavi.core.engine import Engine
from mayavi.core.null_engine import NullEngine

# Enthought library imports
from mayavi.sources.vtk_data_source import VTKDataSource
from mayavi.modules.outline import Outline
from mayavi.modules.grid_plane import GridPlane


class TestGridPlane(unittest.TestCase):

    def setUp(self):
        """Initial setting up of test fixture, automatically called by TestCase before any other test method is invoked"""
        e = NullEngine()
        # Uncomment to see visualization for debugging etc.
        #e = Engine()
        e.start()
        e.new_scene()
        self.e=e

        sgrid = datasets.generateStructuredGrid()
        src = VTKDataSource(data = sgrid)
        e.add_source(src)

        # Create an outline for the data.
        o = Outline()
        e.add_module(o)

        # Create three simple grid plane modules.
        # First normal to 'x' axis.
        gp1 = GridPlane()
        e.add_module(gp1)
        # Second normal to 'y' axis.
        gp2 = GridPlane()
        # We'll test how robust things are by setting attributes
        gp2.grid_plane.axis = 'y'
        gp2.grid_plane.position = 16
        e.add_module(gp2)
        # Third normal to 'z' axis.
        gp3 = GridPlane()
        e.add_module(gp3)
        gp3.grid_plane.axis = 'z'
        gp3.grid_plane.position = 6

        for gp in (gp1, gp2, gp3):
            gp.actor.property.set(ambient=1.0)

        self.scene = e.current_scene
        return

    def tearDown(self):
        """For necessary clean up, automatically called by TestCase after the test methods have been invoked"""
        self.e.stop()
        return

    def check(self):
        """Do the actual testing."""
        s = self.scene

        mm = s.children[0].children[0]
        gp1, gp2, gp3 = mm.children[1:]
        self.assertEqual(gp1.grid_plane.axis,'x')
        self.assertEqual(gp1.grid_plane.position,0)
        self.assertEqual(gp1.actor.property.ambient,1.0)

        self.assertEqual(gp2.grid_plane.axis,'y')
        self.assertEqual(gp2.grid_plane.position,16)
        self.assertEqual(gp2.actor.property.ambient,1.0)

        self.assertEqual(gp3.grid_plane.axis,'z')
        self.assertEqual(gp3.grid_plane.position,6)
        self.assertEqual(gp3.actor.property.ambient,1.0)

    def test_grid_plane(self):
        "Test if the test fixture works"
        self.check()

        #from mayavi.tools.show import show
        #show()


    def test_save_and_restore(self):
        """Test if saving a visualization and restoring it works."""
        engine = self.e
        scene = self.scene

        # Save visualization.
        f = StringIO()
        f.name = abspath('test.mv2') # We simulate a file.
        engine.save_visualization(f)
        f.seek(0) # So we can read this saved data.

        # Remove existing scene.

        engine.close_scene(scene)

        # Load visualization
        engine.load_visualization(f)
        self.scene = engine.current_scene

        self.check()


    def test_deepcopied(self):
        """Test if the MayaVi2 visualization can be deep-copied."""
        ############################################################
        # Test if the MayaVi2 visualization can be deep-copied.

        # Pop the source object.
        s =  self.scene
        source = s.children.pop()
        # Add it back to see if that works without error.
        s.children.append(source)

        self.check()

        # Now deepcopy the source and replace the existing one with
        # the copy.  This basically simulates cutting/copying the
        # object from the UI via the right-click menu on the tree
        # view, and pasting the copy back.
        source1 = copy.deepcopy(source)
        s.children[0] = source1
        self.check()
        #from mayavi.tools.show import show
        #show()



if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_image_data_probe
# Author: Suyog Dutt Jain <suyog.jain@aero.iitb.ac.in>
#         Prabhu Ramachandran <prabhu_r@users.sf.net>
# Copyright (c) 2008,  Enthought, Inc.
# License: BSD Style.

# Standard library imports.
from os.path import abspath
from StringIO import StringIO
import copy
import unittest

# Local imports.
from common import get_example_data

# Enthought library imports
from mayavi.core.null_engine import NullEngine
from mayavi.sources.vtk_xml_file_reader import VTKXMLFileReader
from mayavi.modules.api import ContourGridPlane
from mayavi.filters.image_data_probe import ImageDataProbe

class TestImageDataProbe(unittest.TestCase):

    def setUp(self):
        """Initial setting up of test fixture, automatically called by TestCase before any other test method is invoked"""
        e = NullEngine()
        # Uncomment to see visualization for debugging etc.
        #e = Engine()
        e.start()
        e.new_scene()
        self.e=e

        # Read a VTK (old style) data file.
        r = VTKXMLFileReader()
        r.initialize(get_example_data('pyramid_ug.vtu'))
        e.add_source(r)

        # Create the filters.
        idp = ImageDataProbe()
        idp.rescale_scalars = True
        e.add_filter(idp)
        cgp = ContourGridPlane(enable_contours=False)
        e.add_module(cgp)
        cgp.grid_plane.axis = 'z'
        cgp.grid_plane.position = 1
        self.scene = e.current_scene
        return

    def tearDown(self):
        """For necessary clean up, automatically called by TestCase after the test methods have been invoked"""
        self.e.stop()
        return

    def check(self):
        """Do the actual testing"""
        scene = self.scene
        src = scene.children[0]
        idp = src.children[0]
        mm = idp.children[0]

        self.assertEqual(src.outputs[0].is_a('vtkUnstructuredGrid'),True)
        self.assertEqual(idp.outputs[0].is_a('vtkImageData'),True)
        sc = idp.outputs[0].point_data.scalars
        vc = idp.outputs[0].point_data.vectors
        self.assertEqual(sc.name,idp.rescaled_scalar_name)
        self.assertEqual(vc.name,'velocity')
        self.assertEqual(mm.scalar_lut_manager.data_name,
                                                idp.rescaled_scalar_name)
        self.assertEqual((abs(sc.range[0]) < 1e-2),True)
        self.assertEqual( abs(sc.range[1] - 65535.0) < 1.e-2,True)
        self.assertEqual((idp.outputs[0].dimensions == (3, 3, 2)).all(),True)



    def test_image_data_probe(self):
        "Test if the test fixture works"
        #Now test.
        self.check()

        #from mayavi.tools.show import show
        #show()

    def test_save_and_restore(self):
        """Test if saving a visualization and restoring it works."""
        engine = self.e
        scene = self.scene
        self.check()

        # Save visualization.
        f = StringIO()
        f.name = abspath('test.mv2') # We simulate a file.
        engine.save_visualization(f)
        f.seek(0) # So we can read this saved data.

        # Remove existing scene.

        engine.close_scene(scene)

        # Load visualization
        engine.load_visualization(f)
        self.scene = engine.current_scene

        self.check()


    def test_deepcopied(self):
        """Test if the MayaVi2 visualization can be deep-copied."""
        ############################################################
        # Test if the MayaVi2 visualization can be deep-copied.

        # Pop the source object.
        s =  self.scene
        source = s.children.pop()
        # Add it back to see if that works without error.
        s.children.append(source)

        self.check()

        # Now deepcopy the source and replace the existing one with
        # the copy.  This basically simulates cutting/copying the
        # object from the UI via the right-click menu on the tree
        # view, and pasting the copy back.
        source1 = copy.deepcopy(source)
        s.children[0] = source1
        self.check()
        #from mayavi.tools.show import show
        #show()


if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_image_data_reader
# Author: Suyog Dutt Jain <suyog.jain@aero.iitb.ac.in>
# Copyright (c) 2009,  Enthought, Inc.
# License: BSD Style.

# Standard library imports.
import unittest
import numpy

# Local imports.
from common import get_example_data

# Enthought library imports
from mayavi.sources.image_reader import ImageReader
from mayavi.tests.data_reader_test_base import DataReaderTestBase

class TestDEMImageReader(DataReaderTestBase):

    def setup_reader(self):

        """"Setup the reader in here.  This is called after the engine
        has been created and started.  The engine is available as
        self.e.  This method is called by setUp().
        """
         # Read a DEM Image file.
        r = ImageReader()
        r.initialize(get_example_data('example.dem'))
        self.e.add_source(r)
        self.bounds =(557945.0, 567725.0, 5107991.5, 5121971.5, 682.0, 682.0)

    def check(self, scene, bounds, error = 1.01e-02):
        """Do the actual testing."""

        src = scene.children[0]
        ot = src.children[0].children[0]
        ot.render() # Flush the pipeline.

        # Check the outline bounds
        self.assertEqual(numpy.allclose(ot.outline_filter.output.bounds,bounds,
                                    atol=error), True)
        self.assertEqual(src.reader.spatial_resolution, (30.0, 30.0, 1.0))
        self.assertEqual(src.reader.elevation_bounds, (682.0, 2543.0))

    def test_dem_image_data_reader(self):
        "Test if the test fixture works"
        #Now test.

        self.check(self.scene, self.bounds)

    def test_save_and_restore(self):
        """Test if saving a visualization and restoring it works."""

        self.check_saving(self.e, self.scene, self.bounds)

    def test_deepcopied(self):
        """Test if the MayaVi2 visualization can be deep-copied."""
        ############################################################
        # Test if the MayaVi2 visualization can be deep-copied.

        self.check_deepcopying(self.scene, self.bounds)

class TestMHAImageReader(DataReaderTestBase):

    def setup_reader(self):

        """"Setup the reader in here.  This is called after the engine
        has been created and started.  The engine is available as
        self.e.  This method is called by setUp().
        """
         # Read a Meta Image file.
        r = ImageReader()
        r.initialize(get_example_data('foot.mha'))
        self.e.add_source(r)
        self.bounds =(0.0, 255.0, 0.0, 255.0, 0.0, 0.0)

    def check(self, scene, bounds, error = 1.01e-02):
        """Do the actual testing."""

        src = scene.children[0]
        ot = src.children[0].children[0]
        ot.render() # Flush the pipeline.

        # Check the outline bounds
        self.assertEqual(numpy.allclose(ot.outline_filter.output.bounds,bounds,
                                    atol=error), True)
        self.assertEqual(numpy.allclose(src.reader.data_spacing,(1., 1., 1.)),True)

    def test_mha_image_data_reader(self):
        "Test if the test fixture works"
        #Now test.

        self.check(self.scene, self.bounds)

    def test_save_and_restore(self):
        """Test if saving a visualization and restoring it works."""

        self.check_saving(self.e, self.scene, self.bounds)

    def test_deepcopied(self):
        """Test if the MayaVi2 visualization can be deep-copied."""
        ############################################################
        # Test if the MayaVi2 visualization can be deep-copied.

        self.check_deepcopying(self.scene, self.bounds)

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_image_plane_widget
# Author: Suyog Dutt Jain <suyog.jain@aero.iitb.ac.in>
#         Prabhu Ramachandran <prabhu_r@users.sf.net>
# Copyright (c) 2008,  Enthought, Inc.
# License: BSD Style.

# Standard library imports.
from os.path import abspath
from StringIO import StringIO
import copy
import numpy
import unittest


# Enthought library imports
from mayavi.core.engine import Engine
from mayavi.core.null_engine import NullEngine
from mayavi.sources.array_source import ArraySource
from mayavi.modules.outline import Outline
from mayavi.modules.image_plane_widget import ImagePlaneWidget

class TestImagePlaneWidget(unittest.TestCase):


    def make_data(self):
        """Creates suitable data for the test."""
        dims = numpy.array((64, 64, 64), 'i')

        # Create some scalars to render.
        dx, dy, dz = 10.0/(dims - 1)
        x = numpy.reshape(numpy.arange(-5.0, 5.0+dx*0.5, dx, 'f'),
                          (dims[0], 1, 1))
        y = numpy.reshape(numpy.arange(-5.0, 5.0+dy*0.5, dy, 'f'),
                          (1, dims[1], 1))
        z = numpy.reshape(numpy.arange(-5.0, 5.0+dz*0.5, dz, 'f'),
                          (1, 1, dims[0]))
        scalars = numpy.sin(x*y*z)/(x*y*z)
        return scalars

    def setUp(self):
        """Initial setting up of test fixture, automatically called by TestCase before any other test method is invoked"""
        e = NullEngine()
        # Uncomment to see visualization for debugging etc.
        #e = Engine()
        e.start()
        s=e.new_scene()
        self.e=e
        self.s=s

        ############################################################
        # Create a new scene and set up the visualization.

        d = ArraySource()

        sc = self.make_data()
        d.scalar_data = sc

        e.add_source(d)

        # Create an outline for the data.
        o = Outline()
        e.add_module(o)
        # ImagePlaneWidgets for the scalars
        ipw = ImagePlaneWidget()
        e.add_module(ipw)

        ipw_y = ImagePlaneWidget()
        e.add_module(ipw_y)
        ipw_y.ipw.plane_orientation = 'y_axes'

        ipw_z = ImagePlaneWidget()
        e.add_module(ipw_z)
        ipw_z.ipw.plane_orientation = 'z_axes'
        self.scene = e.current_scene
        return

    def tearDown(self):
        """For necessary clean up, automatically called by TestCase after the test methods have been invoked"""
        self.e.stop()
        return

    def check(self):
        """Do the actual testing."""

        s=self.scene
        src = s.children[0]
        i1, i2, i3 = src.children[0].children[1:]
        self.assertEqual(i1.ipw.plane_orientation,'x_axes')
        self.assertEqual(numpy.allclose(i1.ipw.center, (0, 31.5, 31.5)),True)
        self.assertEqual( i2.ipw.plane_orientation,'y_axes')
        self.assertEqual(numpy.allclose(i2.ipw.center, (31.5, 0, 31.5)),True)
        self.assertEqual(i3.ipw.plane_orientation,'z_axes')
        self.assertEqual( numpy.allclose(i3.ipw.center, (31.5, 31.5, 0)),True)


    def test_image_plane_widget(self):
        "Test if the test fixture works"
        self.check()

    def test_save_and_restore(self):
        """Test if saving a visualization and restoring it works."""
        engine = self.e
        scene = self.scene
        # Save visualization.
        f = StringIO()
        f.name = abspath('test.mv2') # We simulate a file.
        engine.save_visualization(f)
        f.seek(0) # So we can read this saved data.

        # Remove existing scene.

        engine.close_scene(scene)

        # Load visualization
        engine.load_visualization(f)
        self.scene = engine.current_scene

        self.check()

    def test_deepcopied(self):
        """Test if the MayaVi2 visualization can be deep-copied."""
        ############################################################
        # Test if the MayaVi2 visualization can be deep-copied.

        # Pop the source object.
        s =  self.scene
        sources = s.children
        s.children = []
        # Add it back to see if that works without error.
        s.children.extend(sources)

        self.check()

        # Now deepcopy the source and replace the existing one with
        # the copy.  This basically simulates cutting/copying the
        # object from the UI via the right-click menu on the tree
        # view, and pasting the copy back.
        sources1 = copy.deepcopy(sources)
        s.children[:] = sources1
        self.check()


if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_ipw_multiple_scalars
import unittest

from numpy import zeros, random
from tvtk.api import tvtk
from tvtk.common import is_old_pipeline
from mayavi.sources.vtk_data_source import VTKDataSource
from mayavi.core.null_engine import NullEngine
from mayavi.modules.image_plane_widget import ImagePlaneWidget

class TestIPWMultipleScalars(unittest.TestCase):
    def setUp(self):
        # Create dataset with multiple scalars.
        arr1 = zeros(27, 'f')
        for n in range(27):
            arr1[n] = (1+float(n))/10.0
        arr2 = (arr1 + 1).astype('d')
        arr3 = arr1 + 2.0*(0.5 - random.random(27))
        arr3 = arr3.astype('f')

        if is_old_pipeline():
            p = tvtk.ImageData(dimensions=[3,3,3],spacing=[1,1,1],
                               scalar_type='int')
        else:
            p = tvtk.ImageData(dimensions=[3,3,3],spacing=[1,1,1])
        p.point_data.scalars = arr1
        p.point_data.scalars.name = 'first'
        j2 = p.point_data.add_array(arr2)
        p.point_data.get_array(j2).name='second'
        j3 = p.point_data.add_array(arr3)
        p.point_data.get_array(j3).name='third'
        self.img = p
        self.first = arr1
        self.second = arr2
        self.third = arr3

        # Setup the mayavi pipeline.
        e = NullEngine()
        e.start()
        e.new_scene()
        self.e = e

        src = VTKDataSource(data=p)
        e.add_source(src)
        self.src = src
        ipw = ImagePlaneWidget()
        e.add_module(ipw)
        self.ipw = ipw

    def tearDown(self):
        self.e.stop()
        return

    def test_ipw(self):
        """Test the image plane widget."""
        arr1, arr2, arr3 = self.first, self.second, self.third
        ipw = self.ipw.ipw
        
        scalars = ipw.input.point_data.scalars

        r = scalars.range
        expect = min(arr1), max(arr1)
        self.assertEqual(r, expect)
        o = self.src.outputs[0]
        o.update_traits()
        if is_old_pipeline():
            st = ipw.input.scalar_type
        else:
            st = ipw.input.scalar_type_as_string
        self.assertEqual(scalars.data_type, 10)
        self.assertEqual(st, 'float')

        self.src.point_scalars_name = 'second'
        scalars = ipw.input.point_data.scalars
        r = scalars.range
        expect = min(arr2), max(arr2)
        self.assertEqual(r, expect)
        o.update_traits()
        if is_old_pipeline():
            st = ipw.input.scalar_type
        else:
            st = ipw.input.scalar_type_as_string
        self.assertEqual(scalars.data_type, 11)
        self.assertEqual(st, 'double')

        self.src.point_scalars_name = 'third'
        scalars = ipw.input.point_data.scalars
        r = scalars.range
        expect = min(arr3), max(arr3)
        self.assertEqual(r, expect)
        o.update_traits()
        if is_old_pipeline():
            st = ipw.input.scalar_type
        else:
            st = ipw.input.scalar_type_as_string
        self.assertEqual(scalars.data_type, 10)
        self.assertEqual(st, 'float')

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_mayavi_traits
"""
Tests for traits defined in mayavi.core.traits
"""
# Author: Prabhu Ramachandran <prabhu@aero.iitb.ac.in>
# Copyright (c) 2008, Prabhu Ramachandran Enthought, Inc.
# License: BSD Style.

import unittest
import numpy
from traits.api import (HasTraits, Either, Array, Any,
                TraitError, Float, Int)
from mayavi.core.trait_defs import ShadowProperty


ArrayOrNone = Either(None, Array)
class DataNotSmart(HasTraits):
    x = ShadowProperty(ArrayOrNone, smart_notify=False)
    # Test attribute.
    _test = Any
    def _x_changed(self, value):
        self._test = value.copy()

class DataSmart(HasTraits):
    x = ShadowProperty(ArrayOrNone, smart_notify=True)
    # Test attribute.
    _test = Any
    def _x_changed(self, value):
        self._test = value.copy()

class Simple(HasTraits):
    x = ShadowProperty(Float)
    # Test attribute.
    _test = Int(0)
    def _x_changed(self, value):
        self._test += 1


class TestShadowProperty(unittest.TestCase):
    def test_simple_case(self):
        "Test a simple trait wrapped as a shadow property."
        s = Simple(x=10.0)
        self.assertEqual(s._test, 1)
        self.assertEqual(s.x, 10.0)
        s.x = 10.0
        self.assertEqual(s._test, 1)
        self.assertEqual(s.x, 10.0)
        s.x = 20.0
        self.assertEqual(s._test, 2)
        self.assertEqual(s.x, 20.0)
        self.assertRaises(TraitError, s.__setattr__, 'x', 'hey')

    def test_shadow_property_smart(self):
        "Test if the shadow property trait type works correctly."
        x = numpy.linspace(0, 1)
        d = DataSmart(x=x)
        self.assertEqual(numpy.all(d.x == x), True)
        self.assertEqual(numpy.all(d._x == x), True)
        self.assertEqual(numpy.all(d._test == x), True)
        old = x.copy()
        x *= 2
        d.x = x
        self.assertEqual(numpy.all(d.x == x), True)
        self.assertEqual(numpy.all(d._x == x), True)
        # Notifier shouldn't be called.
        self.assertEqual(numpy.all(d._test == old), True)

    def test_shadow_property_not_smart(self):
        "Test if the shadow property trait type works correctly."
        x = numpy.linspace(0, 1)
        d = DataNotSmart(x=x)
        self.assertEqual(numpy.all(d.x == x), True)
        self.assertEqual(numpy.all(d._x == x), True)
        self.assertEqual(numpy.all(d._test == x), True)
        x *= 2
        d.x = x
        self.assertEqual(numpy.all(d.x == x), True)
        self.assertEqual(numpy.all(d._x == x), True)
        self.assertEqual(numpy.all(d._test == x), True)

    def test_type_checking(self):
        "Test if the validation works correctly."
        x = numpy.linspace(0, 1)
        d = DataNotSmart(x=x)
        self.assertRaises(TraitError, d.__setattr__, 'x', 'hey')

    def test_set_trait_change_notify(self):
        "If trait_change_notify is honored."
        s = Simple()
        trait_names = s.trait_names()
        s.x = 10.0
        self.assertEqual(s._test, 1)
        self.assertEqual(s.x, 10.0)
        s.set(x=20.0, trait_change_notify=False)
        self.assertEqual(s._test, 1)
        self.assertEqual(s.x, 20.0)
        # Assert that no new traits were added and no new notifiers were
        # added.
        self.assertEqual(s.trait_names(), trait_names)
        self.assertEqual(s._notifiers(False), None)

if __name__ == '__main__':
    unittest.main()


########NEW FILE########
__FILENAME__ = test_mlab_integration
"""
Integration tests of mlab with the null engine.

This also tests some numerics with VTK.
"""

import unittest

import numpy as np

from mayavi import mlab
from mayavi.core.null_engine import NullEngine
from mayavi.core.engine import Engine
from tvtk.api import tvtk
from mayavi.tools.engine_manager import engine_manager
from mayavi.core.registry import registry


################################################################################
# class `TestMlabNullEngine`
################################################################################
class TestMlabNullEngine(unittest.TestCase):
    """ Stub mlab to isolate as well as possible from creation of a new
        figure.
    """

    def setUp(self):
        mlab.options.backend = 'test'
        e = NullEngine()
        e.start()
        mlab.set_engine(e)
        self.e = e

    def tearDown(self):
        # Check that the NullEngine is still the mlab engine
        if not mlab.get_engine() is self.e:
            raise AssertionError, \
                    "The NullEngine has been overridden"
        engine_manager.current_engine = None
        # Unregistering the engine, to avoid side-effects between tests
        self.e.stop()
        registry.unregister_engine(self.e)


################################################################################
# class `TestMlabNullEngineMisc`
################################################################################
class TestMlabNullEngineMisc(TestMlabNullEngine):
    """ Misc tests for mlab with the null engine
    """
    def test_contour_filter(self):
        a = np.zeros((3, 3, 3))
        a[1, 1, 1] = 1

        src = mlab.pipeline.scalar_field(a)
        filter = mlab.pipeline.contour(src)

        x, y, z = filter.outputs[0].points.to_array().T

        # Check that the contour filter indeed did its work:
        np.testing.assert_almost_equal(x, [ 2. ,  2. ,  1.5,  2.5,  2. ,  2. ])
        np.testing.assert_almost_equal(y, [ 2. ,  1.5,  2. ,  2. ,  2.5,  2. ])
        np.testing.assert_almost_equal(z, [ 1.5,  2. ,  2. ,  2. ,  2. ,  2.5])

        # Check that the filter was not added to a live scene:
        if filter.scene is not None:
            raise AssertionError, "The NullEngine seems not to work"

    def test_user_defined_filter(self):
        x, y, z = np.random.random((3, 100))
        src = mlab.pipeline.scalar_scatter(x, y, z)
        density = mlab.pipeline.user_defined(src, filter='GaussianSplatter')

        self.assertEqual(len(density.outputs), 1)
        self.assert_(isinstance(density.outputs[0], tvtk.ImageData))

    def test_mlab_source(self):
        """ Check that the different objects created by mlab have an
            'mlab_source' attribute.
        """
        # Test for functions taking 3D scalar data
        pipelines = (
            (mlab.pipeline.scalar_scatter, ),
            (mlab.pipeline.scalar_field, ),
            (mlab.pipeline.scalar_field, mlab.pipeline.image_plane_widget),
            (mlab.contour3d, ),
            (mlab.points3d, ), )
        data = np.random.random((3, 3, 3))
        for pipeline in pipelines:
            obj = pipeline[0](data)
            for factory in pipeline[1:]:
                obj = factory(obj)
            self.assertTrue(hasattr(obj, 'mlab_source'))
        # Test for functions taking x, y, z 2d arrays.
        x, y, z = np.random.random((3, 3, 3))
        pipelines = (
            (mlab.mesh, ),
            (mlab.surf, ),
            (mlab.quiver3d, ),
            (mlab.pipeline.vector_scatter, ),
            (mlab.pipeline.vector_scatter,
                            mlab.pipeline.extract_vector_components),
            (mlab.pipeline.vector_scatter,
                            mlab.pipeline.extract_vector_norm),
            (mlab.pipeline.array2d_source, ), )
        for pipeline in pipelines:
            obj = pipeline[0](x, y, z)
            for factory in pipeline[1:]:
                obj = factory(obj)
            self.assertTrue(hasattr(obj, 'mlab_source'))

    def test_figure(self):
        """ Various tests for mlab.figure().
        """
        # Test when specifying figure instances
        f1 = mlab.figure()
        e = mlab.get_engine()
        self.assert_(e.current_scene is f1)
        f2 = mlab.figure()
        self.assert_(e.current_scene is f2)
        mlab.figure(f1)
        self.assert_(e.current_scene is f1)

        # Test when specifying figure numbers
        f1 = mlab.figure(3)
        self.assert_(e.current_scene is f1)
        f2 = mlab.figure(4)
        self.assert_(e.current_scene is f2)
        mlab.figure(3)
        self.assert_(e.current_scene is f1)

        # Test when specifying figure names
        f1 = mlab.figure('Test 1')
        self.assert_(e.current_scene is f1)
        f2 = mlab.figure('Test 2')
        self.assert_(e.current_scene is f2)
        mlab.figure('Test 1')
        self.assert_(e.current_scene is f1)

    def test_close(self):
        """ Various tests for mlab.close().
        """
        f = mlab.figure()
        self.assert_(f.running)
        mlab.close(f)
        self.assertFalse(f.running)

        f = mlab.figure(314)
        self.assert_(f.running)
        mlab.close(314)
        self.assertFalse(f.running)

        f = mlab.figure('test_figure')
        self.assert_(f.running)
        mlab.close('test_figure')
        self.assertFalse(f.running)

        f = mlab.figure()
        self.assert_(f.running)
        mlab.close()
        self.assertFalse(f.running)

        figs = [mlab.figure() for i in range(5)]
        for f in figs:
            self.assert_(f.running)
        mlab.close(all=True)
        for f in figs:
            self.assertFalse(f.running)

    def test_triangular_mesh_reset(self):
        """ When reseting the triangular mesh (ie polydata), if we are
            not careful, we can create a segfault by passing triangules
            between points that do not exist.
        """
        # We need to run this as a full test of mlab, rather than only a
        # test of the source, as to get a segfault, we need a module
        # opened on the source.
        n = 100
        triangles = np.c_[np.arange(n-3),
                            np.arange(n-3)+1,
                            n-1-np.arange(n-3)]
        x, y, z = np.random.random((3, n))
        src = mlab.triangular_mesh(x, y, z, triangles)

        # Now grow the mesh
        n = 1000
        triangles = np.c_[np.arange(n-3),
                            np.arange(n-3)+1,
                            n-1-np.arange(n-3)]
        x, y, z = np.random.random((3, n))
        src.mlab_source.reset(x=x, y=y, z=z, triangles=triangles)

    def test_colorbar(self):
        """ Test that when an object with scalars hidden is created, it
            does not get a colorbar, unless no other is avalaible.
        """
        a = np.random.random((5, 5))
        s1 = mlab.surf(a, colormap='gist_earth')
        s2 = mlab.surf(a, color=(0, 0, 0))
        mlab.colorbar()
        self.assertEqual(
                    s2.module_manager.scalar_lut_manager.show_scalar_bar,
                    False)
        self.assertEqual(
                    s1.module_manager.scalar_lut_manager.show_scalar_bar,
                    True)


################################################################################
# class `TestMlabPipeline`
################################################################################
class TestMlabPipeline(TestMlabNullEngine):
    """ Test the pipeline functions.
        For vtk versions greater than 5.6 (5.10.1 onwards), widgets need
        a render window interactor to be set, otherwise an error is raised.
        As such this test checks for the current VTK version and setups a real
        engine for vtk > 5.6 and null engine otherwise.
    """

    def setUp(self):
        ver = tvtk.Version()
        self.less_than_vtk_5_6 = True
        if ver.vtk_major_version >= 5 and ver.vtk_minor_version >= 10:
            self.less_than_vtk_5_6 = False
        if self.less_than_vtk_5_6:
            super(TestMlabPipeline, self).setUp()
        else:
            e = Engine()
            e.start()
            mlab.set_engine(e)

    def tearDown(self):
        if self.less_than_vtk_5_6:
            super(TestMlabPipeline, self).setUp()
        else:            
            for engine in registry.engines.keys():
                registry.unregister_engine(engine)
    
    def test_probe_data(self):
        """ Test probe_data
        """
        x, y, z = np.mgrid[0:1:10j, 0:1:10j, 0:1:10j]
        r = np.sqrt(x**2 + y**2 + z**2)
        iso = mlab.contour3d(x, y, z, r)
        x_, y_, z_ = np.random.random((3, 10, 4, 2))
        r_ = mlab.pipeline.probe_data(iso, x_, y_, z_)
        np.testing.assert_array_almost_equal(r_,
                                             np.sqrt(x_**2 + y_**2 + z_**2),
                                             decimal=1)
        flow = mlab.flow(x, y, z, x, y, z)
        u_, v_, w_ = mlab.pipeline.probe_data(flow, x_, y_, z_,
                                              type='vectors')
        np.testing.assert_array_almost_equal(u_, x_,
                                             decimal=2)
        np.testing.assert_array_almost_equal(v_, y_,
                                             decimal=2)
        np.testing.assert_array_almost_equal(w_, z_,
                                             decimal=3)


################################################################################
# class `TestMlabHelperFunctions`
################################################################################
class TestMlabHelperFunctions(TestMlabNullEngine):
    """ Test various behaviors of the mlab helper functions.
    """

    def test_barchart(self):
        s = np.random.random((10, 10))
        x, y = np.indices(s.shape)
        bar1 = mlab.barchart(x, y, s)
        bar2 = mlab.barchart(s)
        bar3 = mlab.barchart(s, auto_scale=False)

        # Check that auto scaling worked well in the different
        # configurations
        for bar in bar1, bar2, bar3:
            self.assertEqual(bar.glyph.glyph_source.glyph_source.y_length, 0.9)

    def test_imshow(self):
        s = np.random.random((10, 10))
        # This should work.
        obj = mlab.imshow(s)


################################################################################
# class `TestMlabModules`
################################################################################
class TestMlabModules(TestMlabNullEngine):
    """ Test the mlab modules.
    """
    def test_volume(self):
        """ Test the mlab volume factory.
        """
        scalars = np.zeros((3, 3, 3))
        scalars[0] = 1
        src = mlab.pipeline.scalar_field(scalars)
        color = (1, 0.1, 0.314)
        vol = mlab.pipeline.volume(src, vmin=0.5, vmax=0.9, color=color)
        # Test the color feature
        for value in np.random.random(10):
            # get_color() will sometimes return .314 as .313999...9995, so we
            # use allclose() to match the tuples.
            np.allclose(vol._ctf.get_color(value), color)
        # Test the vmin and vmax features
        for value in 0.5*np.random.random(10):
            self.assertEqual(vol._otf.get_value(value), 0)
        for value in (0.9+0.1*np.random.random(10)):
            self.assertEqual(vol._otf.get_value(value), 0.2)
        # Test the rescaling of the colormap when using vmin and vmax
        # Rmq: we have to be careful: the range of the ctf can change
        vol1 = mlab.pipeline.volume(src)
        range1 = vol1._ctf.range[1] - vol1._ctf.range[0]
        vol2 = mlab.pipeline.volume(src, vmin=0.25, vmax=0.75)
        range2 = vol2._ctf.range[1] - vol2._ctf.range[0]
        for value in 0.5*np.random.random(10):
            np.testing.assert_array_almost_equal(
                        vol1._ctf.get_color(2*range1*value),
                        vol2._ctf.get_color(0.25+range2*value))
        # Test outside the special [0, 1] range
        src = mlab.pipeline.scalar_field(2*scalars)
        vol1 = mlab.pipeline.volume(src)
        range1 = vol1._ctf.range[1] - vol1._ctf.range[0]
        vol2 = mlab.pipeline.volume(src, vmin=0.5, vmax=1.5)
        range2 = vol2._ctf.range[1] - vol2._ctf.range[0]
        for value in np.random.random(10):
            np.testing.assert_array_almost_equal(
                        vol1._ctf.get_color(2*range1*value),
                        vol2._ctf.get_color(0.5+range2*value))

    def test_text(self):
        """ Test the text module.
        """
        data = np.random.random((3, 3, 3))
        src = mlab.pipeline.scalar_field(data)
        # Some smoke testing
        mlab.text(0.1, 0.9, 'foo')
        mlab.text(3, 3, 'foo', z=3)
        mlab.title('foo')
        # Check that specifying 2D positions larger than 1 raises an
        # error
        self.assertRaises(ValueError, mlab.text, 0, 1.5, 'test')

    def test_text3d(self):
        """ Test the text3d module.
        """
        data = np.random.random((3, 3, 3))
        src = mlab.pipeline.scalar_field(data)
        t = mlab.text3d(0, 0, 0, 'foo', opacity=0.5, scale=2,
                    orient_to_camera=False, color=(0, 0, 0),
                    orientation=(90, 0, 0))

    def test_contour_grid_plane(self):
        """Test the contour_grid_plane.
        """
        data = np.random.random((10, 10, 10))
        src = mlab.pipeline.scalar_field(data)
        mlab.pipeline.outline(src)
        mlab.pipeline.grid_plane(src)
        mlab.pipeline.contour_grid_plane(src)

    def test_barchart(self):
        """Test the barchart function."""

        s = np.abs(np.random.random((3,3)))
        b = mlab.barchart(s)
        self.assertEqual(b.glyph.glyph.scale_mode,
                         'scale_by_vector_components')
        s += 1
        b.mlab_source.update()
        self.assertEqual(b.glyph.glyph.scale_mode,
                         'scale_by_vector_components')


if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_mlab_null_engine
"""
Test the mlab null engine.
"""

import unittest

from mayavi import mlab
from mayavi.core.engine import Engine
from mayavi.tools.engine_manager import engine_manager
from mayavi.core.registry import registry
from mayavi.tests.common import get_example_data

################################################################################
# class `TestMlabNullEngineBase`
################################################################################
class TestMlabNullEngineBase(unittest.TestCase):
    """ Base class to test mlab with the null engine
    """
    def setUp(self):
        e = Engine()
        e.start()
        self._non_null_engine = e
        mlab.set_engine(e)

    def tearDown(self):
        # Check that the NullEngine was not set as the default mlab engine.
        if not mlab.get_engine() is self._non_null_engine:
            raise AssertionError, \
                    "The NullEngine has overridden the default one"
        engine_manager.current_engine = None
        # Unregistering all unused engines.
        registry.unregister_engine(self._non_null_engine)
        for engine in registry.engines.keys():
            registry.unregister_engine(engine)


################################################################################
# class `TestRealMlabNullEngine`
################################################################################
class TestRealMlabNullEngine(unittest.TestCase):
    """Tests if the mlab settings via the options.backend and offscreen
    options work correctly."""

    def setUp(self):
        self.backend = mlab.options.backend

    def tearDown(self):
        mlab.options.backend = self.backend
        for engine in registry.engines.keys():
            registry.unregister_engine(engine)

    def test_test_backend(self):
        """Test if setting the backend to 'test' works."""
        mlab.options.backend = 'test'
        mlab.test_contour3d()
        mlab.clf()
        mlab.pipeline.open(get_example_data('cube.vti'))
        mlab.clf()

if __name__ == '__main__':
    unittest.main()


########NEW FILE########
__FILENAME__ = test_mlab_scene_model
"""
Testing the MlabSceneModel
"""
import unittest

import numpy as np

from traits.api import HasTraits, Instance
from mayavi.tools.mlab_scene_model import MlabSceneModel
from mayavi import mlab

from test_mlab_integration import TestMlabNullEngine

###############################################################################
# class `TestMlabSceneModel`
###############################################################################
class TestMlabSceneModel(TestMlabNullEngine):
    """ Testing the MlabSceneModel, in particular the magic
        mlab attribute.
    """

    def test_several_scene_models(self):
        """ Check that plotting to scene attributes using their
            mlab attribute does create objects as children, and does not
            unset the current scene
        """
        class TestObject(HasTraits):
            scene1 = Instance(MlabSceneModel, ())
            scene2 = Instance(MlabSceneModel, ())

        test_object = TestObject()
        x, y, z = np.random.random((3, 10))
        plt = mlab.plot3d(x, y, z,
                    figure=test_object.scene1.mayavi_scene)
        pts = mlab.points3d(x, y, z,
                    figure=test_object.scene2.mayavi_scene)

        # Check that each figure got the module it should have
        self.assertEqual(plt.scene, test_object.scene1)
        self.assertEqual(pts.scene, test_object.scene2)


if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_mlab_source
"""
Test for MlabSource and its subclasses.
"""
# Author: Prabhu Ramachandran <prabhu@aero.iitb.ac.in>
# Copyright (c) 2008, Enthought, Inc.
# License: BSD Style.

import unittest
import numpy as N

from mayavi.tools import sources

################################################################################
# `TestMGlyphSource`
################################################################################
class TestMGlyphSource(unittest.TestCase):
    def setUp(self):
        self.x = x = N.ones(10, float)
        self.y = y = N.ones(10, float)*2.0
        self.z = z = N.linspace(0, 10, 10)
        self.v = v = N.ones((10, 3), float)*10.0
        self.s = s = N.ones(10, float)
        src = sources.MGlyphSource()
        src.reset(x=x, y=y, z=z, u=v[:,0], v=v[:,1], w=v[:,2], scalars=s)
        self.src = src

    def tearDown(self):
        return

    def get_data(self):
        return self.x, self.y, self.z, self.v, self.s, self.src

    def check_traits(self):
        """Check if the sources traits are set correctly."""
        x, y, z, v, s, src = self.get_data()
        # Check if points are set correctly.
        self.assertEqual(N.alltrue(src.points[:,0].ravel() == x.ravel()), True)
        self.assertEqual(N.alltrue(src.points[:,1].ravel() == y.ravel()), True)
        self.assertEqual(N.alltrue(src.points[:,2].ravel() == z.ravel()), True)
        # Check the vectors and scalars.
        self.assertEqual(N.alltrue(src.vectors == v), True)
        self.assertEqual(N.alltrue(src.scalars == s), True)

    def check_dataset(self):
        """Check the TVTK dataset."""
        x, y, z, v, s, src = self.get_data()
        # Check if the dataset is setup right.
        pts = src.dataset.points.to_array()
        self.assertEqual(N.alltrue(pts[:,0].ravel() == x.ravel()), True)
        self.assertEqual(N.alltrue(pts[:,1].ravel() == y.ravel()), True)
        self.assertEqual(N.alltrue(pts[:,2].ravel() == z.ravel()), True)
        vec = src.dataset.point_data.vectors.to_array()
        sc = src.dataset.point_data.scalars.to_array()
        self.assertEqual(N.alltrue(vec == v), True)
        self.assertEqual(N.alltrue(sc == s.ravel()), True)

    def test_reset(self):
        "Test the reset method."
        x, y, z, v, s, src = self.get_data()
        self.check_traits()
        self.check_dataset()

        # Call reset again with just a few things changed to see if it
        # works correctly.
        x *= 5
        s *= 10
        v *= 0.1
        src.reset(x=x, u=v[:,0], v=v[:,1], w=v[:,2], scalars=s)

        self.check_traits()
        self.check_dataset()

    def test_reset1(self):

        "Test the reset method."
        x, y, z, v, s, src = self.get_data()
        self.check_traits()
        self.check_dataset()
        # Call reset again with just a few things changed to see if it
        # works correctly.

        self.x = x = N.ones(20, float)*30.0
        self.y = y = N.ones(20, float)*30.0
        self.z = z = N.ones(20, float)*30.0
        points = N.ones((20, 3), float)*30.0
        self.s = s = N.ones(20, float)
        self.v = v = N.ones((20, 3), float)*30.0

        src.reset(x=x,y=y,z=z, u=v[:,0], v=v[:,1], w=v[:,2], scalars=s,points=points,vectors=v)
        self.check_traits()
        self.check_dataset()

    def test_reset_strange_shape(self):
        " Test the reset method when the inputs are 2-d arrays."

        x, y, z, v, s, src = self.get_data()
        self.x = x = N.reshape(x, (5,2))
        self.y = y = N.reshape(y, (5,2))
        self.z = z = N.reshape(z, (5,2))
        u = N.reshape(v[:,0], (5,2))
        vv = N.reshape(v[:,1], (5,2))
        w = N.reshape(v[:,2], (5,2))
        self.s = s = N.reshape(s, (5,2))
        src.reset(x=x, y=y, z=z, u=u, v=vv, w=w, scalars=s)
        self.check_traits()
        self.check_dataset()


    def test_handlers(self):
        "Test if the various static handlers work correctly."
        x, y, z, v, s, src = self.get_data()
        x *= 2
        y *= 2
        z *= 2
        v *= 2
        s *= 2
        src.x = x
        src.y = y
        src.z = z
        src.u = v[:,0]
        src.v = v[:,1]
        src.w = v[:,2]
        src.scalars = s
        self.check_traits()
        self.check_dataset()

    def test_handlers_strange_shape(self):
        "Test if the various static handlers work correctly for strange shapes."
        # Initialize with 2-d array data.
        x, y, z, v, s, src = self.get_data()
        x = N.reshape(x, (5,2))
        y = N.reshape(y, (5,2))
        z = N.reshape(z, (5,2))
        u = N.reshape(v[:,0], (5,2))
        vv = N.reshape(v[:,1], (5,2))
        w = N.reshape(v[:,2], (5,2))
        s = N.reshape(s, (5,2))
        src.reset(x=x, y=y, z=z, u=u, v=vv, w=w, scalars=s)

        # modify variables in src to check handlers
        self.x = src.x = 2*x
        self.y = src.y = 2*y
        self.z = src.z = 2*z
        src.u = 2*z
        src.v = 2*vv
        src.w = 2*w
        self.v[:,0] = src.u.ravel()
        self.v[:,1] = src.v.ravel()
        self.v[:,2] = src.w.ravel()
        self.s = src.scalars = 2*s
        self.check_traits()
        self.check_dataset()

    def test_set(self):
        "Test if the set method works correctly."
        x, y, z, v, s, src = self.get_data()
        x *= 2
        z *= 2
        s *= 2
        src.set(x=x, z=z, scalars=s)
        self.check_traits()
        self.check_dataset()

    def test_strange_shape(self):
        " Test the MGlyphSource with strange shapes for the arguments "
        x, y, z, v, s, src = self.get_data()
        x = y = z = v = s = 0
        src.reset(x=x, y=y, z=z, u=v, v=v, w=v, scalars=None)
        src.reset(x=x, y=y, z=z, u=v, v=v, w=v, scalars=s)
        x = y = z = v = s = 1
        src.set(x=x, y=y, z=z, u=v, v=v, w=v, scalars=None)
        src.set(x=x, y=y, z=z, u=v, v=v, w=v, scalars=s)


################################################################################
# `TestMGlyphSource`
################################################################################
class TestMVerticalSource(unittest.TestCase):
    def setUp(self):
        self.x = x = N.ones(10, float)
        self.y = y = N.ones(10, float)*2.0
        self.z = z = N.linspace(0, 10, 10)
        self.s = s = N.ones(10, float)
        src = sources.MVerticalGlyphSource()
        src.reset(x=x, y=y, z=z, scalars=s)
        self.src = src

    def tearDown(self):
        return

    def get_data(self):
        return self.x, self.y, self.z, self.s, self.src

    def check_traits(self):
        """Check if the sources traits are set correctly."""
        x, y, z, s, src = self.get_data()
        # Check if points are set correctly.
        self.assertEqual(N.alltrue(src.points[:,0].ravel() == x), True)
        self.assertEqual(N.alltrue(src.points[:,1].ravel() == y), True)
        self.assertEqual(N.alltrue(src.points[:,2].ravel() == z), True)
        # Check the vectors and scalars.
        self.assertEqual(N.alltrue(src.vectors[:, -1] == s), True)
        self.assertEqual(N.alltrue(src.vectors[:, :-1] == 1), True)
        self.assertEqual(N.alltrue(src.scalars == s), True)

    def check_dataset(self):
        """Check the TVTK dataset."""
        x, y, z, s, src = self.get_data()
        # Check if the dataset is setup right.
        pts = src.dataset.points.to_array()
        self.assertEqual(N.alltrue(pts[:,0].ravel() == x), True)
        self.assertEqual(N.alltrue(pts[:,1].ravel() == y), True)
        self.assertEqual(N.alltrue(pts[:,2].ravel() == z), True)
        vec = src.dataset.point_data.vectors.to_array()
        sc = src.dataset.point_data.scalars.to_array()
        self.assertEqual(N.alltrue(vec[:, -1] == s), True)
        self.assertEqual(N.alltrue(vec[:, :-1] == 1), True)
        self.assertEqual(N.alltrue(sc == s), True)

    def test_reset(self):
        "Test the reset method."
        x, y, z, s, src = self.get_data()
        self.check_traits()
        self.check_dataset()

        # Call reset again with just a few things changed to see if it
        # works correctly.
        x *= 5
        s *= 10
        src.reset(x=x, scalars=s)

        self.check_traits()
        self.check_dataset()

    def test_reset1(self):

        "Test the reset method."
        x, y, z, s, src = self.get_data()
        self.check_traits()
        self.check_dataset()
        # Call reset again with just a few things changed to see if it
        # works correctly.

        self.x = x = N.ones(20, float)*30.0
        self.y = y = N.ones(20, float)*30.0
        self.z = z = N.ones(20, float)*30.0
        points = N.ones((20, 3), float)*30.0
        self.s = s = N.ones(20, float)

        src.reset(x=x, y=y, z=z, scalars=s, points=points)
        self.check_traits()
        self.check_dataset()

    def test_handlers(self):
        "Test if the various static handlers work correctly."
        x, y, z, s, src = self.get_data()
        x *= 2
        y *= 2
        z *= 2
        s *= 2
        src.x = x
        src.y = y
        src.z = z
        src.scalars = s
        self.check_traits()
        self.check_dataset()

    def test_set(self):
        "Test if the set method works correctly."
        x, y, z, s, src = self.get_data()
        x *= 2
        z *= 2
        s *= 2
        src.set(x=x, z=z, scalars=s)
        self.check_traits()
        self.check_dataset()


################################################################################
# `TestMArraySource`
################################################################################
class TestMArraySource(unittest.TestCase):
    def setUp(self):
        x, y, z = N.ogrid[-10:10:11j,
                          -10:10:12j,
                          -10:10:20j]
        self.x, self.y, self.z = x, y, z
        dims = (x.shape[0], y.shape[1], z.shape[2])
        self.v = v = N.ones(dims + (3,), float)
        v[...,2] = 2
        v[...,2] = 3
        self.s = s = N.ones(dims, float)
        src = sources.MArraySource()
        src.reset(x=x, y=y, z=z, u=v[...,0], v=v[...,1], w=v[...,2], scalars=s)
        self.src = src

    def tearDown(self):
        return

    def get_data(self):
        return self.x, self.y, self.z, self.v, self.s, self.src

    def check_traits(self):
        """Check if the sources traits are set correctly."""
        x, y, z, v, s, src = self.get_data()
        # Check if points are set correctly.
        self.assertEqual(N.alltrue(src.x == x), True)
        self.assertEqual(N.alltrue(src.y == y), True)
        self.assertEqual(N.alltrue(src.z == z), True)
        # Check the vectors and scalars.
        self.assertEqual(N.alltrue(src.vectors == v), True)
        self.assertEqual(N.alltrue(src.scalars == s), True)

    def check_dataset(self):
        """Check the TVTK dataset."""
        x, y, z, v, s, src = self.get_data()
        # Check if the dataset is setup right.
        dx = x[1, 0, 0] - x[0, 0, 0]
        dy = y[0, 1, 0] - y[0, 0, 0]
        dz = z[0, 0, 1] - z[0, 0, 0]
        origin = [x.min(), y.min(), z.min()]
        spacing = [dx, dy, dz]
        dimensions = (x.shape[0], y.shape[1], z.shape[2])
        ds = src.dataset
        self.assertEqual(N.all(src.m_data.origin == origin), True)
        self.assertEqual(N.allclose(src.m_data.spacing, spacing), True)
        self.assertEqual(N.allclose(ds.dimensions, dimensions), True)

        vec = src.dataset.point_data.vectors.to_array()
        sc = src.dataset.point_data.scalars.to_array()
        v1 = v.transpose((2, 0, 1, 3))
        self.assertEqual(N.alltrue(vec.ravel() == v1.ravel()), True)
        s1 = s.transpose()
        self.assertEqual(N.alltrue(sc.ravel() == s1.ravel()), True)

    def test_reset(self):
        "Test the reset method."
        x, y, z, v, s, src = self.get_data()
        self.check_traits()
        self.check_dataset()

        # Call reset again with just a few things changed to see if it
        # works correctly.
        x *= 5
        s *= 10
        v *= 0.1
        src.reset(x=x, u=v[...,0], v=v[...,1], w=v[...,2], scalars=s)

        self.check_traits()
        self.check_dataset()

    def test_reset1(self):
        "Test the reset method."
        x, y, z, v, s, src = self.get_data()
        self.check_traits()
        self.check_dataset()
        # Call reset again with just a few things changed to see if it
        # works correctly.

        x, y, z = N.ogrid[-10:10:11j,
                          -10:10:12j,
                          -10:10:20j]
        self.x, self.y, self.z = x, y, z

        dims = (x.shape[0], y.shape[1], z.shape[2])
        self.v = v = N.ones(dims + (3,), float)
        v[...,2] = 2
        v[...,2] = 3
        self.s = s = N.ones(dims, float)
        src = sources.MArraySource()
        src.reset(x=x, y=y, z=z, u=v[...,0], v=v[...,1], w=v[...,2], scalars=s,vectors=v)
        self.check_traits()
        self.check_dataset()

    def test_handlers(self):
        "Test if the various static handlers work correctly."
        x, y, z, v, s, src = self.get_data()
        x *= 2
        y *= 2
        z *= 2
        v *= 2
        s *= 2
        src.x = x
        src.y = y
        src.z = z
        src.u = v[...,0]
        src.v = v[...,1]
        src.w = v[...,2]
        src.scalars = s
        self.check_traits()
        self.check_dataset()

    def test_set(self):
        "Test if the set method works correctly."
        x, y, z, v, s, src = self.get_data()
        x *= 2
        z *= 2
        s *= 2
        src.set(x=x, z=z, scalars=s)
        self.check_traits()
        self.check_dataset()



################################################################################
# `TestMLineSource`
################################################################################
class TestMLineSource(unittest.TestCase):
    def setUp(self):
        self.x = x = N.ones(10, float)
        self.y = y = N.ones(10, float)*2.0
        self.z = z = N.linspace(0, 10, 10)
        self.s = s = N.ones(10, float)
        src = sources.MLineSource()
        src.reset(x=x, y=y, z=z, scalars=s)
        self.src = src

    def tearDown(self):
        return

    def get_data(self):
        return self.x, self.y, self.z, self.s, self.src

    def check_traits(self):
        """Check if the sources traits are set correctly."""
        x, y, z, s, src = self.get_data()
        # Check if points are set correctly.
        self.assertEqual(N.alltrue(src.points[:,0].ravel() == x), True)
        self.assertEqual(N.alltrue(src.points[:,1].ravel() == y), True)
        self.assertEqual(N.alltrue(src.points[:,2].ravel() == z), True)
        # Check the scalars.
        self.assertEqual(N.alltrue(src.scalars == s), True)

    def check_dataset(self):
        """Check the TVTK dataset."""
        x, y, z, s, src = self.get_data()
        # Check if the dataset is setup right.
        pts = src.dataset.points.to_array()
        self.assertEqual(N.alltrue(pts[:,0].ravel() == x), True)
        self.assertEqual(N.alltrue(pts[:,1].ravel() == y), True)
        self.assertEqual(N.alltrue(pts[:,2].ravel() == z), True)
        sc = src.dataset.point_data.scalars.to_array()
        self.assertEqual(N.alltrue(sc == s), True)

    def test_reset(self):
        "Test the reset method."
        x, y, z, s, src = self.get_data()
        self.check_traits()
        self.check_dataset()

        # Call reset again with just a few things changed to see if it
        # works correctly.
        x *= 5
        s *= 10
        src.reset(x=x, scalars=s)

        self.check_traits()
        self.check_dataset()

        y *= 6
        x *= 4
        src.reset(x=x, y=y)

        self.check_traits()
        self.check_dataset()

        s *= 4.5
        y /= 4
        src.reset(y=y, s=s)

        self.check_traits()
        self.check_dataset()

    def test_reset1(self):

        "Test the reset method."
        x, y, z, s, src = self.get_data()
        self.check_traits()
        self.check_dataset()
        # Call reset again with just a few things changed to see if it
        # works correctly.

        self.x = x = N.ones(20, float)*30.0
        self.y = y = N.ones(20, float)*30.0
        self.z = z = N.ones(20, float)*30.0
        points = N.ones((20, 3), float)*30.0
        self.s = s = N.ones(20, float)
        src.reset(x=x,y=y,z=z,scalars=s,points=points)
        self.check_traits()
        self.check_dataset()




    def test_handlers(self):
        "Test if the various static handlers work correctly."
        x, y, z, s, src = self.get_data()
        x *= 2
        y *= 2
        z *= 2
        s *= 2
        src.x = x
        src.y = y
        src.z = z
        src.scalars = s
        self.check_traits()
        self.check_dataset()

    def test_set(self):
        "Test if the set method works correctly."
        x, y, z, s, src = self.get_data()
        x *= 2
        z *= 2
        s *= 2
        src.set(x=x, z=z, scalars=s)
        self.check_traits()
        self.check_dataset()

        y *= 2
        s *= 2
        src.set(y=y, scalars=s)
        self.check_traits()
        self.check_dataset()



################################################################################
# `TestMArray2DSource`
################################################################################
class TestMArray2DSource(unittest.TestCase):
    def setUp(self):
        x, y = N.mgrid[-10:10:11j,
                          -10:10:12j]

        self.x, self.y  = x, y
        dims = (x.shape[0], y.shape[1])
        self.s = s = N.ones(dims, float)
        src = sources.MArray2DSource()
        src.reset(x=x, y=y,scalars=s)
        self.src = src

    def tearDown(self):
        return

    def get_data(self):
        return self.x, self.y, self.s, self.src

    def check_traits(self):
        """Check if the sources traits are set correctly."""
        x, y, s, src = self.get_data()

        # Check if points are set correctly.
        self.assertEqual(N.alltrue(src.x == x), True)
        self.assertEqual(N.alltrue(src.y == y), True)
        # Check the scalars.
        self.assertEqual(N.alltrue(src.scalars == s), True)

    def check_dataset(self):
        """Check the TVTK dataset."""
        x, y, s, src = self.get_data()
        # Check if the dataset is setup right.
        x = N.atleast_2d(x.squeeze().T)[0, :].squeeze()
        y = N.atleast_2d(y.squeeze())[0, :].squeeze()
        dx = x[1] - x[0]
        dy = y[1] - y[0]

        origin = [x.min(), y.min(),0 ]
        spacing = [dx, dy, 1]
        ds = src.dataset
        self.assertEqual(N.all(ds.origin == origin), True)
        self.assertEqual(N.allclose(src.m_data.spacing, spacing), True)

        sc = src.dataset.point_data.scalars.to_array()
        s1 = s.transpose()
        self.assertEqual(N.alltrue(sc.ravel() == s1.ravel()), True)

    def test_reset(self):
        "Test the reset method."

        x, y, s, src = self.get_data()

        self.check_traits()
        self.check_dataset()

        # Call reset again with just a few things changed to see if it
        # works correctly.
        x *= 5
        s *= 10
        src.reset(x=x,y=y, scalars=s)


        self.check_traits()
        self.check_dataset()

    def test_handlers(self):
        "Test if the various static handlers work correctly."
        x, y, s, src = self.get_data()
        x *= 2
        y *= 2
        s *= 2
        src.x = x
        src.y = y
        src.scalars = s

        self.check_traits()
        self.check_dataset()


    def test_set(self):
        "Test if the set method works correctly."
        x, y, s, src  = self.get_data()
        x *= 2
        s *= 2
        src.set(x=x,scalars=s)


        self.check_traits()
        self.check_dataset()

        y *= 9
        s *= 2
        src.set(y=y, scalars=s)
        self.check_traits()
        self.check_dataset()

################################################################################
# `TestMGridSource`
################################################################################
class TestMGridSource(unittest.TestCase):
    def setUp(self):
        self.x = x = N.ones([10,10], float)
        self.y = y = N.ones([10,10], float)*2.0
        self.z = z = N.ones([10,10], float)*3.0
        self.s = s = N.ones([10,10], float)
        src = sources.MGridSource()
        src.reset(x=x, y=y, z=z, scalars=s)
        self.src = src

    def tearDown(self):
        return

    def get_data(self):
        return self.x, self.y, self.z, self.s, self.src

    def check_traits(self):
        """Check if the sources traits are set correctly."""
        x, y, z, s, src = self.get_data()

        # Check if points are set correctly.
        self.assertEqual(N.alltrue(src.points[:,0].ravel() == x.ravel()), True)
        self.assertEqual(N.alltrue(src.points[:,1].ravel() == y.ravel()), True)
        self.assertEqual(N.alltrue(src.points[:,2].ravel() == z.ravel()), True)
        # Check the  scalars.

        self.assertEqual(N.alltrue(src.scalars == s), True)

    def check_dataset(self):
        """Check the TVTK dataset."""
        x, y, z, s, src = self.get_data()
        # Check if the dataset is setup right.

        pts = src.dataset.points.to_array()
        self.assertEqual(N.alltrue(pts[:,0].ravel() == x.ravel()), True)
        self.assertEqual(N.alltrue(pts[:,1].ravel() == y.ravel()), True)
        self.assertEqual(N.alltrue(pts[:,2].ravel() == z.ravel()), True)
        sc = src.dataset.point_data.scalars.to_array()
        self.assertEqual(N.alltrue(sc == s.ravel()), True)

    def test_reset(self):
        "Test the reset method."

        x, y, z, s, src = self.get_data()
        self.check_traits()
        self.check_dataset()

        # Call reset again with just a few things changed to see if it
        # works correctly.
        x *= 5
        s *= 10

        src.reset(x=x, scalars=s)
        self.check_traits()
        self.check_dataset()

    def test_handlers(self):
        "Test if the various static handlers work correctly."
        x, y, z, s, src = self.get_data()
        x *= 2
        y *= 2
        z *= 2
        s *= 2
        src.x = x
        src.y = y
        src.z = z
        src.scalars = s
        self.check_traits()
        self.check_dataset()

    def test_set(self):
        "Test if the set method works correctly."
        x, y, z, s, src = self.get_data()
        x *= 2
        z *= 2
        s *= 2
        src.set(x=x, z=z, scalars=s)
        self.check_traits()
        self.check_dataset()

################################################################################
# `TestMArray2DSourceNoArgs`
################################################################################
class TestMArray2DSourceNoArgs(unittest.TestCase):
    """Special Test Case for MArray2DSource when both x and y are specified as None"""
    def setUp(self):

        x=None
        y=None

        self.x, self.y  = x, y

        if x is not None and y is not None:
            dims = (x.shape[0], y.shape[1])
        else:
            dims=(10,10)

        self.s = s = N.ones(dims, float)
        src = sources.MArray2DSource()
        src.reset(x=x, y=y,scalars=s)
        self.src = src

    def tearDown(self):
        return

    def get_data(self):
        return self.x, self.y, self.s, self.src

    def check_traits(self):
        """Check if the sources traits are set correctly."""
        x, y, s, src = self.get_data()
        # Check if points are set correctly.

        if x is not None and y is not None:
            self.assertEqual(N.alltrue(src.x == x), True)
            self.assertEqual(N.alltrue(src.y == y), True)

        else:
            nx, ny = s.shape
            x1, y1 = N.mgrid[-nx/2.:nx/2, -ny/2.:ny/2]
            self.assertEqual(N.alltrue(src.x == x1), True)
            self.assertEqual(N.alltrue(src.y == y1), True)

        # Check the scalars.
        self.assertEqual(N.alltrue(src.scalars == s), True)

    def check_dataset(self):
        """Check the TVTK dataset."""
        x, y, s, src = self.get_data()
        # Check if the dataset is setup right.

        nx, ny = src.scalars.shape

        if x is None and y is None:
            x, y = N.mgrid[-nx/2.:nx/2, -ny/2.:ny/2]

        x = N.atleast_2d(x.squeeze().T)[0, :].squeeze()
        y = N.atleast_2d(y.squeeze())[0, :].squeeze()
        dx = x[1] - x[0]
        dy = y[1] - y[0]
        origin = [x.min(), y.min(),0 ]
        spacing = [dx, dy, 1]
        ds = src.dataset
        self.assertEqual(N.all(ds.origin == origin), True)
        self.assertEqual(N.allclose(ds.spacing, spacing), True)

        sc = src.dataset.point_data.scalars.to_array()
        s1 = s.transpose()
        self.assertEqual(N.alltrue(sc.ravel() == s1.ravel()), True)

    def test_reset(self):
        "Test the reset method."
        x, y, s, src = self.get_data()

        self.check_traits()
        self.check_dataset()

        # Call reset again with just a few things changed to see if it
        # works correctly.

        s *= 10
        src.reset(x=x,y=y, scalars=s)

        self.check_traits()
        self.check_dataset()

    def test_handlers(self):
        "Test if the various static handlers work correctly."
        x, y, s, src = self.get_data()
        s *= 2
        src.scalars = s

        self.check_traits()
        self.check_dataset()


    def test_set(self):
        "Test if the set method works correctly."
        x, y, s, src = self.get_data()
        s *= 2
        src.set(x=x,y=y,scalars=s)

        self.check_traits()
        self.check_dataset()


################################################################################
# `TestMTriangularMeshSource`
################################################################################
class TestMTriangularMeshSource(unittest.TestCase):
    def setUp(self):
        x, y, z = N.array([0, 0, 0]), N.array([0, 0, 1]), N.array([0, 1, 1])
        s = N.array([0.1, 0.2, 0.3])
        self.x, self.y, self.z, self.s = x, y, z, s
        self.triangles = triangles = N.array([[0, 1, 2]])

        src = sources.MTriangularMeshSource()
        src.reset(x=x, y=y, z=z, triangles=triangles, scalars=s)
        self.src = src

    def tearDown(self):
        return

    def get_data(self):
        return self.x, self.y, self.z, self.triangles, self.s, self.src

    def check_traits(self):
        """Check if the sources traits are set correctly."""
        x, y, z, triangles, s, src = self.get_data()

        # Check if points are set correctly.
        self.assertEqual(N.alltrue(src.x == x), True)
        self.assertEqual(N.alltrue(src.y == y), True)
        self.assertEqual(N.alltrue(src.z == z), True)
        # Check the scalars.
        self.assertEqual(N.alltrue(src.scalars == s), True)

    def test_reset(self):
        "Test the reset method."

        x, y, z, triangles, s, src = self.get_data()
        self.check_traits()

        # Call reset again with just a few things changed to see if it
        # works correctly.
        x *= 5
        s *= 10
        src.reset(x=x,y=y,z=z, triangles=triangles, scalars=s)

        self.check_traits()

    def test_changed_size(self):
        """ Change the number of the points, and establish
            to new points, to check that we don't get errors with the
            dimensions of the scalars.
        """
        n = 100
        _, _, _, _, _, src = self.get_data()
        triangles = N.c_[N.arange(n-3),
                            N.arange(n-3)+1,
                            n-1-N.arange(n-3)]
        x, y, z = N.random.random((3, n))
        src.reset(x=x, y=y, z=z, triangles=triangles)


    def test_handlers(self):
        "Test if the various static handlers work correctly."
        x, y, z, triangles, s, src = self.get_data()
        x *= 2
        y *= 2
        s *= 2
        src.x = x
        src.y = y
        src.scalars = s
        src.triangles = triangles

        self.check_traits()


    def test_set(self):
        "Test if the set method works correctly."
        x, y, z, triangles, s, src = self.get_data()
        x *= 2
        s *= 2
        src.set(x=x,scalars=s)

        self.check_traits()

        y *= 9
        s *= 2
        src.set(y=y, scalars=s)

        self.check_traits()



if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_mlab_source_integration
"""
Test for the various mlab source functions.

These tests are higher level than the tests testing directly the
MlabSource subclasses. They are meant to capture errors in the formatting
of the input arguments.
"""
# Author: Gael Varoquaux <gael dot varoquaux at normalesup dot org>
# Copyright (c) 2008, Enthought, Inc.
# License: BSD Style.

import unittest
import numpy as np

from mayavi.tools import sources

################################################################################
# `BaseTestSource`
################################################################################
class BaseTestSource(unittest.TestCase):
    def setUp(self):
        return


    def tearDown(self):
        return


    def all_close(self, a, b):
        """ Similar to numpy's allclose, but works also for a=None.
        """
        if None in (a, b):
            self.assert_(a==b)
        else:
            self.assert_(np.allclose(a, a))


    def check_positions(self, source, x, y, z):
        """ Check that the position vectors of the source do correspond
            to the given input positions
        """
        self.assert_(np.allclose(source.mlab_source.x, x))
        self.assert_(np.allclose(source.mlab_source.y, y))
        self.assert_(np.allclose(source.mlab_source.z, z))


    def check_vectors(self, source, u, v, w):
        """ Check that the vector data corresponds to the given arrays.
        """
        self.all_close(source.mlab_source.u, u)
        self.all_close(source.mlab_source.v, v)
        self.all_close(source.mlab_source.w, w)


    def check_scalars(self, source, s):
        """ Check that the scalar data corresponds to the given array.
        """
        self.all_close(source.mlab_source.scalars, s)


################################################################################
# `TestScalarScatter`
################################################################################
class TestScalarScatter(BaseTestSource):

    def test_input_args(self):
        """ Check that scalar_scatter can take different input arguments """

        # Check for a single number as position vectors.
        ss = sources.scalar_scatter(0, 0, 0, figure=None)
        self.check_positions(ss, 0, 0, 0)
        self.check_scalars(ss, None)
        self.check_vectors(ss, None, None, None)

        # Check for a single number as scalar data, and no position
        # vectors.
        ss = sources.scalar_scatter(0, figure=None)
        self.check_positions(ss, 0, 0, 0)
        self.check_scalars(ss, 0)
        self.check_vectors(ss, None, None, None)

        # Check for a list as position vectors.
        ss = sources.scalar_scatter([0, 1], [0, 1], [0, 1], figure=None)
        self.check_positions(ss, [0, 1], [0, 1], [0, 1])
        self.check_scalars(ss, None)
        self.check_vectors(ss, None, None, None)

        # Check for a list as scalar data, and no position vectors.
        ss = sources.scalar_scatter([0, 1], figure=None)
        self.check_scalars(ss, [0, 1])
        self.check_vectors(ss, None, None, None)

        # Check for a 1D array as position vectors.
        a = np.array([0, 1])
        ss = sources.scalar_scatter(a, a, a, figure=None)
        self.check_positions(ss, a, a, a)
        self.check_scalars(ss, None)
        self.check_vectors(ss, None, None, None)

        # Check for a 1D array as a scalar data, and no position vectors.
        ss = sources.scalar_scatter(a, figure=None)
        self.check_scalars(ss, a)
        self.check_vectors(ss, None, None, None)

        # Check for a 2D array as position vectors.
        a = np.array([[0, 1], [2, 3]])
        ss = sources.scalar_scatter(a, a, a, figure=None)
        self.check_positions(ss, a, a, a)
        self.check_scalars(ss, None)
        self.check_vectors(ss, None, None, None)

        # Check for a 2D array as scalar data, and no position vectors.
        ss = sources.scalar_scatter(a, figure=None)
        self.check_scalars(ss, a)
        self.check_vectors(ss, None, None, None)

        # Check for a 2D array as scalar data, and no position vectors.
        ss = sources.scalar_scatter(a, figure=None)
        self.check_scalars(ss, a)
        self.check_vectors(ss, None, None, None)


################################################################################
# `TestVectorScatter`
################################################################################
class TestVectorScatter(BaseTestSource):

    def test_input_args(self):
        """ Check that vector_scatter can take different input arguments """

        # Check for a single number as a position vector.
        ss = sources.vector_scatter(0, 0, 0, 0, 0, 0, figure=None)
        self.check_positions(ss, 0, 0, 0)
        self.check_scalars(ss, None)
        self.check_vectors(ss, 0, 0, 0)

        # Check for no position vectors, and single numbers for vector
        # data.
        ss = sources.vector_scatter(0, 0, 0, figure=None)
        self.check_positions(ss, 0, 0, 0)
        self.check_scalars(ss, None)
        self.check_vectors(ss, 0, 0, 0)

        # Check for a list as a position vector.
        ss = sources.vector_scatter([0, 1], [0, 1], [0, 1],
                                    [0, 1], [0, 1], [0, 1], figure=None)
        self.check_positions(ss, [0, 1], [0, 1], [0, 1])
        self.check_scalars(ss, None)
        self.check_vectors(ss, [0, 1], [0, 1], [0, 1])

        # Check for a lists as a vector data, and no position vectors
        ss = sources.vector_scatter([0, 1], [0, 1], [0, 1], figure=None)
        self.check_scalars(ss, None)
        self.check_vectors(ss, [0, 1], [0, 1], [0, 1])

        # Check for a 1D array as a position vector.
        a = np.array([0, 1])
        ss = sources.vector_scatter(a, a, a, a, a, a, figure=None)
        self.check_positions(ss, a, a, a)
        self.check_scalars(ss, None)
        self.check_vectors(ss, a, a, a)

        # Check for a 1D array as vector data, and no position vectors.
        ss = sources.vector_scatter(a, a, a, figure=None)
        self.check_scalars(ss, None)
        self.check_vectors(ss, a, a, a)

        # Check for a 2D array as a position vector.
        a = np.array([[0, 1], [2, 3]])
        ss = sources.vector_scatter(a, a, a, a, a, a, figure=None)
        self.check_positions(ss, a, a, a)
        self.check_scalars(ss, None)
        self.check_vectors(ss, a, a, a)

        # Check for a 2D array as vector data, and no position vectors.
        ss = sources.vector_scatter(a, a, a, figure=None)
        self.check_scalars(ss, None)
        self.check_vectors(ss, a, a, a)

        # Check for a 3D array as a position vector.
        x, y, z = np.mgrid[0:3, 0:3, 0:3]
        ss = sources.vector_scatter(x, y, z, x, y, z, figure=None)
        self.check_positions(ss, x, y, z)
        self.check_scalars(ss, None)
        self.check_vectors(ss, x, y, z)

        # Check for a 3D array as vector data, and no position vectors.
        x, y, z = np.mgrid[0:3, 0:3, 0:3]
        ss = sources.scalar_scatter(z, figure=None)
        self.check_scalars(ss, z)
        X, Y, Z = np.indices(z.shape)
        self.check_positions(ss, X, Y, Z)


################################################################################
# `TestArray2DSource`
################################################################################
class TestArray2DSource(BaseTestSource):

    def test_input_args(self):
        """ Check that array2d_source can take different input arguments """

        # Check for a single number as data and no position arrays.
        ss = sources.array2d_source(0, figure=None)
        self.check_scalars(ss, 0)

        # Check for a list as data, and no position arrays.
        ss = sources.array2d_source([0, 1], figure=None)
        self.check_scalars(ss, [0, 1])

        # Check for a 1D array as data, and no position arrays.
        a = np.array([0, 1])
        ss = sources.array2d_source(a, figure=None)
        self.check_scalars(ss, a)

        # Check for a 2D array as data, and no position arrays.
        a = np.array([[0, 1], [2, 3]])
        ss = sources.array2d_source(a, figure=None)
        self.check_scalars(ss, a)

        # Check for 2 lists as positions vectors, and a 2D list as data
        x = [0, 1]
        y = [0, 1]
        s = [[0, 1], [2, 3]]
        ss = sources.array2d_source(x, y, s, figure=None)
        self.check_scalars(ss, s)

        # Check for an ogrid as position vectors, and a function for the
        # scalars
        x, y = np.ogrid[-3:3, -3:3]
        f = lambda x, y: x**2 + y**2
        ss = sources.array2d_source(x, y, f, figure=None)
        self.check_scalars(ss, f(x, y))

        # Check for an mgrid as position vectors, and a 2D array for the
        # scalars
        x, y = np.mgrid[-3:3, -3:3]
        s = np.zeros_like(x)
        ss = sources.array2d_source(x, y, x, figure=None)
        self.check_scalars(ss, s)


################################################################################
# `TestScalarField`
################################################################################
class TestScalarField(BaseTestSource):

    def test_input_args(self):
        """ Check that scalar_field can take different input arguments """

        # Check for 2D arrays as positions vectors, and a function for
        # the data
        f = lambda x, y, z: x**2 + y**2
        x, y = np.mgrid[-3:3, -3:3]
        z = np.zeros_like(x)
        ss = sources.scalar_field(x, y, z, f, figure=None)
        self.check_positions(ss, x, y, z)
        s = f(x, y, z)
        self.check_scalars(ss, s)

        # Check for a 2D array as data, and no position vectors
        s = np.random.random((10, 10))
        ss = sources.scalar_field(s, figure=None)
        self.check_scalars(ss, s)

        # Check for a 3D array as data, and no position vectors
        s = np.random.random((10, 10, 10))
        ss = sources.scalar_field(s, figure=None)
        self.check_scalars(ss, s)

        # Check for a 3D array as data, and 3D arrays as position
        x, y, z = np.mgrid[-3:3, -3:3, -3:3]
        ss = sources.scalar_field(x, y, z, z, figure=None)
        self.check_positions(ss, x, y, z)
        self.check_scalars(ss, z)


################################################################################
# `TestVectorField`
################################################################################
class TestVectorField(BaseTestSource):

    def test_input_args(self):
        """ Check that vector_field can take different input arguments """

        # Check for 2D arrays as positions vectors, and a function for
        # the data
        x, y = np.mgrid[-3:3, -3:3]
        z = np.zeros_like(x)
        def f(x, y, z):
            return y, z, x
        ss = sources.vector_field(x, y, z, f, figure=None)
        self.check_scalars(ss, None)
        self.check_vectors(ss, y, z, x)

        # Check for a 2D array as data, and no position vectors
        u = np.random.random((10, 10))
        v = np.random.random((10, 10))
        w = np.random.random((10, 10))
        ss = sources.vector_field(u, v, w, figure=None)
        self.check_scalars(ss, None)
        self.check_vectors(ss, u, v, w)

        # Check for a 3D array as data, and no position vectors
        u = np.random.random((10, 10, 10))
        v = np.random.random((10, 10, 10))
        w = np.random.random((10, 10, 10))
        ss = sources.vector_field(u, v, w, figure=None)
        self.check_scalars(ss, None)
        self.check_vectors(ss, u, v, w)

        # Check for a 3D array as data, and 3D arrays as position
        x, y, z = np.mgrid[-3:3, -3:3, -3:3]
        ss = sources.vector_field(x, y, z, y, z, x, figure=None)
        self.check_scalars(ss, None)
        self.check_positions(ss, x, y, z)
        self.check_vectors(ss, y, z, x)

################################################################################
# `TestLineSource`
################################################################################
class TestLineSource(BaseTestSource):

    def test_input_args(self):
        """ Check that vector_field can take different input arguments """

        # Check for numbers as position vectors
        ss = sources.line_source(0, 0, 0, figure=None)
        self.check_positions(ss, 0, 0, 0)
        self.check_scalars(ss, None)

        # Check for lists as position vectors and as data
        ss = sources.line_source([0, 1], [0, 1], [0, 1], [2, 3], figure=None)
        self.check_positions(ss, [0, 1], [0, 1], [0, 1])
        self.check_scalars(ss, [2, 3])

        # Check for arrays as position vectors and a function as data
        x, y, z = np.random.random((3, 10))
        f = lambda x, y, z: x + y + z
        ss = sources.line_source(x, y, z, f, figure=None)
        self.check_positions(ss, x, y, z)
        self.check_scalars(ss, f(x, y, z))

################################################################################
# `TestVerticalVectorsSource`
################################################################################
class TestVerticalVectorsSource(BaseTestSource):

    def test_input_args(self):
        """ Check that vector_field can take different input arguments """

        # Check for numbers as position vectors
        ss = sources.vertical_vectors_source(0, 0, 1, figure=None)
        self.check_positions(ss, 0, 0, 0)
        self.check_scalars(ss, 1)
        self.check_vectors(ss, 0, 0, 1)

        ss = sources.vertical_vectors_source(0, 0, 1, 1, figure=None)
        self.check_positions(ss, 0, 0, 1)
        self.check_scalars(ss, 1)
        self.check_vectors(ss, 0, 0, 1)

        # Check for lists as position vectors and as data
        ss = sources.vertical_vectors_source([0, 1], [0, 1], [0, 1], [2, 3],
                                                                figure=None)
        self.check_positions(ss, [0, 1], [0, 1], [0, 1])
        self.check_scalars(ss, [2, 3])
        self.check_vectors(ss, [0, 0], [0, 0], [2, 3])

        # Check for arrays as position vectors and a function as data
        x, y, z = np.random.random((3, 10))
        zeros = np.zeros_like(x)
        f = lambda x, y, z: x + y + z
        ss = sources.vertical_vectors_source(x, y, z, f, figure=None)
        self.check_positions(ss, x, y, z)
        self.check_scalars(ss, f(x, y, z))
        self.check_vectors(ss, zeros, zeros, z)

        ss = sources.vertical_vectors_source(x, y, z, figure=None)
        self.check_positions(ss, x, y, zeros)
        self.check_scalars(ss, z)
        self.check_vectors(ss, zeros, zeros, z)


################################################################################
# `TestSourceInfinite`
################################################################################
class TestVerticalVectorsSource(unittest.TestCase):

    def test_infinite(self):
        """ Check that passing in arrays with infinite values raises
            errors """
        # Some arrays
        x = np.random.random((10, 3, 4))
        y = np.random.random((10, 3, 4))
        z = np.random.random((10, 3, 4))
        u = np.random.random((10, 3, 4))
        v = np.random.random((10, 3, 4))
        w = np.random.random((10, 3, 4))
        s = np.random.random((10, 3, 4))

        # Add a few infinite values:
        u[2, 2, 1] = np.inf
        s[0, 0, 0] = -np.inf

        # Check value errors are raised because of the infinite values
        self.assertRaises(ValueError,
                    sources.grid_source, x[0], y[0], z[0], scalars=s[0],
                    figure=None)

        self.assertRaises(ValueError,
                    sources.vertical_vectors_source, x, y, z, s,
                    figure=None)

        self.assertRaises(ValueError,
                    sources.array2d_source, x[0], y[0], s[0],
                    figure=None)

        self.assertRaises(ValueError,
                    sources.scalar_field, x, y, z, s,
                    figure=None)

        self.assertRaises(ValueError,
                    sources.scalar_scatter, x, y, z, s,
                    figure=None)

        self.assertRaises(ValueError,
                    sources.vector_scatter, x, y, z, u, v, w,
                    figure=None)

        self.assertRaises(ValueError,
                    sources.vector_field, x, y, z, u, v, w,
                    figure=None)

        self.assertRaises(ValueError,
                    sources.line_source, x[0, 0], y[0, 0], z[0, 0], s[0, 0],
                    figure=None)



if __name__ == '__main__':
    unittest.main()


########NEW FILE########
__FILENAME__ = test_mouse_pick_dispatcher
"""
Test the MousePickDispatcher.
"""

import unittest

from traits.api import HasTraits, Instance

from mayavi.core.null_engine import NullEngine, DummyViewer
from tvtk.api import tvtk
from mayavi.tools.engine_manager import engine_manager
from mayavi.core.registry import registry
from mayavi.core.mouse_pick_dispatcher import \
                MousePickDispatcher
from tvtk.pyface.picker import Picker

################################################################################
# class `DummyScene`
################################################################################
class DummyScene(HasTraits):
    """ Mimics the API of a TVTK scene.
    """
    interactor = Instance(tvtk.GenericRenderWindowInteractor, ())

    picker = Instance(Picker, (None, ))


################################################################################
# class `DummyMousePickDispatcher`
################################################################################
class DummyMousePickDispatcher(MousePickDispatcher):
    """ A MousePickDispatcher that accepts the DummyViewer as a Scene.
    """
    scene = Instance(DummyViewer)


################################################################################
# class `TestMousePickerDispatcher`
################################################################################
class TestMousePickerDispatcher(unittest.TestCase):
    """ Create a fake figure, to make sure that observers are well
        registered and removed.
    """

    def setUp(self):
        e = NullEngine()
        e.start()
        registry.register_engine(e)
        engine_manager.current_engine = e
        self.e = e
        self.s = e.new_scene()
        self.s.scene = DummyScene()


    def tearDown(self):
        engine_manager.current_engine = None
        # Unregistering the engine, to avoid side-effects between tests
        self.e.stop()
        registry.unregister_engine(self.e)

    def test_callback_registering(self):
        def test(picker):
            pass
        dispatcher = DummyMousePickDispatcher(scene=self.s)
        initial_interactor_callbacks = frozenset([i for i in range(100)
                                    if self.s.scene.interactor.has_observer(i)
                                ])
        dispatcher.callbacks.append((test, 'point', 'Left'))

        # Check that VTK observers were established
        self.assertTrue(dispatcher._mouse_mvt_callback_nb)
        self.assertTrue('Left' in dispatcher._mouse_press_callback_nbs)
        self.assertTrue('Left' in dispatcher._mouse_release_callback_nbs)

        # Check that we are back to no observers
        dispatcher.callbacks[:] = []
        interactor_callbacks = frozenset([i for i in range(100)
                                    if self.s.scene.interactor.has_observer(i)
                                ])
        self.assertEquals(interactor_callbacks,
                    initial_interactor_callbacks)



if __name__ == '__main__':
    unittest.main()


########NEW FILE########
__FILENAME__ = test_no_ui_toolkit
"""
Tests to try and ensure that important mayavi imports work with no UI.
"""
# Author: Prabhu Ramachandran <prabhu@aero.iitb.ac.in>
# Copyright (c) 2009, Enthought, Inc.
# License: BSD Style.

import sys
import unittest

from traits.etsconfig.api import ETSConfig


class TestNoUIToolkit(unittest.TestCase):

    """Test if any important mayavi imports work with no UI
    whatsoever."""

    def setUp(self):
        self.orig_tk = ETSConfig.toolkit
        ETSConfig._toolkit = 'null'

        # Import something from Pyface to force any potential imports
        # from a UI toolkit.  Why did I pick Pyface? Well, adder_node
        # imports ImageResource and this seems to trigger some UI
        # toolkit import and this makes life difficult as far as the
        # testing goes.  Forcing the issue here should let us test
        # safely since the Pyface imports will be done.
        from pyface.api import GUI

        # Remove any references to wx and Qt
        saved = {}
        for mod in ['wx', 'PyQt4', 'PySide']:
            saved[mod] = sys.modules.pop(mod, None)
        self.saved = saved

    def tearDown(self):
        ETSConfig._toolkit = self.orig_tk
        # Add back any any references to wx and Qt
        for mod in ['wx', 'PyQt4', 'PySide']:
            m = self.saved[mod]
            if m is not None:
                sys.modules[mod] = m

    def test_no_ui(self):
        """Test if mayavi imports work without any UI (wx or PyQt4)."""
        # These imports should work without any UI.
        from mayavi import mlab
        from mayavi.api import Engine
        from mayavi.sources.api import VTKDataSource
        from mayavi.filters.api import Optional
        from mayavi.modules.api import Outline
        from mayavi.preferences.api import preference_manager

        # Should not have triggered an import wx or PyQt4.
        self.assertEqual(sys.modules.has_key('wx'), False)
        self.assertEqual(sys.modules.has_key('PyQt4'), False)


if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_optional_collection
# Author: Suyog Dutt Jain <suyog.jain@aero.iitb.ac.in>
#         Prabhu Ramachandran <prabhu_r@users.sf.net>
# Copyright (c) 2008,  Enthought, Inc.
# License: BSD Style.

# Standard library imports.
from os.path import abspath
from StringIO import StringIO
import copy
import numpy as np
import unittest
import datasets

# Enthought library imports
from mayavi.core.null_engine import NullEngine
from mayavi.filters.contour import Contour
from mayavi.filters.optional import Optional
from mayavi.filters.collection import Collection
from mayavi.filters.api import PolyDataNormals
from mayavi.modules.api import Surface
from mayavi.sources.vtk_data_source import VTKDataSource


class TestOptionalCollection(unittest.TestCase):

    def setUp(self):
        """Initial setting up of test fixture, automatically called by TestCase before any other test method is invoked"""
        e = NullEngine()
        # Uncomment to see visualization for debugging etc.
        #e = Engine()
        e.start()
        e.new_scene()
        self.e=e

        sgrid=datasets.generateStructuredGrid()
        src = VTKDataSource(data = sgrid)
        e.add_source(src)

        c = Contour()
        # `name` is used for the notebook tabs.
        n = PolyDataNormals(name='Normals')
        o = Optional(filter=n, label_text='Compute normals')
        coll = Collection(filters=[c, o], name='IsoSurface')
        e.add_filter(coll)
        s = Surface()
        e.add_module(s)
        self.coll = coll
        self.scene = e.current_scene
        return

    def tearDown(self):
        """For necessary clean up, automatically called by TestCase after the test methods have been invoked"""
        self.e.stop()
        return

    def check(self,coll):
        """Do the actual testing."""
        scene = self.scene
        """Check if test status is OK given the collection."""
        c, o = coll.filters
        c = c.filter
        n = o.filter

        r = coll.outputs[0].point_data.scalars.range

        self.assertEqual(np.allclose(r, (6.09,6.09), atol=1.01e-03), True)
        # Adding a contour should create the appropriate output in
        # the collection.
        c.contours.append(200)
        self.assertEqual(np.allclose(r, [6.09,6.09], atol=1.01e-03), True)
        # the collection's output should be that of the normals.
        self.assertEqual(coll.outputs[0] is n.outputs[0],True)
        # disable the optional filter and check.
        o.enabled = False
        self.assertEqual('disabled' in o.name,True)
        self.assertEqual(coll.outputs[0] is c.outputs[0],True)
        # Set back everything to original state.
        c.contours.pop()
        o.enabled = True
        self.assertEqual(np.allclose(r, (6.09,6.09), atol=1.01e-03), True)
        self.assertEqual(coll.outputs[0] is n.outputs[0], True)
        self.assertEqual('disabled' not in o.name, True)

    def test_optional_collection(self):
        "Test if the test fixture works"
        #Now test.
        coll = self.coll
        self.check(coll)

        #from mayavi.tools.show import show
        #show()

    def test_save_and_restore(self):
        """Test if saving a visualization and restoring it works."""
        engine = self.e
        scene = self.scene

        # Save visualization.
        f = StringIO()
        f.name = abspath('test.mv2') # We simulate a file.
        engine.save_visualization(f)
        f.seek(0) # So we can read this saved data.

        # Remove existing scene.

        engine.close_scene(scene)

        # Load visualization
        engine.load_visualization(f)
        self.scene = engine.current_scene
        coll = self.scene.children[0].children[0]

        self.check(coll)


    def test_deepcopied(self):
        """Test if the MayaVi2 visualization can be deep-copied."""
        ############################################################
        # Test if the MayaVi2 visualization can be deep-copied.

        # Pop the source object.
        s =  self.scene
        source = s.children.pop()
        # Add it back to see if that works without error.
        s.children.append(source)
        coll = s.children[0].children[0]

        self.check(coll)

        # Now deepcopy the source and replace the existing one with
        # the copy.  This basically simulates cutting/copying the
        # object from the UI via the right-click menu on the tree
        # view, and pasting the copy back.
        source1 = copy.deepcopy(source)
        s.children[0] = source1
        coll = s.children[0].children[0]
        self.check(coll)
        #from mayavi.tools.show import show
        #show()



if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_pipeline_info
"""
Tests for the pipeline_info.py module
"""
# Author: Prabhu Ramachandran <prabhu@aero.iitb.ac.in>
# Copyright (c) 2008, Prabhu Ramachandran Enthought, Inc.
# License: BSD Style.

import unittest

from tvtk.api import tvtk
from mayavi.core import pipeline_info


class TestPipelineInfoTest(unittest.TestCase):

    def test_tvtk_dataset_name(self):
        "Can tvtk datasets can be converted to names correctly."
        datasets = [tvtk.ImageData(),
                    tvtk.StructuredPoints(),
                    tvtk.RectilinearGrid(),
                    tvtk.StructuredGrid(),
                    tvtk.PolyData(),
                    tvtk.UnstructuredGrid(),
                    tvtk.Property(), # Not a dataset!
                    'foo', # Not a TVTK object.
                    ]
        expect = ['image_data',
                  'image_data',
                  'rectilinear_grid',
                  'structured_grid',
                  'poly_data',
                  'unstructured_grid',
                  'none',
                  'none'
                  ]
        result = [pipeline_info.get_tvtk_dataset_name(d) for d in datasets]
        self.assertEqual(result, expect)

    def test_default_pipeline_info(self):
        "Is the default PipelineInfo class built right."
        p = pipeline_info.PipelineInfo()
        self.assertEqual(len(p.datasets), 0)
        self.assertEqual(len(p.attribute_types), 0)
        self.assertEqual(len(p.attributes), 0)



if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_plot3d_mb_reader
# Author: Suyog Dutt Jain <suyog.jain@aero.iitb.ac.in>
#         Prabhu Ramachandran <prabhu_r@users.sf.net>
# Copyright (c) 2008,  Enthought, Inc.
# License: BSD Style.

# Standard library imports.
from os.path import abspath
from StringIO import StringIO
import copy
import unittest

# Local imports.
from common import get_example_data

# Enthought library imports
from mayavi.core.null_engine import NullEngine
from mayavi.sources.plot3d_reader import PLOT3DReader
from mayavi.filters.select_output import SelectOutput
from mayavi.modules.outline import Outline

class TestPlot3dMbReader(unittest.TestCase):

    def setUp(self):
        """Initial setting up of test fixture, automatically called by TestCase before any other test method is invoked"""
        e = NullEngine()
        # Uncomment to see visualization for debugging etc.
        #e = Engine()
        e.start()
        e.new_scene()
        self.e=e

        # Read the multi-block plot3d file.
        r = PLOT3DReader()
        r.reader.set(has_byte_count=True, multi_grid=True,
                     byte_order='little_endian')
        r.initialize(get_example_data('tiny.xyz'),
                     get_example_data('tiny.q'),
                     configure=False)
        e.add_source(r)
        # Add the filter.
        f = SelectOutput()
        e.add_filter(f)

        # Create an outline for the data.
        o = Outline()
        e.add_module(o)
        o.render()
        self.o=o
        self.r=r
        self.e=e
        self.scene = e.current_scene
        return

    def tearDown(self):
        """For necessary clean up, automatically called by TestCase after the test methods have been invoked"""
        self.e.stop()
        return

    def test_plot3d_mb_reader(self):
        "Test if the test fixture works"
        s=self.scene
        o=self.o
        #Check the bounds of the outline.
        self.assertEqual(o.outline_filter.output.bounds,
                                    (1.0, 2.0, 1.0, 2.0, 1.0, 2.0))

        #from mayavi.tools.show import show
        #show()


    def test_save_and_restore(self):
        """Test if saving a visualization and restoring it works."""
        engine = self.e
        scene = self.scene

        # Save visualization.
        f = StringIO()
        f.name = abspath('test.mv2') # We simulate a file.
        engine.save_visualization(f)
        f.seek(0) # So we can read this saved data.

        # Remove existing scene.

        engine.close_scene(scene)

        # Load visualization
        engine.load_visualization(f)
        s=self.scene = engine.current_scene

        o = s.children[0].children[0].children[0].children[0]
        self.assertEqual(o.outline_filter.output.bounds,
                                (1.0, 2.0, 1.0, 2.0, 1.0, 2.0))


    def test_deepcopied(self):
        """Test if the MayaVi2 visualization can be deep-copied.
           XXX: The plot 3d reader and multi block version are broken in
                vtk 5.10.1. This will be fixed in next Mayavi release."""
        ############################################################
        # Copy the reader to see if it does not pop up the UI.

        # Pop the source object.
        r=self.r
        e=self.e
        r1 = copy.deepcopy(r)
        e.add_source(r1)

        o1 = r1.children[0].children[0].children[0]
        self.assertEqual(o1.outline_filter.output.bounds,
                                    (1.0, 2.0, 1.0, 2.0, 1.0, 2.0))
        r1.children[0].output_index = 1
        self.assertEqual(o1.outline_filter.output.bounds,
                                    (2.0, 3.0, 1.0, 2.0, 1.0, 2.0))

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_poly_data_reader
# Author: Suyog Dutt Jain <suyog.jain@aero.iitb.ac.in>
# Copyright (c) 2009,  Enthought, Inc.
# License: BSD Style.

# Standard library imports.
import unittest

# Local imports.
from common import get_example_data

# Enthought library imports
from mayavi.sources.poly_data_reader import PolyDataReader
from mayavi.tests.data_reader_test_base import DataReaderTestBase

# External library imports
import vtk

vtk_major_version = vtk.vtkVersion.GetVTKMajorVersion()
vtk_minor_version = vtk.vtkVersion.GetVTKMinorVersion()

class TestPDBReader(DataReaderTestBase):

    def setup_reader(self):

        """"Setup the reader in here.  This is called after the engine
        has been created and started.  The engine is available as
        self.e.  This method is called by setUp().
        """
        # Read a PDB data file.
        r = PolyDataReader()
        r.initialize(get_example_data('caffeine.pdb'))
        self.e.add_source(r)
        self.bounds = (3.10, 10.78, -2.39, 4.03, -10.60, -6.31)

    def test_pdb_data_reader(self):
        "Test if the test fixture works"
        #Now test.

        self.check(self.scene, self.bounds)

    def test_save_and_restore(self):
        """Test if saving a visualization and restoring it works."""

        self.check_saving(self.e, self.scene, self.bounds)

    def test_deepcopied(self):
        """Test if the MayaVi2 visualization can be deep-copied."""
        ############################################################
        # Test if the MayaVi2 visualization can be deep-copied.

        self.check_deepcopying(self.scene, self.bounds)


class TestBYUReader(DataReaderTestBase):

    def setup_reader(self):

        """"Setup the reader in here.  This is called after the engine
        has been created and started.  The engine is available as
        self.e.  This method is called by setUp().
        """
        # Read a BYU data file.
        r = PolyDataReader()
        r.initialize(get_example_data('cow.g'))
        self.e.add_source(r)
        self.bounds = (-4.445, 5.998, -3.608, 2.760, -1.690, 1.690)

    def test_byu_data_reader(self):
        "Test if the test fixture works"
        #Now test.

        self.check(self.scene, self.bounds)

    def test_save_and_restore(self):
        """Test if saving a visualization and restoring it works."""

        self.check_saving(self.e, self.scene, self.bounds)

    def test_deepcopied(self):
        """Test if the MayaVi2 visualization can be deep-copied."""
        ############################################################
        # Test if the MayaVi2 visualization can be deep-copied.

        self.check_deepcopying(self.scene, self.bounds)


class TestOBJReader(DataReaderTestBase):

    def setup_reader(self):

        """"Setup the reader in here.  This is called after the engine
        has been created and started.  The engine is available as
        self.e.  This method is called by setUp().
        """
        # Read a OBJ data file.
        r = PolyDataReader()
        r.initialize(get_example_data('shuttle.obj'))
        self.e.add_source(r)
        self.bounds = (-7.65, 7.04, -4.68, 4.68, -1.35, 4.16)

    def test_obj_data_reader(self):
        "Test if the test fixture works"
        #Now test.

        self.check(self.scene, self.bounds)

    def test_save_and_restore(self):
        """Test if saving a visualization and restoring it works."""

        self.check_saving(self.e, self.scene, self.bounds)

    def test_deepcopied(self):
        """Test if the MayaVi2 visualization can be deep-copied."""
        ############################################################
        # Test if the MayaVi2 visualization can be deep-copied.

        self.check_deepcopying(self.scene, self.bounds)


class TestParticleReader(DataReaderTestBase):

    def setup_reader(self):

        """"Setup the reader in here.  This is called after the engine
        has been created and started.  The engine is available as
        self.e.  This method is called by setUp().
        """
        # Read a Particle data file.
        r = PolyDataReader()
        r.initialize(get_example_data('Particles.raw'))
        self.e.add_source(r)
        r.reader.set(data_byte_order='big_endian', data_type='float', file_type='binary')
        self.bounds = (817.33, 826.09, 545.02, 571.02, 1443.48, 1511.18)

    def test_particle_data_reader(self):
        "Test if the test fixture works"
        #Now test.

        self.check(self.scene, self.bounds)

    def test_save_and_restore(self):
        """Test if saving a visualization and restoring it works."""

        self.check_saving(self.e, self.scene, self.bounds)

    def test_deepcopied(self):
        """Test if the MayaVi2 visualization can be deep-copied."""
        ############################################################
        # Test if the MayaVi2 visualization can be deep-copied.

        self.check_deepcopying(self.scene, self.bounds)


class TestPLYReader(DataReaderTestBase):

    def setup_reader(self):

        """"Setup the reader in here.  This is called after the engine
        has been created and started.  The engine is available as
        self.e.  This method is called by setUp().
        """
        # Read a PLY data file.
        r = PolyDataReader()
        r.initialize(get_example_data('pyramid.ply'))
        self.e.add_source(r)
        self.bounds = (0.0, 1.0, 0.0, 1.0, 0.0, 1.60)

    def test_ply_data_reader(self):
        "Test if the test fixture works"
        if vtk_major_version == 5 and vtk_minor_version in [6, 8]:
            raise unittest.SkipTest('PLY reader broken in this version of VTK')

        #Now test.
        self.check(self.scene, self.bounds)

    def test_save_and_restore(self):
        """Test if saving a visualization and restoring it works."""

        if vtk_major_version == 5 and vtk_minor_version in [6, 8]:
            raise unittest.SkipTest('PLY reader broken in this version of VTK')

        self.check_saving(self.e, self.scene, self.bounds)

    def test_deepcopied(self):
        """Test if the MayaVi2 visualization can be deep-copied."""
        ############################################################
        # Test if the MayaVi2 visualization can be deep-copied.

        if vtk_major_version == 5 and vtk_minor_version in [6, 8]:
            raise unittest.SkipTest('PLY reader broken in this version of VTK')

        self.check_deepcopying(self.scene, self.bounds)


class TestPointsReader(DataReaderTestBase):

    def setup_reader(self):

        """"Setup the reader in here.  This is called after the engine
        has been created and started.  The engine is available as
        self.e.  This method is called by setUp().
        """
        # Read a Points data file.
        r = PolyDataReader()
        r.initialize(get_example_data('points.txt'))
        self.e.add_source(r)
        self.bounds =  (0.0, 1.0, 0.0, 1.0, 0.0, 1.0)

    def test_points_data_reader(self):
        "Test if the test fixture works"
        #Now test.

        self.check(self.scene, self.bounds)

    def test_save_and_restore(self):
        """Test if saving a visualization and restoring it works."""

        self.check_saving(self.e, self.scene, self.bounds)

    def test_deepcopied(self):
        """Test if the MayaVi2 visualization can be deep-copied."""
        ############################################################
        # Test if the MayaVi2 visualization can be deep-copied.

        self.check_deepcopying(self.scene, self.bounds)


class TestSTLReader(DataReaderTestBase):

    def setup_reader(self):

        """"Setup the reader in here.  This is called after the engine
        has been created and started.  The engine is available as
        self.e.  This method is called by setUp().
        """
        # Read a STL data file.
        r = PolyDataReader()
        r.initialize(get_example_data('humanoid_tri.stla'))
        self.e.add_source(r)
        self.bounds =  (0.60, 3.47, -3.96, 3.95, 3.05, 17.39)


    def test_stl_data_reader(self):
        "Test if the test fixture works"
        #Now test.

        self.check(self.scene, self.bounds)

    def test_save_and_restore(self):
        """Test if saving a visualization and restoring it works."""

        self.check_saving(self.e, self.scene, self.bounds)

    def test_deepcopied(self):
        """Test if the MayaVi2 visualization can be deep-copied."""
        ############################################################
        # Test if the MayaVi2 visualization can be deep-copied.

        self.check_deepcopying(self.scene, self.bounds)


class TestFacetReader(DataReaderTestBase):

    def setup_reader(self):

        """"Setup the reader in here.  This is called after the engine
        has been created and started.  The engine is available as
        self.e.  This method is called by setUp().
        """
        # Read a Facet data file.
        r = PolyDataReader()
        r.initialize(get_example_data('clown.facet'))
        self.e.add_source(r)
        self.bounds = (-0.5, 0.69, -0.49, 0.49, -1.09, 0.5)

    def test_facet_data_reader(self):
        "Test if the test fixture works"
        #Now test.

        self.check(self.scene, self.bounds)

    def test_save_and_restore(self):
        """Test if saving a visualization and restoring it works."""

        self.check_saving(self.e, self.scene, self.bounds)

    def test_deepcopied(self):
        """Test if the MayaVi2 visualization can be deep-copied."""
        ############################################################
        # Test if the MayaVi2 visualization can be deep-copied.

        self.check_deepcopying(self.scene, self.bounds)


class TestSLCReader(DataReaderTestBase):

    def setup_reader(self):

        """"Setup the reader in here.  This is called after the engine
        has been created and started.  The engine is available as
        self.e.  This method is called by setUp().
        """
        # Read a SLC data file.
        r = PolyDataReader()
        r.initialize(get_example_data('nut.slc'))
        self.e.add_source(r)
        self.bounds =  (0.0, 67.0, 0.0, 40.0, 0.0, 58.0)

    def test_slc_data_reader(self):
        "Test if the test fixture works"
        #Now test.

        self.check(self.scene, self.bounds)

    def test_save_and_restore(self):
        """Test if saving a visualization and restoring it works."""

        self.check_saving(self.e, self.scene, self.bounds)

    def test_deepcopied(self):
        """Test if the MayaVi2 visualization can be deep-copied."""
        ############################################################
        # Test if the MayaVi2 visualization can be deep-copied.

        self.check_deepcopying(self.scene, self.bounds)

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_preferences_mirror
# Author: Prabhu Ramachandran <prabhu [at] aero . iitb . ac . in>
# Copyright (c) 2008, Enthought Inc.
# License: BSD Style.

import unittest
from pkg_resources import resource_filename

from traits.api import Str, Int, Bool
from apptools.preferences.api import set_default_preferences
from apptools.preferences.api import Preferences, PreferencesHelper
from mayavi.tools.preferences_mirror import PreferencesMirror


class TestPreference(PreferencesHelper):
    """A simple test preference helper."""
    preferences_path = "test"

    bg = Str
    width = Int
    show = Bool


class ClassNameTest(unittest.TestCase):
    def setUp(self):
        """Called before each test is run"""
        self.preferences = set_default_preferences(Preferences())
        # The filename of the example preferences file.
        pref_file = resource_filename('mayavi.tests',
                                      'test_preference.ini')
        self.preferences.load(pref_file)
        self.pref = TestPreference()
        self.mirror = PreferencesMirror()
        self.mirror.preferences = self.pref

    def test_mirroring(self):
        """Are the traits properly mirrored?"""
        pref = self.pref
        mirror = self.mirror
        self.assertEqual(pref.bg, mirror.bg)
        self.assertEqual(pref.width, mirror.width)
        self.assertEqual(pref.show, mirror.show)

    def test_sync(self):
        """Does the mirror listen for changes on original preference."""
        pref = self.pref
        mirror = self.mirror
        # Save original state.
        saved = pref.get()
        pref.set(bg = 'white', width=20, show=True)
        self.assertEqual(pref.bg, mirror.bg)
        self.assertEqual(pref.width, mirror.width)
        self.assertEqual(pref.show, mirror.show)
        # Reset preferences back to defaults.
        pref.set(saved)

    def test_no_reverse_sync(self):
        """mirror must not sync changes back to the original preferences."""
        pref = self.pref
        mirror = self.mirror
        saved = pref.get()
        mirror.set(bg = 'white', width=20, show=True)
        self.assertNotEqual(pref.bg, mirror.bg)
        self.assertNotEqual(pref.width, mirror.width)
        self.assertNotEqual(pref.show, mirror.show)
        self.assertEqual(pref.bg, saved['bg'])
        self.assertEqual(pref.width, saved['width'])
        self.assertEqual(pref.show, saved['show'])

    def test_save(self):
        """Are Mirror's preferences saved correctly"""
        pref = self.pref
        mirror = self.mirror
        saved = pref.get()
        mirror.set(bg = 'white', width=20, show=True)
        mirror.save()
        self.assertEqual(pref.bg, mirror.bg)
        self.assertEqual(pref.width, mirror.width)
        self.assertEqual(pref.show, mirror.show)
        # Reset preferences back to defaults.
        pref.set(saved)

if __name__ == '__main__':
    unittest.main()


########NEW FILE########
__FILENAME__ = test_recorder
"""
Unit tests for the script recorder -- the script recorder has been
refactored to move to AppTools however we repeat the tests here with a
TVTK object to ensure that the test works with TVTK objects.
"""
# Author: Prabhu Ramachandran <prabhu@aero.iitb.ac.in>
# Copyright (c) 2008, Enthought, Inc.
# License: BSD Style.

import unittest

from traits.api import (HasTraits, Float, Instance,
        Str, List, Bool)
from tvtk.api import tvtk
from apptools.scripting.api import (Recorder, recordable,
    set_recorder)


######################################################################
# Test classes.
class Toy(HasTraits):
    color = Str
    type = Str
    ignore = Bool(False, record=False)


class Child(HasTraits):
    name = Str('child')
    age = Float(10.0)
    property = Instance(tvtk.Property, (), record=True)
    toy = Instance(Toy, record=True)
    friends = List(Str)

    @recordable
    def grow(self, x):
        """Increase age by x years."""
        self.age += x
        self.f(1)

    @recordable
    def f(self, args):
        """Function f."""
        return args

    def not_recordable(self):
        pass

class Parent(HasTraits):
    children = List(Child, record=True)
    recorder = Instance(Recorder, record=False)

class Test(HasTraits):
    # This should be set.
    recorder = Instance(HasTraits)

    # These should be ignored.
    _ignore = Bool(False)
    ignore_ = Bool(False)


class TestRecorder(unittest.TestCase):
    def setUp(self):
        self.tape = Recorder()
        set_recorder(self.tape)
        p = Parent()
        c = Child()
        toy = Toy(color='blue', type='bunny')
        c.toy = toy
        p.children.append(c)
        self.p = p
        return

    def tearDown(self):
        self.tape.clear()
        set_recorder(None)
        return

    def test_unique_name(self):
        "Does the get_unique_id method work."
        t = tvtk.XMLUnstructuredGridWriter()
        tape = self.tape
        self.assertEqual(tape._get_unique_name(t),
                         'xml_unstructured_grid_writer')
        self.assertEqual(tape._get_unique_name(t),
                         'xml_unstructured_grid_writer1')
        t = Toy()
        self.assertEqual(tape._get_unique_name(t),
                         'toy')
        t = (1, 2)
        self.assertEqual(tape._get_unique_name(t),
                         'tuple0')
        l = [1, 2]
        self.assertEqual(tape._get_unique_name(l),
                         'list0')
        d = {'a': 1}
        self.assertEqual(tape._get_unique_name(d),
                         'dict0')

        self.assertEqual(tape._get_unique_name(1),
                         'int0')

    def test_record(self):
        "Does recording work correctly."
        tape = self.tape
        p = self.p
        c = p.children[0]
        toy = c.toy
        # start recording.
        tape.recording = True
        tape.register(p)

        # Test if p's recorder attribute is set.
        self.assertEqual(tape, p.recorder)

        # Test script ids and object path.
        self.assertEqual(tape.get_script_id(p), 'parent')
        self.assertEqual(tape.get_object_path(p), '')

        self.assertEqual(tape.get_script_id(c), 'child')
        self.assertEqual(tape.get_object_path(c), 'parent.children[0]')

        self.assertEqual(tape.get_script_id(toy), 'child.toy')
        self.assertEqual(tape.get_object_path(toy),
                         'parent.children[0].toy')

        c.name = 'Ram'
        # The child should first be instantiated.
        self.assertEqual(tape.lines[-2],
                         "child = parent.children[0]")
        # Then its trait set.
        self.assertEqual(tape.lines[-1], "child.name = 'Ram'")
        c.age = 10.5
        self.assertEqual(tape.lines[-1], "child.age = 10.5")
        c.property.representation = 'w'
        self.assertEqual(tape.lines[-1],
                         "child.property.representation = 'wireframe'")
        c.property.color = (1, 0, 0)
        self.assertEqual(tape.lines[-1],
                         "child.property.color = (1.0, 0.0, 0.0)")
        toy.color = 'red'
        self.assertEqual(tape.lines[-1], "child.toy.color = 'red'")
        toy.type = 'teddy'
        self.assertEqual(tape.lines[-1], "child.toy.type = 'teddy'")
        # This trait should be ignored.
        toy.ignore = True
        self.assertEqual(tape.lines[-1], "child.toy.type = 'teddy'")

        # Turn of recording and test.
        tape.recording = False
        toy.type = 'rat'
        self.assertEqual(tape.lines[-1], "child.toy.type = 'teddy'")

        #print tape.script

        # Stop recording.
        n = len(tape.lines)
        tape.unregister(p)
        c.property.representation = 'points'
        toy.type = 'bunny'
        self.assertEqual(tape.lines[-1], "child.toy.type = 'teddy'")
        self.assertEqual(n, len(tape.lines))

        # Make sure the internal data of the recorder is cleared.
        self.assertEqual(0, len(tape._registry))
        self.assertEqual(0, len(tape._reverse_registry))
        self.assertEqual(0, len(tape._known_ids))

    def test_recorded_trait_replaced(self):
        "Does recording work right when a trait is replaced."
        tape = self.tape
        p = self.p
        c = p.children[0]
        toy = c.toy
        # start recording.
        tape.recording = True
        tape.register(p)

        # Test the original trait.
        toy.color = 'red'
        self.assertEqual(tape.lines[-1], "child.toy.color = 'red'")

        # Now reassign the toy.
        t1 = Toy(name='ball')
        c.toy = t1
        t1.color = 'yellow'
        self.assertEqual(tape.lines[-1], "child.toy.color = 'yellow'")

    def test_clear(self):
        "Test the clear method."
        p = self.p
        tape = self.tape

        tape.register(p)
        tape.clear()
        # Everything should be unregistered.
        self.assertEqual(p.recorder, None)
        # Internal data should be wiped clean.
        self.assertEqual(0, len(tape._registry))
        self.assertEqual(0, len(tape._reverse_registry))
        self.assertEqual(0, len(tape._known_ids))
        self.assertEqual(0, len(tape._name_map))

    def test_create_object(self):
        "Is the object imported and created if unknown?"
        tape = self.tape
        tape.recording = True
        t = Toy()
        tape.register(t)
        t.type = 'computer'

        # Since the name toy is unknown, there should be a
        # line to create it.
        self.assertEqual(tape.lines[-3][-10:],
                         "import Toy")
        self.assertEqual(tape.lines[-2],
                         "toy = Toy()")
        self.assertEqual(tape.lines[-1],
                         "toy.type = 'computer'")

        # Since this one is known, there should be no imports or
        # anything.
        t1 = Toy()
        tape.register(t1, known=True)
        t1.type = 'ball'
        self.assertEqual(tape.lines[-2],
                         "toy.type = 'computer'")
        self.assertEqual(tape.lines[-1],
                         "toy1.type = 'ball'")

    def test_list_items_changed(self):
        "Test if a list item is changed does the change get recorded."
        p = self.p
        tape = self.tape
        child = p.children[0]
        tape.register(p, known=True)
        tape.recording = True

        child.friends = ['Krishna', 'Ajay', 'Ali']
        self.assertEqual(tape.lines[-1],
                         "child.friends = ['Krishna', 'Ajay', 'Ali']")
        child.friends[1:] = ['Sam', 'Frodo']
        self.assertEqual(tape.lines[-1],
                         "child.friends[1:3] = ['Sam', 'Frodo']")
        child.friends[1] = 'Hari'
        self.assertEqual(tape.lines[-1],
                    "child.friends[1:2] = ['Hari']")

        # What if we change a list where record=True.
        child1 = Child()
        tape.register(child1)
        p.children.append(child1)
        self.assertEqual(tape.lines[-1],
                         "parent.children[1:1] = [child1]")
        del p.children[1]
        self.assertEqual(tape.lines[-1],
                         "parent.children[1:2] = []")
        p.children[0] = child1
        self.assertEqual(tape.lines[-1],
                         "parent.children[0:1] = [child1]")

    def test_path_change_on_list(self):
        "Does the object path update when a list has changed?"
        # Test the case where we have a hierarchy and we change the
        # list.
        tape = self.tape
        p = self.p
        child1 = Child()
        p.children.append(child1)
        tape.register(p)
        tape.recording = True
        self.assertEqual(tape.get_object_path(child1),
                         'parent.children[1]')
        self.assertEqual(tape.get_script_id(child1),
                         'child1')
        del p.children[0]
        self.assertEqual(tape.get_object_path(child1),
                         'parent.children[0]')
        self.assertEqual(tape.get_script_id(child1),
                         'child1')


    def test_write_script_id_in_namespace(self):
        "Test the write_script_id_in_namespace method."
        tape = self.tape
        tape.recording = True
        # This should not cause an error but insert the name 'foo' in the
        # namespace.
        tape.write_script_id_in_namespace('foo')

    def test_recorder_and_ignored(self):
        "Test if recorder trait is set and private traits are ignored."
        t = Test()
        self.assertEqual(t.recorder, None)
        self.assertEqual(t._ignore, False)
        self.assertEqual(t.ignore_, False)
        tape = Recorder()
        tape.register(t)
        tape.recording = True

        self.assertEqual(t.recorder, tape)
        t._ignore = True
        t.ignore_ = True
        self.assertEqual(len(tape.script.strip()), 0)

    def test_record_function(self):
        "See if recordable function calls are handled correctly."
        # Note that the global recorder is set in setUp and removed in
        # tearDown.

        tape = self.tape
        c = self.p.children[0]
        tape.register(c)
        tape.recording = True

        # Setting the age should be recorded.
        c.age = 11
        self.assertEqual(tape.lines[-1], "child.age = 11.0")

        # This should also work without problems.
        c.f(c.toy)
        self.assertEqual(tape.lines[-2], "child.age = 11.0")
        self.assertEqual(tape.lines[-1], 'child.toy = child.f(child.toy)')

        # Calling f should be recorded.
        c.f(1)
        self.assertEqual(tape.lines[-1], "child.f(1)")

        # This should not record the call to f or the change to the age
        # trait inside grow.
        c.grow(1)
        self.assertEqual(c.age, 12.0)
        self.assertEqual(tape.lines[-2], "child.f(1)")
        self.assertEqual(tape.lines[-1], "child.grow(1)")

        # Non-recordable functions shouldn't be.
        c.not_recordable()
        self.assertEqual(tape.lines[-1], "child.grow(1)")

        # Test a simple recordable function.
        @recordable
        def func(x, y):
            return x, y

        result = func(1, 2)
        self.assertEqual(tape.lines[-1], "tuple0 = func(1, 2)")

    def test_non_has_traits(self):
        "Can classes not using traits be handled?"
        tape = self.tape
        p = self.p
        c = p.children[0]
        class A(object):
            @recordable
            def __init__(self, x, y=1):
                self.x = x
                self.y = y

            @recordable
            def f(self, x, y):
                return x, y

            @recordable
            def g(self, x):
                return x

            def not_recordable(self):
                pass

        tape.register(p)
        tape.recording = True
        # Test if __init__ is recorded correctly.
        a = A(x=1)

        # Should record.
        a.f(1, 'asd')
        self.assertEqual(tape.lines[-3][-8:],
                         "import A")
        self.assertEqual(tape.lines[-2],
                         "a = A(x=1)")
        self.assertEqual(tape.lines[-1], "tuple0 = a.f(1, 'asd')")

        result = a.f(p, c)
        # This should instantiate the parent first, get the child from
        # that and then record the call itself.
        self.assertEqual(tape.lines[-3], "parent = Parent()")
        self.assertEqual(tape.lines[-2], "child = parent.children[0]")
        self.assertEqual(tape.lines[-1], "tuple1 = a.f(parent, child)")

        # This should simply refer to the child.
        result = a.g(c)
        self.assertEqual(tape.lines[-1], "child = a.g(child)")

        # Should do nothing.
        a.not_recordable()
        self.assertEqual(tape.lines[-1], "child = a.g(child)")

        # When a function is called with unknown args it should attempt
        # to create the objects.
        r = a.g(Toy())
        self.assertEqual(tape.lines[-3][-10:], "import Toy",
                         '\n'.join(tape.lines[-5:]))
        self.assertEqual(tape.lines[-2], "toy = Toy()")
        self.assertEqual(tape.lines[-1], "toy = a.g(toy)")

    def test_set_script_id(self):
        "Test if setting script_id at registration time works."
        tape = self.tape
        p = self.p
        c = p.children[0]
        tape.register(p, script_id='child')
        tape.recording = True
        # Ask to be called child.
        self.assertEqual(tape.get_script_id(p), 'child')
        # Register another Child.
        c1 = Child()
        tape.register(c1)
        # Will be child2 since child1 is taken.
        self.assertEqual(tape.get_script_id(c1), 'child2')

        # Test if recording works correctly with the changed script_id.
        p.children.append(c1)
        self.assertEqual(tape.lines[-1],
                         "child.children[1:1] = [child2]")


    def test_save(self):
        "Test if saving tape to file works."
        tape = self.tape
        p = self.p
        c = p.children[0]
        toy = c.toy

        # Start recording
        tape.register(p)
        tape.recording = True
        toy.type = 'teddy'
        # Now stop.
        tape.recording = False
        tape.unregister(p)

        import StringIO
        f = StringIO.StringIO()
        tape.save(f)
        # Test if the file is OK.
        expect = ["child = parent.children[0]\n",
                  "child.toy.type = 'teddy'\n"
                  ]
        f.seek(0)
        lines = f.readlines()
        self.assertEqual(expect, lines)
        f.close()

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_registry
# Author: Suyog Dutt Jain <suyog.jain@aero.iitb.ac.in>
# Copyright (c) 2009,  Enthought, Inc.
# License: BSD Style.

# Standard library imports.
import unittest

#Local Imports
from common import get_example_data

# Enthought library imports
from mayavi.core.null_engine import NullEngine
from mayavi.core.registry import registry
from mayavi.sources.plot3d_reader import PLOT3DReader
from mayavi.core.metadata import SourceMetadata
from mayavi.core.pipeline_info import PipelineInfo

class DummyReader(PLOT3DReader):

    def print_info(self):
        """This is a Dummy Reader for Testing Purposes
        Its extended from PLOT3D Reader"""
        pass

    # Callable which always returns false
    def check_read(cls, filename):
        """ Callable which alwasy returns False
        """
        return False

    check_read = classmethod(check_read)


class TestRegistry(unittest.TestCase):

    def setUp(self):
        """Initial setting up of test fixture, automatically called by TestCase
        before any other test method is invoked"""
        e = NullEngine()
        #Uncomment to see visualization for debugging etc.
        #e = Engine()
        e.start()
        e.new_scene()
        self.e=e
        self.scene = e.current_scene
        return

    def tearDown(self):
        """For necessary clean up, automatically called by TestCase
        after the test methods have been invoked"""
        self.e.stop()
        return

    def test_unique_reader(self):
        "Check if a file with a unique reader in Mayavi2 can be read"
        e = self.e
        reader = e.open(get_example_data('prism.neu'))
        self.assertNotEqual(reader, None)

    def test_unsupported_file(self):
        "Test if the mechanism to handle unsupported files works fine"
        reader = registry.get_file_reader('junk.abc')
        self.assertEqual(reader, None)

    def test_multipe_readers(self):
        "Test if reader conflict is resolved"
        # Testing two files with same extensions but have to be read
        # by different readers
        reader = registry.get_file_reader(get_example_data('tiny.xyz'))
        callable = reader.get_callable()
        self.assertEqual(callable.__name__, 'PLOT3DReader')

        reader = registry.get_file_reader(get_example_data('thio3xx.xyz'))
        callable = reader.get_callable()
        self.assertEqual(callable.__name__, 'PolyDataReader')

    def test_multiple_valid_readers(self):
        """Test if the fixture works fine if there are multiple readers
        capable of reading the file properly"""
        # Inserting a dummy reader into the registry also capable of
        # reading files with extension 'xyz'
        open_dummy = SourceMetadata(
                id            = "DummyFile",
                class_name    = "mayavi.tests.test_registry.DummyReader",
                menu_name     = "&PLOT3D file",
                tooltip       = "Open a PLOT3D data data",
                desc        = "Open a PLOT3D data data",
                help        = "Open a PLOT3D data data",
                extensions = ['xyz'],
                wildcard = 'PLOT3D files (*.xyz)|*.xyz',
                can_read_test = 'mayavi.tests.test_registry:DummyReader.check_read',
                output_info = PipelineInfo(datasets=['structured_grid'],
                    attribute_types=['any'],
                    attributes=['any'])
                )
        registry.sources.append(open_dummy)
        reader = registry.get_file_reader(get_example_data('tiny.xyz'))
        callable = reader.get_callable()
        self.assertEqual(callable.__name__, 'PLOT3DReader')

        # Removing existing readers for .xyz extensions to check if the Dummy
        # reader now reads it.
        remove = []
        for index, src in enumerate(registry.sources[:]):
            if 'xyz' in src.extensions and src.id != 'DummyFile':
                remove.append((index, src))
                registry.sources.remove(src)

        reader = registry.get_file_reader(get_example_data('tiny.xyz'))
        callable = reader.get_callable()
        self.assertEqual(callable.__name__, 'DummyReader')

        for index, src in remove:
            registry.sources.insert(index, src)
        registry.sources.remove(open_dummy)

    def test_no_valid_reader(self):
        """Test that if there is no reader which can read the file with
        assurity, the registry returns the last one of the readers
        which dont have a can_read_test and claim to read the file with
        the given extension"""
        open_dummy = SourceMetadata(
                id            = "DummyFile",
                class_name    = "mayavi.tests.test_registry.DummyReader",
                menu_name     = "&PLOT3D file",
                tooltip       = "Open a PLOT3D data data",
                desc        = "Open a PLOT3D data data",
                help        = "Open a PLOT3D data data",
                extensions = ['xyz'],
                wildcard = 'PLOT3D files (*.xyz)|*.xyz',
                can_read_test = 'mayavi.tests.test_registry:DummyReader.check_read',
                output_info = PipelineInfo(datasets=['structured_grid'],
                    attribute_types=['any'],
                    attributes=['any'])
                )
        registry.sources.append(open_dummy)

        # Remove the poly data reader.
        for index, src in enumerate(registry.sources[:]):
            if src.id == 'PolyDataFile':
                poly = src
                registry.sources.remove(src)
                break

        reader = registry.get_file_reader(get_example_data('tiny.xyz'))
        callable = reader.get_callable()
        self.assertEqual(callable.__name__, 'PLOT3DReader')

        # Add back the poly data reader.
        registry.sources.insert(index, poly)
        registry.sources.remove(open_dummy)

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_script_recording
"""
A simple test for script recording in Mayavi.
"""
# Author: Prabhu Ramachandran <prabhu@aero.iitb.ac.in>
# Copyright (c) 2008, Enthought, Inc.
# License: BSD Style.

import unittest

from apptools.scripting.api import Recorder, set_recorder
from mayavi.sources.parametric_surface import \
    ParametricSurface
from mayavi.modules.outline import Outline
from mayavi.modules.surface import Surface

from mayavi.core.null_engine import NullEngine


class TestScriptRecording(unittest.TestCase):
    def setUp(self):
        tape = Recorder()
        # Set the global recorder.
        set_recorder(tape)
        self.tape = tape

    def tearDown(self):
        self.tape.clear()
        set_recorder(None)

    def test_script_recording(self):
        "Does script recording work correctly."
        # Create a mayavi pipeline and record it.
        tape = self.tape
        e = NullEngine()
        e.start()
        # Start recording.
        tape.recording = True
        tape.register(e, known=True, script_id='engine')
        e.new_scene()
        #print tape.script
        self.assertEqual(tape.lines[-1],
                         "dummy_viewer = engine.new_scene()")

        src = ParametricSurface()
        e.add_source(src)
        expect = 'from mayavi.sources.parametric_surface '\
                 'import ParametricSurface'
        self.assertEqual(tape.lines[-3], expect)
        self.assertEqual(tape.lines[-2],
                         "parametric_surface = ParametricSurface()")
        self.assertEqual(tape.lines[-1],
                         "engine.add_source(parametric_surface)")

        src.function = 'dini'
        self.assertEqual(tape.lines[-1],
                         "parametric_surface.function = 'dini'")

        o = Outline()
        e.add_module(o)
        expect = 'from mayavi.modules.outline import Outline'
        self.assertEqual(tape.lines[-3], expect)
        self.assertEqual(tape.lines[-2], "outline = Outline()")
        self.assertEqual(tape.lines[-1],
                         "engine.add_module(outline)")

        o.actor.property.color = (1,0,0)
        self.assertEqual(tape.lines[-1],
                         "outline.actor.property.color = (1.0, 0.0, 0.0)")

        s = Surface()
        e.add_module(s)
        expect = 'from mayavi.modules.surface import Surface'
        self.assertEqual(tape.lines[-3], expect)
        self.assertEqual(tape.lines[-2], "surface = Surface()")
        self.assertEqual(tape.lines[-1],
                         "engine.add_module(surface)")

        s.actor.property.representation = 'wireframe'
        self.assertEqual(tape.lines[-1],
                         "surface.actor.property.representation = 'wireframe'")

        o.actor.property.representation = 'wireframe'
        self.assertEqual(tape.lines[-1],
                         "outline.actor.property.representation = 'wireframe'")

        s.actor.property.opacity = 0.5
        self.assertEqual(tape.lines[-1],
                         "surface.actor.property.opacity = 0.5")

        s.actor.mapper.scalar_visibility = False
        self.assertEqual(tape.lines[-1],
                         "surface.actor.mapper.scalar_visibility = False")

        #print tape.script

        # Stop recording and test.
        tape.unregister(e)
        tape.record('#end') # Placeholder
        o.actor.property.opacity = 0.5
        self.assertEqual(tape.lines[-1], '#end')
        s.actor.property.color = (1,0,0)
        self.assertEqual(tape.lines[-1], '#end')
        s.enable_contours = True
        self.assertEqual(tape.lines[-1], '#end')
        src.function = 'klein'
        self.assertEqual(tape.lines[-1], '#end')


if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_set_active_attribute
# Author: Suyog Dutt Jain <suyog.jain@aero.iitb.ac.in>
#         Prabhu Ramachandran <prabhu_r@users.sf.net>
# Copyright (c) 2008,  Enthought, Inc.
# License: BSD Style.

# Standard library imports.
from os.path import abspath
from StringIO import StringIO
import copy
import unittest

# Local imports.
from common import get_example_data

# Enthought library imports
from mayavi.core.null_engine import NullEngine
from mayavi.sources.api import VTKXMLFileReader
from mayavi.filters.contour import Contour
from mayavi.filters.api import PolyDataNormals
from mayavi.filters.set_active_attribute import SetActiveAttribute
from mayavi.modules.api import Surface, Outline

class TestSetActiveAttribute(unittest.TestCase):

    def setUp(self):
        """Initial setting up of test fixture, automatically called by TestCase before any other test method is invoked"""
        e = NullEngine()
        # Uncomment to see visualization for debugging etc.
        #e = Engine()
        e.start()
        e.new_scene()
        self.e=e

        r = VTKXMLFileReader()
        r.initialize(get_example_data('pyramid_ug.vtu'))
        e.add_source(r)
        r.point_scalars_name = 'temperature'
        o = Outline()
        e.add_module(o)
        c = Contour()
        e.add_filter(c)
        n = PolyDataNormals()
        e.add_filter(n)
        aa = SetActiveAttribute()
        e.add_filter(aa)
        aa.point_scalars_name = 'pressure'
        s = Surface()
        e.add_module(s)
        self.scene = e.current_scene
        return

    def tearDown(self):
        """For necessary clean up, automatically called by TestCase after the test methods have been invoked"""
        self.e.stop()
        return

    def check(self):
        """Do the actual testing"""
        scene = self.scene
        src = scene.children[0]
        self.assertEqual(src.point_scalars_name,'temperature')
        c = src.children[1]
        sc = c.outputs[0].point_data.scalars
        self.assertEqual(sc.name,'temperature')
        # It is an iso-contour!
        self.assertEqual(sc.range[0],sc.range[1])
        aa = c.children[0].children[0]
        self.assertEqual(aa.point_scalars_name,'pressure')
        sc = aa.outputs[0].point_data.scalars
        self.assertEqual(sc.name, 'pressure')
        self.assertEqual((abs(sc.range[0] - 70) < 1.0),True)
        self.assertEqual((abs(sc.range[1] - 70) < 1.0),True)
        s = aa.children[0].children[0]


    def test_set_active_attribute(self):
        "Test if the test fixture works"
        #Now test.
        self.check()

        #from mayavi.tools.show import show
        #show()


    def test_save_and_restore(self):
        """Test if saving a visualization and restoring it works."""
        engine = self.e
        scene = self.scene

        # Save visualization.
        f = StringIO()
        f.name = abspath('test.mv2') # We simulate a file.
        engine.save_visualization(f)
        f.seek(0) # So we can read this saved data.

        # Remove existing scene.

        engine.close_scene(scene)

        # Load visualization
        engine.load_visualization(f)
        self.scene = engine.current_scene

        self.check()


    def test_deepcopied(self):
        """Test if the MayaVi2 visualization can be deep-copied."""
        ############################################################
        # Test if the MayaVi2 visualization can be deep-copied.

        # Pop the source object.
        s =  self.scene
        source = s.children.pop()
        # Add it back to see if that works without error.
        s.children.append(source)
        self.check()

        # Now deepcopy the source and replace the existing one with
        # the copy.  This basically simulates cutting/copying the
        # object from the UI via the right-click menu on the tree
        # view, and pasting the copy back.
        source1 = copy.deepcopy(source)
        s.children[0] = source1
        self.check()
        #from mayavi.tools.show import show
        #show()



if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_streamline
# Author: Suyog Dutt Jain <suyog.jain@aero.iitb.ac.in>
#         Prabhu Ramachandran <prabhu_r@users.sf.net>
# Copyright (c) 2008,  Enthought, Inc.
# License: BSD Style.

# Standard library imports.
from os.path import abspath
from StringIO import StringIO
import copy
import numpy
import unittest

# Enthought library imports
from mayavi.core.null_engine import NullEngine
from mayavi.sources.array_source import ArraySource
from mayavi.modules.outline import Outline
from mayavi.modules.streamline import Streamline

class TestStreamline(unittest.TestCase):


    def make_data(self):
        """Trivial data -- creates an elementatry scalar field and a
        constant vector field along the 'x' axis."""
        s = numpy.arange(0.0, 10.0, 0.01)
        s = numpy.reshape(s, (10,10,10))
        s = numpy.transpose(s)

        v = numpy.zeros(3000, 'd')
        v[1::3] = 1.0
        v = numpy.reshape(v, (10,10,10,3))
        return s, v

    def setUp(self):
        """Initial setting up of test fixture, automatically called by TestCase before any other test method is invoked"""
        e = NullEngine()
        # Uncomment to see visualization for debugging etc.
        #e = Engine()
        e.start()
        s=e.new_scene()
        self.e=e
        self.s=s

        ############################################################
        # Create a new scene and set up the visualization.

        d = ArraySource()
        sc, vec = self.make_data()
        d.origin = (-5, -5, -5)
        d.scalar_data = sc
        d.vector_data = vec

        e.add_source(d)

        # Create an outline for the data.
        o = Outline()
        e.add_module(o)

        # View the data.
        st = Streamline()
        e.add_module(st)
        widget = st.seed.widget
        widget.set(radius=1.0, center=(-4.0, -4.0, -4.0),
                   theta_resolution=4, phi_resolution=4)

        st = Streamline(streamline_type='ribbon')
        seed = st.seed
        seed.widget = seed.widget_list[1]
        e.add_module(st)
        seed.widget.set(point1=(-5.0, -4.5, -4.0), point2=(-5.0, -4.5, 4.0))
        st.ribbon_filter.width = 0.25

        st = Streamline(streamline_type='tube')
        seed = st.seed
        seed.widget = seed.widget_list[2]
        e.add_module(st)
        seed.widget.set(center=(-5.0, 1.5, -2.5))
        st.tube_filter.radius = 0.15

        st = Streamline(streamline_type='tube')
        seed = st.seed
        seed.widget = seed.widget_list[3]
        e.add_module(st)
        seed.widget.position=(-5.0, 3.75, 3.75)
        st.tube_filter.radius = 0.2
        self.st = st
        self.scene = e.current_scene
        return

    def tearDown(self):
        """For necessary clean up, automatically called by TestCase after the test methods have been invoked"""
        self.e.stop()
        return

    def check(self):
        """Do the actual testing."""

        s=self.scene
        src = s.children[0]

        st = src.children[0].children[2]
        self.assertEqual(st.streamline_type,'ribbon')
        self.assertEqual(st.ribbon_filter.width,0.25)
        self.assertEqual(st.seed.widget,st.seed.widget_list[1])
        self.assertEqual(numpy.allclose(st.seed.widget.point1,
                            (-5.0, -4.5, -4.0)),True)
        self.assertEqual(numpy.allclose(st.seed.widget.point2,
                            (-5.0, -4.5, 4.0)),True)

        st = src.children[0].children[3]
        self.assertEqual(st.streamline_type,'tube')
        self.assertEqual(st.tube_filter.radius,0.15)
        self.assertEqual(st.seed.widget,st.seed.widget_list[2])
        self.assertEqual(numpy.allclose(st.seed.widget.center,
                            (-5.0, 1.5, -2.5)),True)

        st = src.children[0].children[4]
        self.assertEqual(st.streamline_type,'tube')
        self.assertEqual(st.tube_filter.radius,0.2)
        self.assertEqual(st.seed.widget,st.seed.widget_list[3])
        self.assertEqual(numpy.allclose(st.seed.widget.position,
                            (-5.0, 3.75, 3.75)),True)


    def test_streamline(self):
        "Test if the test fixture works"
        self.check()

    def test_components_changed(self):
        """Test if the modules respond correctly when the components
           are changed."""
        st = self.st
        tf = st.tube_filter
        st.tube_filter = tf.__class__()
        st.tube_filter = tf
        st.ribbon_filter = st.ribbon_filter.__class__()
        seed = st.seed
        st.seed = seed.__class__()
        st.seed = seed
        st.actor = st.actor.__class__()
        tracer = st.stream_tracer
        st.stream_tracer = tracer.__class__()
        st.stream_tracer = tracer
        self.check()



    def test_save_and_restore(self):
        """Test if saving a visualization and restoring it works."""
        engine = self.e
        scene = self.scene
        # Save visualization.
        f = StringIO()
        f.name = abspath('test.mv2') # We simulate a file.
        engine.save_visualization(f)
        f.seek(0) # So we can read this saved data.

        # Remove existing scene.

        engine.close_scene(scene)

        # Load visualization
        engine.load_visualization(f)
        self.scene = engine.current_scene

        self.check()

    def test_deepcopied(self):
        """Test if the MayaVi2 visualization can be deep-copied."""
        ############################################################
        # Test if the MayaVi2 visualization can be deep-copied.

        # Pop the source object.
        s =  self.scene
        sources = s.children
        s.children = []
        # Add it back to see if that works without error.
        s.children.extend(sources)

        self.check()

        # Now deepcopy the source and replace the existing one with
        # the copy.  This basically simulates cutting/copying the
        # object from the UI via the right-click menu on the tree
        # view, and pasting the copy back.
        sources1 = copy.deepcopy(sources)
        s.children[:] = sources1
        self.check()


if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_text3d
# Author: Gael Varoquaux <gael dot varoquaux at enthought dot com>
# Copyright (c) 2009,  Enthought, Inc.
# License: BSD Style.

# Standard library imports.
import unittest
from StringIO import StringIO
from os.path import abspath

import numpy as np

# Local imports.
from mayavi.core.null_engine import NullEngine
from tvtk.api import tvtk

# Enthought library imports
from mayavi.sources.array_source import ArraySource
from mayavi.modules.text3d import Text3D

class TestText3D(unittest.TestCase):


    def make_data(self):
        """Trivial data """
        return np.zeros((10,10,10))

    def setUp(self):
        """Initial setting up of test fixture, automatically called by TestCase before any other test method is invoked"""
        e = NullEngine()
        # Uncomment to see visualization for debugging etc.
        #e = Engine()
        e.start()
        s=e.new_scene()
        self.e=e
        self.s=s

        ############################################################
        # Create a new scene and set up the visualization.

        d = ArraySource()
        sc = self.make_data()
        d.scalar_data = sc

        e.add_source(d)
        self.t = Text3D()
        e.add_module(self.t)

        self.scene = e.current_scene
        return


    def save_and_reload(self):
        # Save visualization.
        f = StringIO()
        f.name = abspath('test.mv2') # We simulate a file.
        self.e.save_visualization(f)
        f.seek(0) # So we can read this saved data.

        # Remove existing scene.
        self.e.close_scene(self.scene)

        # Load visualization
        self.e.load_visualization(f)
        self.scene = self.e.current_scene


    def tearDown(self):
        """For necessary clean up, automatically called by TestCase after the test methods have been invoked"""
        self.e.stop()
        return



    def test_text3d(self):
        "Test if the text3d has been properly instanciated"
        self.assert_(isinstance(self.t, Text3D))


    def test_follower(self):
        """ Test if changing 'orient_to_camera' switches between plain
            actor and follower """
        self.t.orient_to_camera = True
        self.assert_(isinstance(self.t.actor.actor, tvtk.Follower))
        self.t.orient_to_camera = False
        self.assertFalse(isinstance(self.t.actor.actor, tvtk.Follower))


    def test_persistence(self):
        # First test persistence without follower
        self.save_and_reload()
        self.t.orient_to_camera = False
        self.assertFalse(isinstance(self.t.actor.actor, tvtk.Follower))
        self.assertFalse(self.t.orient_to_camera)
        self.t.orient_to_camera = True
        self.assert_(isinstance(self.t.actor.actor, tvtk.Follower))
        self.save_and_reload()
        self.assertTrue(self.t.orient_to_camera)
        self.assert_(isinstance(self.t.actor.actor, tvtk.Follower))

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_threshold_filter
# Author: Gael Varoquaux <gael.varoquaux@normalesup.org>
# Copyright (c) 2010,  Enthought, Inc.
# License: BSD Style.

# Standard library imports.
import unittest

import numpy as np

# Local imports.
from mayavi.core.null_engine import NullEngine

# Enthought library imports
from mayavi.filters.threshold import Threshold
from mayavi.sources.array_source import ArraySource


class TestThresholdFilter(unittest.TestCase):

    def make_src(self, nan=False):
        data      = np.empty((3, 3, 3))
        if nan:
            data[0]   = np.nan
        data.flat[:] = np.arange(data.size)
        return ArraySource(scalar_data=data)

    def setUp(self):
        """Initial setting up of test fixture, automatically called by
        TestCase before any other test method is invoked"""
        e = NullEngine()
        # Uncomment to see visualization for debugging etc.
        #e = Engine()
        e.start()
        s = e.new_scene()
        self.e = e
        self.s = s


        self.scene = e.current_scene
        return

    def tearDown(self):
        """For necessary clean up, automatically called by TestCase
        after the test methods have been invoked"""
        self.e.stop()
        return

    def test_threshold_filter_nan(self):
        src = self.make_src(nan=True)
        self.e.add_source(src)
        threshold = Threshold()
        self.e.add_filter(threshold)
        self.assertEqual(np.nanmin(src.scalar_data),
                         np.nanmin(
                            threshold.outputs[0].point_data.scalars.to_array()
                         ))
        self.assertEqual(np.nanmax(src.scalar_data),
                         np.nanmax(
                            threshold.outputs[0].point_data.scalars.to_array()
                         ))


    def test_threshold_filter_threhsold(self):
        src = self.make_src()
        self.e.add_source(src)
        threshold = Threshold()
        self.e.add_filter(threshold)
        threshold.upper_threshold = 20.
        self.assertTrue(20 >=
                         np.nanmax(
                            threshold.outputs[0].point_data.scalars.to_array()
                         ))
        return



if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_unstructured_data_reader
# Author: Suyog Dutt Jain <suyog.jain@aero.iitb.ac.in>
# Copyright (c) 2009,  Enthought, Inc.
# License: BSD Style.

# Standard library imports.
import unittest

# Local imports.
from common import get_example_data

# Enthought library imports
from tvtk.common import is_old_pipeline
from mayavi.sources.unstructured_grid_reader import UnstructuredGridReader
from mayavi.tests.data_reader_test_base import DataReaderTestBase

old_pipeline = is_old_pipeline()

class TestAVSUCDReader(DataReaderTestBase):

    def setup_reader(self):

        """"Setup the reader in here.  This is called after the engine
        has been created and started.  The engine is available as
        self.e.  This method is called by setUp().
        """
        # Read a AVSUCD data file.
        r = UnstructuredGridReader()
        r.initialize(get_example_data('cellsnd.ascii.inp'))
        self.e.add_source(r)
        self.bounds =(-2.0, 2.0, -2.0, 2.0, 0.0, 0.0)

    def test_avsucd_data_reader(self):
        "Test if the test fixture works"
        #Now test.

        self.check(self.scene, self.bounds)

    def test_save_and_restore(self):
        """Test if saving a visualization and restoring it works."""

        self.check_saving(self.e, self.scene, self.bounds)

    def test_deepcopied(self):
        """Test if the MayaVi2 visualization can be deep-copied."""
        ############################################################
        # Test if the MayaVi2 visualization can be deep-copied.

        self.check_deepcopying(self.scene, self.bounds)

@unittest.skipIf(not old_pipeline,
                    "ExodusReader is not supported VTK 6.0 onwards.")
class TestExodusReader(DataReaderTestBase):

    def setup_reader(self):

        """"Setup the reader in here.  This is called after the engine
        has been created and started.  The engine is available as
        self.e.  This method is called by setUp().
        """
        # Read a Exodus data file.
        r = UnstructuredGridReader()
        r.initialize(get_example_data('edgeFaceElem.exii'))
        self.e.add_source(r)
        self.bounds =(-3.0, 3.0, -3.0, 3.0, -3.0, 3.0)

    def test_exodus_data_reader(self):
        "Test if the test fixture works"
        #Now test.

        self.check(self.scene, self.bounds)

    def test_save_and_restore(self):
        """Test if saving a visualization and restoring it works."""

        self.check_saving(self.e, self.scene, self.bounds)

    def test_deepcopied(self):
        """Test if the MayaVi2 visualization can be deep-copied."""
        ############################################################
        # Test if the MayaVi2 visualization can be deep-copied.

        self.check_deepcopying(self.scene, self.bounds)

#TODO: Update the ExodusIIReader test for scenarios as for the other readers
#in this module.
@unittest.skip("ExodusIIReader support is disabled for now.")
class TestExodusIIReader(DataReaderTestBase):

    def setup_reader(self):

        """"Setup the reader in here.  This is called after the engine
        has been created and started.  The engine is available as
        self.e.  This method is called by setUp().
        """
        # Read a Exodus data file.
        r = UnstructuredGridReader()
        r.initialize(get_example_data('disk_out_ref.ex2'))
        self.e.add_source(r)

    def test_point_cell_data(self):
        """ Test if the point and cell data is parsed correctly."""
        u_grid = self.scene.children[0].outputs[0]
        self.assertEqual(u_grid.point_data.number_of_arrays, 7)
        self.assertEqual(u_grid.cell_data.number_of_arrays, 1)
        self.assertEqual(u_grid.point_data.number_of_tuples, 8499)
        self.assertEqual(u_grid.cell_data.number_of_tuples, 7472)

class TestGambitReader(DataReaderTestBase):

    def setup_reader(self):

        """"Setup the reader in here.  This is called after the engine
        has been created and started.  The engine is available as
        self.e.  This method is called by setUp().
        """
        # Read a Gambit data file.
        r = UnstructuredGridReader()
        r.initialize(get_example_data('prism.neu'))
        self.e.add_source(r)
        self.bounds = (-1.0, 1.0, -1.0, 1.0, 0.0, 1.0)

    def test_gambit_data_reader(self):
        "Test if the test fixture works"
        #Now test.

        self.check(self.scene, self.bounds)

    def test_save_and_restore(self):
        """Test if saving a visualization and restoring it works."""

        self.check_saving(self.e, self.scene, self.bounds)

    def test_deepcopied(self):
        """Test if the MayaVi2 visualization can be deep-copied."""
        ############################################################
        # Test if the MayaVi2 visualization can be deep-copied.

        self.check_deepcopying(self.scene, self.bounds)

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_user_defined
# Author: Suyog Dutt Jain <suyog.jain@aero.iitb.ac.in>
#         Prabhu Ramachandran <prabhu_r@users.sf.net>
# Copyright (c) 2008,  Enthought, Inc.
# License: BSD Style.

# Standard library imports.
from os.path import abspath
from StringIO import StringIO
import copy
import unittest

# Local imports.
from common import get_example_data

# Enthought library imports
from mayavi.core.null_engine import NullEngine
from mayavi.filters.optional import Optional
from mayavi.filters.user_defined import UserDefined
from mayavi.filters.api import (CellToPointData, ExtractVectorNorm, ExtractVectorComponents)
from mayavi.modules.api import ScalarCutPlane
from mayavi.sources.vtk_xml_file_reader import VTKXMLFileReader
from tvtk.api import tvtk

class TestUserDefined(unittest.TestCase):

    def setUp(self):
        """Initial setting up of test fixture, automatically called by TestCase before any other test method is invoked"""
        e = NullEngine()
        # Uncomment to see visualization for debugging etc.
        #e = Engine()
        e.start()
        e.new_scene()
        self.e=e

        # Read a VTK (old style) data file.
        r = VTKXMLFileReader()
        r.initialize(get_example_data('pyramid_ug.vtu'))
        e.add_source(r)

        # Create the filters.
        # CellDerivatives
        cd = tvtk.CellDerivatives()
        ud = UserDefined(filter=cd)
        e.add_filter(ud)
        ctp = CellToPointData()
        ctp.filter.pass_cell_data = False
        e.add_filter(ctp)
        evn = ExtractVectorNorm()
        e.add_filter(evn)
        evc = ExtractVectorComponents(component='y-component')
        o = Optional(filter=evc)
        e.add_filter(o)
        e.add_module(ScalarCutPlane())
        self.scene = e.current_scene
        s = self.scene
        return

    def tearDown(self):
        """For necessary clean up, automatically called by TestCase after the test methods have been invoked"""
        self.e.stop()
        return

    def check(self):
        """Do the actual testing."""
        scene = self.scene
        src = scene.children[0]
        ud = src.children[0]
        o = ud.children[0].children[0].children[0]
        mm = o.children[0]

        assert src.outputs[0].point_data.scalars.name == 'temperature'
        assert src.outputs[0].point_data.vectors.name == 'velocity'
        expect = ['ScalarGradient', 'Vorticity']
        expect1 = [x +'-y' for x in expect]
        expect2 = [x + ' magnitude' for x in expect]

        o.enabled = True
        assert o.outputs[0].point_data.scalars.name in expect1
        assert o.outputs[0].point_data.vectors.name in expect
        assert mm.scalar_lut_manager.data_name in expect1
        # Turn of extraction.
        o.enabled = False
        assert o.outputs[0].point_data.scalars.name in expect2
        assert o.outputs[0].point_data.vectors.name in expect
        assert mm.scalar_lut_manager.data_name in expect2

        # Compute the vorticity
        ud.filter.vector_mode = 'compute_vorticity'
        assert o.outputs[0].point_data.scalars.name == 'Vorticity magnitude'
        assert o.outputs[0].point_data.vectors.name == 'Vorticity'
        assert mm.scalar_lut_manager.data_name == 'Vorticity magnitude'
        # Turn on extraction.
        o.enabled = True
        assert o.outputs[0].point_data.scalars.name == 'Vorticity-y'
        assert o.outputs[0].point_data.vectors.name == 'Vorticity'
        assert mm.scalar_lut_manager.data_name == 'Vorticity-y'
        # Turn off extraction.
        o.enabled = False



    def test_user_defined(self):
        "Test if the test fixture works"
        #Now test.
        s = self.scene
        self.check()

        #from mayavi.tools.show import show
        #show()




    def test_save_and_restore(self):
        """Test if saving a visualization and restoring it works."""
        engine = self.e
        scene = self.scene

        # Save visualization.
        f = StringIO()
        f.name = abspath('test.mv2') # We simulate a file.
        engine.save_visualization(f)
        f.seek(0) # So we can read this saved data.

        # Remove existing scene.

        engine.close_scene(scene)

        # Load visualization
        engine.load_visualization(f)
        self.scene = engine.current_scene
        s = self.scene
        self.check()


    def test_deepcopied(self):
        """Test if the MayaVi2 visualization can be deep-copied."""
        ############################################################
        # Test if the MayaVi2 visualization can be deep-copied.

        # Pop the source object.
        s =  self.scene
        source = s.children.pop()
        # Add it back to see if that works without error.
        s.children.append(source)
        cp = source.children[0].children[-1]
        s = self.scene

        self.check()

        # Now deepcopy the source and replace the existing one with
        # the copy.  This basically simulates cutting/copying the
        # object from the UI via the right-click menu on the tree
        # view, and pasting the copy back.
        source1 = copy.deepcopy(source)
        s.children[0] = source1
        s = self.scene
        self.check()
        #from mayavi.tools.show import show
        #show()





if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_vtk_data_source
# Author: Suyog Dutt Jain <suyog.jain@aero.iitb.ac.in>
#         Prabhu Ramachandran <prabhu_r@users.sf.net>
# Copyright (c) 2008,  Enthought, Inc.
# License: BSD Style.

# Standard library imports.
from os.path import abspath
from StringIO import StringIO
import copy
import numpy
import unittest
import datasets

# Enthought library imports
from mayavi.core.null_engine import NullEngine
from mayavi.sources.vtk_data_source import VTKDataSource
from mayavi.modules.outline import Outline
from mayavi.modules.iso_surface import IsoSurface
from mayavi.modules.contour_grid_plane import ContourGridPlane
from mayavi.modules.scalar_cut_plane import ScalarCutPlane
from tvtk.api import tvtk

class TestVTKDataSource(unittest.TestCase):

    def setUp(self):
        """Initial setting up of test fixture, automatically called by TestCase before any other test method is invoked"""
        e = NullEngine()
        # Uncomment to see visualization for debugging etc.
        #e = Engine()
        e.start()
        e.new_scene()
        self.e=e

        sgrid=datasets.generateStructuredGrid()
        src = VTKDataSource(data = sgrid)
        e.add_source(src)

        # Create an outline for the data.
        o = Outline()
        e.add_module(o)

        # Create one ContourGridPlane normal to the 'x' axis.
        cgp1 = ContourGridPlane()
        e.add_module(cgp1)
        # Set the position to the middle of the data.
        cgp1.grid_plane.position = 15

        # Another with filled contours normal to 'y' axis.
        cgp2 = ContourGridPlane()
        cgp2.contour.filled_contours = True
        # Set the axis and position to the middle of the data.
        cgp2.grid_plane.axis = 'y'
        cgp2.grid_plane.position = 15
        e.add_module(cgp2)

        # An isosurface module.
        iso = IsoSurface(compute_normals=True)
        e.add_module(iso)
        iso.contour.contours = [5]

        # An interactive scalar cut plane.
        cp = ScalarCutPlane()
        e.add_module(cp)
        ip = cp.implicit_plane
        ip.normal = 0,0,1
        ip.origin = 0.5, 0.5, 1.0
        # Since this is running offscreen this seems necessary.
        ip.widget.origin = 0.5, 0.5, 1.0
        ip.widget.enabled = False
        self.scene = e.current_scene
        self.cgp2=cgp2
        self.iso=iso
        self.cp=cp
        return

    def tearDown(self):
        """For necessary clean up, automatically called by TestCase after the test methods have been invoked"""
        self.e.stop()
        return

    def check(self):
        """Do the actual testing."""
        scene = self.scene
        src = scene.children[0]
        mm = src.children[0]
        cgp1 = mm.children[1]
        self.assertEqual(cgp1.grid_plane.position,15)

        cgp2 = mm.children[2]
        self.assertEqual(cgp2.contour.filled_contours,True)
        self.assertEqual(cgp2.grid_plane.axis, 'y')
        self.assertEqual(cgp2.grid_plane.position,15)

        iso = mm.children[3]
        ctr = iso.contour.contours
        self.assertEqual(iso.compute_normals,True)
        self.assertEqual(ctr, [5.0])
        rng = iso.actor.mapper.input.point_data.scalars.range
        self.assertEqual(rng[0],5.0)
        self.assertEqual(rng[1],5.0)


        cp = mm.children[4]
        ip = cp.implicit_plane
        self.assertAlmostEqual(numpy.sum(ip.normal - (0,0,1)) , 1e-16)
        self.assertAlmostEqual(numpy.sum(ip.origin - (0.5, 0.5, 1.0)), 0.0)
        self.assertEqual(ip.widget.enabled,False)



    def test_vtk_data_source(self):
        "Test if the test fixture works"
        #Now test.
        self.check()

        #from mayavi.tools.show import show
        #show()

    def test_save_and_restore(self):
        """Test if saving a visualization and restoring it works."""
        engine = self.e
        scene = self.scene

        # Save visualization.
        f = StringIO()
        f.name = abspath('test.mv2') # We simulate a file.
        engine.save_visualization(f)
        f.seek(0) # So we can read this saved data.

        # Remove existing scene.

        engine.close_scene(scene)

        # Load visualization
        engine.load_visualization(f)
        self.scene = engine.current_scene

        self.check()


    def test_deepcopied(self):
        """Test if the MayaVi2 visualization can be deep-copied."""
        ############################################################
        # Test if the MayaVi2 visualization can be deep-copied.

        # Pop the source object.
        s =  self.scene
        source = s.children.pop()
        # Add it back to see if that works without error.
        s.children.append(source)
        cp = source.children[0].children[-1]
        cp.implicit_plane.widget.enabled = False

        self.check()

        # Now deepcopy the source and replace the existing one with
        # the copy.  This basically simulates cutting/copying the
        # object from the UI via the right-click menu on the tree
        # view, and pasting the copy back.
        source1 = copy.deepcopy(source)
        s.children[0] = source1
        cp = source1.children[0].children[-1]
        cp.implicit_plane.widget.enabled = False
        self.check()

    def test_add_child(self):
        """Test if adding a source as a child works correctly."""
        src = self.e.scenes[0].children[0]
        new_src = VTKDataSource(data=tvtk.PolyData())
        src.add_child(new_src)

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_vtk_xml_reader
# Author: Suyog Dutt Jain <suyog.jain@aero.iitb.ac.in>
#         Prabhu Ramachandran <prabhu_r@users.sf.net>
# Copyright (c) 2008,  Enthought, Inc.
# License: BSD Style.

# Standard library imports.
from os.path import abspath
from StringIO import StringIO
import copy
import unittest

import numpy

# Local imports.
from common import get_example_data

# Enthought library imports
from mayavi.core.null_engine import NullEngine
from mayavi.sources.vtk_xml_file_reader import VTKXMLFileReader
from mayavi.modules.outline import Outline
from mayavi.modules.contour_grid_plane import ContourGridPlane
from mayavi.modules.scalar_cut_plane import ScalarCutPlane

class TestVTKXMLReader(unittest.TestCase):

    def setUp(self):

        e = NullEngine()
        # Uncomment to see visualization for debugging etc.
        #e = Engine()
        e.start()
        e.new_scene()
        self.e=e

        # Read a VTK XML data file.
        r = VTKXMLFileReader()
        r.initialize(get_example_data('cube.vti'))
        e.add_source(r)

        # Create an outline for the data.
        o = Outline()
        e.add_module(o)

        # Create one ContourGridPlane normal to the 'x' axis.
        cgp1 = ContourGridPlane()
        e.add_module(cgp1)
        # Set the position to the middle of the data.
        cgp1.grid_plane.position = 1

        # Another with filled contours normal to 'y' axis.
        cgp2 = ContourGridPlane()
        cgp2.contour.filled_contours = True
        # Set the axis and position to the middle of the data.
        cgp2.grid_plane.axis = 'y'
        cgp2.grid_plane.position = 1
        e.add_module(cgp2)

        # An interactive scalar cut plane.
        cp = ScalarCutPlane()
        e.add_module(cp)
        ip = cp.implicit_plane
        ip.normal = 0,0,1
        ip.origin = 0.5, 0.5, 1.0
        # Since this is running offscreen this seems necessary.
        ip.widget.origin = 0.5, 0.5, 1.0
        ip.widget.enabled = False
        self.scene = e.current_scene
        self.cgp2=cgp2
        self.cp=cp
        return

    def tearDown(self):
        """For necessary clean up, automatically called by TestCase after the test methods have been invoked"""
        self.e.stop()
        return

    def check(self):
        """Do the actual testing."""
        scene = self.scene
        src = scene.children[0]
        mm = src.children[0]
        cgp1 = mm.children[1]
        self.assertEqual(cgp1.grid_plane.position,1)

        cgp2 = mm.children[2]
        self.assertEqual(cgp2.contour.filled_contours,True)
        self.assertEqual(cgp2.grid_plane.axis, 'y')
        self.assertEqual(cgp2.grid_plane.position,1)

        cp = mm.children[3]
        ip = cp.implicit_plane
        self.assertAlmostEqual(numpy.sum(ip.normal - (0,0,1)) , 1e-16)
        self.assertAlmostEqual(numpy.sum(ip.origin - (0.5, 0.5, 1.0)), 0.0)
        self.assertEqual(ip.widget.enabled,False)



    def test_vtk_xml_reader(self):
        "Test if the test fixture works"
        #Now test.
        self.check()

        #from mayavi.tools.show import show
        #show()

    def test_save_and_restore(self):
        """Test if saving a visualization and restoring it works."""
        engine = self.e
        scene = self.scene

        # Save visualization.
        f = StringIO()
        f.name = abspath('test.mv2') # We simulate a file.
        engine.save_visualization(f)
        f.seek(0) # So we can read this saved data.

        # Remove existing scene.

        engine.close_scene(scene)

        # Load visualization
        engine.load_visualization(f)
        self.scene = engine.current_scene

        self.check()


    def test_deepcopied(self):
        """Test if the MayaVi2 visualization can be deep-copied."""
        ############################################################
        # Test if the MayaVi2 visualization can be deep-copied.

        # Pop the source object.
        s =  self.scene
        source = s.children.pop()
        # Add it back to see if that works without error.
        s.children.append(source)
        cp = source.children[0].children[-1]
        cp.implicit_plane.widget.enabled = False

        self.check()

        # Now deepcopy the source and replace the existing one with
        # the copy.  This basically simulates cutting/copying the
        # object from the UI via the right-click menu on the tree
        # view, and pasting the copy back.
        source1 = copy.deepcopy(source)
        s.children[0] = source1
        cp = source1.children[0].children[-1]
        cp.implicit_plane.widget.enabled = False
        self.check()
        #from mayavi.tools.show import show
        #show()

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = animator
"""
Simple utility code for animations.
"""
# Author: Prabhu Ramachandran <prabhu at aerodotiitbdotacdotin>
# Copyright (c) 2009, Enthought, Inc.
# License: BSD Style.

import types
from functools import wraps
try:
    from decorator import decorator
    HAS_DECORATOR = True
except ImportError:
    HAS_DECORATOR = False

from pyface.timer.api import Timer
from traits.api import HasTraits, Button, Instance, Range
from traitsui.api import View, Group, Item


###############################################################################
# `Animator` class.
###############################################################################
class Animator(HasTraits):
    """ Convenience class to manage a timer and present a convenient
        UI.  This is based on the code in `tvtk.tools.visual`.
        Here is a simple example of using this class::

            >>> from mayavi import mlab
            >>> def anim():
            ...     f = mlab.gcf()
            ...     while 1:
            ...         f.scene.camera.azimuth(10)
            ...         f.scene.render()
            ...         yield
            ...
            >>> anim = anim()
            >>> t = Animator(500, anim.next)
            >>> t.edit_traits()

        This makes it very easy to animate your visualizations and control
        it from a simple UI.

        **Notes**

        If you want to modify the data plotted by an `mlab` function call,
        please refer to the section on: :ref:`mlab-animating-data`
    """

    ########################################
    # Traits.

    start = Button('Start Animation')
    stop = Button('Stop Animation')
    delay = Range(10, 100000, 500,
                  desc='frequency with which timer is called')

    # The internal timer we manage.
    timer = Instance(Timer)

    ######################################################################
    # User interface view

    traits_view = View(Group(Item('start'),
                             Item('stop'),
                             show_labels=False),
                       Item('_'),
                       Item(name='delay'),
                       title='Animation Controller',
                       buttons=['OK'])

    ######################################################################
    # Initialize object
    def __init__(self, millisec, callable, *args, **kwargs):
        """Constructor.

        **Parameters**

          :millisec: int specifying the delay in milliseconds
                     between calls to the callable.

          :callable: callable function to call after the specified
                     delay.

          :\*args: optional arguments to be passed to the callable.

          :\*\*kwargs: optional keyword arguments to be passed to the callable.

        """
        HasTraits.__init__(self)
        self.delay = millisec
        self.ui = None
        self.timer = Timer(millisec, callable, *args, **kwargs)

    ######################################################################
    # `Animator` protocol.
    ######################################################################
    def show(self):
        """Show the animator UI.
        """
        self.ui = self.edit_traits()

    def close(self):
        """Close the animator UI.
        """
        if self.ui is not None:
            self.ui.dispose()

    ######################################################################
    # Non-public methods, Event handlers
    def _start_fired(self):
        self.timer.Start(self.delay)

    def _stop_fired(self):
        self.timer.Stop()

    def _delay_changed(self, value):
        t = self.timer
        if t is None:
            return
        if t.IsRunning():
            t.Stop()
            t.Start(value)


###############################################################################
# Decorators.

def animate(func=None, delay=500, ui=True):
    """ A convenient decorator to animate a generator that performs an
        animation.  The `delay` parameter specifies the delay (in
        milliseconds) between calls to the decorated function. If `ui` is
        True, then a simple UI for the animator is also popped up.  The
        decorated function will return the `Animator` instance used and a
        user may call its `Stop` method to stop the animation.

        If an ordinary function is decorated a `TypeError` will be raised.

        **Parameters**

        :delay: int specifying the time interval in milliseconds between
                calls to the function.

        :ui: bool specifying if a UI controlling the animation is to be
             provided.

        **Returns**

        The decorated function returns an `Animator` instance.

        **Examples**

        Here is the example provided in the Animator class documentation::

            >>> from mayavi import mlab
            >>> @mlab.animate
            ... def anim():
            ...     f = mlab.gcf()
            ...     while 1:
            ...         f.scene.camera.azimuth(10)
            ...         f.scene.render()
            ...         yield
            ...
            >>> a = anim() # Starts the animation.

        For more specialized use you can pass arguments to the decorator::

            >>> from mayavi import mlab
            >>> @mlab.animate(delay=500, ui=False)
            ... def anim():
            ...     f = mlab.gcf()
            ...     while 1:
            ...         f.scene.camera.azimuth(10)
            ...         f.scene.render()
            ...         yield
            ...
            >>> a = anim() # Starts the animation without a UI.

        **Notes**

        If you want to modify the data plotted by an `mlab` function call,
        please refer to the section on: :ref:`mlab-animating-data`.
    """

    class Wrapper(object):
        # The wrapper which calls the decorated function.

        def __init__(self, function):
            self.func = function
            self.ui = ui
            self.delay = delay

        def __call__(self, *args, **kw):
            if isinstance(self.func, types.GeneratorType):
                f = self.func
            else:
                f = self.func(*args, **kw)
            if isinstance(f, types.GeneratorType):
                a = Animator(self.delay, f.next)
                if self.ui:
                    a.show()
                return a
            else:
                msg = 'The function "%s" must be a generator '\
                      '(use yield)!' % (self.func.__name__)
                raise TypeError(msg)

        def decorator_call(self, func, *args, **kw):
            return self(*args, **kw)


    def _wrapper(function):
        # Needed to create the Wrapper in the right scope.
        if HAS_DECORATOR:
            # The decorator calls a callable with (func, *args, **kw) signature
            return decorator(Wrapper(function).decorator_call, function)
        else:
            return wraps(function)(Wrapper(function))

    if func is None:
        return _wrapper
    else:
        return _wrapper(func)

########NEW FILE########
__FILENAME__ = auto_doc
"""
Automatic documentation from traited objects.
"""

# Author: Gael Varoquaux <gael.varoquaux@normalesup.org>
# Copyright (c) 2007, Enthought, Inc.
# License: BSD Style.

from textwrap import wrap, dedent
import types

old_dedent = dedent


def dedent(text):
    """ Removes as much indentation as possible from some text, but does
    not modify the first line.
    """
    text_lines = [line.rstrip() for line in text.split("\n")]
    if len(text_lines) > 0:
        return text_lines[0] + "\n" + old_dedent(
                                            "\n".join(text_lines[1:]))
    else:
        return text


def make_doc(klass):
    """ Builds a docstring from the object's docstring, and it's traits
    help.
    """
    if hasattr(klass, '__doc__'):
        doc = dedent(klass.__doc__) + "\n"
    else:
        doc = ""
    doc += dedent("""**Keyword arguments:**""")
    traits = klass.class_traits().copy()
    traits.pop('trait_added')
    traits.pop('trait_modified')
    doc += traits_doc(traits)
    return doc


def traits_doc(traits):
    doc = ""
    traits_names = traits.keys()
    traits_names.sort()
    for trait_name in traits_names:
        trait_obj = traits[trait_name]
        if not trait_name[0] == '_':
            doc += format_argument(trait_name, trait_obj)
    return doc


def format_argument(trait_name, trait_obj):
    doc = "\n    :%s: " % trait_name
    pad = "\n" + (len(doc) - 1) * " "
    help = trait_obj.help
    if help is not None:
        arg_desc = help
    else:
        arg_desc = ''
        desc = trait_obj.desc
        if desc is not None:
            arg_desc += desc.rstrip()
        handler = trait_obj.handler
        if handler is not None:
            if (not hasattr(handler, 'aType') or
                        not handler.aType in (types.IntType, types.FloatType)):
                # These types are simple enough
                arg_desc += ' Must be %s.' % handler.info()
        default = trait_obj.default_value()[1]
        if not default in ('', None) and not trait_obj.array:
            arg_desc = arg_desc.rstrip() + " Default: %s" % str(default)
    desc_width = 75 - len(doc)
    for line in wrap(arg_desc, width=desc_width):
        doc += line
        doc += pad
    return doc

########NEW FILE########
__FILENAME__ = camera
"""
Controlling the camera.
"""

# Author: Gael Varoquaux and Prabhu Ramachandran
# Copyright (c) 2007-2008, Enthought, Inc.
# License: BSD Style.

# Standard library imports.
import warnings

try:
    import numpy as np
except ImportError, m:
    msg = '''%s\n%s\nPlease check your numpy installation. If you need numpy,
'easy_install numpy' will install it.
http://numpy.scipy.org
        ''' % (m, '_' * 80)
    raise ImportError(msg)

from numpy import pi

# We can't use gcf, as it creates a circular import in camera management
# routines.
from engine_manager import get_engine


def world_to_display(x, y, z, figure=None):
    """ Converts 3D world coordinates to screenshot pixel coordinates.

        **Parameters**

        :x: float
            World x coordinate
        :y: float
            World y coordinate
        :z: float
            World z coordinate
        :figure: Mayavi figure or None
            The figure to use for the conversion. If None, the
            current one is used.

        **Output**
        :x: float
            Screenshot x coordinate
        :y: float
            Screenshot y coordinate
    """
    if figure is None:
        f = get_engine().current_scene
    else:
        f = figure
    if f is None or f.scene is None:
        return 0, 0

    f.scene._renderer.world_point = [x, y, z, 1]
    f.scene._renderer.world_to_display()
    x, y, _ = f.scene._renderer.display_point
    return x, y


def roll(roll=None, figure=None):
    """ Sets or returns the absolute roll angle of the camera.

    **See also**

    :mlab.view: control the position and direction of the camera
    """
    if figure is None:
        f = get_engine().current_scene
    else:
        f = figure
    if f is None:
        return
    scene = f.scene
    if scene is None:
        return
    cam = scene.camera

    if roll is not None:
        cam.set_roll(roll)
        if not scene.disable_render:
            scene.render()
    return cam.get_roll()


# This is needed for usage inside the view function, where roll is a
# local variable
_roll = roll


def rad2deg(rad):
    """Converts radians to degrees."""
    return rad * 180. / pi


def deg2rad(deg):
    """Converts degrees to radians."""
    return deg * pi / 180.


def get_camera_direction(cam):
    """ Return the polar coordinates for the camera position:
        r, theta, phi, as well as the focal point.
    """
    fp = cam.focal_point
    pos = cam.position
    x, y, z = pos - fp
    r = np.sqrt(x * x + y * y + z * z)
    theta = np.arccos(z / r)
    phi = np.arctan2(y, x)
    return r, theta, phi, fp


def get_outline_bounds(figure=None):
    """ Return the pixel bounds of the objects visible on the figure.
    """
    if figure is None:
        f = get_engine().current_scene
    else:
        f = figure
    if f is None:
        return
    scene = f.scene
    if scene is None:
        return 1, 1, 1, 1

    # Lazy import, to avoid circular imports
    from figure import screenshot
    red, green, blue = scene.background

    # Use mode='rgba' to have float values, as with fig.scene.background
    outline = screenshot(mode='rgba')
    outline = ((outline[..., 0] != red)
                + (outline[..., 1] != green)
                + (outline[..., 2] != blue)
                )
    outline_x = outline.sum(axis=0)
    outline_y = outline.sum(axis=1)
    height, width = outline.shape
    width = float(width)
    height = float(height)

    outline_x = np.where(outline_x)[0]
    outline_y = np.where(outline_y)[0]

    if len(outline_x) == 0:
        x_min = x_max = .5 * width
    else:
        x_min = outline_x.min()
        x_max = outline_x.max()
    if len(outline_y) == 0:
        y_min = y_max = .5 * height
    else:
        y_min = outline_y.min()
        y_max = outline_y.max()
    return x_min, x_max, y_min, y_max, width, height


def view(azimuth=None, elevation=None, distance=None, focalpoint=None,
            roll=None, reset_roll=True, figure=None):
    """ Sets/Gets the view point for the camera::

     view(azimuth=None, elevation=None, distance=None, focalpoint=None,
          roll=None, reset_roll=True, figure=None)

    If called with no arguments this returns the current view of the
    camera.  To understand how this function works imagine the surface
    of a sphere centered around the visualization.  The `azimuth`
    argument specifies the angle "phi" on the x-y plane which varies
    from 0-360 degrees.  The `elevation` argument specifies the angle
    "theta" from the z axis and varies from 0-180 degrees.  The
    `distance` argument is the radius of the sphere and the
    `focalpoint`, the center of the sphere.

    Note that if the `elevation` is close to zero or 180, then the
    `azimuth` angle refers to the amount of rotation of a standard x-y
    plot with respect to the x-axis.  Thus, specifying ``view(0,0)``
    will give you a typical x-y plot with x varying from left to right
    and y from bottom to top.

    **Keyword arguments**:

     :azimuth: float, optional. The azimuthal angle (in degrees, 0-360),
        i.e. the angle subtended by the position vector on a sphere
        projected on to the x-y plane with the x-axis.

     :elevation: float, optional. The zenith angle (in degrees, 0-180),
        i.e. the angle subtended by the position vector and the z-axis.

     :distance: float or 'auto', optional.
        A positive floating point number representing the distance from
        the focal point to place the camera. New in Mayavi 3.4.0: if
        'auto' is passed, the distance is computed to have a best fit of
        objects in the frame.

     :focalpoint: array_like or 'auto', optional.
        An array of 3 floating point numbers representing the focal point
        of the camera. New in Mayavi 3.4.0: if 'auto' is passed, the
        focal point is positioned at the center of all objects in the
        scene.

     :roll: float, optional
        Controls the roll, ie the rotation of the camera around its axis.

     :reset_roll: boolean, optional.
        If True, and 'roll' is not specified, the roll orientation of the
        camera is reset.

     :figure: The Mayavi figure to operate on. If None is passed, the
        current one is used.

    **Returns**:

    If no arguments are supplied it returns a tuple of 4 values
    ``(azimuth, elevation, distance, focalpoint)``, representing the
    current view.  Note that these can be used later on to set the view.

    If arguments are supplied it returns `None`.

    **Examples**:

    Get the current view::

      >>> v = view()
      >>> v
     (45.0, 45.0, 25.02794981, array([ 0.01118028,  0.        ,  4.00558996]))

    Set the view in different ways::

      >>> view(45, 45)
      >>> view(240, 120)
      >>> view(distance=20)
      >>> view(focalpoint=(0,0,9))

    Set the view to that saved in `v` above::

      >>> view(*v)

    **See also**

    :mlab.roll: control the roll angle of the camera, ie the direction
               pointing up
    """
    if figure is None:
        f = get_engine().current_scene
    else:
        f = figure
    if f is None:
        return
    scene = f.scene
    if scene is None:
        return

    ren = scene.renderer
    cam = scene.camera
    cos = np.cos
    sin = np.sin

    # First compute the current state of the camera.
    r, theta, phi, fp = get_camera_direction(cam)

    # If no arguments were specified, just return the current view.
    if azimuth is None and elevation is None and distance is None \
            and focalpoint is None and roll is None:
        return rad2deg(phi), rad2deg(theta), r, fp

    # Convert radians to
    if azimuth is None:
        azimuth = rad2deg(phi)
    else:
        phi = deg2rad(azimuth)
    if elevation is None:
        elevation = rad2deg(theta)
    else:
        theta = deg2rad(elevation)

    # We compute the position of the camera on the surface of a sphere
    # centered at the center of the bounds, with radius chosen from the
    # bounds.
    bounds = np.array(ren.compute_visible_prop_bounds())
    if distance is not None and not distance == 'auto':
        r = distance
    else:
        r = max(bounds[1::2] - bounds[::2]) * 2.0

    cen = (bounds[1::2] + bounds[::2]) * 0.5
    if focalpoint is not None and not focalpoint == 'auto':
        cen = np.asarray(focalpoint)

    # Find camera position.
    x = r * cos(phi) * sin(theta)
    y = r * sin(phi) * sin(theta)
    z = r * cos(theta)

    # Now setup the view.
    cam.focal_point = cen
    cam.position = cen + [x, y, z]
    cam.compute_view_plane_normal()
    ren.reset_camera_clipping_range()

    if roll is not None:
        print "setting roll"
        _roll(roll)
    elif reset_roll:
        # Now calculate the view_up vector of the camera.  If the view up is
        # close to the 'z' axis, the view plane normal is parallel to the
        # camera which is unacceptable, so we use a different view up.
        view_up = [0, 0, 1]
        if abs(elevation) < 5. or abs(elevation) > 175.:
            view_up = [sin(phi), cos(phi), 0]
        cam.view_up = view_up

    if distance == 'auto':
        # Reset the zoom, to have the full extents:
        scene.reset_zoom()
        x_min, x_max, y_min, y_max, w, h = get_outline_bounds(figure=figure)
        x_focus, y_focus = world_to_display(cen[0], cen[1], cen[2],
                                            figure=figure)

        ratio = 1.1 * max((x_focus - x_min) / x_focus,
                        (x_max - x_focus) / (w - x_focus),
                        (y_focus - y_min) / y_focus,
                        (y_max - y_focus) / (h - y_focus),
                       )

        distance = get_camera_direction(cam)[0]
        r = distance * ratio
        # Reset the camera position.
        x = r * cos(phi) * sin(theta)
        y = r * sin(phi) * sin(theta)
        z = r * cos(theta)

        # Now setup the view.
        cam.position = cen + [x, y, z]
        cam.compute_view_plane_normal()
        ren.reset_camera_clipping_range()

    if not scene.disable_render:
        scene.render()
    return rad2deg(phi), rad2deg(theta), r, fp


def move(forward=None, right=None, up=None):
    """ Translates the camera and focal point together.

    The arguments specify the relative distance to translate the
    camera and focal point, so as to produce the appearence of
    moving the camera without changing the effective field of view.
    If called with no arguments, the function returns the absolute
    position of the camera and focal pointon a cartesian coordinate
    system.

    Note that the arguments specify relative motion, although the
    return value with no arguments is in an absolute coordinate system.


    **Keyword arguments**:

     :forward: float, optional. The distance in space to translate the
         camera forward (if positive) or backward (if negative)


     :right: float, optional.  The distance in space to translate the
         camera to the right (if positive) or left (if negative)

     :up: float, optional. The distance in space to translate the
         camera up (if positive) or down (if negative)


    **Returns**:

    If no arguments are supplied (or all are None), returns a
    tuple (camera_position, focal_point_position)

    otherwise, returns None

    **Examples**:

    Get the current camera position::

      >>> cam,foc = move()
      >>> cam
      array([-0.06317079, -0.52849738, -1.68316389])
      >>> foc
      array([ 1.25909623,  0.15692708, -0.37576693])

    Translate the camera::

      >>> move(3,-1,-1.2)
      >>> move()
      (array([ 2.93682921, -1.52849738, -2.88316389]),
       array([ 4.25909623, -0.84307292, -1.57576693]))

    Return to the starting position::
     >>> move(-3,1,1.2)
     >>> move()
     (array([-0.06317079, -0.52849738, -1.68316389]),
      array([ 1.25909623,  0.15692708, -0.37576693]))


    **See also**
    :mlab.yaw: yaw the camera (tilt left-right)
    :mlab.pitch: pitch the camera (tilt up-down)
    :mlab.roll: control the absolute roll angle of the camera
    :mlab.view: set the camera position relative to the focal point instead
                of in absolute space
    """

    f = get_engine().current_scene
    if f is None:
        return
    scene = f.scene
    if scene is None:
        return

    ren = scene.renderer
    cam = scene.camera

    if forward is None and right is None and up is None:
        return cam.position, cam.focal_point

    # vector to offset the camera loc and focal point
    v = np.zeros(3)

    # view plane vetor points behind viewing direction, so we invert it
    yhat = -1 * cam.view_plane_normal
    zhat = cam.view_up

    if forward is not None:
        xhat = np.cross(yhat, zhat)
        v += forward * yhat

    if right is not None:
        v += right * xhat

    if up is not None:
        v += up * zhat

    # Apply the offset and setup the view.
    cam.position = cam.position + v
    cam.focal_point = cam.focal_point + v
    ren.reset_camera_clipping_range()
    scene.render()


def yaw(degrees):
    """ Rotates the camera about the  axis corresponding to the
    "up" direction of the current view. Note that this will
    change the location of the focal point (although not the
    camera location).

    This angle is relative to the current direction - the
    angle is NOT an absolute angle in a fixed coordinate
    system.

    **See also**

    :mlab.pitch: relative rotation about the "right" direction
    :mlab.roll: absolute roll angle (i.e. "up" direction)
    :mlab.move: relative translation of the camera and focal
                point
    """

    f = get_engine().current_scene
    if f is None:
        return
    scene = f.scene
    if scene is None:
        return

    ren = scene.renderer
    cam = scene.camera

    cam.yaw(degrees)

    ren.reset_camera_clipping_range()
    scene.render()


def pitch(degrees):
    """ Rotates the camera about the  axis corresponding to the
    "right" direction of the current view. Note that this will
    change the location of the focal point (although not the
    camera location).

    This angle is relative to the current direction - the
    angle is NOT an absolute angle in a fixed coordinate
    system.

    **See also**

    :mlab.yaw: relative rotation about the "up" direction
    :mlab.roll: absolute roll angle (i.e. "up" direction)
    :mlab.move: relative  translation of the camera and focal
                point
    """

    f = get_engine().current_scene
    if f is None:
        return
    scene = f.scene
    if scene is None:
        return

    ren = scene.renderer
    cam = scene.camera

    cam.pitch(degrees)

    ren.reset_camera_clipping_range()
    scene.render()

########NEW FILE########
__FILENAME__ = csv_loader
# Author: Ilan Schnell <ischnell@enthought.com>
# Copyright (c) 2008, Enthought, Inc.
# License: BSD Style.


from traits.api import HasTraits, Str, Int, Array, List, \
    Instance, on_trait_change, Property, Button

from pyface.api import GUI

from traitsui.api import View, Item, HGroup, Group, \
    ListEditor, TabularEditor, spring, TextEditor, Controller, VSplit

from traitsui.tabular_adapter import TabularAdapter

from mayavi.tools.data_wizards.csv_sniff import Sniff, loadtxt, \
        array2dict


##############################################################################
# ListItem class
##############################################################################
class ListItem(HasTraits):
    """ Class used to represent an item in a list with traits UI.
    """
    column_number = Int
    name = Str
    my_name = Str
    parent = Instance(HasTraits)
    view = View(
               HGroup(
                   Item('name', style='readonly', show_label=False,
                                    resizable=False),
                   Item('my_name', style='simple', show_label=False,
                            editor=TextEditor(auto_set=False, enter_set=True),
                                    springy=True),
               )
           )


##############################################################################
# CSVLoader class
##############################################################################
class CSVLoader(HasTraits):
    """ User interface to load CSV files.
    """

    # The name of the file being loaded.
    filename = Str

    # The comment characters
    comments = Str(desc="The comment characters")

    # The character giving the delimiter between the columns.
    delimiter = Str(
        desc="The character giving the delimiter between the columns")

    # The number of rows to skip at the beginning of the file
    skiprows = Int(
        desc="The number of rows to skip at the beginning of the file")

    columns = List(ListItem)

    data = Array

    data_dict = Property(depends_on='data')

    def _get_data_dict(self):
        return array2dict(self.data)

    def guess_defaults(self):
        try:
            kwds = Sniff(self.filename).kwds()
        except:
            kwds = {'comments': '#',
                    'delimiter': ',',
                    'dtype': float,
                    'skiprows': 0}

        if kwds['delimiter']:
            self.delimiter = kwds['delimiter']
        else:
            self.delimiter = ' '
        self.comments = kwds['comments']
        self.skiprows = kwds['skiprows']
        self.names = list(kwds['dtype']['names'])
        self.formats = list(kwds['dtype']['formats'])

        self.columns = [ListItem(name='Column %i:' % (i + 1),
                                 parent=self,
                                 column_number=i,
                                 my_name=val)
                        for i, val in enumerate(self.names)]
        self.load_data()

    def load_data(self):
        kwds = {}
        kwds['delimiter'] = self.delimiter
        kwds['comments'] = self.comments
        kwds['skiprows'] = self.skiprows
        kwds['dtype'] = dict(names=self.names,
                             formats=self.formats)

        try:
            self.data = loadtxt(self.filename, **kwds)
        except:
            pass


##############################################################################
# CSVLoaderController class
##############################################################################
class CSVLoaderController(Controller):
    """ A controller for the CSVLoader.
    """

    tabular_editor = Instance(HasTraits)

    def _tabular_editor_default(self):
        class ArrayAdapter(TabularAdapter):
            columns = [(n, i) for i, n in enumerate(self.model.names)]
            font = 'Courier 10'
            alignment = 'right'
            format = '%s'

        return TabularEditor(adapter=ArrayAdapter())

    update_preview = Button('Update preview')

    @on_trait_change('update_preview')
    def load_data(self):
        self.model.load_data()

    @on_trait_change('model.columns.my_name,model.data')
    def update_table_editor(self, object, name, old, new):
        if isinstance(object, ListItem):
            self.tabular_editor.adapter.columns[object.column_number] = \
                                (new, object.column_number)
            GUI.set_trait_later(self.info.ui, 'updated', True)

    file_content = Str

    @on_trait_change('model.filename')
    def update_file(self):
        f = open(self.model.filename)
        self.file_content = f.read(300)

    def default_traits_view(self):
        view = View(
                VSplit(
                   HGroup(
                       Group(
                           spring,
                           Item('delimiter',
                                label='Column delimiter character'),
                           Item('comments',
                                label='Comment character'),
                           Item('skiprows',
                                label='Number of lines to skip at the '
                                'beginning of the file'),
                           spring,
                           Item('handler.update_preview',
                                                show_label=False),
                       ),
                       Group(
                           Item('columns',
                               show_label=False,
                               style='readonly',
                               editor=ListEditor(style='custom'),
                               springy=True,
                           ),
                           label="Column names",
                           show_border=True,
                       ),
                   ),
                   Group(
                       Group(
                        Item('data',
                            show_label=False,
                            editor=self.tabular_editor,
                            ),
                        label="Preview table",
                        ),
                        Group(
                        Item('handler.file_content', style='readonly',
                                show_label=False,
                                springy=True),
                        label="%s" % self.model.filename,
                        ),
                    layout='tab'),
               ),
               buttons=['OK', 'Cancel', 'Help'],
               id='csv_load_editor',
               resizable=True,
               width=640,
               height=580,
               title='CSV import - [%s]' % self.model.filename
           )
        return view

if __name__ == '__main__':
    from pyface.api import GUI
    csv_loader = CSVLoader(filename='mydata.csv')
    csv_loader.guess_defaults()
    controller = CSVLoaderController(model=csv_loader)
    controller.edit_traits()
    GUI().start_event_loop()

########NEW FILE########
__FILENAME__ = csv_sniff
# Author: Ilan Schnell <ischnell@enthought.com>
# Copyright (c) 2008, Enthought, Inc.
# License: BSD Style.

# TODO: should derive from HasTraits

import csv

# FIXME: see loadtxt.py (should really be the loadtxt from numpy)
from mayavi.tools.data_wizards.loadtxt import loadtxt


class Sniff(object):
    """ Sniff a CSV file and determine some of it's properties.

        The properties determined here allow an CSV of unknown format
        to be read by numpy.loadtxt, i.e. the methods and attributes
        are suitable to determine required keyword arguments for
        numpy.loadtxt

        Example::

            s = Sniff('mydata.csv')
            print repr(s.delimiter())     # ','
            print s.skiprows()            # 2
            a = s.loadtxt()               # a is now the array

            from numpy import loadtxt     # make sure it's numpy 1.1.0 or
                                          # higher
            b = loadtxt('mydata.csv', **s.kwds())
    """
    def __init__(self, filename):
        self._filename = filename
        self._lines = self._read_few_lines()
        self._reallines = [line for line in self._lines if line.strip()]
        self._dialect = csv.Sniffer().sniff(self._reallines[-1])
        self._get_comment()

        if self._dialect.delimiter.isalnum():
            self._usePySplit = True
            self._numcols = 1
        else:
            self._usePySplit = not self._dialect.delimiter.strip()
            self._numcols = len(self._split(self._reallines[-1]))

        self._datatypes = self._datatypes_of_line(self._reallines[-1])

    def _get_comment(self):
        self._comment = '#'
        line0 = self._reallines[0]
        if line0.startswith('#') or line0.startswith('%'):
            self._comment = line0[0]
            self._reallines[0] = self._dialect.delimiter.join(
                                        line0.split()[1:])
            for i in xrange(1, len(self._reallines)):
                self._reallines[i] = \
                    self._reallines[i].split(self._comment)[0]

    def _read_few_lines(self):
        res = []
        f = open(self._filename, 'rb')
        for line in f:
            line = line.strip()
            res.append(line)
            if len(res) > 20:
                break
        f.close()
        return res

    def _split(self, line):
        if self._usePySplit:
            return line.split()
        else:
            return csv.reader([line], self._dialect).next()

    def _names(self):
        if self._datatypes != self._numcols * (str,):
            for line in self._reallines:
                if len(self._split(line)) != self._numcols:
                    continue
                if self._datatypes_of_line(line) != self._numcols * (str,):
                    continue
                return tuple(t.strip('"\' \t') for t in self._split(line))

        return tuple('Column %i' % (i + 1) for i in xrange(self._numcols))

    def _formats(self):
        res = []
        for c, t in enumerate(self._datatypes):
            if t == str:
                items = [len(self._split(l)[c]) for l in self._reallines[1:]
                         if self._datatypes_of_line(l) == self._datatypes]
                items.append(1)
                res.append('S%i' % max(items))

            elif t == float:
                res.append(t)

            else:
                raise TypeError("Hmm, did not expect: %r" % t)

        return tuple(res)

    def _datatypes_of_line(self, line):

        def isFloat(s):
            try:
                float(s)
                return True
            except ValueError:
                return False

        res = []
        for s in self._split(line):
            if isFloat(s):
                res.append(float)
            else:
                res.append(str)

        return tuple(res)

    def _debug(self):
        print '===== Sniffed information for file %r:' % self._filename
        print 'delimiter = %r' % self.delimiter()
        print 'comments  = %r' % self.comments()
        print 'dtype     = %r' % self.dtype()
        print 'skiprows  = %r' % self.skiprows()

    #-----------------------------------------------------------------------
    # Public API:
    #-----------------------------------------------------------------------

    def comments(self):
        """ Return the character used for comments (usually '#').
        """
        return self._comment

    def delimiter(self):
        """ Return the delimiter string.
            When whitespace is used as the delimiter, None is returned.
        """
        if self._usePySplit:
            return None
        else:
            return self._dialect.delimiter

    def skiprows(self):
        """ The number (int) of rows from the top to skip.
        """
        for n, line in enumerate(self._lines):
            if self._datatypes == self._datatypes_of_line(line):
                return n
        return 0

    def dtype(self):
        """ Return a dict suitable to be used as the dtype keyword
            argument of loadtxt.
        """
        return {'names': self._names(),
                'formats': self._formats()}

    def kwds(self):
        """ Return a dict of the keyword argument needed by numpy.loadtxt
        """
        return {'comments': self.comments(),
                'delimiter': self.delimiter(),
                'skiprows': self.skiprows(),
                'dtype': self.dtype()}

    def loadtxt(self):
        """ Return the array (by using numpy.loadtxt), using the sniffed
            information in the keyword arguments.
        """
        return loadtxt(self._filename, **self.kwds())


def loadtxt_unknown(filename, verbose=0):
    """ Like numpy.loadtxt but more general, in the sense that it uses
        Sniff first to determine the necessary keyword arguments for loadtxt.
    """
    s = Sniff(filename)

    if verbose:
        s._debug()

    return s.loadtxt()


def array2dict(arr):
    """ Takes an array with special names dtypes and returns a dict where
        each name is a key and the corresponding data (as a 1d array) is the
        value.
    """
    res = {}
    for k in arr.dtype.names:
        res[k] = arr[k]

    return res

########NEW FILE########
__FILENAME__ = csv_source_factory
"""
Factory used by mayavi to import csv-like files into datasets.
"""

# Author: Gael Varoquaux <gael.varoquaux@normalesup.org>
# Copyright (c) 2008, Enthought, Inc.
# License: BSD Style.

from traits.api import HasTraits, Callable
from traitsui.api import Handler

from mayavi.tools.data_wizards.data_source_wizard import \
        DataSourceWizardView
from mayavi.tools.data_wizards.csv_loader import \
        CSVLoader, CSVLoaderController


class CallbackCSVLoader(CSVLoaderController):
    """ Simple handler for a TraitsUI view to call a given callback on
        exit.
    """

    # A callable called when the TraitsUI view is closed. The instance
    # that the view was editing is passed to this callable.
    callback = Callable()

    def closed(self, info, is_ok):
        print "CallbackHander"
        if is_ok:
            self.callback(self.model)


class CSVSourceFactory(HasTraits):
    """ Functor to load a CSV-like data from a file.
    """

    def csv_loaded_callback(self, object):
        """
        """
        self.data_source_wizard = DataSourceWizardView(
                data_sources=self.csv_loader.data_dict)
        self.data_source_wizard.edit_traits()

    def __call__(self, fname):
        """ Pops up the dialogs required for the import of the
            CSV to happen.
        """
        self.csv_loader = CSVLoader(filename=fname)
        self.csv_loader.guess_defaults()
        controller = CallbackCSVLoader(model=self.csv_loader,
                        callback=self.csv_loaded_callback)
        controller.edit_traits()

if __name__ == '__main__':
    from pyface.api import GUI
    source_factory = CSVSourceFactory()
    source_factory('mydata.csv')
    GUI().start_event_loop()

########NEW FILE########
__FILENAME__ = data_source_factory

from numpy import c_, zeros, arange

from traits.api import HasStrictTraits, \
    true, false, CArray, Trait, Instance

from mayavi.sources.vtk_data_source import VTKDataSource
from mayavi.sources.array_source import ArraySource
from mayavi.core.source import Source

from tvtk.api import tvtk

ArrayOrNone = Trait(None, (None, CArray))


############################################################################
# The DataSourceFactory class
############################################################################
class DataSourceFactory(HasStrictTraits):
    """ Factory for creating data sources. The information about the
        organisation of the data is given by setting the public traits.
    """

    # Whether the position is implicitely inferred from the array indices
    position_implicit = false

    # Whether the data is on an orthogonal grid
    orthogonal_grid = false

    # If the data is unstructured
    unstructured = false

    # If the factory should attempt to connect the data points
    connected = true

    # The position of the data points
    position_x = ArrayOrNone
    position_y = ArrayOrNone
    position_z = ArrayOrNone

    # Connectivity array. If none, it is implicitely inferred from the array
    # indices
    connectivity_triangles = ArrayOrNone

    # Whether or not the data points should be connected.
    lines = false

    # The scalar data array
    scalar_data = ArrayOrNone

    # Whether there is vector data
    has_vector_data = false

    # The vector components
    vector_u = ArrayOrNone
    vector_v = ArrayOrNone
    vector_w = ArrayOrNone

    #----------------------------------------------------------------------
    # Private traits
    #----------------------------------------------------------------------
    _vtk_source = Instance(tvtk.DataSet)

    _mayavi_source = Instance(Source)

    #----------------------------------------------------------------------
    # Private interface
    #----------------------------------------------------------------------

    def _add_scalar_data(self):
        """ Adds the scalar data to the vtk source.
        """
        if self.scalar_data is not None:
            scalars = self.scalar_data.ravel()
            self._vtk_source.point_data.scalars = scalars

    def _add_vector_data(self):
        """ Adds the vector data to the vtk source.
        """
        if self.has_vector_data:
            vectors = c_[self.vector_u.ravel(),
                         self.vector_v.ravel(),
                         self.vector_w.ravel(),
                        ]
            self._vtk_source.point_data.vectors = vectors

    def _mk_polydata(self):
        """ Creates a PolyData vtk data set using the factory's
            attributes.
        """
        points = c_[self.position_x.ravel(),
                    self.position_y.ravel(),
                    self.position_z.ravel(),
                   ]
        lines = None
        if self.lines:
            np = len(points) - 1
            lines = zeros((np, 2), 'l')
            lines[:, 0] = arange(0, np - 0.5, 1, 'l')
            lines[:, 1] = arange(1, np + 0.5, 1, 'l')
        self._vtk_source = tvtk.PolyData(points=points, lines=lines)
        if (self.connectivity_triangles is not None and
                        self.connected):
            assert self.connectivity_triangles.shape[1] == 3, \
                    "The connectivity list must be Nx3."
            self._vtk_source.polys = self.connectivity_triangles
        self._mayavi_source = VTKDataSource(data=self._vtk_source)

    def _mk_image_data(self):
        """ Creates an ImageData VTK data set and the associated ArraySource
            using the factory's attributes.
        """
        self._mayavi_source = ArraySource(transpose_input_array=True,
                                          scalar_data=self.scalar_data,
                                          origin=[0., 0., 0],
                                          spacing=[1, 1, 1])
        self._vtk_source = self._mayavi_source.image_data

    def _mk_rectilinear_grid(self):
        """ Creates a RectilinearGrid VTK data set using the factory's
            attributes.
        """
        rg = tvtk.RectilinearGrid()
        x = self.position_x.squeeze()
        if x.ndim == 3:
            x = x[:, 0, 0]
        y = self.position_y.squeeze()
        if y.ndim == 3:
            y = y[0, :, 0]
        z = self.position_z.squeeze()
        if z.ndim == 3:
            z = z[0, 0, :]
        # FIXME: We should check array size here.
        rg.dimensions = (x.size, y.size, z.size)
        rg.x_coordinates = x
        rg.y_coordinates = y
        rg.z_coordinates = z
        self._vtk_source = rg
        self._mayavi_source = VTKDataSource(data=self._vtk_source)

    def _mk_structured_grid(self):
        """ Creates a StructuredGrid VTK data set using the factory's
            attributes.
        """
        # FIXME: We need to figure out the dimensions of the data
        # here, if any.
        sg = tvtk.StructuredGrid(dimensions=self.scalar_data.shape)
        sg.points = c_[self.position_x.ravel(),
                       self.position_y.ravel(),
                       self.position_z.ravel(),
                      ]
        self._vtk_source = sg
        self._mayavi_source = VTKDataSource(data=self._vtk_source)

    #----------------------------------------------------------------------
    # Public interface
    #----------------------------------------------------------------------

    def build_data_source(self, **traits):
        """ Uses all the information given by the user on his data
            structure to figure out the right data structure.
        """
        self.set(**traits)
        if not self.lines:
            if self.position_implicit:
                self._mk_image_data()
            elif self.orthogonal_grid:
                self._mk_rectilinear_grid()
            elif self.connectivity_triangles is None:
                if self.unstructured:
                    self._mk_polydata()
                else:
                    self._mk_structured_grid()
            else:
                self._mk_polydata()
        else:
            self._mk_polydata()
        self._add_scalar_data()
        self._add_vector_data()
        return self._mayavi_source


def view(src):
    """ Open up a mayavi scene and display the dataset in it.
    """
    from mayavi import mlab
    mayavi = mlab.get_engine()
    fig = mlab.figure(bgcolor=(1, 1, 1), fgcolor=(0, 0, 0),)
    mayavi.add_source(src)

    mlab.pipeline.surface(src, opacity=0.1)
    mlab.pipeline.surface(mlab.pipeline.extract_edges(src),
                            color=(0, 0, 0), )


def test_image_data():
    from numpy import random
    scalars = random.random((3, 3, 3))
    factory = DataSourceFactory()
    image_data = factory.build_data_source(scalar_data=scalars,
                                       position_implicit=True,)
    view(image_data)


def test_rectilinear_grid():
    from numpy import random, mgrid
    factory = DataSourceFactory()

    scalars = random.random((3, 3, 3))
    x = arange(3) ** 2
    y = 0.5 * arange(3) ** 2
    z = arange(3) ** 2

    rectilinear_grid = factory.build_data_source(scalar_data=scalars,
                                       position_implicit=False,
                                       orthogonal_grid=True,
                                       position_x=x,
                                       position_y=y,
                                       position_z=z)
    view(rectilinear_grid)


def test_structured_grid():
    from numpy import random, mgrid
    factory = DataSourceFactory()

    scalars = random.random((3, 3, 3))
    x, y, z = mgrid[0:3, 0:3, 0:3]
    x = x + 0.5 * random.random(x.shape)
    y = y + 0.5 * random.random(y.shape)
    z = z + 0.5 * random.random(z.shape)

    structured_grid = factory.build_data_source(scalar_data=scalars,
                                       position_x=x,
                                       position_y=y,
                                       position_z=z)
    view(structured_grid)


if __name__ == '__main__':
    from pyface.api import GUI
    test_image_data()
    test_rectilinear_grid()
    test_structured_grid()
    GUI().start_event_loop()

########NEW FILE########
__FILENAME__ = data_source_wizard

from numpy import ones, resize, linspace, atleast_3d

from traits.api import Property, Str, Button, Trait, \
    Any, Instance, HasStrictTraits, false, Dict, HasTraits, \
    CArray, Bool
from traitsui.api import EnumEditor, View, Item, HGroup, \
    VGroup, spring, Group, TextEditor, HTMLEditor, InstanceEditor, \
    TabularEditor, TitleEditor, Label, ArrayEditor, ImageEditor

from traitsui.tabular_adapter import TabularAdapter
from traitsui.image.image import ImageLibrary

from pyface.api import ImageResource

from data_source_factory import DataSourceFactory
from preview_window import PreviewWindow
from mayavi.modules.api import Surface, Glyph
from mayavi.filters.api import ExtractEdges


############################################################################
# The DataSourceWizard class
############################################################################
class DataSourceWizard(HasTraits):

    data_sources = Dict

    _data_sources_names = Property(depends_on='data_sources')

    def _get__data_sources_names(self):
        names = []
        for name in self.data_sources:
            try:
                self.data_sources[name] + 1
                names.append(name)
            except TypeError:
                pass
        names.sort()
        return names

    # Dictionnary mapping the views
    data_type = Trait('point',
            {'A surface':
                    'surface',
            'A set of points, that can be connected by lines':
                    'point',
            'A set of vectors':
                    'vector',
            'Volumetric data':
                    'volumetric',
            })

    position_type = Trait('image data',
                     {'Specified explicitly':
                        'explicit',
                      'Implicitely positioned on a regular grid':
                        'image data',
                      'On an orthogonal grid with varying spacing':
                        'orthogonal grid',
                        })

    # The array that is used for finding out the shape of the grid,
    # when creating an ImageData
    grid_shape_source = Property(depends_on='grid_shape_source_')

    def _get_grid_shape_source(self):
        if self.grid_shape_source_ == '':
            # catter for improperly initialized view
            keys = self._data_sources_names
            if not self.grid_shape.any():
                self.grid_shape = \
                        self.data_sources[keys[0]].shape
            return keys[0]
        elif self.grid_shape_source_[:16] == 'Shape of array: ':
            return self.grid_shape_source_[17:-1]
        else:
            return ""

    # Shadow traits for grid_shape_source
    grid_shape_source_ = Str

    def _grid_shape_source_changed(self):
        if not self.grid_shape_source == '':
            array_shape = \
                    atleast_3d(self.data_sources[self.grid_shape_source]).shape
            grid_shape = ones((3, ))
            grid_shape[:len(array_shape)] = array_shape
            self.grid_shape = grid_shape

    _grid_shape_source_labels = Property(depends_on='_data_sources_names')

    def _get__grid_shape_source_labels(self):
        values = ['Shape of array: "%s"' % name
                    for name in  self._data_sources_names]
        values.sort
        values.append('Specified explicitly')
        return values

    # The shape of the grid array. Used when position is implicit
    grid_shape = CArray(shape=(3,), dtype='i')

    # Whether or not the data points should be connected.
    lines = false

    # The scalar data selection
    scalar_data = Str('', help="Select the array that gives the value of the "
                            "scalars plotted.")

    position_x = Str(help="Select the array that gives the x "
                        "position of the data points")

    position_y = Str(help="Select the array that gives the y "
                        "position of the data points")

    position_z = Str(help="Select the array that gives the z "
                        "position of the data points")

    connectivity_triangles = Str

    has_vector_data = false(help="""Do you want to plot vector components?""")

    # A boolean to ask the user if he wants to load scalar data
    has_scalar_data = false

    vector_u = Str

    vector_v = Str

    vector_w = Str

    #----------------------------------------------------------------------
    # Public interface
    #----------------------------------------------------------------------

    def init_arrays(self):
        # Force all the array names to be properly initialized
        array_names = set(self.data_sources.keys())
        if len(array_names) == 0:
            # We should probably bail out here.
            return False
        for attr in ('position_x', 'position_y', 'position_z',
                     'scalar_data', 'vector_u', 'vector_v',
                     'vector_w', 'connectivity_triangles',
                     ):
            if len(array_names) > 0:
                array_name = array_names.pop()
            setattr(self, attr, array_name)

    def guess_arrays(self):
        """ Do some guess work on the arrays to find sensible default.
        """
        array_names = set(self._data_sources_names)
        found_some = False
        if set(('x', 'y', 'z')).issubset(array_names):
            self.position_x = 'x'
            self.position_y = 'y'
            self.position_z = 'z'
            array_names = array_names.difference(('x', 'y', 'z'))
            found_some = True
        elif set(('X', 'Y', 'Z')).issubset(array_names):
            self.position_x = 'X'
            self.position_y = 'Y'
            self.position_z = 'Z'
            array_names = array_names.difference(('X', 'Y', 'Z'))
            found_some = True

        if set(('u', 'v', 'w')).issubset(array_names):
            self.vector_u = 'u'
            self.vector_v = 'v'
            self.vector_w = 'w'
            array_names = array_names.difference(('u', 'v', 'w'))
            found_some = True
        elif set(('U', 'V', 'W')).issubset(array_names):
            self.vector_u = 'U'
            self.vector_v = 'V'
            self.vector_w = 'W'
            array_names = array_names.difference(('U', 'V', 'W'))
            found_some = True

        if found_some:
            # Need to re-attribute the guessed names.
            for attr in ('scalar_data', 'vector_u', 'vector_v',
                        'vector_w', 'connectivity_triangles'):
                if len(array_names) > 0:
                    setattr(self, attr, array_names.pop())
                else:
                    break

    def build_data_source(self):
        """ This is where we apply the selections made by the user in
            in the wizard to build the data source.
        """
        factory = DataSourceFactory()
        # Keep a reference to the factory to be able to replay it, say
        # on other data.
        self._factory = factory
        if self.data_type_ == 'point':
            # The user wants to explicitly position vector,
            # thus only sensible data structures for points is with
            # explicit positioning.
            self.position_type_ == 'explicit'
            # In addition, this view does not allow for
            # connectivity.
            factory.unstructured = True
            factory.connected = False
        else:
            factory.connected = True

        if (self.position_type_ == "image data"
                and not self.data_type_ == "point"):
            if not self.has_scalar_data and not self.vector_u == '':
                # With image data we need a scalar array always:
                factory.scalar_data = ones(self.grid_shape)
            factory.position_implicit = True
        else:
            factory.position_x = self.get_sdata(self.position_x)
            factory.position_y = self.get_sdata(self.position_y)
            factory.position_z = self.get_sdata(self.position_z)
        if self.position_type_ == "orthogonal grid":
            factory.orthogonal_grid = True
        if self.position_type_ == "explicit" and self.data_type_ == "surface":
            factory.connectivity_triangles = self.get_data(
                                                self.connectivity_triangles)
        if self.lines and self.data_type_ == "point":
            factory.lines = True

        if self.has_vector_data or self.data_type_ == 'vector':
            # In the vector view, the user is not explicitly asked to
            # Enable vectors.
            factory.has_vector_data = True
            factory.vector_u = self.get_sdata(self.vector_u)
            factory.vector_v = self.get_sdata(self.vector_v)
            factory.vector_w = self.get_sdata(self.vector_w)

        if self.has_scalar_data or self.data_type_ == 'volumetric':
            # In the volumetric view, the user is not explicitly asked to
            # Enable scalars.
            factory.scalar_data = self.get_sdata(self.scalar_data)

        if self.connectivity_triangles == '':
            factory.connectivity_triangles = None

        self.data_source = factory.build_data_source()

        if self.has_scalar_data:
            if hasattr(self.data_source, 'scalar_name'):
                self.data_source.scalar_name = self.scalar_data
            elif hasattr(self.data_source, 'point_scalar_name'):
                self.data_source.point_scalar_name = self.scalars

    #----------------------------------------------------------------------
    # Private interface
    #----------------------------------------------------------------------
    def get_data(self, name):
        return self.data_sources[name]

    def get_sdata(self, name):
        ary = self.data_sources[name]
        if not self.data_type_ == 'point':
            ary = resize(ary, self.grid_shape)
        return ary

    def active_arrays(self):
        """ Return the list of the active array-selection drop-downs.
        """
        arrays = []
        if self.data_type_ == 'point' or self.position_type_ == 'explicit':
            arrays.extend(
                    ['position_x', 'position_y', 'position_z', ])
        if self.data_type_ == 'vector' or self.has_vector_data:
            arrays.extend(['vector_u', 'vector_v', 'vector_w'])
        if self.has_scalar_data or self.data_type_ == 'volumetric':
            arrays.extend(['scalar_data'])
        return arrays

    def check_arrays(self):
        """ Checks that all the array have the right size.
        """
        arrays_to_check = self.active_arrays()
        if len(arrays_to_check) == 0:
            return True
        size = self.get_data(getattr(self, arrays_to_check.pop())).size
        for attr in arrays_to_check:
            if not self.get_data(getattr(self, attr)).size == size:
                return False
        if (self.data_type_ == 'surface'
                and self.position_type_ == "explicit"):
            if not self.connectivity_triangles.size / 3 == size:
                return False
        return True


###########################################################################
# class ArrayColumnWrapper
###########################################################################
class ArrayColumnWrapper(HasStrictTraits):

    name = Str
    shape = Str


############################################################################
# class ArrayColumnAdapter
############################################################################
class ArrayColumnAdapter(TabularAdapter):

    columns = [('name',  'name'),
               ('shape', 'shape'), ]

    width = 100


############################################################################
# The DataSourceWizardView class
############################################################################
class DataSourceWizardView(DataSourceWizard):

    #----------------------------------------------------------------------
    # Private traits
    #----------------------------------------------------------------------

    _top_label = Str('Describe your data')

    _info_text = Str('Array size do not match')

    _array_label = Str('Available arrays')

    _data_type_text = Str("What does your data represents?")

    _lines_text = Str("Connect the points with lines")

    _scalar_data_text = Str("Array giving the value of the scalars")

    _optional_scalar_data_text = Str("Associate scalars with the data points")

    _connectivity_text = Str("Array giving the triangles")

    _vector_data_text = Str("Associate vector components")

    _position_text = Property(depends_on="position_type_")

    _position_text_dict = {'explicit':
                'Coordinnates of the data points:',
                           'orthogonal grid':
                'Position of the layers along each axis:',
            }

    def _get__position_text(self):
        return self._position_text_dict.get(self.position_type_, "")

    _shown_help_text = Str

    _data_sources_wrappers = Property(depends_on='data_sources')

    def _get__data_sources_wrappers(self):
        return [
            ArrayColumnWrapper(name=name,
                shape=repr(self.data_sources[name].shape))
                    for name in self._data_sources_names
                ]

    # A traits pointing to the object, to play well with traitsUI
    _self = Instance(DataSourceWizard)

    _suitable_traits_view = Property(depends_on="data_type_")

    def _get__suitable_traits_view(self):
        return "_%s_data_view" % self.data_type_

    ui = Any(False)

    _preview_button = Button(label='Preview structure')

    def __preview_button_fired(self):
        if self.ui:
            self.build_data_source()
            self.preview()

    _ok_button = Button(label='OK')

    def __ok_button_fired(self):
        if self.ui:
            self.ui.dispose()
            self.build_data_source()

    _cancel_button = Button(label='Cancel')

    def __cancel_button_fired(self):
        if self.ui:
            self.ui.dispose()

    _is_ok = Bool

    _is_not_ok = Bool

    def _anytrait_changed(self):
        """ Validates if the OK button is enabled.
        """
        if self.ui:
            self._is_ok = self.check_arrays()
            self._is_not_ok = not self._is_ok

    _preview_window = Instance(PreviewWindow, ())

    _info_image = Instance(ImageResource,
                    ImageLibrary.image_resource('@std:alert16',))

    #----------------------------------------------------------------------
    # TraitsUI views
    #----------------------------------------------------------------------
    _coordinates_group = \
                        HGroup(
                           Item('position_x', label='x',
                               editor=EnumEditor(name='_data_sources_names',
                                        invalid='_is_not_ok')),
                           Item('position_y', label='y',
                               editor=EnumEditor(name='_data_sources_names',
                                        invalid='_is_not_ok')),
                           Item('position_z', label='z',
                               editor=EnumEditor(name='_data_sources_names',
                                        invalid='_is_not_ok')),
                       )

    _position_group = \
                    Group(
                       Item('position_type'),
                       Group(
                           Item('_position_text', style='readonly',
                                    resizable=False,
                                    show_label=False),
                           _coordinates_group,
                           visible_when='not position_type_=="image data"',
                       ),
                       Group(
                           Item('grid_shape_source_',
                            label='Grid shape',
                            editor=EnumEditor(
                                name='_grid_shape_source_labels',
                                        invalid='_is_not_ok')),
                           HGroup(
                            spring,
                            Item('grid_shape', style='custom',
                                    editor=ArrayEditor(width=-60),
                                    show_label=False),
                           enabled_when='grid_shape_source==""',
                            ),
                           visible_when='position_type_=="image data"',
                       ),
                       label='Position of the data points',
                       show_border=True,
                       show_labels=False,
                   ),

    _connectivity_group = \
                   Group(
                       HGroup(
                         Item('_connectivity_text', style='readonly',
                                resizable=False),
                         spring,
                         Item('connectivity_triangles',
                                editor=EnumEditor(name='_data_sources_names'),
                                show_label=False,
                                ),
                         show_labels=False,
                       ),
                       label='Connectivity information',
                       show_border=True,
                       show_labels=False,
                       enabled_when='position_type_=="explicit"',
                   ),

    _scalar_data_group = \
                   Group(
                       Item('_scalar_data_text', style='readonly',
                           resizable=False,
                           show_label=False),
                       HGroup(
                           spring,
                           Item('scalar_data',
                               editor=EnumEditor(name='_data_sources_names',
                                        invalid='_is_not_ok')),
                           show_labels=False,
                           ),
                       label='Scalar value',
                       show_border=True,
                       show_labels=False,
                   )

    _optional_scalar_data_group = \
                   Group(
                       HGroup(
                       'has_scalar_data',
                       Item('_optional_scalar_data_text',
                            resizable=False,
                            style='readonly'),
                       show_labels=False,
                       ),
                       Item('_scalar_data_text', style='readonly',
                            resizable=False,
                            enabled_when='has_scalar_data',
                           show_label=False),
                       HGroup(
                           spring,
                           Item('scalar_data',
                               editor=EnumEditor(name='_data_sources_names',
                                        invalid='_is_not_ok'),
                               enabled_when='has_scalar_data'),
                           show_labels=False,
                           ),
                       label='Scalar data',
                       show_border=True,
                       show_labels=False,
                   ),

    _vector_data_group = \
                   VGroup(
                       HGroup(
                           Item('vector_u', label='u',
                               editor=EnumEditor(name='_data_sources_names',
                                        invalid='_is_not_ok')),
                           Item('vector_v', label='v',
                               editor=EnumEditor(name='_data_sources_names',
                                        invalid='_is_not_ok')),
                           Item('vector_w', label='w',
                               editor=EnumEditor(name='_data_sources_names',
                                        invalid='_is_not_ok')),
                       ),
                       label='Vector data',
                       show_border=True,
                   ),

    _optional_vector_data_group = \
                   VGroup(
                        HGroup(
                            Item('has_vector_data', show_label=False),
                            Item('_vector_data_text', style='readonly',
                                resizable=False,
                                show_label=False),
                        ),
                       HGroup(
                           Item('vector_u', label='u',
                               editor=EnumEditor(name='_data_sources_names',
                                        invalid='_is_not_ok')),
                           Item('vector_v', label='v',
                               editor=EnumEditor(name='_data_sources_names',
                                        invalid='_is_not_ok')),
                           Item('vector_w', label='w',
                               editor=EnumEditor(name='_data_sources_names',
                                        invalid='_is_not_ok')),
                           enabled_when='has_vector_data',
                       ),
                       label='Vector data',
                       show_border=True,
                   ),

    _array_view = \
                View(
                    Item('_array_label', editor=TitleEditor(),
                        show_label=False),
                    Group(
                    Item('_data_sources_wrappers',
                      editor=TabularEditor(
                          adapter=ArrayColumnAdapter(),
                      ),
                    ),
                    show_border=True,
                    show_labels=False
                ))

    _questions_view = View(
                Item('_top_label', editor=TitleEditor(),
                        show_label=False),
                HGroup(
                    Item('_data_type_text', style='readonly',
                                resizable=False),
                    spring,
                    'data_type',
                    spring,
                    show_border=True,
                    show_labels=False,
                  ),
                HGroup(
                    Item('_self', style='custom',
                        editor=InstanceEditor(
                                    view_name='_suitable_traits_view'),
                        ),
                    Group(
                        # FIXME: Giving up on context sensitive help
                        # because of lack of time.
                        #Group(
                        #    Item('_shown_help_text', editor=HTMLEditor(),
                        #        width=300,
                        #        label='Help',
                        #        ),
                        #    show_labels=False,
                        #    label='Help',
                        #),
                        #Group(
                            Item('_preview_button',
                                    enabled_when='_is_ok'),
                            Item('_preview_window', style='custom',
                                    label='Preview structure'),
                            show_labels=False,
                            #label='Preview structure',
                        #),
                        #layout='tabbed',
                        #dock='tab',
                    ),
                    show_labels=False,
                    show_border=True,
                ),
            )

    _point_data_view = \
                View(Group(
                   Group(_coordinates_group,
                        label='Position of the data points',
                        show_border=True,
                   ),
                   HGroup(
                       'lines',
                       Item('_lines_text', style='readonly',
                                        resizable=False),
                       label='Lines',
                       show_labels=False,
                       show_border=True,
                   ),
                   _optional_scalar_data_group,
                   _optional_vector_data_group,
                   # XXX: hack to have more vertical space
                   Label('\n'),
                   Label('\n'),
                   Label('\n'),
                ))

    _surface_data_view = \
                View(Group(
                   _position_group,
                   _connectivity_group,
                   _optional_scalar_data_group,
                   _optional_vector_data_group,
                ))

    _vector_data_view = \
                View(Group(
                   _vector_data_group,
                   _position_group,
                   _optional_scalar_data_group,
                ))

    _volumetric_data_view = \
                View(Group(
                   _scalar_data_group,
                   _position_group,
                   _optional_vector_data_group,
                ))

    _wizard_view = View(
          Group(
            HGroup(
                Item('_self', style='custom', show_label=False,
                     editor=InstanceEditor(view='_array_view'),
                     width=0.17,
                     ),
                '_',
                Item('_self', style='custom', show_label=False,
                     editor=InstanceEditor(view='_questions_view'),
                     ),
                ),
            HGroup(
                Item('_info_image', editor=ImageEditor(),
                    visible_when="_is_not_ok"),
                Item('_info_text', style='readonly', resizable=False,
                    visible_when="_is_not_ok"),
                spring,
                '_cancel_button',
                Item('_ok_button', enabled_when='_is_ok'),
                show_labels=False,
            ),
          ),
        title='Import arrays',
        resizable=True,
        )

    #----------------------------------------------------------------------
    # Public interface
    #----------------------------------------------------------------------

    def __init__(self, **traits):
        DataSourceFactory.__init__(self, **traits)
        self._self = self

    def view_wizard(self):
        """ Pops up the view of the wizard, and keeps the reference it to
            be able to close it.
        """
        # FIXME: Workaround for traits bug in enabled_when
        self.position_type_
        self.data_type_
        self._suitable_traits_view
        self.grid_shape_source
        self._is_ok
        self.ui = self.edit_traits(view='_wizard_view')

    def preview(self):
        """ Display a preview of the data structure in the preview
            window.
        """
        self._preview_window.clear()
        self._preview_window.add_source(self.data_source)
        data = lambda name: self.data_sources[name]
        g = Glyph()
        g.glyph.glyph_source.glyph_source = \
                    g.glyph.glyph_source.glyph_list[0]
        g.glyph.scale_mode = 'data_scaling_off'
        if not (self.has_vector_data or self.data_type_ == 'vector'):
            g.glyph.glyph_source.glyph_source.glyph_type = 'cross'
            g.actor.property.representation = 'points'
            g.actor.property.point_size = 3.
        self._preview_window.add_module(g)
        if not self.data_type_ in ('point', 'vector') or self.lines:
            s = Surface()
            s.actor.property.opacity = 0.3
            self._preview_window.add_module(s)
        if not self.data_type_ == 'point':
            self._preview_window.add_filter(ExtractEdges())
            s = Surface()
            s.actor.property.opacity = 0.2
            self._preview_window.add_module(s)


if __name__ == '__main__':
    from numpy import mgrid

    x, y, z = mgrid[-5:5, -5:5, -5:5]
    r = x ** 2 + y ** 2 + z ** 2
    X = linspace(0, 8)

    data_sources = {
            'x': X,
            'y': y,
            'z': z,
            'r': r
        }

    wizard = DataSourceWizardView(data_sources=data_sources)
    wizard.init_arrays()
    wizard.guess_arrays()
    wizard.view_wizard()

########NEW FILE########
__FILENAME__ = loadtxt
# FIXME:
#   This file contains the loadtxt function from numpy 1.1.0 because there
#   is a bug the loadtxt function of numpy 1.0.4.
#   In the future this file can be removed, once Mayavi depends on
#   numpy 1.1.0 (or higher).

import numpy as np


def _string_like(obj):
    try:
        obj + ''
    except (TypeError, ValueError):
        return 0
    return 1


def _getconv(dtype):
    typ = dtype.type
    if issubclass(typ, np.bool_):
        return lambda x: bool(int(x))
    if issubclass(typ, np.integer):
        return lambda x: int(float(x))
    elif issubclass(typ, np.floating):
        return float
    elif issubclass(typ, np.complex):
        return complex
    else:
        return str


def loadtxt(fname, dtype=float, comments='#', delimiter=None, converters=None,
            skiprows=0, usecols=None, unpack=False):
    """
    Load ASCII data from fname into an array and return the array.

    The data must be regular, same number of values in every row

    Parameters
    ----------
    fname : filename or a file handle.
      Support for gzipped files is automatic, if the filename ends in .gz

    dtype : data-type
      Data type of the resulting array.  If this is a record data-type, the
      resulting array will be 1-d and each row will be interpreted as an
      element of the array. The number of columns used must match the number
      of fields in the data-type in this case.

    comments : str
      The character used to indicate the start of a comment in the file.

    delimiter : str
      A string-like character used to separate values in the file. If delimiter
      is unspecified or none, any whitespace string is a separator.

    converters : {}
      A dictionary mapping column number to a function that will convert that
      column to a float.  Eg, if column 0 is a date string:
      converters={0:datestr2num}. Converters can also be used to provide
      a default value for missing data: converters={3:lambda s: float(s or 0)}.

    skiprows : int
      The number of rows from the top to skip.

    usecols : sequence
      A sequence of integer column indexes to extract where 0 is the first
      column, eg. usecols=(1,4,5) will extract the 2nd, 5th and 6th columns.

    unpack : bool
      If True, will transpose the matrix allowing you to unpack into named
      arguments on the left hand side.

    Examples
    --------
      >>> X = loadtxt('test.dat')  # data in two columns
      >>> x,y,z = load('somefile.dat', usecols=(3,5,7), unpack=True)
      >>> r = np.loadtxt('record.dat',
                         dtype={'names':('gender','age','weight'),
                         'formats': ('S1','i4', 'f4')})

    SeeAlso: scipy.io.loadmat to read and write matfiles.
    """

    if _string_like(fname):
        if fname.endswith('.gz'):
            import gzip
            fh = gzip.open(fname)
        else:
            fh = file(fname)
    elif hasattr(fname, 'seek'):
        fh = fname
    else:
        raise ValueError('fname must be a string or file handle')
    X = []

    dtype = np.dtype(dtype)
    defconv = _getconv(dtype)
    converterseq = None
    if converters is None:
        converters = {}
        if dtype.names is not None:
            converterseq = [_getconv(dtype.fields[name][0]) \
                            for name in dtype.names]

    for i, line in enumerate(fh):
        if i < skiprows:
            continue
        comment_start = line.find(comments)
        if comment_start != -1:
            line = line[:comment_start].strip()
        else:
            line = line.strip()
        if not len(line):
            continue
        vals = line.split(delimiter)
        if converterseq is None:
            converterseq = [converters.get(j, defconv) \
                            for j in xrange(len(vals))]
        if usecols is not None:
            row = [converterseq[j](vals[j]) for j in usecols]
        else:
            row = [converterseq[j](val) for j, val in enumerate(vals)]
        if dtype.names is not None:
            row = tuple(row)
        X.append(row)

    X = np.array(X, dtype)
    X = np.squeeze(X)
    if unpack:
        return X.T
    else:
        return X

########NEW FILE########
__FILENAME__ = preview_window
"""
HasTraits class providing window with a mayavi engine, to preview pipeline
elements.
"""

from traits.api import HasTraits, Instance
from traitsui.api import View, Item
from tvtk.pyface.scene_editor import SceneEditor
from tvtk.pyface.scene_model import SceneModel
from tvtk.pyface.scene import Scene

from mayavi.core.engine import Engine


##############################################################################
# PreviewWindow class
##############################################################################
class PreviewWindow(HasTraits):
    """ A window with a mayavi engine, to preview pipeline elements.
    """

    # The engine that manages the preview view
    _engine = Instance(Engine)

    _scene = Instance(SceneModel, ())

    view = View(Item('_scene', editor=SceneEditor(scene_class=Scene),
                        show_label=False),
                width=500, height=500)

    #-----------------------------------------------------------------------
    # Public API
    #-----------------------------------------------------------------------

    def add_source(self, src):
        self._engine.add_source(src)

    def add_module(self, module):
        self._engine.add_module(module)

    def add_filter(self, filter):
        self._engine.add_module(filter)

    def clear(self):
        self._engine.current_scene.scene.disable_render = True
        self._engine.current_scene.children[:] = []
        self._engine.current_scene.scene.disable_render = False

    #-----------------------------------------------------------------------
    # Private API
    #-----------------------------------------------------------------------

    def __engine_default(self):
        e = Engine()
        e.start()
        e.new_scene(self._scene)
        return e

if __name__ == '__main__':
    from pyface.api import GUI
    from mayavi.sources.api import ParametricSurface
    from mayavi.modules.api import Outline, Surface
    pw = PreviewWindow()
    pw.add_source(ParametricSurface())
    pw.add_module(Outline())
    pw.add_module(Surface())

    pw.edit_traits()

########NEW FILE########
__FILENAME__ = decorations
"""
Functions for adding decorations (axes, colorbar, outlines..) to the
pipeline in a procedural way.
"""

# Author: Gael Varoquaux
# Copyright (c) 2007, 2008, 2009, Enthought, Inc.
# License: BSD Style.

import operator

import numpy as np

# Enthought library imports.
from traits.api import String, CFloat, Instance, HasTraits, \
            Trait, CArray, true, Any, Range, Either
import tools
from figure import draw, gcf

# Mayavi imports
import mayavi.modules.api as modules
from .pipe_base import make_function
from .modules import ModuleFactory
from .engine_manager import get_engine, engine_manager

#############################################################################
# Colorbar related functions


def _orient_colorbar(lut_mgr, orientation):
    """Orients the given LUTManager (make it horizontal or vertical).
    """
    rep = lut_mgr.scalar_bar_representation
    colorbar = lut_mgr.scalar_bar
    if orientation == "vertical":
        if rep is None:
            # VTK < 5.2
            colorbar.orientation = "vertical"
        else:
            rep.orientation = 1
            rep.position = (0.01, 0.15)
            rep.position2 = (0.1, 0.8)
        colorbar.width = 0.1
        colorbar.height = 0.8
        colorbar.position = (0.01, 0.15)
    elif orientation == "horizontal":
        if rep is None:
            colorbar.orientation = "horizontal"
        else:
            rep.orientation = 0
            rep.position = (0.1, 0.01)
            rep.position2 = (0.8, 0.17)
        colorbar.width = 0.8
        colorbar.height = 0.17
        colorbar.position = (0.1, 0.01)
    else:
        raise ValueError("Unknown orientation: %s" % orientation)
    draw()


def _lut_manager_properties(lut_manager, **props):
    """ Internal function used to apply properties to a colorbar.
    """
    need_redraw = False
    orientation = props.get('orientation', None)
    if orientation is not None:
        _orient_colorbar(lut_manager, orientation)

    colorbar = lut_manager.scalar_bar
    title = props.get('title', None)
    if title is not None:
        colorbar.title = title
        need_redraw = True

    label_fmt = props.get('label_fmt', None)
    if label_fmt is not None:
        colorbar.label_format = label_fmt
        need_redraw = True

    nb_labels = props.get('nb_labels', None)
    if nb_labels is not None:
        colorbar.number_of_labels = nb_labels
        need_redraw = True

    nb_colors = props.get('nb_colors', None)
    if nb_colors is not None:
        colorbar.maximum_number_of_colors = nb_colors
        need_redraw = True

    if need_redraw:
        draw()


def scalarbar(object=None, title=None, orientation=None,
                           nb_labels=None, nb_colors=None,
                           label_fmt=None):
    """Adds a colorbar for the scalar color mapping of the given object.

    If no object is specified, the first object with scalar data in the scene
    is used.

    **Keyword arguments**:

        :object: Optional object to get the scalar color map from

        :title: The title string

        :orientation: Can be 'horizontal' or 'vertical'

        :nb_labels: The number of labels to display on the colorbar.

        :label_fmt: The string formater for the labels. This needs to be
                    a formater for float number, eg '%.1f'.

        :nb_colors: The maximum number of colors displayed on the
                    colorbar.
    """
    module_manager = tools._find_module_manager(object=object,
                                                    data_type="scalar")
    if module_manager is None:
        return
    if not module_manager.scalar_lut_manager.show_scalar_bar:
        if title is None:
            title = ''
        if orientation is None:
            orientation = 'horizontal'
    lut_mgr = module_manager.scalar_lut_manager
    module_manager.scalar_lut_manager.show_scalar_bar = True
    _lut_manager_properties(lut_mgr, title=title, orientation=orientation,
                        nb_labels=nb_labels, nb_colors=nb_colors,
                        label_fmt=label_fmt)
    return lut_mgr


def vectorbar(object=None, title=None, orientation=None,
                           nb_labels=None, nb_colors=None,
                           label_fmt=None):
    """Adds a colorbar for the vector color mapping of the given object.

    If no object is specified, the first object with vector data in the scene
    is used.

    **Keyword arguments**

        :object: Optional object to get the vector color map from

        :title: The title string

        :orientation: Can be 'horizontal' or 'vertical'

        :nb_labels: The number of labels to display on the colorbar.

        :label_fmt: The string formater for the labels. This needs to be
                    a formater for float number, eg '%.1f'.

        :nb_colors: The maximum number of colors displayed on the
                    colorbar.
    """
    module_manager = tools._find_module_manager(object=object,
                                                    data_type="vector")
    if module_manager is None:
        return
    if not module_manager.vector_lut_manager.show_scalar_bar:
        if title is None:
            title = ''
        orientation = 'horizontal'
    lut_mgr = module_manager.vector_lut_manager
    lut_mgr.show_scalar_bar = True
    _lut_manager_properties(lut_mgr, title=title, orientation=orientation,
                        nb_labels=nb_labels, nb_colors=nb_colors,
                        label_fmt=label_fmt)
    return lut_mgr


def colorbar(object=None, title=None, orientation=None,
                           nb_labels=None, nb_colors=None,
                           label_fmt=None):
    """Adds a colorbar for the color mapping of the given object.

    If the object has scalar data, the scalar color mapping is
    represented. Elsewhere the vector color mapping is represented, if
    available.
    If no object is specified, the first object with a color map in the scene
    is used.

    **Keyword arguments**:

        :object: Optional object to get the color map from

        :title: The title string

        :orientation: Can be 'horizontal' or 'vertical'

        :nb_labels: The number of labels to display on the colorbar.

        :label_fmt: The string formater for the labels. This needs to be
                    a formater for float number, eg '%.1f'.

        :nb_colors: The maximum number of colors displayed on the
                    colorbar.
    """
    colorbar = scalarbar(object=object, title=title, orientation=orientation,
                            nb_labels=nb_labels, nb_colors=nb_colors,
                            label_fmt=label_fmt)
    if colorbar is None:
        colorbar = vectorbar(object=object, title=title,
                                orientation=orientation,
                                nb_labels=nb_labels, nb_colors=nb_colors,
                                label_fmt=label_fmt)
    return colorbar


#############################################################################
class SingletonModuleFactory(ModuleFactory):
    """ Base classe for factories that can find an existing object
    matching certain criteria instead of building a new one"""

    # The parent object on which this module is going to be added.
    _parent = Any

    def __init__(self, *args, **kwargs):
        """ Try to find an module actor with the same name, on the given
        parent (if any) and use it rather than building a new module."""
        # Call the HasTraits constructor, but not the PipeBase one.
        HasTraits.__init__(self)
        self._scene = gcf()
        if not 'figure' in kwargs:
            self._engine = get_engine()
        else:
            figure = kwargs['figure']
            self._engine = engine_manager.find_figure_engine(figure)
            self._engine.current_scene = figure
            kwargs.pop('figure')
        if self._scene.scene is not None:
            self._scene.scene.disable_render = True
        # Process the arguments
        if len(args) == 1:
            (parent, ) = args
        elif len(args) == 0:
            parent = self._engine.current_object
        else:
            raise ValueError("Wrong number of arguments")

        # Try to find an existing module, if not add one to the pipeline
        if parent == None:
            target = self._scene
        else:
            target = parent

        klass = self._target.__class__

        for obj in tools._traverse(target):
            if (isinstance(obj, klass)
                        and obj.name == self.name):
                self._target = obj
                break
        else:
            # Keep a reference to the parent
            self._parent = parent
            self._engine.add_module(self._target, obj=parent)

        # Now calling the traits setter, so that traits handlers are
        # called
        self.set(**kwargs)
        if self._scene.scene is not None:
            self._scene.scene.disable_render = False


#############################################################################
class AxesLikeModuleFactory(SingletonModuleFactory):
    """ Base class for axes and outline"""

    extent = CArray(shape=(6,),
                    help="""[xmin, xmax, ymin, ymax, zmin, zmax]
                            Default is the object's extents.""", )

    def _extent_changed(self):
        """ There is no universal way of setting extents for decoration
            objects. This should be implemented in subclasses
        """
        pass

    # Override the color and opacity handlers: axes and outlines do not
    # behave like other modules

    def _color_changed(self):
        if self.color:
            try:
                self._target.property.color = self.color
            except AttributeError:
                try:
                    self._target.actor.property.color = self.color
                except AttributeError:
                    pass

    def _opacity_changed(self):
        try:
            self._target.property.opacity = self.opacity
        except AttributeError:
            try:
                self._target.actor.property.opacity = self.opacity
            except AttributeError:
                pass

    def __init__(self, *args, **kwargs):
        """ Overide the call method to be able to catch the extents of
            the object, if any.
        """
        SingletonModuleFactory.__init__(self, *args, **kwargs)
        if not 'extent' in kwargs:
            try:
                # XXX: Do not use tools.set_extent, as it does not work
                # on axes.
                self.extent = self._parent.actor.actor.bounds
            except AttributeError:
                """ Either this is not a module, or it has no actors"""


#############################################################################
class Outline(AxesLikeModuleFactory):
    """ Creates an outline for the current (or given) object."""

    _target = Instance(modules.Outline, ())

    def _extent_changed(self):
        self._target.manual_bounds = True
        self._target.bounds = self.extent


outline = make_function(Outline)


#############################################################################
class Axes(AxesLikeModuleFactory):
    """ Creates axes for the current (or given) object."""

    xlabel = String(None, adapts='axes.x_label',
                help='the label of the x axis')

    ylabel = String(None, adapts='axes.y_label',
                help='the label of the y axis')

    zlabel = String(None, adapts='axes.z_label',
                help='the label of the z axis')

    nb_labels = Range(0, 50, 2, adapts='axes.number_of_labels',
                desc='The number of labels along each direction')

    ranges = Trait(None, None, CArray(shape=(6,)),
                    help="""[xmin, xmax, ymin, ymax, zmin, zmax]
                            Ranges of the labels displayed on the axes.
                            Default is the object's extents.""", )

    x_axis_visibility = true(adapts='axes.x_axis_visibility',
                help="Whether or not the x axis is visible (boolean)")

    y_axis_visibility = true(adapts='axes.y_axis_visibility',
                help="Whether or not the y axis is visible (boolean)")

    z_axis_visibility = true(adapts='axes.z_axis_visibility',
                help="Whether or not the z axis is visible (boolean)")

    _target = Instance(modules.Axes, ())

    def _extent_changed(self):
        """ Code to modify the extents for
        """
        axes = self._target
        axes.axes.use_data_bounds = False
        axes.axes.bounds = self.extent
        if self.ranges is None:
            axes.axes.ranges = \
                axes.module_manager.source.outputs[0].bounds

    def _ranges_changed(self):
        if self.ranges is not None:
            self._target.axes.ranges = self.ranges
            self._target.axes.use_ranges = True

axes = make_function(Axes)


def xlabel(text, object=None):
    """
    Creates a set of axes if there isn't already one, and sets the x label

    **Keyword arguments**:

        :object:  The object to apply the module to, if not the whole scene
                  is searched for a suitable object.
    """
    return axes(object, xlabel=text)


def ylabel(text, object=None):
    """
    Creates a set of axes if there isn't already one, and sets the y label

    **Keyword arguments**:


        :object:  The object to apply the module to, if not the whole scene
                  is searched for a suitable object.
    """
    return axes(object, ylabel=text)


def zlabel(text, object=None):
    """
    Creates a set of axes if there isn't already one, and sets the z label

    **Keyword arguments**

        :object:  The object to apply the module to, if not the whole scene
                  is searched for a suitable object.
    """
    return axes(object, zlabel=text)


##############################################################################
class OrientationAxesFactory(SingletonModuleFactory):
    """Applies the OrientationAxes mayavi module to the given VTK data object.
    """

    xlabel = String(None, adapts='axes.x_axis_label_text',
                help='the label of the x axis')

    ylabel = String(None, adapts='axes.y_axis_label_text',
                help='the label of the y axis')

    zlabel = String(None, adapts='axes.z_axis_label_text',
                help='the label of the z axis')

    _target = Instance(modules.OrientationAxes, ())

orientation_axes = make_function(OrientationAxesFactory)


###############################################################################
class Text(ModuleFactory):
    """ Adds a text on the figure.

        **Function signature**::

            text(x, y, text, ...)

        x, and y are the position of the origin of the text. If no z
        keyword argument is given, x and y are the 2D projection of the
        figure, they belong to [0, 1]. If a z keyword  argument is given, the
        text is positionned in 3D, in figure coordinnates.
        """

    width = Trait(None, None, CFloat, adapts='width',
                        help="""width of the text.""")

    z = Trait(None, None, CFloat,
              help="""Optional z position. When specified, the
                      text is positioned in 3D""")

    _target = Instance(modules.Text, ())

    opacity = CFloat(1, adapts="property.opacity",
                        help="""The opacity of the text.""")

    def __init__(self, x, y, text, **kwargs):
        """ Override init as for different positional arguments."""
        if 'z' in kwargs and kwargs['z'] is not None:
            self._target.z_position = kwargs['z']
            self._target.position_in_3d = True
        elif not (x < 1. and x > 0. and y > 0. and y < 1.):
            raise ValueError('Text positions should be in [0, 1] if no z'
                'position is given')
        super(Text, self).__init__(None, **kwargs)
        self._target.text = text
        self._target.x_position = x
        self._target.y_position = y


text = make_function(Text)


###############################################################################
class Text3D(ModuleFactory):
    """ Positions text at a 3D location in the scene.

        **Function signature**::

            text3d(x, y, z, text, ...)

        x, y, and z are the position of the origin of the text. The
        text is positionned in 3D, in figure coordinnates.
        """

    _target = Instance(modules.Text3D, ())

    scale = Either(CFloat(1), CArray(shape=(3,)),
                        help="""The scale of the text, in figure units.
                                Either a float, or 3-tuple of floats.""")

    orientation = CArray(shape=(3,), adapts='orientation',
                        desc="""the angles giving the orientation of the
                        text. If the text is oriented to the camera,
                        these angles are referenced to the axis of the
                        camera. If not, these angles are referenced to
                        the z axis.""")

    orient_to_camera = true(adapts='orient_to_camera',
                        desc="""if the text is kept oriented to the
                        camera, or is pointing in a specific direction,
                        regardless of the camera position.""")

    def __init__(self, x, y, z, text, **kwargs):
        """ Override init as for different positional arguments."""
        if not 'scale' in kwargs:
            kwargs['scale'] = 1
        super(Text3D, self).__init__(None, **kwargs)
        self._target.text = text
        self._target.position = (x, y, z)

    def _scale_changed(self):
        scale = self.scale
        if operator.isNumberType(scale):
            scale = scale * np.ones((3,))
        self._target.scale = scale

text3d = make_function(Text3D)


#############################################################################
class Title(SingletonModuleFactory):
    """Creates a title for the figure.

    **Function signature**::

        title(text, ...)

    """

    size = CFloat(1, help="the size of the title")

    height = CFloat(0.8, adapts='y_position',
                         help="""height of the title, in portion of the
                                 figure height""")

    def _size_changed(self):
        self._target.width = min(0.05 * self.size * len(self._text), 1)
        self._target.x_position = 0.5 * (1 - self._target.width)

    _target = Instance(modules.Text)

    def __target_default(self):
        """ This is called only if no existing title is found."""
        width = min(0.05 * self.size * len(self._text), 1)
        text = modules.Text(text=self._text,
                            y_position=self.height,
                            x_position=0.5 * (1 - width),)
        text.width = width
        return text

    def __init__(self, text, **kwargs):
        self._text = text  # This will be used by _size_changed
        if not 'name' in kwargs:
            # The name is used as au unique marker to identify the
            # title. We need to set it ASAP.
            self.name = kwargs['name'] = 'Title'
        super(Title, self).__init__(**kwargs)
        self._target.text = self._text
        # We need to set position after Text is initiated, as text will
        # override these positions
        self._target.y_position = self.height
        self._size_changed()


title = make_function(Title)

########NEW FILE########
__FILENAME__ = engine_manager
"""
Central registry for figures with mlab.
"""

# Standard library imports
import warnings

# Enthought librairies imports
from traits.api import HasTraits, Instance

# Local imports
from mayavi.preferences.api import preference_manager
from mayavi.core.registry import registry
from mayavi.core.engine import Engine
from mayavi.core.off_screen_engine import OffScreenEngine
from mayavi.core.null_engine import NullEngine
from mayavi.core.common import process_ui_events
from preferences_mirror import PreferencesMirror

# The mlab options.
options = PreferencesMirror()
options.preferences = preference_manager.mlab


######################################################################
def check_backend():
    """ Check if either we are in test mode, or if there is a
        suitable traits backend installed.
    """
    from traitsui.toolkit import toolkit
    from traits.etsconfig.api import ETSConfig
    from mayavi.tools.engine_manager import options

    toolkit()  # This forces the selection of a toolkit.
    if (options.backend != 'test' and options.offscreen != True) and \
            ETSConfig.toolkit in ('null', ''):
        raise ImportError('''Could not import backend for traits
_______________________________________________________________________________
Make sure that you have either the TraitsBackendWx or the TraitsBackendQt
projects installed. If you installed Mayavi with easy_install, try
easy_install <pkg_name>. easy_install Mayavi[app] will also work.

If you performed a source checkout, be sure to run 'python setup.py install'
in Traits, TraitsGUI, and the Traits backend of your choice.

Also make sure that either wxPython or PyQT is installed.
wxPython: http://www.wxpython.org/
PyQT: http://www.riverbankcomputing.co.uk/software/pyqt/intro
''')


###############################################################################
# `EngineManager` class.
###############################################################################
class EngineManager(HasTraits):
    """ Central registry for figures with mlab.

        This is a container for a list of engines having declared
        themselves as usable by mlab.

        This object is meant to be a thin wrapper on top of the different
        Engine classes, making sure that mlab knows how to start an
        engine and get a figure.
    """

    current_engine = Instance(Engine)

    def get_engine(self):
        """ Returns an engine in agreement with the options.
        """

        # First check if the current engine is running and if it is in
        # the registered engines.
        ce = self.current_engine
        if ce is not None:
            if not ce.running or ce not in registry.engines.values():
                self.current_engine = None

        if self.current_engine is not None:
            engines = list((self.current_engine,))
        else:
            engines = list()
        engines.extend(registry.engines.values())
        if options.backend == 'auto':
            suitable = [e for e in engines
                                if e.__class__.__name__ != 'NullEngine']
        elif options.backend == 'envisage':
            suitable = [e for e in engines
                                if e.__class__.__name__ == 'EnvisageEngine']
        elif options.backend == 'test':
            suitable = [e for e in engines
                                if e.__class__.__name__ == 'NullEngine']
        else:
            suitable = [e for e in engines
                                if e.__class__.__name__ == 'Engine']
        if len(suitable) == 0:
            return self.new_engine()
        else:
            # Return the most engine add to the list most recently.
            self.current_engine = suitable[-1]
            return suitable[-1]

    def get_null_engine(self):
        """Return a suitable null engine and make that the current
        engine.
        """
        # First check if the current engine is running and if it is in
        # the registered engines.
        ce = self.current_engine
        if ce is not None:
            if not ce.running or ce not in registry.engines.values():
                self.current_engine = None

        if self.current_engine is not None:
            engines = list((self.current_engine,))
        else:
            engines = list()
        engines.extend(registry.engines.values())
        engine = None
        for e in engines:
            if e.__class__.__name__ == 'NullEngine':
                engine = e
                break
        else:
            engine = NullEngine(name='Null Mlab Engine')
            engine.start()
        self.current_engine = engine
        return engine

    def set_engine(self, engine):
        """ Sets the mlab engine.
        """
        if not engine.running:
            warnings.warn('Engine is not running', stacklevel=2)
        self.current_engine = engine
        registry.register_engine(engine)

    def new_engine(self):
        """ Creates a new engine, envisage or not depending on the
            options.
        """
        check_backend()
        if options.backend == 'envisage':
            from mayavi.plugins.app import Mayavi
            m = Mayavi(start_gui_event_loop=False)
            m.main()
            process_ui_events()
            window = m.application.workbench.active_window
            engine = window.get_service(Engine)
        elif options.backend == 'test':
            engine = NullEngine(name='Null Mlab Engine')
            engine.start()
        else:
            if options.offscreen:
                engine = OffScreenEngine(name='Mlab offscreen Engine')
                engine.start()
            else:
                engine = Engine(name='Mlab Engine')
                engine.start()
        self.current_engine = engine
        return engine

    def find_figure_engine(self, fig):
        """ Find the engine corresponding to a given mayavi scene.
        """
        for engine in registry.engines.values():
            if fig in engine.scenes:
                return engine
        else:
            raise TypeError("Figure not attached to a mayavi engine.")

    def show_engine(self, engine=None, rich_view=True):
        """ Show a dialog with the mayavi pipeline. This dialog allows to
            edit graphicaly the properties of the different objects on
            the scenes.
        """
        if engine is None:
            engine = self.get_engine()
        if engine.__class__.__name__ == 'EnvisageEngine' or \
                                            options.backend == 'test':
            # FIXME: This should pop up the relevent envisage view
            pass
        elif rich_view:
            from mayavi.core.ui.engine_rich_view import \
                    EngineRichView
            figure = engine.current_scene
            view = EngineRichView(engine=engine)
            if figure is None:
                scene = None
            else:
                scene = figure.scene
            return view.scene_editing_view(scene=scene)
        else:
            from mayavi.core.ui.engine_view import \
                    EngineView
            scene = engine.current_scene
            view = EngineView(engine=engine)
            return view.edit_traits()


engine_manager = EngineManager()

get_engine = engine_manager.get_engine

get_null_engine = engine_manager.get_null_engine

set_engine = engine_manager.set_engine

show_pipeline = engine_manager.show_engine

########NEW FILE########
__FILENAME__ = figure
"""
Functions related to creating the engine or the figures.

"""

# Author: Gael Varoquaux <gael.varoquaux@normalesup.org>
# Copyright (c) 2007, Enthought, Inc.
# License: BSD Style.

# Standard library imports.
from types import IntType
import gc
import warnings
import copy

import numpy as np

# Enthought imports
from pyface.timer.api import do_later

#  imports
from tvtk.api import tvtk
from mayavi.core.scene import Scene
from mayavi.core.registry import registry
from .camera import view
from .engine_manager import get_engine, options, set_engine

######################################################################

# A list to store the allocated scene numbers
__scene_number_list = set((0,))


def figure(figure=None, bgcolor=None, fgcolor=None, engine=None,
                size=(400, 350)):
    """ Creates a new scene or retrieves an existing scene. If the mayavi
    engine is not running this also starts it.

    **Keyword arguments**

        :figure: The name of the figure, or handle to it.

        :bgcolor: The color of the background (None is default).

        :fgcolor: The color of the foreground, that is the color of all text
                  annotation labels (axes, orientation axes, scalar bar
                  labels). It should be sufficiently far from `bgcolor`
                  to see the annotation texts. (None is default).

        :engine: The mayavi engine that controls the figure.

        :size: The size of the scene created, in pixels. May not apply
               for certain scene viewer.
    """
    if isinstance(figure, Scene):
        if figure.scene is None:
            engine = registry.find_scene_engine(figure)
        else:
            engine = registry.find_scene_engine(figure.scene)
        set_engine(engine)
        engine.current_scene = figure
    else:
        if engine is None:
            engine = get_engine()
        if figure is None:
            name = max(__scene_number_list) + 1
            __scene_number_list.update((name,))
            name = 'Mayavi Scene %d' % name
            engine.new_scene(name=name, size=size)
            engine.current_scene.name = name
        else:
            if type(figure) in (IntType, np.int, np.int0, np.int8,
                            np.int16, np.int32, np.int64):
                name = int(figure)
                __scene_number_list.update((name,))
                name = 'Mayavi Scene %d' % name
            else:
                name = str(figure)
            # Go looking in the engine see if the scene is not already
            # running
            for scene in engine.scenes:
                if scene.name == name:
                    engine.current_scene = scene
                    return scene
            else:
                engine.new_scene(name=name, size=size)
                engine.current_scene.name = name
        figure = engine.current_scene
        scene = figure.scene
        if scene is not None:
            if hasattr(scene, 'isometric_view'):
                scene.isometric_view()
            else:
                # Not every viewer might implement this method
                view(40, 50)
    scene = figure.scene
    if scene is not None:
        if bgcolor is None:
            bgcolor = options.background_color
        scene.background = bgcolor
        if fgcolor is None:
            fgcolor = options.foreground_color
        scene.foreground = fgcolor
    return figure


def gcf(engine=None):
    """Return a handle to the current figure.

    You can supply the engine from which you want to retrieve the
    current figure, if you have several mayavi engines.
    """
    if engine is None:
        engine = get_engine()
    scene = engine.current_scene
    if scene is None:
        return figure(engine=engine)
    return scene


def clf(figure=None):
    """Clear the current figure.

    You can also supply the figure that you want to clear.
    """
    try:
        if figure is None:
            scene = gcf()
        else:
            scene = figure
        disable_render = scene.scene.disable_render
        scene.scene.disable_render = True
        scene.children[:] = []
        scene._mouse_pick_dispatcher.clear_callbacks()
        scene.scene.disable_render = disable_render
    except AttributeError:
        pass
    gc.collect()


def close(scene=None, all=False):
    """ Close a figure window

        close() by itself closes the current figure.

        close(num) closes figure number num.

        close(name) closes figure named name.

        close(figure), where figure is a scene instance, closes that
        figure.

        close(all=True) closes all figures controlled by mlab
    """
    if all is True:
        engine = get_engine()
        # We need the copy, as the list gets pruned as we close scenes
        for scene in copy.copy(engine.scenes):
            engine.close_scene(scene)
        return
    if not isinstance(scene, Scene):
        engine = get_engine()
        if scene is None:
            scene = engine.current_scene
        else:
            if type(scene) in (IntType, np.int, np.int0, np.int8,
                            np.int16, np.int32, np.int64):
                scene = int(scene)
                name = 'Mayavi Scene %d' % scene
            else:
                name = str(scene)
            # Go looking in the engine see if the scene is not already
            # running
            for scene in engine.scenes:
                if scene.name == name:
                    break
            else:
                warnings.warn('Scene %s not managed by mlab' % name)
                return
    else:
        if scene.scene is None:
            engine = registry.find_scene_engine(scene)
        else:
            engine = registry.find_scene_engine(scene.scene)
    engine.close_scene(scene)


def draw(figure=None):
    """ Forces a redraw of the current figure.
    """
    if figure is None:
        figure = gcf()
    figure.render()


def savefig(filename, size=None, figure=None, magnification='auto',
                    **kwargs):
    """ Save the current scene.
        The output format are deduced by the extension to filename.
        Possibilities are png, jpg, bmp, tiff, ps, eps, pdf, rib (renderman),
        oogl (geomview), iv (OpenInventor), vrml, obj (wavefront)

        **Parameters**

        :size: the size of the image created (unless magnification is
               set, in which case it is the size of the window used
               for rendering).

        :figure: the figure instance to save to a file.

        :magnification: the magnification is the scaling between the
                        pixels on the screen, and the pixels in the
                        file saved. If you do not specify it, it will be
                        calculated so that the file is saved with the
                        specified size. If you specify a magnification,
                        Mayavi will use the given size as a screen size,
                        and the file size will be 'magnification * size'.

        **Notes**

        If the size specified is larger than the window size, and no
        magnification parameter is passed, the magnification of the scene
        is changed so that the image created has the requested size.
        Please note that if you are trying to save images with sizes
        larger than the window size, there will be additional computation
        cost.

        Any extra keyword arguments are passed along to the respective
        image format's save method.
    """
    if figure is None:
        figure = gcf()
    current_mag = figure.scene.magnification
    try:
        if size is not None:
            current_x, current_y = tuple(figure.scene.get_size())
            target_x, target_y = size
            if magnification is 'auto':
                magnification = max(target_x // current_x,
                                            target_y // current_y) + 1
                target_x = int(target_x / magnification)
                target_y = int(target_y / magnification)
                size = target_x, target_y
        elif magnification is 'auto':
            magnification = 1
        figure.scene.magnification = int(magnification)
        figure.scene.save(filename,
                            size=size,
                            **kwargs)
    finally:
        figure.scene.magnification = int(current_mag)


def sync_camera(reference_figure, target_figure):
    """ Synchronise the camera of the target_figure on the camera of the
        reference_figure.
    """
    reference_figure.scene._renderer.sync_trait('active_camera',
                        target_figure.scene._renderer)
    target_figure.scene._renderer.active_camera.on_trait_change(
            lambda: do_later(target_figure.scene.render))


def screenshot(figure=None, mode='rgb', antialiased=False):
    """ Return the current figure pixmap as an array.

        **Parameters**

        :figure: a figure instance or None, optional
            If specified, the figure instance to capture the view of.
        :mode: {'rgb', 'rgba'}
            The color mode of the array captured.
        :antialiased: {True, False}
            Use anti-aliasing for rendering the screenshot.
            Uses the number of aa frames set by
            figure.scene.anti_aliasing_frames

        **Notes**

        On most systems, this works similarly to taking a screenshot of
        the rendering window. Thus if it is hidden by another window, you
        will capture the other window. This limitation is due to the
        heavy use of the hardware graphics system.

        **Examples**

        This function can be useful for integrating 3D plotting with
        Mayavi in a 2D plot created by matplotlib.

        >>> from mayavi import mlab
        >>> mlab.test_plot3d()
        >>> arr = mlab.screenshot()
        >>> import pylab as pl
        >>> pl.imshow(arr)
        >>> pl.axis('off')
        >>> pl.show()

    """
    if figure is None:
        figure = gcf()
    x, y = tuple(figure.scene.get_size())

    # Try to lift the window
    figure.scene._lift()
    if mode == 'rgb':
        out = tvtk.UnsignedCharArray()
        shape = (y, x, 3)
        pixel_getter = figure.scene.render_window.get_pixel_data
        pg_args = (0, 0, x - 1, y - 1, 1, out)

    elif mode == 'rgba':
        out = tvtk.FloatArray()
        shape = (y, x, 4)
        pixel_getter = figure.scene.render_window.get_rgba_pixel_data
        pg_args = (0, 0, x - 1, y - 1, 1, out)

    else:
        raise ValueError('mode type not understood')

    if antialiased:
        # save the current aa value to restore it later
        old_aa = figure.scene.render_window.aa_frames

        figure.scene.render_window.aa_frames = figure.scene.anti_aliasing_frames
        figure.scene.render()
        pixel_getter(*pg_args)
        figure.scene.render_window.aa_frames = old_aa
        figure.scene.render()

    else:
        pixel_getter(*pg_args)

    # Return the array in a way that pylab.imshow plots it right:
    out = out.to_array()
    out.shape = shape
    out = np.flipud(out)
    return out

########NEW FILE########
__FILENAME__ = filters
"""
Filter factories and their associated functions for mlab.

Module functions meant to be applied to a data source object should take
only one positional argument, the data object, to be easily used in
helper functions.
"""

# Author: Gael Varoquaux <gael.varoquaux@normalesup.org>
#         Prabhu Ramachandran
# Copyright (c) 2007-2008, Enthought, Inc.
# License: BSD Style.

import new

from traits.api import Instance, CFloat, CInt, CArray, Trait, \
            Enum, Property, Any, String
from tvtk.common import camel2enthought
from tvtk.api import tvtk
import mayavi.filters.api as filters
from mayavi.core.registry import registry
from pipe_base import PipeFactory, make_function

# This the list is dynamically populated further down below at the end.
__all__ = ['tube', 'warp_scalar', 'threshold', 'elevation_filter',
            'set_active_attribute', 'user_defined'
          ]


##############################################################################
class TubeFactory(PipeFactory):
    """Applies the Tube mayavi filter to the given VTK object."""

    _target = Instance(filters.Tube, ())

    tube_sides = CInt(6, adapts='filter.number_of_sides',
                        desc="""number of sides of the tubes used to
                        represent the lines.""")

    tube_radius = CFloat(0.05, adapts='filter.radius',
                        desc="""radius of the tubes used to represent the
                        lines.""")


tube = make_function(TubeFactory)


##############################################################################
class WarpScalarFactory(PipeFactory):
    """Applies the WarpScalar mayavi filter to the given VTK object."""

    _target = Instance(filters.WarpScalar, ())

    warp_scale = CFloat(1.0, adapts="filter.scale_factor",
                            help="scale of the warp scalar")

warp_scalar = make_function(WarpScalarFactory)


##############################################################################
class ThresholdFactory(PipeFactory):
    """Applies the Threshold mayavi filter to the given VTK object."""

    _target = Instance(filters.Threshold, ())

    filter_type = Enum('cells', 'points', adapts='filter_type',
                    help="If threshold is put on cells or points")

    low = Trait(None, None, CFloat, help="The lower threshold")

    def _low_changed(self):
        if self.low == None:
            pass
        else:
            self._target.lower_threshold = self.low

    up = Trait(None, None, CFloat, help="The upper threshold")

    def _up_changed(self):
        if self.up == None:
            pass
        else:
            self._target.upper_threshold = self.up


threshold = make_function(ThresholdFactory)


##############################################################################
class ElevationFilterFactory(PipeFactory):
    """Applies the Elevation Filter mayavi filter to the given VTK object."""

    high_point = CArray(default=[0, 0, 1], shape=(3,),
                    adapts="filter.high_point",
                    help="The end point of the projection line")

    low_point = CArray(default=[0, 0, 0], shape=(3,),
                    adapts="filter.low_point",
                    help="The start point of the projection line")

    _target = Instance(filters.ElevationFilter, ())

elevation_filter = make_function(ElevationFilterFactory)


##############################################################################
class SetActiveAttributeFactory(PipeFactory):
    """ Applies the SetActiveAttribute Filter mayavi filter to the given
        VTK object.
    """

    point_scalars = String(
                    adapts="point_scalars_name",
                    help="The name of the active point scalars")

    point_vectors = String(
                    adapts="point_vectors_name",
                    help="The name of the active point vectors")

    point_tensors = String(
                    adapts="point_tensors_name",
                    help="The name of the active point tensors")

    cell_scalars = String(
                    adapts="cell_scalars_name",
                    help="The name of the active cell scalars")

    cell_vectors = String(
                    adapts="cell_vectors_name",
                    help="The name of the active cell vectors")

    cell_tensors = String(
                    adapts="cell_tensors_name",
                    help="The name of the active cell tensors")

    _target = Instance(filters.SetActiveAttribute, ())

set_active_attribute = make_function(SetActiveAttributeFactory)


##############################################################################
class UserDefinedFactory(PipeFactory):
    """Applies the UserDefined mayavi filter to the given TVTK object."""

    _target = Instance(filters.UserDefined, ())

    filter = Instance(tvtk.Object, adapts="filter",
                      help="the tvtk filter to adapt. This"
                           "be either an instance of the filter, or the"
                           "name of this filter.")

    def __init__(self, parent, **kwargs):
        if 'filter' in kwargs:
            filter = kwargs['filter']
            if not isinstance(filter, tvtk.Object):
                try:
                    filter = getattr(tvtk, filter)
                except AttributeError:
                    raise Exception('Filter %s unknown to TVTK' % filter)
                kwargs['filter'] = filter()
                self._target.filter = kwargs['filter']
                self._target.setup_filter()
            else:
                self._target.filter = kwargs['filter']
            if not 'name' in kwargs:
                kwargs['name'] = 'UserDefined(%s)' % \
                        kwargs['filter'].__class__.__name__
        super(UserDefinedFactory, self).__init__(parent, **kwargs)

user_defined = make_function(UserDefinedFactory)


############################################################################
# Automatically generated filters from registry.
############################################################################
class _AutomaticFilterFactory(PipeFactory):
    """The base class for any auto-generated factory classes.

    NOTE: This class requires that the `_metadata` trait be set to
    the metadata object for the object for which this is a factory.
    """

    # The target.
    _target = Property

    # The saved target that is created once and then always returned.
    _saved_target = Any(None)

    def _get__target(self):
        """Getter for the _target trait."""
        if self._saved_target is None:
            self._saved_target = self._metadata.get_callable()()

        return self._saved_target


def _make_functions(namespace):
    """Make the functions for adding filters and add them to the
    namespace automatically.
    """
    for fil in registry.filters:
        func_name = camel2enthought(fil.id)
        class_name = fil.id
        if func_name.endswith('_filter'):
            func_name = func_name[:-7]
            class_name = class_name[:-6]
        class_name = class_name + 'Factory'

        # Don't create any that are already defined.
        if class_name in namespace:
            continue

        # The class to wrap.
        klass = new.classobj(class_name,
                             (_AutomaticFilterFactory,),
                             {'__doc__': fil.help, }
                             )
        klass._metadata = fil

        # The mlab helper function.
        func = make_function(klass)

        # Inject class/function into the namespace and __all__.
        namespace[class_name] = klass
        namespace[func_name] = func
        __all__.append(func_name)

# Create the module related functions.
_make_functions(locals())

########NEW FILE########
__FILENAME__ = helper_functions
"""
Helper functions for mlab. These combine creation of the data sources,
and applying the modules to them to make standard visualization
operation. They should always return the module object created, for
consistency, and because retrieving the vtk data source from a module object
is possible via tools.get_vtk_src

Each helper function should have a test function associated with it,
both for testing and to ilustrate its use.
"""

# Author: Gael Varoquaux <gael.varoquaux@normalesup.org>
# Copyright (c) 2007, Enthought, Inc.
# License: BSD Style.

from modules import VectorsFactory, StreamlineFactory, GlyphFactory, \
            IsoSurfaceFactory, SurfaceFactory, ContourSurfaceFactory, \
            ImageActorFactory, glyph_mode_dict
from sources import vector_scatter, vector_field, scalar_scatter, \
            scalar_field, line_source, array2d_source, grid_source, \
            triangular_mesh_source, vertical_vectors_source
from filters import ExtractVectorNormFactory, WarpScalarFactory, \
            TubeFactory, ExtractEdgesFactory, PolyDataNormalsFactory, \
            StripperFactory
from animator import animate
from mayavi.core.scene import Scene
from auto_doc import traits_doc, dedent
import tools
from traits.api import Array, Callable, CFloat, HasTraits, \
    List, Trait, Any, Instance, TraitError, true
import numpy


def document_pipeline(pipeline):

    def the_function(*args, **kwargs):
        return pipeline(*args, **kwargs)

    if hasattr(pipeline, 'doc'):
        doc = pipeline.doc
    elif pipeline.__doc__ is not None:
        doc = pipeline.__doc__
    else:
        doc = ''

    the_function.__doc__ = dedent("""%s

    **Keyword arguments:**
    %s""") % (dedent(doc),
              traits_doc(pipeline.get_all_traits()),)

    return the_function


#############################################################################
class Pipeline(HasTraits):
    """ Function used to build pipelines for helper functions """
    #doc = ''
    _source_function = Callable()

    _pipeline = List()

    # Traits here only for documentation purposes
    figure = Instance('mayavi.core.scene.Scene',
                help='Figure to populate.')

    def __call__(self, *args, **kwargs):
        """ Calls the logics of the factory, but only after disabling
            rendering, if needed.
        """
        # First retrieve the scene, if any.
        if 'figure' in kwargs:
            figure = kwargs['figure']
            assert isinstance(figure, (Scene, None))
            scene = figure.scene
        else:
            scene = tools.gcf().scene
        if scene is not None:
            self._do_redraw = not scene.disable_render
            scene.disable_render = True
        # Then call the real logic
        output = self.__call_internal__(*args, **kwargs)
        # And re-enable the rendering, if needed.
        if scene is not None:
            scene.disable_render = not self._do_redraw
        return output

    def __call_internal__(self, *args, **kwargs):
        """ Builds the source and runs through the pipeline, returning
        the last object created by the pipeline."""
        self.store_kwargs(kwargs)
        self.source = self._source_function(*args, **kwargs)
        # Copy the pipeline so as not to modify it for the next call
        self.pipeline = self._pipeline[:]
        return self.build_pipeline()

    def store_kwargs(self, kwargs):
        """ Merges the given keyword argument, with traits default and
            store the resulting dictionary in self.kwargs."""
        kwargs = kwargs.copy()
        all_traits = self.get_all_traits()
        if not set(kwargs.keys()).issubset(all_traits.keys()):
            raise ValueError("Invalid keyword arguments : %s" % \
                    ', '.join(
                        str(k) for k in
                        set(kwargs.keys()).difference(all_traits.keys())))
        traits = self.get(self.class_trait_names())
        [traits.pop(key) for key in traits.keys() if key[0] == '_']
        traits.update(kwargs)
        self.kwargs = traits

    def build_pipeline(self):
        """ Runs through the pipeline, applying pipe after pipe. """
        object = self.source
        for pipe in self.pipeline:
            keywords = set(pipe.class_trait_names())
            keywords.remove('trait_added')
            keywords.remove('trait_modified')
            this_kwargs = {}
            for key, value in self.kwargs.iteritems():
                if key in keywords:
                    this_kwargs[key] = value
            object = pipe(object, **this_kwargs)._target
        return object

    def get_all_traits(self):
        """ Returns all the traits of class, and the classes in the pipeline.
        """
        traits = {}
        for pipe in self._pipeline:
            traits.update(pipe.class_traits())
        traits.update(self.class_traits())
        traits.pop('trait_added')
        traits.pop('trait_modified')
        return traits


#############################################################################
class Points3d(Pipeline):
    """
    Plots glyphs (like points) at the position of the supplied data.

    **Function signatures**::

        points3d(x, y, z...)
        points3d(x, y, z, s, ...)
        points3d(x, y, z, f, ...)

    x, y and z are numpy arrays, or lists, all of the same shape, giving
    the positions of the points.

    If only 3 arrays x, y, z are given, all the points are drawn with the
    same size and color.

    In addition, you can pass a fourth array s of the same
    shape as x, y, and z giving an associated scalar value for each
    point, or a function f(x, y, z) returning the scalar value. This
    scalar value can be used to modulate the color and the size of the
    points."""

    _source_function = Callable(scalar_scatter)

    _pipeline = [GlyphFactory, ]

    scale_factor = Any('auto', help='The scaling applied to the glyphs. '
                        'the size of the glyph is by default calculated '
                        'from the inter-glyph spacing. Specify a float to '
                        'give the maximum glyph size in drawing units'
                        )

    def __call_internal__(self, *args, **kwargs):
        """ Override the call to be able to scale automatically the glyphs.
        """
        scale_factor = kwargs.get('scale_factor', 'auto')
        if scale_factor == 'auto':
            kwargs['scale_factor'] = 1
        g = Pipeline.__call_internal__(self, *args, **kwargs)
        if scale_factor == 'auto':
            g.glyph.glyph.scale_factor = \
                             tools._typical_distance(g.mlab_source.dataset)
            g.glyph.glyph.clamping = True
        else:
            g.glyph.glyph.clamping = False
        return g

points3d = document_pipeline(Points3d())


def test_points3d():
    t = numpy.linspace(0, 4 * numpy.pi, 20)
    cos = numpy.cos
    sin = numpy.sin

    x = sin(2 * t)
    y = cos(t)
    z = cos(2 * t)
    s = 2 + sin(t)

    return points3d(x, y, z, s, colormap="copper", scale_factor=.25)

@animate
def test_points3d_anim(obj=None):
    """Animates the test_points3d example."""
    g = obj if obj is not None else test_points3d()
    t = numpy.linspace(0, 4 * numpy.pi, 20)
    # Animate the points3d.
    ms = g.mlab_source
    for i in range(10):
        ms.z = numpy.cos(2 * t * 0.1 * (i + 1))
        yield


def test_molecule():
    """Generates and shows a Caffeine molecule."""
    o = [[30, 62, 19], [8, 21, 10]]
    ox, oy, oz = map(numpy.array, zip(*o))
    n = [[31, 21, 11], [18, 42, 14], [55, 46, 17], [56, 25, 13]]
    nx, ny, nz = map(numpy.array, zip(*n))
    c = [[5, 49, 15], [30, 50, 16], [42, 42, 15], [43, 29, 13], [18, 28, 12],
         [32, 6, 8], [63, 36, 15], [59, 60, 20]]
    cx, cy, cz = map(numpy.array, zip(*c))
    h = [[23, 5, 7], [32, 0, 16], [37, 5, 0], [73, 36, 16], [69, 60, 20],
         [54, 62, 28], [57, 66, 12], [6, 59, 16], [1, 44, 22], [0, 49, 6]]
    hx, hy, hz = map(numpy.array, zip(*h))

    oxygen = points3d(ox, oy, oz, scale_factor=16, scale_mode='none',
                                resolution=20, color=(1, 0, 0), name='Oxygen')
    nitrogen = points3d(nx, ny, nz, scale_factor=20, scale_mode='none',
                                resolution=20, color=(0, 0, 1),
                                name='Nitrogen')
    carbon = points3d(cx, cy, cz, scale_factor=20, scale_mode='none',
                                resolution=20, color=(0, 1, 0), name='Carbon')
    hydrogen = points3d(hx, hy, hz, scale_factor=10, scale_mode='none',
                                resolution=20, color=(1, 1, 1),
                                name='Hydrogen')

    return oxygen, nitrogen, carbon, hydrogen

#############################################################################


class Quiver3D(Points3d):
    """
    Plots glyphs (like arrows) indicating the direction of the vectors
    at the positions supplied.

    **Function signatures**::

        quiver3d(u, v, w, ...)
        quiver3d(x, y, z, u, v, w, ...)
        quiver3d(x, y, z, f, ...)

    u, v, w are numpy arrays giving the components of the vectors.

    If only 3 arrays, u, v, and w are passed, they must be 3D arrays, and
    the positions of the arrows are assumed to be the indices of the
    corresponding points in the (u, v, w) arrays.

    If 6 arrays, (x, y, z, u, v, w) are passed, the 3 first arrays give
    the position of the arrows, and the 3 last the components. They
    can be of any shape.

    If 4 positional arguments, (x, y, z, f) are passed, the last one must be
    a callable, f, that returns vectors components (u, v, w) given the
    positions (x, y, z)."""

    scalars = Array(help="""optional scalar data.""")

    _source_function = Callable(vector_scatter)

    _pipeline = [VectorsFactory, ]


quiver3d = document_pipeline(Quiver3D())


def test_quiver3d():
    x, y, z = numpy.mgrid[-2:3, -2:3, -2:3]
    r = numpy.sqrt(x ** 2 + y ** 2 + z ** 4)
    u = y * numpy.sin(r) / (r + 0.001)
    v = -x * numpy.sin(r) / (r + 0.001)
    w = numpy.zeros_like(z)
    obj = quiver3d(x, y, z, u, v, w, line_width=3, scale_factor=1)
    return obj


def test_quiver3d_cone():
    xmin, xmax, ymin, ymax, zmin, zmax = [-5, 5, -5, 5, -5, 5]
    x, y, z = numpy.mgrid[-5:5:8j, -5:5:8j, -5:5:8j]
    x = x.astype('f')
    y = y.astype('f')
    z = z.astype('f')

    sin = numpy.sin
    cos = numpy.cos
    u = cos(x)
    v = sin(y)
    w = sin(x * z)

    obj = quiver3d(x, y, z, u, v, w, mode='cone', extent=(0, 1, 0, 1, 0, 1),
                   scale_factor=0.9)

    return obj


def test_quiver3d_2d_data():
    dims = [32, 32]
    xmin, xmax, ymin, ymax = [-5, 5, -5, 5]
    x, y = numpy.mgrid[xmin:xmax:dims[0] * 1j,
                       ymin:ymax:dims[1] * 1j]
    x = x.astype('f')
    y = y.astype('f')

    sin = numpy.sin
    cos = numpy.cos
    u = cos(x)
    v = sin(y)
    w = numpy.zeros_like(x)

    return quiver3d(x, y, w, u, v, w, colormap="Purples",
                                scale_factor=0.5, mode="2dthick_arrow")


#############################################################################
class Flow(Pipeline):
    """
    Creates a trajectory of particles following the flow of a vector field.

    **Function signatures**::

        flow(u, v, w, ...)
        flow(x, y, z, u, v, w, ...)
        flow(x, y, z, f, ...)

    u, v, w are numpy arrays giving the components of the vectors.

    If only 3 arrays, u, v, and w are passed, they must be 3D arrays, and
    the positions of the arrows are assumed to be the indices of the
    corresponding points in the (u, v, w) arrays.

    If 6 arrays, (x, y, z, u, v, w) are passed, the 3 first arrays give
    the position of the arrows, and the 3 last the components. The x, y
    and z arrays are then supposed to have been generated by
    `numpy.mgrid`, in other words, they are 3D arrays, with positions
    lying on a 3D orthogonal and regularly spaced grid with nearest
    neighbor in space matching nearest neighbor in the array. The
    function builds a vector field assuming  the points are regularly
    spaced.

    If 4 positional arguments, (x, y, z, f) are passed, the last one must be
    a callable, f, that returns vectors components (u, v, w) given the
    positions (x, y, z)."""

    scalars = Array(help="""optional scalar data.""")

    _source_function = Callable(vector_field)

    _pipeline = [ExtractVectorNormFactory, StreamlineFactory, ]

    def __call_internal__(self, *args, **kwargs):
        """ Override the call to be able to choose whether to apply an
        ExtractVectorNorm filter.
        """
        self.source = self._source_function(*args, **kwargs)
        kwargs.pop('name', None)
        self.store_kwargs(kwargs)
        # Copy the pipeline so as not to modify it for the next call
        self.pipeline = self._pipeline[:]
        if tools._has_scalar_data(self.source):
            self.pipeline.pop(0)
        return self.build_pipeline()

flow = document_pipeline(Flow())


def test_flow():
    x, y, z = numpy.mgrid[-4:4:40j, -4:4:40j, 0:4:20j]
    r = numpy.sqrt(x ** 2 + y ** 2 + z ** 2 + 0.1)
    u = y * numpy.sin(r) / r
    v = -x * numpy.sin(r) / r
    w = numpy.ones_like(z)*0.05
    obj = flow(u, v, w)
    return obj


def test_flow_tubes():
    dims = [32, 32, 32]
    xmin, xmax, ymin, ymax, zmin, zmax = [-5, 5, -5, 5, -5, 5]
    x, y, z = numpy.mgrid[xmin:xmax:dims[0] * 1j,
                          ymin:ymax:dims[1] * 1j,
                          zmin:zmax:dims[2] * 1j]
    x = x.astype('f')
    y = y.astype('f')
    z = z.astype('f')

    sin = numpy.sin
    cos = numpy.cos
    u = cos(x / 2.)
    v = sin(y / 2.)
    w = sin(x * z / 4.)

    obj = flow(x, y, z, u, v, w, linetype='tube')
    return obj


@animate
def test_flow_anim(obj=None):
    obj = obj if obj is not None else test_flow_tubes()
    # Now animate the flow.
    ms = obj.mlab_source
    x, y, z = ms.x, ms.y, ms.z
    for i in range(10):
        u = numpy.cos(x / 2. + numpy.pi * (i + 1) / 10.)
        w = numpy.sin(x * z / 4. + numpy.pi * (i + 1) / 10.)
        ms.set(u=u, w=w)
        yield


def test_flow_scalars():
    dims = [32, 32, 32]
    xmin, xmax, ymin, ymax, zmin, zmax = [-5, 5, -5, 5, -5, 5]
    x, y, z = numpy.mgrid[xmin:xmax:dims[0] * 1j,
                          ymin:ymax:dims[1] * 1j,
                          zmin:zmax:dims[2] * 1j]
    x = x.astype('f')
    y = y.astype('f')
    z = z.astype('f')

    sin = numpy.sin
    cos = numpy.cos
    u = cos(x / 2.)
    v = sin(y / 2.)
    w = sin(x * z / 8.)
    t = x * z

    obj = flow(u, v, w, scalars=t, seedtype='plane',
               linetype='tube', colormap='Spectral')

    return obj


#############################################################################
class Contour3d(Pipeline):
    """
    Plots iso-surfaces for a 3D volume of data suplied as arguments.

    **Function signatures**::

        contour3d(scalars, ...)
        contour3d(x, y, z, scalars, ...)

    scalars is a 3D numpy arrays giving the data on a grid.

    If 4 arrays, (x, y, z, scalars) are passed, the 3 first arrays give
    the position of the arrows, and the last the scalar value. The x, y
    and z arrays are then supposed to have been generated by
    `numpy.mgrid`, in other words, they are 3D arrays, with positions
    lying on a 3D orthogonal and regularly spaced grid with nearest
    neighbor in space matching nearest neighbor in the array. The
    function builds a scalar field assuming  the points are regularly
    spaced.

    If 4 positional arguments, (x, y, z, f) are passed, the last one
    can also be a callable, f, that returns vectors components (u, v, w)
    given the positions (x, y, z)."""

    _source_function = Callable(scalar_field)

    _pipeline = [IsoSurfaceFactory, ]


contour3d = document_pipeline(Contour3d())


def test_contour3d():
    x, y, z = numpy.ogrid[-5:5:64j, -5:5:64j, -5:5:64j]

    scalars = x * x * 0.5 + y * y + z * z * 2.0

    obj = contour3d(scalars, contours=4, transparent=True)
    return obj


@animate
def test_contour3d_anim(obj=None):
    obj = obj if obj is not None else test_contour3d()
    x, y, z = numpy.ogrid[-5:5:64j, -5:5:64j, -5:5:64j]
    # Now animate the contours.
    ms = obj.mlab_source
    for i in range(1, 10):
        ms.scalars = x * x * 0.5 + y * x * 0.1 * (i + 1) + z * z * 0.25
        yield


#############################################################################
class Plot3d(Pipeline):
    """
    Draws lines between points.

    **Function signatures**::

        plot3d(x, y, z, ...)
        plot3d(x, y, z, s, ...)

    x, y, z and s are numpy arrays or lists of the same shape. x, y and z
    give the positions of the successive points of the line. s is an
    optional scalar value associated with each point."""

    tube_radius = Trait(0.025, CFloat, None,
                        adapts='filter.radius',
                        help="""radius of the tubes used to represent the
                        lines, If None, simple lines are used.
                        """)

    _source_function = Callable(line_source)

    _pipeline = [StripperFactory, TubeFactory, SurfaceFactory, ]

    def __call_internal__(self, *args, **kwargs):
        """ Override the call to be able to choose whether to apply
        filters.
        """
        self.source = self._source_function(*args, **kwargs)
        kwargs.pop('name', None)
        self.store_kwargs(kwargs)
        # Copy the pipeline so as not to modify it for the next call
        self.pipeline = self._pipeline[:]
        if self.kwargs['tube_radius'] == None:
            self.pipeline.remove(TubeFactory)
            self.pipeline.remove(StripperFactory)
        return self.build_pipeline()


plot3d = document_pipeline(Plot3d())


def test_plot3d():
    """Generates a pretty set of lines."""
    n_mer, n_long = 6, 11
    pi = numpy.pi
    dphi = pi / 1000.0
    phi = numpy.arange(0.0, 2 * pi + 0.5 * dphi, dphi)
    mu = phi * n_mer
    x = numpy.cos(mu) * (1 + numpy.cos(n_long * mu / n_mer) * 0.5)
    y = numpy.sin(mu) * (1 + numpy.cos(n_long * mu / n_mer) * 0.5)
    z = numpy.sin(n_long * mu / n_mer) * 0.5

    l = plot3d(x, y, z, numpy.sin(mu), tube_radius=0.025, colormap='Spectral')
    return l

@animate
def test_plot3d_anim(obj=None):
    """Generates a pretty set of lines and animates it."""

    # Run the standard example and get the module generated.
    obj = obj if obj is not None else test_plot3d()

    # Some data from the test example for the animation.
    n_mer, n_long = 6, 11
    pi = numpy.pi
    dphi = pi / 1000.0
    phi = numpy.arange(0.0, 2 * pi + 0.5 * dphi, dphi, 'd')
    mu = phi * n_mer

    # Now animate the data.
    ms = obj.mlab_source
    for i in range(10):
        x = numpy.cos(mu) * (1 + numpy.cos(n_long * mu / n_mer +
                                          numpy.pi * (i + 1) / 5.) * 0.5)
        scalars = numpy.sin(mu + numpy.pi * (i + 1) / 5)
        ms.set(x=x, scalars=scalars)
        yield

#############################################################################
class ImShow(Pipeline):
    """
    View a 2D array as an image.

    **Function signatures**::

        imshow(s, ...)

    s is a 2 dimension array. The values of s are mapped to a color using
    the colormap."""

    _source_function = Callable(array2d_source)

    _pipeline = [ImageActorFactory, ]


imshow = document_pipeline(ImShow())


def test_imshow():
    """ Use imshow to visualize a 2D 10x10 random array.
    """
    s = numpy.random.random((10, 10))
    return imshow(s, colormap='gist_earth')


#############################################################################
class Surf(Pipeline):
    """
    Plots a surface using regularly-spaced elevation data supplied as a 2D
    array.

    **Function signatures**::

        surf(s, ...)
        surf(x, y, s, ...)
        surf(x, y, f, ...)

    s is the elevation matrix, a 2D array, where indices along the first
    array axis represent x locations, and indices along the second array
    axis represent y locations.

    x and y can be 1D or 2D arrays such as returned by numpy.ogrid or
    numpy.mgrid. Arrays returned by numpy.meshgrid require a transpose
    first to obtain correct indexing order.
    The points should be located on an orthogonal grid (possibly
    non-uniform). In other words, all the points sharing a same
    index in the s array need to have the same x or y value. For
    arbitrary-shaped position arrays (non-orthogonal grids), see the mesh
    function.

    If only 1 array s is passed, the x and y arrays are assumed to be
    made from the indices of arrays, and an uniformly-spaced data set is
    created.

    If 3 positional arguments are passed the last one must be an array s,
    or a callable, f, that returns an array. x and y give the
    coordinates of positions corresponding to the s values."""

    _source_function = Callable(array2d_source)

    _pipeline = [WarpScalarFactory, PolyDataNormalsFactory, SurfaceFactory]

    warp_scale = Any(1, help="""scale of the z axis (warped from
                        the value of the scalar). By default this scale
                        is a float value.

                        If you specify 'auto', the scale is calculated to
                        give a pleasant aspect ratio to the plot,
                        whatever the bounds of the data.

                        If you specify a value for warp_scale in
                        addition to an extent, the warp scale will be
                        determined by the warp_scale, and the plot be
                        positioned along the z axis with the zero of the
                        data centered on the center of the extent. If you
                        are using explicit extents, this is the best way
                        to control the vertical scale of your plots.

                        If you want to control the extent (or range)
                        of the surface object, rather than its scale,
                        see the `extent` keyword argument.
                        """)

    mask = Array(help="""boolean mask array to suppress some data points.
                 Note: this works based on colormapping of scalars and will
                 not work if you specify a solid color using the
                 `color` keyword.""")

    def __call_internal__(self, *args, **kwargs):
        """ Override the call to be able to scale automatically the axis.
        """
        self.source = self._source_function(*args, **kwargs)
        kwargs.pop('name', None)
        # Deal with both explicit warp scale and extent, this is
        # slightly hairy. The wigner example is a good test case for
        # this.
        if not 'warp_scale' in kwargs and not 'extent' in kwargs:
            try:
                xi, xf, yi, yf, _, _ = self.source.data.bounds
                zi, zf = self.source.data.scalar_range
            except AttributeError:
                xi, xf, yi, yf, _, _ = self.source.image_data.bounds
                zi, zf = self.source.image_data.scalar_range
            aspect_ratios = [(zf - zi) / (xf - xi), (zf - zi) / (yf - yi)]
            if min(aspect_ratios) < 0.01 or max(aspect_ratios) > 100:
                print 'Warning: the range of your scalar values differs by ' \
                'more than a factor 100 than the range of the grid values ' \
                'and you did not '\
                'specify a warp_scale. You could try warp_scale="auto".'
        if 'warp_scale' in kwargs and not kwargs['warp_scale'] == 'auto' \
                and 'extent' in kwargs:
            # XXX: I should use the logging module.
            print 'Warning: both warp_scale and extent keyword argument ' \
            'specified, the z bounds of the extents will be overridden'
            xi, xf, yi, yf, zi, zf = kwargs['extent']
            zo = 0.5 * (zi + zf)
            try:
                si, sf = self.source.data.scalar_range
            except AttributeError:
                si, sf = self.source.image_data.scalar_range
            z_span = kwargs['warp_scale'] * abs(sf - si)
            zi = zo + si * kwargs['warp_scale']
            zf = zi + z_span
            kwargs['extent'] = (xi, xf, yi, yf, zi, zf)
            kwargs['warp_scale'] = 1
        elif kwargs.get('warp_scale', 1) == 'auto':
            if 'extent' in kwargs:
                if 'warp_scale' in kwargs:
                    print "Warning: extent specified, warp_scale='auto' " \
                    "ignored."
            else:
                try:
                    xi, xf, yi, yf, _, _ = self.source.data.bounds
                    zi, zf = self.source.data.scalar_range
                except AttributeError:
                    xi, xf, yi, yf, _, _ = self.source.image_data.bounds
                    zi, zf = self.source.image_data.scalar_range
                z0 = zf - zi
                dz = 0.3 * ((xf - xi) + (yf - yi))
                zi = z0 - 0.5 * dz
                zf = z0 + 0.5 * dz
                kwargs['extent'] = (xi, xf, yi, yf, zi, zf)
            kwargs['warp_scale'] = 1.
        self.store_kwargs(kwargs)

        # Copy the pipeline so as not to modify it for the next call
        self.pipeline = self._pipeline[:]
        return self.build_pipeline()


surf = document_pipeline(Surf())


def test_simple_surf():
    """Test Surf with a simple collection of points."""
    x, y = numpy.mgrid[0:3:1, 0:3:1]
    return surf(x, y, numpy.asarray(x, 'd'))

@animate
def test_simple_surf_anim(obj=None):
    """Test Surf with a simple collection of points and animate it."""
    obj = obj if obj is not None else test_simple_surf()

    ms = obj.mlab_source
    x = ms.x
    for i in range(10):
        ms.scalars = numpy.asarray(x * 0.1 * (i + 1), 'd')
        yield


def test_surf():
    """Test surf on regularly spaced co-ordinates like MayaVi."""
    def f(x, y):
        sin, cos = numpy.sin, numpy.cos
        return sin(x + y) + sin(2 * x - y) + cos(3 * x + 4 * y)

    x, y = numpy.mgrid[-7.:7.05:0.1, -5.:5.05:0.05]
    s = surf(x, y, f)
    #cs = contour_surf(x, y, f, contour_z=0)
    return s


def test_surf_wigner():
    def cat(x, y, alpha=2, eta=1, purity=1):
        """ Multiphoton shrodinger cat. eta is the fidelity, alpha the number
            of photons"""
        cos = numpy.cos
        exp = numpy.exp
        return (1 + eta * (exp(-x ** 2 - (y - alpha) ** 2)
                + exp(-x ** 2 - (y + alpha) ** 2)
                + 2 * purity * exp(-x ** 2 - y ** 2) *
                        cos(2 * alpha * x)) / (2 * (1 + exp(-alpha ** 2)))) / 2
    x, y = numpy.mgrid[-5:5:0.1, -5:5:0.1]
    return surf(x, y, cat)


#############################################################################
class Mesh(Pipeline):
    """
    Plots a surface using grid-spaced data supplied as 2D arrays.

    **Function signatures**::

        mesh(x, y, z, ...)

    x, y, z are 2D arrays, all of the same shape, giving the positions of
    the vertices of the surface. The connectivity between these points is
    implied by the connectivity on the arrays.

    For simple structures (such as orthogonal grids) prefer the `surf`
    function, as it will create more efficient data structures. For mesh
    defined by triangles rather than regular implicit connectivity, see the
    `triangular_mesh` function.
    """

    scale_mode = Trait('none', {'none': 'data_scaling_off',
                                'scalar': 'scale_by_scalar',
                                'vector': 'scale_by_vector'},
                            help="""the scaling mode for the glyphs
                            ('vector', 'scalar', or 'none').""")

    scale_factor = CFloat(0.05,
                        desc="""scale factor of the glyphs used to represent
                        the vertices, in fancy_mesh mode. """)

    tube_radius = Trait(0.025, CFloat, None,
                        help="""radius of the tubes used to represent the
                        lines, in mesh mode. If None, simple lines are used.
                        """)

    scalars = Array(help="""optional scalar data.""")

    mask = Array(help="""boolean mask array to suppress some data points.
                 Note: this works based on colormapping of scalars and will
                 not work if you specify a solid color using the
                 `color` keyword.""")

    representation = Trait('surface', 'wireframe', 'points', 'mesh',
                    'fancymesh',
                    desc="""the representation type used for the surface.""")

    _source_function = Callable(grid_source)

    _pipeline = [ExtractEdgesFactory, GlyphFactory, TubeFactory,
                        SurfaceFactory]

    def __call_internal__(self, *args, **kwargs):
        """ Override the call to be able to choose whether to apply
        filters.
        """
        self.source = self._source_function(*args, **kwargs)
        kwargs.pop('name', None)
        self.store_kwargs(kwargs)
        # Copy the pipeline so as not to modify it for the next call
        self.pipeline = self._pipeline[:]
        if not self.kwargs['representation'] in ('mesh', 'fancymesh'):
            self.pipeline.remove(ExtractEdgesFactory)
            self.pipeline.remove(TubeFactory)
            self.pipeline.remove(GlyphFactory)
            self.pipeline = [PolyDataNormalsFactory, ] + self.pipeline
        else:
            if self.kwargs['tube_radius'] == None:
                self.pipeline.remove(TubeFactory)
            if not self.kwargs['representation'] == 'fancymesh':
                self.pipeline.remove(GlyphFactory)
            self.kwargs['representation'] = 'surface'
        return self.build_pipeline()


mesh = document_pipeline(Mesh())


def test_mesh():
    """A very pretty picture of spherical harmonics translated from
    the octaviz example."""
    pi = numpy.pi
    cos = numpy.cos
    sin = numpy.sin
    dphi, dtheta = pi / 250.0, pi / 250.0
    [phi, theta] = numpy.mgrid[0:pi + dphi * 1.5:dphi,
                               0:2 * pi + dtheta * 1.5:dtheta]
    m0 = 4
    m1 = 3
    m2 = 2
    m3 = 3
    m4 = 6
    m5 = 2
    m6 = 6
    m7 = 4
    r = sin(m0 * phi) ** m1 + cos(m2 * phi) ** m3 + \
        sin(m4 * theta) ** m5 + cos(m6 * theta) ** m7
    x = r * sin(phi) * cos(theta)
    y = r * cos(phi)
    z = r * sin(phi) * sin(theta)

    return mesh(x, y, z, colormap="bone")


def test_mesh_sphere(r=1.0, npts=(100, 100), colormap='jet'):
    """Create a simple sphere."""
    pi = numpy.pi
    cos = numpy.cos
    sin = numpy.sin
    np_phi = npts[0] * 1j
    np_theta = npts[1] * 1j
    phi, theta = numpy.mgrid[0:pi:np_phi, 0:2 * pi:np_theta]
    x = r * sin(phi) * cos(theta)
    y = r * sin(phi) * sin(theta)
    z = r * cos(phi)
    return mesh(x, y, z, colormap=colormap)

@animate
def test_mesh_sphere_anim(obj=None, r=1.0, npts=(100, 100), colormap='jet'):
    """Create a simple sphere and animate it."""
    obj = obj if obj is not None else test_mesh_sphere(r, npts, colormap)
    pi = numpy.pi
    cos = numpy.cos
    np_phi = npts[0] * 1j
    np_theta = npts[1] * 1j
    phi, theta = numpy.mgrid[0:pi:np_phi, 0:2 * pi:np_theta]

    ms = obj.mlab_source
    for i in range(1, 10):
        z = (r + i * 0.25) * cos(phi)
        ms.set(z=z, scalars=z)
        yield

def test_mesh_mask_custom_colors(r=1.0, npts=(100, 100)):
    """Create a sphere with masking and using a custom colormap.

    Note that masking works only when scalars are set.  The custom colormap
    illustrates how one can completely customize the colors with numpy arrays.
    In this case we use a simple 2 color colormap.
    """
    # Create the data like for test_mesh_sphere.
    pi = numpy.pi
    cos = numpy.cos
    sin = numpy.sin
    np_phi = npts[0] * 1j
    np_theta = npts[1] * 1j
    phi, theta = numpy.mgrid[0:pi:np_phi, 0:2 * pi:np_theta]
    x = r * sin(phi) * cos(theta)
    y = r * sin(phi) * sin(theta)
    z = r * cos(phi)

    # Setup the mask array.
    mask = numpy.zeros_like(x).astype(bool)
    mask[::5] = True
    mask[:,::5] = True

    # Create the mesh with the default colormapping.
    m = mesh(x, y, z, scalars=z, mask=mask)

    # Setup the colormap. This is an array of (R, G, B, A) values (each in
    # range 0-255), there should be at least 2 colors in the array.  If you
    # want a constant color set the two colors to the same value.
    colors = numpy.zeros((2, 4), dtype='uint8')
    colors[0,2] = 255
    colors[1,1] = 255
    # Set the alpha value to fully visible.
    colors[:,3] = 255

    # Now setup the lookup table to use these colors.
    m.module_manager.scalar_lut_manager.lut.table = colors
    return m


def test_fancy_mesh():
    """Create a fancy looking mesh using mesh (example taken from octaviz)."""
    pi = numpy.pi
    cos = numpy.cos
    du, dv = pi / 20.0, pi / 20.0
    u, v = numpy.mgrid[0.01:pi + du * 1.5:du, 0:2 * pi + dv * 1.5:dv]
    x = (1 - cos(u)) * cos(u + 2 * pi / 3) * cos(v + 2 * pi / 3.0) * 0.5
    y = (1 - cos(u)) * cos(u + 2 * pi / 3) * cos(v - 2 * pi / 3.0) * 0.5
    z = -cos(u - 2 * pi / 3.)

    m = mesh(x, y, z, representation='fancymesh',
                   tube_radius=0.0075, colormap="RdYlGn")
    return m


#############################################################################
class ContourSurf(Pipeline):
    """
    Plots a the contours of a surface using grid-spaced data for
    elevation supplied as a 2D array.

    **Function signatures**::

        contour_surf(s, ...)
        contour_surf(x, y, s, ...)
        contour_surf(x, y, f, ...)

    s is the elevation matrix, a 2D array. The contour lines plotted
    are lines of equal s value.

    x and y can be 1D or 2D arrays (such as returned by numpy.ogrid or
    numpy.mgrid), but the points should be located on an orthogonal grid
    (possibly non-uniform). In other words, all the points sharing a same
    index in the s array need to have the same x or y value. For
    arbitrary-shaped position arrays (non-orthogonal grids), see the mesh
    function.

    If only 1 array s is passed, the x and y arrays are assumed to be
    made from the indices of arrays, and an uniformly-spaced data set is
    created.

    If 3 positional arguments are passed the last one must be an array s,
    or a callable, f, that returns an array. x and y give the
    coordinates of positions corresponding to the s values."""

    _source_function = Callable(array2d_source)

    _pipeline = [WarpScalarFactory, ContourSurfaceFactory]


contour_surf = document_pipeline(ContourSurf())


def test_contour_surf():
    """Test contour_surf on regularly spaced co-ordinates like MayaVi."""
    def f(x, y):
        sin, cos = numpy.sin, numpy.cos
        return sin(x + y) + sin(2 * x - y) + cos(3 * x + 4 * y)

    x, y = numpy.mgrid[-7.:7.05:0.1, -5.:5.05:0.05]
    s = contour_surf(x, y, f)
    return s

#############################################################################

# Expose only the glyphs that make (more or less) sense for a barchart.
bar_mode_dict = dict()
for item in ('cube', '2dtriangle', '2dsquare', '2dvertex', '2dthick_cross',
             '2ddiamond', '2dcross', '2dcircle'):
    bar_mode_dict[item] = glyph_mode_dict[item]


class BarChart(Pipeline):
    """
    Plots vertical glyphs (like bars) scaled vertical, to do
    histogram-like plots.

    This functions accepts a wide variety of inputs, with positions given
    in 2-D or in 3-D.

    **Function signatures**::

        barchart(s, ...)
        barchart(x, y, s, ...)
        barchart(x, y, f, ...)
        barchart(x, y, z, s, ...)
        barchart(x, y, z, f, ...)

    If only one positional argument is passed, it can be a 1-D, 2-D, or 3-D
    array giving the length of the vectors. The positions of the data
    points are deducted from the indices of array, and an
    uniformly-spaced data set is created.

    If 3 positional arguments (x, y, s) are passed the last one must be
    an array s, or a callable, f, that returns an array. x and y give the
    2D coordinates of positions corresponding to the s values.

    If 4 positional arguments (x, y, z, s) are passed, the 3 first are
    arrays giving the 3D coordinates of the data points, and the last one
    is an array s, or a callable, f, that returns an array giving the
    data value.
    """

    _source_function = Callable(vertical_vectors_source)

    _pipeline = [VectorsFactory, ]

    mode = Trait('cube', bar_mode_dict,
                    desc='The glyph used to represent the bars.')

    lateral_scale = CFloat(0.9, desc='The lateral scale of the glyph, '
                'in units of the distance between nearest points')

    auto_scale = true(desc='whether to compute automatically the '
                           'lateral scaling of the glyphs. This might be '
                           'computationally expensive.')

    def __call_internal__(self, *args, **kwargs):
        """ Override the call to be able to scale automatically the axis.
        """
        g = Pipeline.__call_internal__(self, *args, **kwargs)
        gs = g.glyph.glyph_source
        # Use a cube source for glyphs.
        if not 'mode' in kwargs:
            gs.glyph_source = gs.glyph_dict['cube_source']
        # Position the glyph tail on the point.
        gs.glyph_position = 'tail'
        gs.glyph_source.center = (0.0, 0.0, 0.5)
        g.glyph.glyph.orient = False
        if not 'color' in kwargs:
            g.glyph.color_mode = 'color_by_scalar'
        if not 'scale_mode' in kwargs:
            g.glyph.scale_mode = 'scale_by_vector_components'
        g.glyph.glyph.clamping = False
        # The auto-scaling code. It involves finding the minimum
        # distance between points, which can be very expensive. We
        # shortcut this calculation for structured data
        if len(args) == 1 or self.auto_scale:
            min_axis_distance = 1
        else:
            x, y, z = g.mlab_source.x, g.mlab_source.y, g.mlab_source.z
            min_axis_distance = \
                    tools._min_axis_distance(x, y, z)
        scale_factor = g.glyph.glyph.scale_factor * min_axis_distance
        lateral_scale = kwargs.pop('lateral_scale', self.lateral_scale)
        try:
            g.glyph.glyph_source.glyph_source.y_length = \
                    lateral_scale / (scale_factor)
            g.glyph.glyph_source.glyph_source.x_length = \
                    lateral_scale / (scale_factor)
        except TraitError:
            " Not all types of glyphs have controlable y_length and x_length"

        return g

barchart = document_pipeline(BarChart())


def test_barchart():
    """ Demo the bar chart plot with a 2D array.
    """
    s = numpy.abs(numpy.random.random((3, 3)))
    return barchart(s)


#############################################################################
class TriangularMesh(Mesh):
    """
    Plots a surface using a mesh defined by the position of its vertices
    and the triangles connecting them.

    **Function signatures**::

        triangular_mesh(x, y, z, triangles ...)

    x, y, z are arrays giving the positions of the vertices of the surface.
    triangles is a list of triplets (or an array) list the vertices in
    each triangle. Vertices are indexes by their appearance number in the
    position arrays.

    For simple structures (such as rectangular grids) prefer the surf or
    mesh functions, as they will create more efficient data structures.
    """

    _source_function = Callable(triangular_mesh_source)

triangular_mesh = document_pipeline(TriangularMesh())


def test_triangular_mesh():
    """An example of a cone, ie a non-regular mesh defined by its
        triangles.
    """
    n = 8
    t = numpy.linspace(-numpy.pi, numpy.pi, n)
    z = numpy.exp(1j * t)
    x = z.real.copy()
    y = z.imag.copy()
    z = numpy.zeros_like(x)

    triangles = [(0, i, i + 1) for i in range(1, n)]
    x = numpy.r_[0, x]
    y = numpy.r_[0, y]
    z = numpy.r_[1, z]
    t = numpy.r_[0, t]

    return triangular_mesh(x, y, z, triangles, scalars=t)

########NEW FILE########
__FILENAME__ = mlab
# Author: Gael Varoquaux <gael.varoquaux at normalesup.org>
# Copyright (c) 2007, Enthought, Inc.
# License: BSD Style.

print "!! mayavi.tools.mlab is obsolete and has been replaced by !!"
print "!! mayavi.mlab. Please update your code.                  !!"

from mayavi.mlab import *

########NEW FILE########
__FILENAME__ = mlab_scene_model
"""`MlabSceneModel` makes it easy to plug `mayavi.mlab` in traits UI views.
"""
# Authors: Prabhu Ramachandran <prabhu [at] aero.iitb.ac.in>
# Copyright (c) 2007, Enthought, Inc.
# License: BSD Style.

from traits.api import Instance, Property
from tvtk.pyface.scene_model import SceneModel
from mayavi.core.engine import Engine
from mayavi.core.scene import Scene
from mayavi import mlab as m2_mlab


######################################################################
# `MlabSceneModel` class
######################################################################
class MlabSceneModel(SceneModel):
    """ An container for an mlab model, that can be exposed using a Mayavi
        scene in a TraitsUI view.
    """

    # The mayavi engine.
    engine = Instance(Engine)

    # The mlab instance.
    mlab = Property()

    # A reference to the mayavi scene object
    mayavi_scene = Instance(Scene)

    def __init__(self, parent=None, **traits):
        super(MlabSceneModel, self).__init__(parent, **traits)
        # Store the current mlab figure:
        current_figure = self.engine.current_scene
        # register ourselves with the engine.
        self.engine.new_scene(self)
        # XXX: This is not thread-safe
        self.mayavi_scene = self.engine.current_scene
        # Restore the current figure. We do this, because MlabSceneModel
        # can be created lazy by Traits, on access. Having side effects
        # thus renders the code quite unpredictable
        self.engine.current_scene = current_figure

    ###################################################################
    # Private API.
    ###################################################################
    def _engine_default(self):
        return m2_mlab.get_engine()

    def _get_mlab(self):
        return m2_mlab

########NEW FILE########
__FILENAME__ = modules
"""
Modules factories and their associated functions for mlab.

Module functions meant to be applied to a data source object or a filter
should take only one positional argument, the input, to be easily used in
helper functions.
"""

# Author: Gael Varoquaux <gael.varoquaux@normalesup.org>
#         Prabhu Ramachandran
# Copyright (c) 2007-2008, Enthought, Inc.
# License: BSD Style.

import numpy
import new

from traits.api import Trait, CArray, Instance, CFloat, \
    Any, false, true, TraitTuple, Range, Bool, Property, CInt, Enum, Either
from traits.trait_errors import TraitError
from tvtk.api import tvtk
from tvtk.common import camel2enthought

from mayavi.core.lut_manager import lut_mode_list
import mayavi.modules.api as modules
from mayavi.core.registry import registry
import tools
from pipe_base import PipeFactory, make_function


# This the list is dynamically populated further down below at the end.
__all__ = ['vectors', 'glyph', 'streamline', 'surface', 'iso_surface',
            'image_actor', 'contour_surface', 'contour_grid_plane',
            'custom_grid_plane', 'image_plane_widget',
            'scalar_cut_plane', 'vector_cut_plane', 'volume',
            ]

##############################################################################
# Abstract module classes
##############################################################################


class ModuleFactory(PipeFactory):
    """ Base class for all the modules factories"""
    color = Trait(None, None,
                TraitTuple(Range(0., 1.), Range(0., 1.), Range(0., 1.)),
                help="""the color of the vtk object. Overides the colormap,
                        if any, when specified. This is specified as a
                        triplet of float ranging from 0 to 1, eg (1, 1,
                        1) for white.""", )

    def _color_changed(self):
        if self.color:
            self._target.actor.property.color = self.color
            if hasattr(self._target.actor.mapper, "scalar_visibility"):
                self._target.actor.mapper.scalar_visibility = False
            if hasattr(self._target, "property"):
                self._target.property.color = self.color

    opacity = CFloat(1.,
                desc="""The overall opacity of the vtk object.""")

    def _opacity_changed(self):
        try:
            self._target.actor.property.opacity = self.opacity
        except AttributeError:
            try:
                self._target.property.opacity = self.opacity
            except AttributeError:
                pass

    line_width = CFloat(2.,
                desc=""" The width of the lines, if any used.""")

    def _line_width_changed(self):
        try:
            self._target.actor.property.line_width = self.line_width
        except (AttributeError, TraitError):
            try:
                self._target.property.line_width = self.line_width
            except (AttributeError, TraitError):
                pass


##############################################################################
class DataModuleFactory(ModuleFactory):
    """ Base class for all the module factories operating on data (ie not
        text and outline) """

    reset_zoom = true(help="""Reset the zoom to accomodate the data newly
                        added to the scene. Defaults to True.""")

    extent = CArray(shape=(6,),
                    help="""[xmin, xmax, ymin, ymax, zmin, zmax]
                            Default is the x, y, z arrays extent. Use
                            this to change the extent of the object
                            created.""", )

    def _extent_changed(self):
        tools.set_extent(self._target, self.extent)

    transparent = false(help="""make the opacity of the actor depend on the
                               scalar.""")

    def _transparent_changed(self):
        if self.transparent:
            data_range = \
                self._target.module_manager.scalar_lut_manager.data_range
            self._target.module_manager.scalar_lut_manager.lut.alpha_range = \
                                                                (0.2, 0.8)
            data_range = (numpy.mean(data_range)
                            + 0.4 * (data_range.max() - data_range.min())
                                * numpy.array([-1, 1]))
            self._target.module_manager.scalar_lut_manager.data_range = \
                data_range

    colormap = Trait('blue-red', lut_mode_list(),
                        help="""type of colormap to use.""")

    def _colormap_changed(self):
        colormap = self.colormap
        if colormap[-2:] == "_r":
            colormap = colormap[:-2]
            self._target.module_manager.scalar_lut_manager.reverse_lut = True
            self._target.module_manager.vector_lut_manager.reverse_lut = True
        self._target.module_manager.scalar_lut_manager.lut_mode = colormap
        self._target.module_manager.vector_lut_manager.lut_mode = colormap

    vmin = Trait(None, None, CFloat,
                    help="""vmin is used to scale the colormap.
                            If None, the min of the data will be used""")

    vmax = Trait(None, None, CFloat,
                    help="""vmax is used to scale the colormap.
                            If None, the max of the data will be used""")

    def _vmin_changed(self):
        if self.vmin == None and self.vmax == None:
            self._target.module_manager.scalar_lut_manager.use_default_range\
                    = True
            return

        self._target.module_manager.scalar_lut_manager.use_default_range \
                    = False
        vmin, vmax = \
                self._target.module_manager.scalar_lut_manager.data_range
        if self.vmin is not None:
            vmin = self.vmin
        if self.vmax is not None:
            vmax = self.vmax
        self._target.module_manager.scalar_lut_manager.data_range = \
                        (vmin, vmax)

    _vmax_changed = _vmin_changed

    def __init__(self, *args, **kwargs):
        super(DataModuleFactory, self).__init__(*args, **kwargs)
        # We are adding data to the scene, reset the zoom:
        scene = self._scene.scene
        if scene is not None and self.reset_zoom:
            scene.reset_zoom()


class ContourModuleFactory(DataModuleFactory):
    """ Base class for all the module factories with contours """

    contours = Any(5, help="""Integer/list specifying number/list of
                    contours. Specifying a list of values will only
                    give the requested contours asked for.""")

    def _contours_changed(self):
        contour_list = True
        try:
            len(self.contours)
        except TypeError:
            contour_list = False

        if contour_list:
            self._target.contour.auto_contours = False
            self._target.contour.contours = self.contours
        else:
            assert type(self.contours) == int, \
                            "The contours argument must be an integer"
            assert self.contours > 0, "The contours argument must be positive"
            self._target.contour.set(auto_contours=True,
                                number_of_contours=self.contours)
        if hasattr(self._target, 'enable_contours'):
            self._target.enable_contours = True


##############################################################################
class CutPlaneFactory(DataModuleFactory):
    """ Base class for modules with a cut plane.
    """

    plane_orientation = Enum('x_axes', 'y_axes', 'z_axes',
                        desc="""the orientation of the plane""")

    view_controls = Bool(True, adapts='implicit_plane.visible',
                     desc=("Whether or not the controls of the "
                           "cut plane are shown."))

    def _plane_orientation_changed(self):
        choices = dict(x_axes=numpy.array([1.,  0.,  0.]),
                       y_axes=numpy.array([0.,  1.,  0.]),
                       z_axes=numpy.array([0.,  0.,  1.]))
        self._target.implicit_plane.normal = \
                                choices[self.plane_orientation]


##############################################################################
# Concrete module classes
##############################################################################

# The list of possible glyph modes
glyph_mode_dict = {'2darrow': 0, '2dcircle': 0, '2dcross': 0,
                            '2ddash': 0, '2ddiamond': 0,
                            '2dhooked_arrow': 0, '2dsquare': 0,
                            '2dthick_arrow': 0, '2dthick_cross': 0,
                            '2dtriangle': 0, '2dvertex': 0,
                            'arrow': 1, 'cone': 2, 'cylinder': 3,
                            'sphere': 4, 'cube': 5, 'axes': 6, 'point': 7}


##############################################################################
class VectorsFactory(DataModuleFactory):
    """Applies the Vectors mayavi module to the given data object
        source (Mayavi source, or VTK dataset).
    """

    _target = Instance(modules.Vectors, ())

    scale_factor = CFloat(1., adapts='glyph.glyph.scale_factor',
                            desc="""the scaling applied to the glyphs. The
                                    size of the glyph is by default in drawing
                                    units.""")

    scale_mode = Trait('vector', {'none': 'data_scaling_off',
                                'scalar': 'scale_by_scalar',
                                'vector': 'scale_by_vector'},
                            help="""the scaling mode for the glyphs
                            ('vector', 'scalar', or 'none').""")

    resolution = CInt(8, desc="The resolution of the glyph created. For "
                        "spheres, for instance, this is the number of "
                        "divisions along theta and phi.")

    mask_points = Either(None, CInt,
                        desc="If supplied, only one out of 'mask_points' "
                        "data point is displayed. This option is useful "
                        "to reduce the number of points displayed "
                        "on large datasets")

    def _resolution_changed(self):
        glyph = self._target.glyph.glyph_source.glyph_source
        if hasattr(glyph, 'theta_resolution'):
            glyph.theta_resolution = self.resolution
        if hasattr(glyph, 'phi_resolution'):
            glyph.phi_resolution = self.resolution
        if hasattr(glyph, 'resolution'):
            glyph.resolution = self.resolution
        if hasattr(glyph, 'shaft_resolution'):
            glyph.shaft_resolution = self.resolution
        if hasattr(glyph, 'tip_resolution'):
            glyph.tip_resolution = self.resolution

    def _mask_points_changed(self):
        if self.mask_points is not None:
            self._target.glyph.mask_input_points = True
            self._target.glyph.mask_points.on_ratio = self.mask_points

    def _scale_mode_changed(self):
        self._target.glyph.scale_mode = self.scale_mode_

    mode = Trait('2darrow', glyph_mode_dict,
                    desc="""the mode of the glyphs.""")

    def _mode_changed(self):
        v = self._target
        # Workaround for different version of VTK:
        if hasattr(v.glyph.glyph_source, 'glyph_source'):
            g = v.glyph.glyph_source
        else:
            g = v.glyph
        if self.mode == 'point':
            g.glyph_source = tvtk.PointSource(radius=0, number_of_points=1)
        else:
            g.glyph_source = g.glyph_list[self.mode_]
        if self.mode_ == 0:
            g.glyph_source.glyph_type = self.mode[2:]


vectors = make_function(VectorsFactory)


##############################################################################
class GlyphFactory(VectorsFactory):
    """Applies the Glyph mayavi module to the given VTK data
        source (Mayavi source, or VTK dataset).
    """

    _target = Instance(modules.Glyph, ())

    scale_mode = Trait('scalar', {'none': 'data_scaling_off',
                                'scalar': 'scale_by_scalar',
                                'vector': 'scale_by_vector'},
                            help="""the scaling mode for the glyphs
                            ('vector', 'scalar', or 'none').""")

    mode = Trait('sphere', glyph_mode_dict,
                    desc="""the mode of the glyphs.""")


glyph = make_function(GlyphFactory)


##############################################################################
class StreamlineFactory(DataModuleFactory):
    """Applies the Streamline mayavi module to the given VTK data object."""
    _target = Instance(modules.Streamline, ())

    linetype = Trait('line', 'ribbon', 'tube',
            adapts='streamline_type',
            desc="""the type of line-like object used to display the
                   streamline.""")

    seedtype = Trait('sphere',
            {'sphere': 0, 'line': 1, 'plane': 2, 'point': 3},
            desc="""the widget used as a seed for the streamlines.""")

    seed_visible = Bool(True,
            adapts='seed.widget.enabled',
            desc="Control the visibility of the seed.",
            )

    seed_scale = CFloat(1.,
            desc="Scales the seed around its default center",
            )

    seed_resolution = Either(None, CInt,
            desc='The resolution of the seed. Determines the number of '
                 'seed points')

    integration_direction = Trait('forward', 'backward', 'both',
            adapts='stream_tracer.integration_direction',
            desc="The direction of the integration.",
            )

    def _seedtype_changed(self):
        # XXX: this also acts for seed_scale and seed_resolution, but no
        # need to define explicit callbacks, as all the callbacks are
        # being called anyhow.
        self._target.seed.widget = widget = \
                            self._target.seed.widget_list[self.seedtype_]

        if not self.seed_scale == 1.:
            widget.enabled = True
            if self.seedtype == 'line':
                p1 = widget.point1
                p2 = widget.point2
                center = (p1 + p2) / 2.
                widget.point1 = center + self.seed_scale * (p1 - center)
                widget.point2 = center + self.seed_scale * (p2 - center)
            elif self.seedtype == 'plane':
                p1 = widget.point1
                p2 = widget.point2
                center = (p1 + p2) / 2.
                o = widget.origin
                widget.point1 = center + self.seed_scale * (p1 - center)
                widget.point2 = center + self.seed_scale * (p2 - center)
                widget.origin = center + self.seed_scale * (o - center)
            elif self.seedtype == 'sphere':
                widget.radius *= self.seed_scale

            # XXX: Very ugly, but this is only way I have found to
            # propagate changes.
            self._target.seed.stop()
            self._target.seed.start()
            widget.enabled = self.seed_visible

        if self.seed_resolution is not None:
            widget.enabled = True
            if self.seedtype in ('plane', 'line'):
                widget.resolution = self.seed_resolution
            elif self.seedtype == 'sphere':
                widget.phi_resolution = widget.theta_resolution = \
                        self.seed_resolution

            # XXX: Very ugly, but this is only way I have found to
            # propagate changes.
            self._target.seed.stop()
            self._target.seed.start()
            widget.enabled = self.seed_visible


streamline = make_function(StreamlineFactory)


##############################################################################
class SurfaceFactory(DataModuleFactory):
    """Applies the Surface mayavi module to the given data
        source (Mayavi source, or VTK dataset).
    """
    _target = Instance(modules.Surface, ())

    representation = Trait('surface', 'wireframe', 'points',
                    adapts='actor.property.representation',
                    desc="""the representation type used for the surface.""")


surface = make_function(SurfaceFactory)


##############################################################################
class IsoSurfaceFactory(ContourModuleFactory):
    """Applies the IsoSurface mayavi module to the given data
        source (Mayavi source, or VTK dataset).
    """
    _target = Instance(modules.IsoSurface, ())


iso_surface = make_function(IsoSurfaceFactory)


##############################################################################
class ContourSurfaceFactory(ContourModuleFactory):
    """Applies the Surface mayavi module to the given data
       source (Mayavi source, or VTK dataset) and turns contours on.
    """
    _target = Instance(modules.Surface, ())

    def __init__(self, *args, **kwargs):
        """ Overriding the __init__ to turn contours on."""
        super(ContourSurfaceFactory, self).__init__(*args, **kwargs)
        self._contours_changed()


contour_surface = make_function(ContourSurfaceFactory)


##############################################################################
class ImageActorFactory(DataModuleFactory):
    """Applies the ImageActor mayavi module to the given VTK data object."""
    _target = Instance(modules.ImageActor, ())

    interpolate = Bool(True, adapts='actor.interpolate',
                       desc="""if the pixels in the image are to be
                       interpolated or not.""")

    opacity = Range(0.0, 1.0, 1.0, adapts='actor.opacity',
                    desc="""the opacity of the image.""")


image_actor = make_function(ImageActorFactory)


##############################################################################
class ImagePlaneWidgetFactory(DataModuleFactory):
    """ Applies the ImagePlaneWidget mayavi module to the given data
        source (Mayavi source, or VTK dataset).
    """
    _target = Instance(modules.ImagePlaneWidget, ())

    slice_index = CInt(0, adapts='ipw.slice_index',
                        help="""The index along wich the
                                            image is sliced.""")

    plane_opacity = Range(0.0, 1.0, 1.0, adapts='ipw.plane_property.opacity',
                    desc="""the opacity of the plane actor.""")

    plane_orientation = Enum('x_axes', 'y_axes', 'z_axes',
                        adapts='ipw.plane_orientation',
                        desc="""the orientation of the plane""")

image_plane_widget = make_function(ImagePlaneWidgetFactory)


##############################################################################
class ScalarCutPlaneFactory(CutPlaneFactory):
    """ Applies the ScalarCutPlane mayavi module to the given data
        source (Mayavi source, or VTK dataset).
    """
    _target = Instance(modules.ScalarCutPlane, ())

scalar_cut_plane = make_function(ScalarCutPlaneFactory)


##############################################################################
class VectorCutPlaneFactory(CutPlaneFactory, VectorsFactory):
    """ Applies the VectorCutPlane mayavi module to the given data
        source (Mayavi source, or VTK dataset).
    """
    _target = Instance(modules.VectorCutPlane, ())

vector_cut_plane = make_function(VectorCutPlaneFactory)


##############################################################################
class ContourGridPlaneFactory(ContourModuleFactory):
    """ Applies the ContourGridPlane mayavi module to the given data
        source (Mayavi source, or VTK dataset).
    """
    _target = Instance(modules.ContourGridPlane, ())

contour_grid_plane = make_function(ContourGridPlaneFactory)


##############################################################################
class CustomGridPlaneFactory(ContourModuleFactory):
    """ Applies the CustomGridPlane mayavi module to the given VTK data
        source (Mayavi source, or VTK dataset).
    """
    _target = Instance(modules.CustomGridPlane, ())

custom_grid_plane = make_function(CustomGridPlaneFactory)


##############################################################################
class VolumeFactory(PipeFactory):
    """ Applies the Volume mayavi module to the given VTK data
        source (Mayavi source, or VTK dataset).

        **Note**

        The range of the colormap can be changed simply using the
        vmin/vmax parameters (see below). For more complex modifications of
        the colormap, here is some pseudo code to change the ctf (color
        transfer function), or the otf (opacity transfer function)::

            vol = mlab.pipeline.volume(src)

            # Changing the ctf:
            from tvtk.util.ctf import ColorTransferFunction
            ctf = ColorTransferFunction()
            ctf.add_rgb_point(value, r, g, b)  # r, g, and b are float
                                               # between 0 and 1
            ctf.add_hsv_point(value, h, s, v)
            # ...
            vol._volume_property.set_color(ctf)
            vol._ctf = ctf
            vol.update_ctf = True

            # Changing the otf:
            from tvtk.util.ctf import PiecewiseFunction
            otf = PiecewiseFunction()
            otf.add_point(value, opacity)
            vol._otf = otf
            vol._volume_property.set_scalar_opacity(otf)

        Also, it might be useful to change the range of the ctf::

            ctf.range = [0, 1]
    """

    color = Trait(None, None,
                TraitTuple(Range(0., 1.), Range(0., 1.), Range(0., 1.)),
                help="""the color of the vtk object. Overides the colormap,
                        if any, when specified. This is specified as a
                        triplet of float ranging from 0 to 1, eg (1, 1,
                        1) for white.""", )

    vmin = Trait(None, None, CFloat,
                    help="""vmin is used to scale the transparency
                            gradient. If None, the min of the data will be
                            used""")

    vmax = Trait(None, None, CFloat,
                    help="""vmax is used to scale the transparency
                            gradient. If None, the max of the data will be
                            used""")

    _target = Instance(modules.Volume, ())

    __ctf_rescaled = Bool(False)

    ######################################################################
    # Non-public interface.
    ######################################################################
    def _color_changed(self):
        if not self.color:
            return
        range_min, range_max = self._target.current_range
        from tvtk.util.ctf import ColorTransferFunction
        ctf = ColorTransferFunction()
        try:
            ctf.range = (range_min, range_max)
        except Exception:
            # VTK versions < 5.2 don't seem to need this.
            pass

        r, g, b = self.color
        ctf.add_rgb_point(range_min, r, g, b)
        ctf.add_rgb_point(range_max, r, g, b)

        self._target._ctf = ctf
        self._target._volume_property.set_color(ctf)
        self._target.update_ctf = True

    def _vmin_changed(self):
        vmin = self.vmin
        vmax = self.vmax
        range_min, range_max = self._target.current_range
        if vmin is None:
            vmin = range_min
        if vmax is None:
            vmax = range_max

        # Change the opacity function
        from tvtk.util.ctf import PiecewiseFunction, save_ctfs

        otf = PiecewiseFunction()
        if range_min < vmin:
            otf.add_point(range_min, 0.)
        if range_max > vmax:
            otf.add_point(range_max, 0.2)
        otf.add_point(vmin, 0.)
        otf.add_point(vmax, 0.2)
        self._target._otf = otf
        self._target._volume_property.set_scalar_opacity(otf)
        if self.color is None and not self.__ctf_rescaled and \
                        ((self.vmin is not None) or (self.vmax is not None)):
            # FIXME: We don't use 'rescale_ctfs' because it screws up the
            # nodes.

            def _rescale_value(x):
                nx = (x - range_min) / (range_max - range_min)
                return vmin + nx * (vmax - vmin)
            # The range of the existing ctf can vary.
            scale_min, scale_max = self._target._ctf.range

            def _rescale_node(x):
                nx = (x - scale_min) / (scale_max - scale_min)
                return range_min + nx * (range_max - range_min)

            if hasattr(self._target._ctf, 'nodes'):
                rgb = list()
                for value in self._target._ctf.nodes:
                    r, g, b = \
                            self._target._ctf.get_color(value)
                    rgb.append((_rescale_node(value), r, g, b))
            else:
                rgb = save_ctfs(self._target.volume_property)['rgb']

            from tvtk.util.ctf import ColorTransferFunction
            ctf = ColorTransferFunction()
            try:
                ctf.range = (range_min, range_max)
            except Exception:
                # VTK versions < 5.2 don't seem to need this.
                pass
            rgb.sort()
            v = rgb[0]
            ctf.add_rgb_point(range_min, v[1], v[2], v[3])
            for v in rgb:
                ctf.add_rgb_point(_rescale_value(v[0]), v[1], v[2], v[3])
            ctf.add_rgb_point(range_max, v[1], v[2], v[3])

            self._target._ctf = ctf
            self._target._volume_property.set_color(ctf)
            self.__ctf_rescaled = True

        self._target.update_ctf = True

    # This is not necessary: the job is already done by _vmin_changed
    #_vmax_changed = _vmin_changed

volume = make_function(VolumeFactory)


############################################################################
# Automatically generated modules from registry.
############################################################################
class _AutomaticModuleFactory(DataModuleFactory):
    """The base class for any auto-generated factory classes.

    NOTE: This class requires the `_metadata` trait be set to
    the metadata object for the object for which this is a factory.
    """

    # The target.
    _target = Property

    # The saved target that is created once and then always returned.
    _saved_target = Any(None)

    def _get__target(self):
        """Getter for the _target trait."""
        if self._saved_target is None:
            self._saved_target = self._metadata.get_callable()()

        return self._saved_target


def _make_functions(namespace):
    """Make the functions for adding modules and add them to the
    namespace automatically.
    """
    # Ignore these since they are already provided.
    ignore = ['axes', 'text', 'orientation_axes']
    for mod in registry.modules:
        func_name = camel2enthought(mod.id)
        class_name = mod.id
        if func_name.endswith('_module'):
            func_name = func_name[:-7]
            class_name = class_name[:-6]
        class_name = class_name + 'Factory'

        # Don't create any that are already defined or ignored.
        if class_name in namespace or func_name in ignore:
            continue

        # The class to wrap.
        klass = new.classobj(class_name,
                             (_AutomaticModuleFactory,),
                             {'__doc__': mod.help, }
                             )
        klass._metadata = mod
        # The mlab helper function.
        func = make_function(klass)

        # Inject class/function into the namespace and __all__.
        namespace[class_name] = klass
        namespace[func_name] = func
        __all__.append(func_name)

# Create the module related functions.
_make_functions(locals())

########NEW FILE########
__FILENAME__ = pipeline
"""
API module grouping all the mlab functions to manipulate directly the
pipeline.

"""

# Author: Gael Varoquaux <gael.varoquaux@normalesup.org>
# Copyright (c) 2007-2009, Enthought, Inc.
# License: BSD Style.

from modules import *
from sources import *
from filters import *
from tools import add_dataset, set_extent, add_module_manager, \
    get_vtk_src
from probe_data import probe_data
from tools import _traverse as traverse


########NEW FILE########
__FILENAME__ = pipe_base
"""
Base class for factories for adding objects to the pipeline.

"""

# Author: Gael Varoquaux <gael.varoquaux@normalesup.org>
# Copyright (c) 2007, Enthought, Inc.
# License: BSD Style.

import warnings

from auto_doc import make_doc
from traits.api import HasPrivateTraits, Str, TraitError,\
            Instance, Any, Bool
from mayavi.core.filter import Filter
from mayavi.core.engine import Engine
from mayavi.core.source import Source
from mayavi.core.scene import Scene
from mayavi.core.module_manager import ModuleManager

from tvtk.api import tvtk

import tools
from engine_manager import get_engine


def get_obj(obj, components):
    """ Get the target object for the specified components. """

    for component in components:
        obj = getattr(obj, component)

    return obj


def make_function(factory_class):
    def the_function(*args, **kwargs):
        factory = factory_class(*args, **kwargs)
        return factory._target

    the_function.__doc__ = make_doc(factory_class)
    the_function.func_name = factory_class.__name__.lower()
    return the_function


def get_module_manager(obj):
    """ Returns the module manager that would be used when a module
        is added on the given object, if any, and None elsewhere.
    """
    if hasattr(obj, 'module_manager'):
        return obj.module_manager
    elif isinstance(obj, ModuleManager):
        return obj
    for child in reversed(obj.children):
        if isinstance(child, ModuleManager):
            return child
    else:
        return None


##############################################################################
class PipeFactory(HasPrivateTraits):
    """ Base class for all factories adding pipes on the pipeline """

    name = Str(adapts='name', help='the name of the vtk object created.')

    figure = Instance(Scene)

    _engine = Instance(Engine, help=('the figure on which the object '
                'should be added'))

    _target = Any

    _do_redraw = Bool

    def add_module(self, parent, kwargs=dict()):
        """ Add the target module to the given object.
        """
        # We check to see if the module-manager-related option require to
        # add a new module manager:
        if parent is not None:
            module_manager = get_module_manager(parent)
            if (module_manager is not None and
                        len(module_manager.children) > 0):
                scalar_lut = module_manager.scalar_lut_manager
                vector_lut = module_manager.vector_lut_manager
                if 'vmin' in kwargs:
                    if not scalar_lut.use_default_range and \
                            kwargs['vmin'] != scalar_lut.data_range[0]:
                        parent = self._engine.add_module(ModuleManager(),
                                                        module_manager.parent)
                    elif not scalar_lut.use_default_range and \
                            kwargs['vmin'] != scalar_lut.data_range[0]:
                        parent = self._engine.add_module(ModuleManager(),
                                                        module_manager.parent)

                elif 'vmax' in kwargs:
                    if not scalar_lut.use_default_range and \
                            kwargs['vmax'] != scalar_lut.data_range[1]:
                        parent = self._engine.add_module(ModuleManager(),
                                                        module_manager.parent)
                    elif not scalar_lut.use_default_range and \
                            kwargs['vmax'] != scalar_lut.data_range[1]:
                        parent = self._engine.add_module(ModuleManager(),
                                                        module_manager.parent)

                elif 'colormap' in kwargs:
                    cmap = kwargs['colormap']
                    if (scalar_lut.lut_mode != cmap
                                        or vector_lut.lut_mode != cmap):
                        parent = self._engine.add_module(ModuleManager(),
                                            module_manager.parent)

        self._engine.add_module(self._target, obj=parent)

    def __init__(self, parent, **kwargs):
        # We are not passing the traits to the parent class
        super(PipeFactory, self).__init__()
        # Try to find the right engine and scene to work with
        ancester = parent
        while hasattr(ancester, 'parent'):
            ancester = getattr(ancester, 'parent')
            if isinstance(ancester, Scene):
                self._scene = ancester
                self._engine = ancester.parent
                break
        else:
            if self.figure is not None:
                self._scene = self.figure
            else:
                self._scene = tools.gcf()
                self._engine = get_engine()
        scene = self._scene.scene
        if self.figure is not None and self.figure is not self._scene:
            warnings.warn('Trying to add a module on the wrong scene')
        if isinstance(parent, (Source, tvtk.DataSet)) \
                and not isinstance(parent, Filter) and scene is not None:
            # Search the current scene to see if the  source is already
            # in it, if not add it.
            if not parent in self._scene.children:
                parent = tools.add_dataset(parent, figure=self._scene)

        if scene is not None:
            self._do_redraw = not scene.disable_render
            scene.disable_render = True
        if issubclass(self._target.__class__, Filter):
            self._engine.add_filter(self._target, obj=parent)
        else:
            self.add_module(parent, kwargs)

        # Inject the magical mlab source trait.
        if hasattr(parent, 'mlab_source'):
            ms = parent.mlab_source
            self._target.add_trait('mlab_source', Instance(ms.__class__))
            self._target.mlab_source = ms

        traits = self.get(self.class_trait_names())
        [traits.pop(key) for key in traits.keys()
                                    if key[0] == '_' or key is None]
        traits.update(kwargs)
        # Now calling the traits setter, so that traits handlers are
        # called
        self.set(**traits)
        if scene is not None:
            scene.disable_render = not self._do_redraw

    def set(self, trait_change_notify=True, **traits):
        """ Same as HasTraits.set except that notification is forced,
        unless trait_change_notify==False"""
        HasPrivateTraits.set(self, trait_change_notify=trait_change_notify,
                                    **traits)
        if trait_change_notify == False:
            return
        for trait in traits.iterkeys():
            callback = getattr(self, '_%s_changed' % trait)
            value = getattr(self, trait)
            try:
                if callback is not None:
                    callback()
                self._anytrait_changed(trait, value)
            except TraitError:
                if value == None:
                    # This means "default"
                    pass
                else:
                    raise

    def _anytrait_changed(self, name, value):
        """ This is where we implement the adaptation code. """
        trait = self.trait(name)
        if name[0] == '_':
            # Private attribute
            return
        # hasattr(traits, "adapts") always returns True :-<.
        if not trait.adapts == None:
            components = trait.adapts.split('.')
            obj = get_obj(self._target, components[:-1])
            setattr(obj, components[-1], value)

########NEW FILE########
__FILENAME__ = preferences_mirror
# Author: Prabhu Ramachandran <prabhu [at] aero . iitb . ac . in>
# Copyright (c) 2008,  Prabhu Ramachandran
# License: BSD Style.

# Enthought library imports.
from traits.api import HasTraits, List, Str, Instance
from apptools.preferences.api import PreferencesHelper


###############################################################################
# `PreferencesMirror` class.
###############################################################################
class PreferencesMirror(HasTraits):
    """
    This class mirrors preferences from a PreferencesHelper such that
    users can use them and change them but nothing is saved to disk till
    the user asks for an explicit save.
    """

    # The preferences we mirror.
    preferences = Instance(PreferencesHelper)

    # Private trait to store names of traits.
    _trait_names = List(Str)

    ######################################################################
    # Public interface.
    ######################################################################
    def save(self):
        """Updates the actual preferences and thereby persists them to
        disk.
        """
        for name in self._trait_names:
            setattr(self.preferences, name, getattr(self, name))

    ######################################################################
    # Private interface.
    ######################################################################
    def _preferences_changed(self):
        """Setup traits of our own based on those of the mayavi
        preferences.
        """
        trait_names = []
        opts = self.preferences
        for key, value in opts.traits().iteritems():
            if key not in ['trait_added', 'trait_modified',
                           'preferences', 'preferences_path']:
                self.add_trait(key, value)
                setattr(self, key, getattr(opts, key))
                trait_names.append(key)
                opts.on_trait_change(self._update, key)
        self._trait_names = trait_names

    def _update(self, obj, name, old, new):
        setattr(self, name, new)

########NEW FILE########
__FILENAME__ = probe_data
"""
A helper function to retrieve the data from Mayavi structures on
arbitrary points.
"""

import numpy as np

from tvtk.api import tvtk
from . import tools
import tvtk.common as tvtk_common

def probe_data(mayavi_object, x, y, z, type='scalars', location='points'):
    """ Retrieve the data from a described by Mayavi visualization object
        at points x, y, z.

        **Parameters**

        :viz_obj: A Mayavi visualization object, or a VTK dataset
                  The object describing the data you are interested in.
        :x: float or ndarray.
            The x position where you want to retrieve the data.
        :y: float or ndarray.
            The y position where you want to retrieve the data.
        :z: float or ndarray
            The z position where you want to retrieve the data.
        :type: 'scalars', 'vectors' or 'tensors', optional
            The type of the data to retrieve.
        :location: 'points' or 'cells', optional
            The location of the data to retrieve.

        **Returns**

        The values of the data at the given point, as an ndarray
        (or multiple arrays, in the case of vectors or tensors) of the
        same shape as x, y, and z.
    """
    dataset = tools.get_vtk_src(mayavi_object)[0]
    assert type in ('scalars', 'vectors', 'cells'), (
        "Invalid value for type: must be 'scalars', 'vectors' or "
        "'cells', but '%s' was given" % type)
    x = np.atleast_1d(x)
    y = np.atleast_1d(y)
    z = np.atleast_1d(z)
    shape = x.shape
    assert y.shape == z.shape == shape, \
                        'The x, y and z arguments must have the same shape'
    probe_data = mesh = tvtk.PolyData(points=np.c_[x.ravel(),
                                                   y.ravel(),
                                                   z.ravel()])
    shape = list(shape)
    probe = tvtk.ProbeFilter()
    tvtk_common.configure_input_data(probe, probe_data)
    tvtk_common.configure_source_data(probe, dataset)
    probe.update()

    if location == 'points':
        data = probe.output.point_data
    elif location == 'cells':
        data = probe.output.cell_data
    else:
        raise ValueError("Invalid value for data location, must be "
                         "'points' or 'cells', but '%s' was given."
                         % location)

    values = getattr(data, type)
    if values is None:
        raise ValueError("The object given has no %s data of type %s"
                         % (location, type))
    values = values.to_array()
    if type == 'scalars':
        values = np.reshape(values, shape)
    elif type == 'vectors':
        values = np.reshape(values, shape + [3, ])
        values = np.rollaxis(values, -1)
    else:
        values = np.reshape(values, shape + [-1, ])
        values = np.rollaxis(values, -1)
    return values

########NEW FILE########
__FILENAME__ = server
""" Powerful utility for running a TCP/UDP server that is used to script
Mayavi2 from the network.  This uses Twisted.  This particular version
has been written for the wxPython, adding support for a Qt4 version
should be trivial.

The key functions exposed are::

 serve_tcp(...)
 serve_udp(...)

See the function documentation for more information.  Here is sample
usage::

    from mayavi import mlab
    from mayavi.tools import server
    mlab.test_plot3d()
    server.serve_tcp()

The TCP server will listen on port 8007 by default in the above.  Any
data sent to the server is simply exec'd, meaning you can do pretty much
anything you want.  The `engine`, `scene`, `camera` and `mlab` are all
available and can be used.  For example after running the above you can
do this::

    $ telnet localhost 8007
    Trying 127.0.0.1...
    Connected to localhost.
    Escape character is '^]'.
    scene.camera.azimuth(45)
    mlab.clf()
    mlab.test_contour3d()
    scene.camera.zoom(1.5)

The nice thing about this is that you do not loose any interactivity of
your app and can continue to use its UI as before, any network commands
will be simply run on top of this.

**Warning** while this is very powerful it is also a **huge security
hole** since the remote user can do pretty much anything they want.

"""

# Author: Prabhu Ramachandran <prabhu@aero.iitb.ac.in>
# Copyright (c) 2009, Enthought, Inc.
# License: BSD Style.

import sys
import wx
# Install wxreactor; must be done before the reactor is imported below.
from twisted.internet import wxreactor
wxreactor.install()

# The usual twisted imports.
from twisted.internet.protocol import Protocol, DatagramProtocol, Factory
from twisted.internet import reactor
from twisted.python import log


###############################################################################
# `M2UDP` protocol.
###############################################################################
class M2UDP(DatagramProtocol):

    """Implements a brain dead but supremely powerful UDP API.  Any data
    coming in is simply exec'd.  Meaning you can do pretty much anything
    you want.  The `engine`, `scene`, `camera` and `mlab` are all
    available and can be used.  For example you can easily send this on
    the network::

      scene.camera.azimuth(45)
      mlab.clf()
      mlab.test_contour3d()
      scene.camera.zoom(1.5)

    And these will run just fine retaining the full interactivity of the
    mayavi app.
    """

    def datagramReceived(self, data, (host, port)):
        """Given a line of data, simply execs it to do whatever."""
        log.msg("Received: %r from %s:%d" % (data, host, port))
        c = data.strip()
        if len(c) > 0:
            mlab = self.mlab
            engine = self.engine
            scene = self.scene
            camera = scene.camera
            try:
                exec c in locals(), globals()
            except:
                log.err()
            scene.render()


###############################################################################
# `M2TCP` protocol
###############################################################################
class M2TCP(Protocol):

    """Implements a brain dead but suprememly powerful TCP API.  Any
    data coming in is simply exec'd.  Meaning you can do pretty much
    anything you want.  The `engine`, `scene`, `camera` and `mlab` are
    all available and can be used.  For example you can easily send this
    on the network::

      scene.camera.azimuth(45)
      mlab.clf()
      mlab.test_contour3d()
      scene.camera.zoom(1.5)

    And these will run just fine retaining the full interactivity of the
    mayavi app.
    """

    # Maximum number of concurrent connections allowed.
    maxConnect = 1

    def connectionMade(self):
        log.msg('ConnectionMade')
        self.factory.numConnect += 1
        if self.factory.numConnect > self.maxConnect:
            self.transport.write("Server already in use, try later\n")
            self.transport.loseConnection()

    def connectionLost(self, reason):
        log.msg('ConnectionLost')
        self.factory.numConnect -= 1

    def dataReceived(self, data):
        """Given a line of data, simply execs it to do whatever."""
        c = data.strip()
        log.msg('Received:', c)
        if len(c) > 0:
            mlab = self.factory.mlab
            engine = self.factory.engine
            scene = self.factory.scene
            camera = scene.camera
            try:
                exec c in locals(), globals()
            except:
                log.err()
            scene.render()


###############################################################################
# Utility functions.
###############################################################################
def serve_udp(engine=None, port=9007, logto=sys.stdout):
    """Serve the `M2UDP` protocol using the given `engine` on the
    specified `port` logging messages to given `logto` which is a
    file-like object.  This function will block till the service is
    closed.  There is no need to call `mlab.show()` after or before
    this.  The Mayavi UI will be fully responsive.

    **Parameters**

     :engine: Mayavi engine to use. If this is `None`,
              `mlab.get_engine()` is used to find an appropriate engine.

     :port: int: port to serve on.

     :logto: file : File like object to log messages to.  If this is
                    `None` it disables logging.

    **Examples**

    Here is a very simple example::

        from mayavi import mlab
        from mayavi.tools import server
        mlab.test_plot3d()
        server.serve_udp()

    Test it like so::

        import socket
        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        s.bind(('', 9008))
        s.sendto('camera.azimuth(10)', ('', 9007))

    **Warning**

    Data sent is exec'd so this is a security hole.
    """

    from mayavi import mlab
    e = engine or mlab.get_engine()
    # Setup the protocol with the right attributes.
    proto = M2UDP()
    proto.engine = e
    proto.scene = e.current_scene.scene
    proto.mlab = mlab

    if logto is not None:
        log.startLogging(logto)
    log.msg('Serving Mayavi2 UDP server on port', port)
    log.msg('Using Engine', e)

    # Register the running wxApp.
    reactor.registerWxApp(wx.GetApp())
    # Listen on port 9007 using above protocol.
    reactor.listenUDP(port, proto)
    # Run the server + app.  This will block.
    reactor.run()


def serve_tcp(engine=None, port=8007, logto=sys.stdout, max_connect=1):
    """Serve the `M2TCP` protocol using the given `engine` on the
    specified `port` logging messages to given `logto` which is a
    file-like object.  This function will block till the service is
    closed.  There is no need to call `mlab.show()` after or before
    this.  The Mayavi UI will be fully responsive.

    **Parameters**

     :engine: Mayavi engine to use. If this is `None`,
              `mlab.get_engine()` is used to find an appropriate engine.

     :port: int: port to serve on.

     :logto: file: File like object to log messages to.  If this is
                   `None` it disables logging.

     :max_connect: int: Maximum number of simultaneous connections to
                        support.

    **Examples**

    Here is a very simple example::

        from mayavi import mlab
        from mayavi.tools import server
        mlab.test_plot3d()
        server.serve_tcp()

    The TCP server will listen on port 8007 by default in the above.
    Any data sent to the server is simply exec'd, meaning you can do
    pretty much anything you want.  The `engine`, `scene`, `camera` and
    `mlab` are all available and can be used.  For example after running
    the above you can do this::

        $ telnet localhost 8007
        Trying 127.0.0.1...
        Connected to localhost.
        Escape character is '^]'.
        scene.camera.azimuth(45)
        mlab.clf()
        mlab.test_contour3d()
        scene.camera.zoom(1.5)

    **Warning**

    Data sent is exec'd so this is a security hole.
    """

    from mayavi import mlab
    e = engine or mlab.get_engine()
    # Setup the factory with the right attributes.
    factory = Factory()
    factory.protocol = M2TCP
    factory.maxConnect = max_connect
    factory.numConnect = 0
    factory.engine = e
    factory.scene = e.current_scene.scene
    factory.mlab = mlab

    if logto is not None:
        log.startLogging(logto)
    log.msg('Serving Mayavi2 TCP server on port', port)
    log.msg('Using Engine', e)

    # Register the running wxApp.
    reactor.registerWxApp(wx.GetApp())
    # Listen on port 9007 using above protocol.
    reactor.listenTCP(port, factory)
    # Run the server + app.  This will block.
    reactor.run()


###############################################################################
# Examples and tests.
###############################################################################
def test_tcp():
    """Simple test for the TCP server."""
    from mayavi import mlab
    mlab.test_plot3d()
    serve_tcp()


def test_udp():
    """Simple test for the UDP server."""
    from mayavi import mlab
    mlab.test_plot3d()
    serve_udp()

if __name__ == '__main__':
    test_tcp()

########NEW FILE########
__FILENAME__ = show
# Author: Prabhu Ramachandran <prabhu[at]aero[dot]iitb[dot]ac[dot]in>
# Copyright (c) 2008, Enthought, Inc.
# License: BSD Style.

from traits.etsconfig.api import ETSConfig
from pyface.api import GUI, ApplicationWindow
from traits.api import HasTraits, Button, Any
from traitsui.api import View, Group, Item
from pyface.util import guisupport

# Globals.
# The GUI instance.
_gui = None
# The stop show instance.
_stop_show = None


def is_ui_running():
    """ Returns True if the UI event loop is running.
    """
    from engine_manager import options
    if options.offscreen:
        return True
    elif ETSConfig.toolkit == 'wx':
        return guisupport.is_event_loop_running_wx()
    elif ETSConfig.toolkit == 'qt4':
        return guisupport.is_event_loop_running_qt4()
    else:
        return False


###############################################################################
# `StopShow` class.
###############################################################################
class StopShow(HasTraits):

    ########################################
    # Traits

    stop = Button('Stop interaction',
                  desc='if the UI interaction is to be stopped')

    # Private traits.
    # Stores a reference to the UI object so it can be disposed when the
    # interaction is stopped.
    _ui = Any

    view = View(Group(Item('stop'), show_labels=False),
                buttons=[], title='Control Show')

    ######################################################################
    # `object` interface.
    ######################################################################
    def __init__(self, **traits):
        super(StopShow, self).__init__(**traits)
        self._ui = self.edit_traits()

    ######################################################################
    # Non-public interface.
    ######################################################################
    def _stop_fired(self):
        _gui.stop_event_loop()
        self._ui.dispose()


def show(func=None, stop=False):
    """ Start interacting with the figure.

    By default, this function simply creates a GUI and starts its
    event loop if needed.

    If it is used as a decorator, then it may be used to decorate a
    function which requires a UI.   If the GUI event loop is already
    running it simply runs the function.  If not the event loop is
    started and function is run in the toolkit's event loop.  The choice
    of UI is via `ETSConfig.toolkit`.

    If the argument stop is set to True then it pops up a UI where the
    user can stop the event loop.  Subsequent calls to `show` will
    restart the event loop.

    **Parameters**

      :stop:  A boolean which specifies if a UI dialog is displayed which
              allows the event loop to be stopped.

    **Examples**

    Here is a simple example demonstrating the use of show::

      >>> from mayavi import mlab
      >>> mlab.test_contour3d()
      >>> mlab.show()

    You can stop interaction via a simple pop up UI like so::

      >>> mlab.test_contour3d()
      >>> mlab.show(stop=True)

    The decorator can be used like so::

      >>> @mlab.show
      ... def do():
      ...    mlab.test_contour3d()
      ...
      >>> do()

    The decorator can also be passed the stop argument::

      >>> @mlab.show(stop=True)
      ... def do():
      ...    mlab.test_contour3d()
      ...
      >>> do()

    """
    global _gui, _stop_show
    if func is None:
        if not is_ui_running():
            g = GUI()
            _gui = g
            if stop:
                _stop_show = StopShow()
            g.start_event_loop()
        return

    def wrapper(*args, **kw):
        """Wrapper function to run given function inside the GUI event
        loop.
        """
        global _gui, _stop_show
        tk = ETSConfig.toolkit

        if is_ui_running():
            # In this case we should not pop up the UI since we likely
            # don't want to stop the mainloop.
            return func(*args, **kw)
        else:
            g = GUI()
            if tk == 'wx':
                # Create a dummy app so invoke later works on wx.
                a = ApplicationWindow(size=(1, 1))
                GUI.invoke_later(lambda: a.close())
                a.open()

            GUI.invoke_later(func, *args, **kw)
            _gui = g
            if stop:
                # Pop up the UI to stop the mainloop.
                _stop_show = StopShow()
            g.start_event_loop()

    return wrapper

########NEW FILE########
__FILENAME__ = sources
"""
Data sources classes and their associated functions for mlab.
"""

# Author: Gael Varoquaux <gael.varoquaux@normalesup.org>
#         Prabhu Ramachandran
# Copyright (c) 2007-2010, Enthought, Inc.
# License: BSD Style.

import operator

import numpy as np

from traits.api import (HasTraits, Instance, CArray, Either,
            Bool, on_trait_change, NO_COMPARE)
from tvtk.api import tvtk
from tvtk.common import camel2enthought

from mayavi.sources.array_source import ArraySource
from mayavi.core.registry import registry

import tools
from engine_manager import get_null_engine, engine_manager

__all__ = ['vector_scatter', 'vector_field', 'scalar_scatter',
    'scalar_field', 'line_source', 'array2d_source', 'grid_source',
    'open', 'triangular_mesh_source', 'vertical_vectors_source',
]


###############################################################################
# A subclass of CArray that will accept floats and do a np.atleast_1d
###############################################################################
class CArrayOrNumber(CArray):

    def validate(self, object, name, value):
        if operator.isNumberType(value):
            value = np.atleast_1d(value)
        return CArray.validate(self, object, name, value)


###############################################################################
# `MlabSource` class.
###############################################################################
class MlabSource(HasTraits):
    """
    This class represents the base class for all mlab sources.  These
    classes allow a user to easily update the data without having to
    recreate the whole pipeline.
    """

    # The TVTK dataset we manage.
    dataset = Instance(tvtk.DataSet)

    # The Mayavi data source we manage.
    m_data = Instance(HasTraits)

    ########################################
    # Private traits.

    # Disable the update when data is changed.
    _disable_update = Bool(False)

    ######################################################################
    # `MlabSource` interface.
    ######################################################################
    def reset(self, **traits):
        """Function to create the data from input arrays etc.

        This is to be used when the size of the arrays change or the
        first time when the data is created.  This regenerates the data
        structures and will be slower in general.
        """
        raise NotImplementedError()

    def update(self):
        """Update the visualization.

        This is to be called after the data of the visualization has
        changed.
        """
        if not self._disable_update:
            self.dataset.modified()
            md = self.m_data
            if md is not None:
                if hasattr(md, '_assign_attribute'):
                    md._assign_attribute.update()
                md.data_changed = True

    def set(self, trait_change_notify=True, **traits):
        """Shortcut for setting object trait attributes.

        This is an overridden method that will make changing multiple
        traits easier.  This method is to be called when the arrays have
        changed content but not in shape/size.  In that case one must
        call the `reset` method.

        Parameters
        ----------
        trait_change_notify : Boolean
            If **True** (the default), then each value assigned may generate a
            trait change notification. If **False**, then no trait change
            notifications will be generated. (see also: trait_setq)
        traits : list of key/value pairs
            Trait attributes and their values to be set

        Returns
        -------
        self
            The method returns this object, after setting attributes.
        """
        try:
            self._disable_update = True
            super(MlabSource, self).set(trait_change_notify, **traits)
        finally:
            self._disable_update = False
        if trait_change_notify:
            self.update()
        return self

    ######################################################################
    # Non-public interface.
    ######################################################################
    def _m_data_changed(self, ds):
        if not hasattr(ds, 'mlab_source'):
            ds.add_trait('mlab_source', Instance(MlabSource))
        ds.mlab_source = self


ArrayOrNone = Either(None, CArray, comparison_mode=NO_COMPARE)
ArrayNumberOrNone = Either(None, CArrayOrNumber, comparison_mode=NO_COMPARE)


###############################################################################
# `MGlyphSource` class.
###############################################################################
class MGlyphSource(MlabSource):
    """
    This class represents a glyph data source for Mlab objects and
    allows the user to set the x, y, z, scalar/vector attributes.
    """

    # The x, y, z and points of the glyphs.
    x = ArrayNumberOrNone
    y = ArrayNumberOrNone
    z = ArrayNumberOrNone
    points = ArrayOrNone

    # The scalars shown on the glyphs.
    scalars = ArrayNumberOrNone

    # The u, v, w components of the vector and the vectors.
    u = ArrayNumberOrNone
    v = ArrayNumberOrNone
    w = ArrayNumberOrNone
    vectors = ArrayOrNone

    ######################################################################
    # `MlabSource` interface.
    ######################################################################
    def reset(self, **traits):
        """Creates the dataset afresh or resets existing data source."""
        # First convert numbers to arrays.
        for name in ('x', 'y', 'z', 'u', 'v', 'w', 'scalars'):
            if name in traits and traits[name] is not None:
                traits[name] = np.atleast_1d(traits[name])

        # First set the attributes without really doing anything since
        # the notification handlers are not called.
        self.set(trait_change_notify=False, **traits)

        vectors = self.vectors
        scalars = self.scalars
        points = self.points
        x, y, z = self.x, self.y, self.z
        x = np.atleast_1d(x)
        y = np.atleast_1d(y)
        z = np.atleast_1d(z)

        if 'points' in traits:
            x = points[:, 0].ravel()
            y = points[:, 1].ravel()
            z = points[:, 2].ravel()
            self.set(x=x, y=y, z=z, trait_change_notify=False)

        else:
            points = np.c_[x.ravel(), y.ravel(), z.ravel()].ravel()
            points.shape = (points.size / 3, 3)
            self.set(points=points, trait_change_notify=False)

        u, v, w = self.u, self.v, self.w
        if u is not None:
            u = np.atleast_1d(u)
            v = np.atleast_1d(v)
            w = np.atleast_1d(w)
            if len(u) > 0:
                vectors = np.c_[u.ravel(), v.ravel(),
                                w.ravel()].ravel()
                vectors.shape = (vectors.size / 3, 3)
                self.set(vectors=vectors, trait_change_notify=False)

        if 'vectors' in traits:
            u = vectors[:, 0].ravel()
            v = vectors[:, 1].ravel()
            w = vectors[:, 2].ravel()
            self.set(u=u, v=v, w=w, trait_change_notify=False)

        else:
            if u is not None and len(u) > 0:
                vectors = np.c_[u.ravel(), v.ravel(),
                                w.ravel()].ravel()
                vectors.shape = (vectors.size / 3, 3)
                self.set(vectors=vectors, trait_change_notify=False)

        if vectors is not None and len(vectors) > 0:
            assert len(points) == len(vectors)
        if scalars is not None:
            scalars = np.atleast_1d(scalars)
            if len(scalars) > 0:
                assert len(points) == len(scalars.ravel())

        # Create the dataset.
        polys = np.arange(0, len(points), 1, 'l')
        polys = np.reshape(polys, (len(points), 1))
        if self.dataset is None:
            # Create new dataset if none exists
            pd = tvtk.PolyData()
        else:
            # Modify existing one.
            pd = self.dataset
        pd.set(points=points, polys=polys)

        if self.vectors is not None:
            pd.point_data.vectors = self.vectors
            pd.point_data.vectors.name = 'vectors'
        if self.scalars is not None:
            pd.point_data.scalars = self.scalars.ravel()
            pd.point_data.scalars.name = 'scalars'

        self.dataset = pd

    ######################################################################
    # Non-public interface.
    ######################################################################
    def _x_changed(self, x):
        x = np.atleast_1d(x)
        self.points[:, 0] = x.ravel()
        self.update()

    def _y_changed(self, y):
        y = np.atleast_1d(y)
        self.points[:, 1] = y.ravel()
        self.update()

    def _z_changed(self, z):
        z = np.atleast_1d(z)
        self.points[:, 2] = z.ravel()
        self.update()

    def _u_changed(self, u):
        u = np.atleast_1d(u)
        self.vectors[:, 0] = u.ravel()
        self.update()

    def _v_changed(self, v):
        v = np.atleast_1d(v)
        self.vectors[:, 1] = v.ravel()
        self.update()

    def _w_changed(self, w):
        w = np.atleast_1d(w)
        self.vectors[:, 2] = w.ravel()
        self.update()

    def _points_changed(self, p):
        p = np.atleast_2d(p)
        self.dataset.points = p
        self.update()

    def _scalars_changed(self, s):
        if s is None:
            self.dataset.point_data.scalars = None
            self.dataset.point_data.remove_array('scalars')
        else:
            s = np.atleast_1d(s)
            self.dataset.point_data.scalars = s.ravel()
            self.dataset.point_data.scalars.name = 'scalars'
        self.update()

    def _vectors_changed(self, v):
        self.dataset.point_data.vectors = v
        self.dataset.point_data.vectors.name = 'vectors'
        self.update()


###############################################################################
# `MVerticalGlyphSource` class.
###############################################################################
class MVerticalGlyphSource(MGlyphSource):
    """
    This class represents a vertical glyph data source for Mlab objects
    and allows the user to set the x, y, z, scalar attributes. The
    vectors are created from the scalars to represent them in the
    vertical direction.
    """

    def reset(self, **traits):
        """Creates the dataset afresh or resets existing data source."""
        if 'scalars' in traits:
            s = traits['scalars']
            if s is not None:
                traits['u'] = traits['v'] = np.ones_like(s),
                traits['w'] = s
        super(MVerticalGlyphSource, self).reset(**traits)

    def _scalars_changed(self, s):
        self.dataset.point_data.scalars = s
        self.dataset.point_data.scalars.name = 'scalars'
        self.set(vectors=np.c_[np.ones_like(s),
                                  np.ones_like(s),
                                  s])
        self.update()


###############################################################################
# `MArraySource` class.
###############################################################################
class MArraySource(MlabSource):
    """
    This class represents an array data source for Mlab objects and
    allows the user to set the x, y, z, scalar/vector attributes.
    """

    # The x, y, z arrays for the volume.
    x = ArrayOrNone
    y = ArrayOrNone
    z = ArrayOrNone

    # The scalars shown on the glyphs.
    scalars = ArrayOrNone

    # The u, v, w components of the vector and the vectors.
    u = ArrayOrNone
    v = ArrayOrNone
    w = ArrayOrNone
    vectors = ArrayOrNone

    ######################################################################
    # `MlabSource` interface.
    ######################################################################
    def reset(self, **traits):
        """Creates the dataset afresh or resets existing data source."""

        # First set the attributes without really doing anything since
        # the notification handlers are not called.
        self.set(trait_change_notify=False, **traits)

        vectors = self.vectors
        scalars = self.scalars
        x, y, z = [np.atleast_3d(a) for a in self.x, self.y, self.z]

        u, v, w = self.u, self.v, self.w
        if 'vectors' in traits:
            u = vectors[:, 0].ravel()
            v = vectors[:, 1].ravel()
            w = vectors[:, 2].ravel()
            self.set(u=u, v=v, w=w, trait_change_notify=False)

        else:
            if u is not None and len(u) > 0:
                #vectors = np.concatenate([u[..., np.newaxis],
                #                             v[..., np.newaxis],
                #                             w[..., np.newaxis] ],
                #                axis=3)
                vectors = np.c_[u.ravel(), v.ravel(),
                                   w.ravel()].ravel()
                vectors.shape = (u.shape[0], u.shape[1], w.shape[2], 3)
                self.set(vectors=vectors, trait_change_notify=False)

        if vectors is not None and len(vectors) > 0 and scalars is not None:
            assert len(scalars) == len(vectors)

        if x.shape[0] <= 1:
            dx = 1
        else:
            dx = x[1, 0, 0] - x[0, 0, 0]
        if y.shape[1] <= 1:
            dy = 1
        else:
            dy = y[0, 1, 0] - y[0, 0, 0]
        if z.shape[2] <= 1:
            dz = 1
        else:
            dz = z[0, 0, 1] - z[0, 0, 0]

        if self.m_data is None:
            ds = ArraySource(transpose_input_array=True)
        else:
            ds = self.m_data
        old_scalar = ds.scalar_data
        ds.set(vector_data=vectors,
               origin=[x.min(), y.min(), z.min()],
               spacing=[dx, dy, dz],
               scalar_data=scalars)
        if scalars is old_scalar:
            ds._scalar_data_changed(scalars)

        self.dataset = ds.image_data
        self.m_data = ds

    ######################################################################
    # Non-public interface.
    ######################################################################
    @on_trait_change('[x, y, z]')
    def _xyz_changed(self):
        x, y, z = self.x, self.y, self.z
        dx = x[1, 0, 0] - x[0, 0, 0]
        dy = y[0, 1, 0] - y[0, 0, 0]
        dz = z[0, 0, 1] - z[0, 0, 0]
        ds = self.dataset
        ds.origin = [x.min(), y.min(), z.min()]
        ds.spacing = [dx, dy, dz]
        if self.m_data is not None:
            self.m_data.set(origin=ds.origin, spacing=ds.spacing)
        self.update()

    def _u_changed(self, u):
        self.vectors[..., 0] = u
        self.m_data._vector_data_changed(self.vectors)

    def _v_changed(self, v):
        self.vectors[..., 1] = v
        self.m_data._vector_data_changed(self.vectors)

    def _w_changed(self, w):
        self.vectors[..., 2] = w
        self.m_data._vector_data_changed(self.vectors)

    def _scalars_changed(self, s):
        old = self.m_data.scalar_data
        self.m_data.scalar_data = s
        if old is s:
            self.m_data._scalar_data_changed(s)

    def _vectors_changed(self, v):
        self.m_data.vector_data = v


###############################################################################
# `MLineSource` class.
###############################################################################
class MLineSource(MlabSource):
    """
    This class represents a line data source for Mlab objects and
    allows the user to set the x, y, z, scalar attributes.
    """

    # The x, y, z and points of the glyphs.
    x = ArrayOrNone
    y = ArrayOrNone
    z = ArrayOrNone
    points = ArrayOrNone

    # The scalars shown on the glyphs.
    scalars = ArrayOrNone

    ######################################################################
    # `MlabSource` interface.
    ######################################################################
    def reset(self, **traits):
        """Creates the dataset afresh or resets existing data source."""

        # First set the attributes without really doing anything since
        # the notification handlers are not called.
        self.set(trait_change_notify=False, **traits)

        points = self.points
        scalars = self.scalars
        x, y, z = self.x, self.y, self.z

        if 'points' in traits:
            x = points[:, 0].ravel()
            y = points[:, 1].ravel()
            z = points[:, 2].ravel()
            self.set(x=x, y=y, z=z, trait_change_notify=False)

        else:
            points = np.c_[x.ravel(), y.ravel(), z.ravel()].ravel()
            points.shape = (len(x), 3)
            self.set(points=points, trait_change_notify=False)

        # Create the dataset.
        n_pts = len(points) - 1
        lines = np.zeros((n_pts, 2), 'l')
        lines[:, 0] = np.arange(0, n_pts - 0.5, 1, 'l')
        lines[:, 1] = np.arange(1, n_pts + 0.5, 1, 'l')
        if self.dataset is None:
            pd = tvtk.PolyData()
        else:
            pd = self.dataset
        # Avoid lines refering to non existing points: First set the
        # lines to None, then set the points, then set the lines
        # refering to the new points.
        pd.set(lines=None)
        pd.set(points=points)
        pd.set(lines=lines)

        if scalars is not None and len(scalars) > 0:
            assert len(x) == len(scalars)
            pd.point_data.scalars = np.ravel(scalars)
            pd.point_data.scalars.name = 'scalars'

        self.dataset = pd

    ######################################################################
    # Non-public interface.
    ######################################################################
    def _x_changed(self, x):
        self.points[:, 0] = x
        self.update()

    def _y_changed(self, y):
        self.points[:, 1] = y
        self.update()

    def _z_changed(self, z):
        self.points[:, 2] = z
        self.update()

    def _points_changed(self, p):
        self.dataset.points = p
        self.update()

    def _scalars_changed(self, s):
        self.dataset.point_data.scalars = s.ravel()
        self.dataset.point_data.scalars.name = 'scalars'
        self.update()


###############################################################################
# `MArray2DSource` class.
###############################################################################
class MArray2DSource(MlabSource):
    """
    This class represents a 2D array data source for Mlab objects and
    allows the user to set the x, y  and scalar attributes.
    """

    # The x, y values.
    # Values of X and Y as None are accepted, in that case we would build
    # values of X and Y automatically from the shape of scalars
    x = ArrayOrNone
    y = ArrayOrNone

    # The scalars shown on the glyphs.
    scalars = ArrayOrNone

    # The masking array.
    mask = ArrayOrNone

    ######################################################################
    # `MlabSource` interface.
    ######################################################################
    def reset(self, **traits):
        """Creates the dataset afresh or resets existing data source."""

        # First set the attributes without really doing anything since
        # the notification handlers are not called.
        self.set(trait_change_notify=False, **traits)
        x, y, mask = self.x, self.y, self.mask
        scalars = self.scalars

        # We may have used this without specifying x and y at all in
        # which case we set them from the shape of scalars.
        nx, ny = scalars.shape

        #Build X and Y from shape of Scalars if they are none
        if x is None and y is None:
            x, y = np.mgrid[-nx / 2.:nx / 2, -ny / 2.:ny / 2]

        if mask is not None and len(mask) > 0:
            scalars[mask.astype('bool')] = np.nan
            # The NaN trick only works with floats.
            scalars = scalars.astype('float')
            self.set(scalars=scalars, trait_change_notify=False)

        z = np.array([0])

        self.set(x=x, y=y, z=z, trait_change_notify=False)
        # Do some magic to extract the first row/column, independently of
        # the shape of x and y

        x = np.atleast_2d(x.squeeze().T)[0, :].squeeze()
        y = np.atleast_2d(y.squeeze())[0, :].squeeze()

        if x.ndim == 0:
            dx = 1
        else:
            dx = x[1] - x[0]
        if y.ndim == 0:
            dy = 1
        else:
            dy = y[1] - y[0]
        if self.m_data is None:
            ds = ArraySource(transpose_input_array=True)
        else:
            ds = self.m_data
        old_scalar = ds.scalar_data
        ds.set(origin=[x.min(), y.min(), 0],
               spacing=[dx, dy, 1],
               scalar_data=scalars)
        if old_scalar is scalars:
            ds._scalar_data_changed(scalars)

        self.dataset = ds.image_data
        self.m_data = ds

    #####################################################################
    # Non-public interface.
    #####################################################################
    @on_trait_change('[x, y]')
    def _xy_changed(self):
        x, y, scalars = self.x, self.y, self.scalars

        nx, ny = scalars.shape

        if x is None or y is None:
            x, y = np.mgrid[-nx / 2.:nx / 2, -ny / 2.:ny / 2]

        self.trait_setq(x=x, y=y)
        x = np.atleast_2d(x.squeeze().T)[0, :].squeeze()
        y = np.atleast_2d(y.squeeze())[0, :].squeeze()
        dx = x[1] - x[0]
        dy = y[1] - y[0]
        ds = self.dataset
        ds.origin = [x.min(), y.min(), 0]
        ds.spacing = [dx, dy, 1]
        if self.m_data is not None:
            self.m_data.set(origin=ds.origin, spacing=ds.spacing)
        self.update()

    def _scalars_changed(self, s):
        mask = self.mask
        if mask is not None and len(mask) > 0:
            s[mask.astype('bool')] = np.nan
            # The NaN tric only works with floats.
            s = s.astype('float')
            self.set(scalars=s, trait_change_notify=False)
        old = self.m_data.scalar_data
        self.m_data.scalar_data = s
        if s is old:
            self.m_data._scalar_data_changed(s)


##############################################################################
# `MGridSource` class.
##############################################################################
class MGridSource(MlabSource):
    """
    This class represents a grid source for Mlab objects and
    allows the user to set the x, y, scalar attributes.
    """

    # The x, y, z and points of the grid.
    x = ArrayOrNone
    y = ArrayOrNone
    z = ArrayOrNone
    points = ArrayOrNone

    # The scalars shown on the glyphs.
    scalars = ArrayOrNone

    # The masking array.
    mask = ArrayOrNone

    ######################################################################
    # `MlabSource` interface.
    ######################################################################
    def reset(self, **traits):
        """Creates the dataset afresh or resets existing data source."""

        # First set the attributes without really doing anything since
        # the notification handlers are not called.
        self.set(trait_change_notify=False, **traits)

        points = self.points
        scalars = self.scalars
        x, y, z, mask = self.x, self.y, self.z, self.mask

        if mask is not None and len(mask) > 0:
            scalars[mask.astype('bool')] = np.nan
            # The NaN trick only works with floats.
            scalars = scalars.astype('float')
            self.set(scalars=scalars, trait_change_notify=False)

        assert len(x.shape) == 2, "Array x must be 2 dimensional."
        assert len(y.shape) == 2, "Array y must be 2 dimensional."
        assert len(z.shape) == 2, "Array z must be 2 dimensional."
        assert x.shape == y.shape, "Arrays x and y must have same shape."
        assert y.shape == z.shape, "Arrays y and z must have same shape."

        # Points in the grid source will always be created using x,y,z
        # Changing of points is not allowed because it cannot be used to
        # modify values of x,y,z

        nx, ny = x.shape
        points = np.c_[x.ravel(), y.ravel(), z.ravel()].ravel()
        points.shape = (nx * ny, 3)
        self.set(points=points, trait_change_notify=False)

        i, j = np.mgrid[0:nx - 1, 0:ny - 1]
        i, j = np.ravel(i), np.ravel(j)
        t1 = i * ny + j, (i + 1) * ny + j, (i + 1) * ny + (j + 1)
        t2 = (i + 1) * ny + (j + 1), i * ny + (j + 1), i * ny + j
        nt = len(t1[0])
        triangles = np.zeros((nt * 2, 3), 'l')
        triangles[0:nt, 0], triangles[0:nt, 1], triangles[0:nt, 2] = t1
        triangles[nt:, 0], triangles[nt:, 1], triangles[nt:, 2] = t2

        if self.dataset is None:
            pd = tvtk.PolyData()
        else:
            pd = self.dataset
        pd.set(points=points, polys=triangles)

        if scalars is not None and len(scalars) > 0:
            if not scalars.flags.contiguous:
                scalars = scalars.copy()
                self.set(scalars=scalars, trait_change_notify=False)
            assert x.shape == scalars.shape
            pd.point_data.scalars = scalars.ravel()
            pd.point_data.scalars.name = 'scalars'

        self.dataset = pd

    ######################################################################
    # Non-public interface.
    ######################################################################
    def _x_changed(self, x):
        self.trait_setq(x=x)
        self.points[:, 0] = x.ravel()
        self.update()

    def _y_changed(self, y):
        self.trait_setq(y=y)
        self.points[:, 1] = y.ravel()
        self.update()

    def _z_changed(self, z):
        self.trait_setq(z=z)
        self.points[:, 2] = z.ravel()
        self.update()

    def _points_changed(self, p):
        self.dataset.points = p
        self.update()

    def _scalars_changed(self, s):
        mask = self.mask
        if mask is not None and len(mask) > 0:
            s[mask.astype('bool')] = np.nan
            # The NaN tric only works with floats.
            s = s.astype('float')
            self.set(scalars=s, trait_change_notify=False)

        self.dataset.point_data.scalars = s.ravel()
        self.dataset.point_data.scalars.name = 'scalars'
        self.update()


###############################################################################
# `MTriangularMeshSource` class.
###############################################################################
class MTriangularMeshSource(MlabSource):
    """
    This class represents a triangular mesh source for Mlab objects and
    allows the user to set the x, y, scalar attributes.
    """

    # The x, y, z and points of the grid.
    x = ArrayOrNone
    y = ArrayOrNone
    z = ArrayOrNone
    points = ArrayOrNone
    triangles = ArrayOrNone

    # The scalars shown on the glyphs.
    scalars = ArrayOrNone

    ######################################################################
    # `MlabSource` interface.
    ######################################################################
    def reset(self, **traits):
        """Creates the dataset afresh or resets existing data source."""

        # First set the attributes without really doing anything since
        # the notification handlers are not called.
        self.set(trait_change_notify=False, **traits)

        points = self.points
        scalars = self.scalars

        x, y, z = self.x, self.y, self.z
        points = np.c_[x.ravel(), y.ravel(), z.ravel()].ravel()
        points.shape = (points.size / 3, 3)
        self.set(points=points, trait_change_notify=False)

        triangles = self.triangles
        assert triangles.shape[1] == 3, \
            "The shape of the triangles array must be (X, 3)"
        assert triangles.max() < len(points), \
            "The triangles indices must be smaller that the number of points"
        assert triangles.min() >= 0, \
            "The triangles indices must be positive or null"

        if self.dataset is None:
            pd = tvtk.PolyData()
        else:
            pd = self.dataset
        # Set the points first, and the triangles after: so that the
        # polygone can refer to the right points, in the polydata.
        pd.set(points=points)
        pd.set(polys=triangles)

        if (not 'scalars' in traits
                    and scalars is not None
                    and scalars.shape != x.shape):
            # The scalars where set probably automatically to z, by the
            # factory. We need to reset them, as the size has changed.
            scalars = z

        if scalars is not None and len(scalars) > 0:
            if not scalars.flags.contiguous:
                scalars = scalars.copy()
                self.set(scalars=scalars, trait_change_notify=False)
            assert x.shape == scalars.shape
            pd.point_data.scalars = scalars.ravel()
            pd.point_data.scalars.name = 'scalars'

        self.dataset = pd

    ######################################################################
    # Non-public interface.
    ######################################################################
    def _x_changed(self, x):
        self.trait_setq(x=x)
        self.points[:, 0] = x.ravel()
        self.update()

    def _y_changed(self, y):
        self.trait_setq(y=y)
        self.points[:, 1] = y.ravel()
        self.update()

    def _z_changed(self, z):
        self.trait_setq(z=z)
        self.points[:, 2] = z.ravel()
        self.update()

    def _points_changed(self, p):
        self.dataset.points = p
        self.update()

    def _scalars_changed(self, s):
        self.dataset.point_data.scalars = s.ravel()
        self.dataset.point_data.scalars.name = 'scalars'
        self.update()

    def _triangles_changed(self, triangles):
        if triangles.min() < 0:
            raise ValueError('The triangles array has negative values')
        if triangles.max() > self.x.size:
            raise ValueError('The triangles array has values larger than' \
                                        'the number of points')
        self.dataset.polys = triangles
        self.update()


############################################################################
# Argument processing
############################################################################

def convert_to_arrays(args):
    """ Converts a list of iterables to a list of arrays or callables,
        if needed.
    """
    args = list(args)
    for index, arg in enumerate(args):
        if not callable(arg):
            if not hasattr(arg, 'shape'):
                arg = np.atleast_1d(np.array(arg))
            if np.any(np.isinf(arg)):
                raise ValueError("""Input array contains infinite values
                You can remove them using: a[np.isinf(a)] = np.nan
                """)
            args[index] = arg
    return args


def process_regular_vectors(*args):
    """ Converts different signatures to (x, y, z, u, v, w). """
    args = convert_to_arrays(args)
    if len(args) == 3:
        u, v, w = [np.atleast_3d(a) for a in args]
        assert len(u.shape) == 3, "3D array required"
        x, y, z = np.indices(u.shape)
    elif len(args) == 6:
        x, y, z, u, v, w = args
    elif len(args) == 4:
        x, y, z, f = args
        if not callable(f):
            raise ValueError("When 4 arguments are provided, the fourth must "
                             "be a callable")
        u, v, w = f(x, y, z)
    else:
        raise ValueError("wrong number of arguments")

    assert (x.shape == y.shape and
            y.shape == z.shape and
            u.shape == z.shape and
            v.shape == u.shape and
            w.shape == v.shape), "argument shape are not equal"

    return x, y, z, u, v, w


def process_regular_scalars(*args):
    """ Converts different signatures to (x, y, z, s). """
    args = convert_to_arrays(args)
    if len(args) == 1:
        s = np.atleast_3d(args[0])
        assert len(s.shape) == 3, "3D array required"
        x, y, z = np.indices(s.shape)
    elif len(args) == 3:
        x, y, z = args
        s = None
    elif len(args) == 4:
        x, y, z, s = args
        if callable(s):
            s = s(x, y, z)
    else:
        raise ValueError("wrong number of arguments")

    assert (x.shape == y.shape and
            y.shape == z.shape and
            (s is None
               or s.shape == z.shape)), "argument shape are not equal"

    return x, y, z, s


def process_regular_2d_scalars(*args, **kwargs):
    """ Converts different signatures to (x, y, s). """
    args = convert_to_arrays(args)
    for index, arg in enumerate(args):
        if not callable(arg):
            args[index] = np.atleast_2d(arg)
    if len(args) == 1:
        s = args[0]
        assert len(s.shape) == 2, "2D array required"
        x, y = np.indices(s.shape)
    elif len(args) == 3:
        x, y, s = args
        if callable(s):
            s = s(x, y)
    else:
        raise ValueError("wrong number of arguments")
    assert len(s.shape) == 2, "2D array required"

    if 'mask' in kwargs:
        mask = kwargs['mask']
        s[mask.astype('bool')] = np.nan
        # The NaN tric only works with floats.
        s = s.astype('float')

    return x, y, s


############################################################################
# Sources
############################################################################

def vector_scatter(*args, **kwargs):
    """ Creates scattered vector data.

    **Function signatures**::

        vector_scatter(u, v, w, ...)
        vector_scatter(x, y, z, u, v, w, ...)
        vector_scatter(x, y, z, f, ...)

    If only 3 arrays u, v, w are passed the x, y and z arrays are assumed to be
    made from the indices of vectors.

    If 4 positional arguments are passed the last one must be a callable, f,
    that returns vectors.

    **Keyword arguments**:

        :name: the name of the vtk object created.

        :scalars: optional scalar data.

        :figure: optionally, the figure on which to add the data source.
                 If None, the source is not added to any figure, and will
                 be added automatically by the modules or
                 filters. If False, no figure will be created by modules
                 or filters applied to the source: the source can only
                 be used for testing, or numerical algorithms, not
                 visualization."""
    x, y, z, u, v, w = process_regular_vectors(*args)

    scalars = kwargs.pop('scalars', None)
    if scalars is not None:
        scalars = np.ravel(scalars)
    name = kwargs.pop('name', 'VectorScatter')

    data_source = MGlyphSource()
    data_source.reset(x=x, y=y, z=z, u=u, v=v, w=w, scalars=scalars)

    ds = tools.add_dataset(data_source.dataset, name, **kwargs)
    data_source.m_data = ds
    return ds


def vector_field(*args, **kwargs):
    """ Creates vector field data.

    **Function signatures**::

        vector_field(u, v, w, ...)
        vector_field(x, y, z, u, v, w, ...)
        vector_field(x, y, z, f, ...)

    If only 3 arrays u, v, w are passed the x, y and z arrays are assumed to be
    made from the indices of vectors.

    If the x, y and z arrays are passed, they should have been generated
    by `numpy.mgrid` or `numpy.ogrid`. The function builds a scalar field
    assuming the points are regularily spaced on an orthogonal grid.

    If 4 positional arguments are passed the last one must be a callable, f,
    that returns vectors.

    **Keyword arguments**:

        :name: the name of the vtk object created.

        :scalars: optional scalar data.

        :figure: optionally, the figure on which to add the data source.
                 If None, the source is not added to any figure, and will
                 be added automatically by the modules or
                 filters. If False, no figure will be created by modules
                 or filters applied to the source: the source can only
                 be used for testing, or numerical algorithms, not
                 visualization."""
    if len(args) == 3:
        x = y = z = np.atleast_3d(1)
        u, v, w = [np.atleast_3d(a) for a in args]
    else:
        x, y, z, u, v, w = [np.atleast_3d(a)
                        for a in process_regular_vectors(*args)]

    scalars = kwargs.pop('scalars', None)
    if scalars is not None:
        scalars = np.atleast_3d(scalars)
    data_source = MArraySource()
    data_source.reset(x=x, y=y, z=z, u=u, v=v, w=w, scalars=scalars)
    name = kwargs.pop('name', 'VectorField')
    return tools.add_dataset(data_source.m_data, name, **kwargs)


def scalar_scatter(*args, **kwargs):
    """
    Creates scattered scalar data.

    **Function signatures**::

        scalar_scatter(s, ...)
        scalar_scatter(x, y, z, s, ...)
        scalar_scatter(x, y, z, s, ...)
        scalar_scatter(x, y, z, f, ...)

    If only 1 array s is passed the x, y and z arrays are assumed to be
    made from the indices of vectors.

    If 4 positional arguments are passed the last one must be an array s, or
    a callable, f, that returns an array.

    **Keyword arguments**:

        :name: the name of the vtk object created.

        :figure: optionally, the figure on which to add the data source.
                 If None, the source is not added to any figure, and will
                 be added automatically by the modules or
                 filters. If False, no figure will be created by modules
                 or filters applied to the source: the source can only
                 be used for testing, or numerical algorithms, not
                 visualization."""
    x, y, z, s = process_regular_scalars(*args)

    if s is not None:
        s = np.ravel(s)

    data_source = MGlyphSource()
    data_source.reset(x=x, y=y, z=z, scalars=s)

    name = kwargs.pop('name', 'ScalarScatter')
    ds = tools.add_dataset(data_source.dataset, name, **kwargs)
    data_source.m_data = ds
    return ds


def scalar_field(*args, **kwargs):
    """
    Creates a scalar field data.

    **Function signatures**::

        scalar_field(s, ...)
        scalar_field(x, y, z, s, ...)
        scalar_field(x, y, z, f, ...)

    If only 1 array s is passed the x, y and z arrays are assumed to be
    made from the indices of arrays.

    If the x, y and z arrays are passed they are supposed to have been
    generated by `numpy.mgrid`. The function builds a scalar field assuming
    the points are regularily spaced.

    If 4 positional arguments are passed the last one must be an array s, or
    a callable, f, that returns an array.

    **Keyword arguments**:

        :name: the name of the vtk object created.

        :figure: optionally, the figure on which to add the data source.
                 If None, the source is not added to any figure, and will
                 be added automatically by the modules or
                 filters. If False, no figure will be created by modules
                 or filters applied to the source: the source can only
                 be used for testing, or numerical algorithms, not
                 visualization."""
    if len(args) == 1:
        # Be lazy, don't create three big arrays for 1 input array. The
        # MArraySource is clever-enough to handle flat arrays
        x = y = z = np.atleast_1d(1)
        s = args[0]
    else:
        x, y, z, s = process_regular_scalars(*args)

    data_source = MArraySource()
    data_source.reset(x=x, y=y, z=z, scalars=s)

    name = kwargs.pop('name', 'ScalarField')
    return tools.add_dataset(data_source.m_data, name, **kwargs)


def line_source(*args, **kwargs):
    """
    Creates line data.

    **Function signatures**::

        line_source(x, y, z, ...)
        line_source(x, y, z, s, ...)
        line_source(x, y, z, f, ...)

        If 4 positional arguments are passed the last one must be an array s,
        or a callable, f, that returns an array.

    **Keyword arguments**:

        :name: the name of the vtk object created.

        :figure: optionally, the figure on which to add the data source.
                 If None, the source is not added to any figure, and will
                 be added automatically by the modules or
                 filters. If False, no figure will be created by modules
                 or filters applied to the source: the source can only
                 be used for testing, or numerical algorithms, not
                 visualization."""
    if len(args) == 1:
        raise ValueError("wrong number of arguments")
    x, y, z, s = process_regular_scalars(*args)

    data_source = MLineSource()
    data_source.reset(x=x, y=y, z=z, scalars=s)

    name = kwargs.pop('name', 'LineSource')
    ds = tools.add_dataset(data_source.dataset, name, **kwargs)
    data_source.m_data = ds
    return ds


def array2d_source(*args, **kwargs):
    """
    Creates structured 2D data from a 2D array.

    **Function signatures**::

        array2d_source(s, ...)
        array2d_source(x, y, s, ...)
        array2d_source(x, y, f, ...)

    If 3 positional arguments are passed the last one must be an array s,
    or a callable, f, that returns an array. x and y give the
    coordinnates of positions corresponding to the s values.

    x and y can be 1D or 2D arrays (such as returned by numpy.ogrid or
    numpy.mgrid), but the points should be located on an orthogonal grid
    (possibly non-uniform). In other words, all the points sharing a same
    index in the s array need to have the same x or y value.

    If only 1 array s is passed the x and y arrays are assumed to be
    made from the indices of arrays, and an uniformly-spaced data set is
    created.

    **Keyword arguments**:

        :name: the name of the vtk object created.

        :figure: optionally, the figure on which to add the data source.
                 If None, the source is not added to any figure, and will
                 be added automatically by the modules or
                 filters. If False, no figure will be created by modules
                 or filters applied to the source: the source can only
                 be used for testing, or numerical algorithms, not
                 visualization.

        :mask: Mask points specified in a boolean masking array.
    """
    data_source = MArray2DSource()
    mask = kwargs.pop('mask', None)
    if len(args) == 1:
        args = convert_to_arrays(args)
        s = np.atleast_2d(args[0])
        data_source.reset(scalars=s, mask=mask)
    else:
        x, y, s = process_regular_2d_scalars(*args, **kwargs)
        data_source.reset(x=x, y=y, scalars=s, mask=mask)

    name = kwargs.pop('name', 'Array2DSource')
    return tools.add_dataset(data_source.m_data, name, **kwargs)


def grid_source(x, y, z, **kwargs):
    """
    Creates 2D grid data.

    x, y, z are 2D arrays giving the positions of the vertices of the surface.
    The connectivity between these points is implied by the connectivity on
    the arrays.

    For simple structures (such as orthogonal grids) prefer the array2dsource
    function, as it will create more efficient data structures.

    **Keyword arguments**:

        :name: the name of the vtk object created.

        :scalars: optional scalar data.

        :figure: optionally, the figure on which to add the data source.
                 If None, the source is not added to any figure, and will
                 be added automatically by the modules or
                 filters. If False, no figure will be created by modules
                 or filters applied to the source: the source can only
                 be used for testing, or numerical algorithms, not
                 visualization.

        :mask: Mask points specified in a boolean masking array.

        """
    scalars = kwargs.pop('scalars', None)
    if scalars is None:
        scalars = z
    mask = kwargs.pop('mask', None)

    x, y, z, scalars = convert_to_arrays((x, y, z, scalars))
    data_source = MGridSource()
    data_source.reset(x=x, y=y, z=z, scalars=scalars, mask=mask)

    name = kwargs.pop('name', 'GridSource')
    ds = tools.add_dataset(data_source.dataset, name, **kwargs)
    data_source.m_data = ds
    return ds


def vertical_vectors_source(*args, **kwargs):
    """
    Creates a set of vectors pointing upward, useful eg for bar graphs.

    **Function signatures**::

        vertical_vectors_source(s, ...)
        vertical_vectors_source(x, y, s, ...)
        vertical_vectors_source(x, y, f, ...)
        vertical_vectors_source(x, y, z, s, ...)
        vertical_vectors_source(x, y, z, f, ...)

    If only one positional argument is passed, it can be a 1D, 2D, or 3D
    array giving the length of the vectors. The positions of the data
    points are deducted from the indices of array, and an
    uniformly-spaced data set is created.

    If 3 positional arguments (x, y, s) are passed the last one must be
    an array s, or a callable, f, that returns an array. x and y give the
    2D coordinates of positions corresponding to the s values. The
    vertical position is assumed to be 0.

    If 4 positional arguments (x, y, z, s) are passed, the 3 first are
    arrays giving the 3D coordinates of the data points, and the last one
    is an array s, or a callable, f, that returns an array giving the
    data value.

    **Keyword arguments**:

        :name: the name of the vtk object created.

        :figure: optionally, the figure on which to add the data source.
                 If None, the source is not added to any figure, and will
                 be added automatically by the modules or
                 filters. If False, no figure will be created by modules
                 or filters applied to the source: the source can only
                 be used for testing, or numerical algorithms, not
                 visualization.
    """
    if len(args) == 3:
        x, y, data = args
        if np.isscalar(x):
            z = 0
        else:
            z = np.zeros_like(x)
        args = (x, y, z, data)

    x, y, z, s = process_regular_scalars(*args)

    if s is not None:
        s = np.ravel(s)

    data_source = MVerticalGlyphSource()
    data_source.reset(x=x, y=y, z=z, scalars=s)

    name = kwargs.pop('name', 'VerticalVectorsSource')
    ds = tools.add_dataset(data_source.dataset, name, **kwargs)
    data_source.m_data = ds
    return ds


def triangular_mesh_source(x, y, z, triangles, **kwargs):
    """
    Creates 2D mesh by specifying points and triangle connectivity.

    x, y, z are 2D arrays giving the positions of the vertices of the surface.
    The connectivity between these points is given by listing triplets of
    vertices inter-connected. These vertices are designed by there
    position index.

    **Keyword arguments**:

        :name: the name of the vtk object created.

        :scalars: optional scalar data.

        :figure: optionally, the figure on which to add the data source.
                 If None, the source is not added to any figure, and will
                 be added automatically by the modules or
                 filters. If False, no figure will be created by modules
                 or filters applied to the source: the source can only
                 be used for testing, or numerical algorithms, not
                 visualization.
        """
    x, y, z, triangles = convert_to_arrays((x, y, z, triangles))

    if triangles.min() < 0:
        raise ValueError('The triangles array has negative values')
    if triangles.max() > x.size:
        raise ValueError('The triangles array has values larger than' \
                                    'the number of points')
    scalars = kwargs.pop('scalars', None)
    if scalars is None:
        scalars = z

    data_source = MTriangularMeshSource()
    data_source.reset(x=x, y=y, z=z, triangles=triangles, scalars=scalars)

    name = kwargs.pop('name', 'TriangularMeshSource')
    ds = tools.add_dataset(data_source.dataset, name, **kwargs)
    data_source.m_data = ds
    return ds


def open(filename, figure=None):
    """Open a supported data file given a filename.  Returns the source
    object if a suitable reader was found for the file.

    If 'figure' is False, no view is opened, and the code does not need
    GUI or openGL context.
    """
    if figure is None:
        engine = tools.get_engine()
    elif figure is False:
        # Get a null engine that we can use.
        engine = get_null_engine()
    else:
        engine = engine_manager.find_figure_engine(figure)
        engine.current_scene = figure
    src = engine.open(filename)
    return src


############################################################################
# Automatically generated sources from registry.
############################################################################
def _create_data_source(metadata):
    """Creates a data source and adds it to the mayavi engine given
    metadata of the source.  Returns the created source.
    """
    factory = metadata.get_callable()
    src = factory()
    engine = tools.get_engine()
    engine.add_source(src)
    return src


def _make_functions(namespace):
    """Make the automatic functions and add them to the namespace."""
    for src in registry.sources:
        if len(src.extensions) == 0:
            func_name = camel2enthought(src.id)
            if func_name.endswith('_source'):
                func_name = func_name[:-7]
            func = lambda metadata=src: _create_data_source(metadata)
            func.__doc__ = src.help
            func.__name__ = func_name
            # Inject function into the namespace and __all__.
            namespace[func_name] = func
            __all__.append(func_name)

_make_functions(locals())

########NEW FILE########
__FILENAME__ = tools
"""
The general purpose tools to manipulate the pipeline with the mlab interface.
"""

# Author: Prabhu Ramachandran <prabhu_r@users.sf.net>,
#         Gael Varoquaux      <gael dot varoquaux at normalesup dot org>
# Copyright (c) 2007, 2010 Enthought, Inc.
# License: BSD Style.

# Standard library imports.
import numpy
import types

# Enthought library imports.
from tvtk.api import tvtk

# MayaVi related imports.
from mayavi.sources.vtk_data_source import VTKDataSource
from mayavi.core.module_manager import ModuleManager
from mayavi.core.source import Source
from mayavi.core.filter import Filter

from engine_manager import get_engine, engine_manager, get_null_engine
from figure import gcf

######################################################################
# Utility functions.


def add_dataset(dataset, name='', **kwargs):
    """Add a dataset object to the Mayavi pipeline.

    **Parameters**

    :dataset: a tvtk dataset, or a Mayavi source.
              The dataset added to the Mayavi pipeline
    :figure: a figure identifier number or string, None or False, optionnal.

            If no `figure` keyword argument is given, the data
            is added to the current figure (a new figure if created if
            necessary).

            If a `figure` keyword argument is given, it should either the name
            the number of the figure the dataset should be added to, or None,
            in which case the data is not added to the pipeline.

            If figure is False, a null engine is created. This null
            engine does not create figures, and is mainly usefull for
            tensting, or using the VTK algorithms without visualization.

    **Returns**

    The corresponding Mayavi source is returned.
    """
    if isinstance(dataset, tvtk.Object):
        d = VTKDataSource()
        d.data = dataset
    elif isinstance(dataset, Source):
        d = dataset
    else:
        raise TypeError(
              "first argument should be either a TVTK object"\
              " or a mayavi source")

    if len(name) > 0:
        d.name = name
    if not 'figure' in kwargs:
        # No figure has been specified, retrieve the default one.
        gcf()
        engine = get_engine()
    elif kwargs['figure'] is False:
        # Get a null engine that we can use.
        engine = get_null_engine()
    elif kwargs['figure'] is not None:
        figure = kwargs['figure']
        engine = engine_manager.find_figure_engine(figure)
        engine.current_scene = figure
    else:
        # Return early, as we don't want to add the source to an engine.
        return d
    engine.add_source(d)
    return d


def add_module_manager(object):
    """ Add a module-manager, to control colors and legend bars to the
        given object.
    """
    return get_engine().add_module(ModuleManager(), object)


def _traverse(node):
    """ Generator to traverse a tree accessing the nodes' children
        attribute.

        **Example**

        Here is a simple example printing the names of all the objects in
        the pipeline::

            for obj in mlab.pipeline.traverse(mlab.gcf()):
                print obj.name

    """
    try:
        for leaf in node.children:
            for leaflet in _traverse(leaf):
                yield leaflet
    except AttributeError:
        pass
    yield node


def get_vtk_src(mayavi_object, stop_at_filter=True):
    """ Goes up the Mayavi pipeline to find the data sources of a given
        object.

        **Parameters**

        :object: any Mayavi visualization object

        :stop_at_filter: optional boolean flag: if True, the first object
                         exposing data found going up the pipeline is
                         returned. If False, only the source itself
                         is returned.

        **Returns**

        :sources: List of vtk data sources (vtk data sources, and not
                  Mayavi source objects).

        **Notes**

        This function traverses the Mayavi pipeline. Thus the input
        object 'mayavi_object' should already be added to the pipeline.
    """
    if isinstance(mayavi_object, tvtk.Object) \
                        and hasattr(mayavi_object, 'point_data'):
        # We have been passed a tvtk source
        return [mayavi_object]
    if not (hasattr(mayavi_object, 'parent')
            or isinstance(mayavi_object, Source)):
        raise TypeError('Cannot find data source for given object %s' % (
                                            mayavi_object))
    while True:
        # XXX: If the pipeline is not a DAG, this is an infinite loop
        if isinstance(mayavi_object, Source):
            if stop_at_filter or not isinstance(mayavi_object, Filter):
                return mayavi_object.outputs
        mayavi_object = mayavi_object.parent


def _has_scalar_data(object):
    """Tests if an object has scalar data.
    """
    data_sources = get_vtk_src(object)
    for source in data_sources:
        if source.point_data.scalars is not None:
            return True
        elif source.cell_data.scalars is not None:
            return True
    return False


def _has_vector_data(object):
    """Tests if an object has vector data.
    """
    data_sources = get_vtk_src(object)
    for source in data_sources:
        if source.point_data.vectors is not None:
            return True
        elif source.cell_data.vectors is not None:
            return True
    return False


def _has_tensor_data(object):
    """Tests if an object has tensor data.
    """
    data_sources = get_vtk_src(object)
    for source in data_sources:
        if source.point_data.tensors is not None:
            return True
        elif source.cell_data.tensors is not None:
            return True
    return False


def _find_module_manager(object=None, data_type=None):
    """If an object is specified, returns its module_manager, elsewhere finds
    the first module_manager in the scene.
    """
    if object is None:
        for object in _traverse(gcf()):
            if isinstance(object, ModuleManager):
                if data_type == 'scalar':
                    if not _has_scalar_data(object):
                        continue
                    try:
                        if not object.actor.mapper.scalar_visibility:
                            continue
                    except AttributeError:
                        pass
                if data_type == 'vector' and not _has_vector_data(object):
                    continue
                if data_type == 'tensor' and not _has_tensor_data(object):
                    continue
                return object
    else:
        if hasattr(object, 'module_manager'):
            if ((data_type == 'scalar' and _has_scalar_data(object))
               or (data_type == 'vector' and _has_vector_data(object))
               or (data_type == 'tensor' and _has_tensor_data(object))
                or data_type is None):
                return object.module_manager
            else:
                print("This object has no %s data" % data_type)
        else:
            print("This object has no color map")
    return None


def _typical_distance(data_obj):
    """ Returns a typical distance in a cloud of points.
        This is done by taking the size of the bounding box, and dividing it
        by the cubic root of the number of points.
    """
    x_min, x_max, y_min, y_max, z_min, z_max = data_obj.bounds
    distance = numpy.sqrt(((x_max - x_min) ** 2 + (y_max - y_min) ** 2 +
                           (z_max - z_min) ** 2) / (4 *
                           data_obj.number_of_points ** (0.33)))
    if distance == 0:
        return 1
    else:
        return 0.4 * distance


def _min_distance(x, y, z):
    """ Return the minimum interparticle distance in a cloud of points.
        This is done by brute force calculation of all the distances
        between particle couples.
    """
    distances = numpy.sqrt((x.reshape((-1,)) - x.reshape((1, -1))) ** 2
                           + (y.reshape((-1,)) - y.reshape((1, -1))) ** 2
                           + (z.reshape((-1,)) - z.reshape((1, -1))) ** 2
                          )
    return distances[distances != 0].min()


def _min_axis_distance(x, y, z):
    """ Return the minimum interparticle distance in a cloud of points
        along one of the axis.
        This is done by brute force calculation of all the distances with
        norm infinity between particle couples.
    """
    def axis_min(a):
        a = numpy.abs(a.reshape((-1,)) - a.reshape((-1, 1)))
        a = a[a > 0]
        if a.size == 0:
            return numpy.inf
        return a.min()
    distances = min(axis_min(x), axis_min(y), axis_min(z))
    if distances == numpy.inf:
        return 1
    else:
        return distances


def set_extent(module, extents):
    """ Attempts to set the physical extents of the given module.

        The extents are given as (xmin, xmax, ymin, ymax, zmin, zmax).
        This does not work on an image plane widget, as this module does
        not have an actor.

        Once you use this function on a module, be aware that other
        modules applied on the same data source will not share the same
        scale. Thus for instance an outline module will not respect the
        outline of the actors whose extent you modified. You should pass
        in the same "extents" parameter for this to work.You can have a
        look at the wigner.py example for a heavy use of this
        functionnality.

        **Note**

        This function does not work on some specific modules, such as
        Outline, Axes, or ImagePlaneWidget. For Outline and Axes, use the
        extent keyword argument of mlab.pipeline.outline and
        mlab.pipeline.axes.
    """
    if numpy.all(extents == 0.):
        # That the default setting.
        return
    if not hasattr(module, 'actor'):
        print 'Cannot set extents for %s' % module
        return
    xmin, xmax, ymin, ymax, zmin, zmax = extents
    xo = 0.5 * (xmax + xmin)
    yo = 0.5 * (ymax + ymin)
    zo = 0.5 * (zmax + zmin)
    extentx = 0.5 * (xmax - xmin)
    extenty = 0.5 * (ymax - ymin)
    extentz = 0.5 * (zmax - zmin)
    # Now the actual bounds.
    xmin, xmax, ymin, ymax, zmin, zmax = module.actor.actor.bounds
    # Scale the object
    boundsx = 0.5 * (xmax - xmin)
    boundsy = 0.5 * (ymax - ymin)
    boundsz = 0.5 * (zmax - zmin)
    xs, ys, zs = module.actor.actor.scale
    if not numpy.allclose(xmin, xmax):
        scalex = xs * extentx / boundsx
    else:
        scalex = 1
    if not numpy.allclose(ymin, ymax):
        scaley = ys * extenty / boundsy
    else:
        scaley = 1
    if not numpy.allclose(zmin, zmax):
        scalez = zs * extentz / boundsz
    else:
        scalez = 1

    module.actor.actor.scale = (scalex, scaley, scalez)
    ## Remeasure the bounds
    xmin, xmax, ymin, ymax, zmin, zmax = module.actor.actor.bounds
    xcenter = 0.5 * (xmax + xmin)
    ycenter = 0.5 * (ymax + ymin)
    zcenter = 0.5 * (zmax + zmin)
    # Center the object
    module.actor.actor.origin = (0.,  0.,  0.)
    xpos, ypos, zpos = module.actor.actor.position
    module.actor.actor.position = (xpos + xo - xcenter, ypos + yo - ycenter,
                                            zpos + zo - zcenter)


def start_recording(ui=True):
    """Start automatic script recording.  If the `ui` parameter is
    `True`, it creates a recorder with a user interface, if not it
    creates a vanilla recorder without a UI.

    **Returns**
        The `Recorder` instance created.
    """
    from apptools.scripting.api import start_recording as start
    e = get_engine()
    msg = "Current engine, %s, is already being recorded." % (e)
    assert e.recorder is None, msg
    r = start(e, ui=ui)
    return r


def stop_recording(file=None):
    """Stop the automatic script recording.

    **Parameters**

     :file: An open file or a filename or `None`.  If this is `None`,
            nothing is saved.

    """
    from apptools.scripting.api import stop_recording as stop
    e = get_engine()
    r = e.recorder
    if r is not None:
        stop(e, save=False)
        if type(file) in types.StringTypes:
            f = open(file, 'w')
            r.save(f)
            f.close()
        elif hasattr(file, 'write') and hasattr(file, 'flush'):
            r.save(file)

########NEW FILE########
__FILENAME__ = version
# Wrapped in a try/except in those situations where someone hasn't installed
# as an egg.  What do we do then?  For now, we just punt since we don't want
# to define the version number in two places.
try:
    import pkg_resources
    version = pkg_resources.require('Mayavi')[0].version
except:
    version = ''



########NEW FILE########
__FILENAME__ = __version__
"""Version information for MayaVi2.
"""
# Author: Prabhu Ramachandran <prabhu_r@users.sf.net>
# Copyright (c) 2006, Enthought, Inc.
# License: BSD Style.

from mayavi.version import version as __version__

########NEW FILE########
__FILENAME__ = mlab_reference
"""
Script to generate the function reference for mlab.

"""
# Author: Gael Varoquaux <gael dot varoquaux at normalesup dot org>
# Copyright (c) 2007, Enthought, Inc.
# License: BSD Style.

import os
import sys

DEFAULT_INPUT_DIR = os.path.join('docs', 'source')
OUT_DIR = os.sep.join(
        [os.path.dirname(os.path.abspath(__file__)), DEFAULT_INPUT_DIR,
                'mayavi','auto']
            )

from mayavi.tools import auto_doc
from mayavi import mlab

from inspect import getmembers, getsource, getargspec, formatargspec
from docutils import io as docIO
from docutils import core as docCore

# We need to exec render_image, as we can't import it, because it is not
# in a python package.
render_images = dict(__name__='',
   __file__=os.path.abspath(os.path.join('docs', 'source', 'render_images.py')))
execfile(render_images['__file__'], render_images)
IMAGE_DIR = render_images['IMAGE_DIR']

##############################################################################
def dedent(string):
    if string is not None:
        return auto_doc.dedent(string).lstrip(' ')
    else:
        return '\n'


def indent(lines):
    if lines is None:
        return ''
    return '\n'.join('    '+line for line in lines.split('\n'))


def relpath(target, base=os.curdir):
    """
    Return a relative path to the target from either the current dir or an
    optional base dir. Base can be a directory specified either as absolute
    or relative to current dir.

    Adapted from
    http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/302594
    """

    base_list = (os.path.abspath(base)).split(os.sep)
    target_list = (os.path.abspath(target)).split(os.sep)

    # Starting from the filepath root, work out how much of the filepath is
    # shared by base and target.
    for i in range(min(len(base_list), len(target_list))):
        if base_list[i] <> target_list[i]: break
    else:
        # If we broke out of the loop, i is pointing to the first
        # differing path elements. If we didn't break out of the loop, i
        # is pointing to identical path elements.
        # Increment i so that in all cases it points to the first
        # differing path elements.
        i+=1

    rel_list = [os.pardir] * (len(base_list)-i) + target_list[i:]
    return os.path.join(*rel_list)


def is_valid_rst(string):
    """ Check if the given string can be compiled to rst.
    """
    publisher = docCore.Publisher( source_class = docIO.StringInput,
                        destination_class = docIO.StringOutput )
    publisher.set_components('standalone', 'restructuredtext', 'pseudoxml')
    publisher.process_programmatic_settings(None, None, None)
    publisher.set_source(string, None)

    compiled_rst = publisher.reader.read(publisher.source,
                                publisher.parser, publisher.settings)

    if compiled_rst.parse_messages:
        return False
    else:
        return True


def document_function(func, func_name=None, example_code=None,
                            image_file=None):
    """ Creates a rst documentation string for the function, with an
        image and a example code, if given.
    """
    if func_name==None:
        func_name = func.__name__

    func_doc = func.__doc__

    if func_doc is None:
        print 'function %s is undocumented' % func_name
        func_doc = '\n\n'
    else:
        if is_valid_rst(func_doc):
            func_doc = dedent(func_doc)
        else:
            func_doc = "\n::\n" + func_doc

    func_signature = formatargspec(*getargspec(func))

    documentation = """
%(func_name)s
%(title_line)s

.. function:: %(func_name)s%(func_signature)s

%(func_doc)s

    """ % {
            'func_name' : func_name,
            'title_line': '~'*len(func_name),
            'func_signature': func_signature,
            'func_doc'  : indent(dedent(func_doc))
          }

    if image_file is not None:
        documentation += """

.. image:: %s

""" % image_file

    if example_code is not None:
        documentation += """
**Example** (run in ``ipython -wthread``, ``ipython --gui=wx`` for recent
IPython versions, or in the mayavi2 interactive shell,
see :ref:`running-mlab-scripts` for more info)::

%s
""" % indent(example_code)

    return documentation


##############################################################################
class ModuleReference(object):
    """ The object representing the documentation pages for mlab.
    """

    # Filename of the entry point for the module documentation.
    filename = 'mlab_reference.rst'

    # Directory for the output rst files.
    out_dir = OUT_DIR

    # Directory where the illustration files can be found.
    image_dir = IMAGE_DIR

    # Module to document
    module = None

    # Submodule to classify by
    sub_modules = ()

    # Headers for the sub modules
    sub_headers = None

    # Filenames for the sub modules
    sub_filenames = None

    # Titles for the sub modules pages
    sub_modules_titles = None

    # Header for the main file
    header = ''

    # Footer for the main file
    footer = ''

    # Misc entries that are in no submodules.
    # If this is None, no separate page will be created
    misc_title = None

    # Misc file name
    misc_filename = None

    def __init__(self, **kwargs):
        self.__dict__.update(kwargs)


    def document_function(self, func_name):
        """ Return the documentation page string for a function, with
            automatic discovery of the example and image.
        """
        func = getattr(self.module, func_name)

        print >>sys.stderr, "Documenting function %s" % func_name

        if hasattr(self.module, 'test_' + func_name):
            example_code = getsource(
                                getattr(self.module, 'test_' + func_name))
            example_code = """
import numpy
from mayavi.mlab import *

%s
            """ % example_code
        else:
            example_code = None

        image_file = self.image_dir + os.sep + \
                        self.module.__name__.replace('.', '_') + '_' \
                        + func_name + '.jpg'

        if not os.path.exists(image_file):
            image_file = None
        else:
            image_file = relpath(image_file, self.out_dir)

        documentation = document_function(func,
                                func_name=func_name,
                                example_code=example_code,
                                image_file=image_file)

        return documentation


    def write_doc(self):
        """ Entry point of the object: goes throught the module and
            writes the docs to the disk.
        """
        self.to_document = set([name
                            for name, func in getmembers(self.module)
                            if not ( name[:5] == 'test_' or name[0] == '_')
                                                     and callable(func)])

        outfile = file(os.sep.join([self.out_dir, self.filename]), 'w')

        outfile.write(self.header)

        outfile.write("""

.. module:: %s

.. toctree::

""" % self.module.__name__)

        if self.sub_modules_titles is None:
            self.sub_modules_titles = ['' for submodule in self.sub_modules]
        if self.sub_headers is None:
            self.sub_headers = ['' for submodule in self.sub_modules]
        if self.sub_filenames is None:
            self.sub_filenames = ['%s.rst' for submodule in self.sub_modules]

        # Document the functions imported from a submodule
        for submodule, header, filename, title in zip(
                    self.sub_modules, self.sub_headers,
                    self.sub_filenames, self.sub_modules_titles):

            self.write_doc_submodule(filename, title=title,
                                    header=header,
                                    submodulename=submodule)
            outfile.write('\t%s\n' % filename)

        # And now the rest
        if self.misc_filename is None:
            misc_filename = self.module.__name__ + '.misc'
        else:
            misc_filename = self.misc_filename
        self.write_doc_submodule(misc_filename, title=self.misc_title)

        if self.misc_title is None:
            outfile.write("""

.. include:: %s

""" % misc_filename)
        else:
            outfile.write('\t%s\n' % misc_filename)

        outfile.write(self.footer)
        outfile.write('\n\n')


    def write_doc_submodule(self, filename, title=None,
                    header=None, submodulename=None):
        """ Writes the docs only for the functions defined in a given
            submodule. If submodule is none, all the non-processed
            functions are processed.
        """
        outfile = file(os.sep.join([self.out_dir, filename]), 'w')

        if header is not None:
            outfile.write(header)

        outfile.write('''

.. currentmodule:: %s

.. note::

    This section is only a reference describing the function, please see
    the chapter on :ref:`simple-scripting-with-mlab` for an introduction to
    mlab and how to interact with and assemble the functions of `mlab`.

    Please see the section on :ref:`running-mlab-scripts` for
    instructions on running the examples.

''' % self.module.__name__ )
        if title is not None:
            outfile.write(title + '\n')
            outfile.write('='*len(title) + '\n')

        documented = set()

        for func_name in sorted(self.to_document):
            func = getattr(self.module, func_name)

            if (    submodulename is not None
                    and not func.__module__ == submodulename ):
                continue

            outfile.write(self.document_function(func_name))
            outfile.write("\n\n")
            documented.add(func_name)

        self.to_document.difference_update(documented)


#############################################################################
# Entry point

if __name__ == '__main__':
    try:
        os.makedirs(OUT_DIR)
    except:
        pass


    #########################################################################
    # The main mlab module.
    from mayavi.tools import helper_functions, camera, \
            decorations, figure

    sub_modules = [helper_functions, figure, decorations, camera]

    mlab_reference = ModuleReference(
            filename = 'mlab_reference.rst',
            module  = mlab,
            header  = """

.. _mlab-reference:

MLab reference
=================

Reference list of all the main functions of ``mayavi.mlab``
with documentation and examples.

.. note::

    This section is only a reference describing the function, please see
    the chapter on :ref:`simple-scripting-with-mlab` for an introduction to
    mlab and how to run the examples or interact with and assemble
    the functions of `mlab`.

""",
            footer = """\t../mlab_pipeline_reference.rst\n""",
            sub_modules = [module.__name__ for module in sub_modules],
            sub_filenames = ['mlab_%s.rst' % module.__name__.split('.')[-1]
                                for module in sub_modules],
            sub_modules_titles = ['Plotting functions',
                                 'Figure handling functions',
                                 'Figure decoration functions',
                                 'Camera handling functions'],
            misc_title = 'Other functions',
            misc_filename = 'mlab_other_functions.rst',
            )


    mlab_reference.write_doc()

    #########################################################################
    # The mlab.pipeline module, sources functions.
    from mayavi.tools import pipeline, sources, tools, \
                    probe_data

    pipeline_reference = ModuleReference(
            filename = 'mlab_pipeline_reference.rst',
            module  = pipeline,
            header  = """

.. _mlab-pipeline-reference:

MLab pipeline reference
========================

Reference list of all the main functions of
``pipeline`` sub module of ``mlab``. You can access these functions
using::

    mlab.pipeline.function(...)

These functions can be used for finer control of the Mayavi
pipeline than the main mlab interface. For usage examples, see
:ref:`ontrolling-the-pipeline-with-mlab-scripts`.

""",
            sub_modules = [sources.__name__, tools.__name__,
                           probe_data.__name__],
            sub_filenames = ['mlab_pipeline_sources.rst',
                             'mlab_pipeline_tools.rst',
                             'mlab_pipeline_data.rst'],
            sub_modules_titles = ['Sources', 'Tools', 'Data'],
            misc_title = 'Filters, modules, other functions',
            misc_filename = 'mlab_pipeline_other_functions.rst',
            )

    pipeline_reference.write_doc()


########NEW FILE########
__FILENAME__ = cm2lut
#!/usr/bin/env python
"""
Script used to create lut lists used by mayavi from matplotlib colormaps.
This requires matlplotlib to be installed and should not be ran by the
user, but only once in a while to synchronize with MPL developpement.
"""
# Authors: Frederic Petit <fredmfp@gmail.com>,
#          Gael Varoquaux <gael.varoquaux@normalesup.org>
# Copyright (c) 2007-2009, Enthought, Inc.
# License: BSD Style.

import os
import numpy as np

from matplotlib.cm import datad, get_cmap
from mayavi.core import lut as destination_module
from apptools.persistence import state_pickler
target_dir = os.path.dirname(destination_module.__file__)

values = np.linspace(0., 1., 256)

lut_dic = {}

for name in datad.keys():
    if name.endswith('_r'):
        continue
    lut_dic[name] = get_cmap(name)(values.copy())

out_name = os.path.join(target_dir, 'pylab_luts.pkl')
state_pickler.dump(lut_dic, out_name)


########NEW FILE########
__FILENAME__ = gen_lut_previews
"""
Script to generate the preview images for the mayavi2 LUTs.

Requires ImageMagick.
"""
import os

from mayavi import mlab
from mayavi.core.lut_manager import lut_mode_list, lut_image_dir

import numpy as np

# Create some data
X = np.arange(0, 255)
X = X * np.ones((200, 1))

mlab.clf()
image = mlab.imshow(X.T)
mlab.view(0, 0, 118)
# Make a preview for each possible lut
for lut in lut_mode_list():
    filebasename = os.path.join(lut_image_dir, lut.lower())
    if not lut == 'file':
        image.module_manager.scalar_lut_manager.lut_mode = lut
        mlab.savefig(filebasename + '.png', size=(80, 20))
        #os.system('convert %s.png %s.gif &' %(filebasename, filebasename))
        os.system('montage -geometry -0-0 -label "%s"  %s.png   %s.gif &'
                        % (lut, filebasename, filebasename) )

########NEW FILE########
__FILENAME__ = api
# Author: Prabhu Ramachandran
# License: BSD style

# The external API for tvtk.


# The version of TVTK that is installed
from tvtk.version import version, version as __version__

# The TVTK pseudo-module.
from tvtk.tvtk_access import tvtk

# Handy colors from VTK.
from vtk.util import colors

# Some miscellaneous functionality.
from tvtk.misc import write_data

########NEW FILE########
__FILENAME__ = array_handler
"""
This module contains all the array handling code for TVTK.

The most important functions provided by this module involve the
conversion of numpy arrays/Python lists to different VTK data arrays
and vice-versa.

Warning: Numpy Character arrays will not work properly since there
seems no unique one-to-one VTK data array type to map it to.

"""
# Author: Prabhu Ramachandran <prabhu_r@users.sf.net>
# Copyright (c) 2004-2008,  Enthought, Inc.
# License: BSD Style.

import types
import sys

import vtk
from vtk.util import vtkConstants
try:
    from vtk.util import numpy_support
except ImportError:
    numpy_support = None

import numpy

# Enthought library imports.
from tvtk.array_ext import set_id_type_array
from tvtk.common import is_old_pipeline

# Useful constants for VTK arrays.
VTK_ID_TYPE_SIZE = vtk.vtkIdTypeArray().GetDataTypeSize()
if VTK_ID_TYPE_SIZE == 4:
    ID_TYPE_CODE = numpy.int32
elif VTK_ID_TYPE_SIZE == 8:
    ID_TYPE_CODE = numpy.int64

VTK_LONG_TYPE_SIZE = vtk.vtkLongArray().GetDataTypeSize()
if VTK_LONG_TYPE_SIZE == 4:
    LONG_TYPE_CODE = numpy.int32
    ULONG_TYPE_CODE = numpy.uint32
elif VTK_LONG_TYPE_SIZE == 8:
    LONG_TYPE_CODE = numpy.int64
    ULONG_TYPE_CODE = numpy.uint64

BASE_REFERENCE_COUNT = vtk.vtkObject().GetReferenceCount()


######################################################################
# The array cache.
######################################################################
class ArrayCache(object):

    """Caches references to numpy arrays that are not copied but views
    of which are converted to VTK arrays.  The caching prevents the user
    from deleting or resizing the numpy array after it has been sent
    down to VTK.  The cached arrays are automatically removed when the
    VTK array destructs."""

    ######################################################################
    # `object` interface.
    ######################################################################
    def __init__(self):
        # The cache.
        self._cache = {}

    def __len__(self):
        return len(self._cache)

    def __contains__(self, vtk_arr):
        key = vtk_arr.__this__
        return self._cache.has_key(key)

    ######################################################################
    # `ArrayCache` interface.
    ######################################################################
    def add(self, vtk_arr, np_arr):
        """Add numpy array corresponding to the vtk array to the
        cache."""
        key = vtk_arr.__this__
        cache = self._cache

        # Setup a callback so this cached array reference is removed
        # when the VTK array is destroyed.  Passing the key to the
        # `lambda` function is necessary because the callback will not
        # receive the object (it will receive `None`) and thus there
        # is no way to know which array reference one has to remove.
        vtk_arr.AddObserver('DeleteEvent', lambda o, e, key=key: \
                            self._remove_array(key))

        # Cache the array
        cache[key] = np_arr

    def get(self, vtk_arr):
        """Return the cached numpy array given a VTK array."""
        key = vtk_arr.__this__
        return self._cache[key]

    ######################################################################
    # Non-public interface.
    ######################################################################
    def _remove_array(self, key):
        """Private function that removes the cached array.  Do not
        call this unless you know what you are doing."""
        try:
            del self._cache[key]
        except KeyError:
            pass


######################################################################
# Setup a global `_array_cache`.  The array object cache caches all the
# converted numpy arrays that are not copied.  This prevents the user
# from deleting or resizing the numpy array after it has been sent down
# to VTK.
######################################################################

_dummy = None
# This makes the cache work even when the module is reloaded.
for name in ['array_handler', 'tvtk.array_handler']:
    if sys.modules.has_key(name):
        mod = sys.modules[name]
        if hasattr(mod, '_array_cache'):
            _dummy = mod._array_cache
        del mod
        break

if _dummy:
    _array_cache = _dummy
else:
    _array_cache = ArrayCache()
del _dummy



######################################################################
# Array conversion functions.
######################################################################
def get_vtk_array_type(numeric_array_type):
    """Returns a VTK typecode given a numpy array."""
    # This is a Mapping from numpy array types to VTK array types.
    _arr_vtk = {numpy.dtype(numpy.character):vtkConstants.VTK_UNSIGNED_CHAR,
                numpy.dtype(numpy.uint8):vtkConstants.VTK_UNSIGNED_CHAR,
                numpy.dtype(numpy.uint16):vtkConstants.VTK_UNSIGNED_SHORT,
                numpy.dtype(numpy.int8):vtkConstants.VTK_CHAR,
                numpy.dtype(numpy.int16):vtkConstants.VTK_SHORT,
                numpy.dtype(numpy.int32):vtkConstants.VTK_INT,
                numpy.dtype(numpy.uint32):vtkConstants.VTK_UNSIGNED_INT,
                numpy.dtype(numpy.float32):vtkConstants.VTK_FLOAT,
                numpy.dtype(numpy.float64):vtkConstants.VTK_DOUBLE,
                numpy.dtype(numpy.complex64):vtkConstants.VTK_FLOAT,
                numpy.dtype(numpy.complex128):vtkConstants.VTK_DOUBLE,
                }
    _extra = {numpy.dtype(ID_TYPE_CODE):vtkConstants.VTK_ID_TYPE,
              numpy.dtype(ULONG_TYPE_CODE):vtkConstants.VTK_UNSIGNED_LONG,
              numpy.dtype(LONG_TYPE_CODE):vtkConstants.VTK_LONG,
             }
    for t in _extra:
        if t not in _arr_vtk:
            _arr_vtk[t] = _extra[t]

    try:
        return _arr_vtk[numeric_array_type]
    except KeyError:
        for key in _arr_vtk:
            if numpy.issubdtype(numeric_array_type, key):
                return _arr_vtk[key]
    raise TypeError, "Couldn't translate array's type to VTK"

def get_vtk_to_numeric_typemap():
    """Returns the VTK array type to numpy array type mapping."""
    _vtk_arr = {vtkConstants.VTK_BIT:numpy.bool,
                vtkConstants.VTK_CHAR:numpy.int8,
                vtkConstants.VTK_UNSIGNED_CHAR:numpy.uint8,
                vtkConstants.VTK_SHORT:numpy.int16,
                vtkConstants.VTK_UNSIGNED_SHORT:numpy.uint16,
                vtkConstants.VTK_INT:numpy.int32,
                vtkConstants.VTK_UNSIGNED_INT:numpy.uint32,
                vtkConstants.VTK_LONG:LONG_TYPE_CODE,
                vtkConstants.VTK_UNSIGNED_LONG:ULONG_TYPE_CODE,
                vtkConstants.VTK_ID_TYPE:ID_TYPE_CODE,
                vtkConstants.VTK_FLOAT:numpy.float32,
                vtkConstants.VTK_DOUBLE:numpy.float64}
    return _vtk_arr


def get_numeric_array_type(vtk_array_type):
    """Returns a numpy array typecode given a VTK array type."""
    return get_vtk_to_numeric_typemap()[vtk_array_type]


def get_sizeof_vtk_array(vtk_array_type):
    """Returns the size of a VTK array type."""
    _size_dict = {vtkConstants.VTK_BIT : 1,
                  vtkConstants.VTK_CHAR : 1,
                  vtkConstants.VTK_UNSIGNED_CHAR : 1,
                  vtkConstants.VTK_SHORT : 2,
                  vtkConstants.VTK_UNSIGNED_SHORT : 2,
                  vtkConstants.VTK_INT : 4,
                  vtkConstants.VTK_UNSIGNED_INT : 4,
                  vtkConstants.VTK_LONG : VTK_LONG_TYPE_SIZE,
                  vtkConstants.VTK_UNSIGNED_LONG : VTK_LONG_TYPE_SIZE,
                  vtkConstants.VTK_ID_TYPE : VTK_ID_TYPE_SIZE,
                  vtkConstants.VTK_FLOAT : 4,
                  vtkConstants.VTK_DOUBLE : 8 }
    return _size_dict[vtk_array_type]


def create_vtk_array(vtk_arr_type):
    """Internal function used to create a VTK data array from another
    VTK array given the VTK array type.
    """
    tmp = vtk.vtkDataArray.CreateDataArray(vtk_arr_type)
    # CreateDataArray sets the refcount to 3 and this causes a severe
    # memory leak.
    tmp.SetReferenceCount(BASE_REFERENCE_COUNT)
    return tmp


def array2vtk(num_array, vtk_array=None):
    """Converts a real numpy Array (or a Python list) to a VTK array
    object.

    This function only works for real arrays.  Complex arrays are NOT
    handled.  It also works for multi-component arrays.  However, only
    1, and 2 dimensional arrays are supported.  This function is very
    efficient, so large arrays should not be a problem.

    Even in cases when no copy of the numpy array data is performed,
    a reference to the array is cached.  The passed array can
    therefore be deleted safely in all circumstances.

    Parameters
    ----------

    - num_array : numpy array or Python list/tuple

      The input array must be 1 or 2D.  A copy of the numeric array
      data passed is made in the following circumstances:

       1. A Python list/tuple was passed.
       2. A non-contiguous numpy array was passed.
       3. A `vtkBitArray` instance was passed as the second argument.
       4. The types of the `vtk_array` and the `num_array` are not
          equivalent to each other.  For example if one is an integer
          array and the other a float.


    - vtk_array : `vtkDataArray` (default: `None`)

      If an optional `vtkDataArray` instance, is passed as an argument
      then a new array is not created and returned.  The passed array
      is itself returned.

    """

    z = numpy.asarray(num_array)

    shape = z.shape
    assert len(shape) < 3, \
           "Only arrays of dimensionality 2 or lower are allowed!"
    assert not numpy.issubdtype(z.dtype, complex), \
           "Complex numpy arrays cannot be converted to vtk arrays."\
           "Use real() or imag() to get a component of the array before"\
           " passing it to vtk."

    # First create an array of the right type by using the typecode.
    # Bit arrays need special casing.
    bit_array = False
    if vtk_array is None:
        vtk_typecode = get_vtk_array_type(z.dtype)
        result_array = create_vtk_array(vtk_typecode)
    elif vtk_array.GetDataType() == vtkConstants.VTK_BIT:
        vtk_typecode = vtkConstants.VTK_CHAR
        result_array = create_vtk_array(vtkConstants.VTK_CHAR)
        bit_array = True
    else:
        vtk_typecode = vtk_array.GetDataType()
        result_array = vtk_array

    # Find the shape and set number of components.
    if len(shape) == 1:
        result_array.SetNumberOfComponents(1)
    else:
        result_array.SetNumberOfComponents(shape[1])

    result_array.SetNumberOfTuples(shape[0])

    # Ravel the array appropriately.
    arr_dtype = get_numeric_array_type(vtk_typecode)
    if numpy.issubdtype(z.dtype, arr_dtype):
        z_flat = numpy.ravel(z)
    else:
        z_flat = numpy.ravel(z).astype(arr_dtype)

    # Point the VTK array to the numpy data.  The last argument (1)
    # tells the array not to deallocate.
    result_array.SetVoidArray(numpy.getbuffer(z_flat), len(z_flat), 1)

    if bit_array:
        # Handle bit arrays -- they have to be copied.  Note that bit
        # arrays are used ONLY when the user has passed one as an
        # argument to this function.
        vtk_array.SetNumberOfTuples(result_array.GetNumberOfTuples())
        vtk_array.SetNumberOfComponents(result_array.GetNumberOfComponents())
        for i in range(result_array.GetNumberOfComponents()):
            vtk_array.CopyComponent(i, result_array, i)
        result_array = vtk_array
    else:
        # Save a reference to the flatted array in the array cache.
        # This prevents the user from deleting or resizing the array
        # and getting into serious trouble.  This is only done for
        # non-bit array cases where the data is not copied.
        global _array_cache
        _array_cache.add(result_array, z_flat)

    return result_array


def vtk2array(vtk_array):
    """Converts a VTK data array to a numpy array.

    Given a subclass of vtkDataArray, this function returns an
    appropriate numpy array containing the same data.  The function
    is very efficient since it uses the VTK imaging pipeline to
    convert the data.  If a sufficiently new version of VTK (5.2) is
    installed then it actually uses the buffer interface to return a
    view of the VTK array in the returned numpy array.

    Parameters
    ----------

    - vtk_array : `vtkDataArray`

      The VTK data array to be converted.

    """
    typ = vtk_array.GetDataType()
    assert typ in get_vtk_to_numeric_typemap().keys(), \
           "Unsupported array type %s"%typ

    shape = vtk_array.GetNumberOfTuples(), \
            vtk_array.GetNumberOfComponents()
    if shape[0] == 0:
        dtype = get_numeric_array_type(typ)
        return numpy.array([], dtype)

    # First check if this array already has a numpy array cached, if
    # it does, reshape that and return it.
    if vtk_array in _array_cache:
        arr = _array_cache.get(vtk_array)
        if shape[1] == 1:
            shape = (shape[0], )
        arr = numpy.reshape(arr, shape)
        return arr

    # If VTK's new numpy support is available, use the buffer interface.
    if numpy_support is not None and typ != vtkConstants.VTK_BIT:
        dtype = get_numeric_array_type(typ)
        result = numpy.frombuffer(vtk_array, dtype=dtype)
        if shape[1] == 1:
            shape = (shape[0], )
        result.shape = shape
        return result

    # Setup an imaging pipeline to export the array.
    img_data = vtk.vtkImageData()
    img_data.SetDimensions(shape[0], 1, 1)
    if typ == vtkConstants.VTK_BIT:
        iarr = vtk.vtkCharArray()
        iarr.DeepCopy(vtk_array)
        img_data.GetPointData().SetScalars(iarr)
    elif typ == vtkConstants.VTK_ID_TYPE:
        # Needed since VTK_ID_TYPE does not work with VTK 4.5.
        iarr = vtk.vtkLongArray()
        iarr.SetNumberOfTuples(vtk_array.GetNumberOfTuples())
        nc = vtk_array.GetNumberOfComponents()
        iarr.SetNumberOfComponents(nc)
        for i in range(nc):
            iarr.CopyComponent(i, vtk_array, i)
        img_data.GetPointData().SetScalars(iarr)
    else:
        img_data.GetPointData().SetScalars(vtk_array)

    if is_old_pipeline():
        img_data.SetNumberOfScalarComponents(shape[1])
        if typ == vtkConstants.VTK_ID_TYPE:
            # Hack necessary because vtkImageData can't handle VTK_ID_TYPE.
            img_data.SetScalarType(vtkConstants.VTK_LONG)
            r_dtype = get_numeric_array_type(vtkConstants.VTK_LONG)
        elif typ == vtkConstants.VTK_BIT:
            img_data.SetScalarType(vtkConstants.VTK_CHAR)
            r_dtype = get_numeric_array_type(vtkConstants.VTK_CHAR)
        else:
            img_data.SetScalarType(typ)
            r_dtype = get_numeric_array_type(typ)
        img_data.Update()
    else:
        if typ == vtkConstants.VTK_ID_TYPE:
            r_dtype = get_numeric_array_type(vtkConstants.VTK_LONG)
        elif typ == vtkConstants.VTK_BIT:
            r_dtype = get_numeric_array_type(vtkConstants.VTK_CHAR)
        else:
            r_dtype = get_numeric_array_type(typ)
        img_data.Modified()

    exp = vtk.vtkImageExport()
    if is_old_pipeline():
        exp.SetInput(img_data)
    else:
        exp.SetInputData(img_data)

    # Create an array of the right size and export the image into it.
    im_arr = numpy.empty((shape[0]*shape[1],), r_dtype)
    exp.Export(im_arr)

    # Now reshape it.
    if shape[1] == 1:
        shape = (shape[0], )
    im_arr = numpy.reshape(im_arr, shape)
    return im_arr


def array2vtkCellArray(num_array, vtk_array=None):
    """Given a nested Python list or a numpy array, this method
    creates a vtkCellArray instance and returns it.

    A variety of input arguments are supported as described in the
    Parameter documentation.  If numpy arrays are given, this method
    is highly efficient.  This function is most efficient if the
    passed numpy arrays have a typecode `ID_TYPE_CODE`.  Otherwise a
    typecast is necessary and this involves an extra copy.  This
    method *always copies* the input data.

    An alternative and more efficient way to build the connectivity
    list is to create a vtkIdTypeArray having data of the form
    (npts,p0,p1,...p(npts-1), repeated for each cell) and then call
    <vtkCellArray_instance>.SetCells(n_cell, id_list).

    Parameters
    ----------

    - num_array : numpy array or Python list/tuple

      Valid values are:

        1. A Python list of 1D lists.  Each 1D list can contain one
           cell connectivity list.  This is very slow and is to be
           used only when efficiency is of no consequence.

        2. A 2D numpy array with the cell connectivity list.

        3. A Python list of 2D numpy arrays.  Each numeric array can
           have a different shape.  This makes it easy to generate a
           cell array having cells of different kinds.

    - vtk_array : `vtkCellArray` (default: `None`)

      If an optional `vtkCellArray` instance, is passed as an argument
      then a new array is not created and returned.  The passed array
      is itself modified and returned.

    Example
    -------

       >>> a = [[0], [1, 2], [3, 4, 5], [6, 7, 8, 9]]
       >>> cells = array_handler.array2vtkCellArray(a)
       >>> a = numpy.array([[0,1,2], [3,4,5], [6,7,8]], 'l')
       >>> cells = array_handler.array2vtkCellArray(a)
       >>> l_a = [a[:,:1], a[:2,:2], a]
       >>> cells = array_handler.array2vtkCellArray(l_a)

    """
    if vtk_array:
        cells = vtk_array
    else:
        cells = vtk.vtkCellArray()
    assert cells.GetClassName() == 'vtkCellArray', \
           'Second argument must be a `vtkCellArray` instance.'

    if len(num_array) == 0:
        return cells

    ########################################
    # Internal functions.
    def _slow_array2cells(z, cells):
        cells.Reset()
        vtk_ids = vtk.vtkIdList()
        for i in z:
            vtk_ids.Reset()
            for j in i:
                vtk_ids.InsertNextId(j)
            cells.InsertNextCell(vtk_ids)

    def _get_tmp_array(arr):
        try:
            tmp_arr = numpy.asarray(arr, ID_TYPE_CODE)
        except TypeError:
            tmp_arr = arr.astype(ID_TYPE_CODE)
        return tmp_arr

    def _set_cells(cells, n_cells, id_typ_arr):
        vtk_arr = vtk.vtkIdTypeArray()
        array2vtk(id_typ_arr, vtk_arr)
        cells.SetCells(n_cells, vtk_arr)
    ########################################

    msg = "Invalid argument.  Valid types are a Python list of lists,"\
          " a Python list of numpy arrays, or a numpy array."

    if issubclass(type(num_array), (types.ListType, types.TupleType)):
        assert len(num_array[0]) > 0, "Input array must be 2D."
        tp = type(num_array[0])
        if issubclass(tp, types.ListType): # Pure Python list.
            _slow_array2cells(num_array, cells)
            return cells
        elif issubclass(tp, numpy.ndarray):  # List of arrays.
            # Check shape of array and find total size.
            tot_size = 0
            n_cells = 0
            for arr in num_array:
                assert len(arr.shape) == 2, "Each array must be 2D"
                shp = arr.shape
                tot_size += shp[0]*(shp[1] + 1)
                n_cells += shp[0]
            # Create an empty array.
            id_typ_arr = numpy.empty((tot_size,), ID_TYPE_CODE)
            # Now populate it with the ids.
            count = 0
            for arr in num_array:
                tmp_arr = _get_tmp_array(arr)
                shp = arr.shape
                sz = shp[0]*(shp[1] + 1)
                set_id_type_array(tmp_arr, id_typ_arr[count:count+sz])
                count += sz
            # Now set them cells.
            _set_cells(cells, n_cells, id_typ_arr)
            return cells
        else:
            raise TypeError, msg
    elif issubclass(type(num_array), numpy.ndarray):
        assert len(num_array.shape) == 2, "Input array must be 2D."
        tmp_arr = _get_tmp_array(num_array)
        shp = tmp_arr.shape
        id_typ_arr = numpy.empty((shp[0]*(shp[1] + 1),), ID_TYPE_CODE)
        set_id_type_array(tmp_arr, id_typ_arr)
        _set_cells(cells, shp[0], id_typ_arr)
        return cells
    else:
        raise TypeError, msg


def array2vtkPoints(num_array, vtk_points=None):
    """Converts a numpy array/Python list to a vtkPoints object.

    Unless a Python list/tuple or a non-contiguous array is given, no
    copy of the data is made.  Thus the function is very efficient.

    Parameters
    ----------

    - num_array : numpy array or Python list/tuple

      The input array must be 2D with `shape[1] == 3`.

    - vtk_points : `vtkPoints` (default: `None`)

      If an optional `vtkPoints` instance, is passed as an argument
      then a new array is not created and returned.  The passed array
      is itself modified and returned.

    """
    if vtk_points:
        points  = vtk_points
    else:
        points = vtk.vtkPoints()

    arr = numpy.asarray(num_array)
    assert len(arr.shape) == 2, "Points array must be 2 dimensional."
    assert arr.shape[1] == 3, "Incorrect shape: shape[1] must be 3."
    vtk_array = array2vtk(arr)
    points.SetData(vtk_array)
    return points


def array2vtkIdList(num_array, vtk_idlist=None):
    """Converts a numpy array/Python list to a vtkIdList object.

    Parameters
    ----------

    - num_array : numpy array or Python list/tuple

      The input array must be 2D with `shape[1] == 3`.

    - vtk_idlist : `vtkIdList` (default: `None`)

      If an optional `vtkIdList` instance, is passed as an argument
      then a new array is not created and returned.  The passed array
      is itself modified and returned.

    """
    if vtk_idlist:
        ids = vtk_idlist
    else:
        ids = vtk.vtkIdList()

    arr = numpy.asarray(num_array)
    assert len(arr.shape) == 1, "Array for vtkIdList must be 1D"
    ids.SetNumberOfIds(len(arr))
    for i, j in enumerate(arr):
        ids.SetId(i, j)
    return ids


######################################################################
# Array argument handling functions.
######################################################################

def is_array(arr):
    """Returns True if the passed `arr` is a numpy array or a List."""
    if issubclass(type(arr), (numpy.ndarray, types.ListType)):
        return True
    return False


def convert_array(arr, vtk_typ=None):
    """Convert the given array to the optional type specified by
    `vtk_typ`.

    Parameters
    ----------

    - arr : numpy array/list.
    - vtk_typ : `string` or `None`
      represents the type the array is to be converted to.

    """
    if vtk_typ:
        conv = {'vtkCellArray': array2vtkCellArray,
                'vtkPoints': array2vtkPoints,
                'vtkIdList': array2vtkIdList}
        if vtk_typ in conv.keys():
            vtk_arr = getattr(vtk, vtk_typ)()
            return conv[vtk_typ](arr, vtk_arr)
        elif vtk_typ.find('Array') > -1:
            try:
                vtk_arr = getattr(vtk, vtk_typ)()
            except TypeError: # vtk_typ == 'vtkDataArray'
                return array2vtk(arr)
            else:
                return array2vtk(arr, vtk_arr)
        else:
            return arr
    else:
        return array2vtk(arr)


def is_array_sig(s):
    """Given a signature, return if the signature has an array."""
    if not isinstance(s, basestring):
        return False
    arr_types = ['Array', 'vtkPoints', 'vtkIdList']
    for i in arr_types:
        if s.find(i) > -1:
            return True
    return False


def is_array_or_vtkarray(arg):
    """Returns True if the argument is an array/Python list or if it
    is a vtk array."""

    if is_array(arg):
        return True
    else:
        if hasattr(arg, '_vtk_obj'):
            if is_array_sig(arg._vtk_obj.__class__.__name__):
                return True
    return False


def get_correct_sig(args, sigs):
    """Given a list of args and a collection of possible signatures,
    this function returns the most appropriate signature.  This
    function is only called by deref_array.  This implies that one of
    the signatures has an array type.

    """
    # First do the trivial cases.
    if sigs is None:
        return None
    if len(sigs) == 1:
        return sigs[0]
    else:
        # Non-trivial cases.
        la = len(args)
        candidate_sigs = [s for s in sigs if len(s) == la]
        count = len(candidate_sigs)
        if count == 0:
            # No sig has the right number of args.
            msg = "Insufficient number of arguments to method."\
                  "Valid arguments are:\n%s"%sigs
            raise TypeError, msg
        elif count == 1:
            # If only one of the sigs has the right number of args,
            # return it.
            return candidate_sigs[0]
        else:
            # More than one sig has the same number of args.
            # Check if args need conversion at all.
            array_idx = [i for i, a in enumerate(args) \
                         if is_array_or_vtkarray(a)]
            n_arr = len(array_idx)
            if n_arr == 0:
                # No conversion necessary so signature info is
                # useless.
                return None
            else:
                # Need to find the right sig.  This is done by finding
                # the first signature that matches all the arrays in
                # the argument.
                for sig in candidate_sigs:
                    array_in_sig = [is_array_sig(s) for s in sig]
                    if array_in_sig.count(True) != len(array_idx):
                        continue
                    bad = False
                    for i in array_idx:
                        if not array_in_sig[i]:
                            bad = True
                    if not bad:
                        return sig
                # Could not find any valid signature, so give up.
                return None


def deref_vtk(obj):
    """Dereferences the VTK object from the object if possible.  This
    is duplicated from `tvtk_base.py` because I'd like to keep this
    module independent of `tvtk_base.py`.
    """
    if hasattr(obj, '_vtk_obj'):
        return obj._vtk_obj
    else:
        return obj


def deref_array(args, sigs=None):
    """Given a bunch of arguments and optional signature information,
    this converts the arguments suitably.  If the argument is either a
    Python list or a numpy array it is converted to a suitable type
    based on the signature information.  If it is not an array, but a
    TVTK object the VTK object is dereferenced.  Otherwise nothing is
    done.  If no signature information is provided the arrays are
    automatically converted (this can sometimes go wrong).  The
    signature information is provided in the form of a list of lists.

    """
    ret = []
    sig = get_correct_sig(args, sigs)
    if sig:
        for a, s in zip(args, sig):
            if is_array(a) and is_array_sig(s):
                ret.append(convert_array(a, s))
            else:
                ret.append(deref_vtk(a))
    else:
        for a in args:
            if is_array(a):
                ret.append(convert_array(a))
            else:
                ret.append(deref_vtk(a))
    return ret

########NEW FILE########
__FILENAME__ = class_tree
# Author: Prabhu Ramachandran
# Copyright (c) 2004-2007, Enthought, Inc.
# License: BSD Style.

"""This module generates the class hierarchy for any given Python
modules.  This can be used (among other things) to generate the
traitified VTK classes in the correct order.

"""

import __builtin__


class TreeNode:
    """Represents a node in the class tree.

    Stores information on the sub and super classes of a particular
    class.  It also stores the inheritance level of the class inside
    the inheritance tree (essentially how many levels of inheritance
    are there below this class).  This inheritance level is computed
    when the `get_level` method is called.  The `get_level` method
    works only when the parent information is complete.

    """

    def __init__(self, klass):
        """Given a class, create a node in the tree.

        Parameters
        ----------
        - klass : `class`

          The class which is represented as a node in the tree.

        """
        self.klass = klass
        self.name = klass.__name__
        self.children = []
        self.parents = []
        # Uninitialized level is set to None
        self.level = None

    def add_parent(self, parent):
        """Add a parent node."""
        assert isinstance(parent, TreeNode)
        if parent not in self.parents:
            self.parents.append(parent)

    def add_child(self, child):
        """Add a child node. """
        assert isinstance(child, TreeNode)
        if child not in self.children:
            self.children.append(child)

    def get_level(self):
        """Returns the inheritance level of the node (an int).  If the
        level has not been set, the method computes it.  Note however,
        that this computation will fail if the parent information is
        incorrect.

        """
        if not self.level:
            if self.parents:
                self.level = max([x.get_level() for x in self.parents]) + 1
            else:
                self.level = 0
        return self.level

    def get_ancestors(self):
        """Returns a list of ancestor nodes from which this class has
        descended.

        """
        def _get_ancestors(node, ancestors):
            ancestors.extend(node.parents)
            for p in node.parents:
                _get_ancestors(p, ancestors)
        ancestors = []
        _get_ancestors(self, ancestors)
        return ancestors


class ClassTree:
    """Contains and generates all the class tree information.

    On initialization of the instance, nothing is done.  The classes
    are obtained using the list of modules (or a single module) that
    is used to initialize the instance.  One must then call the
    `create` method to generate the tree structure.  The instance of
    the class also can be treated as an iterator which iterates over
    the nodes of the tree.

    There are two ways in which the tree hierarchy is stored.  A
    dictionary mapping class names to the tree node and a tree
    represented as a list of lists containing the nodes.  The tree is
    organized based on a concept of an inheritance level.  A class
    that has no parent classes (no base classes) is said to be at
    level zero.  If a class inherits successively from 7 classes, it
    is at level 6.  An example of inheritance for a vtkFoo class is
    given below:

      vtkFoo -> vtkBar -> vtkObject -> vtkObjectBase

    Here, vtkObjectBase has an inheritance level of 0 and vtkFoo a
    level of 3.  One can traverse the tree by using the level as an
    index and find all the classes at a particular level.

    Here is some example usage of this class::

        >>> import vtk
        >>> t = ClassTree(vtk)
        >>> t.create()
        >>> print t.get_node('vtkObject').name
        vtkObject
        >>> print t.get_node('vtkObject').parents[0].name
        vtkObjectBase
        >>> print len(t.tree[0])
        1
        >>> t.tree[0][0].name
        vtkObjectBase

    """

    def __init__(self, modules):
        """Initialize the instance with the given modules.

        Parameters
        ----------

        - modules : `sequence` of modules or a module

          This is either a single module or a sequence of modules.
          The instance uses these list of modules to generate the
          class tree.

        """
        self.nodes = {}
        self.tree = [[]]
        if not hasattr(modules, '__iter__'):
            self.modules = [modules]
        else:
            self.modules = modules

    def __iter__(self):
        return iter(self.nodes.values())

    def _generate_hierarchy(self, klass):
        """Does the hard work of generating the class hierarchy."""
        node = self.get_node(klass.__name__, create=1)
        for base in klass.__bases__:
            base_node = self.get_node_from_class(base, create=1)
            node.add_parent(base_node)
            base_node.add_child(node)
            self._generate_hierarchy(base)

    def get_class(self, name):
        """Given a class name in the given modules returns the class."""
        klass = None
        for m in self.modules:
            if hasattr(m, name):
                return getattr(m, name)
        if hasattr(__builtin__, name):
            klass = getattr(__builtin__, name)
        if not klass:
            try:
                klass = self.nodes[name].klass
            except KeyError:
                raise KeyError, "Cannot find class of name %s"%name
        return klass

    def add_node(self, klass):
        """Create a node for the given class."""
        name = klass.__name__
        if not self.nodes.has_key(name):
            node = TreeNode(klass)
            self.nodes[name] = node
            return node

    def get_node(self, name, create=0):
        """Get a node of the given name.

        Parameters
        ----------

        - name : `str`

          Name of the node to get.

        - create : `boolean`

          If True, a new node will be added if no node of the given
          name is available.  Defaults to False.

        Returns
        -------

        - `TreeNode`

        """
        if self.nodes.has_key(name):
            return self.nodes[name]
        elif create:
            return self.add_node(self.get_class(name))

    def get_node_from_class(self, cls, create=0):
        """Get a node of the given class.

        Parameters
        ----------

        - cls : `class`

          Class of the node to get.

        - create : `boolean`

          If True, a new node will be added if no node of the given
          name is available.  Defaults to False.

        Returns
        -------

        - `TreeNode`

        """
        name = cls.__name__
        if self.nodes.has_key(name):
            return self.nodes[name]
        elif create:
            return self.add_node(cls)

    def create(self, class_names=None):
        """This method generates the class tree given an optional list
        of class names.

        Parameters
        ----------

        - class_names - `list` of `str`

          An optional list of names of the classes to generate the
          tree for.  Defaults to None where the class list is computed
          from the modules.

        """
        if class_names is None:
            class_names = []
            for m in self.modules:
                class_names.extend(dir(m))

        # Generate the nodes.
        for name in class_names:
            klass = self.get_class(name)
            if klass and hasattr(klass, '__bases__'):
                self._generate_hierarchy(klass)

        # Compute the inheritance level and store the nodes in the tree.
        for node in self:
            d = node.get_level()
            while len(self.tree) <= d:
                self.tree.append([])
            self.tree[d].append(node)

        # Sort the nodes alphabetically.
        def _comp(x, y):
            return cmp(x.name, y.name)
        for nodes in self.tree:
            nodes.sort(_comp)

########NEW FILE########
__FILENAME__ = code_gen
"""This module generates tvtk (Traited VTK) classes from the
VTK-Python API.

"""
# Author: Prabhu Ramachandran
# Copyright (c) 2004-2007, Enthought, Inc.
# License: BSD Style.


import vtk
import os
import os.path
import zipfile
import tempfile
import shutil
import glob
from optparse import OptionParser

# Local imports -- these should be relative imports since these are
# imported before the package is installed.
from common import get_tvtk_name, camel2enthought
from wrapper_gen import WrapperGenerator
from special_gen import HelperGenerator


######################################################################
# `TVTKGenerator`
######################################################################

class TVTKGenerator:
    """Generates all the TVTK code."""

    def __init__(self, out_dir=''):
        """Initializes the instance.

        Parameters
        ----------

        - out_dir -  `string`

          The output directory to generate code in.  The directory is
          created if it does not exist.  A directory called
          `tvtk_classes` is created inside this directory and all the
          code is written here.  Any existing code there is blindly
          overwritten.  If no out_dir is specified, a temporary one is
          created using `tempfile.mkdtemp`.

        """
        if not out_dir:
            out_dir = tempfile.mkdtemp()
        self.out_dir = os.path.join(out_dir, 'tvtk_classes')

        if not os.path.exists(self.out_dir):
            os.makedirs(self.out_dir)
        self.zip_name = 'tvtk_classes.zip'

        self.wrap_gen = WrapperGenerator()
        self.helper_gen = HelperGenerator()

    #################################################################
    # `TVTKGenerator` interface.
    #################################################################

    def generate_code(self):
        """Generate all the wrapper code in `self.out_dir`.
        """
        out_dir = self.out_dir
        helper_gen = self.helper_gen
        wrap_gen = self.wrap_gen
        # Create an __init__.py file
        f = open(os.path.join(out_dir, '__init__.py'), 'w')
        f.close()

        # Crete a vtk_version.py file that contains VTK build
        # information.
        v = vtk.vtkVersion()
        vtk_version = v.GetVTKVersion()[:3]
        vtk_src_version = v.GetVTKSourceVersion()
        code ="vtk_build_version = \'%s\'\n"%(vtk_version)
        code += "vtk_build_src_version = \'%s\'\n"%(vtk_src_version)
        f = open(os.path.join(out_dir, 'vtk_version.py'), 'w')
        f.write(code)
        f.close()

        # Write the helper code header.
        helper_file = open(os.path.join(out_dir, 'tvtk_helper.py'), 'w')
        helper_gen.write_prelims(helper_file)

        # Write the wrapper files.
        tree = wrap_gen.get_tree().tree

        #classes = dir(vtk)
        classes = [x.name for x in wrap_gen.get_tree() \
                   if x.name.startswith('vtk') and \
                   not x.name.startswith('vtkQt') and \
                   not issubclass(getattr(vtk, x.name), object) ]
        for nodes in tree:
            for node in nodes:
                if node.name in classes:
                    tvtk_name = get_tvtk_name(node.name)
                    self._write_wrapper_class(node, tvtk_name)
                    helper_gen.add_class(tvtk_name, helper_file)
        helper_file.close()

    def write_wrapper_classes(self, names):
        """Given VTK class names in the list `names`, write out the
        wrapper classes to a suitable file.  This is a convenience
        method so one can generate a just a few of the wrapper classes
        if desired.  This is useful when debugging.  Please note that
        the method also generates code for all the ancestors of the
        specified classes.

        """
        # Wrappers for the ancesors are generated in order to get the
        # _updateable_traits_ information correctly.
        nodes = []
        for name in names:
            node = self.wrap_gen.get_tree().get_node(name)
            if node is None:
                print 'ERROR: Cannot find class: %s'%name
            nodes.append(node)

        # Get ancestors.
        for node in nodes[:]:
            anc = node.get_ancestors()
            for i in anc:
                if i not in nodes:
                    nodes.insert(0, i)
        # Sort them as per their level.
        nodes.sort(lambda x, y: cmp(x.level, y.level))

        # Write code.
        for node in nodes:
            tvtk_name = get_tvtk_name(node.name)
            self._write_wrapper_class(node, tvtk_name)

    def build_zip(self, include_src=False):
        """Build the zip file (with name `self.zip_name`) in the
        current directory.

        Parameters
        ----------

        - include_src : `bool` (default: False)

          If True, also includes all the ``*.py`` files in the ZIP file.
          By default only the ``*.pyc`` files are included.

        """
        cwd = os.getcwd()
        d = os.path.dirname(self.out_dir)
        os.chdir(d)
        z = zipfile.PyZipFile(self.zip_name, 'w',
                              zipfile.ZIP_DEFLATED)
        if include_src:
            l = glob.glob(os.path.join('tvtk_classes', '*.py'))
            for x in l:
                fname = os.path.basename(x)
                z.write(x, 'tvtk_classes/%s'%fname)
        z.writepy('tvtk_classes')
        z.close()
        if os.path.exists(cwd + "/" + self.zip_name):
            os.unlink(cwd + "/" + self.zip_name)
        shutil.move(self.zip_name, cwd)
        os.chdir(cwd)

    def clean(self):
        """Delete the temporary directory where the code has been
        generated.
        """
        tmp_dir = os.path.dirname(self.out_dir)
        d = os.listdir(tmp_dir)
        ok = 0
        if len(d) == 1 and d[0] == 'tvtk_classes':
            ok = 1
        if ok:
            shutil.rmtree(tmp_dir)
        else:
            print "Not removing directory:", tmp_dir
            print "It does not contain a tvtk_classes directory!"

    #################################################################
    # Non-public interface.
    #################################################################
    def _write_wrapper_class(self, node, tvtk_name):
        """Write the wrapper code to a file."""
        # The only reason this method is separate is to generate code
        # for an individual class when debugging.
        fname = camel2enthought(tvtk_name) + '.py'
        out = open(os.path.join(self.out_dir, fname), 'w')
        self.wrap_gen.generate_code(node, out)
        out.close()



######################################################################
# Utility functions.
######################################################################

def main():
    usage = """usage: %prog [options] [vtk_classes]

The options are described below.  An optional list of VTK classes for
which code is to be generated may be specified.  If none are specified
code will be generated for all the VTK classes.
    """
    parser = OptionParser(usage)
    parser.add_option("-o", "--output-dir", action="store",
                      type="string", dest="out_dir", default='',
                      help="Output directory in which to generate code.")
    parser.add_option("-n", "--no-clean", action="store_false",
                      dest="clean", default=True,
                      help="Do not clean the temporary directory.")
    parser.add_option("-z", "--no-zipfile", action="store_false",
                      dest="zip", default=True,
                      help="Do not create a ZIP file.")
    parser.add_option("-s", "--source", action="store_true",
                      dest="src", default=False,
                      help="Include source files (*.py) in addition to *.pyc files in the ZIP file.")

    (options, args) = parser.parse_args()

    # Now do stuff.
    gen = TVTKGenerator(options.out_dir)

    if len(args) == 0:
        gen.generate_code()
    else:
        gen.write_wrapper_classes(args)

    if options.zip:
        gen.build_zip(options.src)

    if options.clean:
        gen.clean()


if __name__ == '__main__':
    main()

########NEW FILE########
__FILENAME__ = common
"""Common functions and classes that do not require any external
dependencies (apart from the standard library of course).

"""
# Author: Prabhu Ramachandran <prabhu_r@users.sf.net>
# Copyright (c) 2005-2007, Enthought, Inc.
# License: BSD Style.

import string
import re
import vtk

vtk_major_version = vtk.vtkVersion.GetVTKMajorVersion()

######################################################################
# Utility functions.
######################################################################

def get_tvtk_name(vtk_name):
    """Converts a VTK class name to a TVTK class name.

    This function additionally converts any leading digits into a
    suitable string.

    For example:

      >>> get_tvtk_name('vtk3DSImporter')
      'ThreeDSImporter'
      >>> get_tvtk_name('vtkXMLDataReader')
      'XMLDataReader'

    """
    if vtk_name[:3] == 'vtk':
        name = vtk_name[3:]
        dig2name = {'1':'One', '2':'Two', '3':'Three', '4':'Four',
                    '5':'Five', '6': 'Six', '7':'Seven', '8':'Eight',
                    '9': 'Nine', '0':'Zero'}

        if name[0] in string.digits:
            return dig2name[name[0]] + name[1:]
        else:
            return name
    else:
        return vtk_name

def is_old_pipeline():
    return vtk_major_version < 6

def configure_connection(obj, inp):
    """ Configure topology for vtk pipeline obj."""
    if hasattr(inp, 'output_port'):
        obj.input_connection = inp.output_port
    elif inp.has_output_port():
        obj.input_connection = inp.get_output_object()
    else:
        configure_input(obj, inp.outputs[0])

def configure_input_data(obj, data):
    """ Configure the input data for vtk pipeline object obj."""
    if is_old_pipeline():
        obj.input = data
    else:
        obj.set_input_data(data)

def configure_input(inp, op):
    """ Configure the inp using op."""
    if is_old_pipeline():
        if op.is_a('vtkDataSet'):
            inp.input = op
        else:
            inp.input = op.output
    else:
        if hasattr(op, 'output_port'):
            inp.input_connection = op.output_port
        elif op.is_a('vtkAlgorithmOutput'):
            inp.input_connection = op
        elif op.is_a('vtkDataSet'):
            inp.set_input_data(op)
        else:
            raise ValueError('Unknown input type for object %s'%op)

def configure_outputs(obj, tvtk_obj):
    if is_old_pipeline():
        obj.outputs = [tvtk_obj.output]
    else:
        if hasattr(tvtk_obj, 'output_port'):
            obj.outputs = [tvtk_obj.output_port]
        else:
            obj.outputs = [tvtk_obj]

def configure_source_data(obj, data):
    """ Configure the source data for vtk pipeline object obj."""
    if is_old_pipeline():
        obj.source = data
    else:
        if data.is_a('vtkAlgorithmOutput'):
            obj.set_source_connection(data)
        else:
            obj.set_source_data(data)

class _Camel2Enthought:
    """Simple functor class to convert names from CamelCase to
    Enthought compatible names.

    For example::
      >>> camel2enthought = _Camel2Enthought()
      >>> camel2enthought('XMLActor2DToSGML')
      'xml_actor2d_to_sgml'

    """

    def __init__(self):
        self.patn = re.compile(r'([A-Z0-9]+)([a-z0-9]*)')
        self.nd_patn = re.compile(r'(\D[123])_D')
    def __call__(self, name):
        ret = self.patn.sub(self._repl, name)
        ret = self.nd_patn.sub(r'\1d', ret)
        if ret[0] == '_':
            ret = ret[1:]
        return ret.lower()
    def _repl(self, m):
        g1 = m.group(1)
        g2 = m.group(2)
        if len(g1) > 1:
            if g2:
                return '_' + g1[:-1] + '_' + g1[-1] + g2
            else:
                return '_' + g1
        else:
            return '_' + g1 + g2

# Instantiate a converter.
camel2enthought = _Camel2Enthought()

########NEW FILE########
__FILENAME__ = indenter
"""This module defines an indenter class that handles indentation
levels for automatic code generation.  It also defines other
miscellaneous classes useful for the tvtk code generation.

"""

# Author: Prabhu Ramachandran
# Copyright (c) 2004, Enthought, Inc.
# License: BSD Style.

import re

# Local imports (there is a good reason for the relative imports).
from common import get_tvtk_name, camel2enthought


######################################################################
# `Indent` class.
######################################################################

class Indent:
    """This class manages indentation levels for dynamically generated
    Python code.  The class also provides a method that formats a text
    string suitably at a given indentation level.

    """
    def __init__(self, nspace=4):
        """Initializes the object.

        Parameters
        ----------

        - nspace : `int`

          Specifies the number of spaces to use for each indentation
          level. Defaults to 4.

        """
        self.tab = ''
        self.txt = ''
        self.nspace = 0
        self.set_tab(nspace)
        self.space_re = re.compile(r'^\s*$')
        self.find_space_re = re.compile(r'\s*(\S)')

    def __repr__(self):
        return self.txt

    def set_tab(self, nspace):
        """Set the number of spaces a tab represents."""
        self.nspace = nspace
        self.tab = ' '*nspace

    def reset(self):
        """Reset the indentation level to 0."""
        self.txt = ''

    def incr(self):
        """Increase the indentation level."""
        self.txt += self.tab

    def decr(self):
        """Decrease the indentation level."""
        self.txt = self.txt[:-self.nspace]

    def format(self, txt):
        """Formats given text as per current indentation levels.

        Note that the returned string always ends with a newline to
        avoid problems for subsequent lines in the output that have to
        deal trailing garbage in the last line.

        Parameters
        ----------

        - txt : `string`

          Input text string to be formatted.  Can contain newlines.

          If the input text is a single line of text then leading
          space is stripped and the current indentation is added to
          the left along with a newline and the resulting string is
          returned.

          If the input text is multi-line input the indentation of the
          first line is ignored, and the second line is considered.
          All subsequent lines have the current indentation followed
          by any extra space from the default indentation.

        """
        space_re = self.space_re
        find_space_re = self.find_space_re

        d = txt.split('\n')
        one_liner = 1
        if len(d) > 1:
            for i in d[1:]:
                if not space_re.match(i):
                    one_liner = 0
                    break
        elif len(d) == 0:
            return '\n'

        if one_liner:
            return '%s%s\n'%(repr(self), d[0].strip())
        else:
            strip_idx = 0
            m = find_space_re.match(d[1])

            try:
                strip_idx = m.start(1)
            except AttributeError:
                strip_idx = 0
            ret = []
            if not space_re.match(d[0]):
                ret.append('%s%s'%(repr(self), d[0]))
            for i in d[1:]:
                if i:
                    ret.append('%s%s'%(repr(self), i[strip_idx:]))
                else:
                    ret.append(repr(self))

            if space_re.match(ret[-1]):
                ret[-1] = ''
            else:
                ret.append('')
            return '\n'.join(ret)


######################################################################
# `VTKDocMassager` class.
######################################################################

class VTKDocMassager:
    """This class massages the documentation strings suitably for
    inclusion in the TVTK code.  The names of all the VTK classes are
    changed suitably and when possible the method names are also
    changed.

    This class is *not* generic and is *very* specific to VTK
    documentation strings.
    """
    def __init__(self):
        self.renamer = re.compile(r'(vtk[A-Z0-9]\S+)')
        self.ren_func = lambda m: get_tvtk_name(m.group(1))
        self.func_re = re.compile(r'([a-z0-9]+[A-Z])')
        self.cpp_method_re = re.compile(r'C\+\+: .*?;\n*')

    #################################################################
    # `VTKDocMassager` interface.
    #################################################################

    def write_class_doc(self, doc, out, indent):
        """Write processed class documentation string into `out`.

        Parameters
        ----------
        - doc : `string`

          The documentation string.

        - out : file line object.

        - indent : `Indent`
        """
        ret = self.massage(doc)
        indent.incr()
        out.write(indent.format('"""'))
        out.write(indent.format('\n' + ret))
        out.write(indent.format('"""'))
        indent.decr()

    def write_trait_doc(self, doc, out, indent):
        """Write processed trait documentation string into `out`.

        This method removes the call signature information from the
        method.

        Parameters
        ----------
        - doc : `string`

          The documentation string.

        - out : file line object.

        - indent : `Indent`
        """
        ret = self._remove_sig(doc)
        indent.incr()
        out.write(indent.format('"""'))
        out.write(indent.format('\n'+self.massage(ret)))
        out.write(indent.format('"""'))
        indent.decr()

    def write_method_doc(self, doc, out, indent):
        """Write processed method documentation string into `out`.

        The method signature is appopriately massaged.

        Parameters
        ----------
        - doc : `string`

          The documentation string.

        - out : file line object.

        - indent : `Indent`
        """
        orig_name = doc[2:doc.find('(')]
        name = camel2enthought(orig_name)
        my_sig = self._rename_class(doc[:doc.find('\n\n')])
        my_sig = self.cpp_method_re.sub('', my_sig)
        my_sig = my_sig.replace('V.'+orig_name, 'V.'+name)
        indent.incr()
        out.write(indent.format('"""'))
        out.write(indent.format(my_sig))
        ret = self._remove_sig(doc)
        if ret:
            out.write('\n')
            out.write(indent.format('\n'+self.massage(ret)))
        out.write(indent.format('"""'))
        indent.decr()

    def get_method_doc(self, doc):
        """Return processed method documentation string from `doc`.

        The method signature is appopriately massaged.

        Parameters
        ----------
        - doc : `string`

          The documentation string.
        """
        orig_name = doc[2:doc.find('(')]
        name = camel2enthought(orig_name)
        my_sig = self._rename_class(doc[:doc.find('\n\n')])
        my_sig = self.cpp_method_re.sub('', my_sig)
        my_sig = my_sig.replace('V.'+orig_name, 'V.'+name)
        ret = self.massage(self._remove_sig(doc))
        if ret:
            return my_sig + '\n' + ret
        else:
            return my_sig

    def massage(self, doc):
        """Returns massaged documentation string from passed
        docstring, `doc`.  This method basically renames the methods
        and classes in the docstring.
        """
        ret = self._rename_methods(doc)
        ret = self._rename_class(ret)
        return ret

    #################################################################
    # Non-public interface.
    #################################################################

    def _rename_class(self, doc):
        return self.renamer.sub(self.ren_func, doc)

    def _remove_sig(self, doc):
        idx = doc.find('\n\n') + 2
        if len(doc) > idx:
            return doc[idx:]
        else:
            return ''

    def _rename_methods(self, doc):
        lines = doc.split('\n')
        nl = []
        for line in lines:
            words = line.split(' ')
            nw = []
            for word in words:
                if word[:3] == 'vtk':
                    nw.append(word)
                else:
                    if self.func_re.search(word):
                        nw.append(camel2enthought(word))
                    else:
                        nw.append(word)
            nl.append(' '.join(nw))
        return '\n'.join(nl)


########NEW FILE########
__FILENAME__ = messenger
"""
Implements a simple, robust, safe, Messenger class that allows one to
register callbacks for a signal/slot (or event/handler) kind of
messaging system.  One can basically register a callback
function/method to be called when an object sends a particular event.
The Messenger class is Borg.  So it is easy to instantiate and use.
This module is also reload-safe, so if the module is reloaded the
callback information is not lost.  Method callbacks do not have a
reference counting problem since weak references are used.

The main functionality of this module is provided by three functions,
`connect`, `disconnect` and `send`.

Here is example usage with VTK::

    >>> import messenger, vtk
    >>> def cb(obj, evt):
    ...  print obj.__class__.__name__, evt
    ...
    >>> o = vtk.vtkProperty()
    >>> o.AddObserver('ModifiedEvent', messenger.send)
    1
    >>> messenger.connect(o, 'ModifiedEvent', cb)
    >>>
    >>> o.SetRepresentation(1)
    vtkOpenGLProperty ModifiedEvent
    >>> messenger.connect(o, 'AnyEvent', cb)
    >>> o.SetRepresentation(2)
    vtkOpenGLProperty ModifiedEvent
    vtkOpenGLProperty ModifiedEvent
    >>>
    >>> messenger.send(o, 'foo')
    vtkOpenGLProperty foo
    >>> messenger.disconnect(o, 'AnyEvent')
    >>> messenger.send(o, 'foo')
    >>>

This approach is necessary if you don't want to be bitten by reference
cycles.  If you have a Python object holding a reference to a VTK
object and pass a method of the object to the AddObserver call, you
will get a reference cycle that cannot be collected by the garbage
collector.  Using this messenger module gets around the problem.

Also note that adding a connection for 'AnyEvent' will trigger a
callback no matter what event was generated.  The code above also
shows how disconnection works.

"""
# Author: Prabhu Ramachandran
# Copyright (c) 2004-2007, Enthought, Inc.
# License: BSD Style.

__all__ = ['Messenger', 'MessengerError',
           'connect', 'disconnect', 'send']

import types
import sys
import weakref


#################################################################
# This code makes the module reload-safe.
#################################################################
_saved = {}

for name in ['messenger', 'tvtk.messenger']:
    if sys.modules.has_key(name):
        mod = sys.modules[name]
        if hasattr(mod, 'Messenger'):
            _saved = mod.Messenger._shared_data
        del mod
        break


#################################################################
# `MessengerError` class for exceptions raised by Messenger.
#################################################################

class MessengerError(Exception):
    pass



#################################################################
# `Messenger` class.
#################################################################

class Messenger:

    """Implements a messenger class which deals with something like
    signals and slots.  Basically, an object can register a signal
    that it plans to emit.  Any other object can decide to handle that
    signal (of that particular object) by registering itself with the
    messenger.  When a signal is emitted the messenger calls all
    handlers.  This makes it totally easy to deal with communication
    between objects.  The class is Borg.  Rather than use this class,
    please use the 'connect' and 'disconnect' functions.

    """

    _shared_data = _saved

    def __init__(self):
        """Create the messenger.  This class is Borg.  So all
        instances are the same.

        """

        self.__dict__ = self._shared_data

        if not hasattr(self, '_signals'):
            # First instantiation.
            self._signals = {}
            self._catch_all = ['AnyEvent', 'all']

    #################################################################
    # 'Messenger' interface.
    #################################################################

    def connect(self, obj, event, callback):
        """ Registers a slot given an object and its signal to slot
        into and also given a bound method in `callback` that should
        have two arguments.  `send` will call the callback
        with the object that emitted the signal and the actual
        event/signal as arguments.

        Parameters
        ----------

        - obj :  Python object

          Any Python object that will generate the particular event.

        - event : An event (can be anything, usually strings)

          The event `obj` will generate.  If this is in the list
          `self._catch_all`, then any event will call this callback.

        - callback : `function` or `method`

          This callback will be called when the object generates the
          particular event.  The object, event and any other arguments
          and keyword arguments given by the `obj` are passed along to
          the callback.

        """
        typ = type(callback)
        key = hash(obj)
        if not self._signals.has_key(key):
            self._signals[key] = {}
        signals = self._signals[key]
        if not signals.has_key(event):
            signals[event] = {}

        slots = signals[event]

        callback_key = hash(callback)
        if typ is types.FunctionType:
            slots[callback_key] = (None, callback)
        elif typ is types.MethodType:
            obj = weakref.ref(callback.im_self)
            name = callback.__name__
            slots[callback_key] = (obj, name)
        else:
            raise MessengerError, \
                  "Callback must be a function or method. "\
                  "You passed a %s."%(str(callback))

    def disconnect(self, obj, event=None, callback=None, obj_is_hash=False):
        """Disconnects the object and its event handlers.

        Parameters
        ----------

        - obj : Object

          The object that generates events.

        - event : The event.  (defaults to None)

        - callback : `function` or `method`

          The event handler.

         If `event` and `callback` are None (the default) all the
         events and handlers for the object are removed.  If only
         `callback` is None, only this handler is removed.  If `obj`
         and 'event' alone are specified, all handlers for the event
         are removed.

        - obj_is_hash : `bool`

         Specifies if the object passed is a hash instead of the object itself.
         This is needed if the object is gc'd but only the hash exists and one
         wants to disconnect the object.

        """
        signals = self._signals
        if obj_is_hash:
            key = obj
        else:
            key = hash(obj)
        if not signals.has_key(key):
            return
        if callback is None:
            if event is None:
                del signals[key]
            else:
                del signals[key][event]
        else:
            del signals[key][event][hash(callback)]

    def send(self, source, event, *args, **kw_args):
        """To be called by the object `source` that desires to
        generate a particular event.  This function in turn invokes
        all the handlers for the event passing the `source` object,
        event and any additional arguments and keyword arguments.  If
        any connected callback is garbage collected without being
        disconnected, it is silently removed from the existing slots.

        Parameters
        ----------

        - source : Python object

          This is the object that generated the event.

        - event : The event.

          If there are handlers connected to events called 'AnyEvent'
          or 'all', then any event will invoke these.

        """
        try:
            sigs = self._get_signals(source)
        except (MessengerError, KeyError):
            return
        events = self._catch_all[:]
        if event not in events:
            events.append(event)
        for evt in events:
            if sigs.has_key(evt):
                slots = sigs[evt]
                for key in slots.keys():
                    obj, meth = slots[key]
                    if obj: # instance method
                        inst = obj()
                        if inst:
                            getattr(inst, meth)(source, event, *args, **kw_args)
                        else:
                            # Oops, dead reference.
                            del slots[key]
                    else: # normal function
                        meth(source, event, *args, **kw_args)

    def is_registered(self, obj):
        """Returns if the given object has registered itself with the
        messenger.

        """
        try:
            sigs = self._get_signals(obj)
        except MessengerError:
            return 0
        else:
            return 1

    def get_signal_names(self, obj):
        """Returns a list of signal names the object passed has
        registered.

        """
        return self._get_signals(obj).keys()

    #################################################################
    # Non-public interface.
    #################################################################

    def _get_signals(self, obj):
        """Given an object `obj` it returns the signals of that
        object.

        """
        ret = self._signals.get(hash(obj))
        if ret is None:
            raise MessengerError, \
                  "No such object: %s, has registered itself "\
                  "with the messenger."%obj
        else:
            return ret


#################################################################
# Convenience functions.
#################################################################

_messenger = Messenger()

def connect(obj, event, callback):
    _messenger.connect(obj, event, callback)
connect.__doc__ = _messenger.connect.__doc__

def disconnect(obj, event=None, callback=None, obj_is_hash=False):
    _messenger.disconnect(obj, event, callback)
disconnect.__doc__ = _messenger.disconnect.__doc__

def send(obj, event, *args, **kw_args):
    _messenger.send(obj, event, *args, **kw_args)
send.__doc__ = _messenger.send.__doc__

del _saved


########NEW FILE########
__FILENAME__ = misc
"""Some miscellaneous convenience functionality.
"""
# Author: Prabhu Ramachandran <prabhu_r [at] users.sf.net>
# Copyright (c) 2007,  Enthought, Inc.
# License: BSD Style.

from os.path import splitext

# We import from tvtk.py and not api.py to prevent circular imports.
from tvtk.tvtk_access import tvtk
from tvtk.common import configure_input_data

######################################################################
# Utility functions.
######################################################################
def write_data(dataset, fname, **kwargs):
    """Given a TVTK `dataset` this writes the `dataset` to a VTK XML
    file having file name `fname`.

    If the given file name has no extension, one is automatically picked
    based on the dataset and an XML file is written out.  If the
    filename has a '.vtk' extension an old style VTK file is written.
    If any other extension is specified, an XML file is written out with
    the given extension.

    Any additional keyword arguments are passed to the writer used.
    """

    err_msg = "Can only write tvtk.DataSet instances "\
              "'got %s instead"%(dataset.__class__.__name__)
    assert isinstance(dataset, tvtk.DataSet), err_msg

    # Mapping to determine appropriate extension and writer.
    d2r = {'vtkImageData': ('.vti', tvtk.StructuredPointsWriter),
           'vtkRectilinearGrid': ('.vtr', tvtk.RectilinearGridWriter),
           'vtkStructuredGrid': ('.vts', tvtk.StructuredGridWriter),
           'vtkPolyData': ('.vtp', tvtk.PolyDataWriter),
           'vtkUnstructuredGrid': ('.vtu', tvtk.UnstructuredGridWriter)
           }

    for type in d2r:
        if dataset.is_a(type):
            datatype = d2r[type]
            break

    ext = splitext(fname)[1]
    if ext == '.vtk':
        file_name = fname
        writer = datatype[1]
    elif len(ext) == 0:
        file_name = fname + datatype[0]
        writer = tvtk.XMLDataSetWriter
    else:
        file_name = fname
        writer = tvtk.XMLDataSetWriter

    w = writer(file_name=file_name, **kwargs)
    configure_input_data(w, dataset)
    w.write()


########NEW FILE########
__FILENAME__ = browser
"""A tvtk pipeline browser.

An abstract `TreeGenerator` class defines the interface of a tree
generator.  This class is responsible for generating the list of
children.  Often tvtk object's children are collections of various
objects, some sequences and some simple objects.  In order to provide
a unified interface to all children, all of these objects are wrapped
using the `CompositeIterable` which presents all children as a single
iterable.

`SimpleTreeGenerator` does not do extensive analysis of the passed
object in order to compute the children.  `FullTreeGenerator` however
uses the algorithm that MayaVi-1.x uses and therefore generates a
large number of objects.

The `PipelineBrowser` class presents the view of the pipeline as a
tree.  It allows one to specify the TreeGenerator instance.  The
`TreeEditor` from the traits package is used to represent the view.  A
`TVTKLeafNode` defines a node that has no children.  A
`TVTKBranchNode` is a node that has children.  The nodes basically
wrap up the tvtk object and present an interface suitable for the
TreeEditor.

TODO:

 * When a node is selected, the actor involved could be highlighted.

"""
# Author: Prabhu Ramachandran <prabhu_r@users.sf.net>
# Copyright (c) 2005, Enthought, Inc.
# License: BSD Style.

# Standard library imports.
import re

# Enthought library imports.
from traits.api import HasTraits, Property, Any, Instance, \
                             Trait, List, Str, Dict, Python
from traitsui.api import \
     TreeEditor, TreeNodeObject, ObjectTreeNode, View, Item, Group
from traitsui.menu import Menu, Action

from tvtk.api import tvtk
from tvtk import messenger
from tvtk.tvtk_base import TVTKBase
from tvtk.tvtk_base_handler import TVTKBaseHandler
from tvtk.common import camel2enthought


######################################################################
# Utility functions.
######################################################################
def is_iterable(x):
    return hasattr(x, '__iter__')


def get_icon(object_name):
    """Given the name of the object, this function returns an
    appropriate icon image name.  If no icon is appropriate it returns
    the empty string."""

    # The mapping from names to icons.
    icon_map = {'actor': 'actor.png',
                'camera': 'camera.png',
                'coordinate': 'coordinate.png',
                'filter': 'filter.png',
                'lookuptable': 'lookuptable.png',
                'mapper': 'mapper.png',
                'polydata': 'polydata.png',
                'property': 'property.png',
                'reader': 'reader.png',
                'renderer': 'renderer.png',
                'rendererwindowinteractor': 'rendererwindowinteractor.png',
                'source': 'source.png',
                'texture': 'texture.png',
                'window': 'window.png',
                'writer': 'writer.png',
                }

    # Lower case the name.
    name = object_name.lower()

    for key in icon_map:
        if name.endswith(key):
            return icon_map[key]

    # No valid icon for this object.
    return ''


######################################################################
# `TreeGenerator` class.
######################################################################
class TreeGenerator(HasTraits):
    """Encapsulates the methods that generate the tree via the
    `get_children` method."""

    def has_children(self, obj):
        """Returns True if object `obj` has children."""
        raise NotImplementedError

    def get_children(self, obj):
        """Returns a dictionary containing the children of the object
        `obj`."""
        raise NotImplementedError

    def get_node(self, obj):
        """Get a node object representing this object."""
        raise NotImplementedError

    def get_nodes(self, menu):
        """Returns a list of nodes for the tree editor.  The menu
        entries to use for the nodes are passed as `menu`."""
        raise NotImplementedError


######################################################################
# `SimpleTreeGenerator` class.
######################################################################
class SimpleTreeGenerator(TreeGenerator):
    """This particular class generates a simple pipeline
    representation.  Not every possible object is obtained."""

    def has_children(self, obj):
        """Returns true of the object has children, false if not.  This is
        very specific to tvtk objects."""
        if isinstance(obj, (tvtk.RenderWindow, tvtk.Renderer,
                            tvtk.Collection)):
            return True

        for attribute in ['source', 'get_input', 'input', 'mapper', 'property',
                          'texture', 'text_property', 'volume_property',
                          'lookup_table', 'producer_port', 'producer']:
            if hasattr(obj, attribute):
                return True

        return False

    def get_children(self, obj):
        """Returns the child objects of a particular tvtk object in a
        dictionary, the keys are the trait names.  This is used to
        generate the tree in the browser."""
        kids = {}
        def _add_kid(key, x):
            if x is None:
                kids[key] = None
            else:
                if type(x) in (type([]), type(())):
                    x1 = [i for i in x if isinstance(i, TVTKBase)]
                    if x1:
                        kids[key] = x1
                elif isinstance(x, TVTKBase):
                    kids[key] = x

        if isinstance(obj, tvtk.RenderWindow):
            return {'renderers':obj.renderers}
        elif isinstance(obj, tvtk.Renderer):
            if hasattr(obj, 'view_props'):
                return {'view_props':obj.view_props,
                        'active_camera':obj.active_camera}
            else:
                return {'props':obj.props,
                        'active_camera':obj.active_camera}

        #if isinstance(obj, tvtk.Collection):
        #    _add_kid(obj)

        # Misc. properties.
        for attribute in ['mapper', 'property', 'texture',
                          'text_property', 'volume_property',
                          'lookup_table', 'producer']:
            if hasattr(obj, attribute):
                _add_kid(attribute, getattr(obj, attribute))

        # Check for sources and inputs.
        if hasattr(obj, 'number_of_sources'):
            srcs = [obj.get_source(i) \
                    for i in range(obj.number_of_sources)]
            _add_kid('source', srcs)
        elif hasattr(obj, 'source'):
            _add_kid('source', obj.source)

        if hasattr(obj, 'get_input'):
            inputs = []
            if hasattr(obj, 'number_of_input_ports'):
                if obj.number_of_input_ports:
                    inputs = [obj.get_input(i) \
                              for i in range(obj.number_of_input_ports)]
            else:
                inputs = [obj.get_input(i) \
                          for i in range(obj.number_of_inputs)]
            _add_kid('input', inputs)
        elif hasattr(obj, 'input'):
            _add_kid('input', obj.input)

        if hasattr(obj, 'producer_port'):
            _add_kid('producer_port', obj.producer_port)

        return kids

    def get_node(self, obj):
        """Get a node object representing the object passed."""
        if self.has_children(obj):
            return TVTKBranchNode(object=obj, tree_generator=self)
        else:
            return TVTKLeafNode(object=obj)

    def get_nodes(self, menu):
        """Returns a list of nodes for the tree editor.  The menu
        entries to use are given as `menu`"""
        nodes = [ObjectTreeNode(node_for=[TVTKBranchNode],
                                view=View(Group(Item('object', style='custom'),
                                                show_labels=False)),
                                auto_open=False,
                                children='children', label='name', menu=menu,
                                rename=False, delete=False, copy=False,
                                insert=False),
                 ObjectTreeNode(node_for=[TVTKLeafNode],
                                view=View(Group(Item('object', style='custom'),
                                                show_labels=False)),
                                auto_open=False,
                                label='name', menu=menu, rename=False,
                                delete=False, copy=False, insert=False),
                 ObjectTreeNode(node_for=[TVTKCollectionNode],
                                auto_open=True, children='children',
                                label='name', menu=menu, rename=False,
                                delete=False, copy=False, insert=False),
                 ]
        return nodes


######################################################################
# `FullTreeGenerator` class.
######################################################################
class FullTreeGenerator(SimpleTreeGenerator):
    """This particular class picks up a lot more children in the
    pipeline and is similar to the code used in MayaVi-1.x's pipeline
    browser."""

    def __init__(self, **traits):
        super(FullTreeGenerator, self).__init__(**traits)
        self.last_transform = 0

    def get_children(self, obj):
        """Returns the child objects of a particular tvtk object in a
        dictionary, the keys are the trait names.  This is used to
        generate the tree in the browser."""

        vtk_obj = tvtk.to_vtk(obj)
        methods = self._get_methods(vtk_obj)

        kids = {}
        def _add_kid(key, x):
            if x is None:
                kids[key] = None
            else:
                if type(x) in (type([]), type(())):
                    x1 = [i for i in x if isinstance(i, TVTKBase)]
                    if x1:
                        kids[key] = x1
                elif isinstance(x, TVTKBase):
                    if hasattr(x, '__iter__'):
                        # Don't add iterable objects that contain non
                        # acceptable nodes
                        if len(list(x)) and isinstance(list(x)[0], TVTKBase):
                            kids[key] = x
                    else:
                        kids[key] = x

        for method in methods:
            attr = camel2enthought(method[0])
            if hasattr(obj, attr):
                _add_kid(attr, getattr(obj, attr))

        # Check for sources and inputs.
        if hasattr(obj, 'number_of_sources'):
            srcs = [obj.get_source(i) \
                    for i in range(obj.number_of_sources)]
            _add_kid('source', srcs)
        elif hasattr(obj, 'source'):
            _add_kid('source', obj.source)

        if hasattr(obj, 'get_input'):
            inputs = []
            if hasattr(obj, 'number_of_input_ports'):
                if obj.number_of_input_ports:
                    # Sometimes not all the inputs can be retrieved using
                    # 'get_input', as they may be sources (for instance
                    # the ProbeFilter).
                    inputs = list()
                    for i in range(obj.number_of_input_ports):
                        try:
                            inputs.append(obj.get_input(i))
                        except TypeError:
                            pass
                    if not inputs:
                        inputs = [obj.get_input()]
            else:
                inputs = [obj.get_input(i) \
                          for i in range(obj.number_of_inputs)]
            _add_kid('input', inputs)
        elif hasattr(obj, 'input'):
            _add_kid('input', obj.input)

        if hasattr(obj, 'producer_port'):
            _add_kid('producer_port', obj.producer_port)

        return kids

    def has_children(self, obj):
        """Returns true of the object has children, false if not.  This is
        very specific to tvtk objects."""
        if isinstance(obj, (tvtk.RenderWindow, tvtk.Renderer,
                            tvtk.Collection)):
            return True
        for attribute in ['source', 'get_input', 'input', 'mapper', 'property',
                          'texture', 'text_property', 'volume_property',
                          'lookup_table', 'producer_port', 'producer']:
            if hasattr(obj, attribute):
                return True
        # FIXME: This is inefficient.  We probably should cache the
        # get_children call.
        if self.get_children(obj):
            return True
        return False

    ###########################################################################
    # Non-public interface.
    ###########################################################################
    def _get_methods(self, vtk_obj):
        """Obtain the various methods from the passed object."""

        def _remove_method(name, methods, method_names):
            """Removes methods if they have a particular name."""
            try:
                idx = method_names.index(name)
            except ValueError:
                pass
            else:
                del methods[idx], method_names[idx]
            return methods, method_names

        # The following code basically gets the 'str' representation
        # of the VTK object and parses it to obtain information about
        # the object's children.  It is a hack but has worked well for
        # a *very* long time with MayaVi-1.x and before.

        # Oops, this isn't a VTK object.
        if not hasattr(vtk_obj, 'GetClassName'):
            return []

        methods = str(vtk_obj)
        methods = methods.split("\n")
        del methods[0]

        # using only the first set of indented values.
        patn = re.compile("  \S")
        for method in methods[:]:
            if patn.match(method):
                if method.find(":") == -1:
                    methods.remove(method)
                elif method[1].find("none") > -1:
                    methods.remove(method)
            else:
                methods.remove(method)

        # Props/Prop is deprecated in more recent VTK releases.
        for method in methods[:]:
            if method.strip()[:6] == "Props:":
                if hasattr(vtk_obj, "GetViewProps"):
                    methods.remove(method)
                    methods.append("ViewProps: ")
            elif method.strip()[:5] == "Prop:":
                if hasattr(vtk_obj, "GetViewProp"):
                    methods.remove(method)
                    methods.append("ViewProp: ")

        method_names = []
        for i in range(0, len(methods)):
            strng = methods[i].replace(" ", "")
            methods[i] = strng.split(":")
            method_names.append(methods[i][0])

        if re.match("vtk\w*Renderer", vtk_obj.GetClassName()):
            methods.append(["ActiveCamera", ""])

        if re.match("vtk\w*Assembly", vtk_obj.GetClassName()):
            methods.append(["Parts", ""])
            methods.append(["Volumes", ""])
            methods.append(["Actors", ""])

        if vtk_obj.IsA('vtkAbstractTransform'):
            if self.last_transform > 0:
                _remove_method('Inverse', methods, method_names)
            else:
                self.last_transform += 1
        else:
            self.last_transform = 0

        # Some of these object are removed because they arent useful in
        # the browser.  I check for Source and Input anyway so I dont need
        # them.
        for name in('Output', 'FieldData', 'CellData', 'PointData',
                    'Source', 'Input', 'ExtentTranslator',
                    'Interactor', 'Lights', 'Information', 'Executive'):
            _remove_method(name, methods, method_names)

        return methods


######################################################################
# `CompositeIterable` class.
######################################################################
class CompositeIterable(HasTraits):

    """This class allows one to iterate over a bunch of disparate
    objects treating them as one single iterable.  Each of the
    iterated objects is wrapped with a suitable Node class so that the
    object may be used in a Traits Tree Editor.
    """

    tree_generator = Instance(TreeGenerator)

    def __init__(self, args, **traits):
        super(CompositeIterable, self).__init__(**traits)
        self.args = args

    def __iter__(self):
        tg = self.tree_generator
        for arg in self.args:
            if is_iterable(arg):
                for x in arg:
                    yield tg.get_node(x)
            else:
                yield tg.get_node(arg)

    def __len__(self):
        x = 0
        for arg in self.args:
            if is_iterable(arg):
                x += len(arg)
            else:
                x += 1
        return x


######################################################################
# `TVTKLeafNode` class.
######################################################################
class TVTKLeafNode(TreeNodeObject):
    """Represents a leaf in the tree view."""

    # The tvtk object being wrapped.
    object = Instance(TVTKBase)
    # Name to show on the view.
    name = Property

    # Work around problem with HasPrivateTraits.
    __ = Python

    def __hash__(self):
        return hash(tvtk.to_vtk(self.object))

    def _get_name(self):
        return self.object.__class__.__name__

    ######################################################################
    # `TreeNodeObject` interface
    ######################################################################
    def tno_get_icon(self, node, is_expanded):
        """ Returns the icon for a specified object.
        """
        icon = get_icon(self.name)
        if icon:
            return icon
        else:
            return super(TVTKLeafNode, self).tno_get_icon(node, is_expanded)


######################################################################
# `TVTKBranchNode` class.
######################################################################
class TVTKBranchNode(TreeNodeObject):
    """Represents a branch in the tree view.  The `children` trait
    produces an iterable that represents the children of the branch.
    """
    # The tvtk object being wrapped.
    object = Instance(TVTKBase)
    # Children of the object.
    children = Property
    # Name to show on the view.
    name = Property
    # Tree generator to use.
    tree_generator = Instance(TreeGenerator)
    # Cache of children.
    children_cache = Dict

    # Work around problem with HasPrivateTraits.
    __ = Python

    def __init__(self, **traits):
        super(TVTKBranchNode, self).__init__(**traits)

    def __del__(self):
        try:
            self._remove_listners()
        except:
            pass

    def __hash__(self):
        return hash(tvtk.to_vtk(self.object))

    def _get_children_from_cache(self):
        return [x for x in self.children_cache.values() if x is not None]

    def _create_children(self):
        kids = self.tree_generator.get_children(self.object)
        self.children_cache = kids
        self._setup_listners()

    def _setup_listners(self):
        object = self.object
        kids = self.children_cache
        for key, val in kids.items():
            if isinstance(val, tvtk.Collection):
                vtk_obj = tvtk.to_vtk(val)
                messenger.connect(vtk_obj, 'ModifiedEvent',
                                  self._notify_children)
            else:
                object.on_trait_change(self._notify_children, key)

    def _remove_listners(self):
        object = self.object
        kids = self.children_cache
        for key, val in kids.items():
            if isinstance(val, tvtk.Collection):
                vtk_obj = tvtk.to_vtk(val)
                messenger.disconnect(vtk_obj, 'ModifiedEvent',
                                     self._notify_children)
            else:
                object.on_trait_change(self._notify_children, key, remove=True)

    def _notify_children(self, obj=None, name=None, old=None, new=None):
        old_val = self._get_children_from_cache()
        self._remove_listners()
        self._create_children()
        new_val = self._get_children_from_cache()
        self.trait_property_changed('children', old_val, new_val)

    def _get_children(self):
        if not self.children_cache:
            self._create_children()
        kids = self._get_children_from_cache()
        tg = self.tree_generator
        return CompositeIterable(kids, tree_generator=tg)

    def _get_name(self):
        return self.object.__class__.__name__

    ######################################################################
    # `TreeNodeObject` interface
    ######################################################################
    def tno_get_icon(self, node, is_expanded):
        """ Returns the icon for a specified object.
        """
        icon = get_icon(self.name)
        if icon:
            return icon
        else:
            return super(TVTKBranchNode, self).tno_get_icon(node, is_expanded)


######################################################################
# `TVTKCollectionNode` class.
######################################################################
class TVTKCollectionNode(TreeNodeObject):
    """Represents a collection of typically unconnected roots in the
    tree view.
    """
    # List of child nodes.
    object = List(TVTKBase)
    # Children of the object.
    children = Property
    # Name to show on the view.
    name = Str
    # Tree generator to use.
    tree_generator = Instance(TreeGenerator)

    # Work around problem with HasPrivateTraits.
    __ = Python

    def __init__(self, **traits):
        super(TVTKCollectionNode, self).__init__(**traits)

    def _get_children(self):
        tg = self.tree_generator
        return CompositeIterable(self.object, tree_generator=tg)


######################################################################
# `CloseHandler` class.
######################################################################
class UICloseHandler(TVTKBaseHandler):
    """This class cleans up after the UI for the object is closed."""
    # The browser associated with this UI.
    browser = Any

    def close(self, info, is_ok):
        """This method is invoked when the user closes the UI."""
        obj = info.object
        obj.on_trait_change(self.browser.render, remove=True)
        return True


######################################################################
# `PipelineBrowser` class.
######################################################################
class PipelineBrowser(HasTraits):
    # The tree generator to use.
    tree_generator = Trait(FullTreeGenerator(),
                           Instance(TreeGenerator))

    # The TVTK render window(s) associated with this browser.
    renwins = List

    # The root object to view in the pipeline.  If None (default), the
    # root object is the render_window of the Scene instance passed at
    # object instantiation time.
    root_object = List(TVTKBase)

    # Private traits.
    # The root of the tree to display.
    _root = Any

    ###########################################################################
    # `object` interface.
    ###########################################################################
    def __init__(self, renwin=None, **traits):
        """Initializes the object.

        Parameters
        ----------

        - renwin: `Scene` instance.  Defaults to None.

          This may be passed in addition to the renwins attribute
          which can be a list of scenes.

        """
        super(PipelineBrowser, self).__init__(**traits)
        self.ui = None
        self.view = None
        if renwin:
            self.renwins.append(renwin)

        self._root_object_changed(self.root_object)
        menu = Menu(Action(name='Refresh', action='editor.update_editor'),
                    Action(name='Expand all', action='editor.expand_all'))
        self.menu = menu

        nodes = self.tree_generator.get_nodes(menu)

        self.tree_editor = TreeEditor(nodes=nodes,
                                      editable=False,
                                      orientation='vertical',
                                      hide_root=True,
                                      on_dclick=self._on_dclick)
        self.view = View(Group(Item(name='_root',
                                    editor=self.tree_editor,
                                    resizable=True),
                               show_labels=False,
                               show_border=False,
                               orientation='vertical'),
                         title='Pipeline browser',
                         help=False,
                         resizable=True, undo=False, revert=False,
                         width=.3, height=.3)

    ###########################################################################
    # `PipelineBrowser` interface.
    ###########################################################################
    def show(self, parent=None):
        """Show the tree view if not already show.  If optional
        `parent` widget is passed, the tree is displayed inside the
        passed parent widget."""
        # If UI already exists, raise it and return.
        if self.ui and self.ui.control:
            try:
                self.ui.control.Raise()
            except AttributeError:
                pass
            else:
                return
        else:
            # No active ui, create one.
            if parent:
                self.ui = self.view.ui(self, parent=parent, kind='subpanel')
            else:
                self.ui = self.view.ui(self, parent=parent)

    def update(self):
        """Update the tree view."""
        # This is a hack.
        if self.ui and self.ui.control:
            try:
                ed = self.ui._editors[0]
                ed.update_editor()
                self.ui.control.Refresh()
            except (AttributeError, IndexError):
                pass
    # Another name for update.
    refresh = update

    def render(self):
        """Calls render on all render windows associated with this
        browser."""
        for rw in self.renwins:
            rw.render()

    ###########################################################################
    # Non-public interface.
    ###########################################################################
    def _make_default_root(self):
        tree_gen = self.tree_generator
        objs = [x.render_window for x in self.renwins]
        node = TVTKCollectionNode(object=objs, name="Root",
                                  tree_generator=tree_gen)
        return node

    def _tree_generator_changed(self, tree_gen):
        """Traits event handler."""
        if self._root:
            root_obj = self._root.object
        else:
            root_obj = self.root_object
        if root_obj:
            ro = root_obj
            if not hasattr(root_obj, '__len__'):
                ro = [root_obj]

            self._root = TVTKCollectionNode(object=ro,
                                            name="Root",
                                            tree_generator=tree_gen)
        else:
            self._root = self._make_default_root()

        self.tree_editor.nodes = tree_gen.get_nodes(self.menu)
        self.update()

    def _root_object_changed(self, root_obj):
        """Trait handler called when the root object is assigned to."""
        tg = self.tree_generator
        if root_obj:
            self._root = TVTKCollectionNode(object=root_obj, name="Root",
                                            tree_generator=tg)
        else:
            self._root = self._make_default_root()
            self.root_object = self._root.object
        self.update()

    def _root_object_items_changed(self, list_event):
        """Trait handler called when the items of the list change."""
        self._root_object_changed(self.root_object)

    def _on_dclick(self, obj):
        """Callback that is called when nodes are double-clicked."""
        if hasattr(obj, 'object') and hasattr(obj.object, 'edit_traits'):
            object = obj.object
            view = object.trait_view()
            view.handler = UICloseHandler(browser=self)
            object.on_trait_change(self.render)
            ui = object.edit_traits(view=view)



######################################################################
# Test cases.
######################################################################
def main(instantiate_gui=True):
    """Simple test case."""
    from tvtk.tools import ivtk

    v = ivtk.viewer(browser=False, instantiate_gui=instantiate_gui)
    cs = tvtk.ConeSource()
    m = tvtk.PolyDataMapper(input=cs.output)
    a = tvtk.Actor(mapper=m)
    v.scene.add_actor(a)
    v.scene.reset_zoom()

    b = PipelineBrowser(v.scene)
    b.show()

    return v, b, a


if __name__ == '__main__':
    from pyface.api import GUI
    gui = GUI()
    main(instantiate_gui=False)
    gui.start_event_loop()

########NEW FILE########
__FILENAME__ = browser_plugin
""" The TVTK pipeline browser plugin. """


# Enthought library imports.
from envisage.api import Plugin
from traits.api import List


class BrowserPlugin(Plugin):
    """ The TVTK pipeline browser plugin. """

    # Extension point Ids.
    VIEWS = 'envisage.ui.workbench.views'

    #### 'IPlugin' interface ##################################################

    # The plugin's name (suitable for displaying to the user).
    name = 'TVTK Pipeline Browser'

    # Our ID.
    id = 'tvtk.browser'

    #### Extension points offered by this plugin ##############################

    # None.

    #### Contributions to extension points made by this plugin ################

    views = List(contributes_to=VIEWS)

    def _views_default(self):
        """ Trait initializer. """

        return [self._browser_view_factory]

    ###########################################################################
    # Private interface.
    ###########################################################################

    def _browser_view_factory(self, window, **traits):
        """ Factory method for browser views. """

        from tvtk.plugins.browser.browser_view import (
            BrowserView
        )

        browser_view = BrowserView(
            scene_manager = self._get_scene_manager(window),
            window        = window,
            **traits
        )

        return browser_view

    def _get_scene_manager(self, window):
        """ Lookup the window's scene manager service. """

        # Get the scene manager (a 'per window' service, so we look it up via
        # the window!).
        from tvtk.plugins.scene.i_scene_manager import (
            ISceneManager
        )

        return window.get_service(ISceneManager)

#### EOF ######################################################################

########NEW FILE########
__FILENAME__ = browser_view
""" The TVTK pipeline browser view. """


# Author: Prabhu Ramachandran <prabhu_r@users.sf.net>
# Copyright (c) 2005, Enthought, Inc.
# License: BSD Style.


# Enthought library imports.
from pyface.workbench.api import View
from traits.api import Instance, on_trait_change


class BrowserView(View):
    """ The TVTK pipeline browser view. """

    #### 'IWorkbenchPart' interface ###########################################

    # The part's name (displayed to the user).
    name = 'TVTK Pipeline Browser'

    #### 'IView' interface ####################################################

    # The position of the view relative to the item specified in the
    # 'relative_to' trait.
    position = 'left'

    #### 'BrowserView' interface ##############################################

    # The pipeline browser instance that we are a view of.
    browser = Instance('tvtk.pipeline.browser.PipelineBrowser')

    # The scene manager.
    scene_manager = Instance(
        'tvtk.plugins.scene.i_scene_manager.ISceneManager'
    )

    ###########################################################################
    # 'IWorkbenchPart' interface.
    ###########################################################################

    def create_control(self, parent):
        """ Create the toolkit-specific control that represents the view. """

        from tvtk.pipeline.browser import PipelineBrowser

        self.browser = PipelineBrowser()
        self.browser.show(parent=parent)

        return self.browser.ui.control

    ###########################################################################
    # Private interface.
    ###########################################################################

    #### Trait change handlers ################################################

    @on_trait_change('scene_manager:scenes_items')
    def _on_scenes_changed(self, event):
        """ Dynamic trait change handler.

        This is called when scenes are added/removed from the scene manager, it
        is used to add and remove objects from the pipeline.

        """

        # Scenes that were removed.
        map(self._remove_scene, event.removed)

        # Scenes that were added.
        map(self._add_scene, event.added)

        return

    #### Methods ##############################################################

    def _add_scene(self, scene):
        """ Add the specified scene to the pipeline browser. """

        self.browser.renwins.append(scene)
        self.browser.root_object.append(scene.render_window)

        return

    def _remove_scene(self, scene):
        """ Remove the specified scene from the pipeline browser. """

        if scene in self.browser.renwins:
            self.browser.renwins.remove(scene)
            self.browser.root_object.remove(scene.render_window)

        return

#### EOF ######################################################################

########NEW FILE########
__FILENAME__ = i_scene_manager
""" The interface for TVTK scene managers. """


# Enthought library imports.
from tvtk.pyface.tvtk_scene import TVTKScene
from pyface.workbench.api import WorkbenchWindow
from traits.api import Interface, List, Instance


class ISceneManager(Interface):
    """ The interface for TVTK scene managerss. """

    # The currently active scene (None, if no scene is active).
    current_scene = Instance(TVTKScene)

    # A list of all open scenes.
    scenes = List(TVTKScene)

    # The workbench window that the manager is in (there is one scene manager
    # per workbench window).
    window = Instance(WorkbenchWindow)

#### EOF ######################################################################




########NEW FILE########
__FILENAME__ = scene_editor
""" A TVTK scene editor. """

# Author: Prabhu Ramachandran <prabhu_r@users.sf.net>
# Copyright (c) 2005, Enthought, Inc.
# License: BSD Style.


# Enthought library imports.
from apptools.preferences.api import get_default_preferences
from tvtk.pyface.tvtk_scene import TVTKScene
from tvtk.pyface.api import DecoratedScene
from pyface.workbench.api import Editor
from traits.api import Instance


#### Handy functions ##########################################################

def _id_generator():
    """ Return an ever-increasing number useful for creating unique Ids. """

    n = 1
    while True:
        yield(n)
        n += 1

_id_generator = _id_generator()


class SceneEditor(Editor):
    """ A TVTK scene editor. """

    #### 'SceneEditor' interface ##############################################

    # The TVTK scene object.
    scene = Instance(TVTKScene)

    ###########################################################################
    # 'IWorkbenchPart' interface.
    ###########################################################################

    #### Trait initializers ###################################################

    def _id_default(self):
        """ Trait initializer. """

        return self.name

    def _name_default(self):
        """ Trait initializer. """

        return 'TVTK Scene %d' % (_id_generator.next())

    #### Methods ##############################################################

    def create_control(self, parent):
        """ Create the toolkit-specific control that represents the editor. """

        # We hold a reference to the scene itself to make sure it does not get
        # garbage collected (because we only return the scene's 'control' not
        # the scene itself). The scene is also referenced by the scene manager.
        self.scene = self._create_decorated_scene(parent)
        self.scene.render()

        return self.scene.control

    def destroy_control(self):
        """ Destroy the toolkit-specific control that represents the
        editor.
        """
        if self.scene is not None:
            # Close the scene to cleanly shut it down.
            self.scene.close()

        # Call the parent method.
        return super(SceneEditor, self).destroy_control()

    ###########################################################################
    # Private interface.
    ###########################################################################

    def _create_decorated_scene(self, parent):
        """ Create a new decorated scene. """

        pref = get_default_preferences()
        stereo = eval(pref.get('tvtk.scene.stereo'))

        scene = DecoratedScene(parent, stereo=stereo)

        # Set the scene's traits to preference values.
        scene.magnification = \
                eval(pref.get('tvtk.scene.magnification'))

        fg = eval(pref.get('tvtk.scene.foreground_color'))
        bg = eval(pref.get('tvtk.scene.background_color'))
        scene.foreground = fg
        scene.background = bg
        # FIXME: This seems necessary for some strange reason, if not
        # the actual background of the renderer never gets set even
        # though the renderer and the scene's background are synced.
        scene.renderer.background = scene.background

        return scene

#### EOF ######################################################################

########NEW FILE########
__FILENAME__ = scene_manager
""" Manage the TVTK scenes. """

# Enthought library imports.
from tvtk.pyface.tvtk_scene import TVTKScene
from pyface.workbench.api import WorkbenchWindow
from traits.api import HasTraits, List, Instance, Property
from traits.api import implements, on_trait_change
from tvtk.plugins.scene.scene_editor import SceneEditor

# Local imports.
from i_scene_manager import ISceneManager


class SceneManager(HasTraits):
    """ Manage the TVTK scenes. """

    implements(ISceneManager)

    #### 'SceneManager' interface #############################################

    # The currently active scene (None, if no scene is active).
    current_scene = Property(Instance(TVTKScene))

    # A list of all open scenes.
    scenes = List(TVTKScene)

    # The workbench window that the manager is in (there is one scene manager
    # per workbench window).
    window = Instance(WorkbenchWindow)

    #### Private interface ####################################################

    # Shadow trait for the 'current_scene' property.
    _current_scene = Instance(TVTKScene)

    ###########################################################################
    # 'SceneManager' interface.
    ###########################################################################

    #### Trait properties #####################################################

    def _get_current_scene(self):
        """ Property getter. """

        scene_count = len(self.scenes)
        if scene_count == 0:
            scene = None

        elif scene_count == 1:
            scene = self.scenes[0]

        else:
            scene = self._current_scene

        return scene

    def _set_current_scene(self, scene):
        """ Property setter. """

        self._current_scene = scene

        return

    #### Trait change handlers ################################################

    @on_trait_change('window:editor_opened')
    def _on_editor_opened(self, obj, trait_name, old, new):
        """ Dynamic trait change handler. """

        if isinstance(new, SceneEditor):
            self.scenes.append(new.scene)

        return

    @on_trait_change('window:editor_closing')
    def _on_editor_closed(self, obj, trait_name, old, new):
        """ Dynamic trait change handler. """

        if isinstance(new, SceneEditor):
            self.scenes.remove(new.scene)

        return

    @on_trait_change('window:active_editor')
    def _on_active_editor_changed(self, obj, trait_name, old, new):
        """ Dynamic trait change handler. """

        if isinstance(new, SceneEditor):
            self.current_scene = new.scene

        else:
            self.current_scene = None

        return

#### EOF ######################################################################




########NEW FILE########
__FILENAME__ = scene_plugin
""" The TVTK render window scene plugin. """


# Enthought library imports.
from envisage.api import Plugin, ServiceOffer
from traits.api import List


# This module's package.
PKG = '.'.join(__name__.split('.')[:-1])


class ScenePlugin(Plugin):
    """ The TVTK render window scene plugin. """

    # Extension point Ids.
    PREFERENCES    = 'envisage.preferences'
    SERVICE_OFFERS = 'envisage.ui.workbench.service_offers'

    #### 'IPlugin' interface ##################################################

    # The plugin's name (suitable for displaying to the user).
    name = 'TVTK Scene Plugin'

    # Our ID.
    id = 'tvtk.scene'

    #### Extension points offered by this plugin ##############################

    # None.

    #### Contributions to extension points made by this plugin ################

    preferences = List(contributes_to=PREFERENCES)

    def _preferences_default(self):
        """ Trait initializer. """

        return ['pkgfile://%s/preferences.ini' % PKG]

    service_offers = List(contributes_to=SERVICE_OFFERS)

    def _service_offers_default(self):
        """ Trait initializer. """

        scene_manager_service_offer = ServiceOffer(
            protocol = PKG + '.i_scene_manager.ISceneManager',
            factory  = PKG + '.scene_manager.SceneManager',
        )

        return [scene_manager_service_offer]

#### EOF ######################################################################

########NEW FILE########
__FILENAME__ = actions
""" The various actions for the Scene plugin. """


# Author: Prabhu Ramachandran <prabhu_r@users.sf.net>
# Copyright (c) 2005-2007, Enthought, Inc.
# License: BSD Style.


# Enthought library imports.
from pyface.api import FileDialog, OK
from pyface.action.api import Action
from traits.api import Instance, Property, Str


class SceneAction(Action):
    """ Base class for actions that require a scene manager. """

    #### 'SceneAction' interface ##############################################

    # The scene manager.
    scene_manager = Property(Instance(
        'tvtk.plugins.scene.i_scene_manager import ISceneManager'
    ))

    def _get_scene_manager(self):
        """ Trait property getter. """

        from tvtk.plugins.scene.i_scene_manager import (
            ISceneManager
        )

        return self.window.get_service(ISceneManager)


class NewScene(Action):
    """ An action that creates a new TVTK scene. """

    #### 'Action' interface ###################################################

    name = 'Scene'

    def perform(self, event):
        """ Performs the action. """

        from tvtk.plugins.scene.scene_editor import SceneEditor

        editor = self.window.edit(object(), kind=SceneEditor)

        return editor


class SaveScene(SceneAction):
    """ An action that saves a scene to an image. """

    #### 'Action' interface ###################################################

    name = 'Save Scene'

    def perform(self, event):
        """ Performs the action. """

        extensions = [
            '*.png', '*.jpg', '*.jpeg', '*.tiff', '*.bmp', '*.ps', '*.eps',
            '*.tex', '*.rib', '*.wrl', '*.oogl', '*.pdf', '*.vrml', '*.obj',
            '*.iv'
        ]

        wildcard = '|'.join(extensions)

        dialog = FileDialog(
            parent   = self.window.control,
            title    = 'Save scene to image',
            action   = 'save as',
            wildcard = wildcard
        )
        if dialog.open() == OK:
            scene = self.scene_manager.current_scene
            if scene is not None:
                scene.save(dialog.path)

        return


class SaveSceneToImage(SceneAction):
    """ An action that saves a scene to an image. """

    #### 'Action' interface ###################################################

    # Name of the action.
    name = 'Image'

    #### 'SaveSceneToImage' interface #########################################

    # The save method name.
    save_method = Str('save')

    # The wildcard for the file dialog.
    wildcard = Str("All files (*.*)|*.*")

    ###########################################################################
    # 'Action' interface.
    ###########################################################################

    def perform(self, event):
        """ Perform the action. """

        dialog = FileDialog(
            parent   = self.window.control,
            title    = 'Save scene to %s' % self.name,
            action   = 'save as',
            wildcard = self.wildcard
        )
        if dialog.open() == OK:
            scene = self.scene_manager.current_scene
            if scene is not None:
                method = getattr(scene, self.save_method)
                method(dialog.path)

        return


# These are all specific subclasses that save particular images.
class SaveSceneToPNG(SaveSceneToImage):
    name        = 'PNG Image'
    save_method = 'save_png'
    wildcard    = 'PNG images (*.png)|*.png|' \
                  'All files (*.*)|*.*'

class SaveSceneToJPEG(SaveSceneToImage):
    name        = 'JPEG Image'
    save_method = 'save_jpg'
    wildcard    = 'JPEG images (*.jpg)|*.jpg|' \
                  'JPEG images (*.jpeg)|*.jpeg|' \
                  'All files (*.*)|*.*'

class SaveSceneToBMP(SaveSceneToImage):
    name        = 'BMP Image'
    save_method = 'save_bmp'
    wildcard    = 'BMP images (*.bmp)|*.bmp|' \
                  'All files (*.*)|*.*'

class SaveSceneToTIFF(SaveSceneToImage):
    name        = 'TIFF Image'
    save_method = 'save_tiff'
    wildcard    = 'TIFF images (*.tif)|*.tif|' \
                  'TIFF images (*.tiff)|*.tiff|' \
                  'All files (*.*)|*.*'

class SaveSceneToPS(SaveSceneToImage):
    name        = 'PostScript bitmap Image'
    save_method = 'save_ps'
    wildcard    = 'PostScript bitmap images (*.ps)|*.ps|' \
                  'All files (*.*)|*.*'

class SaveSceneToGL2PS(SaveSceneToImage):
    name        = 'Vector PS/EPS/PDF/TeX'
    save_method = 'save_gl2ps'
    wildcard    = 'All files (*.*)|*.*|' \
                  'EPS files (*.eps)|*.eps|' \
                  'PS files (*.ps)|*.ps|' \
                  'PDF files (*.pdf)|*.pdf|' \
                  'TeX files (*.tex)|*.tex'

class SaveSceneToRIB(SaveSceneToImage):
    name        = 'RenderMan RIB file'
    save_method = 'save_rib'
    wildcard    = 'RIB files (*.rib)|*.rib|' \
                  'All files (*.*)|*.*'

class SaveSceneToOOGL(SaveSceneToImage):
    name        = 'GeomView OOGL file'
    save_method = 'save_oogl'
    wildcard    = 'OOGL files (*.oogl)|*.oogl|' \
                  'All files (*.*)|*.*'

class SaveSceneToIV(SaveSceneToImage):
    name        = 'OpenInventor file'
    save_method = 'save_iv'
    wildcard    = 'OpenInventor files (*.iv)|*.iv|' \
                  'All files (*.*)|*.*'

class SaveSceneToVRML(SaveSceneToImage):
    name        = 'VRML file'
    save_method = 'save_vrml'
    wildcard    = 'VRML files (*.wrl)|*.wrl|' \
                  'All files (*.*)|*.*'

class SaveSceneToOBJ(SaveSceneToImage):
    name        = 'Wavefront OBJ file'
    save_method = 'save_wavefront'
    wildcard    = 'OBJ files (*.obj)|*.obj|' \
                  'All files (*.*)|*.*'


class SetView(SceneAction):
    """ An action that sets the current scene to a particular view."""

    #### 'SetView' interface ##################################################

    # The method to invoke on the scene that will set the view.
    view_method = Str

    ###########################################################################
    # 'Action' interface.
    ###########################################################################

    def perform(self, event):
        """ Perform the action. """

        scene = self.scene_manager.current_scene
        if scene is not None:
            method = getattr(scene, self.view_method)
            method()

        return

# These are all specific subclasses that invoke particular views.
class ResetZoom(SetView):
    name = '&Reset Zoom'
    view_method = 'reset_zoom'

class IsometricView(SetView):
    name = '&Isometric View'
    view_method = 'isometric_view'

class XPlusView(SetView):
    name = '&X+ View'
    view_method = 'x_plus_view'

class XMinusView(SetView):
    name = '&X- View'
    view_method = 'x_minus_view'

class YPlusView(SetView):
    name = '&Y+ View'
    view_method = 'y_plus_view'

class YMinusView(SetView):
    name = '&Y- View'
    view_method = 'y_minus_view'

class ZPlusView(SetView):
    name = '&Z+ View'
    view_method = 'z_plus_view'

class ZMinusView(SetView):
    name = '&Z- View'
    view_method = 'z_minus_view'

#### EOF ######################################################################

########NEW FILE########
__FILENAME__ = scene_preferences_page
""" Preferences page for a TVTK scene. """

# Author: Prabhu Ramachandran <prabhu_r@users.sf.net>
# Copyright (c) 2005, Enthought, Inc.
# License: BSD Style.


# Enthought library imports.
from apptools.preferences.ui.api import PreferencesPage
from traits.api import Range
from traitsui.api import View, Group, Item
from tvtk.tvtk_base import false_bool_trait, vtk_color_trait


class ScenePreferencesPage(PreferencesPage):
    """ Preferences page for a TVTK scene. """

    #### 'PreferencesPage' interface ##########################################

    # The page's category (e.g. 'General/Appearance'). The empty string means
    # that this is a top-level page.
    category = ''

    # The page's help identifier (optional). If a help Id *is* provided then
    # there will be a 'Help' button shown on the preference page.
    help_id = ''

    # The page name (this is what is shown in the preferences dialog.
    name = 'TVTK Scene'

    # The path to the preferences node that contains the preferences.
    preferences_path = 'tvtk.scene'

    #### Preferences ##########################################################

    # Turn on/off stereo rendering. Note that this is useful only at startup
    # and not at runtime.
    stereo = false_bool_trait(
        desc='specifies if stereo rendering is turned on'
    )

    # The magnification to use when dumping the screen to an image.
    magnification = Range(
        1, 2048, 1,
        desc='specifies the magnification to use while generating images'
    )

    # The background color of the renderer.
    background_color = vtk_color_trait((0.5, 0.5, 0.5))

    # The foreground color of the renderer.
    foreground_color = vtk_color_trait((1.0, 1.0, 1.0))

    #### Traits UI views ######################################################

    traits_view = View(
        Group(
            Item(name='background_color'),
            Item(name='foreground_color'),
            Item(name='stereo'),
            Item(name='magnification')
        )
    )

#### EOF ######################################################################

########NEW FILE########
__FILENAME__ = scene_ui_action_set
""" The default action set for the scene UI plugin. """


# Author: Prabhu Ramachandran <prabhu_r@users.sf.net>
# Copyright (c) 2006, Enthought, Inc.
# License: BSD Style.


# Enthought library imports.
from envisage.ui.action.api import Action, ActionSet, Group, Menu


# This package
PKG = '.'.join(__name__.split('.')[:-1])


#### Groups ###################################################################

scene_group = Group(
    id='TVTKSceneGroup',
    path='MenuBar/File', before='ExitGroup'
)

view_group = Group(
    id='TVTKViewGroup',
    path='MenuBar/Tools', before='PreferencesGroup'
)

#### Menus ####################################################################

new_menu = Menu(
    name='&New',
    path='MenuBar/File', group='TVTKSceneGroup'
)

save_scene_as_menu = Menu(
    id='SaveSceneAs', name="Sa&ve Scene As",
    path='MenuBar/File', group='TVTKSceneGroup', after='New'
)

#### Actions ##################################################################

new_scene = Action(
    class_name = PKG + '.actions.NewScene',
    path       = 'MenuBar/File/New', group='additions'
)

#### Save actions ####

save_scene = Action(
    class_name = PKG + '.actions.SaveScene',
    path       = 'MenuBar/File', group='TVTKSceneGroup', after='SaveSceneAs'
)

save_scene_to_png = Action(
    class_name = PKG + '.actions.SaveSceneToPNG',
    path       = 'MenuBar/File/SaveSceneAs'
)

save_scene_to_jpeg = Action(
    class_name = PKG + '.actions.SaveSceneToJPEG',
    path       = 'MenuBar/File/SaveSceneAs'
)

save_scene_to_bmp = Action(
    class_name = PKG + '.actions.SaveSceneToBMP',
    path       = 'MenuBar/File/SaveSceneAs'
)

save_scene_to_tiff = Action(
    class_name = PKG + '.actions.SaveSceneToTIFF',
    path       = 'MenuBar/File/SaveSceneAs'
)

save_scene_to_ps = Action(
    class_name = PKG + '.actions.SaveSceneToPS',
    path       = 'MenuBar/File/SaveSceneAs'
)

save_scene_to_gl2ps = Action(
    class_name = PKG + '.actions.SaveSceneToGL2PS',
    path       = 'MenuBar/File/SaveSceneAs'
)

save_scene_to_rib = Action(
    class_name = PKG + '.actions.SaveSceneToRIB',
    path       = 'MenuBar/File/SaveSceneAs'
)

save_scene_to_oogl = Action(
    class_name = PKG + '.actions.SaveSceneToOOGL',
    path       = 'MenuBar/File/SaveSceneAs'
)

save_scene_to_iv = Action(
    class_name = PKG + '.actions.SaveSceneToIV',
    path       = 'MenuBar/File/SaveSceneAs'
)

save_scene_to_vrml = Action(
    class_name = PKG + '.actions.SaveSceneToVRML',
    path       = 'MenuBar/File/SaveSceneAs'
)

save_scene_to_obj = Action(
    class_name = PKG + '.actions.SaveSceneToOBJ',
    path       = 'MenuBar/File/SaveSceneAs'
)

#### View actions ####

reset_zoom = Action(
    class_name = PKG + '.actions.ResetZoom',
    path       = 'MenuBar/Tools', group='TVTKViewGroup'
)

isometric_view = Action(
    class_name = PKG + '.actions.IsometricView',
    path       = 'MenuBar/Tools', group='TVTKViewGroup'
)

x_plus_view = Action(
    class_name = PKG + '.actions.XPlusView',
    path       = 'MenuBar/Tools', group='TVTKViewGroup'
)

x_minus_view = Action(
    class_name = PKG + '.actions.XMinusView',
    path       = 'MenuBar/Tools', group='TVTKViewGroup'
)

y_plus_view = Action(
    class_name = PKG + '.actions.YPlusView',
    path       = 'MenuBar/Tools', group='TVTKViewGroup'
)

y_minus_view = Action(
    class_name = PKG + '.actions.YMinusView',
    path       = 'MenuBar/Tools', group='TVTKViewGroup'
)

z_plus_view = Action(
    class_name = PKG + '.actions.ZPlusView',
    path       = 'MenuBar/Tools', group='TVTKViewGroup'
)

z_minus_view = Action(
    class_name = PKG + '.actions.ZMinusView',
    path       = 'MenuBar/Tools', group='TVTKViewGroup'
)


class SceneUIActionSet(ActionSet):
    """ The default action set for the scene UI plugin. """

    groups  = [scene_group, view_group]
    menus   = [new_menu, save_scene_as_menu]
    actions = [
        new_scene,

        # Save actions.
        save_scene, save_scene_to_png, save_scene_to_jpeg, save_scene_to_bmp,
        save_scene_to_tiff, save_scene_to_ps, save_scene_to_gl2ps,
        save_scene_to_rib, save_scene_to_oogl, save_scene_to_iv,
        save_scene_to_vrml, save_scene_to_obj,

        # Scene actions.
        reset_zoom, isometric_view, x_plus_view, x_minus_view, y_plus_view,
        y_minus_view, z_plus_view, z_minus_view
    ]

#### EOF ######################################################################

########NEW FILE########
__FILENAME__ = scene_ui_plugin
""" A TVTK render window scene UI plugin. """


# Enthought library imports.
from envisage.api import Plugin
from traits.api import List


class SceneUIPlugin(Plugin):
    """ A TVTK render window scene UI plugin.

    This is the plugin that contributes actions, menus, preferences pages
    etc.

    """

    # Extension point Ids.
    ACTION_SETS       = 'envisage.ui.workbench.action_sets'
    PREFERENCES_PAGES = 'envisage.ui.workbench.preferences_pages'

    #### 'IPlugin' interface ##################################################

    # The plugin's name (suitable for displaying to the user).
    name = 'TVTK Scene UI Plugin'

    # Our ID.
    id = 'tvtk.scene_ui'

    #### Extension points offered by this plugin ##############################

    # None.

    #### Contributions to extension points made by this plugin ################

    action_sets = List(contributes_to=ACTION_SETS)

    def _action_sets_default(self):
        """ Trait initializer. """

        from tvtk.plugins.scene.ui.scene_ui_action_set import (
            SceneUIActionSet
        )

        return [SceneUIActionSet]

    preferences_pages = List(contributes_to=PREFERENCES_PAGES)

    def _preferences_pages_default(self):
        """ Trait initializer. """

        from tvtk.plugins.scene.ui.scene_preferences_page import (
            ScenePreferencesPage
        )

        return [ScenePreferencesPage]

#### EOF ######################################################################

########NEW FILE########
__FILENAME__ = actors
#------------------------------------------------------------------------------
# Copyright (c) 2005, Enthought, Inc.
# All rights reserved.
#
# This software is provided without warranty under the terms of the BSD
# license included in enthought/LICENSE.txt and may be redistributed only
# under the conditions described in the aforementioned license.  The license
# is also available online at http://www.enthought.com/licenses/BSD.txt
# Thanks for using Enthought open source!
#
# Author: Enthought, Inc.
# Description: <Enthought pyface package component>
#------------------------------------------------------------------------------
"""Helper functions to make a bunch of simple actors.  This is useful
when writing demo/example code.

"""

# Author: Prabhu Ramachandran <prabhu_r@users.sf.net>
# Copyright (c) 2005, Enthought, Inc.
# License: BSD Style.

from tvtk.api import tvtk
from vtk.util import colors
from tvtk.common import configure_input_data

def axes_actor(origin=(0, 0, 0), scale_factor=1.0, radius=0.02,
               sides=12):
    """Creates a simple axes actor and returns a tvtk.Actor object."""
    axes = tvtk.Axes(origin=origin, scale_factor=scale_factor, symmetric=1)
    tube = tvtk.TubeFilter(radius=radius, number_of_sides=sides,
                           vary_radius='vary_radius_off')
    configure_input_data(tube, axes.output)
    mapper = tvtk.PolyDataMapper()
    configure_input_data(mapper, tube.output)
    actor = tvtk.Actor(mapper=mapper)
    axes.update()
    return actor


def cone_actor(center=(0, 0, 0), height=1.0, radius=0.5,
               direction=(1, 0, 0), resolution=100, color=colors.red,
               opacity=1.0):
    """ Sets up a cone actor and returns the tvtk.Actor object."""
    source = tvtk.ConeSource(center=center, height=height,
                             radius=radius, direction=direction,
                             resolution=resolution)
    mapper = tvtk.PolyDataMapper()
    configure_input_data(mapper, source.output)
    p = tvtk.Property(opacity=opacity, color=color)
    actor = tvtk.Actor(mapper=mapper, property=p)
    source.update()
    return actor


def cube_actor(center=(0, 0, 0), color=colors.blue, opacity=1.0):
    """ Creates a cube and returns the tvtk.Actor. """

    source = tvtk.CubeSource(center=center)
    mapper = tvtk.PolyDataMapper()
    configure_input_data(mapper, source.output)
    p = tvtk.Property(opacity=opacity, color=color)
    actor = tvtk.Actor(mapper=mapper, property=p)
    source.update()
    return actor


def cylinder_actor(center=(0, 0, 0), radius=0.5, resolution=64,
                   color=colors.green, opacity=1.0):
    """ Creates a cylinder and returns a tvtk.Actor. """
    source = tvtk.CylinderSource(center=center, radius=radius,
                                 resolution=resolution)
    mapper = tvtk.PolyDataMapper()
    configure_input_data(mapper, source.output)
    prop = tvtk.Property(opacity=opacity, color=color)
    actor = tvtk.Actor(mapper=mapper, property=prop)
    source.update()
    return actor


def earth_actor(radius=0.5, opacity=1.0):
    """ Creates an earth source and returns the actor. """
    source = tvtk.EarthSource(radius=radius, on_ratio=16, outline=0)
    mapper = tvtk.PolyDataMapper()
    configure_input_data(mapper, source.output)
    prop = tvtk.Property(opacity=opacity)
    actor = tvtk.Actor(mapper=mapper, property=prop)
    source.update()
    return actor


def sphere_actor(center=(0, 0, 0), radius=0.5, resolution=32,
                 color=colors.purple, opacity=1.0):
    """ Creates a sphere and returns the actor. """
    source = tvtk.SphereSource(center=center, radius=radius,
                               theta_resolution=resolution,
                               phi_resolution=resolution)
    mapper = tvtk.PolyDataMapper()
    configure_input_data(mapper, source.output)
    prop = tvtk.Property(opacity=opacity, color=color)
    actor = tvtk.Actor(mapper=mapper, property=prop)
    source.update()
    return actor


def arrow_actor(color=colors.peacock, opacity=1.0, resolution=24):
    """ Creates a 3D Arrow and returns an actor. """
    source = tvtk.ArrowSource(tip_resolution=resolution,
                              shaft_resolution=resolution)
    mapper = tvtk.PolyDataMapper()
    configure_input_data(mapper, source.output)
    prop = tvtk.Property(opacity=opacity, color=color)
    actor = tvtk.Actor(mapper=mapper, property=prop)
    source.update()
    return actor


########NEW FILE########
__FILENAME__ = actor_editor
""" A mostly-general Traits UI editor for viewing things in TVTK scenes.
"""

# Authors: Robert Kern <robert.kern [at] gmail.com>
#          Prabhu Ramachandran <prabhu [at] aero.iitb.ac.in>
# Copyright (c) 2007, Enthought, Inc.
# License: BSD Style.

# Import the toolkit specific version.
from tvtk.pyface.toolkit import toolkit_object
ActorEditor = toolkit_object('actor_editor:ActorEditor')

########NEW FILE########
__FILENAME__ = actor_model
""" A simple model to use for viewing TVTK actors/widgets.
"""

# Authors: Robert Kern <robert.kern [at] gmail.com>
#          Prabhu Ramachandran <prabhu [at] aero.iitb.ac.in>
# Copyright (c) 2007, Enthought, Inc.
# License: BSD Style.

# Enthought library imports.
from traits.api import Dict, Event, HasTraits, Bool

#####################################################################
# `ITVTKActorModel` class
#####################################################################
class ITVTKActorModel(HasTraits):
    """ An interface for view models that can control a TVTK scene's contents.
    """

    # This maintains a dictionary mapping objects (by identity) to lists (or
    # single items) of TVTK Actors or 3D Widgets that represent them in the
    # scene. Adding and removing objects from this dictionary adds and removes
    # them from the scene. This is the trait that will be edited by a
    # ActorEditor.
    actor_map = Dict()

    # Turn off rendering such that multiple adds/removes can be refreshed at
    # once.
    disable_render = Bool(False)

    # Send this event in order to force a rendering of the scene.
    do_render = Event()



########NEW FILE########
__FILENAME__ = api
from decorated_scene import DecoratedScene
from scene import Scene

########NEW FILE########
__FILENAME__ = decorated_scene
"""A VTK interactor scene which provides a convenient toolbar that
allows the user to set the camera view, turn on the axes indicator
etc.
"""
# Authors: Prabhu Ramachandran <prabhu_r@users.sf.net>,
#          Dave Peterson <dpeterson@enthought.com>
# Copyright (c) 2006, Enthought, Inc.
# License: BSD Style.


# Import the toolkit specific version.
from tvtk.pyface.toolkit import toolkit_object
DecoratedScene = toolkit_object('decorated_scene:DecoratedScene')

########NEW FILE########
__FILENAME__ = light_manager
#------------------------------------------------------------------------------
# Copyright (c) 2005, Enthought, Inc.
# All rights reserved.
#
# This software is provided without warranty under the terms of the BSD
# license included in enthought/LICENSE.txt and may be redistributed only
# under the conditions described in the aforementioned license.  The license
# is also available online at http://www.enthought.com/licenses/BSD.txt
# Thanks for using Enthought open source!
#
# Author: Enthought, Inc.
# Description: <Enthought pyface package component>
#------------------------------------------------------------------------------
"""This module provides a light manager that may be used to change the
lighting of a VTK scene.

This module is largely ported from MayaVi's Lights.py but the
implementation is considerably different.

"""
# Author: Prabhu Ramachandran <prabhu_r@users.sf.net>
# Copyright (c) 2005, Enthought, Inc.
# License: BSD Style.

from math import sin, cos, atan2, pi, sqrt

from traits.api import HasTraits, Range, false, \
                                 Instance, Trait, List
from traitsui.api import View, Group, Handler, ListEditor, Item
from tvtk.api import tvtk
from tvtk.tvtk_base import vtk_color_trait, TraitRevPrefixMap
from tvtk.common import is_old_pipeline, configure_input, configure_input_data
from apptools.persistence import state_pickler

######################################################################
# `LightGlyph` class.
######################################################################
class LightGlyph(HasTraits):
    """Manages a glyph that represents a Light source in the scene.
    This gives the user an *idea* of where the light source is placed
    while configuring the lights.
    """
    # The version of this class.  Used for persistence.
    __version__ = 0

    def __init__(self):
        self.el = 0.0
        self.az = 0.0

        # Create an arrow.
        arrow = tvtk.ArrowSource()

        # Transform it suitably so it is oriented correctly.
        t = tvtk.Transform()
        tf = tvtk.TransformFilter()
        tf.transform = t
        t.rotate_y(90.0)
        t.translate((-2, 0, 0))
        configure_input_data(tf, arrow.output)

        mapper = tvtk.PolyDataMapper()
        configure_input(mapper, tf)

        self.actor = actor = tvtk.Follower()
        actor.mapper = mapper
        prop = actor.property
        prop.color = 0, 1, 1
        prop.ambient = 0.5
        prop.diffuse = 0.5

    def __get_pure_state__(self):
        d = self.__dict__.copy()
        for name in ['__sync_trait__',  '__traits_listener__']:
            d.pop(name, None)
        return d

    def __getstate__(self):
        return state_pickler.dumps(self)

    def __setstate__(self, str_state):
        self.__init__()
        state_pickler.set_state(self, state_pickler.loads_state(str_state))

    #################################################################
    # `LightGlyph` interface.
    #################################################################
    def add(self, ren, bounds):
        """Adds the actors to the given renderer (`ren`).  The actors
        are scaled as per the given bounds."""
        scale = max(bounds[1]-bounds[0], bounds[3] - bounds[2],
                    bounds[5]-bounds[4])*0.75
        self.actor.scale = scale, scale, scale
        ren.add_actor(self.actor)
        cam = ren.active_camera
        self.actor.camera = cam

    def remove(self, ren):
        """Removes the actors of the glyph from the given renderer
        (`ren`)."""
        ren.remove_actor(self.actor)

    def move_to(self, elevation=None, azimuth = None):
        """Move the glyphs to the specified elevation and azimuth."""
        self.actor.rotate_x(-self.el)
        self.actor.rotate_y(-self.az)
        if elevation != None:
            self.el = elevation
        if azimuth != None:
            self.az = azimuth
        self.actor.rotate_y(self.az)
        self.actor.rotate_x(self.el)

    def show(self):
        """Show the glyphs on screen."""
        self.actor.visibility = 1

    def hide(self):
        """Hide the glyphs on screen."""
        self.actor.visibility = 0

    def set_color(self, clr):
        """Change the glyphs color."""
        self.actor.property.color = clr



######################################################################
# `CameraLight` class.
######################################################################
class CameraLight(HasTraits):

    """This class manages a tvtk.Light object and a LightGlyph object."""

    # The version of this class.  Used for persistence.
    __version__ = 0

    #################################################################
    # Traits.
    #################################################################
    elevation = Range(-90.0, 90.0, 0.0,
                      desc="the elevation of the light")
    azimuth = Range(-180.0, 180.0, 0.0,
                    desc="the aziumthal angle of the light")
    activate = Trait(False, false,
                     desc="specifies if the light is enabled or not")
    source = Instance(tvtk.Light, ())

    # FIXME: Traits Delegation does not work correctly and changes to
    # this object are not reflected in the delegate nicely.
    #color = Delegate('source', modify=True)
    #intensity = Delegate('source', modify=True)

    # For now we mirror these traits from the source.
    intensity = Range(0.0, 1.0, 1.0,
                      desc="the intensity of the light")
    color = vtk_color_trait((1.0, 1.0, 1.0))
    color.desc = "the color of the light"

    default_view = View(Item(name='activate'), Item(name='elevation'),
                        Item(name='azimuth'), Item(name='intensity'),
                        Item(name='color'))

    #################################################################
    # `object` interface.
    #################################################################
    def __init__(self, renwin, **traits):
        self.glyph = LightGlyph()
        super(CameraLight, self).__init__(**traits)
        self.source.light_type = 'camera_light'
        self._intensity_changed(self.intensity)
        self._activate_changed(self.activate)
        self._color_changed(self.color)

        renwin.renderer.add_light(self.source)
        self.on_trait_change(renwin.render)

    def __get_pure_state__(self):
        d = self.__dict__.copy()
        for name in ['__sync_trait__', '__traits_listener__']:
            d.pop(name, None)
        return d

    def __getstate__(self):
        return state_pickler.dumps(self)

    def __setstate__(self, str_state):
        #self.__init__()
        state_pickler.set_state(self, state_pickler.loads_state(str_state))

    #################################################################
    # `LightGlyph` interface.
    #################################################################
    def close(self, renwin):
        """Remove the light source and the glyph from the
        renderwindow.  This is usually to be called when the Light is
        removed from the scene."""
        ren = renwin.renderer
        self.on_trait_change(renwin.render, remove=True)
        ren.remove_light(self.source)
        self.remove_glyph(ren)

    def add_glyph(self, ren, bounds):
        """Add the light glyph to the passed renderer ('ren').  Scale
        the actors using the bounds (`bounds`) provided."""
        self.glyph.add(ren, bounds)

    def remove_glyph(self, ren):
        """Remove the light glyph from the passed renderer."""
        self.glyph.remove(ren)

    def move_to(self, elevation, azimuth):
        """Move the light to the specified elevation and azimuthal
        angles (in degrees)."""
        self.elevation = elevation
        self.azimuth = azimuth

    #################################################################
    # Trait handlers.
    #################################################################
    def _activate_changed(self, val):
        if val:
            self.source.switch = 1
            self.glyph.show()
        else:
            self.source.switch = 0
            self.glyph.hide()

    def _intensity_changed(self, val):
        self.source.intensity = val

    def _color_changed(self, val):
        if is_old_pipeline():
            self.source.color = val
        else:
            self.source.set_color(val)
        self.glyph.set_color(val)

    def _elevation_changed(self, val):
        self.glyph.move_to(val, self.azimuth)
        self.source.position = self._to_pos(val, self.azimuth)

    def _azimuth_changed(self, val):
        self.glyph.move_to(self.elevation, val)
        self.source.position = self._to_pos(self.elevation, val)

    #################################################################
    # Non-public interface.
    #################################################################
    def _to_pos(self, elevation, azimuth):
        """Convert the given elevation and azimuth angles (degrees) to
        a position vector."""
        theta = azimuth*pi/180.0
        phi = (90.0-elevation)*pi/180.0
        x = sin(theta)*sin(phi)
        y = cos(phi)
        z = cos(theta)*sin(phi)
        return x, y, z

    def _from_pos(self, x, y, z):
        """Given the position vector, return an elevation and azimuth
        angle (in degrees)."""
        theta = atan2(x, z)
        phi = atan2(sqrt(x**2+z**2), y)
        az = theta*180.0/pi
        el = 90.0 - phi*180.0/pi
        return el, az



######################################################################
# `CloseHandler` class.
######################################################################
class CloseHandler(Handler):
    """This class cleans up after the UI for the Light Manager is
    closed."""
    def close(self, info, is_ok):
        """This method is invoked when the user closes the UI."""
        light_manager = info.object
        light_manager.on_ui_close()
        return True


######################################################################
# `LightManager` class.
######################################################################
class LightManager(HasTraits):

    """This class manages all the lights and presents a GUI for the
    lights.

    There are two default lighting modes possible (specified via the
    `light_mode` trait).  The 'vtk' mode uses the default lighting
    mode which is basically a single headlight.  The 'raymond' mode
    creates three lights to give better overall illumination (thanks
    to Raymond Maple).
    """

    # The version of this class.  Used for persistence.
    __version__ = 0

    #################################################################
    # Traits.
    #################################################################

    # Valid modes currently are 'vtk' and 'raymond'.  'vtk' is the
    # default VTK light setup with only one light on in headlight
    # mode. 'raymond' is Raymond Maple's default configuration with
    # three active lights.  Please note that this only specifies a
    # default mode used to initialize the lights to a sane default.
    # The user can always change the light configuration via the GUI
    # such that the mode is neither 'vtk' nor 'raymond'.
    light_mode = Trait('raymond', TraitRevPrefixMap({'raymond':1,
                                                     'vtk':2}),
                       desc='specifies a default lighting mode')

    # Specify the number of lights.  If new lights are added they are
    # by default turned off.  Similarly if the number of lights are
    # reduced the last lights alone are removed.
    number_of_lights = Range(3, 8, 4, desc='specifies the number of lights')

    # The list of added lights.
    lights = List(CameraLight, editor=ListEditor(use_notebook=True,
                                                 page_name='Light'),
                  record=True)

    view = View( Group( 'light_mode',
                        'number_of_lights', ),
                Item('lights', style='custom', show_label=False),
                resizable=True,
                buttons=['OK'])


    #################################################################
    # `object` interface.
    #################################################################
    def __init__(self, renwin, **traits):
        super(LightManager, self).__init__(**traits)

        self.ui = None
        self.renwin = renwin
        ren = self.renwin.renderer

        # VTK requires that there always be atleast one light turned
        # on (with SwitchOn).  The renderer already has one headlight
        # already enabled.  We merely set the intensity of this light
        # to zero and never change that.  Note that if this light is
        # turned off, and no other lights are "on", then VTK will
        # create a new light!
        ren.lights[0].intensity = 0.0

        # Create the lights.
        self.lights = []
        for i in range(self.number_of_lights):
            light = CameraLight(self.renwin)
            self.lights.append(light)

        # Setup the light mode.
        self._light_mode_changed(self.light_mode)

    def __get_pure_state__(self):
        d = self.__dict__.copy()
        for name in ['__sync_trait__', 'renwin', 'ui',
                     '__traits_listener__']:
            d.pop(name, None)
        return d

    def __set_pure_state__(self, state):
        first = ['light_mode', 'number_of_lights']
        state_pickler.set_state(self, state, first=first, last=['lights'])

    def __getstate__(self):
        return state_pickler.dumps(self)

    def __setstate__(self, str_state):
        # This method is unnecessary since this object will almost
        # never be pickled by itself and only via the scene, therefore
        # __init__ will be called when the scene is constructed.
        # However, setstate is defined just for completeness.
        #self.__init__()
        state = state_pickler.loads_state(str_state)
        state_pickler.update_state(state)
        self.__set_pure_state__(state)

    #################################################################
    # `LightManager` interface.
    #################################################################
    def configure(self):
        """Pops up the GUI control widget."""
        if self.ui is None:
            self._show_glyphs()
            view = View(Group(Item(name='light_mode'),
                              Item(name='number_of_lights'),
                              label='LightManager'),
                        Group(Item(name='lights', style='custom'),
                              label='Lights',
                              selected=True, show_labels=False),
                        resizable=True,
                        buttons=['OK'],
                        handler=CloseHandler())
            self.ui = view.ui(self)
        else:
            try:
                self.ui.control.Raise()
            except AttributeError:
                pass

    def on_ui_close(self):
        """This method removes the glyphs used to show the lights on
        screen when the GUI dialog is closed.  This is typically only
        called from the CloseHandler."""
        ren = self.renwin.renderer
        for l in self.lights:
            l.remove_glyph(ren)
        self.ui = None

    #################################################################
    # Non-public interface.
    #################################################################
    def _show_glyphs(self):
        """Shows the glyphs when the light config UI is shown."""
        rw = self.renwin
        ren = rw.renderer
        rw.reset_zoom()
        bounds = ren.compute_visible_prop_bounds()
        for light in self.lights:
            light.add_glyph(ren, bounds)
        rw.render()

    def _light_mode_changed(self, mode):
        lights = self.lights
        if mode == 'raymond':
            for i in range(len(lights)):
                if i < 3:
                    lights[i].activate = True
                    lights[i].intensity = 1.0
                    lights[i].color = 1.0, 1.0, 1.0
                else:
                    lights[i].activate = False
                    lights[i].move_to(0.0, 0.0)
                    lights[i].intensity = 1.0
                    lights[i].color = 1.0, 1.0, 1.0

            lights[0].move_to(45.0, 45.0)
            lights[1].move_to(-30.0,-60.0)
            lights[1].intensity = 0.6
            lights[2].move_to(-30.0, 60.0)
            lights[2].intensity = 0.5
        else:
            for i in range(len(lights)):
                lights[i].move_to(0.0, 0.0)
                lights[i].intensity = 1.0
                lights[i].color = 1.0, 1.0, 1.0
                if i == 0 :
                    lights[i].activate  = True
                else:
                    lights[i].activate = False

    def _number_of_lights_changed(self, old, new):
        ren = self.renwin.renderer
        changed = False
        if new == old:
            return
        elif new > old:
            for i in range(new - old):
                light = CameraLight(self.renwin)
                self.lights.append(light)
            changed = True
        elif new < old:
            for i in range(old - new):
                light = self.lights.pop()
                light.close(self.renwin)
            changed = True


########NEW FILE########
__FILENAME__ = picker
#------------------------------------------------------------------------------
# Copyright (c) 2005, Enthought, Inc.
# All rights reserved.
#
# This software is provided without warranty under the terms of the BSD
# license included in enthought/LICENSE.txt and may be redistributed only
# under the conditions described in the aforementioned license.  The license
# is also available online at http://www.enthought.com/licenses/BSD.txt
# Thanks for using Enthought open source!
#
# Author: Enthought, Inc.
# Description: <Enthought pyface package component>
#------------------------------------------------------------------------------
"""This module provides basic picking functionality.  Using this, one
can interactively select a point and/or a cell in the data.  One can
also can use a world point picker (i.e. a generic point in space) and
probe for the data at that point.

"""
# Author: Prabhu Ramachandran <prabhu_r@users.sf.net>
# Copyright (c) 2004, Enthought, Inc.
# License: BSD Style.

from traits.api import HasTraits, Trait, Long, Array, Any, Float, \
                                 Instance, Range, true, Str
from traitsui.api import View, Group, Item, Handler
from tvtk.api import tvtk
from tvtk.tvtk_base import TraitRevPrefixMap, false_bool_trait
from tvtk.common import configure_input_data
from apptools.persistence import state_pickler


######################################################################
# Utility functions.
######################################################################
def get_last_input(data):
    """Attempts to get the deepest possible data value in the
    pipeline.  Used when probing a selected point."""
    tmp = inp = data
    while tmp:
        try:
            tmp = inp.input
            if tmp:
                inp = tmp
        except AttributeError:
            tmp = None
    return inp

######################################################################
# `PickedData` class.
######################################################################
class PickedData(HasTraits):
    """This class stores the picked data."""

    # Was there a valid picked point?
    valid = Trait(false_bool_trait,
                  desc='specifies the validity of the pick event')
    # Id of picked point (-1 implies none was picked)
    point_id = Long(-1, desc='the picked point ID')
    # Id of picked cell (-1 implies none was picked)
    cell_id = Long(-1, desc='the picked cell ID')
    # World pick -- this has no ID.
    world_pick = Trait(false_bool_trait,
                       desc='specifies if the pick is a world pick.')
    # Coordinate of picked point.
    coordinate = Array('d', (3,), labels=['x', 'y', 'z'], cols=3,
                       desc='the coordinate of the picked point')

    # The picked data -- usually a tvtk.PointData or tvtk.CellData of
    # the object picked.  The user can use this data and extract any
    # necessary values.
    data = Any


######################################################################
# `PickerHandler` class.
######################################################################
class PickHandler(HasTraits):
    """This is the handler for the picked data.  Subclass this to do
    what you need.  Each time a pick occurs the handle_pick is called
    by the `Picker` class."""

    def handle_pick(self, data):
        """Called when a pick event happens.

        Parameters
        ----------

        - data : `PickedData` instance.
        """
        pass


######################################################################
# `DefaultPickerHandler` class.
######################################################################
class DefaultPickHandler(PickHandler):
    """The default handler for the picked data."""

    # Traits.
    ID = Trait(None, None, Long, desc='the picked ID')

    coordinate = Trait(None, None, Array('d', (3,)),
                       desc='the coordinate of the picked point')

    scalar = Trait(None, None, Float, desc='the scalar at picked point')

    vector = Trait(None, None, Array('d', (3,)),
                   desc='the vector at picked point')

    tensor = Trait(None, None, Array('d', (3,3)),
                   desc='the tensor at picked point')

    # History of picked data.
    history = Str

    default_view = View(Item(name='ID', style='readonly'),
                        Item(name='coordinate', style='readonly'),
                        Item(name='scalar', style='readonly'),
                        Item(name='vector', style='readonly'),
                        Item(name='tensor', style='readonly'),
                        Item(name='history', style='custom'),
                        )

    def __init__(self, **traits):
        super(DefaultPickHandler, self).__init__(**traits)
        # This saves all the data picked earlier.
        self.data = {'ID':[], 'coordinate':[], 'scalar':[], 'vector':[],
                     'tensor':[]}

    #################################################################
    # `DefaultPickHandler` interface.
    #################################################################
    def handle_pick(self, data):
        """Called when a pick event happens.
        """
        if data.valid_:
            if data.point_id > -1:
                self.ID = data.point_id
            elif data.cell_id > -1:
                self.ID = data.cell_id
            self.coordinate = data.coordinate

            if data.data:
                array_data = {'scalar': data.data.scalars,
                              'vector': data.data.vectors,
                              'tensor': data.data.tensors}
            else:
                array_data = {'scalar': None,
                              'vector': None,
                              'tensor': None}
            for name in array_data.keys():
                if array_data[name]:
                    setattr(self, name, array_data[name][self.ID])
                else:
                    setattr(self, name, None)
        else:
            for name in ['ID', 'coordinate', 'scalar', 'vector', 'tensor']:
                setattr(self, name, None)
        self._update_data()

    #################################################################
    # Non-public interface.
    #################################################################
    def _update_data(self):
        for name in ['ID', 'coordinate', 'scalar', 'vector', 'tensor']:
            value = getattr(self, name)
            self.data.get(name).append(getattr(self, name))
            self.history += '%s: %r\n'%(name, value)



######################################################################
# `CloseHandler` class.
######################################################################
class CloseHandler(Handler):
    """This class cleans up after the UI for the Picker is closed."""
    def close(self, info, is_ok):
        """This method is invoked when the user closes the UI."""
        picker = info.object
        picker.on_ui_close()
        return True


######################################################################
# `Picker` class.
######################################################################
class Picker(HasTraits):
    """This module creates a 'Picker' that can interactively select a
    point and/or a cell in the data.  It also can use a world point
    picker (i.e. a generic point in space) and will probe for the data
    at that point.

    The Picker is usually called via a callback from the GUI
    interactor window.  After performing a pick on the VTK scene, a
    Picker object creates a `PickedData` object and passes it on to
    the pick_handler trait for further handling.
    """

    # The version of this class.  Used for persistence.
    __version__ = 0

    # Speficifies the pick type.  The 'point_picker' and 'cell_picker'
    # options are self-explanatory.  The 'world_picker' picks a point
    # using a WorldPointPicker and additionally uses a ProbeFilter to
    # probe the data at the picked point.
    pick_type = Trait('point', TraitRevPrefixMap({'point_picker':1,
                                                  'cell_picker':2,
                                                  'world_picker':3}),
                      desc='specifies the picker type to use')

    # The pick_handler.  Set this to your own subclass if you want do
    # do something different from the default.
    pick_handler = Trait(DefaultPickHandler(), Instance(PickHandler))

    # Picking tolerance.
    tolerance = Range(0.0, 0.25, 0.025)

    # show the GUI on pick ?
    show_gui = true(desc = "whether to show the picker GUI on pick")

    # Raise the GUI on pick ?
    auto_raise = true(desc = "whether to raise the picker GUI on pick")

    default_view = View(Group(Group(Item(name='pick_type'),
                                    Item(name='tolerance'), show_border=True),
                              Group(Item(name='pick_handler', style='custom'),
                                    show_border=True, show_labels=False),
                              Group(Item(name='show_gui'),
                                    Item(name='auto_raise'), show_border=True),
                              ),
                        resizable=True,
                        buttons=['OK'],
                        handler=CloseHandler())

    #################################################################
    # `object` interface.
    #################################################################
    def __init__(self, renwin, **traits):
        super(Picker, self).__init__(**traits)

        self.renwin = renwin
        self.pointpicker = tvtk.PointPicker()
        self.cellpicker = tvtk.CellPicker()
        self.worldpicker = tvtk.WorldPointPicker()
        self.probe_data = tvtk.PolyData()
        self._tolerance_changed(self.tolerance)

        # Use a set of axis to show the picked point.
        self.p_source = tvtk.Axes()
        self.p_mapper = tvtk.PolyDataMapper()
        self.p_actor = tvtk.Actor ()
        self.p_source.symmetric = 1
        self.p_actor.pickable = 0
        self.p_actor.visibility = 0
        prop = self.p_actor.property
        prop.line_width = 2
        prop.ambient = 1.0
        prop.diffuse = 0.0
        configure_input_data(self.p_mapper, self.p_source.output)
        self.p_actor.mapper = self.p_mapper

        self.probe_data.points = [[0.0, 0.0, 0.0]]

        self.ui = None

    def __get_pure_state__(self):
        d = self.__dict__.copy()
        for x in ['renwin', 'ui', 'pick_handler', '__sync_trait__', '__traits_listener__']:
            d.pop(x, None)
        return d

    def __getstate__(self):
        return state_pickler.dumps(self)

    def __setstate__(self, str_state):
        # This method is unnecessary since this object will almost
        # never be pickled by itself and only via the scene, therefore
        # __init__ will be called when the scene is constructed.
        # However, setstate is defined just for completeness.
        state_pickler.set_state(self, state_pickler.loads_state(str_state))

    #################################################################
    # `Picker` interface.
    #################################################################
    def pick(self, x, y):
        """Calls one of the current pickers and then passes the
        obtained data to the `self.pick_handler` object's
        `handle_pick` method.

        Parameters
        ----------

        - x : X position of the mouse in the window.

        - y : Y position of the mouse in the window.

          Note that the origin of x, y must be at the left bottom
          corner of the window.  Thus, for most GUI toolkits, y must
          be flipped appropriately such that y=0 is the bottom of the
          window.
        """

        data = None
        if self.pick_type_ == 1:
            data = self.pick_point(x, y)
        elif self.pick_type_ == 2:
            data = self.pick_cell(x, y)
        elif self.pick_type_ == 3:
            data = self.pick_world(x, y)

        self.pick_handler.handle_pick(data)
        if self.show_gui:
            self._setup_gui()

    def pick_point(self, x, y):
        """ Picks the nearest point. Returns a `PickedData` instance."""
        self.pointpicker.pick((float(x), float(y), 0.0), self.renwin.renderer)

        pp = self.pointpicker
        id = pp.point_id
        picked_data = PickedData()
        coord = pp.pick_position
        picked_data.coordinate = coord

        if id > -1:
            data = pp.mapper.input.point_data
            bounds = pp.mapper.input.bounds

            picked_data.valid = 1
            picked_data.point_id = id
            picked_data.data = data

            self._update_actor(coord, bounds)
        else:
            self.p_actor.visibility = 0

        self.renwin.render()
        return picked_data

    def pick_cell (self, x, y):
        """ Picks the nearest cell. Returns a `PickedData` instance."""
        try:
            self.cellpicker.pick(float(x), float(y), 0.0,
                                 self.renwin.renderer)
        except TypeError:
            # On old versions of VTK, the signature used to be different
            self.cellpicker.pick((float(x), float(y), 0.0),
                                 self.renwin.renderer)

        cp = self.cellpicker
        id = cp.cell_id
        picked_data = PickedData()
        coord = cp.pick_position
        picked_data.coordinate = coord

        if id > -1:
            data = cp.mapper.input.cell_data
            bounds = cp.mapper.input.bounds

            picked_data.valid = 1
            picked_data.cell_id = id
            picked_data.data = data

            self._update_actor(coord, bounds)
        else:
            self.p_actor.visibility = 0

        self.renwin.render()
        return picked_data

    def pick_world(self, x, y):
        """ Picks a world point and probes for data there. Returns a
        `PickedData` instance."""
        self.worldpicker.pick((float(x), float(y), 0.0), self.renwin.renderer)

        # Use the cell picker to get the data that needs to be probed.
        try:
            self.cellpicker.pick( (float(x), float(y), 0.0), self.renwin.renderer)
        except TypeError:
            self.cellpicker.pick( float(x), float(y), 0.0, self.renwin.renderer)

        wp = self.worldpicker
        cp = self.cellpicker
        coord = wp.pick_position
        self.probe_data.points = [list(coord)]
        picked_data = PickedData()
        picked_data.coordinate = coord

        if cp.mapper:
            data = get_last_input(cp.mapper.input)
            # Need to create the probe each time because otherwise it
            # does not seem to work properly.
            probe = tvtk.ProbeFilter()
            probe.source = data
            probe.input = self.probe_data
            probe.update()
            data = probe.output.point_data
            bounds = cp.mapper.input.bounds

            picked_data.valid = 1
            picked_data.world_pick = 1
            picked_data.point_id = 0
            picked_data.data = data

            self._update_actor(coord, bounds)
        else:
            self.p_actor.visibility = 0

        self.renwin.render()
        return picked_data

    def on_ui_close(self):
        """This method makes the picker actor invisible when the GUI
        dialog is closed."""
        self.p_actor.visibility = 0
        self.renwin.renderer.remove_actor(self.p_actor)
        self.ui = None

    #################################################################
    # Non-public interface.
    #################################################################
    def _tolerance_changed(self, val):
        """ Trait handler for the tolerance trait."""
        self.pointpicker.tolerance = val
        self.cellpicker.tolerance = val

    def _update_actor(self, coordinate, bounds):
        """Updates the actor by setting its position and scale."""
        dx = 0.3*(bounds[1]-bounds[0])
        dy = 0.3*(bounds[3]-bounds[2])
        dz = 0.3*(bounds[5]-bounds[4])
        scale = max(dx,dy,dz)
        self.p_source.origin = coordinate
        self.p_source.scale_factor = scale
        self.p_actor.visibility = 1

    def _setup_gui(self):
        """Pops up the GUI control widget."""
        # Popup the GUI control.
        if self.ui is None:
            self.ui = self.edit_traits()
            # Note that we add actors to the renderer rather than to
            # renwin to prevent event notifications on actor
            # additions.
            self.renwin.renderer.add_actor(self.p_actor)
        elif self.auto_raise:
            try:
                self.ui.control.Raise()
            except AttributeError:
                pass


########NEW FILE########
__FILENAME__ = scene
#------------------------------------------------------------------------------
# Copyright (c) 2005, Enthought, Inc.
# All rights reserved.
#
# This software is provided without warranty under the terms of the BSD
# license included in enthought/LICENSE.txt and may be redistributed only
# under the conditions described in the aforementioned license.  The license
# is also available online at http://www.enthought.com/licenses/BSD.txt
# Thanks for using Enthought open source!
#
# Author: Enthought, Inc.
# Description: <Enthought pyface package component>
#------------------------------------------------------------------------------
"""A VTK interactor scene widget for the PyFace wxPython backend.  See
the class docs for more details.

"""
# Author: Prabhu Ramachandran <prabhu_r@users.sf.net>
# Copyright (c) 2004-2007, Enthought, Inc.
# License: BSD Style.


# Import the toolkit specific version.
from tvtk.pyface.toolkit import toolkit_object
Scene = toolkit_object('scene:Scene')

########NEW FILE########
__FILENAME__ = scene_editor
"""A `SceneEditor` for the `SceneModel`.
"""

# Authors: Prabhu Ramachandran <prabhu [at] aero.iitb.ac.in>
#          Robert Kern <robert.kern [at] gmail.com>
#
# Copyright (c) 2007, Enthought, Inc.
# License: BSD Style.

# Import the toolkit specific version.
from tvtk.pyface.toolkit import toolkit_object
SceneEditor = toolkit_object('scene_editor:SceneEditor')

########NEW FILE########
__FILENAME__ = scene_model
"""
TODO:

 * We need a cleaner way to manipulate the camera  and other things as a model.
   The current approach will be far from perfect but should work.

Caveats:

 * You can't have multiple views of the model.  This will not be supported.

"""
# Author: Prabhu Ramachandran <prabhu [at] aero.iitb.ac.in>
# Copyright (c) 2007, Enthought, Inc.
# License: BSD Style.

# Enthought library imports.
from traits.api import Dict, Event, \
                                 Instance, List, Property
from traitsui.api import View, Group, Item, InstanceEditor
from tvtk.pyface.tvtk_scene import TVTKScene


#####################################################################
# `SceneModelError` class
#####################################################################
class SceneModelError(Exception):
    pass


#####################################################################
# `SceneModel` class
#####################################################################
class SceneModel(TVTKScene):

    ########################################
    # TVTKScene traits.

    light_manager = Property

    picker = Property

    ########################################
    # SceneModel traits.

    # A convenient dictionary based interface to add/remove actors and widgets.
    # This is similar to the interface provided for the ActorEditor.
    actor_map = Dict()

    # This is used primarily to implement the add_actor/remove_actor methods.
    actor_list = List()

    # The actual scene being edited.
    scene_editor = Instance(TVTKScene)

    do_render = Event()

    # Fired when this is activated.
    activated = Event()

    # Fired when this widget is closed.
    closing = Event()

    # This exists just to mirror the TVTKWindow api.
    scene = Property

    ###################################
    # View related traits.

    # Render_window's view.
    _stereo_view = Group(Item(name='stereo_render'),
                         Item(name='stereo_type'),
                         show_border=True,
                         label='Stereo rendering',
                         )

    # The default view of this object.
    default_view = View(Group(
                            Group(Item(name='background'),
                                  Item(name='foreground'),
                                  Item(name='parallel_projection'),
                                  Item(name='disable_render'),
                                  Item(name='off_screen_rendering'),
                                  Item(name='jpeg_quality'),
                                  Item(name='jpeg_progressive'),
                                  Item(name='magnification'),
                                  Item(name='anti_aliasing_frames'),
                                  ),
                            Group(Item(name='render_window',
                                       style='custom',
                                       visible_when='object.stereo',
                                       editor=InstanceEditor(view=View(_stereo_view)),                                       show_label=False),
                                  ),
                            label='Scene'),
                        Group(Item(name='light_manager',
                                   style='custom',
                                   editor=InstanceEditor(),
                                   show_label=False),
                                   label='Lights')
                        )

    ###################################
    # Private traits.

    # Used by the editor to determine if the widget was enabled or not.
    enabled_info = Dict()

    def __init__(self, parent=None, **traits):
        """ Initializes the object. """
        # Base class constructor.  We call TVTKScene's super here on purpose.
        # Calling TVTKScene's init will create a new window which we do not
        # want.
        super(TVTKScene, self).__init__(**traits)
        self.control = None

    ######################################################################
    # TVTKScene API.
    ######################################################################
    def render(self):
        """ Force the scene to be rendered. Nothing is done if the
        `disable_render` trait is set to True."""

        self.do_render = True

    def add_actors(self, actors):
        """ Adds a single actor or a tuple or list of actors to the
        renderer."""
        if hasattr(actors, '__iter__'):
            self.actor_list.extend(actors)
        else:
            self.actor_list.append(actors)

    def remove_actors(self, actors):
        """ Removes a single actor or a tuple or list of actors from
        the renderer."""
        my_actors = self.actor_list
        if hasattr(actors, '__iter__'):
            for actor in actors:
                my_actors.remove(actor)
        else:
            my_actors.remove(actors)

    # Conevenience methods.
    add_actor = add_actors
    remove_actor = remove_actors

    def add_widgets(self, widgets, enabled=True):
        """Adds widgets to the renderer.
        """
        if not hasattr(widgets, '__iter__'):
            widgets = [widgets]
        for widget in widgets:
            self.enabled_info[widget] = enabled
        self.add_actors(widgets)

    def remove_widgets(self, widgets):
        """Removes widgets from the renderer."""
        if not hasattr(widgets, '__iter__'):
            widgets = [widgets]
        self.remove_actors(widgets)
        for widget in widgets:
            del self.enabled_info[widget]

    def reset_zoom(self):
        """Reset the camera so everything in the scene fits."""
        if self.scene_editor is not None:
            self.scene_editor.reset_zoom()

    def save(self, file_name, size=None, **kw_args):
        """Saves rendered scene to one of several image formats
        depending on the specified extension of the filename.

        If an additional size (2-tuple) argument is passed the window
        is resized to the specified size in order to produce a
        suitably sized output image.  Please note that when the window
        is resized, the window may be obscured by other widgets and
        the camera zoom is not reset which is likely to produce an
        image that does not reflect what is seen on screen.

        Any extra keyword arguments are passed along to the respective
        image format's save method.
        """
        self._check_scene_editor()
        self.scene_editor.save(file_name, size, **kw_args)

    def save_ps(self, file_name):
        """Saves the rendered scene to a rasterized PostScript image.
        For vector graphics use the save_gl2ps method."""
        self._check_scene_editor()
        self.scene_editor.save_ps(file_name)

    def save_bmp(self, file_name):
        """Save to a BMP image file."""
        self._check_scene_editor()
        self.scene_editor.save_bmp(file_name)

    def save_tiff(self, file_name):
        """Save to a TIFF image file."""
        self._check_scene_editor()
        self.scene_editor.save_tiff(file_name)

    def save_png(self, file_name):
        """Save to a PNG image file."""
        self._check_scene_editor()
        self.scene_editor.save_png(file_name)

    def save_jpg(self, file_name, quality=None, progressive=None):
        """Arguments: file_name if passed will be used, quality is the
        quality of the JPEG(10-100) are valid, the progressive
        arguments toggles progressive jpegs."""
        self._check_scene_editor()
        self.scene_editor.save_jpg(file_name, quality, progressive)

    def save_iv(self, file_name):
        """Save to an OpenInventor file."""
        self._check_scene_editor()
        self.scene_editor.save_iv(file_name)

    def save_vrml(self, file_name):
        """Save to a VRML file."""
        self._check_scene_editor()
        self.scene_editor.save_vrml(file_name)

    def save_oogl(self, file_name):
        """Saves the scene to a Geomview OOGL file. Requires VTK 4 to
        work."""
        self._check_scene_editor()
        self.scene_editor.save_oogl(file_name)

    def save_rib(self, file_name, bg=0, resolution=None, resfactor=1.0):
        """Save scene to a RenderMan RIB file.

        Keyword Arguments:

        file_name -- File name to save to.

        bg -- Optional background option.  If 0 then no background is
        saved.  If non-None then a background is saved.  If left alone
        (defaults to None) it will result in a pop-up window asking
        for yes/no.

        resolution -- Specify the resolution of the generated image in
        the form of a tuple (nx, ny).

        resfactor -- The resolution factor which scales the resolution.
        """
        self._check_scene_editor()
        self.scene_editor.save_rib(file_name, bg, resolution, resfactor)

    def save_wavefront(self, file_name):
        """Save scene to a Wavefront OBJ file.  Two files are
        generated.  One with a .obj extension and another with a .mtl
        extension which contains the material proerties.

        Keyword Arguments:

        file_name -- File name to save to
        """
        self._check_scene_editor()
        self.scene_editor.save_wavefront(file_name)

    def save_gl2ps(self, file_name, exp=None):
        """Save scene to a vector PostScript/EPS/PDF/TeX file using
        GL2PS.  If you choose to use a TeX file then note that only
        the text output is saved to the file.  You will need to save
        the graphics separately.

        Keyword Arguments:

        file_name -- File name to save to.

        exp -- Optionally configured vtkGL2PSExporter object.
        Defaults to None and this will use the default settings with
        the output file type chosen based on the extention of the file
        name.
        """
        self._check_scene_editor()
        self.scene_editor.save_gl2ps(file_name, exp)

    def get_size(self):
        """Return size of the render window."""
        self._check_scene_editor()
        return self.scene_editor.get_size()

    def set_size(self, size):
        """Set the size of the window."""
        self._check_scene_editor()
        self.scene_editor.set_size(size)

    def _update_view(self, x, y, z, vx, vy, vz):
        """Used internally to set the view."""
        if self.scene_editor is not None:
            self.scene_editor._update_view(x, y, z, vx, vy, vz)

    def _check_scene_editor(self):
        if self.scene_editor is None:
            msg = """
            This method requires that there be an active scene editor.
            To do this, you will typically need to invoke::
              object.edit_traits()
            where object is the object that contains the SceneModel.
            """
            raise SceneModelError(msg)

    def _scene_editor_changed(self, old, new):
        if new is None:
            self._renderer = None
            self._renwin = None
            self._interactor = None
        else:
            self._renderer = new._renderer
            self._renwin = new._renwin
            self._interactor = new._interactor

    def _get_picker(self):
        """Getter for the picker."""
        se = self.scene_editor
        if se is not None and hasattr(se, 'picker'):
            return se.picker
        return None

    def _get_light_manager(self):
        """Getter for the light manager."""
        se = self.scene_editor
        if se is not None:
            return se.light_manager
        return None

    ######################################################################
    # SceneModel API.
    ######################################################################
    def _get_scene(self):
        """Getter for the scene property."""
        return self


########NEW FILE########
__FILENAME__ = toolkit
#------------------------------------------------------------------------------
# Copyright (c) 2007, Riverbank Computing Limited
# All rights reserved.
#
# This software is provided without warranty under the terms of the BSD
# license included in enthought/LICENSE.txt and may be redistributed only
# under the conditions described in the aforementioned license.  The license
# is also available online at http://www.enthought.com/licenses/BSD.txt
#
#------------------------------------------------------------------------------

# Standard library imports.
import sys

# Enthought library imports.
from traits.etsconfig.api import ETSConfig

# This is set to the toolkit selection.
_toolkit = None

def _init_toolkit():
    """ Initialise the current toolkit. """

    def import_toolkit(tk):
        try:
            # Try and import the toolkit's pyface backend init module.
            __import__('tvtk.pyface.ui.%s.init' % tk)
        except:
            raise

    if ETSConfig.toolkit:
        # If the toolkit has been explicitly specified, just import it and
        # allow failure if an exception is thrown.
        import_toolkit(ETSConfig.toolkit)
        tk = ETSConfig.toolkit
    else:
        # Toolkits to check for if none is explicitly specified.
        known_toolkits = ('wx', 'qt4', 'null')

        for tk in known_toolkits:
            try:
                import_toolkit(tk)

                # In case we have just decided on a toolkit, tell everybody else.
                ETSConfig.toolkit = tk
                break
            except ImportError:
                pass
        else:
            # Try to import the null toolkit but don't set the ETSConfig toolkit
            try:
                tk = 'null'
                import_toolkit(tk)

                import warnings
                warnings.warn("Unable to import the %s backend for pyface;"\
                              " using the 'null' toolkit instead." % ", ".join(toolkits))
            except:
                raise ImportError("unable to import a pyface backend for any of the %s toolkits" \
                                  % ", ".join(known_toolkits))

    # Save the imported toolkit name.
    global _toolkit
    _toolkit = tk

# Do this once then disappear.
_init_toolkit()
del _init_toolkit


def toolkit_object(name):
    """ Return the toolkit specific object with the given name.  The name
    consists of the relative module path and the object name separated by a
    colon.
    """

    mname, oname = name.split(':')
    be = 'tvtk.pyface.ui.%s.' % _toolkit
    be_mname = be + mname

    class Unimplemented(object):
        """ This is returned if an object isn't implemented by the selected
        toolkit.  It raises an exception if it is ever instantiated.
        """

        def __init__(self, *args, **kwargs):
            raise NotImplementedError("the %s pyface backend doesn't implement %s" % (be, oname))

    be_obj = Unimplemented

    try:
        __import__(be_mname)

        try:
            be_obj = getattr(sys.modules[be_mname], oname)
        except AttributeError:
            pass
    except ImportError:
        pass

    return be_obj

########NEW FILE########
__FILENAME__ = tvtk_scene
"""A TVTK interactor scene widget.  This class only uses TVTK and
Traits.  It does not even use any Pyface widgets.  This is nice when
you want to create a raw TVTK window but with some nice funcationality
that is similar to the widgets.  It is also the base class for the
toolkit specific classes since it implements the core
functionality. See the class docs for more details.

"""
# Author: Prabhu Ramachandran <prabhu@enthought.com>
# Copyright (c) 2007-2013, Enthought, Inc.
# License: BSD Style.


import os.path

from apptools.persistence import state_pickler
from tvtk.api import tvtk
from tvtk import messenger
from tvtk.tvtk_base import vtk_color_trait
from tvtk.common import configure_input

from traits.api import HasPrivateTraits, HasTraits, Any, Int, \
     Property, Instance, Event, Range, Bool, Trait, Str

from tvtk.pyface import light_manager

VTK_VER = tvtk.Version().vtk_version



######################################################################
# `TVTKScene` class.
######################################################################
class TVTKScene(HasPrivateTraits):
    """A TVTK interactor scene widget.

    This widget uses a RenderWindowInteractor and therefore supports
    interaction with VTK widgets.  The widget uses TVTK.  The widget
    also supports the following:

    - Save the scene to a bunch of common (and not so common) image
      formats.

    - save the rendered scene to the clipboard.

    - adding/removing lists/tuples of actors

    - setting the view to useful predefined views (just like in
      MayaVi).

    - If one passes `stereo=1` to the constructor, stereo rendering is
      enabled.  By default this is disabled.  Changing the stereo trait
      has no effect during runtime.

    - One can disable rendering by setting `disable_render` to True.

    """

    # The version of this class.  Used for persistence.
    __version__ = 0

    ###########################################################################
    # Traits.
    ###########################################################################

    # Turn on/off stereo rendering.  This is set on initialization and
    # has no effect once the widget is realized.
    stereo = Bool(False)

    # Perform line smoothing for all renderered lines.  This produces
    # much nicer looking lines but renders slower.  This setting works
    # only when called before the first render.
    line_smoothing = Bool(False)

    # Perform point smoothing for all renderered points.  This
    # produces much nicer looking points but renders slower.  This
    # setting works only when called before the first render.
    point_smoothing = Bool(False)

    # Perform polygon smoothing (anti-aliasing) for all rendered
    # polygons.  This produces much nicer looking points but renders
    # slower.  This setting works only when called before the first
    # render.
    polygon_smoothing = Bool(False)

    # Enable parallel projection.  This trait is synchronized with
    # that of the camera.
    parallel_projection = Bool(False, desc='if the camera uses parallel projection')

    # Disable rendering.
    disable_render = Bool(False, desc='if rendering is to be disabled')

    # Enable off-screen rendering.  This allows a user to render the
    # scene to an image without the need to have the window active.
    # For example, the application can be minimized and the saved
    # scene should be generated correctly.  This is handy for batch
    # scripts and the like.  This works under Win32.  Under Mac OS X
    # and Linux it requires a recent VTK version (later than Oct 2005
    # and ideally later than March 2006) to work correctly.
    off_screen_rendering = Bool(False, desc='if off-screen rendering is enabled')

    # The background color of the window.  This is really a shadow
    # trait of the renderer's background.  Delegation does not seem to
    # work nicely for this.
    background = Trait(vtk_color_trait((0.5, 0.5, 0.5)),
                       desc='the background color of the window')

    # The default foreground color of any actors.  This basically
    # saves the preference and actors will listen to changes --
    # the scene itself does not use this.
    foreground = Trait(vtk_color_trait((1.0, 1.0, 1.0)),
                       desc='the default foreground color of actors')

    # The magnification to use when generating images from the render
    # window.
    magnification = Range(1, 2048, 1,
                          desc='the magnification used when the screen is saved to an image')

    # Specifies the number of frames to use for anti-aliasing when
    # saving a scene.  This basically increases
    # `self.render_window.aa_frames` in order to produce anti-aliased
    # figures when a scene is saved to an image.  It then restores the
    # `aa_frames` in order to get interactive rendering rates.
    anti_aliasing_frames = Range(0, 20, 8, desc='number of frames to use for anti-aliasing when saving a scene')

    # Default JPEG quality.
    jpeg_quality = Range(10, 100, 95, desc='the quality of the JPEG image to produce')

    # Default JPEG progressive setting.
    jpeg_progressive = Bool(True, desc='if the generated JPEG should be progressive')

    # The light manager.
    light_manager = Instance(light_manager.LightManager, record=True)

    # Is the scene busy or not.
    busy = Property(Bool, record=False)

    ########################################
    # Events

    # Lifecycle events: there are no opening/opened events since the
    # control is actually created in __init__.

    # The control is going to be closed.
    closing = Event(record=False)

    # The control has been closed.
    closed = Event(record=False)

    # Event fired when an actor is added to the scene.
    actor_added = Event(record=False)
    # Event fired when any actor is removed from the scene.
    actor_removed = Event(record=False)

    ########################################
    # Properties.

    # The interactor used by the scene.
    interactor = Property(Instance(tvtk.GenericRenderWindowInteractor))

    # The render_window.
    render_window = Property(Instance(tvtk.RenderWindow))

    # The renderer.
    renderer = Property(Instance(tvtk.Renderer))

    # The camera.
    camera = Property(Instance(tvtk.Camera))

    # The control to mimic the Widget behavior.
    control = Any

    ########################################
    # Private traits.

    # A recorder for script recording.
    recorder = Instance(HasTraits, record=False, transient=True)
    # Cached last camera state.
    _last_camera_state = Any(transient=True)
    _camera_observer_id = Int(transient=True)
    _script_id = Str(transient=True)

    # The renderer instance.
    _renderer = Instance(tvtk.Renderer)
    _renwin = Instance(tvtk.RenderWindow)
    _interactor = Instance(tvtk.RenderWindowInteractor)
    _camera = Instance(tvtk.Camera)
    _busy_count = Int(0)

    ###########################################################################
    # 'object' interface.
    ###########################################################################
    def __init__(self, parent=None, **traits):
        """ Initializes the object. """

        # Base class constructor.
        super(TVTKScene, self).__init__(**traits)

        # Used to set the view of the scene.
        self._def_pos = 1

        self.control = self._create_control(parent)
        self._renwin.update_traits()

    def __get_pure_state__(self):
        """Allows us to pickle the scene."""
        # The control attribute is not picklable since it is a VTK
        # object so we remove it.
        d = self.__dict__.copy()
        for x in ['control', '_renwin', '_interactor', '_camera',
                  '_busy_count', '__sync_trait__', 'recorder',
                  '_last_camera_state', '_camera_observer_id',
                  '_script_id', '__traits_listener__']:
            d.pop(x, None)
        # Additionally pickle these.
        d['camera'] = self.camera
        return d

    def __getstate__(self):
        return state_pickler.dumps(self)

    def __setstate__(self, str_state):
        # This method is unnecessary since this object will almost
        # never be pickled by itself and only via an object that
        # contains it, therefore __init__ will be called when the
        # scene is constructed.  However, setstate is defined just for
        # completeness.
        state_pickler.set_state(self, state_pickler.loads_state(str_state))

    ###########################################################################
    # 'Scene' interface.
    ###########################################################################
    def render(self):
        """ Force the scene to be rendered. Nothing is done if the
        `disable_render` trait is set to True."""
        if not self.disable_render:
            self._renwin.render()

    def add_actors(self, actors):
        """ Adds a single actor or a tuple or list of actors to the
        renderer."""
        # Reset the zoom if this is the first actor.
        reset_zoom = (len(self._renderer.actors) == 0 and len(self._renderer.volumes)==0)
        if hasattr(actors, '__iter__'):
            for actor in actors:
                self._renderer.add_actor(actor)
        else:
            self._renderer.add_actor(actors)
        self.actor_added = actors

        if reset_zoom:
            self.reset_zoom()
        else:
            self.render()

    def remove_actors(self, actors):
        """ Removes a single actor or a tuple or list of actors from
        the renderer."""
        if hasattr(actors, '__iter__'):
            for actor in actors:
                self._renderer.remove_actor(actor)
        else:
            self._renderer.remove_actor(actors)
        self.actor_removed = actors
        self.render()

    # Conevenience methods.
    add_actor = add_actors
    remove_actor = remove_actors

    def add_widgets(self, widgets, enabled=True):
        """Adds a single 3D widget or a sequence of widgets to the renderer.
        If `enabled` is True the widget is also enabled once it is added."""
        if not hasattr(widgets, '__iter__'):
            widgets = [widgets]
        iren = self._interactor
        for widget in widgets:
            widget.interactor = iren
            widget.enabled = enabled
        self.render()

    def remove_widgets(self, widgets):
        """Removes a single 3D widget or a sequence of widgets from the
        renderer."""
        if not hasattr(widgets, '__iter__'):
            widgets = [widgets]
        iren = self._interactor
        for widget in widgets:
            if widget.interactor is not None:
                widget.enabled = False
                widget.interactor = None
        self.render()

    def close(self):
        """Close the scene cleanly.  This ensures that the scene is
        shutdown cleanly.  This should be called if you are getting
        async errors when closing a scene from a UI.  This is based on
        the observations of Charl Botha here:

          http://public.kitware.com/pipermail/vtkusers/2008-May/095291.html

        """
        # Return if we are already closed.
        if self._renwin is None:
            return

        # Fire the "closing" event.
        self.closing = True
        # Disable any renders through traits listner callbacks.
        self.disable_render = True
        # Remove sync trait listeners.
        self.sync_trait('background', self._renderer, remove=True)
        self.sync_trait('parallel_projection', self.camera, remove=True)
        self.sync_trait('off_screen_rendering', self._renwin, remove=True)

        # Remove all the renderer's props.
        self._renderer.remove_all_view_props()
        # Set the renderwindow to release all resources and the OpenGL
        # context.
        self._renwin.finalize()
        # Disconnect the interactor from the renderwindow.
        self._interactor.render_window = None
        # Remove the reference to the render window.
        del self._renwin
        # Fire the "closed" event.
        self.closed = True

    def x_plus_view(self):
        """View scene down the +X axis. """
        self._update_view(self._def_pos, 0, 0, 0, 0, 1)
        self._record_methods('x_plus_view()')

    def x_minus_view(self):
        """View scene down the -X axis. """
        self._update_view(-self._def_pos, 0, 0, 0, 0, 1)
        self._record_methods('x_minus_view()')

    def z_plus_view(self):
        """View scene down the +Z axis. """
        self._update_view(0, 0, self._def_pos, 0, 1, 0)
        self._record_methods('z_plus_view()')

    def z_minus_view(self):
        """View scene down the -Z axis. """
        self._update_view(0, 0, -self._def_pos, 0, 1, 0)
        self._record_methods('z_minus_view()')

    def y_plus_view(self):
        """View scene down the +Y axis. """
        self._update_view(0, self._def_pos, 0, 1, 0, 0)
        self._record_methods('y_plus_view()')

    def y_minus_view(self):
        """View scene down the -Y axis. """
        self._update_view(0, -self._def_pos, 0, 1, 0, 0)
        self._record_methods('y_minus_view()')

    def isometric_view(self):
        """Set the view to an iso-metric view. """
        self._update_view(self._def_pos, self._def_pos, self._def_pos,
                          0, 0, 1)
        self._record_methods('isometric_view()')

    def reset_zoom(self):
        """Reset the camera so everything in the scene fits."""
        self._renderer.reset_camera()
        self.render()
        self._record_methods('reset_zoom()')

    def save(self, file_name, size=None, **kw_args):
        """Saves rendered scene to one of several image formats
        depending on the specified extension of the filename.

        If an additional size (2-tuple) argument is passed the window
        is resized to the specified size in order to produce a
        suitably sized output image.  Please note that when the window
        is resized, the window may be obscured by other widgets and
        the camera zoom is not reset which is likely to produce an
        image that does not reflect what is seen on screen.

        Any extra keyword arguments are passed along to the respective
        image format's save method.
        """
        ext = os.path.splitext(file_name)[1]
        meth_map = {'.ps': 'ps', '.bmp': 'bmp', '.tiff': 'tiff',
                    '.png': 'png', '.jpg': 'jpg', '.jpeg': 'jpg',
                    '.iv': 'iv', '.wrl': 'vrml', '.vrml':'vrml',
                    '.oogl': 'oogl', '.rib': 'rib', '.obj': 'wavefront',
                    '.eps': 'gl2ps', '.pdf':'gl2ps', '.tex': 'gl2ps',
                    '.x3d': 'x3d', '.pov': 'povray'}
        if ext.lower() not in meth_map.keys():
            raise ValueError, \
                  'Unable to find suitable image type for given file extension.'
        meth = getattr(self, 'save_' + meth_map[ext])
        if size is not None:
            orig_size = self.get_size()
            self.set_size(size)
            meth(file_name, **kw_args)
            self.set_size(orig_size)
            self._record_methods('save(%r, %r)'%(file_name, size))
        else:
            meth(file_name, **kw_args)
            self._record_methods('save(%r)'%(file_name))

    def save_ps(self, file_name):
        """Saves the rendered scene to a rasterized PostScript image.
        For vector graphics use the save_gl2ps method."""
        if len(file_name) != 0:
            w2if = tvtk.WindowToImageFilter(read_front_buffer=
                                              not self.off_screen_rendering)
            w2if.magnification = self.magnification
            self._lift()
            w2if.input = self._renwin
            ex = tvtk.PostScriptWriter()
            ex.file_name = file_name
            configure_input(ex, w2if)
            self._exporter_write(ex)

    def save_bmp(self, file_name):
        """Save to a BMP image file."""
        if len(file_name) != 0:
            w2if = tvtk.WindowToImageFilter(read_front_buffer=
                                              not self.off_screen_rendering)
            w2if.magnification = self.magnification
            self._lift()
            w2if.input = self._renwin
            ex = tvtk.BMPWriter()
            ex.file_name = file_name
            configure_input(ex, w2if)
            self._exporter_write(ex)

    def save_tiff(self, file_name):
        """Save to a TIFF image file."""
        if len(file_name) != 0:
            w2if = tvtk.WindowToImageFilter(read_front_buffer=
                                              not self.off_screen_rendering)
            w2if.magnification = self.magnification
            self._lift()
            w2if.input = self._renwin
            ex = tvtk.TIFFWriter()
            ex.file_name = file_name
            configure_input(ex, w2if)
            self._exporter_write(ex)

    def save_png(self, file_name):
        """Save to a PNG image file."""
        if len(file_name) != 0:
            w2if = tvtk.WindowToImageFilter(read_front_buffer=
                                              not self.off_screen_rendering)
            w2if.magnification = self.magnification
            self._lift()
            w2if.input = self._renwin
            ex = tvtk.PNGWriter()
            ex.file_name = file_name
            configure_input(ex, w2if)
            self._exporter_write(ex)

    def save_jpg(self, file_name, quality=None, progressive=None):
        """Arguments: file_name if passed will be used, quality is the
        quality of the JPEG(10-100) are valid, the progressive
        arguments toggles progressive jpegs."""
        if len(file_name) != 0:
            if not quality and not progressive:
                quality, progressive = self.jpeg_quality, self.jpeg_progressive
            w2if = tvtk.WindowToImageFilter(read_front_buffer=
                                              not self.off_screen_rendering)
            w2if.magnification = self.magnification
            self._lift()
            w2if.input = self._renwin
            ex = tvtk.JPEGWriter()
            ex.quality = quality
            ex.progressive = progressive
            ex.file_name = file_name
            configure_input(ex, w2if)
            self._exporter_write(ex)

    def save_iv(self, file_name):
        """Save to an OpenInventor file."""
        if len(file_name) != 0:
            ex = tvtk.IVExporter()
            self._lift()
            ex.input = self._renwin
            ex.file_name = file_name
            self._exporter_write(ex)

    def save_vrml(self, file_name):
        """Save to a VRML file."""
        if len(file_name) != 0:
            ex = tvtk.VRMLExporter()
            self._lift()
            ex.input = self._renwin
            ex.file_name = file_name
            self._exporter_write(ex)

    def save_oogl(self, file_name):
        """Saves the scene to a Geomview OOGL file. Requires VTK 4 to
        work."""
        if len(file_name) != 0:
            ex = tvtk.OOGLExporter()
            self._lift()
            ex.input = self._renwin
            ex.file_name = file_name
            self._exporter_write(ex)

    def save_rib(self, file_name, bg=0, resolution=None, resfactor=1.0):
        """Save scene to a RenderMan RIB file.

        Keyword Arguments:

        file_name -- File name to save to.

        bg -- Optional background option.  If 0 then no background is
        saved.  If non-None then a background is saved.  If left alone
        (defaults to None) it will result in a pop-up window asking
        for yes/no.

        resolution -- Specify the resolution of the generated image in
        the form of a tuple (nx, ny).

        resfactor -- The resolution factor which scales the resolution.
        """
        if resolution == None:
            # get present window size
            Nx, Ny = self.render_window.size
        else:
            try:
                Nx, Ny = resolution
            except TypeError:
                raise TypeError, \
                      "Resolution (%s) should be a sequence with two elements"%resolution

        if len(file_name) == 0:
            return

        f_pref = os.path.splitext(file_name)[0]
        ex = tvtk.RIBExporter()
        ex.size = int(resfactor*Nx), int(resfactor*Ny)
        ex.file_prefix = f_pref
        ex.texture_prefix = f_pref + "_tex"
        self._lift()
        ex.render_window = self._renwin
        ex.background = bg

        if VTK_VER[:3] in ['4.2', '4.4']:
            # The vtkRIBExporter is broken in respect to VTK light
            # types.  Therefore we need to convert all lights into
            # scene lights before the save and later convert them
            # back.

            ########################################
            # Internal functions
            def x3to4(x):
                # convert 3-vector to 4-vector (w=1 -> point in space)
                return (x[0], x[1], x[2], 1.0 )
            def x4to3(x):
                # convert 4-vector to 3-vector
                return (x[0], x[1], x[2])

            def cameralight_transform(light, xform, light_type):
                # transform light by 4x4 matrix xform
                origin = x3to4(light.position)
                focus = x3to4(light.focal_point)
                neworigin = xform.multiply_point(origin)
                newfocus = xform.multiply_point(focus)
                light.position = x4to3(neworigin)
                light.focal_point = x4to3(newfocus)
                light.light_type = light_type
            ########################################

            save_lights_type=[]
            for light in self.light_manager.lights:
                save_lights_type.append(light.source.light_type)

            # Convert lights to scene lights.
            cam = self.camera
            xform = tvtk.Matrix4x4()
            xform.deep_copy(cam.camera_light_transform_matrix)
            for light in self.light_manager.lights:
                cameralight_transform(light.source, xform, "scene_light")

            # Write the RIB file.
            self._exporter_write(ex)

            # Now re-convert lights to camera lights.
            xform.invert()
            for i,light in enumerate(self.light_manager.lights):
                cameralight_transform(light.source, xform, save_lights_type[i])

            # Change the camera position. Otherwise VTK would render
            # one broken frame after the export.
            cam.roll(0.5)
            cam.roll(-0.5)
        else:
            self._exporter_write(ex)

    def save_wavefront(self, file_name):
        """Save scene to a Wavefront OBJ file.  Two files are
        generated.  One with a .obj extension and another with a .mtl
        extension which contains the material proerties.

        Keyword Arguments:

        file_name -- File name to save to
        """
        if len(file_name) != 0:
            ex = tvtk.OBJExporter()
            self._lift()
            ex.input = self._renwin
            f_pref = os.path.splitext(file_name)[0]
            ex.file_prefix = f_pref
            self._exporter_write(ex)

    def save_gl2ps(self, file_name, exp=None):
        """Save scene to a vector PostScript/EPS/PDF/TeX file using
        GL2PS.  If you choose to use a TeX file then note that only
        the text output is saved to the file.  You will need to save
        the graphics separately.

        Keyword Arguments:

        file_name -- File name to save to.

        exp -- Optionally configured vtkGL2PSExporter object.
        Defaults to None and this will use the default settings with
        the output file type chosen based on the extention of the file
        name.
        """

        # Make sure the exporter is available.
        if not hasattr(tvtk, 'GL2PSExporter'):
            msg = "Saving as a vector PS/EPS/PDF/TeX file using GL2PS is "\
                  "either not supported by your version of VTK or "\
                  "you have not configured VTK to work with GL2PS -- read "\
                  "the documentation for the vtkGL2PSExporter class."
            print msg
            return

        if len(file_name) != 0:
            f_prefix, f_ext = os.path.splitext(file_name)
            ex = None
            if exp:
                ex = exp
                if not isinstance(exp, tvtk.GL2PSExporter):
                    msg = "Need a vtkGL2PSExporter you passed a "\
                          "%s"%exp.__class__.__name__
                    raise TypeError, msg
                ex.file_prefix = f_prefix
            else:
                ex = tvtk.GL2PSExporter()
                # defaults
                ex.file_prefix = f_prefix
                if f_ext == ".ps":
                    ex.file_format = 'ps'
                elif f_ext == ".tex":
                    ex.file_format = 'tex'
                elif f_ext == ".pdf":
                    ex.file_format = 'pdf'
                else:
                    ex.file_format = 'eps'
                ex.sort = 'bsp'
                ex.compress = 1
                ex.edit_traits(kind='livemodal')

            self._lift()
            ex.render_window = self._renwin
            if ex.write3d_props_as_raster_image:
                self._exporter_write(ex)
            else:
                ex.write()

    def save_x3d(self, file_name):
        """Save scene to an X3D file (http://www.web3d.org/x3d/).

        Keyword Arguments:

        file_name -- File name to save to.
        """
        # Make sure the exporter is available.
        if not hasattr(tvtk, 'X3DExporter'):
            msg = "Saving as a X3D file does not appear to be  "\
                  "supported by your version of VTK."
            print msg
            return

        if len(file_name) != 0:
            ex = tvtk.X3DExporter()
            ex.input = self._renwin
            ex.file_name = file_name
            ex.update()
            ex.write()

    def save_povray(self, file_name):
        """Save scene to a POVRAY (Persistance of Vision Raytracer),
        file (http://www.povray.org).

        Keyword Arguments:

        file_name -- File name to save to.
        """
        # Make sure the exporter is available.
        if not hasattr(tvtk, 'POVExporter'):
            msg = "Saving as a POVRAY file does not appear to be  "\
                  "supported by your version of VTK."
            print msg
            return

        if len(file_name) != 0:
            ex = tvtk.POVExporter()
            ex.input = self._renwin
            if hasattr(ex, 'file_name'):
                ex.file_name = file_name
            else:
                ex.file_prefix = os.path.splitext(file_name)[0]
            ex.update()
            ex.write()

    def get_size(self):
        """Return size of the render window."""
        return self._interactor.size

    def set_size(self, size):
        """Set the size of the window."""
        self._interactor.size = size
        self._renwin.size = size


    ###########################################################################
    # Properties.
    ###########################################################################
    def _get_interactor(self):
        """Returns the vtkRenderWindowInteractor of the parent class"""
        return self._interactor

    def _get_render_window(self):
        """Returns the scene's render window."""
        return self._renwin

    def _get_renderer(self):
        """Returns the scene's renderer."""
        return self._renderer

    def _get_camera(self):
        """ Returns the active camera. """
        return self._renderer.active_camera

    def _get_busy(self):
        return self._busy_count > 0

    def _set_busy(self, value):
        """The `busy` trait is either `True` or `False`.  However,
        this could be problematic since we could have two methods
        `foo` and `bar that both set `scene.busy = True`.  As soon as
        `bar` is done it sets `busy` back to `False`.  This is wrong
        since the UI is still busy as `foo` is not done yet.  We
        therefore store the number of busy calls and either increment
        it or decrement it and change the state back to `False` only
        when the count is zero.
        """
        bc = self._busy_count
        if value:
            bc += 1
        else:
            bc -= 1
            bc = max(0, bc)

        self._busy_count = bc
        if bc == 1:
            self.trait_property_changed('busy', False, True)
        if bc == 0:
            self.trait_property_changed('busy', True, False)

    ###########################################################################
    # Non-public interface.
    ###########################################################################
    def _create_control(self, parent):
        """ Create the toolkit-specific control that represents the widget. """

        # Create the renderwindow.
        renwin = self._renwin = tvtk.RenderWindow()
        # If we are doing offscreen rendering we set the window size to
        # (1,1) so the window does not appear at all
        if self.off_screen_rendering:
            renwin.size = (1,1)

        renwin.set(point_smoothing=self.point_smoothing,
                   line_smoothing=self.line_smoothing,
                   polygon_smoothing=self.polygon_smoothing)
        # Create a renderer and add it to the renderwindow
        self._renderer = tvtk.Renderer()
        renwin.add_renderer(self._renderer)
        self._interactor = tvtk.RenderWindowInteractor(render_window=renwin)
        # Save a reference to our camera so it is not GC'd -- needed for
        # the sync_traits to work.
        self._camera = self.camera

        # Sync various traits.
        self._renderer.background = self.background
        self.sync_trait('background', self._renderer)
        self._renderer.on_trait_change(self.render, 'background')
        self._camera.parallel_projection = self.parallel_projection
        self.sync_trait('parallel_projection', self._camera)
        renwin.off_screen_rendering = self.off_screen_rendering
        self.sync_trait('off_screen_rendering', self._renwin)
        self.render_window.on_trait_change(self.render, 'off_screen_rendering')
        self.render_window.on_trait_change(self.render, 'stereo_render')
        self.render_window.on_trait_change(self.render, 'stereo_type')
        self.camera.on_trait_change(self.render, 'parallel_projection')

        self._interactor.initialize()
        self._interactor.render()
        self.light_manager = light_manager.LightManager(self)

        if self.off_screen_rendering:
            # We want the default size to be the normal (300, 300).
            # Setting the size now should not resize the window if
            # offscreen is working properly in VTK.
            renwin.size = (300, 300)

        return self._interactor

    def _lift(self):
        """Lift the window to the top. Useful when saving screen to an
        image."""
        return

    def _exporter_write(self, ex):
        """Abstracts the exporter's write method."""
        # Bumps up the anti-aliasing frames when the image is saved so
        # that the saved picture looks nicer.
        rw = self.render_window
        aa_frames = rw.aa_frames
        rw.aa_frames = self.anti_aliasing_frames
        rw.render()
        ex.update()
        ex.write()
        # Set the frames back to original setting.
        rw.aa_frames = aa_frames
        rw.render()

    def _update_view(self, x, y, z, vx, vy, vz):
        """Used internally to set the view."""
        camera = self.camera
        camera.focal_point = 0.0, 0.0, 0.0
        camera.position = x, y, z
        camera.view_up = vx, vy, vz
        self._renderer.reset_camera()
        self.render()

    def _disable_render_changed(self, val):
        if not val and self._renwin is not None:
            self.render()

    def _record_methods(self, calls):
        """A method to record a simple method called on self.  We need a
        more powerful and less intrusive way like decorators to do this.
        Note that calls can be a string with new lines in which case we
        interpret this as multiple calls.
        """
        r = self.recorder
        if r is not None:
            sid = self._script_id
            for call in calls.split('\n'):
                r.record('%s.%s'%(sid, call))

    def _record_camera_position(self, vtk_obj=None, event=None):
        """Callback to record the camera position."""
        r = self.recorder
        if r is not None:
            state = self._get_camera_state()
            lcs = self._last_camera_state
            if state != lcs:
                self._last_camera_state = state
                sid = self._script_id
                for key, value in state:
                    r.record('%s.camera.%s = %r'%(sid, key, value))
                r.record('%s.camera.compute_view_plane_normal()'%sid)
                r.record('%s.render()'%sid)

    def _get_camera_state(self):
        c = self.camera
        state = []
        state.append(('position', list(c.position)))
        state.append(('focal_point', list(c.focal_point)))
        state.append(('view_angle', c.view_angle))
        state.append(('view_up', list(c.view_up)))
        state.append(('clipping_range', list(c.clipping_range)))
        return state

    def _recorder_changed(self, r):
        """When the recorder is set we add an event handler so we can
        record the change to the camera position after the interaction.
        """
        iren = self._interactor
        if r is not None:
            self._script_id = r.get_script_id(self)
            id = iren.add_observer('EndInteractionEvent',
                                   messenger.send)
            self._camera_observer_id = id
            i_vtk = tvtk.to_vtk(iren)
            messenger.connect(i_vtk, 'EndInteractionEvent',
                              self._record_camera_position)
        else:
            self._script_id = ''
            iren.remove_observer(self._camera_observer_id)
            i_vtk = tvtk.to_vtk(iren)
            messenger.disconnect(i_vtk, 'EndInteractionEvent',
                                 self._record_camera_position)

######################################################################
# `TVTKScene` class.
######################################################################
class TVTKWindow(HasTraits):
    """A basic TVTK window class that can be used in the MayaVi engine
    for visualization without envisage/pyface etc.  Technically we
    could just have used the `TVTKScene` class but we want to support
    the closing and activated events since they are used to notify the
    MayaVi engine if the window is closed or activated.  In this case
    we do nothing but honour the interface.
    """

    closing = Event
    activated = Event
    def __init__(self, **traits):
        """All the keyword arguments are passed on to the `TVTKScene`
        instance created."""
        self.scene = TVTKScene(**traits)

########NEW FILE########
__FILENAME__ = init
#------------------------------------------------------------------------------
# Copyright (c) 2007, Riverbank Computing Limited
# All rights reserved.
#
# This software is provided without warranty under the terms of the BSD
# license included in enthought/LICENSE.txt and may be redistributed only
# under the conditions described in the aforementioned license.  The license
# is also available online at http://www.enthought.com/licenses/BSD.txt
#------------------------------------------------------------------------------
""" Initialize this backend.
"""

# There is nothing for us to initialize, but the toolkit switching code depends
# on the existence of this module.

#### EOF ######################################################################

########NEW FILE########
__FILENAME__ = actor_editor
""" A mostly-general Traits UI editor for viewing things in TVTK scenes.
"""

# Authors: Robert Kern <robert.kern [at] gmail.com>
#          Prabhu Ramachandran <prabhu [at] aero.iitb.ac.in>
# Copyright (c) 2007, Enthought, Inc.
# License: BSD Style.

# Major library imports.
import os
from pyface.qt import QtGui

# Enthought library imports.
from traits.api import Any, Bool, Callable, Dict, Str
from traitsui.qt4.editor import Editor
from traitsui.basic_editor_factory import BasicEditorFactory
from decorated_scene import DecoratedScene

#####################################################################
# `_ActorEditor` class
#####################################################################
class _ActorEditor(Editor):
    """ An editor for TVTK scenes.
    """

    # The editor is scrollable, so override the default.
    scrollable = Bool(True)

    # Internal GUI traits.
    _scene = Any()


    #### Public 'Editor' interface #############################################

    def init(self, parent):
        """ Finishes initializing the editor by creating the underlying toolkit
        widget.
        """

        factory = self.factory
        self.control = QtGui.QWidget()
        lay = QtGui.QVBoxLayout(self.control)
        lay.setContentsMargins(0, 0, 0, 0)

        self._create_scene()


    def update_editor(self):
        """ Updates the editor when the object trait changes external to the
        editor.
        """

        # Everything should really be handled elsewhere in trait notifications.
        # Just pass here.
        pass


    def dispose(self):
        """ Disposes of the contents of an editor.
        """

        # Remove notifications.
        self._setup_scene_notifications(remove=True)

        # Remove the current scene.
        if self._scene is not None:
            self._scene.close()
            self._scene = None

        # This will destroy self.control and all of its children, including the
        # scene's control.
        super(_ActorEditor, self).dispose()


    #### Private '_ActorEditor' interface ##################################

    def _create_scene(self):
        """ Create the TVTK scene widget.
        """

        factory = self.factory
        self._scene = factory.scene_class(self.control, **factory.scene_kwds)
        scene = self._scene

        # Disable rendering on the scene until we're finished.
        scene.disable_render = True
        # Add all of the actors in the current actor map.
        for obj, actors in self.value.items():
            self._add_actors_widgets(actors)
        # Set up Traits notifications.
        self._setup_scene_notifications()
        # Re-enable rendering.
        scene.disable_render = False

        self.control.layout().addWidget(scene.control)

        # Force a render.
        scene.render()


    def _setup_scene_notifications(self, remove=False):
        """ Set up or remove all of the Trait notifications that control the
        scene widget.
        """

        self.object.on_trait_change(
            self._set_scene_disable_render,
            name=self.factory.disable_render_name,
            remove=remove,
        )
        self.object.on_trait_event(
            self._scene.render,
            name=self.factory.do_render_name,
            remove=remove,
        )
        self.object.on_trait_change(
            self._actors_changed,
            name=self.name+'_items',
            remove=remove,
        )
        self.object.on_trait_change(
            self._actor_map_changed,
            name=self.name,
            remove=remove,
        )


    def _set_scene_disable_render(self, new):
        """ A callback for Traits notifications.
        """

        self._scene.disable_render = new


    def _actors_changed(self, event):
        """ Handle the event of the actors in the actor map changing.
        """

        scene = self._scene
        # Temporarily turn off rendering. We (re)store the old value of
        # disable_render because it may already be True.
        old_disable_render = scene.disable_render
        scene.disable_render = True
        try:
            for obj, actors in event.removed.items():
                self._remove_actors_widgets(actors)
            for obj, actors in event.added.items():
                self._add_actors_widgets(actors)
            for obj, actors in event.changed.items():
                # The actors in the event are the old ones. Grab the new ones
                # from the actor map itself.
                self._remove_actors_widgets(actors)
                self._add_actors_widgets(self.value[obj])
        finally:
            scene.disable_render = old_disable_render
            scene.render()


    def _actor_map_changed(self, object, name, old, new):
        """ Handle the case when the entire actor map is set to something else.
        """

        scene = self._scene
        # Temporarily turn off rendering. We (re)store the old value of
        # disable_render because it may already be True.
        old_disable_render = scene.disable_render
        scene.disable_render = True
        try:
            for obj, actors in old.items():
                self._remove_actors_widgets(actors)
            for obj, actors in new.items():
                self._add_actors_widgets(actors)
        finally:
            scene.disable_render = old_disable_render
            scene.render()

    def _separate_actors_widgets(self, actors_widgets):
        """Given a sequence (or single) of actors or widgets, this returns a
        list of just the actors and another of just the widgets.
        """
        if not hasattr(actors_widgets, '__getitem__'):
            actors_widgets = [actors_widgets]
        actors = []
        widgets = []
        for actor in actors_widgets:
            if actor.is_a('vtk3DWidget'):
                widgets.append(actor)
            else:
                actors.append(actor)
        return actors, widgets

    def _add_actors_widgets(self, actors_widgets):
        """Add actors and widgets to scene."""
        scene = self._scene
        actors, widgets = self._separate_actors_widgets(actors_widgets)
        scene.add_actors(actors)
        scene.add_widgets(widgets)

    def _remove_actors_widgets(self, actors_widgets):
        """Remove actors and widgets from scene."""
        scene = self._scene
        actors, widgets = self._separate_actors_widgets(actors_widgets)
        scene.remove_actors(actors)
        scene.remove_widgets(widgets)


#####################################################################
# `ActorEditor` class
#####################################################################
class ActorEditor(BasicEditorFactory):
    """ An editor factory for TVTK scenes.
    """

    # The class of the editor object to be constructed.
    klass = _ActorEditor

    # The class or factory function for creating the actual scene object.
    scene_class = Callable(DecoratedScene)

    # Keyword arguments to pass to the scene factory.
    scene_kwds = Dict()

    # The name of the trait used for ITVTKActorModel.disable_render.
    disable_render_name = Str('disable_render')

    # The name of the trait used for ITVTKActorModel.do_render.
    do_render_name = Str('do_render')

#### EOF #######################################################################

########NEW FILE########
__FILENAME__ = decorated_scene
"""A VTK interactor scene which provides a convenient toolbar that
allows the user to set the camera view, turn on the axes indicator
etc.
"""
# Authors: Prabhu Ramachandran <prabhu_r@users.sf.net>,
#          Dave Peterson <dpeterson@enthought.com>
# Copyright (c) 2006, Enthought, Inc.
# License: BSD Style.

# System imports.
from os.path import dirname

import os
from pyface.qt import QtGui

# Enthought library imports.
from pyface.api import ImageResource, FileDialog, OK
from pyface.action.api import ToolBarManager, Group, Action
from tvtk.api import tvtk
from traits.api import Instance, false, Either, List

# Local imports.
from scene import Scene


###########################################################################
# 'DecoratedScene' class
###########################################################################
class DecoratedScene(Scene):
    """A VTK interactor scene which provides a convenient toolbar that
    allows the user to set the camera view, turn on the axes indicator
    etc.
    """
    #######################################################################
    # Traits
    #######################################################################

    if hasattr(tvtk, 'OrientationMarkerWidget'):
        # The tvtk orientation marker widget.  This only exists in VTK
        # 5.x.
        marker = Instance(tvtk.OrientationMarkerWidget, ())

        # The tvtk axes that will be shown for the orientation.
        axes = Instance(tvtk.AxesActor, ())
    else:
        marker = None
        axes = None

    # Determine if the orientation axis is shown or not.
    show_axes = false

    # The list of actions represented in the toolbar
    actions = List(Either(Action, Group))

    ##########################################################################
    # `object` interface
    ##########################################################################
    def __init__(self, parent, **traits):
        super(DecoratedScene, self).__init__(parent, **traits)
        self._setup_axes_marker()

    def __get_pure_state__(self):
        """Allows us to pickle the scene."""
        # The control attribute is not picklable since it is a VTK
        # object so we remove it.
        d = super(DecoratedScene, self).__get_pure_state__()
        for x in ['_content', '_panel', '_tool_bar', 'actions']:
            d.pop(x, None)
        return d

    ##########################################################################
    # Non-public interface.
    ##########################################################################
    def _create_control(self, parent):
        """ Create the toolkit-specific control that represents the widget.

            Overridden to wrap the Scene control within a panel that
            also contains a toolbar.
        """
        # Create a panel as a wrapper of the scene toolkit control.  This
        # allows us to also add additional controls.
        self._panel = QtGui.QMainWindow()

        # Add our toolbar to the panel.
        tbm = self._get_tool_bar_manager()
        self._tool_bar = tbm.create_tool_bar(self._panel)
        self._panel.addToolBar(self._tool_bar)

        # Create the actual scene content
        self._content = super(DecoratedScene, self)._create_control(self._panel)
        self._panel.setCentralWidget(self._content)

        return self._panel

    def _setup_axes_marker(self):
        axes = self.axes
        if axes is None:
            # For VTK versions < 5.0.
            return

        axes.set(
            normalized_tip_length=(0.4, 0.4, 0.4),
            normalized_shaft_length=(0.6, 0.6, 0.6),
            shaft_type='cylinder'
            )

        p = axes.x_axis_caption_actor2d.caption_text_property
        axes.y_axis_caption_actor2d.caption_text_property = p
        axes.z_axis_caption_actor2d.caption_text_property = p
        p.set(color=(1,1,1), shadow=False, italic=False)
        self._background_changed(self.background)

        self.marker.set(key_press_activation=False)
        self.marker.orientation_marker = axes

    def _get_tool_bar_manager(self):
        """ Returns the tool_bar_manager for this scene.
        """
        tbm = ToolBarManager( *self.actions )
        return tbm


    def _get_image_path(self):
        """Returns the directory which contains the images used by the
        toolbar."""

        # So that we can find the images.
        import tvtk.pyface.api

        return dirname(tvtk.pyface.api.__file__)

    def _toggle_projection(self):
        """ Toggle between perspective and parallel projection, this
        is used for the toolbar.
        """
        if self._panel is not None:
            self.parallel_projection = not self.parallel_projection

    def _toggle_axes(self, *args):
        """Used by the toolbar to turn on/off the axes indicator.
        """
        if self._panel is not None:
            self.show_axes = not self.show_axes

    def _save_snapshot(self):
        """Invoked by the toolbar menu to save a snapshot of the scene
        to an image.  Note that the extension of the filename
        determines what image type is saved.  The default is PNG.
        """
        if self._panel is not None:
            wildcard = "PNG images (*.png)|*.png|Determine by extension (*.*)|*.*"
            dialog = FileDialog(
                parent = self._panel,
                title = 'Save scene to image',
                action = 'save as',
                default_filename = "snapshot.png",
                wildcard = wildcard
            )
            if dialog.open() == OK:
                # The extension of the path will determine the actual
                # image type saved.
                self.save(dialog.path)

    def _configure_scene(self):
        """Invoked when the toolbar icon for configuration is clicked.
        """
        self.edit_traits()

    ######################################################################
    # Trait handlers.
    ######################################################################
    def _show_axes_changed(self):
        marker = self.marker
        if (self._vtk_control is not None) and (marker is not None):
            if not self.show_axes:
                marker.interactor = None
                marker.enabled = False
            else:
                marker.interactor = self.interactor
                marker.enabled = True
            self.render()

    def _background_changed(self, value):
        # Depending on the background, this sets the axes text and
        # outline color to something that should be visible.
        axes = self.axes
        if (self._vtk_control is not None) and (axes is not None):
            p = self.axes.x_axis_caption_actor2d.caption_text_property
            m = self.marker
            s = value[0] + value[1] + value[2]
            if s <= 1.0:
                p.color = (1,1,1)
                m.set_outline_color(1,1,1)
            else:
                p.color = (0,0,0)
                m.set_outline_color(0,0,0)
            self.render()

    def _actions_default(self):
        return [
            Group(
                Action(
                    image = ImageResource('16x16/x-axis',
                        search_path = [self._get_image_path()],
                        ),
                    tooltip = "View along the -X axis",
                    on_perform = self.x_minus_view,
                    ),
                Action(
                    image = ImageResource('16x16/x-axis',
                        search_path = [self._get_image_path()],
                        ),
                    tooltip = "View along the +X axis",
                    on_perform = self.x_plus_view,
                    ),
                Action(
                    image = ImageResource('16x16/y-axis',
                        search_path = [self._get_image_path()],
                        ),
                    tooltip = "View along the -Y axis",
                    on_perform = self.y_minus_view,
                    ),
                Action(
                    image = ImageResource('16x16/y-axis',
                        search_path = [self._get_image_path()],
                        ),
                    tooltip = "View along the +Y axis",
                    on_perform = self.y_plus_view,
                    ),
                Action(
                    image = ImageResource('16x16/z-axis',
                        search_path = [self._get_image_path()],
                        ),
                    tooltip = "View along the -Z axis",
                    on_perform = self.z_minus_view,
                    ),
                Action(
                    image = ImageResource('16x16/z-axis',
                        search_path = [self._get_image_path()],
                        ),
                    tooltip = "View along the +Z axis",
                    on_perform = self.z_plus_view,
                    ),
                Action(
                    image = ImageResource('16x16/isometric',
                        search_path = [self._get_image_path()],
                        ),
                    tooltip = "Obtain an isometric view",
                    on_perform = self.isometric_view,
                    ),
                ),
            Group(
                Action(
                    image = ImageResource('16x16/parallel',
                        search_path = [self._get_image_path()],
                        ),
                    tooltip = 'Toggle parallel projection',
                    style="toggle",
                    on_perform = self._toggle_projection,
                    checked = self.parallel_projection,
                    ),
                Action(
                    image = ImageResource('16x16/origin_glyph',
                        search_path = [self._get_image_path()],
                        ),
                    tooltip = 'Toggle axes indicator',
                    style="toggle",
                    enabled=(self.marker is not None),
                    on_perform = self._toggle_axes,
                    checked = self.show_axes,
                    ),
                Action(
                    image = ImageResource('16x16/fullscreen',
                        search_path = [self._get_image_path()],
                        ),
                    tooltip = 'Full Screen (press "q" or "e" or Esc to exit fullscreen)',
                    style="push",
                    on_perform = self._full_screen_fired,
                    ),
                ),
            Group(
                Action(
                    image = ImageResource('16x16/save',
                        search_path = [self._get_image_path()],
                        ),
                    tooltip = "Save a snapshot of this scene",
                    on_perform = self._save_snapshot,
                    ),
                Action(
                    image = ImageResource('16x16/configure',
                        search_path = [self._get_image_path()],
                        ),
                    tooltip = 'Configure the scene',
                    style="push",
                    on_perform = self._configure_scene,
                    ),
                ),
            ]


########NEW FILE########
__FILENAME__ = init
#------------------------------------------------------------------------------
# Copyright (c) 2007, Riverbank Computing Limited
# All rights reserved.
#
# This software is provided without warranty under the terms of the BSD
# license.
#
# Author: Riverbank Computing Limited
# Description: <Enthought pyface package component>
#
# In an e-mail to enthought-dev on 2008.09.12 at 2:49 AM CDT, Phil Thompson said:
# The advantage is that all of the PyQt code in ETS can now be re-licensed to
# use the BSD - and I hereby give my permission for that to be done. It's
# been on my list of things to do.
#------------------------------------------------------------------------------


# Standard library imports.
import sys

# Major package imports.
import os

# PyQt4 version check crash PySide toolkit
from pyface.qt import qt_api
if qt_api == 'pyqt':
    from PyQt4 import QtGui, QtCore

    # Check the version numbers are late enough.
    if QtCore.QT_VERSION < 0x040200:
        raise RuntimeError, "Need Qt v4.2 or higher, but got v%s" % QtCore.QT_VERSION_STR

    if QtCore.PYQT_VERSION < 0x040100:
        raise RuntimeError, "Need PyQt v4.1 or higher, but got v%s" % QtCore.PYQT_VERSION_STR
else:
    from PySide import QtGui, QtCore

# It's possible that it has already been initialised.
_app = QtGui.QApplication.instance()

if _app is None:
    _app = QtGui.QApplication(sys.argv)

#### EOF ######################################################################

########NEW FILE########
__FILENAME__ = QVTKRenderWindowInteractor
"""
A simple VTK widget for PyQt v4, the Qt v4 bindings for Python.
See http://www.trolltech.com for Qt documentation, and
http://www.riverbankcomputing.co.uk for PyQt.

This class is based on the vtkGenericRenderWindowInteractor and is
therefore fairly powerful.  It should also play nicely with the
vtk3DWidget code.

Created by Prabhu Ramachandran, May 2002
Based on David Gobbi's QVTKRenderWidget.py

Changes by Gerard Vermeulen Feb. 2003
 Win32 support.

Changes by Gerard Vermeulen, May 2003
 Bug fixes and better integration with the Qt framework.

Changes by Phil Thompson, Nov. 2006
 Ported to PyQt v4.
 Added support for wheel events.

Changes by Phil Thompson, Oct. 2007
 Bug fixes.

Changes by Phil Thompson, Mar. 2008
 Added cursor support.
"""

import sys

import os
from pyface.qt import qt_api
if qt_api == 'pyqt':
    from PyQt4 import QtGui, QtCore
else:
    from PySide import QtGui, QtCore
    from ctypes import pythonapi, c_void_p, py_object
    pythonapi.PyCObject_AsVoidPtr.restype = c_void_p
    pythonapi.PyCObject_AsVoidPtr.argtypes = [ py_object ]

import vtk

from tvtk import messenger


class QVTKRenderWindowInteractor(QtGui.QWidget):

    """ A QVTKRenderWindowInteractor for Python and Qt.  Uses a
    vtkGenericRenderWindowInteractor to handle the interactions.  Use
    GetRenderWindow() to get the vtkRenderWindow.  Create with the
    keyword stereo=1 in order to generate a stereo-capable window.

    The user interface is summarized in vtkInteractorStyle.h:

    - Keypress j / Keypress t: toggle between joystick (position
      sensitive) and trackball (motion sensitive) styles. In joystick
      style, motion occurs continuously as long as a mouse button is
      pressed. In trackball style, motion occurs when the mouse button
      is pressed and the mouse pointer moves.

    - Keypress c / Keypress o: toggle between camera and object
      (actor) modes. In camera mode, mouse events affect the camera
      position and focal point. In object mode, mouse events affect
      the actor that is under the mouse pointer.

    - Button 1: rotate the camera around its focal point (if camera
      mode) or rotate the actor around its origin (if actor mode). The
      rotation is in the direction defined from the center of the
      renderer's viewport towards the mouse position. In joystick mode,
      the magnitude of the rotation is determined by the distance the
      mouse is from the center of the render window.

    - Button 2: pan the camera (if camera mode) or translate the actor
      (if object mode). In joystick mode, the direction of pan or
      translation is from the center of the viewport towards the mouse
      position. In trackball mode, the direction of motion is the
      direction the mouse moves. (Note: with 2-button mice, pan is
      defined as <Shift>-Button 1.)

    - Button 3: zoom the camera (if camera mode) or scale the actor
      (if object mode). Zoom in/increase scale if the mouse position is
      in the top half of the viewport; zoom out/decrease scale if the
      mouse position is in the bottom half. In joystick mode, the amount
      of zoom is controlled by the distance of the mouse pointer from
      the horizontal centerline of the window.

    - Keypress 3: toggle the render window into and out of stereo
      mode.  By default, red-blue stereo pairs are created. Some systems
      support Crystal Eyes LCD stereo glasses; you have to invoke
      SetStereoTypeToCrystalEyes() on the rendering window.  Note: to
      use stereo you also need to pass a stereo=1 keyword argument to
      the constructor.

    - Keypress e: exit the application.

    - Keypress f: fly to the picked point

    - Keypress p: perform a pick operation. The render window interactor
      has an internal instance of vtkCellPicker that it uses to pick.

    - Keypress r: reset the camera view along the current view
      direction. Centers the actors and moves the camera so that all actors
      are visible.

    - Keypress s: modify the representation of all actors so that they
      are surfaces.

    - Keypress u: invoke the user-defined function. Typically, this
      keypress will bring up an interactor that you can type commands in.

    - Keypress w: modify the representation of all actors so that they
      are wireframe.
    """

    # Map between VTK and Qt cursors.
    _CURSOR_MAP = {
        0:  QtCore.Qt.ArrowCursor,          # VTK_CURSOR_DEFAULT
        1:  QtCore.Qt.ArrowCursor,          # VTK_CURSOR_ARROW
        2:  QtCore.Qt.SizeBDiagCursor,      # VTK_CURSOR_SIZENE
        3:  QtCore.Qt.SizeFDiagCursor,      # VTK_CURSOR_SIZENWSE
        4:  QtCore.Qt.SizeBDiagCursor,      # VTK_CURSOR_SIZESW
        5:  QtCore.Qt.SizeFDiagCursor,      # VTK_CURSOR_SIZESE
        6:  QtCore.Qt.SizeVerCursor,        # VTK_CURSOR_SIZENS
        7:  QtCore.Qt.SizeHorCursor,        # VTK_CURSOR_SIZEWE
        8:  QtCore.Qt.SizeAllCursor,        # VTK_CURSOR_SIZEALL
        9:  QtCore.Qt.PointingHandCursor,   # VTK_CURSOR_HAND
        10: QtCore.Qt.CrossCursor,          # VTK_CURSOR_CROSSHAIR
    }

    # Map from Qt key codes to VTK key names
    _KEY_MAP = {
        QtCore.Qt.Key_Escape: "Esc",
        QtCore.Qt.Key_Tab: "Tab",
        QtCore.Qt.Key_Backtab: "Backtab",
        QtCore.Qt.Key_Backspace: "Backspace",
        QtCore.Qt.Key_Return: "Return",
        QtCore.Qt.Key_Enter: "Enter",
        QtCore.Qt.Key_Insert: "Insert",
        QtCore.Qt.Key_Delete: "Delete",
        QtCore.Qt.Key_Pause: "Pause",
        QtCore.Qt.Key_Print: "Print",
        QtCore.Qt.Key_SysReq: "Sysreq",
        QtCore.Qt.Key_Clear: "Clear",
        QtCore.Qt.Key_Home: "Home",
        QtCore.Qt.Key_End: "End",
        QtCore.Qt.Key_Left: "Left",
        QtCore.Qt.Key_Up: "Up",
        QtCore.Qt.Key_Right: "Right",
        QtCore.Qt.Key_Down: "Down",
        QtCore.Qt.Key_PageUp: "Prior",
        QtCore.Qt.Key_PageDown: "Next",
        QtCore.Qt.Key_Meta: "Meta",
        QtCore.Qt.Key_CapsLock: "Caps_Lock",
        QtCore.Qt.Key_NumLock: "Num_Lock",
        QtCore.Qt.Key_ScrollLock: "Scroll_Lock",
        QtCore.Qt.Key_F1: "F1",
        QtCore.Qt.Key_F2: "F2",
        QtCore.Qt.Key_F3: "F3",
        QtCore.Qt.Key_F4: "F4",
        QtCore.Qt.Key_F5: "F5",
        QtCore.Qt.Key_F6: "F6",
        QtCore.Qt.Key_F7: "F7",
        QtCore.Qt.Key_F8: "F8",
        QtCore.Qt.Key_F9: "F9",
        QtCore.Qt.Key_F10: "F10",
        QtCore.Qt.Key_F11: "F11",
        QtCore.Qt.Key_F12: "F12",
    }

    def __init__(self, parent=None, wflags=QtCore.Qt.WindowFlags(), **kw):
        # the current button
        self._ActiveButton = QtCore.Qt.NoButton

        # private attributes
        self.__oldFocus = None
        self.__saveX = 0
        self.__saveY = 0
        self.__saveModifiers = QtCore.Qt.NoModifier
        self.__saveButtons = QtCore.Qt.NoButton

        # do special handling of some keywords:
        # stereo, rw

        stereo = 0

        if kw.has_key('stereo'):
            if kw['stereo']:
                stereo = 1

        rw = None

        if kw.has_key('rw'):
            rw = kw['rw']

        # create qt-level widget
        QtGui.QWidget.__init__(self, parent, wflags|QtCore.Qt.MSWindowsOwnDC)

        if rw: # user-supplied render window
            self._RenderWindow = rw
        else:
            self._RenderWindow = vtk.vtkRenderWindow()

        if qt_api == 'pyqt' or sys.platform != 'win32':
            self._RenderWindow.SetWindowInfo(str(int(self.winId())))
        else:
            # On Windows PySide has a bug with winID() function, so this is fix:
            self._RenderWindow.SetWindowInfo(
                str(int(pythonapi.PyCObject_AsVoidPtr(self.winId()))))
        self._should_set_parent_info = (sys.platform == 'win32')

        if stereo: # stereo mode
            self._RenderWindow.StereoCapableWindowOn()
            self._RenderWindow.SetStereoTypeToCrystalEyes()

        self._Iren = vtk.vtkGenericRenderWindowInteractor()
        self._Iren.SetRenderWindow(self._RenderWindow)

        # do all the necessary qt setup
        self.setAttribute(QtCore.Qt.WA_OpaquePaintEvent)
        self.setAttribute(QtCore.Qt.WA_PaintOnScreen)
        self.setMouseTracking(True) # get all mouse events
        self.setFocusPolicy(QtCore.Qt.WheelFocus)
        self.setSizePolicy(QtGui.QSizePolicy(QtGui.QSizePolicy.Expanding, QtGui.QSizePolicy.Expanding))

        self._Timer = QtCore.QTimer(self)
        self.connect(self._Timer, QtCore.SIGNAL('timeout()'), self.TimerEvent)

        self._Iren.AddObserver('CreateTimerEvent', messenger.send)
        messenger.connect(self._Iren, 'CreateTimerEvent', self.CreateTimer)
        self._Iren.AddObserver('DestroyTimerEvent', messenger.send)
        messenger.connect(self._Iren, 'DestroyTimerEvent', self.DestroyTimer)
        render_window = self._Iren.GetRenderWindow()
        render_window.AddObserver('CursorChangedEvent', messenger.send)
        messenger.connect(render_window, 'CursorChangedEvent', self.CursorChangedEvent)

    def __getattr__(self, attr):
        """Makes the object behave like a vtkGenericRenderWindowInteractor"""
        if attr == '__vtk__':
            return lambda t=self._Iren: t
        elif hasattr(self._Iren, attr):
            return getattr(self._Iren, attr)
        else:
            raise AttributeError, self.__class__.__name__ + \
                  " has no attribute named " + attr

    def CreateTimer(self, obj, evt):
        self._Timer.start(10)

    def DestroyTimer(self, obj, evt):
        self._Timer.stop()
        return 1

    def TimerEvent(self):
        self._Iren.TimerEvent()

    def CursorChangedEvent(self, obj, evt):
        """Called when the CursorChangedEvent fires on the render window."""
        # This indirection is needed since when the event fires, the current
        # cursor is not yet set so we defer this by which time the current
        # cursor should have been set.
        QtCore.QTimer.singleShot(0, self.ShowCursor)

    def HideCursor(self):
        """Hides the cursor."""
        self.setCursor(QtCore.Qt.BlankCursor)

    def ShowCursor(self):
        """Shows the cursor."""
        vtk_cursor = self._Iren.GetRenderWindow().GetCurrentCursor()
        qt_cursor = self._CURSOR_MAP.get(vtk_cursor, QtCore.Qt.ArrowCursor)
        self.setCursor(qt_cursor)

    def sizeHint(self):
        return QtCore.QSize(400, 400)

    def paintEngine(self):
        return None

    def paintEvent(self, ev):
        self._RenderWindow.Render()

    def resizeEvent(self, ev):
        if self._should_set_parent_info:
            # Set the window info and parent info on every resize.
            # vtkWin32OpenGLRenderWindow will render using incorrect offsets if
            # the parent info is not given to it because it assumes that it
            # needs to make room for the title bar.
            if qt_api == 'pyqt' or sys.platform != 'win32':
                self._RenderWindow.SetWindowInfo(str(int(self.winId())))
            else:
                # On Windows PySide has a bug with winID() function, so this is fix:
                self._RenderWindow.SetWindowInfo(
                    str(int(pythonapi.PyCObject_AsVoidPtr(self.winId()))))
            parent = self.parent()
            if parent is not None:
                if qt_api == 'pyqt' or sys.platform != 'win32':
                    self._RenderWindow.SetParentInfo(str(int(self.winId())))
                else:
                    # On Windows PySide has a bug with winID() function, so this is fix:
                    self._RenderWindow.SetParentInfo(
                        str(int(pythonapi.PyCObject_AsVoidPtr(self.winId()))))
            else:
                self._RenderWindow.SetParentInfo('')

        w = self.width()
        h = self.height()

        self._RenderWindow.SetSize(w, h)
        self._Iren.SetSize(w, h)

    def _GetCtrlShift(self, ev):
        ctrl = shift = False

        if hasattr(ev, 'modifiers'):
            if ev.modifiers() & QtCore.Qt.ShiftModifier:
                shift = True
            if ev.modifiers() & QtCore.Qt.ControlModifier:
                ctrl = True
        else:
            if self.__saveModifiers & QtCore.Qt.ShiftModifier:
                shift = True
            if self.__saveModifiers & QtCore.Qt.ControlModifier:
                ctrl = True

        return ctrl, shift

    def enterEvent(self, ev):
        if not self.hasFocus():
            self.__oldFocus = self.focusWidget()
            self.setFocus()

        ctrl, shift = self._GetCtrlShift(ev)
        self._Iren.SetEventInformationFlipY(self.__saveX, self.__saveY,
                                            ctrl, shift, chr(0), 0, None)
        self._Iren.EnterEvent()

    def leaveEvent(self, ev):
        if self.__saveButtons == QtCore.Qt.NoButton and self.__oldFocus:
            self.__oldFocus.setFocus()
            self.__oldFocus = None

        ctrl, shift = self._GetCtrlShift(ev)
        self._Iren.SetEventInformationFlipY(self.__saveX, self.__saveY,
                                            ctrl, shift, chr(0), 0, None)
        self._Iren.LeaveEvent()

    def mousePressEvent(self, ev):
        ctrl, shift = self._GetCtrlShift(ev)
        repeat = 0
        if ev.type() == QtCore.QEvent.MouseButtonDblClick:
            repeat = 1
        self._Iren.SetEventInformationFlipY(ev.x(), ev.y(),
                                            ctrl, shift, chr(0), repeat, None)

        self._ActiveButton = ev.button()

        if self._ActiveButton == QtCore.Qt.LeftButton:
            self._Iren.LeftButtonPressEvent()
        elif self._ActiveButton == QtCore.Qt.RightButton:
            self._Iren.RightButtonPressEvent()
        elif self._ActiveButton == QtCore.Qt.MidButton:
            self._Iren.MiddleButtonPressEvent()

    def mouseReleaseEvent(self, ev):
        ctrl, shift = self._GetCtrlShift(ev)
        self._Iren.SetEventInformationFlipY(ev.x(), ev.y(),
                                            ctrl, shift, chr(0), 0, None)

        if self._ActiveButton == QtCore.Qt.LeftButton:
            self._Iren.LeftButtonReleaseEvent()
        elif self._ActiveButton == QtCore.Qt.RightButton:
            self._Iren.RightButtonReleaseEvent()
        elif self._ActiveButton == QtCore.Qt.MidButton:
            self._Iren.MiddleButtonReleaseEvent()

    def mouseMoveEvent(self, ev):
        self.__saveModifiers = ev.modifiers()
        self.__saveButtons = ev.buttons()
        self.__saveX = ev.x()
        self.__saveY = ev.y()

        ctrl, shift = self._GetCtrlShift(ev)
        self._Iren.SetEventInformationFlipY(ev.x(), ev.y(),
                                            ctrl, shift, chr(0), 0, None)
        self._Iren.MouseMoveEvent()

    def keyPressEvent(self, ev):
        ctrl, shift = self._GetCtrlShift(ev)
        key_sym = self._KEY_MAP.get(ev.key(), None)
        if ev.key() < 256:
            if ev.text():
                key = str(ev.text())
            else:
                # Has modifiers, but an ASCII key code.
                key = chr(ev.key())
        else:
            key = chr(0)

        self._Iren.SetEventInformationFlipY(self.__saveX, self.__saveY,
                                            ctrl, shift, key, 0, key_sym)
        self._Iren.KeyPressEvent()
        self._Iren.CharEvent()

    def keyReleaseEvent(self, ev):
        ctrl, shift = self._GetCtrlShift(ev)
        key_sym = self._KEY_MAP.get(ev.key(), None)
        if ev.key() < 256:
            key = chr(ev.key())
        else:
            key = chr(0)

        self._Iren.SetEventInformationFlipY(self.__saveX, self.__saveY,
                                            ctrl, shift, key, 0, key_sym)
        self._Iren.KeyReleaseEvent()

    def wheelEvent(self, ev):
        if ev.delta() >= 0:
            self._Iren.MouseWheelForwardEvent()
        else:
            self._Iren.MouseWheelBackwardEvent()

    def GetRenderWindow(self):
        return self._RenderWindow

    def Render(self):
        self.update()


def QVTKRenderWidgetConeExample():
    """A simple example that uses the QVTKRenderWindowInteractor class."""

    # every QT app needs an app
    app = QtGui.QApplication(['QVTKRenderWindowInteractor'])

    # create the widget
    widget = QVTKRenderWindowInteractor()
    widget.Initialize()
    widget.Start()
    # if you dont want the 'q' key to exit comment this.
    widget.AddObserver("ExitEvent", lambda o, e, a=app: a.quit())

    ren = vtk.vtkRenderer()
    widget.GetRenderWindow().AddRenderer(ren)

    cone = vtk.vtkConeSource()
    cone.SetResolution(8)

    coneMapper = vtk.vtkPolyDataMapper()
    coneMapper.SetInput(cone.GetOutput())

    coneActor = vtk.vtkActor()
    coneActor.SetMapper(coneMapper)

    ren.AddActor(coneActor)

    # show the widget
    widget.show()
    # start event processing
    app.exec_()

if __name__ == "__main__":
    QVTKRenderWidgetConeExample()

########NEW FILE########
__FILENAME__ = scene
#------------------------------------------------------------------------------
# Copyright (c) 2005, Enthought, Inc.
# All rights reserved.
#
# This software is provided without warranty under the terms of the BSD
# license included in enthought/LICENSE.txt and may be redistributed only
# under the conditions described in the aforementioned license.  The license
# is also available online at http://www.enthought.com/licenses/BSD.txt
# Thanks for using Enthought open source!
#
# Author: Enthought, Inc.
# Description: <Enthought pyface package component>
#------------------------------------------------------------------------------

"""A VTK interactor scene widget for the PyFace PyQt backend.  See the class
docs for more details.
"""

# Author: Prabhu Ramachandran <prabhu_r@users.sf.net>
# Copyright (c) 2004-2007, Enthought, Inc.
# License: BSD Style.


import os
import tempfile

from pyface.qt import QtCore, QtGui

from tvtk.api import tvtk
from tvtk import messenger
from traits.api import Instance, Button, Any
from traitsui.api import View, Group, Item, InstanceEditor

from pyface.api import Widget, GUI, FileDialog, OK
from tvtk.pyface import picker
from tvtk.pyface import light_manager
from tvtk.pyface.tvtk_scene import TVTKScene

from QVTKRenderWindowInteractor import QVTKRenderWindowInteractor


######################################################################
# `_VTKRenderWindowInteractor` class.
######################################################################
class _VTKRenderWindowInteractor(QVTKRenderWindowInteractor):
    """ This is a thin wrapper around the standard VTK PyQt interactor.
    """
    def __init__(self, scene, parent, **kwargs):
        QVTKRenderWindowInteractor.__init__(self, parent, **kwargs)

        self._scene = scene
        self._interacting = False

    def resizeEvent(self, e):
        """ Reimplemented to refresh the traits of the render window.
        """
        QVTKRenderWindowInteractor.resizeEvent(self, e)

        self._scene._renwin.update_traits()

    def paintEvent(self, e):
        """ Reimplemented to create the light manager only when needed.  This
        is necessary because it makes sense to create the light manager only
        when the widget is realized.  Only when the widget is realized is the
        VTK render window created and only then are the default lights all
        setup correctly.
        """
        QVTKRenderWindowInteractor.paintEvent(self, e)

        scene = self._scene

        if scene.light_manager is None:
            scene.light_manager = light_manager.LightManager(scene)
            renwin = scene._renwin
            renwin.update_traits()
            vtk_rw = tvtk.to_vtk(renwin)
            renwin.add_observer('StartEvent', messenger.send)
            messenger.connect(vtk_rw, 'StartEvent', self._start_event_callback)
            renwin.add_observer('EndEvent', messenger.send)
            messenger.connect(vtk_rw, 'EndEvent', self._end_event_callback)

    def keyPressEvent(self, e):
        """ This method is overridden to prevent the 's'/'w'/'e'/'q' keys from
        doing the default thing which is generally useless.  It also handles
        the 'p' and 'l' keys so the picker and light manager are called.
        """
        key = e.key()
        modifiers = e.modifiers()

        scene = self._scene
        camera = scene.camera

        if key in [QtCore.Qt.Key_Minus]:
            camera.zoom(0.8)
            scene.render()
            scene._record_methods('camera.zoom(0.8)\nrender()')
            return

        if key in [QtCore.Qt.Key_Equal, QtCore.Qt.Key_Plus]:
            camera.zoom(1.25)
            scene.render()
            scene._record_methods('camera.zoom(1.25)\nrender()')
            return

        if key in [QtCore.Qt.Key_E, QtCore.Qt.Key_Q, QtCore.Qt.Key_Escape]:
            scene._disable_fullscreen()
            return

        if key in [QtCore.Qt.Key_W]:
            return

        if key in [QtCore.Qt.Key_R]:
            scene._record_methods('reset_zoom()')
            return

        if key in [QtCore.Qt.Key_P] and modifiers == QtCore.Qt.NoModifier:
            pos = self.mapFromGlobal(QtGui.QCursor.pos())
            x = pos.x()
            y = self.height() - pos.y()
            scene.picker.pick(x, y)
            return

        if key in [QtCore.Qt.Key_F] and modifiers == QtCore.Qt.NoModifier:
            pos = self.mapFromGlobal(QtGui.QCursor.pos())
            x = pos.x()
            y = self.height() - pos.y()
            data = scene.picker.pick_world(x, y)
            coord = data.coordinate
            if coord is not None:
                camera.focal_point = coord
                scene.render()
                scene._record_methods('camera.focal_point = %r\n'\
                                      'render()'%list(coord))
            return

        if key in [QtCore.Qt.Key_L] and modifiers == QtCore.Qt.NoModifier:
            scene.light_manager.configure()
            return

        if key in [QtCore.Qt.Key_S] and modifiers == QtCore.Qt.NoModifier:
            fname = popup_save(self.parent())
            if len(fname) != 0:
                self.save(fname)
            return

        shift = ((modifiers & QtCore.Qt.ShiftModifier) == QtCore.Qt.ShiftModifier)

        if key == QtCore.Qt.Key_Left:
            if shift:
                camera.yaw(-5)
                scene._record_methods('camera.yaw(-5)')
            else:
                camera.azimuth(5)
                scene._record_methods('camera.azimuth(5)')

            scene.render()
            scene._record_methods('render()')
            return

        if key == QtCore.Qt.Key_Right:
            if shift:
                camera.yaw(5)
                scene._record_methods('camera.yaw(5)')
            else:
                camera.azimuth(-5)
                scene._record_methods('camera.azimuth(-5)')

            scene.render()
            scene._record_methods('render()')
            return

        if key == QtCore.Qt.Key_Up:
            if shift:
                camera.pitch(-5)
                scene._record_methods('camera.pitch(-5)')
            else:
                camera.elevation(-5)
                scene._record_methods('camera.elevation(-5)')

            camera.orthogonalize_view_up()
            scene.render()
            scene._record_methods('camera.orthogonalize_view_up()\nrender()')
            return

        if key == QtCore.Qt.Key_Down:
            if shift:
                camera.pitch(5)
                scene._record_methods('camera.pitch(5)')
            else:
                camera.elevation(5)
                scene._record_methods('camera.elevation(5)')

            camera.orthogonalize_view_up()
            scene.render()
            scene._record_methods('camera.orthogonalize_view_up()\nrender()')
            return

        QVTKRenderWindowInteractor.keyPressEvent(self, e)

    def mousePressEvent(self, ev):
        """Override for mouse presses."""
        self._interacting = True
        QVTKRenderWindowInteractor.mousePressEvent(self, ev)

    def mouseReleaseEvent(self, ev):
        """Override for mouse releases."""
        self._interacting = False
        QVTKRenderWindowInteractor.mouseReleaseEvent(self, ev)

    def _start_event_callback(self, obj, event):
        if self._interacting:
            return
        else:
            self._scene.busy = True

    def _end_event_callback(self, obj, event):
        if self._interacting:
            return
        else:
            self._scene.busy = False


######################################################################
# Utility functions.
######################################################################
def popup_save(parent=None):
    """Popup a dialog asking for an image name to save the scene to.
    This is used mainly to save a scene in full screen mode. Returns a
    filename, returns empty string if action was cancelled. `parent` is
    the parent widget over which the dialog will be popped up.
    """
    extns = ['*.png', '*.jpg', '*.jpeg', '*.tiff', '*.bmp', '*.ps', '*.eps',
             '*.tex', '*.rib', '*.wrl', '*.oogl', '*.pdf', '*.vrml', '*.obj',
             '*.iv']
    wildcard='|'.join(extns)

    dialog = FileDialog(
        parent = parent, title='Save scene to image',
        action='save as', wildcard=wildcard
    )
    if dialog.open() == OK:
        return dialog.path
    else:
        return ''


######################################################################
# `Scene` class.
######################################################################
class Scene(TVTKScene, Widget):
    """A VTK interactor scene widget for pyface and PyQt.

    This widget uses a RenderWindowInteractor and therefore supports
    interaction with VTK widgets.  The widget uses TVTK.  In addition
    to the features that the base TVTKScene provides this widget
    supports:

    - saving the rendered scene to the clipboard.

    - picking data on screen.  Press 'p' or 'P' when the mouse is over
      a point that you need to pick.

    - The widget also uses a light manager to manage the lighting of
      the scene.  Press 'l' or 'L' to activate a GUI configuration
      dialog for the lights.

    - Pressing the left, right, up and down arrow let you rotate the
      camera in those directions.  When shift-arrow is pressed then
      the camera is panned.  Pressing the '+' (or '=')  and '-' keys
      let you zoom in and out.

    - full screen rendering via the full_screen button on the UI.

    """

    # The version of this class.  Used for persistence.
    __version__ = 0

    ###########################################################################
    # Traits.
    ###########################################################################

    # Turn on full-screen rendering.
    full_screen = Button('Full Screen')

    # The picker handles pick events.
    picker = Instance(picker.Picker)

    ########################################

    # Render_window's view.
    _stereo_view = Group(Item(name='stereo_render'),
                         Item(name='stereo_type'),
                         show_border=True,
                         label='Stereo rendering',
                         )

    # The default view of this object.
    default_view = View(Group(
                            Group(Item(name='background'),
                                  Item(name='foreground'),
                                  Item(name='parallel_projection'),
                                  Item(name='disable_render'),
                                  Item(name='off_screen_rendering'),
                                  Item(name='jpeg_quality'),
                                  Item(name='jpeg_progressive'),
                                  Item(name='magnification'),
                                  Item(name='anti_aliasing_frames'),
                                  Item(name='full_screen',
                                       show_label=False),
                                  ),
                            Group(Item(name='render_window',
                                       style='custom',
                                       visible_when='object.stereo',
                                       editor=InstanceEditor(view=View(_stereo_view)),
                                       show_label=False),
                                  ),
                            label='Scene'),
                         Group( Item(name='light_manager',
                                style='custom', show_label=False),
                                label='Lights'),
                         buttons=['OK', 'Cancel']
                        )

    ########################################
    # Private traits.

    _vtk_control = Instance(_VTKRenderWindowInteractor)
    _fullscreen = Any(False)

    ###########################################################################
    # 'object' interface.
    ###########################################################################
    def __init__(self, parent=None, **traits):
        """ Initializes the object. """

        # Base class constructor.
        super(Scene, self).__init__(parent, **traits)

        # Setup the default picker.
        self.picker = picker.Picker(self)

        # The light manager needs creating.
        self.light_manager = None

        self._cursor = QtCore.Qt.ArrowCursor

    def __get_pure_state__(self):
        """Allows us to pickle the scene."""
        # The control attribute is not picklable since it is a VTK
        # object so we remove it.
        d = super(Scene, self).__get_pure_state__()
        for x in ['_vtk_control', '_fullscreen']:
            d.pop(x, None)
        return d

    ###########################################################################
    # 'Scene' interface.
    ###########################################################################
    def render(self):
        """ Force the scene to be rendered. Nothing is done if the
        `disable_render` trait is set to True."""
        if not self.disable_render:
            self._vtk_control.Render()

    def get_size(self):
        """Return size of the render window."""
        sz = self._vtk_control.size()

        return (sz.width(), sz.height())

    def set_size(self, size):
        """Set the size of the window."""
        self._vtk_control.resize(*size)

    def hide_cursor(self):
        """Hide the cursor."""
        self._cursor = self._vtk_control.cursor().shape()
        self._vtk_control.setCursor(QtCore.Qt.BlankCursor)

    def show_cursor(self):
        """Show the cursor."""
        self._vtk_control.setCursor(self._cursor)

    ###########################################################################
    # 'TVTKScene' interface.
    ###########################################################################
    def save_to_clipboard(self):
        """Saves a bitmap of the scene to the clipboard."""
        handler, name = tempfile.mkstemp()
        self.save_bmp(name)
        QtGui.QApplication.clipboard().setImage(QtGui.QImage(name))
        os.close(handler)
        os.unlink(name)

    ###########################################################################
    # Non-public interface.
    ###########################################################################
    def _create_control(self, parent):
        """ Create the toolkit-specific control that represents the widget. """

        # Create the VTK widget.
        self._vtk_control = window = _VTKRenderWindowInteractor(self, parent,
                                                                 stereo=self.stereo)

        # Switch the default interaction style to the trackball one.
        window.GetInteractorStyle().SetCurrentStyleToTrackballCamera()

        # Grab the renderwindow.
        renwin = self._renwin = tvtk.to_tvtk(window.GetRenderWindow())
        renwin.set(point_smoothing=self.point_smoothing,
                   line_smoothing=self.line_smoothing,
                   polygon_smoothing=self.polygon_smoothing)
        # Create a renderer and add it to the renderwindow
        self._renderer = tvtk.Renderer()
        renwin.add_renderer(self._renderer)
        # Save a reference to our camera so it is not GC'd -- needed for
        # the sync_traits to work.
        self._camera = self.camera

        # Sync various traits.
        self._renderer.background = self.background
        self.sync_trait('background', self._renderer)
        self.renderer.on_trait_change(self.render, 'background')
        renwin.off_screen_rendering = self.off_screen_rendering
        self._camera.parallel_projection = self.parallel_projection
        self.sync_trait('parallel_projection', self._camera)
        self.sync_trait('off_screen_rendering', self._renwin)
        self.render_window.on_trait_change(self.render, 'off_screen_rendering')
        self.render_window.on_trait_change(self.render, 'stereo_render')
        self.render_window.on_trait_change(self.render, 'stereo_type')
        self.camera.on_trait_change(self.render, 'parallel_projection')

        self._interactor = tvtk.to_tvtk(window._Iren)

        return window

    def _lift(self):
        """Lift the window to the top. Useful when saving screen to an
        image."""
        if self.render_window.off_screen_rendering:
            # Do nothing if off screen rendering is being used.
            return

        self._vtk_control.window().raise_()
        QtCore.QCoreApplication.processEvents()

    def _full_screen_fired(self):
        fs = self._fullscreen
        if fs:
            self._vtk_control.window().showNormal()
            self._fullscreen = False
        else:
            self._vtk_control.window().showFullScreen()
            self._fullscreen = True
            
    def _disable_fullscreen(self):
        fs = self._fullscreen
        if fs:
            self._vtk_control.window().showNormal()
            self._fullscreen = False
            
    def _busy_changed(self, val):
        GUI.set_busy(val)

########NEW FILE########
__FILENAME__ = scene_editor
"""A `SceneEditor` for the `SceneModel`.

"""

# Authors: Prabhu Ramachandran <prabhu [at] aero.iitb.ac.in>
#          Robert Kern <robert.kern [at] gmail.com>
#
# Copyright (c) 2007, Enthought, Inc.
# License: BSD Style.

import os
from pyface.qt import QtGui

# Enthought library imports.
from traits.api import Any, Bool, Callable
from traitsui.qt4.editor import Editor
from traitsui.basic_editor_factory import BasicEditorFactory
from decorated_scene import DecoratedScene

#####################################################################
# `_SceneEditor` class
#####################################################################
class _SceneEditor(Editor):
    """ An editor for SceneModels.
    """

    # The editor is scrollable, so override the default.
    scrollable = Bool(True)

    # Internal GUI traits.
    _scene = Any()


    #### Public 'Editor' interface #############################################

    def init(self, parent):
        """ Finishes initializing the editor by creating the underlying toolkit
        widget.
        """

        factory = self.factory
        self.control = QtGui.QWidget()
        lay = QtGui.QVBoxLayout(self.control)
        lay.setContentsMargins(0, 0, 0, 0)

        assert self.value.scene_editor is None, \
                "The SceneModel may only have one active editor!"
        self._create_scene()
        self.value.activated = True

    def update_editor(self):
        """ Updates the editor when the object trait changes external to the
        editor.
        """

        # Everything should really be handled elsewhere in trait notifications.
        # Just pass here.
        pass


    def dispose(self):
        """ Disposes of the contents of an editor.
        """

        # Remove notifications.

        self.value.closing = True
        self.value.scene_editor = None
        self._setup_scene_notifications(remove=True)

        # Remove the current scene.
        if self._scene is not None:
            self._scene.close()
            self._scene = None

        # This will destroy self.control and all of its children, including the
        # scene's control.
        super(_SceneEditor, self).dispose()

    #### Private '_SceneEditor' interface ##################################

    def _create_scene(self):
        """ Create the TVTK scene widget.
        """

        factory = self.factory
        self._scene = factory.scene_class(self.control)
        scene = self._scene
        self.value.scene_editor = scene

        # Disable rendering on the scene until we're finished.
        scene.disable_render = True
        # Add all of the actors in the current actor map.
        for obj, actors in self.value.actor_map.items():
            self._add_actors_widgets(actors)
        # Add all of the actors in the current actor map.
        self._add_actors_widgets(self.value.actor_list)
        # Set up Traits notifications.
        self._setup_scene_notifications()
        # Re-enable rendering.
        scene.disable_render = False

        self.control.layout().addWidget(scene.control)

        # Force a render.
        scene.render()

    def _setup_scene_notifications(self, remove=False):
        """ Set up or remove all of the Trait notifications that control the
        scene widget.
        """

        traits_to_sync = ['foreground', 'anti_aliasing_frames',
                          'stereo',  'background', 'off_screen_rendering',
                          'polygon_smoothing', 'jpeg_progressive',
                          'point_smoothing', 'busy', 'disable_render',
                          'magnification', 'jpeg_quality',
                          'parallel_projection', 'line_smoothing']

        model = self.value
        scene = self._scene
        if not remove:
            scene.set(**model.get(traits_to_sync))
        for trait in traits_to_sync:
            scene.sync_trait(trait, model, mutual=True, remove=remove)

        model.on_trait_change(
            scene.render,
            name='do_render',
            remove=remove,
        )
        model.on_trait_change(
            self._actors_changed,
            name='actor_map_items',
            remove=remove,
        )
        model.on_trait_change(
            self._actor_map_changed,
            name='actor_map',
            remove=remove,
        )

        model.on_trait_change(
            self._actor_list_items_changed,
            name='actor_list_items',
            remove=remove,
        )
        model.on_trait_change(
            self._actor_list_changed,
            name='actor_list',
            remove=remove,
        )

    def _actors_changed(self, event):
        """ Handle the event of the actors in the actor map changing.
        """

        scene = self._scene
        # Temporarily turn off rendering. We (re)store the old value of
        # disable_render because it may already be True.
        old_disable_render = scene.disable_render
        scene.disable_render = True
        try:
            for obj, actors in event.removed.items():
                self._remove_actors_widgets(actors)
            for obj, actors in event.added.items():
                self._add_actors_widgets(actors)
            for obj, actors in event.changed.items():
                # The actors in the event are the old ones. Grab the new ones
                # from the actor map itself.
                self._remove_actors_widgets(actors)
                self._add_actors_widgets(self.value.actor_map[obj])
        finally:
            scene.disable_render = old_disable_render
            scene.render()

    def _actor_map_changed(self, object, name, old, new):
        """ Handle the case when the entire actor map is set to something else.
        """

        scene = self._scene
        # Temporarily turn off rendering. We (re)store the old value of
        # disable_render because it may already be True.
        old_disable_render = scene.disable_render
        scene.disable_render = True
        try:
            for obj, actors in old.items():
                self._remove_actors_widgets(actors)
            for obj, actors in new.items():
                self._add_actors_widgets(actors)
        finally:
            scene.disable_render = old_disable_render
            scene.render()

    def _actor_list_items_changed(self, event):
        self._actor_list_changed(self.value, 'actor_list', event.removed,
                                 event.added)

    def _actor_list_changed(self, object, name, old, new):
        """ Handle the event of the actors in the actor map changing.
        """

        scene = self._scene
        # Temporarily turn off rendering. We (re)store the old value of
        # disable_render because it may already be True.
        old_disable_render = scene.disable_render
        scene.disable_render = True
        try:
            self._remove_actors_widgets(old)
            self._add_actors_widgets(new)
        finally:
            scene.disable_render = old_disable_render
            scene.render()

    def _separate_actors_widgets(self, actors_widgets):
        """Given a sequence (or single) of actors or widgets, this returns a
        list of just the actors and another of just the widgets.
        """
        if not hasattr(actors_widgets, '__getitem__'):
            actors_widgets = [actors_widgets]
        actors = []
        widgets = []
        for actor in actors_widgets:
            if actor.is_a('vtk3DWidget') or actor.is_a('vtkInteractorObserver'):
                widgets.append(actor)
            else:
                actors.append(actor)
        return actors, widgets

    def _add_actors_widgets(self, actors_widgets):
        """Add actors and widgets to scene."""
        scene = self._scene
        actors, widgets = self._separate_actors_widgets(actors_widgets)
        scene.add_actors(actors)
        enabled_info = self.value.enabled_info
        for widget in widgets:
            scene.add_widgets(widget, enabled_info.get(widget, True))

    def _remove_actors_widgets(self, actors_widgets):
        """Remove actors and widgets from scene."""
        scene = self._scene
        actors, widgets = self._separate_actors_widgets(actors_widgets)
        scene.remove_actors(actors)
        scene.remove_widgets(widgets)


#####################################################################
# `SceneEditor` class
#####################################################################
class SceneEditor(BasicEditorFactory):
    """ A TraitsUI editor factory for SceneModel instances.
    """

    # The class of the editor object to be constructed.
    klass = _SceneEditor

    # The class or factory function for creating the actual scene object.
    scene_class = Callable(DecoratedScene)

#### EOF #######################################################################

########NEW FILE########
__FILENAME__ = actor_editor
#------------------------------------------------------------------------------
#
#  Copyright (c) 2007, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Authors: Robert Kern <robert.kern [at] gmail.com>
#           Prabhu Ramachandran <prabhu [at] aero.iitb.ac.in>
#
#------------------------------------------------------------------------------

""" A mostly-general Traits UI editor for viewing things in TVTK scenes.
"""

# Major library imports.
import wx

# Enthought library imports.
from traits.api import Any, Bool, Callable, Dict, Str
from traitsui.wx.editor import Editor
from traitsui.basic_editor_factory import BasicEditorFactory
from decorated_scene import DecoratedScene

#####################################################################
# `_ActorEditor` class
#####################################################################
class _ActorEditor(Editor):
    """ An editor for TVTK scenes.
    """

    # The editor is scrollable, so override the default.
    scrollable = Bool(True)

    # Internal GUI traits.
    _sizer = Any()
    _scene = Any()


    #### Public 'Editor' interface #############################################

    def init(self, parent):
        """ Finishes initializing the editor by creating the underlying toolkit
        widget.
        """

        factory = self.factory
        self.control = wx.Panel(parent, -1)
        self._sizer = wx.BoxSizer(wx.VERTICAL)
        self.control.SetSizer(self._sizer)

        self._create_scene()


    def update_editor(self):
        """ Updates the editor when the object trait changes external to the
        editor.
        """

        # Everything should really be handled elsewhere in trait notifications.
        # Just pass here.
        pass


    def dispose(self):
        """ Disposes of the contents of an editor.
        """

        # Remove notifications.
        self._setup_scene_notifications(remove=True)

        # Remove the current scene.
        if self._scene is not None:
            self._scene.close()
            self._scene = None

        self._sizer = None

        # This will destroy self.control and all of its children, including the
        # scene's control.
        super(_ActorEditor, self).dispose()


    #### Private '_ActorEditor' interface ##################################

    def _create_scene(self):
        """ Create the TVTK scene widget.
        """

        factory = self.factory
        self._scene = factory.scene_class(self.control, **factory.scene_kwds)
        scene = self._scene

        # Disable rendering on the scene until we're finished.
        scene.disable_render = True
        # Add all of the actors in the current actor map.
        for obj, actors in self.value.items():
            self._add_actors_widgets(actors)
        # Set up Traits notifications.
        self._setup_scene_notifications()
        # Re-enable rendering.
        scene.disable_render = False

        # Ensure the scene's wx control is sized to fill our view's area.  Note
        # that the sizer doesn't automatically layout its contents upon adding
        # a new child so we have to force it to do a layout.
        self._sizer.Add(scene.control, 1, wx.EXPAND)
        self._sizer.Layout()

        wx.EVT_IDLE(scene.control, None)

        # Force a render.
        scene.render()


    def _setup_scene_notifications(self, remove=False):
        """ Set up or remove all of the Trait notifications that control the
        scene widget.
        """

        self.object.on_trait_change(
            self._set_scene_disable_render,
            name=self.factory.disable_render_name,
            remove=remove,
        )
        self.object.on_trait_event(
            self._scene.render,
            name=self.factory.do_render_name,
            remove=remove,
        )
        self.object.on_trait_change(
            self._actors_changed,
            name=self.name+'_items',
            remove=remove,
        )
        self.object.on_trait_change(
            self._actor_map_changed,
            name=self.name,
            remove=remove,
        )


    def _set_scene_disable_render(self, new):
        """ A callback for Traits notifications.
        """

        self._scene.disable_render = new


    def _actors_changed(self, event):
        """ Handle the event of the actors in the actor map changing.
        """

        scene = self._scene
        # Temporarily turn off rendering. We (re)store the old value of
        # disable_render because it may already be True.
        old_disable_render = scene.disable_render
        scene.disable_render = True
        try:
            for obj, actors in event.removed.items():
                self._remove_actors_widgets(actors)
            for obj, actors in event.added.items():
                self._add_actors_widgets(actors)
            for obj, actors in event.changed.items():
                # The actors in the event are the old ones. Grab the new ones
                # from the actor map itself.
                self._remove_actors_widgets(actors)
                self._add_actors_widgets(self.value[obj])
        finally:
            scene.disable_render = old_disable_render
            scene.render()


    def _actor_map_changed(self, object, name, old, new):
        """ Handle the case when the entire actor map is set to something else.
        """

        scene = self._scene
        # Temporarily turn off rendering. We (re)store the old value of
        # disable_render because it may already be True.
        old_disable_render = scene.disable_render
        scene.disable_render = True
        try:
            for obj, actors in old.items():
                self._remove_actors_widgets(actors)
            for obj, actors in new.items():
                self._add_actors_widgets(actors)
        finally:
            scene.disable_render = old_disable_render
            scene.render()

    def _separate_actors_widgets(self, actors_widgets):
        """Given a sequence (or single) of actors or widgets, this returns a
        list of just the actors and another of just the widgets.
        """
        if not hasattr(actors_widgets, '__getitem__'):
            actors_widgets = [actors_widgets]
        actors = []
        widgets = []
        for actor in actors_widgets:
            if actor.is_a('vtk3DWidget'):
                widgets.append(actor)
            else:
                actors.append(actor)
        return actors, widgets

    def _add_actors_widgets(self, actors_widgets):
        """Add actors and widgets to scene."""
        scene = self._scene
        actors, widgets = self._separate_actors_widgets(actors_widgets)
        scene.add_actors(actors)
        scene.add_widgets(widgets)

    def _remove_actors_widgets(self, actors_widgets):
        """Remove actors and widgets from scene."""
        scene = self._scene
        actors, widgets = self._separate_actors_widgets(actors_widgets)
        scene.remove_actors(actors)
        scene.remove_widgets(widgets)


#####################################################################
# `ActorEditor` class
#####################################################################
class ActorEditor(BasicEditorFactory):
    """ An editor factory for TVTK scenes.
    """

    # The class of the editor object to be constructed.
    klass = _ActorEditor

    # The class or factory function for creating the actual scene object.
    scene_class = Callable(DecoratedScene)

    # Keyword arguments to pass to the scene factory.
    scene_kwds = Dict()

    # The name of the trait used for ITVTKActorModel.disable_render.
    disable_render_name = Str('disable_render')

    # The name of the trait used for ITVTKActorModel.do_render.
    do_render_name = Str('do_render')

#### EOF #######################################################################

########NEW FILE########
__FILENAME__ = decorated_scene
#------------------------------------------------------------------------------
#
#  Copyright (c) 2006, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Authors: Prabhu Ramachandran <prabhu_r@users.sf.net>,
#           Dave Peterson <dpeterson@enthought.com>
#
#------------------------------------------------------------------------------

""" A VTK interactor scene which provides a convenient toolbar that allows the
    user to set the camera view, turn on the axes indicator, etc.
"""

# System imports.
from os.path import dirname
import wx

# Enthought library imports.
from pyface.api import ImageResource, FileDialog, OK
from pyface.action.api import ToolBarManager, Group, Action
from tvtk.api import tvtk
from traits.api import Instance, false, List, Either

# Local imports.
from scene import Scene


###########################################################################
# 'DecoratedScene' class
###########################################################################
class DecoratedScene(Scene):
    """A VTK interactor scene which provides a convenient toolbar that
    allows the user to set the camera view, turn on the axes indicator
    etc.
    """
    #######################################################################
    # Traits
    #######################################################################

    if hasattr(tvtk, 'OrientationMarkerWidget'):
        # The tvtk orientation marker widget.  This only exists in VTK
        # 5.x.
        marker = Instance(tvtk.OrientationMarkerWidget, ())

        # The tvtk axes that will be shown for the orientation.
        axes = Instance(tvtk.AxesActor, ())
    else:
        marker = None
        axes = None

    # Determine if the orientation axis is shown or not.
    show_axes = false

    # The list of actions represented in the toolbar
    actions = List(Either(Action, Group))

    ##########################################################################
    # `object` interface
    ##########################################################################
    def __init__(self, parent, **traits):
        super(DecoratedScene, self).__init__(parent, **traits)
        self._setup_axes_marker()

    def __get_pure_state__(self):
        """Allows us to pickle the scene."""
        # The control attribute is not picklable since it is a VTK
        # object so we remove it.
        d = super(DecoratedScene, self).__get_pure_state__()
        for x in ['_content', '_panel', '_sizer', '_tool_bar', 'actions']:
            d.pop(x, None)
        return d

    ##########################################################################
    # Non-public interface.
    ##########################################################################
    def _create_control(self, parent):
        """ Create the toolkit-specific control that represents the widget.

            Overridden to wrap the Scene control within a panel that
            also contains a toolbar.
        """
        # Create a panel as a wrapper of the scene toolkit control.  This
        # allows us to also add additional controls.
        self._panel = wx.Panel(parent, -1, style=wx.CLIP_CHILDREN)
        self._sizer = wx.BoxSizer(wx.VERTICAL)
        self._panel.SetSizer(self._sizer)

        # Add our toolbar to the panel.
        tbm = self._get_tool_bar_manager()
        self._tool_bar = tbm.create_tool_bar(self._panel)
        self._sizer.Add(self._tool_bar, 0, wx.EXPAND)

        # Create the actual scene content
        self._content = super(DecoratedScene, self)._create_control(
            self._panel)
        self._sizer.Add(self._content, 1, wx.EXPAND)

        # Ensure the child controls are laid-out.
        self._sizer.Layout()

        return self._panel

    def _setup_axes_marker(self):
        axes = self.axes
        if axes is None:
            # For VTK versions < 5.0.
            return

        axes.set(
            normalized_tip_length=(0.4, 0.4, 0.4),
            normalized_shaft_length=(0.6, 0.6, 0.6),
            shaft_type='cylinder'
            )

        p = axes.x_axis_caption_actor2d.caption_text_property
        axes.y_axis_caption_actor2d.caption_text_property = p
        axes.z_axis_caption_actor2d.caption_text_property = p
        p.set(color=(1,1,1), shadow=False, italic=False)
        self._background_changed(self.background)

        self.marker.set(key_press_activation=False)
        self.marker.orientation_marker = axes

    def _get_tool_bar_manager(self):
        """ Returns the tool_bar_manager for this scene.
        """
        tbm = ToolBarManager( *self.actions )
        return tbm

    def _get_image_path(self):
        """Returns the directory which contains the images used by the
        toolbar."""

        # So that we can find the images.
        import tvtk.pyface.api

        return dirname(tvtk.pyface.api.__file__)

    def _toggle_projection(self):
        """ Toggle between perspective and parallel projection, this
        is used for the toolbar.
        """
        if self._panel is not None:
            self.parallel_projection = not self.parallel_projection

    def _toggle_axes(self):
        """Used by the toolbar to turn on/off the axes indicator.
        """
        if self._panel is not None:
            self.show_axes = not self.show_axes

    def _save_snapshot(self):
        """Invoked by the toolbar menu to save a snapshot of the scene
        to an image.  Note that the extension of the filename
        determines what image type is saved.  The default is PNG.
        """
        if self._panel is not None:
            wildcard = "PNG images (*.png)|*.png|Determine by extension (*.*)|*.*"
            dialog = FileDialog(
                parent = self._panel,
                title = 'Save scene to image',
                action = 'save as',
                default_filename = "snapshot.png",
                wildcard = wildcard
            )
            if dialog.open() == OK:
                # The extension of the path will determine the actual
                # image type saved.
                self.save(dialog.path)

    def _configure_scene(self):
        """Invoked when the toolbar icon for configuration is clicked.
        """
        self.edit_traits()

    ######################################################################
    # Trait handlers.
    ######################################################################
    def _show_axes_changed(self):
        marker = self.marker
        if (self._vtk_control is not None) and (marker is not None):
            if not self.show_axes:
                marker.interactor = None
                marker.enabled = False
            else:
                marker.interactor = self.interactor
                marker.enabled = True
            self.render()

    def _background_changed(self, value):
        # Depending on the background, this sets the axes text and
        # outline color to something that should be visible.
        axes = self.axes
        if (self._vtk_control is not None) and (axes is not None):
            p = self.axes.x_axis_caption_actor2d.caption_text_property
            m = self.marker
            s = value[0] + value[1] + value[2]
            if s <= 1.0:
                p.color = (1,1,1)
                m.set_outline_color(1,1,1)
            else:
                p.color = (0,0,0)
                m.set_outline_color(0,0,0)
            self.render()


    def _actions_default(self):
        return [
            Group(
                Action(
                    image = ImageResource('16x16/x-axis',
                        search_path = [self._get_image_path()],
                        ),
                    tooltip = "View along the -X axis",
                    on_perform = self.x_minus_view,
                    ),
                Action(
                    image = ImageResource('16x16/x-axis',
                        search_path = [self._get_image_path()],
                        ),
                    tooltip = "View along the +X axis",
                    on_perform = self.x_plus_view,
                    ),
                Action(
                    image = ImageResource('16x16/y-axis',
                        search_path = [self._get_image_path()],
                        ),
                    tooltip = "View along the -Y axis",
                    on_perform = self.y_minus_view,
                    ),
                Action(
                    image = ImageResource('16x16/y-axis',
                        search_path = [self._get_image_path()],
                        ),
                    tooltip = "View along the +Y axis",
                    on_perform = self.y_plus_view,
                    ),
                Action(
                    image = ImageResource('16x16/z-axis',
                        search_path = [self._get_image_path()],
                        ),
                    tooltip = "View along the -Z axis",
                    on_perform = self.z_minus_view,
                    ),
                Action(
                    image = ImageResource('16x16/z-axis',
                        search_path = [self._get_image_path()],
                        ),
                    tooltip = "View along the +Z axis",
                    on_perform = self.z_plus_view,
                    ),
                Action(
                    image = ImageResource('16x16/isometric',
                        search_path = [self._get_image_path()],
                        ),
                    tooltip = "Obtain an isometric view",
                    on_perform = self.isometric_view,
                    ),
                ),
            Group(
                Action(
                    image = ImageResource('16x16/parallel',
                        search_path = [self._get_image_path()],
                        ),
                    tooltip = 'Toggle parallel projection',
                    style="toggle",
                    on_perform = self._toggle_projection,
                    checked = self.parallel_projection,
                    ),
                Action(
                    image = ImageResource('16x16/origin_glyph',
                        search_path = [self._get_image_path()],
                        ),
                    tooltip = 'Toggle axes indicator',
                    style="toggle",
                    enabled=(self.marker is not None),
                    on_perform = self._toggle_axes,
                    checked = self.show_axes,
                    ),
                Action(
                    image = ImageResource('16x16/fullscreen',
                        search_path = [self._get_image_path()],
                        ),
                    tooltip = 'Full Screen (press "q" or "e" or ESC to exit fullscreen)',
                    style="push",
                    on_perform = self._full_screen_fired,
                    ),
                ),
            Group(
                Action(
                    image = ImageResource('16x16/save',
                        search_path = [self._get_image_path()],
                        ),
                    tooltip = "Save a snapshot of this scene",
                    on_perform = self._save_snapshot,
                    ),
                Action(
                    image = ImageResource('16x16/configure',
                        search_path = [self._get_image_path()],
                        ),
                    tooltip = 'Configure the scene',
                    style="push",
                    on_perform = self._configure_scene,
                    ),
                ),
            ]


########NEW FILE########
__FILENAME__ = init
#------------------------------------------------------------------------------
#
#  Copyright (c) 2007, Riverbank Computing Limited
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#------------------------------------------------------------------------------

# Major package imports.
import wx


# Check the version number is late enough.
if wx.VERSION < (2, 6):
    raise RuntimeError, "Need wx version 2.6 or higher, but got %s" % str(wx.VERSION)

# It's possible that it has already been initialised.
_app = wx.GetApp()

if _app is None:
    _app = wx.PySimpleApp()

    # Before we can load any images we have to initialize wxPython's image
    # handlers.
    wx.InitAllImageHandlers()

#### EOF ######################################################################

########NEW FILE########
__FILENAME__ = scene
#------------------------------------------------------------------------------
# Copyright (c) 2005, Enthought, Inc.
# All rights reserved.
#
# This software is provided without warranty under the terms of the BSD
# license included in enthought/LICENSE.txt and may be redistributed only
# under the conditions described in the aforementioned license.  The license
# is also available online at http://www.enthought.com/licenses/BSD.txt
# Thanks for using Enthought open source!
#
# Author: Enthought, Inc.
# Description: <Enthought pyface package component>
#------------------------------------------------------------------------------
"""A VTK interactor scene widget for the PyFace wxPython backend.  See
the class docs for more details.

"""
# Author: Prabhu Ramachandran <prabhu_r@users.sf.net>
# Copyright (c) 2004-2008, Enthought, Inc.
# License: BSD Style.


import sys
import os
import tempfile
import wx

from tvtk.api import tvtk
from tvtk import messenger
from traits.api import Instance, Button, Any, Bool
from traitsui.api import View, Group, Item, InstanceEditor

from pyface.api import Widget, GUI, FileDialog, OK
from tvtk.pyface import picker
from tvtk.pyface import light_manager
from tvtk.pyface.tvtk_scene import TVTKScene

from wxVTKRenderWindowInteractor import wxVTKRenderWindowInteractor


######################################################################
# Utility functions.
######################################################################
def popup_save(parent=None):
    """Popup a dialog asking for an image name to save the scene to.
    This is used mainly to save a scene in full screen mode. Returns a
    filename, returns empty string if action was cancelled. `parent` is
    the parent widget over which the dialog will be popped up.
    """
    extns = ['*.png', '*.jpg', '*.jpeg', '*.tiff', '*.bmp', '*.ps', '*.eps',
             '*.tex', '*.rib', '*.wrl', '*.oogl', '*.pdf', '*.vrml', '*.obj',
             '*.iv']
    wildcard='|'.join(extns)

    dialog = FileDialog(
        parent = parent, title='Save scene to image',
        action='save as', wildcard=wildcard
    )
    if dialog.open() == OK:
        return dialog.path
    else:
        return ''


######################################################################
# `FullScreen` class.
######################################################################
class FullScreen(object):
    """Creates a full screen interactor widget.  This will use VTK's
    event loop until the user presses 'q'/'e' on the full screen
    window.  This does not yet support interacting with any widgets on
    the renderered scene.

    This class is really meant to be used for VTK versions earlier
    than 5.1 where there was a bug with reparenting a window.

    """
    def __init__(self, scene):
        self.scene = scene
        self.old_rw = scene.render_window
        self.ren = scene.renderer

    def run(self):
        # Remove the renderer from the current render window.
        self.old_rw.remove_renderer(self.ren)

        # Creates renderwindow tha should be used ONLY for
        # visualization in full screen
        full_rw = tvtk.RenderWindow(stereo_capable_window=True,
                                    full_screen=True
                                    )
        # add the current visualization
        full_rw.add_renderer(self.ren)

        # Under OS X there is no support for creating a full screen
        # window so we set the size of the window here.
        if sys.platform  == 'darwin':
            full_rw.size = tuple(wx.GetDisplaySize())

        # provides a simple interactor
        style = tvtk.InteractorStyleTrackballCamera()
        self.iren = tvtk.RenderWindowInteractor(render_window=full_rw,
                                                interactor_style=style)

        # Gets parameters for stereo visualization
        if self.old_rw.stereo_render:
            full_rw.set(stereo_type=self.old_rw.stereo_type, stereo_render=True)

        # Starts the interactor
        self.iren.initialize()
        self.iren.render()
        self.iren.start()

        # Once the full screen window is quit this releases the
        # renderer before it is destroyed, and return it to the main
        # renderwindow.
        full_rw.remove_renderer(self.ren)
        self.old_rw.add_renderer(self.ren)
        self.old_rw.render()
        self.iren.disable()


######################################################################
# `PopupScene` class.
######################################################################
class PopupScene(object):
    """Pops up a Scene instance with an independent `wx.Frame` in
    order to produce either a standalone window or usually a full
    screen view with *complete* interactivity (including widget
    interaction).
    """
    def __init__(self, scene):
        self.orig_parent = None
        self.orig_size = None
        self.orig_pos = None
        self.frame = None
        self.scene = scene
        self.vtk_control = self.scene._vtk_control

    def _setup_frame(self):
        vtk_control = self.vtk_control
        self.orig_parent = vtk_control.GetParent()
        self.orig_size = vtk_control.GetSize()
        self.orig_pos = vtk_control.GetPosition()
        f = self.frame = wx.Frame(None, -1)
        return f

    def reparent_vtk(self, widget):
        """Reparent VTK control to another widget.
        """
        scene = self.scene
        vc = self.vtk_control
        # We want to disable any rendering at this time so we override
        # the original render with a dummy after saving it.
        orig_disable_render = scene.disable_render
        scene.disable_render = True
        orig_render = vc.Render
        vc.Render = lambda : None
        rw = vc.GetRenderWindow()
        if sys.platform != 'darwin' and wx.Platform != '__WXMSW__':
            rw.SetNextWindowInfo(str(widget.GetHandle()))
            rw.WindowRemap()
        vc.Reparent(widget)
        wx.GetApp().Yield(True)
        # Restore the original render.
        vc.Render = orig_render
        vc.Render()
        scene.disable_render = orig_disable_render

    def popup(self, size=None):
        """Create a popup window of scene and set its default size.
        """
        vc = self.vtk_control
        f = self._setup_frame()
        if size is None:
            f.SetSize(vc.GetSize())
        else:
            f.SetSize(size)
        f.Show(True)
        self.reparent_vtk(f)

    def fullscreen(self):
        """Create a popup window of scene.
        """
        f = self._setup_frame()
        f.Show(True)
        self.reparent_vtk(f)
        f.ShowFullScreen(True)

    def close(self):
        """Close the window and reparent the TVTK scene.
        """
        f = self.frame
        if f is None:
            return

        vc = self.vtk_control
        self.reparent_vtk(self.orig_parent)
        vc.SetSize(self.orig_size)
        vc.SetPosition(self.orig_pos)
        f.ShowFullScreen(False)
        f.Show(False)
        f.Close()
        self.frame = None


######################################################################
# `Scene` class.
######################################################################
class Scene(TVTKScene, Widget):
    """A VTK interactor scene widget for pyface and wxPython.

    This widget uses a RenderWindowInteractor and therefore supports
    interaction with VTK widgets.  The widget uses TVTK.  In addition
    to the features that the base TVTKScene provides this widget
    supports:

    - saving the rendered scene to the clipboard.

    - picking data on screen.  Press 'p' or 'P' when the mouse is over
      a point that you need to pick.

    - The widget also uses a light manager to manage the lighting of
      the scene.  Press 'l' or 'L' to activate a GUI configuration
      dialog for the lights.

    - Pressing the left, right, up and down arrow let you rotate the
      camera in those directions.  When shift-arrow is pressed then
      the camera is panned.  Pressing the '+' (or '=')  and '-' keys
      let you zoom in and out.

    - Pressing the 'f' key will set the camera focal point to the
      current point.

    - full screen rendering via the full_screen button on the UI.

    """

    # The version of this class.  Used for persistence.
    __version__ = 0

    ###########################################################################
    # Traits.
    ###########################################################################

    # Turn on full-screen rendering.
    full_screen = Button('Full Screen')

    # The picker handles pick events.
    picker = Instance(picker.Picker)

    ########################################

    # Render_window's view.
    _stereo_view = Group(Item(name='stereo_render'),
                         Item(name='stereo_type'),
                         show_border=True,
                         label='Stereo rendering',
                         )

    # The default view of this object.
    default_view = View(Group(
                            Group(Item(name='background'),
                                  Item(name='foreground'),
                                  Item(name='parallel_projection'),
                                  Item(name='disable_render'),
                                  Item(name='off_screen_rendering'),
                                  Item(name='jpeg_quality'),
                                  Item(name='jpeg_progressive'),
                                  Item(name='magnification'),
                                  Item(name='anti_aliasing_frames'),
                                  Item(name='full_screen',
                                       show_label=False),
                                  ),
                            Group(Item(name='render_window',
                                       style='custom',
                                       visible_when='object.stereo',
                                       editor=InstanceEditor(view=View(_stereo_view)),
                                       show_label=False),
                                  ),
                            label='Scene'),
                         Group( Item(name='light_manager',
                                style='custom', show_label=False),
                                label='Lights'),
                         buttons=['OK', 'Cancel']
                        )

    ########################################
    # Private traits.

    _vtk_control = Instance(wxVTKRenderWindowInteractor)
    _fullscreen = Any
    _interacting = Bool

    ###########################################################################
    # 'object' interface.
    ###########################################################################
    def __init__(self, parent=None, **traits):
        """ Initializes the object. """

        # Base class constructor.
        super(Scene, self).__init__(parent, **traits)

        # Setup the default picker.
        self.picker = picker.Picker(self)


    def __get_pure_state__(self):
        """Allows us to pickle the scene."""
        # The control attribute is not picklable since it is a VTK
        # object so we remove it.
        d = super(Scene, self).__get_pure_state__()
        for x in ['_vtk_control', '_fullscreen', '_interacting']:
            d.pop(x, None)
        return d

    ###########################################################################
    # 'Scene' interface.
    ###########################################################################
    def render(self):
        """ Force the scene to be rendered. Nothing is done if the
        `disable_render` trait is set to True."""
        if not self.disable_render:
            self._vtk_control.Render()

    def get_size(self):
        """Return size of the render window."""
        return self._vtk_control.GetSize()

    def set_size(self, size):
        """Set the size of the window."""
        self._vtk_control.SetSize(size)

    def hide_cursor(self):
        """Hide the cursor."""
        self._vtk_control.HideCursor()

    def show_cursor(self):
        """Show the cursor."""
        self._vtk_control.ShowCursor()

    ###########################################################################
    # 'TVTKScene' interface.
    ###########################################################################
    def save_to_clipboard(self):
        """Saves a bitmap of the scene to the clipboard."""
        handler, name = tempfile.mkstemp()
        self.save_bmp(name)
        bmp = wx.Bitmap(name, wx.BITMAP_TYPE_BMP)
        bmpdo = wx.BitmapDataObject(bmp)
        wx.TheClipboard.Open()
        wx.TheClipboard.SetData(bmpdo)
        wx.TheClipboard.Close()
        os.close(handler)
        os.unlink(name)

    ###########################################################################
    # `wxVTKRenderWindowInteractor` interface.
    ###########################################################################
    def OnKeyDown(self, event):
        """This method is overridden to prevent the 's'/'w'/'e'/'q'
        keys from doing the default thing which is generally useless.
        It also handles the 'p' and 'l' keys so the picker and light
        manager are called.
        """
        keycode = event.GetKeyCode()
        modifiers = event.HasModifiers()
        camera = self.camera
        if keycode < 256:
            key = chr(keycode)
            if key == '-':
                camera.zoom(0.8)
                self.render()
                self._record_methods('camera.zoom(0.8)\nrender()')
                return
            if key in ['=', '+']:
                camera.zoom(1.25)
                self.render()
                self._record_methods('camera.zoom(1.25)\nrender()')
                return
            if key.lower() in ['q', 'e'] or keycode == wx.WXK_ESCAPE:
                self._disable_fullscreen()
            if key.lower() in ['w']:
                event.Skip()
                return
            if key.lower() in ['r']:
                self._record_methods('reset_zoom()')
            # Handle picking.
            if key.lower() in ['p']:
                # In wxPython-2.6, there appears to be a bug in
                # EVT_CHAR so that event.GetX() and event.GetY() are
                # not correct.  Therefore the picker is called on
                # KeyUp.
                event.Skip()
                return
            # Camera focal point.
            if key.lower() in ['f']:
                event.Skip()
                return
            # Light configuration.
            if key.lower() in ['l'] and not modifiers:
                self.light_manager.configure()
                return
            if key.lower() in ['s'] and not modifiers:
                parent = self._vtk_control.GetParent()
                fname = popup_save(parent)
                if len(fname) != 0:
                    self.save(fname)
                return

        shift = event.ShiftDown()
        if keycode == wx.WXK_LEFT:
            if shift:
                camera.yaw(-5)
                self._record_methods('camera.yaw(-5)')
            else:
                camera.azimuth(5)
                self._record_methods('camera.azimuth(5)')
            self.render()
            self._record_methods('render()')
            return
        elif keycode == wx.WXK_RIGHT:
            if shift:
                camera.yaw(5)
                self._record_methods('camera.yaw(5)')
            else:
                camera.azimuth(-5)
                self._record_methods('camera.azimuth(-5)')
            self.render()
            self._record_methods('render()')
            return
        elif keycode == wx.WXK_UP:
            if shift:
                camera.pitch(-5)
                self._record_methods('camera.pitch(-5)')
            else:
                camera.elevation(-5)
                self._record_methods('camera.elevation(-5)')
            camera.orthogonalize_view_up()
            self.render()
            self._record_methods('camera.orthogonalize_view_up()\nrender()')
            return
        elif keycode == wx.WXK_DOWN:
            if shift:
                camera.pitch(5)
                self._record_methods('camera.pitch(5)')
            else:
                camera.elevation(5)
                self._record_methods('camera.elevation(5)')
            camera.orthogonalize_view_up()
            self.render()
            self._record_methods('camera.orthogonalize_view_up()\nrender()')
            return

        self._vtk_control.OnKeyDown(event)

        # Skipping the event is not ideal but necessary because we
        # have no way of knowing of the event was really handled or
        # not and not skipping will break any keyboard accelerators.
        # In practice this does not seem to pose serious problems.
        event.Skip()

    def OnKeyUp(self, event):
        """This method is overridden to prevent the 's'/'w'/'e'/'q'
        keys from doing the default thing which is generally useless.
        It also handles the 'p' and 'l' keys so the picker and light
        manager are called.  The 'f' key sets the camera focus.
        """
        keycode = event.GetKeyCode()
        modifiers = event.HasModifiers()
        if keycode < 256:
            key = chr(keycode)
            if key.lower() in ['s', 'w', 'e', 'q']:
                event.Skip()
                return
            # Set camera focal point.
            if key.lower() in ['f']:
                if not modifiers:
                    if sys.platform == 'darwin':
                        x, y = self._interactor.event_position
                    else:
                        x = event.GetX()
                        y = self._vtk_control.GetSize()[1] - event.GetY()
                    data = self.picker.pick_world(x, y)
                    coord = data.coordinate
                    if coord is not None:
                        self.camera.focal_point = coord
                        self.render()
                        self._record_methods('camera.focal_point = %r\n'\
                                             'render()'%list(coord))
                        return
            # Handle picking.
            if key.lower() in ['p']:
                if not modifiers:
                    if sys.platform == 'darwin':
                        x, y = self._interactor.event_position
                    else:
                        x = event.GetX()
                        y = self._vtk_control.GetSize()[1] - event.GetY()
                    self.picker.pick(x, y)
                    return
                else:
                    # This is here to disable VTK's own pick handler
                    # which can get called when you press Alt/Ctrl +
                    # 'p'.
                    event.Skip()
                    return
            # Light configuration.
            if key.lower() in ['l']:
                event.Skip()
                return

        self._vtk_control.OnKeyUp(event)
        event.Skip()


    def OnPaint(self, event):
        """This method is overridden temporarily in order to create
        the light manager.  This is necessary because it makes sense
        to create the light manager only when the widget is realized.
        Only when the widget is realized is the VTK render window
        created and only then are the default lights all setup
        correctly.  This handler is removed on the first Paint event
        and the default paint handler of the
        wxVTKRenderWindowInteractor is used instead."""

        # Call the original handler (this will Show the widget)
        self._vtk_control.OnPaint(event)
        if len(self.renderer.lights) == 0:
            # The renderer is not ready yet, we do not do anything, and
            # we do not remove this callback, so that it will be called
            # later.
            return
        # Now create the light manager.
        self.light_manager = light_manager.LightManager(self)

        renwin = self._renwin
        renwin.update_traits()

        vtk_rw = tvtk.to_vtk(renwin)
        renwin.add_observer('StartEvent', messenger.send)
        messenger.connect(vtk_rw, 'StartEvent', self._start_event_callback)
        renwin.add_observer('EndEvent', messenger.send)
        messenger.connect(vtk_rw, 'EndEvent', self._end_event_callback)

        # Reset the event handler to the default since our job is done.
        wx.EVT_PAINT(self._vtk_control, None) # Remove the default handler.
        wx.EVT_PAINT(self._vtk_control, self._vtk_control.OnPaint)

    def OnSize(self, event):
        """Overrides the default OnSize in order to refresh the traits
        of the render window."""
        if self._renwin is not None:
            self._vtk_control.OnSize(event)
            self._renwin.update_traits()

    def OnButtonDown(self, event):
        """Overrides the default on button down method.
        """
        self._interacting = True
        self._vtk_control.OnButtonDown(event)

    def OnButtonUp(self, event):
        self._interacting = False
        self._vtk_control.OnButtonUp(event)

    ###########################################################################
    # Non-public interface.
    ###########################################################################
    def _create_control(self, parent):
        """ Create the toolkit-specific control that represents the widget. """

        # Create the VTK widget.
        self._vtk_control = window = wxVTKRenderWindowInteractor(parent, -1,
                                                                 stereo=self.stereo)

        # Override these handlers.
        wx.EVT_CHAR(window, None) # Remove the default handler.
        wx.EVT_CHAR(window, self.OnKeyDown)
        wx.EVT_KEY_UP(window, None) # Remove the default handler.
        wx.EVT_KEY_UP(window, self.OnKeyUp)
        wx.EVT_PAINT(window, None) # Remove the default handler.
        wx.EVT_PAINT(window, self.OnPaint)
        wx.EVT_SIZE(window, None) # Remove the default handler.
        wx.EVT_SIZE(window, self.OnSize)
        # Override the button down and up handlers as well to note the
        # interaction.  This is to toggle the busy status nicely.
        for evt in (wx.EVT_LEFT_DOWN, wx.EVT_RIGHT_DOWN,
                    wx.EVT_MIDDLE_DOWN):
            evt(window, None)
            evt(window, self.OnButtonDown)
        for evt in (wx.EVT_LEFT_UP, wx.EVT_RIGHT_UP,
                    wx.EVT_MIDDLE_UP):
            evt(window, None)
            evt(window, self.OnButtonUp)

        # Enable the widget.
        window.Enable(1)
        # Switch the default interaction style to the trackball one.
        window.GetInteractorStyle().SetCurrentStyleToTrackballCamera()

        # Grab the renderwindow.
        renwin = self._renwin = tvtk.to_tvtk(window.GetRenderWindow())
        renwin.set(point_smoothing=self.point_smoothing,
                   line_smoothing=self.line_smoothing,
                   polygon_smoothing=self.polygon_smoothing)
        # Create a renderer and add it to the renderwindow
        self._renderer = tvtk.Renderer()
        renwin.add_renderer(self._renderer)
        # Save a reference to our camera so it is not GC'd -- needed for
        # the sync_traits to work.
        self._camera = self.camera

        # Sync various traits.
        self._renderer.background = self.background
        self.sync_trait('background', self._renderer)
        self.renderer.on_trait_change(self.render, 'background')
        self._camera.parallel_projection = self.parallel_projection
        self.sync_trait('parallel_projection', self._camera)
        renwin.off_screen_rendering = self.off_screen_rendering
        self.sync_trait('off_screen_rendering', self._renwin)
        self.render_window.on_trait_change(self.render, 'off_screen_rendering')
        self.render_window.on_trait_change(self.render, 'stereo_render')
        self.render_window.on_trait_change(self.render, 'stereo_type')
        self.camera.on_trait_change(self.render, 'parallel_projection')

        def _show_parent_hack(window, parent):
            """A hack to get the VTK scene properly setup for use."""
            # Force the parent to show itself.
            parent.Show(1)
            # on some platforms, this SetSize() is necessary to cause
            # an OnPaint() when the event loop begins; else we get an
            # empty window until we force a redraw.
            window.SetSize(parent.GetSize())
            # This is necessary on slow machines in order to force the
            # wx events to be handled.
            wx.GetApp().Yield(True)
            window.Render()

        if wx.Platform == '__WXMSW__':
            _show_parent_hack(window, parent)
        else:
            if (wx.VERSION[0] == 2) and (wx.VERSION[1] < 5):
                _show_parent_hack(window, parent)
            window.Update()

        # Because of the way the VTK widget is setup, and because we
        # set the size above, the window sizing is usually completely
        # messed up when the application window is shown.  To work
        # around this a dynamic IDLE event handler is added and
        # immediately removed once it executes.  This event handler
        # simply forces a resize to occur.  The _idle_count allows us
        # to execute the idle function a few times (this seems to work
        # better).
        def _do_idle(event, window=window):
            w = wx.GetTopLevelParent(window)
            # Force a resize
            sz = w.GetSize()
            w.SetSize((sz[0]-1, sz[1]-1))
            w.SetSize(sz)
            window._idle_count -= 1
            if window._idle_count < 1:
                wx.EVT_IDLE(window, None)
                del window._idle_count

        window._idle_count = 2
        wx.EVT_IDLE(window, _do_idle)

        self._interactor = tvtk.to_tvtk(window._Iren)
        return window

    def _lift(self):
        """Lift the window to the top. Useful when saving screen to an
        image."""
        if self.render_window.off_screen_rendering:
            # Do nothing if off screen rendering is being used.
            return

        w = self._vtk_control
        while w and not w.IsTopLevel():
            w = w.GetParent()
        if w:
            w.Raise()
            wx.GetApp().Yield(True)
            self.render()

    def _start_event_callback(self, obj, event):
        if self._interacting:
            return
        else:
            self.busy = True

    def _end_event_callback(self, obj, event):
        if self._interacting:
            return
        else:
            self.busy = False

    def _busy_changed(self, val):
        GUI.set_busy(val)

    def _full_screen_fired(self):
        fs = self._fullscreen
        if isinstance(fs, PopupScene):
            fs.close()
            self._fullscreen = None
        elif fs is None:
            ver = tvtk.Version()
            popup = False
            if wx.Platform == '__WXMSW__':
                popup = True
            elif ver.vtk_major_version > 5:
                popup = True
            elif (ver.vtk_major_version == 5) and \
                 ((ver.vtk_minor_version >= 1) or \
                  (ver.vtk_build_version > 2)):
                popup = True
            if popup:
                # There is a bug with earlier versions of VTK that
                # breaks reparenting a window which is why we test for
                # the version above.
                f = PopupScene(self)
                self._fullscreen = f
                f.fullscreen()
            else:
                f = FullScreen(self)
                f.run() # This will block.
                self._fullscreen = None

    def _disable_fullscreen(self):
        fs = self._fullscreen
        if isinstance(fs, PopupScene):
            fs.close()
            self._fullscreen = None

########NEW FILE########
__FILENAME__ = scene_editor
#------------------------------------------------------------------------------
#
#  Copyright (c) 2007, Enthought, Inc.
#  All rights reserved.
#
#  This software is provided without warranty under the terms of the BSD
#  license included in enthought/LICENSE.txt and may be redistributed only
#  under the conditions described in the aforementioned license.  The license
#  is also available online at http://www.enthought.com/licenses/BSD.txt
#
#  Thanks for using Enthought open source!
#
#  Authors: Prabhu Ramachandran <prabhu [at] aero.iitb.ac.in>
#           Robert Kern <robert.kern [at] gmail.com>
#
#------------------------------------------------------------------------------

""" A `SceneEditor` for the `SceneModel`.
"""

import wx

# Enthought library imports.
from traits.api import Any, Bool, Callable
from traitsui.wx.editor import Editor
from traitsui.basic_editor_factory import BasicEditorFactory
from decorated_scene import DecoratedScene

#####################################################################
# `_SceneEditor` class
#####################################################################
class _SceneEditor(Editor):
    """ An editor for SceneModels.
    """

    # The editor is scrollable, so override the default.
    scrollable = Bool(True)

    # Internal GUI traits.
    _sizer = Any()
    _scene = Any()


    #### Public 'Editor' interface #############################################

    def init(self, parent):
        """ Finishes initializing the editor by creating the underlying toolkit
        widget.
        """

        factory = self.factory
        self.control = wx.Panel(parent, -1)
        self._sizer = wx.BoxSizer(wx.VERTICAL)
        self.control.SetSizer(self._sizer)

        assert self.value.scene_editor is None, \
                "The SceneModel may only have one active editor!"
        self._create_scene()
        self.value.activated = True

    def update_editor(self):
        """ Updates the editor when the object trait changes external to the
        editor.
        """

        # Everything should really be handled elsewhere in trait notifications.
        # Just pass here.
        pass


    def dispose(self):
        """ Disposes of the contents of an editor.
        """

        # Remove notifications.

        self.value.closing = True
        self.value.scene_editor = None
        self._setup_scene_notifications(remove=True)

        # Remove the current scene.
        if self._scene is not None:
            self._scene.close()
            self._scene = None

        self._sizer = None

        # This will destroy self.control and all of its children, including the
        # scene's control.
        super(_SceneEditor, self).dispose()

    #### Private '_SceneEditor' interface ##################################

    def _create_scene(self):
        """ Create the TVTK scene widget.
        """

        factory = self.factory
        self._scene = factory.scene_class(self.control)
        scene = self._scene
        self.value.scene_editor = scene

        # Disable rendering on the scene until we're finished.
        scene.disable_render = True
        # Add all of the actors in the current actor map.
        for obj, actors in self.value.actor_map.items():
            self._add_actors_widgets(actors)
        # Add all of the actors in the current actor map.
        self._add_actors_widgets(self.value.actor_list)
        # Set up Traits notifications.
        self._setup_scene_notifications()
        # Re-enable rendering.
        scene.disable_render = False

        # Ensure the scene's wx control is sized to fill our view's area.  Note
        # that the sizer doesn't automatically layout its contents upon adding
        # a new child so we have to force it to do a layout.
        self._sizer.Add(scene.control, 1, wx.EXPAND)
        self._sizer.Layout()

        wx.EVT_IDLE(scene.control, None)

        # Force a render.
        scene.render()

    def _setup_scene_notifications(self, remove=False):
        """ Set up or remove all of the Trait notifications that control the
        scene widget.
        """

        traits_to_sync = ['foreground', 'anti_aliasing_frames',
                          'stereo',  'background', 'off_screen_rendering',
                          'polygon_smoothing', 'jpeg_progressive',
                          'point_smoothing', 'busy', 'disable_render',
                          'magnification', 'jpeg_quality',
                          'parallel_projection', 'line_smoothing']

        model = self.value
        scene = self._scene
        if not remove:
            scene.set(**model.get(traits_to_sync))
        for trait in traits_to_sync:
            scene.sync_trait(trait, model, mutual=True, remove=remove)

        model.on_trait_change(
            scene.render,
            name='do_render',
            remove=remove,
        )
        model.on_trait_change(
            self._actors_changed,
            name='actor_map_items',
            remove=remove,
        )
        model.on_trait_change(
            self._actor_map_changed,
            name='actor_map',
            remove=remove,
        )

        model.on_trait_change(
            self._actor_list_items_changed,
            name='actor_list_items',
            remove=remove,
        )
        model.on_trait_change(
            self._actor_list_changed,
            name='actor_list',
            remove=remove,
        )

    def _actors_changed(self, event):
        """ Handle the event of the actors in the actor map changing.
        """

        scene = self._scene
        # Temporarily turn off rendering. We (re)store the old value of
        # disable_render because it may already be True.
        old_disable_render = scene.disable_render
        scene.disable_render = True
        try:
            for obj, actors in event.removed.items():
                self._remove_actors_widgets(actors)
            for obj, actors in event.added.items():
                self._add_actors_widgets(actors)
            for obj, actors in event.changed.items():
                # The actors in the event are the old ones. Grab the new ones
                # from the actor map itself.
                self._remove_actors_widgets(actors)
                self._add_actors_widgets(self.value.actor_map[obj])
        finally:
            scene.disable_render = old_disable_render
            scene.render()

    def _actor_map_changed(self, object, name, old, new):
        """ Handle the case when the entire actor map is set to something else.
        """

        scene = self._scene
        # Temporarily turn off rendering. We (re)store the old value of
        # disable_render because it may already be True.
        old_disable_render = scene.disable_render
        scene.disable_render = True
        try:
            for obj, actors in old.items():
                self._remove_actors_widgets(actors)
            for obj, actors in new.items():
                self._add_actors_widgets(actors)
        finally:
            scene.disable_render = old_disable_render
            scene.render()

    def _actor_list_items_changed(self, event):
        self._actor_list_changed(self.value, 'actor_list', event.removed,
                                 event.added)

    def _actor_list_changed(self, object, name, old, new):
        """ Handle the event of the actors in the actor map changing.
        """

        scene = self._scene
        # Temporarily turn off rendering. We (re)store the old value of
        # disable_render because it may already be True.
        old_disable_render = scene.disable_render
        scene.disable_render = True
        try:
            self._remove_actors_widgets(old)
            self._add_actors_widgets(new)
        finally:
            scene.disable_render = old_disable_render
            scene.render()

    def _separate_actors_widgets(self, actors_widgets):
        """Given a sequence (or single) of actors or widgets, this returns a
        list of just the actors and another of just the widgets.
        """
        if not hasattr(actors_widgets, '__getitem__'):
            actors_widgets = [actors_widgets]
        actors = []
        widgets = []
        for actor in actors_widgets:
            if actor.is_a('vtk3DWidget') or actor.is_a('vtkInteractorObserver'):
                widgets.append(actor)
            else:
                actors.append(actor)
        return actors, widgets

    def _add_actors_widgets(self, actors_widgets):
        """Add actors and widgets to scene."""
        scene = self._scene
        actors, widgets = self._separate_actors_widgets(actors_widgets)
        scene.add_actors(actors)
        enabled_info = self.value.enabled_info
        for widget in widgets:
            scene.add_widgets(widget, enabled_info.get(widget, True))

    def _remove_actors_widgets(self, actors_widgets):
        """Remove actors and widgets from scene."""
        scene = self._scene
        actors, widgets = self._separate_actors_widgets(actors_widgets)
        scene.remove_actors(actors)
        scene.remove_widgets(widgets)


#####################################################################
# `SceneEditor` class
#####################################################################
class SceneEditor(BasicEditorFactory):
    """ A TraitsUI editor factory for SceneModel instances.
    """

    # The class of the editor object to be constructed.
    klass = _SceneEditor

    # The class or factory function for creating the actual scene object.
    scene_class = Callable(DecoratedScene)

#### EOF #######################################################################

########NEW FILE########
__FILENAME__ = wxVTKRenderWindowInteractor
"""

A VTK RenderWindowInteractor widget for wxPython.

Find wxPython info at http://wxPython.org

Created by Prabhu Ramachandran, April 2002
Based on wxVTKRenderWindow.py

Fixes and updates by Charl P. Botha 2003-2008

Updated to new wx namespace and some cleaning up by Andrea Gavana,
December 2006
"""

"""
Please see the example at the end of this file.

----------------------------------------
Creation:

 wxVTKRenderWindowInteractor(parent, ID, stereo=0, [wx keywords]):

 You should create a wx.PySimpleApp() or some other wx**App before
 creating the window.

Behaviour:

 Uses __getattr__ to make the wxVTKRenderWindowInteractor behave just
 like a vtkGenericRenderWindowInteractor.

----------------------------------------

"""

# import usual libraries
import wx
import vtk

# wxPython 2.4.0.4 and newer prefers the use of True and False, standard
# booleans in Python 2.2 but not earlier.  Here we define these values if
# they don't exist so that we can use True and False in the rest of the
# code.  At the time of this writing, that happens exactly ONCE in
# CreateTimer()
try:
    True
except NameError:
    True = 1
    False = 0

# a few configuration items, see what works best on your system

# Use GLCanvas as base class instead of wx.Window.
# This is sometimes necessary under wxGTK or the image is blank.
# (in wxWindows 2.3.1 and earlier, the GLCanvas had scroll bars)
baseClass = wx.Window
if wx.Platform == "__WXGTK__":
    import wx.glcanvas
    baseClass = wx.glcanvas.GLCanvas

# Keep capturing mouse after mouse is dragged out of window
# (in wxGTK 2.3.2 there is a bug that keeps this from working,
# but it is only relevant in wxGTK if there are multiple windows)
_useCapture = (wx.Platform == "__WXMSW__")

# for wx < 2.9.2, CmdDown is preferred to ControlDown since it catches the
# meta key on OS X, but in later versions, CmdDown is depricated and its
# functionality moved to ControlDown
_useCmdDown = (wx.VERSION[0] < 2) or \
              (wx.VERSION[0] == 2 and wx.VERSION[1] < 9) or \
              (wx.VERSION[0] == 2 and wx.VERSION[1] == 9 and wx.VERSION[2] < 2)

# end of configuration items


class EventTimer(wx.Timer):
    """Simple wx.Timer class.
    """

    def __init__(self, iren):
        """Default class constructor.
        @param iren: current render window
        """
        wx.Timer.__init__(self)
        self.iren = iren


    def Notify(self):
        """ The timer has expired.
        """
        self.iren.TimerEvent()


class wxVTKRenderWindowInteractor(baseClass):
    """
    A wxRenderWindow for wxPython.
    Use GetRenderWindow() to get the vtkRenderWindow.
    Create with the keyword stereo=1 in order to
    generate a stereo-capable window.
    """

    # class variable that can also be used to request instances that use
    # stereo; this is overridden by the stereo=1/0 parameter.  If you set
    # it to True, the NEXT instantiated object will attempt to allocate a
    # stereo visual.  E.g.:
    # wxVTKRenderWindowInteractor.USE_STEREO = True
    # myRWI = wxVTKRenderWindowInteractor(parent, -1)
    USE_STEREO = False

    def __init__(self, parent, ID, *args, **kw):
        """Default class constructor.

        Parameters
        ----------
        parent
            parent window
        ID
            window identifier
        kw
            wxPython keywords (position, size, style) plus the 'stereo' keyword
        """
        # private attributes
        self.__RenderWhenDisabled = 0

        # First do special handling of some keywords:
        # stereo, position, size, style

        stereo = 0

        if kw.has_key('stereo'):
            if kw['stereo']:
                stereo = 1
            del kw['stereo']

        elif self.USE_STEREO:
            stereo = 1

        position, size = wx.DefaultPosition, wx.DefaultSize

        if kw.has_key('position'):
            position = kw['position']
            del kw['position']

        if kw.has_key('size'):
            size = kw['size']
            del kw['size']

        # wx.WANTS_CHARS says to give us e.g. TAB
        # wx.NO_FULL_REPAINT_ON_RESIZE cuts down resize flicker under GTK
        style = wx.WANTS_CHARS | wx.NO_FULL_REPAINT_ON_RESIZE

        if kw.has_key('style'):
            style = style | kw['style']
            del kw['style']

        # the enclosing frame must be shown under GTK or the windows
        #  don't connect together properly
        if wx.Platform != '__WXMSW__':
            l = []
            p = parent
            while p: # make a list of all parents
                l.append(p)
                p = p.GetParent()
            l.reverse() # sort list into descending order
            for p in l:
                p.Show(1)

        if baseClass.__name__ == 'GLCanvas':
            # code added by cpbotha to enable stereo and double
            # buffering correctly where the user requests this; remember
            # that the glXContext in this case is NOT allocated by VTK,
            # but by WX, hence all of this.

            # Initialize GLCanvas with correct attriblist
            attribList = [wx.glcanvas.WX_GL_RGBA,
                          wx.glcanvas.WX_GL_MIN_RED, 1,
                          wx.glcanvas.WX_GL_MIN_GREEN, 1,
                          wx.glcanvas.WX_GL_MIN_BLUE, 1,
                          wx.glcanvas.WX_GL_DEPTH_SIZE, 16,
                          wx.glcanvas.WX_GL_DOUBLEBUFFER]
            if stereo:
                attribList.append(wx.glcanvas.WX_GL_STEREO)

            try:
                baseClass.__init__(self, parent, id=ID, pos=position,
                                   size=size, style=style,
                                   attribList=attribList)
            except wx.PyAssertionError:
                # visual couldn't be allocated, so we go back to default
                baseClass.__init__(self, parent, id=ID, pos=position,
                                   size=size, style=style)
                if stereo:
                    # and make sure everyone knows that the stereo
                    # visual wasn't set.
                    stereo = 0

        else:
            baseClass.__init__(self, parent, ID, position, size, style)

        # create the RenderWindow and initialize it
        self._Iren = vtk.vtkGenericRenderWindowInteractor()
        self._Iren.SetRenderWindow( vtk.vtkRenderWindow() )
        self._Iren.AddObserver('CreateTimerEvent', self.CreateTimer)
        self._Iren.AddObserver('DestroyTimerEvent', self.DestroyTimer)
        self._Iren.GetRenderWindow().AddObserver('CursorChangedEvent',
                                                 self.CursorChangedEvent)

        try:
            self._Iren.GetRenderWindow().SetSize(size.width, size.height)
        except AttributeError:
            self._Iren.GetRenderWindow().SetSize(size[0], size[1])

        if stereo:
            self._Iren.GetRenderWindow().StereoCapableWindowOn()
            self._Iren.GetRenderWindow().SetStereoTypeToCrystalEyes()

        self.__handle = None

        self.BindEvents()

        # with this, we can make sure that the reparenting logic in
        # Render() isn't called before the first OnPaint() has
        # successfully been run (and set up the VTK/WX display links)
        self.__has_painted = False

        # set when we have captured the mouse.
        self._own_mouse = False
        # used to store WHICH mouse button led to mouse capture
        self._mouse_capture_button = 0

        # A mapping for cursor changes.
        self._cursor_map = {0: wx.CURSOR_ARROW, # VTK_CURSOR_DEFAULT
                            1: wx.CURSOR_ARROW, # VTK_CURSOR_ARROW
                            2: wx.CURSOR_SIZENESW, # VTK_CURSOR_SIZENE
                            3: wx.CURSOR_SIZENWSE, # VTK_CURSOR_SIZENWSE
                            4: wx.CURSOR_SIZENESW, # VTK_CURSOR_SIZESW
                            5: wx.CURSOR_SIZENWSE, # VTK_CURSOR_SIZESE
                            6: wx.CURSOR_SIZENS, # VTK_CURSOR_SIZENS
                            7: wx.CURSOR_SIZEWE, # VTK_CURSOR_SIZEWE
                            8: wx.CURSOR_SIZING, # VTK_CURSOR_SIZEALL
                            9: wx.CURSOR_HAND, # VTK_CURSOR_HAND
                            10: wx.CURSOR_CROSS, # VTK_CURSOR_CROSSHAIR
                           }

    def BindEvents(self):
        """Binds all the necessary events for navigation, sizing,
        drawing.
        """
        # refresh window by doing a Render
        self.Bind(wx.EVT_PAINT, self.OnPaint)
        # turn off background erase to reduce flicker
        self.Bind(wx.EVT_ERASE_BACKGROUND, lambda e: None)

        # Bind the events to the event converters
        self.Bind(wx.EVT_RIGHT_DOWN, self.OnButtonDown)
        self.Bind(wx.EVT_LEFT_DOWN, self.OnButtonDown)
        self.Bind(wx.EVT_MIDDLE_DOWN, self.OnButtonDown)
        self.Bind(wx.EVT_RIGHT_UP, self.OnButtonUp)
        self.Bind(wx.EVT_LEFT_UP, self.OnButtonUp)
        self.Bind(wx.EVT_MIDDLE_UP, self.OnButtonUp)
        self.Bind(wx.EVT_MOUSEWHEEL, self.OnMouseWheel)
        self.Bind(wx.EVT_MOTION, self.OnMotion)

        # Bind the double clicks as well.
        self.Bind(wx.EVT_LEFT_DCLICK, self.OnButtonDown)
        self.Bind(wx.EVT_MIDDLE_DCLICK, self.OnButtonDown)
        self.Bind(wx.EVT_RIGHT_DCLICK, self.OnButtonDown)

        self.Bind(wx.EVT_ENTER_WINDOW, self.OnEnter)
        self.Bind(wx.EVT_LEAVE_WINDOW, self.OnLeave)

        # If we use EVT_KEY_DOWN instead of EVT_CHAR, capital versions
        # of all characters are always returned.  EVT_CHAR also performs
        # other necessary keyboard-dependent translations.
        self.Bind(wx.EVT_CHAR, self.OnKeyDown)
        self.Bind(wx.EVT_KEY_UP, self.OnKeyUp)

        self.Bind(wx.EVT_SIZE, self.OnSize)

        # the wx 2.8.7.1 documentation states that you HAVE to handle
        # this event if you make use of CaptureMouse, which we do.
        if _useCapture and hasattr(wx, 'EVT_MOUSE_CAPTURE_LOST'):
            self.Bind(wx.EVT_MOUSE_CAPTURE_LOST,
                    self.OnMouseCaptureLost)


    def __getattr__(self, attr):
        """Makes the object behave like a
        vtkGenericRenderWindowInteractor.
        """
        if attr == '__vtk__':
            return lambda t=self._Iren: t
        elif hasattr(self._Iren, attr):
            return getattr(self._Iren, attr)
        else:
            raise AttributeError, self.__class__.__name__ + \
                  " has no attribute named " + attr

    def CreateTimer(self, obj, evt):
        """ Creates a timer.
        """
        self._timer = EventTimer(self)
        self._timer.Start(10, True)

    def DestroyTimer(self, obj, evt):
        """The timer is a one shot timer so will expire automatically.
        """
        return 1

    def _CursorChangedEvent(self, obj, evt):
        """Change the wx cursor if the renderwindow's cursor was
        changed.
        """
        cur = self._cursor_map[obj.GetCurrentCursor()]
        c = wx.StockCursor(cur)
        self.SetCursor(c)

    def CursorChangedEvent(self, obj, evt):
        """Called when the CursorChangedEvent fires on the render
        window."""
        # This indirection is needed since when the event fires, the
        # current cursor is not yet set so we defer this by which time
        # the current cursor should have been set.
        wx.CallAfter(self._CursorChangedEvent, obj, evt)

    def HideCursor(self):
        """Hides the cursor."""
        c = wx.StockCursor(wx.CURSOR_BLANK)
        self.SetCursor(c)

    def ShowCursor(self):
        """Shows the cursor."""
        rw = self._Iren.GetRenderWindow()
        cur = self._cursor_map[rw.GetCurrentCursor()]
        c = wx.StockCursor(cur)
        self.SetCursor(c)

    def GetDisplayId(self):
        """Function to get X11 Display ID from WX and return it in a format
        that can be used by VTK Python.

        We query the X11 Display with a new call that was added in wxPython
        2.6.0.1.  The call returns a SWIG object which we can query for the
        address and subsequently turn into an old-style SWIG-mangled string
        representation to pass to VTK.
        """
        d = None

        try:
            d = wx.GetXDisplay()

        except NameError:
            # wx.GetXDisplay was added by Robin Dunn in wxPython 2.6.0.1
            # if it's not available, we can't pass it.  In general,
            # things will still work; on some setups, it'll break.
            pass

        else:
            # wx returns None on platforms where wx.GetXDisplay is not relevant
            if d:
                d = hex(d)
                # On wxPython-2.6.3.2 and above there is no leading '0x'.
                if not d.startswith('0x'):
                    d = '0x' + d

                # we now have 0xdeadbeef
                # VTK wants it as: _deadbeef_void_p (pre-SWIG-1.3 style)
                d = '_%s_%s\0' % (d[2:], 'void_p')

        return d

    def OnMouseCaptureLost(self, event):
        """This is signalled when we lose mouse capture due to an
        external event, such as when a dialog box is shown.  See the
        wx documentation.
        """

        # the documentation seems to imply that by this time we've
        # already lost capture.  I have to assume that we don't need
        # to call ReleaseMouse ourselves.
        if _useCapture and self._own_mouse:
            self._own_mouse = False

    def OnPaint(self,event):
        """Handles the wx.EVT_PAINT event for
        wxVTKRenderWindowInteractor.
        """

        # wx should continue event processing after this handler.
        # We call this BEFORE Render(), so that if Render() raises
        # an exception, wx doesn't re-call OnPaint repeatedly.
        event.Skip()

        dc = wx.PaintDC(self)

        # Check that a renderwindow exists, if not do nothing.
        rw = self._Iren.GetRenderWindow()
        if rw is None:
            return

        # make sure the RenderWindow is sized correctly
        rw.SetSize(*self.GetSizeTuple())

        # Tell the RenderWindow to render inside the wx.Window.
        if not self.__handle:

            # on relevant platforms, set the X11 Display ID
            d = self.GetDisplayId()
            if d:
                self._Iren.GetRenderWindow().SetDisplayId(d)

            # store the handle
            self.__handle = self.GetHandle()
            # and give it to VTK
            self._Iren.GetRenderWindow().SetWindowInfo(str(self.__handle))

            # now that we've painted once, the Render() reparenting logic
            # is safe
            self.__has_painted = True

        self.Render()

    def OnSize(self,event):
        """Handles the wx.EVT_SIZE event for
        wxVTKRenderWindowInteractor.
        """

        # event processing should continue (we call this before the
        # Render(), in case it raises an exception)
        event.Skip()

        try:
            width, height = event.GetSize()
        except:
            width = event.GetSize().width
            height = event.GetSize().height
        self._Iren.SetSize(width, height)
        self._Iren.ConfigureEvent()

        # this will check for __handle
        self.Render()

    def CommandDown(self, event):
        if _useCmdDown:
            return event.CmdDown()
        else:
            return event.ControlDown()

    def OnMotion(self,event):
        """Handles the wx.EVT_MOTION event for
        wxVTKRenderWindowInteractor.
        """

        # event processing should continue
        # we call this early in case any of the VTK code raises an
        # exception.
        event.Skip()

        self._Iren.SetEventInformationFlipY(event.GetX(), event.GetY(),
                                            self.CommandDown(event),
                                            event.ShiftDown(),
                                            chr(0), 0, None)
        self._Iren.MouseMoveEvent()

    def OnEnter(self,event):
        """Handles the wx.EVT_ENTER_WINDOW event for
        wxVTKRenderWindowInteractor.
        """

        # event processing should continue
        event.Skip()

        self._Iren.SetEventInformationFlipY(event.GetX(), event.GetY(),
                                            self.CommandDown(event),
              event.ShiftDown(),
              chr(0), 0, None)
        self._Iren.EnterEvent()


    def OnLeave(self,event):
        """Handles the wx.EVT_LEAVE_WINDOW event for
        wxVTKRenderWindowInteractor.
        """

        # event processing should continue
        event.Skip()

        self._Iren.SetEventInformationFlipY(event.GetX(), event.GetY(),
                                            self.CommandDown(event),
              event.ShiftDown(),
              chr(0), 0, None)
        self._Iren.LeaveEvent()


    def OnButtonDown(self,event):
        """Handles the wx.EVT_LEFT/RIGHT/MIDDLE_DOWN events for
        wxVTKRenderWindowInteractor.
        """

        # allow wx event processing to continue
        # on wxPython 2.6.0.1, omitting this will cause problems with
        # the initial focus, resulting in the wxVTKRWI ignoring keypresses
        # until we focus elsewhere and then refocus the wxVTKRWI frame
        # we do it this early in case any of the following VTK code
        # raises an exception.
        event.Skip()

        ctrl, shift = self.CommandDown(event), event.ShiftDown()
        self._Iren.SetEventInformationFlipY(event.GetX(), event.GetY(),
                                            ctrl, shift, chr(0), 0, None)

        button = 0
        if event.RightIsDown():
            self._Iren.RightButtonPressEvent()
            button = 'Right'
        elif event.LeftIsDown():
            self._Iren.LeftButtonPressEvent()
            button = 'Left'
        elif event.MiddleIsDown():
            self._Iren.MiddleButtonPressEvent()
            button = 'Middle'

        # save the button and capture mouse until the button is released
        # we only capture the mouse if it hasn't already been captured
        if _useCapture and not self._own_mouse:
            self._own_mouse = True
            self._mouse_capture_button = button
            self.CaptureMouse()


    def OnButtonUp(self,event):
        """Handles the wx.EVT_LEFT/RIGHT/MIDDLE_UP events for
        wxVTKRenderWindowInteractor.
        """

        # event processing should continue
        event.Skip()

        button = 0
        if event.RightUp():
            button = 'Right'
        elif event.LeftUp():
            button = 'Left'
        elif event.MiddleUp():
            button = 'Middle'

        # if the same button is released that captured the mouse, and
        # we have the mouse, release it.
        # (we need to get rid of this as soon as possible; if we don't
        #  and one of the event handlers raises an exception, mouse
        #  is never released.)
        if _useCapture and self._own_mouse and \
                button==self._mouse_capture_button:
            self.ReleaseMouse()
            self._own_mouse = False

        ctrl, shift = self.CommandDown(event), event.ShiftDown()
        self._Iren.SetEventInformationFlipY(event.GetX(), event.GetY(),
                                            ctrl, shift, chr(0), 0, None)

        if button == 'Right':
            self._Iren.RightButtonReleaseEvent()
        elif button == 'Left':
            self._Iren.LeftButtonReleaseEvent()
        elif button == 'Middle':
            self._Iren.MiddleButtonReleaseEvent()


    def OnMouseWheel(self,event):
        """Handles the wx.EVT_MOUSEWHEEL event for
        wxVTKRenderWindowInteractor.
        """

        # event processing should continue
        event.Skip()

        ctrl, shift = self.CommandDown(event), event.ShiftDown()
        self._Iren.SetEventInformationFlipY(event.GetX(), event.GetY(),
                                            ctrl, shift, chr(0), 0, None)
        if event.GetWheelRotation() > 0:
            self._Iren.MouseWheelForwardEvent()
        else:
            self._Iren.MouseWheelBackwardEvent()


    def OnKeyDown(self,event):
        """Handles the wx.EVT_KEY_DOWN event for
        wxVTKRenderWindowInteractor.
        """

        # event processing should continue
        event.Skip()

        ctrl, shift = self.CommandDown(event), event.ShiftDown()
        keycode, keysym = event.GetKeyCode(), None
        key = chr(0)
        if keycode < 256:
            key = chr(keycode)

        # wxPython 2.6.0.1 does not return a valid event.Get{X,Y}()
        # for this event, so we use the cached position.
        (x,y)= self._Iren.GetEventPosition()
        self._Iren.SetEventInformation(x, y,
                                       ctrl, shift, key, 0,
                                       keysym)

        self._Iren.KeyPressEvent()
        self._Iren.CharEvent()


    def OnKeyUp(self,event):
        """Handles the wx.EVT_KEY_UP event for
        wxVTKRenderWindowInteractor.
        """

        # event processing should continue
        event.Skip()

        ctrl, shift = self.CommandDown(event), event.ShiftDown()
        keycode, keysym = event.GetKeyCode(), None
        key = chr(0)
        if keycode < 256:
            key = chr(keycode)

        self._Iren.SetEventInformationFlipY(event.GetX(), event.GetY(),
                                            ctrl, shift, key, 0,
                                            keysym)
        self._Iren.KeyReleaseEvent()


    def GetRenderWindow(self):
        """Returns the render window (vtkRenderWindow).
        """
        return self._Iren.GetRenderWindow()

    def Render(self):
        """Actually renders the VTK scene on screen.
        """
        RenderAllowed = 1

        if not self.__RenderWhenDisabled:
            # the user doesn't want us to render when the toplevel frame
            # is disabled - first find the top level parent
            topParent = wx.GetTopLevelParent(self)
            if topParent:
                # if it exists, check whether it's enabled
                # if it's not enabeld, RenderAllowed will be false
                RenderAllowed = topParent.IsEnabled()

        if RenderAllowed:
            if self.__handle and self.__handle == self.GetHandle():
                self._Iren.GetRenderWindow().Render()

            elif self.GetHandle() and self.__has_painted:
                # this means the user has reparented us; let's adapt to the
                # new situation by doing the WindowRemap dance
                self._Iren.GetRenderWindow().SetNextWindowInfo(
                    str(self.GetHandle()))

                # make sure the DisplayId is also set correctly
                d = self.GetDisplayId()
                if d:
                    self._Iren.GetRenderWindow().SetDisplayId(d)

                # do the actual remap with the new parent information
                self._Iren.GetRenderWindow().WindowRemap()

                # store the new situation
                self.__handle = self.GetHandle()
                self._Iren.GetRenderWindow().Render()

    def SetRenderWhenDisabled(self, newValue):
        """Change value of __RenderWhenDisabled ivar.

        If __RenderWhenDisabled is false (the default), this widget will not
        call Render() on the RenderWindow if the top level frame (i.e. the
        containing frame) has been disabled.

        This prevents recursive rendering during wx.SafeYield() calls.
        wx.SafeYield() can be called during the ProgressMethod() callback of
        a VTK object to have progress bars and other GUI elements updated -
        it does this by disabling all windows (disallowing user-input to
        prevent re-entrancy of code) and then handling all outstanding
        GUI events.

        However, this often triggers an OnPaint() method for wxVTKRWIs,
        resulting in a Render(), resulting in Update() being called whilst
        still in progress.
        """
        self.__RenderWhenDisabled = bool(newValue)


#--------------------------------------------------------------------
def wxVTKRenderWindowInteractorConeExample():
    """Like it says, just a simple example
    """
    # every wx app needs an app
    app = wx.PySimpleApp()

    # create the top-level frame, sizer and wxVTKRWI
    frame = wx.Frame(None, -1, "wxVTKRenderWindowInteractor", size=(400,400))
    widget = wxVTKRenderWindowInteractor(frame, -1)
    sizer = wx.BoxSizer(wx.VERTICAL)
    sizer.Add(widget, 1, wx.EXPAND)
    frame.SetSizer(sizer)
    frame.Layout()

    # It would be more correct (API-wise) to call widget.Initialize() and
    # widget.Start() here, but Initialize() calls RenderWindow.Render().
    # That Render() call will get through before we can setup the
    # RenderWindow() to render via the wxWidgets-created context; this
    # causes flashing on some platforms and downright breaks things on
    # other platforms.  Instead, we call widget.Enable().  This means
    # that the RWI::Initialized ivar is not set, but in THIS SPECIFIC CASE,
    # that doesn't matter.
    widget.Enable(1)

    widget.AddObserver("ExitEvent", lambda o,e,f=frame: f.Close())

    ren = vtk.vtkRenderer()
    widget.GetRenderWindow().AddRenderer(ren)

    cone = vtk.vtkConeSource()
    cone.SetResolution(8)

    coneMapper = vtk.vtkPolyDataMapper()
    coneMapper.SetInput(cone.GetOutput())

    coneActor = vtk.vtkActor()
    coneActor.SetMapper(coneMapper)

    ren.AddActor(coneActor)

    # show the window
    frame.Show()

    app.MainLoop()

if __name__ == "__main__":
    wxVTKRenderWindowInteractorConeExample()


########NEW FILE########
__FILENAME__ = special_gen
"""This module defines classes used in tvtk code generation,

`SpecialGenerator` defines methods that write out special code for
some of the VTK classes.  `HelperGenerator` helps generate the
`tvtk_helper.py` class.

"""
# Author: Prabhu Ramachandran
# Copyright (c) 2004-2007, Enthought, Inc.
# License: BSD Style.

import vtk

# These are relative imports for good reason.
import indenter
from common import get_tvtk_name


######################################################################
# `SpecialGenerator` class.
######################################################################

class SpecialGenerator:
    """Generates special code for some of the TVTK classes.

    For example vtkMatrix4x4 objects can be pickled nicely if the
    elements of the matrix are stored and restored.  So we define a
    `_write_Matrix4x4` method that generates the appropriate code.

    """

    def __init__(self, indent):
        """`indent` is a reference to the `Indenter` instance of the
        WrapperGenerator.

        """
        self.indent = indent

    #################################################################
    # `SpecialGenerator` interface.
    #################################################################

    def generate_code(self, node, out):
        """Write the code given the node in the class tree, `node`,
        and output file-like object, `out`.
        """
        self._write_special(node.name, out)

    #################################################################
    # Non-public interface.
    #################################################################

    def _write_special(self, name, out):
        """Given the name of the class, call appropriate method, if
        available.

        """
        tname = get_tvtk_name(name)
        writer = '_write_%s'%tname
        if hasattr(self, writer):
            getattr(self, writer)(out)

    def _write_InteractorEventRecorder(self, out):
        # This class is a pain because it must always take highest
        # priority, the default value is therefore set to a huge
        # number so that it catches all events first.
        code = '''
        priority = traits.Trait(1.0, traits.Float, traits.Range(0.0, 1.0))
        def _priority_changed(self, old_val, new_val):
            self._do_change(self._vtk_obj.SetPriority,
                            self.priority)
        priority.help = \
            """
            Set/Get the priority at which events are processed. This is used when
            multiple interactor observers are used simultaneously. The default value
            is 0.0 (lowest priority.) Note that when multiple interactor observer
            have the same priority, then the last observer added will process the
            event first. (Note: once the set_interactor() method has been called,
            changing the priority does not effect event processing. You will have
            to set_interactor(_null), change priority, and then set_interactor(iren)
            to have the priority take effect.)
            """
        '''
        out.write(self.indent.format(code))

    def _write_Matrix4x4(self, out):
        code = """
        def __getstate__(self):
            d = tvtk_base.TVTKBase.__getstate__(self)
            obj = self._vtk_obj
            e = [obj.GetElement(i, j) for i in range(4) for j in range(4)]
            d['elements'] = e
            return d

        def __setstate__(self, dict):
            e = dict.pop('elements')
            tvtk_base.TVTKBase.__setstate__(self, dict)
            self._in_set = 1
            obj = self._vtk_obj
            [obj.SetElement(i, j, e[4*i+j]) for i in range(4) for j in range(4)]
            self._in_set = 0
            self.update_traits()

        def from_array(self, arr):
            '''Set the value of the matrix using the passed
            Numeric array or Python list.
            '''
            obj = self._vtk_obj
            [obj.SetElement(i, j, arr[i,j]) for i in range(4) for j in range(4)]

        def to_array(self):
            '''Return the object as a numpy array.'''
            obj = self._vtk_obj
            e = [obj.GetElement(i, j) for i in range(4) for j in range(4)]
            arr = array_handler.numpy.array(e, dtype=float)
            arr.shape = (4,4)
            return arr

        """
        out.write(self.indent.format(code))

    def _write_Property(self, out):
        # Color is made from the other specified colors.
        code = """
        def __getstate__(self):
            d = tvtk_base.TVTKBase.__getstate__(self)
            if 'color' in d:
                del d['color']
            return d

        def __setstate__(self, dict):
            tvtk_base.TVTKBase.__setstate__(self, dict)
            self.update_traits()
        """
        out.write(self.indent.format(code))

    _write_Light = _write_Property

    def _write_Collection(self, out):
        code = """
        def __len__(self):
            return self._vtk_obj.GetNumberOfItems()

        def __iter__(self):
            self._vtk_obj.InitTraversal()
            return self

        def next(self):
            try:
                val = self._vtk_obj.GetNextItem()
            except AttributeError:
                val = self._vtk_obj.GetNextProp()
            if val is None:
                raise StopIteration
            return wrap_vtk(val)

        def __getitem__(self, key):
            obj = self._vtk_obj
            if type(key) != type(1):
                raise TypeError, "Only integers are valid keys."
            ni = obj.GetNumberOfItems()
            if key < 0:
                key =  ni + key
            ret = obj.GetItemAsObject(key)
            if ret is None:
                raise IndexError, "Index out of range."
            return wrap_vtk(ret)

        def __setitem__(self, key, val):
            obj = self._vtk_obj
            if type(key) != type(1):
                raise TypeError, "Only integers are valid key."
            ni = obj.GetNumberOfItems()
            if key < 0:
                key =  ni + key
            if key < 0 or key >= ni:
                raise IndexError, "Index out of range."
            obj.ReplaceItem(key, deref_vtk(val))

        def __delitem__(self, key):
            obj = self._vtk_obj
            if type(key) != type(1):
                raise TypeError, "Only integers are valid keys."
            ni = obj.GetNumberOfItems()
            if key < 0:
                key =  ni + key
            if key < 0 or key >= ni:
                raise IndexError, "Index out of range."
            obj.RemoveItem(key)

        def __repr__(self):
            return repr([repr(x) for x in self])

        def append(self, val):
            self._vtk_obj.AddItem(deref_vtk(val))

        def extend(self, arr):
            obj = self._vtk_obj
            for i in arr:
                obj.AddItem(deref_vtk(i))
        """
        out.write(self.indent.format(code))

    def _write_DataArray(self, out):
        code = """
        def __len__(self):
            return self._vtk_obj.GetNumberOfTuples()

        def __iter__(self):
            obj = self._vtk_obj
            n = obj.GetNumberOfTuples()
            nc = obj.GetNumberOfComponents()
            if nc in [1,2,3,4,9]:
                meth = getattr(obj, 'GetTuple%d'%nc)
                for i in xrange(n):
                    yield meth(i)
            else:
                for i in xrange(n):
                    yield tuple([obj.GetComponent(i, x) for x in range(nc)])

        def _check_key(self, key, n):
            if type(key) not in [int, long]:
                raise TypeError, "Only integers are valid keys."
            if key < 0:
                key =  n + key
            if key < 0 or key >= n:
                raise IndexError, "Index out of range."
            return key

        def __getitem__(self, key):
            obj = self._vtk_obj
            n = obj.GetNumberOfTuples()
            key = self._check_key(key, n)
            nc = obj.GetNumberOfComponents()
            if nc in [1,2,3,4,9]:
                return getattr(obj, 'GetTuple%d'%nc)(key)
            else:
                return tuple([obj.GetComponent(key, x) for x in range(nc)])

        def __setitem__(self, key, val):
            obj = self._vtk_obj
            n = obj.GetNumberOfTuples()
            key = self._check_key(key, n)
            nc = obj.GetNumberOfComponents()
            if nc == 1:
                obj.SetValue(key, val)
            elif nc in [2,3,4,9]:
                getattr(obj, 'SetTuple%d'%nc)(key, *val)
            else:
                assert len(val) == nc, \
                       'length of %s != %s.'%(val, nc)
                for x in range(nc):
                    obj.SetComponent(key, x, val[x])

        def __repr__(self):
            obj = self._vtk_obj
            n = obj.GetNumberOfTuples()
            if n <= 10:
                return repr([x for x in self])
            else:
                first, last = self[0], self[-1]
                return '[%s, ..., %s], length = %s'%(first, last, n)

        def append(self, val):
            obj = self._vtk_obj
            nc = obj.GetNumberOfComponents()
            if nc == 1:
                obj.InsertNextTuple1(val)
            elif nc in [2,3,4,9]:
                meth = getattr(obj, 'InsertNextTuple%d'%nc)
                meth(*val)
            else:
                n = obj.GetNumberOfTuples()
                for x in range(nc):
                    obj.InsertComponent(n, x, val[x])
            self.update_traits()

        def extend(self, arr):
            obj = self._vtk_obj
            nc = obj.GetNumberOfComponents()
            if nc == 1:
                for i in arr:
                    obj.InsertNextTuple1(i)
            elif nc in [2,3,4,9]:
                meth = getattr(obj, 'InsertNextTuple%d'%nc)
                for i in arr:
                    meth(*i)
            else:
                n = obj.GetNumberOfTuples()
                for i in range(len(arr)):
                    for x in range(nc):
                        obj.InsertComponent(n+i, x, arr[i][x])
            self.update_traits()

        def from_array(self, arr):
            '''Set the value of the data array using the passed
            Numeric array or Python list.  This is implemented
            efficiently.
            '''
            array_handler.array2vtk(arr, self._vtk_obj)
            self.update_traits()

        def to_array(self):
            '''Return the object as a Numeric array.'''
            return array_handler.vtk2array(self._vtk_obj)

        """
        out.write(self.indent.format(code))

    def _write_Points(self, out):
        code = """
        def __len__(self):
            return self._vtk_obj.GetNumberOfPoints()

        def __iter__(self):
            obj = self._vtk_obj
            n = obj.GetNumberOfPoints()
            for i in xrange(n):
                yield obj.GetPoint(i)

        def _check_key(self, key, n):
            if type(key) != type(1):
                raise TypeError, "Only integers are valid keys."
            if key < 0:
                key =  n + key
            if key < 0 or key >= n:
                raise IndexError, "Index out of range."
            return key

        def __getitem__(self, key):
            obj = self._vtk_obj
            n = obj.GetNumberOfPoints()
            key = self._check_key(key, n)
            return obj.GetPoint(key)

        def __setitem__(self, key, val):
            obj = self._vtk_obj
            n = obj.GetNumberOfPoints()
            key = self._check_key(key, n)
            obj.SetPoint(key, val)

        def __repr__(self):
            obj = self._vtk_obj
            n = obj.GetNumberOfPoints()
            if n <= 10:
                return repr([x for x in self])
            else:
                meth = obj.GetPoint
                return '[%s, ..., %s], length = %s'%(meth(0),
                                                     meth(n-1), n)

        def append(self, val):
            self._vtk_obj.InsertNextPoint(val)
            self.update_traits()

        def extend(self, arr):
            obj = self._vtk_obj
            for i in arr:
                obj.InsertNextPoint(i)
            self.update_traits()

        def from_array(self, arr):
            '''Set the value of the data array using the passed
            Numeric array or Python list.  This is implemented
            efficiently.
            '''
            array_handler.array2vtkPoints(arr, self._vtk_obj)
            self.update_traits()

        def to_array(self):
            '''Return the object as a Numeric array.'''
            return array_handler.vtk2array(self._vtk_obj.GetData())

        """
        out.write(self.indent.format(code))

    def _write_IdList(self, out):
        code = """
        def __len__(self):
            return self._vtk_obj.GetNumberOfIds()

        def __iter__(self):
            obj = self._vtk_obj
            n = obj.GetNumberOfIds()
            for i in xrange(n):
                yield obj.GetId(i)

        def _check_key(self, key, n):
            if type(key) != type(1):
                raise TypeError, "Only integers are valid keys."
            if key < 0:
                key =  n + key
            if key < 0 or key >= n:
                raise IndexError, "Index out of range."
            return key

        def __getitem__(self, key):
            obj = self._vtk_obj
            n = obj.GetNumberOfIds()
            key = self._check_key(key, n)
            return obj.GetId(key)

        def __setitem__(self, key, val):
            obj = self._vtk_obj
            n = obj.GetNumberOfIds()
            key = self._check_key(key, n)
            obj.SetId(key, val)

        def __repr__(self):
            obj = self._vtk_obj
            n = obj.GetNumberOfIds()
            if n <= 10:
                return repr([x for x in self])
            else:
                meth = obj.GetId
                return '[%s, ..., %s], length = %s'%(meth(0),
                                                     meth(n-1), n)

        def append(self, val):
            self._vtk_obj.InsertNextId(val)
            self.update_traits()

        def extend(self, arr):
            obj = self._vtk_obj
            for i in arr:
                obj.InsertNextId(i)
            self.update_traits()

        def from_array(self, arr):
            '''Set the value of the data array using the passed
            Numeric array or Python list.  This is implemented
            efficiently.
            '''
            array_handler.array2vtkIdList(arr, self._vtk_obj)
            self.update_traits()

        """
        out.write(self.indent.format(code))

    def _write_CellArray(self, out):
        code = """
        def from_array(self, arr):
            '''Set the value of the data array using the passed
            Numeric array or Python list.  This is implemented
            efficiently.
            '''
            array_handler.array2vtkCellArray(arr, self._vtk_obj)
            self.update_traits()

        def to_array(self):
            '''Return the object as a Numeric array.'''
            return array_handler.vtk2array(self._vtk_obj.GetData())
        """
        out.write(self.indent.format(code))

######################################################################
# `HelperGenerator` class.
######################################################################

class HelperGenerator:
    """Writes out the tvtk_helper.py file that makes it easy to use
    tvtk objects efficiently.

    """

    def __init__(self):
        self.indent = indenter.Indent()

    #################################################################
    # `HelperGenerator` interface.
    #################################################################

    def write_prelims(self, out):
        """ Write out the preliminary data."""
        indent = self.indent
        v = vtk.vtkVersion()
        vtk_version = v.GetVTKVersion()[:3]
        vtk_src_version = v.GetVTKSourceVersion()
        code = """
        import vtk
        from tvtk import tvtk_base
        from tvtk.common import get_tvtk_name, camel2enthought

        # Caches all the classes.
        _cache = {}

        def set_ancestors(klass):
            tmp = klass.__bases__
            if not tmp:
                return
            # Assuming a single inheritance.
            tmp = tmp[0]
            name = tmp.__name__
            while not _cache.has_key(name) and \
                    name not in ['TVTKBase', 'object']:
                _cache[name] = tmp
                tmp = tmp.__bases__[0]
                name = tmp.__name__

        def get_module(fname):
            try:
                mod = __import__('tvtk.custom.%%s'%%fname,
                                 globals(), locals(), [fname])
            except ImportError:
                # This is a local import since the tvtk modules are all
                # inside the tvtk_classes ZIP file and are local to the
                # current module: tvtk_helper.py
                mod = __import__('tvtk.tvtk_classes.%%s'%%fname, globals(), locals(), [fname])
            return mod

        def get_class(name):
            if _cache.has_key(name):
                return _cache[name]
            else:
                fname = camel2enthought(name)
                mod = get_module(fname)
                klass = getattr(mod, name)
                _cache[name] = klass
                set_ancestors(klass)
                return klass

        def wrap_vtk(obj):
            if isinstance(obj, tvtk_base.TVTKBase):
                return obj
            elif isinstance(obj, vtk.vtkObjectBase):
                cached_obj = tvtk_base.get_tvtk_object_from_cache(obj)
                if cached_obj is not None:
                    return cached_obj
                cname = get_tvtk_name(obj.__class__.__name__)
                tvtk_class = get_class(cname)
                return tvtk_class(obj)
            else:
                return obj


        class TVTK(object):
            to_tvtk = staticmethod(wrap_vtk)
            to_vtk = staticmethod(tvtk_base.deref_vtk)

        """%locals()
        out.write(indent.format(code))
        indent.incr()

    def add_class(self, name, out):
        """Add a tvtk class with name, `name` as a property to the
        helper class output file-like object, `out`.
        """
        code = """
        %(name)s = property(lambda self: get_class('%(name)s'))
        """%locals()
        out.write(self.indent.format(code))

########NEW FILE########
__FILENAME__ = test_array_ext
"""Unit tests for the array related extension code.

"""
# Author: Prabhu Ramachandran <prabhu_r@users.sf.net>
# Copyright (c) 2005, Enthought, Inc.
# License: BSD Style.

import unittest

import numpy

from tvtk.array_handler import ID_TYPE_CODE
from tvtk.array_ext import set_id_type_array

class TestArrayExt(unittest.TestCase):
    def test_set_id_type_array(self):
        N = 5
        a = numpy.zeros((N,4), ID_TYPE_CODE)
        a[:,1] = 1
        a[:,2] = 2
        a[:,3] = 3

        def diff_arr(x, y):
            return numpy.sum(numpy.ravel(x) - numpy.ravel(y[:,1:]))

        # Test contiguous arrays.
        b = numpy.zeros((N,5), ID_TYPE_CODE)
        set_id_type_array(a, b)
        self.assertEqual(diff_arr(a, b), 0)

        # Test non-contiguous arrays.
        b = numpy.zeros((N,3), ID_TYPE_CODE)
        set_id_type_array(a[:,::2], b)
        self.assertEqual(diff_arr(a[:,::2], b), 0)

        # Test 1D array.
        b = numpy.zeros(N*5, ID_TYPE_CODE)
        set_id_type_array(a, b)
        self.assertEqual(diff_arr(a, numpy.reshape(b, (N,5))), 0)

        # Test assertions.
        d = a.astype('d')
        b = numpy.zeros((N, 5), ID_TYPE_CODE)
        self.assertRaises(AssertionError, set_id_type_array,
                          d, b)

        # B should b contiguous.
        b = numpy.zeros((N, 10), ID_TYPE_CODE)
        self.assertRaises(AssertionError, set_id_type_array,
                          a, b[:,::2])

        self.assertRaises(AssertionError, set_id_type_array,
                          a[0], b)

        # Test size check assertion.
        b = numpy.zeros((N, 4), ID_TYPE_CODE)
        self.assertRaises(AssertionError, set_id_type_array,
                          a, b)

        b = numpy.zeros(N*6, ID_TYPE_CODE)
        self.assertRaises(AssertionError, set_id_type_array,
                          a, b)

        # This should work!
        set_id_type_array(a, b[:N*5])
        self.assertEqual(diff_arr(a, numpy.reshape(b[:N*5], (N,5))), 0)


if __name__ == "__main__":
    unittest.main()

########NEW FILE########
__FILENAME__ = test_array_handler
"""
Tests for array_handler.py.
"""
# Author: Prabhu Ramachandran <prabhu_r@users.sf.net>
# Copyright (c) 2005-2008, Enthought, Inc.
# License: BSD Style.

import unittest
import vtk
import numpy

from tvtk import array_handler
from tvtk import tvtk_base

# FIXME: test_tvtk_base.py is in the local directory so just doing
#     from test_tvtk_base import Prop
#     should be enough, however nose 0.9.3 will not find it, unless you give
#     it the full path.  It nose 0.10.3 works fine in this respect.
from tvtk.tests.test_tvtk_base import Prop


def mysum(arr):
    val = arr
    while type(val) == numpy.ndarray:
        val = numpy.sum(val)
    return val


class TestArrayHandler(unittest.TestCase):
    def _check_arrays(self, arr, vtk_arr):
        self.assertEqual(vtk_arr.GetNumberOfTuples(), len(arr))
        if len(arr.shape) == 2:
            dim1 = arr.shape[1]
            self.assertEqual(vtk_arr.GetNumberOfComponents(), dim1)
            for i in range(len(arr)):
                if dim1 in [1,2,3,4,9]:
                    res = getattr(vtk_arr, 'GetTuple%s'%dim1)(i)
                    self.assertEqual(numpy.sum(res - arr[i]), 0)
                else:
                    res = [vtk_arr.GetComponent(i, j) for j in range(dim1)]
                    self.assertEqual(numpy.sum(res - arr[i]), 0)
        else:
            if arr.dtype.char == 'c':
                for i in range(len(arr)):
                    self.assertEqual(chr(int(vtk_arr.GetTuple1(i))), arr[i])
            else:
                for i in range(len(arr)):
                    self.assertEqual(vtk_arr.GetTuple1(i), arr[i])


    def test_array2vtk(self):
        """Test Numeric array to VTK array conversion and vice-versa."""
        # Put all the test arrays here.
        t_z = []

        # Test the different types of arrays.
        t_z.append(numpy.array([-128, 0, 127], numpy.int8))

        # FIXME: character arrays are a problem since there is no
        # unique mapping to a VTK data type and back.
        #t_z.append(numpy.array([-128, 0, 127], numpy.character))
        t_z.append(numpy.array([-32768, 0, 32767], numpy.int16))
        t_z.append(numpy.array([-2147483648, 0, 2147483647], numpy.int32))
        t_z.append(numpy.array([0, 255], numpy.uint8))
        t_z.append(numpy.array([0, 65535], numpy.uint16))
        t_z.append(numpy.array([0, 4294967295L], numpy.uint32))
        t_z.append(numpy.array([-1.0e38, 0, 1.0e38], 'f'))
        t_z.append(numpy.array([-1.0e299, 0, 1.0e299], 'd'))

        # Check multi-component arrays.
        t_z.append(numpy.array([[1], [2], [300]], 'd'))
        t_z.append(numpy.array([[1, 20], [300, 4000]], 'd'))
        t_z.append(numpy.array([[1, 2, 3], [4, 5, 6]], 'f'))
        t_z.append(numpy.array([[1, 2, 3],[4, 5, 6]], 'd'))
        t_z.append(numpy.array([[1, 2, 3, 400],[4, 5, 6, 700]],
                                 'd'))
        t_z.append(numpy.array([range(9),range(10,19)], 'f'))

        # Test if a Python list also works.
        t_z.append(numpy.array([[1., 2., 3., 400.],[4, 5, 6, 700]],
                                 'd'))

        # Test if arrays with number of components not in [1,2,3,4,9] work.
        t_z.append(numpy.array([[1, 2, 3, 400, 5000],
                                  [4, 5, 6, 700, 8000]], 'd'))
        t_z.append(numpy.array([range(10), range(10,20)], 'd'))

        for z in t_z:
            vtk_arr = array_handler.array2vtk(z)
            # Test for memory leaks.
            self.assertEqual(vtk_arr.GetReferenceCount(),
                             array_handler.BASE_REFERENCE_COUNT)
            self._check_arrays(z, vtk_arr)
            z1 = array_handler.vtk2array(vtk_arr)
            if len(z.shape) == 1:
                self.assertEqual(len(z1.shape), 1)
            if z.dtype.char != 'c':
                #print z1
                self.assertEqual(sum(numpy.ravel(z) - numpy.ravel(z1)), 0)
            else:
                #print z1.astype('c')
                self.assertEqual(z, z1.astype('c'))

        # Check if type conversion works correctly.
        z = numpy.array([-128, 0, 127], numpy.int8)
        vtk_arr = vtk.vtkDoubleArray()
        ident = id(vtk_arr)
        vtk_arr = array_handler.array2vtk(z, vtk_arr)
        # Make sure this is the same array!
        self.assertEqual(ident, id(vtk_arr))
        self._check_arrays(z, vtk_arr)

        # Check the vtkBitArray.
        vtk_arr = vtk.vtkBitArray()
        vtk_arr.InsertNextValue(0)
        vtk_arr.InsertNextValue(1)
        vtk_arr.InsertNextValue(0)
        vtk_arr.InsertNextValue(1)
        arr = array_handler.vtk2array(vtk_arr)
        self.assertEqual(numpy.sum(arr - [0,1,0,1]), 0)
        vtk_arr = array_handler.array2vtk(arr, vtk_arr)
        self.assertEqual(vtk_arr.GetValue(0), 0)
        self.assertEqual(vtk_arr.GetValue(1), 1)
        self.assertEqual(vtk_arr.GetValue(2), 0)
        self.assertEqual(vtk_arr.GetValue(3), 1)

        # ----------------------------------------
        # Test if the array is copied or not.
        a = numpy.array([[1, 2, 3],[4, 5, 6]], 'd')
        vtk_arr = array_handler.array2vtk(a)
        # Change the numpy array and see if the changes are
        # reflected in the VTK array.
        a[0] = [10.0, 20.0, 30.0]
        self.assertEqual(vtk_arr.GetTuple3(0), (10., 20., 30.))

        # Make sure the cache is doing its job.
        key = vtk_arr.__this__
        z = array_handler._array_cache.get(vtk_arr)
        self.assertEqual(numpy.sum(z - numpy.ravel(a)), 0.0)

        l1 = len(array_handler._array_cache)
        # del the Numeric array and see if this still works.
        del a
        self.assertEqual(vtk_arr.GetTuple3(0), (10., 20., 30.))
        # Check the cache -- just making sure.
        self.assertEqual(len(array_handler._array_cache), l1)

        # Delete the VTK array and see if the cache is cleared.
        del vtk_arr
        self.assertEqual(len(array_handler._array_cache), l1-1)
        self.assertEqual(array_handler._array_cache._cache.has_key(key),
                         False)

        # Make sure bit arrays are copied.
        vtk_arr = vtk.vtkBitArray()
        a = numpy.array([0,1,0,1], numpy.int32)
        vtk_arr = array_handler.array2vtk(a, vtk_arr)
        del a
        self.assertEqual(vtk_arr.GetValue(0), 0)
        self.assertEqual(vtk_arr.GetValue(1), 1)
        self.assertEqual(vtk_arr.GetValue(2), 0)
        self.assertEqual(vtk_arr.GetValue(3), 1)

        # Make sure the code at least runs for all the non-complex
        # numerical dtypes in numpy.
        for dtype in (numpy.sctypes['int'] + numpy.sctypes['uint'] +
                            numpy.sctypes['float']):
            array_handler.array2vtk(numpy.zeros((1,), dtype=dtype))


    def test_arr2cell_array(self):
        """Test Numeric array to vtkCellArray conversion."""
        # Test list of lists.
        a = [[0], [1, 2], [3, 4, 5], [6, 7, 8, 9]]
        cells = array_handler.array2vtkCellArray(a)
        z = numpy.array([1, 0, 2, 1,2, 3, 3,4,5, 4, 6,7,8,9])
        arr = array_handler.vtk2array(cells.GetData())
        self.assertEqual(numpy.sum(arr - z), 0)
        self.assertEqual(len(arr.shape), 1)
        self.assertEqual(len(arr), 14)

        # Test if optional argument stuff also works.
        cells = vtk.vtkCellArray()
        ident = id(cells)
        cells = array_handler.array2vtkCellArray(a, cells)
        self.assertEqual(id(cells), ident)
        arr = array_handler.vtk2array(cells.GetData())
        self.assertEqual(numpy.sum(arr - z), 0)
        self.assertEqual(cells.GetNumberOfCells(), 4)

        # Make sure this resets the cell array and does not add to the
        # existing list!
        cells = array_handler.array2vtkCellArray(a, cells)
        self.assertEqual(cells.GetNumberOfCells(), 4)

        # Test Numeric array handling.
        N = 3
        a = numpy.zeros((N,3), numpy.int)
        a[:,1] = 1
        a[:,2] = 2
        cells = array_handler.array2vtkCellArray(a)
        arr = array_handler.vtk2array(cells.GetData())
        expect = numpy.array([3, 0, 1, 2]*3, numpy.int)
        self.assertEqual(numpy.alltrue(numpy.equal(arr, expect)),
                         True)
        self.assertEqual(cells.GetNumberOfCells(), N)

        # Test if a list of Numeric arrays of different cell lengths works.
        l_a = [a[:,:1], a, a[:2,:2]]
        cells = array_handler.array2vtkCellArray(l_a)
        arr = array_handler.vtk2array(cells.GetData())
        expect = numpy.array([1, 0]*3 + [3, 0, 1, 2]*3 + [2, 0,1]*2, numpy.int)
        self.assertEqual(numpy.alltrue(numpy.equal(arr, expect)),
                         True)
        self.assertEqual(cells.GetNumberOfCells(), N*2 + 2)

        # This should not take a long while.  This merely tests if a
        # million cells can be created rapidly.
        N = int(1e6)
        a = numpy.zeros((N,3), numpy.int)
        a[:,1] = 1
        a[:,2] = 2
        cells = array_handler.array2vtkCellArray(a)
        self.assertEqual(cells.GetNumberOfCells(), N)

    def test_arr2vtkPoints(self):
        """Test Numeric array to vtkPoints conversion."""
        a = [[0.0, 0.0, 0.0], [1.0, 1.0, 1.0]]
        p = array_handler.array2vtkPoints(a)
        self.assertEqual(p.GetPoint(0), (0.0, 0.0, 0.0))
        self.assertEqual(p.GetPoint(1), (1.0, 1.0, 1.0))
        p = vtk.vtkPoints()
        ident = id(p)
        p = array_handler.array2vtkPoints(numpy.array(a), p)
        self.assertEqual(p.GetPoint(0), (0.0, 0.0, 0.0))
        self.assertEqual(p.GetPoint(1), (1.0, 1.0, 1.0))
        self.assertEqual(id(p), ident)
        self.assertRaises(AssertionError, array_handler.array2vtkPoints,
                          [0.0, 1.0])
        self.assertRaises(AssertionError, array_handler.array2vtkPoints,
                          [0.0, 1.0, 1.0])


    def test_arr2vtkIdList(self):
        """Test array to vtkIdList conversion."""
        a = [1, 2, 3, 4, 5]
        p = array_handler.array2vtkIdList(a)
        for i, j in enumerate(a):
            self.assertEqual(p.GetId(i), j)
        p = vtk.vtkIdList()
        ident = id(p)
        p = array_handler.array2vtkIdList(numpy.array(a), p)
        for i, j in enumerate(a):
            self.assertEqual(p.GetId(i), j)
        self.assertEqual(id(p), ident)

        self.assertRaises(AssertionError, array_handler.array2vtkIdList,
                          [[1,2,3]])

    def test_get_correct_sig(self):
        """Test multiple signature cases that have array arguments."""
        obj = tvtk_base.TVTKBase(vtk.vtkIdTypeArray)
        sigs = [ None,
                 [['vtkDataArray']],
                 [['int', 'vtkIdList']],
                 [['int', 'vtkPoints'], ['int', 'int']],
                 [['int', 'vtkPoints'], ['int']],
                 [['int'], ['int', 'vtkPoints']],
                 [['int', 'vtkDataArray'], ['int', 'int']],
                 [['int', 'vtkDataArray'], ['int', 'int']],
                 [['vtkIdList', 'vtkCellArray'], ['int', 'vtkPoints'],
                  ['int', 'vtkDataArray']],
                 [['vtkIdList', 'vtkCellArray'], ['int', 'vtkPoints'],
                  ['int', 'vtkDataArray']],
                 [['vtkIdTypeArray', 'vtkCellArray'], ['int', 'vtkPoints'],
                  ['int', 'vtkDataArray']],
                 [['vtkIdTypeArray', 'vtkCellArray'], ['int', 'vtkPoints'],
                  ['int', 'vtkDataArray']],
                 [['vtkIdTypeArray', 'vtkCellArray'], ['int', 'vtkPoints'],
                  ['int', ('float', 'float', 'float')]],
                 ]
        args = [ [1], # No sig info.
                 ['foo'], # One sig.
                 [1], # One sig.
                 [1], # Error
                 [1], # Only one valid sig.
                 [1,[1,1,1]], # Only one valid sig.
                 [1, [1,1,1]], # Multiple valid sigs.
                 [1,1], # No arrays!
                 [1,1], # No match so returns None.
                 [1, [1,1,1]], # ambiguous, pick first match.
                 [numpy.array([1,1]), [1,1,1]], # Match!
                 [obj, [2,1,2,3]], # TVTK array object, match.
                 [[2,1,2,3], obj], # TVTK array object, match but has
                                   # wrong argument. Should be caught
                                   # by VTK.
                 ]
        res = [ None,
                ['vtkDataArray'],
                ['int', 'vtkIdList'],
                TypeError,
                ['int'],
                ['int', 'vtkPoints'],
                ['int', 'vtkDataArray'],
                None,
                None,
                ['int', 'vtkPoints'],
                ['vtkIdTypeArray', 'vtkCellArray'],
                ['vtkIdTypeArray', 'vtkCellArray'],
                ['vtkIdTypeArray', 'vtkCellArray'],
                ]
        for i in range(len(sigs)):
            if res[i] is TypeError:
                self.assertRaises(res[i], array_handler.get_correct_sig,
                                  args[i], sigs[i])
            else:
                s = array_handler.get_correct_sig(args[i], sigs[i])
                #print s, res[i]
                self.assertEqual(s, res[i])

    def test_deref_array(self):
        """Test if dereferencing array args works correctly."""
        sigs = [[['vtkDataArray']],
                [['vtkFloatArray']],
                [['vtkCellArray']],
                [['vtkPoints']],
                [['int', 'vtkIdList']],
                [['int', ('float', 'float'), 'vtkDataArray']],
                [['Prop', 'int', 'vtkDataArray']],
                [['Points', ('float', 'float', 'float')]]
                ]
        args = [[[1,2,3]],
                [[0,0,0]],
                [[[1,2,3],[4,5,6]]],
                [[[0.,0.,0.], [1.,1.,1.]]],
                [1, [1,2,3]],
                [1, (0.0, 0.0), [1.0, 1.0, 1.0]],
                [Prop(), 1, numpy.array([1.0, 1.0, 1.0])],
                [[[1,2,3]], [1,2,3]]
                ]
        r = array_handler.deref_array(args[0], sigs[0])
        self.assertEqual(mysum(array_handler.vtk2array(r[0]) -args[0]), 0)
        r = array_handler.deref_array(args[1], sigs[1])
        self.assertEqual(mysum(array_handler.vtk2array(r[0]) - args[1]), 0)

        r = array_handler.deref_array(args[2], sigs[2])
        self.assertEqual(r[0].GetNumberOfCells(), 2)

        r = array_handler.deref_array(args[3], sigs[3])
        self.assertEqual(mysum(array_handler.vtk2array(r[0].GetData()) -
                                     numpy.array(args[3], 'f')), 0)

        r = array_handler.deref_array(args[4], sigs[4])
        self.assertEqual(r[0], 1)
        self.assertEqual(r[1].__class__.__name__, 'vtkIdList')

        r = array_handler.deref_array(args[5], sigs[5])
        self.assertEqual(r[0], 1)
        self.assertEqual(r[1], (0.0, 0.0))
        self.assertEqual(mysum(array_handler.vtk2array(r[2]) -args[5][2]), 0)

        r = array_handler.deref_array(args[6], sigs[6])
        self.assertEqual(r[0].IsA('vtkProperty'), True)
        self.assertEqual(r[1], 1)
        self.assertEqual(mysum(array_handler.vtk2array(r[2]) -args[6][2]), 0)

        r = array_handler.deref_array(args[7], sigs[7])

    def test_reference_to_array(self):
        """Does to_array return an existing array instead of a new copy."""
        arr = numpy.arange(0.0, 10.0, 0.1)
        arr  = numpy.reshape(arr, (25, 4))
        vtk_arr = array_handler.array2vtk(arr)
        arr1 = array_handler.vtk2array(vtk_arr)
        # Now make sure these are using the same memory.
        arr[0][0] = 100.0
        self.assertEqual(arr[0][0], arr1[0][0])
        self.assertEqual(arr.shape, arr1.shape)

    def test_array_cache(self):
        """Test the ArrayCache class."""
        cache = array_handler.ArrayCache()
        # Test if len works.
        self.assertEqual(len(cache), 0)
        arr = numpy.zeros(100, float)
        varr = vtk.vtkFloatArray()
        # test contains
        self.assertEqual(varr not in cache, True)
        cache.add(varr, arr)
        self.assertEqual(len(cache), 1)
        self.assertEqual(varr in cache, True)

        # Test the get method.
        self.assertEqual(cache.get(varr) is arr, True)

        # Test if the cache is cleared when the array is deleted.
        del varr
        self.assertEqual(len(cache), 0)

    def test_id_array(self):
        """Test if a vtkIdTypeArray is converted correctly."""
        arr = vtk.vtkIdTypeArray()
        arr.SetNumberOfTuples(10)
        for i in range(10):
            arr.SetValue(i, i)

        np = array_handler.vtk2array(arr)
        self.assertEqual(numpy.all(np == range(10)), True)


if __name__ == "__main__":
    unittest.main()

########NEW FILE########
__FILENAME__ = test_class_tree
# Author: Prabhu Ramachandran
# License: BSD style
# Copyright (c) 2004, Enthought, Inc.

"""Tests class_tree.py.  Uses the vtk module to test the code.  Also
tests if the tree generation works for the __builtin__ module.

"""

import unittest
from tvtk import class_tree

import vtk
import __builtin__

# This computation can be expensive, so we cache it.
_cache = class_tree.ClassTree(vtk)
_cache.create()

vtk_major_version = vtk.vtkVersion.GetVTKMajorVersion()

def get_level(klass):
    """Gets the inheritance level of a given class."""
    if not klass.__bases__:
        return 0
    else:
        return max([get_level(b) for b in klass.__bases__]) + 1


class TestClassTree(unittest.TestCase):
    def setUp(self):
        self.t = _cache

    def test_basic_vtk(self):
        """Basic tests for the VTK module."""
        t = self.t
        self.assertEqual(t.get_node('vtkObject').name, 'vtkObject')
        self.assertEqual(t.get_node('vtkObject').parents[0].name,
                         'vtkObjectBase')
        if (hasattr(vtk, 'vtkTuple')):
            names = [x.name for x in t.tree[0]]
            names.sort()
            if vtk_major_version < 6:
                self.assertEqual(len(t.tree[0]), 12)
                expect = ['object', 'vtkColor3', 'vtkColor4', 'vtkDenseArray',
                          'vtkObjectBase', 'vtkRect',
                          'vtkSparseArray', 'vtkTuple',
                          'vtkTypedArray', 'vtkVector', 'vtkVector2',
                          'vtkVector3']
            else:
                self.assertEqual(len(t.tree[0]), 13)
                expect = ['object', 'vtkColor3', 'vtkColor4', 'vtkDenseArray',
                          'vtkObjectBase', 'vtkQuaternion', 'vtkRect',
                          'vtkSparseArray', 'vtkTuple',
                          'vtkTypedArray', 'vtkVector', 'vtkVector2',
                          'vtkVector3']
            self.assertEqual(names, expect)
        elif (hasattr(vtk, 'vtkVector')):
            self.assertEqual(len(t.tree[0]), 11)
            names = [x.name for x in t.tree[0]]
            names.sort()
            expect = ['object', 'vtkColor3', 'vtkColor4', 'vtkDenseArray',
                      'vtkObjectBase', 'vtkRect', 'vtkSparseArray',
                      'vtkTypedArray', 'vtkVector', 'vtkVector2',
                      'vtkVector3']
            self.assertEqual(names, expect)
        elif (hasattr(vtk, 'vtkArrayCoordinates')
                        and issubclass(vtk.vtkArrayCoordinates, object)):
            self.assertEqual(len(t.tree[0]), 2)
            names = [x.name for x in t.tree[0]]
            names.sort()
            self.assertEqual(names, ['object', 'vtkObjectBase'])
        else:
            self.assertEqual(len(t.tree[0]), 1)
            self.assertEqual(t.tree[0][0].name, 'vtkObjectBase')

    def test_ancestors(self):
        """Check if get_ancestors is OK."""

        # The parent child information is already tested so this test
        # needs to ensure that the method works for a few known
        # examples.

        # Simple VTK test.
        t = self.t
        n = t.get_node('vtkDataArray')
        x = vtk.vtkDataArray
        ancestors = []
        while x.__name__ != 'vtkObjectBase':
            x = x.__bases__[0]
            ancestors.append(x.__name__)
        self.assertEqual([x.name for x in n.get_ancestors()], ancestors)

        # Simple __builtin__ test.
        t = class_tree.ClassTree(__builtin__)
        t.create()
        n = t.get_node('TabError')
        bases = ['IndentationError', 'SyntaxError',
                 'StandardError', 'Exception']
        if len(Exception.__bases__) > 0:
            bases.extend(['BaseException', 'object'])
        self.assertEqual([x.name for x in n.get_ancestors()],
                         bases)

    def test_parent_child(self):
        """Check if the node's parent and children are correct."""
        t = self.t

        for node in t:
            n_class = t.get_class(node.name)
            base_names = [x.__name__ for x in n_class.__bases__]
            base_names.sort()
            parent_names = [x.name for x in node.parents]
            parent_names.sort()
            self.assertEqual(base_names, parent_names)

            for c in node.children:
                c_class = t.get_class(c.name)
                base_names = [x.__name__ for x in c_class.__bases__]
                self.assertEqual(node.name in base_names, True)

    def test_level(self):
        """Check the node levels."""
        t = self.t
        for node in t:
            self.assertEqual(get_level(t.get_class(node.name)), node.level)

    def test_tree(self):
        """Check the tree structure."""
        t = self.t
        n = sum([len(x) for x in t.tree])
        self.assertEqual(n, len(t.nodes))

        for level, nodes in enumerate(t.tree):
            for n in nodes:
                self.assertEqual(n.level, level)

    def test_builtin(self):
        """Check if tree structure for __builtin__ works."""

        # This tests to see if the tree structure generation works for
        # the __builtin__ module.
        t = class_tree.ClassTree(__builtin__)
        t.create()
        self.t = t
        self.test_parent_child()
        self.test_level()
        self.test_tree()


if __name__ == "__main__":
    unittest.main()

########NEW FILE########
__FILENAME__ = test_ctf_util
"""Simple tests for the color transfer function utilities in tvtk."""

import unittest

from tvtk.util.ctf import (load_ctfs, save_ctfs, \
        rescale_ctfs, ColorTransferFunction, PiecewiseFunction)
from tvtk.api import tvtk


def make_volume_prop(mins=255, maxs=355):
    """Make a volume property for the testing."""
    table = tvtk.VolumeProperty()
    ctf = ColorTransferFunction()
    ds = (maxs-mins)/4.0
    try:
        ctf.range = (mins, maxs)
    except Exception:
        # VTK versions < 5.2 don't seem to need this.
        pass
    ctf.add_rgb_point(mins,      0.00, 0.0, 1.00)
    ctf.add_rgb_point(mins+ds,   0.25, 0.5, 0.75)
    ctf.add_rgb_point(mins+2*ds, 0.50, 1.0, 0.50)
    ctf.add_rgb_point(mins+3*ds, 0.75, 0.5, 0.25)
    ctf.add_rgb_point(maxs,      1.00, 0.0, 0.00)
    otf = PiecewiseFunction()
    otf.add_point(mins, 0.0)
    otf.add_point(maxs, 0.2)
    table.set_color(ctf)
    table.set_scalar_opacity(otf)
    return table, ctf, otf


################################################################################
# `TestCTFUtil` class.
################################################################################
class TestCTFUtil(unittest.TestCase):
    def setUp(self):
        """Called before every test is run."""
        vp, ctf, otf = make_volume_prop()
        self.vp = vp
        self.ctf = ctf
        self.otf = otf

    def tearDown(self):
        """Called after the test is run."""
        return

    def test_save_load_ctf(self):
        """Test saving and loading of a CTF."""
        # Create a default ctf, save it.
        data = save_ctfs(self.vp)
        # load it into another volume property,
        mvp = tvtk.VolumeProperty()
        ctf = load_ctfs(data, mvp)
        # get the data from the new one
        mdata = save_ctfs(mvp)
        # check that both the data are identical.
        self.assertEqual(mdata, data)

    def test_rescale_ctf(self):
        """Test rescaling a CTF."""
        # Expected data.
        evp, ectf, eotf = make_volume_prop(0.0, 1.0)
        edata = save_ctfs(evp)
        # Rescaled data.
        ctf, otf = rescale_ctfs(self.vp, (0.0, 1.0))
        data = save_ctfs(self.vp)
        # check that both the data are identical.
        self.assertEqual(edata, data)


if __name__ == '__main__':
    unittest.main()


########NEW FILE########
__FILENAME__ = test_indenter
"""Tests for indenter.py."""

# Author: Prabhu Ramachandran
# License: BSD style
# Copyright (c) 2004, Enthought, Inc.

import unittest
import cStringIO

from tvtk import indenter


class TestIndent(unittest.TestCase):
    def test_basic(self):
        """Simple tests for indenter."""
        id = indenter.Indent()
        self.assertEqual(str(id), '')
        id.incr()
        self.assertEqual(str(id), '    ')
        id.incr()
        self.assertEqual(str(id), '        ')
        id.decr()
        self.assertEqual(str(id), '    ')
        id.decr()
        self.assertEqual(str(id), '')
        id.incr(); id.incr()
        id.reset()
        self.assertEqual(str(id), '')

    def test_format(self):
        """Tests if formatting works ok."""
        id = indenter.Indent()
        id.incr()
        # test one liner with trailing newlines
        txt = """class foo:\n\n   \n   \n"""
        t1 = id.format(txt)
        self.assertEqual(t1, '    class foo:\n')
        # test one liner with no trailing newline.
        txt = """class foo:"""
        t1 = id.format(txt)
        self.assertEqual(t1, '    class foo:\n')

        # test multi-line text.
        txt = """print "hi!"
        if name == 'hi':
            print "hi, hi!"
        """
        res = """    print "hi!"\n    if name == 'hi':\n        print "hi, hi!"\n"""
        self.assertEqual(id.format(txt), res)

        txt = """
        class Foo:
            def __init__(self):
                pass
            def _get_a(self):
                return self._a"""
        res = """    class Foo:
        def __init__(self):
            pass
        def _get_a(self):
            return self._a""" + '\n'
        self.assertEqual(id.format(txt), res)


class TestVTKDocMassager(unittest.TestCase):
    def test_doc_massage(self):
        """Test massage method."""
        doc = "This is a test.  All VTK classes and vtk classes\n"\
              "are named like this: vtkActor, vtkLODProperty,\n"\
              "vtkXMLDataReader, vtk3DSImporter etc.  The methods \n"\
              "of a VTK object are like GetData, GetOutput, \n"\
              "SetRepresentationToWireframe.  Ivars are named like\n"\
              "SpecularColor, Write3DPropsAsRasterImage etc."
        ret = "This is a test.  All VTK classes and vtk classes\n"\
              "are named like this: Actor, LODProperty,\n"\
              "XMLDataReader, ThreeDSImporter etc.  The methods \n"\
              "of a VTK object are like get_data, get_output, \n"\
              "set_representation_to_wireframe.  Ivars are named like\n"\
              "specular_color, write3d_props_as_raster_image etc."
        dm = indenter.VTKDocMassager()
        self.assertEqual(dm.massage(doc), ret)

    def test_rename_class(self):
        """Test if VTK classes are renamed correctly."""
        dm = indenter.VTKDocMassager()
        t = 'vtkFooBar vtkXMLDataReader vtk3DSReader vtk2000Bug'
        r = dm._rename_class(t)
        correct = 'FooBar XMLDataReader ThreeDSReader Two000Bug'
        self.assertEqual(r, correct)

    def test_remove_sig(self):
        """Test if function signature is removed correctly."""
        dm = indenter.VTKDocMassager()
        t = 'V.GetOutput(int) -> vtkStructuredPoints\n'\
            'C++: vtkStructuredPoints *GetOutput (int idx);\n'\
            'V.GetOutput() -> vtkStructuredPoints\n'\
            'C++: vtkStructuredPoints *GetOutput ();\n\n'\
            ' Set/Get the output of this reader.\n'
        r = dm._remove_sig(t)
        correct = ' Set/Get the output of this reader.\n'
        self.assertEqual(r, correct)
        t = 'V.GetOutput(int) -> vtkStructuredPoints\n'\
            'C++: vtkStructuredPoints *GetOutput (int idx);\n'\
            'V.GetOutput() -> vtkStructuredPoints\n'\
            'C++: vtkStructuredPoints *GetOutput ();\n\n'
        r = dm._remove_sig(t)
        correct = ''
        self.assertEqual(r, correct)

    def test_class_doc(self):
        """Test if class docs are generated correctly."""
        dm = indenter.VTKDocMassager()
        indent = indenter.Indent()
        out = cStringIO.StringIO()
        doc = "vtkLODProperty, vtkXMLDataReader, vtk3DSImporter\n"\
              "SetRepresentationToWireframe, Write3DPropsAsRasterImage"
        dm.write_class_doc(doc, out, indent)
        out.seek(0)
        ret = out.read()
        correct = '''    """
    LODProperty, XMLDataReader, ThreeDSImporter
    set_representation_to_wireframe, write3d_props_as_raster_image
    """\n'''
        #print ret
        #print correct
        self.assertEqual(ret, correct)

        # Test empty doc
        out = cStringIO.StringIO()
        doc = ""
        dm.write_class_doc(doc, out, indent)
        out.seek(0)
        ret = out.read()
        self.assertEqual(ret, '    """\n    \n    """\n')

    def test_trait_doc(self):
        """Test if trait docs are generated correctly."""
        dm = indenter.VTKDocMassager()
        indent = indenter.Indent()
        out = cStringIO.StringIO()
        doc = 'V.GetOutput(int) -> vtkStructuredPoints\n'\
              'C++: vtkStructuredPoints *GetOutput (int idx);\n'\
              'V.GetOutput() -> vtkStructuredPoints\n'\
              'C++: vtkStructuredPoints *GetOutput ();\n\n'\
              'vtkLODProperty, vtkXMLDataReader, vtk3DSImporter\n'\
              'SetRepresentationToWireframe, Write3DPropsAsRasterImage'
        dm.write_trait_doc(doc, out, indent)
        out.seek(0)
        ret = out.read()
        correct = '''    """
    LODProperty, XMLDataReader, ThreeDSImporter
    set_representation_to_wireframe, write3d_props_as_raster_image
    """\n'''
        #print ret
        #print correct
        self.assertEqual(ret, correct)

        # Test empty doc.
        out = cStringIO.StringIO()
        doc = 'V.GetOutput(int) -> vtkStructuredPoints\n'\
              'C++: vtkStructuredPoints *GetOutput (int idx);\n'\
              'V.GetOutput() -> vtkStructuredPoints\n'\
              'C++: vtkStructuredPoints *GetOutput ();\n\n'
        dm.write_trait_doc(doc, out, indent)
        out.seek(0)
        ret = out.read()
        self.assertEqual(ret, '    """\n    \n    """\n')

    def test_method_doc(self):
        """Test if method docs are generated correctly."""
        dm = indenter.VTKDocMassager()
        indent = indenter.Indent()
        out = cStringIO.StringIO()
        doc = 'V.GetOutput(int) -> vtkStructuredPoints\n'\
              'C++: vtkStructuredPoints *GetOutput (int idx);\n'\
              'V.GetOutput() -> vtkStructuredPoints\n'\
              'C++: vtkStructuredPoints *GetOutput ();\n\n'\
              'vtkLODProperty, vtkXMLDataReader, vtk3DSImporter\n'\
              'SetRepresentationToWireframe, Write3DPropsAsRasterImage'
        dm.write_method_doc(doc, out, indent)
        out.seek(0)
        ret = out.read()
        correct = '''    """
    V.get_output(int) -> StructuredPoints
    V.get_output() -> StructuredPoints

    LODProperty, XMLDataReader, ThreeDSImporter
    set_representation_to_wireframe, write3d_props_as_raster_image
    """\n'''
        #print ret
        #print correct
        self.assertEqual(ret, correct)

        # Test empty doc.
        out = cStringIO.StringIO()
        doc = 'V.GetOutput(int) -> vtkStructuredPoints\n'\
              'C++: vtkStructuredPoints *GetOutput (int idx);\n'\
              'V.GetOutput() -> vtkStructuredPoints\n'\
              'C++: vtkStructuredPoints *GetOutput ();\n\n'
        dm.write_method_doc(doc, out, indent)
        out.seek(0)
        ret = out.read()
        correct = '''    """
    V.get_output(int) -> StructuredPoints
    V.get_output() -> StructuredPoints
    """\n'''
        #print ret
        #print correct
        self.assertEqual(ret, correct)


    def test_get_method_doc(self):
        """Test if get_method_doc works correctly."""
        dm = indenter.VTKDocMassager()
        doc = 'V.GetOutput(int) -> vtkStructuredPoints\n'\
              'C++: vtkStructuredPoints *GetOutput (int idx);\n'\
              'V.GetOutput() -> vtkStructuredPoints\n'\
              'C++: vtkStructuredPoints *GetOutput ();\n\n'\
              'vtkLODProperty, vtkXMLDataReader, vtk3DSImporter\n'\
              'SetRepresentationToWireframe, Write3DPropsAsRasterImage'
        ret = dm.get_method_doc(doc)
        correct = 'V.get_output(int) -> StructuredPoints\n'\
                  'V.get_output() -> StructuredPoints\n\n'\
                  'LODProperty, XMLDataReader, ThreeDSImporter\n'\
                  'set_representation_to_wireframe, '\
                  'write3d_props_as_raster_image'
        #print ret
        #print correct
        self.assertEqual(ret, correct)

        # Test empty doc (only signature exists).
        doc = 'V.GetOutput(int) -> vtkStructuredPoints\n'\
              'C++: vtkStructuredPoints *GetOutput (int idx);\n'\
              'V.GetOutput() -> vtkStructuredPoints\n'\
              'C++: vtkStructuredPoints *GetOutput ();\n\n'
        ret = dm.get_method_doc(doc)
        correct = 'V.get_output(int) -> StructuredPoints\n'\
                  'V.get_output() -> StructuredPoints\n'
        self.assertEqual(ret, correct)


if __name__ == "__main__":
    unittest.main()

########NEW FILE########
__FILENAME__ = test_messenger
"""Tests for messenger.py

"""
# Author: Prabhu Ramachandran
# Copyright (c) 2004,  Enthought, Inc.
# License: BSD Style.

import unittest

from tvtk import messenger

#################################################################
# Support code.
#################################################################

class A:
    def __init__(self):
        self.event = None
        self.args = None
        self.kw = None
        self.did_catch_all = 0

    def callback(self, obj, event, *args, **kw):
        self.event = event
        self.args = args
        self.kw = kw

    def catch_all_cb(self, obj, event, *args, **kw):
        self.did_catch_all = 1

ret = None

def callback(obj, event, *args, **kw):
    global ret
    ret  = event, args, kw

class B:
    def __init__(self):
        self.a = A()
        messenger.connect(self, 'method', self.a.callback)
        messenger.connect(self, 'function', callback)
    def __del__(self):
        messenger.disconnect(self)

    def send(self, *args, **kw):
        messenger.send(self, 'method', *args, **kw)
        messenger.send(self, 'function', *args, **kw)


#################################################################
# The test case.
#################################################################

class TestMessenger(unittest.TestCase):
    def test_basic(self):
        """Test basic functionality of the messenger."""
        m = messenger.Messenger()
        orig_len = len(m._signals)
        b = B()
        b.send(1, test=1)
        self.assertEqual(b.a.event, 'method')
        self.assertEqual(ret[0], 'function')
        self.assertEqual(b.a.args, (1,))
        self.assertEqual(ret[1], (1,))
        self.assertEqual(b.a.kw, {'test':1})
        self.assertEqual(ret[2], {'test':1})
        # Ensures that disconnect works and also that there are no
        # reference cycles.
        self.assertEqual(len(m._signals) > orig_len, True)
        del b
        self.assertEqual(len(m._signals), orig_len)

    def test_reload(self):
        """Tests if module is reload safe."""
        b = B()
        m = messenger.Messenger()
        orig_len = len(m._signals)
        reload(messenger)
        m = messenger.Messenger()
        self.assertEqual(len(m._signals), orig_len)
        b.send(1, test=1)
        self.assertEqual(b.a.event, 'method')
        self.assertEqual(ret[0], 'function')
        self.assertEqual(b.a.args, (1,))
        self.assertEqual(ret[1], (1,))
        self.assertEqual(b.a.kw, {'test':1})
        self.assertEqual(ret[2], {'test':1})

    def test_catchall(self):
        """Tests if catch all handlers are called."""
        b = B()
        b.send()
        self.assertEqual(b.a.event, 'method')
        self.assertEqual(b.a.args, ())
        self.assertEqual(b.a.kw, {})
        self.assertEqual(b.a.did_catch_all, 0)
        messenger.connect(b, 'AnyEvent', b.a.catch_all_cb)
        b.send(1, test=1)
        self.assertEqual(b.a.event, 'method')
        self.assertEqual(b.a.args, (1,))
        self.assertEqual(b.a.kw, {'test':1})
        self.assertEqual(b.a.did_catch_all, 1)
        b.a.did_catch_all = 0
        messenger.disconnect(b, 'AnyEvent')
        b.send(1, test=1)
        self.assertEqual(b.a.did_catch_all, 0)

    def test_disconnect(self):
        """Tests if disconnection works correctly."""
        global ret
        ret = None
        b = B()
        messenger.disconnect(b)
        b.send(1, test=1)
        self.assertEqual(b.a.event, None)
        self.assertEqual(b.a.args, None)
        self.assertEqual(b.a.kw, None)
        self.assertEqual(b.a.did_catch_all, 0)
        self.assertEqual(ret, None)

    def test_send_on_dead_ref(self):
        """Test if sending to a gc'd callback works gracefully."""
        class C:
            def foo(self, o, e):
                pass
        c = C()
        c1 = C()
        messenger.connect(c1, 'foo', c.foo)
        messenger.send(c1, 'foo')

        # Test if things behave sanely if a message was sent and one
        # of the callbacks has been gc'd.
        m = messenger.Messenger()
        l1 = len(m._signals[hash(c1)]['foo'])
        #
        del c
        messenger.send(c1, 'foo')
        #
        l2 = len(m._signals[hash(c1)]['foo'])
        # Since 'c' is gc'd this callback should have been cleared
        # out.
        self.assertEqual(l2, l1 - 1)

        # Clean up.
        messenger.disconnect(c1)


if __name__ == "__main__":
    unittest.main()

########NEW FILE########
__FILENAME__ = test_misc
"""
Tests for enthought/tvtk/misc.py
"""
# Author: Prabhu Ramachandran <prabhu@aero.iitb.ac.in>
# Copyright (c) 2008, Enthought, Inc.
# License: BSD Style.

import unittest
import tempfile
import os.path
import os

from tvtk.api import tvtk, write_data

class TestMisc(unittest.TestCase):
    def setUp(self):

        datasets = [tvtk.ImageData(),
                    tvtk.StructuredPoints(),
                    tvtk.RectilinearGrid(),
                    tvtk.StructuredGrid(),
                    tvtk.PolyData(),
                    tvtk.UnstructuredGrid(),
                    ]
        exts = ['.vti', '.vti', '.vtr', '.vts', '.vtp', '.vtu']
        self.datasets = datasets
        self.exts = exts

    def test_write_data_xml_noext(self):
        "XML file writing without extensions"
        # Check if write_data writes out XML files with the correct
        # extension when none is specified.

        datasets = self.datasets
        exts = self.exts

        for d, ext in zip(datasets, exts):
            fh, fname = tempfile.mkstemp(ext)
            fbase = os.path.splitext(fname)[0]
            os.close(fh)
            os.remove(fname)
            write_data(d, fbase)
            self.assertEqual(os.path.exists(fname), True)
            os.remove(fname)

    def test_write_data_xml(self):
        "XML file writing with specified extension"
        datasets = self.datasets

        for d in datasets:
            fh, fname = tempfile.mkstemp('.xml')
            os.close(fh)
            os.remove(fname)
            self.assertEqual(os.path.exists(fname), False)
            write_data(d, fname)
            self.assertEqual(os.path.exists(fname), True)
            os.remove(fname)

    def test_write_data_xml_kwargs(self):
        "XML file writing with extra keyword arguments"
        datasets = self.datasets
        exts = self.exts

        for d, ext in zip(datasets, exts):
            fh, fname = tempfile.mkstemp(ext)
            fbase = os.path.splitext(fname)[0]
            os.close(fh)
            os.remove(fname)
            # Test if passing extra keyword args is supported.
            write_data(d, fbase, compressor=None, data_mode='ascii')
            self.assertEqual(os.path.exists(fname), True)
            os.remove(fname)

    def test_write_data_vtk(self):
        "Old-style VTK file writing with specified extension"
        datasets = self.datasets

        for d in datasets:
            fh, fname = tempfile.mkstemp('.vtk')
            os.close(fh)
            os.remove(fname)
            self.assertEqual(os.path.exists(fname), False)
            write_data(d, fname)
            self.assertEqual(os.path.exists(fname), True)
            r = tvtk.DataSetReader(file_name=fname)
            r.update()
            self.assertEqual(isinstance(r.output, d.__class__), True)
            os.remove(fname)


if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_tvtk
"""Tests for tvtk objects.

Some of these tests are copied from test_tvtk_base.  This is just to
make sure that the generated code works well.

"""
# Author: Prabhu Ramachandran
# Copyright (c) 2004, Enthought, Inc.
# License: BSD Style.

import unittest
import cPickle
import weakref
import vtk
import new
import sys
import gc
import numpy
import vtk

from tvtk import tvtk_base
from tvtk.common import get_tvtk_name, configure_input_data

from traits.api import TraitError

vtk_major_version = vtk.vtkVersion.GetVTKMajorVersion()
vtk_minor_version = vtk.vtkVersion.GetVTKMinorVersion()

try:
    from tvtk.api import tvtk
except ImportError:
    msg = """
You need to build the tvtk_classes.zip file to run this test.
To generate tvtk_classes.zip you must do the following::

  $ cd ../ # This is the enthought/tvtk directory
  $ python code_gen.py
"""
    raise ImportError, msg

# Only used for testing.
from tvtk.tvtk_classes import tvtk_helper

def mysum(arr):
    val = arr
    while type(val) == numpy.ndarray:
        val = numpy.sum(val)
    return val

class TestTVTK(unittest.TestCase):
    def test_wrap_vtk(self):
        """Test if the wrap_vtk function works."""
        o = vtk.vtkVolume()
        w = tvtk_helper.wrap_vtk(o)
        self.assertEqual(w.__class__.__name__, 'Volume')
        w1 = tvtk_helper.wrap_vtk(w)
        self.assertEqual(w, w1)
        del w1, w, o
        class A:
            pass
        a = A()
        w = tvtk_helper.wrap_vtk(a)
        self.assertEqual(a, w)

    def test_cache(self):
        """Test the caching of ancestor classes."""
        # Shut off pesky warnings.
        vtk.vtkObject.GlobalWarningDisplayOff()
        o = tvtk.ImageFFT()
        vtk_ver = vtk.vtkVersion().GetVTKVersion()
        if vtk_ver[:3] in ['4.2', '4.4']:
            cached = ['ImageFourierFilter', 'ImageDecomposeFilter',
                      'ImageIterateFilter', 'ImageToImageFilter',
                      'ImageSource', 'Source', 'ProcessObject',
                      'Object', 'ObjectBase']
        else:
            cached = ['ImageFourierFilter', 'ImageDecomposeFilter',
                      'ImageIterateFilter', 'ThreadedImageAlgorithm',
                      'ImageAlgorithm', 'Algorithm', 'Object',
                      'ObjectBase']

        for i in cached:
            self.assertEqual(tvtk_helper._cache.has_key(i), True)
        vtk.vtkObject.GlobalWarningDisplayOn()

    def test_custom(self):
        """Test if custom modules can be imported."""

        # Hack to simulate a module inside tvtk.custom.
        mod = new.module('xml_data_reader')
        class XMLDataReader:
            def f(self):
                return 'f'
        setattr(mod, 'XMLDataReader', XMLDataReader)
        sys.modules['tvtk.custom.xml_data_reader'] = mod

        # Now test if this is the one imported.
        r = tvtk.XMLDataReader()
        self.assertEqual(r.f(), 'f')
        self.assertEqual(r.__class__.__bases__, ())

        # Clean up.
        del sys.modules['tvtk.custom.xml_data_reader']

    def test_basic(self):
        """Test a simple tvtk pipeline."""
        # If this works without any problems, we are ok.
        cs = tvtk.ConeSource()
        m = tvtk.PolyDataMapper()
        if vtk_major_version < 6:
            m.input = cs.output # This should work
            m.input = cs.get_output() # This should also work.
        else:
            m.input_connection = cs.output_port # This should work.
            m.set_input_data(cs.get_output()) # This should also work.
        a = tvtk.Actor()
        a.mapper = m
        cs.resolution = 36
        p = a.property
        p.representation = 'w'

    def test_do_change(self):
        """Test if VTK object changes when trait is changed."""
        p = tvtk.Property()
        p.edge_visibility = not p.edge_visibility
        p.representation = 'p'
        p.interpolation = 'phong'
        p.opacity = 0.5
        p.color = (0,1,0)
        p.diffuse_color = (1,1,1)
        p.specular_color = (1,1,0)
        for t, g in p._updateable_traits_:
            val = getattr(p._vtk_obj, g)()
            if t in ['representation', 'interpolation']:
                self.assertEqual(val, getattr(p, t + '_'))
            else:
                self.assertEqual(val, getattr(p, t))

    def test_auto_update(self):
        """Test if traits are updated when the VTK object changes."""
        p = tvtk.Property()
        obj = p._vtk_obj
        obj.SetEdgeVisibility(1)
        self.assertEqual(p.edge_visibility, 1)

        obj.SetOpacity(0.5)
        self.assertEqual(p.opacity, 0.5)

        obj.SetRepresentationToPoints()
        self.assertEqual(p.representation, 'points')

        # color traits have been made non updateable
        if vtk_major_version <= 5 and vtk_minor_version < 10:
            val = (1.0, 1.0, 0.0)
            obj.SetColor(val)
            self.assertEqual(p.color, val)

        val = (1.0, 0.0, 0.0)
        obj.SetDiffuseColor(val)
        self.assertEqual(p.diffuse_color, val)

        val = (0.0, 1.0, 0.0)
        obj.SetSpecularColor(val)
        self.assertEqual(p.specular_color, val)

    def test_obj_del(self):
        """Test object deletion and reference cycles."""
        p = tvtk.Property()
        p.representation = 0
        ref = weakref.ref(p)
        del p
        self.assertEqual(ref(), None)

    def test_help_trait(self):
        """Test if the help attribute is correct."""
        n = tvtk.PolyDataNormals()
        t = n.traits()
        test = t['splitting'].help != t['non_manifold_traversal'].help
        self.assertEqual(test, True)

    def test_object_cache(self):
        """Test if object cache works."""
        cs = tvtk.ConeSource()
        hash1 = hash(cs)
        o = cs.output
        if hasattr(o, 'producer_port'):
            src = o.producer_port.producer
        else:
            src = cs.executive.algorithm
        self.assertEqual(src, cs)
        self.assertEqual(hash1, hash(src))
        del cs, src
        gc.collect()
        # The test sometimes fails as VTK seems to generate objects with the
        # same memory address and hash, we try to force it to allocate more
        # objects so as to not end up reusing the same address and hash.
        junk = [vtk.vtkConeSource() for i in range(5)]

        # Now get another ConeSource and ensure the hash is different.
        cs = tvtk.ConeSource()
        o = cs.output
        if hasattr(o, 'producer_port'):
            src = o.producer_port.producer
        else:
            src = cs.executive.algorithm

        self.assertEqual(hash1 != hash(src), True)
        self.assertEqual(hash(cs), hash(src))

        # Test for a bug with collections and the object cache.
        r = tvtk.Renderer()
        def _get_props(obj):
            if hasattr(obj, 'view_props'):
                return obj.view_props
            else:
                return obj.props

        p = _get_props(r)
        l1 = len(tvtk_base._object_cache)
        p1 = _get_props(r)
        del p1
        l2 = len(tvtk_base._object_cache)
        self.assertEqual(l1, l2)


    def test_init_traits(self):
        """Test if the objects traits can be set in __init__."""
        p = tvtk.Property(opacity=0.1, color=(1,0,0), representation='p')
        self.assertEqual(p.opacity, 0.1)
        self.assertEqual(p.color, (1.0, 0.0, 0.0))
        self.assertEqual(p.representation, 'points')

        # Test case where the object traits are wrong.
        self.assertRaises(TraitError, tvtk.Property, foo='bar')

        cs = tvtk.ConeSource(radius=0.1, height=0.5, resolution=32)
        self.assertEqual(cs.radius, 0.1)
        self.assertEqual(cs.height, 0.5)
        self.assertEqual(cs.resolution, 32)

        # Test case where the object traits are wrong.
        self.assertRaises(TraitError, tvtk.ConeSource, foo=1)

    def test_matrix4x4(self):
        """Test if Matrix4x4 works nicely."""
        m = tvtk.Matrix4x4()
        [m.set_element(i, j, i*4 +j) for i in range(4) for j in range(4)]
        s = cPickle.dumps(m)
        del m
        m = cPickle.loads(s)
        for i in range(4):
            for j in range(4):
                self.assertEqual(m.get_element(i, j), i*4 + j)
        # Test the from/to_array functions.
        a = numpy.array(range(16), dtype=float)
        a.shape = 4,4
        m = tvtk.Matrix4x4()
        m.from_array(a)
        b = m.to_array()
        self.assertEqual(numpy.allclose(a, b), True)


    def test_property(self):
        """Test if Property's color works ok in all circumstances."""
        p = tvtk.Property()
        val = (0., 1., 0.)
        p.color = val
        p.specular = 1.0
        self.assertEqual(p.specular_color, val)
        self.assertEqual(p.diffuse_color, val)
        self.assertEqual(p.ambient_color, val)

        sc = (1., 0., 1.)
        p.specular_color = sc
        self.assertEqual(p.specular_color, sc)
        self.assertEqual(p.diffuse_color, val)
        self.assertEqual(p.ambient_color, val)
        self.assertEqual(p.color, (0.5, 0.5, 0.5))

        # Test pickling.
        s = cPickle.dumps(p)
        del p
        p = cPickle.loads(s)
        self.assertEqual(p.specular_color, sc)
        self.assertEqual(p.diffuse_color, val)
        self.assertEqual(p.ambient_color, val)
        self.assertEqual(p.color, (0.5, 0.5, 0.5))

    def test_collection(self):
        """Test if Collection objects work nicely."""
        ac = tvtk.ActorCollection()
        self.assertEqual(len(ac), 0)
        self.assertRaises(IndexError, ac.__getitem__, 0)
        a_list = []
        a = tvtk.Actor()
        a_list.append(a)
        ac.append(a)
        self.assertRaises(TypeError, ac.__getitem__, 's')
        self.assertEqual(len(ac), 1)
        a = tvtk.Actor()
        a_list.append(a)
        ac.append(a)
        self.assertEqual(len(ac), 2)

        # Test iterator nature.
        for i, j in zip(ac, a_list):
            self.assertEqual(i._vtk_obj, j._vtk_obj)
        for i, j in enumerate(ac):
            self.assertEqual(a_list[i]._vtk_obj, j._vtk_obj)

        # Test __setitem__.
        ac[0] = a_list[1]
        ac[1] = a_list[0]
        self.assertEqual(ac[0]._vtk_obj, a_list[1]._vtk_obj)
        self.assertEqual(ac[1]._vtk_obj, a_list[0]._vtk_obj)
        self.assertRaises(TypeError, ac.__setitem__, 's', a_list[1])

        # Test __delitem__.
        del ac[-2]
        self.assertEqual(ac[0]._vtk_obj, a_list[0]._vtk_obj)
        self.assertEqual(len(ac), 1)
        self.assertRaises(TypeError, ac.__delitem__, 1.414)
        del ac[0]
        self.assertEqual(len(ac), 0)

        # Test __repr__.
        self.assertEqual(repr(ac), '[]')

        # test extend.
        ac.extend(a_list)
        self.assertEqual(len(ac), 2)
        for i, j in enumerate(ac):
            self.assertEqual(a_list[i]._vtk_obj, j._vtk_obj)

        # Test the prop collection.
        pc = tvtk.PropCollection()
        a = tvtk.Actor()
        pc.append(a)
        self.assertEqual(pc[0], a)
        for i in pc:
            self.assertEqual(i, a)

    def test_set_scalars(self):
        """Test if SetScalars works without a segfault."""
        mesh = tvtk.PolyData()
        sc = tvtk.FloatArray()
        # If this does not segfault, we are OK.
        mesh.point_data.scalars = sc

    def test_data_array(self):
        """Test if vtkDataArrays behave in a Pythonic fashion."""
        # Check a 3D array.
        f = tvtk.FloatArray()
        a = numpy.array([[0.,0,0],[1,1,1]])
        f.from_array(a)
        self.assertEqual(f.number_of_components, 3)
        self.assertEqual(f.number_of_tuples, 2)
        self.assertEqual(mysum(f.to_array() - a), 0)
        for i, j in zip(a, f):
            self.assertEqual(mysum(i-j), 0.0)
        self.assertEqual(f[0], (0.0, 0.0, 0.0))
        self.assertEqual(f[-1], (1.,1.,1.))
        self.assertEqual(repr(f), '[(0.0, 0.0, 0.0), (1.0, 1.0, 1.0)]')
        f.append((2,2,2))
        f.extend([[3,3,3], [4,4,4]])
        self.assertEqual(len(f), 5)
        self.assertEqual(f.number_of_components, 3)
        self.assertEqual(f.number_of_tuples, 5)
        f[1] = [-1,-1,-1]
        self.assertEqual(f[1], (-1.0, -1.0, -1.0))
        self.assertRaises(IndexError, f.__getitem__, 100)
        self.assertRaises(IndexError, f.__setitem__, 100, 100)

        # Check a 5D arrray
        a = numpy.array([[0.,0,0, 0, 0],[1,1,1, 1, 1]])
        f.from_array(a)
        self.assertEqual(mysum(f.to_array()- a), 0.0)
        for i, j in zip(a, f):
            self.assertEqual(mysum(i - j), 0.0)
        self.assertEqual(f[0], (0.0, 0.0, 0.0, 0.0, 0.0))
        self.assertEqual(f[-1], (1.,1.,1., 1., 1.))
        self.assertEqual(repr(f),
                         '[(0.0, 0.0, 0.0, 0.0, 0.0), (1.0, 1.0, 1.0, 1.0, 1.0)]')
        f.append((2,2,2,2,2))
        f.extend([[3,3,3,3,3], [4,4,4,4,4]])
        self.assertEqual(len(f), 5)
        self.assertEqual(f.number_of_components, 5)
        self.assertEqual(f.number_of_tuples, 5)
        self.assertEqual(f[-1], (4., 4.,4.,4.,4.))
        f[1] = [-1,-1,-1, -1,-1]
        self.assertEqual(f[1], (-1.0, -1.0, -1.0,-1.0, -1.0))
        self.assertRaises(IndexError, f.__getitem__, 100)
        self.assertRaises(IndexError, f.__setitem__, 100, 100)

    def test_points(self):
        """Test if vtkPoints behaves in a Pythonic fashion."""
        f = tvtk.Points()
        a = numpy.array([[0.,0,0],[1,1,1]])
        f.from_array(a)
        self.assertEqual(mysum(f.to_array() - a), 0)
        for i, j in zip(a, f):
            self.assertEqual(mysum(i - j), 0)

        a[0,0] = 1.0 # Should change the VTK data!
        # Make sure that everything works even when the original array
        # is deleted.
        del a
        self.assertEqual(f[0], (1.0, 0.0, 0.0))
        self.assertEqual(f[-1], (1.,1.,1.))
        self.assertEqual(repr(f), '[(1.0, 0.0, 0.0), (1.0, 1.0, 1.0)]')
        f.append((2,2,2))
        f.extend([[3,3,3], [4,4,4]])
        self.assertEqual(len(f), 5)
        f[1] = [-1,-1,-1]
        self.assertEqual(f[1], (-1.0, -1.0, -1.0))
        self.assertRaises(IndexError, f.__getitem__, 100)
        self.assertRaises(IndexError, f.__setitem__, 100, 100)

    def test_idlist(self):
        """Test if vtkIdList behaves in a Pythonic fashion."""
        f = tvtk.IdList()
        a = numpy.array([0, 1, 2, 3])
        f.from_array(a)
        for i, j in zip(a, f):
            self.assertEqual(i, j)
        self.assertEqual(f[-1], 3)
        self.assertEqual(f[0], 0)
        if type(f[0]) is long:
            self.assertEqual(repr(f), '[0L, 1L, 2L, 3L]')
        else:
            self.assertEqual(repr(f), '[0, 1, 2, 3]')
        f.append(4)
        f.extend([5, 6])
        self.assertEqual(len(f), 7)
        f[1] = -1
        self.assertEqual(f[1], -1)
        self.assertRaises(IndexError, f.__getitem__, 100)
        self.assertRaises(IndexError, f.__setitem__, 100, 100)

    def test_array_conversion(self):
        """Test if Numeric/VTK array conversion works."""
        # This is only a simple test.
        data = numpy.array([[0,0,0,10], [1,0,0,20],
                            [0,1,0,20], [0,0,1,30]], 'f')
        triangles = numpy.array([[0,1,3], [0,3,2],
                                 [1,2,3], [0,2,1]])
        points = data[:,:3]
        temperature = data[:,-1]
        mesh = tvtk.PolyData()
        mesh.points = points
        mesh.polys = triangles
        mesh.point_data.scalars = temperature

        # Test if a normal float array also works.
        temp = tvtk.FloatArray()
        temp.from_array(temperature)
        mesh.point_data.scalars = temp

    def test_append_poly_data_input(self):
        """Test if AppendPolyData has its get_input wrapped right."""
        a = tvtk.AppendPolyData()
        self.assertEqual(hasattr(a, 'get_input'), True)
        self.assertEqual(a.input, None)

    def test_property_change_notification(self):
        """Test if changes to properties generate notification events."""
        # Create a dummy class to test with.
        class Junk:
            def f(self, obj, name, old, new):
                self.data = obj, name, old, new
        z = Junk()
        cs = tvtk.ConeSource()
        m = tvtk.PolyDataMapper()
        if vtk_major_version < 6:
            m.on_trait_change(z.f, 'input')
            m.input = cs.output
            self.assertEqual(z.data, (m, 'input', None, cs.output))
            m.input = None
            self.assertEqual(z.data, (m, 'input', cs.output, None))
            m.on_trait_change(z.f, 'input', remove=True)
            m.input = cs.output
        else:
            m.on_trait_change(z.f, 'input_connection')
            m.input_connection = cs.output_port
            self.assertEqual(z.data, (m, 'input_connection', None, cs.output_port))
            m.input_connection = None
            self.assertEqual(z.data, (m, 'input_connection', cs.output_port, None))
            m.on_trait_change(z.f, 'input_connection', remove=True)
            m.input_connection = cs.output_port
        a = tvtk.Actor()
        a.on_trait_change(z.f, 'mapper')
        a.on_trait_change(z.f, 'property')
        a.mapper = m
        self.assertEqual(z.data, (a, 'mapper', None, m))
        old = a.property
        new = tvtk.Property()
        a.property = new
        self.assertEqual(z.data, (a, 'property', old, new))

        # Check if property notification occurs on add_input/remove_input
        a = tvtk.AppendPolyData()
        pd = tvtk.PolyData()
        if vtk_major_version < 6:
            a.on_trait_change(z.f, 'input')
            a.add_input(pd)
            old, new = None, pd
            self.assertEqual(z.data, (a, 'input', old, new))
            a.remove_input(pd)
            old, new = pd, None
            self.assertEqual(z.data, (a, 'input', old, new))
            a.remove_all_inputs()
            old, new = None, None
            self.assertEqual(z.data, (a, 'input', old, new))
        else:
            a.add_input_data(pd)
            self.assertEqual(a.input, pd)
            a.remove_input_data(pd)
            self.assertEqual(a.input, None)
            a.remove_all_inputs()
            self.assertEqual(a.input, None)

    def test_tuple_array_handling(self):
        """Test if methods can take any sequence rather than only tuples."""
        sg = tvtk.StructuredGridGeometryFilter()
        # setting a bogus value triggers an error since VTK assumes
        # that we want the extent set in the passed object.  If we use
        # an Array type instead of a Tuple then we can pass in
        # a list and it should work OK.
        sg.extent = [0,-1, 0,-1, 0,-1]

    def test_information_keys(self):
        """Test if vtk information objects can be created."""
        s = tvtk.StructuredPoints()
        x = s.FIELD_ARRAY_TYPE()
        y = tvtk.Information()
        x.get(y)

    def test_parent_child_bounds(self):
        """CubeAxesActor2D's bounds should be writable."""
        c = tvtk.CubeAxesActor2D()
        c.bounds = (0,1,0,1,0,1)

    def test_parent_child_input(self):
        """Case where parent has GetInput and child SetInput."""
        vm = tvtk.VolumeTextureMapper2D()
        # In this case if the wrapping is not done right, the input
        # trait is made read-only which is a bug.  We set the input
        # below to test this.
        configure_input_data(vm, tvtk.ImageData())
        spw = tvtk.StructuredPointsWriter()
        if vtk_major_version < 6:
            spw.input = None
        else:
            spw.input_connection = None

    def test_image_data_scalar_type(self):
        """Does ImageData support all scalar types?.
        Setting scalar type is no longer supported on VTK 6."""
        if vtk_major_version < 6:
            img = tvtk.ImageData()
            # There are 22 scalar types in VTK-5.2.  We should be able to
            # use them all.
            for i in range(0, 22):
                img.scalar_type = i

    def test_null_string_wrapper(self):
        "Check if a null string default is wrapped as a String trait."
        cap = tvtk.CaptionActor2D()
        self.assertEqual(('caption', 'GetCaption') in cap._updateable_traits_, True)
        self.assertEqual('caption' in cap._full_traitnames_list_, True)

# This separates out any tests for the entire module that would affect
# the functioning of the other tests.
class TestTVTKModule(unittest.TestCase):
    def test_all_instantiable(self):
        """Test if all the TVTK classes are instantiable."""
        # This is a comprehensive test that instantiates every single
        # non-abstract tvtk class.  This takes a while.
        ok = True
        ignore = []
        if vtk.vtkVersion.GetVTKMajorVersion() >= 5 and \
            vtk.vtkVersion.GetVTKMinorVersion() == 8:
                ignore = ['vtkAxesTransformRepresentation']
        # Turn off VTK warnings.
        vtk.vtkObject.GlobalWarningDisplayOff()
        names = [name for name in dir(vtk) \
                 if name.startswith('vtk') and \
                 not name.startswith('vtkQt')]
        for name in names:
            if name in ignore:
                continue
            klass = getattr(vtk, name)
            if hasattr(klass, '__bases__') \
                    and not issubclass(klass, object):
                try:
                    obj = klass()
                except (TypeError, NotImplementedError):
                    # These classes are abstract and can't/shouldn't
                    # be instantiated.
                    pass
                else:
                    t_name = get_tvtk_name(name)
                    skip = ['ObjectBase']
                    if t_name not in skip:
                        k = getattr(tvtk, t_name)
                        try:
                            obj = k()
                        except TraitError, msg:
                            print "class:", t_name, msg
                            ok = False
        # Now clear out the cache so other tests can run.
        tvtk_helper._cache.clear()
        # Turn on warnings.
        vtk.vtkObject.GlobalWarningDisplayOn()
        # Now raise an error if things were not OK.
        if not ok:
            raise TraitError, \
                  "Errors occured during this test, see printed messages."


if __name__ == "__main__":
    unittest.main()

########NEW FILE########
__FILENAME__ = test_tvtk_base
"""Tests for tvtk_base.py.  These only test the basic functionality of
the code in tvtk_base.  More tests for TVTK objects should be in
test_tvtk.py.

"""
# Author: Prabhu Ramachandran
# Copyright (c) 2004, Enthought, Inc.
# License: BSD Style.

import unittest
import cPickle
import weakref
import vtk
import gc

from traits import api as traits
from tvtk import tvtk_base
from tvtk.common import get_tvtk_name, camel2enthought


# An elementary class based on vtkProperty that is used only for
# testing.
class Prop(tvtk_base.TVTKBase):
    def __init__(self, obj=None, update=1, **traits):
        tvtk_base.TVTKBase.__init__(self, vtk.vtkProperty, obj, update, **traits)

    edge_visibility = tvtk_base.false_bool_trait
    def _edge_visibility_changed(self, old_val, new_val):
        self._do_change(self._vtk_obj.SetEdgeVisibility, self.edge_visibility_)

    representation = traits.Trait('surface',
                            tvtk_base.TraitRevPrefixMap({'points': 0, 'wireframe': 1, 'surface': 2}))
    def _representation_changed(self, old_val, new_val):
        self._do_change(self._vtk_obj.SetRepresentation, self.representation_)

    opacity = traits.Trait(1.0, traits.Range(0.0, 1.0))
    def _opacity_changed(self, old_val, new_val):
        self._do_change(self._vtk_obj.SetOpacity,
                        self.opacity)

    specular_color = tvtk_base.vtk_color_trait((1.0, 1.0, 1.0))
    def _specular_color_changed(self, old_val, new_val):
        self._do_change(self._vtk_obj.SetSpecularColor,
                        self.specular_color, 1)

    diffuse_color = tvtk_base.vtk_color_trait((1.0, 1.0, 1.0))
    def _diffuse_color_changed(self, old_val, new_val):
        self._do_change(self._vtk_obj.SetDiffuseColor,
                        self.diffuse_color, 1)

    color = tvtk_base.vtk_color_trait((1.0, 1.0, 1.0))
    def _color_changed(self, old_val, new_val):
        self._do_change(self._vtk_obj.SetColor,
                        self.color)

    _updateable_traits_ = (('edge_visibility', 'GetEdgeVisibility'),
                           ('opacity', 'GetOpacity'),
                           ('specular_color', 'GetSpecularColor'),
                           ('color', 'GetColor'),
                           ('diffuse_color', 'GetDiffuseColor'),
                           ('representation', 'GetRepresentation'))



class TestTVTKBase(unittest.TestCase):
    def test_tvtk_name(self):
        """Test VTK to TVTK class name conversion."""
        v_name = ['vtkFooBar', 'vtkXMLDataReader',
                  'vtk3DSReader', 'vtk2000Bug']
        t_name = ['FooBar', 'XMLDataReader',
                  'ThreeDSReader', 'Two000Bug']
        for i, vn in enumerate(v_name):
            tn = get_tvtk_name(vn)
            self.assertEqual(tn, t_name[i])

        num = ['Zero', 'One', 'Two', 'Three', 'Four', 'Five',
               'Six', 'Seven', 'Eight', 'Nine']
        for i in range(10):
            vn = 'vtk%dA'%i
            tn = get_tvtk_name(vn)
            self.assertEqual(tn, '%sA'%num[i])

    def test_camel2enthought(self):
        """Test CamelCase to Enthought style name conversion."""
        v_name = ['GetFooBar', 'GetOBBTree', 'XMLDataReader',
                  'GetFooXML', 'HTMLIsSGML', '_SetMe', '_XYZTest',
                  'Actor2D', 'Actor3D', 'Actor6D', 'PLOT3DReader',
                  'Actor61Dimension', 'GL2PSExporter',
                  'Volume16Reader']
        t_name = ['get_foo_bar', 'get_obb_tree', 'xml_data_reader',
                  'get_foo_xml', 'html_is_sgml', '_set_me',
                  '_xyz_test', 'actor2d', 'actor3d', 'actor6_d',
                  'plot3d_reader', 'actor61_dimension',
                  'gl2ps_exporter', 'volume16_reader']
        for i, vn in enumerate(v_name):
            tn = camel2enthought(vn)
            self.assertEqual(tn, t_name[i])

    def test_do_change(self):
        """Test if VTK object changes when trait is changed."""
        p = Prop()
        p.edge_visibility = not p.edge_visibility
        p.representation = 'p'
        p.opacity = 0.5
        p.color = (0,1,0)
        p.diffuse_color = (1,1,1)
        p.specular_color = (1,1,0)
        for t, g in p._updateable_traits_:
            val = getattr(p._vtk_obj, g)()
            if t == 'representation':
                self.assertEqual(val, getattr(p, t + '_'))
            else:
                self.assertEqual(val, getattr(p, t))

    def test_auto_update(self):
        """Test trait updation when the VTK object changes."""
        p = Prop()
        obj = p._vtk_obj
        obj.SetEdgeVisibility(1)
        self.assertEqual(p.edge_visibility, 1)

        obj.SetOpacity(0.5)
        self.assertEqual(p.opacity, 0.5)

        obj.SetRepresentationToPoints()
        self.assertEqual(p.representation, 'points')

        val = (1.0, 1.0, 0.0)
        obj.SetColor(val)
        self.assertEqual(p.color, val)

        val = (1.0, 0.0, 0.0)
        obj.SetDiffuseColor(val)
        self.assertEqual(p.diffuse_color, val)

        val = (0.0, 1.0, 0.0)
        obj.SetSpecularColor(val)
        self.assertEqual(p.specular_color, val)

    def test_setup_teardown_observers(self):
        """If setup_observers and teardown_observers work correctly."""
        p = Prop()
        # Turn off the observers.
        p.teardown_observers()
        obj = p._vtk_obj
        obj.SetEdgeVisibility(1)
        self.assertEqual(p.edge_visibility, 0)

        obj.SetOpacity(0.5)
        self.assertEqual(p.opacity, 1.0)

        obj.SetRepresentationToPoints()
        self.assertEqual(p.representation, 'surface')

        # Setup the observers again.
        p.update_traits()
        p.setup_observers()

        self.assertEqual(p.edge_visibility, 1)
        self.assertEqual(p.opacity, 0.5)
        self.assertEqual(p.representation, 'points')

        obj.SetEdgeVisibility(0)
        self.assertEqual(p.edge_visibility, 0)

        obj.SetOpacity(1.0)
        self.assertEqual(p.opacity, 1.0)

        obj.SetRepresentationToSurface()
        self.assertEqual(p.representation, 'surface')

    def test_pickle(self):
        """Test if pickling works."""
        p = Prop()
        p.edge_visibility = 1
        p.representation = 'p'
        p.opacity = 0.5
        p.color = (0,1,0)
        p.diffuse_color = (0,1,1)
        p.specular_color = (1,1,0)

        s = cPickle.dumps(p)
        del p

        p = cPickle.loads(s)

        self.assertEqual(p.edge_visibility, 1)
        self.assertEqual(p.opacity, 0.5)
        self.assertEqual(p.representation, 'points')
        val = (0.0, 1.0, 1.0)
        self.assertEqual(p.color, val)
        val = (0.0, 1.0, 1.0)
        self.assertEqual(p.diffuse_color, val)
        val = (1.0, 1.0, 0.0)
        self.assertEqual(p.specular_color, val)

        # test if pickling also works on an existing object.
        d = p.__getstate__()
        del p
        p = Prop()
        addr = p._vtk_obj.__this__
        p.__setstate__(d)
        # Make sure its the same object.
        self.assertEqual(addr, p._vtk_obj.__this__)

        self.assertEqual(p.edge_visibility, 1)
        self.assertEqual(p.opacity, 0.5)
        self.assertEqual(p.representation, 'points')
        val = (0.0, 1.0, 1.0)
        self.assertEqual(p.color, val)

    def test_rev_prefix_map(self):
        """Test the reverse prefix map trait we use."""
        p = Prop()
        p.representation = 'p'
        p.representation = 'wire'
        p.representation = 'points'
        p.representation = 2
        self.assertEqual(p.representation, 'surface')
        self.assertRaises(traits.TraitError, setattr , p,
                          'representation', 'points1')
        self.assertRaises(traits.TraitError, setattr , p,
                          'representation', 'POINTS')

    def test_deref_vtk(self):
        """Test the `deref_vtk` function."""
        p = Prop()
        o = tvtk_base.deref_vtk(p)
        self.assertEqual(o.IsA('vtkProperty'), True)
        o1 = tvtk_base.deref_vtk(o)
        self.assertEqual(o1.IsA('vtkProperty'), True)

        o = tvtk_base.deref_vtk(self)
        self.assertEqual(o.__class__.__name__, 'TestTVTKBase')

    def test_obj_del(self):
        """Test object deletion and reference cycles."""
        p = Prop()
        p.representation = 0
        ref = weakref.ref(p)
        del p
        self.assertEqual(ref(), None)

    def test_strict_traits(self):
        """Test if TVTK objects use strict traits."""
        p = Prop()
        self.assertRaises(traits.TraitError, setattr, p, 'foo', 1)
        self.assertRaises(traits.TraitError, setattr, p, '_foo', 1)
        self.assertRaises(traits.TraitError, setattr, p, '__foo', 1)

    def test_init_traits(self):
        """Test if the objects traits can be set in __init__."""
        p = Prop(opacity=0.1, color=(1,0,0), representation='p')
        self.assertEqual(p.opacity, 0.1)
        self.assertEqual(p.color, (1.0, 0.0, 0.0))
        self.assertEqual(p.representation, 'points')

        # Test case where the object traits are wrong.
        self.assertRaises(traits.TraitError, Prop, foo='bar')

    def test_zz_object_cache(self):
        """Test if object cache works correctly."""
        # HACK!  The zz in the method name ensures that this is run
        # last.  The reloading messes up some of the other tests
        # because the Prop classes base class is different.

        l1 = len(tvtk_base._object_cache)
        p = Prop()
        addr = p._vtk_obj.__this__
        self.assertEqual(l1 + 1, len(tvtk_base._object_cache))
        self.assertEqual(p, tvtk_base._object_cache.get(addr))

        del p
        gc.collect() # Force collection.
        self.assertEqual(l1, len(tvtk_base._object_cache))
        self.assertEqual(tvtk_base._object_cache.has_key(addr),
                         False)

        # Check reload-safety.
        p = Prop()
        l1 = len(tvtk_base._object_cache)
        reload(tvtk_base)
        self.assertEqual(l1, len(tvtk_base._object_cache))

    # Reloading causes havoc with nosetests based tests so we skip in
    # that case.  Unittest will see the test just fine.
    test_zz_object_cache.__test__ = False


if __name__ == "__main__":
    unittest.main()

########NEW FILE########
__FILENAME__ = test_vtk_parser
# Author: Prabhu Ramachandran
# License: BSD style
# Copyright (c) 2004, Enthought, Inc.

"""Tests for vtk_parser.py.

Note that the `test_parse_all` parses every single class in
VTK-Python.  It organizes the methods and also tries to obtain the
method signature for every method in every class.  If this runs
without crashing or raising any exceptions, then it shows that the
vtk_parser will work for any VTK class.  The test will show a few VTK
error messages but they are usually harmless.

"""

import unittest
from tvtk import vtk_parser

import time # Only used when timing.
import sys  # Only used when debugging.
import vtk

# This is a little expensive to create so we cache it.
_cache = vtk_parser.VTKMethodParser()
vtk_major_version = vtk.vtkVersion.GetVTKMajorVersion()
vtk_minor_version = vtk.vtkVersion.GetVTKMinorVersion()

class TestVTKParser(unittest.TestCase):
    def setUp(self):
        self.p = _cache

    def test_methods(self):
        """Check get_methods."""
        p = self.p
        meths = p.get_methods(vtk.vtkFloatArray)

        # Check if special methods are removed.
        for m in meths:
            self.assertEqual((m.find('__') == -1), True)

    def test_parse(self):
        """Check if the methods are organized correctly."""
        p = self.p
        # Simple case of a vtkObject.
        p.parse(vtk.vtkObject())
        self.assertEqual(p.get_toggle_methods(),
                         {'Debug': 0, 'GlobalWarningDisplay': 1})
        if (vtk_major_version >= 5 and vtk_minor_version >= 10) or \
           (vtk_major_version >= 6):
            self.assertEqual(p.get_state_methods(), {})
            self.assertEqual(p.get_get_methods(), ['GetCommand', 'GetMTime'])
        elif vtk_major_version >= 5 and vtk_minor_version >= 6:
            self.assertEqual(p.get_state_methods(), {})
            self.assertEqual(p.get_get_methods(), ['GetMTime'])
        else:
            self.assertEqual(p.get_state_methods(), {'ReferenceCount':(1, None)})
            self.assertEqual(p.get_get_methods(), ['GetMTime'])
        self.assertEqual(p.get_get_set_methods(), {})

        res = ['AddObserver', 'BreakOnError', 'HasObserver',
               'InvokeEvent', 'IsA', 'Modified', 'NewInstance',
               'Register', 'RemoveObserver', 'RemoveObservers',
               'SafeDownCast', 'UnRegister', 'RemoveAllObservers']
        for i in p.get_other_methods():
            self.assertEqual(i in res, True)

        # Parse a fairly complex case of a vtkProperty with the same
        # parser object.
        p.parse(vtk.vtkProperty)
        self.assertEqual(p.toggle_meths, p.get_toggle_methods())
        res = {'EdgeVisibility': 0, 'BackfaceCulling': 0,
               'FrontfaceCulling': 0}
        if p.get_toggle_methods().has_key('Shading'):
            res['Shading'] = 0

        result = p.get_toggle_methods()
        for key in res:
            self.assertEqual(key in result, True)
            self.assertEqual(result[key], res[key])

        res = {'Interpolation': [['Gouraud', 1], ['Flat', 0],
                                 ['Gouraud', 1], ['Phong', 2]],
               'Representation': [['Surface', 2], ['Points', 0],
                                  ['Surface', 2], ['Wireframe', 1]]}

        self.assertEqual(p.get_state_methods(), res)
        self.assertEqual(p.state_meths, p.get_state_methods())

        obj = vtk.vtkProperty()
        res = {'Ambient': (0.0, (0.0, 1.0)),
               'AmbientColor': ((1.0, 1.0, 1.0), None),
               'Color': ((1.0, 1.0, 1.0), None),
               'Diffuse': (1.0, (0.0, 1.0)),
               'DiffuseColor': ((1.0, 1.0, 1.0), None),
               'EdgeColor': ((1.0, 1.0, 1.0), None),
               'LineStipplePattern': (65535, None),
               'LineStippleRepeatFactor': (1, (1, vtk.VTK_LARGE_INTEGER)),
               'LineWidth': (1.0, (0.0, vtk.VTK_LARGE_FLOAT)),
               'Opacity': (1.0, (0.0, 1.0)),
               'PointSize': (1.0, (0.0, vtk.VTK_LARGE_FLOAT)),
               'ReferenceCount': (1, None),
               'Specular': (0.0, (0.0, 1.0)),
               'SpecularColor': ((1.0, 1.0, 1.0), None),
               'SpecularPower': (1.0, (0.0, 100.0))}
        if ('ReferenceCount' not in p.get_get_set_methods()):
            del res['ReferenceCount']
        result = p.get_get_set_methods().keys()
        if hasattr(obj, 'GetTexture'):
            result.remove('Texture')
        self.assertEqual(sorted(res.keys()), sorted(result))
        self.assertEqual(p.get_set_meths, p.get_get_set_methods())
        for x in res:
            if res[x][1]:
                # This is necessary since the returned value is not
                # usually exactly the same as defined in the header file.
                default = getattr(obj, 'Get%s'%x)()
                val = getattr(obj, 'Get%sMinValue'%x)(), \
                      getattr(obj, 'Get%sMaxValue'%x)()
                self.assertEqual(p.get_get_set_methods()[x],
                                 (default, val))

        if hasattr(obj, 'GetTexture'):
            expect = ['GetMaterial', 'GetMaterialName',
                      'GetNumberOfTextures', 'GetShaderProgram']
            if hasattr(obj, 'GetMaterialName'):
                if hasattr(obj, 'GetShaderDeviceAdapter2'):
                    expect.append('GetShaderDeviceAdapter2')
                msg = "%s not in %s"%(p.get_get_methods(), expect)
                self.assertTrue(all([x in expect for x in sorted(p.get_get_methods())]), msg)
            else:
                expect.remove('GetMaterialName')
                self.assertEqual(p.get_get_methods(), expect)
        else:
            self.assertEqual(p.get_get_methods(), [])
        self.assertEqual(p.get_meths, p.get_get_methods())

        res = ['BackfaceRender', 'DeepCopy', 'Render']
        if hasattr(obj, 'GetTexture'):
            if vtk_major_version == 6 and vtk_minor_version == 1:
                res = ['AddShaderVariable', 'BackfaceRender', 'DeepCopy',
                       'ReleaseGraphicsResources', 'RemoveAllTextures', 'RemoveTexture',
                       'Render']
            else:
                res = ['AddShaderVariable', 'BackfaceRender', 'DeepCopy',
                       'LoadMaterial', 'LoadMaterialFromString',
                       'ReleaseGraphicsResources', 'RemoveAllTextures', 'RemoveTexture',
                       'Render']
        if hasattr(obj, 'PostRender'):
            res.append('PostRender')
            res.sort()
        self.assertEqual(p.get_other_methods(), res)
        self.assertEqual(p.other_meths, p.get_other_methods())

    def test_parse_image_reslice(self):
        """Check if the vtkImageReslice is parsed correctly."""
        p = self.p
        p.parse(vtk.vtkImageReslice)
        state_meths = p.get_state_methods()
        self.assertEqual('OutputSpacing' not in state_meths, True)
        self.assertEqual('OutputOrigin' not in state_meths, True)
        self.assertEqual('OutputExtent' not in state_meths, True)

    def test_props_allocated_rendertime_is_not_a_get_set_method(self):
        p = self.p
        a = vtk.vtkActor()
        if hasattr(a, 'GetAllocatedRenderTime'):
            p.parse(vtk.vtkProp)
            self.assertFalse('AllocatedRenderTime' in p.get_get_set_methods())

    def test_method_signature(self):
        """Check if VTK method signatures are parsed correctly."""
        p = self.p

        # Simple tests.
        o = vtk.vtkProperty()
        self.assertEqual([(['string'], None)],
                         p.get_method_signature(o.GetClassName))
        if hasattr(vtk, 'vtkArrayCoordinates'):
            self.assertEqual([([('float', 'float', 'float')], None),
                              ([None], (['float', 'float', 'float'],)),
                              ([None], ('float', 'float', 'float'))],
                             p.get_method_signature(o.GetColor))
        else:
            self.assertEqual([([('float', 'float', 'float')], None),
                              ([None], (('float', 'float', 'float'),))],
                             p.get_method_signature(o.GetColor))
        if hasattr(vtk, 'vtkArrayCoordinates'):
            self.assertEqual([([None], ('float', 'float', 'float')),
                ([None], (['float', 'float', 'float'],))],
                             p.get_method_signature(o.SetColor))

        else:
            self.assertEqual([([None], ('float', 'float', 'float')),
                              ([None], (('float', 'float', 'float'),))],
                             p.get_method_signature(o.SetColor))

        # Get VTK version to handle changed APIs.
        vtk_ver = vtk.vtkVersion().GetVTKVersion()

        # Test vtkObjects args.
        o = vtk.vtkContourFilter()
        if vtk_major_version < 6:
            sig = p.get_method_signature(o.SetInput)
        else:
            sig = p.get_method_signature(o.SetInputData)
        if len(sig) == 1:
            self.assertEqual([([None], ['vtkDataSet'])],
                             sig)
        elif vtk_ver[:3] in ['4.2', '4.4']:
            self.assertEqual([([None], ['vtkDataObject']),
                              ([None], ('int', 'vtkDataObject')),
                              ([None], ['vtkDataSet']),
                              ([None], ('int', 'vtkDataSet'))
                              ], sig)
        elif vtk_ver[:2] == '5.' or vtk_ver[:3] == '4.5':
            self.assertEqual([([None], ['vtkDataObject']),
                              ([None], ('int', 'vtkDataObject')),
                              ], sig)

        self.assertEqual([(['vtkPolyData'], None),
                          (['vtkPolyData'], ['int'])],
                         p.get_method_signature(o.GetOutput))

        # Test if function arguments work.
        self.assertEqual([(['int'], ('int', 'function'))],
                         p.get_method_signature(o.AddObserver))
        # This one's for completeness.
        if ((len(p.get_method_signature(o.RemoveObserver))) == 2):
            self.assertEqual([([None], ['vtkCommand']), ([None], ['int'])],
                             p.get_method_signature(o.RemoveObserver))
        else:
            self.assertEqual([([None], ['int'])],
                             p.get_method_signature(o.RemoveObserver))


    def test_special_non_state_methods(self):
        """Check exceptional cases that are not state methods."""
        p = self.p
        p.parse(vtk.vtkDataObject)
        self.assert_('UpdateExtent' not in p.get_state_methods())
        if vtk_major_version < 6:
            self.assert_('UpdateExtent' in p.get_get_set_methods())

        p.parse(vtk.vtkImageImport)
        self.assert_('DataExtent' not in p.get_state_methods())
        self.assert_('DataExtent' in p.get_get_set_methods())

    def test_no_tree(self):
        """Check if parser is usable without the tree."""
        p = vtk_parser.VTKMethodParser(use_tree=False)
        self.assertEqual(p.get_tree(), None)
        self.p = p
        self.test_methods()
        self.test_parse()
        self.test_method_signature()

        # Now check that it really works for abstract classes.
        # abstract classes that have state methods
        abs_class = [vtk.vtkDicer, vtk.vtkMapper, vtk.vtkScalarsToColors,
                     vtk.vtkStreamer, vtk.vtkUnstructuredGridVolumeMapper,
                     vtk.vtkVolumeMapper, vtk.vtkXMLWriter]

        for k in abs_class:
            p.parse(k)
            # Make sure we did get the state methods.
            self.assertEqual(len(p.get_state_methods()) > 0, True)

            for key, values in p.get_state_methods().items():
                for val in values:
                    # No state information is obtainable since no
                    # class tree is created.
                    self.assertTrue(val[1] in [None, 0, 1, 2])

    def test_parse_all(self):
        """Check if all VTK classes are parseable."""

        # This test is a tough one because every single class in the
        # VTK API is parsed.  A few VTK error messages (not test
        # errors) might be seen on screen but these are normal.

        #t1 = time.clock()
        p = self.p
        for obj in dir(vtk):
            k = getattr(vtk, obj)
            ignore = ['mutable', 'exc', 'kits', 'util']
            if hasattr(k, '__bases__') and obj not in ignore:
                #print k.__name__,
                #sys.stdout.flush()
                p.parse(k)
                for method in p.get_methods(k):
                    #print method
                    p.get_method_signature(getattr(k, method))
        #print time.clock() - t1, 'seconds'


if __name__ == "__main__":
    unittest.main()

########NEW FILE########
__FILENAME__ = test_wrapper_gen
"""Elementary tests for wrapper_gen.py.

This test suite is not comprehensive because it is very hard to test
wrapper_gen directly.

"""
# Author: Prabhu Ramachandran <prabhu_r@users.sf.net>
# Copyright (c) 2004, Prabhu Ramachandran,  Enthought, Inc.
# License: BSD Style.

import unittest
import vtk

from tvtk import wrapper_gen

_cache = wrapper_gen.WrapperGenerator()


class TestWrapperGenerator(unittest.TestCase):
    def setUp(self):
        self.wg = _cache

    def test_find_type(self):
        wg = self.wg
        sigs = ['int', 'vtkOpenGLVolumeMapper',
                ('int', 'int', 'float', 'list'),
                ('int', 'vtkActor', 'vtkXMLReader'),
                ['vtkImageActor', 'vtkExporter'],
                ['int', 'vtkDataArray', 'vtkCellArray',
                 'vtkIdTypeArray']
                ]
        expect = ['basic', 'vtk', 'basic', 'vtk', 'vtk', 'array']
        for i, sig in enumerate(sigs):
            self.assertEqual(expect[i], wg._find_type(sig))

    def test_sig_types(self):
        wg = self.wg
        meths = [vtk.vtkProperty.GetColor,
                 vtk.vtkProperty.GetRepresentation,
                 vtk.vtkStructuredPointsReader.GetOutput,
                 vtk.vtkPolyData.SetPoints,
                 vtk.vtkPolyData.SetPolys,
                 vtk.vtkQuad.CellBoundary,
                 vtk.vtkContourFilter.SetLocator
                 ]
        expect = [('basic', 'basic'),
                  ('basic', None),
                  ('vtk', 'basic'),
                  ('basic', 'array'),
                  ('basic', 'array'),
                  ('basic', 'array'),
                  ('basic', 'vtk'),
                  ]
        for i, meth in enumerate(meths):
            sig = wg.parser.get_method_signature(meth)
            self.assertEqual(expect[i], wg._find_sig_type(sig))
        sig = [(['int'], ['int']),
               (['vtkStructuredPoints'], ['vtkFooClass'])]
        self.assertEqual(('vtk', 'vtk'), wg._find_sig_type(sig))

if __name__ == "__main__":
    unittest.main()

########NEW FILE########
__FILENAME__ = ivtk
"""ivtk - Interactive TVTK.

A utility module that makes VTK/TVTK easier to use from the Python
interpreter.  For a standalone application simply run this file.  To
use this under IPython (with -wthread) use the `viewer()` helper
function or use the `IVTK` class.  The widget can also make use of the
tvtk pipeline browser.

Here is example usage of the viewer along with tvtk under IPython:

    >>> from tvtk.tools import ivtk
    >>> from tvtk.api import tvtk
    >>> cs = tvtk.ConeSource()
    >>> m = tvtk.PolyDataMapper()
    >>> m.input = cs.output
    >>> a = tvtk.Actor()
    >>> a.mapper = m
    >>> v = ivtk.viewer()
    >>> v.scene.add_actors(a)
    >>> v.scene.reset_zoom()

"""

# Author: Prabhu Ramachandran <prabhu_r@users.sf.net>
# Copyright (c) 2005-2008, Enthought, Inc.
# License: BSD Style.

# Standard library imports.
import os.path

# Enthought library imports.
from pyface.api import FileDialog, GUI, OK, PythonShell
from pyface.api import SplitApplicationWindow, ApplicationWindow
from pyface.api import SplitPanel
from tvtk.pyface.api import Scene, DecoratedScene
from pyface.action.api import Action, MenuBarManager,\
     MenuManager, Separator
from pyface.image_resource import ImageResource
from pyface.resource.api import resource_path

from traits.api import Float, Str, Instance, Callable

from tvtk.api import tvtk

from tvtk.pipeline.browser import PipelineBrowser

######################################################################
# The scene icon.
######################################################################
def mk_scene_icon():
    icon_path = os.path.join(resource_path(), 'images', 'scene.ico')
    return ImageResource(icon_path)

scene_icon = mk_scene_icon()

######################################################################
# `ExitAction` class.
######################################################################
class ExitAction(Action):
    """ Exits the application. """
    def __init__(self, window):
        """ Creates a new action. """
        self._window = window
        self.name = "E&xit"

    def perform(self):
        """ Performs the action. """
        self._window.close()


######################################################################
# `SaveImageAction` class.
######################################################################
class SaveImageAction(Action):
    """Saves the rendered scene to an image."""
    def __init__(self, window):
        self._window = window
        self.name = "S&ave Scene"

    def perform(self):
        """Pops up a dialog used to save the scene to an image."""
        extns = ['*.png', '*.jpg', '*.jpeg', '*.tiff', '*.bmp', '*.ps', '*.eps',
                 '*.tex', '*.rib', '*.wrl', '*.oogl', '*.pdf', '*.vrml', '*.obj',
                 '*.iv']
        dlg = FileDialog(parent=self._window.control, action='save as',
                wildcard='|'.join(extns), title="Save scene to image")
        if dlg.open() == OK:
            self._window.scene.save(dlg.path)


######################################################################
# `SaveToClipboardAction` class.
######################################################################
class SaveToClipboardAction(Action):
    """ Saves rendered scene to the Clipboard. """
    def __init__(self, window):
        """ Creates a new action. """
        self._window = window
        self.name = "&Copy"

    def perform(self):
        """ Performs the action. """
        self._window.scene.save_to_clipboard()


######################################################################
# `SpecialViewAction` class.
######################################################################
class SpecialViewAction(Action):
    """Sets the scene to a particular view."""
    def __init__(self, window, name, view):
        """ Creates a new action. """
        self._window = window
        self.name = name
        self.view = view

    def perform(self):
        """ Performs the action. """
        # Hack!  Works tho.
        try:
            meth = getattr(self._window.scene, self.view)
            meth()
        except AttributeError:
            pass


def create_ivtk_menu(obj):
    """Creates a menu bar suitable for all IVTK windows.

    Parameters
    ----------

    - obj : A Pyface application window.

      This is the window which requires the menu items.
    """

    menu_bar_manager = MenuBarManager(
        MenuManager(SaveImageAction(obj),
                    Separator(),
                    ExitAction(obj),
                    name = '&File',
                    ),
        MenuManager(SaveToClipboardAction(obj),
                    name = '&Edit',
                    ),
        MenuManager(SpecialViewAction(obj, "&Reset Zoom", 'reset_zoom'),
                    Separator(),
                    SpecialViewAction(obj, "&Isometric", 'isometric_view'),
                    SpecialViewAction(obj, "&X positive", 'x_plus_view'),
                    SpecialViewAction(obj, "X negative", 'x_minus_view'),
                    SpecialViewAction(obj, "&Y positive", 'y_plus_view'),
                    SpecialViewAction(obj, "Y negative", 'y_minus_view'),
                    SpecialViewAction(obj, "&Z positive", 'z_plus_view'),
                    SpecialViewAction(obj, "Z negative", 'z_minus_view'),
                    name = '&View',
                    )
        )
    return menu_bar_manager


######################################################################
# `SceneWithBrowser` class.
######################################################################
class SceneWithBrowser(SplitPanel):
    """ Provides an Scene along with an embedded PyCrust Python shell.
    In the shell, 'scene' and 's' are bound to the Scene."""

    # The ratio of the size of the left/top pane to the right/bottom pane.
    ratio = Float(0.3)

    # The direction in which the panel is split.
    direction = Str('vertical')

    # The `Scene` instance into which VTK renders.
    scene = Instance(Scene)

    # The `PythonShell` instance.
    browser = Instance(PipelineBrowser)

    ###########################################################################
    # `IWidget` interface.
    ###########################################################################
    def destroy(self):
        if self.scene is not None:
            self.scene.close()
        super(SceneWithBrowser, self).destroy()

    ###########################################################################
    # Protected 'SplitPanel' interface.
    ###########################################################################
    def _create_lhs(self, parent):
        """ Creates the left hand side or top depending on the style. """
        self._create_scene(parent)
        self.browser = PipelineBrowser(self.scene)
        self.browser.show(parent=parent)
        return self.browser.ui.control

    def _create_rhs(self, parent):
        """ Creates the right hand side or bottom depending on the
        style.  's' and 'scene' are bound to the Scene instance."""
        self._create_scene(parent)
        self.scene.renderer.background = 0.5, 0.5, 0.5
        return self.scene.control

    ###########################################################################
    # Private 'SceneWithBrowser' interface.
    ###########################################################################
    def _create_scene(self, parent):
        """ Make sure that the scene has been created. """
        if self.scene is None:
            self.scene = DecoratedScene(parent)


######################################################################
# `IVTKWithCrust` class.
######################################################################
class IVTKWithCrust(SplitApplicationWindow):
    """ Provides an Scene along with an embedded PyCrust Python shell.
    In the shell, 'scene' and 's' are bound to the Scene."""

    # The ratio of the size of the left/top pane to the right/bottom pane.
    ratio = Float(0.7)

    # The direction in which the panel is split.
    direction = Str('horizontal')

    # The `Scene` instance into which VTK renders.
    scene = Instance(Scene)

    # The `PythonShell` instance.
    python_shell = Instance(PythonShell)

    ###########################################################################
    # 'object' interface.
    ###########################################################################
    def __init__(self, **traits):
        """ Creates a new window. """

        # Base class constructor.
        super(IVTKWithCrust, self).__init__(**traits)
        self.title = 'TVTK Scene'
        # Create the window's menu bar.
        self.menu_bar_manager = create_ivtk_menu(self)

    ###########################################################################
    # `IWindow` interface.
    ###########################################################################
    def close(self):
        if self.scene is not None:
            self.scene.close()
        super(IVTKWithCrust, self).close()

    ###########################################################################
    # Protected 'SplitApplicationWindow' interface.
    ###########################################################################
    def _create_lhs(self, parent):
        """ Creates the left hand side or top depending on the style. """

        self.scene = DecoratedScene(parent)
        self.scene.renderer.background = 0.5, 0.5, 0.5
        return self.scene.control

    def _create_rhs(self, parent):
        """ Creates the right hand side or bottom depending on the
        style.  's' and 'scene' are bound to the Scene instance."""

        self.python_shell = PythonShell(parent)
        self.python_shell.bind('scene', self.scene)
        self.python_shell.bind('s', self.scene)
        self.python_shell.bind('tvtk', tvtk)

        return self.python_shell.control


######################################################################
# `IVTKWithCrustAndBrowser` class.
######################################################################
class IVTKWithCrustAndBrowser(SplitApplicationWindow):
    """ Provides an Scene along with an embedded PyCrust Python shell.
    In the shell, 'scene' and 's' are bound to the Scene."""

    # The ratio of the size of the left/top pane to the right/bottom pane.
    ratio = Float(0.7)

    # The direction in which the panel is split.
    direction = Str('horizontal')

    # The `Scene` instance into which VTK renders.
    scene = Instance(Scene)

    # The `PipelineBrowser` instance.
    browser = Instance(PipelineBrowser)

    # The ordered split window to use.
    browser_scene = Instance(SceneWithBrowser)

    # The `PythonShell` instance.
    python_shell = Instance(PythonShell)

    ###########################################################################
    # 'object' interface.
    ###########################################################################
    def __init__(self, **traits):
        """ Creates a new window. """

        # Base class constructor.
        super(IVTKWithCrustAndBrowser, self).__init__(**traits)
        self.title = 'TVTK Scene'
        # Create the window's menu bar.
        self.menu_bar_manager = create_ivtk_menu(self)

    ###########################################################################
    # `IWindow` interface.
    ###########################################################################
    def close(self):
        if self.scene is not None:
            self.scene.close()
        super(IVTKWithCrustAndBrowser, self).close()

    ###########################################################################
    # Protected 'SplitApplicationWindow' interface.
    ###########################################################################

    # The icon of the window
    icon = Instance(ImageResource, scene_icon)

    def _create_lhs(self, parent):
        """ Creates the left hand side or top depending on the style. """
        self.browser_scene = SceneWithBrowser(parent)
        self.scene = self.browser_scene.scene
        self.browser = self.browser_scene.browser
        return self.browser_scene.control

    def _create_rhs(self, parent):
        """ Creates the right hand side or bottom depending on the
        style.  's' and 'scene' are bound to the Scene instance."""

        self.python_shell = PythonShell(parent)
        self.python_shell.bind('scene', self.scene)
        self.python_shell.bind('s', self.scene)
        self.python_shell.bind('browser', self.browser)
        self.python_shell.bind('b', self.browser)
        self.python_shell.bind('tvtk', tvtk)

        return self.python_shell.control


######################################################################
# `IVTK` class.
######################################################################
class IVTK(ApplicationWindow):
    """ Provides an Scene along without an embedded Python shell.
    This is useful when scripting from the vanilla Python or IPython
    interpreter."""

    # The `Scene` instance into which VTK renders.
    scene = Instance(Scene)

    # The callable (or class) to create the scene instance
    _scene_factory = Callable(DecoratedScene)

    ###########################################################################
    # 'object' interface.
    ###########################################################################
    def __init__(self, **traits):
        """ Creates a new application window. """

        # Base class constructor.
        super(IVTK, self).__init__(**traits)
        self.title = 'TVTK Scene'
        self.menu_bar_manager = create_ivtk_menu(self)

    ###########################################################################
    # `IWindow` interface.
    ###########################################################################
    def close(self):
        if self.scene is not None:
            self.scene.close()
        super(IVTK, self).close()

    ###########################################################################
    # Protected 'ApplicationWindow' interface.
    ###########################################################################

    # The icon of the window
    icon = Instance(ImageResource, scene_icon)

    def _create_contents(self, parent):
        """ Create the contents of the window. """

        self.scene = self._scene_factory(parent)

        return self.scene.control

######################################################################
# `IVTKWithBrowser` class.
######################################################################
class IVTKWithBrowser(ApplicationWindow):
    """ Provides an Scene along without an embedded Python shell.
    This is useful when scripting from the vanilla Python or IPython
    interpreter."""

    # The `Scene` instance into which VTK renders.
    scene = Instance(Scene)

    # The `PipelineBrowser` instance.
    browser = Instance(PipelineBrowser)

    # The ordered split window to use.
    browser_scene = Instance(SceneWithBrowser)

    ###########################################################################
    # 'object' interface.
    ###########################################################################
    def __init__(self, **traits):
        """ Creates a new application window. """

        # Base class constructor.
        super(IVTKWithBrowser, self).__init__(**traits)
        self.title = 'TVTK Scene'
        self.menu_bar_manager = create_ivtk_menu(self)

    ###########################################################################
    # `IWindow` interface.
    ###########################################################################
    def close(self):
        if self.scene is not None:
            self.scene.close()
        super(IVTKWithBrowser, self).close()

    ###########################################################################
    # Protected 'ApplicationWindow' interface.
    ###########################################################################

    # The icon of the window
    icon = Instance(ImageResource, scene_icon)

    def _create_contents(self, parent):
        """ Create the contents of the window. """

        self.browser_scene = SceneWithBrowser(parent)
        self.scene = self.browser_scene.scene
        self.browser = self.browser_scene.browser
        return self.browser_scene.control


######################################################################
# Utility functions.
######################################################################
def viewer(browser=True, instantiate_gui=False):
    """Creates an IVTK instance, opens the window and returns the
    embedded scene inside it.  This is useful from an IPython/vanilla
    Python shell.  It returns the viewer window instance.

    Parameters
    ----------

    - browser : `bool` (default, True)

      If True, creates an IVTK scene with an embedded PipelineBrowser.
      If False, does not create it.

    - instantiate_gui : `bool` (default: False)

      If True, create an instance of GUI().  This is useful when this
      function is invoked from within an IPython shell.  OTOH, if this
      is called from within a wxPython app (or with ipython -wthread)
      you don't want to start another GUI instance.
    """
    if instantiate_gui:
        gui = GUI()
    if browser:
        v = IVTKWithBrowser(size=(600,600))
    else:
        v = IVTK(size=(600,600))
    v.open()
    return v


def main():
    # Create the GUI.
    gui = GUI()
    # Create and open an application window.
    window = IVTKWithCrustAndBrowser(size=(800,600))
    window.open()
    # Start the GUI event loop!
    gui.start_event_loop()


if __name__ == '__main__':
    main()

########NEW FILE########
__FILENAME__ = mlab
"""A module that provides Matlab like 3d visualization functionality.

The general idea is shamelessly stolen from the `high-level API`_
provided by Octaviz_. Some of the test cases and demos are also
translated from there!

.. _Octaviz: http://octaviz.sourceforge.net/
.. _high-level API: http://octaviz.sourceforge.net/index.php?page=manpagesq

The implementation provided here is object oriented and each
visualization capability is implemented as a class that has traits.
So each of these may be configured.  Each visualization class derives
(ultimately) from MLabBase which is responsible for adding/removing
its actors into the render window.  The classes all require that the
RenderWindow be a `pyface.tvtk.scene.Scene` instance (this constraint
can be relaxed if necessary later on).

This module offers the following broad class of functionality:

`Figure`
  This basically manages all of the objects rendered.  Just like
  figure in any Matlab like environment.  A convenience function
  called `figure` may be used to create a nice Figure instance.

`Glyphs`
  This and its subclasses let one place glyphs at points specified as
  inputs.  The subclasses are: `Arrows`, `Cones`, `Cubes`,
  `Cylinders`, `Spheres`, and `Points`.

`Line3`
  Draws lines between the points specified at initialization time.

`Outline`
  Draws an outline for the contained objects.

`Title`
  Draws a title for the entire figure.

`LUTBase`
  Manages a lookup table and a scalar bar (legend) for it.  This is
  subclassed by all classes that need a LUT.

`SurfRegular`
  MayaVi1's imv.surf like functionality that plots surfaces given x
  (1D), y(1D) and z (or a callable) arrays.

`SurfRegularC`
  Also plots contour lines.

`TriMesh`
  Given triangle connectivity and points, plots a mesh of them.

`FancyTriMesh`
  Plots the mesh using tubes and spheres so its fancier.

`Mesh`
  Given x, y generated from numpy.mgrid, and a z to go with it.  Along
  with optional scalars.  This class builds the triangle connectivity
  (assuming that x, y are from numpy.mgrid) and builds a mesh and
  shows it.

`FancyMesh`
  Like mesh but shows the mesh using tubes and spheres.

`Surf`
  This generates a surface mesh just like Mesh but renders the mesh as
  a surface.

`Contour3`
  Shows contour for a mesh.

`ImShow`
  Allows one to view large numeric arrays as image data using an image
  actor.  This is just like MayaVi1's `mayavi.tools.imv.viewi`.

To see nice examples of all of these look at the `test_*` functions at
the end of this file.  Here is a quick example that uses these test
functions::

 >>> from tvtk.tools import mlab
 >>> f = mlab.figure()
 >>> mlab.test_surf(f) # Create a spherical harmonic.
 >>> f.pop() # Remove it.
 >>> mlab.test_molecule(f) # Show a caffeine molecule.
 >>> f.renwin.reset_zoom() # Scale the view.
 >>> f.pop() # Remove this.
 >>> mlab.test_lines(f) # Show pretty lines.
 >>> f.clear() # Remove all the stuff on screen.

"""
# Author: Prabhu Ramachandran <prabhu_r@users.sf.net>
# Copyright (c) 2005-2007, Enthought, Inc.
# License: BSD Style.

from distutils.version import StrictVersion

import numpy

from traits.api import HasTraits, List, Instance, Any, Float, Bool, \
                                 Str, Trait, Int
from pyface.api import GUI

from tvtk.api import tvtk
from tvtk.tvtk_base import TVTKBase, vtk_color_trait
from tvtk.common import configure_input_data
from tvtk.tools import ivtk

# Set this to False to not use LOD Actors.
USE_LOD_ACTOR = True

VTK_VER = StrictVersion(tvtk.Version().vtk_version)

######################################################################
# Utility functions.
######################################################################
def _make_actor(**kwargs):
    """Return a TVTK actor.  If `mlab.USE_LOD_ACTOR` is `True` it
    returns an LODActor if not it returns a normal actor.
    """
    if USE_LOD_ACTOR:
        r = tvtk.LODActor(number_of_cloud_points=1500)
        r.property.point_size = 2.0
        r.set(**kwargs)
        return r
    else:
        return tvtk.Actor(**kwargs)


def _create_structured_points_direct(x, y, z=None):
    """Creates a StructuredPoints object given input data in the form
    of numpy arrays.

    Input Arguments:
       x -- Array of x-coordinates.  These should be regularly spaced.

       y -- Array of y-coordinates.  These should be regularly spaced.

       z -- Array of z values for the x, y values given.  The values
       should be computed such that the z values are computed as x
       varies fastest and y next.  If z is None then no scalars are
       associated with the structured points.  Only the structured
       points data set is created.
    """

    nx = len(x)
    ny = len(y)
    if z is not None:
        nz = numpy.size(z)
        assert nx*ny == nz, "len(x)*len(y) != len(z)"\
               "You passed nx=%d, ny=%d,  nz=%d"%(nx, ny, nz)

    xmin, ymin = x[0], y[0]
    dx, dy= (x[1] - x[0]), (y[1] - y[0])

    sp = tvtk.StructuredPoints(dimensions=(nx,ny,1),
                               origin=(xmin, ymin, 0),
                               spacing=(dx, dy, 1))
    if z is not None:
        sp.point_data.scalars = numpy.ravel(z)
        sp.point_data.scalars.name = 'scalars'
    return sp


def sampler(xa, ya, func, *args, **kwargs):
    """Samples a function at an array of ordered points (with equal
    spacing) and returns an array of scalars as per VTK's requirements
    for a structured points data set, i.e. x varying fastest and y
    varying next.

    Input Arguments:
        xa -- Array of x points.

        ya -- Array if y points.

        func -- function of x, and y to sample.

        args -- additional positional arguments for func()
        (default is empty)

        kwargs -- a dict of additional keyword arguments for func()
        (default is empty)
    """
    ret = func(xa[:,None] + numpy.zeros_like(ya),
               numpy.transpose(ya[:,None] + numpy.zeros_like(xa)),
               *args, **kwargs
               )
    return numpy.transpose(ret)


def _check_sanity(x, y, z):
    """Checks the given arrays to see if they are suitable for
    surf."""
    msg = "Only ravelled or 2D arrays can be viewed! "\
          "This array has shape %s" % str(z.shape)
    assert len(z.shape) <= 2, msg

    if len( z.shape ) == 2:
        msg = "len(x)*len(y) != len(z.flat).  You passed "\
              "nx=%d, ny=%d, shape of z=%s"%(len(x), len(y), z.shape)
        assert z.shape[0]*z.shape[1] == len(x)*len(y), msg

        msg = "length of y(%d) and x(%d) must match shape of z "\
              "%s. (Maybe you need to swap x and y?)"%(len(y), len(x),
                                                        str(z.shape))
        assert z.shape == (len(y), len(x)), msg


def squeeze(a):
    "Returns a with any ones from the shape of a removed"
    a = numpy.asarray(a)
    b = numpy.asarray(a.shape)
    val = numpy.reshape(a,
                          tuple(numpy.compress(numpy.not_equal(b, 1), b)))
    return val


def make_surf_actor(x, y, z, warp=1, scale=[1.0, 1.0, 1.0],
                    make_actor=True, *args, **kwargs):
    """Creates a surface given regularly spaced values of x, y and the
    corresponding z as arrays.  Also works if z is a function.
    Currently works only for regular data - can be enhanced later.

    Parameters
    ----------

        x -- Array of x points (regularly spaced)

        y -- Array if y points (regularly spaced)

        z -- A 2D array for the x and y points with x varying fastest
        and y next.  Also will work if z is a callable which supports
        x and y arrays as the arguments.

        warp -- If true, warp the data to show a 3D surface
        (default = 1).

        scale -- Scale the x, y and z axis as per passed values.
        Defaults to [1.0, 1.0, 1.0].

        make_actor -- also create actors suitably (default True)

        args -- additional positional arguments for func()
        (default is empty)

        kwargs -- a dict of additional keyword arguments for func()
        (default is empty)
    """

    if callable(z):
        zval = numpy.ravel(sampler(x, y, z, *args, **kwargs))
        x, y = squeeze(x), squeeze(y)
    else:
        x, y = squeeze(x), squeeze(y)
        _check_sanity(x, y, z)
        zval = numpy.ravel(z)
        assert len(zval) > 0, "z is empty - nothing to plot!"

    xs = x*scale[0]
    ys = y*scale[1]
    data = _create_structured_points_direct(xs, ys, zval)
    if not make_actor:
        return data
    if warp:
        geom_f = tvtk.ImageDataGeometryFilter()
        configure_input_data(geom_f, data)

        warper = tvtk.WarpScalar(scale_factor=scale[2])
        configure_input_data(warper, geom_f.output)
        normals = tvtk.PolyDataNormals(feature_angle=45)
        configure_input_data(normals, warper.output)

        mapper = tvtk.PolyDataMapper(scalar_range=(min(zval),max(zval)))
        configure_input_data(mapper, normals.output)
    else:
        mapper = tvtk.PolyDataMapper(scalar_range=(min(zval),max(zval)))
        configure_input_data(mapper, data)
    actor = _make_actor(mapper=mapper)
    return data, actor


def make_triangle_polydata(triangles, points, scalars=None):
    t = numpy.asarray(triangles, 'l')
    assert t.shape[1] == 3, "The list of polygons must be Nx3."

    if scalars is not None:
        assert len(points) == len(numpy.ravel(scalars))

    pd = tvtk.PolyData(points=points, polys=t)
    if scalars is not None:
        pd.point_data.scalars = numpy.ravel(scalars)
        pd.point_data.scalars.name = 'scalars'
    return pd


def make_triangles_points(x, y, z, scalars=None):
    """Given x, y, and z co-ordinates made using numpy.mgrid and
    optional scalars.  This function returns triangles and points
    corresponding to a mesh formed by them.

    Parameters
    ----------

    - x : array
        A list of x coordinate values formed using numpy.mgrid.
    - y : array
        A list of y coordinate values formed using numpy.mgrid.
    - z : array
        A list of z coordinate values formed using numpy.mgrid.
    - scalars : array (optional)
        Scalars to associate with the points.
    """
    assert len(x.shape) == 2, "Array x must be 2 dimensional."
    assert len(y.shape) == 2, "Array y must be 2 dimensional."
    assert len(z.shape) == 2, "Array z must be 2 dimensional."
    assert x.shape == y.shape, "Arrays x and y must have same shape."
    assert y.shape == z.shape, "Arrays y and z must have same shape."

    nx, ny = x.shape
    i, j = numpy.mgrid[0:nx-1,0:ny-1]
    i, j = numpy.ravel(i), numpy.ravel(j)
    t1 = i*ny+j, (i+1)*ny+j, (i+1)*ny+(j+1)
    t2 = (i+1)*ny+(j+1), i*ny+(j+1), i*ny+j
    nt = len(t1[0])
    triangles = numpy.zeros((nt*2, 3), 'l')
    triangles[0:nt,0], triangles[0:nt,1], triangles[0:nt,2] = t1
    triangles[nt:,0], triangles[nt:,1], triangles[nt:,2] = t2

    points = numpy.zeros((nx, ny, 3), 'd')
    points[:,:,0], points[:,:,1], points[:,:,2] = x, y, z
    points = numpy.reshape(points, (nx*ny, 3))

    return triangles, points



######################################################################
# `MLabBase` class.
######################################################################
class MLabBase(HasTraits):
    # List of actors.
    actors = List(TVTKBase)
    # Renderwindow to render into.
    renwin = Any

    def update(self):
        self.renwin.render()

    def render(self):
        if self.renwin:
            self.renwin.render()

    def _renwin_changed(self, old, new):
        if old:
            old.remove_actors(self.actors)
            old.render()
        if new:
            new.add_actors(self.actors)
            new.render()

    def _actors_changed(self, old, new):
        self._handle_actors(old, new)

    def _actors_items_changed(self, list_event):
        self._handle_actors(list_event.removed, list_event.added)

    def _handle_actors(self, removed, added):
        rw = self.renwin
        if rw:
            rw.remove_actors(removed)
            rw.add_actors(added)
            rw.render()



######################################################################
# `Glyphs` class.
######################################################################
class Glyphs(MLabBase):
    # The source glyph which is placed at various locations.
    glyph_source = Any

    # A Glyph3D instance replicates the glyph_sources at various
    # points.
    glyph = Instance(tvtk.Glyph3D, (), {'vector_mode':'use_vector',
                                        'scale_mode':'data_scaling_off'})

    # Color of the glyphs.
    color = vtk_color_trait((1.0, 1.0, 1.0))

    def __init__(self, points, vectors=None, scalars=None, **traits):
        super(Glyphs, self).__init__(**traits)

        if vectors is not None:
            assert len(points) == len(vectors)
        if scalars is not None:
            assert len(points) == len(scalars)

        self.points = points
        self.vectors = vectors
        self.scalars = scalars

        polys = numpy.arange(0, len(points), 1, 'l')
        polys = numpy.reshape(polys, (len(points), 1))
        pd = tvtk.PolyData(points=points, polys=polys)
        if self.vectors is not None:
            pd.point_data.vectors = vectors
            pd.point_data.vectors.name = 'vectors'
        if self.scalars is not None:
            pd.point_data.scalars = scalars
            pd.point_data.scalars.name = 'scalars'

        self.poly_data = pd

        configure_input_data(self.glyph, pd)
        if self.glyph_source:
            self.glyph.source = self.glyph_source.output

        mapper = tvtk.PolyDataMapper(input=self.glyph.output)
        actor = _make_actor(mapper=mapper)
        actor.property.color = self.color
        self.actors.append(actor)

    def update(self):
        self.poly_data.update()
        self.renwin.render()

    def _color_changed(self, val):
        if self.actors:
            self.actors[0].property.color = val
        self.render()

    def _glyph_source_changed(self, val):
        self.glyph.source = val.output
        self.render()


######################################################################
# `Arrows` class.
######################################################################
class Arrows(Glyphs):
    # The arrow glyph which is placed at various locations.
    glyph_source = Instance(tvtk.ArrowSource, ())

######################################################################
# `Cones` class.
######################################################################
class Cones(Glyphs):
    # The cone glyph which is placed at various locations.
    glyph_source = Instance(tvtk.ConeSource, ())

    # Radius of the cone.
    radius = Float(0.05, desc='radius of the cone')

    def __init__(self, points, vectors=None, scalars=None, **traits):
        super(Cones, self).__init__(points, vectors, scalars, **traits)
        self._radius_changed(self.radius)

    def _radius_changed(self, val):
        self.glyph_source.radius = val
        self.render()


######################################################################
# `Cubes` class.
######################################################################
class Cubes(Glyphs):
    # The cube glyph which is placed at various locations.
    glyph_source = Instance(tvtk.CubeSource, ())
    # The side length of the cube.
    length = Float(0.05, desc='side length of the cube')

    def __init__(self, points, vectors=None, scalars=None, **traits):
        super(Cubes, self).__init__(points, vectors, scalars, **traits)
        self._radius_changed(self.radius)

    def _length_changed(self, val):
        self.glyph_source.x_length = val
        self.glyph_source.y_length = val
        self.glyph_source.z_length = val
        self.render()


######################################################################
# `Cylinders` class.
######################################################################
class Cylinders(Glyphs):
    # The cylinder glyph which is placed at various locations.
    glyph_source = Instance(tvtk.CylinderSource, ())


######################################################################
# `Spheres` class.
######################################################################
class Spheres(Glyphs):
    # The sphere which is placed at various locations.
    glyph_source = Instance(tvtk.SphereSource, (),
                            {'phi_resolution':15,
                             'theta_resolution':30})
    # Radius of the sphere.
    radius = Float(0.05, desc='radius of the sphere')

    def __init__(self, points, vectors=None, scalars=None, **traits):
        super(Spheres, self).__init__(points, vectors, scalars, **traits)
        self._radius_changed(self.radius)

    def _radius_changed(self, val):
        self.glyph_source.radius = val
        self.render()


######################################################################
# `Points` class.
######################################################################
class Points(Glyphs):
    # The point which is placed at various locations.
    glyph_source = Instance(tvtk.PointSource, (),
                            {'radius':0, 'number_of_points':1})


######################################################################
# `Line3` class.
######################################################################
class Line3(MLabBase):
    # Radius of the tube filter.
    radius = Float(0.01, desc='radius of the tubes')
    # Should a tube filter be used or not.
    use_tubes = Bool(True,
                     desc='specifies if the tube filter should be used')

    # The Tube filter used to generate tubes from the lines.
    tube_filter = Instance(tvtk.TubeFilter, (), {'number_of_sides':6})

    # Color of the actor.
    color = vtk_color_trait((1.0, 1.0, 1.0))

    def __init__(self, points, **traits):
        super(MLabBase, self).__init__(**traits)

        assert len(points[0]) == 3, "The points must be 3D"

        self.points = points

        np = len(points) - 1
        lines = numpy.zeros((np, 2), 'l')
        lines[:,0] = numpy.arange(0, np-0.5, 1, 'l')
        lines[:,1] = numpy.arange(1, np+0.5, 1, 'l')
        pd = tvtk.PolyData(points=points, lines=lines)
        self.poly_data = pd

        mapper = tvtk.PolyDataMapper()
        self.mapper = mapper
        tf = self.tube_filter
        tf.radius = self.radius
        if self.use_tubes:
            configure_input_data(tf, pd)
            configure_input_data(mapper, tf.output)

        a = _make_actor(mapper=mapper)
        a.property.color = self.color
        self.actors.append(a)

    def _radius_changed(self, val):
        self.tube_filter.radius = val
        self.render()

    def _use_tubes_changed(self, val):
        if val:
            tf = self.tube_filter
            configure_input_data(tf, self.poly_data)
            configure_input_data(self.mapper, tf.output)
        else:
            configure_input_data(self.mapper, self.poly_data)
        self.render()

    def _color_changed(self, val):
        if self.actors:
            self.actors[0].property.color = val
        self.render()


######################################################################
# `Outline` class.
######################################################################
class Outline(MLabBase):
    # The axis instance to use to annotate the outline
    axis = Instance(tvtk.CubeAxesActor2D, (),
                    {'label_format':"%4.2g", 'fly_mode':"outer_edges",
                     'font_factor':1.25, 'number_of_labels':5,
                     'corner_offset':0.0, 'scaling':0})
    # The outline source.
    outline = Instance(tvtk.OutlineSource, ())

    def __init__(self, **traits):
        super(Outline, self).__init__(**traits)

        out_mapper = tvtk.PolyDataMapper(input=self.outline.output)
        out_actor = _make_actor(mapper=out_mapper)
        axis = self.axis
        if hasattr(axis, 'view_prop'):
            axis.view_prop = out_actor
        else:
            axis.prop = out_actor

        self.actors.extend([out_actor, axis])

    def update(self):
        if self.renwin:
            rw = self.renwin
            v1, v2 = [x.visibility for x in self.actors]
            self.actors[0].visibility = 0
            self.actors[1].visibility = 0
            rw.render()
            bounds = rw.renderer.compute_visible_prop_bounds()
            self.outline.bounds = bounds
            rw.render()
            self.actors[0].visibility = v1
            self.actors[1].visibility = v2

    def _renwin_changed(self, old, new):
        super(Outline, self)._renwin_changed(old, new)
        if old:
            old.on_trait_change(self.update, 'actor_added', remove=True)
            old.on_trait_change(self.update, 'actor_removed', remove=True)
        if new:
            self.axis.camera = new.renderer.active_camera
            new.on_trait_change(self.update, 'actor_added')
            new.on_trait_change(self.update, 'actor_removed')


######################################################################
# `Title` class.
######################################################################
class Title(MLabBase):
    # Text of the title.
    text = Str('Title', desc='text of the title')

    # The text actor that renders the title.
    text_actor = Instance(tvtk.TextActor, ())

    def __init__(self, **traits):
        super(Title, self).__init__(**traits)

        ta = self.text_actor
        if VTK_VER > '5.1':
            ta.set(text_scale_mode='prop', height=0.05, input=self.text)
        else:
            ta.set(scaled_text=True, height=0.05, input=self.text)
        pc = ta.position_coordinate
        pc.coordinate_system = 'normalized_viewport'
        pc.value = 0.25, 0.925, 0.0
        self.actors.append(self.text_actor)

    def _text_changed(self, val):
        self.text_actor.input = val
        self.render()

######################################################################
# `LUTBase` class.
######################################################################
class LUTBase(MLabBase):
    # The choices for the lookuptable
    lut_type = Trait('red-blue', 'red-blue', 'blue-red',
                     'black-white', 'white-black',
                     desc='the type of the lookup table')

    # The LookupTable instance.
    lut = Instance(tvtk.LookupTable, ())

    # The scalar bar.
    scalar_bar = Instance(tvtk.ScalarBarActor, (),
                          {'orientation':'horizontal',
                           'width':0.8, 'height':0.17})

    # The scalar_bar widget.
    scalar_bar_widget = Instance(tvtk.ScalarBarWidget, ())

    # The legend name for the scalar bar.
    legend_text = Str('Scalar', desc='the title of the legend')

    # Turn on/off the visibility of the scalar bar.
    show_scalar_bar = Bool(False,
                           desc='specifies if scalar bar is shown or not')

    def __init__(self, **traits):
        super(LUTBase, self).__init__(**traits)
        self.lut.number_of_colors = 256
        self._lut_type_changed(self.lut_type)
        self.scalar_bar.set(lookup_table=self.lut,
                            title=self.legend_text)
        pc = self.scalar_bar.position_coordinate
        pc.coordinate_system = 'normalized_viewport'
        pc.value = 0.1, 0.01, 0.0
        self.scalar_bar_widget.set(scalar_bar_actor=self.scalar_bar,
                                   key_press_activation=False)

    def _lut_type_changed(self, val):
        if val == 'red-blue':
            hue_range = 0.0, 0.6667
            saturation_range = 1.0, 1.0
            value_range = 1.0, 1.0
        elif val == 'blue-red':
            hue_range = 0.6667, 0.0
            saturation_range = 1.0, 1.0
            value_range = 1.0, 1.0
        elif val == 'black-white':
            hue_range = 0.0, 0.0
            saturation_range = 0.0, 0.0
            value_range = 0.0, 1.0
        elif val == 'white-black':
            hue_range = 0.0, 0.0
            saturation_range = 0.0, 0.0
            value_range = 1.0, 0.0
        lut = self.lut
        lut.set(hue_range=hue_range, saturation_range=saturation_range,
                value_range=value_range, number_of_table_values=256,
                ramp='sqrt')
        lut.force_build()

        self.render()

    def _legend_text_changed(self, val):
        self.scalar_bar.title = val
        self.scalar_bar.modified()
        self.render()

    def _show_scalar_bar_changed(self, val):
        if self.renwin:
            self.scalar_bar_widget.enabled = val
            self.renwin.render()

    def _renwin_changed(self, old, new):
        sbw = self.scalar_bar_widget
        if old:
            sbw.interactor = None
            old.render()
        if new:
            sbw.interactor = new.interactor
            sbw.enabled = self.show_scalar_bar
            new.render()
        super(LUTBase, self)._renwin_changed(old, new)



######################################################################
# `SurfRegular` class.
######################################################################
class SurfRegular(LUTBase):

    def __init__(self, x, y, z, warp=1, scale=[1.0, 1.0, 1.0], f_args=(),
                 f_kwargs=None, **traits):
        super(SurfRegular, self).__init__(**traits)

        if f_kwargs is None:
            f_kwargs = {}

        data, actor = make_surf_actor(x, y, z, warp, scale, *f_args,
                                      **f_kwargs)
        self.data = data
        mapper = actor.mapper
        mapper.lookup_table = self.lut
        self.lut.table_range = mapper.scalar_range

        self.actors.append(actor)


######################################################################
# `SurfRegularC` class.
######################################################################
class SurfRegularC(LUTBase):
    # Number of contours.
    number_of_contours = Int(10, desc='number of contours values')

    # The contour filter.
    contour_filter = Instance(tvtk.ContourFilter, ())

    def __init__(self, x, y, z, warp=1, scale=[1.0, 1.0, 1.0], f_args=(),
                 f_kwargs=None, **traits):
        super(SurfRegularC, self).__init__(**traits)

        if f_kwargs is None:
            f_kwargs = {}

        data, actor = make_surf_actor(x, y, z, warp, scale, *f_args,
                                      **f_kwargs)
        mapper = actor.mapper
        mapper.lookup_table = self.lut
        self.lut.table_range = mapper.scalar_range
        self.data = data

        dr = data.point_data.scalars.range
        cf = self.contour_filter
        configure_input_data(cf, data)
        cf.generate_values(self.number_of_contours, dr[0], dr[1])
        mapper = tvtk.PolyDataMapper(input=cf.output, lookup_table=self.lut)
        cont_actor = _make_actor(mapper=mapper)

        self.actors.extend([actor, cont_actor])

    def _number_of_contours_changed(self, val):
        dr = self.data.point_data.scalars.range
        self.contour_filter.generate_values(val, dr[0], dr[1])
        self.render()


######################################################################
# `TriMesh` class.
######################################################################
class TriMesh(LUTBase):
    # Disables/enables scalar visibility.
    scalar_visibility = Bool(False, desc='show scalar visibility')

    # Representation of the mesh as surface or wireframe.
    surface = Bool(False, desc='show as surface or wireframe')

    # Color of the mesh.
    color = vtk_color_trait((0.5, 1.0, 0.5))

    def __init__(self, triangles, points, scalars=None, **traits):
        """
        Parameters
        ----------

        - triangles : array
          This contains a list of vertex indices forming the triangles.
        - points : array
          Contains the list of points referred to in the triangle list.
        - scalars : array (optional)
          Scalars to associate with the points.
        """
        super(TriMesh, self).__init__(**traits)

        self.pd = make_triangle_polydata(triangles, points, scalars)

        mapper = tvtk.PolyDataMapper(input=self.pd, lookup_table=self.lut,
                                     scalar_visibility=self.scalar_visibility)
        if scalars is not None:
            rs = numpy.ravel(scalars)
            dr = min(rs), max(rs)
            mapper.scalar_range = dr
            self.lut.table_range = dr

        actor = _make_actor(mapper=mapper)
        representation = 'w'
        if self.surface:
            representation = 's'
        if representation == 'w':
            actor.property.set(diffuse=0.0, ambient=1.0, color=self.color,
                               representation=representation)
        else:
            actor.property.set(diffuse=1.0, ambient=0.0, color=self.color,
                               representation=representation)

        self.actors.append(actor)

    def _scalar_visibility_changed(self, val):
        if self.actors:
            mapper = self.actors[0].mapper
            mapper.scalar_visibility = val
        self.render()

    def _surface_changed(self, val):
        if self.actors:
            representation = 'w'
            if val:
                representation = 's'

            actor = self.actors[0]
            if representation == 'w':
                actor.property.set(diffuse=0.0, ambient=1.0,
                                   representation=representation)
            else:
                actor.property.set(diffuse=1.0, ambient=0.0,
                                   representation=representation)
        self.render()

    def _color_changed(self, val):
        if self.actors:
            self.actors[0].property.color = val
        self.render()


######################################################################
# `FancyTriMesh` class.
######################################################################
class FancyTriMesh(LUTBase):
    """Shows a mesh of triangles and draws the edges as tubes and
    points as balls."""
    # Disables/enables scalar visibility.
    scalar_visibility = Bool(False, desc='show scalar visibility')

    # Color of the mesh.
    color = vtk_color_trait((0.5, 1.0, 0.5))

    # The radius of the tubes.
    tube_radius = Float(0.0, desc='radius of the tubes')

    # The radius of the spheres.
    sphere_radius = Float(0.0, desc='radius of the spheres')

    # The TubeFilter used to make the tubes for the edges.
    tube_filter = Instance(tvtk.TubeFilter, (),
                           {'vary_radius':'vary_radius_off',
                            'number_of_sides':6})
    # The sphere source for the points.
    sphere_source = Instance(tvtk.SphereSource, (),
                             {'theta_resolution':12,
                              'phi_resolution':12})

    def __init__(self, triangles, points, scalars=None, **traits):
        """
        Parameters
        ----------

        - triangles : array
          This contains a list of vertex indices forming the triangles.
        - points : array
          Contains the list of points referred to in the triangle list.
        - scalars : array (optional)
          Scalars to associate with the points.
        """
        super(FancyTriMesh, self).__init__(**traits)

        self.points = points
        self.pd = make_triangle_polydata(triangles, points, scalars)

        # Update the radii so the default is computed correctly.
        self._tube_radius_changed(self.tube_radius)
        self._sphere_radius_changed(self.sphere_radius)

        scalar_vis = self.scalar_visibility

        # Extract the edges and show the lines as tubes.
        self.extract_filter = tvtk.ExtractEdges(input=self.pd)
        extract_f = self.extract_filter
        self.tube_filter.set(input=extract_f.output,
                             radius=self.tube_radius)
        edge_mapper = tvtk.PolyDataMapper(input=self.tube_filter.output,
                                          lookup_table=self.lut,
                                          scalar_visibility=scalar_vis)
        edge_actor = _make_actor(mapper=edge_mapper)
        edge_actor.property.color = self.color

        # Create the spheres for the points.
        self.sphere_source.radius = self.sphere_radius
        spheres = tvtk.Glyph3D(scaling=0, source=self.sphere_source.output,
                               input=extract_f.output)
        sphere_mapper = tvtk.PolyDataMapper(input=spheres.output,
                                            lookup_table=self.lut,
                                            scalar_visibility=scalar_vis)
        sphere_actor = _make_actor(mapper=sphere_mapper)
        sphere_actor.property.color = self.color

        if scalars is not None:
            rs = numpy.ravel(scalars)
            dr = min(rs), max(rs)
            self.lut.table_range = dr
            edge_mapper.scalar_range = dr
            sphere_mapper.scalar_range = dr

        self.actors.extend([edge_actor, sphere_actor])

    def _scalar_visibility_changed(self, val):
        if self.actors:
            for i in self.actors:
                i.mapper.scalar_visibility = val
        self.render()

    def _tube_radius_changed(self, val):
        points = self.points
        if val < 1.0e-9:
            val = (max(numpy.ravel(points)) -
                   min(numpy.ravel(points)))/250.0
        self.tube_radius = val
        self.tube_filter.radius = val
        self.render()

    def _sphere_radius_changed(self, val):
        points = self.points
        if val < 1.0e-9:
            val = (max(numpy.ravel(points)) -
                       min(numpy.ravel(points)))/100.0
        self.sphere_radius = val
        self.sphere_source.radius = val
        self.render()

    def _color_changed(self, val):
        if self.actors:
            self.actors[0].property.color = val
        self.render()

######################################################################
# `Mesh` class.
######################################################################
class Mesh(TriMesh):
    def __init__(self, x, y, z, scalars=None, **traits):
        """
        Parameters
        ----------

        - x : array
          A list of x coordinate values formed using numpy.mgrid.
        - y : array
          A list of y coordinate values formed using numpy.mgrid.
        - z : array
          A list of z coordinate values formed using numpy.mgrid.
        - scalars : array (optional)
          Scalars to associate with the points.
        """
        triangles, points = make_triangles_points(x, y, z, scalars)
        super(Mesh, self).__init__(triangles, points, scalars, **traits)


######################################################################
# `FancyMesh` class.
######################################################################
class FancyMesh(FancyTriMesh):
    def __init__(self, x, y, z, scalars=None, **traits):
        """
        Parameters
        ----------

        - x : array
          A list of x coordinate values formed using numpy.mgrid.
        - y : array
          A list of y coordinate values formed using numpy.mgrid.
        - z : array
          A list of z coordinate values formed using numpy.mgrid.
        - scalars : array (optional)
          Scalars to associate with the points.
        """
        triangles, points = make_triangles_points(x, y, z, scalars)
        super(FancyMesh, self).__init__(triangles, points, scalars, **traits)


######################################################################
# `Surf` class.
######################################################################
class Surf(LUTBase):
    # Disables/enables scalar visibility.
    scalar_visibility = Bool(True, desc='show scalar visibility')

    # Color of the mesh.
    color = vtk_color_trait((0.5, 1.0, 0.5))

    def __init__(self, x, y, z, scalars=None, **traits):
        """
        Parameters
        ----------

        - x : array
          A list of x coordinate values formed using numpy.mgrid.
        - y : array
          A list of y coordinate values formed using numpy.mgrid.
        - z : array
          A list of z coordinate values formed using numpy.mgrid.
        - scalars : array (optional)
          Scalars to associate with the points.
        """
        super(Surf, self).__init__(**traits)
        triangles, points = make_triangles_points(x, y, z, scalars)
        self.pd = make_triangle_polydata(triangles, points, scalars)

        mapper = tvtk.PolyDataMapper(input=self.pd, lookup_table=self.lut,
                                     scalar_visibility=self.scalar_visibility)
        if scalars is not None:
            rs = numpy.ravel(scalars)
            dr = min(rs), max(rs)
            mapper.scalar_range = dr
            self.lut.table_range = dr

        actor = _make_actor(mapper=mapper)
        actor.property.set(color=self.color)
        self.actors.append(actor)

    def _scalar_visibility_changed(self, val):
        if self.actors:
            mapper = self.actors[0].mapper
            mapper.scalar_visibility = val
        self.render()

    def _surface_changed(self, val):
        if self.actors:
            representation = 'w'
            if val:
                representation = 's'
            self.actors[0].property.representation = representation
        self.render()

    def _color_changed(self, val):
        if self.actors:
            self.actors[0].property.color = val
        self.render()


######################################################################
# `Contour3` class.
######################################################################
class Contour3(LUTBase):
    # Number of contours.
    number_of_contours = Int(10, desc='number of contours values')

    # The contour filter.
    contour_filter = Instance(tvtk.ContourFilter, ())

    def __init__(self, x, y, z, scalars, **traits):
        """
        Parameters
        ----------

        - x : array
          A list of x coordinate values formed using numpy.mgrid.
        - y : array
          A list of y coordinate values formed using numpy.mgrid.
        - z : array
          A list of z coordinate values formed using numpy.mgrid.
        - scalars : array
          Scalars to associate with the points.
        """
        super(Contour3, self).__init__(**traits)
        triangles, points = make_triangles_points(x, y, z, scalars)
        self.pd = make_triangle_polydata(triangles, points, scalars)

        dr = self.pd.point_data.scalars.range
        self.lut.table_range = dr

        cf = self.contour_filter
        configure_input_data(cf, self.pd)
        cf.generate_values(self.number_of_contours, dr[0], dr[1])
        mapper = tvtk.PolyDataMapper(input=cf.output, lookup_table=self.lut,
                                     scalar_range=dr)
        cont_actor = _make_actor(mapper=mapper)

        self.actors.append(cont_actor)

    def _number_of_contours_changed(self, val):
        dr = self.pd.point_data.scalars.range
        self.contour_filter.generate_values(val, dr[0], dr[1])
        self.render()


######################################################################
# `ImShow` class.
######################################################################
class ImShow(LUTBase):
    """Allows one to view a 2D numpy array as an image.  This works
    best for very large arrays (like 1024x1024 arrays).
    """

    # Interpolate the image or not.
    interpolate = Bool(False, desc='specifies if image should be interpolated')

    def __init__(self, arr, scale=[1.0, 1.0, 1.0], **traits):
        """
        Parameters
        ----------
        - arr : Array to be viewed.

        - scale : Scale the x, y and z axis as per passed values.
          Defaults to [1.0, 1.0, 1.0].
        """
        super(ImShow, self).__init__(**traits)

        assert len(arr.shape) == 2, "Only 2D arrays can be viewed!"

        ny, nx = arr.shape
        dx, dy, junk = numpy.array(scale)*1.0
        xa = numpy.arange(0, nx*scale[0] - 0.1*dx, dx, 'f')
        ya = numpy.arange(0, ny*scale[1] - 0.1*dy, dy, 'f')

        arr_flat = numpy.ravel(arr)
        min_val = min(arr_flat)
        max_val = max(arr_flat)

        sp = _create_structured_points_direct(xa, ya)
        lut = self.lut
        lut.table_range = min_val, max_val
        a = lut.map_scalars(arr_flat, 0, 0)
        sp.point_data.scalars = a
        sp.point_data.scalars.name = 'scalars'
        sp.scalar_type = 'unsigned_char'
        sp.number_of_scalar_components = 4

        ia = tvtk.ImageActor(input=sp, interpolate=self.interpolate)

        self.actors.append(ia)

    def _interpolate_changed(self, val):
        if self.actors:
            ia = self.actors[0]
            ia.interpolate = val
        self.render()


######################################################################
# `Figure` class.
######################################################################
class Figure(HasTraits):
    """A Figure manages varuous MLabBase objects.  Each of these
    objects contains an actor and does something neat."""

    # The various instances of MLabBase that populate this figure.
    objects = List(MLabBase)

    def __init__(self, renwin, **traits):
        super(Figure, self).__init__(**traits)
        self.renwin = renwin

    def add(self, obj):
        """Add an object to the figure.  This adds the actors of the
        object to the renderwindow."""
        self.objects.append(obj)

    def pop(self):
        """Pops out the last object."""
        return self.objects.pop()

    def clear(self):
        """Removes all objects in the figure."""
        self.objects = []

    def _objects_changed(self, new, old):
        self._handle_objects(new, old)

    def _objects_items_changed(self, list_event):
        self._handle_objects(list_event.removed, list_event.added)

    def _handle_objects(self, removed, added):
        for obj in removed:
            obj.renwin = None
        rw = self.renwin
        for obj in added:
            obj.renwin = rw
        rw.reset_zoom()
        rw.render()


def figure(outline=True, browser=True):
    """Simple helper function that returns a usable figure.

    Parameters
    ----------

    - outline : `bool` (default: True)

      If True, create an outline bounding box along with an axes
      marker for the scene.

    - browser : `bool` (default, True)

      If True, creates an IVTK scene with an embedded PipelineBrowser.
      If False, does not create it.
    """
    v = ivtk.viewer(browser)
    f = Figure(v.scene)
    if outline:
        o = Outline()
        f.add(o)
    v.scene.reset_zoom()
    return f


######################################################################
# Test functions.
######################################################################
def test_arrows(fig):
    a = Arrows([[-1,-1,-1],[1,0,0]], [[1,1,1],[0,1,0]], color=(1,0,0))
    fig.add(a)


def test_lines(fig):
    """Generates a pretty set of lines."""
    n_mer, n_long = 6, 11
    pi = numpy.pi
    dphi = pi/1000.0
    phi = numpy.arange(0.0, 2*pi + 0.5*dphi, dphi, 'd')
    mu = phi*n_mer
    x = numpy.cos(mu)*(1+numpy.cos(n_long*mu/n_mer)*0.5)
    y = numpy.sin(mu)*(1+numpy.cos(n_long*mu/n_mer)*0.5)
    z = numpy.sin(n_long*mu/n_mer)*0.5

    pts = numpy.zeros((len(mu), 3), 'd')
    pts[:,0], pts[:,1], pts[:,2] = x, y, z

    l = Line3(pts, radius=0.05, color=(0.0, 0.0, 0.8))

    fig.add(l)

def test_molecule(fig):
    """Generates and shows a Caffeine molecule."""
    o = [[30, 62, 19],[8, 21, 10]]
    n = [[31, 21, 11], [18, 42, 14], [55, 46, 17], [56, 25, 13]]
    c = [[5, 49, 15], [30, 50, 16], [42, 42, 15], [43, 29, 13], [18, 28, 12],
         [32, 6, 8], [63, 36, 15], [59, 60, 20]]
    h = [[23, 5, 7], [32, 0, 16], [37, 5, 0], [73, 36, 16], [69, 60, 20],
         [54, 62, 28], [57, 66, 12], [6, 59, 16], [1, 44, 22], [0, 49, 6]]

    oxygen = Spheres(o, radius=8, color=(1,0,0))
    nitrogen = Spheres(n, radius=10, color=(0,0,1))
    carbon = Spheres(c, radius=10, color=(0,1,0))
    hydrogen = Spheres(h, radius=5, color=(1,1,1))

    for i in oxygen, nitrogen, carbon, hydrogen:
        fig.add(i)

def test_trimesh(fig):
    """Test for simple triangle mesh."""
    pts = numpy.array([[0.0,0,0], [1.0,0.0,0.0], [1,1,0]], 'd')
    triangles = [[0, 1, 2]]
    t1 = TriMesh(triangles, pts)
    fig.add(t1)
    pts1 = pts.copy()
    pts1[:,2] = 1.0
    t2 = FancyTriMesh(triangles, pts1)
    fig.add(t2)

def test_surf_regular(fig, contour=1):
    """Test Surf on regularly spaced co-ordinates like MayaVi."""
    def f(x, y):
        return numpy.sin(x*y)/(x*y)

    x = numpy.arange(-7., 7.05, 0.1)
    y = numpy.arange(-5., 5.05, 0.05)
    if contour:
        s = SurfRegularC(x, y, f)
    else:
        s = SurfRegular(x, y, f)
    fig.add(s)


def test_simple_surf(fig):
    """Test Surf with a simple collection of points."""
    x, y = numpy.mgrid[0:3:1,0:3:1]
    z = x
    s = Surf(x, y, z, numpy.asarray(z, 'd'))
    fig.add(s)

def test_surf(fig):
    """A very pretty picture of spherical harmonics translated from
    the octaviz example."""
    pi = numpy.pi
    cos = numpy.cos
    sin = numpy.sin
    dphi, dtheta = pi/250.0, pi/250.0
    [phi,theta] = numpy.mgrid[0:pi+dphi*1.5:dphi,0:2*pi+dtheta*1.5:dtheta]
    m0 = 4; m1 = 3; m2 = 2; m3 = 3; m4 = 6; m5 = 2; m6 = 6; m7 = 4;
    r = sin(m0*phi)**m1 + cos(m2*phi)**m3 + sin(m4*theta)**m5 + cos(m6*theta)**m7
    x = r*sin(phi)*cos(theta)
    y = r*cos(phi)
    z = r*sin(phi)*sin(theta);

    s = Surf(x, y, z, z)
    fig.add(s)

def test_mesh_sphere(fig):
    """Create a simple sphere and test the mesh."""
    pi = numpy.pi
    cos = numpy.cos
    sin = numpy.sin
    du, dv = pi/20.0, pi/20.0
    phi, theta = numpy.mgrid[0.01:pi+du*1.5:du, 0:2*pi+dv*1.5:dv]
    r = 1.0
    x = r*sin(phi)*cos(theta)
    y = r*sin(phi)*sin(theta)
    z = r*cos(phi)
    s = FancyMesh(x, y, z, z, scalar_visibility=True)
    fig.add(s)

def test_mesh(fig):
    """Create a fancy looking mesh (example taken from octaviz)."""
    pi = numpy.pi
    cos = numpy.cos
    sin = numpy.sin
    du, dv = pi/20.0, pi/20.0
    u, v = numpy.mgrid[0.01:pi+du*1.5:du, 0:2*pi+dv*1.5:dv]
    x = (1- cos(u))*cos(u+2*pi/3) * cos(v + 2*pi/3.0)*0.5
    y = (1- cos(u))*cos(u+2*pi/3) * cos(v - 2*pi/3.0)*0.5
    z = cos(u-2*pi/3.)

    m = FancyMesh(x, y, z, z, scalar_visibility=True)
    fig.add(m)

def test_imshow(fig):
    """Show a large random array."""
    z_large = numpy.random.random((1024, 512))
    i = ImShow(z_large)
    fig.add(i)


def main():
    gui = GUI()
    # Create and open an application window.
    window = ivtk.IVTKWithCrustAndBrowser(size=(800,600))
    window.open()
    f = Figure(window.scene)

    # Create an outline.
    o = Outline()
    f.add(o)

    # Create some pretty pictures.
    #test_lines(f)
    test_surf(f)

    window.scene.reset_zoom()

    # Start the GUI event loop!
    gui.start_event_loop()


if __name__ == '__main__':
    main()

########NEW FILE########
__FILENAME__ = tvtk_doc
"""

Utility code that provides classes helpful in choosing a suitable TVTK
class.  It does this by providing a list of all the classes along with
the option to be able to search for the documentation.

The nice thing about the UI is that it performs some kind of completion
on names typed by the user, plus it allows users to search through the
TVTK class docs very easily.  Once a search string is typed the
completion and available lists are modified so you can do completion of
the searched class names.  If a unique enough string is typed the class
docs are shown.

"""
# Author: Prabhu Ramachandran <prabhu [at] aero . iitb . ac . in>
# Copyright (c) 2008,  Enthought, Inc.
# License: BSD Style.

# Standard library imports.
import vtk
import types
import inspect

# Enthought library imports.
from traits.api import HasTraits, Property, List, Str, \
                                 Instance, Button, Int
from traitsui.api import View, Group, Item, EnumEditor,\
                                    ListEditor, TextEditor
from tvtk.api import tvtk
from tvtk.common import get_tvtk_name

################################################################################
# Utility functions.
################################################################################
def get_tvtk_class_names():
    """Returns 4 lists:

     1. A list of all the TVTK class names that are not abstract.

     2. A list of the TVTK sources (have only outputs and no inputs)

     3. A list of the TVTK filters (both inputs and outputs)

     4. A list of the TVTK sinks (only inputs and no outputs)

    """
    # Shut of VTK warnings for the time being.
    o = vtk.vtkObject
    w = o.GetGlobalWarningDisplay()
    o.SetGlobalWarningDisplay(0) # Turn it off.

    all = []
    src = []
    filter = []
    sink = []
    for name in dir(vtk):
        if name.startswith('vtk') and not name.startswith('vtkQt'):
            klass = getattr(vtk, name)
            try:
                c = klass()
            except (TypeError, NotImplementedError):
                continue

            tvtk_name = get_tvtk_name(name)
            all.append(tvtk_name)
            has_input = has_output = False
            if hasattr(klass, 'GetNumberOfInputPorts'):
                if c.GetNumberOfInputPorts() > 0:
                    has_input = True
            if hasattr(klass, 'GetNumberOfOutputPorts'):
                if c.GetNumberOfOutputPorts() > 0:
                    has_output = True

            if has_input:
                if has_output:
                    filter.append(tvtk_name)
                else:
                    sink.append(tvtk_name)
            elif has_output:
                src.append(tvtk_name)

    o.SetGlobalWarningDisplay(w)

    result = (all, src, filter, sink)
    for x in result:
        x.sort()

    return result

def get_func_doc(func, fname):
    """Returns function documentation."""
    if inspect.isfunction(func):
        func_obj = func
    elif inspect.ismethod(func):
        func_obj = func.im_func
    else:
        return ''
    args, vargs, vkw = inspect.getargs(func_obj.func_code)
    defaults = func_obj.func_defaults
    doc = fname + inspect.formatargspec(args, vargs, vkw, defaults)
    d = inspect.getdoc(func)
    if d is not None:
        doc += '\n\n' + d + '\n\n'
    return doc

def get_tvtk_class_doc(obj):
    """Return's the objects documentation."""
    doc = obj.__doc__ + '\nTraits:\n-------------------\n\n'

    ignore = ['trait_added', 'trait_modified']
    for key, trait in obj.traits().iteritems():
        if key.startswith('_') or key.endswith('_') or key in ignore:
            continue
        doc += '\n%s: %s'%(key, trait.help)

    doc += '\nMethods:\n----------------------\n\n'
    traits = obj.trait_names()
    for name in dir(obj):
        if name in traits or name.startswith('_'):
            continue
        if name.find('trait') > -1 and name != 'update_traits':
            continue
        func = getattr(obj, name)
        if callable(func):
            doc += '\n' + get_func_doc(func, name)

    return doc

# GLOBALS
TVTK_CLASSES, TVTK_SOURCES, TVTK_FILTERS, TVTK_SINKS = get_tvtk_class_names()

################################################################################
# `DocSearch` class.
################################################################################
class DocSearch(object):

    """A simple class that provides a method to search through class
    documentation.  This code is taken from mayavi-1.x's ivtk.VtkHelp

    """

    # These are class attributes to prevent regenerating them everytime
    # this class is instantiated.
    VTK_CLASSES = []
    VTK_CLASS_DOC = []

    def __init__(self):
        self.vtk_classes = self.VTK_CLASSES
        self.vtk_c_doc = self.VTK_CLASS_DOC

        if len(self.VTK_CLASSES) == 0:
            self._setup_data()

    def _setup_data(self):
        self.vtk_classes = [x for x in dir(vtk) if x.startswith('vtk')]
        n = len(self.vtk_classes)
        # Store the class docs in the list given below.
        self.vtk_c_doc = ['']*n

        # setup the data.
        for i in range(n):
            c = self.vtk_classes[i]
            try:
                doc = getattr(vtk, c).__doc__.lower()
                self.vtk_c_doc[i] = doc
            except AttributeError:
                pass

    def search(self, word):
        """ Search for word in class documentation and return matching
        classes.  This is also case insensitive.  The searching
        supports the 'and' and 'or' keywords that allow for fairly
        complex searches.  A space between words assumes that the two
        words appear one after the other.

        Parameters
        ----------
            word -- name to search for.
        """
        assert type(word) in types.StringTypes, \
               "Sorry, passed argument, %s is not a string."%word
        if len(word.strip()) == 0:
            return []

        lword = word.lower().strip()
        tmp_list = lword.split()
        wlist = []
        prev = ""
        for w in tmp_list:
            z = w.strip()
            if z in ('and', 'or'):
                if prev and prev not in ('and', 'or'):
                    wlist.append(prev)
                    wlist.append(z)
                    prev = z
            else:
                if prev and prev not in ('and', 'or'):
                    prev = prev + ' ' + z
                else:
                    prev = z

        if prev in ('and', 'or'):
            del wlist[-1]
        elif prev:
            wlist.append(prev)

        ret = []
        i = 0
        vtk_classes = self.vtk_classes
        vtk_c_doc = self.vtk_c_doc
        N = len(vtk_classes)
        while i < N:
            stored_test = 0
            do_test = ''
            for w in wlist:
                if w == 'and':
                    do_test = 'and'
                elif w == 'or':
                    do_test = 'or'
                else:
                    test = (vtk_c_doc[i].find(w) > -1)
                    if do_test == 'and':
                        stored_test = stored_test and test
                    elif do_test == 'or':
                        stored_test = stored_test or test
                    elif do_test == '':
                        stored_test = test
            if stored_test:
                ret.append(vtk_classes[i])
            i = i + 1

        return [get_tvtk_name(x) for x in ret]

_search_help_doc =  """
                        Help on Searching
           ---------------------------------------

To search for a particular TVTK class, type in the 'class_name' text entry
widget.  The class names are all case sensitive.   You may also select
the class from the list of available class names at the top.

As you type you will see completion options in the completions
list, the instant a complete match is found the class documentation will
be show in the bottom.

You can also search the TVTK class documentation for strings (case
insensitive).  The search option supports the 'and' and 'or' keywords to
do advanced searches.  Press <Enter>/<Return> to perform the search.

The top 25 hits will show up in the completions, to view a particular
hit either select the choice from the available ones or type in the
name in the 'class_name' entry box.  To clear the search string click
the 'Clear search' button or erase the search string manually.

"""


################################################################################
# `TVTKClassChooser` class.
################################################################################
class TVTKClassChooser(HasTraits):

    # The selected object, is None if no valid class_name was made.
    object = Property

    # The TVTK class name to choose.
    class_name = Str('', desc='class name of TVTK class (case sensitive)')

    # The string to search for in the class docs -- the search supports
    # 'and' and 'or' keywords.
    search = Str('', desc='string to search in TVTK class documentation '\
                          'supports the "and" and "or" keywords. '\
                          'press <Enter> to start search. '\
                          'This is case insensitive.')

    clear_search = Button

    # The class documentation.
    doc = Str(_search_help_doc)

    # Completions for the choice of class.
    completions = List(Str)

    # List of available class names as strings.
    available = List(TVTK_CLASSES)

    ########################################
    # Private traits.

    finder = Instance(DocSearch)

    n_completion = Int(25)

    ########################################
    # View related traits.

    view = View(Group(Item(name='class_name',
                           editor=EnumEditor(name='available')),
                      Item(name='class_name',
                           has_focus=True
                           ),
                      Item(name='search',
                           editor=TextEditor(enter_set=True,
                                             auto_set=False)
                           ),
                      Item(name='clear_search',
                           show_label=False),
                      Item('_'),
                      Item(name='completions',
                           editor=ListEditor(columns=3),
                           style='readonly'
                           ),
                      Item(name='doc',
                           resizable=True,
                           label='Documentation',
                           style='custom')
                      ),
                id='tvtk_doc',
                resizable=True,
                width=800,
                height=600,
                title='TVTK class chooser',
                buttons = ["OK", "Cancel"]
                )
    ######################################################################
    # `object` interface.
    ######################################################################
    def __init__(self, **traits):
        super(TVTKClassChooser, self).__init__(**traits)
        self._orig_available = list(self.available)

    ######################################################################
    # Non-public interface.
    ######################################################################
    def _get_object(self):
        o = None
        if len(self.class_name) > 0:
            try:
                o = getattr(tvtk, self.class_name)()
            except (AttributeError, TypeError):
                pass
        return o

    def _class_name_changed(self, value):
        av = self.available
        comp = [x for x in av if x.startswith(value)]
        self.completions = comp[:self.n_completion]
        if len(comp) == 1 and value != comp[0]:
            self.class_name = comp[0]

        o = self.object
        if o is not None:
            self.doc = get_tvtk_class_doc(o)
        else:
            self.doc = _search_help_doc

    def _finder_default(self):
        return DocSearch()

    def _clear_search_fired(self):
        self.search = ''

    def _search_changed(self, value):
        if len(value) < 3:
            self.available = self._orig_available
            return

        f = self.finder
        result = f.search(str(value))
        if len(result) == 0:
            self.available = self._orig_available
        elif len(result) == 1:
            self.class_name = result[0]
        else:
            self.available = result
            self.completions = result[:self.n_completion]


################################################################################
# `TVTKSourceChooser` class.
################################################################################
class TVTKSourceChooser(TVTKClassChooser):
    available = List(TVTK_SOURCES)

################################################################################
# `TVTKFilterChooser` class.
################################################################################
class TVTKFilterChooser(TVTKClassChooser):
    available = List(TVTK_FILTERS)

################################################################################
# `TVTKSinkChooser` class.
################################################################################
class TVTKSinkChooser(TVTKClassChooser):
    available = List(TVTK_SINKS)


def main():
    """Pops up a class chooser which doubles as a nice help search
    documentation tool.
    """
    s = TVTKClassChooser()
    s.configure_traits()

if __name__ == '__main__':
    main()

########NEW FILE########
__FILENAME__ = visual
""" A module that provides VPython like capabilities.  For more
details about VPython, refer the official website.
VPython : http://www.vpython.org/index.html

The API is based on VPython, but instead of using OpenGL and other C
libraries, this is based completly on TVTK, and Traits and Numpy.
All of the demos are also translated from VPython examples.

The implementation is done using object oriented design, and each
visualization capability is implemented as a seperate traits class.
The attributes of each class could be independently edited.

The API is kept as similar to VPython as much as possible.

This module offers the following classes :

 Display actors
 sphere, cylinder, cone, box, arrow, curve, ring, helix, ellipsoid

 Functionality classes
 frame, vector, animator

 Utility functions
 iterator, remove_actor, show

To see examples of classes and functions look at the `test_*`
functions at the end of this file. Here is a quick example
demonstrating how to use visual.

Note: To provide threading support for WXWidgets which are essential
for all GUI fucntionalities in visual, the visual module should be
interactively used in ipython only when wthread mode is
enabled. visual will not work properly in an interactive mode in
vanilla python interpretor.
::

    $ ipython -wthread

    In [1]: from tvtk.tools import visual
    In [2]: visual.test_sphere()
    In [3]: s = visual.sphere() # Create a sphere actor
    In [4]: s.edit_traits() # Edit sphere actor's properties via GUI

"""
# Author: Raashid Baig <raashid@aero.iitb.ac.in>
#         Prabhu Ramachandran <prabhu_r@users.sf.net>
#
# License: BSD Style.
# Version: 1.0
# Year : 2007

# Standard library imports.
import sys
import numpy
import time
from math import sin, cos, pi, sqrt, acos, asin
from vtk.util import colors as color

# Enthought library imports.
from traits.api import HasTraits, Trait, Instance, Tuple, Int, \
     Float, Range, Button, Array, Color, Bool, Any, List, Enum
from traitsui.api import View, Item, Group, RGBColorEditor, RangeEditor
from traitsui.message import message
from tvtk.api import tvtk
from tvtk.tools import ivtk
from tvtk.common import configure_input_data
from pyface.api import GUI
from pyface.timer.api import Timer
from tvtk.tvtk_base import TVTKBase, vtk_color_trait



# Set the global variable to None, for it's future use in function
# get_viewer()
_viewer = None

#################################################################
################       Utility function      ####################
#################################################################

def _create_viewer():
    """Creates and retunrs the ivtk viewer to get_viewer() function"""
    v = ivtk.viewer(browser = False)
    v.scene.background = (0,0,0)
    GUI.process_events()
    return v

def set_viewer(viewer):
    """Set the global viewer.  Handy if you need to use visual from your
    own viewer.  Pass an object that has a `scene` trait containing a
    tvtk scene instance.
    """
    global _viewer
    _viewer = viewer

def get_viewer():
    """ Creates and returns an ivtk viewer. If the fuction is called
    1st time than creates and returns the viewer, otherwise the
    originally created viewer itself is returned. Checking is done
    through the global variable _viewer.
    """
    global _viewer
    if _viewer is None:
        # If no viewer has been created till this point in program
        # _create_viewer() is called and a new ivtk viewer is created
        _viewer = _create_viewer()
    else:
        try:
            _viewer.scene.render()
        except:
            # If the original ivtk window is destroyed when function
            # is called more than once an exception is raised so that
            # a new ivtk browser is created and returned.
            _viewer = _create_viewer()
    return _viewer

def show_actor(*tvtk_actors):
    """ Gets an ivtk viewer from the function get_viewer() and adds
    all the actors given, to the ivtk scene.
    """
    v = get_viewer()
    v.scene.add_actors(tvtk_actors)
    v.scene.reset_zoom()

def remove_actor(*tvtk_actors):
    """ Gets the ivtk viewer from the function get_viewer() and
    removes all the actors given, from the ivtk scene."""
    v = get_viewer()
    for x in tvtk_actors:
        v.scene.remove_actors(x.actor)
        v.scene.reset_zoom()

def show():
    """This function has to be called at the end in a stand alone
    visual program. Note - Don't call this function when running
    visual from ipython iterpretor in an interactive mode
    """
    if '-wthread' in sys.argv:
        pass
    else:
        gui = GUI()
        gui.start_event_loop()

def iterate(millisec, callable, *args, **kwargs):
    """Creates an instance of utility class Animator and returns it,
    used for programs with animations, see examples for demonstration
    """
    return Animator(millisec, callable, *args, **kwargs)

def translate(old, new, points):
    """Translate function takes 3 arguments the old position, new
    position and the points. The function translates all the points to
    the new position and returns the new points"""
    diff = new - old
    points[:] = points + diff
    return points

def translate_points(diff, points):
    """Translate function takes 2 arguments the with which the points
    are required to be translated and the points. The function
    translates all the points to the new position and returns the new
    points"""
    points[:] = points + diff
    return points

def _create_rotation_matrix(axis, angle):
    """Create a rotation matrix given an axis and an angle (in
    degrees) to rotate by.
    """
    axis = numpy.asarray(axis, dtype = float)
    axis /= sqrt(numpy.inner(axis, axis)) #Normalizing the axis
    x = axis[0]
    y = axis[1]
    z = axis[2]
    t = angle*pi/180
    cost = cos(t)
    sint = sin(t)
    rotator = numpy.zeros((3,3), float)
    rotator[0][0] = cost + (1-cost)*(x*x)
    rotator[0][1] = (1-cost)*x*y - (sint)*z
    rotator[0][2] = (1-cost)*x*z + (sint)*y

    rotator[1][0] = (1-cost)*y*x + (sint)*z
    rotator[1][1] = cost + (1-cost)*(y*y)
    rotator[1][2] = (1-cost)*y*z - (sint)*x

    rotator[2][0] = (1-cost)*z*x - (sint)*y
    rotator[2][1] = (1-cost)*z*y + (sint)*x
    rotator[2][2] = cost + (1-cost)*(z*z)
    return rotator

def axis_changed(old, new, pos, points):
    """The function takes 4 arguments, the old and the new axis, the
    position and points. All arguments should be given as a numpy
    array, The first 3 can also be given in form of a tuple. The
    function rotates all the points so that they become aligned with
    the new axis"""
    # Creating a working normalized copy of old axis
    o = old/float(sqrt(numpy.inner(old, old)))
    # Creating a working normalized copy of new axis
    n = new/sqrt(numpy.inner(new, new))
    dpdt = numpy.dot(o, n)
    if abs(abs(dpdt) - 1.0) < 1e-10:
        if dpdt < 0:
            #This is a must in the case when the new and the old axis are
            #opposite to each other
            diff = -pos
            points = translate_points(diff, points)
            #Flipping the points to reverse the axis
            points[:] = -points
            diff = pos
            points = translate_points(diff, points)
            return points
        else:
            #This is useful in the case when the new and the old axis are
            #very close to each other
            return points
    alpha = acos(dpdt)# Calculating angle between the old & new axis
    raxis = numpy.cross(o, n)# Calculating the axis about which to rotate
    #Creating the rotation multiplication matrix
    data = _create_rotation_matrix(raxis, 180.0*alpha/pi)

    if (numpy.allclose(pos, 0.0)):
        points[:] = numpy.dot(points, data.T)
        return points
    else:
        diff = -pos
        points = translate_points(diff, points)
        points[:] = numpy.dot(points, data.T)
        diff = pos
        points = translate_points(diff, points)
        return points

def rotate(axis, angle, origin, pos, points, maxis):
    """Rotate function takes 6 arguments the axis about which the
    actor has to be rotated, the angle with which the actor has to be
    rotated, the point (origin) about which actor has to be rotated
    and posistion, points and current axis of the actor. The function
    returns the new position, points and axis of the actor after the
    rotation."""
    data = _create_rotation_matrix(axis, angle)

    if (numpy.allclose(pos, 0.0) and numpy.allclose(origin, 0.0)):
        points[:] = numpy.dot(points, data.T)
        raxis = numpy.dot(maxis, data.T)
        return pos, points, raxis
    else:
        diff = (-1*origin[0], -1*origin[1], -1*origin[2])
        pos = pos - origin
        points = translate_points(diff, points)
        points[:] = numpy.dot(points, data.T)
        pos = numpy.dot(pos, data.T)
        diff = (origin[0], origin[1], origin[2])
        points = translate_points(diff, points)
        pos = pos + origin
        raxis = numpy.dot(maxis, data.T)
        return pos, points, raxis

def rotate_single_point(axis, angle, origin, pos, maxis):
    """Rotate function takes 5 arguments the axis about which the
    actor has to be rotated, the angle with which the actor has to be
    rotated, the point (origin) about which actor has to be rotated
    and posistion, and current axis of the actor. The function returns
    the new position and new axis of the actor after the rotation."""
    axis = numpy.asarray(axis, dtype = float)
    data = _create_rotation_matrix(axis, angle)

    if (numpy.allclose(pos, 0.0)):
        raxis = numpy.dot(maxis, data.T)
        return pos, raxis
    else:
        pos = pos - origin
        pos = numpy.dot(pos, data.T)
        pos = pos + origin
        raxis = pos/sqrt(numpy.inner(pos, pos))
        return pos, raxis

def scale(scale_factor, points, pos):
    """Scale function takes 2 arguments the scaling_factor in a form
    of list, or a tuple giving the scale factor for x,y and z
    axis. The function returns the new points ofthe actor after
    scaling"""
    #Creating the scaling multiplication matrix
    sc = numpy.asarray(scale_factor, dtype=float)
    data = numpy.diag(sc)

    if (numpy.allclose(pos, 0.0)):
        points[:] = numpy.dot(points, data.T)
        return points
    else:
        diff = (-1*pos[0], -1*pos[1], -1*pos[2])
        points = translate_points(diff, points)
        points[:] = numpy.dot(points, data.T)
        diff = (pos[0], pos[1], pos[2])
        points = translate_points(diff, points)
        return points

#################################################################
####################### Functionality classes ###################
#################################################################

class VTimer(Timer):
    def __init__(self, millisecs, callable, *args, **kw_args):
        #Initializing the init method of parent class Timer
        Timer.__init__(self, millisecs, callable, *args, **kw_args)
        self.viewer = get_viewer()
        self.viewer.on_trait_change(self._close, 'closing')

    def _close(self):
        self.Stop()
        print "Stopping iterations since the viewer has been closed."

    def Notify(self):
        """Overridden to call the given callable.
        """
        try:
            self.callable(*self.args, **self.kw_args)
        except StopIteration:
            self.Stop()
        except:
            self.Stop()
            raise

class Animator(HasTraits):
    #####################################################################
    # Traits definitions

    start_animation = Button('Start Animation')
    stop_animation = Button('Stop Animation')
    time_period = Range(1, 100000, 100,
                      desc='Specifies frequency with which timer is called')

    itimer = Instance(VTimer)

    ######################################################################
    # User interface view

    event_group = Group(Item('start_animation', style = 'simple'),
                         Item('_'),
                         Item('stop_animation', style = 'simple'),
                         Item('_'),
                         show_labels = False,)

    traits_view = View(event_group,
                       Item(name = 'time_period'),
                       title = 'Animation Controler', buttons = ['OK'], width = 250)


    ######################################################################
    # Initialize object
    def __init__(self, millisec, callable, *args, **kwargs):
        self.time_period = millisec
        self.itimer = VTimer(millisec, callable, *args, **kwargs)

    ######################################################################
    # Non-public methods, Event handlers
    def _start_animation_fired(self):
        self.itimer.Start()

    def _stop_animation_fired(self):
        self.itimer.Stop()

    def _time_period_changed(self, value):
        t = self.itimer
        if t is None:
            return
        t.millisec = value
        if t.IsRunning():
            t.Stop()
            t.Start(value)

class MVector(numpy.ndarray):
    """MVector class gives many of the functionalities given by Vector
    of VPython"""
    def __new__(subtype, x = 0.0, y = 0.0, z = 0.0):
        data = numpy.array((x, y, z), float)
        ret = numpy.ndarray.__new__(subtype, shape = (3,),
                                    buffer = data, dtype=float,
                                    order = False)
        return ret.copy()

    def _get_x(self):
        return self[0]

    def _set_x(self, val):
        self[0] = val

    x = property(_get_x, _set_x)

    def _get_y(self):
        return self[1]

    def _set_y(self, val):
        self[1] = val

    y = property(_get_y, _set_y)

    def _get_z(self):
        return self[2]

    def _set_z(self, val):
        self[2] = val

    z = property(_get_z, _set_z)

    def dot(vec1, vec2):
        """ Function performs the dot vector multiplication of 2
        vector instances and returning a new vector instance equal to
        the dot product of given vectors"""
        i = vec1.x * vec2.x
        j = vec1.y * vec2.y
        k = vec1.z * vec2.z
        dot = i + j + k
        return dot

    def cross(vec1, vec2):
        """ Function performing the cross vector multiplication of 2
        vector instances and returning a new vector instance equal to
        the cross product of given vectors"""
        i = (vec1.y*vec2.z - vec1.z*vec2.y)
        j = (vec1.z*vec2.x - vec1.x*vec2.z)
        k = (vec1.x*vec2.y - vec1.y*vec2.x)
        cross = MVector(i, j, k)
        return cross

    def mag(vec):
        """ Function computes and returns the magnitude of a vector"""
        mag = sqrt(vec[0]**2 + vec[1]**2 + vec[2]**2)
        return mag

    def norm(vec):
        """ Function computes and returns the normalized form of a
        given vector"""
        norm = vec/sqrt(numpy.inner(vec, vec))
        return norm

class Frame(HasTraits):
    """Frame groups together all the actors given to it into a single
    unit, so that they can be manipulated as a combined entity."""
    #####################################################################
    # Traits definitions

    axis = Array(value = (1.0, 0.0, 0.0), desc = 'the frame axis')
    x = Range(-1e299, 1e299, 0.0, desc = 'the X coordinate of frame objects')
    y = Range(-1e299, 1e299, 0.0, desc = 'the Y coordinate of frame objects')
    z = Range(-1e299, 1e299, 0.0, desc = 'the Z coordinate of frame objects')
    pos = Array(value = (0.0, 0.0, 0.0), desc = 'the frame pos')
    objects = List
    visibility = Bool(True)
    viewer = Any

    ######################################################################
    # User interface view

    traits_view = View(Group(Item(name = 'x', label = 'Pos X'),
                             Item(name = 'y', label = 'Pos Y'),
                             Item(name = 'z', label = 'Pos Z'),
                             Item(name = 'visibility'),
                             label = 'Frame Properties',
                             show_border = True),
                             buttons=['OK'],
                             )

    def __init__(self, *arguments, **traits):
        self.arg = list(arguments)
        HasTraits.__init__(self, **traits)

        self.keys = traits.keys()

        self._pos_changed(numpy.array([0.0, 0.0, 0.0]), self.pos)
        self._x_changed(0.0, self.x)
        self._y_changed(0.0, self.y)
        self._z_changed(0.0, self.z)
        #self._axis_changed(numpy.array([1.0, 0.0, 0.0]), self.axis)

    ######################################################################
    # Non-public methods, Event handlers
    def _pos_changed(self, old, new):
        diff = new - old
        for a in self.arg:
            a.pos = a.pos + diff

    def _x_changed(self, old, new):
        diff = new - old
        for a in self.arg:
            a.x = a.x + diff

    def _y_changed(self, old, new):
        diff = new - old
        for a in self.arg:
            a.y = a.y + diff

    def _z_changed(self, old, new):
        diff = new - old
        for a in self.arg:
            a.z = a.z + diff

    def _axis_changed(self, old, new):
        if (numpy.allclose(old, new)):
            pass
        else:
            o = old/sqrt(numpy.inner(old, old))
            n = new/sqrt(numpy.inner(new, new))
            raxis = numpy.cross(o, n)
            # raxis is the axis about which the rotation of th objects
            # will be performed so that they have the new axis
            alpha = acos(numpy.dot(o, n))
            # alpha is the angle between the old and the new axis
            alpha = 180.0*alpha/pi
            for a in self.arg:
                a.rotate(alpha, raxis, self.pos)

    def _visibility_changed(self, value):
        val = int(value)
        if (val == 1):
            for a in self.arg:
                a.actor.visibility = 1
        else:
            for a in self.arg:
                a.actor.visibility = 0

    ######################################################################
    # Object's public methods
    def rotate(self, angle, axis, origin = numpy.array([0.0, 0.0, 0.0])):
        for a in self.arg:
            a.rotate(angle, axis, origin)
        pts = numpy.array([1.0, 0.0, 0.0])#junk points passed as arguments
        pos, pts, faxis = rotate(axis, angle, origin, self.pos, pts, self.axis)
        self.set(pos=pos, axis = faxis, trait_change_notify = False)


###################################################################
###################### Actor Classes ##############################
###################################################################

class Curve(HasTraits):
    """Curve class creates a polydata source using point and
    connectivity arrays given by the user, which inturn is used to
    create a polydata actor"""
    #####################################################################
    # Traits definitions

    points = Trait(None, None, Array('d', shape=(None,3)), desc='the points of the curve')
    pos = Array(value = (0.0, 0.0, 0.0), desc = 'the curve pos')
    radius = Range(0.0, 1.0e299, value = 0.01, desc = 'the radius of curve tube')
    axis = Array(value = (1.0, 0.0, 0.0), desc = 'the curve axis')
    x = Range(-1e299, 1e299, 0.0, desc = 'the X coordinate of curve')
    y = Range(-1e299, 1e299, 0.0, desc = 'the Y coordinate of curve')
    z = Range(-1e299, 1e299, 0.0, desc = 'the Z coordinate of curve')
    color = vtk_color_trait((1.0, 1.0, 1.0))
    representation = Enum('s', 'w', 'p')
    visibility = Bool(True)

    polydata = Instance(tvtk.PolyData, args=())
    property = Instance(tvtk.Property)
    stripper = Instance(tvtk.Stripper, args=())
    tube = Instance(tvtk.TubeFilter, args=())
    actor = Instance(tvtk.Actor, args=()) # tvtk Actor, for the usual pipeline architecture.

    viewer = Any

    ######################################################################
    # User interface view

    traits_view = View(Group(Item(name = 'color'),
                             Item(name = 'visibility'),
                             Item(name = 'radius'),
                             Item(name = 'x', label = 'Pos X'),
                             Item(name = 'y', label = 'Pos Y'),
                             Item(name = 'z', label = 'Pos Z'),
                             Item(name = 'representation'),
                             label = 'Curve Properties',
                             show_border = True),
                             buttons=['OK'],
                             )

    def __init__(self, **traits):
        self.property = self.actor.property

        HasTraits.__init__(self, **traits)

        self._points_changed(self.points)
        self._color_changed(self.color)
        self._visibility_changed(self.visibility)
        self._radius_changed(self.radius)
        self._axis_changed(numpy.array((1.0, 0.0, 0.0)), self.axis)

        configure_input_data(self.stripper, self.polydata)
        configure_input_data(self.tube, self.stripper.output)
        self.tube.number_of_sides = 4
        self.tube.capping = 1

        m = tvtk.PolyDataMapper()
        configure_input_data(m, self.tube.output)
        self.actor.mapper = m
        self.stripper.update()
        self.tube.update()
        self.actor.mapper.update()
        self.property = self.actor.property
        self.property.representation = self.representation
        show_actor(self.actor)
        self.viewer = get_viewer()

        self.property.on_trait_change(self.viewer.scene.render)
        self.actor.on_trait_change(self.viewer.scene.render)
        self.tube.on_trait_change(self.viewer.scene.render)

    ######################################################################
    # Object's public methods
    def append(self, pnt):
        """Function appeneds new points given as arguments to the
        current points"""
        self.extend([pnt])

    def extend(self, pts):
        if self.points is None:
            p = pts
        else:
            n = self.points.shape[0]
            p = numpy.resize(self.points, (n+len(pts), 3))
            p[:n] = self.points
            p[n:] = pts
        self.points = p
        self.update()

    def update(self):
        self.polydata.modified()
        self.stripper.update()
        self.tube.update()
        self.actor.mapper.update()
        self.viewer.scene.render()

    def rotate(self, angle, axis, origin = numpy.array([0.0, 0.0, 0.0])):
        """Function takes atleast 2 arguments: axis about which to
        rotate the actor and angle with which to rotate the actor, the
        3rd agrument is origin i.e. the point about which to rotate
        the actor, by default it is set to the global origin"""
        p, pi, ax = rotate(axis, angle, origin, self.pos, self.points, numpy.array([0.0, 0.0, 0.0]))
        self.set(pos = p, trait_change_notify = False)
        self.set(points = pi, trait_change_notify = False)
        self.set(axis = ax, trait_change_notify = False)
        self.polydata.points = self.points
        self.polydata.modified()
        self.stripper.update()
        self.tube.update()
        self.actor.mapper.update()
        self.render()

    def render(self):
        """Function redraws/refreshs the ivtk viewer's scene"""
        v = self.viewer
        if v is not None:
            v.scene.render()

    ######################################################################
    # Non-public methods, Event handlers
    def _points_changed(self, value):
        self.polydata.points = value
        if value is None:
            np = 0
            lines = None
        else:
            np = len(self.points) - 1
            lines = numpy.zeros((np, 2), 'l')
            lines[:,0] = numpy.arange(0, np-0.5, 1, 'l')
            lines[:,1] = numpy.arange(1, np+0.5, 1, 'l')
        self.polydata.lines = lines
        self.polydata.modified()
        self.stripper.update()
        self.tube.update()
        v = self.viewer
        if v is not None:
            v.scene.render()

    def _x_changed(self, value):
        self.x = value
        self.pos = (self.x, self.pos[1],self.pos[2])

    def _y_changed(self, value):
        self.y = value
        self.pos = (self.pos[0], self.y, self.pos[2])

    def _z_changed(self, value):
        self.z = value
        self.pos = (self.pos[0], self.pos[1], self.z)

    def _pos_changed(self, old, new):
        self.set(x = new[0], trait_change_notify = False)
        self.set(y = new[1], trait_change_notify = False)
        self.set(z = new[2], trait_change_notify = False)
        p = translate(old, new, self.points)
        self.set(points = p, trait_change_notify = False)
        self.polydata.points = self.points
        self.polydata.modified()
        self.stripper.update()
        self.tube.update()
        self.actor.mapper.update()
        self.render()

    def _axis_changed(self, old, new):
        self.points = axis_changed(old, new, self.pos, self.points)
        self.polydata.points = self.points
        self.polydata.modified()
        self.stripper.update()
        self.tube.update()
        self.render()

    def _color_changed(self, value):
        self.actor.property.color = value

    def _radius_changed(self, value):
        self.tube.radius = self.radius

    def _representation_changed(self, value):
        self.property.representation = self.representation
        self.property.modified()
        self.render()

    def _visibility_changed(self, value):
        val = int(value)
        if (val == 1):
            self.actor.visibility = 1
        else:
            self.actor.visibility = 0

class Ring(HasTraits):
    """Ring class creates a Ring form tvtk polydata, follows
    the usual VTK pipeline and creates a ring actor."""
    #####################################################################
    # Traits definitions

    points = Array('d', shape = (360,3))
    radius = Range(-1e299, 1e299, value = 0.5, desc = 'the ring radius')
    pos = Array(value = (0.0, 0.0, 0.0), desc = 'the ring pos')
    axis = Array(value = (1.0, 0.0, 0.0), desc = 'the ring axis')
    color = vtk_color_trait((1.0, 1.0, 1.0))
    x = Range(-1e299, 1e299, 0.0, desc = 'the X coordinate of ring center')
    y = Range(-1e299, 1e299, 0.0, desc = 'the Y coordinate of ring center')
    z = Range(-1e299, 1e299, 0.0, desc = 'the Z coordinate of ring center')
    representation = Enum('s', 'w', 'p')
    thickness = Range(0, 1e299, value = 0.01, desc = 'the ring thickness')
    visibility = Bool(True)
    viewer = Any

    polydata = Instance(tvtk.PolyData, ())
    property = Instance(tvtk.Property)
    tube = Instance(tvtk.TubeFilter, ())
    actor = Instance(tvtk.Actor, ()) # tvtk Actor, for the usual pipeline architecture.
    normals = Instance(tvtk.PolyDataNormals(), ())

    ######################################################################
    # User interface view

    traits_view = View(Group(Item(name = 'radius'),
                             Item(name = 'thickness'),
                             Item(name = 'x', label = 'Pos X'),
                             Item(name = 'y', label = 'Pos Y'),
                             Item(name = 'z', label = 'Pos Z'),
                             Item(name = 'color'),
                             Item(name = 'visibility'),
                             Item(name = 'representation'),
                             label = 'Ring Properties',
                             show_border = True),
                             buttons=['OK'],
                        )

    def __init__(self, **traits):
        self.property = self.actor.property

        HasTraits.__init__(self, **traits)

        self._create_points()
        self._pos_changed(numpy.array([0.0, 0.0, 0.0]), self.pos)
        self._x_changed(self.x)
        self._y_changed(self.y)
        self._z_changed(self.z)
        self._color_changed(self.color)
        self._visibility_changed(self.visibility)
        self._thickness_changed(self.thickness)
        self._axis_changed(numpy.array((1.0, 0.0, 0.0)), self.axis)

        self.normals = tvtk.PolyDataNormals()
        configure_input_data(self.normals, self.polydata)
        configure_input_data(self.tube, self.normals.outputs)
        self.normals.update()
        self.tube.update()
        self.tube.number_of_sides = 4
        self.tube.capping = 1

        m = tvtk.PolyDataMapper()
        configure_input_data(m, self.tube.outputs)
        self.actor.mapper = m
        self.property = self.actor.property
        self.property.representation = self.representation
        show_actor(self.actor)
        self.viewer = get_viewer()

        self.property.on_trait_change(self.viewer.scene.render)
        self.actor.on_trait_change(self.viewer.scene.render)
        self.tube.on_trait_change(self.viewer.scene.render)

    ######################################################################
    # Non-public methods, Event handlers
    def _create_points(self):
        for i in range(0,360,1):
            theta = i*pi/180
            self.points[i][0] = 0.0
            self.points[i][1] = self.radius*sin(theta)
            self.points[i][2] = self.radius*cos(theta)

        np = len(self.points) - 1
        lines = numpy.zeros((np, 2), 'l')
        lines[:,0] = numpy.arange(0, np-0.5, 1, 'l')
        lines[:,1] = numpy.arange(1, np+0.5, 1, 'l')
        self.polydata.points = self.points
        self.polydata.lines = lines
        v = self.viewer
        if v is not None:
            v.scene.render()

    def _color_changed(self, value):
        self.actor.property.color = value

    def _radius_changed(self, old, new):
        factor = new/old

        if (numpy.allclose(self.pos, 0.0)):
            self.points[:] = factor*self.points[:]
            self.polydata.modified()
            self.normals.update()
            self.tube.update()
            self.actor.mapper.update()
            self.render()
        else:
            c = self.pos
            diff = (0.0, 0.0, 0.0) - c
            self.points = translate_points(diff, self.points)
            self.points[:] = factor*self.points[:]
            diff = c
            self.points = translate_points(diff, self.points)
            self.polydata.points = self.points
            self.polydata.modified()
            self.normals.update()
            self.actor.mapper.update()
            self.tube.update()
            self.render()

    def _x_changed(self, value):
        self.x = value
        self.pos = (self.x, self.pos[1],self.pos[2])

    def _y_changed(self, value):
        self.y = value
        self.pos = (self.pos[0], self.y, self.pos[2])

    def _z_changed(self, value):
        self.z = value
        self.pos = (self.pos[0], self.pos[1], self.z)

    def _pos_changed(self, old, new):
        self.set(x = new[0], trait_change_notify = False)
        self.set(y = new[1], trait_change_notify = False)
        self.set(z = new[2], trait_change_notify = False)
        self.points = translate(old, new, self.points)
        self.polydata.points = self.points
        self.polydata.modified()
        self.normals.update()
        self.tube.update()
        self.actor.mapper.update()
        self.render()

    def _axis_changed(self, old, new):
        self.points = axis_changed(old, new, self.pos, self.points)
        self.polydata.points = self.points
        self.polydata.modified()
        self.normals.update()
        self.tube.update()
        self.render()

    def _representation_changed(self, value):
        self.property.representation = self.representation
        self.property.modified()
        self.render()

    def _visibility_changed(self, value):
        val = int(value)
        if (val == 1):
            self.actor.visibility = 1
        else:
            self.actor.visibility = 0

    def _thickness_changed(self, value):
        self.tube.radius = value

    ######################################################################
    # Object's public methods
    def rotate(self, angle, axis, origin = numpy.array([0.0, 0.0, 0.0])):
        """Function takes atleast 2 arguments: angle with which to
        rotate the actor, and the axis about which to rotate the
        actor, the 3rd agrument is origin i.e. the point about which
        to rotate the actor, by default it is set to the global origin"""
        p, pi, ax = rotate(axis, angle, origin, self.pos, self.points, self.axis)
        self.set(pos = p, trait_change_notify = False)
        self.points = pi
        self.set(axis = ax, trait_change_notify = False)
        self.polydata.points = self.points
        self.polydata.modified()
        self.normals.update()
        self.tube.update()
        self.actor.mapper.update()
        self.render()

    def render(self):
        v = self.viewer
        if v is not None:
            v.scene.render()


class Cone(HasTraits):
    """Cone class creates Cone from polydata obtained from tvtk
    ConeSource, follows the usual VTK pipeline and creates a Cone
    actor, which is passed to the show_actor() function as an
    argument.
    """
    #####################################################################
    # Traits definitions

    points = Array('d', shape = (7,3))
    radius = Range(0.0, 100.0, value = 0.5, desc = 'the cone radius')
    height = Range(0.0, 100.0, value = 1.0, desc = 'the cone height')
    pos = Array(value = (0.0, 0.0, 0.0), desc = 'the cone pos')
    axis = Array(value = (1.0, 0.0, 0.0), desc = 'the cone axis')
    color = vtk_color_trait((1.0, 1.0, 1.0))
    x = Range(-1e299, 1e299, 0.0, desc = 'the X coordinate of cone center')
    y = Range(-1e299, 1e299, 0.0, desc = 'the Y coordinate of cone center')
    z = Range(-1e299, 1e299, 0.0, desc = 'the Z coordinate of cone center')
    representation = Enum('s', 'w', 'p')
    visibility = Bool(True)
    viewer = Any

    polydata = Instance(tvtk.PolyData, ())
    property = Instance(tvtk.Property)
    actor = Instance(tvtk.Actor, ())

    ######################################################################
    # User interface view

    traits_view = View(Group(Item(name = 'radius'),
                             Item(name = 'height'),
                             Item(name = 'x', label = 'Pos X'),
                             Item(name = 'y', label = 'Pos Y'),
                             Item(name = 'z', label = 'Pos Z'),
                             Item(name = 'color'),
                             Item(name = 'visibility'),
                             Item(name = 'representation'),
                             label = 'Cone Properties',
                             show_border = True),
                             buttons=['OK'],
                             )

    def __init__(self, **traits):
        self.property = self.actor.property

        HasTraits.__init__(self, **traits)

        self._create_points(self.radius, self.height, self.pos, self.axis)
        self._pos_changed(numpy.array([0.0, 0.0, 0.0]), self.pos)
        self._x_changed(self.x)
        self._y_changed(self.y)
        self._z_changed(self.z)
        self._color_changed(self.color)

        m = tvtk.PolyDataMapper()
        configure_input_data(m, self.polydata)
        self.actor.mapper = m
        self.property = self.actor.property
        self.property.representation = self.representation
        show_actor(self.actor) # passing the actors function for rendering
        self.viewer = get_viewer() # getting the ivtk viewer

        self.property.on_trait_change(self.viewer.scene.render)
        self.actor.on_trait_change(self.viewer.scene.render)

    ######################################################################
    # Non-public methods, Event handlers
    def _create_points(self, r, h, c, d):
        cs = tvtk.ConeSource(radius = r, height = h, center = tuple(c), direction = tuple(d))
        cs.update()
        ps = cs.output

        points = ps.points.to_array()
        self.points = points
        self.polydata.points = self.points
        self.polydata.polys = ps.polys
        return points, ps.polys

    def _color_changed(self, value):
        self.actor.property.color = value

    def _radius_changed(self):
        points, lines = self._create_points(self.radius, self.height, self.pos, self.axis)
        self.polydata.points = points
        self.polydata.modified()
        self.actor.mapper.update()
        self.render()

    def _height_changed(self):
        points, lines = self._create_points(self.radius, self.height, self.pos, self.axis)
        self.polydata.points = points
        self.polydata.modified()
        self.actor.mapper.update()
        self.render()

    def _pos_changed(self, old, new):
        self.set(x = new[0], trait_change_notify = False)
        self.set(y = new[1], trait_change_notify = False)
        self.set(z = new[2], trait_change_notify = False)
        points, lines = self._create_points(self.radius, self.height, self.pos, self.axis)
        self.points = points
        self.polydata.modified()
        self.actor.mapper.update()
        self.render()

    def _axis_changed(self):
        points, lines = self._create_points(self.radius, self.height, self.pos, self.axis)
        self.polydata.points = points
        self.polydata.modified()
        self.render()

    def _x_changed(self, value):
        self.x = value
        self.pos = (self.x, self.pos[1],self.pos[2])

    def _y_changed(self, value):
        self.y = value
        self.pos = (self.pos[0], self.y, self.pos[2])

    def _z_changed(self, value):
        self.z = value
        self.pos = (self.pos[0], self.pos[1], self.z)

    def _representation_changed(self, value):
        self.property.representation = self.representation
        self.property.modified()
        self.render()

    def _visibility_changed(self, value):
        val = int(value)
        if (val == 1):
            self.actor.visibility = 1
        else:
            self.actor.visibility = 0

    ######################################################################
    # Object's public methods
    def rotate(self, angle, axis, origin = numpy.array([0.0, 0.0, 0.0])):
        """Function takes atleast 2 arguments: axis about which to
        rotate the actor and angle with which to rotate the actor, the
        3rd agrument is origin i.e. the point about which to rotate
        the actor, by default it is set to the global origin"""
        p, pi, ax = rotate(axis, angle, origin, self.pos, self.points, self.axis)
        self.set(pos = p, trait_change_notify = False)
        self.points = pi
        self.set(axis = ax, trait_change_notify = False)
        self.polydata.points = self.points
        self.polydata.modified()
        self.actor.mapper.update()
        self.render()

    def render(self):
        v = self.viewer
        if v is not None:
            v.scene.render()

class Sphere(HasTraits):
    """Sphere class creates Sphere from tvtk SphereSource, follows the
    usual VTK pipeline and creates a Sphere actor, which is passed to
    the show_actor() function as an argument.
    """
    #####################################################################
    # Traits definitions

    radius = Range(0.0, 1e299, value = 0.5, desc = 'the sphere radius')
    pos = Array(value = (0.0, 0.0, 0.0), desc = 'the sphere pos')
    axis = Array(value = (1.0, 0.0, 0.0), desc= 'the sphere axis')
    color = vtk_color_trait((1.0, 1.0, 1.0))
    x = Range(-1e299, 1e299, 0.0, desc = 'the X coordinate of sphere center')
    y = Range(-1e299, 1e299, 0.0, desc = 'the Y coordinate of sphere center')
    z = Range(-1e299, 1e299, 0.0, desc = 'the Z coordinate of sphere center')
    representation = Enum('s', 'w', 'p')
    visibility = Bool(True)
    viewer = Any

    polydata = Instance(tvtk.PolyData, ())
    property = Instance(tvtk.Property)
    actor = Instance(tvtk.Actor, ()) # tvtk Actor, for the usual pipeline architecture.
    normals = Instance(tvtk.PolyDataNormals, ())

    ######################################################################
    # User interface view

    traits_view = View(Group(Item(name = 'radius', style = 'simple'),
                             Item(name = 'x', label = 'Pos X'),
                             Item(name = 'y', label = 'Pos Y'),
                             Item(name = 'z', label = 'Pos Z'),
                             Item(name = 'color'),
                             Item(name = 'visibility'),
                             Item(name = 'representation'),
                             label = 'Sphere Properties',
                             show_border = True),
                             buttons=['OK'],
                             )

    def __init__(self, **traits):
        self.property = self.actor.property

        HasTraits.__init__(self, **traits)

        self._create_points(self.radius, self.pos)
        self._color_changed(self.color)
        self._visibility_changed(self.visibility)
        self._x_changed(self.x)
        self._y_changed(self.y)
        self._z_changed(self.z)

        self.normals = tvtk.PolyDataNormals()
        configure_input_data(self.normals, self.polydata)
        self.normals.update()
        m = tvtk.PolyDataMapper() # the usual vtk pipleine countinuation
        configure_input_data(m, self.normals.output)
        self.actor.mapper = m
        self.property = self.actor.property
        self.property.representation = self.representation
        show_actor(self.actor) # passing the actors function for rendering
        self.viewer = get_viewer() # getting the ivtk viewer

        self.property.on_trait_change(self.viewer.scene.render)
        self.actor.on_trait_change(self.viewer.scene.render)

    ######################################################################
    # Non-public methods, Event handlers
    def _create_points(self, r, c):
        sp = tvtk.SphereSource(radius = r, center = tuple(c), 
                               phi_resolution = 20, 
                               theta_resolution = 20)
        sp.update()
        ps = sp.output

        points = ps.points.to_array()
        self.points = points
        self.polydata.points = self.points
        self.polydata.polys = ps.polys
        return points, ps.polys

    def _radius_changed(self, value):
        points, polys = self._create_points(self.radius, self.pos)
        self.polydata.points = points
        self.polydata.modified()
        self.render()

    def _color_changed(self, value):
        self.actor.property.color = value

    def _pos_changed(self, old, new):
        self.set(x = new[0], trait_change_notify = False)
        self.set(y = new[1], trait_change_notify = False)
        self.set(z = new[2], trait_change_notify = False)
        points, lines = self._create_points(self.radius, self.pos)
        self.polydata.points = points
        self.polydata.modified()
        self.normals.update()
        self.render()

    def _axis_changed(self, old, new):
        self.points = axis_changed(old, new, self.pos, self.points)
        self.polydata.points = self.points
        self.polydata.modified()
        self.normals.update()
        self.render()

    def _x_changed(self, value):
        self.x = value
        self.pos = (self.x, self.pos[1],self.pos[2])

    def _y_changed(self, value):
        self.y = value
        self.pos = (self.pos[0], self.y, self.pos[2])

    def _z_changed(self, value):
        self.z = value
        self.pos = (self.pos[0], self.pos[1], self.z)

    def _representation_changed(self, value):
        self.property.representation = self.representation
        self.property.modified()
        self.render()

    def _visibility_changed(self, value):
        val = int(value)
        if (val == 1):
            self.actor.visibility = 1
        else:
            self.actor.visibility = 0

    ######################################################################
    # Object's public methods
    def render(self):
        v = self.viewer
        if v is not None:
            v.scene.render()

    def rotate(self, angle, axis, origin = numpy.array([0.0, 0.0, 0.0])):
        """Function takes atleast 2 arguments: axis about which to
        rotate the actor and angle with which to rotate the actor, the
        3rd agrument is origin i.e. the point about which to rotate
        the actor, by default it is set to the global origin"""
        p, pi, ax = rotate(axis, angle, origin, self.pos, self.points, self.axis)
        self.set(pos = p, trait_change_notify = False)
        self.points = pi
        self.set(axis = ax, trait_change_notify = False)
        self.polydata.points = self.points
        self.polydata.modified()
        self.render()

class Cylinder(HasTraits):
    """Cylinder class creates Cylinder from tvtk CylinderSource,
    follows the usual VTK pipeline and creates a Sphere actor, which
    is passed to the show_actor() function as an argument.
    """
    #####################################################################
    # Traits definitions

    # XXX: These should really not be ranges, but positive numbers.
    radius = Range(0.0, 1e299, value = 1.0, desc = 'the cylinder radius')
    length = Range(0.0, 1e299, value = 1.0, desc = 'the cylinder length')
    pos = Array(value = (0.0, 0.0, 0.0), desc = 'the cylinder pos')
    axis = Array(value = (1.0, 0.0, 0.0), desc = 'the cylinder axis')
    points = Array('d', shape = (60,3))
    color = vtk_color_trait((1.0, 1.0, 1.0))
    x = Range(-1e299, 1e299, 0.0, desc = 'the X coordinate of cylinder center')
    y = Range(-1e299, 1e299, 0.0, desc = 'the Y coordinate of cylinder center')
    z = Range(-1e299, 1e299, 0.0, desc = 'the Z coordinate of cylinder center')
    representation = Enum('s', 'w', 'p')
    visibility = Bool(True)
    viewer = Any

    polydata = Instance(tvtk.PolyData, ())
    actor = Instance(tvtk.Actor, ()) # tvtk Actor, for the usual pipeline architecture.
    property = Instance(tvtk.Property)
    normals = Instance(tvtk.PolyDataNormals(), ())

    ######################################################################
    # User interface view

    traits_view = View(Group(Item(name = 'radius', style = 'simple'),
                             Item(name = 'length', style = 'simple'),
                             Item(name = 'x', label = 'Pos X'),
                             Item(name = 'y', label = 'Pos Y'),
                             Item(name = 'z', label = 'Pos Z'),
                             Item(name = 'color'),
                             Item(name = 'visibility'),
                             Item(name = 'representation'),
                             label = 'Cylinder Properties',
                             show_border = True),
                             buttons=['OK'],
                             )

    def __init__(self, **traits):
        self.property = self.actor.property

        HasTraits.__init__(self, **traits)

        self._create_points(self.radius, self.pos, self.length)
        self._color_changed(self.color)
        self._visibility_changed(self.visibility)
        self._axis_changed(numpy.array([1.0, 0.0, 0.0]), self.axis)
        self._x_changed(self.x)
        self._y_changed(self.y)
        self._z_changed(self.z)

        self.normals = tvtk.PolyDataNormals()
        configure_input_data(self.normals, self.polydata)
        m = tvtk.PolyDataMapper() # the usual vtk pipleine countinuation
        configure_input_data(m, self.normals.output)
        self.actor.mapper = m
        self.property = self.actor.property
        self.property.representation = self.representation
        show_actor(self.actor) # passing the actors function for rendering
        self.viewer = get_viewer() # getting the ivtk viewer

        self.property.on_trait_change(self.viewer.scene.render)
        self.actor.on_trait_change(self.viewer.scene.render)

    ######################################################################
    # Non-public methods, Event handlers
    def _create_points(self, r, c, h):
        cp = tvtk.CylinderSource(radius = r, height = h, resolution = 15)
        cp.update()
        ps = cp.output
        points = ps.points.to_array()
        l = len(points)
        for i in range(0, l, 1):
            points[i][1] = points[i][1] + h/2.0
        points = axis_changed(numpy.array([0.0,1.0,0.0]),numpy.array([1.0,0.0,0.0]),numpy.array([0.0, 0.0, 0.0]), points)
        points = translate(numpy.array([0.0, 0.0, 0.0]), self.pos, points)
        self.points = points
        self.polydata.points = self.points
        self.polydata.polys = ps.polys
        return points, ps.polys

    def _radius_changed(self, old, new):
        self.points, polys = self._create_points(self.radius, self.pos, self.length)
        self.polydata.points = self.points
        self.polydata.modified()
        self.normals.update()
        self.render()

    def _length_changed(self, value):
        self.points, polys = self._create_points(self.radius, self.pos, self.length)
        self.polydata.points = self.points
        self.polydata.modified()
        self.normals.update()
        self.render()

    def _axis_changed(self, old, new):
        self.points = axis_changed(old, new, self.pos, self.points)
        self.polydata.points = self.points
        self.polydata.modified()
        self.normals.update()
        self.render()

    def _pos_changed(self, old, new):
        self.set(x = new[0], trait_change_notify = False)
        self.set(y = new[1], trait_change_notify = False)
        self.set(z = new[2], trait_change_notify = False)
        self.points = translate(old, new, self.points)
        self.polydata.points = self.points
        self.polydata.modified()
        self.normals.update()
        self.render()

    def _color_changed(self, value):
        self.actor.property.color = value

    def _x_changed(self, value):
        self.x = value
        self.pos = (self.x, self.pos[1],self.pos[2])

    def _y_changed(self, value):
        self.y = value
        self.pos = (self.pos[0], self.y, self.pos[2])

    def _z_changed(self, value):
        self.z = value
        self.pos = (self.pos[0], self.pos[1], self.z)

    def _representation_changed(self, value):
        self.property.representation = self.representation
        self.property.modified()
        self.render()

    def _visibility_changed(self, value):
        val = int(value)
        if (val == 1):
            self.actor.visibility = 1
        else:
            self.actor.visibility = 0

    ######################################################################
    # Object's public methods
    def rotate(self, angle, axis, origin = numpy.array([0.0, 0.0, 0.0])):
        """Function takes atleast 2 arguments: axis about which to
        rotate the actor and angle with which to rotate the actor, the
        3rd agrument is origin i.e. the point about which to rotate
        the actor, by default it is set to the global origin"""
        p, pi, ax = rotate(axis, angle, origin, self.pos, self.points, self.axis)
        self.set(pos = p, trait_change_notify = False)
        self.points = pi
        self.set(axis = ax, trait_change_notify = False)
        self.polydata.points = self.points
        self.polydata.modified()
        self.normals.update()
        self.render()

    def render(self):
        v = self.viewer
        if v is not None:
            v.scene.render()

class Box(HasTraits):
    """Box class creates Box from tvtk CubeSource, follows the usual
    VTK pipeline and creates a Cube actor, which is passed to the
    show_actor() function as an argument.
    """
    #####################################################################
    # Traits definitions

    size = Tuple((1.0, 1.0, 1.0), desc = 'the box size')
    pos = Array(value = (0.0, 0.0, 0.0), desc = 'the Box pos')
    color = vtk_color_trait((1.0, 1.0, 1.0))
    x = Range(-1e299, 1e299, 0.0, desc = 'the X coordinate of box center')
    y = Range(-1e299, 1e299, 0.0, desc = 'the Y coordinate of box center')
    z = Range(-1e299, 1e299, 0.0, desc = 'the Z coordinate of box center')
    representation = Enum('s', 'w', 'p')
    length = Range(0, 1e299, 1.0, desc = 'the box length')
    height = Range(0, 1e299, 1.0, desc = 'the box height')
    width = Range(0, 1e299, 1.0, desc = 'the box width')
    axis = Array(value = (1.0, 0.0, 0.0), desc = 'the box axis')
    points = Array('d', shape = (24,3))
    visibility = Bool(True)
    viewer = Any

    polydata = Instance(tvtk.PolyData, ())
    actor = Instance(tvtk.Actor, ()) # tvtk Actor, for the usual pipeline architecture.
    property = Instance(tvtk.Property)

    ######################################################################
    # User interface view

    traits_view = View(Group(Item(name = 'length'),
                             Item(name = 'height'),
                             Item(name = 'width'),
                             Item(name = 'x', label = 'Pos X'),
                             Item(name = 'y', label = 'Pos Y'),
                             Item(name = 'z', label = 'Pos Z'),
                             Item(name = 'color'),
                             Item(name = 'visibility'),
                             Item(name = 'representation'),
                             label = 'Box Properties',
                             show_border = True),
                             buttons = ['OK'],
                             )

    def __init__(self, **traits):
        self.property = self.actor.property

        HasTraits.__init__(self, **traits)

        self._create_points(self.size, self.pos)
        self._color_changed(self.color)
        self._visibility_changed(self.visibility)
        self._axis_changed(numpy.array([1.0, 0.0, 0.0]), self.axis)
        self._x_changed(self.x)
        self._y_changed(self.y)
        self._z_changed(self.z)
        self._length_changed(self.length)
        self._height_changed(self.height)
        self._width_changed(self.width)

        m = tvtk.PolyDataMapper() # the usual vtk pipleine countinuation
        configure_input_data(m, self.polydata)
        self.actor.mapper = m
        self.property = self.actor.property
        self.property.representation = self.representation
        show_actor(self.actor) # passing the actors function for rendering
        self.viewer = get_viewer() # getting the ivtk viewer

        self.property.on_trait_change(self.viewer.scene.render)
        self.actor.on_trait_change(self.viewer.scene.render)

    ######################################################################
    # Non-public methods, Event handlers
    def _create_points(self, s, c):
        cp = tvtk.CubeSource(x_length = s[0], y_length = s[1], z_length = s[2], center = tuple(c))
        cp.update()
        ps = cp.output
        points = ps.points.to_array()

        self.points = points
        self.polydata.points = self.points
        self.polydata.polys = ps.polys
        return points, ps.polys

    def _size_changed(self, old, new):
        self.set(length = new[0], trait_change_notify = False)
        self.set(height = new[1], trait_change_notify = False)
        self.set(width = new[2], trait_change_notify = False)
        self.points, lines = self._create_points(self.size, self.pos)
        self.polydata.points = self.points
        self.polydata.modified()
        self.render()

    def _pos_changed(self, old, new):
        self.set(x = new[0], trait_change_notify = False)
        self.set(y = new[1], trait_change_notify = False)
        self.set(z = new[2], trait_change_notify = False)
        self.points = translate(old, new, self.points)
        #self.connectivity.points = self.points
        self.polydata.modified()
        self.render()

    def _axis_changed(self, old, new):
        self.points = axis_changed(old, new, self.pos, self.points)
        #self.connectivity.points = self.points
        self.polydata.modified()
        self.render()

    def _color_changed(self, value):
        self.actor.property.color = value

    def _x_changed(self, value):
        self.x = value
        self.pos = (self.x, self.pos[1],self.pos[2])

    def _y_changed(self, value):
        self.y = value
        self.pos = (self.pos[0], self.y, self.pos[2])

    def _z_changed(self, value):
        self.z = value
        self.pos = (self.pos[0], self.pos[1], self.z)

    def _representation_changed(self, value):
        self.property.representation = self.representation
        self.property.modified()
        self.render()

    def _length_changed(self, value):
        self.size = (self.length, self.size[1],self.size[2])

    def _height_changed(self, value):
        self.size = (self.size[0], self.height, self.size[2])

    def _width_changed(self, value):
        self.size = (self.size[0], self.size[1], self.width)

    def _visibility_changed(self, value):
        val = int(value)
        if (val == 1):
            self.actor.visibility = 1
        else:
            self.actor.visibility = 0

    ######################################################################
    # Object's public methods
    def rotate(self, angle, axis, origin = numpy.array([0.0, 0.0, 0.0])):
        """Function takes atleast 2 arguments: axis about which to
        rotate the actor and angle with which to rotate the actor, the
        3rd agrument is origin i.e. the point about which to rotate
        the actor, by default it is set to the global origin"""
        p, pi, ax = rotate(axis, angle, origin, self.pos, self.points, self.axis)
        self.set(pos = p, trait_change_notify = False)
        self.points = pi
        self.set(axis = ax, trait_change_notify = False)
        #self.connectivity.points = self.points
        self.polydata.modified()
        self.render()

    def render(self):
        v = self.viewer
        if v is not None:
            v.scene.render()

class Arrow(HasTraits):
    """Arrow class creates Arrow from tvtk ArrowSource, follows the
    usual VTK pipeline and creates a Arrow actor, which is passed to
    the show_actor() function as an argument.
    """
    #####################################################################
    # Traits definitions

    points = Array('d', shape = (31 ,3))
    radius_cone = Range(0.0, 10.0, value = 0.08, desc = 'the radius of cone portion of arrow')
    radius_shaft = Range(0.0, 5.0, value = 0.03, desc = 'the radius of shaft portion of arrow')
    length_cone = Range(0.0, 1.0, value = 0.35, desc = 'shaft length of arrow')
    axis = Array(value = (1.0, 0.0, 0.0), desc = 'the arrow axis')
    color = vtk_color_trait((1.0, 1.0, 1.0))
    pos = Array(value = (0.0, 0.0, 0.0), desc = 'the Arrow pos')
    x = Range(-1e299, 1e299, 0.0, desc = 'the X coordinate of arrow center')
    y = Range(-1e299, 1e299, 0.0, desc = 'the Y coordinate of arrow center')
    z = Range(-1e299, 1e299, 0.0, desc = 'the Z coordinate of arrow center')
    representation = Enum('s', 'w', 'p')
    visibility = Bool(True)
    viewer = Any

    actor = Instance(tvtk.Actor, ()) # tvtk Actor, for the usual pipeline architecture.
    property = Instance(tvtk.Property)
    polydata = Instance(tvtk.PolyData, ())
    normals = Instance(tvtk.PolyDataNormals(), ())

    ######################################################################
    # User interface view

    traits_view = View(Group(Item(name = 'radius_cone'),
                             Item(name = 'length_cone'),
                             Item(name = 'radius_shaft'),
                             Item(name = 'x', label = 'Pos X'),
                             Item(name = 'y', label = 'Pos Y'),
                             Item(name = 'z', label = 'Pos Z'),
                             Item(name = 'color'),
                             Item(name = 'visibility'),
                             Item(name = 'representation'),
                             label = 'Arrow Properties',
                             show_border = True), buttons=['OK'])

    def __init__(self, **traits):
        self.property = self.actor.property

        HasTraits.__init__(self, **traits)

        self._create_points(self.radius_cone, self.length_cone, self.radius_shaft, self.pos)
        self._color_changed(self.color)
        self._visibility_changed(self.visibility)
        self._pos_changed(numpy.array([0.0, 0.0, 0.0]), self.pos)
        self._x_changed(self.x)
        self._y_changed(self.y)
        self._z_changed(self.z)
        self._axis_changed(numpy.array((1.0, 0.0, 0.0)), self.axis)

        self.normals = tvtk.PolyDataNormals()
        configure_input_data(self.normals, self.polydata)
        self.normals.update()
        m = tvtk.PolyDataMapper() # the usual vtk pipleine countinuation
        configure_input_data(m, self.normals.output)
        self.actor.mapper = m
        self.property = self.actor.property
        self.property.representation = self.representation
        show_actor(self.actor) # passing the actors function for rendering
        self.viewer = get_viewer() # getting the ivtk viewer

        self.property.on_trait_change(self.viewer.scene.render)
        self.actor.on_trait_change(self.viewer.scene.render)

    ######################################################################
    # Non-public methods, Event handlers
    def _create_points(self, rc, lc, rs, ps):
        asrc = tvtk.ArrowSource(tip_radius = rc, tip_length = lc, shaft_radius = rs)
        asrc.update()
        ps = asrc.output
        points = ps.points.to_array()
        points = translate(numpy.array([0.0, 0.0, 0.0]), self.pos, points)
        self.points = points
        self.polydata.points = self.points
        self.polydata.polys = ps.polys
        return points, ps.polys

    def _radius_cone_changed(self, old, new):
        self.points, polys = self._create_points(self.radius_cone, self.length_cone, self.radius_shaft, self.pos)
        self.polydata.points = self.points
        self.polydata.modified()
        self.normals.update()
        self.render()

    def _length_cone_changed(self, old, new):
        self.points, polys = self._create_points(self.radius_cone, self.length_cone, self.radius_shaft, self.pos)
        self.polydata.points = self.points
        self.polydata.modified()
        self.normals.update()
        self.render()

    def _radius_shaft_changed(self, old, new):
        self.points, polys = self._create_points(self.radius_cone, self.length_cone, self.radius_shaft, self.pos)
        self.polydata.points = self.points
        self.polydata.modified()
        self.normals.update()
        self.render()

    def _pos_changed(self, old, new):
        self.set(x = new[0], trait_change_notify = False)
        self.set(y = new[1], trait_change_notify = False)
        self.set(z = new[2], trait_change_notify = False)
        self.points = translate(old, new, self.points)
        self.polydata.points = self.points
        self.polydata.modified()
        self.normals.update()
        self.render()

    def _axis_changed(self, old, new):
        self.points = axis_changed(old, new, self.pos, self.points)
        self.polydata.points = self.points
        self.polydata.modified()
        self.normals.update()
        self.render()

    def _color_changed(self, value):
        self.actor.property.color = value

    def _x_changed(self, value):
        self.x = value
        self.pos = (self.x, self.pos[1],self.pos[2])

    def _y_changed(self, value):
        self.y = value
        self.pos = (self.pos[0], self.y, self.pos[2])

    def _z_changed(self, value):
        self.z = value
        self.pos = (self.pos[0], self.pos[1], self.z)

    def _representation_changed(self, value):
        self.property.representation = self.representation
        self.property.modified()
        self.render()

    def _visibility_changed(self, value):
        val = int(value)
        if (val == 1):
            self.actor.visibility = 1
        else:
            self.actor.visibility = 0

    ######################################################################
    # Object's public methods
    def rotate(self, angle, axis, origin = numpy.array([0.0, 0.0, 0.0])):
        """Function takes atleast 2 arguments: axis about which to
        rotate the actor and angle with which to rotate the actor, the
        3rd agrument is origin i.e. the point about which to rotate
        the actor, by default it is set to the global origin"""
        p, pi, ax = rotate(axis, angle, origin, self.pos, self.points, self.axis)
        self.set(pos = p, trait_change_notify = False)
        self.points = pi
        self.set(axis = ax, trait_change_notify = False)
        self.polydata.points = self.points
        self.polydata.modified()
        self.normals.update()
        self.render()

    def render(self):
        v = self.viewer
        if v is not None:
            v.scene.render()

class Helix(HasTraits):
    """Helix class creates Helix/Spring from tvtk polydata, follows the
    usual VTK pipeline and creates an Helix actor, which is passed to
    the show_actor() function as an argument.
    """
    #####################################################################
    # Traits definitions

    coils = Int(5)
    points = Array('d', shape = (None, 3))
    radius = Range(0.01, 1e299, value = 0.2, desc = 'the helix radius')
    length = Range(0.01, 1e299, value = 1.0, desc = 'the helix length')
    pos = Array(value = (0.0, 0.0, 0.0), desc = 'the helix position')
    axis = Array(value = (1.0, 0.0, 0.0), desc = 'the helix axis')
    color = vtk_color_trait((1.0, 1.0, 1.0))
    x = Range(-1e299, 1e299, 0.0, desc = 'the X coordinate of helix center')
    y = Range(-1e299, 1e299, 0.0, desc = 'the Y coordinate of helix center')
    z = Range(-1e299, 1e299, 0.0, desc = 'the Z coordinate of helix center')
    representation = Enum('s', 'w', 'p')
    thickness = Range(0, 1e299, value = 0.01, desc = 'the helix thickness')

    visibility = Bool(True)
    viewer = Any

    polydata = Instance(tvtk.PolyData, ())
    property = Instance(tvtk.Property)
    tube = Instance(tvtk.TubeFilter, ())
    actor = Instance(tvtk.Actor, ()) # tvtk Actor, for the usual pipeline architecture.
    normals = Instance(tvtk.PolyDataNormals(), ())

    ######################################################################
    # User interface view

    traits_view = View(Group(Item(name = 'radius'),
                             Item(name = 'length'),
                             Item(name = 'thickness'),
                             Item(name = 'x', label = 'Pos X'),
                             Item(name = 'y', label = 'Pos Y'),
                             Item(name = 'z', label = 'Pos Z'),
                             Item(name = 'color'),
                             Item(name = 'visibility'),
                             Item(name = 'representation'),
                             label = 'Helix Properties',
                             show_border = True), buttons=['OK'])

    def __init__(self, **traits):
        self.property = self.actor.property

        HasTraits.__init__(self, **traits)

        self._create_points()
        self._pos_changed(numpy.array([0.0, 0.0, 0.0]), self.pos)
        self._x_changed(self.x)
        self._y_changed(self.y)
        self._z_changed(self.z)
        self._color_changed(self.color)
        self._visibility_changed(self.visibility)
        self._thickness_changed(self.thickness)
        self._axis_changed(numpy.array((1.0, 0.0, 0.0)), self.axis)

        self.normals = tvtk.PolyDataNormals()
        configure_input_data(self.normals, self.polydata)
        configure_input_data(self.tube, self.normals.output)
        self.tube.number_of_sides = 4
        self.tube.capping = 1

        m = tvtk.PolyDataMapper()
        configure_input_data(m, self.tube.output)
        self.actor.mapper = m
        self.property = self.actor.property
        self.property.representation = self.representation
        show_actor(self.actor)
        self.viewer = get_viewer()

        self.property.on_trait_change(self.viewer.scene.render)
        self.actor.on_trait_change(self.viewer.scene.render)
        self.tube.on_trait_change(self.viewer.scene.render)

    ######################################################################
    # Non-public methods, Event handlers
    def _create_points(self):
        h = self.length/(self.coils*10)
        cons = self.length/(self.coils*10)
        j = 0
        self.points.resize(self.coils*10, 3)
        for i in range(0,self.coils*360,36):
            theta = i*pi/180
            self.points[j][0] = h
            self.points[j][1] = self.radius*sin(theta)
            self.points[j][2] = self.radius*cos(theta)
            j = j+1
            h = h + cons

        np = len(self.points) - 1
        lines = numpy.zeros((np, 2), 'l')
        lines[:,0] = numpy.arange(0, np-0.5, 1, 'l')
        lines[:,1] = numpy.arange(1, np+0.5, 1, 'l')
        self.polydata.points = self.points
        self.polydata.lines = lines
        self.normals.update()
        self.tube.update()

    def _color_changed(self, value):
        self.actor.property.color = value

    def _radius_changed(self, old, new):
        self._create_points()
        self._pos_changed(numpy.array([0.0, 0.0, 0.0]), self.pos)
        self.change_axis(numpy.array((1.0, 0.0, 0.0)), self.axis)
        self.polydata.points = self.points
        self.polydata.modified()
        self.normals.update()
        self.tube.update()
        self.render()

    def _coils_changed(self, old, new):
        p = numpy.arange(self.coils*10*3, dtype = float)
        p = p.reshape(self.coils*10,3)
        h = self.length/(self.coils*10)
        cons = self.length/(self.coils*10)
        j = 0
        for i in range(0,self.coils*360,36):
            theta = i*pi/180
            p[j][0] = h
            p[j][1] = self.radius*sin(theta)
            p[j][2] = self.radius*cos(theta)
            j = j+1
            h = h + cons

        np = len(p) - 1
        lines = numpy.zeros((np, 2), 'l')
        lines[:,0] = numpy.arange(0, np-0.5, 1, 'l')
        lines[:,1] = numpy.arange(1, np+0.5, 1, 'l')
        self.polydata.points = p
        self.polydata.lines = lines
        self.points = p
        self._pos_changed(numpy.array([0.0, 0.0, 0.0]), self.pos)
        self.change_axis(numpy.array((1.0, 0.0, 0.0)), self.axis)
        self.polydata.modified()
        self.normals.update()
        self.tube.update()
        self.render()

    def _x_changed(self, value):
        self.x = value
        self.pos = (self.x, self.pos[1],self.pos[2])

    def _y_changed(self, value):
        self.y = value
        self.pos = (self.pos[0], self.y, self.pos[2])

    def _z_changed(self, value):
        self.z = value
        self.pos = (self.pos[0], self.pos[1], self.z)

    def _representation_changed(self, value):
        self.property.representation = self.representation
        self.property.modified()
        self.render()

    def _pos_changed(self, old, new):
        self.set(x = new[0], trait_change_notify = False)
        self.set(y = new[1], trait_change_notify = False)
        self.set(z = new[2], trait_change_notify = False)
        self.points = translate(old, new, self.points)
        #self.polydata.points = self.points
        self.polydata.modified()
        self.normals.update()
        self.tube.update()
        self.render()

    def _axis_changed(self, old, new):
        self.points = axis_changed(old, new, self.pos, self.points)
        #self.polydata.points = self.points
        self.polydata.modified()
        self.normals.update()
        self.tube.update()
        self.render()

    def change_axis(self, old, new):
        self.points = axis_changed(old, new, self.pos, self.points)
        self.polydata.points = self.points

    def _length_changed(self, old, new):
        self._create_points()
        v = self.viewer
        if v:
            v.scene.disable_render = True
        self._pos_changed(numpy.array([0.0, 0.0, 0.0]), self.pos)
        self.change_axis(numpy.array((1.0, 0.0, 0.0)), self.axis)
        if v:
            v.scene.disable_render = False
        self.polydata.points = self.points
        self.polydata.modified()
        self.normals.update()
        self.tube.update()
        self.render()

    def _visibility_changed(self, value):
        val = int(value)
        if (val == 1):
            self.actor.visibility = 1
        else:
            self.actor.visibility = 0

    def _thickness_changed(self, value):
        self.tube.radius = value

    ######################################################################
    # Object's public methods
    def rotate(self, angle, axis, origin = numpy.array([0.0, 0.0, 0.0])):
        """Function takes atleast 2 arguments: axis about which to
        rotate the actor and angle with which to rotate the actor, the
        3rd agrument is origin i.e. the point about which to rotate
        the actor, by default it is set to the global origin"""
        p, pi, ax = rotate(axis, angle, origin, self.pos, self.points, self.axis)
        self.set(pos = p, trait_change_notify = False)
        self.points = pi
        self.set(axis = ax, trait_change_notify = False)
        self.polydata.points = self.points
        self.polydata.modified()
        self.normals.update()
        self.tube.update()
        self.render()

    def render(self):
        v = self.viewer
        if v is not None:
            v.scene.render()

class Ellipsoid(HasTraits):
    """Ellipsoid class creates Ellipsoid from tvtk SphereSource by
    suitably scaling it, follows the usual VTK pipeline and creates a
    Ellipsoid actor, which is passed to the show_actor() function as
    an argument.
    """
    #####################################################################
    # Traits definitions

    radius = Range(0.0, 1e299, value = 0.5, desc = 'Undistorted ellipsoid radius')
    pos = Array(value = (0.0, 0.0, 0.0), desc = 'Ellipsoid pos')
    color = vtk_color_trait((1.0, 1.0, 1.0))
    axis = Array(value = (1.0, 0.0, 0.0), desc= 'Ellipsoid axis')
    size = Array(value = (1.0, 0.5, 1.0), desc= 'Ellipsoid size_factor')
    length = Range(0.0, 1e299, 1.0, desc = 'Scaling factor in X direction')
    height = Range(0.0, 1e299, 0.5, desc = 'Sscaling factor in Y direction')
    width = Range(0.0, 1e299, 1.0, desc = 'Scaling factor in Z direction')
    x = Range(-1e299, 1e299, 0.0, desc = 'X coordinate of ellipsoid center')
    y = Range(-1e299, 1e299, 0.0, desc = 'Y coordinate of ellipsoid center')
    z = Range(-1e299, 1e299, 0.0, desc = 'Z coordinate of ellipsoid center')
    representation = Enum('s', 'w', 'p')
    visibility = Bool(True)
    viewer = Any

    polydata = Instance(tvtk.PolyData, ())
    property = Instance(tvtk.Property)
    actor = Instance(tvtk.Actor, ()) # tvtk Actor, for the usual pipeline architecture.
    normals = Instance(tvtk.PolyDataNormals(), ())

    ######################################################################
    # User interface view

    traits_view = View(Group(Item(name = 'radius', style = 'simple'),
                             Item(name = 'x', label = 'Pos X'),
                             Item(name = 'y', label = 'Pos Y'),
                             Item(name = 'z', label = 'Pos Z'),
                             Item(name = 'length', label = 'Length'),
                             Item(name = 'height', label = 'Height'),
                             Item(name = 'width', label = 'Width'),
                             Item(name = 'color'),
                             Item(name = 'visibility'),
                             Item(name = 'representation'),
                             label = 'Ellipsoid Properties',
                             show_border = True), buttons=['OK'])

    def __init__(self, **traits):
        self.property = self.actor.property

        HasTraits.__init__(self, **traits)

        self._create_points(self.radius, self.pos)
        self._color_changed(self.color)
        self._visibility_changed(self.visibility)
        self._x_changed(self.x)
        self._y_changed(self.y)
        self._z_changed(self.z)
        self._axis_changed(numpy.array((1.0, 0.0, 0.0)), self.axis)

        self.normals = tvtk.PolyDataNormals()
        configure_input_data(self.normals, self.polydata)
        self.normals.update()
        m = tvtk.PolyDataMapper() # the usual vtk pipleine countinuation
        configure_input_data(self.normals, self.normals.output)
        self.actor.mapper = m
        self.property = self.actor.property
        self.property.representation = self.representation
        show_actor(self.actor) # passing the actors function for rendering
        self.viewer = get_viewer() # getting the ivtk viewer

        self.property.on_trait_change(self.viewer.scene.render)
        self.actor.on_trait_change(self.viewer.scene.render)

    ######################################################################
    # Non-public methods, Event handlers
    def _create_points(self, r, c):
        sp = tvtk.SphereSource(radius = r, center = tuple(c), phi_resolution = 20, theta_resolution = 20)
        sp.update()
        ps = sp.output

        points = ps.points.to_array()
        points = scale(self.size, points, self.pos)
        self.points = points
        self.polydata.points = self.points
        self.polydata.polys = ps.polys
        return points, ps.polys

    def _radius_changed(self, value):
        points, polys = self._create_points(self.radius, self.pos)
        self.polydata.points = points
        self.polydata.modified()
        self.normals.update()
        self.render()

    def _size_changed(self, value):
        points, polys = self._create_points(self.radius, self.pos)
        self.polydata.points = points
        self.polydata.modified()
        self.normals.update()
        self.render()

    def _color_changed(self, value):
        self.actor.property.color = value

    def _pos_changed(self, old, new):
        self.set(x = new[0], trait_change_notify = False)
        self.set(y = new[1], trait_change_notify = False)
        self.set(z = new[2], trait_change_notify = False)
        points, lines = self._create_points(self.radius, self.pos)
        self.polydata.points = points
        self.polydata.modified()
        self.normals.update()
        self.render()

    def _axis_changed(self, old, new):
        points = axis_changed(old, new, self.pos, self.points)
        self.points = points
        self.polydata.points = self.points
        self.polydata.modified()
        self.normals.update()
        self.render()

    def _x_changed(self, value):
        self.x = value
        self.pos = (self.x, self.pos[1],self.pos[2])

    def _y_changed(self, value):
        self.y = value
        self.pos = (self.pos[0], self.y, self.pos[2])

    def _z_changed(self, value):
        self.z = value
        self.pos = (self.pos[0], self.pos[1], self.z)

    def _representation_changed(self, value):
        self.property.representation = self.representation
        self.property.modified()
        self.render()

    def _length_changed(self, value):
        self.x_scale = value
        self.size = (self.length, self.size[1], self.size[2])

    def _height_changed(self, value):
        self.y_scale = value
        self.size = (self.size[0], self.height, self.size[2])

    def _width_changed(self, value):
        self.z_scale = value
        self.size = (self.size[0], self.size[1], self.width)

    def _visibility_changed(self, value):
        val = int(value)
        if (val == 1):
            self.actor.visibility = 1
        else:
            self.actor.visibility = 0

    ######################################################################
    # Object's public methods
    def render(self):
        v = self.viewer
        if v is not None:
            v.scene.render()

    def rotate(self, angle, axis, origin = numpy.array([0.0, 0.0, 0.0])):
        """Function takes atleast 2 arguments: axis about which to
        rotate the actor and angle with which to rotate the actor, the
        3rd agrument is origin i.e. the point about which to rotate
        the actor, by default it is set to the global origin"""
        p, pi, ax = rotate(axis, angle, origin, self.pos, self.points, self.axis)
        self.set(pos = p, trait_change_notify = False)
        self.points = pi
        self.set(axis = ax, trait_change_notify = False)
        self.polydata.points = self.points
        self.polydata.modified()
        self.render()


###########################################################
################### Compatibility layer ###################
###########################################################

sphere = Sphere
vector = MVector
frame = Frame
curve = Curve
ring = Ring
cone = Cone
cylinder = Cylinder
box = Box
arrow = Arrow
helix = Helix
ellipsoid = Ellipsoid
mag = numpy.linalg.norm

def rate(arg):
    msg = """Do not use rate, instead use the iterate() function.
    Iterate should be called with a callback.  This callback will be
    periodically called via a timer.  This will make your script's UI
    completely interactive.
    """
    print '*'*80
    print msg
    print '*'*80


############################################################
####################  Test Functions #######################
############################################################

def test_sphere():
    s1 = sphere()
    s2 = sphere(radius = 1.5, pos = (2, 0, 0), color = (1, 0, 0))
    s2.edit_traits()

def test_box():
    b1 = box()
    b2 = box(center = (2, 0, 0), size = (2, 1, 1), color = (0.5, 0.5, 1.0))
    b2.edit_traits()

def test_cone():
    c = cone(pos = (5,0,0), color = (1,1,0), axis = (1,1,0))
    c.edit_traits()

def test_cylinder():
    c1 = cylinder()
    c2 = cylinder(radius = 1.5, pos = (2, 0, 0), color = (1, 0, 0))
    c2.edit_traits()

def test_arrow():
    a = arrow()
    a.edit_traits()

def test_curve():
    c = curve(points = ([[0,0,0],[1,0,0],[0,1,0],[0,0,1]]))
    c.edit_traits()
    return c

def test_ring():
    r1 = ring()
    r2 = ring(radius = 1.5, pos = (2,0,0), color = (1,0,0))
    r2.edit_traits()

def test_helix():
    h1 = helix()
    r2 = helix(radius = 0.5, pos = (2,0,0), color = (1,0,0))
    r2.edit_traits()

def test_ellipsoid():
    e1 = ellipsoid()
    e1.edit_traits()

def test_remove_actors():
    """Test fuction for testing integrity of remove function for
    actors"""
    s = sphere(radius = 1.5, pos = (0, 0, 0), color = (1, 0, 0))
    b = box(center = (1, 0, 0), size = (2, 1, 1), color = (0.5, 0.5, 1.0))
    co = cone(resolution = 100, pos = (2, 0, 0), color = (0, 1, 0))
    cy = cylinder(resolution = 100, pos = (3, 0, 0), color = (0, 0, 1))

    time.sleep(3)
    print "Removed sphere from scene"
    remove_actor(s)

    time.sleep(3)
    print "Removed cone from cone"
    remove_actor(co)

def test_frame():
    c1 = cone(pos = (3.0, 0.0, 0.0))
    r1 = ring()
    f = frame(r1,c1)
    f.edit_traits()
    return f

def rotate_frame():
    """Test fuction for testing integrity of rotation function of
    frame"""
    r1 = ring(pos = (1,0,0))
    h1 = helix(pos = (1,0,0))
    f = frame(r1,h1)
    f.pos = (2,0,0)
    f.axis = (1,1,1)
    j = 1
    def anim():
        f.rotate(j, [0.0, 1.0, 0.0])
    ti = iterate(200, anim)
    ti.edit_traits()
    return ti

def test_rotate():
    """Test fuction for testing integrity of rotation function of
    actors"""
    r = ring()
    r.pos = (3,0,0)
    r2 = ring(pos = (3,0,0))
    points1 = r2.points
    r.rotate(90, [0,1,0], [1,0,0])
    r.rotate(-90, [0,1,0], [1,0,0])
    points2 = r.points
    if (numpy.allclose(points1, points2)):
        print "All clear"
    else:
        print "Test failed"
    return r

def test_translate():
    """This is a basic examples function demonstrating the creating
    simple animation from visual actors.  Note the show function has
    to be called in stand alone programs."""
    b = box()
    xlen = 10
    s = sphere(pos = (xlen, 0, 0))
    s.velocity = (-1,0,0)

    def anim():
        x = s.x
        if (x < 1):
            s.velocity = (1, 0, 0)
        elif (x > xlen):
            s.velocity = (-1, 0, 0)
        s.x = x + s.velocity[0]

    ti = iterate(50, anim)
    ti.edit_traits()

def bounce():
    """This is a basic example function, extending the previous
    example."""
    xlen = 10
    b1 = box(size = (1, 4, 4), color = (0,1,0))
    b2 = box(size = (1, 4, 4), color = (0,1,0), pos = (xlen, 0, 0))
    s = sphere(radius = 0.5, pos = (xlen, 0, 0), color = (1, 0, 0))
    s.velocity = (-1, 0, 0)

    def anim():
        x = s.x
        if (x == 1):
            s.velocity = (1, 0, 0)
        elif (x == (xlen-1)):
            s.velocity = (-1, 0, 0)
        s.x = x + s.velocity[0]

    t = iterate(60, anim)
    t.edit_traits()
    return t


########NEW FILE########
__FILENAME__ = tvtk_access
"""Creates a pseudo-package called `tvtk` that lets one use the tvtk
classes in a clean and quick manner.  The `TVTK` class is instantiated
and this instance serves as the `tvtk` 'module'.  For more details on
this see the devel.txt in the TVTK documentation directory.
"""
# Author: Prabhu Ramachandran <prabhu [at] aero.iitb.ac.in>
# Copyright (c) 2007-2008,  Enthought, Inc.
# License: BSD Style.


from os.path import exists, join, dirname, isdir

# The tvtk wrapper code is all typically inside one zip file.  We try to
# find this file and then create the 'tvtk' module wrapper from that.  If
# the ZIP file is extracted into a tvtk_classes directory the ZIP file is
# not used and the tvtk_classes directory is inserted into sys.path and
# the directory contents are used for the tvtk classes -- note that you
# must have the following structure
# tvtk_classes/tvtk_classes/__init__.py.  This is handy for tools like
# pydev (Eclipse). If neither the tvtk_classes directory or the zip file
# is found an error is raised.

_zip = join(dirname(__file__), 'tvtk_classes.zip')
tvtk_class_dir = join(dirname(__file__), 'tvtk_classes')

if not ( exists(tvtk_class_dir) and isdir(tvtk_class_dir)
         or exists(_zip)):
    raise ImportError("TVTK not built properly. "
        "Unable to find either a directory: %s or a file: %s "
        "with the TVTK classes." % (tvtk_class_dir, _zip) )

# Check if the VTK version is the same as that used to build TVTK.
from tvtk.tvtk_classes.vtk_version import vtk_build_version

# Make sure VTK is installed.
try:
    import vtk
except ImportError, m:
    msg = '%s\n%s\nDo you have vtk installed properly?\n' \
          'VTK (and build instructions) can be obtained from http://www.vtk.org\n' \
         % (m, '_'*80)
    raise ImportError(msg)

vtk_version = vtk.vtkVersion().GetVTKVersion()[:3]
if vtk_version != vtk_build_version:
    msg = '*'*80 + "\n" + \
          'WARNING: Imported VTK version (%s) does not match the one used\n'\
          '         to build the TVTK classes (%s). This may cause problems.\n'\
          '         Please rebuild TVTK.\n'%(vtk_version, vtk_build_version) +\
          '*'*80 + '\n'
    print msg

# Now setup TVTK itself.
from tvtk.tvtk_classes import tvtk_helper
tvtk = tvtk_helper.TVTK()


########NEW FILE########
__FILENAME__ = tvtk_base
"""Commonly used code by tvtk objects.

"""
# Author: Prabhu Ramachandran <prabhu_r@users.sf.net>
# Copyright (c) 2004-2008,  Enthought, Inc.
# License: BSD Style.

import types
import sys
import weakref
import os
import logging

import vtk

from traits import api as traits
from traitsui.api import BooleanEditor, RGBColorEditor, FileEditor
import messenger

# Setup a logger for this module.
logger = logging.getLogger(__name__)

######################################################################
# The TVTK object cache.
######################################################################

class TVTKObjectCache(weakref.WeakValueDictionary):
    def __init__(self, *args, **kw):
        self._observer_data = {}
        weakref.WeakValueDictionary.__init__(self, *args, **kw)
        def remove(wr, selfref=weakref.ref(self)):
            self = selfref()
            if self is not None:
                self.teardown_observers(wr.key)
                del self.data[wr.key]
        self._remove = remove

    def setup_observers(self, vtk_obj, event, method):
        """Setup the observer for the VTK object's event.

        Parameters
        ----------

        vtk_obj -- The VTK object for which the `event` is
        observed.

        event -- The VTK event to watch.

        method -- The method to be called back when `event` is
        fired on the VTK object.

        """

        # Setup the observer so the traits are updated even if the
        # wrapped VTK object changes.
        if hasattr(vtk_obj, 'AddObserver'):
            # Some classes like vtkInformation* derive from
            # tvtk.ObjectBase which don't support Add/RemoveObserver.
            messenger.connect(vtk_obj, event, method)
            ob_id = vtk_obj.AddObserver(event, messenger.send)
            key = vtk_obj.__this__
            od = self._observer_data
            if key in od:
                od[key].append((vtk_obj, ob_id))
            else:
                od[key] = [(vtk_obj, ob_id)]

    def teardown_observers(self, key):
        """Given the key of the VTK object (vtk_obj.__this__), this
        removes the observer for the ModifiedEvent and also disconnects
        the messenger.
        """
        od = self._observer_data
        if key not in od:
            return

        for vtk_obj, ob_id in od[key]:
            try:
                # The disconnection sometimes fails at exit.
                vtk_obj.RemoveObserver(ob_id)
            except AttributeError:
                pass
        try:
            messenger.disconnect(vtk_obj)
        except AttributeError:
            pass
        del od[key]


# The TVTK object cache (`_object_cache`).  This caches all the TVTK
# instances using weakrefs.  When a VTK object is wrapped via the
# `wrap_vtk` function this cache is checked.  The key is the VTK
# object's address.  The value of the dict is the TVTK wrapper object.
# If the VTK object address exists in the cache, it is returned by
# `wrap_vtk`.  `wrap_vtk` is defined in `tvtk_helper.py` which is
# stored in the ZIP file.

_dummy = None
# This makes the cache work even when the module is reloaded.
for name in ['tvtk_base', 'tvtk.tvtk_base']:
    if sys.modules.has_key(name):
        mod = sys.modules[name]
        if hasattr(mod, '_object_cache'):
            _dummy = mod._object_cache
        del mod
        break

if _dummy is not None:
    _object_cache = _dummy
else:
    _object_cache = TVTKObjectCache()
del _dummy


def get_tvtk_object_from_cache(vtk_obj):
    """Returns the cached TVTK object given a VTK object."""
    return _object_cache.get(vtk_obj.__this__)


######################################################################
# Special traits used by the tvtk objects.
######################################################################

true_bool_trait = traits.Trait('true',
                               {'true':  1, 't': 1, 'yes': 1,
                                'y': 1, 'on': 1, 1: 1, 'false': 0,
                                'f': 0, 'no':  0, 'n': 0,
                                'off': 0, 0: 0, -1:0},
                               editor=BooleanEditor)

false_bool_trait = traits.Trait('false', true_bool_trait)


class TraitRevPrefixMap(traits.TraitPrefixMap):
    """A reverse mapped TraitPrefixMap.  This handler allows for
    something like the following::

      >>> class A(HasTraits):
      ...     a = Trait('ab', TraitRevPrefixMap({'ab':1, 'cd':2}))
      ...
      >>> a = A()
      >>> a.a = 'c'
      >>> print a.a
      'cd'
      >>> a.a = 1
      >>> print a.a
      'ab'

    That is, you can set the trait to the value itself.  If multiple
    keys map to the same value, one of the valid keys will be used.

    """
    def __init__(self, map):
        traits.TraitPrefixMap.__init__(self, map)
        self._rmap = {}
        for key, value in map.items():
            self._rmap[value] = key

    def validate(self, object, name, value):
        try:
            if self._rmap.has_key(value):
                value = self._rmap[value]
            if not self._map.has_key( value ):
                match = None
                n     = len( value )
                for key in self.map.keys():
                    if value == key[:n]:
                        if match is not None:
                           match = None
                           break
                        match = key
                if match is None:
                    self.error( object, name, value )
                self._map[ value ] = match
            return self._map[ value ]
        except:
            self.error( object, name, value )

    def info(self):
        keys = [repr(x) for x in self._rmap.keys()]
        keys.sort()
        msg = ' or '.join(keys)
        return traits.TraitPrefixMap.info(self) + ' or ' + msg


def vtk_color_trait(default, **metadata):
    Range = traits.Range
    if default[0] == -1.0:
        # Occurs for the vtkTextProperty's color trait.  Need to work
        # around.
        return traits.Trait(default, traits.Tuple(*default),
                            traits.Tuple(Range(0.0, 1.0),
                                         Range(0.0, 1.0),
                                         Range(0.0, 1.0),
                                         editor=RGBColorEditor),
                            **metadata)
    else:
        return traits.Trait(traits.Tuple(Range(0.0, 1.0, default[0]),
                                         Range(0.0, 1.0, default[1]),
                                         Range(0.0, 1.0, default[2])),
                            editor=RGBColorEditor, **metadata)


# Special cases for the FileName and FilePrefix
vtk_file_name = traits.Trait(None, None, traits.Str, types.UnicodeType,
                             editor=FileEditor)
vtk_file_prefix = traits.Trait(None, None, traits.Str, types.UnicodeType,
                               editor=(FileEditor, {'truncate_ext': True}))

# The Property class traits are delegated in the Actors.
vtk_property_delegate = traits.Delegate('property', modify=True)


######################################################################
# Utility functions.
######################################################################
def deref_vtk(obj):
    """Dereferences the VTK object from the object if possible."""
    if isinstance(obj, TVTKBase):
        return obj._vtk_obj
    else:
        return obj


######################################################################
# 'TVTKBase' class (base class for all tvtk classes):
######################################################################
class TVTKBase(traits.HasStrictTraits):
    """The base class for all TVTK objects.  This class encapsulates
    key functionality common to all the TVTK classes.

    TVTK classes provide a trait wrapped VTK object.  They also
    primitively picklable.  Only the basic state of the object itself
    is pickled.  References to other VTK objects are NOT pickled.

    """

    # This is just a dummy integer (MUST be > 1) that indicates that
    # we are updating the traits and there is no need to change the
    # underlying VTK object.
    DOING_UPDATE = 10

    ########################################
    # Private traits.

    # This trait is only used internally and should not activate any
    # notifications when set which is why we use `Python`.
    _in_set = traits.Python

    # The wrapped VTK object.
    _vtk_obj = traits.Trait(None, None, vtk.vtkObjectBase())

    # Stores the names of the traits that need to be updated.
    _updateable_traits_ = traits.Tuple

    # List of trait names that are to be included in the full traits view of this object.
    _full_traitnames_list_ = traits.List

    #################################################################
    # `object` interface.
    #################################################################
    def __init__(self, klass, obj=None, update=True, **traits):
        """Object initialization.

        Parameters
        ----------

        - klass: `vtkObjectBase`

          A VTK class to wrap.  If `obj` is passed, its class must be
          the same as `klass` or a subclass of it.

        - obj: `vtkObjectBase` (default: None)

          An optional VTK object.  If passed the passed object is
          wrapped.  This defaults to `None` where a new VTK instance
          of class, `klass` is created.

        - update: `bool` (default: True)

          If True (default), the traits of the class are automatically
          updated based on the state of the wrapped VTK object.  If
          False, no updation is performed.  This is particularly
          useful when the object is being unpickled.

        - traits: `dict`

          A dictionary having the names of the traits as its keys.
          This allows a user to set the traits of the object while
          creating the object.

        """
        # Initialize the Python attribute.
        self._in_set = 0
        if obj:
            assert obj.IsA(klass.__name__)
            self._vtk_obj = obj
        else:
            self._vtk_obj = klass()

        # print "INIT", self.__class__.__name__, repr(self._vtk_obj)

        # Call the Super class to update the traits.
        # Inhibit any updates at this point since we update in the end
        # anyway.
        self._in_set = 1
        super(TVTKBase, self).__init__(**traits)
        self._in_set = 0

        # Update the traits based on the values of the VTK object.
        if update:
            self.update_traits()

        # Setup observers for the modified event.
        self.setup_observers()

        _object_cache[self._vtk_obj.__this__] = self

    def __getinitargs__(self):
        """This is merely a placeholder so that subclasses can
        override this if needed.  This is called by `__setstate__`
        because `traits.HasTrait` is a newstyle class.

        """
        # You usually don't want to call update when calling __init__
        # from __setstate__
        return (None, 0)

    def __getstate__(self):
        """Support for primitive pickling.  Only the basic state is
        pickled.
        """
        self.update_traits()
        d = self.__dict__.copy()
        for i in ['_vtk_obj', '_in_set', 'reference_count',
                  'global_warning_display', '__sync_trait__']:
            d.pop(i, None)
        return d

    def __setstate__(self, dict):
        """Support for primitive pickling.  Only the basic state is
        pickled.
        """
        # This is a newstyle class so we need to call init here.
        if self._vtk_obj is None:
            self.__init__(*self.__getinitargs__())
        self._in_set = 1
        for i in dict:
            # Not enough to update the dict because the vtk object
            # needs to be updated.
            try:
                setattr(self, i, dict[i])
            except traits.TraitError, msg:
                print "WARNING:",
                print msg
        self._in_set = 0

    def __str__(self):
        """Return a nice string representation of the object.

        This merely returns the result of str on the underlying VTK
        object.
        """
        return str(self._vtk_obj)

    #################################################################
    # `HasTraits` interface.
    #################################################################

    def class_trait_view_elements ( cls ):
        """ Returns the ViewElements object associated with the class.

        The returned object can be used to access all the view elements
        associated with the class.

        Overridden here to search through a particular directory for substitute
        views to use for this tvtk object. The view should be declared in a
        file named <class name>_view. We execute this file and replace any
        currently defined view elements with view elements declared in this
        file (that have the same name).

        """

        # FIXME: This can be enhanced to search for new views also (in addition
        # to replacing current views).

        view_elements = super(TVTKBase, cls).class_trait_view_elements()
        # Get the names of all the currently defined view elements.
        names = view_elements.filter_by()
        baseDir = os.path.dirname(os.path.abspath(__file__))
        viewDir = os.path.join(baseDir, 'view')
        try:
            module_name = cls.__module__.split('.')[-1]
            view_filename = os.path.join(viewDir,
                                         module_name + '_view.py')
            result = {}
            execfile(view_filename, {}, result)
            for name in names:
                if name in result:
                    view_elements.content[ name ] = result[name]
        except Exception, e:
            pass
        return view_elements

    class_trait_view_elements = classmethod( class_trait_view_elements )

    #################################################################
    # `TVTKBase` interface.
    #################################################################
    def setup_observers(self):
        """Add an observer for the ModifiedEvent so the traits are kept
        up-to-date with the wrapped VTK object and do it in a way that
        avoids reference cycles."""
        _object_cache.setup_observers(self._vtk_obj,
                                      'ModifiedEvent',
                                      self.update_traits)

    def teardown_observers(self):
        """Remove the observer for the Modified event."""
        _object_cache.teardown_observers(self._vtk_obj.__this__)

    def update_traits(self, obj=None, event=None):
        """Updates all the 'updateable' traits of the object.

        The method works by getting the current value from the wrapped
        VTK object.  `self._updateable_traits_` stores a tuple of
        tuples containing the trait name followed by the name of the
        get method to use on the wrapped VTK object.

        The `obj` and `event` parameters may be ignored and are not
        used in the function.  They exist only for compatibility with
        the VTK observer callback functions.

        """
        if self._in_set:
            return
        if not hasattr(self, '_updateable_traits_'):
            return

        self._in_set = self.DOING_UPDATE
        vtk_obj = self._vtk_obj

        # Save the warning state and turn it off!
        warn = vtk.vtkObject.GetGlobalWarningDisplay()
        vtk.vtkObject.GlobalWarningDisplayOff()

        for name, getter in self._updateable_traits_:
            try:
                val = getattr(vtk_obj, getter)()
            except (AttributeError, TypeError):
                pass
            else:
                if name == 'global_warning_display':
                    setattr(self, name, warn)
                else:
                    setattr(self, name, val)
        # Reset the warning state.
        vtk.vtkObject.SetGlobalWarningDisplay(warn)
        self._in_set = 0

    #################################################################
    # Non-public interface.
    #################################################################
    def _do_change(self, method, val, force_update=False):
        """This is called by the various traits when they change in
        order to update the underlying VTK object.

        Parameters
        ----------

        - method: `method`

          The method to invoke on the VTK object when called.

        - val: `Any`

          Argument to the method.

        - force_update: `bool` (default: False)

          If True, `update_traits` is always called at the end.

        """
        if self._in_set == self.DOING_UPDATE:
            return
        vtk_obj = self._vtk_obj
        self._in_set += 1
        mtime = self._wrapped_mtime(vtk_obj) + 1
        try:
            method(val)
        except TypeError:
            if hasattr(val, '__len__'):
                method(*val)
            else:
                raise
        self._in_set -= 1
        if force_update or self._wrapped_mtime(vtk_obj) > mtime:
            self.update_traits()


    def _wrap_call(self, vtk_method, *args):
        """This method allows us to safely call a VTK method without
        calling `update_traits` during the call.  This method is
        therefore used to wrap any 'Set' call on a VTK object.

        The method returns the output of the vtk_method call.

        Parameters
        ----------

        - vtk_method: `method`

          The method to invoke safely.

        - args: `Any`

          Argument to be passed to the method.

        """
        vtk_obj = self._vtk_obj
        self._in_set += 1
        mtime = self._wrapped_mtime(vtk_obj) + 1
        ret = vtk_method(*args)
        self._in_set -= 1
        if self._wrapped_mtime(vtk_obj) > mtime:
            self.update_traits()
        return ret

    def _wrapped_mtime(self, vtk_obj):
        """A simple wrapper for the mtime so tvtk can be used for
        `vtk.vtkObjectBase` subclasses that neither have an
        `AddObserver` or a `GetMTime` method.
        """
        try:
            return vtk_obj.GetMTime()
        except AttributeError:
            return 0

########NEW FILE########
__FILENAME__ = tvtk_base_handler
""" Handler and UI elements for tvtk objects.
"""
# Author: Vibha Srinivasan <vibha@enthought.com>
# Copyright (c) 2008,  Enthought, Inc.
# License: BSD Style.

from traits.api import HasTraits, Str, Instance, Property, Button, List, Enum
from traitsui.api import Handler, UIInfo, TableEditor, View, Item
from traitsui.table_column import ObjectColumn
from traits.trait_base \
    import user_name_for, xgetattr

class TraitsViewObject(HasTraits):
   """ Wrapper for all items to be included in the full traits view of the TVTKBase
   object.
   """

   # Trait name (name of the trait that is to be included in the view).
   name = Str

   # The TVTKBase object for which we are building a view.
   parent = Instance(HasTraits)


class ValueColumn(ObjectColumn):
   """ Column to display the trait value for each trait of a tvtk object.
   """

   def get_object ( self, object ):
        """ Returns the actual object being edited.
        Overridden here to return the tvtk object (which is the parent trait of object).

        """
        return object.parent


   def target_name ( self, object ):
        """ Returns the target object and name for the column.
        Overridden here to return the trait name (which is the object's name trait) rather than the
        column's name trait.

        """
        name   = object.name
        object = self.get_object( object )
        col    = name.rfind( '.' )
        if col < 0:
            return ( object, name )

        return ( xgetattr( object, name[ :col ] ), name[ col + 1: ] )


   def get_raw_value ( self, object ):
        """ Gets the unformatted value of the column for a specified object.
        Overridden here to return the trait name (which is the object's name trait) rather than the
        column's name trait.

        """
        try:
            target, name = self.target_name( object )
            return xgetattr( target, name )
        except:
            return None


""" A handler for the TVTKBase object.
"""

class TVTKBaseHandler(Handler):
   """ A handler for the TVTKBase object.
   """

   # A reference to the UIInfo object.
   info = Instance(UIInfo)

   # Type of view (of info.object) to display.
   view_type = Enum(['Basic', 'Advanced'])

   # The view for the object (that is, info.object)
   view = Property(depends_on='view_type')

   # List of TraitsViewObject items, where each item contains information
   # about the trait to display as a row in a table editor.
   _full_traits_list = Property(List, editor = TableEditor(columns =
                                           [ObjectColumn(name='name'),
                                            ValueColumn(name='value')]))

   def init_info(self, info):
       """ Informs the handler what the UIInfo object for a View will be.
       Overridden here to save a reference to the info object.
       """
       self.info = info
       return


   def _get__full_traits_list(self):
       """ Returns a list of objects to be included in the table editor for
       the full traits view.
       """
       return [TraitsViewObject(name=name, parent = self.info.object)
                          for name in self.info.object._full_traitnames_list_]

   def _get_view(self):
      """ Returns the view (for info.object) to be displayed in the
      InstanceEditor.
      """
      if self.view_type ==  "Basic":
           view = self.info.object.trait_view('view')
      else:
           view = self.info.object.trait_view('full_traits_view')
      # This method is called when the default traits view for the object is
      # displayed. The default traits view already has a title, so do not
      # display a title for the contained view.
      view.title = ''
      return view


#### EOF ###################################################################

########NEW FILE########
__FILENAME__ = ctf
"""Color transfer function related code.

"""
# Author: Prabhu Ramachandran <prabhu@aero.iitb.ac.in>
# Copyright (c) 2006-2009, Enthought, Inc.
# License: BSD Style.

# Enthought library imports.
from traits.api import List
from tvtk.api import tvtk


##########################################################################
# Color transfer function related utility code from MayaVi1.
##########################################################################
def _err_msg(obj, cls_name):
    return '%s %s does not have either a "nodes" attribute or a '\
           '"get_node_value" method'%(cls_name, str(obj))

def save_ctfs(volume_property):
    """Given a `tvtk.VolumeProperty` it saves the state of the RGB and
    opacity CTF to a dictionary and returns that.

    The 'rgb' key stores a list of (x, r, g, b) and the 'alpha' a list
    of (x, a) values.
    """
    vp = volume_property
    ctf = vp.rgb_transfer_function
    otf = vp.get_scalar_opacity()
    s1, s2 = ctf.range
    # The RGB values.
    nc = ctf.size
    rgb = []
    if hasattr(ctf, 'nodes'):
        for i in range(nc):
            x = ctf.nodes[i]
            r, g, b = ctf.get_color(x)
            rgb.append([x, r, g, b])
    elif hasattr(ctf, 'get_node_value'):
        val = [0]*6
        for i in range(nc):
            ctf.get_node_value(i, val)
            rgb.append(val[:4])
    else:
        raise TypeError, _err_msg(ctf, 'ColorTransferFunction')

    # The Alpha values.
    na = otf.size
    a = []
    if hasattr(otf, 'nodes'):
        for i in range(na):
            x = otf.nodes[i]
            val = otf.get_value(x)
            a.append([x, val])
    elif hasattr(otf, 'get_node_value'):
        val = [0]*4
        for i in range(na):
            otf.get_node_value(i, val)
            a.append(val[:2])
    else:
        raise TypeError, _err_msg(otf, 'PiecewiseFunction')

    return {'range': (s1, s2), 'rgb':rgb, 'alpha':a}

def load_ctfs(saved_data, volume_property):
    """ Given the saved data produced via `save_ctfs`, this sets the
    state of the passed volume_property appropriately.

    It returns the new color transfer function and piecewise function.
    """
    rgb = saved_data['rgb']
    a = saved_data['alpha']

    # The new_ctf/otf shenanigans are necessary because if the ctf/otf
    # go out of scope we loose the node information.  This is because
    # the tvtk object is really a dynamically generated wrapper.

    # First do the RGB values ...
    new_ctf = True
    ctf = volume_property.rgb_transfer_function
    if isinstance(ctf, ColorTransferFunction):
        new_ctf = False
        ctf.remove_all_points()
    else:
        ctf = ColorTransferFunction()
    nc = len(rgb)
    for i in range(nc):
        ctf.add_rgb_point(rgb[i][0], *(rgb[i][1:]))
    if new_ctf:
        volume_property.set_color(ctf)
    try:
        ctf.range = saved_data['range']
    except Exception:
        # VTK versions < 5.2 don't seem to need this.
        pass
    # and then the alpha values.
    na = len(a)
    new_otf = True
    otf = volume_property.get_scalar_opacity()
    if isinstance(otf, PiecewiseFunction):
        new_otf = False
        otf.remove_all_points()
    else:
        otf = PiecewiseFunction()
    for i in range(na):
        otf.add_point(a[i][0], a[i][1])
    if new_otf:
        volume_property.set_scalar_opacity(otf)
    return ctf, otf

def rescale_ctfs(volume_property, new_range):
    """ Given the volume_property with a new_range for the data while
    using the same transfer functions, this function rescales the
    CTF's so that everything works OK.

    It returns the CTF and OTF.
    """
    ctf = volume_property.rgb_transfer_function
    otf = volume_property.get_scalar_opacity()
    old_range = ctf.range
    def _rescale_value(x, old, new):
        nx = (x - old[0])/(old[1] - old[0])
        return new[0] + nx*(new[1] - new[0])
    if new_range[0] != old_range[0] and new_range[1] != old_range[1]:
        s_d = save_ctfs(volume_property)
        # Set the new range making sure that they are in the right order.
        s1, s2 = new_range
        if s1 > s2:
            s_d['range'] = (s2, s1)
        else:
            s_d['range'] = (s1, s2)
        # Rescale the RGB values.
        rgb = s_d['rgb']
        for v in rgb:
            v[0] = _rescale_value(v[0], old_range, new_range)
        # Rescale the alpha values.
        alpha = s_d['alpha']
        for v in alpha:
            v[0] = _rescale_value(v[0], old_range, new_range)
        # Now load the rescaled values.
        ctf, otf = load_ctfs(s_d, volume_property)
    return ctf, otf

def set_lut(lut, volume_property):
    """Given a `tvtk.LookupTable` and a `tvtk.VolumeProperty` it saves
    the state of the RGB and opacity CTF from the volume property to
    the LUT.  The number of colors to use is obtained from the LUT and
    not the CTF.
    """
    vp = volume_property
    ctf = vp.rgb_transfer_function
    otf = vp.get_scalar_opacity()
    s1, s2 = ctf.range
    nc = lut.number_of_colors
    ds = float(s2-s1)/(nc - 1)
    for i in range(nc):
        r, g, b = ctf.get_color(s1 + i*ds)
        a = otf.get_value(s1 + i*ds)
        lut.set_table_value(i, r, g, b, a)

def set_ctf_from_lut(lut, volume_property):
    """Given a `tvtk.LookupTable` and a `tvtk.VolumeProperty` it loads
    the state of the RGB and opacity CTF from the lookup table to the
    CTF.  The CTF range is obtained from the volume property and the
    number of colors to use is obtained from the LUT.
    """
    vp = volume_property
    ctf = vp.rgb_transfer_function
    s1, s2 = ctf.range
    nc = lut.number_of_colors
    ds = float(s2-s1)/(nc - 1)
    ctf = ColorTransferFunction()
    otf = PiecewiseFunction()
    for i in range(nc):
        v = s1 + i*ds
        r, g, b, a = lut.get_table_value(i)
        ctf.add_rgb_point(v, r, g, b)
        otf.add_point(v, a)
    volume_property.set_color(ctf)
    volume_property.set_scalar_opacity(otf)


##########################################################################
# `ColorTransferFunction` class.
##########################################################################
class ColorTransferFunction(tvtk.ColorTransferFunction):
    """Overrides a few important methods that allow us to glean node
    information.  This is useful in cases where the super class does
    not have methods to get the nodes.
    """

    # Stores the nodes used by the CTF.  Note that this is not a
    # proper trait and modifying this will not change the underlying
    # VTK object.
    nodes = List

    def add_rgb_point(self, *args):
        """V.add_rgb_point(float, float, float, float) -> int
        V.add_rgb_point(float, float, float, float, float, float) -> int

        Add/Remove a point to/from the function defined in RGB or HSV
        Return the index of the point (0 based), or -1 on error.

        Wrapper around parent class functionality to store node
        information.

        """
        ret = super(ColorTransferFunction, self).add_rgb_point(*args)
        self.nodes.append(args[0])
        self.nodes.sort()
        return ret

    def add_hsv_point(self, *args):
        """V.add_hsv_point(float, float, float, float) -> int
        V.add_hsv_point(float, float, float, float, float, float) -> int

        Add/Remove a point to/from the function defined in RGB or HSV
        Return the index of the point (0 based), or -1 on error.

        Wrapper around parent class functionality to store node
        information.

        """
        ret = super(ColorTransferFunction, self).add_hsv_point(*args)
        self.nodes.append(args[0])
        self.nodes.sort()
        return ret

    def remove_all_points(self):
        """Remove all the points.
        """
        super(ColorTransferFunction, self).remove_all_points()
        self.nodes = []


##########################################################################
# `PiecewiseFunction` class.
##########################################################################
class PiecewiseFunction(tvtk.PiecewiseFunction):
    """Overrides a few important methods that allow us to glean node
    information.  This is useful in cases where the super class does
    not have methods to get the nodes.
    """

    # Stores the nodes used by the function.  Note that this is not a
    # proper trait and modifying this will not change the underlying
    # VTK object.
    nodes = List

    def initialize(self):
        """V.initialize()

        Clears out the current function. A newly created
        PiecewiseFunction is alreay initialized, so there is no need
        to call this method which in turn simply calls
        remove_all_points()
        """
        super(PiecewiseFunction, self).initialize()
        self.nodes = []

    def add_point(self, x, val):
        """V.add_point(float, float) -> int
        V.add_point(float, float, float, float) -> int

        Add/Remove points to/from the function. If a duplicate point
        is added then the function value is changed at that location.
        Return the index of the point (0 based), or -1 on error.
        """
        ret = super(PiecewiseFunction, self).add_point(x, val)
        self.nodes.append(x)
        self.nodes.sort()
        return ret

    def remove_point(self, x):
        """V.remove_point(float) -> int

        Add/Remove points to/from the function. If a duplicate point
        is added then the function value is changed at that location.
        Return the index of the point (0 based), or -1 on error.
        """
        ret = super(PiecewiseFunction, self).remove_point(x)
        self.nodes.remove(x)
        self.nodes.sort()
        return ret

    def remove_all_points(self):
        """Remove all the points.
        """
        super(PiecewiseFunction, self).remove_all_points()
        self.nodes = []


########NEW FILE########
__FILENAME__ = gradient_editor
""" The common code for a gradient editor for `tvtk.LookupTables` and
`tvtk.VolumeProperty` color transfer functions.  Most of the code is
independent of tvtk however.

The toolkit specific code is in toolkit specific files.  This code is
distributed under the conditions of the BSD license.

This code was originally written by Gerald Knizia <cgk.d@gmx.net> and
later modified by Prabhu Ramachandran for tvtk and MayaVi2.

Copyright (c) 2005-2013, Gerald Knizia and Prabhu Ramachandran
"""

from os.path import splitext

from tvtk.api import tvtk


##########################################################################
# Utility functions.
##########################################################################
def lerp(arg0,arg1,f):
    """linearly interpolate between arguments arg0 and arg1.

       The weight f is from [0..1], with f=0 giving arg0 and f=1 giving arg1"""
    return (1-f)*arg0 + f*arg1

def rgba_to_hsva(r,g,b,a):
    """Convert color from RGBA to HSVA.

    input: r,g,b,a are from [0..1]
    output: h,s,v,a are from [0..1] (h will never be 1.0)

    See http://en.wikipedia.org/wiki/HSV_color_space
    Only difference: hue range is [0..1) here, not [0..360)."""
    max_comp = max((r,g,b))
    min_comp = min((r,g,b))
    h = 1.0/6.0 #60.0
    if ( max_comp != min_comp ):
        if ( r >= g) and ( r >= b ):
            h *= 0 + (g-b)/(max_comp-min_comp)
        elif ( g >= b ):
            h *= 2 + (b-r)/(max_comp-min_comp)
        else:
            h *= 4 + (r-g)/(max_comp-min_comp)
    if h < 0:
            h += 1.0
    if h > 1.0:
            h -= 1.0
    if ( max_comp != 0 ):
        s = ( max_comp - min_comp )/max_comp
    else:
        s = 0
    v = max_comp
    return (h,s,v,a)

def hsva_to_rgba(h_,s,v,a):
    """Convert color from HSVA to RGBA.

    input: h,s,v,a are from [0..1]
    output: r,g,b,a are from [0..1]

    See http://en.wikipedia.org/wiki/HSV_color_space
    Only difference: hue range is [0..1) here, not [0..360)."""
    (r,g,b,a) = (v,v,v,a)
    h = h_ * 360.0
    if ( s < 1e-4 ):
        return (r,g,b,a)#zero saturation -> color acromatic
    hue_slice_index = int(h/60.0)
    hue_partial = h/60.0 - hue_slice_index
    p = v * ( 1 - s )
    q = v * ( 1 - hue_partial * s )
    t = v * ( 1 - (1-hue_partial) * s )
    if ( 0 == hue_slice_index ):
        r, g, b = v, t, p
    elif ( 1 == hue_slice_index ):
        r, g, b = q, v, p
    elif ( 2 == hue_slice_index ):
        r, g, b = p, v, t
    elif ( 3 == hue_slice_index ):
        r, g, b = p, q, v
    elif ( 4 == hue_slice_index ):
        r, g, b = t, p, v
    elif ( 5 == hue_slice_index ):
        r, g, b = v, p, q
    return (r,g,b,a)


##########################################################################
# `Color` class.
##########################################################################
class Color:
    """Represents a color and provides means of automatic conversion between
    HSV(A) and RGB(A) color spaces. The color is stored in HSVA space."""
    def __init__(self):
        self.hsva = (0.0, 0.0, 0.5, 1.0)

    def set_rgb(self,r,g,b):
        self.set_rgba(r,g,b,1.0)

    def set_rgba(self,r,g,b,a):
        self.hsva = rgba_to_hsva(r,g,b,a)

    def get_rgb255(self):
        """returns a tuple (r,g,b) of 3 integers in range [0..255] representing
        the color."""
        rgba = self.get_rgba()
        return (int(rgba[0]*255), int(rgba[1]*255), int(rgba[2]*255) )

    def get_rgba(self):
        h,s,v,a = self.hsva
        return hsva_to_rgba(h,s,v,a)

    def get_hsva(self):
        return self.hsva

    def set_hsva(self,h,s,v,a):
        self.hsva = (h,s,v,a)

    def set_lerp(self, f,A,B):
        """Set self to result of linear interpolation between colors A and
           B in HSVA space.

           The weight f is from [0..1], with f=0 giving A and f=1 giving
           color B."""
        h = lerp(A.hsva[0], B.hsva[0], f)
        s = lerp(A.hsva[1], B.hsva[1], f)
        v = lerp(A.hsva[2], B.hsva[2], f)
        a = lerp(A.hsva[3], B.hsva[3], f)
        self.hsva = (h,s,v,a)


##########################################################################
# `ColorControlPoint` class.
##########################################################################
class ColorControlPoint:
    """A control point represents a fixed position in the gradient
    and its assigned color. A control point can have indifferent
    color channels in hsv space, i.e. channels, on which its
    presence does not impose any effect."""
    def __init__(self, active_channels, fixed=False):
        self.color = Color()
        # position in the gradient table. range: [0..1].
        self.pos = 0.0
        # fixed control points can not be moved to other positions. The
        # control points for the begin and the end of the gradient are usually
        # the only fixed control points.
        self.fixed = fixed

        if ( 'a' != active_channels ):
            self.active_channels = "rgb"
            self.activate_channels(active_channels)
        else:
            self.active_channels = "a"

    def activate_channels(self,new_channels):
        """NewChannels: string consisting of the new color channel names"""
        for c in new_channels:
            if ( not ( c in self.active_channels ) ):
                self.active_channels += c

    def set_pos(self,f):
        self.pos = max(min(f,1.0), 0.0)

##########################################################################
# `GradientTableOld` class.
##########################################################################
class GradientTableOld:
    """this class represents a logical gradient table, i.e. an array
    of colors and the means to control it via control points"""

    def __init__( self, num_entries ):
        self.size = num_entries
        self.table = [[0.0]*self.size, [0.0]*self.size,
                      [0.0]*self.size, [0.0]*self.size]
        self.table_hsva = [[0.0]*self.size, [0.0]*self.size,
                           [0.0]*self.size, [0.0]*self.size]
        # ^- table[channel][index]: rgba values of the colors of the table.
        # range: [0..1]^4.

        # insert the control points for the left and the right end of the
        # gradient. These are fixed (i.e. cannot be moved or deleted) and
        # allow one to set begin and end colors.
        left_control_point = ColorControlPoint(fixed=True, active_channels="hsva")
        left_control_point.set_pos(0.0)
        left_control_point.color.set_rgb(0.0, 0.0, 0.0)
        right_control_point = ColorControlPoint(fixed=True, active_channels="hsva")
        right_control_point.set_pos(1.0)
        right_control_point.color.set_rgb(1.0, 1.0, 1.0)
        self.control_points = [left_control_point, right_control_point]
        # note: The array of control points always has to be sorted by gradient
        # position of the control points.

        # insert another control point. This one has no real function, it
        # is just there to make the gradient editor more colorful initially
        # and suggest to the (first time user) that it is actually possible to
        # place more control points.
        mid_control_point = ColorControlPoint(active_channels="hsv")
        mid_control_point.set_pos(0.4)
        mid_control_point.color.set_rgb(1.0,0.4,0.0)
        self.insert_control_point( mid_control_point )

        # it is possible to scale the output gradient using a nonlinear function
        # which maps [0..1] to [0..1], aviable using the "nonlin" option in the
        # gui. Per default, this option is disabled however.
        self.scaling_function_string = ""  # will receive the function string if
                                           # set, e.g. "x**(4*a)"

        self.scaling_function_parameter = 0.5 # the parameter a, slider controlled
        self.scaling_function = None      # the actual function object. takes one
                                          # position parameter. None if disabled.

        self.update()

    def get_color_hsva(self,idx):
        """return (h,s,v,a) tuple in self.table_hsva for index idx"""
        return (self.table_hsva[0][idx],self.table_hsva[1][idx],
                self.table_hsva[2][idx],self.table_hsva[3][idx])

    def get_color(self,idx):
        """return (r,g,b,a) tuple in self.table for index idx"""
        return (self.table[0][idx],self.table[1][idx],
                self.table[2][idx],self.table[3][idx])

    def set_color_hsva(self,idx,hsva_color):
        """set hsva table entry for index idx to hsva_color, which must be
        (h,s,v,a)"""
        self.table_hsva[0][idx] = hsva_color[0]
        self.table_hsva[1][idx] = hsva_color[1]
        self.table_hsva[2][idx] = hsva_color[2]
        self.table_hsva[3][idx] = hsva_color[3]

    def set_color(self,idx,rgba_color):
        """set rgba table entry for index idx to rgba_color, which must be
        (r,g,b,a)"""
        self.table[0][idx] = rgba_color[0]
        self.table[1][idx] = rgba_color[1]
        self.table[2][idx] = rgba_color[2]
        self.table[3][idx] = rgba_color[3]

    def get_pos_index(self,f):
        """return index in .table of gradient position f \in [0..1]"""
        return int(f*(self.size-1))

    def get_index_pos(self,idx):
        """return position f \in [0..1] of gradient table index idx"""
        return (1.0*idx)/(self.size-1)

    def get_pos_color(self,f):
        """return a Color object representing the color which is lies at
        position f \in [0..1] in the current gradient"""
        result = Color()
        #e = self.table_hsva[:,self.get_pos_index(f)]
        e = self.get_color_hsva(self.get_pos_index(f))
        result.set_hsva(e[0], e[1], e[2], e[3])
        return result

    def get_pos_rgba_color_lerped(self,f):
        """return a (r,g,b,a) color representing the color which is lies at
        position f \in [0..1] in the current gradient. if f is outside the
        [0..1] interval, the result will be clamped to this interval"""
        scaled_pos = max(min(f,1.0), 0.0)*(self.size-1)
        idx0 = int(scaled_pos)
        fraction = scaled_pos - idx0
        idx1 = min( self.size - 1, 1 + idx0 )
        r = lerp( self.table[0][idx0], self.table[0][idx1], fraction )
        g = lerp( self.table[1][idx0], self.table[1][idx1], fraction )
        b = lerp( self.table[2][idx0], self.table[2][idx1], fraction )
        a = lerp( self.table[3][idx0], self.table[3][idx1], fraction )
        return (r,g,b,a)

    def insert_control_point(self,new_point):
        """Insert a new control point into the table. Does sort the control
        points, but does NOT update the table."""
        self.control_points += [new_point]
        self.sort_control_points()

    def sort_control_points(self):
        """Sort control points by position. Call this if the position of
        any control point was changed externally. The control point array
        always has to be sorted."""
        def pred(x, y):
            if x < y:
                return -1
            elif y < x:
                return +1
            else:
                return 0
        self.control_points.sort( lambda x, y: pred(x.pos, y.pos) )

    def update(self):
        """Recalculate the gradient table from the control points. The colors
        are interpolated linearly between each two control points in hsva space.
        """
        #self.Sortcontrol_points()
        control_point_indices_total = []
        for point in self.control_points:
            control_point_indices_total.append((self.get_pos_index(point.pos),point))

        # first, recalculate the Hsva table channel-wise from the control points
        for it in [("h",0),("s",1),("v",2),("a",3)]:
            # take into account only control points which are active
            # for the current channel
            control_point_indices = filter( \
                lambda x: it[0] in x[1].active_channels,
                control_point_indices_total )
            assert( len( control_point_indices ) >= 2 )

            # we always interpolate between two adjacent control points on the
            # current channel. NextIntervalBeginIdx marks the first table index
            # on which the next set of control points is to be choosen.
            start_point_id = -1
            end_point_id = 0
            start_pos = 0 #dummy value
            end_pos = 0 #dummy value
            next_interval_begin_idx = 0
            end_point = control_point_indices[0][1]
            assert( next_interval_begin_idx == 0 )
            for k in range(self.size):
                while( k == next_interval_begin_idx ):
                    # ^-- this loop makes sure that we won't attempt to
                    # interpolate between two control points that lie on
                    # each other. read "if" instead of "while".
                    start_point_id += 1
                    end_point_id += 1
                    start_point = end_point
                    start_pos = end_pos
                    end_point = control_point_indices[end_point_id][1]
                    end_pos = end_point.pos
                    next_interval_begin_idx = 1+control_point_indices[end_point_id][0]

                # calculate float position of this entry in the gradient table
                # and (linear) position in the current gradient between the
                # two current control points
                cur_pos = self.get_index_pos(k)
                f = ( cur_pos - start_pos ) / ( end_pos - start_pos )
                assert( ( 0 <= f ) and ( f <= 1 ) )
                # ^-- this might happen when two control points lie on each
                # other. Since this case only occurs as an intermediate case
                # when dragging it is not really problematic.
                #f = min( 1.0, max( 0.0, f ) )

                self.table_hsva[it[1]][k] = lerp(start_point.color.hsva[it[1]],
                        end_point.color.hsva[it[1]], f)
            assert( next_interval_begin_idx == self.size )
        # convert hsva colors to rgba
        for k in range(self.size):
            h,s,v,a = self.get_color_hsva(k)
            self.set_color(k, hsva_to_rgba(h, s, v, a))

    def store_to_vtk_lookup_table(self, vtk_table, num_entries=256):
        """Store current color table in `vtk_table`, an instance of
        `tvtk.LookupTable`.
        """
        vtk_table.number_of_table_values = num_entries
        scale_xform = lambda x:x
        if self.scaling_function:
            scale_xform = self.scaling_function
        for idx in range(num_entries):
            f = scale_xform(float(idx)/(num_entries-1))
            rgba = self.get_pos_rgba_color_lerped(f)
            vtk_table.set_table_value( idx, rgba )

    def store_to_vtk_volume_prop(self, volume_prop, scalar_range):
        """Given a `tvtk.VolumeProperty` and a scalar range to map
        values into, this sets the CTF based on the current control
        points.
        """
        # FIXME: This method does not support scaling!
        ctf = volume_prop.rgb_transfer_function
        ctf.remove_all_points()
        otf = volume_prop.get_scalar_opacity()
        otf.remove_all_points()
        s1, s2 = scalar_range
        size = s2 - s1
        for point in self.control_points:
            x = s1 + point.pos*size
            h, s, v, a = point.color.get_hsva()
            if point.active_channels != 'a':
                ctf.add_hsv_point(x, h, s, v)
            if 'a' in point.active_channels:
                otf.add_point(x, a)

    def load_from_vtk_volume_prop(self, volume_prop):
        """Given a vtkVolumeProperty, this initializes the control
        points of the gradient table.  This works best when a
        ctf.ColorTransferFunction and PiecewiseFunction are used.

        Note that it is not as easy to setup the control points from a
        LUT because the LUT may end up having more than the size of
        the table editor here.  It also usually does not make sense to
        do this with a LUT.
        """
        # FIXME: This method does not support scaling!
        ctf = volume_prop.rgb_transfer_function
        otf = volume_prop.get_scalar_opacity()
        # We need a CTF with at least 2 points.
        size = ctf.size
        assert (size > 1)
        assert (otf.size > 1)
        s1, s2 = ctf.range
        scale = float(s2 - s1)
        ds = scale/(size -1)
        new_ctl_pts = []
        has_nodes = False
        if hasattr(ctf, 'nodes'):
            has_nodes = True
        for i in range(size):
            if has_nodes:
                x = ctf.nodes[i]
            else:
                x = s1 + i*ds
            r, g, b = ctf.get_color(x)
            a = otf.get_value(x)
            if (i == 0) or (i == (size-1)):
                # First and last points are fixed.
                pt = ColorControlPoint(active_channels="hsva", fixed=True)
            else:
                pt = ColorControlPoint(active_channels="hsv", fixed=False)

            pt.color.set_rgba(r, g, b, a)
            pos = (x - s1)/scale
            pt.set_pos(pos)
            new_ctl_pts.append(pt)

        # The alpha values are indipendent of the hsv ones.
        size = otf.size
        ds = scale/(size -1)
        has_nodes = False
        if hasattr(ctf, 'nodes'):
            has_nodes = True
        for i in range(1, size-1):
            if has_nodes:
                x = otf.nodes[i]
            else:
                x = s1 + i*ds
            a = otf.get_value(x)
            r, g, b = ctf.get_color(x)
            pt = ColorControlPoint(active_channels="a", fixed=False)
            pt.color.set_rgba(r, g, b, a)
            pos = (x - s1)/scale
            pt.set_pos(pos)
            new_ctl_pts.append(pt)

        self.control_points = new_ctl_pts
        self.sort_control_points()
        self.update()

    def scaling_parameters_changed(self):
        """Recompile the scaling function."""
        from math import tan, atan, cos, acos, sin, asin, pow, log, exp, e, pi
        self.scaling_function = None

        # let python generate a new function via the exec statement. to make
        # the security risk calculable, we execute that function in a local
        # scope. The downside is that we have to provide math functions
        # one at a time.
        def_string = "def ParamFn(x): return %s " % (self.scaling_function_string)
        dict = {"a":self.scaling_function_parameter, "ParamFn":None,
            "atan":atan, "tan":tan, "cos":cos, "acos":acos,
            "sin":sin, "asin":asin, "pow":pow, "log":log, "exp":exp, "e":e,
            "pi":pi }
        if ( "" == self.scaling_function_string ):
            return
        try:
            exec def_string in dict
            self.scaling_function = dict["ParamFn"]
        except:
            raise ValueError("failed to compile function: ", def_string )

    def set_scaling_function_parameter(self,new_parameter):
        """Set the 'a' parameter of the scaling function"""
        self.scaling_function_parameter = new_parameter
        self.scaling_parameters_changed()

    def set_scaling_function(self,new_function_string):
        """Set scaling function. new_function_string is a string describing the
        function, e.g. 'x**(4*a)' """
        self.scaling_function_string = new_function_string
        self.scaling_parameters_changed()

    def save(self, file_name):
        """Save control point set into a new file FileName. It is not checked
        whether the file already exists. Further writes out a VTK .lut file
        and a .jpg file showing the gradients."""

        # Ensure that if the input file name had one of the extensions
        # we'll be writing out ourselves, it gets stripped out first.
        path_base,ext = splitext(file_name)
        #print(file_name)
        if ext.lower() in ['.lut','.jpg','.jpeg','.grad']:
            ext = ''
        file_name = path_base  + ext

        # Create the three names for the files we'll be actually
        # writing out.
        file_name_grad = file_name + '.grad'
        file_name_lut = file_name + '.lut'
        file_name_jpg = file_name + '.jpg'

        # write control points set.
        file = open( file_name_grad, "w" )
        file.write( "V 2.0 Color Gradient File\n" )
        file.write( "ScalingFunction: %s\n" % (self.scaling_function_string) )
        file.write( "ScalingParameter: %s\n" % (self.scaling_function_parameter) )
        file.write( "ControlPoints: (pos fixed bindings h s v a)\n" )
        for control_point in self.control_points:
            file.write( "  %s %s %s %s %s %s %s\n" % ( \
                control_point.pos, control_point.fixed, control_point.active_channels,
                control_point.color.get_hsva()[0], control_point.color.get_hsva()[1],
                control_point.color.get_hsva()[2], control_point.color.get_hsva()[3] ) )
        file.close()

        # write vtk lookup table. Unfortunatelly these objects don't seem to
        # have any built in and exposed means of loading or saving them, so
        # we build the vtk file directly
        vtk_table = tvtk.LookupTable()
        self.store_to_vtk_lookup_table(vtk_table)
        file = open( file_name_lut, "w" )
        num_colors = vtk_table.number_of_table_values
        file.write( "LOOKUP_TABLE UnnamedTable %s\n" % ( num_colors ) )
        for idx in range(num_colors):
            entry = vtk_table.get_table_value(idx)
            file.write("%.4f %.4f %.4f %.4f\n" % (entry[0],entry[1],entry[2],entry[3]))
        file.close()

        # if the python image library is aviable, also generate a small .jpg
        # file showing how the gradient looks. Based on code from Arnd Baecker.
        try:
            import Image
        except ImportError:
            pass  # we're ready otherwise. no jpg output tho.
        else:
            Ny=64  # vertical size of the jpeg
            im = Image.new("RGBA",(num_colors,Ny))
            for nx in range(num_colors):
                (r,g,b,a) = vtk_table.get_table_value(nx)
                for ny in range(Ny):
                    im.putpixel((nx,ny),(int(255*r),int(255*g),int(255*b),
                                         int(255*a)))
            im.save(file_name_jpg,"JPEG")
            # it might be better to store the gradient as .png file, as these
            # are actually able to store alpha components (unlike jpg files)
            # and might also lead to a better compression.

    def load(self, file_name):
        """Load control point set from file FileName and recalculate gradient
        table."""
        file = open( file_name, "r" )
        version_tag = file.readline()
        version = float(version_tag.split()[1])+1e-5
        if ( version >= 1.1 ):
            # read in the scaling function and the scaling function parameter
            function_line_split = file.readline().split()
            parameter_line = file.readline()
            if ( len(function_line_split)==2 ):
                self.scaling_function_string = function_line_split[1]
            else:
                self.scaling_function_string = ""
            self.scaling_function_parameter = float(parameter_line.split()[1])
        else:
            self.scaling_function_string = ""
            self.scaling_function_parameter = 0.5
        file.readline()
        new_control_points = []
        while True:
            cur_line = file.readline()
            if len(cur_line) == 0:
                # readline is supposed to return an empty string at EOF
                break
            args = cur_line.split()
            if ( len(args) < 7 ):
                msg = "gradient file format broken at line:\n"
                msg += cur_line
                raise ValueError(msg)
            new_point = ColorControlPoint(active_channels="")
            new_point.set_pos( float( args[0] ) )
            new_point.fixed = "True" == args[1] #bool( args[1] )
            new_point.active_channels = args[2]
            (h,s,v,a) = ( float(args[3]), float(args[4]),
                          float(args[5]), float(args[6]) )
            new_point.color.set_hsva(h,s,v,a)
            new_control_points.append(new_point)
        file.close()
        self.control_points = new_control_points
        self.sort_control_points()
        self.scaling_parameters_changed()
        self.update()


##########################################################################
# `GradientTable` class.
##########################################################################
class GradientTable:
    """this class represents a logical gradient table, i.e. an array
    of colors and the means to control it via control points

    This class (unlike the GradientTableOld) does not support scaling
    and uses VTK's ColorTransferFunction and PiecewiseFunction to
    perform the actual interpolation.
    """

    def __init__( self, num_entries ):
        self.size = num_entries
        self.table = tvtk.ColorTransferFunction()
        try:
            self.table.range = (0.0, 1.0)
        except Exception:
            # VTK versions < 5.2 don't seem to need this.
            pass

        self.alpha = tvtk.PiecewiseFunction()
        # These VTK classes perform the interpolation for us.

        # insert the control points for the left and the right end of the
        # gradient. These are fixed (i.e. cannot be moved or deleted) and
        # allow one to set begin and end colors.
        left_control_point = ColorControlPoint(fixed=True, active_channels="hsva")
        left_control_point.set_pos(0.0)
        left_control_point.color.set_rgb(0.0, 0.0, 0.0)
        right_control_point = ColorControlPoint(fixed=True, active_channels="hsva")
        right_control_point.set_pos(1.0)
        right_control_point.color.set_rgb(1.0, 1.0, 1.0)
        self.control_points = [left_control_point, right_control_point]
        # note: The array of control points always has to be sorted by gradient
        # position of the control points.

        # insert another control point. This one has no real function, it
        # is just there to make the gradient editor more colorful initially
        # and suggest to the (first time user) that it is actually possible to
        # place more control points.
        mid_control_point = ColorControlPoint(active_channels="hsv")
        mid_control_point.set_pos(0.4)
        mid_control_point.color.set_rgb(1.0,0.4,0.0)
        self.insert_control_point( mid_control_point )

        # These variables are only for compatibility with GradientTableOld.
        self.scaling_function_string = ""  # will receive the function string if
                                           # set, e.g. "x**(4*a)"

        self.scaling_function_parameter = 0.5 # the parameter a, slider controlled
        self.scaling_function = None      # the actual function object. takes one
                                          # position parameter. None if disabled.

        self.update()

    def get_color_hsva(self, f):
        """return (h,s,v,a) tuple in self.table_hsva for fraction f in
        [0,1]."""
        r, g, b = self.table.get_color(f)
        a = self.alpha.get_value(f)
        return rgba_to_hsva(r, g, b, a)

    def get_color(self, f):
        """return (r,g,b,a) tuple in self.table for fraction f in
        [0,1]."""
        r, g, b = self.table.get_color(f)
        a = self.alpha.get_value(f)
        return r, g, b, a

    def get_pos_color(self,f):
        """return a Color object representing the color which is lies at
        position f \in [0..1] in the current gradient"""
        result = Color()
        e = self.get_color_hsva(f)
        result.set_hsva(*e)
        return result

    def get_pos_rgba_color_lerped(self,f):
        """return a (r,g,b,a) color representing the color which is lies at
        position f \in [0..1] in the current gradient. if f is outside the
        [0..1] interval, the result will be clamped to this
        interval."""
        return self.get_color(f)

    def insert_control_point(self,new_point):
        """Insert a new control point into the table. Does sort the control
        points, but does NOT update the table."""
        self.control_points += [new_point]
        self.sort_control_points()

    def sort_control_points(self):
        """Sort control points by position. Call this if the position of
        any control point was changed externally. The control point array
        always has to be sorted."""
        def pred(x, y):
            if x < y:
                return -1
            elif y < x:
                return +1
            else:
                return 0
        self.control_points.sort( lambda x, y: pred(x.pos, y.pos) )

    def update(self):
        """Recalculate the gradient table from the control points. The
        colors are interpolated linearly between each two control
        points in hsva space.
        """
        #self.sort_control_points()

        table = self.table
        alpha = self.alpha
        table.remove_all_points()
        alpha.remove_all_points()
        for point in self.control_points:
            x = point.pos
            h, s, v, a = point.color.get_hsva()
            if point.active_channels != 'a':
                table.add_hsv_point(x, h, s, v)
            if 'a' in point.active_channels:
                alpha.add_point(x, a)

    def store_to_vtk_lookup_table(self, vtk_table, num_entries=256):
        """Store current color table in `vtk_table`, an instance of
        `tvtk.LookupTable`.
        """
        vtk_table.number_of_table_values = num_entries
        for idx in range(num_entries):
            f = float(idx)/(num_entries-1)
            rgba = self.get_color(f)
            vtk_table.set_table_value( idx, rgba )

    def store_to_vtk_volume_prop(self, volume_prop, scalar_range):
        """Given a `tvtk.VolumeProperty` and a scalar range to map
        values into, this sets the CTF based on the current control
        points.
        """
        # FIXME: This method does not support scaling!
        ctf = volume_prop.rgb_transfer_function
        ctf.remove_all_points()
        otf = volume_prop.get_scalar_opacity()
        otf.remove_all_points()
        s1, s2 = scalar_range
        try:
            ctf.range = s1, s2
        except Exception:
            # VTK versions < 5.2 don't seem to need this.
            pass
        size = s2 - s1
        for point in self.control_points:
            x = s1 + point.pos*size
            h, s, v, a = point.color.get_hsva()
            if point.active_channels != 'a':
                ctf.add_hsv_point(x, h, s, v)
            if 'a' in point.active_channels:
                otf.add_point(x, a)

    def load_from_vtk_volume_prop(self, volume_prop):
        """Given a vtkVolumeProperty, this initializes the control
        points of the gradient table.  This works best when a
        ctf.ColorTransferFunction and PiecewiseFunction are used.

        Note that it is not as easy to setup the control points from a
        LUT because the LUT may end up having more than the size of
        the table editor here.  It also usually does not make sense to
        do this with a LUT.
        """
        # FIXME: This method does not support scaling!
        ctf = volume_prop.rgb_transfer_function
        otf = volume_prop.get_scalar_opacity()
        # We need a CTF with at least 2 points.
        size = ctf.size
        assert (size > 1)
        assert (otf.size > 1)
        s1, s2 = ctf.range
        scale = float(s2 - s1)
        ds = scale/(size -1)
        new_ctl_pts = []
        has_nodes = False
        if hasattr(ctf, 'nodes'):
            has_nodes = True
        for i in range(size):
            if has_nodes:
                x = ctf.nodes[i]
            else:
                x = s1 + i*ds
            r, g, b = ctf.get_color(x)
            a = otf.get_value(x)
            if (i == 0) or (i == (size-1)):
                # First and last points are fixed.
                pt = ColorControlPoint(active_channels="hsva", fixed=True)
            else:
                pt = ColorControlPoint(active_channels="hsv", fixed=False)

            pt.color.set_rgba(r, g, b, a)
            pos = (x - s1)/scale
            pt.set_pos(pos)
            new_ctl_pts.append(pt)

        # The alpha values are indipendent of the hsv ones.
        size = otf.size
        ds = scale/(size -1)
        has_nodes = False
        if hasattr(ctf, 'nodes'):
            has_nodes = True
        for i in range(1, size-1):
            if has_nodes:
                x = otf.nodes[i]
            else:
                x = s1 + i*ds
            a = otf.get_value(x)
            r, g, b = ctf.get_color(x)
            pt = ColorControlPoint(active_channels="a", fixed=False)
            pt.color.set_rgba(r, g, b, a)
            pos = (x - s1)/scale
            pt.set_pos(pos)
            new_ctl_pts.append(pt)

        self.control_points = new_ctl_pts
        self.sort_control_points()
        self.update()

    def scaling_parameters_changed(self):
        """Recompile the scaling function."""
        raise NotImplementedError

    def set_scaling_function_parameter(self,new_parameter):
        """Set the 'a' parameter of the scaling function"""
        raise NotImplementedError

    def set_scaling_function(self,new_function_string):
        """Set scaling function. new_function_string is a string describing the
        function, e.g. 'x**(4*a)' """
        raise NotImplementedError

    def save(self, file_name):
        """Save control point set into a new file FileName. It is not checked
        whether the file already exists. Further writes out a VTK .lut file
        and a .jpg file showing the gradients."""

        # Ensure that if the input file name had one of the extensions
        # we'll be writing out ourselves, it gets stripped out first.
        path_base,ext = splitext(file_name)
        #print(file_name)
        if ext.lower() in ['.lut','.jpg','.jpeg','.grad']:
            ext = ''
        file_name = path_base  + ext

        # Create the three names for the files we'll be actually
        # writing out.
        file_name_grad = file_name + '.grad'
        file_name_lut = file_name + '.lut'
        file_name_jpg = file_name + '.jpg'

        # write control points set.
        file = open( file_name_grad, "w" )
        file.write( "V 2.0 Color Gradient File\n" )
        file.write( "ScalingFunction: %s\n" % (self.scaling_function_string) )
        file.write( "ScalingParameter: %s\n" % (self.scaling_function_parameter) )
        file.write( "ControlPoints: (pos fixed bindings h s v a)\n" )
        for control_point in self.control_points:
            file.write( "  %s %s %s %s %s %s %s\n" % ( \
                control_point.pos, control_point.fixed, control_point.active_channels,
                control_point.color.get_hsva()[0], control_point.color.get_hsva()[1],
                control_point.color.get_hsva()[2], control_point.color.get_hsva()[3] ) )
        file.close()

        # write vtk lookup table. Unfortunatelly these objects don't seem to
        # have any built in and exposed means of loading or saving them, so
        # we build the vtk file directly
        vtk_table = tvtk.LookupTable()
        self.store_to_vtk_lookup_table(vtk_table)
        file = open( file_name_lut, "w" )
        num_colors = vtk_table.number_of_table_values
        file.write( "LOOKUP_TABLE UnnamedTable %s\n" % ( num_colors ) )
        for idx in range(num_colors):
            entry = vtk_table.get_table_value(idx)
            file.write("%.4f %.4f %.4f %.4f\n" % (entry[0],entry[1],entry[2],entry[3]))
        file.close()

        # if the python image library is aviable, also generate a small .jpg
        # file showing how the gradient looks. Based on code from Arnd Baecker.
        try:
            import Image
        except ImportError:
            pass  # we're ready otherwise. no jpg output tho.
        else:
            Ny=64  # vertical size of the jpeg
            im = Image.new("RGBA",(num_colors,Ny))
            for nx in range(num_colors):
                (r,g,b,a) = vtk_table.get_table_value(nx)
                for ny in range(Ny):
                    im.putpixel((nx,ny),(int(255*r),int(255*g),int(255*b),
                                         int(255*a)))
            im.save(file_name_jpg,"JPEG")
            # it might be better to store the gradient as .png file, as these
            # are actually able to store alpha components (unlike jpg files)
            # and might also lead to a better compression.

    def load(self, file_name):
        """Load control point set from file FileName and recalculate gradient
        table."""
        file = open( file_name, "r" )
        version_tag = file.readline()
        version = float(version_tag.split()[1])+1e-5
        if ( version >= 1.1 ):
            # read in the scaling function and the scaling function parameter
            function_line_split = file.readline().split()
            parameter_line = file.readline()
            if ( len(function_line_split)==2 ):
                self.scaling_function_string = function_line_split[1]
            else:
                self.scaling_function_string = ""
            self.scaling_function_parameter = float(parameter_line.split()[1])
        else:
            self.scaling_function_string = ""
            self.scaling_function_parameter = 0.5
        file.readline()
        new_control_points = []
        while True:
            cur_line = file.readline()
            if len(cur_line) == 0:
                # readline is supposed to return an empty string at EOF
                break
            args = cur_line.split()
            if ( len(args) < 7 ):
                msg = "gradient file format broken at line:\n"
                msg += cur_line
                raise ValueError(msg)
            new_point = ColorControlPoint(active_channels="")
            new_point.set_pos( float( args[0] ) )
            new_point.fixed = "True" == args[1] #bool( args[1] )
            new_point.active_channels = args[2]
            (h,s,v,a) = ( float(args[3]), float(args[4]),
                          float(args[5]), float(args[6]) )
            new_point.color.set_hsva(h,s,v,a)
            new_control_points.append(new_point)
        file.close()
        self.control_points = new_control_points
        self.sort_control_points()
        #self.scaling_parameters_changed()
        self.update()



##########################################################################
# `ChannelBase` class.
##########################################################################
class ChannelBase(object):
    def __init__(self, function_control, name, rgb_color,
                 channel_index, channel_mode):
        """arguments documented in function body"""
        self.control = function_control  #owning function control
        self.name = name #'r','g','b','h','s','v' or 'a'
        self.rgb_color = rgb_color
        # ^-- string containing a tk color value with which to
        # paint this channel
        self.index = channel_index #0: r or h, 1: g or s, 2: b or v, 3: a
        self.mode = channel_mode #'hsv' or 'rgb'

    def get_value(self, color):
        """Return height value of the current channel for the given color.
        Range: 0..1"""
        if ( self.mode == 'hsv' ):
            return color.get_hsva()[self.index]
        else:
            return color.get_rgba()[self.index]

    def get_value_index(self, color):
        """Return height index of channel value of Color.
        Range: [1..ControlHeight]"""
        return int( 1+(self.control.height-1)*(1.0 - self.get_value(color)) )

    def get_index_value(self, y):
        """Get value in [0..1] of height index y"""
        return min(1.0, max(0.0, 1.0 - float(y)/(self.control.height-1)))

    def set_value( self, color, new_value_on_this_channel ):
        """Color will be modified: NewValue.. will be set to the color
        channel that ``*self`` represents."""
        if ( self.mode == 'hsv' ):
            hsva = [color.get_hsva()[0], color.get_hsva()[1],
                    color.get_hsva()[2], color.get_hsva()[3] ]
            hsva[self.index] = new_value_on_this_channel
            if ( hsva[0] >= 1.0 - 1e-5 ):
                # hack to make sure hue does not jump back to 0.0
                # when it should be at 1.0 (rgb <-> hsv xform not
                # invertible there)
                hsva[0] = 1.0 - 1e-5
            color.set_hsva(hsva[0],hsva[1],hsva[2],hsva[3])
        else:
            rgba = [color.get_rgba()[0], color.get_rgba()[1],
                    color.get_rgba()[2], color.get_rgba()[3] ]
            rgba[self.index] = new_value_on_this_channel
            color.set_rgba(rgba[0],rgba[1],rgba[2],rgba[3])

    def set_value_index( self, color, y ):
        """Color will be modified: the value assigned to the height index
        y will be set to the color channel of Color ``*self`` represents."""
        self.set_value( color, self.get_index_value(y) )

    def get_pos_index(self,f):
        """Return x-index for gradient position f in [0..1]"""
        return int(f*(self.control.width-1))

    def get_index_pos(self,idx):
        """Return gradient position f in [0..1] for x-index Idx in
        [0..ControlWidth-1]"""
        return (1.0*idx)/(self.control.width-1)

    def paint(self, painter):
        """Paint current channel into Canvas (a canvas of a function control
        object).
        
        This should be overridden to do the actual painting.

        """
        raise NotImplementedError

##########################################################################
# `FunctionControl` class.
##########################################################################
class FunctionControl(object):
    """Widget which displays a rectangular regions on which hue, sat, val
    or rgb values can be modified. An function control can have one or more
    attached color channels."""

    # Radius around a control point center in which we'd still count a
    # click as "clicked the control point"
    control_pt_click_tolerance = 4
    
    ChannelFactory = ChannelBase

    def __init__(self, master, gradient_table, color_space, width, height):
        """Initialize a function control widget on tkframe master.

        Parameters:
        -----------

        master: The master widget.  Note that this widget *must* have
             the methods specified in the `AbstractGradientEditorWidget`
             interface.

        on_table_changed: Callback function taking a bool argument of meaning
            'FinalUpdate'. FinalUpdate is true if a control point is dropped,
            created or removed and false if the update is due to a control point
            currently beeing dragged (but not yet dropped)

        color_space: String which specifies the channels painted on this control.
             May be any combination of h,s,v,r,g,b,a in which each channel
             occurs only once.

        set_status_text: a callback used to set the status text
             when using the editor.
        """
        self.text_map = {'r': 'RED', 'g': 'GREEN', 'b': 'BLUE',
                         'h': 'HUE', 's': 'SATURATION', 'v': 'VALUE',
                         'a': 'ALPHA'}
        self.master = master
        self.table = gradient_table
        self.gradient_table = gradient_table
        self.width = width
        self.height = height

        self.channels = []

        # add the channels
        Channel = self.ChannelFactory
        for c in color_space:
            if c == 'r':
                self.channels += [Channel(self, "r", (255,0,0), 0, 'rgb' )]
            elif c == 'g':
                self.channels += [Channel(self, "g", (0,255,0), 1, 'rgb' )]
            elif c == 'b':
                self.channels += [Channel(self, "b", (0,0,255), 2, 'rgb' )]
            elif c == 'h':
                self.channels += [Channel(self, "h", (255,0,0), 0, 'hsv' )]
            elif c == 's':
                self.channels += [Channel(self, "s", (0,255,0), 1, 'hsv' )]
            elif c == 'v':
                self.channels += [Channel(self, "v", (0,0,255), 2, 'hsv' )]
            elif c == 'a':
                self.channels += [Channel(self, "a", (0,0,0), 3, 'hsv' )]

        # generate a list of channels on which markers should
        # be bound if moved on the current channel. since we interpolate
        # the colors in hsv space, changing the r, g or b coordinates
        # explicitely means that h, s and v all have to be fixed.
        self.active_channels_string = ""
        for channel in self.channels:
            self.active_channels_string += channel.name
        if ( ( 'r' in color_space ) or ( 'g' in color_space ) or ( 'b' in color_space ) ):
            for c in "hsv":
                if ( not ( c in self.active_channels_string ) ):
                    self.active_channels_string += c
        if ( color_space == 'a' ):
            # alpha channels actually independent of all other channels.
            self.active_channels_string = 'a'

        # need to set to "None" initially or event handlers get confused.
        self.cur_drag = None #<- [channel,control_point] while something is dragged.

    def find_control_point(self, x, y):
        """Check if a control point lies near (x,y) or near x if y == None.
        returns [channel, control point] if found, None otherwise"""
        for channel in self.channels:
            for control_point in self.table.control_points:
                # take into account only control points which are
                # actually active for the current channel
                if ( not ( channel.name in control_point.active_channels ) ):
                    continue
                point_x = channel.get_pos_index( control_point.pos )
                point_y = channel.get_value_index( control_point.color )
                y_ = y
                if ( None == y_ ):
                    y_ = point_y
                if ( (point_x-x)**2 + (point_y-y_)**2 <= self.control_pt_click_tolerance**2 ):
                    return [channel, control_point]
        return None

    def table_config_changed(self, final_update):
        """Called internally in the control if the configuration of the attached
        gradient table has changed due to actions of this control.

        Forwards the update/change notice."""
        self.table.update()
        self.master.on_gradient_table_changed(final_update)

    ######################################################################
    # Toolkit specific event methods.
    # Look at wx_gradient_editor.py and qt_gradient_editor.py to see
    # the methods that are necessary.  
    ######################################################################


##########################################################################
# `AbstractGradientEditor` interface.
##########################################################################
class AbstractGradientEditor(object):
    def on_gradient_table_changed(self, final_update):
        """ Update the gradient table and vtk lookuptable."""
        raise NotImplementedError

    def set_status_text(self, msg):
        """Set the status on the status widget if you have one."""
        raise NotImplementedError

    def get_table_range(self):
        """Return the CTF or LUT's scalar range."""
        raise NotImplementedError


##########################################################################
# `GradientEditorWidget` interface.
##########################################################################
class GradientEditorWidget(AbstractGradientEditor):
    """A Gradient Editor widget that can be used anywhere.
    """
    def __init__(self, master, vtk_table, on_change_color_table=None,
                 colors=None):
        """

        Parameters:
        -----------

        vtk_table : the `tvtk.LookupTable` or `tvtk.VolumeProperty` object
                    to set.

        on_change_color_table : A callback called when the color table
                                changes.

        colors : list of 'rgb', 'hsv', 'h', 's', 'v', 'a'
                 (Default : ['rgb', 'hsv', 'a'])

                 'rgb' creates one panel to edit Red, Green and Blue
                 colors.

                 'hsv' creates one panel to edit Hue, Saturation and
                 Value.

                 'h', 's', 'v', 'r', 'g', 'b', 'a' separately
                 specified creates different panels for each.
        """
        if colors is None:
            colors = ['rgb', 'hsv', 'a']
        self.colors = colors
        self.gradient_preview_width = 300
        self.gradient_preview_height = 50
        self.channel_function_width = self.gradient_preview_width
        self.channel_function_height = 80
        self.gradient_table = GradientTable(self.gradient_preview_width)
        self.vtk_color_table = vtk_table
        if isinstance(vtk_table, tvtk.LookupTable):
            self.vtk_table_is_lut = True
        else:
            # This is a tvtk.VolumeProperty
            self.vtk_table_is_lut = False
            # Initialize the editor with the volume property.
            self.gradient_table.load_from_vtk_volume_prop(vtk_table)

        self.on_change_color_table = on_change_color_table

        # Add the function controls:
        self.function_controls = []

        self.tooltip_text = 'Left click: move control points\n'\
                            'Right click: add/remove control points'
        editor_data = {'rgb': ('', 'RGB'),
                            'hsv': ('Hue: Red; Saturation: Green; '\
                               'Value: Blue\n',
                               'HSV'
                               ),
                       'h': ('', 'HUE'),
                       's': ('', 'SAT'),
                       'v': ('', 'VAL'),
                       'r': ('', 'RED'),
                       'g': ('', 'GREEN'),
                       'b': ('', 'BLUE'),
                       'a': ('', 'ALPHA'),
                       }
        self.editor_data = editor_data

    ######################################################################
    # `GradientEditorWidget` interface.
    ######################################################################
    def set_status_text(self, msg):
        raise NotImplementedError

    def on_gradient_table_changed(self, final_update ):
        """ Update the gradient table and vtk lookuptable..."""
        # update all function controls.
        for control in self.function_controls:
            control.update()
        # repaint the gradient display or the external windows only
        # when the instant*** options are set or when the update was final.
        #if final_update or ( 1 == self.show_instant_gradients.get() ):
        if True:
            self.gradient_control.update()

        #if final_update or ( 1 == self.show_instant_feedback.get() ):
        if final_update:
            vtk_table = self.vtk_color_table
            if self.vtk_table_is_lut:
                self.gradient_table.store_to_vtk_lookup_table(vtk_table)
            else:
                rng = self.get_table_range()
                self.gradient_table.store_to_vtk_volume_prop(vtk_table, rng)

            cb = self.on_change_color_table
            if cb is not None:
                cb()

    def get_table_range(self):
        vtk_table = self.vtk_color_table
        if self.vtk_table_is_lut:
            return vtk_table.table_range
        else:
            return vtk_table.get_scalar_opacity().range

    def load(self, file_name):
        """Set the state of the color table using the given file.
        """
        if len(file_name) == 0:
            return
        self.gradient_table.load(file_name)
        self.on_gradient_table_changed(final_update = True)

    def save(self, file_name):
        """Store the color table to the given file.  This actually
        generates 3 files, a '.grad', a '.lut' file and a '.jpg' file.
        The .lut file can be used to setup a lookup table.  The .grad
        file is used to set the state of the gradient table and the
        JPG file is an image of the how the lut will look.
        """
        if len(file_name) == 0:
            return
        self.gradient_table.save(file_name)

########NEW FILE########
__FILENAME__ = qt_gradient_editor
""" A Qt based color gradient editor for vtkLookupTables and
color transfer functions.

This code is distributed under the conditions of the BSD license.

Based on a wxPython by Pete Schmitt <schmitt@colorado.edu>

Author: Prabhu Ramachandran <prabhu@enthought.com>
Copyright (c) 2012-2013 Enthought, Inc., Mumbai, India.
"""


# Enthought library imports
from pyface.qt import QtCore, QtGui

# Local imports
from gradient_editor import (ColorControlPoint, ChannelBase, FunctionControl, 
    GradientEditorWidget)

##########################################################################
# `QGradientControl` class.
##########################################################################
class QGradientControl(QtGui.QWidget):
    """Widget which displays the gradient represented by an GradientTable
    object (and does nothing beyond that)"""
    def __init__(self, parent, gradient_table, width, height ):
        """master: panel in which to place the control. GradientTable is the
        Table to which to attach."""
        super(QGradientControl, self).__init__(parent=parent)
        self.resize(width, height)
        self.setAttribute(QtCore.Qt.WA_OpaquePaintEvent, True)

        self.width = width
        self.height = height
        self.gradient_table = gradient_table
        assert( gradient_table.size == width )
        self.setMinimumSize(100, 50)
        # currently only able to use gradient tables in the same size as the 
        # canvas width

    def paintEvent(self, event):
        """Paint handler."""
        super(QGradientControl, self).paintEvent(event)
        
        painter = QtGui.QPainter(self)
        brush = QtGui.QBrush(QtGui.QColor(0, 0, 0) )
        painter.setBrush(brush)
        painter.setBackgroundMode(QtCore.Qt.OpaqueMode)
        sz = self.size()
        width, height = sz.width(), sz.height()

        xform = self.gradient_table.scaling_function
        start_y = 0
        end_y = height
        if xform:
            # if a scaling transformation is provided, paint the original
            # gradient under the scaled gradient.
            start_y = height/2

        # paint the original gradient as it stands in the table.
        color = QtGui.QColor()
        for x in range(width):
            (r,g,b,a) = self.gradient_table.get_pos_rgba_color_lerped(float(x)/(width-1))
            color.setRgb(int(255*r), int(255*g), int(255*b))
            painter.setPen(color)
            brush.setColor(color)
            painter.drawLine(x, start_y, x, end_y)
        if xform:
            # paint the scaled gradient below
            end_y = start_y
            start_y = 0
            for x in range(width):
                f = float(x)/(width-1)
                (r,g,b,a) = self.gradient_table.get_pos_rgba_color_lerped(xform(f))
	        color.set(int(255*r), int(255*g), int(255*b))
                brush.setColor(color)
                painter.drawLine(x, start_y, x, end_y)


##########################################################################
# `Channel` class.
##########################################################################
class Channel(ChannelBase):
    def paint(self, painter):
        """Paint current channel into Canvas (a canvas of a function control
        object).

        Contents of the canvas are not deleted prior to painting,
        so more than one channel can be painted into the same canvas.
        """

        table = self.control.table
        # only control points which are active for the current channel
        # are to be painted. filter them out.
        relevant_control_points = filter( \
            lambda x: self.name in x.active_channels,
            table.control_points )
        # lines between control points
        color = QtGui.QColor(*self.rgb_color)
        painter.setPen(color)
        brush = QtGui.QBrush(color)
        painter.setBrush(brush)
        painter.setBackgroundMode(QtCore.Qt.OpaqueMode)
        for k in range( len(relevant_control_points) - 1 ):
            cur_point = relevant_control_points[k]
            next_point = relevant_control_points[1+k]

            painter.drawLine(self.get_pos_index(cur_point.pos),
                             self.get_value_index(cur_point.color),
                             self.get_pos_index(next_point.pos),
                             self.get_value_index(next_point.color))

        # control points themself.
        color = QtCore.Qt.black
        painter.setPen(color)
        for control_point in relevant_control_points:
            x = self.get_pos_index( control_point.pos )
            y = self.get_value_index( control_point.color )
            radius=6
            #print(x,y)
            painter.drawRect(x-(radius/2.0), y-(radius/2.0), radius, radius)
            painter.drawRect(100,80,6,6)


##########################################################################
# `QFunctionControl` class.
##########################################################################
class QFunctionControl(QtGui.QWidget, FunctionControl):
    """Widget which displays a rectangular regions on which hue, sat, val
    or rgb values can be modified. An function control can have one or more
    attached color channels."""

    # Radius around a control point center in which we'd still count a
    # click as "clicked the control point"
    control_pt_click_tolerance = 4
    
    ChannelFactory = Channel

    def __init__(self, master, gradient_table, color_space, width, height):
        """Initialize a function control widget on tkframe master.

        Parameters:
        -----------

        master: The master widget.  Note that this widget *must* have
             the methods specified in the `AbstractGradientEditorWidget`
             interface.

        on_table_changed: Callback function taking a bool argument of meaning
            'FinalUpdate'. FinalUpdate is true if a control point is dropped,
            created or removed and false if the update is due to a control point
            currently beeing dragged (but not yet dropped)

        color_space: String which specifies the channels painted on this control.
             May be any combination of h,s,v,r,g,b,a in which each channel
             occurs only once.

        set_status_text: a callback used to set the status text
             when using the editor.
        """
        FunctionControl.__init__(self, master, gradient_table, color_space, 
                                 width, height)
        
        QtGui.QWidget.__init__(self, parent=master)
        self.resize(width, height)
        self.setMinimumSize(100, 50)

    ######################################################################
    # Qt event handlers.
    ######################################################################
    def paintEvent(self, event):
        super(QFunctionControl, self).paintEvent(event)
        
        painter = QtGui.QPainter(self)
        brush = QtGui.QBrush(QtGui.QColor(255, 255, 255))
        painter.setBrush(brush)
        width, height = self.size().width(), self.size().height()        
        painter.drawRect(0, 0, width, height)
        for channel in self.channels:
            channel.paint(painter)

    def mousePressEvent(self, event):
        if event.button() == QtCore.Qt.LeftButton:
            self.cur_drag = self.find_control_point(event.x(), event.y())
        super(QFunctionControl, self).mousePressEvent(event)

    def mouseReleaseEvent(self, event):
        if event.button() == QtCore.Qt.LeftButton:
            if self.cur_drag:
                self.table_config_changed( final_update = True )
                self.cur_drag = None
        elif event.button() == QtCore.Qt.RightButton:
            # toggle control point. check if there is a control point
            # under the mouse. If yes, delete it, if not, create one
            # at that point.
            cur_control_point = self.find_control_point(event.x(), None)
            if cur_control_point:
                # found a marker at the click position. delete it and return,
                # unless it is a fixed marker (at pos 0 or 1)..
                if ( cur_control_point[1].fixed ):
                    # in this case do nothing. Fixed markers cannot be deleted.
                    return
                self.table.control_points.remove(cur_control_point[1])
                self.table_config_changed(final_update=True)
            else:
                # since there was no marker to remove at the point, we assume
                # that we should place one there
                new_control_point = ColorControlPoint(active_channels=self.active_channels_string)
                new_control_point.set_pos(self.channels[0].get_index_pos(event.x()))
    
                # set new control point color to the color currently present
                # at its designated position
                new_control_point.color = self.table.get_pos_color(new_control_point.pos)
    
                self.table.insert_control_point(new_control_point)
                self.table_config_changed(final_update = True)
                
        if isinstance(event, QtGui.QMouseEvent):
            super(QFunctionControl, self).mouseReleaseEvent(event)

    def leaveEvent(self, event):
        if self.cur_drag:
            self.table_config_changed( final_update = True )
            self.cur_drag = None
        super(QFunctionControl, self).leaveEvent(event)
        
    def resizeEvent(self, event):
        sz = self.size()
        self.width = sz.width()
        self.height = sz.height()

    def mouseMoveEvent(self, event):
        # currently dragging a control point?
        channel = None
        point = None
        if self.cur_drag:
            channel = self.cur_drag[0]
            point = self.cur_drag[1]
            if ( not point.fixed ):
                point.set_pos( channel.get_index_pos(event.x()) )
                point.activate_channels( self.active_channels_string )
                self.table.sort_control_points()
            channel.set_value_index( point.color, event.y() )
            self.table_config_changed( final_update = False )

        screenX = event.x()
        screenY = event.y()
        width, height = self.size().width(), self.size().height()
        master = self.master
        s1, s2 = master.get_table_range()
        if channel is not None:
            name = self.text_map[channel.name]
            pos = s1 + (s2 - s1)*point.pos
            val = channel.get_value(point.color)
            txt = '%s: (%.3f, %.3f)'%(name, pos, val)
        else:
            x = s1 + (s2 - s1)*float(screenX)/(width-1)
            y = 1.0 - float(screenY)/(height-1)
            txt = "position: (%.3f, %.3f)"%(x, y)

        self.master.set_status_text(txt)

##########################################################################
# `QGradientEditorWidget` class.
##########################################################################
class QGradientEditorWidget(QtGui.QWidget, GradientEditorWidget):
    """A Gradient Editor widget that can be used anywhere.
    """
    def __init__(self, master, vtk_table, on_change_color_table=None,
                 colors=None):
        """

        Parameters:
        -----------

        vtk_table : the `tvtk.LookupTable` or `tvtk.VolumeProperty` object
                    to set.

        on_change_color_table : A callback called when the color table
                                changes.

        colors : list of 'rgb', 'hsv', 'h', 's', 'v', 'a'
                 (Default : ['rgb', 'hsv', 'a'])

                 'rgb' creates one panel to edit Red, Green and Blue
                 colors.

                 'hsv' creates one panel to edit Hue, Saturation and
                 Value.

                 'h', 's', 'v', 'r', 'g', 'b', 'a' separately
                 specified creates different panels for each.
        """
        GradientEditorWidget.__init__(self, master, vtk_table, 
                                      on_change_color_table, colors)
        QtGui.QWidget.__init__(self, master)

        gradient_preview_width = self.gradient_preview_width
        gradient_preview_height = self.gradient_preview_height
        channel_function_width = self.channel_function_width
        channel_function_height = self.channel_function_height
        
        # set up all the panels in a grid
        # 6x2 size:  6 rows, 2 columns...
        grid = QtGui.QGridLayout()
        grid.setColumnStretch(0, 0)
        grid.setColumnStretch(1, 1)

        # "Gradient Viewer" panel, in position (0,1) for sizer
        self.gradient_control = QGradientControl(self,
                                                 self.gradient_table,
                                                 gradient_preview_width,
                                                 gradient_preview_height)
        self.setToolTip('Right click for menu')
        grid.addWidget(QtGui.QLabel("", self), 0, 0)
        grid.addWidget(self.gradient_control, 0, 1)
        
        # Setup the context menu to fire for the Gradient control alone.
        gc = self.gradient_control
        gc.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)
        gc.customContextMenuRequested.connect(self.contextMenuEventOnGradient)
        
        # Add the function controls:
        function_controls = self.function_controls
        editor_data = self.editor_data
        
        row = 1
        for color in self.colors:
            data = editor_data[color]
            control = QFunctionControl(self, self.gradient_table, color,
                                       channel_function_width,
                                       channel_function_height)
            txt = data[0] + self.tooltip_text
            control.setToolTip(txt)
            # Add name of editor (to left side of editor)
            grid.addWidget(QtGui.QLabel(data[1], self), row, 0)
            # Add the "RGB" control point editor
            grid.addWidget(control, row, 1)
            function_controls.append(control)
            row += 1

        # The status text.
        self.text = QtGui.QLabel('status', self)
        grid.addWidget(self.text, row, 0, 1, 2)

        self.setLayout(grid)
        self.show()

    ######################################################################
    # `GradientEditorWidget` interface.
    ######################################################################
    def set_status_text(self, msg):
        self.text.setText(msg)

    ######################################################################
    # Qt event methods.
    ######################################################################
    def contextMenuEventOnGradient(self, pos):
        menu = QtGui.QMenu(self)
        saveAction = menu.addAction("Save as")
        loadAction = menu.addAction("Load")
        action = menu.exec_(self.mapToGlobal(pos))
        if action == saveAction:
            self.on_save()
        elif action == loadAction:
            self.on_load()        

    def on_save(self, event=None):
        """
        Open "Save" dialog, write lookuptable to 3 files: ``*.lut``
        (lookuptable) ``*.grad`` (gradient table for use with this program),
        and ``*.jpg`` (image of the gradient)
        """
        wildcard = "Gradient Files (*.grad);;All Files (*.*)"
        filename, filter = QtGui.QFileDialog.getSaveFileName(self, 
                                                "Save LUT to...", 
                                                '',
                                                wildcard)
        if filename:
            self.save(filename)

    def on_load(self, event=None):
        """
        Load a ``*.grad`` lookuptable file.
        """
        wildcard = "Gradient Files (*.grad);;All Files (*.*)"
        filename, filter = QtGui.QFileDialog.getOpenFileName(self, 
                                                "Open gradient file...", 
                                                '',
                                                wildcard)
        if filename:
            self.load(filename)


##########################################################################
# `QGradientEditor` class.
##########################################################################
class QGradientEditor(QtGui.QMainWindow):
    """ QMainWindow that displays the gradient editor window,
    i.e. the thing that contains the gradient display, the function
    controls and the buttons.
    """
    def __init__(self, vtk_table, on_change_color_table = None, colors=None):
        """Initialize the gradient editor window.

        Parameters
        ----------
        vtk_table: Instance of vtkLookupTable, designating the table which is
            to be edited.
        on_change_color_table: Callback function taking no arguments. Called
            when the color table was changed and rendering is
            requested.
        """
        super(QGradientEditor, self).__init__()
        self.setWindowTitle("Color Gradient Editor")
        self.widget = QGradientEditorWidget(self, vtk_table,
                                            on_change_color_table,
                                            colors)
                        
        self.setCentralWidget(self.widget)                
        self.resize(300, 500)

        self.statusBar()
        ## Set up the MenuBar
        menu = self.menuBar()
        file_menu = menu.addMenu("&File")
        
        file_action = QtGui.QAction("&Save", self)
        file_action.setStatusTip("Save CTF")
        file_action.triggered.connect(self.widget.on_save)
        file_menu.addAction(file_action)
        
        load_action = QtGui.QAction("&Load", self)
        load_action.setStatusTip("Load CTF")
        load_action.triggered.connect(self.widget.on_load)
        file_menu.addAction(load_action)
        
        quit_action = QtGui.QAction("&Quit", self)
        quit_action.setStatusTip("Quit application")
        quit_action.triggered.connect(QtGui.QApplication.instance().quit)
        file_menu.addAction(quit_action)

        help_menu = menu.addMenu("&Help")
        action = QtGui.QAction("&Help", self)
        action.setStatusTip("Help")
        action.triggered.connect(self.on_help)
        help_menu.addAction(action)
        action = QtGui.QAction("&About", self)
        action.setStatusTip("About application")
        action.triggered.connect(self.on_about)
        help_menu.addAction(action)

                
    def on_help(self, event=None):
        """ Help defining the mouse interactions """
        message = "Right click to add control points.  Left click to move control points"
        QtGui.QMessageBox.information(self, 'Help', message)

    def on_about(self, event=None):
        """ Who wrote the program?"""
        message = 'tk Gradient Editor for MayaVi1: Gerald Knizia (cgk.d@gmx.net)\n'\
                  'wxPython port: Pete Schmitt (schmitt@colorado.edu)\n'\
                  'Qt port: Prabhu Ramachandran\n'\
                  'Enhanced for Mayavi2: Prabhu Ramachandran'
        QtGui.QMessageBox.information(self, 'About gradient editor', message)


def main():
    from traitsui_gradient_editor import make_test_table
    import sys
    table, ctf, otf = make_test_table(lut=False)
    # the actual gradient editor code.
    def on_color_table_changed():
        """If we had a vtk window running, update it here"""
        print("Update Render Window")

    app = QtGui.QApplication.instance()
    editor = QGradientEditor(table,
                              on_color_table_changed,
                              colors=['rgb', 'a', 'h', 's', 'v'],
                              )
    editor.setWindowTitle("Gradient editor")
    editor.show()
    sys.exit(app.exec_())


##########################################################################
# Test application.
##########################################################################
if __name__ == "__main__":
    main()

########NEW FILE########
__FILENAME__ = tk_gradient_editor
""" Defines the UI for a gradient editor for vtkLookupTables and color
transfer functions.

This code is distributed under the conditions of the BSD license.

This code was originally written by Gerald Knizia <cgk.d@gmx.net> and
later modified by Prabhu Ramachandran

Copyright (c) 2005-2006, Gerald Knizia and Prabhu Ramachandran
"""

import Tkinter as tk
import tkFileDialog

from gradient_editor import GradientTable, ColorControlPoint

##########################################################################
# `GradientControl` class.
##########################################################################
class GradientControl(tk.Frame):
    """Widget which displays the gradient represented by an GradientTable
    object (and does nothing beyond that)"""
    def __init__(self, master, gradient_table, width, height ):
        """master: frame in which to place the control. GradientTable is the
        Table to which to attach."""
        tk.Frame.__init__(self, master, borderwidth=2, relief='groove')
        self.width = width
        self.height = height
        self.gradient_table = gradient_table
        assert( gradient_table.size == width )
        # ^- currently only able to use gradient tables in the same
        # size as the canvas width
        self.canvas = tk.Canvas(self, background="white", width=width,
                height=height)
        self.canvas.pack()
        self.update()

    def update(self):
        """Repaint the control."""
        self.canvas.delete(tk.ALL) # clears all lines contained.

        # a look around the web (http://wiki.tcl.tk/11868) told me that
        # using the PhotoImage tk-control would not be a good idea and
        # that line objects work faster. While I doubt this is an optimal
        # solution it currently works fast enought.

        xform = self.gradient_table.scaling_function
        start_y = 0
        end_y = self.height
        if xform:
            # if a scaling transformation is provided, paint the original
            # gradient under the scaled gradient.
            start_y = self.height/2

        # paint the original gradient as it stands in the table.
        width = self.width
        for x in range(width):
            (r,g,b,a) = self.gradient_table.get_pos_rgba_color_lerped(float(x)/(width-1))
            self.canvas.create_line(x,start_y,x,end_y, \
                    fill="#%02x%02x%02x" % (int(255*r),int(255*g),int(255*b)))
        if xform:
            # paint the scaled gradient below
            end_y = start_y
            start_y = 0
            for x in range(self.width):
                f = float(x)/(self.width-1)
                (r,g,b,a) = self.gradient_table.get_pos_rgba_color_lerped(xform(f))
                self.canvas.create_line(x,start_y,x,end_y, \
                        fill="#%02x%02x%02x" % (int(255*r),int(255*g),int(255*b)))

##########################################################################
# `FunctionControl` class.
##########################################################################
class FunctionControl(tk.Frame):
    """Widget which displays a rectangular regions on which hue, sat, val
    or rgb values can be modified. An function control can have one or more
    attached color channels."""

    # Radius around a control point center in which we'd still count a
    # click as "clicked the control point"
    control_pt_click_tolerance = 4

    class Channel:
        def __init__(self, function_control, name, color_string,
                channel_index, channel_mode):
            """arguments documented in function body"""
            self.control = function_control  #owning function control
            self.name = name #'r','g','b','h','s','v' or 'a'
            self.color_string = color_string
            # ^-- string containing a tk color value with which to
            # paint this channel
            self.index = channel_index #0: r or h, 1: g or s, 2: b or v, 3: a
            self.mode = channel_mode #'hsv' or 'rgb'

        def get_value(self, color):
            """Return height value of the current channel for the given color.
            Range: 0..1"""
            if ( self.mode == 'hsv' ):
                return color.get_hsva()[self.index]
            else:
                return color.get_rgba()[self.index]
        def get_value_index(self, color):
            """Return height index of channel value of Color.
            Range: [1..ControlHeight]"""
            return int( 1+(self.control.height-1)*(1.0 - self.get_value(color)) )
        def get_index_value(self, y):
            """Get value in [0..1] of height index y"""
            return min(1.0, max(0.0, 1.0 - float(y-1)/(self.control.height-1)))

        def set_value( self, color, new_value_on_this_channel ):
            """Color will be modified: NewValue.. will be set to the color
            channel that ``*self`` represents."""
            if ( self.mode == 'hsv' ):
                hsva = [color.get_hsva()[0], color.get_hsva()[1],
                        color.get_hsva()[2], color.get_hsva()[3] ]
                hsva[self.index] = new_value_on_this_channel
                if ( hsva[0] >= 1.0 - 1e-5 ):
                    # hack to make sure hue does not jump back to 0.0
                    # when it should be at 1.0 (rgb <-> hsv xform not
                    # invertible there)
                    hsva[0] = 1.0 - 1e-5
                color.set_hsva(hsva[0],hsva[1],hsva[2],hsva[3])
            else:
                rgba = [color.get_rgba()[0], color.get_rgba()[1],
                        color.get_rgba()[2], color.get_rgba()[3] ]
                rgba[self.index] = new_value_on_this_channel
                color.set_rgba(rgba[0],rgba[1],rgba[2],rgba[3])
        def set_value_index( self, color, y ):
            """Color will be modified: the value assigned to the height index
            y will be set to the color channel of Color that ``*self`` represents."""
            self.set_value( color, self.get_index_value(y) )

        def get_pos_index(self,f):
            """Return x-index for gradient position f in [0..1]"""
            return int(f*(self.control.width-1))

        def get_index_pos(self,idx):
            """Return gradient position f in [0..1] for x-index Idx in
            [0..ControlWidth-1]"""
            return (1.0*idx)/(self.control.width-1)

        def paint(self, canvas):
            """Paint current channel into Canvas (a canvas of a function control
            object).

            Contents of the canvas are not deleted prior to painting,
            so more than one channel can be painted into the same canvas."""
            table = self.control.table
            # only control points which are active for the current channel
            # are to be painted. filter them out.
            relevant_control_points = filter( \
                lambda x: self.name in x.active_channels,
                table.control_points )
            # lines between control points
            for k in range( len(relevant_control_points) - 1 ):
                cur_point = relevant_control_points[k]
                next_point = relevant_control_points[1+k]

                canvas.create_line( self.get_pos_index(cur_point.pos),
                        self.get_value_index(cur_point.color),
                        self.get_pos_index(next_point.pos),
                        self.get_value_index(next_point.color),
                        fill = self.color_string  )
            # control points themself.
            for control_point in relevant_control_points:
                x = self.get_pos_index( control_point.pos )
                y = self.get_value_index( control_point.color )
                radius = 3
                canvas.create_rectangle( x - radius, y - radius, x + radius,
                    y + radius, outline = '#000000' )

    def __init__(self, master, gradient_table, color_space, width, height,
            on_table_changed = None ):
        tk.Frame.__init__(self, master, borderwidth=2, relief='groove')
        """Initialize a function control widget on tkframe master.

        input:
        OnTableChanged: Callback function taking a bool argument of meaning
            'FinalUpdate'. FinalUpdate is true if a control point is dropped,
            created or removed and false if the update is due to a control point
            currently beeing dragged (but not yet dropped)
        ColorSpace: String which specifies the channels painted on this control.
             May be any combination of h,s,v,r,g,b,a in which each channel
             occurs only once."""
        self.on_table_changed = on_table_changed
        self.table = gradient_table
        self.width = width
        self.height = height

        self.gradient_table = gradient_table
        self.canvas = tk.Canvas(self, background="white", \
            width=self.width, height=self.height)
        self.canvas.pack()
        self.channels = []

        # add the channels
        Channel = FunctionControl.Channel
        for c in color_space:
            if c == 'r':
                self.channels += [Channel(self, "r", "red", 0, 'rgb' )]
            elif c == 'g':
                self.channels += [Channel(self, "g", "green", 1, 'rgb' )]
            elif c == 'b':
                self.channels += [Channel(self, "b", "blue", 2, 'rgb' )]
            elif c == 'v':
                self.channels += [Channel(self, "v", "#7f7f7f", 2, 'hsv' )]
            elif c == 'h':
                self.channels += [Channel(self, "h", "#ff0000", 0, 'hsv' )]
            elif c == 's':
                self.channels += [Channel(self, "s", "#ffafaf", 1, 'hsv' )]
            elif c == 'a':
                self.channels += [Channel(self, "a", "#000000", 3, 'hsv' )]

        # generate a list of channels on which markers should
        # be bound if moved on the current channel. since we interpolate
        # the colors in hsv space, changing the r, g or b coordinates
        # explicitely means that h, s and v all have to be fixed.
        self.active_channels_string = ""
        for channel in self.channels:
            self.active_channels_string += channel.name
        if ( ( 'r' in color_space ) or ( 'g' in color_space ) or ( 'b' in color_space ) ):
            for c in "hsv":
                if ( not ( c in self.active_channels_string ) ):
                    self.active_channels_string += c
        if ( color_space == 'a' ):
            # alpha channels actually independent of all other channels.
            self.active_channels_string = 'a'

        self.update()

        self.canvas.bind( "<ButtonRelease-1>", self.on_left_button_up )
        self.canvas.bind( "<Button-1>", self.on_left_button_down )
        self.canvas.bind( "<ButtonRelease-3>", self.on_right_button_up )
        self.canvas.bind( "<Button-3>", self.on_right_button_down )
        self.canvas.bind( "<Motion>", self.on_mouse_move )

        self.cur_drag = None #<- [channel,control_point] while something is dragged.

    def update(self):
        """Repaint the control."""
        canvas = self.canvas # shortcut...
        canvas.delete(tk.ALL)

        for channel in self.channels:
            channel.paint(self.canvas)

    def find_control_point(self, x, y):
        """Check if a control point lies near (x,y) or near x if y == None.
        returns [channel, control point] if found, None otherwise"""
        for channel in self.channels:
            for control_point in self.table.control_points:
                # take into account only control points which are
                # actually active for the current channel
                if ( not ( channel.name in control_point.active_channels ) ):
                    continue
                point_x = channel.get_pos_index( control_point.pos )
                point_y = channel.get_value_index( control_point.color )
                y_ = y
                if ( None == y_ ):
                    y_ = point_y
                if ( (point_x-x)**2 + (point_y-y_)**2 <= self.control_pt_click_tolerance**2 ):
                    return [channel, control_point]
        return None

    def on_left_button_down(self, event):
        self.cur_drag = self.find_control_point( event.x, event.y )

    def on_left_button_up(self, event):
        if self.cur_drag:
            self.table_config_changed( final_update = True )
            self.cur_drag = None

    def on_right_button_down(self, event):
        pass

    def table_config_changed(self, final_update):
        """Called internally in the control if the configuration of the attached
        gradient table has changed due to actions of this control.

        Forwards the update/change notice."""
        self.table.update()
        if self.on_table_changed:
            self.on_table_changed(final_update)
        else:
            self.update()

    def on_right_button_up(self, event):
        # toggle control point. check if there is a control point
        # under the mouse. If yes, delete it, if not, create one
        # at that point.
        cur_control_point = self.find_control_point(event.x, None)
        if cur_control_point:
            # found a marker at the click position. delete it and return,
            # unless it is a fixed marker (at pos 0 or 1)..
            if ( cur_control_point[1].fixed ):
                # in this case do nothing. Fixed markers cannot be deleted.
                return
            self.table.control_points.remove(cur_control_point[1])
            self.table_config_changed(final_update=True)
        else:
            # since there was no marker to remove at the point, we assume
            # that we should place one there
            new_control_point = ColorControlPoint(active_channels = self.active_channels_string)
            new_control_point.set_pos(self.channels[0].get_index_pos(event.x))

            # set new control point color to the color currently present
            # at its designated position
            new_control_point.color = self.table.get_pos_color(new_control_point.pos)

            self.table.insert_control_point( new_control_point )
            self.table_config_changed( final_update = True )

    def on_mouse_move(self, event):
        # currently dragging a control point?
        if self.cur_drag:
            channel = self.cur_drag[0]
            point = self.cur_drag[1]
            if ( not point.fixed ):
                point.set_pos( channel.get_index_pos(event.x) )
                point.activate_channels( self.active_channels_string )
                self.table.sort_control_points()
            channel.set_value_index( point.color, event.y )
            self.table_config_changed( final_update = False )


##########################################################################
# `GradientEditor` class.
##########################################################################
class GradientEditor(tk.Toplevel):
    """The gradient editor window, i.e. the thing that contains the gradient
    display, the function controls and the buttons."""
    def __init__(self, master, vtk_table, on_change_color_table = None):
        """Initialize the gradient editor window.

        Parameters
        ----------
        master
            Owning widget, for example a tk root object.
        VtkTable
            Instance of vtkLookupTable, designating the table which is
            to be edited.
        OnChangeColorTable
            Callback function taking no arguments. Called
            when the color table was changed and rendering is requested."""

        # Inner dimensions of the color control gui-elements in pixels.
        gradient_preview_width = 300
        gradient_preview_height = 50
        channel_function_width = gradient_preview_width
        channel_function_height = 80

        tk.Toplevel.__init__(self, master)
        self.title("Color Gradient Editor")
        self.minsize( gradient_preview_width+4, gradient_preview_height + 5 * \
                      channel_function_height + 50 )

        self.gradient_table = GradientTable(gradient_preview_width)
        self.vtk_color_table = vtk_table

        # create controls.
        self.gradient_control = GradientControl(self, self.gradient_table,
                                                gradient_preview_width,
                                                gradient_preview_height )
        self.gradient_control.grid(row=0,column=1,sticky="we")

        def on_gradient_table_changed( final_update ):
            # update all function controls.
            self.function_control_rgb.update()
            for control in self.function_controls_hsv:
                control.update()
            # repaint the gradient display or the external windows only
            # when the instant*** options are set or when the update was final.
            if final_update or ( 1 == self.show_instant_gradients.get() ):
                self.gradient_control.update()

            if final_update or ( 1 == self.show_instant_feedback.get() ):
                self.gradient_table.store_to_vtk_lookup_table( self.vtk_color_table )
                on_change_color_table()
        self.on_gradient_table_changed = on_gradient_table_changed

        self.function_control_rgb = FunctionControl(self, self.gradient_table,
                "rgb", channel_function_width, channel_function_height,
                on_gradient_table_changed)
        label = tk.Label( self, text = "rgb" )
        label.grid(row=1, column=0)
        self.function_control_rgb.grid(row=1,column=1,sticky="we")
        self.function_controls_hsv = []
        for it in [("hue",2), ("sat",3), ("val",4), ("alp", 5) ]:
            control = FunctionControl(self, self.gradient_table,
                it[0][0], channel_function_width, channel_function_height,
                on_gradient_table_changed )
            control.grid(row=it[1],column=1,sticky="we")
            self.function_controls_hsv.append(control)

            label = tk.Label( self, text = it[0] )
            label.grid(row=it[1], column=0)

        # buttons and the instruction label get into an own subframe for
        # easier control.
        button_frame = tk.Frame(self)
        button_frame.grid(row=6,column=0,columnspan=2)

        ok_button = tk.Button(button_frame, text="ok", command=self.ok)
        ok_button.grid(row=0,column=1)
        #CancelButton = tk.Button(ButtonFrame, text="cancel", command=self.Cancel)
        #CancelButton.grid(row=0,column=2)
        spacer = tk.Frame(button_frame, width=10 )
        spacer.grid(row=0,column=3)
        save_button = tk.Button(button_frame, text="save", command=self.save_gradient)
        save_button.grid(row=0,column=4)
        load_button = tk.Button(button_frame, text="load", command=self.load_gradient)
        load_button.grid(row=0,column=5)
        spacer = tk.Frame(button_frame, width=10 )
        spacer.grid(row=0,column=6)
        label = tk.Label(button_frame,text="instant:")
        label.grid(row=0,column=7)

        # these two buttons control whether gradient and render target
        # updates are executed during movement of control points or
        # only at the end of such changes.
        self.show_instant_gradients = tk.IntVar()
        self.show_instant_gradients.set(1) # enable instant gradients by default
        self.show_instant_feedback = tk.IntVar()
        self.show_instant_feedback.set(0) # disable instant feedback by default
        instant_gradient_button = tk.Checkbutton(button_frame, text="grad")
        instant_gradient_button.grid(row=0,column=8)
        instant_gradient_button.configure(variable=self.show_instant_gradients)
        instant_feedback_button = tk.Checkbutton(button_frame, text="feed")
        instant_feedback_button.grid(row=0,column=9)
        instant_feedback_button.configure(variable=self.show_instant_feedback)

        instruction_label = tk.Label(button_frame,
                text="left button: move point; right click: toggle point")
        instruction_label.grid(column=0,columnspan=9,row=1)

        # insert a ratio button which decides whether the controls for nonlinear
        # scaling of the gradient are shown and activated.
        self.nonlinear_scaling_enabled = tk.IntVar()
        self.nonlinear_scaling_enabled.set(0)
        nonlinear_enabled_button = tk.Checkbutton(button_frame, text="nonlin")
        nonlinear_enabled_button.grid(column=9,row=1)
        nonlinear_enabled_button.configure(variable=self.nonlinear_scaling_enabled,
            command=self.nonlinear_scaling_option_changed)

        # the controls for the nonlinear scaling also get into an own frame.
        # this one can be shown or hidden when the "nonlin"-button is pressed
        nonlin_frame = tk.Frame(self)
        self.nonlin_frame = nonlin_frame

        label = tk.Label(nonlin_frame, text="f(x) =")
        label.grid(row=0, column=0)
        self.nonlinear_function_string = tk.StringVar()
        self.nonlinear_function_string.set( "x**(4*a)" )
        function_edit = tk.Entry(nonlin_frame, width=35,
            textvariable=self.nonlinear_function_string)
        function_edit.bind("<Return>", self.nonlinear_function_string_changed )
        function_edit.grid(row=0, column=1)

        label = tk.Label(nonlin_frame, text="param a:")
        label.grid(row=1, column=0)
        self.parameter_scale = tk.Scale(nonlin_frame, from_=0.0, to=1.0,
            resolution=0.001, length=250, orient="horizontal")
        self.parameter_scale.bind("<ButtonRelease>",
            lambda event: self.nonlinear_parameter_scale_changed(final_update=True))
        self.parameter_scale.bind("<Motion>",
            lambda event:self.nonlinear_parameter_scale_changed(final_update=False))
        self.parameter_scale.set(0.5)
        self.parameter_scale.grid(row=1, column=1)
        label = tk.Label(nonlin_frame, text= \
                "f(x) should map [0..1] to [0..1]. It rescales the gradient.")
        label.grid(column=0,columnspan=2,row=2)

        # finally, write the current gradient out into main program
        on_gradient_table_changed(final_update = True)

    def nonlinear_scaling_option_changed(self):
        """called when the 'nonlin'-button is pressed to toggle if nonlinear-
        scaling is activated and the corresponding controls are shown"""
        if ( 1 == self.nonlinear_scaling_enabled.get() ):
            # activate the nonlinear scaling controls
            self.nonlin_frame.grid(row=7,column=0,columnspan=2)
            self.nonlinear_parameter_scale_changed(final_update=False)
            self.nonlinear_function_string_changed(None)
        else:
            # disable the nonlinear scaling controls (and the scaling)
            self.nonlin_frame.pack(side=tk.LEFT, anchor=tk.NW)
            self.nonlin_frame.pack_forget()
            self.gradient_table.set_scaling_function("")
            self.on_gradient_table_changed(final_update=True)

    def nonlinear_parameter_scale_changed(self,final_update):
        """Event Handler for the nonlinear-parameter scaling bar. FinalUpdate
        is true on ButtonRelease and False on Motion"""
        self.gradient_table.set_scaling_function_parameter(self.parameter_scale.get())
        self.on_gradient_table_changed(final_update = final_update)

    def nonlinear_function_string_changed(self,event):
        """Invoked when Return is pressed in the nonlinear-function edit"""
        self.gradient_table.set_scaling_function(self.nonlinear_function_string.get())
        self.on_gradient_table_changed(final_update = True)

    def ok(self):
        self.destroy()

    def save_gradient(self):
        filetypes = [("Gradient Files","*.grad"),("All Files","*")]
        file_name = tkFileDialog.asksaveasfilename(defaultextension=".grad",
                                                   filetypes=filetypes)
        if file_name:
            # there is probably a way to find out which file type the user
            # actually selected. But since I don't know it and also don't really
            # know how to find it out, i rely on this error prone method...
            if ( ".lut" == file_name[len(file_name)-4:] ):
                self.gradient_table.save(file_name)
            self.gradient_table.save(file_name)

    def load_gradient(self):
        filetypes = [("Gradient Files","*.grad"), ("All Files","*")]
        file_name = tkFileDialog.askopenfilename(defaultextension=".grad",
                                                 filetypes=filetypes)
        if file_name:
            self.gradient_table.load(file_name)
            self.on_gradient_table_changed(final_update = True)
            if self.gradient_table.scaling_function:
                self.parameter_scale.set(self.gradient_table.scaling_function_parameter)
                self.nonlinear_function_string.set(self.gradient_table.scaling_function_string)
                self.nonlinear_scaling_enabled.set(1)
                self.nonlinear_scaling_option_changed()
            else:
                self.nonlinear_scaling_enabled.set(0)
                self.nonlinear_scaling_option_changed()



if __name__ == "__main__":
    # prepare a vtk window with an actor for visible feedback. Don't be
    # be scared, the actual gradient editor code is only 3 lines long,
    # the rest is setup of the scene.
    from tvtk.api import tvtk
    import vtk
    from vtk.tk import vtkTkRenderWidget
    from math import cos
    root = tk.Tk()
    root.minsize(520,520)
    render_frame = tk.Frame(root)
    render_frame.pack()
    render_widget = vtkTkRenderWidget.vtkTkRenderWidget(render_frame,
                                                        width=512, height=512 )
    render_widget.pack(side=tk.BOTTOM,expand='true',fill='both')
    render_window = render_widget.GetRenderWindow()
    renderer = vtk.vtkRenderer()
    renderer.SetBackground(0.2,0.2,0.4)
    render_window.AddRenderer(renderer)

    image_data = vtk.vtkImageData()
    N = 72
    image_data.SetDimensions(N,N,1)
    try:
        method = image_data.SetScalarComponentFromFloat
    except AttributeError:
        method = image_data.SetScalarComponentFromDouble
    for i in range(N):
        for j in range(N):
            a = float(i)/N
            b = float(j)/N
            v = 0.5 + 0.5*cos(13*a)*cos(8*b+3*a*a)
            v = v**2
            method(i,j,0,0,v)
    geometry_filter = vtk.vtkImageDataGeometryFilter()
    geometry_filter.SetInput(image_data)
    warp = vtk.vtkWarpScalar()
    warp.SetInput(geometry_filter.GetOutput())
    warp.SetScaleFactor(8.1)
    normal_filter = vtk.vtkPolyDataNormals()
    normal_filter.SetInput(warp.GetOutput())
    data_mapper = vtk.vtkDataSetMapper()
    data_mapper.SetInput(normal_filter.GetOutput())
    data_actor = vtk.vtkActor()
    data_actor.SetMapper(data_mapper)
    renderer.AddActor(data_actor)

    table = vtk.vtkLookupTable()
    data_mapper.SetLookupTable(table)

    # the actual gradient editor code.
    def on_color_table_changed():
        render_window.Render()

    # Gradient editor only works with tvtk objects, so convert the lut
    # to a tvtk version.
    tvtk_table = tvtk.to_tvtk(table)
    editor = GradientEditor(root, tvtk_table, on_color_table_changed)

    root.mainloop()

########NEW FILE########
__FILENAME__ = traitsui_gradient_editor
""" Abstracts the Gradient editors provided for Qt and wxPython so these
can be used from TraitsUI.


Author: Prabhu Ramachandran
Copyright (c) 2012-2013  Enthought Inc., Mumbai, India.
"""

from traits.etsconfig.api import ETSConfig
from traitsui.api import CustomEditor
from tvtk.api import tvtk

##########################################################################
# Traits UI factory functions.
##########################################################################
def gradient_editor_factory(parent, trait_editor):
    """This is a factory function for `traitsui.CustomEditor` and allows us to
    use the `wxGradientEditorWidget` or `QGradientEditorWidget` as a traits 
    UI editor.
    """
    tvtk_obj = getattr(trait_editor.object, trait_editor.name)
    if ETSConfig.toolkit == 'wx':
        from wx_gradient_editor import wxGradientEditorWidget
        widget = wxGradientEditorWidget(parent, tvtk_obj)
    elif ETSConfig.toolkit == 'qt4':
        from qt_gradient_editor import QGradientEditorWidget
        widget = QGradientEditorWidget(None, tvtk_obj)
    else:
        msg = 'Toolkit %s does not implement gradient_editors.'%ETSConfig.toolkit
        raise NotImplementedError(msg)
    return widget


##########################################################################
# Editor for VolumeProperty
##########################################################################
VolumePropertyEditor = CustomEditor(gradient_editor_factory)

##########################################################################
# Test case related code.
##########################################################################
def make_test_table(lut=False):
    from ctf import ColorTransferFunction, PiecewiseFunction
    if lut:
        table = tvtk.LookupTable()
        table.table_range = (255, 355)
        return table, None, None
    else:
        table = tvtk.VolumeProperty()
        ctf = ColorTransferFunction()
        mins, maxs = 255, 355
        ds = (maxs-mins)/4.0
        try:
            ctf.range = (mins, maxs)
        except Exception:
            # VTK versions < 5.2 don't seem to need this.
            pass
        ctf.add_rgb_point(mins,      0.00, 0.0, 1.00)
        ctf.add_rgb_point(mins+ds,   0.25, 0.5, 0.75)
        ctf.add_rgb_point(mins+2*ds, 0.50, 1.0, 0.50)
        ctf.add_rgb_point(mins+3*ds, 0.75, 0.5, 0.25)
        ctf.add_rgb_point(maxs,      1.00, 0.0, 0.00)
        otf = PiecewiseFunction()
        otf.add_point(255, 0.0)
        otf.add_point(355, 0.2)
        table.set_color(ctf)
        table.set_scalar_opacity(otf)
        return table, ctf, otf

def test_trait_ui():
    from traits.api import HasTraits, Instance, Button
    from traitsui.api import View, Item, Group

    class Test(HasTraits):
        p = Instance(tvtk.VolumeProperty, ())
        b = Button('Click me')

        view = View(Group(
                        Item(name='p', style='custom',
                            resizable=True,
                            editor=VolumePropertyEditor),
                        Item('b'),
                        show_labels=False),
                    resizable=True
                    )

    table, otf, ctf = make_test_table(False)
    t = Test(p=table)
    # We need to hang on to these so these don't go out of scope.
    t.otf = otf
    t.ctf = ctf
    return t


if __name__ == '__main__':
    t = test_trait_ui()
    t.configure_traits()
    
########NEW FILE########
__FILENAME__ = wx_gradient_editor
""" A wxPython based color gradient editor for vtkLookupTables and
color transfer functions.

This code is distributed under the conditions of the BSD license.

Based on a Tk version of this widget by Gerald Knizia <cgk.d@gmx.net>
Ported to wxPython by Pete Schmitt <schmitt@colorado.edu>
Cleaned up and enhanced for use with MayaVi2 by Prabhu Ramachandran

Copyright (c) 2005-2013, Gerald Knizia, Pete Schmitt and Prabhu Ramachandran
"""


# Third-party imports
import wx

# Local imports
from gradient_editor import (ColorControlPoint, ChannelBase, FunctionControl, 
    GradientEditorWidget)

##########################################################################
# `wxGradientControl` class.
##########################################################################
class wxGradientControl(wx.Panel):
    """Widget which displays the gradient represented by an GradientTable
    object (and does nothing beyond that)"""
    def __init__(self, masterPanel, gradient_table, width, height ):
        """master: panel in which to place the control. GradientTable is the
        Table to which to attach."""
        wx.Panel.__init__(self, masterPanel, size=wx.Size(width, height),
                          style=wx.RAISED_BORDER,
                          name="Colormap Panel")

        self.SetBackgroundColour(wx.Colour(255,255,255))
        self.width = width
        self.height = height
        self.gradient_table = gradient_table
        assert( gradient_table.size == width )
        # ^- currently only able to use gradient tables in the same size as the canvas width

        # bind paint event to redraw  when resizing/creating window...
        wx.EVT_PAINT(self, self.OnPaint)

    def OnPaint(self, event):
        """ Paint event handler for when the window is resized and
        whatnot."""
        dc = wx.PaintDC(self)
        self.update()

    def update(self):
        """Repaint the control."""
        #self.canvas.delete(tk.ALL) # clears all lines contained.
        dc = wx.ClientDC(self)
        dc.SetBackground(wx.Brush(wx.Colour(0,0,0), wx.SOLID))
        dc.Clear()

        width, height = self.GetSize()

        # From the old tk GradientEditor:
        #     a look around the web (http://wiki.tcl.tk/11868) told me that
        #     using the PhotoImage tk-control would not be a good idea and
        #     that line objects work faster. While I doubt this is an optimal
        #     solution it currently works fast enought.
        # So... let's do the same thing for the new and improved (?) wxPython GradientEditor.

        xform = self.gradient_table.scaling_function
        start_y = 0
        end_y = height
        if xform:
            # if a scaling transformation is provided, paint the original
            # gradient under the scaled gradient.
            start_y = height/2

        # paint the original gradient as it stands in the table.
        dc.BeginDrawing()
        for x in range(width):
            (r,g,b,a) = self.gradient_table.get_pos_rgba_color_lerped(float(x)/(width-1))
            dc.SetPen(wx.Pen(wx.Colour(int(255*r),int(255*g),int(255*b))))
            dc.SetBrush(wx.Brush((int(255*r),int(255*g),int(255*b)), wx.SOLID))
            dc.DrawLine(x, start_y, x, end_y)
        if xform:
            # paint the scaled gradient below
            end_y = start_y
            start_y = 0
            for x in range(width):
                f = float(x)/(width-1)
                (r,g,b,a) = self.gradient_table.get_pos_rgba_color_lerped(xform(f))
                dc.SetBrush(wx.Brush((int(255*r),int(255*g),int(255*b)), wx.SOLID))
                dc.DrawLine(x, start_y, x, end_y)
        dc.EndDrawing()


##########################################################################
# `Channel` class.
##########################################################################
class Channel(ChannelBase):
    def paint(self, deviceContext):
        """Paint current channel into Canvas (a canvas of a function control
        object).

        Contents of the canvas are not deleted prior to painting,
        so more than one channel can be painted into the same canvas."""
        dc = deviceContext

        table = self.control.table
        # only control points which are active for the current channel
        # are to be painted. filter them out.
        relevant_control_points = filter( \
            lambda x: self.name in x.active_channels,
            table.control_points )
        dc.BeginDrawing()
        # lines between control points
        dc.SetPen(wx.Pen(self.rgb_color,1))
        #dc.SetBrush(wx.Brush((255,255,255), wx.SOLID))
        dc.SetBrush(wx.Brush((255,255,255), wx.SOLID))
        for k in range( len(relevant_control_points) - 1 ):
            cur_point = relevant_control_points[k]
            next_point = relevant_control_points[1+k]

            dc.DrawLine( self.get_pos_index(cur_point.pos),
                    self.get_value_index(cur_point.color),
                    self.get_pos_index(next_point.pos),
                    self.get_value_index(next_point.color))

        # control points themself.
        dc.SetPen(wx.Pen("BLACK",1))
        dc.SetBrush(wx.Brush((255,255,255), wx.SOLID))
        for control_point in relevant_control_points:
            x = self.get_pos_index( control_point.pos )
            y = self.get_value_index( control_point.color )
            radius=6
            #print(x,y)
            dc.DrawRectangle(x-(radius/2.0), y-(radius/2.0),radius,radius)
            dc.DrawRectangle(100,80,6,6)
        dc.EndDrawing()


##########################################################################
# `wxFunctionControl` class.
##########################################################################
class wxFunctionControl(wx.Panel, FunctionControl):
    """Widget which displays a rectangular regions on which hue, sat, val
    or rgb values can be modified. An function control can have one or more
    attached color channels."""

    # Radius around a control point center in which we'd still count a
    # click as "clicked the control point"
    control_pt_click_tolerance = 4
    
    ChannelFactory = Channel

    def __init__(self, master, gradient_table, color_space, width, height):
        """Initialize a function control widget on tkframe master.

        Parameters:
        -----------

        master: The master widget.  Note that this widget *must* have
             the methods specified in the `AbstractGradientEditorWidget`
             interface.

        on_table_changed: Callback function taking a bool argument of meaning
            'FinalUpdate'. FinalUpdate is true if a control point is dropped,
            created or removed and false if the update is due to a control point
            currently beeing dragged (but not yet dropped)

        color_space: String which specifies the channels painted on this control.
             May be any combination of h,s,v,r,g,b,a in which each channel
             occurs only once.

        set_status_text: a callback used to set the status text
             when using the editor.
        """
        FunctionControl.__init__(self, master, gradient_table, color_space, 
                                 width, height)
                                 
        wx.Panel.__init__(self, master, size=wx.Size(width, height),
                          name="RGBHSVA Editor")

        self.update()

        wx.EVT_LEFT_DOWN(self, self.on_left_button_down)
        wx.EVT_LEFT_UP(self, self.on_left_button_up)
        wx.EVT_RIGHT_DOWN(self, self.on_right_button_down)
        wx.EVT_RIGHT_UP(self, self.on_right_button_up)
        wx.EVT_MOTION(self, self.on_mouse_move)
        wx.EVT_PAINT(self, self.on_paint)
        wx.EVT_LEAVE_WINDOW(self, self.on_leave_window)

    ######################################################################
    # wxPython event methods.
    ######################################################################
    def update(self, event = None):
        """Repaint the control."""
        dc = wx.ClientDC(self)
        #if we have a custom background, we *must* set the background brush *BEFORE* clearing...
        dc.SetBackground(wx.Brush(wx.Colour(255,255,255), wx.SOLID))
        dc.Clear()

        for channel in self.channels:
            channel.paint(dc)

    def on_paint(self, event=None):
        dc = wx.PaintDC(self)
        self.update()

    def on_left_button_down(self, event):
        self.cur_drag = self.find_control_point( event.GetX(), event.GetY() )

    def on_left_button_up(self, event):
        if self.cur_drag:
            self.table_config_changed( final_update = True )
            self.cur_drag = None

    def on_leave_window(self, event):
        self.on_left_button_up(event)

    def on_right_button_down(self, event):
        pass

    def on_right_button_up(self, event):
        # toggle control point. check if there is a control point
        # under the mouse. If yes, delete it, if not, create one
        # at that point.
        cur_control_point = self.find_control_point(event.GetX(), None)
        if cur_control_point:
            # found a marker at the click position. delete it and return,
            # unless it is a fixed marker (at pos 0 or 1)..
            if ( cur_control_point[1].fixed ):
                # in this case do nothing. Fixed markers cannot be deleted.
                return
            self.table.control_points.remove(cur_control_point[1])
            self.table_config_changed(final_update=True)
        else:
            # since there was no marker to remove at the point, we assume
            # that we should place one there
            new_control_point = ColorControlPoint(active_channels = self.active_channels_string)
            new_control_point.set_pos(self.channels[0].get_index_pos(event.GetX()))

            # set new control point color to the color currently present
            # at its designated position
            new_control_point.color = self.table.get_pos_color(new_control_point.pos)

            self.table.insert_control_point( new_control_point )
            self.table_config_changed( final_update = True )

    def on_mouse_move(self, event):
        # currently dragging a control point?
        channel = None
        point = None
        if self.cur_drag:
            channel = self.cur_drag[0]
            point = self.cur_drag[1]
            if ( not point.fixed ):
                point.set_pos( channel.get_index_pos(event.GetX()) )
                point.activate_channels( self.active_channels_string )
                self.table.sort_control_points()
            channel.set_value_index( point.color, event.GetY() )
            self.table_config_changed( final_update = False )

        screenX = event.GetX()
        screenY = event.GetY()
        width, height = self.GetSize()
        master = self.master
        s1, s2 = master.get_table_range()
        if channel is not None:
            name = self.text_map[channel.name]
            pos = s1 + (s2 - s1)*point.pos
            val = channel.get_value(point.color)
            txt = '%s: (%.3f, %.3f)'%(name, pos, val)
        else:
            x = s1 + (s2 - s1)*float(screenX)/(width-1)
            y = 1.0 - float(screenY)/(height-1)
            txt = "position: (%.3f, %.3f)"%(x, y)

        self.master.set_status_text(txt)


##########################################################################
# `wxGradientEditorWidget` class.
##########################################################################
class wxGradientEditorWidget(wx.Panel, GradientEditorWidget):
    """A Gradient Editor widget that can be used anywhere.
    """
    def __init__(self, master, vtk_table, on_change_color_table=None,
                 colors=None):
        """

        Parameters:
        -----------

        vtk_table : the `tvtk.LookupTable` or `tvtk.VolumeProperty` object
                    to set.

        on_change_color_table : A callback called when the color table
                                changes.

        colors : list of 'rgb', 'hsv', 'h', 's', 'v', 'a'
                 (Default : ['rgb', 'hsv', 'a'])

                 'rgb' creates one panel to edit Red, Green and Blue
                 colors.

                 'hsv' creates one panel to edit Hue, Saturation and
                 Value.

                 'h', 's', 'v', 'r', 'g', 'b', 'a' separately
                 specified creates different panels for each.
        """
        GradientEditorWidget.__init__(self, master, vtk_table, 
                                      on_change_color_table, colors)
        wx.Panel.__init__(self, master)

        gradient_preview_width = self.gradient_preview_width
        gradient_preview_height = self.gradient_preview_height
        channel_function_width = self.channel_function_width
        channel_function_height = self.channel_function_height

        # set up all the panels in a gridbagsizer (i.e. a big grid)
        # 6x2 size:  6 rows, 2 columns...
        sizer = wx.GridBagSizer(2, 2)

        # "Gradient Viewer" panel, in position (0,1) for sizer
        self.gradient_control = wxGradientControl(self,
                                                  self.gradient_table,
                                                  gradient_preview_width,
                                                  gradient_preview_height)
        tt = wx.ToolTip('Right click for menu')
        self.gradient_control.Bind(wx.EVT_CONTEXT_MENU, self.on_gradient_menu)
        self.gradient_control.SetToolTip(tt)
        sizer.Add(self.gradient_control, pos=(0,1))

        # Add the function controls:
        function_controls = self.function_controls

        
        editor_data = self.editor_data
        row = 1
        for color in self.colors:
            data = editor_data[color]
            control = wxFunctionControl(self, self.gradient_table, color,
                                        channel_function_width,
                                        channel_function_height)
            txt = data[0] + self.tooltip_text
            control.SetToolTip(wx.ToolTip(txt))
            # Add name of editor (to left side of editor)
            sizer.Add(wx.StaticText(self, -1, data[1]), pos=(row, 0),
                      flag=wx.ALIGN_CENTER|wx.ALL)
            # Add the "RGB" control point editor
            sizer.Add(control, pos=(row, 1))
            function_controls.append(control)
            row += 1

        # The status text.
        self.text = wx.StaticText(self, -1, 'status')
        sizer.Add(self.text, (row,0), (row,2))
        row += 1

        # set the appropriate sizer.
        sizer.SetSizeHints(self)
        self.SetSizerAndFit(sizer)

    ######################################################################
    # `wxGradientEditorWidget` interface.
    ######################################################################
    def set_status_text(self, msg):
        t = self.text
        t.SetLabel(msg)
        t.Refresh()
        t.Update()

    ######################################################################
    # wxPython event methods.
    ######################################################################
    def on_gradient_menu(self, event):
        if not hasattr(self, 'save_menuid'):
            # Do this only the first time.
            self.save_menuid = wx.NewId()
            self.load_menuid = wx.NewId()
            self.Bind(wx.EVT_MENU, self.on_save, id=self.save_menuid)
            self.Bind(wx.EVT_MENU, self.on_load, id=self.load_menuid)

        menu = wx.Menu()
        menu.Append(self.save_menuid, "Save as")
        menu.Append(self.load_menuid, "Load")
        self.PopupMenu(menu)
        menu.Destroy()

    def on_save(self, event):
        """
        Open "Save" dialog, write lookuptable to 3 files: ``*.lut`` 
        (lookuptable) ``*.grad`` (gradient table for use with this program), 
        and ``*.jpg`` (image of the gradient)
        """
        dlg = wx.FileDialog(self, "Save LUT to...", style=wx.SAVE)
        wildcard = "Gradient Files (.grad)|*.grad|"   \
                   "All files (*.*)|*.*"
        dlg.SetWildcard(wildcard)
        if (dlg.ShowModal() == wx.ID_OK):
            file_name = dlg.GetPath()
            if file_name:
                self.save(file_name)

    def on_load(self, event):
        """
        Load a ``*.grad`` lookuptable file using wxpython dialog
        """
        style = wx.OPEN | wx.HIDE_READONLY
        dlg = wx.FileDialog(self, "Open a file", style=style)
        wildcard = "Gradient Files (.grad)|*.grad|"   \
                   "All files (*.*)|*.*"
        dlg.SetWildcard(wildcard)
        if (dlg.ShowModal() == wx.ID_OK):
            file_name = dlg.GetPath()
            if file_name:
                self.load(file_name)


##########################################################################
# `wxGradientEditor` class.
##########################################################################
class wxGradientEditor(wx.Frame):
    """ wxPython frame that displays the gradient editor window,
    i.e. the thing that contains the gradient display, the function
    controls and the buttons.
    """
    def __init__(self, vtk_table, on_change_color_table = None, colors=None):
        """Initialize the gradient editor window.

        Parameters
        ----------
        vtk_table: Instance of vtkLookupTable, designating the table which is
            to be edited.
        on_change_color_table: Callback function taking no arguments. Called
            when the color table was changed and rendering is
            requested.
        """

        wx.Frame.__init__(self, None, -1, "Color Gradient Editor",
                          wx.DefaultPosition, [350, 400])

        self.widget = wxGradientEditorWidget(self, vtk_table,
                                             on_change_color_table,
                                             colors)

        # draw the rest of the GUI (i.e. statusbar, menubar, etc.
        self.SetupMenuBar()
        self.CreateStatusBar()

    def SetupMenuBar(self):
        """
        Create menus (i.e. Create Filemenu and submenus, help menu, ...)
        """
        ## Set up the MenuBar
        MenuBar = wx.MenuBar()

        #FILE Menu....
        file_menu = wx.Menu()
        item = file_menu.Append(-1, "&Save","Save CTF")
        self.Bind(wx.EVT_MENU, self.widget.on_save, item)
        item = file_menu.Append(-1, "&Load","Load CTF")
        self.Bind(wx.EVT_MENU, self.widget.on_load, item)
        item = file_menu.Append(-1, "&Close","Close this frame")
        self.Bind(wx.EVT_MENU, self.OnQuit, item)
        MenuBar.Append(file_menu, "&File")

        help_menu = wx.Menu()
        item = help_menu.Append(-1, "&Help", "Help")
        self.Bind(wx.EVT_MENU, self.OnHelp, item)
        item = help_menu.Append(-1, "&About", "About")
        self.Bind(wx.EVT_MENU, self.OnAbout, item)
        MenuBar.Append(help_menu, "&Help")

        self.SetMenuBar(MenuBar)

    def OnQuit(self, event):
        self.Close()

    def OnHelp(self, event):
        """ Help defining the mouse interactions """
        message = "Right click to add control points.  Left click to move control points"
        dlg = wx.MessageDialog(self, message,
                               'About wxGradientEditor',
                               wx.OK | wx.ICON_INFORMATION
                               )
        dlg.ShowModal()
        dlg.Destroy()

    def OnAbout(self, event):
        """ Who wrote the program?"""
        message = 'tk Gradient Editor for MayaVi1: Gerald Knizia (cgk.d@gmx.net)\n'\
                  'wxPython port: Pete Schmitt (schmitt@colorado.edu)\n'\
                  'Enhanced for MayaVi2: Prabhu Ramachandran'
        dlg = wx.MessageDialog(self, message,
                               'About wxGradientEditor',
                               wx.OK | wx.ICON_INFORMATION
                               )
        dlg.ShowModal()
        dlg.Destroy()


##########################################################################
# Test application.
##########################################################################
def main():
    from traitsui_gradient_editor import make_test_table
    table, ctf, otf = make_test_table(lut=False)
    # the actual gradient editor code.
    def on_color_table_changed():
        """If we had a vtk window running, update it here"""
        print("Update Render Window")

    app = wx.PySimpleApp()
    editor = wxGradientEditor(table,
                              on_color_table_changed,
                              colors=['rgb', 'a', 'h', 's', 'v'],
                              )
    editor.Show()
    app.MainLoop()


if __name__ == "__main__":
    main()

########NEW FILE########
__FILENAME__ = version
# Wrapped in a try/except in those situations where someone hasn't installed
# as an egg.  What do we do then?  For now, we just punt since we don't want
# to define the version number in two places.
try:
    import pkg_resources
    version = pkg_resources.require('Mayavi')[0].version
except:
    version = ''



########NEW FILE########
__FILENAME__ = parametric_function_source_view
from traitsui.api import View, HGroup, Item
from tvtk.tvtk_base import TVTKBaseHandler

view = View((['generate_texture_coordinates'], ['scalar_mode'],
    HGroup(Item('u_resolution', label = 'u'),
          Item('v_resolution', label = 'v'),
          Item('w_resolution', label = 'w'),
          label = 'Resolution', show_border = True)),
    handler = TVTKBaseHandler,
    title='Edit ParametricFunctionSource properties', scrollable=True,
    buttons=['OK', 'Cancel'])



########NEW FILE########
__FILENAME__ = vtk_module
"""Abstracts all VTK related modules into one module.  This makes it trivial to
support local VTK classes that a user may have built.

By default it imports all of VTK and then looks for a tvtk_local module and
imports everything from that.  In order to add local classes to the TVTK build
one may simply provide a tvtk_local.py module somewhere with any classes that
need to be wrapped.

"""

# Author: Prabhu Ramachandran <prabhu [at] aero.iitb.ac.in>
# Copyright (c) 2007,  Enthought, Inc.
# License: BSD Style.

from vtk import *

try:
    from tvtk_local import *
except ImportError:
    pass

########NEW FILE########
__FILENAME__ = vtk_parser
"""This module parses the VTK methods, obtains the argument and return
type information, and organizes them.

"""
# Author: Prabhu Ramachandran
# Copyright (c) 2004-2007, Enthought, Inc.
# License: BSD Style.

import re

# Local imports (these are relative imports for a good reason).
import class_tree
import vtk_module as vtk


class VTKMethodParser:
    """This class provides useful methods for parsing methods of a VTK
    class or instance.

    The class allows one to categorize the methods of the VTK class
    and also obtain the method signatures in a form that is easy to
    use.  When the `parse` method is called, it in turn calls the
    `_organize_methods` method.  This method organizes the VTK methods
    into different instance variables described in the following.
    `self.toggle_meths` contains a dictionary of all the boolean
    methods of the form <Value>On/Off.  The dictionary keys are
    strings with the <Value>'s and the value of each item is the
    default value (0/1) of the item (the example below will clarify
    this).  `self.state_meths` contains a dictionary which collects
    the Set<Prop>To<Value> type of methods.  The key is the <Prop> and
    the value is a list containing the different string <Value>'s and
    their corresponding mapped value.  The first value in these is the
    default value of the <Prop>.  `self.get_set_meths` will contain a
    dictionary which collects all the methods of the form
    Set/Get<Prop> that are not already specified in
    `self.toggle_meths` or `self.state_meths`.  The default value of
    the Get<Prop> is stored.  If the value accepted by the method has
    a range (via the methods `Get<Prop>MinValue` and
    `Get<Prop>MaxValue`), then that range is computed and stored.
    `self.get_meths` stores the methods that are of the form
    `Get<Prop>`.  `self.other_meths` stores the remaining methods.
    The parsing is quite fast.  Parsing every class in the VTK API
    takes a couple of seconds (on a Pentium III @ 450Mhz).

    Here is an example::

       >>> import vtk
       >>> p = VTKMethodParser()
       >>> p.parse(vtk.vtkProperty)
       >>> print p.get_toggle_methods()
       {'EdgeVisibility': 0, 'BackfaceCulling': 0, 'FrontfaceCulling': 0}
       >>> print p.get_state_methods()['Representation']
       [['Surface', 2], ['Points', 0], ['Surface', 2], ['Wireframe', 1]]
       >>> print p.get_get_set_methods()['Opacity']
       (1.0, (0.0, 1.0))
       >>> print p.get_get_methods()
       ['GetClassName']
       >>> print p.get_other_methods()[:3]
       ['BackfaceRender', 'DeepCopy', 'IsA']


    The class also provides a method called `get_method_signature`
    that obtains the Python method signature given the VTK method
    object.  Here is an example::

       >>> import vtk
       >>> p = VTKMethodParser()
       >>> o = vtk.vtkProperty
       >>> print p.get_method_signature(o.GetClassName)
       [(['string'], None)]
       >>> print p.get_method_signature(o.GetColor)[0]
       ([('float', 'float', 'float')], None)
       >>> print p.get_method_signature(o.GetColor)[1]
       ([None], (('float', 'float', 'float'),))

    The `get_method_signature` is fairly efficient and obtaining the
    signature for every method in every class in the VTK API takes
    around 6 seconds (on a Pentium III @ 450Mhz).

    """

    def __init__(self, use_tree=True):
        """Initializes the object.

        Parameters
        ----------

        - use_tree : `bool`

          If True (default), use a ClassTree instance to obtain a
          concrete subclass for an abstract base class.  This is used
          only to find the range and default values for some of the
          methods.  If False, no ClassTree instance is created.

          This is optional because, creating a ClassTree is expensive.
          The parser functionality can be very useful even without the
          use of a ClassTree.  For example, if one wants to save the
          state of a VTK object one only needs to know the names of
          the methods and not their default values, ranges etc.  In
          that case using a parser should be cheap.

        """
        # The ClassTree is needed to find an instantiable child class
        # for an abstract VTK parent class.  This instance is used to
        # obtain the state values and the ranges of the arguments
        # accepted by the Get/Set methods that have a
        # Get<Prop>{MaxValue,MinValue} method.
        if use_tree:
            self._tree = class_tree.ClassTree(vtk)
            self._tree.create()
        else:
            self._tree = None
        self._state_patn = re.compile('To[A-Z0-9]')
        self._initialize()

    #################################################################
    # 'VTKMethodParser' interface.
    #################################################################

    def parse(self, obj, no_warn=True):
        """Parse the methods for a given VTK object/class.

        Given a VTK class or object, this method parses the methods
        and orgaizes them into useful categories.  The categories and
        their usage is documented in the documentation for the class.

        Parameters
        ----------

        - obj : VTK class or instance

        - no_warn : `bool` (default: True)

          If True (default), it suppresses any warnings generated by
          the VTK object when parsing the methods.  This is safe to
          use.

        """
        if not hasattr(obj, '__bases__'):
            klass = obj.__class__
        else:
            klass = obj

        methods = self.get_methods(klass)

        if no_warn:
            # Save warning setting and shut it off before parsing.
            warn = vtk.vtkObject.GetGlobalWarningDisplay()
            if klass.__name__ <> 'vtkObject':
                vtk.vtkObject.GlobalWarningDisplayOff()

        self._organize_methods(klass, methods)

        if no_warn:
            # Reset warning status.
            vtk.vtkObject.SetGlobalWarningDisplay(warn)

    def _get_parent_methods(self, klass):
        """Returns all the methods of the classes parents."""
        methods = {}
        while len(klass.__bases__) > 0:
            klass = klass.__bases__[0]
            meths = dir(klass)
            d = methods.fromkeys(meths)
            methods.update(d)
        return methods.keys()

    def get_methods(self, klass):
        """Returns all the relevant methods of the given VTK class."""
        methods = dir(klass)[:]
        if hasattr(klass, '__members__'):
            # Only VTK versions < 4.5 have these.
            for m in klass.__members__:
                methods.remove(m)
        # Ignore the parent methods.
        ignore = self._get_parent_methods(klass)

        # Skip some of the ignores.
        skip = ['GetInput', 'SetInput']
        # Sometimes the child has only GetInput while the parent has
        # SetInput.
        if hasattr(klass, 'SetInput') and \
            'SetInput' not in methods and \
            'GetInput' in methods:
            methods.append('SetInput')

        # Get/set pairs that are overridden.  Basically, if a parent
        # class has a 'GetThing' and the child overrides/has a
        # 'SetThing' (or vice-versa), then the removal of the parent
        # methods is wrong since the child changes the trait definition
        # which breaks things.  We therefore do not remove any of the
        # Get/SetThings that are ignored due to them being in the
        # parent.  However one has to be careful about cases where these are
        # really Toggle (ThingOn) or State (SetThingToThong) etc. methods and
        # in those cases we really should ignore the method.  So in essence,
        # any Get/Set pair that is not a State or Toggle should be redefined.
        overrides = []
        for m in methods:
            check = False
            if m.startswith('Get'):
                m1 = 'Set' + m[3:]
                check = True
            elif m.startswith('Set'):
                m1 = 'Get' + m[3:]
                check = True
            if check:
                if m1 in methods and (m1 in ignore or m in ignore):
                    # Skips are stored as Set followed by Get.
                    skip.extend(['Set' +m[3:], 'Get'+m[3:]])

        for m in skip[:]:
            if m.startswith('Set'):
                base = m[3:]
                mg, ms = 'Get' + base, 'Set' + base
                m_st = 'Set' + base + 'To'
                m_t = base + 'Off'
                for method in methods:
                    if m_st in method or m_t == method:
                        skip.remove(ms)
                        skip.remove(mg)
                        break

        if 'GetViewProp' in methods and 'GetProp' in methods:
            ignore.extend(['GetProp', 'SetProp'])
        if 'GetViewProps' in methods and 'GetProps' in methods:
            ignore.extend(['GetProps', 'SetProps'])
        # Remove any deprecated traits.
        if 'GetScaledText' in methods and 'GetTextScaleMode' in methods:
            ignore.extend(['GetScaledText', 'SetScaledText',
                           'ScaledTextOn', 'ScaledTextOff'])

        # Now we can safely remove the methods.
        for m in methods[:]:
            if m in ignore and m not in skip:
                methods.remove(m)

        return methods

    def get_toggle_methods(self):
        """Returns a dictionary of the parsed <Value>On/Off methods
        along with the default value.

        """
        return self.toggle_meths

    def get_state_methods(self):
        """Returns a dict of the parsed Set<Prop>To<Value>.

        The keys are the <Prop> string with a list of the different
        <Value> strings along with their corresponding value (if
        obtainable).  The first value is the default value of the
        state.

        """
        return self.state_meths

    def get_get_set_methods(self):
        """Returns a dict of the parsed Get/Set<Value> methods.

        The keys of the dict are the <Value> strings and contain a
        two-tuple containing the default value (or None if it is not
        obtainable for some reason) and a pair of numbers specifying
        an acceptable range of values (or None if not obtainable).

        """
        return self.get_set_meths

    def get_get_methods(self):
        """Return a list of parsed Get<Value> methods.

        All of these methods do NOT have a corresponding Set<Value>.

        """
        return self.get_meths

    def get_other_methods(self):
        """Return list of all other methods, that are not
        categorizable.

        """
        return self.other_meths

    def get_method_signature(self, method):
        """Returns information on the Python method signature given
        the VTK method.

        The doc string of the given method object to get the method
        signature.  The method returns a list of tuples, each of which
        contains 2 items, the first is a list representing the return
        value the second represents the arguments to be passed to the
        function.  If the method supports different return values and
        arguments, this function returns all of their signatures.

        Parameters
        ----------

        - method : `method`

          A VTK method object.

        """
        # Remove all the C++ function signatures.
        doc = method.__doc__
        doc = doc[:doc.find('\n\n')]
        sig = []
        c_sig = [] # The C++ signature
        in_sig = False
        in_c_sig = False
        counter = 0
        for line in doc.split('\n'):
            if line.startswith('V.'):
                in_sig = True
                in_c_sig = False
                sig.append(line.strip())
            elif line.startswith('C++:'):
                in_sig = False
                in_c_sig = True
                c_sig.append(line.strip())
                counter += 1
            elif in_sig:
                sig[counter] = sig[counter] + line.strip()
            elif in_c_sig:
                c_sig[counter-1] = c_sig[counter-1] + line.strip()


        # Remove the V.<method_name>
        sig = [x.replace('V.' + method.__name__, '') for x in sig]
        c_sig = [x[x.find('('):] for x in c_sig]

        pat = re.compile(r'\b')

        # Split into [return_value, arguments] after processing them.
        tmp = list(sig)
        sig = []
        for sig_idx, i in enumerate(tmp):
            # Split to get return values.
            x = i.split('->')
            # Strip each part.
            x = [y.strip() for y in x]

            if len(x) == 1: # No return value
                x = [None, x[0]]
            else:
                x.reverse()

            ret, arg = x

            # Remove leading and trailing parens for arguments.
            arg = arg[1:-1]
            if not arg:
                arg = None
            if arg and arg[-1] in [')', ']']:
                arg = arg + ','

            # Check if we are able to parse all the arguments -- some
            # unstable versions of VTK have problems generating the
            # docstring and in this case we will try to use the C++
            # docstring signature.

            n_arg = 0
            arg_map = {'unsigned int': 'int', 'unsigned char': 'int',
                    'unsigned long': 'long', 'unsigned short': 'int'}
            if arg is not None and c_sig:
                n_arg = arg.count(',') + 1
                # The carguments have parenthesis like: (int, int)
                carg = c_sig[sig_idx][1:-1].split(',')
                if n_arg > 0:
                    args = []
                    if len(carg) == n_arg:
                        for idx, x in enumerate(arg.split(',')):
                            if len(x.strip()) == 0:
                                carg_val = carg[idx].strip()
                                if 'unsigned' in carg_val and \
                                    carg_val in arg_map:
                                    args.append(arg_map[carg_val])
                                elif 'void' in carg_val:
                                    args.append("string")
                                else:
                                    args.append(x)
                            else:
                                args.append(x)
                        arg = ', '.join(args)

            if ret is not None and ret.startswith('(') and '...' in ret:
                # A tuple (new in VTK-5.7)
                ret = "tuple"

            if arg is not None:
                if '[float, ...]' in arg:
                    arg = arg.replace('[float, ...]', 'tuple')
                elif '(float, ...)' in arg:
                    arg = arg.replace('(float, ...)', 'tuple')

            if ret == '(, )':
                ret = None

            # Now quote the args and eval them.  Easy!
            try:
                if ret:
                    ret = eval(pat.sub('\"', ret))
                if arg:
                    arg = eval(pat.sub('\"', arg))
                    if type(arg) == type('str'):
                        arg = [arg]
            except SyntaxError:
                pass
            else:
                sig.append(([ret], arg))

        return sig

    def get_tree(self):
        """Return the ClassTree instance used by this class."""
        return self._tree

    #################################################################
    # Non-public interface.
    #################################################################

    def _initialize(self):
        """Initializes the method categories."""
        # Collects the <Value>On/Off methods.
        self.toggle_meths = {}
        # Collects the Set<Prop>To<Value> methods.
        self.state_meths = {}
        # Collects the Set/Get<Value> pairs.
        self.get_set_meths = {}
        # Collects the Get<Value> methods.
        self.get_meths = []
        # Collects all the remaining methods.
        self.other_meths = []

    def _organize_methods(self, klass, methods):
        """Organizes the given methods of a VTK class into different
        categories.

        Parameters
        ----------

        - klass : A VTK class

        - methods : `list` of `str`

          A list of the methods to be categorized.

        """
        self._initialize()
        meths = methods[:]
        meths = self._find_toggle_methods(klass, meths)
        meths = self._find_state_methods(klass, meths)
        meths = self._find_get_set_methods(klass, meths)
        meths = self._find_get_methods(klass, meths)
        self.other_meths = [x for x in meths \
                            if callable(getattr(klass, x))]

    def _remove_method(self, meths, method):
        try:
            meths.remove(method)
        except ValueError:
            pass

    def _find_toggle_methods(self, klass, methods):
        """Find/store methods of the form <Value>{On,Off} in the given
        `methods`.  Returns the remaining list of methods.

        """
        meths = methods[:]
        tm = self.toggle_meths
        klass_name = klass.__name__
        problem_methods = ['CopyVectors', 'CopyTensors',
                           'CopyTCoords', 'CopyScalars',
                           'CopyNormals', 'CopyGlobalIds',
                           'CopyPedigreeIds']
        for method in meths[:]:
            if klass_name == 'vtkDataSetAttributes' and \
               method[:-2] in problem_methods:
                continue
            elif method[:-2] == 'AlphaBitPlanes':
                continue
            if method[-2:] == 'On':
                key = method[:-2]
                if (key + 'Off') in meths and ('Get' + key) in meths:
                    tm[key] = None
                    meths.remove(method)
                    meths.remove(key + 'Off')
                    self._remove_method(meths, 'Set' + key)
                    self._remove_method(meths, 'Get' + key)
        # get defaults
        if tm:
            obj = self._get_instance(klass)
            if obj:
                for key in tm:
                    try:
                        tm[key] = getattr(obj, 'Get%s'%key)()
                    except (TypeError, AttributeError):
                        print klass.__name__, key
                        pass
        return meths

    def _find_state_methods(self, klass, methods):
        """Find/store methods of the form Set<Prop>To<Value> in the
        given `methods`.  Returns the remaining list of methods.  The
        method also computes the mapped value of the different
        <Values>.

        """
        # These ignored ones are really not state methods.
        ignore = ['SetUpdateExtentToWholeExtent',
                  'SetDataExtentToWholeExtent',
                  'SetOutputSpacingToDefault', # In vtkImageReslice.
                  'SetOutputOriginToDefault', # In vtkImageReslice
                  'SetOutputExtentToDefault' # In vtkImageReslice
                  ]
        meths = methods[:]
        sm = self.state_meths
        for method in meths[:]:
            if method not in ignore and method[:3] == 'Set':
                # Methods of form Set<Prop>To<Value>
                match = self._state_patn.search(method)
                # Second cond. ensures that this is not an accident.
                if match and (('Get'+method[3:]) not in meths):
                    key = method[3:match.start()] # The <Prop> part.
                    if (('Get' + key) in methods):
                        val = method[match.start()+2:] # <Value> part.
                        meths.remove(method)
                        if sm.has_key(key):
                            sm[key].append([val, None])
                        else:
                            sm[key] = [[val, None]]
                            meths.remove('Get'+ key)
                            self._remove_method(meths, 'Set'+ key)
                            if ('Get' + key + 'MaxValue') in meths:
                                meths.remove('Get' + key + 'MaxValue')
                                meths.remove('Get' + key + 'MinValue')
                            try:
                                meths.remove('Get' + key + 'AsString')
                            except ValueError:
                                pass
        # Find the values for each of the states, i.e. find that
        # vtkProperty.SetRepresentationToWireframe() corresponds to
        # vtkProperty.SetRepresentation(1).
        if sm:
            obj = self._get_instance(klass)
            klass_name = klass.__name__
            if obj and not klass_name.endswith('Viewer'):
                # We do not try to inspect viewers, because they'll
                # trigger segfaults during the inspection
                for key, values in sm.items():
                    default = getattr(obj, 'Get%s'%key)()
                    for x in values[:]:
                        try:
                            getattr(obj, 'Set%sTo%s'%(key, x[0]))()
                        except TypeError:
                            # vtkRenderedGraphRepresentation has some of
                            # its SetIvarToState methods that have
                            # non-standard arguments, this throws off
                            # the parser and we ignore these.
                            #print klass.__name__, key
                            pass
                        else:
                            val = getattr(obj, 'Get%s'%key)()
                            x[1] = val
                            if val == default:
                                values.insert(0, [x[0], val])
        return meths

    def _find_get_set_methods(self, klass, methods):
        """Find/store methods of the form {Get,Set}Prop in the given
        `methods` and returns the remaining list of methods.

        Note that it makes sense to call this *after*
        `_find_state_methods` is called in order to avoid incorrect
        duplication.  This method also computes the default value and
        the ranges of the arguments (when possible) by using the
        Get<Prop>{MaxValue,MinValue} methods.

        """
        meths = methods[:]
        gsm = self.get_set_meths
        klass_name = klass.__name__

        for method in meths[:]:
            # Methods of the Set/Get form.
            if method in ['Get', 'Set']:
                # This occurs with the vtkInformation class.
                continue
            elif klass_name == 'vtkProp' and method[3:] == 'AllocatedRenderTime':
                # vtkProp.Get/SetAllocatedRenderTime is private and
                # SetAllocatedRenderTime takes two args, don't wrap it.
                continue
            elif klass_name == 'vtkGenericAttributeCollection' and \
                method[3:] == 'AttributesToInterpolate':
                continue
            elif klass_name == 'vtkOverlappingAMR' and method[3:] == 'Origin':
                continue
            elif (klass_name == 'vtkOrientationMarkerWidget'
                  and method[3:] in ['OutlineColor', 'Viewport']):
                continue
            elif (klass_name == 'vtkImageDataGeometryFilter'
                  and method[3:] == 'Extent'):
                continue
            elif (klass_name == 'vtkVolumeMapper'
                  and method[3:] == 'CroppingRegionPlanes'):
                continue
            elif (method[:3] == 'Set') and ('Get' + method[3:]) in methods:
                key = method[3:]
                meths.remove('Set' + key)
                meths.remove('Get' + key)
                if ('Get' + key + 'MaxValue') in meths:
                    meths.remove('Get' + key + 'MaxValue')
                    meths.remove('Get' + key + 'MinValue')
                    gsm[key] = 1
                else:
                    gsm[key] = None

        # Find the default and range of the values.
        if gsm:
            obj = self._get_instance(klass)
            if obj:
                for key, value in gsm.items():
                    if klass_name in ['vtkPolyData', 'vtkContext2D']:
                        # Evil hack, these classes segfault!
                        default = None
                    elif klass_name == 'vtkHyperOctree' and \
                            key == 'Dimension':
                        # This class breaks standard VTK conventions.
                        gsm[key] = (3, (1, 3))
                        continue
                    else:
                        try:
                            default = getattr(obj, 'Get%s'%key)()
                        except TypeError:
                            default = None
                    if value:
                        low = getattr(obj, 'Get%sMinValue'%key)()
                        high = getattr(obj, 'Get%sMaxValue'%key)()
                        gsm[key] = (default, (low, high))
                    else:
                        gsm[key] = (default, None)
            else:
                # We still might have methods that have a default range.
                for key, value in gsm.items():
                    if value == 1:
                        gsm[key] = None

        return meths

    def _find_get_methods(self, klass, methods):
        """Find/store methods of the form Get<Value> in the given
        `methods` and returns the remaining list of methods.

        """
        meths = methods[:]
        gm = self.get_meths
        for method in meths[:]:
            if method == 'Get':
                # Occurs with vtkInformation
                continue
            elif method[:3] == 'Get':
                gm.append(method)
                meths.remove(method)
        return meths

    def _get_instance(self, klass):
        """Given a VTK class, `klass`, returns an instance of the
        class.

        If the class is abstract, it uses the class tree to return an
        instantiable subclass.  This is necessary to get the values of
        the 'state' methods and the ranges for the Get/Set methods.

        """
        obj = None
        try:
            obj = klass()
        except (TypeError, NotImplementedError):
            if self._tree:
                t = self._tree
                n = t.get_node(klass.__name__)
                for c in n.children:
                    obj = self._get_instance(t.get_class(c.name))
                    if obj:
                        break
        return obj

########NEW FILE########
__FILENAME__ = wrapper_gen
"""This module generates the tvtk (Traited VTK) wrapper classes for
VTK classes.

"""
# Author: Prabhu Ramachandran
# Copyright (c) 2004, Enthought, Inc.
# License: BSD Style.


import sys
import vtk
import types
import textwrap
import keyword
import copy

# Local imports (these are relative imports because the package is not
# installed when these modules are imported).
from common import get_tvtk_name, camel2enthought
import vtk_parser
import indenter
import special_gen


def clean_special_chars(s):
    """Given a string with a '\n' or '\r' it replaces it with a suitably
    escaped string.
    """
    s1 = s.replace('\n', '\\n')
    s2 = s1.replace('\r', '\\r')
    return s2


######################################################################
# `WrapperGenerator` class.
######################################################################

class WrapperGenerator:
    """Generates the wrapper code for all the TVTK classes.

    """
    def __init__(self):
        self.indent = indenter.Indent()
        self.parser = vtk_parser.VTKMethodParser()
        self.special = special_gen.SpecialGenerator(self.indent)
        self.dm = indenter.VTKDocMassager()

    #################################################################
    # `WrapperGenerator` interface.
    #################################################################

    def get_tree(self):
        """Returns the parser's class tree."""
        return self.parser.get_tree()

    def generate_code(self, node, out):
        """Generates the code for the given node in the parse tree
        along with an opened file-like object.

        Parameters
        ----------

        - node

          A node in the ClassTree.

        - out :  file-like object.

          Must support a `write` method.  Code is written to it.

        """
        self.indent.reset()

        self._write_prelims(node, out)

        # Write the class decl and __init__
        self._gen_class_init(node, out)

        # Write the other methods.
        self._gen_methods(node, out)

        # Write any special code if available.
        self.special.generate_code(node, out)

        out.write('\n')

    #################################################################
    # Non-public interface.
    #################################################################

    def _write_prelims(self, node, out):
        """Write preliminary information given the node in the class
        tree, `node`, and output file-like object, `out`.

        """
        prelim = """
        # Automatically generated code: EDIT AT YOUR OWN RISK
        from traits import api as traits
        from traitsui import api as traitsui

        from tvtk import vtk_module as vtk
        from tvtk import tvtk_base
        from tvtk.tvtk_base_handler import TVTKBaseHandler
        from tvtk import messenger
        from tvtk.tvtk_base import deref_vtk
        from tvtk import array_handler
        from tvtk.array_handler import deref_array
        from tvtk.tvtk_classes.tvtk_helper import wrap_vtk

        """
        out.write(self.indent.format(prelim))

    def _gen_class_init(self, node, out):
        indent = self.indent
        klass = self.get_tree().get_class(node.name)
        vtk_class_name = klass.__name__
        class_name = self._get_class_name(klass)
        if node.level == 0:
            base_name = 'tvtk_base.TVTKBase'
        else:
            base_name = self._get_class_name(klass.__bases__)[0]
            if base_name != 'object':
                # Import the base class.
                base_fname = camel2enthought(base_name)
                _imp = "from tvtk.tvtk_classes.%(base_fname)s import %(base_name)s"%locals()
                out.write(indent.format(_imp))
                out.write('\n\n')

        # Write the class declaration.
        cdef = """
        class %(class_name)s(%(base_name)s):
        """%locals()
        out.write(indent.format(cdef))

        self.dm.write_class_doc(klass.__doc__, out, indent)
        indent.incr()

        # Write __init__
        decl = """
        def __init__(self, obj=None, update=True, **traits):
            tvtk_base.TVTKBase.__init__(self, vtk.%(vtk_class_name)s, obj, update, **traits)

        """%locals()
        out.write(indent.format(decl))

        if 'vtk3DWidget' in [x.name for x in node.get_ancestors()]:
            # In this case we also update the traits on the
            # EndInteractionEvent.  Note that we don't need to change
            decl = '''
            def setup_observers(self):
                """Setup the observers for the object."""
                super(%(class_name)s, self).setup_observers()
                tvtk_base._object_cache.setup_observers(self._vtk_obj,
                                              'EndInteractionEvent',
                                              self.update_traits)
            '''%locals()
            out.write(indent.format(decl))

    def _gen_methods(self, node, out):
        klass = self.get_tree().get_class(node.name)
        self.parser.parse(klass)

        if klass.__name__ == 'vtkCamera':
            # 'vtkCamera.Roll' has conflicting signatures --
            # Get/SetRoll() plus an additional Roll() method.  So we
            # wrap all of them as methods and not as traits.
            p = self.parser
            p.get_set_meths.pop('Roll')
            p.other_meths.extend(['GetRoll', 'SetRoll'])

        # ----------------------------------------
        # Generate the code.

        # The return values are editable traits.
        toggle = self._gen_toggle_methods(klass, out)
        state = self._gen_state_methods(klass, out)
        get_set = self._gen_get_set_methods(klass, out)
        # These do not produce editable traits.
        self._gen_get_methods(klass, out)
        self._gen_other_methods(klass, out)

        # ----------------------------------------
        # Now write out the _updateable_traits_ and View related code.

        # Store the data in the node after updating from parents.
        # Note that this data is generated and stored at run
        # time. This is the reason why the wrapper code for the
        # classes are generated in the reverse order of their depth in
        # the inheritance tree.
        data = {'toggle':toggle, 'state':state, 'get_set':get_set}
        if node.level != 0 and node.parents[0].name != 'object':
            pd = node.parents[0].data
            for i in data.keys():
                data[i].update(pd[i])
        node.data = data

        # ----------------------------------------
        # Write out the updateable traits, this is used by
        # the `update_traits` method.
        ut = {}
        for i in data.values():
            ut.update(i)
        junk = textwrap.fill(repr(tuple(ut.items())))
        code = "\n_updateable_traits_ = \\" + "\n%s\n\n"%junk
        out.write(self.indent.format(code))

        # ----------------------------------------
        # Write out the full_traits_view and the more compact
        # traits_view

        # First copy the data over (we're going to edit it and don't
        # want the node's version to be changed).
        d = copy.deepcopy(data)

        # Add support for property trait delegation.
        #Commented out because of problems.
        #self._generate_delegates(node, d, out)

        toggle, state, get_set = d['toggle'], d['state'], d['get_set']

        # Remove unwanted stuff.
        def _safe_remove(d, keys):
            for key in keys:
                try:
                    del d[key]
                except KeyError:
                    pass

        # No point having these in the GUI.
        _safe_remove(get_set, ['reference_count', 'progress'])

        class_name = get_tvtk_name(node.name)
        title = 'Edit %s properties'%class_name

        # Write the full_traits_view.
        # The full traits view displays all of the relevant traits in a table
        # editor. For this, we first write out the _full_traitnames_list: this
        # is used by the TVTKBaseHandler to build a TableEditor for all of
        # the (relevant) traits in the tvtk object.
        t_g = toggle.keys(); t_g.sort()
        s_g = state.keys(); s_g.sort()
        gs_g = get_set.keys(); gs_g.sort()

        junk = textwrap.fill("(%s)" % (t_g + s_g + gs_g))
        code = "\n_full_traitnames_list_ = \\" + "\n%s\n\n"%junk
        out.write(self.indent.format(code))

        # Start the trait_view() method.
        code = "\ndef trait_view(self, name=None, view_element=None):"
        out.write(self.indent.format(code))
        self.indent.incr()
        code = "\nif view_element is not None or name not in (None, '', 'traits_view', 'full_traits_view', 'view'):"
        out.write(self.indent.format(code))
        self.indent.incr()
        code = "\nreturn super(%s, self).trait_view(name, view_element)" % class_name
        out.write(self.indent.format(code))
        self.indent.decr()

        # Now write the full traits view.
        code = "\nif name == 'full_traits_view':"
        out.write(self.indent.format(code))
        self.indent.incr()
        item_contents = (
              'traitsui.Item("handler._full_traits_list",show_label=False)')
        junk = 'traitsui.View((%s),'% item_contents
        code = "\nfull_traits_view = \\" + \
               "\n%s\ntitle=\'%s\', scrollable=True, resizable=True,"\
               "\nhandler=TVTKBaseHandler,"\
               "\nbuttons=['OK', 'Cancel'])"\
               "\nreturn full_traits_view"%(junk, title)
        out.write(self.indent.format(code))
        self.indent.decr()

        # Next, we write a compact traits_view (which we call 'view'), which
        # removes some generally unused items.
        code = "\nelif name == 'view':"
        out.write(self.indent.format(code))
        self.indent.incr()
        _safe_remove(get_set, ['progress_text'])
        _safe_remove(toggle, ['abort_execute', 'release_data_flag',
                              'dragable', 'pickable',
                              'debug', 'global_warning_display'])
        t_g = toggle.keys(); t_g.sort()
        s_g = state.keys(); s_g.sort()
        gs_g = get_set.keys(); gs_g.sort()
        junk = textwrap.fill('traitsui.View((%s, %s, %s),'%(t_g, s_g, gs_g))
        code = "\nview = \\" + \
               "\n%s\ntitle=\'%s\', scrollable=True, resizable=True,"\
               "\nhandler=TVTKBaseHandler,"\
               "\nbuttons=['OK', 'Cancel'])"\
               "\nreturn view"%(junk, title)
        out.write(self.indent.format(code))
        self.indent.decr()

        # Finally, we write the default traits_view which includes a field
        # for specifying the view type (basic or advanced) and the                     # corresponding view (basic->view and advanced->full_traits_view)
        code = "\nelif name in (None, 'traits_view'):"
        out.write(self.indent.format(code))
        self.indent.incr()
        viewtype_contents = (
            'traitsui.HGroup(traitsui.spring, "handler.view_type", ' +\
                             'show_border=True)')
        view_contents = (
            '\ntraitsui.Item("handler.info.object", ' +\
            'editor = traitsui.InstanceEditor(view_name="handler.view"), ' +\
            'style = "custom", show_label=False)')
        junk = 'traitsui.View((%s, %s),'% (viewtype_contents, view_contents)
        code = "\ntraits_view = \\" + \
               "\n%s\ntitle=\'%s\', scrollable=True, resizable=True,"\
               "\nhandler=TVTKBaseHandler,"\
               "\nbuttons=['OK', 'Cancel'])"\
               "\nreturn traits_view\n\n"%(junk, title)
        out.write(self.indent.format(code))
        self.indent.decr()

        self.indent.decr()

    def _generate_delegates(self, node, n_data, out):
        """This method generates delegates for specific classes.  It
        modifies the n_data dictionary."""
        prop_name = {'vtkActor': 'vtkProperty',
                     'vtkActor2D': 'vtkProperty2D',
                     'vtkVolume': 'vtkVolumeProperty'}
        if node.name in prop_name.keys():
            prop_node = self.get_tree().get_node(prop_name[node.name])
            prop_data = prop_node.data
            # Update the data of the node so the view includes the
            # property traits.
            code = ''
            for key in n_data.keys():
                props = prop_data[key]
                n_data[key].update(props)
                # Write the delegates.
                for p in props:
                    code += '%s = tvtk_base.vtk_property_delegate\n'%p
            code += '\n'
            out.write(self.indent.format(code))

    def _gen_toggle_methods(self, klass, out):
        meths = self.parser.get_toggle_methods()
        updateable_traits = {}
        for m in meths:
            name = self._reform_name(m)
            updateable_traits[name] = 'Get' + m
            t_def = 'tvtk_base.false_bool_trait'
            if meths[m]:
                t_def = 'tvtk_base.true_bool_trait'
            try:
                vtk_set_meth = getattr(klass, 'Set' + m)
            except AttributeError:
                # Broken VTK API (4.2) where sometimes GetProp and
                # PropOn/Off exist but no SetProp method is available.
                vtk_get_meth = getattr(klass, 'Get' + m)
                self._write_trait(out, name, t_def, vtk_get_meth,
                                  mapped=True, broken_bool=True)
            else:
                self._write_trait(out, name, t_def, vtk_set_meth,
                                  mapped=True)
        return updateable_traits

    def _gen_state_methods(self, klass, out):
        parser = self.parser
        indent = self.indent
        meths = parser.get_state_methods()
        updateable_traits = {}

        for m in meths.keys():
            name = self._reform_name(m)
            updateable_traits[name] = 'Get' + m
            d = {}
            vtk_val = 0
            for key, val in meths[m]:
                d[self._reform_name(key)] = val
                if isinstance(val, vtk.vtkObjectBase):
                    vtk_val = 1

            # Setting the default value of the traits of these classes
            # Else they are not instantiable
            if klass.__name__ == 'vtkCellQuality' \
                    and m == 'QualityMeasure':
                vtk_val = 1
            if klass.__name__ == 'vtkRenderView' \
                    and m == 'InteractionMode':
                vtk_val = 1
            if klass.__name__ == 'vtkMatrixMathFilter' \
                    and m == 'Operation':
                vtk_val = 1
            if klass.__name__ == 'vtkResliceImageViewer' \
                    and m == 'ResliceMode':
                vtk_val = 'axis_aligned'
            if  klass.__name__ == 'vtkThreshold' \
                   and m == 'PointsDataType':
                vtk_val = 10

            if (not hasattr(klass, 'Set' + m)):
                # Sometimes (very rarely) the VTK method is
                # inconsistent.  For example in VTK-4.4
                # vtkExtentTranslator::SetSplitMode does not exist.
                # In this case wrap it specially.
                vtk_val = 1
            if  vtk_val == 0 and m in ['DataScalarType', 'OutputScalarType',
                                       'UpdateExtent']:
                vtk_val = 2

            # Sometimes, some methods have default values that are
            # outside the specified choices.  This is to special case
            # these.
            extra_val = None
            if vtk_val == 0 and klass.__name__ == 'vtkGenericEnSightReader' \
                   and m == 'ByteOrder':
                extra_val = 2
            if vtk_val == 0 and klass.__name__ == 'vtkImageData' \
                   and m == 'ScalarType':
                extra_val = range(0, 22)
            if vtk_val == 0 and klass.__name__ == 'vtkImagePlaneWidget' \
                   and m == 'PlaneOrientation':
                extra_val = 3
            if (vtk_val == 0) and (klass.__name__ == 'vtkThreshold') \
                   and (m == 'AttributeMode'):
                extra_val = -1
            if (sys.platform == 'darwin') and (vtk_val == 0) \
                   and (klass.__name__ == 'vtkRenderWindow') \
                   and (m == 'StereoType'):
                extra_val = 0

            if not vtk_val:
                default = self._reform_name(meths[m][0][0])
                if extra_val is None:
                    t_def = """traits.Trait('%(default)s',
                                       tvtk_base.TraitRevPrefixMap(%(d)s))"""\
                    %locals()
                elif hasattr(extra_val, '__iter__'):
                    extra_val = str(extra_val)[1:-1]

            if (not hasattr(klass, 'Set' + m)):
                # Sometimes (very rarely) the VTK method is
                # inconsistent.  For example in VTK-4.4
                # vtkExtentTranslator::SetSplitMode does not exist.
                # In this case wrap it specially.
                vtk_val = 1
            if  vtk_val == 0 and m in ['DataScalarType', 'OutputScalarType',
                                       'UpdateExtent']:
                vtk_val = 2

            # Sometimes, some methods have default values that are
            # outside the specified choices.  This is to special case
            # these.
            extra_val = None
            if vtk_val == 0 and klass.__name__ == 'vtkGenericEnSightReader' \
                   and m == 'ByteOrder':
                extra_val = 2
            if vtk_val == 0 and klass.__name__ == 'vtkImageData' \
                   and m == 'ScalarType':
                extra_val = range(0, 22)
            if vtk_val == 0 and klass.__name__ == 'vtkImagePlaneWidget' \
                   and m == 'PlaneOrientation':
                extra_val = 3
            if (vtk_val == 0) and (klass.__name__ == 'vtkThreshold') \
                   and (m == 'AttributeMode'):
                extra_val = -1
            if (sys.platform == 'darwin') and (vtk_val == 0) \
                   and (klass.__name__ == 'vtkRenderWindow') \
                   and (m == 'StereoType'):
                extra_val = 0

            if not vtk_val:
                default = self._reform_name(meths[m][0][0])
                if extra_val is None:
                    t_def = """traits.Trait('%(default)s',
                                       tvtk_base.TraitRevPrefixMap(%(d)s))"""\
                    %locals()
                elif hasattr(extra_val, '__iter__'):
                    extra_val = str(extra_val)[1:-1]
                    t_def = """traits.Trait('%(default)s', %(extra_val)s,
                                       tvtk_base.TraitRevPrefixMap(%(d)s))"""\
                    %locals()
                else:
                    t_def = """traits.Trait('%(default)s', %(extra_val)s,
                                       tvtk_base.TraitRevPrefixMap(%(d)s))"""\
                    %locals()
                vtk_set_meth = getattr(klass, 'Set' + m)
                self._write_trait(out, name, t_def, vtk_set_meth,
                                  mapped=True)
            else:
                del updateable_traits[name]
                vtk_meth = getattr(klass, 'Get' + m)
                self._write_tvtk_method(out, vtk_meth)
                if vtk_val == 2:
                    vtk_meth = getattr(klass, 'Set' + m)
                    self._write_tvtk_method(out, vtk_meth)
                for key, val in meths[m][1:]:
                    x = self._reform_name(key)
                    vtk_meth = getattr(klass, 'Set%sTo%s'%(m, key))
                    decl = 'def set_%s_to_%s(self):'%(name, x)
                    body = 'self._vtk_obj.Set%(m)sTo%(key)s()\n'%locals()
                    self._write_generic_method(out, decl, vtk_meth, body)

        return updateable_traits

    def _gen_get_set_methods(self, klass, out):
        parser = self.parser
        meths = parser.get_get_set_methods()
        updateable_traits = {}
        for m in meths.keys():
            name = self._reform_name(m)
            updateable_traits[name] = 'Get' + m
            vtk_get_meth = getattr(klass, 'Get' + m)
            vtk_set_meth = getattr(klass, 'Set' + m)
            if meths[m]:
                default, rng = meths[m]
            else:
                # In this case we could not get the defaults and range
                # since class has no known concrete subclass.  This
                # happens in very rare circumstances and while the
                # below look like hacks, they are the best we can do.

                sig = parser.get_method_signature(vtk_get_meth)
                if sig[0][1] is None:
                    ret = sig[0][0][0]
                    if ret[:3] == 'vtk':
                        default, rng = None, None
                    elif ret == 'int':
                        default, rng = 0, None
                    elif ret == 'float':
                        default, rng = 0.0, None
                    elif ret == 'string':
                        default, rng = '', None
                    else:
                        default, rng = None, None
                else:
                    self._write_tvtk_method(out, vtk_get_meth, sig)
                    self._write_tvtk_method(out, vtk_set_meth)
                    continue

            if m == 'Output':
                self._write_get_output_method(klass, out, set=True)
                del updateable_traits['output']
            elif m == 'Source':
                # Special cased because vtkGlyph3D.GetSource/SetSource
                # etc. have a special structure to support multiple
                # sources.
                del updateable_traits['source']
                self._write_get_source_method(klass, out)
            elif m == 'ScalarType':
                del updateable_traits['scalar_type']
            elif m == 'Input':
                # In VTK > 4.5, Set/GetInput have multiple signatures.
                del updateable_traits['input']
                self._write_get_input_method(klass, out)
            elif m == 'InputConnection':
                del updateable_traits['input_connection']
                self._write_get_input_connection_method(klass, out)
            elif m.endswith('FileName'):
                t_def = 'tvtk_base.vtk_file_name("")'
                self._write_trait(out, name, t_def, vtk_set_meth, mapped=False)
            elif m.endswith('FilePrefix'):
                t_def = 'tvtk_base.vtk_file_prefix("")'
                self._write_trait(out, name, t_def, vtk_set_meth, mapped=False)
            elif rng is None:
                typ = type(default)
                number_map = {types.IntType: 'traits.Int',
                              types.FloatType: 'traits.Float',
                              types.LongType: 'traits.Long'}
                if klass.__name__ == 'vtkImageReader2':
                    if m == 'HeaderSize':
                        typ = types.LongType
                if typ in number_map:
                    t_name = number_map[typ]
                    t_def = '%(t_name)s(%(default)s, enter_set=True, '\
                            'auto_set=False)'%locals()
                    self._write_trait(out, name, t_def, vtk_set_meth,
                                      mapped=False)
                elif m in ['AreaLabelArrayName'] and \
                        klass.__name__ == 'vtkTreeAreaView':
                    # A special case for the vtkTreeAreaView which
                    # returns a default None value for what ought to be
                    # a string.  This is perhaps best fixed in the VTK
                    # Python wrapper but thats just too much work.
                    t_def = "traits.Trait('%(default)s', None, "\
                            "traits.String('%(default)s', enter_set=True, "\
                            "auto_set=False))"%locals()
                    self._write_trait(out, name, t_def, vtk_set_meth,
                                      mapped=False)
                elif typ in types.StringTypes:
                    if '\n' in default or '\r' in default:
                        default = clean_special_chars(default)

                    if default == '\x00':
                        default = ''
                        t_def = 'traits.String("%(default)s", '%locals()
                    elif default == '"':
                        t_def = "traits.String('%(default)s', "%locals()
                    elif default == "'":
                        t_def = '''traits.String("%(default)s", '''%locals()
                    else:
                        t_def = 'traits.String(r"%(default)s", '%locals()
                    t_def += 'enter_set=True, auto_set=False)'
                    self._write_trait(out, name, t_def, vtk_set_meth,
                                      mapped=False)
                elif typ in (types.TupleType,):
                    if (name.find('color') > -1 or \
                        name.find('bond_color') > -1 or \
                        name.find('background') > -1) and \
                        len(default) == 3:
                        # This is a color.
                        force = 'False'
                        if klass.__name__ in ['vtkProperty', 'vtkLight']:
                            # These two classes are special because if
                            # you change one color the GetColor
                            # changes value so we must force an
                            # update.
                            force = 'True'
                        if klass.__name__ == 'vtkPLYWriter' \
                                and name == 'color':
                            print 'vtkPLYWriter color is not updateable'
                            default = (1.0, 1.0, 1.0)
                            del updateable_traits[name]
                        if klass.__name__ == 'vtkMoleculeMapper' \
                                and name == 'bond_color':
                            print 'vtkMoleculeMapper bond_color is not updateable'
                            default = (1.0, 1.0, 1.0)
                            del updateable_traits[name]
                        t_def = 'tvtk_base.vtk_color_trait(%(default)s)'%locals()
                        self._write_trait(out, name, t_def, vtk_set_meth,
                                          mapped=False, force_update=force)
                    else:
                        # Some other tuple
                        shape = (len(default),)
                        if type(default[0]) is int:
                            dtype = 'int'
                        else:
                            dtype = 'float'
                        t_def = 'traits.Array('\
                                'shape=%(shape)s, value=%(default)s, '\
                                'dtype=%(dtype)s, '\
                                'enter_set=True, auto_set=False, '\
                                'cols=3)'%locals()
                        self._write_trait(out, name, t_def, vtk_set_meth,
                                          mapped=False)
                elif default is None or \
                         isinstance(default, vtk.vtkObjectBase):
                    g_sig = parser.get_method_signature(vtk_get_meth)
                    s_sig = parser.get_method_signature(vtk_set_meth)
                    # Bunch of hacks to work around issues.
                    #print g_sig, vtk_get_meth, klass.__name__
                    if len(g_sig) == 0:
                        g_sig = [([None], None)]

                    if len(s_sig) == 0:
                        s_sig = [([None], [None])]
                        g_sig = [([None], None)]

                    elif s_sig[0][1] is None or s_sig[0][1] == '':
                        s_sig[0] = list(s_sig[0])
                        s_sig[0][1] = [None]

                    if g_sig[0][0][0] == 'string':
                        # If the get method really returns a string
                        # wrap it as such.
                        t_def = 'traits.Trait(None, None, '\
                                'traits.String(enter_set=True, auto_set=False))'
                        self._write_trait(out, name, t_def, vtk_set_meth,
                                          mapped=False)
                    else:
                        if (g_sig[0][1] is None) and (len(s_sig[0][1]) == 1):
                            # Get needs no args and Set needs one arg
                            self._write_property(out, name, vtk_get_meth,
                                                 vtk_set_meth)
                        else: # Get has args or Set needs many args.
                            self._write_tvtk_method(out, vtk_get_meth, g_sig)
                            self._write_tvtk_method(out, vtk_set_meth, s_sig)
                        del updateable_traits[name]
                elif typ is types.BooleanType:
                    t_def = 'traits.Bool(%(default)s)'%locals()
                    self._write_trait(out, name, t_def, vtk_set_meth,
                                      mapped=False)
                else:
                    print "%s:"%klass.__name__,
                    print "Ignoring method: Get/Set%s"%m
                    print "default: %s, range: None"%default
                    del updateable_traits[name]

            else: # Has a specified range of valid values.
                if klass.__name__ == 'vtkCubeAxesActor2D' and \
                       name == 'inertia':
                    # VTK bug.  Inconsistent API!
                    rng = (float(rng[0]), float(rng[1]))
                # If the default is just a little off from the range
                # then extend the range.
                if (default < rng[0]) and (rng[0] - default) < 2:
                    rng = (default, rng[1])
                if (default > rng[1]) and (default - rng[1]) < 2:
                    rng = (rng[0], default)
                # Sometimes the default is not in the valid range to
                # perhaps indicate that the class is not initialized
                if (default < rng[0]) or (default > rng[1]):
                    t_def = 'traits.Trait(%(default)s, %(default)s, '\
                            'traits.Range%(rng)s'%locals()
                    t_def = t_def[:-1] + ', enter_set=True, auto_set=False))'
                else:
                    t_def = 'traits.Trait(%(default)s, '\
                            'traits.Range%(rng)s'%locals()
                    t_def = t_def[:-1] + ', enter_set=True, auto_set=False))'
                self._write_trait(out, name, t_def, vtk_set_meth,
                                  mapped=False)

        return updateable_traits

    def _gen_get_methods(self, klass, out):
        parser = self.parser
        meths = parser.get_get_methods()
        for m in meths:
            vtk_get_meth = getattr(klass, m)
            if m == 'GetOutput': # GetOutput is special.
                self._write_get_output_method(klass, out, set=False)
            elif m == 'GetInput': # GetInput is special.
                self._write_pure_get_input_method(klass, out)
            elif m == 'GetOutputPort':
                # This method sometimes prints warnings so we handle
                # it specially.GetInput is special.
                self._write_pure_get_output_port_method(klass, out)
            else:
                name = self._reform_name(m[3:])
                sig = parser.get_method_signature(vtk_get_meth)
                simple_get = 0
                if len(sig) == 1 and sig[0][1] is None:
                    simple_get = 1
                elif len(sig) > 1:
                    for i in sig:
                        if i[1] is None:
                            simple_get = 1
                            break
                if simple_get:
                    self._write_property(out, name, vtk_get_meth, None)
                else:
                    # Cannot be represented as a simple property,
                    # so we wrap it as a plain old method.
                    self._write_tvtk_method(out, vtk_get_meth, sig)

    def _gen_other_methods(self, klass, out):
        parser = self.parser
        meths = parser.get_other_methods()
        for m in meths:
            vtk_meth = getattr(klass, m)
            self._write_tvtk_method(out, vtk_meth)

    #################################################################
    # Private utility methods.
    #################################################################

    def _reform_name(self, name, method=False):
        """Converts a VTK name to an Enthought style one.  If `method`
        is True it does not touch names that are all upper case."""
        if name == 'TeX':
            # Special case for some of the names.  TeX occurs in the
            # vtkGL2PSExporter class.
            return 'tex'
        if name.isupper() and method:
            # All upper case names should remain the same since they
            # are usually special methods.
            return name

        res = camel2enthought(name)
        if keyword.iskeyword(res):
            return res + '_'
        else:
            return res

    def _get_class_name(self, klasses):
        """Returns renamed VTK classes as per TVTK naming style."""
        ret = []
        if type(klasses) in (types.ListType, types.TupleType):
            return  [get_tvtk_name(x.__name__) \
                     for x in klasses]
        else:
            return get_tvtk_name(klasses.__name__)

    def _find_type(self, val):
        """Given `val` which is extracted from the method call
        signature, this returns the type of the value.  Right now this
        is in ['vtk', 'array', 'basic'].  'vtk' refers to a VTK type,
        'array' to a vtkDataArray/vtkCellArray/vtkPoints/vtkIdList,
        'basic' refers to a non-VTK, basic Python type.
        """
        _arr_types = ['Array', 'vtkPoints', 'vtkIdList']
        s = repr(val)
        if s.find('vtk') > -1:
            for i in _arr_types:
                if s.find(i) > -1:
                    return 'array'
            return 'vtk'
        else:
            return 'basic'

    def _find_arg_type(self, sig):
        """Given a method signature `sig`, this finds the argument
        types.  It uses the `_find_type` method to obtain its result.
        If no arguments are present in *all* of the signatures, then
        it returns `None`.

        """
        if len(sig) == 1:
            if sig[0][1] is None:
                return None
        args = [s[1] for s in sig]
        return self._find_type(args)

    def _find_return_type(self, sig):
        """Given a method signature `sig`, this finds the return
        types.
        """
        rets = [s[0] for s in sig]
        return self._find_type(rets)

    def _find_sig_type(self, sig):
        """Given a method signature `sig`, this finds the return and
        argument types using.  This is a convenience type and returns
        a tuple containing (ret_type, arg_type).
        """
        return self._find_return_type(sig), self._find_arg_type(sig)

    def _find_array_arg_sig(self, sig):
        """Returns a list of argument signatures from the signature
        information for a method.
        """
        return [s[1] for s in sig]

    #################################################################
    # The following methods do the writing.
    #################################################################

    def _write_get_output_method(self, klass, out, set=False):
        """Write the get_output method.  This method is special and
        needs special care.  `klass` is the class for which the method
        is being wrapped, `out` is the output file.  If `set` is True,
        a set_output method is also wrapped.  This defaults to False.
        """
        vtk_get_meth = getattr(klass, 'GetOutput')
        sig = self.parser.get_method_signature(vtk_get_meth)

        # First write out a property.
        doc = "Output of this source, i.e. the result of `get_output()`."
        if set:
            trait_def = """
            def _get_output(self):
                return wrap_vtk(self._vtk_obj.GetOutput())
            def _set_output(self, obj):
                old_val = self._get_output()
                self._wrap_call(self._vtk_obj.SetOutput, deref_vtk(obj))
                self.trait_property_changed('output', old_val, obj)
            output = traits.Property(_get_output, _set_output,
                                     help=\"%(doc)s\")

            """%locals()
        else:
            trait_def = """
            def _get_output(self):
                return wrap_vtk(self._vtk_obj.GetOutput())
            output = traits.Property(_get_output,
                                     help=\"%(doc)s\")

            """%locals()
        out.write(self.indent.format(trait_def))

        # Now write the generic method.
        if len(sig) == 1:
            decl = "def get_output(self):"
            body = "return wrap_vtk(self._vtk_obj.GetOutput())"
        else:
            decl = "def get_output(self, idx=None):"
            body = """
            if idx is None:
                return wrap_vtk(self._vtk_obj.GetOutput())
            else:
                return wrap_vtk(self._vtk_obj.GetOutput(idx))
            """
        self._write_generic_method(out, decl, vtk_get_meth, body)

        if set:
            decl = "def set_output(self, obj):"
            body = "old_val = self._get_output()\n"
            body += "self._wrap_call(self._vtk_obj.SetOutput, deref_vtk(obj))\n"
            body += "self.trait_property_changed('output', old_val, obj)\n"
            vtk_set_meth = getattr(klass, 'SetOutput')
            self._write_generic_method(out, decl,
                                       vtk_set_meth, body)

    def _write_get_source_method(self, klass, out):
        """Write the set/get_source method.  This method needs special
        care.  `klass` is the class for which the method is being
        wrapped, `out` is the output file.
        """
        vtk_get_meth = getattr(klass, 'GetSource')
        vtk_set_meth = getattr(klass, 'SetSource')
        set_sig = self.parser.get_method_signature(vtk_set_meth)
        if len(set_sig) > 1:
            # Special case.  First write the property for the first source.
            doc = "The first source of this object, i.e. the result of `get_source(0)`."
            trait_def = """
            def _get_source(self):
                return wrap_vtk(self._vtk_obj.GetSource(0))
            def _set_source(self, obj):
                old_val = self._get_source()
                self._wrap_call(self._vtk_obj.SetSource, deref_vtk(obj))
                self.trait_property_changed('source', old_val, obj)
            source = traits.Property(_get_source, _set_source,
                                     help=\"%(doc)s\")

            """%locals()
            out.write(self.indent.format(trait_def))
            # Now wrap the set_source and get_source.
            self._write_tvtk_method(out, vtk_get_meth)
            self._write_tvtk_method(out, vtk_set_meth, set_sig)
        else:
            self._write_property(out, 'source', vtk_get_meth, vtk_set_meth)

    def _write_pure_get_output_port_method(self, klass, out):
        """Handle the GetOutputPort method so that it does not print
        unnecessary warning messages.  `klass` is the class for which
        the method is being wrapped, `out` is the output file.
        """
        vtk_get_meth = getattr(klass, 'GetOutputPort')
        t_def = """
        def _get_output_port(self):
            if self._vtk_obj.GetNumberOfOutputPorts():
                return wrap_vtk(self._vtk_obj.GetOutputPort())
            else:
                return None
        """%locals()
        indent = self.indent
        out.write(indent.format(t_def))
        t_def = """output_port = traits.Property(_get_output_port, help=\\"""
        out.write(indent.format(t_def))
        doc = vtk_get_meth.__doc__
        self.dm.write_trait_doc(doc, out, indent)
        # Close the function definition.
        out.write(indent.format(')'))
        out.write('\n')

    def _write_pure_get_input_method(self, klass, out):
        """Write the get_input method when the class only has the
        getter and no setter.  `klass` is the class for which the
        method is being wrapped, `out` is the output file.
        """
        vtk_get_meth = getattr(klass, 'GetInput')
        get_sig = self.parser.get_method_signature(vtk_get_meth)
        if len(get_sig) > 1:
            # Special case.  First write the property for the first input.
            doc = "The first input of this object, i.e. the result of `get_input(0)`."
            trait_def = """
            def _get_input(self):
                try:
                    return wrap_vtk(self._vtk_obj.GetInput(0))
                except TypeError:
                    return wrap_vtk(self._vtk_obj.GetInput())
            input = traits.Property(_get_input,
                                    help=\"%(doc)s\")

            """%locals()
            out.write(self.indent.format(trait_def))
            # Now wrap the get_input with args.
            self._write_tvtk_method(out, vtk_get_meth)
        else:
            self._write_property(out, 'input', vtk_get_meth, None)

    def _write_get_input_method(self, klass, out):
        """Write the set/get_input method.  This method needs special
        care.  `klass` is the class for which the method is being
        wrapped, `out` is the output file.
        """
        vtk_get_meth = getattr(klass, 'GetInput')
        vtk_set_meth = getattr(klass, 'SetInput')
        set_sig = self.parser.get_method_signature(vtk_set_meth)
        if len(set_sig) > 1:
            # Special case.  First write the property for the first input.
            doc = "The first input of this object, i.e. the result of `get_input(0)`."
            trait_def = """
            def _get_input(self):
                try:
                    return wrap_vtk(self._vtk_obj.GetInput(0))
                except TypeError:
                    return wrap_vtk(self._vtk_obj.GetInput())
            def _set_input(self, obj):
                old_val = self._get_input()
                self._wrap_call(self._vtk_obj.SetInput, deref_vtk(obj))
                self.trait_property_changed('input', old_val, obj)
            input = traits.Property(_get_input, _set_input,
                                    help=\"%(doc)s\")

            """%locals()
            out.write(self.indent.format(trait_def))
            # Now wrap the set_input and get_input.
            self._write_tvtk_method(out, vtk_get_meth)
            self._write_tvtk_method(out, vtk_set_meth, set_sig)
        else:
            self._write_property(out, 'input', vtk_get_meth, vtk_set_meth)

    def _write_get_input_connection_method(self, klass, out):
        """Write the set/get_input_connection method.  This method
        needs needs to be wrapped as a property and a method for
        convenience.  `klass` is the class for which the method is
        being wrapped, `out` is the output file.
        """
        vtk_get_meth = getattr(klass, 'GetInputConnection')
        vtk_set_meth = getattr(klass, 'SetInputConnection')
        doc = "The first input connection for this object, i.e. the result of `get_input_connection(0, 0)`."
        trait_def = """
        def _get_input_connection(self):
            if self._vtk_obj.GetTotalNumberOfInputConnections():
                return wrap_vtk(self._vtk_obj.GetInputConnection(0, 0))
            else:
                return None
        def _set_input_connection(self, obj):
            old_val = self._get_input_connection()
            self._wrap_call(self._vtk_obj.SetInputConnection, deref_vtk(obj))
            self.trait_property_changed('input_connection', old_val, obj)
        input_connection = traits.Property(_get_input_connection,
                                           _set_input_connection,
                                           help=\"%(doc)s\")

        """%locals()
        out.write(self.indent.format(trait_def))
        # Now wrap the set_input_connection and get_input_connection.
        self._write_tvtk_method(out, vtk_get_meth)
        self._write_tvtk_method(out, vtk_set_meth)

    def _write_tvtk_method(self, out, vtk_meth, sig=None):
        """Write a generic tvtk_method to `out`.

        Parameters
        ----------

        - out : file like object

        - vtk_meth : VTK method

          The VTK method to wrap.  A docstring is extracted from
          this.

        - sig : Signature of vtk_method (default: None)

          If None, this is computed.  If not, the passed signature
          information is used.
        """
        if not sig:
            sig = self.parser.get_method_signature(vtk_meth)

        # Figure out if we really need to wrap the return and deref
        # the args.
        ret_type, arg_type = self._find_sig_type(sig)

        vtk_m_name = vtk_meth.__name__
        name = self._reform_name(vtk_m_name, method=True)
        if keyword.iskeyword(name):
            name = name + '_'
        method_affects_input = vtk_m_name in ['AddInput', 'RemoveInput',
                                              'RemoveAllInputs',
                                              'SetInputByNumber']

        if arg_type is None:
            decl = 'def %s(self):'%name
            body = ""
            if method_affects_input:
                body += "old_val = self._get_input()\n"
            if ret_type in ['vtk', 'array']:
                body += "ret = wrap_vtk(self._vtk_obj.%s())\n"\
                        %vtk_m_name
            else:
                body += "ret = self._vtk_obj.%s()\n"\
                        %vtk_m_name
            if method_affects_input:
                body += "self.trait_property_changed('input', old_val, self._get_input())\n"
            body += "return ret\n\n"

        else:
            decl = 'def %s(self, *args):'%name
            if arg_type == 'vtk':
                body = ""
                if method_affects_input:
                    body += "old_val = self._get_input()\n"
                body += "my_args = [deref_vtk(x) for x in args]\n"\
                        "ret = self._wrap_call(self._vtk_obj.%s, *my_args)\n"\
                        %vtk_m_name
                if method_affects_input:
                    body += "self.trait_property_changed('input', old_val, self._get_input())\n"

            elif arg_type == 'array':
                arr_sig = self._find_array_arg_sig(sig)
                body = "my_args = deref_array(args, %s)\n"\
                       "ret = self._wrap_call(self._vtk_obj.%s, *my_args)\n"\
                       %(arr_sig, vtk_m_name)
            else:
                body = "ret = self._wrap_call(self._vtk_obj.%s, *args)\n"\
                       %vtk_m_name
            if ret_type in ['vtk', 'array']:
                body += "return wrap_vtk(ret)\n"
            else:
                body += "return ret\n"

        self._write_generic_method(out, decl, vtk_meth, body)

    def _write_generic_method(self, out, decl, vtk_doc_meth, body):
        """Write out a method given the declaration, `decl`, the VTK
        method, `vtk_doc_meth`, from which the docstring is to be
        extracted and the code body, `body`.  Each of these is set as
        per the current indentation level.  output is written to the
        `out` object.

        `vtk_doc_meth` could also be a string, in which case the
        string is used directly.

        """
        if type(vtk_doc_meth) in types.StringTypes:
            doc = vtk_doc_meth
        else: # Must be a method so get the docstring.
            doc = self.dm.get_method_doc(vtk_doc_meth.__doc__)
        indent = self.indent
        out.write(indent.format(decl))
        indent.incr()
        if doc:
            out.write(indent.format('"""\n' + doc + '"""\n'))
        out.write(indent.format(body))
        out.write('\n')
        indent.decr()

    def _write_trait(self, out, t_name, t_def, vtk_set_meth,
                     mapped, force_update=None, broken_bool=False):
        """Write out a complete trait definition to `out`.

        Parameters
        ----------
        - out : File like object.

        - t_name : `string`: Name of the trait.

        - t_def : `string` : Trait definition.

        - vtk_set_meth : VTK setter method.

        - mapped : `bool` : Specifies if the trait is mapped.

        - force_update : `string` or `None` : force_update argument.

        - broken_bool : `bool` (default: `False`)

          If `True` the bool method does not have a 'Set' method and
          must be handled specially.  In this case make sure that the
          vtk_set_meth points to the 'Get' method.

        """
        changed = '_%s_changed'%t_name
        vtk_m_name = vtk_set_meth.__name__
        map_str = ''
        if mapped:
            map_str = '_'
        force_str = ''
        if force_update is not None:
            force_str = ', %s'%force_update

        # Fixing the trait definition in order to handle the help trait.
        if t_def.endswith(')'):
            t_def = t_def[:-1] + ', help=\\'
        else:
            t_def += '(help=\\'
        trait_def = '%(t_name)s = %(t_def)s'%locals()

        if broken_bool:
            msg = "If broken_bool is true, make sure vtk_set_meth "\
                  "is of form 'GetProp'"
            assert vtk_m_name[:3] == 'Get', msg
            vtk_on_name = vtk_m_name[3:] + 'On'
            vtk_off_name = vtk_m_name[3:] + 'Off'
            changed_def = """
            def %(changed)s(self, old_val, new_val):
                def _bool_change(val, obj=self._vtk_obj):
                    if val:
                        obj.%(vtk_on_name)s()
                    else:
                        obj.%(vtk_off_name)s()
                self._do_change(_bool_change, self.%(t_name)s%(map_str)s%(force_str)s)
            """%locals()
        else:
            changed_def = """
            def %(changed)s(self, old_val, new_val):
                self._do_change(self._vtk_obj.%(vtk_m_name)s,
                                self.%(t_name)s%(map_str)s%(force_str)s)
            """%locals()

        indent = self.indent
        # First write the trait definition.
        out.write(indent.format(trait_def))
        # Write the help docs.
        doc = vtk_set_meth.__doc__
        self.dm.write_trait_doc(doc, out, indent)
        # End the function definition.
        out.write(indent.format(')'))
        # Write the handler method.
        out.write(indent.format(changed_def))
        out.write('\n')

    def _write_property(self, out, t_name, vtk_get_meth, vtk_set_meth,
                        multi_arg=False):
        """Writes out a traited property to `out` given the trait
        name, `t_name`, the VTK get method, `vtk_get_meth` an optional
        VTK set method for read-write traits as, `vtk_set_meth` plus a
        boolean value for `multi_arg`.  If `multi_arg` is True, the
        setter is treated as if it accepts a list of parameters.  If
        not the setter is treated as if it accepts a single parameter.
        """
        indent = self.indent
        getter = '_get_%s'%t_name
        vtk_get_name = vtk_get_meth.__name__
        sig = self.parser.get_method_signature(vtk_get_meth)
        ret_type = self._find_return_type(sig)

        if ret_type in ['vtk', 'array']:
            trait_def = """
            def %(getter)s(self):
                return wrap_vtk(self._vtk_obj.%(vtk_get_name)s())
            """%locals()
        else:
            trait_def = """
            def %(getter)s(self):
                return self._vtk_obj.%(vtk_get_name)s()
            """%locals()
        out.write(indent.format(trait_def))

        if vtk_set_meth:
            setter = '_set_%s'%t_name
            vtk_set_name = vtk_set_meth.__name__
            sig = self.parser.get_method_signature(vtk_set_meth)
            arg_type = self._find_arg_type(sig)
            if multi_arg:
                if arg_type == 'vtk':
                    trait_def = """
                    def %(setter)s(self, *args):
                        old_val = self.%(getter)s()
                        my_args = [deref_vtk(x) for x in args]
                        self._wrap_call(self._vtk_obj.%(vtk_set_name)s,
                                        *my_args)
                        self.trait_property_changed('%(t_name)s', old_val, args)
                    """%locals()
                elif arg_type == 'array':
                    arr_sig = self._find_array_arg_sig(sig)
                    trait_def = """
                    def %(setter)s(self, *args):
                        old_val = self.%(getter)s()
                        my_args = deref_array(args, %(arr_sig)s)
                        self._wrap_call(self._vtk_obj.%(vtk_set_name)s,
                                        *my_args)
                        self.trait_property_changed('%(t_name)s', old_val, args)
                    """%locals()

                else:
                    trait_def = """
                    def %(setter)s(self, *args):
                        old_val = self.%(getter)s()
                        self._wrap_call(self._vtk_obj.%(vtk_set_name)s,
                                        *args)
                        self.trait_property_changed('%(t_name)s', old_val, args)
                    """%locals()
            else:
                if arg_type == 'vtk':
                    trait_def = """
                    def %(setter)s(self, arg):
                        old_val = self.%(getter)s()
                        self._wrap_call(self._vtk_obj.%(vtk_set_name)s,
                                        deref_vtk(arg))
                        self.trait_property_changed('%(t_name)s', old_val, arg)
                    """%locals()
                elif arg_type == 'array':
                    arr_sig = self._find_array_arg_sig(sig)
                    trait_def = """
                    def %(setter)s(self, arg):
                        old_val = self.%(getter)s()
                        my_arg = deref_array([arg], %(arr_sig)s)
                        self._wrap_call(self._vtk_obj.%(vtk_set_name)s,
                                        my_arg[0])
                        self.trait_property_changed('%(t_name)s', old_val, arg)
                    """%locals()

                else:
                    trait_def = """
                    def %(setter)s(self, arg):
                        old_val = self.%(getter)s()
                        self._wrap_call(self._vtk_obj.%(vtk_set_name)s,
                                        arg)
                        self.trait_property_changed('%(t_name)s', old_val, arg)
                    """%locals()
            out.write(indent.format(trait_def))
            t_def = "traits.Property(%(getter)s, %(setter)s, help=\\"%locals()
        else:
            t_def = "traits.Property(%(getter)s, help=\\"%locals()

        trait_def = """%(t_name)s = %(t_def)s"""%locals()
        out.write(indent.format(trait_def))
        doc = vtk_get_meth.__doc__
        self.dm.write_trait_doc(doc, out, indent)
        # Close the function definition.
        out.write(indent.format(')'))
        out.write('\n')


########NEW FILE########
