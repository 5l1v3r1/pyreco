__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# Quantlib cython wrapper documentation build configuration file, created by
# sphinx-quickstart on Tue Apr  5 00:10:19 2011.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.insert(0, os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc', 'sphinx.ext.autosummary']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'Quantlib cython wrapper'
copyright = u'2011, Didrik Pinte, Patrick Henaff'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '0.1'
# The full version, including alpha/beta/rc tags.
release = '0.1.1'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = []

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'Quantlibcythonwrapperdoc'


# -- Options for LaTeX output --------------------------------------------------

# The paper size ('letter' or 'a4').
#latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
#latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'Quantlibcythonwrapper.tex', u'Quantlib cython wrapper Documentation',
   u'Didrik Pinte', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Additional stuff for the LaTeX preamble.
#latex_preamble = ''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'quantlibcythonwrapper', u'Quantlib cython wrapper Documentation',
     [u'Didrik Pinte'], 1)
]

########NEW FILE########
__FILENAME__ = american_option
"""
 Copyright (C) 2011, Enthought Inc
 Copyright (C) 2011, Patrick Henaff

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
"""

from quantlib.instruments.api import AmericanExercise, VanillaOption, Put
from quantlib.instruments.payoffs import PlainVanillaPayoff
from quantlib.pricingengines.api import BaroneAdesiWhaleyApproximationEngine
from quantlib.pricingengines.api import FDAmericanEngine
from quantlib.processes.black_scholes_process import BlackScholesMertonProcess
from quantlib.quotes import SimpleQuote
from quantlib.settings import Settings
from quantlib.time.api import Actual365Fixed, Date, May, TARGET
from quantlib.termstructures.volatility.equityfx.black_vol_term_structure \
        import BlackConstantVol
from quantlib.termstructures.yields.api import FlatForward


def main():
    # global data
    todays_date = Date(15, May, 1998)
    Settings.instance().evaluation_date = todays_date
    settlement_date = Date(17, May, 1998)

    risk_free_rate = FlatForward(
        reference_date=settlement_date,
        forward=0.06,
        daycounter=Actual365Fixed()
    )

    # option parameters
    exercise = AmericanExercise(
        earliest_exercise_date = settlement_date,
        latest_exercise_date   = Date(17, May, 1999)
    )
    payoff = PlainVanillaPayoff(Put, 40.0)

    # market data
    underlying = SimpleQuote(36.0)
    volatility = BlackConstantVol(todays_date, TARGET(), 0.20,
                                  Actual365Fixed())
    dividend_yield = FlatForward(
        reference_date = settlement_date,
        forward        = 0.00,
        daycounter     = Actual365Fixed()
    )

    # report
    header = '%19s' % 'method' + ' |' + \
            ' |'.join(['%17s' % tag for tag in ['value',
                                                'estimated error',
                                                'actual error' ] ])
    print
    print header
    print '-'*len(header)

    refValue = None

    def report(method, x, dx=None):
        e = '%.4f' % abs(x - refValue)
        x = '%.5f' % x
        if dx:
            dx = '%.4f' % dx
        else:
            dx = 'n/a'
        print '%19s' % method + ' |' + \
            ' |'.join(['%17s' % y for y in [x, dx, e] ])

    # good to go

    process = BlackScholesMertonProcess(
        underlying, dividend_yield, risk_free_rate, volatility
    )

    option = VanillaOption(payoff, exercise)

    refValue = 4.48667344
    report('reference value', refValue)

    # method: analytic

    option.set_pricing_engine(BaroneAdesiWhaleyApproximationEngine(process))
    report('Barone-Adesi-Whaley', option.net_present_value)

    # method: finite differences
    time_steps = 801
    grid_points = 800

    option.set_pricing_engine(FDAmericanEngine('CrankNicolson',
                              process, time_steps, grid_points))
    report('finite differences', option.net_present_value)


    print 'This is work in progress.'
    print 'Some pricing engines are not yet interfaced.'

    return

    option.set_pricing_engine(BjerksundStenslandEngine(process))
    report('Bjerksund-Stensland',option.NPV())

    # method: binomial
    timeSteps = 801

    option.setPricingEngine(BinomialVanillaEngine(process,'jr',timeSteps))
    report('binomial (JR)',option.NPV())

    option.setPricingEngine(BinomialVanillaEngine(process,'crr',timeSteps))
    report('binomial (CRR)',option.NPV())

    option.setPricingEngine(BinomialVanillaEngine(process,'eqp',timeSteps))
    report('binomial (EQP)',option.NPV())

    option.setPricingEngine(BinomialVanillaEngine(process,'trigeorgis',timeSteps))
    report('bin. (Trigeorgis)',option.NPV())

    option.setPricingEngine(BinomialVanillaEngine(process,'tian',timeSteps))
    report('binomial (Tian)',option.NPV())

    option.setPricingEngine(BinomialVanillaEngine(process,'lr',timeSteps))
    report('binomial (LR)',option.NPV())

if __name__ == '__main__':
    main()


########NEW FILE########
__FILENAME__ = basic_example
""" Simple example pricing a European option 
using a Black&Scholes Merton process."""

from quantlib.instruments.api import (EuropeanExercise, PlainVanillaPayoff, Put,
                                      VanillaOption)
from quantlib.pricingengines.api import AnalyticEuropeanEngine
from quantlib.processes.black_scholes_process import BlackScholesMertonProcess
from quantlib.quotes import SimpleQuote
from quantlib.settings import Settings
from quantlib.time.api import TARGET, Actual365Fixed, today
from quantlib.termstructures.yields.api import FlatForward
from quantlib.termstructures.volatility.api import BlackConstantVol


settings = Settings.instance()
calendar = TARGET()

offset = 366

todays_date = today() - offset
settlement_date = todays_date + 2

settings.evaluation_date = todays_date

# options parameters
option_type = Put
underlying = 36
strike = 40
dividend_yield = 0.00
risk_free_rate = 0.06
volatility = 0.20
maturity = settlement_date + 363
daycounter = Actual365Fixed()

underlyingH = SimpleQuote(underlying)

# bootstrap the yield/dividend/vol curves
flat_term_structure = FlatForward(
    reference_date=settlement_date,
    forward=risk_free_rate,
    daycounter=daycounter
)

flat_dividend_ts = FlatForward(
    reference_date=settlement_date,
    forward=dividend_yield,
    daycounter=daycounter
)

flat_vol_ts = BlackConstantVol(
    settlement_date, calendar, volatility, daycounter
)

black_scholes_merton_process = BlackScholesMertonProcess(
    underlyingH, flat_dividend_ts, flat_term_structure, flat_vol_ts
)

payoff = PlainVanillaPayoff(option_type, strike)

european_exercise = EuropeanExercise(maturity)

european_option = VanillaOption(payoff, european_exercise)


method = 'Black-Scholes'
analytic_european_engine = AnalyticEuropeanEngine(black_scholes_merton_process)

european_option.set_pricing_engine(analytic_european_engine)

print(
    'today: %s settlement: %s maturity: %s' % (
        todays_date, settlement_date, maturity
    )
)
print('NPV: %f\n' % european_option.net_present_value)


### EOF #######################################################################
########NEW FILE########
__FILENAME__ = bonds
""" Example demonstrating pricing bonds using PyQL.

This example is based on the QuantLib Excel bond demo.

"""

from quantlib.instruments.bonds import FixedRateBond
from quantlib.time.api import (
    TARGET, Unadjusted, ModifiedFollowing, Following, NullCalendar
)
from quantlib.compounding import Continuous
from quantlib.pricingengines.bond import DiscountingBondEngine
from quantlib.time.date import Date, August, Period, Jul, Annual, Years
from quantlib.time.daycounter import Actual365Fixed
from quantlib.time.daycounters.actual_actual import ActualActual, ISMA
from quantlib.time.schedule import Schedule, Backward
from quantlib.settings import Settings
from quantlib.termstructures.yields.api import (
    FlatForward, YieldTermStructure
)

todays_date = Date(25, August, 2011)


settings = Settings.instance()
settings.evaluation_date = todays_date

calendar = TARGET()
effective_date = Date(10, Jul, 2006)
termination_date = calendar.advance(
    effective_date, 10, Years, convention=Unadjusted
)


settlement_days = 3
face_amount = 100.0
coupon_rate = 0.05
redemption = 100.0

fixed_bond_schedule = Schedule(
    effective_date,
    termination_date,
    Period(Annual),
    calendar,
    ModifiedFollowing,
    ModifiedFollowing,
    Backward
)

issue_date = effective_date
bond = FixedRateBond(
    settlement_days,
    face_amount,
    fixed_bond_schedule,
    [coupon_rate],
    ActualActual(ISMA),
    Following,
    redemption,
    issue_date
)

discounting_term_structure = YieldTermStructure(relinkable=True)
flat_term_structure = FlatForward(
    settlement_days = 1,
    forward         = 0.044,
    calendar        = NullCalendar(),
    daycounter      = Actual365Fixed(),
    compounding     = Continuous,
    frequency       = Annual)
discounting_term_structure.link_to(flat_term_structure)
pricing_engine = DiscountingBondEngine(discounting_term_structure)
bond.set_pricing_engine(pricing_engine)


print 'Settlement date: ', bond.settlement_date()
print 'Maturity date:', bond.maturity_date
print 'Accrued amount: ', bond.accrued_amount(bond.settlement_date())
print 'Clean price:', bond.clean_price



########NEW FILE########
__FILENAME__ = calibrate_heston
"""
 Copyright (C) 2011, Enthought Inc
 Copyright (C) 2011, Patrick Henaff

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
"""

import numpy as np
import pandas
from pandas import DataFrame
import datetime

from quantlib.models.equity.heston_model import (
    HestonModelHelper, HestonModel, ImpliedVolError
)

from quantlib.models.equity.bates_model import (BatesModel, BatesDetJumpModel,
     BatesDoubleExpModel, BatesDoubleExpDetJumpModel)
from quantlib.processes.heston_process import HestonProcess
from quantlib.processes.bates_process import BatesProcess

from quantlib.pricingengines.api import (AnalyticHestonEngine, BatesEngine,
     BatesDetJumpEngine, BatesDoubleExpEngine, BatesDoubleExpDetJumpEngine)
from quantlib.math.optimization import LevenbergMarquardt, EndCriteria
from quantlib.settings import Settings
from quantlib.time.api import Period, Date, Actual365Fixed, TARGET, Days
from quantlib.quotes import SimpleQuote
from quantlib.util.converter import df_to_zero_curve, pydate_to_qldate


def heston_helpers(df_option, dtTrade=None, df_rates=None, ival=None):
    """
    Create array of heston options helpers
    """

    if dtTrade is None:
        dtTrade = df_option['dtTrade'][0]
    DtSettlement = pydate_to_qldate(dtTrade)

    settings = Settings()
    settings.evaluation_date = DtSettlement

    calendar = TARGET()

    if df_rates is None:
        df_tmp = DataFrame.filter(df_option, items=['dtExpiry', 'IR', 'IDIV'])
        grouped = df_tmp.groupby('dtExpiry')
        df_rates = grouped.agg(lambda x: x[0])

    # convert data frame (date/value) into zero curve
    # expect the index to be a date, and 1 column of values

    risk_free_ts = df_to_zero_curve(df_rates['R'], dtTrade)
    dividend_ts = df_to_zero_curve(df_rates['D'], dtTrade)

    # back out the spot from any forward
    iRate = df_option['R'][0]
    iDiv = df_option['D'][0]
    TTM = df_option['T'][0]
    Fwd = df_option['F'][0]
    spot = SimpleQuote(Fwd * np.exp(-(iRate - iDiv) * TTM))
    print('Spot: %f risk-free rate: %f div. yield: %f' % \
          (spot.value, iRate, iDiv))

    # loop through rows in option data frame, construct
    # helpers for bid/ask

    oneDay = datetime.timedelta(days=1)
    dtExpiry = [dtTrade + int(t * 365) * oneDay for t in df_option['T']]
    df_option['dtExpiry'] = dtExpiry

    options = []
    for index, row in df_option.T.iteritems():

        strike = row['K']
        if (strike / spot.value > 1.3) | (strike / spot.value < .7):
            continue

        days = int(365 * row['T'])
        maturity = Period(days, Days)

        options.append(
                HestonModelHelper(
                    maturity, calendar, spot.value,
                    strike, SimpleQuote(row['VB']),
                    risk_free_ts, dividend_ts,
                    ImpliedVolError))

        options.append(
                HestonModelHelper(
                    maturity, calendar, spot.value,
                    strike, SimpleQuote(row['VA']),
                    risk_free_ts, dividend_ts,
                    ImpliedVolError))

    return {'options': options, 'spot': spot}


def merge_df(df_option, options, model_name):
    df_output = DataFrame.filter(df_option,
                items=['dtTrade', 'dtExpiry',
                       'Type', 'K', 'Mid',
                       'QuickDelta', 'VB', 'VA',
                       'R', 'D', 'ATMVol', 'F', 'T'])

    model_value = np.zeros(len(df_option))
    model_iv = np.zeros(len(df_option))
    for i, j in zip(range(len(df_option)), range(0, len(options), 2)):
        model_value[i] = options[j].model_value()
        model_iv[i] = options[j].impliedVolatility(model_value[i],
            accuracy=1.e-5, maxEvaluations=5000,
            minVol=.01, maxVol=10.0)

    df_output[model_name + '-Value'] = model_value
    df_output[model_name + '-IV'] = model_iv

    return df_output


def bates_calibration(df_option, dtTrade=None, df_rates=None, ival=None):

    # array of option helpers
    hh = heston_helpers(df_option, dtTrade, df_rates, ival)
    options = hh['options']
    spot = hh['spot']

    risk_free_ts = df_to_zero_curve(df_rates['R'], dtTrade)
    dividend_ts = df_to_zero_curve(df_rates['D'], dtTrade)

    v0 = .02

    if ival is None:
        ival = {'v0': v0, 'kappa': 3.7, 'theta': v0,
        'sigma': 1.0, 'rho': -.6, 'lambda': .1,
        'nu': -.5, 'delta': 0.3}

    process = BatesProcess(
        risk_free_ts, dividend_ts, spot, ival['v0'], ival['kappa'],
         ival['theta'], ival['sigma'], ival['rho'],
         ival['lambda'], ival['nu'], ival['delta'])

    model = BatesModel(process)
    engine = BatesEngine(model, 64)

    for option in options:
        option.set_pricing_engine(engine)

    om = LevenbergMarquardt()
    model.calibrate(
        options, om, EndCriteria(400, 40, 1.0e-8, 1.0e-8, 1.0e-8)
    )

    print('model calibration results:')
    print('v0: %f kappa: %f theta: %f sigma: %f\nrho: %f lambda: \
    %f nu: %f delta: %f' %
          (model.v0, model.kappa, model.theta, model.sigma,
           model.rho, model.Lambda, model.nu, model.delta))

    calib_error = (1.0 / len(options)) * sum(
        [pow(o.calibration_error(), 2) for o in options])

    print('SSE: %f' % calib_error)

    return merge_df(df_option, options, 'Bates')


def heston_calibration(df_option, dtTrade=None, df_rates=None, ival=None):
    """
    calibrate heston model
    """

    # array of option helpers
    print df_option, df_rates, ival
    hh = heston_helpers(df_option, dtTrade, df_rates, ival)
    options = hh['options']
    spot = hh['spot']

    risk_free_ts = df_to_zero_curve(df_rates['R'], dtTrade)
    dividend_ts = df_to_zero_curve(df_rates['D'], dtTrade)

    if ival is None:
        ival = {'v0': 0.1, 'kappa': 1.0, 'theta': 0.1,
        'sigma': 0.5, 'rho': -.5}

    process = HestonProcess(
        risk_free_ts, dividend_ts, spot, ival['v0'], ival['kappa'],
         ival['theta'], ival['sigma'], ival['rho'])

    model = HestonModel(process)
    engine = AnalyticHestonEngine(model, 64)

    for option in options:
        option.set_pricing_engine(engine)

    om = LevenbergMarquardt(1e-8, 1e-8, 1e-8)
    model.calibrate(
        options, om, EndCriteria(400, 40, 1.0e-8, 1.0e-8, 1.0e-8)
    )

    print('model calibration results:')
    print('v0: %f kappa: %f theta: %f sigma: %f rho: %f' %
          (model.v0, model.kappa, model.theta, model.sigma,
           model.rho))

    calib_error = (1.0 / len(options)) * sum(
        [pow(o.calibration_error() * 100.0, 2) for o in options])

    print('SSE: %f' % calib_error)

    return merge_df(df_option, options, 'Heston')


def batesdetjump_calibration(df_option, dtTrade=None,
                             df_rates=None, ival=None):

    # array of option helpers
    hh = heston_helpers(df_option, dtTrade, df_rates, ival)
    options = hh['options']
    spot = hh['spot']

    risk_free_ts = df_to_zero_curve(df_rates['R'], dtTrade)
    dividend_ts = df_to_zero_curve(df_rates['D'], dtTrade)

    v0 = .02

    if ival is None:
        ival = {'v0': v0, 'kappa': 3.7, 'theta': v0,
        'sigma': 1.0, 'rho': -.6, 'lambda': .1,
        'nu': -.5, 'delta': 0.3}

    process = BatesProcess(
        risk_free_ts, dividend_ts, spot, ival['v0'], ival['kappa'],
         ival['theta'], ival['sigma'], ival['rho'],
         ival['lambda'], ival['nu'], ival['delta'])

    model = BatesDetJumpModel(process)
    engine = BatesDetJumpEngine(model, 64)

    for option in options:
        option.set_pricing_engine(engine)

    om = LevenbergMarquardt()
    model.calibrate(
        options, om, EndCriteria(400, 40, 1.0e-8, 1.0e-8, 1.0e-8)
    )

    print('BatesDetJumpModel calibration:')
    print('v0: %f kappa: %f theta: %f sigma: %f\nrho: %f lambda: %f nu: %f \
    delta: %f\nkappaLambda: %f thetaLambda: %f' %
          (model.v0, model.kappa, model.theta, model.sigma,
           model.rho, model.Lambda, model.nu, model.delta,
           model.kappaLambda, model.thetaLambda))

    calib_error = (1.0 / len(options)) * sum(
        [pow(o.calibration_error(), 2) for o in options])

    print('SSE: %f' % calib_error)

    return merge_df(df_option, options, 'BatesDetJump')


def batesdoubleexp_calibration(df_option, dtTrade=None,
                               df_rates=None, ival=None):

    # array of option helpers
    hh = heston_helpers(df_option, dtTrade, df_rates, ival)
    options = hh['options']
    spot = hh['spot']

    risk_free_ts = df_to_zero_curve(df_rates['R'], dtTrade)
    dividend_ts = df_to_zero_curve(df_rates['D'], dtTrade)

    v0 = .02

    if ival is None:
        ival = {'v0': v0, 'kappa': 3.7, 'theta': v0,
        'sigma': 1.0, 'rho': -.6, 'lambda': .1,
        'nu': -.5, 'delta': 0.3}

    process = HestonProcess(
        risk_free_ts, dividend_ts, spot, ival['v0'], ival['kappa'],
         ival['theta'], ival['sigma'], ival['rho'])

    model = BatesDoubleExpModel(process)
    engine = BatesDoubleExpEngine(model, 64)

    for option in options:
        option.set_pricing_engine(engine)

    om = LevenbergMarquardt()
    model.calibrate(
        options, om, EndCriteria(400, 40, 1.0e-8, 1.0e-8, 1.0e-8)
    )

    print('BatesDoubleExpModel calibration:')
    print('v0: %f kappa: %f theta: %f sigma: %f\nrho: %f lambda: %f \
    nuUp: %f nuDown: %f\np: %f' %
          (model.v0, model.kappa, model.theta, model.sigma,
           model.rho, model.Lambda, model.nuUp, model.nuDown,
           model.p))

    calib_error = (1.0 / len(options)) * sum(
        [pow(o.calibration_error(), 2) for o in options])

    print('SSE: %f' % calib_error)

    return merge_df(df_option, options, 'BatesDoubleExp')


def batesdoubleexpdetjump_calibration(df_option, dtTrade=None,
                                      df_rates=None, ival=None):

    # array of option helpers
    hh = heston_helpers(df_option, dtTrade, df_rates, ival)
    options = hh['options']
    spot = hh['spot']

    risk_free_ts = df_to_zero_curve(df_rates['R'], dtTrade)
    dividend_ts = df_to_zero_curve(df_rates['D'], dtTrade)

    v0 = .02

    if ival is None:

        ival = {'v0': v0, 'kappa': 3.7, 'theta': v0,
        'sigma': .1, 'rho': -.6, 'lambda': .1,
        'nu': -.5, 'delta': 0.3}

    process = HestonProcess(
        risk_free_ts, dividend_ts, spot, ival['v0'], ival['kappa'],
         ival['theta'], ival['sigma'], ival['rho'])

    model = BatesDoubleExpDetJumpModel(process, 1.0)
    engine = BatesDoubleExpDetJumpEngine(model, 64)

    for option in options:
        option.set_pricing_engine(engine)

    om = LevenbergMarquardt()
    model.calibrate(
        options, om, EndCriteria(400, 40, 1.0e-8, 1.0e-8, 1.0e-8)
    )

    print('BatesDoubleExpDetJumpModel calibration:')
    print('v0: %f kappa: %f theta: %f sigma: %f\nrho: %f lambda: %f \
    nuUp: %f nuDown: %f\np: %f\nkappaLambda: %f thetaLambda: %f' %
          (model.v0, model.kappa, model.theta, model.sigma,
           model.rho, model.Lambda, model.nuUp, model.nuDown,
           model.p, model.kappaLambda, model.thetaLambda))

    calib_error = (1.0 / len(options)) * sum(
        [pow(o.calibration_error(), 2) for o in options])

    print('SSE: %f' % calib_error)

    return merge_df(df_option, options, 'BatesDoubleExpDetJump')

df_rates = pandas.load('data/df_rates.pkl')

# data set with no smoothing
df_option = pandas.load('data/df_SPX_24jan2011.pkl')
dtTrade = df_option['dtTrade'][0]

if True:
    print('heston calibration...')
    df_output = heston_calibration(df_option, dtTrade,
                               df_rates)
    df_output.save('data/df_calibration_output_heston.pkl')

if False:
    print('bates calibration...')
    df_output = bates_calibration(df_option, dtTrade,
                               df_rates)
    df_output.save('data/df_calibration_output_bates.pkl')

if False:
    print('batesdetjump calibration...')
    df_output = batesdetjump_calibration(df_option, dtTrade,
                               df_rates)
    df_output.save('data/df_calibration_output_batesdetjump.pkl')

if False:
    print('bates double exp calibration...')
    df_output = batesdoubleexp_calibration(df_option, dtTrade,
                               df_rates)
    df_output.save('data/df_calibration_output_batesdoubleexp.pkl')

if False:
    print('bates double exp det jump calibration...')
    df_output = batesdoubleexpdetjump_calibration(df_option, dtTrade,
                               df_rates)
    df_output.save('data/df_calibration_output_batesdoubleexpdetjump.pkl')

########NEW FILE########
__FILENAME__ = calibration_plot
# plot fitted vs bid/ask vol at selected maturities

import pandas
import matplotlib.pyplot as plt
from pandas import DataFrame

def calibration_subplot(ax, group, i, model_name):
    group = group.sort_index(by='K')
    dtExpiry = group.get_value(group.index[0], 'dtExpiry')
    K = group['K']
    VB = group['VB']
    VA = group['VA']
    VM = group[model_name + '-IV']

    ax.plot(K, VA, 'b.', K,VB,'b.', K,VM,'r-')
    if i==3:
        ax.set_xlabel('Strike')
    if i==0:
        ax.set_ylabel('Implied Vol')
    ax.set_title('Expiry: %s' % dtExpiry)
    
def calibration_plot(title, df_calibration, model_name):
    df_calibration = DataFrame.filter(df_calibration,
                    items=['dtExpiry', 
                           'K', 'VB', 'VA',
                           'T', model_name+'-IV'])

    # group by maturity
    grouped = df_calibration.groupby('dtExpiry')

    all_groups = [(dt, g) for dt, g in grouped]
    
    xy = [(0,0), (0,1), (1,0), (1,1)]

    for k in range(0, len(all_groups),4):
        if (k+4) >= len(all_groups):
            break
        plt.figure()
        fig, axs = plt.subplots(2, 2, sharex=True, sharey=True)

        for i in range(4):
            x,y = xy[i]
            calibration_subplot(axs[x,y], all_groups[i+k][1],i, model_name)
        fig.suptitle(title, fontsize=12, fontweight='bold')
        fig.show()

# heston model
df_calibration = \
  pandas.load('data/df_calibration_output_heston.pkl')
dtTrade = df_calibration['dtTrade'][0]
title = 'Heston Model (%s)' % dtTrade
calibration_plot(title, df_calibration, 'Heston')

if False:
    # bates model
    df_calibration = \
                   pandas.load('data/df_calibration_output_bates.pkl')
    dtTrade = df_calibration['dtTrade'][0]
    title = 'Bates Model (%s)' % dtTrade
    calibration_plot(title, df_calibration, 'Bates')

    # det jump
    df_calibration = \
      pandas.load('data/df_calibration_output_batesdetjump.pkl')
    dtTrade = df_calibration['dtTrade'][0]
    title = 'Bates Det Jump Model (%s)' % dtTrade
    calibration_plot(title, df_calibration, 'BatesDetJump')

    # double exp
    df_calibration = \
      pandas.load('data/df_calibration_output_batesdoubleexp.pkl')
    dtTrade = df_calibration['dtTrade'][0]
    title = 'Bates Double Exp Model (%s)' % dtTrade
    calibration_plot(title, df_calibration, 'BatesDoubleExp')

    # double exp det jump
    df_calibration = \
      pandas.load('data/df_calibration_output_batesdoubleexpdetjump.pkl')
    dtTrade = df_calibration['dtTrade'][0]
    title = 'Bates Double Exp Det Jump Model (%s)' % dtTrade
    calibration_plot(title, df_calibration, 'BatesDoubleExpDetJump')

########NEW FILE########
__FILENAME__ = cds
""" Example of CDS pricing with PyQL.

This example is based on the QuantLib CDS official example.

Copyright (C) 2012 Enthought Inc.
 
"""

from quantlib.instruments.credit_default_swap import CreditDefaultSwap, SELLER
from quantlib.pricingengines.credit import MidPointCdsEngine
from quantlib.settings import Settings
from quantlib.time.api import (
    Date, May, Actual365Fixed, Following, TARGET, Period, Months,
    Quarterly, TwentiethIMM, Years, Schedule, Unadjusted
)
from quantlib.termstructures.credit.api import SpreadCdsHelper, PiecewiseDefaultCurve
from quantlib.termstructures.yields.api import FlatForward

if __name__ == '__main__':

    #*********************
    #***  MARKET DATA  ***
    #*********************
    calendar = TARGET()

    todays_date = Date(15, May, 2007)
    # must be a business day
    todays_date = calendar.adjust(todays_date)

    Settings.instance().evaluation_date = todays_date

    # dummy curve
    ts_curve = FlatForward(
        reference_date=todays_date, forward=0.01, daycounter=Actual365Fixed()
    )

    # In Lehmans Brothers "guide to exotic credit derivatives"
    # p. 32 there's a simple case, zero flat curve with a flat CDS
    # curve with constant market spreads of 150 bp and RR = 50%
    # corresponds to a flat 3% hazard rate. The implied 1-year
    # survival probability is 97.04% and the 2-years is 94.18%

    # market
    recovery_rate = 0.5
    quoted_spreads = [0.0150, 0.0150, 0.0150, 0.0150 ]
    tenors = [Period(i, Months) for i in [3, 6, 12, 24]]
    maturities = [
        calendar.adjust(todays_date + tenors[i], Following) for i in range(4)
    ]
    instruments = []
    for i in range(4):
        helper = SpreadCdsHelper(
            quoted_spreads[i], tenors[i], 0, calendar, Quarterly,
            Following, TwentiethIMM, Actual365Fixed(), recovery_rate, ts_curve
        )

        instruments.append(helper)

    # Bootstrap hazard rates
    hazard_rate_structure = PiecewiseDefaultCurve(
        'HazardRate', 'BackwardFlat', todays_date, instruments, Actual365Fixed()
    )

    #vector<pair<Date, Real> > hr_curve_data = hazardRateStructure->nodes();

    #cout << "Calibrated hazard rate values: " << endl ;
    #for (Size i=0; i<hr_curve_data.size(); i++) {
    #    cout << "hazard rate on " << hr_curve_data[i].first << " is "
    #         << hr_curve_data[i].second << endl;
    #}
    #cout << endl;


    target = todays_date + Period(1, Years)
    print target
    print "Some survival probability values: "
    print "1Y survival probability: {:%}".format(
            hazard_rate_structure.survival_probability(target)
    )
    print "               expected: {:%}".format(0.9704)

    print "2Y survival probability: {:%}".format(
        hazard_rate_structure.survival_probability(todays_date + 2*Years)
    )
    print "               expected: {:%}".format(0.9418)

    # reprice instruments
    nominal = 1000000.0;
    #Handle<DefaultProbabilityTermStructure> probability(hazardRateStructure);
    engine = MidPointCdsEngine(hazard_rate_structure, recovery_rate, ts_curve)

    cds_schedule = Schedule(
        todays_date, maturities[0], Period(Quarterly), calendar,
        termination_date_convention=Unadjusted,
        date_generation_rule=TwentiethIMM
    )

    cds_3m = CreditDefaultSwap(
        SELLER, nominal, quoted_spreads[0], cds_schedule, Following,
        Actual365Fixed()
    )

    cds_schedule = Schedule(
        todays_date, maturities[1], Period(Quarterly), calendar,
        termination_date_convention=Unadjusted,
        date_generation_rule=TwentiethIMM
    )

    cds_6m = CreditDefaultSwap(
        SELLER, nominal, quoted_spreads[1], cds_schedule, Following,
        Actual365Fixed()
    )

    cds_schedule = Schedule(
        todays_date, maturities[2], Period(Quarterly), calendar,
        termination_date_convention=Unadjusted,
        date_generation_rule=TwentiethIMM
    )

    cds_1y = CreditDefaultSwap(
        SELLER, nominal, quoted_spreads[2], cds_schedule, Following,
        Actual365Fixed()
    )

    cds_schedule = Schedule(
        todays_date, maturities[3], Period(Quarterly), calendar,
        termination_date_convention=Unadjusted,
        date_generation_rule=TwentiethIMM
    )

    cds_2y = CreditDefaultSwap(
        SELLER, nominal, quoted_spreads[3], cds_schedule, Following,
        Actual365Fixed()
    )

    cds_3m.set_pricing_engine(engine);
    cds_6m.set_pricing_engine(engine);
    cds_1y.set_pricing_engine(engine);
    cds_2y.set_pricing_engine(engine);

    print "Repricing of quoted CDSs employed for calibration: "
    print "3M fair spread: {}".format(cds_3m.fair_spread)
    print "   NPV:         ", cds_3m.net_present_value
    print "   default leg: ", cds_3m.default_leg_npv
    print "   coupon leg:  ", cds_3m.coupon_leg_npv

    print "6M fair spread: {}".format(cds_6m.fair_spread)
    print "   NPV:         ", cds_6m.net_present_value
    print "   default leg: ", cds_6m.default_leg_npv
    print "   coupon leg:  ", cds_6m.coupon_leg_npv

    print "1Y fair spread: {}".format(cds_1y.fair_spread)
    print "   NPV:         ", cds_1y.net_present_value
    print "   default leg: ", cds_1y.default_leg_npv
    print "   coupon leg:  ", cds_1y.coupon_leg_npv

    print "2Y fair spread: {}".format(cds_2y.fair_spread)
    print "   NPV:         ", cds_2y.net_present_value
    print "   default leg: ", cds_2y.default_leg_npv
    print "   coupon leg:  ", cds_2y.coupon_leg_npv


########NEW FILE########
__FILENAME__ = make_zero_coupon
"""
 Copyright (C) 2011, Enthought Inc
 Copyright (C) 2011, Patrick Henaff

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
"""

# This script shows how to build libor zero-coupon
# curves from deposits and swap rates, and plot
# a series of such curves

from quantlib.settings import Settings
from quantlib.termstructures.yields.rate_helpers import DepositRateHelper, SwapRateHelper
from quantlib.termstructures.yields.piecewise_yield_curve import \
    term_structure_factory
from quantlib.time.api import Date, TARGET, Period, Months, Years, Days
from quantlib.time.api import (ModifiedFollowing, Unadjusted, Actual360,
                               Thirty360, ActualActual)

from quantlib.time.api import September, ISDA, today
from quantlib.currency import USDCurrency
from quantlib.quotes import SimpleQuote

from quantlib.indexes.libor import Libor
from quantlib.time.date import Semiannual, Annual

import datetime

import numpy as np
import matplotlib.pyplot as plt
import pandas

def QLDateTodate(dt):
    """
    Converts a QL Date to a datetime
    """
    
    return datetime.datetime(dt.year, dt.month, dt.day)
    
def dateToDate(dt):
    return Date(dt.day, dt.month, dt.year)

def get_term_structure(df_libor, dtObs):
    
    settings = Settings()

    # Market information
    calendar = TARGET()

    # must be a business day
    eval_date = calendar.adjust(dateToDate(dtObs))
    settings.evaluation_date = eval_date

    settlement_days = 2
    settlement_date = calendar.advance(eval_date, settlement_days, Days)
    # must be a business day
    settlement_date = calendar.adjust(settlement_date);

    depositData =[[1, Months, 'Libor1M'],
                  [3, Months, 'Libor3M'],
                  [6, Months, 'Libor6M']]

    swapData = [[ 1, Years, 'Swap1Y'],
                [ 2, Years, 'Swap2Y'],
                [ 3, Years, 'Swap3Y'],
                [ 4, Years, 'Swap4Y'],
                [ 5, Years, 'Swap5Y'],
                [ 7, Years, 'Swap7Y'],
                [ 10, Years,'Swap10Y'],
                [ 30, Years,'Swap30Y']]

    rate_helpers = []

    end_of_month = True

    for m, period, label in depositData:
        tenor = Period(m, Months)
        rate = df_libor.get_value(dtObs, label)
        helper = DepositRateHelper(float(rate/100.0), tenor,
                 settlement_days,
                 calendar, ModifiedFollowing,
                 end_of_month,
                 Actual360())

        rate_helpers.append(helper)

    endOfMonth = True

    liborIndex = Libor('USD Libor', Period(6, Months),
                       settlement_days,
                       USDCurrency(), calendar,
                       ModifiedFollowing,
                       endOfMonth, Actual360())

    spread = SimpleQuote(0)
    fwdStart = Period(0, Days)

    for m, period, label in swapData:
        rate = df_libor.get_value(dtObs, label)
        helper = SwapRateHelper(SimpleQuote(rate/100.0),
                 Period(m, Years), 
            calendar, Annual,
            Unadjusted, Thirty360(),
            liborIndex, spread, fwdStart)

        rate_helpers.append(helper)

    ts_day_counter = ActualActual(ISDA)
    tolerance = 1.0e-15

    ts = term_structure_factory('discount', 'loglinear',
         settlement_date, rate_helpers,
         ts_day_counter, tolerance)

    return ts

def zero_curve(ts, dtObs):
    calendar = TARGET()
    days = range(10, 365*20, 30)
    dtMat = [calendar.advance(dateToDate(dtObs), d, Days) for d in days]
    df = np.array([ts.discount(dt) for dt in dtMat])
    dtMat = [QLDateTodate(dt) for dt in dtMat]
    dtToday = QLDateTodate(dtObs)
    dt = np.array([(d-dtToday).days/365.0 for d in dtMat])
    zc = -np.log(df) / dt
    return (dtMat, zc)

if __name__ == '__main__':
    
    df_libor = pandas.load('data/df_libor.pkl')
    dtObs = df_libor.index
    
    fig = plt.figure()
    ax = fig.add_subplot(111)

    # compute x-axis limits
    ts = get_term_structure(df_libor, dtObs[0])
    (dtMat, zc) = zero_curve(ts, dtObs[0])
    dtMin = dtMat[0]
    ts = get_term_structure(df_libor, dtObs[-1])
    (dtMat, zc) = zero_curve(ts, dtObs[-1])
    dtMax = dtMat[-1]
    
    print('dtMin %s dtMax %s' % (dtMin, dtMax))
    
    ax.set_xlim(dtMin, dtMax)
    ax.set_ylim(0.0, 0.1)
    
    dtI = dtObs[range(0, len(dtObs)-1, 100)]
    for dt in dtI:
        ts = get_term_structure(df_libor, dt)
        (dtMat, zc) = zero_curve(ts, dt)
        ax.plot(dtMat, zc)
    
    plt.title('Zero-coupon USD Libor from %s to %s' %
         (dtI[0].strftime('%m/%d/%Y'),
          dtI[-1].strftime('%m/%d/%Y')))
    
    plt.show()
    
    

########NEW FILE########
__FILENAME__ = option_valuation
""" Option valuation example based on a C++ example from the QuantLib mailing list.

Expected  buggy results (see quantlib mailing list:

///////////////////////////  RESULTS
////////////////////////////////////////////////
Description of the option:        IBM Option
Date of maturity:                       January 26th, 2013
Type of the option:                   Call
Strike of the option:                  190
Discrete dividends
Dates                           Dividends
February 10th, 2012             0
May 10th, 2012                  0
August 10th, 2012               0
November 10th, 2012             0
NPV of the European Option with discrete dividends=0:           17.9647
NPV of the European Option without dividend:                     17.9647
NPV of the American Option with discrete dividends=0:   18.5707
NPV of the American Option without dividend:                    17.9647

"""

from quantlib.settings import Settings
from quantlib.compounding import Simple
from quantlib.currency import USDCurrency
from quantlib.indexes.libor import Libor
from quantlib.indexes.swap_index import SwapIndex
from quantlib.instruments.option import EuropeanExercise, AmericanExercise
from quantlib.instruments.option import VanillaOption, DividendVanillaOption
from quantlib.instruments.payoffs import PlainVanillaPayoff
from quantlib.pricingengines.api import AnalyticDividendEuropeanEngine
from quantlib.pricingengines.api import FDDividendAmericanEngine
from quantlib.pricingengines.api import AnalyticEuropeanEngine
from quantlib.pricingengines.api import FDAmericanEngine
from quantlib.processes.black_scholes_process import BlackScholesProcess
from quantlib.quotes import SimpleQuote
from quantlib.time.api import (
    Date, Days, Period, Actual360, Months, Jan, ModifiedFollowing, Years, Feb
)
from quantlib.time.calendars.united_states import UnitedStates
from quantlib.termstructures.yields.api import (
    PiecewiseYieldCurve, DepositRateHelper
)
from quantlib.termstructures.volatility.equityfx.black_vol_term_structure import BlackConstantVol
from quantlib.termstructures.yields.api import SwapRateHelper

def dividendOption():
    # ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    # ++++++++++++++++++++ General Parameter for all the computation +++++++++++++++++++++++
    # ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    # declaration of the today's date (date where the records are done)
    todaysDate = Date(24 , Jan ,2012)	# INPUT
    Settings.instance().evaluation_date = todaysDate #!\ IMPORTANT COMMAND REQUIRED FOR ALL VALUATIONS
    calendar = UnitedStates() # INPUT
    settlement_days	= 2	# INPUT
    # Calcul of the settlement date : need to add a period of 2 days to the todays date
    settlementDate =  calendar.advance(
        todaysDate, period=Period(settlement_days, Days)
    )
    dayCounter = Actual360() # INPUT
    currency = USDCurrency() # INPUT	

    print "Date of the evaluation:			", todaysDate
    print "Calendar used:         			", calendar.name()
    print "Number of settlement Days:		", settlement_days
    print "Date of settlement:       		", settlementDate
    print "Convention of day counter:		", dayCounter.name()
    print "Currency of the actual context:\t\t", currency.name

    # ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    # ++++++++++++++++++++ Description of the underlying +++++++++++++++++++++++++++++++++++
    # ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    underlying_name		= "IBM"
    underlying_price	= 191.75	# INPUT
    underlying_vol		= 0.2094	# INPUT

    print "**********************************"
    print "Name of the underlying:			", underlying_name
    print "Price of the underlying at t0:	", underlying_price
    print "Volatility of the underlying:		", underlying_vol

    # For a great managing of price and vol objects --> Handle
    underlying_priceH  = SimpleQuote(underlying_price)

    # We suppose the vol constant : his term structure is flat --> BlackConstantVol object
    flatVolTS = BlackConstantVol(settlementDate, calendar, underlying_vol, dayCounter)
    
    # ++++++++++++++++++++ Description of Yield Term Structure
    
    #  Libor data record 
    print "**********************************"
    print "Description of the Libor used for the Yield Curve construction" 
    
    Libor_dayCounter = Actual360();

    liborRates = []
    liborRatesTenor = []
    # INPUT : all the following data are input : the rate and the corresponding tenor
    #		You could make the choice of more or less data
    #		--> However you have tho choice the instruments with different maturities
    liborRates = [ 0.002763, 0.004082, 0.005601, 0.006390, 0.007125, 0.007928, 0.009446, 
            0.01110]
    liborRatesTenor = [Period(tenor, Months) for tenor in [1,2,3,4,5,6,9,12]]
    
    for tenor, rate in zip(liborRatesTenor, liborRates):
        print tenor, "\t\t\t", rate

    # Swap data record 

    # description of the fixed leg of the swap
    Swap_fixedLegTenor	= Period(12, Months) # INPUT
    Swap_fixedLegConvention = ModifiedFollowing # INPUT
    Swap_fixedLegDayCounter = Actual360() # INPUT
    # description of the float leg of the swap
    Swap_iborIndex =  Libor(
        "USDLibor", Period(3,Months), settlement_days, USDCurrency(),
        UnitedStates(), Actual360()
    )

    print "Description of the Swap used for the Yield Curve construction"
    print "Tenor of the fixed leg:			", Swap_fixedLegTenor
    print "Index of the floated leg: 		", Swap_iborIndex.name
    print "Maturity		Rate				"

    swapRates = []
    swapRatesTenor = []
    # INPUT : all the following data are input : the rate and the corresponding tenor
    #		You could make the choice of more or less data
    #		--> However you have tho choice the instruments with different maturities
    swapRates = [0.005681, 0.006970, 0.009310, 0.012010, 0.014628, 0.016881, 0.018745,
                 0.020260, 0.021545]
    swapRatesTenor = [Period(i, Years) for i in range(2, 11)]
    
    for tenor, rate in zip(swapRatesTenor, swapRates):
        print tenor, "\t\t\t", rate
    
    # ++++++++++++++++++++ Creation of the vector of RateHelper (need for the Yield Curve construction)
    # ++++++++++++++++++++ Libor 
    LiborFamilyName = currency.name + "Libor"
    instruments = []
    for rate, tenor in zip(liborRates, liborRatesTenor):
        # Index description ___ creation of a Libor index
        liborIndex =  Libor(LiborFamilyName, tenor, settlement_days, currency, calendar,
                Libor_dayCounter)
        # Initialize rate helper	___ the DepositRateHelper link the recording rate with the Libor index													
        instruments.append(DepositRateHelper(rate, index=liborIndex))

    # +++++++++++++++++++++ Swap
    SwapFamilyName = currency.name + "swapIndex";
    for tenor, rate in zip(swapRatesTenor, swapRates):
        # swap description ___ creation of a swap index. The floating leg is described in the index 'Swap_iborIndex'
        swapIndex = SwapIndex (SwapFamilyName, tenor, settlement_days, currency, calendar,
                Swap_fixedLegTenor, Swap_fixedLegConvention, Swap_fixedLegDayCounter,
                Swap_iborIndex)
        # Initialize rate helper __ the SwapRateHelper links the swap index width his rate
        instruments.append(SwapRateHelper.from_index(rate,swapIndex))
    
    # ++++++++++++++++++  Now the creation of the yield curve

    riskFreeTS = PiecewiseYieldCurve('zero', 'linear', settlementDate, instruments, dayCounter)


    # ++++++++++++++++++  build of the underlying process : with a Black-Scholes model 

    print 'Creating process'

    bsProcess = BlackScholesProcess(underlying_priceH, riskFreeTS, flatVolTS)


    # ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    # ++++++++++++++++++++ Description of the option +++++++++++++++++++++++++++++++++++++++
    # ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    
    Option_name = "IBM Option"
    maturity = Date(26, Jan,2013)
    strike = 190
    option_type = 'call'

    # Here, as an implementation exemple, we make the test with borth american and european exercise
    europeanExercise = EuropeanExercise(maturity)
    # The emericanExercise need also the settlement date, as his right to exerce the buy or call start at the settlement date!
    #americanExercise = AmericanExercise(settlementDate, maturity)
    americanExercise = AmericanExercise(maturity, settlementDate)
    
    print "**********************************"
    print "Description of the option:		", Option_name
    print "Date of maturity:     			", maturity
    print "Type of the option:   			", option_type
    print "Strike of the option:		    ", strike



    # ++++++++++++++++++ Description of the discrete dividends
    # INPUT You have to determine the frequece and rates of the discrete dividend. Here is a sollution, but she's not the only one.
    # Last know dividend:
    dividend			= 0.75 #//0.75
    next_dividend_date	= Date(10,Feb,2012)
    # HERE we have make the assumption that the dividend will grow with the quarterly croissance:
    dividendCroissance	= 1.03
    dividendfrequence	= Period(3, Months)
    dividendDates = []
    dividends = []


    d = next_dividend_date
    while d <= maturity:
        dividendDates.append(d)
        dividends.append(dividend)
        d = d + dividendfrequence
        dividend *= dividendCroissance

    print "Discrete dividends				"
    print "Dates				Dividends		"
    for date, div in zip(dividendDates, dividends):
        print date, "		", div

    # ++++++++++++++++++ Description of the final payoff 
    payoff = PlainVanillaPayoff(option_type, strike)

    # ++++++++++++++++++ The OPTIONS : (American and European) with their dividends description:
    dividendEuropeanOption = DividendVanillaOption(
        payoff, europeanExercise, dividendDates, dividends
    )
    dividendAmericanOption = DividendVanillaOption(
        payoff, americanExercise, dividendDates, dividends
    )


    # just too test
    europeanOption = VanillaOption(payoff, europeanExercise)
    americanOption =  VanillaOption(payoff, americanExercise)

    # ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    # ++++++++++++++++++++ Description of the pricing  +++++++++++++++++++++++++++++++++++++
    # ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    
    # For the european options we have a closed analytic formula: The Black Scholes:
    dividendEuropeanEngine = AnalyticDividendEuropeanEngine(bsProcess)

    # For the american option we have make the choice of the finite difference model with the CrankNicolson scheme
    #		this model need to precise the time and space step
    #		More they are greater, more the calul will be precise.
    americanGirdPoints = 600
    americanTimeSteps	= 600
    dividendAmericanEngine = FDDividendAmericanEngine('CrankNicolson', bsProcess,americanTimeSteps, americanGirdPoints)

    # just to test
    europeanEngine = AnalyticEuropeanEngine(bsProcess)
    americanEngine = FDAmericanEngine('CrankNicolson', bsProcess,americanTimeSteps, americanGirdPoints)


    # ++++++++++++++++++++ Valorisation ++++++++++++++++++++++++++++++++++++++++
        
    # Link the pricing Engine to the option
    dividendEuropeanOption.set_pricing_engine(dividendEuropeanEngine)
    dividendAmericanOption.set_pricing_engine(dividendAmericanEngine)
    
    # just	to test
    europeanOption.set_pricing_engine(europeanEngine)
    americanOption.set_pricing_engine(americanEngine)

    # Now we make all the needing calcul	
    # ... and final results
    print "NPV of the European Option with discrete dividends=0:	{:.4f}".format(dividendEuropeanOption.npv)
    print "NPV of the European Option without dividend:		{:.4f}".format(europeanOption.npv)
    print "NPV of the American Option with discrete dividends=0:	{:.4f}".format(dividendAmericanOption.npv)
    print "NPV of the American Option without dividend:		{:.4f}".format(americanOption.npv)
    # just a single test
    print "ZeroRate with a maturity at ", maturity, ": ", \
            riskFreeTS.zero_rate(maturity, dayCounter, Simple)



if __name__ == '__main__':

    dividendOption()


########NEW FILE########
__FILENAME__ = Download_USD_LIBOR
"""
 Copyright (C) 2011, Enthought Inc
 Copyright (C) 2011, Patrick Henaff

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
"""

# Time Series of US Deposit and Swap Rates
# ========================================

# This notebook demonstrates how to download time series of USD deposit
# and swap rates from the US Federal Reserve Board web site.
#
# The data is obtained from the site www.federalreserve.gov. The time series
# can be downloaded from a web browser, but they can also be downloaded
# programmatically. The site provides directions on how to construct the URL
# corresponding to each particular data set. In the example below, the URL is
# specific to the H15 table, with all deposit and swap rates included.
# In this script, we download 11 years of daily data, from January 2000 to
# December 2011. The data is stored in a pandas DataFrame.

import os
import urllib
import numpy as np

from pandas.io.parsers import read_csv
from datetime import date


def get_frb_url(dtStart, dtEnd):
    """
    Federal Reserve Board URL
    Construct this URL at 'http://www.federalreserve.gov/datadownload
    """

    url = 'http://www.federalreserve.gov/datadownload/Output.aspx?rel=H15&series=8f47c9df920bbb475f402efa44f35c29&lastObs=&from=%s&to=%s&filetype=csv&label=include&layout=seriescolumn' % (dtStart.strftime('%m/%d/%Y'), dtEnd.strftime('%m/%d/%Y'))
    return url


def dataconverter(s):
    """
    The FRB data file has
    - numeric cells
    - empty cells
    - cells with 'NC' or 'ND'
    """
    try:
        res = float(s)
    except:
        res = np.nan
    return res


def good_row(z):
    """
    Retain days with no gaps (0 or NaN) in data
    """

    try:
        res = not ((z.isnull()) | (z == 0)).any()
    except:
        res = False
    return res

if __name__ == '__main__':

    fname = os.path.join('..', 'data', 'frb_h15.csv')

    if not os.path.isfile(fname):
        url = get_frb_url(dtStart=date(2000, 1, 1),
                          dtEnd=date(2011, 12, 20))
        frb_site = urllib.urlopen(url)
        text = frb_site.read().strip()

        f = open(fname, 'w')
        f.write(text)
        f.close()

    # simpler labels
    columns_dic = {"RIFLDIY01_N.B": 'Swap1Y',
               "RIFLDIY02_N.B": 'Swap2Y',
               "RIFLDIY03_N.B": 'Swap3Y',
               "RIFLDIY04_N.B": 'Swap4Y',
               "RIFLDIY05_N.B": 'Swap5Y',
               "RIFLDIY07_N.B": 'Swap7Y',
               "RIFLDIY10_N.B": 'Swap10Y',
               "RIFLDIY30_N.B": 'Swap30Y',
               "RILSPDEPM01_N.B": 'Libor1M',
               "RILSPDEPM03_N.B": 'Libor3M',
               "RILSPDEPM06_N.B": 'Libor6M'}

    # the data converter is applied to all columns
    # excluding the index column (0)

    dc_dict = {i: dataconverter for i
               in range(1, len(columns_dic) + 1)}

    df_libor = read_csv(fname, sep=',', header=0,
                    index_col=0, parse_dates=True,
                    converters=dc_dict,
                    skiprows=[0, 1, 2, 3, 4])

    df_libor = df_libor.rename(columns=columns_dic)
    good_rows = df_libor.apply(good_row, axis=1)
    df_libor_good = df_libor[good_rows]
    df_libor_good.save(os.path.join('..', 'data', 'df_libor.pkl'))

########NEW FILE########
__FILENAME__ = HestonSimulation
"""
 Copyright (C) 2011, Enthought Inc
 Copyright (C) 2011, Patrick Henaff

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
"""

# Heston & Bates Process Simulation
# =================================
# 
# This script demonstrates the simulation of Heston and Bates model.

# Heston process
# ==============

# The asset price $S_t$ is governed by the process:
# 
# $$
# \frac{dS_t}{S_t} = \mu dt + \sqrt{\nu_t} dW_t^s
# $$
# 
# where the variance $\nu_t$ is a CIR process:
#
# $$
# d \nu_t = \kappa (\theta - \nu_t) dt + \eta \sqrt{\nu_t} dW_t^{\nu}
# $$
#
# $dW_t^s$ and $dW_t^{\nu}$ are Wiener processes with correlation $\rho$.

from quantlib.processes.bates_process import BatesProcess
from quantlib.models.equity.bates_model import BatesModel
from quantlib.processes.heston_process import HestonProcess
from quantlib.models.equity.heston_model import HestonModel
from quantlib.quotes import SimpleQuote
from quantlib.settings import Settings
from quantlib.time.api import today, NullCalendar, ActualActual
from quantlib.util.rates import flat_rate
import pylab as pl
from quantlib.sim.simulate import simulateHeston, simulateBates

# The Heston Process
# ------------------

settings = Settings.instance()
settlement_date = today()
settings.evaluation_date = settlement_date

daycounter = ActualActual()
calendar = NullCalendar()

interest_rate = .1
dividend_yield = .04

risk_free_ts = flat_rate(interest_rate, daycounter)
dividend_ts = flat_rate(dividend_yield, daycounter)

s0 = SimpleQuote(100.0)

# Heston model

v0 = 0.05
kappa = 5.0
theta = 0.05
sigma = 1.0e-4
rho = -0.5

process = HestonProcess(risk_free_ts, dividend_ts, s0, v0,
                       kappa, theta, sigma, rho)

# The simulation
# --------------
#
# The *simulateHeston* function is not part of Quantlib. It has been added
# to the pyQL interface (see folder quantlib/sim). This illustrates
# how to create extensions to Quantlib and expose them to python.


# simulate and plot Heston paths
paths = 20
steps = 100
horizon = 2
seed = 12345

model = HestonModel(process)

res = simulateHeston(model, paths, steps, horizon, seed)

time = res[0, :]
simulations = res[1:, :].T
pl.figure()
pl.plot(time, simulations)
pl.xlabel('Time')
pl.ylabel('Stock Price')
pl.title('Heston Process Simulation')
pl.show()

# The Bates process
# -----------------

ival = {'v0': v0, 'kappa': 3.7, 'theta': v0,
    'sigma': 1.0, 'rho': -.6, 'lambda': .1,
    'nu': -.5, 'delta': 0.3}

spot = SimpleQuote(1200)

proc_bates = BatesProcess(
    risk_free_ts, dividend_ts, spot, ival['v0'], ival['kappa'],
     ival['theta'], ival['sigma'], ival['rho'],
     ival['lambda'], ival['nu'], ival['delta'])

model_bates = BatesModel(proc_bates)

res_bates = simulateBates(model_bates, paths, steps, horizon, seed)

time = res_bates[0, :]
simulations = res_bates[1:, :].T
pl.figure()
pl.plot(time, simulations)
pl.xlabel('Time')
pl.ylabel('Stock Price')
pl.title('Bates Process Simulation')
pl.show()

########NEW FILE########
__FILENAME__ = heston_calibration
# -*- coding: utf-8 -*-
# <nbformat>3</nbformat>

# <markdowncell>

# Calibration of Heston's Model on SPX data
# =======================================
# 
# This notebook demonstrates the calibration of Heston's model on SPX data, using the QuantLib hestonmodel class. 
# The code is adapted from the test suite written by Klaus Spandersen.
# 
# The calibration function takes as input a `pandas.DataFrame` constructed in notebook OptionQuotes.
# 
# QuantLib dependencies
# ---------------------

# <codecell>

import numpy as np
import pandas
from pandas import DataFrame
import datetime

from quantlib.models.equity.heston_model import (
    HestonModelHelper, HestonModel, ImpliedVolError)

from quantlib.processes.heston_process import HestonProcess
from quantlib.pricingengines.api import AnalyticHestonEngine
from quantlib.math.optimization import LevenbergMarquardt, EndCriteria
from quantlib.settings import Settings
from quantlib.time.api import Period, Date, Actual365Fixed, TARGET, Days
from quantlib.quotes import SimpleQuote
from quantlib.termstructures.yields.zero_curve import ZeroCurve

import matplotlib.pyplot as plt

# <markdowncell>

# Utility functions
# -----------------
# 
# The calibration process uses some utility functions, defined below.

# <codecell>

def dateToQLDate(dt):
    """
    Converts a datetime object into a QL Date
    """
    
    return Date(dt.day, dt.month, dt.year)

def dfToZeroCurve(df_rates, dtSettlement, daycounter=Actual365Fixed()):
    """
    Convert a panda data frame into a QL zero curve
    """
    
    dates = [dateToQLDate(dt) for dt in df_rates.index]
    dates.insert(0, dateToQLDate(dtSettlement))
    dates.append(dates[-1]+365*2)
    vx = list(df_rates.values)
    vx.insert(0, vx[0])
    vx.append(vx[-1])
    return ZeroCurve(dates, vx, daycounter)

# <markdowncell>

# Market data is converted into a set of helper objects, one per data point. For each strike
# and maturity, we construct a helper for the bid and ask prices.

# <codecell>

def heston_helpers(spot, df_option, dtTrade, df_rates):
    """
    Create array of heston options helpers
    """

    DtSettlement = dateToQLDate(dtTrade)
    
    settings = Settings()
    settings.evaluation_date = DtSettlement

    calendar = TARGET()

    # convert data frame (date/value) into zero curve
    # expect the index to be a date, and 1 column of values

    risk_free_ts = dfToZeroCurve(df_rates['iRate'], dtTrade)
    dividend_ts = dfToZeroCurve(df_rates['iDiv'], dtTrade)

    # loop through rows in option data frame, construct
    # helpers for bid/ask

    oneDay = datetime.timedelta(days=1)
    dtExpiry = [dtTrade + int(t*365)*oneDay for t in df_option['TTM']]
    df_option['dtExpiry'] = dtExpiry

    options = []
    for index, row in df_option.T.iteritems():

        strike = row['Strike']
        if (strike/spot.value > 1.3) | (strike/spot.value < .7):
            continue

        days = int(365*row['TTM'])
        maturity = Period(days, Days)

        options.append(
                HestonModelHelper(
                    maturity, calendar, spot.value,
                    strike, SimpleQuote(row['IVBid']),
                    risk_free_ts, dividend_ts,
                    ImpliedVolError))
        
        options.append(
                HestonModelHelper(
                    maturity, calendar, spot.value,
                    strike, SimpleQuote(row['IVAsk']),
                    risk_free_ts, dividend_ts,
                    ImpliedVolError))

    return {'options':options, 'spot': spot}

# <markdowncell>

# The function merge_df merges the result of the calibration (fitted option price and fitted implied volatility)
# with the input data set. This will facilitate the plotting of actual vs. fitted volatility.

# <codecell>

def merge_df(df_option, options, model_name):
    df_output = DataFrame.filter(df_option,
                items=['dtTrade', 'dtExpiry',
                       'Type', 'Strike', 'Mid',
                       'QuickDelta', 'IVBid', 'IVAsk',
                       'iRate', 'iDiv', 'ATMVol', 'Fwd', 'TTM'])

    model_value = np.zeros(len(df_option))
    model_iv = np.zeros(len(df_option))
    for i, j in zip(range(len(df_option)), range(0, len(options),2)):
        model_value[i] = options[j].model_value()
        model_iv[i] = options[j].impliedVolatility(model_value[i],
            accuracy=1.e-5, maxEvaluations=5000,
            minVol=.01, maxVol=10.0)

    df_output[model_name + '-Value'] = model_value
    df_output[model_name + '-IV'] = model_iv
    
    return df_output

# <markdowncell>

# The calibration process
# -----------------------
# 
# The calibration process is performed by the following function.

# <codecell>

def heston_calibration(df_option, ival=None):
    """
    calibrate heston model
    """

    # extract rates and div yields from the data set    
    df_tmp = DataFrame.filter(df_option, items=['dtExpiry', 'iRate', 'iDiv'])
    grouped = df_tmp.groupby('dtExpiry')

    def aggregate(serie):
        return serie[serie.index[0]]

    df_rates = grouped.agg(aggregate)

    # Get first index:
    first_index = 0

    dtTrade = df_option['dtTrade'][first_index]
    # back out the spot from any forward
    iRate = df_option['iRate'][first_index]
    iDiv = df_option['iDiv'][first_index]
    TTM = df_option['TTM'][first_index]
    Fwd = df_option['Fwd'][first_index]
    spot = SimpleQuote(Fwd*np.exp(-(iRate-iDiv)*TTM))
    print('Spot: %f risk-free rate: %f div. yield: %f' % (spot.value, iRate, iDiv))

    # build array of option helpers
    hh = heston_helpers(spot, df_option, dtTrade, df_rates)
    options = hh['options']
    spot = hh['spot']

    risk_free_ts = dfToZeroCurve(df_rates['iRate'], dtTrade)
    dividend_ts = dfToZeroCurve(df_rates['iDiv'], dtTrade)

    # initial values for parameters
    if ival is None:
        ival = {'v0': 0.1, 'kappa': 1.0, 'theta': 0.1,
        'sigma': 0.5, 'rho': -.5}

    process = HestonProcess(
        risk_free_ts, dividend_ts, spot, ival['v0'], ival['kappa'],
         ival['theta'], ival['sigma'], ival['rho'])

    model = HestonModel(process)
    engine = AnalyticHestonEngine(model, 64)

    for option in options:
        option.set_pricing_engine(engine)

    om = LevenbergMarquardt(1e-8, 1e-8, 1e-8)
    model.calibrate(
        options, om, EndCriteria(400, 40, 1.0e-8, 1.0e-8, 1.0e-8)
    )

    print('model calibration results:')
    print('v0: %f kappa: %f theta: %f sigma: %f rho: %f' %
          (model.v0, model.kappa, model.theta, model.sigma,
           model.rho))

    calib_error = (1.0/len(options)) * sum(
        [pow(o.calibration_error()*100.0,2) for o in options])

    print('SSE: %f' % calib_error)

    # merge the fitted volatility and the input data set
    return merge_df(df_option, options, 'Heston')

# <markdowncell>

# Calibration
# -----------
# 
# Finally, the calibration is performed by first loading the option data and calling the calibration routine.

# <codecell>

df_options = pandas.load('../data/df_options_SPX_24jan2011.pkl')
df_heston_cal = heston_calibration(df_options)

# <markdowncell>

# Plot Actual vs. Fitted Implied Volatility
# -----------------------------------------
# 
# We display 4 graphs in one plot, and show the bid/ask market volatility with the fitted volatility
# for selected maturities.

# <codecell>

def calibration_subplot(ax, group, i, model_name):
    group = group.sort_index(by='Strike')
    dtExpiry = group.get_value(group.index[0], 'dtExpiry')
    K = group['Strike']
    VB = group['IVBid']
    VA = group['IVAsk']
    VM = group[model_name + '-IV']

    ax.plot(K, VA, 'b.', K,VB,'b.', K,VM,'r-')
    if i==3:
        ax.set_xlabel('Strike')
    if i==0:
        ax.set_ylabel('Implied Vol')
    ax.text(.6,.8,'%s' % dtExpiry, transform=ax.transAxes)
    
def calibration_plot(title, df_calibration, model_name):
    df_calibration = DataFrame.filter(df_calibration,
                    items=['dtExpiry', 
                           'Strike', 'IVBid', 'IVAsk',
                           'TTM', model_name+'-IV'])

    # group by maturity
    grouped = df_calibration.groupby('dtExpiry')

    all_groups = [(dt, g) for dt, g in grouped]
    
    xy = [(0,0), (0,1), (1,0), (1,1)]

    for k in range(0, len(all_groups),4):
        if (k+4) >= len(all_groups):
            break
        plt.figure()
        fig, axs = plt.subplots(2, 2, sharex=True, sharey=True)

        for i in range(4):
            x,y = xy[i]
            calibration_subplot(axs[x,y], all_groups[i+k][1],i, model_name)
        plt.show()

# <codecell>

dtTrade = df_options['dtTrade'][0]
title = 'Heston Model (%s)' % dtTrade
calibration_plot(title, df_heston_cal, 'Heston')


########NEW FILE########
__FILENAME__ = Libor_to_ZC
"""
 Copyright (C) 2013, Enthought Inc
 Copyright (C) 2013, Patrick Henaff

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
"""

# Libor Zero-Coupon Curve and Principal Components Analysis
# =========================================================

# This script demonstrates how to build a Libor zero-coupon curve
# from deposit and swap rates. It also performs a statistical
# a statistical analysis on curve shifts, and shows that
# the 3 principal components accounts for most of the
# curve variability and can be interpreted as follows:
#
# * The first factor represents an approximate parallel shift
# * The second factor represents a twist
# * The third factor represents a change in convexity

import os

import numpy as np
import matplotlib.pyplot as plt
import matplotlib.mlab as ml

import pandas as pd
from quantlib.util.rates import zero_rate, make_term_structure


if __name__ == '__main__':

    df_libor = pd.load(os.path.join('..', 'data', 'df_libor.pkl'))

    dtObs = df_libor.index

    dtI = dtObs[range(0, len(dtObs) - 1, 60)]
    days = [10, 30, 90, 182, 365, 365 * 2, 365 * 3,
            365 * 5, 365 * 10, 365 * 15]

    # maturity in columns, observation days in rows
    zc_rate = np.empty((len(dtI), len(days)), dtype='float64')
    dt_maturity = np.empty_like(zc_rate, dtype='object')

    # one observation date at a time, construct a term structure from
    # deposit and swap rates, then compute zero-coupon rates at
    # selected maturities
    for i, obs_date in enumerate(dtI):
        print(obs_date)
        rates = df_libor.xs(obs_date) / 100.0
        ts = make_term_structure(rates, obs_date)
        (dt_maturity[i, ], zc_rate[i, ]) = zero_rate(ts, days, obs_date)

    # PCA on rate change
    zc_pca = ml.PCA(np.diff(zc_rate, axis=0))

    fig = plt.figure()
    fig.set_size_inches(10, 6)

    ax = fig.add_subplot(121)

    dtMin = dt_maturity[0, 0]
    dtMax = dt_maturity[-1, -1]
    ax.set_xlim(dtMin, dtMax)
    ax.set_ylim(0.0, 0.1)

    # plot a few curves
    for i in range(0, len(dtI), 3):
        ax.plot(dt_maturity[i, ], zc_rate[i, ])
    plt.title('Zero-Coupon USD Libor: 2000 to 2010')

    ax2 = fig.add_subplot(122)
    ttm = np.array(days) / 365.0
    ax2.plot(ttm, zc_pca.Wt[0, ], 'k--', ttm, zc_pca.Wt[1, ], 'k:', ttm,
             zc_pca.Wt[2, ], 'k')
    leg = ax2.legend(('PC 1', 'PC 2', 'PC 3'))
    plt.title('First 3 Principal Components of USD Libor')
    plt.show()

########NEW FILE########
__FILENAME__ = OptionQuotes
# Preprocessing of Option Quotes
# ==============================
# 
# This notebook demonstrates the preprocessing of equity options, in preparation for the estimation of the parameters of a stochastic model.
# A number of preliminary calculations must be performed:
# 
# 1. Calculation of implied risk-free rate and dividend yield, and derivation of forward prices
# 2. Calculation of forward at-the-money volatility. There is probably no option struck at the forward price, so this item must be computed by interpolation.
# 3. Calculation of the Black-=Scholes implied bid and ask volatility, given bid and ask option prices. 
# 4. Calculation of 'Quick Delta': this is a common measure of moneyness, useful for representing the volatility smile.
# 
# Each step is now described.
# 
# Calculation of implied dividend yield and risk-free rate
# --------------------------------------------------------
# 
# Recall the put-call parity relationship with continuous dividends:
# 
# $$
# C_t - P_t = S_t e^{-d (T-t)} - K e^{-r (T-t)}
# $$
# 
# where
# 
# * $C_t$ price of call at time $t$
# * $P_t$ price of put at time $t$
# * $S_t$ spot price of underlying asset
# * $d$ continuous dividend yield
# * $r$ risk-free rate
# * $T$ Expity
# 
# For each maturity, we estimate the linear regression:
# 
# $$
# C_t - P_t = a_0 + a_1 K
# $$
# 
# which yields
# 
# $$
# r = - \frac{1}{T} \ln (-a_1)
# $$
# $$
# d = \frac{1}{T} \ln \left( \frac{S_t}{a_0} \right)
# $$
# 
# Calculation of forward at-the-money volatility
# ----------------------------------------------
# 
# We next want to estimate the implied volatility of an option struck at the forward price. In general, such option is not traded, and the volatility must therefore be estimated. The calculation involves 3 steps, performed separately on calls and puts:
# 
# 1. Estimate the bid ($\sigma_b(K)$) and ask ($\sigma_a(K)$) Black-Scholes volatility for each quote.
# 2. Compute a mid-market implied volatility for each quote:
# $$
# \sigma(K) = \frac{\sigma_b(K)+\sigma_a(K)}{2}
# $$
# 3. Let $F$ be the forward price, the corresponding mid-market implied volatility is computed by linear interpolation between the two quuotes braketing $F$.
# 
# The forward ATM volatility is the average of the volatilities computed on calls and puts.
# 
# Quick Delta
# -----------
# 
# Recall that the delta of a European call is defined as $N(d_1)$, where
# 
# $$
# d_{1} = \frac{1}{\sigma \sqrt{T}} \left[ \ln \left( \frac{S}{K} \right) + \left( r + \frac{1}{2}\sigma^2 \right)T \right]
# $$
# 
# The "Quick Delta" (QD) is a popular measure of moneyness, inspired from the definition of delta:
# 
# $$
# QD(K) = N \left( \frac{1}{\sigma \sqrt{T}} \ln \left( \frac{F_T}{K} \right) \right)
# $$
# 
# Note that $QD(F_T)=0.5$, for all maturities, while the regular forward delta is a function of time to expiry. This property of Quick Delta makes it convenient for representing the volatility smile.
# 
# Data Filters
# ------------
# 
# A number of filters may be applied, in an attempt to exclude inconsistent or erroneous data.
# 
# 1. Exclusion of maturities shorter than $tMin$
# 2. Exclusion of maturities with less than $nMin$ quotes
# 3. Exclusion of quotes with Quick Delta less than $QDMin$ or higher than $QDMax$
# 
# Implementation
# --------------
# 
# This logic is implemented in the function `Compute_IV`, presented below. The function takes as argument a `pandas DataFrame` and returns another 
# `DataFrame`, with one row per quote and 14 columns:
# 
# 1. Type: 'C'/'P'
# 2. Strike
# 3. dtExpiry
# 4. dtTrade
# 5. Spot
# 6. IVBid: Black-Scholes implied volatility (bid)
# 7. IVAsk: Black-Scholes implied volatility (ask)
# 8. QD: Quick Delta
# 9. iRate: risk-free rate (continuously compounded)
# 10. iDiv: dividend yield (continuously compounded)
# 11. Fwd: Forward price
# 12. TTM: Time to maturity, in fraction of years (ACT/365)
# 13. PBid: Premium (bid)
# 14. PAsk: Premium (ask)

# <codecell>

import pandas
import dateutil
import re
import datetime
import numpy as np
from pandas import DataFrame
from scipy.interpolate import interp1d
from scipy.stats import norm
from scipy.linalg import lstsq

import quantlib.pricingengines.blackformula
from quantlib.pricingengines.blackformula import blackFormulaImpliedStdDev

def Compute_IV(optionDataFrame, tMin=0, nMin=0, QDMin=0, QDMax=1, keepOTMData=True):
    
    """
    Pre-processing of a standard European option quote file.
    - Calculation of implied risk-free rate and dividend yield
    - Calculation of implied volatility
    - Estimate ATM volatility for each expiry
    - Compute implied volatility and Quick Delta for each quote
    
    Options for filtering the input data set: 
    - maturities with less than nMin strikes are ignored
    - maturities shorter than tMin (ACT/365 daycount) are ignored
    - strikes with Quick Delta < qdMin or > qdMax are ignored
    """
    
    grouped = optionDataFrame.groupby('dtExpiry') 

    isFirst = True
    for spec, group in grouped:
        print('processing group %s' % spec)

        # implied vol for this type/expiry group

        indx = group.index
        
        dtTrade = group['dtTrade'][indx[0]]
        dtExpiry = group['dtExpiry'][indx[0]]
        spot = group['Spot'][indx[0]]
        daysToExpiry = (dtExpiry-dtTrade).days
        timeToMaturity = daysToExpiry/365.0

        # exclude groups with too short time to maturity
        
        if timeToMaturity < tMin:
            continue
            
        # exclude groups with too few data points
        
        df_call = group[group['Type'] == 'C']
        df_put = group[group['Type'] == 'P']
        
        if (len(df_call) < nMin) | (len(df_put) < nMin):
            continue

        # calculate forward, implied interest rate and implied div. yield
            
        df_C = DataFrame((df_call['PBid']+df_call['PAsk'])/2,
                         columns=['PremiumC'])
        df_C.index = df_call['Strike']
        df_P = DataFrame((df_put['PBid']+df_put['PAsk'])/2,
                         columns=['PremiumP'])
        df_P.index = df_put['Strike']
        
        # use 'inner' join because some strikes are not quoted for C and P
        df_all = df_C.join(df_P, how='inner')
        df_all['Strike'] = df_all.index
        df_all['C-P'] = df_all['PremiumC'] - df_all['PremiumP']

        y = np.array(df_all['C-P'])
        x = np.array(df_all['Strike'])
        A = np.vstack((x, np.ones(x.shape))).T

        b = np.linalg.lstsq(A, y)[0]
        # intercept is last coef
        iRate = -np.log(-b[0])/timeToMaturity
        dRate = np.log(spot/b[1])/timeToMaturity
        
        discountFactor = np.exp(-iRate*timeToMaturity)
        Fwd = spot * np.exp((iRate-dRate)*timeToMaturity)

        print('Fwd: %f int rate: %f div yield: %f' % (Fwd, iRate, dRate))

        # mid-market ATM volatility
        
        def impvol(cp, strike, premium):
            try:
                vol = blackFormulaImpliedStdDev(cp, strike,
                    forward=Fwd, blackPrice=premium, discount=discountFactor,
                    TTM=timeToMaturity)
            except:
                vol = np.nan
            return vol/np.sqrt(timeToMaturity)
        
        # implied bid/ask vol for all options
        
        df_call['IVBid'] = [impvol('C', strike, price) for strike, price
                            in zip(df_call['Strike'], df_call['PBid'])]
        df_call['IVAsk'] = [impvol('C', strike, price) for strike, price
                            in zip(df_call['Strike'], df_call['PAsk'])]
        
        df_call['IVMid'] = (df_call['IVBid'] + df_call['IVAsk'])/2
        
        df_put['IVBid'] = [impvol('P', strike, price) for strike, price
                           in zip(df_put['Strike'], df_put['PBid'])]
        df_put['IVAsk'] = [impvol('P', strike, price) for strike, price
                           in zip(df_put['Strike'], df_put['PAsk'])]
        
        df_put['IVMid'] = (df_put['IVBid'] + df_put['IVAsk'])/2
        
        f_call = interp1d(df_call['Strike'].values, df_call['IVMid'].values)
        f_put = interp1d(df_put['Strike'].values, df_put['IVMid'].values)

        atmVol = (f_call(Fwd)+f_put(Fwd))/2
        print('ATM vol: %f' % atmVol)

        # Quick Delta, computed with ATM vol
        rv = norm()
        df_call['QuickDelta'] = [rv.cdf(np.log(Fwd/strike)/(atmVol*np.sqrt(timeToMaturity))) \
        for strike in df_call['Strike']]
        df_put['QuickDelta'] = [rv.cdf(np.log(Fwd/strike)/(atmVol*np.sqrt(timeToMaturity))) \
        for strike in df_put['Strike']]

        # keep data within QD range
    
        df_call = df_call[(df_call['QuickDelta'] >= QDMin) & \
                          (df_call['QuickDelta'] <= QDMax) ]
                        
        df_put = df_put[  (df_put['QuickDelta'] >= QDMin) & \
                          (df_put['QuickDelta'] <= QDMax) ]

        # final assembly...

        df_cp = df_call.append(df_put,  ignore_index=True)
        df_cp['iRate'] = iRate 
        df_cp['iDiv'] = dRate 
        df_cp['ATMVol'] = atmVol 
        df_cp['Fwd'] = Fwd
        df_cp['TTM'] = timeToMaturity
        df_cp['CP'] = [1 if t == 'C' else -1 for t in df_cp['Type']]

        # keep only OTM data ?
        if keepOTMData:
            df_cp = df_cp[((df_cp['Strike']>=Fwd) & (df_cp['Type'] == 'C')) |
                          ((df_cp['Strike']<Fwd) & (df_cp['Type'] == 'P'))]
                         
        if isFirst:
            df_final = df_cp
            isFirst = False 
        else:
            df_final = df_final.append(df_cp, ignore_index=True)

    return df_final

# <markdowncell>

# Example
# -------
# 
# Using the SPX data set found in the data folder, the above procedure generates a `DataFrame` suited for use in a calibration program.

# <codecell>

if __name__ == '__main__':

    option_data_frame = pandas.core.common.load('../data/df_SPX_24jan2011.pkl')

    df_final = Compute_IV(option_data_frame, tMin=1.0/12, nMin=6, QDMin=.2, QDMax=.8)

    # save a csv file and pickled data frame
    df_final.to_csv('../data/df_options_SPX_24jan2011.csv', index=False)
    df_final.save('../data/df_options_SPX_24jan2011.pkl')


########NEW FILE########
__FILENAME__ = SPX_Options
# -*- coding: utf-8 -*-
# <nbformat>3</nbformat>

# <markdowncell>

# Standardized Option Quotes Data Format
# ======================================
# 
# To facilitate model calibration, a standard input format has been defined, which contains all the
# necessary data. The data is held in a [Panda](http://pandas.pydata.org) table, with one row per quote and
# 8 columns, as follows:
# 
# * dtTrade: Quote date, or time stamp
# * Strike: Ditto
# * dtExpiry: Option expiry date
# * CP: Call/Put flag, coded as C/P or Call/Put
# * Spot: Price of underlying asset
# * Type: European/American
# * PBid: Bid price
# * PAsk: Ask price
# 
# Note that we do not include the dividend yield nor the risk-free rate in the data set: The 
# implied forward price and risk-free rate are estimated from the call/put parity.
# 
# SPX Option Data Processing
# --------------------------
# 
# As an illustration, we provide below the procedure for converting raw SPX option data, as published by the [CBOE](http://www.cboe.com/DelayedQuote/QuoteTableDownload.aspx), into the standard input format.
# 
# ### SPX Utility functions
# 
# These functions parse the SPX option names, and extract expiry date and strike.

# <codecell>

import pandas
import dateutil, datetime
import re

def ExpiryMonth(s):
    """
    SPX contract months
    """
    call_months = "ABCDEFGHIJKL"
    put_months = "MNOPQRSTUVWX"

    try:
        m = call_months.index(s)
    except ValueError:
        m = put_months.index(s)

    return m

spx_symbol = re.compile("\\(SPX(1[0-9])([0-9]{2})([A-Z])([0-9]{3,4})-E\\)")

def parseSPX(s):
    """
    Parse an SPX quote string, return expiry date and strike
    """
    tokens = spx_symbol.split(s)

    if len(tokens) == 1:
        return {'dtExpiry': None, 'strike': -1}

    year = 2000 + int(tokens[1])
    day = int(tokens[2])
    month = ExpiryMonth(tokens[3])
    strike = float(tokens[4])

    dtExpiry = datetime.date(year, month, day)

    return ({'dtExpiry': dtExpiry, 'strike': strike})


# <markdowncell>

# ### Reading the SPX raw data file
# 
# The csv file downloaded from the CBOE site can be converted into a standard panda table by the following function. 

# <codecell>

def read_SPX_file(option_data_file):
    """
    Read SPX csv file, return spot and data frame of option quotes
    """

    # read two lines for spot price and trade date
    with open(option_data_file) as fid:
        lineOne = fid.readline()
        spot = float(lineOne.split(',')[1])

        lineTwo = fid.readline()
        dt = lineTwo.split('@')[0]
        dtTrade = dateutil.parser.parse(dt).date()

        print('Dt Calc: %s Spot: %f' % (dtTrade, spot))

    # read all option price records as a data frame
    df = pandas.io.parsers.read_csv(option_data_file, header=0, sep=',', skiprows=[0,1])

    # split and stack calls and puts
    call_df = df[['Calls', 'Bid', 'Ask']]
    call_df = call_df.rename(columns={'Calls':'Spec', 'Bid':'PBid', 'Ask': 'PAsk'})
    call_df['Type'] = 'C'

    put_df = df[['Puts', 'Bid.1', 'Ask.1']]
    put_df = put_df.rename(columns = {'Puts':'Spec', 'Bid.1':'PBid',
    'Ask.1':'PAsk'})
    put_df['Type'] = 'P'

    df_all = call_df.append(put_df,  ignore_index=True)

    # parse Calls and Puts columns for strike and contract month
    # insert into data frame

    cp = [parseSPX(s) for s in df_all['Spec']]
    df_all['Strike'] = [x['strike'] for x in cp]
    df_all['dtExpiry'] = [x['dtExpiry'] for x in cp]

    del df_all['Spec']

    df_all = df_all[(df_all['Strike'] > 0) & (df_all['PBid']>0) \
                    & (df_all['PAsk']>0)]

    df_all['dtTrade'] = dtTrade
    df_all['Spot'] = spot

    return df_all

option_data_file = \
    '../data/SPX-Options-24jan2011.csv'

if __name__ == '__main__':
    df_SPX = read_SPX_file(option_data_file)
    print '%d records processed' % len(df_SPX)

    # save a csv file and pickled data frame
    df_SPX.to_csv('../data/df_SPX_24jan2011.csv', index=False)
    df_SPX.save('../data/df_SPX_24jan2011.pkl')
    print 'File saved'


########NEW FILE########
__FILENAME__ = USD_Deposit_Swap
"""
 Copyright (C) 2013, Enthought Inc
 Copyright (C) 2013, Patrick Henaff

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
"""

# USD Deposit and Swap Rates
# ==========================
#
# This script shows how to process a curve of US deposit and swap rates.
# The data comes from the US Federal Reserve Board, and is published daily
# as a data set named 'Table H15'.
# Here, we extract a curve from the data set and construct a simple plot .

import os
import datetime
import pandas as pd
import pylab as pl

if __name__ == '__main__':

    # maturities in years
    maturities_dic = {'Swap1Y': 1,
                      'Swap2Y': 2,
                      'Swap3Y': 3,
                      'Swap4Y': 4,
                      'Swap5Y': 5,
                      'Swap7Y': 7,
                      'Swap10Y': 10,
                      'Swap30Y': 30,
                      'Libor1M': 1.0 / 12,
                      'Libor3M': 3.0 / 12,
                      'Libor6M': 6.0 / 12}

    dt_obs = datetime.datetime(2011, 12, 20)

    # extract a yield curve from data frame
    libor_rates = pd.load(os.path.join('..', 'data', 'df_libor.pkl'))
    df_libor = pd.DataFrame(libor_rates.xs(dt_obs), columns=['Rate'])

    # add maturity column
    df_libor['Maturity'] = [maturities_dic[k] for k in df_libor.index]

    # add maturity column
    df_libor['Maturity'] = [col_mat_dic[k] for k in df_libor.index]
    
    # ... and sort by increasing maturity
    df_libor = df_libor.sort_index(by='Maturity')

    print df_libor
    
    pl.plot(df_libor['Maturity'], df_libor['Rate'])
    pl.xlabel('Maturity (Yr)')
    pl.ylabel('Deposit/Libor Rate')
    pl.title('Libor Deposit and Swap Rates (%s) \n from Table H15 \
    at www.federalreserve.gov' % dt_obs.strftime('%d-%b-%Y'))
    pl.show()

########NEW FILE########
__FILENAME__ = settings_test
# simple example to demonstrate the use of Settings()


from quantlib.quotes import SimpleQuote
from quantlib.settings import Settings
from quantlib.termstructures.yields.api import FlatForward
from quantlib.time.api import Actual360, Date, NullCalendar, TARGET

calendar = TARGET()
settings = Settings()

date_today      = Date(6,9,2011)
date_payment    = Date(6,10,2011)
settlement_days = 2

settings.evaluation_date = date_today
quote = SimpleQuote(value=0.03)

term_structure = FlatForward(
    settlement_days = settlement_days,
    quote           = quote,
    calendar        = NullCalendar(),
    daycounter      = Actual360()
)

df_1 = term_structure.discount(date_payment)

date_today = Date(19,9,2011)
settings.evaluation_date = date_today

date_payment = Date(19,10,2011)
df_2 = term_structure.discount(date_payment)

# df_1 and df_2 should be identical:
print('rate: %f df_1: %f df_2 %f difference: %f' % (quote.value, df_1, df_2, df_2-df_1))

# the term structure registers a listener on the quote: a change in quote
# triggers a lazy recalculation of the discount factor

quote.value = .05
df_2 = term_structure.discount(date_payment)
print('rate: %f df_2: %f' % (quote.value, df_2))

########NEW FILE########
__FILENAME__ = settings_with_QL_error
# This code throws a QuantLib::Error that terminates python
# Settings is set by default to today's date.
# If dt_payment is in the past, a QuantLib::Error is thrown from c++
import logging


from quantlib.quotes import SimpleQuote
from quantlib.termstructures.yields.api import FlatForward
from quantlib.time.api import Actual360, Date, NullCalendar, TARGET


logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

calendar = TARGET()

date_today      = Date(6,9,2011)
date_payment    = Date(6,12,2000)
settlement_days = 2

quote = SimpleQuote(value=0.03)

term_structure = FlatForward(
    settlement_days = settlement_days,
    quote           = quote,
    calendar        = NullCalendar(),
    daycounter      = Actual360()
)

try:
    df_1 = term_structure.discount(date_payment)
    print('rate: %f df_1: %f' % (quote.value, df_1))
except RuntimeError as exc:
    logger.error('Evaluation date and discount date issue.')
    logger.exception(exc)


########NEW FILE########
__FILENAME__ = swap
""" Port of the swap example of QuantLib SWIG to PyQL.

Warning: this is work in progress and currently not working.
"""
from quantlib.indexes.euribor import Euribor6M
from quantlib.pricingengines.swap import DiscountingSwapEngine
from quantlib.settings import Settings
from quantlib.quotes import SimpleQuote
from quantlib.termstructures.yields.api import DepositRateHelper, FraRateHelper
from quantlib.termstructures.yields.api import FuturesRateHelper, SwapRateHelper
from quantlib.termstructures.yields.api import YieldTermStructure
from quantlib.termstructures.yields.api import PiecewiseYieldCurve
from quantlib.time.api import Actual360, Date, November, TARGET, Weeks, Annual
from quantlib.time.api import Months, Years, Period, ModifiedFollowing
from quantlib.time.api import Unadjusted, Thirty360, Semiannual, Schedule
from quantlib.time.api import Forward, ActualActual, ISDA

# global data
calendar = TARGET()
todaysDate = Date(6,November,2001);
Settings.instance().evaluation_date = todaysDate
settlementDate = Date(8,November,2001);

# market quotes
deposits = { (1,Weeks): 0.0382,
             (1,Months): 0.0372,
             (3,Months): 0.0363,
             (6,Months): 0.0353,
             (9,Months): 0.0348,
             (1,Years): 0.0345 }

FRAs = { (3,6): 0.037125,
         (6,9): 0.037125,
         (9,12): 0.037125 }

futures = { Date(19,12,2001): 96.2875,
            Date(20,3,2002): 96.7875,
            Date(19,6,2002): 96.9875,
            Date(18,9,2002): 96.6875,
            Date(18,12,2002): 96.4875,
            Date(19,3,2003): 96.3875,
            Date(18,6,2003): 96.2875,
            Date(17,9,2003): 96.0875 }

swaps = { (2,Years): 0.037125,
          (3,Years): 0.0398,
          (5,Years): 0.0443,
          (10,Years): 0.05165,
          (15,Years): 0.055175 }

# convert them to Quote objects
#for n,unit in deposits.keys():
#    deposits[(n,unit)] = SimpleQuote(deposits[(n,unit)])
for n,m in FRAs.keys():
    FRAs[(n,m)] = SimpleQuote(FRAs[(n,m)])
for d in futures.keys():
    futures[d] = SimpleQuote(futures[d])
#for n,unit in swaps.keys():
#    swaps[(n,unit)] = SimpleQuote(swaps[(n,unit)])

# build rate helpers

dayCounter = Actual360()
settlementDays = 2
depositHelpers = [ DepositRateHelper(deposits[(n,unit)],
                                     Period(n,unit), settlementDays,
                                     calendar, ModifiedFollowing,
                                     False, dayCounter)
                   for n, unit in [(1,Weeks),(1,Months),(3,Months),
                                   (6,Months),(9,Months),(1,Years)] ]

dayCounter = Actual360()
settlementDays = 2
fraHelpers = [ FraRateHelper(FRAs[(n,m)],
                             n, m, settlementDays,
                             calendar, ModifiedFollowing,
                             False, dayCounter)
               for n, m in FRAs.keys() ]

dayCounter = Actual360()
months = 3
futuresHelpers = [ FuturesRateHelper(futures[d],
                                     d, months,
                                     calendar, ModifiedFollowing,
                                     True, dayCounter)
                   for d in futures.keys() ]

settlementDays = 2
fixedLegFrequency = Annual
fixedLegTenor = Period(1,Years)
fixedLegAdjustment = Unadjusted
fixedLegDayCounter = Thirty360()
floatingLegFrequency = Semiannual
floatingLegTenor = Period(6,Months)
floatingLegAdjustment = ModifiedFollowing
swapHelpers = [ SwapRateHelper.from_tenor(swaps[(n,unit)],
                               Period(n,unit), calendar,
                               fixedLegFrequency, fixedLegAdjustment,
                               fixedLegDayCounter, Euribor6M())
                for n, unit in swaps.keys() ]

### Curve building 

ts_daycounter = ActualActual(ISDA)

# term-structure construction
helpers = depositHelpers + swapHelpers
depoSwapCurve = PiecewiseYieldCurve(
    'discount', 'loglinear', settlementDate, helpers, ts_daycounter
)

helpers = depositHelpers[:2] + futuresHelpers + swapHelpers[1:]
depoFuturesSwapCurve = PiecewiseYieldCurve(
    'discount', 'loglinear',settlementDate, helpers, ts_daycounter
)

helpers = depositHelpers[:3] + fraHelpers + swapHelpers
depoFraSwapCurve = PiecewiseYieldCurve(
    'discount', 'loglinear', settlementDate, helpers, ts_daycounter
)


# Term structures that will be used for pricing:
discountTermStructure = YieldTermStructure(relinkable=True)
forecastTermStructure = YieldTermStructure(relinkable=True)

### SWAPS TO BE PRICED


nominal = 1000000
length = 5
maturity = calendar.advance(settlementDate,length,Years)
payFixed = True

fixedLegFrequency = Annual
fixedLegAdjustment = Unadjusted
fixedLegDayCounter = Thirty360()
fixedRate = 0.04

floatingLegFrequency = Semiannual
spread = 0.0
fixingDays = 2
index = Euribor6M(forecastTermStructure)
floatingLegAdjustment = ModifiedFollowing
floatingLegDayCounter = index.dayCounter()

fixedSchedule = Schedule(settlementDate, maturity,
                         fixedLegTenor, calendar,
                         fixedLegAdjustment, fixedLegAdjustment,
                         Forward, False)
floatingSchedule = Schedule(settlementDate, maturity,
                            floatingLegTenor, calendar,
                            floatingLegAdjustment, floatingLegAdjustment,
                            Forward, False)

spot = VanillaSwap(VanillaSwap.Payer, nominal,
                   fixedSchedule, fixedRate, fixedLegDayCounter,
                   floatingSchedule, index, spread,
                   floatingLegDayCounter)
spot.setPricingEngine(swapEngine)

forwardStart = calendar.advance(settlementDate,1,Years)
forwardEnd = calendar.advance(forwardStart,length,Years)
fixedSchedule = Schedule(forwardStart, forwardEnd,
                         fixedLegTenor, calendar,
                         fixedLegAdjustment, fixedLegAdjustment,
                         Forward, False)
floatingSchedule = Schedule(forwardStart, forwardEnd,
                            floatingLegTenor, calendar,
                            floatingLegAdjustment, floatingLegAdjustment,
                            Forward, False)

forward = VanillaSwap(VanillaSwap.Payer, nominal,
                      fixedSchedule, fixedRate, fixedLegDayCounter,
                      floatingSchedule, index, spread,
                      floatingLegDayCounter)

swapEngine = DiscountingSwapEngine(discountTermStructure)

forward.setPricingEngine(swapEngine)

# price on the bootstrapped curves

def formatPrice(p,digits=2):
    format = '%%.%df' % digits
    return format % p

def formatRate(r,digits=2):
    format = '%%.%df %%%%' % digits
    return format % (r*100)

headers = ("term structure", "net present value",
           "fair spread", "fair fixed rate" )
separator = " | "

format = ''
width = 0
for h in headers[:-1]:
    format += '%%%ds' % len(h)
    format += separator
    width += len(h) + len(separator)
format += '%%%ds' % len(headers[-1])
width += len(headers[-1])

rule = "-" * width
dblrule = "=" * width
tab = " " * 8

def report(swap, name):
    print format % (name, formatPrice(swap.NPV(),2),
                    formatRate(swap.fairSpread(),4),
                    formatRate(swap.fairRate(),4))

print dblrule
print "5-year market swap-rate = %s" % formatRate(swaps[(5,Years)].value())
print dblrule

# price on two different term structures

print tab + "5-years swap paying %s" % formatRate(fixedRate)
print separator.join(headers)
print rule

discountTermStructure.linkTo(depoFuturesSwapCurve)
forecastTermStructure.linkTo(depoFuturesSwapCurve)
report(spot,'depo-fut-swap')

discountTermStructure.linkTo(depoFraSwapCurve)
forecastTermStructure.linkTo(depoFraSwapCurve)
report(spot,'depo-FRA-swap')

print rule

# price the 1-year forward swap

print tab + "5-years, 1-year forward swap paying %s" % formatRate(fixedRate)
print rule

discountTermStructure.linkTo(depoFuturesSwapCurve)
forecastTermStructure.linkTo(depoFuturesSwapCurve)
report(forward,'depo-fut-swap')

discountTermStructure.linkTo(depoFraSwapCurve)
forecastTermStructure.linkTo(depoFraSwapCurve)
report(forward,'depo-FRA-swap')

# modify the 5-years swap rate and reprice

swaps[(5,Years)].setValue(0.046)

print dblrule
print "5-year market swap-rate = %s" % formatRate(swaps[(5,Years)].value())
print dblrule

print tab + "5-years swap paying %s" % formatRate(fixedRate)
print separator.join(headers)
print rule

discountTermStructure.linkTo(depoFuturesSwapCurve)
forecastTermStructure.linkTo(depoFuturesSwapCurve)
report(spot,'depo-fut-swap')

discountTermStructure.linkTo(depoFraSwapCurve)
forecastTermStructure.linkTo(depoFraSwapCurve)
report(spot,'depo-FRA-swap')

print rule

print tab + "5-years, 1-year forward swap paying %s" % formatRate(fixedRate)
print rule

discountTermStructure.linkTo(depoFuturesSwapCurve)
forecastTermStructure.linkTo(depoFuturesSwapCurve)
report(forward,'depo-fut-swap')

discountTermStructure.linkTo(depoFraSwapCurve)
forecastTermStructure.linkTo(depoFraSwapCurve)
report(forward,'depo-FRA-swap')

########NEW FILE########
__FILENAME__ = traits_example
""" Simple example pricing a European option using a Black&Scholes Merton process."""

import datetime
from traits.api import HasTraits, Enum, Float, Date, Property, Range
from traitsui.api import View, Item, HGroup, EnumEditor

from quantlib.instruments.option import Put, Call, EuropeanExercise
from quantlib.instruments.payoffs import PlainVanillaPayoff
from quantlib.instruments.option import VanillaOption
from quantlib.pricingengines.vanilla import AnalyticEuropeanEngine
from quantlib.processes.black_scholes_process import BlackScholesMertonProcess
from quantlib.quotes import SimpleQuote
from quantlib.settings import Settings
from quantlib.time.api import TARGET, Actual365Fixed, today, Date as QlDate
from quantlib.termstructures.yields.api import FlatForward
from quantlib.termstructures.volatility.equityfx.black_vol_term_structure \
    import BlackConstantVol


settings = Settings.instance()
calendar = TARGET()

offset = 366

todays_date = today() - offset
settlement_date = todays_date + 2

settings.evaluation_date = todays_date


class OptionValuation(HasTraits):

    # options parameters
    option_type = Enum(Put, Call)
    underlying = Float(36)
    strike = Float(40)
    dividend_yield = Range(0.0, 0.5)
    risk_free_rate = Range(0.0, 0.2)
    volatility = Range(0.0, 0.5)
    maturity = Date(datetime.date.today())
    daycounter = Actual365Fixed()

    option_npv = Property(
        depends_on=[
            'option_type', 'underlying', 'strike', 'dividend_yield',
            'risk_free_rate', 'volatility', 'maturity'
        ]
    )

    ### Traits view   ##########################################################

    traits_view = View(
        Item('option_type', editor=EnumEditor(values={Put:'Put', Call:'Call'})),
        'underlying', 'strike', 'dividend_yield', 'risk_free_rate',
        'volatility', 'maturity',
        HGroup( Item('option_npv', label='Option value'))
    )

    ### Private protocol   #####################################################

    def _get_option_npv(self):
        """ Suboptimal getter for the npv.

        FIXME: We currently have to recreate most of the objects because we do not
        expose enough of the QuantLib api.

        """

        # convert datetime object to QlDate
        maturity = QlDate.from_datetime(self.maturity)

        underlyingH = SimpleQuote(self.underlying)

        # bootstrap the yield/dividend/vol curves
        flat_term_structure = FlatForward(
            reference_date = settlement_date,
            forward = self.risk_free_rate,
            daycounter = self.daycounter
        )

        flat_dividend_ts = FlatForward(
            reference_date = settlement_date,
            forward = self.dividend_yield,
            daycounter = self.daycounter
        )

        flat_vol_ts = BlackConstantVol(
            settlement_date, calendar, self.volatility, self.daycounter
        )

        black_scholes_merton_process = BlackScholesMertonProcess(
            underlyingH, flat_dividend_ts, flat_term_structure,flat_vol_ts
        )

        payoff = PlainVanillaPayoff(self.option_type, self.strike)

        european_exercise = EuropeanExercise(maturity)

        european_option = VanillaOption(payoff, european_exercise)

        analytic_european_engine = AnalyticEuropeanEngine(black_scholes_merton_process)

        european_option.set_pricing_engine(analytic_european_engine)

        return european_option.net_present_value

if __name__ == '__main__':

    model = OptionValuation()
    model.configure_traits()


### EOF #######################################################################

########NEW FILE########
__FILENAME__ = compounding
#Compounding style
Simple = 0                 # 1+rt
Compounded = 1             # (1+r)^t
Continuous = 2             # e^{rt}
SimpleThenCompounded = 3   # Simple up to the first period then Compounded


def compounding_from_name(name):
    dic = {'Simple': Simple,
           'Compounded': Compounded,
           'Continuous': Continuous,
           'SimpleThenCompounded': SimpleThenCompounded}

    try:
        cp = dic[name]
        return cp
    except ValueError:
        print('Compounding style %s is unknown' % name)

########NEW FILE########
__FILENAME__ = api
"""
 Copyright (C) 2014, Enthought Inc
 Copyright (C) 2014, Patrick Henaff

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
"""

from .libor import Libor
from .euribor import Euribor, Euribor6M
from .ibor_index import IborIndex

########NEW FILE########
__FILENAME__ = api
from .bonds import FixedRateBond, ZeroCouponBond
from .credit_default_swap import CreditDefaultSwap
from .option import EuropeanExercise, AmericanExercise, VanillaOption
from .option import DividendVanillaOption, EuropeanOption
from .payoffs import Put, Call, PlainVanillaPayoff, PAYOFF_TO_STR

########NEW FILE########
__FILENAME__ = swap
import collections
from quantlib.util.prettyprint import prettyprint


class DataStore(object):
    _labels = None
    _data = None
    _labels_short = None

    @classmethod
    def match(**kwargs):
        """
        Match all records on keys
        """


class SwapData(object):
    _labels = ["market",
               "currency",
               "settlement_days",
               "fixed_leg_period",
               "fixed_leg_daycount",
               "fixed_leg_convention",
               "floating_leg_reference",
               "floating_leg_period",
               "floating_leg_daycount",
               "floating_leg_convention",
               "calendar"]

    # column labels for pretty printing
    _labels_short = ["market", "currency", "settle", "fx per",
                     "fx d/c", "fx conv",
                     "fl ref", "fl per", "fl d/c", "fl conv",
                     "calendar"]

    _data = [
        ("USD(NY)", "USD", 2, "6M", "30/360", "ModifiedFollowing",
         "LIBOR", "3M", "ACT/360", "ModifiedFollowing", "TARGET"),
        ("USD(LONDON)", "USD", 2, "1Y", "ACT/360", "ModifiedFollowing",
         "LIBOR", "3M", "ACT/360", "ModifiedFollowing", "TARGET"),
        ("EUR:1Y", "EUR", 2, "1Y", "30/360", "Unadjusted",
         "Euribor", "3M", "ACT/360", "ModifiedFollowing", "TARGET"),
        ("EUR:>1Y", "EUR", 2, "1Y", "30/360", "Unadjusted",
         "Euribor", "6M", "ACT/360", "ModifiedFollowing", "TARGET"),
        ("GBP:1Y", "GBP", 0, "1Y", "ACT/365", "ModifiedFollowing",
         "LIBOR", "3M", "ACT/365", "ModifiedFollowing", "GBR"),
        ("GBP:>1Y", "GBP", 0, "6M", "ACT/365", "ModifiedFollowing",
         "LIBOR", "6M", "ACT/365", "ModifiedFollowing", "GBR"),
        ("JPY(Tibor)", "JPY", 2, "6M", "ACT/365", "ModifiedFollowing",
         "Tibor", "3M", "ACT/365", "ModifiedFollowing", "JPN"),
        ("JPY(Libor)", "JPY", 2, "6M", "ACT/365", "ModifiedFollowing",
         "LIBOR", "6M", "ACT/360", "ModifiedFollowing", "JPN"),
        ("CHF:1Y", "CHF", 2, "1Y", "30/360", "ModifiedFollowing",
         "LIBOR", "3M", "ACT/360", "ModifiedFollowing", "CHE"),
        ("CHF:>1Y", "CHF", 2, "1Y", "30/360", "ModifiedFollowing",
         "LIBOR", "6M", "ACT/360", "ModifiedFollowing", "CHE")
    ]

    Row = collections.namedtuple("Row", _labels[1:])
    _dic = {}
    for line in _data:
        row = Row._make(line[1:])
        _dic[line[0]] = row

    @classmethod
    def help(self):
        _data_t = map(list, zip(*self._data))
        return prettyprint(self._labels_short, 'ssissssssss', _data_t)

    @classmethod
    def params(self, market):
        return self._dic[market]

    @classmethod
    def match(self, params):
        """
        Returns the row(s) that match the parameters
        """

        res = []
        for k, v in self._dic.items():
            row = vars(v)
            is_match = all([params[kp] == row[kp] for kp in params])
            if is_match:
                res.append(row)
        return res

########NEW FILE########
__FILENAME__ = market
from quantlib.termstructures.yields.api import (
    FixedRateBondHelper, DepositRateHelper, FuturesRateHelper, SwapRateHelper)

from quantlib.quotes import SimpleQuote

from quantlib.time.api import (Date, Period, Calendar, Years,
                               Days, JointCalendar, UnitedStates,
                               UnitedKingdom)
from quantlib.time.date import (code_to_frequency, pydate_from_qldate,
                                qldate_from_pydate)
from quantlib.time.daycounter import DayCounter

from quantlib.settings import Settings
from quantlib.indexes.api import IborIndex

from quantlib.util.converter import pydate_to_qldate

from quantlib.termstructures.yields.piecewise_yield_curve import \
    term_structure_factory

from quantlib.market.conventions.swap import SwapData
from quantlib.time.businessdayconvention import BusinessDayConvention

from quantlib.instruments.swap import VanillaSwap, Payer
from quantlib.pricingengines.swap import DiscountingSwapEngine
from quantlib.time.schedule import Schedule, Forward
from quantlib.termstructures.yields.api import (
    YieldTermStructure)
import quantlib.time.imm as imm

from quantlib.time.api import Backward, Following


def libor_market(market='USD(NY)', **kwargs):
    m = IborMarket('USD Libor', market, **kwargs)
    return m


def next_imm_date(reference_date, tenor):
    """
    Third Wednesday of contract month
    """
    dt = qldate_from_pydate(reference_date)
    for k in range(tenor):
        tmp = imm.next_date(dt)
        dt = pydate_to_qldate(tmp)
    return pydate_from_qldate(dt)


def make_rate_helper(market, quote, reference_date=None):
    """
    Wrapper for deposit and swaps rate helpers makers
    TODO: class method of RateHelper?
    """

    rate_type, tenor, quote_value = quote

    if(rate_type == 'SWAP'):
        libor_index = market._floating_rate_index
        spread = SimpleQuote(0)
        fwdStart = Period(0, Days)
        helper = SwapRateHelper.from_tenor(
            quote_value,
            Period(tenor),
            market._floating_rate_index.fixing_calendar,
            code_to_frequency(market._params.fixed_leg_period),
            BusinessDayConvention.from_name(
                market._params.fixed_leg_convention),
            DayCounter.from_name(market._params.fixed_leg_daycount),
            libor_index, spread, fwdStart)
    elif(rate_type == 'DEP'):
        end_of_month = True
        helper = DepositRateHelper(
            quote_value,
            Period(tenor),
            market._params.settlement_days,
            market._floating_rate_index.fixing_calendar,
            market._floating_rate_index.business_day_convention,
            end_of_month,
            DayCounter.from_name(market._deposit_daycount))
    elif(rate_type == 'ED'):
        if reference_date is None:
            raise Exception("Reference date needed with ED Futures data")

        forward_date = next_imm_date(reference_date, tenor)

        helper = FuturesRateHelper(
            rate =SimpleQuote(quote_value),
            imm_date = qldate_from_pydate(forward_date),
            length_in_months = 3,
            calendar = market._floating_rate_index.fixing_calendar,
            convention = market._floating_rate_index.business_day_convention,
            end_of_month = True,
            day_counter = DayCounter.from_name(
                market._params.floating_leg_daycount))

    elif rate_type.startswith('ER'):
        # TODO For Euribor futures, we found it useful to supply the `imm_date`
        # parameter directly, instead of as a number of periods from the
        # evaluation date, as for ED futures. To achieve this, we pass the
        # `imm_date` in the `tenor` field of the quote.
        helper = FuturesRateHelper(
            rate=SimpleQuote(quote_value),
            imm_date=tenor,
            length_in_months=3,
            calendar=market._floating_rate_index.fixing_calendar,
            convention=market._floating_rate_index.business_day_convention,
            end_of_month=True,
            day_counter=DayCounter.from_name(
                market._params.floating_leg_daycount))
    else:
        raise Exception("Rate type %s not supported" % rate_type)

    return helper


def make_eurobond_helper(
        market, clean_price, coupons, tenor, issue_date, maturity):

    """ Wrapper for bond helpers.

    FIXME: This convenience method has some conventions specifically
    hardcoded for Eurobonds. These should be moved to the market.

    """

    # Create schedule based on market and bond parameters.
    index = market._floating_rate_index
    schedule = Schedule(
        issue_date,
        maturity,
        Period(tenor),
        index.fixing_calendar,
        index.business_day_convention,
        index.business_day_convention,
        Backward,  # Date generation rule
        index.end_of_month,
        )

    daycounter = DayCounter.from_name("Actual/Actual (Bond)")
    helper = FixedRateBondHelper(
        SimpleQuote(clean_price),
        market._params.settlement_days,
        100.0,
        schedule,
        coupons,
        daycounter,
        Following,  # Payment convention
        100.0,
        issue_date)

    return helper


class Market:
    """
    Abstract Market class.
    A Market is a virtual environment where financial assets are traded.
    It defines the conventions for quoting prices and yield,
    for measuring time, etc.
    """

    def __init__(self, name):
        self._name = name

    @property
    def name(self):
        return self._name


class FixedIncomeMarket(Market):
    """
    A Fixed Income Market, defined by:
    - a list of benchmarks instruments (deposits, FRA, swaps,
      EuroDollar futures, bonds)
    - a set of market conventions, needed to interpreted the quoted
      prices of benchmark instruments, and for computing
      derived quantities (yield curves)

    This class models an homogeneous market: It is assumed that the
    market conventions for all fixed rate instruments, including swaps,
    are all consistent. The conventions may vary between the fixed rate
    instruments and the deposit instruments.
    """

    pass


class IborMarket(FixedIncomeMarket):

    def __init__(self, name, market, **kwargs):

        params = SwapData.params(market)
        params = params._replace(**kwargs)
        self._params = params
        self._name = name
        self._market = market

        # floating rate index
        index = IborIndex.from_name(market, **kwargs)
        self._floating_rate_index = index

        self._deposit_daycount = params.floating_leg_daycount
        self._termstructure_daycount = 'ACT/365'

        self._eval_date = None
        self._quotes = None
        self._termstructure = None

        self._discount_term_structure = None
        self._forecast_term_structure = None

        self._rate_helpers = []
        self._quotes = []

    def __str__(self):
        return 'Fixed Income Market: %s' % self._name

    def _set_evaluation_date(self, dt_obs):
        if(~isinstance(dt_obs, Date)):
            dt_obs = pydate_to_qldate(dt_obs)
        settings = Settings()
        calendar = JointCalendar(UnitedStates(), UnitedKingdom())
        # must be a business day
        eval_date = calendar.adjust(dt_obs)
        settings.evaluation_date = eval_date
        self._eval_date = eval_date
        return eval_date

    def set_quotes(self, dt_obs, quotes):

        self._quotes.extend(quotes)
        eval_date = self._set_evaluation_date(dt_obs)

        for quote in quotes:
            # construct rate helper
            helper = make_rate_helper(self, quote, eval_date)
            self._rate_helpers.append(helper)

    def set_bonds(self, dt_obs, quotes):
        """ Supply the market with a set of bond quotes.

        The `quotes` parameter must be a list of quotes of the form
        (clean_price, coupons, tenor, issue_date, maturity). For more
        information about the format of the individual fields, see
        the documentation for :meth:`add_bond_quote`.

        """

        self._quotes.extend(quotes)
        self._set_evaluation_date(dt_obs)

        for quote in quotes:
            self.add_bond_quote(*quote)

    def add_bond_quote(
            self, clean_price, coupons, tenor, issue_date, maturity):
        """
        Add a bond quote to the market.

        Parameters
        ----------
        clean_price : real
            Clean price of the bond.
        coupons : real or list(real)
            Interest rates paid by the bond.
        tenor : str
            Tenor of the bond.
        issue_date, maturity : Date instance
            Issue date and maturity of the bond.

        """

        if not isinstance(coupons, (list, tuple)):
            coupons = [coupons]

        helper = make_eurobond_helper(
            self, clean_price, coupons, tenor, issue_date, maturity)
        self._rate_helpers.append(helper)

    @property
    def calendar(self):
        return self._params.calendar

    @property
    def settlement_days(self):
        return self._params.settlement_days

    @property
    def fixed_rate_frequency(self):
        return self._params.fixed_rate_frequency

    @property
    def fixed_rate_convention(self):
        return self._params.fixed_instrument_convention

    @property
    def fixed_rate_daycounter(self):
        return self._params.fixed_rate_daycounter

    @property
    def termstructure_daycounter(self):
        return self._termstructure_daycounter

    @property
    def reference_date(self):
        return 0

    @property
    def max_date(self):
        return 0

    def to_str(self):
        str = \
            "Ibor Market %s\n" % self._name + \
            "Number of settlement days: %d\n" % self._params.settlement_days +\
            "Fixed rate frequency: %s\n" % self._params.fixed_rate_frequency +\
            "Fixed rate convention: %s\n" % self._params.fixed_instrument_convention +\
            "Fixed rate daycount: %s\n" % self._params.fixed_instrument_daycounter +\
            "Term structure daycount: %s\n" % self._termstructure_daycount + \
            "Floating rate index: %s\n" % self._floating_rate_index + \
            "Deposit daycount: %s\n" % self._deposit_daycount + \
            "Calendar: %s\n" % self._params.calendar

        return str

    def bootstrap_term_structure(self, interpolator='loglinear'):
        tolerance = 1.0e-15
        settings = Settings()
        calendar = JointCalendar(UnitedStates(), UnitedKingdom())
        # must be a business day
        eval_date = self._eval_date
        settings.evaluation_date = eval_date
        settlement_days = self._params.settlement_days
        settlement_date = calendar.advance(eval_date, settlement_days, Days)
        # must be a business day
        settlement_date = calendar.adjust(settlement_date)
        ts = term_structure_factory(
            'discount', interpolator,
            settlement_date, self._rate_helpers,
            DayCounter.from_name(self._termstructure_daycount),
            tolerance)
        self._term_structure = ts
        self._discount_term_structure = YieldTermStructure(relinkable=True)
        self._discount_term_structure.link_to(ts)

        self._forecast_term_structure = YieldTermStructure(relinkable=True)
        self._forecast_term_structure.link_to(ts)

        return ts

    def discount(self, date_maturity, extrapolate=True):
        return self._discount_term_structure.discount(date_maturity)

    def create_fixed_float_swap(self, settlement_date, length, fixed_rate,
                                floating_spread, **kwargs):
        """
        Create a fixed-for-float swap given:
        - settlement date
        - length in years
        - additional arguments to modify market default parameters
        """

        _params = self._params._replace(**kwargs)

        index = IborIndex.from_name(self._market,
                                    self._forecast_term_structure,
                                    **kwargs)

        swap_type = Payer
        nominal = 100.0
        fixed_convention = \
            BusinessDayConvention.from_name(_params.fixed_leg_convention)
        floating_convention = \
            BusinessDayConvention.from_name(_params.floating_leg_convention)
        fixed_frequency = \
            code_to_frequency(_params.fixed_leg_period)
        floating_frequency = code_to_frequency(_params.floating_leg_period)
        fixed_daycount = DayCounter.from_name(_params.fixed_leg_daycount)
        float_daycount = DayCounter.from_name(_params.floating_leg_daycount)
        calendar = Calendar.from_name(_params.calendar)

        maturity = calendar.advance(settlement_date, length, Years,
                                    convention=floating_convention)

        fixed_schedule = Schedule(settlement_date, maturity,
                                  Period(fixed_frequency), calendar,
                                  fixed_convention, fixed_convention,
                                  Forward, False)

        float_schedule = Schedule(settlement_date, maturity,
                                  Period(floating_frequency),
                                  calendar, floating_convention,
                                  floating_convention,
                                  Forward, False)

        swap = VanillaSwap(swap_type, nominal, fixed_schedule, fixed_rate,
                           fixed_daycount, float_schedule, index,
                           floating_spread, float_daycount, fixed_convention)

        engine = DiscountingSwapEngine(self._discount_term_structure,
                                       False,
                                       settlementDate=settlement_date,
                                       npvDate=settlement_date)

        swap.set_pricing_engine(engine)

        return swap

########NEW FILE########
__FILENAME__ = fixed_income
"""
 Copyright (C) 2013, Enthought Inc
 Copyright (C) 2013, Patrick Henaff

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
"""

import numpy as np
from quantlib.instruments.bonds import (
    FixedRateBond
)

from quantlib.compounding import Compounded

from quantlib.pricingengines.bond import DiscountingBondEngine
from quantlib.time.calendar import (
    TARGET, Unadjusted, ModifiedFollowing, Following)

from quantlib.time.calendars.null_calendar import NullCalendar
from quantlib.time.date import (
    Date, Days, Period, Years, str_to_frequency)

from quantlib.time.schedule import Schedule, Backward
from quantlib.settings import Settings
from quantlib.termstructures.yields.api import (
    FlatForward, YieldTermStructure
)

from quantlib.time.daycounter import DayCounter

from quantlib.util.converter import pydate_to_qldate

from quantlib.mlab.util import common_shape, array_call

DEBUG = False


def bndprice(bond_yield, coupon_rate, pricing_date, maturity_date,
             period, basis, compounding_frequency=None):
    """
    Calculate price and accrued interest

    Args:

    bond_yield:    compound yield to maturity
    coupon_rate:   coupon rate in decimal form (5% = .05)
    pricing_date:  the date where market data is observed. Settlement
                   is by default 2 days after pricing_date
    maturity_date: ... bond
    period:        periodicity of coupon payments
    basis:         day count basis for computing accrued interest
    compounding_frequency: ... of yield. By default: annual for ISMA,
                           semi annual otherwise


    Returns:
    price: clean price
    ac:    accrued interest

    """

    args = locals()
    the_shape, shape  = common_shape(args)

    if DEBUG:
        print(the_shape)
        print(shape)
        print(values)

    all_scalars = np.all([shape[key][0] == 'scalar' for key in shape])

    if all_scalars:
        price, ac = _bndprice(**args)
    else:
        res = array_call(_bndprice, shape, args)
        price = np.reshape([x[0] for x in res], the_shape)
        ac = np.reshape([x[1] for x in res], the_shape)
    return (price, ac)


def _bndprice(bond_yield, coupon_rate, pricing_date, maturity_date,
              period, basis, compounding_frequency):
    """
    Clean price and accrued interest of a bond
    """

    _period = str_to_frequency(period)

    evaluation_date = pydate_to_qldate(pricing_date)

    settings = Settings()
    settings.evaluation_date = evaluation_date

    calendar = TARGET()
    termination_date = pydate_to_qldate(maturity_date)

    # effective date must be before settlement date, but do not
    # care about exact issuance date of bond

    effective_date = Date(termination_date.day, termination_date.month,
                          evaluation_date.year)
    effective_date = calendar.advance(
        effective_date, -1, Years, convention=Unadjusted)

    settlement_date = calendar.advance(
            evaluation_date, 2, Days, convention=ModifiedFollowing)

    face_amount = 100.0
    redemption = 100.0

    fixed_bond_schedule = Schedule(
        effective_date,
        termination_date,
        Period(_period),
        calendar,
        ModifiedFollowing,
        ModifiedFollowing,
        Backward
    )

    issue_date = effective_date
    cnt = DayCounter.from_name(basis)
    settlement_days = 2

    bond = FixedRateBond(
                settlement_days,
                face_amount,
                fixed_bond_schedule,
                [coupon_rate],
                cnt,
                Following,
                redemption,
                issue_date
    )

    discounting_term_structure = YieldTermStructure(relinkable=True)

    cnt_yield = DayCounter.from_name('Actual/Actual (Historical)')

    flat_term_structure = FlatForward(
        settlement_days=2,
        forward=bond_yield,
        calendar=NullCalendar(),
        daycounter=cnt_yield,
        compounding=Compounded,
        frequency=_period)

    discounting_term_structure.link_to(flat_term_structure)

    engine = DiscountingBondEngine(discounting_term_structure)

    bond.set_pricing_engine(engine)

    price = bond.clean_price
    ac = bond.accrued_amount(pydate_to_qldate(settlement_date))

    return (price, ac)


def cfamounts(coupon_rate, pricing_date, maturity_date,
             period, basis):
    """
    Calculate price and accrued interest

    Args:

    coupon_rate:   coupon rate in decimal form (5% = .05)
    pricing_date:  the date where market data is observed. Settlement
                   is by default 2 days after pricing_date
    maturity_date: ... bond
    period:        periodicity of coupon payments
    basis:         day count basis for computing accrued interest


    Returns:
    cf_amounts: cash flow amount
    cf_dates:   cash flow dates

    """

    args = locals()
    the_shape, shape  = common_shape(args)

    all_scalars = np.all([shape[key][0] == 'scalar' for key in shape])

    if all_scalars:
        cf_a, cf_d = _cfamounts(**args)
    else:
        raise Exception('Only scalar inputs are handled')

    return (cf_a, cf_d)


def _cfamounts(coupon_rate, pricing_date, maturity_date,
              period, basis):
    """
    cash flow schedule
    """

    _period = str_to_frequency(period)

    evaluation_date = pydate_to_qldate(pricing_date)

    settings = Settings()
    settings.evaluation_date = evaluation_date

    calendar = TARGET()
    termination_date = pydate_to_qldate(maturity_date)

    # effective date must be before settlement date, but do not
    # care about exact issuance date of bond

    effective_date = Date(termination_date.day, termination_date.month,
                          evaluation_date.year)
    effective_date = calendar.advance(
        effective_date, -1, Years, convention=Unadjusted)

    face_amount = 100.0
    redemption = 100.0

    fixed_bond_schedule = Schedule(
        effective_date,
        termination_date,
        Period(_period),
        calendar,
        ModifiedFollowing,
        ModifiedFollowing,
        Backward
    )

    issue_date = effective_date
    cnt = DayCounter.from_name(basis)
    settlement_days = 2

    bond = FixedRateBond(
                settlement_days,
                face_amount,
                fixed_bond_schedule,
                [coupon_rate],
                cnt,
                Following,
                redemption,
                issue_date)

    res = zip(*bond.cashflows)

    return(res)

########NEW FILE########
__FILENAME__ = option_pricing
"""
 Copyright (C) 2012, Enthought Inc
 Copyright (C) 2012, Patrick Henaff

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
"""

import numpy as np
import quantlib.reference.names as nm

from quantlib.instruments.option import EuropeanExercise, VanillaOption
from quantlib.instruments.payoffs import PlainVanillaPayoff, Put, Call
from quantlib.models.equity.heston_model import HestonModel
from quantlib.pricingengines.vanilla.vanilla import AnalyticHestonEngine
from quantlib.processes.heston_process import HestonProcess
from quantlib.quotes import SimpleQuote
from quantlib.settings import Settings
from quantlib.util.converter import pydate_to_qldate, df_to_zero_curve

from quantlib.instruments.api import EuropeanOption
from quantlib.pricingengines.api import AnalyticEuropeanEngine
from quantlib.processes.api import BlackScholesMertonProcess
from quantlib.termstructures.yields.api import FlatForward
from quantlib.termstructures.volatility.api import BlackConstantVol
from quantlib.time.api import today, NullCalendar, ActualActual

from quantlib.time.date import (Period, Days)
from quantlib.mlab.util import common_shape, array_call


def heston_pricer(trade_date, options, params, rates, spot):
    """
    Price a list of European options with heston model.

    """

    spot = SimpleQuote(spot)

    risk_free_ts = df_to_zero_curve(rates[nm.INTEREST_RATE], trade_date)
    dividend_ts = df_to_zero_curve(rates[nm.DIVIDEND_YIELD], trade_date)

    process = HestonProcess(risk_free_ts, dividend_ts, spot, **params)

    model = HestonModel(process)
    engine = AnalyticHestonEngine(model, 64)

    settlement_date = pydate_to_qldate(trade_date)

    settings = Settings()
    settings.evaluation_date = settlement_date

    modeled_values = np.zeros(len(options))

    for index, row in options.T.iteritems():

        expiry_date = row[nm.EXPIRY_DATE]
        strike = row[nm.STRIKE]

        option_type = Call if row[nm.OPTION_TYPE] == nm.CALL_OPTION else Put

        payoff = PlainVanillaPayoff(option_type, strike)

        expiry_qldate = pydate_to_qldate(expiry_date)
        exercise = EuropeanExercise(expiry_qldate)

        option = VanillaOption(payoff, exercise)
        option.set_pricing_engine(engine)

        modeled_values[index] = option.net_present_value

    prices = options.filter(items=[nm.EXPIRY_DATE, nm.STRIKE,
                                   nm.OPTION_TYPE, nm.SPOT])
    prices[nm.PRICE] = modeled_values
    prices[nm.TRADE_DATE] = trade_date

    return prices


def blsprice(spot, strike, risk_free_rate, time, volatility,
             option_type='Call', dividend=0.0, calc='price'):

    """
    Matlab's blsprice + greeks (delta, gamma, theta, rho, vega, lambda)
    """
    args = locals()
    the_shape, shape = common_shape(args)

    all_scalars = np.all([shape[key][0] == 'scalar' for key in shape])

    if all_scalars:
        res = _blsprice(**args)
    else:
        res = array_call(_blsprice, shape, args)
        res = np.reshape(res, the_shape)
    return res


def _blsprice(spot, strike, risk_free_rate, time, volatility,
             option_type='Call', dividend=0.0, calc='price'):
    """
    Black-Scholes option pricing model + greeks.
    """
    _spot = SimpleQuote(spot)

    daycounter = ActualActual()
    risk_free_ts = FlatForward(today(), risk_free_rate, daycounter)
    dividend_ts = FlatForward(today(), dividend, daycounter)
    volatility_ts = BlackConstantVol(today(), NullCalendar(),
                                     volatility, daycounter)

    process = BlackScholesMertonProcess(_spot, dividend_ts,
                                        risk_free_ts, volatility_ts)

    exercise_date = today() + Period(time * 365, Days)
    exercise = EuropeanExercise(exercise_date)

    payoff = PlainVanillaPayoff(option_type, strike)

    option = EuropeanOption(payoff, exercise)
    engine = AnalyticEuropeanEngine(process)
    option.set_pricing_engine(engine)

    if calc == 'price':
        res = option.npv
    elif calc == 'delta':
        res = option.delta
    elif calc == 'gamma':
        res = option.gamma
    elif calc == 'theta':
        res = option.theta
    elif calc == 'rho':
        res = option.rho
    elif calc == 'vega':
        res = option.vega
    elif calc == 'lambda':
        res = option.delta * spot / option.npv
    else:
        raise ValueError('calc type %s is unknown' % calc)

    return res


def blsimpv(price, spot, strike, risk_free_rate, time,
             option_type='Call', dividend=0.0):

    args = locals()
    the_shape, shape = common_shape(args)

    all_scalars = np.all([shape[key][0] == 'scalar' for key in shape])

    if all_scalars:
        res = _blsimpv(**args)
    else:
        res = array_call(_blsimpv, shape, args)

    return res


def _blsimpv(price, spot, strike, risk_free_rate, time,
             option_type='Call', dividend=0.0):

    spot = SimpleQuote(spot)
    daycounter = ActualActual()
    risk_free_ts = FlatForward(today(), risk_free_rate, daycounter)
    dividend_ts = FlatForward(today(), dividend, daycounter)
    volatility_ts = BlackConstantVol(today(), NullCalendar(),
                                     .3, daycounter)

    process = BlackScholesMertonProcess(spot, dividend_ts,
                                        risk_free_ts, volatility_ts)

    exercise_date = today() + Period(time * 365, Days)
    exercise = EuropeanExercise(exercise_date)

    payoff = PlainVanillaPayoff(option_type, strike)

    option = EuropeanOption(payoff, exercise)
    engine = AnalyticEuropeanEngine(process)
    option.set_pricing_engine(engine)

    accuracy = 0.001
    max_evaluations = 1000
    min_vol = 0.01
    max_vol = 2

    vol = option.implied_volatility(price, process,
            accuracy,
            max_evaluations,
            min_vol,
            max_vol)

    return vol

########NEW FILE########
__FILENAME__ = term_structure
"""
 Copyright (C) 2013, Enthought Inc
 Copyright (C) 2013, Patrick Henaff

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
"""

from quantlib.time.calendar import TARGET
from quantlib.settings import Settings
from quantlib.time.schedule import Schedule

from quantlib.time.date import (Period, Days, Months)
from quantlib.time.daycounter import DayCounter
from quantlib.compounding import compounding_from_name

from quantlib.util.converter import qldate_to_pydate, pydate_to_qldate

from quantlib.util.rates import make_term_structure


def zbt_libor_yield(instruments, yields, pricing_date,
                    basis='Actual/Actual (Bond)',
                    compounding_freq='Continuous',
                    maturity_dates=None):
    """
    Bootstrap a zero-coupon curve from libor rates and swap yields

    Args:

    insruments:    list of instruments, of the form Libor?M for Libor rates
                   and Swap?Y for swap rates
    yields:        market rates
    pricing_date:  the date where market data is observed. Settlement
                   is by default 2 days after pricing_date

    Optional:

    compounding_frequency: ... of zero-coupon rates. By default:
                   'Continuous'

    Returns:

    zero_rate:     zero-coupon rate
    maturity_date: ... of corresponding rate
    """

    calendar = TARGET()

    settings = Settings()
    # must be a business day
    eval_date = calendar.adjust(pydate_to_qldate(pricing_date))
    settings.evaluation_date = eval_date

    rates = dict(zip(instruments, yields))
    ts = make_term_structure(rates, pricing_date)

    cnt = DayCounter.from_name(basis)

    if maturity_dates is None:
        # schedule of maturity dates from settlement date to last date on
        # the term structure

        s = Schedule(effective_date=ts.reference_date,
                     termination_date=ts.max_date,
                     tenor=Period(1, Months),
                     calendar=TARGET())
        maturity_dates = [qldate_to_pydate(dt) for dt in s.dates()]

    cp_freq = compounding_from_name(compounding_freq)
    zc = [ts.zero_rate(date=pydate_to_qldate(dt),
                       day_counter=cnt,
                       compounding=cp_freq).rate for dt in maturity_dates]

    return (maturity_dates, zc)

########NEW FILE########
__FILENAME__ = util
"""
 Copyright (C) 2013, Enthought Inc
 Copyright (C) 2013, Patrick Henaff

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
"""

import numpy as np
from numbers import Number
from datetime import date


def common_shape(args):
    """
    Inspect the input arguments to a function and
    verify that the shapes are compatible, in a matlab sense:
    either scalar or arrays of identical shapes
    """

    # all non-scalar arguments must have the same shape, do not care if
    # it is a numpy type or not

    the_shape = None
    res = {}
    for a, value in args.items():

        if isinstance(value, Number) or \
           isinstance(value, basestring) or \
           isinstance(value, date):
            res[a] = ('scalar', None)
        else:
            if(the_shape is None):
                the_shape = np.shape(value)
                res[a] = ('array', the_shape)
            elif(the_shape == np.shape(value)):
                res[a] = ('array', the_shape)
            else:
                raise ValueError('Wrong shape for argument %s. \
                Excepting a scalar or array of shape %s' % \
                                 (a, str(the_shape)))

    return (the_shape, res)


def array_call(foo, shape, values):
    """
    Call function foo with all elements in array arguments
    return an output of same shape as array input elements
    """

    array_vars = [k for k, v in shape.items() if v[0] == 'array']
    scalar_vars = [k for k, v in shape.items() if v[0] == 'scalar']

    for key in array_vars:
        values[key] = np.ravel(values[key])

    nb_items = len(values[array_vars[0]])

    input_args = dict((key, 0) for key in shape)

    # fill scalar arguments once
    for key in scalar_vars:
        input_args[key] = values[key]

    # iterate through elements of array arguments
    # output is a list because foo may return a list.
    res = list()
    for i in range(nb_items):
        for key in array_vars:
            input_args[key] = values[key][i]
        res.append(foo(**input_args))

    return res

########NEW FILE########
__FILENAME__ = api
from .vanilla.vanilla import VanillaOptionEngine, AnalyticEuropeanEngine
from .vanilla.vanilla import AnalyticHestonEngine
from .vanilla.vanilla import BaroneAdesiWhaleyApproximationEngine
from .vanilla.vanilla import BatesEngine, BatesDetJumpEngine
from .vanilla.vanilla import BatesDoubleExpEngine, BatesDoubleExpDetJumpEngine
from .vanilla.vanilla import AnalyticDividendEuropeanEngine
from .vanilla.vanilla import FDDividendAmericanEngine, FDAmericanEngine

########NEW FILE########
__FILENAME__ = api
from .black_scholes_process import BlackScholesMertonProcess

########NEW FILE########
__FILENAME__ = data_structures
""" Definition of canonical data structures used in the
high-level functions of pyql. The data structures are all pandas DataFrames,
with defined column names and types. The data frames are empty, and should be
used as follows:

>>> import quantlib.reference.data_structures as df
>>> x = df.option_quotes.reindex(index=range(10))
"""

import numpy as np
from pandas import DataFrame

import quantlib.reference.names as nm


def option_quotes_template():

    return DataFrame(np.empty((0,), dtype=[(nm.TRADE_DATE, 'object'),
                                           (nm.STRIKE, 'f4'),
                                           (nm.EXPIRY_DATE, 'object'),
                                           (nm.OPTION_TYPE, 'a1'),
                                           (nm.SPOT, 'f4'),
                                           (nm.EXERCISE_STYLE, 'a4'),
                                           (nm.PRICE_BID, 'f4'),
                                           (nm.PRICE_ASK, 'f4')]))


def riskfree_dividend_template():
    return DataFrame.from_records(np.empty((1,),
                                  dtype=[(nm.DIVIDEND_YIELD, 'f4'),
                                         (nm.INTEREST_RATE, 'f4'),
                                         (nm.MATURITY_DATE, 'object')]),
                                  index=nm.MATURITY_DATE)

########NEW FILE########
__FILENAME__ = names
"""
This module defines string constants that are used as panda
    column names.
"""
# General

EXPIRY_DATE = 'dtExpiry'
TRADE_DATE = 'dtTrade'

SPOT = 'Spot'
PRICE_BID = 'PBid'
PRICE_ASK = 'PAsk'
PRICE = 'Price'

INTEREST_RATE = 'iRate'
DIVIDEND_YIELD = 'dRate'
MATURITY_DATE = 'dtMaturity'

# Options

OPTION_TYPE = 'Type'
EXERCISE_STYLE = 'Style'
STRIKE = 'Strike'
ATMVOL = 'ATMVol'
FORWARD = 'Fwd'
QUICKDELTA = 'QuickDelta'

IVOL_ASK = 'IVAsk'
IVOL_BID = 'IVBid'
IVOL_MID = 'IVMid'

CALL_OPTION = 'C'
PUT_OPTION = 'P'
EURO_EXERCISE = 'Euro'
AMER_EXERCISE = 'Amer'

########NEW FILE########
__FILENAME__ = api
from .default_probability_helpers import SpreadCdsHelper, CdsHelper
from .piecewise_default_curve import PiecewiseDefaultCurve

########NEW FILE########
__FILENAME__ = api
from .equityfx.black_vol_term_structure import BlackVolTermStructure
from .equityfx.black_vol_term_structure import BlackConstantVol

########NEW FILE########
__FILENAME__ = api
from .bond_helpers import BondHelper, FixedRateBondHelper
from .flat_forward import FlatForward
from .piecewise_yield_curve import PiecewiseYieldCurve
from .rate_helpers import (
    RateHelper, DepositRateHelper, FraRateHelper,
    FuturesRateHelper, SwapRateHelper)
from .yield_term_structure import YieldTermStructure
from .zero_curve import ZeroCurve

########NEW FILE########
__FILENAME__ = test_bonds
from .unittest_tools import unittest

from quantlib.instruments.bonds import (
    FixedRateBond, ZeroCouponBond
)
from quantlib.pricingengines.bond import DiscountingBondEngine
from quantlib.time.calendar import (
    TARGET, Unadjusted, ModifiedFollowing, Following
)
from quantlib.time.calendars.united_states import (
    UnitedStates, GOVERNMENTBOND
)
from quantlib.time.calendars.null_calendar import NullCalendar
from quantlib.compounding import Compounded, Continuous
from quantlib.time.date import (
    Date, Days, Semiannual, January, August, Period, March, February,
    Jul, Annual, Years
)
from quantlib.time.daycounter import Actual365Fixed
from quantlib.time.daycounters.actual_actual import ActualActual, Bond, ISMA
from quantlib.time.schedule import Schedule, Backward
from quantlib.settings import Settings
from quantlib.termstructures.yields.api import (
    FlatForward, YieldTermStructure
)


class BondTestCase(unittest.TestCase):

    @unittest.skip('This test is not numerically accurate and fails')
    def test_pricing_bond(self):
        '''Inspired by the C++ code from http://quantcorner.wordpress.com/.'''

        settings = Settings()

        # Date setup
        calendar = TARGET()

        # Settlement date
        settlement_date = calendar.adjust(Date(28, January, 2011))

        # Evaluation date
        fixing_days = 1
        settlement_days = 1

        todays_date = calendar.advance(
            settlement_date, -fixing_days, Days
        )

        settings.evaluation_date = todays_date

        # Bound attributes
        face_amount = 100.0
        redemption = 100.0
        issue_date = Date(27, January, 2011)
        maturity_date = Date(31, August, 2020)
        coupon_rate = 0.03625
        bond_yield = 0.034921

        discounting_term_structure = YieldTermStructure(relinkable=True)
        flat_term_structure = FlatForward(
            reference_date = settlement_date,
            forward        = bond_yield,
            daycounter     = Actual365Fixed(), #actual_actual.ActualActual(actual_actual.Bond),
            compounding    = Compounded,
            frequency      = Semiannual)
        # have a look at the FixedRateBondHelper to simplify this
        # construction
        discounting_term_structure.link_to(flat_term_structure)


	    #Rate
        fixed_bond_schedule = Schedule(
            issue_date,
            maturity_date,
            Period(Semiannual),
            UnitedStates(market=GOVERNMENTBOND),
            Unadjusted,
            Unadjusted,
            Backward,
            False);


        bond = FixedRateBond(
            settlement_days,
		    face_amount,
		    fixed_bond_schedule,
		    [coupon_rate],
            ActualActual(Bond),
		    Unadjusted,
            redemption,
            issue_date
        )

        bond.set_pricing_engine(discounting_term_structure)

        # tests
        self.assertTrue(Date(27, January, 2011), bond.issue_date)
        self.assertTrue(Date(31, August, 2020), bond.maturity_date)
        self.assertTrue(settings.evaluation_date, bond.valuation_date)

        # the following assertion fails but must be verified
        self.assertAlmostEqual(101.1, bond.clean_price, 1)
        self.assertAlmostEqual(101.1, bond.net_present_value, 1)
        self.assertAlmostEqual(101.1, bond.dirty_price)
        self.assertAlmostEqual(0.009851, bond.accrued_amount())


        print settings.evaluation_date
        print 'Principal: {}'.format(face_amount)
        print 'Issuing date: {} '.format(bond.issue_date)
        print 'Maturity: {}'.format(bond.maturity_date)
        print 'Coupon rate: {:.4%}'.format(coupon_rate)
        print 'Yield: {:.4%}'.format(bond_yield)
        print 'Net present value: {:.4f}'.format(bond.net_present_value)
        print 'Clean price: {:.4f}'.format(bond.clean_price)
        print 'Dirty price: {:.4f}'.format(bond.dirty_price)
        print 'Accrued coupon: {:.6f}'.format(bond.accrued_amount())
        print 'Accrued coupon: {:.6f}'.format(
            bond.accrued_amount(Date(1, March, 2011))
        )

    def test_excel_example_with_fixed_rate_bond(self):
        '''Port the QuantLib Excel adding bond example to Python. '''


        todays_date = Date(25, August, 2011)


        settings = Settings()
        settings.evaluation_date =  todays_date

        calendar = TARGET()
        effective_date = Date(10, Jul, 2006)
        termination_date = calendar.advance(
            effective_date, 10, Years, convention=Unadjusted
        )


        settlement_days = 3
        face_amount = 100.0
        coupon_rate = 0.05
        redemption = 100.0

        fixed_bond_schedule = Schedule(
            effective_date,
            termination_date,
            Period(Annual),
            calendar,
            ModifiedFollowing,
            ModifiedFollowing,
            Backward
        )

        issue_date = effective_date
        bond = FixedRateBond(
            settlement_days,
		    face_amount,
		    fixed_bond_schedule,
		    [coupon_rate],
            ActualActual(ISMA),
		    Following,
            redemption,
            issue_date
        )

        discounting_term_structure = YieldTermStructure(relinkable=True)
        flat_term_structure = FlatForward(
            settlement_days = 1,
            forward         = 0.044,
            calendar        = NullCalendar(),
            daycounter      = Actual365Fixed(),
            compounding     = Continuous,
            frequency       = Annual)

        discounting_term_structure.link_to(flat_term_structure)

        engine = DiscountingBondEngine(discounting_term_structure)

        bond.set_pricing_engine(engine)


        self.assertEquals(Date(10, Jul, 2016), termination_date)
        self.assertEquals(
            calendar.advance(todays_date, 3, Days), bond.settlement_date()
        )
        self.assertEquals(Date(11, Jul, 2016), bond.maturity_date)
        self.assertAlmostEqual(
            0.6849, bond.accrued_amount(bond.settlement_date()), 4
        )
        self.assertAlmostEqual(102.1154, bond.clean_price, 4)


    def test_excel_example_with_zero_coupon_bond(self):


        todays_date = Date(25, August, 2011)

        settlement_days = 3
        face_amount = 100
        calendar = TARGET()
        maturity_date = Date(26, February, 2024)

        bond = ZeroCouponBond(
            settlement_days, calendar, face_amount, maturity_date, Following,
            100., todays_date
        )

        discounting_term_structure = YieldTermStructure(relinkable=True)
        flat_term_structure = FlatForward(
            settlement_days = 1,
            forward         = 0.044,
            calendar        = NullCalendar(),
            daycounter      = Actual365Fixed(),
            compounding     = Continuous,
            frequency       = Annual)
        discounting_term_structure.link_to(flat_term_structure)

        engine = DiscountingBondEngine(discounting_term_structure)

        bond.set_pricing_engine(engine)


        self.assertEquals(
            calendar.advance(todays_date, 3, Days), bond.settlement_date()
        )
        self.assertEquals(0., bond.accrued_amount(bond.settlement_date()))
        self.assertAlmostEquals(57.6915, bond.clean_price, 4)

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_bond_helpers
from .unittest_tools import unittest

from quantlib.quotes import SimpleQuote
from quantlib.termstructures.yields.bond_helpers import (
    FixedRateBondHelper)
from quantlib.time.api import (
    Annual, Backward, Date, DayCounter, Following, Period, Schedule, TARGET)
from quantlib.time.calendar import ModifiedFollowing


class TestFixedRateBondHelper(unittest.TestCase):

    def test_create_fixed_rate_bond_helper(self):

        issue_date = Date(20, 3, 2014)
        maturity = Date(20, 3, 2019)

        schedule = Schedule(
            issue_date,
            maturity,
            Period(Annual),
            TARGET(),
            ModifiedFollowing,
            ModifiedFollowing,
            Backward,
            False
        )

        clean_price = 71.23
        settlement_days = 3
        rates = [0.035]

        daycounter = DayCounter.from_name("Actual/Actual (Bond)")
        helper = FixedRateBondHelper(
            SimpleQuote(clean_price),
            settlement_days,
            100.0,
            schedule,
            rates,
            daycounter,
            Following,
            100.0,
            issue_date)

        self.assertEqual(helper.quote, clean_price)


if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_business_day_convention
from .unittest_tools import unittest

from quantlib.time.calendar import (
    Following, Preceding)

from quantlib.time.businessdayconvention import BusinessDayConvention


class TestBusinessDayConvention(unittest.TestCase):

    def test_creation(self):

        b = BusinessDayConvention.from_name('Following')

        self.assertEquals(str(b), 'Following')
        self.assertEquals(b, Following)

        c = BusinessDayConvention(Preceding)
        self.assertEquals(c, Preceding)


if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_calendar
from .unittest_tools import unittest

from quantlib.time.calendar import (
    Following, ModifiedFollowing, ModifiedPreceding, Preceding, TARGET,
    holiday_list
)
from quantlib.time.calendars.united_kingdom import UnitedKingdom, EXCHANGE
from quantlib.time.calendars.united_states import UnitedStates, NYSE
from quantlib.time.calendars.null_calendar import NullCalendar
from quantlib.time.calendars.germany import Germany, FrankfurtStockExchange
from quantlib.time.date import (
    Date, May, March, June, Jan, August, Months,November, Period, Days,
    Apr, Jul, Sep, Oct, Dec, Nov)
from quantlib.time.calendars.jointcalendar import JointCalendar, JOINHOLIDAYS, JOINBUSINESSDAYS
from quantlib.util.version import QUANTLIB_VERSION

# QuantLib 1.4 added one extra holiday to the 2011 UK calendar (29 April 2011,
# the royal wedding), bringing the total to 9 holidays.
major, minor = QUANTLIB_VERSION[:2]
if major >= 1 and minor >= 4:
    UK_HOLIDAYS_2011 = 9
else:
    UK_HOLIDAYS_2011 = 8


class TestQuantLibCalendar(unittest.TestCase):

    def test_calendar_creation(self):

        calendar = TARGET()
        self.assertEquals('TARGET',  calendar.name)

        ukcalendar = UnitedKingdom()
        self.assertEquals('UK settlement',  ukcalendar.name)

        lse_cal = UnitedKingdom(market=EXCHANGE)
        self.assertEquals('London stock exchange',  lse_cal.name)

        null_calendar = NullCalendar()
        self.assertEquals('Null', null_calendar.name)

    def test_christmas_is_holiday(self):

        calendar = TARGET()

        date = Date(24,12, 2011)

        self.assertTrue(calendar.is_holiday(date))

    def test_is_business_day(self):

        ukcal = UnitedKingdom()

        bank_holiday_date = Date(3, May, 2010) #Early May Bank Holiday
        business_day = Date(28, March, 2011)

        self.assertFalse(ukcal.is_business_day(bank_holiday_date))
        self.assertTrue(ukcal.is_business_day(business_day))

    def test_joint(self):

        ukcal = UnitedKingdom()
        uscal = UnitedStates()

        bank_holiday_date = Date(3, May, 2010) #Early May Bank Holiday
        thanksgiving_holiday_date = Date(22, Nov, 2012)

        jtcal = JointCalendar(ukcal, uscal, JOINHOLIDAYS)

        self.assertFalse(jtcal.is_business_day(bank_holiday_date))
        self.assertFalse(jtcal.is_business_day(thanksgiving_holiday_date))

        jtcal = JointCalendar(ukcal, uscal, JOINBUSINESSDAYS)

        self.assertTrue(jtcal.is_business_day(bank_holiday_date))
        self.assertTrue(jtcal.is_business_day(thanksgiving_holiday_date))

    def test_business_days_between_dates(self):

        ukcal = UnitedKingdom()

        date1 = Date(30, May, 2011)

        # 30st of May is Spring Bank Holiday
        date2 = Date(3, June, 2011)

        day_count = ukcal.business_days_between(date1, date2, include_last=True)

        self.assertEquals(4, day_count)

    def test_holiday_list_acces_and_modification(self):

        ukcal = UnitedKingdom()

        holidays = list(
            holiday_list(ukcal, Date(1, Jan, 2011), Date(31, 12,2011) )
        )
        self.assertEquals(UK_HOLIDAYS_2011, len(holidays))

        new_holiday_date = Date(23, August, 2011)

        ukcal.add_holiday(new_holiday_date)

        holidays = list(
            holiday_list(ukcal, Date(1, Jan, 2011), Date(31, 12,2011) )
        )
        self.assertEquals(UK_HOLIDAYS_2011 + 1, len(holidays))

        ukcal.remove_holiday(new_holiday_date)

        holidays = list(
            holiday_list(ukcal, Date(1, Jan, 2011), Date(31, 12,2011) )
        )
        self.assertEquals(UK_HOLIDAYS_2011, len(holidays))

    def test_adjust_business_day(self):

        ukcal = UnitedKingdom()

        bank_holiday_date = Date(3, May, 2010) #Early May Bank Holiday

        adjusted_date = ukcal.adjust(bank_holiday_date)
        following_date = bank_holiday_date + 1
        self.assertTrue(following_date == adjusted_date)

        adjusted_date = ukcal.adjust(bank_holiday_date, convention=Preceding)
        following_date = bank_holiday_date - 3 # bank holiday is a Monday
        self.assertTrue(following_date == adjusted_date)

        adjusted_date = ukcal.adjust(bank_holiday_date,
                convention=ModifiedPreceding)
        following_date = bank_holiday_date + 1 # Preceding is on a different
                                               # month
        self.assertTrue(following_date == adjusted_date)

    def test_calendar_date_advance(self):
        ukcal = UnitedKingdom()

        bank_holiday_date = Date(3, May, 2010) #Early May Bank Holiday

        advanced_date = ukcal.advance(bank_holiday_date, step=6, units=Months)
        expected_date = Date(3, November, 2010)
        self.assertTrue(expected_date == advanced_date)

        period_10days = Period(10, Days)
        advanced_date = ukcal.advance(bank_holiday_date, period=period_10days)
        expected_date = Date(17, May, 2010)
        self.assertTrue(expected_date == advanced_date)

    def test_united_states_calendar(self):

        uscal = UnitedStates()
        holiday_date = Date(4, Jul, 2010)

        self.assertTrue(uscal.is_holiday(holiday_date))

        uscal = UnitedStates(market=NYSE)
        holiday_date = Date(5, Sep, 2011) # Labor day

        self.assertTrue(uscal.is_holiday(holiday_date))

    def test_german_calendar(self):

        frankfcal   = Germany(FrankfurtStockExchange);
        first_date  = Date(31,Oct,2009)
        second_date = Date(1,Jan ,2010);

        Dec_30_2009 = Date(30, Dec, 2009)
        Jan_4_2010 = Date(4, Jan, 2010)

        self.assertEquals(
            Dec_30_2009, frankfcal.adjust(second_date , Preceding)
        )
        self.assertEquals(
            Jan_4_2010,
            frankfcal.adjust(second_date , ModifiedPreceding)
        )

        mat = Period(2,Months)

        self.assertEquals(
            Jan_4_2010,
            frankfcal.advance(
                first_date, period=mat, convention=Following,
                end_of_month=False
            )
        )
        self.assertEquals(
            Dec_30_2009,
            frankfcal.advance(
                first_date, period=mat, convention=ModifiedFollowing,
                end_of_month=False
            )
        )
        self.assertEquals(
            41,
            frankfcal.business_days_between(
                first_date, second_date, False, False
            )
        )



class TestDateList(unittest.TestCase):

    def test_iteration_on_date_list(self):

        date_iterator = holiday_list(
            TARGET(), Date(1, Jan, 2000), Date(1, Jan, 2001)
        )

        holidays = [
            Date(21, Apr, 2000), Date(24, Apr, 2000),
            Date(1, May, 2000), Date(25, Dec, 2000),
            Date(26, Dec, 2000), Date(1, Jan, 2001)
        ]

        for date in date_iterator:
            self.assertIn(date, holidays)


if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_cashflows
from .unittest_tools import unittest

from quantlib.time.date import Date
import quantlib.cashflow as cf
from datetime import date


class TestQuantLibDate(unittest.TestCase):

    def test_simple_cashflow(self):

        cf_date = Date(1, 7, 2030)
        cf_amount = 100.0

        test_cf = cf.SimpleCashFlow(cf_amount, cf_date)

        self.assertEquals(test_cf.amount, cf_amount)
        self.assertEquals(test_cf.date, cf_date)

    def test_leg(self):

        cf_date = Date(1, 7, 2030)
        pydate = date(2030, 7, 1)
        cf_amount = 100.0

        leg = ((cf_amount, cf_date),)

        test_leg = cf.SimpleLeg(leg)
        self.assertEquals(test_leg.size, 1)
        self.assertEquals(test_leg.items, [(100.0, pydate)])

########NEW FILE########
__FILENAME__ = test_cds
""" Unittests for the CDS related classes. """

from .unittest_tools import  unittest

from quantlib.settings import Settings
from quantlib.quotes import SimpleQuote
from quantlib.termstructures.yields.api import FlatForward
from quantlib.termstructures.credit.api import SpreadCdsHelper, PiecewiseDefaultCurve
from quantlib.time.api import TARGET, Date, Actual365Fixed, Months, \
        Following, Quarterly, TwentiethIMM, May, Period


def create_helper():

    calendar = TARGET()

    todays_date = Date(15, May, 2007)
    todays_date = calendar.adjust(todays_date)

    Settings.instance().evaluation_date = todays_date

    flat_rate = SimpleQuote(0.01)
    ts_curve = FlatForward(todays_date, flat_rate, Actual365Fixed())

    recovery_rate = 0.5
    quoted_spreads = 0.0150
    tenor = Period(3, Months)

    helper = SpreadCdsHelper(
            quoted_spreads, tenor, 0, calendar, Quarterly,
            Following, TwentiethIMM, Actual365Fixed(), recovery_rate, ts_curve
    )

    return todays_date, helper



class SpreadCdsHelperTestCase(unittest.TestCase):

    def test_create_helper(self):

        todays_date, helper = create_helper()

        self.assertIsNotNone(helper)

class PiecewiseDefaultCurveTestCase(unittest.TestCase):

    def test_create_piecewise(self):

        todays_date, helper = create_helper()

        for trait in ['HazardRate', 'DefaultDensity', 'SurvivalProbability']:
            for interpolator in ['Linear', 'LogLinear', 'BackwardFlat']:
                curve = PiecewiseDefaultCurve(
                    trait,
                    interpolator,
                    reference_date=todays_date,
                    helpers=[helper],
                    daycounter=Actual365Fixed()
                )

                self.assertIsNotNone(curve)


if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_currrencies
from .unittest_tools import unittest

from quantlib.currency import Currency, USDCurrency

class TestCurrency(unittest.TestCase):

    def test_create_currency(self):
        currency = Currency()
        self.assertEquals('null currency', str(currency))

    def test_from_name(self):
        cu_1 = Currency.from_name('USD')
        cu_2 = USDCurrency()
        self.assertEquals(cu_1.name, cu_2.name)

if __name__ == '__main__':
    unittest.main()


########NEW FILE########
__FILENAME__ = test_date
import datetime

from .unittest_tools import unittest

from quantlib.time.date import (
    Date, Jan, Feb, Mar, Apr, May, Jun, Jul, Sep, Nov, Thursday, Friday,
    Period,
    Annual, Semiannual, Bimonthly, EveryFourthMonth, Months, Years, Weeks,
    Days, OtherFrequency, end_of_month, is_end_of_month, is_leap,
    next_weekday, nth_weekday, today, pydate_from_qldate, qldate_from_pydate
)

import quantlib.time.imm as imm
from datetime import date


class TestQuantLibDate(unittest.TestCase):

    def test_today(self):

        py_today = datetime.date.today()

        ql_today = today()

        self.assertEquals(py_today.day, ql_today.day)
        self.assertEquals(py_today.month, ql_today.month)
        self.assertEquals(py_today.year, ql_today.year)

    def test_date_empyt_initialisation(self):

        date1 = Date()
        self.assertTrue(date1 is not None)

    def test_date_creation(self):

        date1 = Date(19, Nov, 1998)
        self.assertEquals(11, date1.month)

        date2 = Date(29, Feb, 2008)
        self.assertEquals(2, date2.month)

        with self.assertRaises(RuntimeError):
            # getting an invalid day
            date2 = Date(29, Feb, 2009)

    def test_from_datetime_classmethod(self):

        date1 = Date(19, Nov, 1998)

        datetime_date = datetime.date(1998, 11, 19)
        from_datetime_date = Date.from_datetime(datetime_date)
        self.assertEquals(from_datetime_date.serial, date1.serial)

        datetime_datetime = datetime.datetime(1998, 11, 19, 01, 00)
        from_datetime_datetime = Date.from_datetime(datetime_datetime)
        self.assertEquals(from_datetime_datetime.serial, date1.serial)

    def test_comparison_with_datetime(self):

        date_nov_98 = Date(19, Nov, 1998)
        datetime_date_nov_98 = datetime.date(1998, 11, 19)

        self.assertTrue(date_nov_98 == datetime_date_nov_98)
        self.assertEquals(cmp(date_nov_98, datetime_date_nov_98), 0)

        datetime_date_oct_98 = datetime.date(1998, 10, 19)
        self.assertTrue(date_nov_98 > datetime_date_oct_98)

    def test_equality(self):
        date1 = Date(1, 1, 2011)
        date2 = Date(1, 1, 2011)
        date3 = datetime.date(2011, 1, 1)

        self.assertEquals(date1, date2)

        self.assertEquals(date1, date3)

    def test_arithmetic_operators(self):

        # addition
        date1 = Date(19, Nov, 1998)
        date2 = date1 + 5
        expected_date = Date(24, Nov, 1998)
        self.assertTrue(expected_date == date2)

        # iadd
        date1 = Date(19, Nov, 1998)
        date1 += 3
        expected_date = Date(22, Nov, 1998)
        self.assertTrue(expected_date == date1)

        # substraction
        date1 = Date(19, Nov, 1998)
        date3 = date1 - 5
        expected_date = Date(14, Nov, 1998)
        self.assertTrue(expected_date == date3)

        with self.assertRaises(ValueError):
            # invalid operation
            date3 - date1

        # isub
        date1 = Date(19, Nov, 1998)
        date1 -= 3
        expected_date = Date(16, Nov, 1998)
        self.assertTrue(expected_date == date1)

    def test_next_weekday(self):
        ''' Test next weekday

        The Friday following Tuesday, January 15th, 2002 was
        January 18th, 2002.
        see http://www.cpearson.com/excel/DateTimeWS.htm
        '''

        date1 = Date(15, Jan, 2002)
        date2 = next_weekday(date1, Friday)

        expected_date = Date(18, Jan, 2002)
        self.assertTrue(expected_date == date2)

    def test_nth_weekday(self):
        ''' The 4th Thursday of Mar, 1998 was Mar 26th, 1998.
        see http://www.cpearson.com/excel/DateTimeWS.htm
        '''

        date1 = nth_weekday(4, Thursday, Mar, 1998)

        expected_date = Date(26, Mar, 1998)
        self.assertTrue(expected_date == date1)

    def test_nth_weekday_invalid_month(self):

        with self.assertRaises(RuntimeError):
            nth_weekday(4, Thursday, 0, 2000)

    def test_end_of_month(self):

        date1 = Date(16, Feb, 2011)
        date2 = end_of_month(date1)
        expected_date = Date(28, Feb, 2011)
        self.assertTrue(expected_date == date2)

    def test_is_end_of_month(self):

        date1 = Date(28, Feb, 2011)

        self.assertTrue(is_end_of_month(date1))

    def test_is_leap(self):

        self.assertTrue(is_leap(2008))
        self.assertFalse(is_leap(2009))

    def test_convertion_to_integer(self):

        date1 = Date(28, Feb, 2011)

        self.assertEquals(date1.serial, int(date1))


class ConversionMethodsTestCase(unittest.TestCase):

    def test_conversion_from_datetime_to_pyql(self):

        date1 = datetime.date(2010, 1, 1)

        qldate1 = qldate_from_pydate(date1)

        expected_result = Date(1, Jan, 2010)

        self.assertEquals(expected_result, qldate1)

    def test_conversion_from_pyql_to_datetime(self):

        date1 = Date(1, Jan, 2010)

        pydate1 = pydate_from_qldate(date1)

        expected_result = datetime.date(2010, 1, 1)

        self.assertEquals(expected_result, pydate1)


class TestQuantLibPeriod(unittest.TestCase):

    def test_creation_with_frequency(self):

        period = Period(Annual)

        self.assertEquals(1, period.length)
        self.assertEquals(Years, period.units)

        period = Period(Bimonthly)

        self.assertEquals(2, period.length)
        self.assertEquals(Months, period.units)

    def test_normalize_period(self):

        period = Period(12, Months)

        period.normalize()

        self.assertEquals(1, period.length)
        self.assertEquals(Years, period.units)

    def test_rich_cmp(self):

        # equality
        period1 = Period(Annual)
        period2 = Period(1, Years)
        self.assertTrue(period1 == period2)

        period1 = Period(12, Months)
        period2 = Period(1, Years)
        self.assertTrue(period1 == period2)

        # non equality
        period1 = Period(11, Months)
        period2 = Period(1, Years)
        period3 = Period(150, Weeks)
        period4 = Period(52, Weeks)

        self.assertTrue(period1 != period2)
        self.assertTrue(period1 < period2)
        self.assertTrue(period3 > period1)
        self.assertTrue(period3 >= period1)
        self.assertTrue(period4 <= period2)

    def test_creation_with_time_and_units(self):

        period = Period(10, Months)

        self.assertEquals(10, period.length)
        self.assertEquals(Months, period.units)
        self.assertEquals(OtherFrequency, period.frequency)

    def test_adding_period_to_date(self):

        date1 = Date(1, May, 2011)

        period = Period(1, Months)
        date2 = date1 + period
        expected_date = Date(1, Jun, 2011)
        self.assertTrue(expected_date == date2)

        period = Period(Bimonthly)
        date2 = date1 + period
        expected_date = Date(1, Jul, 2011)
        self.assertTrue(expected_date == date2)

        period = Period(10, Months)
        date2 = date1 + period
        expected_date = Date(1, Mar, 2012)
        self.assertTrue(expected_date == date2)

    def test_period_substraction(self):

        period1 = Period(11, Months)
        period2 = Period(EveryFourthMonth)

        period3 = period1 - period2
        self.assertEquals(7, period3.length)
        self.assertEquals(Months, period3.units)

    def test_multiplication(self):

        period = Period(Bimonthly)

        period2 = period * 10
        self.assertEquals(20, period2.length)

        # invert operation
        period2 = 10 * period
        self.assertIsInstance(period2, Period)
        self.assertEquals(20, period2.length)

    def test_inplace_addition(self):

        period = Period(Bimonthly)

        period2 = Period(2, Months)

        period += period2

        self.assertEquals(4, period.length)
        self.assertEquals(Months, period.units)

        with self.assertRaises(ValueError):
            period3 = Period(2, Weeks)
            period += period3  # does not support different units

    def test_inplace_substraction(self):

        period = Period(Semiannual)

        period2 = Period(3, Months)

        period -= period2

        self.assertEquals(3, period.length)
        self.assertEquals(Months, period.units)

        with self.assertRaises(ValueError):
            period3 = Period(2, Weeks)
            period -= period3  # does not support different units

    def test_inplace_division(self):

        period = Period(Semiannual)

        period /= 3

        self.assertEquals(2, period.length)
        self.assertEquals(Months, period.units)

    def test_substracting_period_to_date(self):

        date1 = Date(1, May, 2011)

        period = Period(1, Months)
        date2 = date1 - period
        expected_date = Date(1, Apr, 2011)
        self.assertTrue(expected_date == date2)

        period = Period(Bimonthly)
        date2 = date1 - period
        expected_date = Date(1, Mar, 2011)
        self.assertTrue(expected_date == date2)

        period = Period(10, Days)
        date2 = date1 - period
        expected_date = Date(21, Apr, 2011)
        self.assertTrue(expected_date == date2)

class TestQuantLibIMM(unittest.TestCase):

    def test_is_imm_date(self):

        dt = Date(17, Sep, 2014)
        is_imm = imm.is_IMM_date(dt)
        self.assertTrue(is_imm)

        dt = Date(18, Sep, 2014)
        is_imm = imm.is_IMM_date(dt)
        self.assertFalse(is_imm)

    def test_is_imm_code(self):

        is_good = imm.is_IMM_code('H9')
        self.assertTrue(is_good)

        is_bad = imm.is_IMM_code('WX')
        self.assertFalse(is_bad)

    def test_imm_date(self):
        dt = imm.date('M9')
        print('IMM date M9: %s' % dt)
        cd = imm.code(qldate_from_pydate(dt))
        print('IMM code for %s: %s' % (dt, cd))
        self.assertTrue(cd == 'M9')

    def test_next_date(self):
        dt = Date(19, Jun, 2014)
        dt_2 = imm.next_date(dt)
        # 17 sep 2014
        self.assertEquals(dt_2, date(2014, 9, 17))

        dt_3 = imm.next_date('M9', True, today())
        # 18 sep 2019
        self.assertEquals(dt_3, date(2019, 9, 18))

    def test_next_code(self):
        dt = Date(10, Jun, 2014)
        cd_2 = imm.next_code(dt)
        # M4
        self.assertEquals(cd_2, "M4")

        cd_3 = imm.next_code('M9', True, today())
        # U9
        self.assertEquals(cd_3, "U9")

########NEW FILE########
__FILENAME__ = test_daycounter
from .unittest_tools import unittest

from quantlib.time.daycounter import (
    Actual360, DayCounter, SimpleDayCounter
)

from quantlib.time.daycounters.actual_actual import (
    ActualActual, ISDA, ISMA, AFB
)

from quantlib.time.daycounters.thirty360 import (
        Thirty360, EUROBONDBASIS
)
from quantlib.time.date import (
    Date, November, May, February, July, January, Period,
    Months
)

class TestDayCounter(unittest.TestCase):

    def test_create_day_counter(self):

        day_counter = Actual360()

        self.assertTrue(day_counter is not None)
        self.assertIsInstance(day_counter, DayCounter)

    def test_daycounter_name(self):

        day_counter = Actual360()
        self.assertEquals('Actual/360', day_counter.name())

class TestDayCounterFromName(unittest.TestCase):

    def test_create_simple_daycounter_from_name(self):

        type_vs_name = {
            'Actual360' : 'Actual/360',
            'Actual/360' : 'Actual/360',
            'Actual365Fixed' : 'Actual/365 (Fixed)',
            'Actual/365' : 'Actual/365 (Fixed)',
            'OneDayCounter' : '1/1',
            '1/1' : '1/1',
        }

        for counter_type, expected_name in type_vs_name.items():

            cnt = DayCounter.from_name(counter_type)
            self.assertEquals(cnt.name(), expected_name)

    def test_create_daycounter_with_convention_from_name(self):

        type_vs_name = {
            'Actual/Actual (Bond)' : 'Actual/Actual (ISMA)',
            'Actual/Actual (ISMA)' : 'Actual/Actual (ISMA)',
            'Actual/Actual (ISDA)' : 'Actual/Actual (ISDA)',
            'Actual/Actual (Historical)' : 'Actual/Actual (ISDA)',
            'Actual/Actual (Actual365)' : 'Actual/Actual (ISDA)',
            'Actual/Actual (AFB)' : 'Actual/Actual (AFB)',
            'Actual/Actual (Euro)' : 'Actual/Actual (AFB)',
        }

        for counter_type, expected_name in type_vs_name.items():

            cnt = DayCounter.from_name(counter_type)
            self.assertEquals(cnt.name(), expected_name)



class TestActualActual(unittest.TestCase):

    def setUp(self):

        self.from_date = Date(1, November, 2003)
        self.to_date = Date(1, May, 2004)
        self.ref_start = Date(1, November, 2003)
        self.ref_end = Date(1, May, 2004)

    def test_first_example_isda(self):

        day_counter = ActualActual(ISDA)

        self.assertAlmostEqual(
            0.497724380567,
            day_counter.year_fraction(self.from_date, self.to_date)
        )

    def test_first_example_isma(self):
        day_counter = ActualActual(ISMA)

        self.assertAlmostEqual(
            0.5,
            day_counter.year_fraction(self.from_date, self.to_date,
                self.ref_start, self.ref_end)
        )

    def test_first_example_afb(self):
        day_counter = ActualActual(AFB)

        self.assertAlmostEqual(
            0.497267759563,
            day_counter.year_fraction(self.from_date, self.to_date)
        )


    def test_short_calculation_first_period_isda(self):
        day_counter = ActualActual(ISDA)
        from_date = Date(1, February, 1999)
        to_date = Date(1, July, 1999)

        expected_result = 0.410958904110

        self.assertAlmostEquals(
            expected_result,
            day_counter.year_fraction(from_date, to_date)
        )

    def test_short_calculation_first_period_isma(self):
        day_counter = ActualActual(ISMA)
        from_date = Date(1, February, 1999)
        to_date = Date(1, July, 1999)
        ref_start = Date(1,July,1998)
        ref_end = Date(1,July,1999)
        expected_result = 0.410958904110

        self.assertAlmostEquals(
            expected_result,
            day_counter.year_fraction(from_date, to_date, ref_start, ref_end)
        )

    def test_short_calculation_first_period_afb(self):
        day_counter = ActualActual(AFB)
        from_date = Date(1, February, 1999)
        to_date = Date(1, July, 1999)

        expected_result = 0.410958904110

        self.assertAlmostEquals(
            expected_result,
            day_counter.year_fraction(from_date, to_date)
        )

    def test_short_calculation_second_period_isda(self):
        day_counter = ActualActual(ISDA)
        from_date = Date(1, July, 1999)
        to_date = Date(1, July, 2000)

        expected_result = 1.001377348600

        self.assertAlmostEquals(
            expected_result,
            day_counter.year_fraction(from_date, to_date)
        )

    def test_short_calculation_second_period_isma(self):
        day_counter = ActualActual(ISMA)
        from_date = Date(1, July, 1999)
        to_date = Date(1, July, 2000)
        ref_start = Date(1, July, 1999)
        ref_end = Date(1, July, 2000)


        expected_result = 1.000000000000

        self.assertAlmostEquals(
            expected_result,
            day_counter.year_fraction(from_date, to_date, ref_start, ref_end)
        )


    def test_short_calculation_second_period_afb(self):
        day_counter = ActualActual(AFB)
        from_date = Date(1, July, 1999)
        to_date = Date(1, July, 2000)

        expected_result = 1.000000000000

        self.assertAlmostEquals(
            expected_result,
            day_counter.year_fraction(from_date, to_date)
        )

    def test_simple(self):

        periods = [3, 6, 12]
        expected_times = [0.25, 0.5, 1.0]
        first = Date(1,January,2002)

        day_counter = SimpleDayCounter();

        for index, period in enumerate(periods):
            end = first + Period(period,  Months)
            calculated = day_counter.year_fraction(first,end)
            self.assertAlmostEquals(
                expected_times[index], calculated
            )


    def test_thirty360(self):

        day_counter = Thirty360(EUROBONDBASIS)
        from_date = Date(1, July, 1999)
        to_date = Date(1, July, 2000)

        expected_result = 1.000000000000

        self.assertAlmostEquals(
            expected_result,
            day_counter.year_fraction(from_date, to_date)
        )


    def test_equality_method(self):

        day_counter = Thirty360(EUROBONDBASIS)

        self.assertNotEquals(day_counter.name(), Thirty360().name())
        self.assertNotEqual(day_counter, Thirty360())
        self.assertEquals(day_counter, Thirty360(EUROBONDBASIS))

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_heston_model
import numpy as np

from .unittest_tools import unittest

from quantlib.instruments.option import EuropeanExercise, VanillaOption
from quantlib.instruments.payoffs import Call, PlainVanillaPayoff, Put
from quantlib.models.equity.heston_model import (
    HestonModelHelper, HestonModel, ImpliedVolError
)

from quantlib.processes.heston_process import HestonProcess
from quantlib.processes.bates_process import BatesProcess
from quantlib.models.equity.bates_model import (BatesDetJumpModel)

from quantlib.pricingengines.blackformula import blackFormula
from quantlib.pricingengines.vanilla.vanilla import (
    AnalyticHestonEngine,
    BatesDetJumpEngine)
from quantlib.processes.heston_process import QUADRATICEXPONENTIAL
from quantlib.math.optimization import LevenbergMarquardt, EndCriteria
from quantlib.settings import Settings
from quantlib.time.api import (
    today, Actual360, NullCalendar, Period, Months, Years, Date, July,
    Actual365Fixed, TARGET, Weeks, ActualActual
)
from quantlib.termstructures.yields.flat_forward import FlatForward
from quantlib.quotes import SimpleQuote
from quantlib.termstructures.yields.zero_curve import ZeroCurve

from quantlib.pricingengines.vanilla.mcvanillaengine import MCVanillaEngine


def flat_rate(forward, daycounter):
    return FlatForward(
        forward=SimpleQuote(forward),
        settlement_days=0,
        calendar=NullCalendar(),
        daycounter=daycounter
    )


class HestonModelTestCase(unittest.TestCase):
    """Test cases are based on the test-suite/hestonmodel.cpp in QuantLib.

    """

    def setUp(self):

        self.settings = Settings()

    def test_black_calibration(self):

        # calibrate a Heston model to a constant volatility surface without
        # smile. expected result is a vanishing volatility of the volatility.
        # In addition theta and v0 should be equal to the constant variance

        todays_date = today()

        self.settings.evaluation_date = todays_date

        daycounter = Actual360()
        calendar = NullCalendar()

        risk_free_ts = flat_rate(0.04, daycounter)
        dividend_ts = flat_rate(0.50, daycounter)

        option_maturities = [
            Period(1, Months),
            Period(2, Months),
            Period(3, Months),
            Period(6, Months),
            Period(9, Months),
            Period(1, Years),
            Period(2, Years)
        ]

        options = []

        s0 = SimpleQuote(1.0)
        vol = SimpleQuote(0.1)

        volatility = vol.value

        for maturity in option_maturities:
            for moneyness in np.arange(-1.0, 2.0, 1.):
                tau = daycounter.year_fraction(
                    risk_free_ts.reference_date,
                    calendar.advance(
                        risk_free_ts.reference_date,
                        period=maturity)
                )
                forward_price = s0.value * dividend_ts.discount(tau) / \
                                risk_free_ts.discount(tau)
                strike_price = forward_price * np.exp(
                    -moneyness * volatility * np.sqrt(tau)
                )
                options.append(
                    HestonModelHelper(
                        maturity, calendar, s0.value, strike_price, vol,
                        risk_free_ts, dividend_ts
                    )
                )

        for sigma in np.arange(0.1, 0.7, 0.2):
            v0    = 0.01
            kappa = 0.2
            theta = 0.02
            rho   = -0.75

            process = HestonProcess(
                risk_free_ts, dividend_ts, s0, v0, kappa, theta, sigma, rho
            )

            self.assertEquals(v0, process.v0)
            self.assertEquals(kappa, process.kappa)
            self.assertEquals(theta, process.theta)
            self.assertEquals(sigma, process.sigma)
            self.assertEquals(rho, process.rho)
            self.assertEquals(1.0, process.s0().value)

            model = HestonModel(process)
            engine = AnalyticHestonEngine(model, 96)

            for option in options:
                option.set_pricing_engine(engine)

            optimisation_method = LevenbergMarquardt(1e-8, 1e-8, 1e-8)

            end_criteria = EndCriteria(400, 40, 1.0e-8, 1.0e-8, 1.0e-8)
            model.calibrate(options, optimisation_method, end_criteria)

            tolerance = 3.0e-3

            self.assertFalse(model.sigma > tolerance)

            self.assertAlmostEqual(
                model.kappa * model.theta,
                model.kappa * volatility ** 2,
                delta=tolerance
            )
            self.assertAlmostEqual(model.v0, volatility ** 2, delta=tolerance)

    def test_DAX_calibration(self):

        # this example is taken from A. Sepp
        # Pricing European-Style Options under Jump Diffusion Processes
        # with Stochstic Volatility: Applications of Fourier Transform
        # http://math.ut.ee/~spartak/papers/stochjumpvols.pdf

        settlement_date = Date(5, July, 2002)

        self.settings.evaluation_date = settlement_date

        daycounter = Actual365Fixed()
        calendar = TARGET()

        t = [13, 41, 75, 165, 256, 345, 524, 703]
        r = [0.0357,0.0349,0.0341,0.0355,0.0359,0.0368,0.0386,0.0401]

        dates = [settlement_date] + [settlement_date + val for val in t]
        rates = [0.0357] + r

        risk_free_ts = ZeroCurve(dates, rates, daycounter)
        dividend_ts = FlatForward(
            settlement_date, forward=0.0, daycounter=daycounter
        )

        v = [
            0.6625,0.4875,0.4204,0.3667,0.3431,0.3267,0.3121,0.3121,
            0.6007,0.4543,0.3967,0.3511,0.3279,0.3154,0.2984,0.2921,
            0.5084,0.4221,0.3718,0.3327,0.3155,0.3027,0.2919,0.2889,
            0.4541,0.3869,0.3492,0.3149,0.2963,0.2926,0.2819,0.2800,
            0.4060,0.3607,0.3330,0.2999,0.2887,0.2811,0.2751,0.2775,
            0.3726,0.3396,0.3108,0.2781,0.2788,0.2722,0.2661,0.2686,
            0.3550,0.3277,0.3012,0.2781,0.2781,0.2661,0.2661,0.2681,
            0.3428,0.3209,0.2958,0.2740,0.2688,0.2627,0.2580,0.2620,
            0.3302,0.3062,0.2799,0.2631,0.2573,0.2533,0.2504,0.2544,
            0.3343,0.2959,0.2705,0.2540,0.2504,0.2464,0.2448,0.2462,
            0.3460,0.2845,0.2624,0.2463,0.2425,0.2385,0.2373,0.2422,
            0.3857,0.2860,0.2578,0.2399,0.2357,0.2327,0.2312,0.2351,
            0.3976,0.2860,0.2607,0.2356,0.2297,0.2268,0.2241,0.2320
        ]

        s0 = SimpleQuote(4468.17)
        strikes = [
            3400, 3600, 3800, 4000, 4200, 4400, 4500, 4600, 4800, 5000, 5200,
            5400, 5600
        ]

        options = []

        for s, strike in enumerate(strikes):
            for m in range(len(t)):
                vol = SimpleQuote(v[s * 8 + m])
                # round to weeks
                maturity = Period((int)((t[m] + 3) / 7.), Weeks)
                options.append(
                    HestonModelHelper(
                        maturity, calendar, s0.value, strike, vol,
                        risk_free_ts, dividend_ts,
                        ImpliedVolError
                    )
                )

        v0    = 0.1
        kappa = 1.0
        theta = 0.1
        sigma = 0.5
        rho   = -0.5

        process = HestonProcess(
            risk_free_ts, dividend_ts, s0, v0, kappa, theta, sigma, rho
        )

        model = HestonModel(process)

        engine = AnalyticHestonEngine(model, 64)

        for option in options:
            option.set_pricing_engine(engine)

        om = LevenbergMarquardt(1e-8, 1e-8, 1e-8)

        model.calibrate(
            options, om, EndCriteria(400, 40, 1.0e-8, 1.0e-8, 1.0e-8)
        )

        sse = 0
        for i in range(len(strikes) * len(t)):
            diff = options[i].calibration_error() * 100.0
            sse += diff * diff

        expected = 177.2  # see article by A. Sepp.
        self.assertAlmostEquals(expected, sse, delta=1.0)

    def test_analytic_versus_black(self):
        settlement_date = today()
        self.settings.evaluation_date = settlement_date

        daycounter = ActualActual()

        exercise_date = settlement_date + 6 * Months

        payoff = PlainVanillaPayoff(Put, 30)

        exercise = EuropeanExercise(exercise_date)

        risk_free_ts = flat_rate(0.1, daycounter)
        dividend_ts = flat_rate(0.04, daycounter)

        s0 = SimpleQuote(32.0)

        v0    = 0.05
        kappa = 5.0
        theta = 0.05
        sigma = 1.0e-4
        rho   = 0.0

        process = HestonProcess(
            risk_free_ts, dividend_ts, s0, v0, kappa, theta, sigma, rho
        )

        option = VanillaOption(payoff, exercise)

        engine = AnalyticHestonEngine(HestonModel(process), 144)

        option.set_pricing_engine(engine)

        calculated = option.net_present_value

        year_fraction = daycounter.year_fraction(
            settlement_date, exercise_date
        )

        forward_price = 32 * np.exp((0.1 - 0.04) * year_fraction)
        expected = blackFormula(
            payoff.type, payoff.strike, forward_price,
            np.sqrt(0.05 * year_fraction)
        ) * np.exp(-0.1 * year_fraction)

        tolerance = 2.0e-7

        self.assertAlmostEqual(
            calculated,
            expected,
            delta=tolerance
        )

    def test_bates_det_jump(self):
        # this looks like a bug in QL:
        # Bates Det Jump model does not have sigma as parameter, yet
        # changing sigma changes the result!

        settlement_date = today()
        self.settings.evaluation_date = settlement_date

        daycounter = ActualActual()

        exercise_date = settlement_date + 6 * Months

        payoff = PlainVanillaPayoff(Put, 1290)
        exercise = EuropeanExercise(exercise_date)
        option = VanillaOption(payoff, exercise)

        risk_free_ts = flat_rate(0.02, daycounter)
        dividend_ts = flat_rate(0.04, daycounter)

        spot = 1290

        ival = {'delta': 3.6828677022272715e-06,
        'kappa': 19.02581428347027,
        'kappaLambda': 1.1209758060939223,
        'lambda': 0.06524550732595163,
        'nu': -1.8968106563601956,
        'rho': -0.7480898462264719,
        'sigma': 1.0206363887835108,
        'theta': 0.01965384459461113,
        'thetaLambda': 0.028915397380738218,
        'v0': 0.06566800935242285}

        process = BatesProcess(
        risk_free_ts, dividend_ts, SimpleQuote(spot),
        ival['v0'], ival['kappa'],
        ival['theta'], ival['sigma'], ival['rho'],
        ival['lambda'], ival['nu'], ival['delta'])

        model = BatesDetJumpModel(process,
                ival['kappaLambda'], ival['thetaLambda'])

        engine = BatesDetJumpEngine(model, 64)

        option.set_pricing_engine(engine)

        calc_1 = option.net_present_value

        ival['sigma'] = 1.e-6

        process = BatesProcess(
        risk_free_ts, dividend_ts, SimpleQuote(spot),
        ival['v0'], ival['kappa'],
        ival['theta'], ival['sigma'], ival['rho'],
        ival['lambda'], ival['nu'], ival['delta'])

        model = BatesDetJumpModel(process,
                ival['kappaLambda'], ival['thetaLambda'])
        engine = BatesDetJumpEngine(model, 64)

        option.set_pricing_engine(engine)

        calc_2 = option.net_present_value

        if(abs(calc_1-calc_2) > 1.e-5):
            print 'calc 1 %f calc 2 %f' % (calc_1, calc_2)
        self.assertNotEqual(calc_1, calc_2)

    def test_smith(self):
        # test against result published in
        # Journal of Computational Finance Vol. 11/1 Fall 2007
        # An almost exact simulation method for the heston model

        def payoff(o, scenario):
            Strike = o['S']
            if o['CP'] == 'C':
                exercise = [max(ST - Strike, 0) for ST in scenario]
            else:
                exercise = [max(-ST + Strike, 0) for ST in scenario]
            return np.mean(exercise)

        settlement_date = today()
        self.settings.evaluation_date = settlement_date

        daycounter = ActualActual()
        timeToMaturity = 4

        exercise_date = settlement_date + timeToMaturity * 365

        c_payoff = PlainVanillaPayoff(Call, 100)

        exercise = EuropeanExercise(exercise_date)

        risk_free_ts = flat_rate(0., daycounter)
        dividend_ts = flat_rate(0., daycounter)

        s0 = SimpleQuote(100.0)

        v0    = 0.0194
        kappa = 1.0407
        theta = 0.0586
        sigma = 0.5196
        rho   = -.6747

        nb_steps_a = 100
        nb_paths = 20000
        seed = 12347

        process = HestonProcess(
            risk_free_ts, dividend_ts, s0, v0, kappa, theta,
            sigma, rho, QUADRATICEXPONENTIAL)

        model = HestonModel(process)

        option = VanillaOption(c_payoff, exercise)

        engine = AnalyticHestonEngine(model, 144)

        option.set_pricing_engine(engine)

        price_fft  = option.net_present_value

        engine = MCVanillaEngine(
              trait='MCEuropeanHestonEngine',
              RNG='PseudoRandom',
              process=process,
              doAntitheticVariate=True,
              stepsPerYear=nb_steps_a,
              requiredSamples=nb_paths,
              seed=seed)

        option.set_pricing_engine(engine)
        price_mc = option.net_present_value

        expected = 15.1796
        tolerance = .05

        self.assertAlmostEqual(
            price_fft,
            expected,
            delta=tolerance)
        self.assertAlmostEqual(
            price_mc,
            expected,
            delta=tolerance)

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_indexes
"""
 Copyright (C) 2011, Enthought Inc
 Copyright (C) 2011, Patrick Henaff

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
"""

from .unittest_tools import unittest

from quantlib.currency import USDCurrency
from quantlib.index import Index
from quantlib.indexes.interest_rate_index import InterestRateIndex
from quantlib.indexes.libor import Libor
from quantlib.indexes.swap_index import SwapIndex
from quantlib.indexes.euribor import Euribor6M
from quantlib.settings import Settings
from quantlib.time.api import (Days, Months, Period, TARGET, Actual360,
                               today, Actual365Fixed)
from quantlib.time.api import Following
from quantlib.termstructures.yields.api import (
    FlatForward, YieldTermStructure)
from quantlib.time.api import Date, January


class TestIndex(unittest.TestCase):

    def test_create_index(self):

        with self.assertRaises(ValueError):
            Index()


class TestIRIndex(unittest.TestCase):

    def test_create_index(self):

        with self.assertRaises(ValueError):
            InterestRateIndex()


class TestLibor(unittest.TestCase):

    def test_create_libor_index(self):

        settings = Settings.instance()

        # Market information
        calendar = TARGET()

        # must be a business day
        eval_date = calendar.adjust(today())
        settings.evaluation_date = eval_date

        settlement_days = 2
        settlement_date = calendar.advance(eval_date, settlement_days, Days)
        # must be a business day
        settlement_date = calendar.adjust(settlement_date)

        term_structure = YieldTermStructure(relinkable=True)
        term_structure.link_to(FlatForward(settlement_date, 0.05,
                                           Actual365Fixed()))

        index = Libor('USD Libor', Period(6, Months), settlement_days,
                      USDCurrency(), calendar, Actual360(),
                      term_structure)

        t = index.tenor
        self.assertEquals(t.length, 6)
        self.assertEquals(t.units, 2)
        self.assertEquals('USD Libor6M Actual/360', index.name)


class TestEuribor(unittest.TestCase):

    def test_creation(self):

        settlement_date = Date(1, January, 2014)
        term_structure = YieldTermStructure(relinkable=True)
        term_structure.link_to(FlatForward(settlement_date, 0.05,
                                          Actual365Fixed()))
        # Makes sure the constructor does not segfault anymore ;-)
        index = Euribor6M(term_structure)

        self.assertEquals(index.name, 'Euribor6M Actual/360')


class SwapIndexTestCase(unittest.TestCase):

    def test_create_swap_index(self):

        settings = Settings.instance()

        # Market information
        calendar = TARGET()

        # must be a business day
        eval_date = calendar.adjust(today())
        settings.evaluation_date = eval_date

        settlement_days = 2
        settlement_date = calendar.advance(eval_date, settlement_days, Days)
        # must be a business day
        settlement_date = calendar.adjust(settlement_date)
        term_structure = YieldTermStructure(relinkable=True)
        term_structure.link_to(FlatForward(settlement_date, 0.05,
                                          Actual365Fixed()))

        ibor_index = Libor('USD Libor', Period(6, Months), settlement_days,
                        USDCurrency(), calendar, Actual360(),
                           term_structure)

        index = SwapIndex(
            'family name', Period(3, Months), 10, USDCurrency(), TARGET(),
            Period(12, Months), Following, Actual360(), ibor_index)

        self.assertIsNotNone(index)


if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_interest_rate
from .unittest_tools import unittest

from quantlib.interest_rate import InterestRate

from quantlib.compounding import Continuous, Compounded
from quantlib.time.api import Actual360, Monthly, NoFrequency, Once


class InterestRateTestCase(unittest.TestCase):

    def setUp(self):

        self.day_counter = Actual360()

    def test_create_interest_rate_frequency_makes_no_sense(self):

        rate = 0.05
        counter = self.day_counter
        compounding = Continuous
        frequency = Monthly

        interest_rate = InterestRate(rate, counter, compounding, frequency)

        self.assertAlmostEquals(interest_rate.rate, rate)
        self.assertEquals(interest_rate.compounding, compounding)

        # Returns NoFrequency when it does not make sense
        self.assertEquals(interest_rate.frequency, NoFrequency)

        # Broken check. DayCoonter != Actual360
        self.assertEquals(interest_rate.day_counter, Actual360())

    def test_create_interest_rate_compounded(self):

        rate = 0.05
        counter = self.day_counter
        compounding = Compounded
        frequency = Monthly

        interest_rate = InterestRate(rate, counter, compounding, frequency)

        self.assertAlmostEquals(interest_rate.rate, rate)
        self.assertEquals(interest_rate.compounding, compounding)
        self.assertEquals(interest_rate.frequency, Monthly)

    def test_create_interest_rate_compounded_error(self):

        rate = 0.05
        counter = self.day_counter
        compounding = Compounded

        for frequency in [Once, NoFrequency]:
            with self.assertRaises(RuntimeError):
                InterestRate(rate, counter, compounding, frequency)

    def test_repr(self):

        rate = 0.05
        counter = self.day_counter
        compounding = Compounded
        frequency = Monthly

        interest_rate = InterestRate(rate, counter, compounding, frequency)

        self.assertEquals(
            repr(interest_rate),
            "0.05 Actual/360 Monthly compounding"
        )


if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_market
from .unittest_tools import unittest

from quantlib.compounding import Simple
from quantlib.time.api import Date, Actual360
from quantlib.market.market import libor_market, IborMarket


class MarketTestCase(unittest.TestCase):

    def test_libor_market(self):
        """
        Basic test of Libor market
        Not checking numerical accuracy
        """

        # US libor market, with default conventions:
        # semi-annual fixed vs. 3M Libor
        m = libor_market('USD(NY)')

        # add quotes
        eval_date = Date(20, 9, 2004)

        quotes = [('DEP', '1W', 0.0382),
                  ('DEP', '1M', 0.0372),
                  ('DEP', '3M', 0.0363),
                  ('DEP', '6M', 0.0353),
                  ('DEP', '9M', 0.0348),
                  ('DEP', '1Y', 0.0345),
                  ('SWAP', '2Y', 0.037125),
                  ('SWAP', '3Y', 0.0398),
                  ('SWAP', '5Y', 0.0443),
                  ('SWAP', '10Y', 0.05165),
                  ('SWAP', '15Y', 0.055175)]

        m.set_quotes(eval_date, quotes)

        m.bootstrap_term_structure()

        dt = Date(1, 1, 2010)
        df = m.discount(dt)

        print('discount factor for %s (USD Libor): %f' % (dt, df))

        # Euribor market, with default conventions:
        # annual fixed vs. 6M Libor
        m = libor_market('EUR:>1Y')

        m.set_quotes(eval_date, quotes)

        m.bootstrap_term_structure()

        df = m.discount(dt)

        print('discount factor for %s (Euribor): %f' % (dt, df))
        self.assertTrue(df > 0)

    def test_ed(self):
        """
        Curve construction with EuroDollar futures
        Not checking numerical accuracy
        """

        # US libor market, with default conventions:
        # semi-annual fixed vs. 3M Libor
        m = libor_market('USD(LONDON)')

        # add quotes
        eval_date = Date(20, 9, 2004)

        quotes = [
            ('ED', 1, 96.2875),
            ('ED', 2, 96.7875),
            ('ED', 3, 96.9875),
            ('ED', 4, 96.6875),
            ('ED', 5, 96.4875),
            ('ED', 6, 96.3875),
            ('ED', 7, 96.2875),
            ('ED', 8, 96.0875)]

        m.set_quotes(eval_date, quotes)

        m.bootstrap_term_structure()

        dt = Date(1, 1, 2005)
        df = m.discount(dt)

        print('discount factor for %s (USD Libor): %f' % (dt, df))

        self.assertTrue(df > 0)

    def test_euribor(self):
        """
        Market tests for Euribor futures.

        Not checking numerical accuracy.

        """
        # Euribor market instance.
        m = IborMarket('Euribor Market', 'EUR:1Y')

        evaluation_date = Date(20, 3, 2014)
        quotes = [
            (u'ERM4', Date(18,  6, 2014), 99.67),
            (u'ERU4', Date(17,  9, 2014), 99.67),
            (u'ERZ4', Date(17, 12, 2014), 99.66),
            (u'ERH5', Date(18,  3, 2015), 99.63),
            (u'ERM5', Date(17,  6, 2015), 99.59),
            (u'ERU5', Date(16,  9, 2015), 99.53),
            (u'ERZ5', Date(16, 12, 2015), 99.46),
            (u'ERH6', Date(16,  3, 2016), 99.38),
        ]

        m.set_quotes(evaluation_date, quotes)
        m.bootstrap_term_structure()

        dt = Date(20, 6, 2014)
        df = m.discount(dt)
        self.assertTrue(df > 0)

    def test_fixed_rate_bonds(self):
        """
        Market tests for fixed rate bond quotes.

        Not checking numerical accuracy.

        """
        m = IborMarket('Euribor Market', 'EUR:1Y')

        evaluation_date = Date(20, 3, 2014)
        quotes = [
            (103.455, [0.02], '1Y', Date(14, 1, 2011), Date(26, 2, 2016)),
            (100.075, [0.0025], '1Y', Date(14, 2, 2014), Date(11, 3, 2016)),
            (105.15, [0.0275], '1Y', Date(26, 4, 2011), Date(8, 4, 2016))
        ]

        m.set_bonds(evaluation_date, quotes)
        m.bootstrap_term_structure()

        dt = Date(20, 6, 2014)
        df = m.discount(dt)
        self.assertTrue(df > 0)

    def test_market_internals(self):
        # FIXME: this should be a test case in its own right, closer to
        # YieldTermStructure.

        m = libor_market('USD(NY)')
        eval_date = Date(20, 9, 2004)

        quotes = [('DEP', '1W', 0.0382),
                  ('DEP', '1M', 0.0372),
                  ('DEP', '3M', 0.0363),
                  ('DEP', '6M', 0.0353),
                  ('DEP', '9M', 0.0348),
                  ('DEP', '1Y', 0.0345)]

        m.set_quotes(eval_date, quotes)
        ts = m.bootstrap_term_structure()

        # Compute zero and forward rates.
        zero_rate = ts.zero_rate(Date(1, 1, 2005), Actual360(), Simple)
        forward_rate = ts.forward_rate(Date(1, 1, 2005), Date(30, 1, 2005),
                                       Actual360(), Simple)

        # We don't test for numerical accuracy.
        self.assertGreater(zero_rate.rate, 0)
        self.assertGreater(forward_rate.rate, 0)

        # Check that the linked term structures are consistent with the
        # original term structure.
        discount_ts = m._discount_term_structure
        forecast_ts = m._forecast_term_structure
        self.assertIsNotNone(discount_ts)
        self.assertIsNotNone(forecast_ts)

        for linked_ts in [discount_ts, forecast_ts]:
            rate = linked_ts.zero_rate(
                Date(1, 1, 2005), Actual360(), Simple)
            self.assertEqual(rate.rate, zero_rate.rate)

            rate = linked_ts.forward_rate(
                Date(1, 1, 2005), Date(30, 1, 2005), Actual360(), Simple)
            self.assertEqual(rate.rate, forward_rate.rate)


if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_mlab
from .unittest_tools import unittest

from datetime import date
from quantlib.mlab.option_pricing import heston_pricer, blsprice, blsimpv
from quantlib.mlab.fixed_income import bndprice, cfamounts
from quantlib.mlab.term_structure import zbt_libor_yield

from quantlib.util.rates import make_rate_helper, zero_rate
import quantlib.reference.names as nm
import quantlib.reference.data_structures as ds

from quantlib.termstructures.yields.piecewise_yield_curve import \
    term_structure_factory
from quantlib.time.api import ActualActual, ISDA
from quantlib.util.converter import pydate_to_qldate


class MLabTestCase(unittest.TestCase):

    def test_heston_pricer(self):

        trade_date = date(2011, 1, 24)
        spot = 1290.58

        # option definition
        options = ds.option_quotes_template().reindex(index=range(2))
        options[nm.OPTION_TYPE] = ['C', 'P']
        options[nm.STRIKE] = [1290, 1290]
        options[nm.EXPIRY_DATE] = [date(2015, 1, 1), date(2015, 1, 1)]
        options[nm.SPOT] = [spot] * 2

        # interest rate and dividend yield
        rates = ds.riskfree_dividend_template().reindex(
            index=[date(2011, 3, 16), date(2013, 3, 16), date(2015, 3, 16)])
        rates[nm.DIVIDEND_YIELD] = [.021, .023, .024]
        rates[nm.INTEREST_RATE] = [.010, .015, .019]

        # heston model
        heston_params = dict(v0=0.051965,
            kappa=0.977314, theta=0.102573,
            sigma=0.987796, rho=-0.747033
        )

        results = heston_pricer(trade_date, options,
                                heston_params, rates, spot=1290.58)

        price_call = results[nm.PRICE][0]
        price_put = results[nm.PRICE][1]

        self.assertAlmostEqual(price_call, 194.6, 1)
        self.assertAlmostEqual(price_put, 218.9, 1)

    def test_blsprice(self):
        """
        from maltab documentation of blsprice
        """
        p = blsprice(spot=585, strike=600, risk_free_rate=.05,
                     time=1 / 4., volatility=.25,
                     option_type=('Call', 'Put'),
                     dividend=0.045)

        self.assertAlmostEquals(p[0], 22.6716, 3)
        self.assertAlmostEquals(p[1], 36.7626, 3)

        v = blsimpv(p, spot=585, strike=600, risk_free_rate=.05,
                     time=1 / 4.,
                     option_type=('Call', 'Put'),
                     dividend=0.045)

        self.assertAlmostEquals(v[0], .25, 3)
        self.assertAlmostEquals(v[1], .25, 3)

    def test_yield(self):

        rates_data = [('Libor1M', .01),
                  ('Libor3M', .015),
                  ('Libor6M', .017),
                  ('Swap1Y', .02),
                  ('Swap2Y', .03),
                  ('Swap3Y', .04),
                  ('Swap5Y', .05),
                  ('Swap7Y', .06),
                  ('Swap10Y', .07),
                  ('Swap20Y', .08)]

        settlement_date = pydate_to_qldate('01-Dec-2013')
        rate_helpers = []
        for label, rate in rates_data:
            h = make_rate_helper(label, rate, settlement_date)
            rate_helpers.append(h)

            ts_day_counter = ActualActual(ISDA)
            tolerance = 1.0e-15

        ts = term_structure_factory('discount', 'loglinear',
         settlement_date, rate_helpers,
         ts_day_counter, tolerance)

        zc = zero_rate(ts, (200, 300), settlement_date)
        # not a real test - just verify execution
        self.assertAlmostEqual(zc[1][0], 0.0189, 2)

    def test_bndprice(self):
        """
        Test from Matlab bndprice help
        ac is matched exactly
        price accurate to 10^-3
        """

        Yield = [0.04, 0.05, 0.06]
        CouponRate = 0.05
        Maturity = '15-Jun-2002'

        (price, ac) = bndprice(bond_yield=Yield, coupon_rate=CouponRate,
                           pricing_date='18-Jan-1997',
                           maturity_date=Maturity,
                           period='Semiannual',
                           basis='Actual/Actual (Bond)',
                           compounding_frequency='Semiannual')

        # Matlab values
        ml_price = [104.8106, 99.9951, 95.4384]
        ml_ac = [0.4945, ] * 3
        for i, p in enumerate(price):
            self.assertAlmostEqual(p, ml_price[i], 2)

        for i, a in enumerate(ac):
            self.assertAlmostEqual(a, ml_ac[i], 3)

    def test_cfamounts(self):
        """
        Test from Matlab cfamounts help
        """

        CouponRate = 0.05
        Maturity = '15-Jun-1995'

        res = cfamounts(coupon_rate=CouponRate,
                           pricing_date='29-oct-1993',
                           maturity_date=Maturity,
                           period='Semiannual',
                           basis='Actual/Actual (Bond)')

        for cf, dt in zip(*res):
            print('%s %7.2f' % (dt, cf))

        dt = res[1]
        cf = res[0]
        pydate = date(1993, 6, 15)

        self.assertEquals(cf[6], 100.0)
        self.assertEquals(dt[1], pydate)

    def test_greeks(self):
        """
        From Matlab help for blsdelta, blsgamma
        """
        c, p = blsprice(spot=50, strike=50, risk_free_rate=.1,
                  time=0.25, volatility=.3,
                  option_type=('Call', 'Put'), calc='delta')

        matlab_c = 0.5955
        matlab_p = -0.4045

        self.assertAlmostEqual(c, matlab_c, 3)
        self.assertAlmostEqual(p, matlab_p, 3)

        g = blsprice(spot=50, strike=50, risk_free_rate=.12,
                  time=0.25, volatility=.3,
                  option_type='Call', calc='gamma')

        matlab_g = 0.0512
        self.assertAlmostEqual(g, matlab_g, 3)

    def test_zero_rate(self):
        """
        Not a real test - just verifies that it runs
        """

        instruments = ['Libor1M',
                   'Libor3M',
                   'Libor6M',
                   'Swap1Y',
                   'Swap2Y',
                   'Swap3Y',
                   'Swap5Y',
                   'Swap7Y',
                   'Swap10Y',
                   'Swap20Y',
                   'Swap30Y']
        yields = [.01, .015, .02, .03, .04,
              .05, .06, .07, .08, .09,
              .1]

        pricing_date = '01-dec-2013'
        dt, rates = zbt_libor_yield(instruments, yields, pricing_date,
                    compounding_freq='Continuous',
                    maturity_dates=None)

        self.assertAlmostEqual(rates[0], .01, 3)

########NEW FILE########
__FILENAME__ = test_notebooks
from .unittest_tools import unittest

import pandas
import numpy as np
from pandas import DataFrame

import quantlib.reference.names as nm
from quantlib.pricingengines.blackformula import blackFormulaImpliedStdDev

def Compute_IV(optionDataFrame, tMin=0, nMin=0, QDMin=0, QDMax=1,
               keepOTMData=True):

    """
    Pre-processing of a standard European option quote file.
    - Calculation of implied risk-free rate and dividend yield
    - Calculation of implied volatility
    - Estimate ATM volatility for each expiry
    - Compute implied volatility and Quick Delta for each quote

    Options for filtering the input data set: 
    - maturities with less than nMin strikes are ignored
    - maturities shorter than tMin (ACT/365 daycount) are ignored
    - strikes with Quick Delta < qdMin or > qdMax are ignored
    """

    grouped = optionDataFrame.groupby(nm.EXPIRY_DATE)

    isFirst = True
    for spec, group in grouped:
        print('processing group %s' % spec)

        # implied vol for this type/expiry group

        indx = group.index

        dtTrade = group[nm.TRADE_DATE][indx[0]]
        dtExpiry = group[nm.EXPIRY_DATE][indx[0]]
        spot = group[nm.SPOT][indx[0]]
        daysToExpiry = (dtExpiry - dtTrade).days
        timeToMaturity = daysToExpiry / 365.0

        # exclude groups with too short time to maturity

        if timeToMaturity < tMin:
            continue

        # exclude groups with too few data points

        df_call = group[group[nm.OPTION_TYPE] == nm.CALL_OPTION]
        df_put = group[group[nm.OPTION_TYPE] == nm.PUT_OPTION]

        if (len(df_call) < nMin) | (len(df_put) < nMin):
            continue

        # calculate forward, implied interest rate and implied div. yield

        df_C = DataFrame((df_call['PBid'] + df_call['PAsk']) / 2,
                         columns=['PremiumC'])
        df_C.index = df_call['Strike'].values

        df_P = DataFrame((df_put['PBid'] + df_put['PAsk']) / 2,
                         columns=['PremiumP'])
        df_P.index = df_put['Strike'].values

        # use 'inner' join because some strikes are not quoted for C and P
        df_all = df_C.join(df_P, how='inner')
        df_all['Strike'] = df_all.index
        df_all['C-P'] = df_all['PremiumC'] - df_all['PremiumP']

        y = np.array(df_all['C-P'])
        x = np.array(df_all['Strike'])
        A = np.vstack((x, np.ones(x.shape))).T

        b = np.linalg.lstsq(A, y)[0]

        # intercept is last coef
        iRate = -np.log(-b[0]) / timeToMaturity
        dRate = np.log(spot / b[1]) / timeToMaturity

        discountFactor = np.exp(-iRate * timeToMaturity)
        Fwd = spot * np.exp((iRate - dRate) * timeToMaturity)

        print('Fwd: %f int rate: %f div yield: %f' % (Fwd, iRate, dRate))

        # mid-market ATM volatility

        def impvol(cp, strike, premium):
            try:
                vol = blackFormulaImpliedStdDev(cp, strike,
                    forward=Fwd, blackPrice=premium, discount=discountFactor,
                    TTM=timeToMaturity)
            except:
                vol = np.nan
            return vol / np.sqrt(timeToMaturity)

        # implied bid/ask vol for all options

        df_call['IVBid'] = [impvol('C', strike, price) for strike, price
                            in zip(df_call['Strike'], df_call['PBid'])]
        df_call['IVAsk'] = [impvol('C', strike, price) for strike, price
                            in zip(df_call['Strike'], df_call['PAsk'])]

        df_call['IVMid'] = (df_call['IVBid'] + df_call['IVAsk']) / 2

        df_put['IVBid'] = [impvol('P', strike, price) for strike, price
                           in zip(df_put['Strike'], df_put['PBid'])]
        df_put['IVAsk'] = [impvol('P', strike, price) for strike, price
                           in zip(df_put['Strike'], df_put['PAsk'])]

        df_put['IVMid'] = (df_put['IVBid'] + df_put['IVAsk']) / 2

        # f_call = interp1d(df_call['Strike'].values, df_call['IVMid'].values)
        # f_put = interp1d(df_put['Strike'].values, df_put['IVMid'].values)

        # atmVol = (f_call(Fwd) + f_put(Fwd)) / 2
        atmVol = .20
        print('ATM vol: %f' % atmVol)

        # Quick Delta, computed with ATM vol
        df_call['QuickDelta'] = 0.5
        df_put['QuickDelta'] = 0.5

        # keep data within QD range

        df_call = df_call[(df_call['QuickDelta'] >= QDMin) & \
                          (df_call['QuickDelta'] <= QDMax) ]

        df_put = df_put[(df_put['QuickDelta'] >= QDMin) & \
                        (df_put['QuickDelta'] <= QDMax) ]

        # final assembly...

        df_cp = df_call.append(df_put, ignore_index=True)
        df_cp[nm.INTEREST_RATE] = iRate 
        df_cp[nm.DIVIDEND_YIELD] = dRate 
        df_cp[nm.ATMVOL] = atmVol 
        df_cp[nm.FORWARD] = Fwd

        # keep only OTM data ?
        if keepOTMData:
            df_cp = df_cp[((df_cp[nm.STRIKE]>=Fwd) & (df_cp[nm.OPTION_TYPE] == nm.CALL_OPTION)) |
                          ((df_cp[nm.STRIKE]<Fwd) & (df_cp[nm.OPTION_TYPE] == nm.PUT_OPTION))]

        if isFirst:
            df_final = df_cp
            isFirst = False
        else:
            df_final = df_final.append(df_cp, ignore_index=True)

    return df_final


class NoteBooksTestCase(unittest.TestCase):
    """
    Test some functions used in notebooks.
    Mostly useful to test stability of pandas API
    """

    def test_option_quotes(self):

        option_data_frame = \
                          pandas.core.common.load('./quantlib/test/data/df_SPX_24jan2011.pkl')

        df_final = Compute_IV(option_data_frame, tMin=1 / 12,
                              nMin=6, QDMin=.2, QDMax=.8)

        print('Number of rows: %d' % len(df_final.index))
        self.assertEqual(len(df_final.index), 553, 'Wrong number of rows')

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_parse_ql_version_string
from .unittest_tools import unittest

from quantlib.util.version import parse_ql_version_string


class TestParseQlVersionString(unittest.TestCase):

    def test_match_valid(self):

        version = parse_ql_version_string("1.2")
        self.assertEqual(version, (1, 2, None, None))
        version = parse_ql_version_string("1.2.3")
        self.assertEqual(version, (1, 2, 3, None))
        version = parse_ql_version_string("1.2.3-rc4")
        self.assertEqual(version, (1, 2, 3, 'rc4'))
        version = parse_ql_version_string("1.2-rc4")
        self.assertEqual(version, (1, 2, None, 'rc4'))

    def test_match_invalid(self):

        with self.assertRaises(ValueError):
            parse_ql_version_string("1")
        with self.assertRaises(ValueError):
            parse_ql_version_string("1-rc2")
        with self.assertRaises(ValueError):
            parse_ql_version_string("1.2.3.4.5")

########NEW FILE########
__FILENAME__ = test_payoff
from .unittest_tools import unittest

from quantlib.instruments.payoffs import PlainVanillaPayoff, PAYOFF_TO_STR, Call


class PayoffTestCase(unittest.TestCase):

    def test_plain_vaniila_payoff(self):

        payoff = PlainVanillaPayoff('call', 10.0)

        self.assertEquals(PAYOFF_TO_STR[payoff.type], 'Call')
        self.assertEquals(payoff.strike, 10.0)


        payoff = PlainVanillaPayoff(Call, 10.0)

        self.assertEquals(payoff.type, Call)
        self.assertEquals(payoff.strike, 10.0)

########NEW FILE########
__FILENAME__ = test_piecewise_yield_curve
"""
 Copyright (C) 2011, Enthought Inc
 Copyright (C) 2011, Patrick Henaff

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
"""

from .unittest_tools import unittest

from quantlib.currency import USDCurrency
from quantlib.indexes.swap_index import SwapIndex
from quantlib.settings import Settings
from quantlib.termstructures.yields.rate_helpers import (
    DepositRateHelper, SwapRateHelper)
from quantlib.termstructures.yields.piecewise_yield_curve import (
    term_structure_factory, VALID_TRAITS, VALID_INTERPOLATORS,
    PiecewiseYieldCurve)
from quantlib.time.api import Date, TARGET, Period, Months, Years, Days
from quantlib.time.api import September, ISDA, today, Mar
from quantlib.time.api import ModifiedFollowing, Unadjusted, Actual360
from quantlib.time.api import Thirty360, ActualActual, Actual365Fixed
from quantlib.time.api import Annual, UnitedStates
from quantlib.quotes import SimpleQuote
from quantlib.termstructures.yields.api import YieldTermStructure
from quantlib.indexes.libor import Libor


class PiecewiseYieldCurveTestCase(unittest.TestCase):

    def test_creation(self):

        settings = Settings()

        # Market information
        calendar = TARGET()

        # must be a business day
        settings.evaluation_date = calendar.adjust(today())

        settlement_date = Date(18, September, 2008)
        # must be a business day
        settlement_date = calendar.adjust(settlement_date);

        quotes = [0.0096, 0.0145, 0.0194]
        tenors =  [3, 6, 12]

        rate_helpers = []

        calendar =  TARGET()
        deposit_day_counter = Actual365Fixed()
        convention = ModifiedFollowing
        end_of_month = True

        for quote, month in zip(quotes, tenors):
            tenor = Period(month, Months)
            fixing_days = 3

            helper = DepositRateHelper(
                quote, tenor, fixing_days, calendar, convention, end_of_month,
                deposit_day_counter
            )

            rate_helpers.append(helper)


        ts_day_counter = ActualActual(ISDA)

        tolerance = 1.0e-15

        ts = term_structure_factory(
            'discount', 'loglinear', settlement_date, rate_helpers,
            ts_day_counter, tolerance
        )

        self.assertIsNotNone(ts)

        self.assertEquals( Date(18, September, 2008), ts.reference_date)

        # this is not a real test ...
        self.assertAlmostEquals(0.9975, ts.discount(Date(21, 12, 2008)), 4)
        self.assertAlmostEquals(0.9944, ts.discount(Date(21, 4, 2009)), 4)
        self.assertAlmostEquals(0.9904, ts.discount(Date(21, 9, 2009)), 4)

    def test_all_types_of_piecewise_curves(self):

        settings = Settings()

        # Market information
        calendar = TARGET()

        todays_date = Date(12, September, 2008)
        # must be a business day
        settings.evaluation_date = calendar.adjust(todays_date)

        settlement_date = Date(18, September, 2008)
        # must be a business day
        settlement_date = calendar.adjust(settlement_date);

        quotes = [0.0096, 0.0145, 0.0194]
        tenors =  [3, 6, 12]

        rate_helpers = []

        deposit_day_counter = Actual365Fixed()
        convention = ModifiedFollowing
        end_of_month = True

        for quote, month in zip(quotes, tenors):
            tenor = Period(month, Months)
            fixing_days = 3

            helper = DepositRateHelper(
                quote, tenor, fixing_days, calendar, convention, end_of_month,
                deposit_day_counter
            )

            rate_helpers.append(helper)


        tolerance = 1.0e-15 

        for trait in VALID_TRAITS:
            for interpolation in VALID_INTERPOLATORS:
                ts = PiecewiseYieldCurve(
                    trait, interpolation, settlement_date, rate_helpers,
                    deposit_day_counter, tolerance
                )

                self.assertIsNotNone(ts)
                self.assertEquals( Date(18, September, 2008), ts.reference_date)


    def test_deposit_swap(self):

        settings = Settings()

        # Market information
        calendar = TARGET()

        todays_date = Date(1, Mar, 2012)

        # must be a business day
        eval_date = calendar.adjust(todays_date)
        settings.evaluation_date = eval_date

        settlement_days = 2
        settlement_date = calendar.advance(eval_date, settlement_days, Days)
        # must be a business day
        settlement_date = calendar.adjust(settlement_date);

        depositData = [[ 1, Months, 4.581 ],
                       [ 2, Months, 4.573 ],
                       [ 3, Months, 4.557 ],
                       [ 6, Months, 4.496 ],
                       [ 9, Months, 4.490 ]]

        swapData = [[ 1, Years, 4.54 ],
                    [ 5, Years, 4.99 ],
                    [ 10, Years, 5.47 ],
                    [ 20, Years, 5.89 ],
                    [ 30, Years, 5.96 ]]

        rate_helpers = []

        end_of_month = True

        for m, period, rate in depositData:
            tenor = Period(m, Months)

            helper = DepositRateHelper(rate/100, tenor, settlement_days,
                     calendar, ModifiedFollowing, end_of_month,
                     Actual360())

            rate_helpers.append(helper)

        liborIndex = Libor('USD Libor', Period(6, Months), settlement_days,
                           USDCurrency(), calendar, Actual360(),
                           YieldTermStructure(relinkable=False))

        spread = SimpleQuote(0)
        fwdStart = Period(0, Days)

        for m, period, rate in swapData:

            helper = SwapRateHelper.from_tenor(
                rate/100, Period(m, Years), calendar, Annual, Unadjusted, Thirty360(), liborIndex,
                spread, fwdStart
            )

            rate_helpers.append(helper)

        ts_day_counter = ActualActual(ISDA)
        tolerance = 1.0e-15

        ts = term_structure_factory(
            'discount', 'loglinear', settlement_date, rate_helpers,
            ts_day_counter, tolerance)

        self.assertEquals(settlement_date, ts.reference_date)

        # this is not a real test ...
        self.assertAlmostEquals(0.9103,
             ts.discount(calendar.advance(todays_date, 2, Years)),3)
        self.assertAlmostEquals(0.7836,
             ts.discount(calendar.advance(todays_date, 5, Years)),3)
        self.assertAlmostEquals(0.5827,
             ts.discount(calendar.advance(todays_date, 10, Years)),3)
        self.assertAlmostEquals(0.4223,
             ts.discount(calendar.advance(todays_date, 15, Years)),3)


    #@unittest.skip('This segfaults')
    def test_zero_curve_on_swap_index(self):

        todays_date = today()

        calendar = UnitedStates() # INPUT
        dayCounter = Actual360() # INPUT
        currency = USDCurrency() # INPUT	

        Settings.instance().evaluation_date = todays_date
        settlement_days	= 2

        settlement_date =  calendar.advance(
            todays_date, period=Period(settlement_days, Days)
        )

        liborRates = [ 0.002763, 0.004082, 0.005601, 0.006390, 0.007125, 0.007928, 0.009446,
            0.01110]
        liborRatesTenor = [Period(tenor, Months) for tenor in [1,2,3,4,5,6,9,12]]
        Libor_dayCounter = Actual360();


        swapRates = [0.005681, 0.006970, 0.009310, 0.012010, 0.014628, 0.016881, 0.018745,
                 0.020260, 0.021545]
        swapRatesTenor = [Period(i, Years) for i in range(2, 11)]
        # description of the fixed leg of the swap
        Swap_fixedLegTenor = Period(12, Months)      # INPUT
        Swap_fixedLegConvention = ModifiedFollowing  # INPUT
        Swap_fixedLegDayCounter = Actual360()        # INPUT
        # description of the float leg of the swap
        Swap_iborIndex = Libor(
            "USDLibor", Period(3, Months), settlement_days, USDCurrency(),
            UnitedStates(), Actual360(), YieldTermStructure(relinkable=False)
        )

        SwapFamilyName = currency.name + "swapIndex"
        instruments = []

        # ++++++++++++++++++++ Creation of the vector of RateHelper (need for the Yield Curve construction)
        # ++++++++++++++++++++ Libor 
        LiborFamilyName = currency.name + "Libor"
        instruments = []
        for rate, tenor in zip(liborRates, liborRatesTenor):
            # Index description ___ creation of a Libor index
            liborIndex =  Libor(LiborFamilyName, tenor, settlement_days,
                                currency, calendar, Libor_dayCounter,
                                YieldTermStructure(relinkable=False))
            # Initialize rate helper
            # the DepositRateHelper link the recording rate with the Libor
            # index

            instruments.append(DepositRateHelper(rate, index=liborIndex))


        for tenor, rate in zip(swapRatesTenor, swapRates):
            # swap description ___ creation of a swap index. The floating leg is described in the index 'Swap_iborIndex'
            swapIndex = SwapIndex (SwapFamilyName, tenor, settlement_days, currency, calendar,
                    Swap_fixedLegTenor, Swap_fixedLegConvention, Swap_fixedLegDayCounter,
                    Swap_iborIndex)
            # Initialize rate helper __ the SwapRateHelper links the swap index width his rate
            instruments.append(SwapRateHelper.from_index(rate,swapIndex))

        # ++++++++++++++++++  Now the creation of the yield curve

        tolerance = 1.0e-15

        ts = term_structure_factory(
            'zero', 'linear', settlement_date, instruments, dayCounter, tolerance
        )

        self.assertEquals(settlement_date, ts.reference_date)

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_process
from .unittest_tools import unittest
from quantlib.models.equity.bates_model import (BatesModel, BatesDoubleExpModel)
from quantlib.processes.heston_process import HestonProcess
from quantlib.processes.bates_process import BatesProcess

from quantlib.settings import Settings
from quantlib.time.api import (
    today, NullCalendar, ActualActual
)
from quantlib.termstructures.yields.flat_forward import FlatForward
from quantlib.quotes import SimpleQuote


def flat_rate(forward, daycounter):
    return FlatForward(
        forward = SimpleQuote(forward),
        settlement_days = 0,
        calendar = NullCalendar(),
        daycounter = daycounter
    )


class ProcessTestCase(unittest.TestCase):

    def setUp(self):
        settlement_date = today()

        settings = Settings()
        settings.evaluation_date = settlement_date

        daycounter = ActualActual()
        self.calendar = NullCalendar()

        i_rate = .1
        i_div = .04

        self.risk_free_ts = flat_rate(i_rate, daycounter)
        self.dividend_ts = flat_rate(i_div, daycounter)

        self.s0 = SimpleQuote(32.0)

        # Bates model

        self.v0 = 0.05
        self.kappa = 5.0
        self.theta = 0.05
        self.sigma = 1.0e-4
        self.rho = 0.0
        self.Lambda = .1
        self.nu = .01
        self.delta = .001

    def test_batest_process(self):
        pb = BatesProcess(self.risk_free_ts, self.dividend_ts, self.s0, self.v0,
                          self.kappa, self.theta, self.sigma, self.rho,
                          self.Lambda, self.nu, self.delta)

        self.assertIsNotNone(pb)

        mb = BatesModel(pb)

        self.assertIsNotNone(mb)

    def test_heston_process(self):

        ph = HestonProcess(self.risk_free_ts, self.dividend_ts, self.s0, self.v0,
                            self.kappa, self.theta, self.sigma, self.rho)
        self.assertIsNotNone(ph)

        # constructor with default arguments
        me = BatesDoubleExpModel(ph)
        self.assertIsNotNone(me)

        # speficy the arguments
        me = BatesDoubleExpModel(ph, Lambda=0.234, nuUp=0.43, nuDown=0.54, p=.6)
        self.assertIsNotNone(me)

if __name__ == '__main__':
    unittest.main()


########NEW FILE########
__FILENAME__ = test_quotes
from .unittest_tools import unittest

from quantlib.quotes import SimpleQuote


class SimpleQuoteTestCase(unittest.TestCase):

    def test_round_trip(self):

        value = 72.03
        quote = SimpleQuote(value)
        self.assertLess(abs(value - quote.value), 1e-12)

########NEW FILE########
__FILENAME__ = test_rate_helpers
from .unittest_tools import unittest

from quantlib.quotes import SimpleQuote
from quantlib.time.api import Period, Months, TARGET, ModifiedFollowing
from quantlib.time.api import Actual365Fixed, Date
from quantlib.termstructures.yields.rate_helpers import DepositRateHelper
from quantlib.termstructures.yields.rate_helpers import FraRateHelper
from quantlib.termstructures.yields.rate_helpers import FuturesRateHelper
from quantlib.termstructures.yields.rate_helpers import SwapRateHelper
from quantlib.termstructures.yields.api import YieldTermStructure


class RateHelpersTestCase(unittest.TestCase):

    def test_create_deposit_rate_helper(self):

        quote = 0.0096
        tenor = Period(3, Months)
        fixing_days = 3
        calendar =  TARGET()
        convention = ModifiedFollowing
        end_of_month = True
        deposit_day_counter = Actual365Fixed()


        helper = DepositRateHelper(
            quote, tenor, fixing_days, calendar, convention, end_of_month,
            deposit_day_counter
        )

        self.assertIsNotNone(helper)
        self.assertEquals(quote, helper.quote)


    def test_create_fra_rate_helper(self):

        quote = SimpleQuote(0.0096)
        month_to_start = 3
        month_to_end = 9
        fixing_days = 2
        calendar =  TARGET()
        convention = ModifiedFollowing
        end_of_month = True
        day_counter = Actual365Fixed()


        helper = FraRateHelper(
            quote, month_to_start, month_to_end, fixing_days, calendar,
            convention, end_of_month, day_counter
        )

        self.assertIsNotNone(helper)
        self.assertEquals(quote.value, helper.quote)

    def test_create_futures_rate_helper(self):

        quote = SimpleQuote(0.0096)
        imm_date = Date(19, 12, 2001)
        length_in_months = 9
        calendar =  TARGET()
        convention = ModifiedFollowing
        end_of_month = True
        day_counter = Actual365Fixed()


        helper = FuturesRateHelper(
            quote, imm_date, length_in_months, calendar,
            convention, end_of_month, day_counter
        )

        self.assertIsNotNone(helper)
        self.assertEquals(quote.value, helper.quote)


    def test_create_swap_rate_helper_no_classmethod(self):

        with self.assertRaises(ValueError):
            SwapRateHelper()


    def test_create_swap_rate_helper_from_index(self):

        from quantlib.currency import USDCurrency
        from quantlib.indexes.swap_index import SwapIndex
        from quantlib.indexes.libor import Libor
        from quantlib.time.api import Years, UnitedStates, Actual360

        calendar = UnitedStates()
        settlement_days = 2
        currency = USDCurrency()
        fixed_leg_tenor	= Period(12, Months)
        fixed_leg_convention = ModifiedFollowing
        fixed_leg_daycounter = Actual360()
        family_name = currency.name + 'index'
        ibor_index =  Libor(
            "USDLibor", Period(3,Months), settlement_days, USDCurrency(),
            UnitedStates(), Actual360(), YieldTermStructure(relinkable=False)
        )

        rate = 0.005681
        tenor = Period(1, Years)

        index = SwapIndex (
            family_name, tenor, settlement_days, currency, calendar,
            fixed_leg_tenor, fixed_leg_convention,
            fixed_leg_daycounter, ibor_index)

        helper = SwapRateHelper.from_index(rate, index)

        #self.fail(
        #    'Make this pass: create and ask for the .quote property'
        #    ' Test the from_index and from_tenor methods'
        #)

        self.assertIsNotNone(helper)
        self.assertAlmostEquals(rate, helper.quote)

        with self.assertRaises(RuntimeError):
            self.assertAlmostEquals(rate, helper.implied_quote)

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_reference
import numpy as np

from datetime import date, timedelta

from .unittest_tools import unittest
import quantlib.reference.data_structures as df
import  quantlib.reference.names as nm

class ReferenceTestCase(unittest.TestCase):

    def setUp(self):
        pass

    def test_option_quotes(self):
        x = df.option_quotes_template().reindex(index=range(10))
        x[nm.STRIKE] = range(10)
        x[nm.OPTION_TYPE] = ['C']*10
        x[nm.EXPIRY_DATE] = [date(2000,1,1)]*10
        x[nm.SPOT] = [100]*10
        self.assertTrue(True)


    def test_riskfree_dividend(self):
        x = df.riskfree_dividend_template().reindex(
            index=[date(2000,1,1)+timedelta(days=k) for k in range(10)])
        x[nm.DIVIDEND_YIELD] = np.linspace(.01, .03, 10)
        x[nm.INTEREST_RATE] = np.linspace(.02, .04, 10)
        self.assertTrue(True)

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_schedule
from .unittest_tools import unittest
from quantlib.time.date import (
    Date, Period, Jan, Dec, Weeks, Sep, Months, Nov
)
from quantlib.time.calendar import Following, Preceding
from quantlib.time.calendars.united_kingdom import UnitedKingdom
from quantlib.time.schedule import Schedule, Twentieth, Forward, Backward

class ScheduleTestCase(unittest.TestCase):

    def test_create_schedule(self):

        from_date = Date(1, Jan, 2011)
        to_date = Date(31, Dec, 2011)
        tenor = Period(3, Weeks)
        calendar = UnitedKingdom()
        convention = Following
        termination_convention = Following
        rule = Forward

        schedule = Schedule(
            from_date, to_date, tenor, calendar, convention, termination_convention, rule
        )

        self.assertIsNotNone(schedule)

        for date in schedule.dates():
            pass

        # Constructor using the defaults for the different conventions
        schedule = Schedule(from_date, to_date, tenor, calendar)

        self.assertIsNotNone(schedule)


class ScheduleMethodTestCase(unittest.TestCase):

    def setUp(self):
        self.from_date = Date(1, Jan, 2011)
        self.to_date = Date(31, Dec, 2011)
        self.tenor = Period(4, Weeks)
        self.calendar = UnitedKingdom()
        self.convention = Following
        self.termination_convention = Preceding
        self.rule = Twentieth

        self.schedule = Schedule(
            self.from_date, self.to_date, self.tenor, self.calendar,
            self.convention, self.termination_convention, self.rule
        )

    def test_size(self):

        self.assertEquals(15, self.schedule.size())

    def test_dates(self):

        expected_dates_length = self.schedule.size()
        dates = list(self.schedule.dates())

        self.assertEquals(expected_dates_length, len(dates))


    def test_at(self):

        expected_date = self.calendar.adjust(self.from_date, Following)
        self.assertTrue(expected_date == self.schedule.at(0))

        next_date = self.calendar.adjust(
            self.from_date + Period(4, Weeks), Following
        )
        expected_date = Date(20, next_date.month, next_date.year)

        self.assertTrue(expected_date == self.schedule.at(1))

    def test_previous_next_reference_date(self):
        from_date = Date(3, Sep, 2011)
        to_date = Date(15, Dec, 2011)
        tenor = Period(1, Months)
        calendar = UnitedKingdom()
        convention = Following
        termination_convention = Following
        rule = Forward

        fwd_schedule = Schedule(from_date, to_date, tenor, calendar, convention,
                termination_convention, rule)

        expected_date = Date(5, Sep, 2011)
        self.assert_(expected_date == fwd_schedule.next_date(from_date))

        rule = Backward

        bwd_schedule = Schedule(from_date, to_date, tenor, calendar, convention,
                termination_convention, rule)

        expected_date = Date(15, Nov, 2011)
        self.assert_(expected_date == bwd_schedule.previous_date(to_date))


if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_settings
from .unittest_tools import unittest
from quantlib.instruments.bonds import FixedRateBond
from quantlib.time.api import (
    Date, Days, August, Period, Jul, Annual, today, Years, TARGET,
    Unadjusted, Schedule, ModifiedFollowing, Backward, ActualActual, ISMA,
    Following
)

from quantlib.settings import Settings

class SettingsTestCase(unittest.TestCase):

    def test_using_settings(self):

        settings = Settings()

        evaluation_date = today()

        # have to set the evaluation date before the test as it is a global
        # attribute for the whole library ... meaning that previous test_cases
        # might have set this to another date
        settings.evaluation_date = evaluation_date

        self.assertTrue(
            evaluation_date == settings.evaluation_date
        )

        self.assertTrue(settings.version.startswith('1'))

    def test_settings_instance_method(self):

        Settings.instance().evaluation_date = today()

        self.assertEquals(
                today(),
                Settings.instance().evaluation_date
        )


    def test_bond_schedule_today(self):
        '''Test date calculations and role of settings when evaluation date 
        set to current date. 

        
        '''
        
        todays_date = today()

        settings = Settings()
        settings.evaluation_date =  todays_date

        calendar = TARGET()
        effective_date = Date(10, Jul, 2006)
        termination_date = calendar.advance(
            effective_date, 10, Years, convention=Unadjusted)

        settlement_days = 3
        face_amount = 100.0
        coupon_rate = 0.05
        redemption = 100.0
        
        fixed_bond_schedule = Schedule(
            effective_date,
            termination_date,
            Period(Annual),
            calendar,
            ModifiedFollowing,
            ModifiedFollowing,
            Backward
        )

        issue_date = effective_date

        bond = FixedRateBond(
            settlement_days,
		    face_amount,
		    fixed_bond_schedule,
		    [coupon_rate],
            ActualActual(ISMA), 
		    Following,
            redemption,
            issue_date
        )

        self.assertEquals(
            calendar.advance(todays_date, 3, Days), bond.settlement_date())

    def test_bond_schedule_anotherday(self):
        '''Test date calculations and role of settings when evaluation date 
        set to arbitrary date. 

        This test is known to fail with boost 1.42.
        
        '''
        
        todays_date = Date(30, August, 2011) 

        settings = Settings()
        settings.evaluation_date =  todays_date

        calendar = TARGET()
        effective_date = Date(10, Jul, 2006)
        termination_date = calendar.advance(
            effective_date, 10, Years, convention=Unadjusted)

        settlement_days = 3
        face_amount = 100.0
        coupon_rate = 0.05
        redemption = 100.0
        
        fixed_bond_schedule = Schedule(
            effective_date,
            termination_date,
            Period(Annual),
            calendar,
            ModifiedFollowing,
            ModifiedFollowing,
            Backward
        )

        issue_date = effective_date

        bond = FixedRateBond(
            settlement_days,
		    face_amount,
		    fixed_bond_schedule,
		    [coupon_rate],
            ActualActual(ISMA), 
		    Following,
            redemption,
            issue_date
        )

        self.assertEquals(
            calendar.advance(todays_date, 3, Days), bond.settlement_date())
       
    def test_bond_schedule_anotherday_bug_cython_implementation(self):

        import quantlib.test.test_cython_bug as tcb

        date1, date2  = tcb.test_bond_schedule_today_cython()
        self.assertEquals(date1, date2)
        
        date1, date2  = tcb.test_bond_schedule_anotherday_cython()
        self.assertEquals(date1, date2)
    


########NEW FILE########
__FILENAME__ = test_simulate
import numpy as np

from .unittest_tools import unittest
from quantlib.processes.heston_process import HestonProcess
from quantlib.processes.bates_process import BatesProcess
from quantlib.models.equity.heston_model import HestonModel
from quantlib.models.equity.bates_model import (BatesModel,
     BatesDetJumpModel, BatesDoubleExpModel)

from quantlib.settings import Settings
from quantlib.time.api import (
    today, NullCalendar, ActualActual
)
from quantlib.termstructures.yields.flat_forward import FlatForward
from quantlib.quotes import SimpleQuote


from quantlib.sim.simulate import (simulateHeston, simulateBates,
                                   simulateBatesDetJumpModel,
                                   simulateBatesDoubleExpModel)


from quantlib.processes.heston_process import PARTIALTRUNCATION

def flat_rate(forward, daycounter):
    return FlatForward(
        forward = SimpleQuote(forward),
        settlement_days = 0,
        calendar = NullCalendar(),
        daycounter = daycounter
    )


class SimTestCase(unittest.TestCase):
    """
    Test simulation execution
    """

    def setUp(self):

        self.settings = Settings()
        daycounter = ActualActual()
        interest_rate = .1
        dividend_yield = .04

        self.risk_free_ts = flat_rate(interest_rate, daycounter)
        self.dividend_ts = flat_rate(dividend_yield, daycounter)

        s0 = SimpleQuote(32.0)

        # Heston model

        v0 = 0.05
        kappa = 5.0
        theta = 0.05
        sigma = 1.0e-4
        rho = -0.5

        self.heston_process = HestonProcess(self.risk_free_ts,
                                            self.dividend_ts, s0, v0,
                                            kappa, theta, sigma, rho,
                                            PARTIALTRUNCATION)

        v0 = 0.05
        ival = {'v0': v0, 'kappa': 3.7, 'theta': v0,
                'sigma': 1.0, 'rho': -.6, 'lambda': .1,
                'nu': -.5, 'delta': 0.3}

        spot = SimpleQuote(1200)

        self.bates_process = BatesProcess(self.risk_free_ts, self.dividend_ts,
                 spot, ival['v0'], ival['kappa'],
                 ival['theta'], ival['sigma'], ival['rho'],
                 ival['lambda'], ival['nu'], ival['delta'])

    def test_simulate_heston_1(self):

        settings = self.settings
        settlement_date = today()
        settings.evaluation_date = settlement_date

        # simulate Heston paths
        paths = 4
        steps = 10
        horizon = 1
        seed = 12345
        tolerance = 1.e-3

        model = HestonModel(self.heston_process)

        res = simulateHeston(model, paths, steps, horizon, seed)

        time = res[0, :]
        time_expected = np.arange(0, 1.1, .1)
        simulations = res[1:, :].T

        np.testing.assert_array_almost_equal(time, time_expected, decimal=4)

    def test_simulate_heston_2(self):

        s0 = SimpleQuote(100.0)
        v0    = 0.05
        kappa = 5.0
        theta = 0.05
        sigma = 1.0e-4
        rho   = 0.0

        process = HestonProcess(self.risk_free_ts,
                                self.dividend_ts, s0, v0,
                                kappa, theta, sigma, rho)

        model = HestonModel(process)

        nbPaths = 4
        nbSteps = 100
        horizon = 1
        seed = 12345
        res = simulateHeston(model, nbPaths, nbSteps, horizon, seed)

        self.assertAlmostEqual(res[1, -1], 152.50, delta=.1)

    def test_simulate_bates(self):

        model = BatesModel(self.bates_process)

        paths = 4
        steps = 10
        horizon = 1
        seed = 12345
        tolerance = 1.e-3

        res = simulateBates(model, paths, steps, horizon, seed)

        time = res[0, :]
        time_expected = np.arange(0, 1.1, .1)
        simulations = res[1:, :].T

        np.testing.assert_array_almost_equal(time, time_expected, decimal=4)

    def test_simulate_batesDetJumpModel(self):

        model = BatesDetJumpModel(self.bates_process)

        paths = 4
        steps = 10
        horizon = 1
        seed = 12345
        tolerance = 1.e-3

        res = simulateBatesDetJumpModel(model, paths, steps, horizon, seed)

        time = res[0, :]
        time_expected = np.arange(0, 1.1, .1)
        simulations = res[1:, :].T

        np.testing.assert_array_almost_equal(time, time_expected, decimal=4)

    def test_simulate_batesDoubleExpModel(self):

        model = BatesDoubleExpModel(self.heston_process)

        paths = 4
        steps = 10
        horizon = 1
        seed = 12345
        tolerance = 1.e-3

        res = simulateBatesDoubleExpModel(model, paths, steps, horizon, seed)

        time = res[0, :]
        time_expected = np.arange(0, 1.1, .1)
        simulations = res[1:, :].T

        np.testing.assert_array_almost_equal(time, time_expected, decimal=4)


if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_swap
from .unittest_tools import unittest

from quantlib.instruments.swap import VanillaSwap, Payer
from quantlib.util.converter import pydate_to_qldate
from quantlib.pricingengines.swap import DiscountingSwapEngine
from quantlib.time.calendar import (
    Unadjusted, ModifiedFollowing
)

from quantlib.time.date import (
    Date, Days, Semiannual, January, Period,
    Annual, Years, Months)

from quantlib.time.api import Actual365Fixed, Thirty360, TARGET, Actual360
from quantlib.time.schedule import Schedule, Forward
from quantlib.settings import Settings
from quantlib.termstructures.yields.api import (
    FlatForward, YieldTermStructure)

from quantlib.currency import USDCurrency
from quantlib.indexes.libor import Libor

from quantlib.market.market import libor_market


class TestQuantLibSwap(unittest.TestCase):

    def test_swap_QL(self):
        """
        Test that a swap with fixed coupon = fair rate has an NPV=0
        Create from QL objects
        """

        swap_type = Payer
        nominal = 100.0
        fixedConvention = Unadjusted
        floatingConvention = ModifiedFollowing
        fixedFrequency = Annual
        floatingFrequency = Semiannual
        fixedDayCount = Thirty360()
        floatDayCount = Thirty360()
        calendar = TARGET()
        settlement_days = 2

        eval_date = Date(02, January, 2014)
        settings = Settings()
        settings.evaluation_date = eval_date

        settlement_date = calendar.advance(eval_date, settlement_days, Days)
        # must be a business day
        settlement_date = calendar.adjust(settlement_date)

        termStructure = YieldTermStructure(relinkable=True)
        termStructure.link_to(FlatForward(settlement_date, 0.05,
                                          Actual365Fixed()))

        index = Libor('USD Libor', Period(6, Months), settlement_days,
                      USDCurrency(), calendar, Actual360(),
                      termStructure)

        length = 5
        fixedRate = .05
        floatingSpread = 0.0

        maturity = calendar.advance(settlement_date, length, Years,
                                    convention=floatingConvention)

        fixedSchedule = Schedule(settlement_date, maturity,
                                 Period(fixedFrequency),
                                 calendar, fixedConvention, fixedConvention,
                                 Forward, False)

        floatSchedule = Schedule(settlement_date, maturity,
                                 Period(floatingFrequency),
                                 calendar, floatingConvention,
                                 floatingConvention,
                                 Forward, False)

        swap = VanillaSwap(swap_type, nominal, fixedSchedule, fixedRate,
                           fixedDayCount,
                           floatSchedule, index, floatingSpread,
                           floatDayCount, fixedConvention)

        engine = DiscountingSwapEngine(termStructure,
                                       False,
                                       settlement_date, settlement_date)
        swap.set_pricing_engine(engine)

        l = swap.leg(0)
        print l.to_str()

        l = swap.leg(1)
        print l.to_str()

        f = swap.fair_rate
        print('fair rate: %f' % f)
        p = swap.net_present_value
        print('NPV: %f' % p)

        swap = VanillaSwap(swap_type, nominal, fixedSchedule, f,
                           fixedDayCount,
                           floatSchedule, index, floatingSpread,
                           floatDayCount, fixedConvention)
        swap.set_pricing_engine(engine)

        p = swap.net_present_value
        print('NPV: %f' % p)
        self.assertAlmostEquals(p, 0)

    def test_swap_from_market(self):
        """
        Test that a swap with fixed coupon = fair rate has an NPV=0
        Create from market
        """

        eval_date = Date(02, January, 2014)
        settings = Settings()
        settings.evaluation_date = eval_date

        calendar = TARGET()
        settlement_date = calendar.advance(eval_date, 2, Days)
        # must be a business day
        settlement_date = calendar.adjust(settlement_date)

        length = 5
        fixed_rate = .05
        floating_spread = 0.0

        m = libor_market('USD(NY)')

        quotes = [('DEP', '1W', 0.0382),
                  ('DEP', '1M', 0.0372),
                  ('DEP', '3M', 0.0363),
                  ('DEP', '6M', 0.0353),
                  ('DEP', '9M', 0.0348),
                  ('DEP', '1Y', 0.0345),
                  ('SWAP', '2Y', 0.037125),
                  ('SWAP', '3Y', 0.0398),
                  ('SWAP', '5Y', 0.0443),
                  ('SWAP', '10Y', 0.05165),
                  ('SWAP', '15Y', 0.055175)]

        m.set_quotes(eval_date, quotes)

        m.bootstrap_term_structure()

        dt = Date(2, January, 2015)
        df = m.discount(dt)
        print('discount factor for %s (USD Libor): %f' % (dt, df))

        swap = m.create_fixed_float_swap(settlement_date, length, fixed_rate,
                                         floating_spread)

        fixed_l = swap.leg(0)
        print fixed_l.to_str()

        float_l = swap.leg(1)
        print float_l.to_str()

        f = swap.fair_rate
        print('fair rate: %f' % f)
        p = swap.net_present_value
        print('NPV: %f' % p)

        fixed_npv = swap.fixed_leg_npv
        float_npv = swap.floating_leg_npv

        # verify calculation by discounting both legs

        tot = 0.0
        for a, dt in fixed_l.items:
            df = m.discount(pydate_to_qldate(dt))
            tot += a * df
        print('fixed npv: %f discounted cf: %f' % (fixed_npv, tot))
        self.assertAlmostEquals(fixed_npv, -tot)

        tot = 0.0
        for a, dt in float_l.items:
            df = m.discount(pydate_to_qldate(dt))
            tot += a * df
        print('float npv: %f discounted cf: %f' % (float_npv, tot))
        self.assertAlmostEquals(float_npv, tot)


if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_termstructures
"""
 Copyright (C) 2011, Enthought Inc
 Copyright (C) 2011, Patrick Henaff

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
"""

from .unittest_tools import unittest
from quantlib.termstructures.yields.api import (
    FlatForward, YieldTermStructure
)
from quantlib.quotes import SimpleQuote

from quantlib.settings import Settings
from quantlib.time.calendar import TARGET
from quantlib.time.calendars.null_calendar import NullCalendar
from quantlib.time.daycounter import Actual360, Actual365Fixed
from quantlib.time.date import today, Days


class SimpleQuoteTestCase(unittest.TestCase):

    def test_using_simple_quote(self):

        quote = SimpleQuote(10)

        self.assertEquals(10, quote.value)

        quote.value = 15

        self.assertEquals(15, quote.value)
        self.assertTrue(quote.is_valid)

    def test_empty_constructor(self):

        quote = SimpleQuote()

        self.assertTrue(quote.is_valid)
        self.assertEquals(0.0, quote.value)


class YieldTermStructureTestCase(unittest.TestCase):

    def test_relinkable_structures(self):

        discounting_term_structure = YieldTermStructure(relinkable=True)

        settlement_days = 3
        flat_term_structure = FlatForward(settlement_days=settlement_days,
            forward=0.044, calendar=NullCalendar(), daycounter=Actual360())

        discounting_term_structure.link_to(flat_term_structure)

        evaluation_date = Settings().evaluation_date +100
        self.assertEquals(
            flat_term_structure.discount(evaluation_date),
            discounting_term_structure.discount(evaluation_date)
        )


        another_flat_term_structure = FlatForward(settlement_days=10,
            forward=0.067, calendar=NullCalendar(), daycounter=Actual365Fixed())

        discounting_term_structure.link_to(another_flat_term_structure)

        self.assertEquals(
            another_flat_term_structure.discount(evaluation_date),
            discounting_term_structure.discount(evaluation_date)
        )

        self.assertNotEquals(
            flat_term_structure.discount(evaluation_date),
            discounting_term_structure.discount(evaluation_date)
        )

class FlatForwardTestCase(unittest.TestCase):

    def setUp(self):

        self.calendar = TARGET()
        self.settlement_days = 2
        self.adjusted_today = self.calendar.adjust(today())
        Settings().evaluation_date = self.adjusted_today
        self.settlement_date = self.calendar.advance(
            today(), self.settlement_days, Days
        )

    def test_reference_evaluation_data_changed(self):
        """Testing term structure against evaluation date change... """

        quote = SimpleQuote()
        term_structure = FlatForward(settlement_days=self.settlement_days,
            forward=quote, calendar=NullCalendar(), daycounter=Actual360())

        quote.value = 0.03

        expected = []
        for days in [10, 30, 60, 120, 360, 720]:
            expected.append(
                term_structure.discount(self.adjusted_today + days)
            )

        Settings().evaluation_date = self.adjusted_today + 30

        calculated = []
        for days in [10, 30, 60, 120, 360, 720]:
            calculated.append(
                term_structure.discount(self.adjusted_today+ 30 + days)
            )

        for i, val in enumerate(expected):
            self.assertAlmostEquals(val, calculated[i])


########NEW FILE########
__FILENAME__ = test_util
import datetime

from .unittest_tools import unittest
from quantlib.time.date import Date, Nov, today

from quantlib.util.converter import pydate_to_qldate


class TestUtil(unittest.TestCase):

    def test_converter_1(self):
        ql_today_1 = today()
        py_today = datetime.date.today()
        ql_today_2 = pydate_to_qldate(py_today)

        self.assertEquals(ql_today_1.day, ql_today_2.day)
        self.assertEquals(ql_today_1.month, ql_today_2.month)
        self.assertEquals(ql_today_1.year, ql_today_2.year)

    def test_converter_2(self):

        ql_1 = Date(20, Nov, 2005)
        ql_2 = pydate_to_qldate('20-Nov-2005')

        self.assertEquals(ql_1.day, ql_2.day)
        self.assertEquals(ql_1.month, ql_2.month)
        self.assertEquals(ql_1.year, ql_2.year)

    def test_converter_2(self):

        ql_1 = Date(20, Nov, 2005)
        ql_2 = pydate_to_qldate('20-Nov-2005')

        self.assertEquals(ql_1.day, ql_2.day)
        self.assertEquals(ql_1.month, ql_2.month)
        self.assertEquals(ql_1.year, ql_2.year)

if __name__ == '__main__':
    unittest.main()


########NEW FILE########
__FILENAME__ = test_vanilla_option
from .unittest_tools import unittest
from quantlib.instruments.option import (
    EuropeanExercise, AmericanExercise, DividendVanillaOption
    )
from quantlib.instruments.payoffs import PlainVanillaPayoff, Put
from quantlib.instruments.option import VanillaOption
from quantlib.pricingengines.vanilla.vanilla import (
    AnalyticEuropeanEngine, BaroneAdesiWhaleyApproximationEngine,
    FDDividendAmericanEngine
    )
from quantlib.processes.black_scholes_process import BlackScholesMertonProcess
from quantlib.settings import Settings
from quantlib.time.api import Date, TARGET, May, Actual365Fixed
from quantlib.termstructures.yields.flat_forward import FlatForward
from quantlib.quotes import SimpleQuote

from quantlib.termstructures.volatility.equityfx.black_vol_term_structure import BlackConstantVol


class VanillaOptionTestCase(unittest.TestCase):
    """Base test for all the cases related to VanillaOption.

    This test case is based on the QuantLib example EquityOption.cpp
    """

    def setUp(self):

        self.settings = Settings()

        self.calendar = TARGET()

        self.todays_date = Date(15, May, 1998)
        self.settlement_date = Date(17, May, 1998)

        self.settings.evaluation_date = self.todays_date

        # options parameters
        self.option_type = Put
        self.underlying = 36
        self.strike = 40
        self.dividend_yield = 0.00
        self.risk_free_rate = 0.06
        self.volatility = 0.20
        self.maturity = Date(17, May, 1999)
        self.daycounter = Actual365Fixed()

        self.underlyingH = SimpleQuote(self.underlying)

        # bootstrap the yield/dividend/vol curves
        self.flat_term_structure = FlatForward(
            reference_date = self.settlement_date,
            forward        = self.risk_free_rate,
            daycounter     = self.daycounter
        )
        self.flat_dividend_ts = FlatForward(
            reference_date = self.settlement_date,
            forward        = self.dividend_yield,
            daycounter     = self.daycounter
        )

        self.flat_vol_ts = BlackConstantVol(
            self.settlement_date,
            self.calendar,
            self.volatility,
            self.daycounter
        )

        self.black_scholes_merton_process = BlackScholesMertonProcess(
            self.underlyingH,
            self.flat_dividend_ts,
            self.flat_term_structure,
            self.flat_vol_ts
        )

        self.payoff = PlainVanillaPayoff(self.option_type, self.strike)

        #Additional parameters for testing DividendVanillaOption
        self.dividend_dates = []
        self.dividends = []
        self.american_time_steps = 600
        self.american_grid_points = 600

        #Parameters for implied volatility:
        self.accuracy = 0.001
        self.max_evaluations = 1000
        self.min_vol = 0.001
        self.max_vol = 4
        self.target_price = 4.485992

    def test_str(self):
        quote_str = str(self.underlyingH)
        self.assertEquals('Simple Quote: 36.000000', quote_str)

        payoff_str = str(self.payoff)
        self.assertEquals('Payoff: Vanilla Put @ 40.000000', payoff_str)

        exercise = EuropeanExercise(self.maturity)
        exercise_str = str(exercise)
        self.assertEquals('Exercise type: European', exercise_str)


        option = VanillaOption(self.payoff, exercise)
        self.assertEquals('Exercise type: European', str(option.exercise))
        vanilla_str = str(option)
        self.assertEquals('VanillaOption Exercise type: European Payoff: Vanilla', vanilla_str)

    def test_european_vanilla_option_usage(self):


        european_exercise = EuropeanExercise(self.maturity)
        european_option = VanillaOption(self.payoff, european_exercise)

        analytic_european_engine = AnalyticEuropeanEngine(
            self.black_scholes_merton_process
        )

        european_option.set_pricing_engine(analytic_european_engine)

        self.assertAlmostEquals(3.844308, european_option.net_present_value, 6)

    def test_american_vanilla_option(self):

        american_exercise = AmericanExercise(self.maturity)
        american_option = VanillaOption(self.payoff, american_exercise)

        engine = BaroneAdesiWhaleyApproximationEngine(
            self.black_scholes_merton_process
        )

        american_option.set_pricing_engine(engine)

        self.assertAlmostEquals(4.459628, american_option.net_present_value, 6)

    def test_american_vanilla_option_with_earliest_date(self):

        american_exercise = AmericanExercise(
            latest_exercise_date   = self.maturity,
            earliest_exercise_date = self.settlement_date
        )
        american_option = VanillaOption(self.payoff, american_exercise)

        engine = BaroneAdesiWhaleyApproximationEngine(
            self.black_scholes_merton_process
        )

        american_option.set_pricing_engine(engine)

        self.assertAlmostEquals(4.459628, american_option.net_present_value, 6)


    def test_american_vanilla_option_with_earliest_date_wrong_order(self):

        with self.assertRaises(RuntimeError):
            AmericanExercise(
                self.settlement_date,
                self.maturity
            )

    def test_dividend_american_option(self):

        american_exercise = AmericanExercise(self.maturity)
        american_option = DividendVanillaOption(
            self.payoff, american_exercise, self.dividend_dates, self.dividends
        )

        engine = FDDividendAmericanEngine(
            'CrankNicolson', self.black_scholes_merton_process,
            self.american_time_steps, self.american_grid_points
        )

        american_option.set_pricing_engine(engine)

        #Note slightly different value using CrankNicolson
        self.assertAlmostEquals(4.485992, american_option.net_present_value, 6)

    def test_dividend_american_option_implied_volatility(self):

        american_exercise = AmericanExercise(self.maturity)
        american_option = DividendVanillaOption(
            self.payoff, american_exercise, self.dividend_dates, self.dividends
        )

        engine = FDDividendAmericanEngine(
            'CrankNicolson', self.black_scholes_merton_process,
            self.american_time_steps, self.american_grid_points
        )

        american_option.set_pricing_engine(engine)

        implied_volatility = american_option.implied_volatility(
            self.target_price,
            self.black_scholes_merton_process,
            self.accuracy,
            self.max_evaluations,
            self.min_vol,
            self.max_vol
        )

        self.assertAlmostEquals(0.200, implied_volatility, 3)

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = unittest_tools
# Compatibility layer for Python 2.6: try loading unittest2
import sys
if sys.version_info[:2] == (2, 6):
    try:
        import unittest2 as unittest
    except ImportError:
        raise Exception('The test suite requires unittest2 on Python 2.6')
else:
    import unittest



########NEW FILE########
__FILENAME__ = api
"""
 Copyright (C) 2011, Enthought Inc
 Copyright (C) 2011, Patrick Henaff

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
"""

from .calendar import (
    Calendar, TARGET, ModifiedFollowing, Following, ModifiedPreceding,
    Preceding, Unadjusted, holiday_list
    )
from .calendars.jointcalendar import JointCalendar
from .calendars.null_calendar import NullCalendar
from .calendars.united_kingdom import UnitedKingdom
from .calendars.united_states import UnitedStates

from .daycounter import Actual360, Actual365Fixed, DayCounter
from .daycounters.thirty360 import Thirty360
from .daycounters.actual_actual import (ActualActual, ISMA, ISDA, Bond,
    Historical, Actual365, AFB, Euro)


from .date import (
    Date, Months, Period, today, Years, Days, Annual, Semiannual, Weeks,
    Quarterly,
    January, February, March, April, May, June, July, August,
    September, November, December,
    Jan, Feb, Mar, Apr, Jun, Jul, Aug, Sep, Oct, Nov, Dec,
    Daily, Monthly, Annual, NoFrequency, Once
)

from .schedule import Schedule, Backward, Forward, TwentiethIMM


########NEW FILE########
__FILENAME__ = converter
"""
 Copyright (C) 2011, Enthought Inc
 Copyright (C) 2011, Patrick Henaff

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
"""

import string
import re
import datetime

from quantlib.time.api import Date, Actual365Fixed
import quantlib.time.date as dt
from quantlib.termstructures.yields.zero_curve import ZeroCurve

_dayOfWeekName = ['Monday', 'Tuesday', 'Wednesday', 'Thursday',
                  'Friday', 'Saturday', 'Sunday']
_monthName = ['January', 'February', 'March', 'April', 'May',
              'June', 'July', 'August', 'September', 'October',
              'November', 'December']
_shortMonthName = ['jan', 'feb', 'mar', 'apr', 'may', 'jun',
                   'jul', 'aug', 'sep', 'oct', 'nov', 'dec']


date_re_list = [ \
    # Styles: (1)
    (re.compile("([0-9]+)-([A-Za-z]+)-([0-9]{2,4})"),
     (3, 2, 1)),
    # Styles: (2)
    (re.compile("([0-9]{4,4})([0-9]{2,2})([0-9]{2,2})"),
     (1, 2, 3)),
    # Styles: (3)
    (re.compile("([0-9]+)/([0-9]+)/([0-9]{2,4})"),
     (2, 1, 3)),
    # Styles: (4)
    (re.compile("([0-9](1,2))([A-Za-z](3,3))([0-9](2,4))"),
     (3, 2, 1)),
    # Styles: (5)
    (re.compile("([0-9]{2,4})-([0-9]+)-([0-9]+)"),
     (1, 2, 3))]

DAYS = 1
MONTHS = 2
YEARS = 3


def _partition_date(date):
    """
    Partition a date string into three sub-strings
    year, month, day

    The following styles are understood:
    (1) 22-AUG-1993 or
        22-Aug-03 (2000+yy if yy<50)
    (2) 20010131
    (3) mm/dd/yy or
        mm/dd/yyyy
    (4) 10Aug2004 or
        10Aug04
    (5) yyyy-mm-dd
    """

    date = string.lstrip(string.rstrip(date))
    for reg, idx in date_re_list:
        mo = reg.match(date)
        if mo != None:
            return (mo.group(idx[0]), mo.group(idx[1]),
                    mo.group(idx[2]))

    raise Exception("couldn't partition date: %s" % date)


def _parsedate(date):
    """
    Parse a date string and return the tuple
    (year, month, day)
    """
    (yy, mo, dd) = _partition_date(date)
    if len(yy) == 2:
        yy = string.atoi(yy)
        yy += 2000 if yy < 50 else 1900
    else:
        yy = string.atoi(yy)

    try:
        mm = string.atoi(mo)
    except:
        mo = string.lower(mo)
        if not mo in _shortMonthName:
            raise Exception("Bad month name: " + mo)
        else:
            mm = _shortMonthName.index(mo) + 1

    dd = string.atoi(dd)
    return (yy, mm, dd)


def pydate(date):
    """
    Accomodate date inputs as string or python date
    """

    if isinstance(date, datetime.datetime):
        return date
    else:
        yy, mm, dd = _parsedate(date)
        return datetime.datetime(yy, mm, dd)


def pydate_to_qldate(date):
    """
    Converts a datetime object or a date string
    into a QL Date.
    """

    if isinstance(date, Date):
        return date
    if isinstance(date, basestring):
        yy, mm, dd = _parsedate(date)
        return Date(dd, mm, yy)
    else:
        return dt.qldate_from_pydate(date)


def qldate_to_pydate(date):
    """
    Converts a QL Date to a datetime
    """

    return datetime.datetime(date.year, date.month, date.day)


def df_to_zero_curve(rates, settlement_date, daycounter=Actual365Fixed()):
    """ Converts a pandas data frame into a QL zero curve. """

    dates = [pydate_to_qldate(dt) for dt in rates.index]
    dates.insert(0, pydate_to_qldate(settlement_date))

    # arbitrarily extend the curve a few years to provide flat
    # extrapolation
    dates.append(dates[-1] + 365 * 2)

    values = rates.values.tolist()
    values.insert(0, values[0])
    values.append(values[-1])

    return ZeroCurve(dates, values, daycounter)

########NEW FILE########
__FILENAME__ = enums
"""
 @author: Bart Mosley
 @copyright: BG Research LLC, 2011

 Copyright (C) 2011, Enthought Inc
 Copyright (C) 2011, Patrick Henaff

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
"""

# Enumerations used in QuantLib code
# Organized by function

from quantlib.time.date import qldate_from_pydate, pydate_from_qldate
from quantlib.util.converter import pydate


class TimeUnits(object):
    from quantlib.time.date import Days, Weeks, Months, Years


class Compounding(object):
    Simple = 0     # 1+rt
    Compounded = 1  # (1+r)^t
    Continuous = 2  # e^{rt}
    SimpleThenCompounded = 3  # Simple up to the first period then Compounded


class BusinessDayConventions(object):
    from quantlib.time.calendar import (
        ModifiedFollowing, Following, ModifiedPreceding,
        Preceding, Unadjusted,
    )


class Frequencies(object):
    from quantlib.time.date import (
        Annual, Semiannual, Quarterly, Monthly, Weekly, Daily
    )


class Months(object):
    from quantlib.time.date import (
        January, February, March, April, May, June,
        July, August, September, November, December,
        Jan, Feb, Mar, Apr, Jun, Jul, Aug, Sep, Oct, Nov, Dec
    )


class DateGeneration(object):
    from quantlib.time.schedule import Backward, Forward


class DayCounters(dict):
    from quantlib.time.daycounters.thirty360 import Thirty360
    from quantlib.time.daycounter import (
        Actual360, Actual365Fixed
    )
    from quantlib.time.daycounters.actual_actual import (
        ActualActual, ISMA, ISDA, Bond
    )

    _lookup = dict([(dc.name(), dc) for dc in
                    [Thirty360(), Actual360(), Actual365Fixed(),
                     ActualActual(), ActualActual(ISMA), ActualActual(ISDA),
                     ActualActual(Bond)
                     ]]
                   )

    def __init__(self, *args):
        dict.__init__(self, self._lookup)
        self.update(*args)

    @classmethod
    def year_fraction(cls, date1, date2, daycounter=None):
        '''
        Calculate the fraction of a year between two date1 and date2,
        based on the daycount specified.
        dates may be ccyymmdd or python datetime.dates
        '''
        pydate1, pydate2 = map(pydate, (date1, date2))

        if not daycounter:
            daycounter = cls.ActualActual()

        qldate1 = qldate_from_pydate(pydate1)
        qldate2 = qldate_from_pydate(pydate2)

        return daycounter.year_fraction(qldate1, qldate2)

    @classmethod
    def daycount(cls, date1, date2, daycounter=None):
        pydate1, pydate2 = map(pydate, (date1, date2))

        if not daycounter:
            daycounter = cls.ActualActual()

        qldate1 = qldate_from_pydate(pydate1)
        qldate2 = qldate_from_pydate(pydate2)

        return daycounter.day_count(qldate1, qldate2)


class Calendars(dict):

    '''
    Wrapper for quantlib Calendar objects and methods.
    Accepts python.datetime objects and strings
    instead of pyql.quantlib dates.
    
    :adjust:            Adjust date to business day
    :advance:           Advance date by specified period
    :is_business_day:   Checks date
    
    can be used as a dict using name property of pyql.quantlib.calendar objects
    for example:
        
        Calendars()['TARGET'] returns TARGET calendar
        
    '''

    from quantlib.time.calendar import TARGET
    from quantlib.time.calendars.null_calendar import NullCalendar
    from quantlib.time.calendars.germany import (
        Germany, EUREX, FrankfurtStockExchange, SETTLEMENT as GER_SETTLEMENT,
        EUWAX, XETRA
    )
    from quantlib.time.calendars.united_kingdom import (
        EXCHANGE, METALS, SETTLEMENT as UK_SETTLEMENT,
        UnitedKingdom
    )
    from quantlib.time.calendars.united_states import (
        UnitedStates, GOVERNMENTBOND, NYSE, NERC, SETTLEMENT as US_SETTLEMENT
    )

    _lookup = dict([(cal.name(), cal) for cal in
                    [TARGET(), NullCalendar(),
                     Germany(), Germany(EUREX), Germany(
                         FrankfurtStockExchange),
                        Germany(GER_SETTLEMENT), Germany(
                            EUWAX), Germany(XETRA),
                        UnitedKingdom(),
                        UnitedKingdom(EXCHANGE), UnitedKingdom(METALS),
                        UnitedKingdom(UK_SETTLEMENT),
                        UnitedStates(),
                        UnitedStates(GOVERNMENTBOND), UnitedStates(
                            NYSE), UnitedStates(NERC),
                        UnitedStates(US_SETTLEMENT)]
                    ]
                   )

    def __init__(self, *args):

        dict.__init__(self, self._lookup)
        self.update(*args)

    @classmethod
    def adjust(cls, date, calendar=None, convention=None):

        if not calendar:
            calendar = cls.TARGET()

        elif not hasattr(calendar, "adjust"):
            return None

        if not convention:
            convention = BusinessDayConventions.Following

        qldate = qldate_from_pydate(pydate(date))
        try:
            return pydate_from_qldate(calendar.adjust(qldate, convention))
        except:
            try:
                return pydate_from_qldate(calendar().adjust(qldate,
                                                            convention))
            except:
                return None

    @classmethod
    def advance(cls, date, n, timeunit=None, calendar=None, convention=None):
        """
        Advance pydate according the specified calendar and convention
        
        :pydate:   e.g. 19600809, date(1964, 9, 29), '5-23-1993'
        :n:        integer
        :timeunit: e.g., enums.TimeUnits.Days

        usage
        -----
        
        Note 9/6/1980 is a weekend
    
        >>> Calendars.advance(19800906, 1)
        datetime.date(1980, 9, 8)
        
        """
        if not calendar:
            calendar = cls.TARGET()

        elif not hasattr(calendar, "advance"):
            return None

        if not convention:
            convention = BusinessDayConventions.Following

        if not timeunit:
            timeunit = TimeUnits.Days

        qldate = qldate_from_pydate(pydate(date))
        try:
            return pydate_from_qldate(calendar.advance(qldate, n, timeunit))

        except:
            try:
                return pydate_from_qldate(
                    calendar().advance(qldate, n, timeunit)
                )

            except:
                print("failure {}".format(qldate))
                return None

    @classmethod
    def is_business_day(cls, date, calendar=None):
        if not calendar:
            calendar = cls.TARGET()

        elif not hasattr(calendar, "advance"):
            return None

        qldate = qldate_from_pydate(pydate(date))
        try:
            return calendar.is_business_day(qldate)

        except:
            try:
                return calendar().is_business_day(qldate)

            except:
                return None

########NEW FILE########
__FILENAME__ = prettyprint
from types import TupleType, ListType
import re, string
import numpy 
from math import floor, log10
import operator

def abswithnone(x):
    if x is None:
        return 0
    elif numpy.isnan(x):
        return 0
    else:
        return abs(x)

def lenwithnone(x):
    try:
        return len(x)
    except TypeError, err:
        return 0

def prettyprint(cLab, cTyp, cTmp):
    """
    PRETTYPRINT
    formatted display of table

    prettyprint(labels, types, data)
    labels: array of labels, or char array
    types: 
    - i: integer
    - v: 2 dec (e.g. dollar value)
    - p: 4 dec (dollar price)
    - d: date (normalDate or scalar() value)
    - s: string
    data: array of column vectors
    """

    if type(cLab) in (TupleType, ListType):
        cLabels = cLab
    else:
        p = re.compile(r'\W+')
        cLabels = p.split(cLab)

    nbColumns = len(cLabels)

    if len(cTyp) != nbColumns:
        raise Exception, 'dimension mismatch: %d labels, %d types.' % (nbColumns, len(cTyp))

    if type(cTyp) is (TupleType, ListType):
        cTypes = cTyp
    else:
        cTypes = []
        for c in cTyp:
            cTypes.append(c)

    # verify types
    legalTypes = 'ivpdcs'
    for t in cTypes:
        if t not in legalTypes:
            raise Exception, 'Data type %s not found. legal types are: %s' % (t,  legalTypes)

    cValues = cTmp

    if len(cValues) != nbColumns:
        raise Exception, 'dimension mismatch: %d labels, %d data columns.' % (nbColumns, len(cValues))

    nbRows = max(map(lambda x:len(x), cValues))

    dash = '-'
    space = ' '
    s1 = ''
    s2 = ''
    rows = []
    rows.append(s1)
    rows.append(s2)
    for i in range(nbRows):
        rows.append('')

    for (label, fcode, values) in map(None, cLabels, cTypes, cValues):
        # determine the width of this field
        # as the max of:
        # - width of data
        # - width of label

        w2 = len(label)
        if fcode == 'i':
            # integers
            w1 = floor(max(1,log10(1.0+max(map(abswithnone, values)))))+2
            sFormat = ' %%%dd ' % max(w1, w2)
        elif fcode == 'v':
            # doubles representing a quantity with 2 decimal places (ex: value)
            deci = 2;
            try:
                w1 = floor(max(1,log10(1.0+max(map(abswithnone, values))))) + 3 + deci
            except OverflowError,e:
                raise Exception("values="+values.__str__()+"\n"+e.__str__())
            sFormat = ' %%%d.%df ' % (max(w1, w2), deci)
        elif fcode == 'p':
            # doubles representing a quantity with 4 decinal places (ex: price)
            deci = 4
            try:
##                print map(abswithnone, values)
                w1 = floor(max(1,log10(1.0+max(map(abswithnone, values))))) + 3 + deci
            except ValueError, e:
                ## TODO: this is here because of a bug when values is all numpy.nan
                w1 = 10
            except OverflowError,e:
                raise Exception("values="+values.__str__()+"\n"+e.__str__())
            sFormat = ' %%%d.%df ' % (max(w1, w2), deci)
        elif fcode == 'd':
            # a date
            w1 = 9
            sFormat = ' %%%ds ' % max(w1, w2)
        elif fcode == 'c':
            # a date
            w1 = 6
            sFormat = ' %%%ds ' % max(w1, w2)
            
        elif fcode == 's':
            # a string
            w1 = max(map(lenwithnone, values))
            sFormat = ' %%%ds ' % max(w1, w2)

        width = max(w1, w2)
        fmt = ' %%%ds ' % width
        s1 += fmt % label
        s2 += fmt % (dash*int(width))
        
        # dates in scalar form must be translated back into normal dates
        if fcode == 'd' and type(values[0]) == int:
            for i in range(min(len(values), nbRows)):
                rows[i+2] += sFormat % normalDateFromScalar(values[i])
        else:
            for i in range(min(len(values), nbRows)):
                if values[i] is not None:
                    rows[i+2] += sFormat % values[i]
                else:
                    rows[i+2] += space*int(width+2)
        if nbRows>len(values):
            for i in range(len(values), nbRows):
                rows[i+2] += space*int(width+2)

    rows[0] = s1
    rows[1] = s2
    
    str = ''
    for r in rows:
        str += r + '\n'

    return str

def prettyprinttranspose(cLab, cTyp, cTmp):
    """
    PRETTYPRINTTRANSPOSE
    formatted display of table transposed

    prettyprinttranspose(labels, types, data)
    labels: array of labels, or char array
    types: 
    - i: integer
    - v: 2 dec (e.g. dollar value)
    - p: 4 dec (dollar price)
    - d: date (normalDate or scalar() value)
    - s: string
    data: array of column vectors
    """

    if type(cLab) in (TupleType, ListType):
        cLabels = cLab
    else:
        p = re.compile(r'\W+')
        cLabels = p.split(cLab)

    nbColumns = len(cLabels)

    if len(cTyp) != nbColumns:
        raise Exception, 'dimension mismatch: %d labels, %d types.' % (nbColumns, len(cTyp))

    if type(cTyp) is (TupleType, ListType):
        cTypes = cTyp
    else:
        cTypes = []
        for c in cTyp:
            cTypes.append(c)

    # verify types
    legalTypes = 'ivpdcs'
    for t in cTypes:
        if t not in legalTypes:
            raise Exception, 'Data type %s not found. legal types are: %s' % (t,  legalTypes)

    cValues = cTmp

    if len(cValues) != nbColumns:
        raise Exception, 'dimension mismatch: %d labels, %d data columns.' % (nbColumns, len(cValues))

    # Convert format to string and add labels
    sValues = [[c[1]+' |']+[' '+prettyprintformatter(r,c[2]) for r in c[0]] for c in zip(cValues,cLabels,cTypes)]
    cMax = max([len(c) for c in sValues])
    
    # fill unused end of columns
    sValues = [c+[' ']*(cMax-len(c)) for c in sValues]
    
    # get lengths of all strings
    sLen = [[len(r) for r in c] for c in sValues]
    
    # get max lengths of rows 
    sMaxRowLen=reduce(lambda x,y: [max(z) for z in zip(x,y)],sLen)
    
    # add spaces to fill to max length of rows
    sValues = [[' '*(r[1]-len(r[0]))+r[0] for r in zip(c,sMaxRowLen)] for c in sValues]
    return reduce(operator.add,[ reduce(operator.add,c)+"\n" for c in sValues])


def prettyprintformatter(value,fcode):
    if value is None:
        return "none"
    elif fcode == 'i':
        return "%d" % value
    elif fcode == 'v':
        return "%.2f" % value
    elif fcode == 'p':        
        return "%.2f" % value
    elif fcode == 'd':
        return str(ND(value))
    elif fcode == 'c':
        return str(ND(value))        
    elif fcode == 's':
        return value.__str__() #make sure you return a string..in case someone is sending int as string accidentially.
    else:
        raise Exception, 'Data type %s not found'%fcode


########NEW FILE########
__FILENAME__ = rates
"""
 Copyright (C) 2013, Enthought Inc
 Copyright (C) 2013, Patrick Henaff

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
"""

# Utility functions for handling interest rates
# ---------------------------------------------

import string
import re
import numpy as np

import quantlib
from quantlib.settings import Settings
from quantlib.termstructures.yields.rate_helpers import \
     DepositRateHelper, SwapRateHelper
from quantlib.time.api import (TARGET, Period, Months, Years, Days,
                               ModifiedFollowing, Unadjusted, Actual360,
                               Thirty360, Annual, ActualActual, ISDA,
                               JointCalendar, UnitedStates, UnitedKingdom,
                               NullCalendar)

from quantlib.currency import USDCurrency
from quantlib.quotes import SimpleQuote
from quantlib.util.converter import pydate_to_qldate, qldate_to_pydate
from quantlib.indexes.libor import Libor
from quantlib.termstructures.yields.piecewise_yield_curve import \
    term_structure_factory

from quantlib.termstructures.yields.api import FlatForward, YieldTermStructure


_label_re_list = [ \
    # Swap
    re.compile("(SWAP)([0-9]{1,2})(Y)"),
    # Libor
    re.compile("(LIBOR)([1-9]{1,2})(M)")]


def _parse_rate_label(label):
    """
    Parse labels of the form
    Swap5Y
    Libor6M
    """

    label = string.lstrip(string.rstrip(label.upper()))
    for reg in _label_re_list:
        mo = reg.match(label)
        if mo != None:
            return (mo.group(1), int(mo.group(2)),
                    mo.group(3))

    raise Exception("couldn't parse label: %s" % label)


def make_rate_helper(label, rate, dt_obs, currency='USD'):
    """
    Wrapper for deposit and swaps rate helpers makers
    For Swaps: assume USD swap fixed rates vs. 6M Libor
    TODO: make this more general
    """

    if(currency.upper() != 'USD'):
        raise Exception("Only supported currency is USD.")

    rate_type, tenor, period = _parse_rate_label(label)

    if(~isinstance(dt_obs, quantlib.time.date.Date)):
        dt_obs = pydate_to_qldate(dt_obs)
    settings = Settings()
    calendar = JointCalendar(UnitedStates(), UnitedKingdom())
    # must be a business day
    eval_date = calendar.adjust(dt_obs)
    settings.evaluation_date = eval_date
    settlement_days = 2
    settlement_date = calendar.advance(eval_date, settlement_days, Days)
    # must be a business day
    settlement_date = calendar.adjust(settlement_date)
    end_of_month = True

    if((rate_type == 'SWAP') & (period == 'Y')):
        liborIndex = Libor('USD Libor', Period(6, Months),
                       settlement_days,
                       USDCurrency(), calendar,
                       Actual360(), YieldTermStructure(relinkable=False))
        spread = SimpleQuote(0)
        fwdStart = Period(0, Days)
        helper = SwapRateHelper.from_tenor(rate,
                 Period(tenor, Years),
                 calendar, Annual,
                 Unadjusted, Thirty360(),
                 liborIndex, spread, fwdStart)
    elif((rate_type == 'LIBOR') & (period == 'M')):
        helper = DepositRateHelper(rate, Period(tenor, Months),
                 settlement_days,
                 calendar, ModifiedFollowing,
                 end_of_month,
                 Actual360())
    else:
        raise Exception("Rate type %s not supported" % label)

    return (helper)


def make_term_structure(rates, dt_obs):
    """
    rates is a dictionary-like structure with labels as keys
    and rates (decimal) as values.
    TODO: Make it more generic
    """

    settlement_date = pydate_to_qldate(dt_obs)
    rate_helpers = []
    for label in rates.keys():
        r = rates[label]
        h = make_rate_helper(label, r, settlement_date)
        rate_helpers.append(h)

    ts_day_counter = ActualActual(ISDA)
    tolerance = 1.0e-15
    ts = term_structure_factory('discount', 'loglinear',
         settlement_date, rate_helpers,
         ts_day_counter, tolerance)

    return ts


def zero_rate(term_structure, days, dt_settlement, calendar=TARGET()):
    """
    Compute zero-coupon rate, continuous ACT/365 from settlement date to given
    maturity expressed in calendar days
    Return
    - array of maturity dates
    - array of zero-coupon rates
    """

    dtMat = [calendar.advance(pydate_to_qldate(dt_settlement), d, Days)
             for d in days]
    df = np.array([term_structure.discount(dt) for dt in dtMat])
    dtMat = [qldate_to_pydate(dt) for dt in dtMat]
    dtToday = qldate_to_pydate(dt_settlement)
    dt = np.array([(d - dtToday).days / 365.0 for d in dtMat])
    zc = -np.log(df) / dt

    return (dtMat, zc)


def flat_rate(forward, daycounter):
    """
    Create a flat yield curve, with rate defined according
    to the specified day-count convention.
    Used mostly for unit tests and simple illustrations.
    """

    return FlatForward(
        forward=SimpleQuote(forward),
        settlement_days=0,
        calendar=NullCalendar(),
        daycounter=daycounter
    )

########NEW FILE########
__FILENAME__ = version
import re

from quantlib.settings import Settings


def _to_int(s):
    if s is None:
        return None
    else:
        return int(s)


def parse_ql_version_string(version):
    """
    Parse a QuantLib version string.

    Parameters
    ----------
    version : string
        A QuantLib version string of the form major.minor.patch-release,
        where the fields "patch" and "release" are optional.

    Returns
    -------
    A tuple (major, minor, patch, release), where patch and release are
    None if they were not present in the version string.

    """
    m = re.match("^(\d+)\.(\d+)(?:\.(\d+))?(?:-(\w+))?$", version)
    if m is None:
        raise ValueError("Invalid QuantLib version string: {}".format(version))
    major, minor, patch = [_to_int(field) for field in m.groups()[:3]]
    release = m.groups()[3]
    return major, minor, patch, release


QUANTLIB_VERSION = parse_ql_version_string(Settings().version)

########NEW FILE########
